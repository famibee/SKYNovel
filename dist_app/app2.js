import { parse as Jl, resolve as Ql, format as tu } from "url";
var Yo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Fn(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var nr = { exports: {} };
/*!
 * Platform.js v1.3.6
 * Copyright 2014-2020 Benjamin Tan
 * Copyright 2011-2013 John-David Dalton
 * Available under MIT license
 */
var eu = nr.exports, qo;
function iu() {
  return qo || (qo = 1, function(r, t) {
    (function() {
      var e = {
        function: !0,
        object: !0
      }, i = e[typeof window] && window || this, n = t, s = r && !r.nodeType && r, o = n && s && typeof Yo == "object" && Yo;
      o && (o.global === o || o.window === o || o.self === o) && (i = o);
      var a = Math.pow(2, 53) - 1, h = /\bOpera/, l = Object.prototype, u = l.hasOwnProperty, c = l.toString;
      function f(w) {
        return w = String(w), w.charAt(0).toUpperCase() + w.slice(1);
      }
      function d(w, O, R) {
        var U = {
          "10.0": "10",
          "6.4": "10 Technical Preview",
          "6.3": "8.1",
          "6.2": "8",
          "6.1": "Server 2008 R2 / 7",
          "6.0": "Server 2008 / Vista",
          "5.2": "Server 2003 / XP 64-bit",
          "5.1": "XP",
          "5.01": "2000 SP1",
          "5.0": "2000",
          "4.0": "NT",
          "4.90": "ME"
        };
        return O && R && /^Win/i.test(w) && !/^Windows Phone /i.test(w) && (U = U[/[\d.]+$/.exec(w)]) && (w = "Windows " + U), w = String(w), O && R && (w = w.replace(RegExp(O, "i"), R)), w = v(
          w.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]
        ), w;
      }
      function p(w, O) {
        var R = -1, U = w ? w.length : 0;
        if (typeof U == "number" && U > -1 && U <= a)
          for (; ++R < U; )
            O(w[R], R, w);
        else
          _(w, O);
      }
      function v(w) {
        return w = x(w), /^(?:webOS|i(?:OS|P))/.test(w) ? w : f(w);
      }
      function _(w, O) {
        for (var R in w)
          u.call(w, R) && O(w[R], R, w);
      }
      function m(w) {
        return w == null ? f(w) : c.call(w).slice(8, -1);
      }
      function y(w, O) {
        var R = w != null ? typeof w[O] : "number";
        return !/^(?:boolean|number|string|undefined)$/.test(R) && (R == "object" ? !!w[O] : !0);
      }
      function b(w) {
        return String(w).replace(/([ -])(?!$)/g, "$1?");
      }
      function P(w, O) {
        var R = null;
        return p(w, function(U, q) {
          R = O(R, U, q, w);
        }), R;
      }
      function x(w) {
        return String(w).replace(/^ +| +$/g, "");
      }
      function T(w) {
        var O = i, R = w && typeof w == "object" && m(w) != "String";
        R && (O = w, w = null);
        var U = O.navigator || {}, q = U.userAgent || "";
        w || (w = q);
        var tt = R ? !!U.likeChrome : /\bChrome\b/.test(w) && !/internal|\n/i.test(c.toString()), ct = "Object", Y = R ? ct : "ScriptBridgingProxyObject", g = R ? ct : "Environment", S = R && O.java ? "JavaPackage" : m(O.java), E = R ? ct : "RuntimeObject", M = /\bJava/.test(S) && O.java, N = M && m(O.environment) == g, k = M ? "a" : "α", B = M ? "b" : "β", H = O.document || {}, Z = O.operamini || O.opera, J = h.test(J = R && Z ? Z["[[Class]]"] : m(Z)) ? J : Z = null, C, ut = w, X = [], xt = null, lt = w == q, V = lt && Z && typeof Z.version == "function" && Z.version(), Mt, ht = Kt([
          { label: "EdgeHTML", pattern: "Edge" },
          "Trident",
          { label: "WebKit", pattern: "AppleWebKit" },
          "iCab",
          "Presto",
          "NetFront",
          "Tasman",
          "KHTML",
          "Gecko"
        ]), F = Jt([
          "Adobe AIR",
          "Arora",
          "Avant Browser",
          "Breach",
          "Camino",
          "Electron",
          "Epiphany",
          "Fennec",
          "Flock",
          "Galeon",
          "GreenBrowser",
          "iCab",
          "Iceweasel",
          "K-Meleon",
          "Konqueror",
          "Lunascape",
          "Maxthon",
          { label: "Microsoft Edge", pattern: "(?:Edge|Edg|EdgA|EdgiOS)" },
          "Midori",
          "Nook Browser",
          "PaleMoon",
          "PhantomJS",
          "Raven",
          "Rekonq",
          "RockMelt",
          { label: "Samsung Internet", pattern: "SamsungBrowser" },
          "SeaMonkey",
          { label: "Silk", pattern: "(?:Cloud9|Silk-Accelerated)" },
          "Sleipnir",
          "SlimBrowser",
          { label: "SRWare Iron", pattern: "Iron" },
          "Sunrise",
          "Swiftfox",
          "Vivaldi",
          "Waterfox",
          "WebPositive",
          { label: "Yandex Browser", pattern: "YaBrowser" },
          { label: "UC Browser", pattern: "UCBrowser" },
          "Opera Mini",
          { label: "Opera Mini", pattern: "OPiOS" },
          "Opera",
          { label: "Opera", pattern: "OPR" },
          "Chromium",
          "Chrome",
          { label: "Chrome", pattern: "(?:HeadlessChrome)" },
          { label: "Chrome Mobile", pattern: "(?:CriOS|CrMo)" },
          { label: "Firefox", pattern: "(?:Firefox|Minefield)" },
          { label: "Firefox for iOS", pattern: "FxiOS" },
          { label: "IE", pattern: "IEMobile" },
          { label: "IE", pattern: "MSIE" },
          "Safari"
        ]), W = Qe([
          { label: "BlackBerry", pattern: "BB10" },
          "BlackBerry",
          { label: "Galaxy S", pattern: "GT-I9000" },
          { label: "Galaxy S2", pattern: "GT-I9100" },
          { label: "Galaxy S3", pattern: "GT-I9300" },
          { label: "Galaxy S4", pattern: "GT-I9500" },
          { label: "Galaxy S5", pattern: "SM-G900" },
          { label: "Galaxy S6", pattern: "SM-G920" },
          { label: "Galaxy S6 Edge", pattern: "SM-G925" },
          { label: "Galaxy S7", pattern: "SM-G930" },
          { label: "Galaxy S7 Edge", pattern: "SM-G935" },
          "Google TV",
          "Lumia",
          "iPad",
          "iPod",
          "iPhone",
          "Kindle",
          { label: "Kindle Fire", pattern: "(?:Cloud9|Silk-Accelerated)" },
          "Nexus",
          "Nook",
          "PlayBook",
          "PlayStation Vita",
          "PlayStation",
          "TouchPad",
          "Transformer",
          { label: "Wii U", pattern: "WiiU" },
          "Wii",
          "Xbox One",
          { label: "Xbox 360", pattern: "Xbox" },
          "Xoom"
        ]), et = Ce({
          Apple: { iPad: 1, iPhone: 1, iPod: 1 },
          Alcatel: {},
          Archos: {},
          Amazon: { Kindle: 1, "Kindle Fire": 1 },
          Asus: { Transformer: 1 },
          "Barnes & Noble": { Nook: 1 },
          BlackBerry: { PlayBook: 1 },
          Google: { "Google TV": 1, Nexus: 1 },
          HP: { TouchPad: 1 },
          HTC: {},
          Huawei: {},
          Lenovo: {},
          LG: {},
          Microsoft: { Xbox: 1, "Xbox One": 1 },
          Motorola: { Xoom: 1 },
          Nintendo: { "Wii U": 1, Wii: 1 },
          Nokia: { Lumia: 1 },
          Oppo: {},
          Samsung: { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 },
          Sony: { PlayStation: 1, "PlayStation Vita": 1 },
          Xiaomi: { Mi: 1, Redmi: 1 }
        }), G = je([
          "Windows Phone",
          "KaiOS",
          "Android",
          "CentOS",
          { label: "Chrome OS", pattern: "CrOS" },
          "Debian",
          { label: "DragonFly BSD", pattern: "DragonFly" },
          "Fedora",
          "FreeBSD",
          "Gentoo",
          "Haiku",
          "Kubuntu",
          "Linux Mint",
          "OpenBSD",
          "Red Hat",
          "SuSE",
          "Ubuntu",
          "Xubuntu",
          "Cygwin",
          "Symbian OS",
          "hpwOS",
          "webOS ",
          "webOS",
          "Tablet OS",
          "Tizen",
          "Linux",
          "Mac OS X",
          "Macintosh",
          "Mac",
          "Windows 98;",
          "Windows "
        ]);
        function Kt(zt) {
          return P(zt, function(Pt, yt) {
            return Pt || RegExp("\\b" + (yt.pattern || b(yt)) + "\\b", "i").exec(w) && (yt.label || yt);
          });
        }
        function Ce(zt) {
          return P(zt, function(Pt, yt, ve) {
            return Pt || (yt[W] || yt[/^[a-z]+(?: +[a-z]+\b)*/i.exec(W)] || RegExp("\\b" + b(ve) + "(?:\\b|\\w*\\d)", "i").exec(w)) && ve;
          });
        }
        function Jt(zt) {
          return P(zt, function(Pt, yt) {
            return Pt || RegExp("\\b" + (yt.pattern || b(yt)) + "\\b", "i").exec(w) && (yt.label || yt);
          });
        }
        function je(zt) {
          return P(zt, function(Pt, yt) {
            var ve = yt.pattern || b(yt);
            return !Pt && (Pt = RegExp("\\b" + ve + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(w)) && (Pt = d(Pt, ve, yt.label || yt)), Pt;
          });
        }
        function Qe(zt) {
          return P(zt, function(Pt, yt) {
            var ve = yt.pattern || b(yt);
            return !Pt && (Pt = RegExp("\\b" + ve + " *\\d+[.\\w_]*", "i").exec(w) || RegExp("\\b" + ve + " *\\w+-[\\w]*", "i").exec(w) || RegExp("\\b" + ve + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(w)) && ((Pt = String(yt.label && !RegExp(ve, "i").test(yt.label) ? yt.label : Pt).split("/"))[1] && !/[\d.]+/.test(Pt[0]) && (Pt[0] += " " + Pt[1]), yt = yt.label || yt, Pt = v(Pt[0].replace(RegExp(ve, "i"), yt).replace(RegExp("; *(?:" + yt + "[_-])?", "i"), " ").replace(RegExp("(" + yt + ")[-_.]?(\\w)", "i"), "$1 $2"))), Pt;
          });
        }
        function ti(zt) {
          return P(zt, function(Pt, yt) {
            return Pt || (RegExp(yt + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(w) || 0)[1] || null;
          });
        }
        function ei() {
          return this.description || "";
        }
        if (ht && (ht = [ht]), /\bAndroid\b/.test(G) && !W && (C = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(w)) && (W = x(C[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null), et && !W ? W = Qe([et]) : et && W && (W = W.replace(RegExp("^(" + b(et) + ")[-_.\\s]", "i"), et + " ").replace(RegExp("^(" + b(et) + ")[-_.]?(\\w)", "i"), et + " $2")), (C = /\bGoogle TV\b/.exec(W)) && (W = C[0]), /\bSimulator\b/i.test(w) && (W = (W ? W + " " : "") + "Simulator"), F == "Opera Mini" && /\bOPiOS\b/.test(w) && X.push("running in Turbo/Uncompressed mode"), F == "IE" && /\blike iPhone OS\b/.test(w) ? (C = T(w.replace(/like iPhone OS/, "")), et = C.manufacturer, W = C.product) : /^iP/.test(W) ? (F || (F = "Safari"), G = "iOS" + ((C = / OS ([\d_]+)/i.exec(w)) ? " " + C[1].replace(/_/g, ".") : "")) : F == "Konqueror" && /^Linux\b/i.test(G) ? G = "Kubuntu" : et && et != "Google" && (/Chrome/.test(F) && !/\bMobile Safari\b/i.test(w) || /\bVita\b/.test(W)) || /\bAndroid\b/.test(G) && /^Chrome/.test(F) && /\bVersion\//i.test(w) ? (F = "Android Browser", G = /\bAndroid\b/.test(G) ? G : "Android") : F == "Silk" ? (/\bMobi/i.test(w) || (G = "Android", X.unshift("desktop mode")), /Accelerated *= *true/i.test(w) && X.unshift("accelerated")) : F == "UC Browser" && /\bUCWEB\b/.test(w) ? X.push("speed mode") : F == "PaleMoon" && (C = /\bFirefox\/([\d.]+)\b/.exec(w)) ? X.push("identifying as Firefox " + C[1]) : F == "Firefox" && (C = /\b(Mobile|Tablet|TV)\b/i.exec(w)) ? (G || (G = "Firefox OS"), W || (W = C[1])) : !F || (C = !/\bMinefield\b/i.test(w) && /\b(?:Firefox|Safari)\b/.exec(F)) ? (F && !W && /[\/,]|^[^(]+?\)/.test(w.slice(w.indexOf(C + "/") + 8)) && (F = null), (C = W || et || G) && (W || et || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(G)) && (F = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(G) ? G : C) + " Browser")) : F == "Electron" && (C = (/\bChrome\/([\d.]+)\b/.exec(w) || 0)[1]) && X.push("Chromium " + C), V || (V = ti([
          "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
          "Version",
          b(F),
          "(?:Firefox|Minefield|NetFront)"
        ])), (C = ht == "iCab" && parseFloat(V) > 3 && "WebKit" || /\bOpera\b/.test(F) && (/\bOPR\b/.test(w) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(w) && !/^(?:Trident|EdgeHTML)$/.test(ht) && "WebKit" || !ht && /\bMSIE\b/i.test(w) && (G == "Mac OS" ? "Tasman" : "Trident") || ht == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(F) && "NetFront") && (ht = [C]), F == "IE" && (C = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(w) || 0)[1]) ? (F += " Mobile", G = "Windows Phone " + (/\+$/.test(C) ? C : C + ".x"), X.unshift("desktop mode")) : /\bWPDesktop\b/i.test(w) ? (F = "IE Mobile", G = "Windows Phone 8.x", X.unshift("desktop mode"), V || (V = (/\brv:([\d.]+)/.exec(w) || 0)[1])) : F != "IE" && ht == "Trident" && (C = /\brv:([\d.]+)/.exec(w)) && (F && X.push("identifying as " + F + (V ? " " + V : "")), F = "IE", V = C[1]), lt) {
          if (y(O, "global"))
            if (M && (C = M.lang.System, ut = C.getProperty("os.arch"), G = G || C.getProperty("os.name") + " " + C.getProperty("os.version")), N) {
              try {
                V = O.require("ringo/engine").version.join("."), F = "RingoJS";
              } catch {
                (C = O.system) && C.global.system == O.system && (F = "Narwhal", G || (G = C[0].os || null));
              }
              F || (F = "Rhino");
            } else typeof O.process == "object" && !O.process.browser && (C = O.process) && (typeof C.versions == "object" && (typeof C.versions.electron == "string" ? (X.push("Node " + C.versions.node), F = "Electron", V = C.versions.electron) : typeof C.versions.nw == "string" && (X.push("Chromium " + V, "Node " + C.versions.node), F = "NW.js", V = C.versions.nw)), F || (F = "Node.js", ut = C.arch, G = C.platform, V = /[\d.]+/.exec(C.version), V = V ? V[0] : null));
          else m(C = O.runtime) == Y ? (F = "Adobe AIR", G = C.flash.system.Capabilities.os) : m(C = O.phantom) == E ? (F = "PhantomJS", V = (C = C.version || null) && C.major + "." + C.minor + "." + C.patch) : typeof H.documentMode == "number" && (C = /\bTrident\/(\d+)/i.exec(w)) ? (V = [V, H.documentMode], (C = +C[1] + 4) != V[1] && (X.push("IE " + V[1] + " mode"), ht && (ht[1] = ""), V[1] = C), V = F == "IE" ? String(V[1].toFixed(1)) : V[0]) : typeof H.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(F) && (X.push("masking as " + F + " " + V), F = "IE", V = "11.0", ht = ["Trident"], G = "Windows");
          G = G && v(G);
        }
        if (V && (C = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(V) || /(?:alpha|beta)(?: ?\d)?/i.exec(w + ";" + (lt && U.appMinorVersion)) || /\bMinefield\b/i.test(w) && "a") && (xt = /b/i.test(C) ? "beta" : "alpha", V = V.replace(RegExp(C + "\\+?$"), "") + (xt == "beta" ? B : k) + (/\d+\+?/.exec(C) || "")), F == "Fennec" || F == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(G))
          F = "Firefox Mobile";
        else if (F == "Maxthon" && V)
          V = V.replace(/\.[\d.]+/, ".x");
        else if (/\bXbox\b/i.test(W))
          W == "Xbox 360" && (G = null), W == "Xbox 360" && /\bIEMobile\b/.test(w) && X.unshift("mobile mode");
        else if ((/^(?:Chrome|IE|Opera)$/.test(F) || F && !W && !/Browser|Mobi/.test(F)) && (G == "Windows CE" || /Mobi/i.test(w)))
          F += " Mobile";
        else if (F == "IE" && lt)
          try {
            O.external === null && X.unshift("platform preview");
          } catch {
            X.unshift("embedded");
          }
        else (/\bBlackBerry\b/.test(W) || /\bBB10\b/.test(w)) && (C = (RegExp(W.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(w) || 0)[1] || V) ? (C = [C, /BB10/.test(w)], G = (C[1] ? (W = null, et = "BlackBerry") : "Device Software") + " " + C[0], V = null) : this != _ && W != "Wii" && (lt && Z || /Opera/.test(F) && /\b(?:MSIE|Firefox)\b/i.test(w) || F == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(G) || F == "IE" && (G && !/^Win/.test(G) && V > 5.5 || /\bWindows XP\b/.test(G) && V > 8 || V == 8 && !/\bTrident\b/.test(w))) && !h.test(C = T.call(_, w.replace(h, "") + ";")) && C.name && (C = "ing as " + C.name + ((C = C.version) ? " " + C : ""), h.test(F) ? (/\bIE\b/.test(C) && G == "Mac OS" && (G = null), C = "identify" + C) : (C = "mask" + C, J ? F = v(J.replace(/([a-z])([A-Z])/g, "$1 $2")) : F = "Opera", /\bIE\b/.test(C) && (G = null), lt || (V = null)), ht = ["Presto"], X.push(C));
        (C = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(w) || 0)[1]) && (C = [parseFloat(C.replace(/\.(\d)$/, ".0$1")), C], F == "Safari" && C[1].slice(-1) == "+" ? (F = "WebKit Nightly", xt = "alpha", V = C[1].slice(0, -1)) : (V == C[1] || V == (C[2] = (/\bSafari\/([\d.]+\+?)/i.exec(w) || 0)[1])) && (V = null), C[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(w) || 0)[1], C[0] == 537.36 && C[2] == 537.36 && parseFloat(C[1]) >= 28 && ht == "WebKit" && (ht = ["Blink"]), !lt || !tt && !C[1] ? (ht && (ht[1] = "like Safari"), C = (C = C[0], C < 400 ? 1 : C < 500 ? 2 : C < 526 ? 3 : C < 533 ? 4 : C < 534 ? "4+" : C < 535 ? 5 : C < 537 ? 6 : C < 538 ? 7 : C < 601 ? 8 : C < 602 ? 9 : C < 604 ? 10 : C < 606 ? 11 : C < 608 ? 12 : "12")) : (ht && (ht[1] = "like Chrome"), C = C[1] || (C = C[0], C < 530 ? 1 : C < 532 ? 2 : C < 532.05 ? 3 : C < 533 ? 4 : C < 534.03 ? 5 : C < 534.07 ? 6 : C < 534.1 ? 7 : C < 534.13 ? 8 : C < 534.16 ? 9 : C < 534.24 ? 10 : C < 534.3 ? 11 : C < 535.01 ? 12 : C < 535.02 ? "13+" : C < 535.07 ? 15 : C < 535.11 ? 16 : C < 535.19 ? 17 : C < 536.05 ? 18 : C < 536.1 ? 19 : C < 537.01 ? 20 : C < 537.11 ? "21+" : C < 537.13 ? 23 : C < 537.18 ? 24 : C < 537.24 ? 25 : C < 537.36 ? 26 : ht != "Blink" ? "27" : "28")), ht && (ht[1] += " " + (C += typeof C == "number" ? ".x" : /[.+]/.test(C) ? "" : "+")), F == "Safari" && (!V || parseInt(V) > 45) ? V = C : F == "Chrome" && /\bHeadlessChrome/i.test(w) && X.unshift("headless")), F == "Opera" && (C = /\bzbov|zvav$/.exec(G)) ? (F += " ", X.unshift("desktop mode"), C == "zvav" ? (F += "Mini", V = null) : F += "Mobile", G = G.replace(RegExp(" *" + C + "$"), "")) : F == "Safari" && /\bChrome\b/.exec(ht && ht[1]) ? (X.unshift("desktop mode"), F = "Chrome Mobile", V = null, /\bOS X\b/.test(G) ? (et = "Apple", G = "iOS 4.3+") : G = null) : /\bSRWare Iron\b/.test(F) && !V && (V = ti("Chrome")), V && V.indexOf(C = /[\d.]+$/.exec(G)) == 0 && w.indexOf("/" + C + "-") > -1 && (G = x(G.replace(C, ""))), G && G.indexOf(F) != -1 && !RegExp(F + " OS").test(G) && (G = G.replace(RegExp(" *" + b(F) + " *"), "")), ht && !/\b(?:Avant|Nook)\b/.test(F) && (/Browser|Lunascape|Maxthon/.test(F) || F != "Safari" && /^iOS/.test(G) && /\bSafari\b/.test(ht[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(F) && ht[1]) && (C = ht[ht.length - 1]) && X.push(C), X.length && (X = ["(" + X.join("; ") + ")"]), et && W && W.indexOf(et) < 0 && X.push("on " + et), W && X.push((/^on /.test(X[X.length - 1]) ? "" : "on ") + W), G && (C = / ([\d.+]+)$/.exec(G), Mt = C && G.charAt(G.length - C[0].length - 1) == "/", G = {
          architecture: 32,
          family: C && !Mt ? G.replace(C[0], "") : G,
          version: C ? C[1] : null,
          toString: function() {
            var zt = this.version;
            return this.family + (zt && !Mt ? " " + zt : "") + (this.architecture == 64 ? " 64-bit" : "");
          }
        }), (C = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(ut)) && !/\bi686\b/i.test(ut) ? (G && (G.architecture = 64, G.family = G.family.replace(RegExp(" *" + C), "")), F && (/\bWOW64\b/i.test(w) || lt && /\w(?:86|32)$/.test(U.cpuClass || U.platform) && !/\bWin64; x64\b/i.test(w)) && X.unshift("32-bit")) : G && /^OS X/.test(G.family) && F == "Chrome" && parseFloat(V) >= 39 && (G.architecture = 64), w || (w = null);
        var Wt = {};
        return Wt.description = w, Wt.layout = ht && ht[0], Wt.manufacturer = et, Wt.name = F, Wt.prerelease = xt, Wt.product = W, Wt.ua = w, Wt.version = F && V, Wt.os = G || {
          /**
           * The CPU architecture the OS is built for.
           *
           * @memberOf platform.os
           * @type number|null
           */
          architecture: null,
          /**
           * The family of the OS.
           *
           * Common values include:
           * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
           * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
           * "SuSE", "Android", "iOS" and "Windows Phone"
           *
           * @memberOf platform.os
           * @type string|null
           */
          family: null,
          /**
           * The version of the OS.
           *
           * @memberOf platform.os
           * @type string|null
           */
          version: null,
          /**
           * Returns the OS string.
           *
           * @memberOf platform.os
           * @returns {string} The OS string.
           */
          toString: function() {
            return "null";
          }
        }, Wt.parse = T, Wt.toString = ei, Wt.version && X.unshift(V), Wt.name && X.unshift(F), G && F && !(G == String(G).split(" ")[0] && (G == F.split(" ")[0] || W)) && X.push(W ? "(" + G + ")" : "on " + G), X.length && (Wt.description = X.join(" ")), Wt;
      }
      var I = T();
      n && s ? _(I, function(w, O) {
        n[O] = w;
      }) : i.platform = I;
    }).call(eu);
  }(nr, nr.exports)), nr.exports;
}
var sr = iu();
const ru = /* @__PURE__ */ Fn(sr);
function Ye(r) {
  return parseInt(String(r), 10);
}
function bt(r) {
  const t = parseInt(String(r), 10);
  return t < 0 ? -t : t;
}
"toInt" in String.prototype || (String.prototype.toInt = function() {
  return Ye(this);
});
"toUint" in String.prototype || (String.prototype.toUint = function() {
  const r = Ye(this);
  return r < 0 ? -r : r;
});
function Po(r = "/", t = " ", e = ":", i = "") {
  const n = /* @__PURE__ */ new Date();
  return n.getFullYear() + r + String(100 + n.getMonth() + 1).slice(1, 3) + r + String(100 + n.getDate()).slice(1, 3) + t + String(100 + n.getHours()).slice(1, 3) + e + String(100 + n.getMinutes()).slice(1, 3) + (i === "" ? "" : i + String(n.getMilliseconds()));
}
const wh = "/* SKYNovel */";
function nu() {
  const r = document.getElementsByTagName("head")[0], t = r.children.length;
  for (let e = t - 1; e >= 0; --e) {
    const i = r.children[e];
    i instanceof HTMLStyleElement && i.innerText.startsWith(wh) && r.removeChild(i);
  }
}
function hr(r) {
  const t = document.createElement("style");
  t.innerHTML = wh + r, document.getElementsByTagName("head")[0].appendChild(t);
}
function L(r, t, e) {
  const i = r[t];
  if (!(t in r)) {
    if (isNaN(e)) throw `[${r[":タグ名"]}]属性 ${t} は必須です`;
    return r[t] = e, e;
  }
  const n = String(i).startsWith("0x") ? parseInt(i) : parseFloat(i);
  if (isNaN(n)) throw `[${r[":タグ名"]}]属性 ${t} の値【${i}】が数値ではありません`;
  return r[t] = n;
}
function $(r, t, e) {
  if (!(t in r)) return r[t] = e;
  const i = r[t];
  if (i === null) return !1;
  const n = String(i);
  return r[t] = n === "false" ? !1 : !!n;
}
function Co(r) {
  if (r.startsWith("#")) return parseInt(r.slice(1), 16);
  const t = Number(r);
  if (!isNaN(t)) return t;
  if (r === "black") return 0;
  A.cc4ColorName.fillStyle = r;
  const e = A.cc4ColorName.fillStyle;
  if (e === "#000000") throw `色名前 ${r} が異常です`;
  return parseInt(e.slice(1), 16);
}
function Th(r, t, e) {
  const i = r[t];
  return i ? r[t] = Co(String(i)) : r[t] = e;
}
const su = /JSON at position (\d+)$/;
function un(r, t = "", e = "") {
  const i = (e.match(su) ?? ["", ""])[1];
  return `[${r[":タグ名"]}] ${t} 属性の解析エラー : ${e}
${r[t]}${i ? `
${"^".padStart(Number(i))}` : ""}`;
}
const ou = /^[^\/\.]+$|[^\/]+(?=\.)/;
function lr(r) {
  return (r.match(ou) ?? [""])[0];
}
class A {
  static stageW = 0;
  static stageH = 0;
  static debugLog = !1;
  static isSafari = sr.name === "Safari";
  static isFirefox = sr.name === "Firefox";
  static isMac = /OS X/.test(sr.os?.family ?? "");
  static isMobile = !/(Windows|OS X)/.test(sr.os?.family ?? "");
  static hDip = {};
  static isDbg = !1;
  static isPackaged = !1;
  static isDarkMode = !1;
  static cc4ColorName;
}
function au(r) {
  var t = this.constructor;
  return this.then(
    function(e) {
      return t.resolve(r()).then(function() {
        return e;
      });
    },
    function(e) {
      return t.resolve(r()).then(function() {
        return t.reject(e);
      });
    }
  );
}
function hu(r) {
  var t = this;
  return new t(function(e, i) {
    if (!(r && typeof r.length < "u"))
      return i(
        new TypeError(
          typeof r + " " + r + " is not iterable(cannot read property Symbol(Symbol.iterator))"
        )
      );
    var n = Array.prototype.slice.call(r);
    if (n.length === 0) return e([]);
    var s = n.length;
    function o(h, l) {
      if (l && (typeof l == "object" || typeof l == "function")) {
        var u = l.then;
        if (typeof u == "function") {
          u.call(
            l,
            function(c) {
              o(h, c);
            },
            function(c) {
              n[h] = { status: "rejected", reason: c }, --s === 0 && e(n);
            }
          );
          return;
        }
      }
      n[h] = { status: "fulfilled", value: l }, --s === 0 && e(n);
    }
    for (var a = 0; a < n.length; a++)
      o(a, n[a]);
  });
}
function Eh(r, t) {
  this.name = "AggregateError", this.errors = r, this.message = t || "";
}
Eh.prototype = Error.prototype;
function lu(r) {
  var t = this;
  return new t(function(e, i) {
    if (!(r && typeof r.length < "u"))
      return i(new TypeError("Promise.any accepts an array"));
    var n = Array.prototype.slice.call(r);
    if (n.length === 0) return i();
    for (var s = [], o = 0; o < n.length; o++)
      try {
        t.resolve(n[o]).then(e).catch(function(a) {
          s.push(a), s.length === n.length && i(
            new Eh(
              s,
              "All promises were rejected"
            )
          );
        });
      } catch (a) {
        i(a);
      }
  });
}
var uu = setTimeout;
function Sh(r) {
  return !!(r && typeof r.length < "u");
}
function cu() {
}
function fu(r, t) {
  return function() {
    r.apply(t, arguments);
  };
}
function At(r) {
  if (!(this instanceof At))
    throw new TypeError("Promises must be constructed via new");
  if (typeof r != "function") throw new TypeError("not a function");
  this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], Ch(r, this);
}
function Ph(r, t) {
  for (; r._state === 3; )
    r = r._value;
  if (r._state === 0) {
    r._deferreds.push(t);
    return;
  }
  r._handled = !0, At._immediateFn(function() {
    var e = r._state === 1 ? t.onFulfilled : t.onRejected;
    if (e === null) {
      (r._state === 1 ? Ms : mr)(t.promise, r._value);
      return;
    }
    var i;
    try {
      i = e(r._value);
    } catch (n) {
      mr(t.promise, n);
      return;
    }
    Ms(t.promise, i);
  });
}
function Ms(r, t) {
  try {
    if (t === r)
      throw new TypeError("A promise cannot be resolved with itself.");
    if (t && (typeof t == "object" || typeof t == "function")) {
      var e = t.then;
      if (t instanceof At) {
        r._state = 3, r._value = t, Rs(r);
        return;
      } else if (typeof e == "function") {
        Ch(fu(e, t), r);
        return;
      }
    }
    r._state = 1, r._value = t, Rs(r);
  } catch (i) {
    mr(r, i);
  }
}
function mr(r, t) {
  r._state = 2, r._value = t, Rs(r);
}
function Rs(r) {
  r._state === 2 && r._deferreds.length === 0 && At._immediateFn(function() {
    r._handled || At._unhandledRejectionFn(r._value);
  });
  for (var t = 0, e = r._deferreds.length; t < e; t++)
    Ph(r, r._deferreds[t]);
  r._deferreds = null;
}
function du(r, t, e) {
  this.onFulfilled = typeof r == "function" ? r : null, this.onRejected = typeof t == "function" ? t : null, this.promise = e;
}
function Ch(r, t) {
  var e = !1;
  try {
    r(
      function(i) {
        e || (e = !0, Ms(t, i));
      },
      function(i) {
        e || (e = !0, mr(t, i));
      }
    );
  } catch (i) {
    if (e) return;
    e = !0, mr(t, i);
  }
}
At.prototype.catch = function(r) {
  return this.then(null, r);
};
At.prototype.then = function(r, t) {
  var e = new this.constructor(cu);
  return Ph(this, new du(r, t, e)), e;
};
At.prototype.finally = au;
At.all = function(r) {
  return new At(function(t, e) {
    if (!Sh(r))
      return e(new TypeError("Promise.all accepts an array"));
    var i = Array.prototype.slice.call(r);
    if (i.length === 0) return t([]);
    var n = i.length;
    function s(a, h) {
      try {
        if (h && (typeof h == "object" || typeof h == "function")) {
          var l = h.then;
          if (typeof l == "function") {
            l.call(
              h,
              function(u) {
                s(a, u);
              },
              e
            );
            return;
          }
        }
        i[a] = h, --n === 0 && t(i);
      } catch (u) {
        e(u);
      }
    }
    for (var o = 0; o < i.length; o++)
      s(o, i[o]);
  });
};
At.any = lu;
At.allSettled = hu;
At.resolve = function(r) {
  return r && typeof r == "object" && r.constructor === At ? r : new At(function(t) {
    t(r);
  });
};
At.reject = function(r) {
  return new At(function(t, e) {
    e(r);
  });
};
At.race = function(r) {
  return new At(function(t, e) {
    if (!Sh(r))
      return e(new TypeError("Promise.race accepts an array"));
    for (var i = 0, n = r.length; i < n; i++)
      At.resolve(r[i]).then(t, e);
  });
};
At._immediateFn = // @ts-ignore
typeof setImmediate == "function" && function(r) {
  setImmediate(r);
} || function(r) {
  uu(r, 0);
};
At._unhandledRejectionFn = function(t) {
  typeof console < "u" && console && console.warn("Possible Unhandled Promise Rejection:", t);
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Xn, Zo;
function pu() {
  if (Zo) return Xn;
  Zo = 1;
  var r = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, e = Object.prototype.propertyIsEnumerable;
  function i(s) {
    if (s == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(s);
  }
  function n() {
    try {
      if (!Object.assign)
        return !1;
      var s = new String("abc");
      if (s[5] = "de", Object.getOwnPropertyNames(s)[0] === "5")
        return !1;
      for (var o = {}, a = 0; a < 10; a++)
        o["_" + String.fromCharCode(a)] = a;
      var h = Object.getOwnPropertyNames(o).map(function(u) {
        return o[u];
      });
      if (h.join("") !== "0123456789")
        return !1;
      var l = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(u) {
        l[u] = u;
      }), Object.keys(Object.assign({}, l)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Xn = n() ? Object.assign : function(s, o) {
    for (var a, h = i(s), l, u = 1; u < arguments.length; u++) {
      a = Object(arguments[u]);
      for (var c in a)
        t.call(a, c) && (h[c] = a[c]);
      if (r) {
        l = r(a);
        for (var f = 0; f < l.length; f++)
          e.call(a, l[f]) && (h[l[f]] = a[l[f]]);
      }
    }
    return h;
  }, Xn;
}
var vu = pu();
const _u = /* @__PURE__ */ Fn(vu);
/*!
 * @pixi/polyfill - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/polyfill is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
typeof globalThis > "u" && (typeof self < "u" ? self.globalThis = self : typeof global < "u" && (global.globalThis = global));
globalThis.Promise || (globalThis.Promise = At);
Object.assign || (Object.assign = _u);
var mu = 16;
Date.now && Date.prototype.getTime || (Date.now = function() {
  return (/* @__PURE__ */ new Date()).getTime();
});
if (!(globalThis.performance && globalThis.performance.now)) {
  var yu = Date.now();
  globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {
    return Date.now() - yu;
  };
}
var Vn = Date.now(), Ko = ["ms", "moz", "webkit", "o"];
for (var Wn = 0; Wn < Ko.length && !globalThis.requestAnimationFrame; ++Wn) {
  var Yn = Ko[Wn];
  globalThis.requestAnimationFrame = globalThis[Yn + "RequestAnimationFrame"], globalThis.cancelAnimationFrame = globalThis[Yn + "CancelAnimationFrame"] || globalThis[Yn + "CancelRequestAnimationFrame"];
}
globalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(r) {
  if (typeof r != "function")
    throw new TypeError(r + "is not a function");
  var t = Date.now(), e = mu + Vn - t;
  return e < 0 && (e = 0), Vn = t, globalThis.self.setTimeout(function() {
    Vn = Date.now(), r(performance.now());
  }, e);
});
globalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(r) {
  return clearTimeout(r);
});
Math.sign || (Math.sign = function(t) {
  return t = Number(t), t === 0 || isNaN(t) ? t : t > 0 ? 1 : -1;
});
Number.isInteger || (Number.isInteger = function(t) {
  return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
});
globalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array);
globalThis.Float32Array || (globalThis.Float32Array = Array);
globalThis.Uint32Array || (globalThis.Uint32Array = Array);
globalThis.Uint16Array || (globalThis.Uint16Array = Array);
globalThis.Uint8Array || (globalThis.Uint8Array = Array);
globalThis.Int32Array || (globalThis.Int32Array = Array);
/*!
 * @pixi/constants - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var qe;
(function(r) {
  r[r.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", r[r.WEBGL = 1] = "WEBGL", r[r.WEBGL2 = 2] = "WEBGL2";
})(qe || (qe = {}));
var yr;
(function(r) {
  r[r.UNKNOWN = 0] = "UNKNOWN", r[r.WEBGL = 1] = "WEBGL", r[r.CANVAS = 2] = "CANVAS";
})(yr || (yr = {}));
var Tn;
(function(r) {
  r[r.COLOR = 16384] = "COLOR", r[r.DEPTH = 256] = "DEPTH", r[r.STENCIL = 1024] = "STENCIL";
})(Tn || (Tn = {}));
var it;
(function(r) {
  r[r.NORMAL = 0] = "NORMAL", r[r.ADD = 1] = "ADD", r[r.MULTIPLY = 2] = "MULTIPLY", r[r.SCREEN = 3] = "SCREEN", r[r.OVERLAY = 4] = "OVERLAY", r[r.DARKEN = 5] = "DARKEN", r[r.LIGHTEN = 6] = "LIGHTEN", r[r.COLOR_DODGE = 7] = "COLOR_DODGE", r[r.COLOR_BURN = 8] = "COLOR_BURN", r[r.HARD_LIGHT = 9] = "HARD_LIGHT", r[r.SOFT_LIGHT = 10] = "SOFT_LIGHT", r[r.DIFFERENCE = 11] = "DIFFERENCE", r[r.EXCLUSION = 12] = "EXCLUSION", r[r.HUE = 13] = "HUE", r[r.SATURATION = 14] = "SATURATION", r[r.COLOR = 15] = "COLOR", r[r.LUMINOSITY = 16] = "LUMINOSITY", r[r.NORMAL_NPM = 17] = "NORMAL_NPM", r[r.ADD_NPM = 18] = "ADD_NPM", r[r.SCREEN_NPM = 19] = "SCREEN_NPM", r[r.NONE = 20] = "NONE", r[r.SRC_OVER = 0] = "SRC_OVER", r[r.SRC_IN = 21] = "SRC_IN", r[r.SRC_OUT = 22] = "SRC_OUT", r[r.SRC_ATOP = 23] = "SRC_ATOP", r[r.DST_OVER = 24] = "DST_OVER", r[r.DST_IN = 25] = "DST_IN", r[r.DST_OUT = 26] = "DST_OUT", r[r.DST_ATOP = 27] = "DST_ATOP", r[r.ERASE = 26] = "ERASE", r[r.SUBTRACT = 28] = "SUBTRACT", r[r.XOR = 29] = "XOR";
})(it || (it = {}));
var we;
(function(r) {
  r[r.POINTS = 0] = "POINTS", r[r.LINES = 1] = "LINES", r[r.LINE_LOOP = 2] = "LINE_LOOP", r[r.LINE_STRIP = 3] = "LINE_STRIP", r[r.TRIANGLES = 4] = "TRIANGLES", r[r.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", r[r.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(we || (we = {}));
var z;
(function(r) {
  r[r.RGBA = 6408] = "RGBA", r[r.RGB = 6407] = "RGB", r[r.RG = 33319] = "RG", r[r.RED = 6403] = "RED", r[r.RGBA_INTEGER = 36249] = "RGBA_INTEGER", r[r.RGB_INTEGER = 36248] = "RGB_INTEGER", r[r.RG_INTEGER = 33320] = "RG_INTEGER", r[r.RED_INTEGER = 36244] = "RED_INTEGER", r[r.ALPHA = 6406] = "ALPHA", r[r.LUMINANCE = 6409] = "LUMINANCE", r[r.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", r[r.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", r[r.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(z || (z = {}));
var wi;
(function(r) {
  r[r.TEXTURE_2D = 3553] = "TEXTURE_2D", r[r.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", r[r.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", r[r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", r[r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", r[r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", r[r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(wi || (wi = {}));
var st;
(function(r) {
  r[r.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", r[r.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", r[r.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", r[r.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", r[r.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", r[r.UNSIGNED_INT = 5125] = "UNSIGNED_INT", r[r.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", r[r.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", r[r.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", r[r.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", r[r.BYTE = 5120] = "BYTE", r[r.SHORT = 5122] = "SHORT", r[r.INT = 5124] = "INT", r[r.FLOAT = 5126] = "FLOAT", r[r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", r[r.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(st || (st = {}));
var En;
(function(r) {
  r[r.FLOAT = 0] = "FLOAT", r[r.INT = 1] = "INT", r[r.UINT = 2] = "UINT";
})(En || (En = {}));
var Me;
(function(r) {
  r[r.NEAREST = 0] = "NEAREST", r[r.LINEAR = 1] = "LINEAR";
})(Me || (Me = {}));
var ke;
(function(r) {
  r[r.CLAMP = 33071] = "CLAMP", r[r.REPEAT = 10497] = "REPEAT", r[r.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(ke || (ke = {}));
var Ee;
(function(r) {
  r[r.OFF = 0] = "OFF", r[r.POW2 = 1] = "POW2", r[r.ON = 2] = "ON", r[r.ON_MANUAL = 3] = "ON_MANUAL";
})(Ee || (Ee = {}));
var Se;
(function(r) {
  r[r.NPM = 0] = "NPM", r[r.UNPACK = 1] = "UNPACK", r[r.PMA = 2] = "PMA", r[r.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", r[r.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", r[r.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", r[r.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(Se || (Se = {}));
var be;
(function(r) {
  r[r.NO = 0] = "NO", r[r.YES = 1] = "YES", r[r.AUTO = 2] = "AUTO", r[r.BLEND = 0] = "BLEND", r[r.CLEAR = 1] = "CLEAR", r[r.BLIT = 2] = "BLIT";
})(be || (be = {}));
var Sn;
(function(r) {
  r[r.AUTO = 0] = "AUTO", r[r.MANUAL = 1] = "MANUAL";
})(Sn || (Sn = {}));
var ne;
(function(r) {
  r.LOW = "lowp", r.MEDIUM = "mediump", r.HIGH = "highp";
})(ne || (ne = {}));
var jt;
(function(r) {
  r[r.NONE = 0] = "NONE", r[r.SCISSOR = 1] = "SCISSOR", r[r.STENCIL = 2] = "STENCIL", r[r.SPRITE = 3] = "SPRITE", r[r.COLOR = 4] = "COLOR";
})(jt || (jt = {}));
var Jo;
(function(r) {
  r[r.RED = 1] = "RED", r[r.GREEN = 2] = "GREEN", r[r.BLUE = 4] = "BLUE", r[r.ALPHA = 8] = "ALPHA";
})(Jo || (Jo = {}));
var Rt;
(function(r) {
  r[r.NONE = 0] = "NONE", r[r.LOW = 2] = "LOW", r[r.MEDIUM = 4] = "MEDIUM", r[r.HIGH = 8] = "HIGH";
})(Rt || (Rt = {}));
var Ne;
(function(r) {
  r[r.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", r[r.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", r[r.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(Ne || (Ne = {}));
/*!
 * @pixi/settings - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var gu = {
  /**
   * Creates a canvas element of the given size.
   * This canvas is created using the browser's native canvas element.
   * @param width - width of the canvas
   * @param height - height of the canvas
   */
  createCanvas: function(r, t) {
    var e = document.createElement("canvas");
    return e.width = r, e.height = t, e;
  },
  getWebGLRenderingContext: function() {
    return WebGLRenderingContext;
  },
  getNavigator: function() {
    return navigator;
  },
  getBaseUrl: function() {
    var r;
    return (r = document.baseURI) !== null && r !== void 0 ? r : window.location.href;
  },
  fetch: function(r, t) {
    return fetch(r, t);
  }
}, qn = /iPhone/i, Qo = /iPod/i, ta = /iPad/i, ea = /\biOS-universal(?:.+)Mac\b/i, Zn = /\bAndroid(?:.+)Mobile\b/i, ia = /Android/i, Mi = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, Dr = /Silk/i, He = /Windows Phone/i, ra = /\bWindows(?:.+)ARM\b/i, na = /BlackBerry/i, sa = /BB10/i, oa = /Opera Mini/i, aa = /\b(CriOS|Chrome)(?:.+)Mobile/i, ha = /Mobile(?:.+)Firefox\b/i, la = function(r) {
  return typeof r < "u" && r.platform === "MacIntel" && typeof r.maxTouchPoints == "number" && r.maxTouchPoints > 1 && typeof MSStream > "u";
};
function bu(r) {
  return function(t) {
    return t.test(r);
  };
}
function xu(r) {
  var t = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  !r && typeof navigator < "u" ? t = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    maxTouchPoints: navigator.maxTouchPoints || 0
  } : typeof r == "string" ? t.userAgent = r : r && r.userAgent && (t = {
    userAgent: r.userAgent,
    platform: r.platform,
    maxTouchPoints: r.maxTouchPoints || 0
  });
  var e = t.userAgent, i = e.split("[FBAN");
  typeof i[1] < "u" && (e = i[0]), i = e.split("Twitter"), typeof i[1] < "u" && (e = i[0]);
  var n = bu(e), s = {
    apple: {
      phone: n(qn) && !n(He),
      ipod: n(Qo),
      tablet: !n(qn) && (n(ta) || la(t)) && !n(He),
      universal: n(ea),
      device: (n(qn) || n(Qo) || n(ta) || n(ea) || la(t)) && !n(He)
    },
    amazon: {
      phone: n(Mi),
      tablet: !n(Mi) && n(Dr),
      device: n(Mi) || n(Dr)
    },
    android: {
      phone: !n(He) && n(Mi) || !n(He) && n(Zn),
      tablet: !n(He) && !n(Mi) && !n(Zn) && (n(Dr) || n(ia)),
      device: !n(He) && (n(Mi) || n(Dr) || n(Zn) || n(ia)) || n(/\bokhttp\b/i)
    },
    windows: {
      phone: n(He),
      tablet: n(ra),
      device: n(He) || n(ra)
    },
    other: {
      blackberry: n(na),
      blackberry10: n(sa),
      opera: n(oa),
      firefox: n(ha),
      chrome: n(aa),
      device: n(na) || n(sa) || n(oa) || n(ha) || n(aa)
    },
    any: !1,
    phone: !1,
    tablet: !1
  };
  return s.any = s.apple.device || s.android.device || s.windows.device || s.other.device, s.phone = s.apple.phone || s.android.phone || s.windows.phone, s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet, s;
}
var Re = xu(globalThis.navigator);
function wu() {
  return !Re.apple.device;
}
function Tu(r) {
  var t = !0;
  if (Re.tablet || Re.phone) {
    if (Re.apple.device) {
      var e = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (e) {
        var i = parseInt(e[1], 10);
        i < 11 && (t = !1);
      }
    }
    if (Re.android.device) {
      var e = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (e) {
        var i = parseInt(e[1], 10);
        i < 7 && (t = !1);
      }
    }
  }
  return t ? r : 4;
}
var K = {
  /**
   * This adapter is used to call methods that are platform dependent.
   * For example `document.createElement` only runs on the web but fails in node environments.
   * This allows us to support more platforms by abstracting away specific implementations per platform.
   *
   * By default the adapter is set to work in the browser. However you can create your own
   * by implementing the `IAdapter` interface. See `IAdapter` for more information.
   * @name ADAPTER
   * @memberof PIXI.settings
   * @type {PIXI.IAdapter}
   * @default PIXI.BrowserAdapter
   */
  ADAPTER: gu,
  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  MIPMAP_TEXTURES: Ee.POW2,
  /**
   * Default anisotropic filtering level of textures.
   * Usually from 0 to 16
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @default 0
   */
  ANISOTROPIC_LEVEL: 0,
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Default filter resolution.
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,
  /**
   * Default filter samples.
   * @static
   * @name FILTER_MULTISAMPLE
   * @memberof PIXI.settings
   * @type {PIXI.MSAA_QUALITY}
   * @default PIXI.MSAA_QUALITY.NONE
   */
  FILTER_MULTISAMPLE: Rt.NONE,
  /**
   * The maximum textures that this device supports.
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @type {number}
   * @default 32
   */
  SPRITE_MAX_TEXTURES: Tu(32),
  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,
  /**
   * The default render options if none are supplied to {@link PIXI.Renderer}
   * or {@link PIXI.CanvasRenderer}.
   * @static
   * @name RENDER_OPTIONS
   * @memberof PIXI.settings
   * @type {object}
   * @property {boolean} [antialias=false] - {@link PIXI.IRendererOptions.antialias}
   * @property {boolean} [autoDensity=false] - {@link PIXI.IRendererOptions.autoDensity}
   * @property {number} [backgroundAlpha=1] - {@link PIXI.IRendererOptions.backgroundAlpha}
   * @property {number} [backgroundColor=0x000000] - {@link PIXI.IRendererOptions.backgroundColor}
   * @property {boolean} [clearBeforeRender=true] - {@link PIXI.IRendererOptions.clearBeforeRender}
   * @property {number} [height=600] - {@link PIXI.IRendererOptions.height}
   * @property {boolean} [preserveDrawingBuffer=false] - {@link PIXI.IRendererOptions.preserveDrawingBuffer}
   * @property {boolean|'notMultiplied'} [useContextAlpha=true] - {@link PIXI.IRendererOptions.useContextAlpha}
   * @property {HTMLCanvasElement} [view=null] - {@link PIXI.IRendererOptions.view}
   * @property {number} [width=800] - {@link PIXI.IRendererOptions.width}
   */
  RENDER_OPTIONS: {
    view: null,
    width: 800,
    height: 600,
    autoDensity: !1,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: !0,
    clearBeforeRender: !0,
    antialias: !1,
    preserveDrawingBuffer: !1
  },
  /**
   * Default Garbage Collection mode.
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: Sn.AUTO,
  /**
   * Default Garbage Collection max idle.
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,
  /**
   * Default Garbage Collection maximum check count.
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,
  /**
   * Default wrap modes that are supported by pixi.
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: ke.CLAMP,
  /**
   * Default scale mode for textures.
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: Me.LINEAR,
  /**
   * Default specify float precision in vertex shader.
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.HIGH
   */
  PRECISION_VERTEX: ne.HIGH,
  /**
   * Default specify float precision in fragment shader.
   * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION_FRAGMENT: Re.apple.device ? ne.HIGH : ne.MEDIUM,
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: wu(),
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: !1,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: !1
}, Kn = { exports: {} }, ua;
function Eu() {
  return ua || (ua = 1, function(r) {
    var t = Object.prototype.hasOwnProperty, e = "~";
    function i() {
    }
    Object.create && (i.prototype = /* @__PURE__ */ Object.create(null), new i().__proto__ || (e = !1));
    function n(h, l, u) {
      this.fn = h, this.context = l, this.once = u || !1;
    }
    function s(h, l, u, c, f) {
      if (typeof u != "function")
        throw new TypeError("The listener must be a function");
      var d = new n(u, c || h, f), p = e ? e + l : l;
      return h._events[p] ? h._events[p].fn ? h._events[p] = [h._events[p], d] : h._events[p].push(d) : (h._events[p] = d, h._eventsCount++), h;
    }
    function o(h, l) {
      --h._eventsCount === 0 ? h._events = new i() : delete h._events[l];
    }
    function a() {
      this._events = new i(), this._eventsCount = 0;
    }
    a.prototype.eventNames = function() {
      var l = [], u, c;
      if (this._eventsCount === 0) return l;
      for (c in u = this._events)
        t.call(u, c) && l.push(e ? c.slice(1) : c);
      return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(u)) : l;
    }, a.prototype.listeners = function(l) {
      var u = e ? e + l : l, c = this._events[u];
      if (!c) return [];
      if (c.fn) return [c.fn];
      for (var f = 0, d = c.length, p = new Array(d); f < d; f++)
        p[f] = c[f].fn;
      return p;
    }, a.prototype.listenerCount = function(l) {
      var u = e ? e + l : l, c = this._events[u];
      return c ? c.fn ? 1 : c.length : 0;
    }, a.prototype.emit = function(l, u, c, f, d, p) {
      var v = e ? e + l : l;
      if (!this._events[v]) return !1;
      var _ = this._events[v], m = arguments.length, y, b;
      if (_.fn) {
        switch (_.once && this.removeListener(l, _.fn, void 0, !0), m) {
          case 1:
            return _.fn.call(_.context), !0;
          case 2:
            return _.fn.call(_.context, u), !0;
          case 3:
            return _.fn.call(_.context, u, c), !0;
          case 4:
            return _.fn.call(_.context, u, c, f), !0;
          case 5:
            return _.fn.call(_.context, u, c, f, d), !0;
          case 6:
            return _.fn.call(_.context, u, c, f, d, p), !0;
        }
        for (b = 1, y = new Array(m - 1); b < m; b++)
          y[b - 1] = arguments[b];
        _.fn.apply(_.context, y);
      } else {
        var P = _.length, x;
        for (b = 0; b < P; b++)
          switch (_[b].once && this.removeListener(l, _[b].fn, void 0, !0), m) {
            case 1:
              _[b].fn.call(_[b].context);
              break;
            case 2:
              _[b].fn.call(_[b].context, u);
              break;
            case 3:
              _[b].fn.call(_[b].context, u, c);
              break;
            case 4:
              _[b].fn.call(_[b].context, u, c, f);
              break;
            default:
              if (!y) for (x = 1, y = new Array(m - 1); x < m; x++)
                y[x - 1] = arguments[x];
              _[b].fn.apply(_[b].context, y);
          }
      }
      return !0;
    }, a.prototype.on = function(l, u, c) {
      return s(this, l, u, c, !1);
    }, a.prototype.once = function(l, u, c) {
      return s(this, l, u, c, !0);
    }, a.prototype.removeListener = function(l, u, c, f) {
      var d = e ? e + l : l;
      if (!this._events[d]) return this;
      if (!u)
        return o(this, d), this;
      var p = this._events[d];
      if (p.fn)
        p.fn === u && (!f || p.once) && (!c || p.context === c) && o(this, d);
      else {
        for (var v = 0, _ = [], m = p.length; v < m; v++)
          (p[v].fn !== u || f && !p[v].once || c && p[v].context !== c) && _.push(p[v]);
        _.length ? this._events[d] = _.length === 1 ? _[0] : _ : o(this, d);
      }
      return this;
    }, a.prototype.removeAllListeners = function(l) {
      var u;
      return l ? (u = e ? e + l : l, this._events[u] && o(this, u)) : (this._events = new i(), this._eventsCount = 0), this;
    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = e, a.EventEmitter = a, r.exports = a;
  }(Kn)), Kn.exports;
}
var Su = Eu();
const Pe = /* @__PURE__ */ Fn(Su);
var Lr = { exports: {} }, ca;
function Pu() {
  if (ca) return Lr.exports;
  ca = 1, Lr.exports = r, Lr.exports.default = r;
  function r(g, S, E) {
    E = E || 2;
    var M = S && S.length, N = M ? S[0] * E : g.length, k = t(g, 0, N, E, !0), B = [];
    if (!k || k.next === k.prev) return B;
    var H, Z, J, C, ut, X, xt;
    if (M && (k = h(g, S, k, E)), g.length > 80 * E) {
      H = J = g[0], Z = C = g[1];
      for (var lt = E; lt < N; lt += E)
        ut = g[lt], X = g[lt + 1], ut < H && (H = ut), X < Z && (Z = X), ut > J && (J = ut), X > C && (C = X);
      xt = Math.max(J - H, C - Z), xt = xt !== 0 ? 32767 / xt : 0;
    }
    return i(k, B, E, H, Z, xt, 0), B;
  }
  function t(g, S, E, M, N) {
    var k, B;
    if (N === Y(g, S, E, M) > 0)
      for (k = S; k < E; k += M) B = q(k, g[k], g[k + 1], B);
    else
      for (k = E - M; k >= S; k -= M) B = q(k, g[k], g[k + 1], B);
    return B && P(B, B.next) && (tt(B), B = B.next), B;
  }
  function e(g, S) {
    if (!g) return g;
    S || (S = g);
    var E = g, M;
    do
      if (M = !1, !E.steiner && (P(E, E.next) || b(E.prev, E, E.next) === 0)) {
        if (tt(E), E = S = E.prev, E === E.next) break;
        M = !0;
      } else
        E = E.next;
    while (M || E !== S);
    return S;
  }
  function i(g, S, E, M, N, k, B) {
    if (g) {
      !B && k && d(g, M, N, k);
      for (var H = g, Z, J; g.prev !== g.next; ) {
        if (Z = g.prev, J = g.next, k ? s(g, M, N, k) : n(g)) {
          S.push(Z.i / E | 0), S.push(g.i / E | 0), S.push(J.i / E | 0), tt(g), g = J.next, H = J.next;
          continue;
        }
        if (g = J, g === H) {
          B ? B === 1 ? (g = o(e(g), S, E), i(g, S, E, M, N, k, 2)) : B === 2 && a(g, S, E, M, N, k) : i(e(g), S, E, M, N, k, 1);
          break;
        }
      }
    }
  }
  function n(g) {
    var S = g.prev, E = g, M = g.next;
    if (b(S, E, M) >= 0) return !1;
    for (var N = S.x, k = E.x, B = M.x, H = S.y, Z = E.y, J = M.y, C = N < k ? N < B ? N : B : k < B ? k : B, ut = H < Z ? H < J ? H : J : Z < J ? Z : J, X = N > k ? N > B ? N : B : k > B ? k : B, xt = H > Z ? H > J ? H : J : Z > J ? Z : J, lt = M.next; lt !== S; ) {
      if (lt.x >= C && lt.x <= X && lt.y >= ut && lt.y <= xt && m(N, H, k, Z, B, J, lt.x, lt.y) && b(lt.prev, lt, lt.next) >= 0) return !1;
      lt = lt.next;
    }
    return !0;
  }
  function s(g, S, E, M) {
    var N = g.prev, k = g, B = g.next;
    if (b(N, k, B) >= 0) return !1;
    for (var H = N.x, Z = k.x, J = B.x, C = N.y, ut = k.y, X = B.y, xt = H < Z ? H < J ? H : J : Z < J ? Z : J, lt = C < ut ? C < X ? C : X : ut < X ? ut : X, V = H > Z ? H > J ? H : J : Z > J ? Z : J, Mt = C > ut ? C > X ? C : X : ut > X ? ut : X, ht = v(xt, lt, S, E, M), F = v(V, Mt, S, E, M), W = g.prevZ, et = g.nextZ; W && W.z >= ht && et && et.z <= F; ) {
      if (W.x >= xt && W.x <= V && W.y >= lt && W.y <= Mt && W !== N && W !== B && m(H, C, Z, ut, J, X, W.x, W.y) && b(W.prev, W, W.next) >= 0 || (W = W.prevZ, et.x >= xt && et.x <= V && et.y >= lt && et.y <= Mt && et !== N && et !== B && m(H, C, Z, ut, J, X, et.x, et.y) && b(et.prev, et, et.next) >= 0)) return !1;
      et = et.nextZ;
    }
    for (; W && W.z >= ht; ) {
      if (W.x >= xt && W.x <= V && W.y >= lt && W.y <= Mt && W !== N && W !== B && m(H, C, Z, ut, J, X, W.x, W.y) && b(W.prev, W, W.next) >= 0) return !1;
      W = W.prevZ;
    }
    for (; et && et.z <= F; ) {
      if (et.x >= xt && et.x <= V && et.y >= lt && et.y <= Mt && et !== N && et !== B && m(H, C, Z, ut, J, X, et.x, et.y) && b(et.prev, et, et.next) >= 0) return !1;
      et = et.nextZ;
    }
    return !0;
  }
  function o(g, S, E) {
    var M = g;
    do {
      var N = M.prev, k = M.next.next;
      !P(N, k) && x(N, M, M.next, k) && O(N, k) && O(k, N) && (S.push(N.i / E | 0), S.push(M.i / E | 0), S.push(k.i / E | 0), tt(M), tt(M.next), M = g = k), M = M.next;
    } while (M !== g);
    return e(M);
  }
  function a(g, S, E, M, N, k) {
    var B = g;
    do {
      for (var H = B.next.next; H !== B.prev; ) {
        if (B.i !== H.i && y(B, H)) {
          var Z = U(B, H);
          B = e(B, B.next), Z = e(Z, Z.next), i(B, S, E, M, N, k, 0), i(Z, S, E, M, N, k, 0);
          return;
        }
        H = H.next;
      }
      B = B.next;
    } while (B !== g);
  }
  function h(g, S, E, M) {
    var N = [], k, B, H, Z, J;
    for (k = 0, B = S.length; k < B; k++)
      H = S[k] * M, Z = k < B - 1 ? S[k + 1] * M : g.length, J = t(g, H, Z, M, !1), J === J.next && (J.steiner = !0), N.push(_(J));
    for (N.sort(l), k = 0; k < N.length; k++)
      E = u(N[k], E);
    return E;
  }
  function l(g, S) {
    return g.x - S.x;
  }
  function u(g, S) {
    var E = c(g, S);
    if (!E)
      return S;
    var M = U(E, g);
    return e(M, M.next), e(E, E.next);
  }
  function c(g, S) {
    var E = S, M = g.x, N = g.y, k = -1 / 0, B;
    do {
      if (N <= E.y && N >= E.next.y && E.next.y !== E.y) {
        var H = E.x + (N - E.y) * (E.next.x - E.x) / (E.next.y - E.y);
        if (H <= M && H > k && (k = H, B = E.x < E.next.x ? E : E.next, H === M))
          return B;
      }
      E = E.next;
    } while (E !== S);
    if (!B) return null;
    var Z = B, J = B.x, C = B.y, ut = 1 / 0, X;
    E = B;
    do
      M >= E.x && E.x >= J && M !== E.x && m(N < C ? M : k, N, J, C, N < C ? k : M, N, E.x, E.y) && (X = Math.abs(N - E.y) / (M - E.x), O(E, g) && (X < ut || X === ut && (E.x > B.x || E.x === B.x && f(B, E))) && (B = E, ut = X)), E = E.next;
    while (E !== Z);
    return B;
  }
  function f(g, S) {
    return b(g.prev, g, S.prev) < 0 && b(S.next, g, g.next) < 0;
  }
  function d(g, S, E, M) {
    var N = g;
    do
      N.z === 0 && (N.z = v(N.x, N.y, S, E, M)), N.prevZ = N.prev, N.nextZ = N.next, N = N.next;
    while (N !== g);
    N.prevZ.nextZ = null, N.prevZ = null, p(N);
  }
  function p(g) {
    var S, E, M, N, k, B, H, Z, J = 1;
    do {
      for (E = g, g = null, k = null, B = 0; E; ) {
        for (B++, M = E, H = 0, S = 0; S < J && (H++, M = M.nextZ, !!M); S++)
          ;
        for (Z = J; H > 0 || Z > 0 && M; )
          H !== 0 && (Z === 0 || !M || E.z <= M.z) ? (N = E, E = E.nextZ, H--) : (N = M, M = M.nextZ, Z--), k ? k.nextZ = N : g = N, N.prevZ = k, k = N;
        E = M;
      }
      k.nextZ = null, J *= 2;
    } while (B > 1);
    return g;
  }
  function v(g, S, E, M, N) {
    return g = (g - E) * N | 0, S = (S - M) * N | 0, g = (g | g << 8) & 16711935, g = (g | g << 4) & 252645135, g = (g | g << 2) & 858993459, g = (g | g << 1) & 1431655765, S = (S | S << 8) & 16711935, S = (S | S << 4) & 252645135, S = (S | S << 2) & 858993459, S = (S | S << 1) & 1431655765, g | S << 1;
  }
  function _(g) {
    var S = g, E = g;
    do
      (S.x < E.x || S.x === E.x && S.y < E.y) && (E = S), S = S.next;
    while (S !== g);
    return E;
  }
  function m(g, S, E, M, N, k, B, H) {
    return (N - B) * (S - H) >= (g - B) * (k - H) && (g - B) * (M - H) >= (E - B) * (S - H) && (E - B) * (k - H) >= (N - B) * (M - H);
  }
  function y(g, S) {
    return g.next.i !== S.i && g.prev.i !== S.i && !w(g, S) && // dones't intersect other edges
    (O(g, S) && O(S, g) && R(g, S) && // locally visible
    (b(g.prev, g, S.prev) || b(g, S.prev, S)) || // does not create opposite-facing sectors
    P(g, S) && b(g.prev, g, g.next) > 0 && b(S.prev, S, S.next) > 0);
  }
  function b(g, S, E) {
    return (S.y - g.y) * (E.x - S.x) - (S.x - g.x) * (E.y - S.y);
  }
  function P(g, S) {
    return g.x === S.x && g.y === S.y;
  }
  function x(g, S, E, M) {
    var N = I(b(g, S, E)), k = I(b(g, S, M)), B = I(b(E, M, g)), H = I(b(E, M, S));
    return !!(N !== k && B !== H || N === 0 && T(g, E, S) || k === 0 && T(g, M, S) || B === 0 && T(E, g, M) || H === 0 && T(E, S, M));
  }
  function T(g, S, E) {
    return S.x <= Math.max(g.x, E.x) && S.x >= Math.min(g.x, E.x) && S.y <= Math.max(g.y, E.y) && S.y >= Math.min(g.y, E.y);
  }
  function I(g) {
    return g > 0 ? 1 : g < 0 ? -1 : 0;
  }
  function w(g, S) {
    var E = g;
    do {
      if (E.i !== g.i && E.next.i !== g.i && E.i !== S.i && E.next.i !== S.i && x(E, E.next, g, S)) return !0;
      E = E.next;
    } while (E !== g);
    return !1;
  }
  function O(g, S) {
    return b(g.prev, g, g.next) < 0 ? b(g, S, g.next) >= 0 && b(g, g.prev, S) >= 0 : b(g, S, g.prev) < 0 || b(g, g.next, S) < 0;
  }
  function R(g, S) {
    var E = g, M = !1, N = (g.x + S.x) / 2, k = (g.y + S.y) / 2;
    do
      E.y > k != E.next.y > k && E.next.y !== E.y && N < (E.next.x - E.x) * (k - E.y) / (E.next.y - E.y) + E.x && (M = !M), E = E.next;
    while (E !== g);
    return M;
  }
  function U(g, S) {
    var E = new ct(g.i, g.x, g.y), M = new ct(S.i, S.x, S.y), N = g.next, k = S.prev;
    return g.next = S, S.prev = g, E.next = N, N.prev = E, M.next = E, E.prev = M, k.next = M, M.prev = k, M;
  }
  function q(g, S, E, M) {
    var N = new ct(g, S, E);
    return M ? (N.next = M.next, N.prev = M, M.next.prev = N, M.next = N) : (N.prev = N, N.next = N), N;
  }
  function tt(g) {
    g.next.prev = g.prev, g.prev.next = g.next, g.prevZ && (g.prevZ.nextZ = g.nextZ), g.nextZ && (g.nextZ.prevZ = g.prevZ);
  }
  function ct(g, S, E) {
    this.i = g, this.x = S, this.y = E, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
  }
  r.deviation = function(g, S, E, M) {
    var N = S && S.length, k = N ? S[0] * E : g.length, B = Math.abs(Y(g, 0, k, E));
    if (N)
      for (var H = 0, Z = S.length; H < Z; H++) {
        var J = S[H] * E, C = H < Z - 1 ? S[H + 1] * E : g.length;
        B -= Math.abs(Y(g, J, C, E));
      }
    var ut = 0;
    for (H = 0; H < M.length; H += 3) {
      var X = M[H] * E, xt = M[H + 1] * E, lt = M[H + 2] * E;
      ut += Math.abs(
        (g[X] - g[lt]) * (g[xt + 1] - g[X + 1]) - (g[X] - g[xt]) * (g[lt + 1] - g[X + 1])
      );
    }
    return B === 0 && ut === 0 ? 0 : Math.abs((ut - B) / B);
  };
  function Y(g, S, E, M) {
    for (var N = 0, k = S, B = E - M; k < E; k += M)
      N += (g[B] - g[k]) * (g[k + 1] + g[B + 1]), B = k;
    return N;
  }
  return r.flatten = function(g) {
    for (var S = g[0][0].length, E = { vertices: [], holes: [], dimensions: S }, M = 0, N = 0; N < g.length; N++) {
      for (var k = 0; k < g[N].length; k++)
        for (var B = 0; B < S; B++) E.vertices.push(g[N][k][B]);
      N > 0 && (M += g[N - 1].length, E.holes.push(M));
    }
    return E;
  }, Lr.exports;
}
var Cu = Pu();
const Ih = /* @__PURE__ */ Fn(Cu);
/*!
 * @pixi/utils - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Ni = {
  parse: Jl,
  format: tu,
  resolve: Ql
};
K.RETINA_PREFIX = /@([0-9\.]+)x/;
K.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var ks = !1, fa = "6.5.10";
function Iu() {
  ks = !0;
}
function Ou(r) {
  var t;
  if (!ks) {
    if (K.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      var e = [
        `
 %c %c %c PixiJS ` + fa + " - ✰ " + r + ` ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ 

`,
        "background: #ff66a5; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff66a5; background: #030307; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "background: #ffc3dc; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;"
      ];
      (t = globalThis.console).log.apply(t, e);
    } else globalThis.console && globalThis.console.log("PixiJS " + fa + " - " + r + " - http://www.pixijs.com/");
    ks = !0;
  }
}
var Jn;
function Mu() {
  return typeof Jn > "u" && (Jn = function() {
    var t = {
      stencil: !0,
      failIfMajorPerformanceCaveat: K.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
    };
    try {
      if (!K.ADAPTER.getWebGLRenderingContext())
        return !1;
      var e = K.ADAPTER.createCanvas(), i = e.getContext("webgl", t) || e.getContext("experimental-webgl", t), n = !!(i && i.getContextAttributes().stencil);
      if (i) {
        var s = i.getExtension("WEBGL_lose_context");
        s && s.loseContext();
      }
      return i = null, n;
    } catch {
      return !1;
    }
  }()), Jn;
}
var Ru = "#f0f8ff", ku = "#faebd7", Nu = "#00ffff", Au = "#7fffd4", Du = "#f0ffff", Lu = "#f5f5dc", Fu = "#ffe4c4", Bu = "#000000", Uu = "#ffebcd", Gu = "#0000ff", ju = "#8a2be2", Hu = "#a52a2a", $u = "#deb887", zu = "#5f9ea0", Xu = "#7fff00", Vu = "#d2691e", Wu = "#ff7f50", Yu = "#6495ed", qu = "#fff8dc", Zu = "#dc143c", Ku = "#00ffff", Ju = "#00008b", Qu = "#008b8b", tc = "#b8860b", ec = "#a9a9a9", ic = "#006400", rc = "#a9a9a9", nc = "#bdb76b", sc = "#8b008b", oc = "#556b2f", ac = "#ff8c00", hc = "#9932cc", lc = "#8b0000", uc = "#e9967a", cc = "#8fbc8f", fc = "#483d8b", dc = "#2f4f4f", pc = "#2f4f4f", vc = "#00ced1", _c = "#9400d3", mc = "#ff1493", yc = "#00bfff", gc = "#696969", bc = "#696969", xc = "#1e90ff", wc = "#b22222", Tc = "#fffaf0", Ec = "#228b22", Sc = "#ff00ff", Pc = "#dcdcdc", Cc = "#f8f8ff", Ic = "#daa520", Oc = "#ffd700", Mc = "#808080", Rc = "#008000", kc = "#adff2f", Nc = "#808080", Ac = "#f0fff0", Dc = "#ff69b4", Lc = "#cd5c5c", Fc = "#4b0082", Bc = "#fffff0", Uc = "#f0e68c", Gc = "#fff0f5", jc = "#e6e6fa", Hc = "#7cfc00", $c = "#fffacd", zc = "#add8e6", Xc = "#f08080", Vc = "#e0ffff", Wc = "#fafad2", Yc = "#d3d3d3", qc = "#90ee90", Zc = "#d3d3d3", Kc = "#ffb6c1", Jc = "#ffa07a", Qc = "#20b2aa", tf = "#87cefa", ef = "#778899", rf = "#778899", nf = "#b0c4de", sf = "#ffffe0", of = "#00ff00", af = "#32cd32", hf = "#faf0e6", lf = "#ff00ff", uf = "#800000", cf = "#66cdaa", ff = "#0000cd", df = "#ba55d3", pf = "#9370db", vf = "#3cb371", _f = "#7b68ee", mf = "#00fa9a", yf = "#48d1cc", gf = "#c71585", bf = "#191970", xf = "#f5fffa", wf = "#ffe4e1", Tf = "#ffe4b5", Ef = "#ffdead", Sf = "#000080", Pf = "#fdf5e6", Cf = "#808000", If = "#6b8e23", Of = "#ffa500", Mf = "#ff4500", Rf = "#da70d6", kf = "#eee8aa", Nf = "#98fb98", Af = "#afeeee", Df = "#db7093", Lf = "#ffefd5", Ff = "#ffdab9", Bf = "#cd853f", Uf = "#ffc0cb", Gf = "#dda0dd", jf = "#b0e0e6", Hf = "#800080", $f = "#663399", zf = "#ff0000", Xf = "#bc8f8f", Vf = "#4169e1", Wf = "#8b4513", Yf = "#fa8072", qf = "#f4a460", Zf = "#2e8b57", Kf = "#fff5ee", Jf = "#a0522d", Qf = "#c0c0c0", td = "#87ceeb", ed = "#6a5acd", id = "#708090", rd = "#708090", nd = "#fffafa", sd = "#00ff7f", od = "#4682b4", ad = "#d2b48c", hd = "#008080", ld = "#d8bfd8", ud = "#ff6347", cd = "#40e0d0", fd = "#ee82ee", dd = "#f5deb3", pd = "#ffffff", vd = "#f5f5f5", _d = "#ffff00", md = "#9acd32", yd = {
  aliceblue: Ru,
  antiquewhite: ku,
  aqua: Nu,
  aquamarine: Au,
  azure: Du,
  beige: Lu,
  bisque: Fu,
  black: Bu,
  blanchedalmond: Uu,
  blue: Gu,
  blueviolet: ju,
  brown: Hu,
  burlywood: $u,
  cadetblue: zu,
  chartreuse: Xu,
  chocolate: Vu,
  coral: Wu,
  cornflowerblue: Yu,
  cornsilk: qu,
  crimson: Zu,
  cyan: Ku,
  darkblue: Ju,
  darkcyan: Qu,
  darkgoldenrod: tc,
  darkgray: ec,
  darkgreen: ic,
  darkgrey: rc,
  darkkhaki: nc,
  darkmagenta: sc,
  darkolivegreen: oc,
  darkorange: ac,
  darkorchid: hc,
  darkred: lc,
  darksalmon: uc,
  darkseagreen: cc,
  darkslateblue: fc,
  darkslategray: dc,
  darkslategrey: pc,
  darkturquoise: vc,
  darkviolet: _c,
  deeppink: mc,
  deepskyblue: yc,
  dimgray: gc,
  dimgrey: bc,
  dodgerblue: xc,
  firebrick: wc,
  floralwhite: Tc,
  forestgreen: Ec,
  fuchsia: Sc,
  gainsboro: Pc,
  ghostwhite: Cc,
  goldenrod: Ic,
  gold: Oc,
  gray: Mc,
  green: Rc,
  greenyellow: kc,
  grey: Nc,
  honeydew: Ac,
  hotpink: Dc,
  indianred: Lc,
  indigo: Fc,
  ivory: Bc,
  khaki: Uc,
  lavenderblush: Gc,
  lavender: jc,
  lawngreen: Hc,
  lemonchiffon: $c,
  lightblue: zc,
  lightcoral: Xc,
  lightcyan: Vc,
  lightgoldenrodyellow: Wc,
  lightgray: Yc,
  lightgreen: qc,
  lightgrey: Zc,
  lightpink: Kc,
  lightsalmon: Jc,
  lightseagreen: Qc,
  lightskyblue: tf,
  lightslategray: ef,
  lightslategrey: rf,
  lightsteelblue: nf,
  lightyellow: sf,
  lime: of,
  limegreen: af,
  linen: hf,
  magenta: lf,
  maroon: uf,
  mediumaquamarine: cf,
  mediumblue: ff,
  mediumorchid: df,
  mediumpurple: pf,
  mediumseagreen: vf,
  mediumslateblue: _f,
  mediumspringgreen: mf,
  mediumturquoise: yf,
  mediumvioletred: gf,
  midnightblue: bf,
  mintcream: xf,
  mistyrose: wf,
  moccasin: Tf,
  navajowhite: Ef,
  navy: Sf,
  oldlace: Pf,
  olive: Cf,
  olivedrab: If,
  orange: Of,
  orangered: Mf,
  orchid: Rf,
  palegoldenrod: kf,
  palegreen: Nf,
  paleturquoise: Af,
  palevioletred: Df,
  papayawhip: Lf,
  peachpuff: Ff,
  peru: Bf,
  pink: Uf,
  plum: Gf,
  powderblue: jf,
  purple: Hf,
  rebeccapurple: $f,
  red: zf,
  rosybrown: Xf,
  royalblue: Vf,
  saddlebrown: Wf,
  salmon: Yf,
  sandybrown: qf,
  seagreen: Zf,
  seashell: Kf,
  sienna: Jf,
  silver: Qf,
  skyblue: td,
  slateblue: ed,
  slategray: id,
  slategrey: rd,
  snow: nd,
  springgreen: sd,
  steelblue: od,
  tan: ad,
  teal: hd,
  thistle: ld,
  tomato: ud,
  turquoise: cd,
  violet: fd,
  wheat: dd,
  white: pd,
  whitesmoke: vd,
  yellow: _d,
  yellowgreen: md
};
function Gi(r, t) {
  return t === void 0 && (t = []), t[0] = (r >> 16 & 255) / 255, t[1] = (r >> 8 & 255) / 255, t[2] = (r & 255) / 255, t;
}
function Oh(r) {
  var t = r.toString(16);
  return t = "000000".substring(0, 6 - t.length) + t, "#" + t;
}
function Mh(r) {
  return typeof r == "string" && (r = yd[r.toLowerCase()] || r, r[0] === "#" && (r = r.slice(1))), parseInt(r, 16);
}
function gd() {
  for (var r = [], t = [], e = 0; e < 32; e++)
    r[e] = e, t[e] = e;
  r[it.NORMAL_NPM] = it.NORMAL, r[it.ADD_NPM] = it.ADD, r[it.SCREEN_NPM] = it.SCREEN, t[it.NORMAL] = it.NORMAL_NPM, t[it.ADD] = it.ADD_NPM, t[it.SCREEN] = it.SCREEN_NPM;
  var i = [];
  return i.push(t), i.push(r), i;
}
var Rh = gd();
function kh(r, t) {
  return Rh[t ? 1 : 0][r];
}
function bd(r, t, e, i) {
  return e = e || new Float32Array(4), i || i === void 0 ? (e[0] = r[0] * t, e[1] = r[1] * t, e[2] = r[2] * t) : (e[0] = r[0], e[1] = r[1], e[2] = r[2]), e[3] = t, e;
}
function Io(r, t) {
  if (t === 1)
    return (t * 255 << 24) + r;
  if (t === 0)
    return 0;
  var e = r >> 16 & 255, i = r >> 8 & 255, n = r & 255;
  return e = e * t + 0.5 | 0, i = i * t + 0.5 | 0, n = n * t + 0.5 | 0, (t * 255 << 24) + (e << 16) + (i << 8) + n;
}
function Nh(r, t, e, i) {
  return e = e || new Float32Array(4), e[0] = (r >> 16 & 255) / 255, e[1] = (r >> 8 & 255) / 255, e[2] = (r & 255) / 255, (i || i === void 0) && (e[0] *= t, e[1] *= t, e[2] *= t), e[3] = t, e;
}
function xd(r, t) {
  t === void 0 && (t = null);
  var e = r * 6;
  if (t = t || new Uint16Array(e), t.length !== e)
    throw new Error("Out buffer length is incorrect, got " + t.length + " and expected " + e);
  for (var i = 0, n = 0; i < e; i += 6, n += 4)
    t[i + 0] = n + 0, t[i + 1] = n + 1, t[i + 2] = n + 2, t[i + 3] = n + 0, t[i + 4] = n + 2, t[i + 5] = n + 3;
  return t;
}
function Ah(r) {
  if (r.BYTES_PER_ELEMENT === 4)
    return r instanceof Float32Array ? "Float32Array" : r instanceof Uint32Array ? "Uint32Array" : "Int32Array";
  if (r.BYTES_PER_ELEMENT === 2) {
    if (r instanceof Uint16Array)
      return "Uint16Array";
  } else if (r.BYTES_PER_ELEMENT === 1 && r instanceof Uint8Array)
    return "Uint8Array";
  return null;
}
function Pn(r) {
  return r += r === 0 ? 1 : 0, --r, r |= r >>> 1, r |= r >>> 2, r |= r >>> 4, r |= r >>> 8, r |= r >>> 16, r + 1;
}
function da(r) {
  return !(r & r - 1) && !!r;
}
function pa(r) {
  var t = (r > 65535 ? 1 : 0) << 4;
  r >>>= t;
  var e = (r > 255 ? 1 : 0) << 3;
  return r >>>= e, t |= e, e = (r > 15 ? 1 : 0) << 2, r >>>= e, t |= e, e = (r > 3 ? 1 : 0) << 1, r >>>= e, t |= e, t | r >> 1;
}
function Fi(r, t, e) {
  var i = r.length, n;
  if (!(t >= i || e === 0)) {
    e = t + e > i ? i - t : e;
    var s = i - e;
    for (n = t; n < s; ++n)
      r[n] = r[n + e];
    r.length = s;
  }
}
function Ai(r) {
  return r === 0 ? 0 : r < 0 ? -1 : 1;
}
var wd = 0;
function Pi() {
  return ++wd;
}
var va = {};
function Te(r, t, e) {
  if (e === void 0 && (e = 3), !va[t]) {
    var i = new Error().stack;
    typeof i > "u" ? console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + r) : (i = i.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", t + `
Deprecated since v` + r), console.warn(i), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + r), console.warn(i))), va[t] = !0;
  }
}
var _a = {}, Qt = /* @__PURE__ */ Object.create(null), ze = /* @__PURE__ */ Object.create(null);
function Dh() {
  var r;
  for (r in Qt)
    delete Qt[r];
  for (r in ze)
    delete ze[r];
}
var ma = (
  /** @class */
  function() {
    function r(t, e, i) {
      this.canvas = K.ADAPTER.createCanvas(), this.context = this.canvas.getContext("2d"), this.resolution = i || K.RESOLUTION, this.resize(t, e);
    }
    return r.prototype.clear = function() {
      this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }, r.prototype.resize = function(t, e) {
      this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);
    }, r.prototype.destroy = function() {
      this.context = null, this.canvas = null;
    }, Object.defineProperty(r.prototype, "width", {
      /**
       * The width of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.width;
      },
      set: function(t) {
        this.canvas.width = Math.round(t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "height", {
      /**
       * The height of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.height;
      },
      set: function(t) {
        this.canvas.height = Math.round(t);
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
);
function Td(r) {
  var t = r.width, e = r.height, i = r.getContext("2d", {
    willReadFrequently: !0
  }), n = i.getImageData(0, 0, t, e), s = n.data, o = s.length, a = {
    top: null,
    left: null,
    right: null,
    bottom: null
  }, h = null, l, u, c;
  for (l = 0; l < o; l += 4)
    s[l + 3] !== 0 && (u = l / 4 % t, c = ~~(l / 4 / t), a.top === null && (a.top = c), (a.left === null || u < a.left) && (a.left = u), (a.right === null || a.right < u) && (a.right = u + 1), (a.bottom === null || a.bottom < c) && (a.bottom = c));
  return a.top !== null && (t = a.right - a.left, e = a.bottom - a.top + 1, h = i.getImageData(a.left, a.top, t, e)), {
    height: e,
    width: t,
    data: h
  };
}
var Fr;
function Ed(r, t) {
  if (t === void 0 && (t = globalThis.location), r.indexOf("data:") === 0)
    return "";
  t = t || globalThis.location, Fr || (Fr = document.createElement("a")), Fr.href = r;
  var e = Ni.parse(Fr.href), i = !e.port && t.port === "" || e.port === t.port;
  return e.hostname !== t.hostname || !i || e.protocol !== t.protocol ? "anonymous" : "";
}
function Cn(r, t) {
  var e = K.RETINA_PREFIX.exec(r);
  return e ? parseFloat(e[1]) : t !== void 0 ? t : 1;
}
/*!
 * @pixi/math - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var In = Math.PI * 2, Sd = 180 / Math.PI, Pd = Math.PI / 180, Yt;
(function(r) {
  r[r.POLY = 0] = "POLY", r[r.RECT = 1] = "RECT", r[r.CIRC = 2] = "CIRC", r[r.ELIP = 3] = "ELIP", r[r.RREC = 4] = "RREC";
})(Yt || (Yt = {}));
var Ot = (
  /** @class */
  function() {
    function r(t, e) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e;
    }
    return r.prototype.clone = function() {
      return new r(this.x, this.y);
    }, r.prototype.copyFrom = function(t) {
      return this.set(t.x, t.y), this;
    }, r.prototype.copyTo = function(t) {
      return t.set(this.x, this.y), t;
    }, r.prototype.equals = function(t) {
      return t.x === this.x && t.y === this.y;
    }, r.prototype.set = function(t, e) {
      return t === void 0 && (t = 0), e === void 0 && (e = t), this.x = t, this.y = e, this;
    }, r.prototype.toString = function() {
      return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
    }, r;
  }()
), Br = [new Ot(), new Ot(), new Ot(), new Ot()], dt = (
  /** @class */
  function() {
    function r(t, e, i, n) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), i === void 0 && (i = 0), n === void 0 && (n = 0), this.x = Number(t), this.y = Number(e), this.width = Number(i), this.height = Number(n), this.type = Yt.RECT;
    }
    return Object.defineProperty(r.prototype, "left", {
      /** Returns the left edge of the rectangle. */
      get: function() {
        return this.x;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "right", {
      /** Returns the right edge of the rectangle. */
      get: function() {
        return this.x + this.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "top", {
      /** Returns the top edge of the rectangle. */
      get: function() {
        return this.y;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "bottom", {
      /** Returns the bottom edge of the rectangle. */
      get: function() {
        return this.y + this.height;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "EMPTY", {
      /** A constant empty rectangle. */
      get: function() {
        return new r(0, 0, 0, 0);
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.clone = function() {
      return new r(this.x, this.y, this.width, this.height);
    }, r.prototype.copyFrom = function(t) {
      return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
    }, r.prototype.copyTo = function(t) {
      return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
    }, r.prototype.contains = function(t, e) {
      return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
    }, r.prototype.intersects = function(t, e) {
      if (!e) {
        var i = this.x < t.x ? t.x : this.x, n = this.right > t.right ? t.right : this.right;
        if (n <= i)
          return !1;
        var s = this.y < t.y ? t.y : this.y, o = this.bottom > t.bottom ? t.bottom : this.bottom;
        return o > s;
      }
      var a = this.left, h = this.right, l = this.top, u = this.bottom;
      if (h <= a || u <= l)
        return !1;
      var c = Br[0].set(t.left, t.top), f = Br[1].set(t.left, t.bottom), d = Br[2].set(t.right, t.top), p = Br[3].set(t.right, t.bottom);
      if (d.x <= c.x || f.y <= c.y)
        return !1;
      var v = Math.sign(e.a * e.d - e.b * e.c);
      if (v === 0 || (e.apply(c, c), e.apply(f, f), e.apply(d, d), e.apply(p, p), Math.max(c.x, f.x, d.x, p.x) <= a || Math.min(c.x, f.x, d.x, p.x) >= h || Math.max(c.y, f.y, d.y, p.y) <= l || Math.min(c.y, f.y, d.y, p.y) >= u))
        return !1;
      var _ = v * (f.y - c.y), m = v * (c.x - f.x), y = _ * a + m * l, b = _ * h + m * l, P = _ * a + m * u, x = _ * h + m * u;
      if (Math.max(y, b, P, x) <= _ * c.x + m * c.y || Math.min(y, b, P, x) >= _ * p.x + m * p.y)
        return !1;
      var T = v * (c.y - d.y), I = v * (d.x - c.x), w = T * a + I * l, O = T * h + I * l, R = T * a + I * u, U = T * h + I * u;
      return !(Math.max(w, O, R, U) <= T * c.x + I * c.y || Math.min(w, O, R, U) >= T * p.x + I * p.y);
    }, r.prototype.pad = function(t, e) {
      return t === void 0 && (t = 0), e === void 0 && (e = t), this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
    }, r.prototype.fit = function(t) {
      var e = Math.max(this.x, t.x), i = Math.min(this.x + this.width, t.x + t.width), n = Math.max(this.y, t.y), s = Math.min(this.y + this.height, t.y + t.height);
      return this.x = e, this.width = Math.max(i - e, 0), this.y = n, this.height = Math.max(s - n, 0), this;
    }, r.prototype.ceil = function(t, e) {
      t === void 0 && (t = 1), e === void 0 && (e = 1e-3);
      var i = Math.ceil((this.x + this.width - e) * t) / t, n = Math.ceil((this.y + this.height - e) * t) / t;
      return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = i - this.x, this.height = n - this.y, this;
    }, r.prototype.enlarge = function(t) {
      var e = Math.min(this.x, t.x), i = Math.max(this.x + this.width, t.x + t.width), n = Math.min(this.y, t.y), s = Math.max(this.y + this.height, t.y + t.height);
      return this.x = e, this.width = i - e, this.y = n, this.height = s - n, this;
    }, r.prototype.toString = function() {
      return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    }, r;
  }()
), Cd = (
  /** @class */
  function() {
    function r(t, e, i) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), i === void 0 && (i = 0), this.x = t, this.y = e, this.radius = i, this.type = Yt.CIRC;
    }
    return r.prototype.clone = function() {
      return new r(this.x, this.y, this.radius);
    }, r.prototype.contains = function(t, e) {
      if (this.radius <= 0)
        return !1;
      var i = this.radius * this.radius, n = this.x - t, s = this.y - e;
      return n *= n, s *= s, n + s <= i;
    }, r.prototype.getBounds = function() {
      return new dt(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }, r.prototype.toString = function() {
      return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
    }, r;
  }()
), Id = (
  /** @class */
  function() {
    function r(t, e, i, n) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), i === void 0 && (i = 0), n === void 0 && (n = 0), this.x = t, this.y = e, this.width = i, this.height = n, this.type = Yt.ELIP;
    }
    return r.prototype.clone = function() {
      return new r(this.x, this.y, this.width, this.height);
    }, r.prototype.contains = function(t, e) {
      if (this.width <= 0 || this.height <= 0)
        return !1;
      var i = (t - this.x) / this.width, n = (e - this.y) / this.height;
      return i *= i, n *= n, i + n <= 1;
    }, r.prototype.getBounds = function() {
      return new dt(this.x - this.width, this.y - this.height, this.width, this.height);
    }, r.prototype.toString = function() {
      return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    }, r;
  }()
), cn = (
  /** @class */
  function() {
    function r() {
      for (var t = arguments, e = [], i = 0; i < arguments.length; i++)
        e[i] = t[i];
      var n = Array.isArray(e[0]) ? e[0] : e;
      if (typeof n[0] != "number") {
        for (var s = [], o = 0, a = n.length; o < a; o++)
          s.push(n[o].x, n[o].y);
        n = s;
      }
      this.points = n, this.type = Yt.POLY, this.closeStroke = !0;
    }
    return r.prototype.clone = function() {
      var t = this.points.slice(), e = new r(t);
      return e.closeStroke = this.closeStroke, e;
    }, r.prototype.contains = function(t, e) {
      for (var i = !1, n = this.points.length / 2, s = 0, o = n - 1; s < n; o = s++) {
        var a = this.points[s * 2], h = this.points[s * 2 + 1], l = this.points[o * 2], u = this.points[o * 2 + 1], c = h > e != u > e && t < (l - a) * ((e - h) / (u - h)) + a;
        c && (i = !i);
      }
      return i;
    }, r.prototype.toString = function() {
      return "[@pixi/math:Polygon" + ("closeStroke=" + this.closeStroke) + ("points=" + this.points.reduce(function(t, e) {
        return t + ", " + e;
      }, "") + "]");
    }, r;
  }()
), Od = (
  /** @class */
  function() {
    function r(t, e, i, n, s) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), i === void 0 && (i = 0), n === void 0 && (n = 0), s === void 0 && (s = 20), this.x = t, this.y = e, this.width = i, this.height = n, this.radius = s, this.type = Yt.RREC;
    }
    return r.prototype.clone = function() {
      return new r(this.x, this.y, this.width, this.height, this.radius);
    }, r.prototype.contains = function(t, e) {
      if (this.width <= 0 || this.height <= 0)
        return !1;
      if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
        var i = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (e >= this.y + i && e <= this.y + this.height - i || t >= this.x + i && t <= this.x + this.width - i)
          return !0;
        var n = t - (this.x + i), s = e - (this.y + i), o = i * i;
        if (n * n + s * s <= o || (n = t - (this.x + this.width - i), n * n + s * s <= o) || (s = e - (this.y + this.height - i), n * n + s * s <= o) || (n = t - (this.x + i), n * n + s * s <= o))
          return !0;
      }
      return !1;
    }, r.prototype.toString = function() {
      return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + ("width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]");
    }, r;
  }()
), Di = (
  /** @class */
  function() {
    function r(t, e, i, n) {
      i === void 0 && (i = 0), n === void 0 && (n = 0), this._x = i, this._y = n, this.cb = t, this.scope = e;
    }
    return r.prototype.clone = function(t, e) {
      return t === void 0 && (t = this.cb), e === void 0 && (e = this.scope), new r(t, e, this._x, this._y);
    }, r.prototype.set = function(t, e) {
      return t === void 0 && (t = 0), e === void 0 && (e = t), (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this.cb.call(this.scope)), this;
    }, r.prototype.copyFrom = function(t) {
      return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this;
    }, r.prototype.copyTo = function(t) {
      return t.set(this._x, this._y), t;
    }, r.prototype.equals = function(t) {
      return t.x === this._x && t.y === this._y;
    }, r.prototype.toString = function() {
      return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
    }, Object.defineProperty(r.prototype, "x", {
      /** Position of the observable point on the x axis. */
      get: function() {
        return this._x;
      },
      set: function(t) {
        this._x !== t && (this._x = t, this.cb.call(this.scope));
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "y", {
      /** Position of the observable point on the y axis. */
      get: function() {
        return this._y;
      },
      set: function(t) {
        this._y !== t && (this._y = t, this.cb.call(this.scope));
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
), Vt = (
  /** @class */
  function() {
    function r(t, e, i, n, s, o) {
      t === void 0 && (t = 1), e === void 0 && (e = 0), i === void 0 && (i = 0), n === void 0 && (n = 1), s === void 0 && (s = 0), o === void 0 && (o = 0), this.array = null, this.a = t, this.b = e, this.c = i, this.d = n, this.tx = s, this.ty = o;
    }
    return r.prototype.fromArray = function(t) {
      this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
    }, r.prototype.set = function(t, e, i, n, s, o) {
      return this.a = t, this.b = e, this.c = i, this.d = n, this.tx = s, this.ty = o, this;
    }, r.prototype.toArray = function(t, e) {
      this.array || (this.array = new Float32Array(9));
      var i = e || this.array;
      return t ? (i[0] = this.a, i[1] = this.b, i[2] = 0, i[3] = this.c, i[4] = this.d, i[5] = 0, i[6] = this.tx, i[7] = this.ty, i[8] = 1) : (i[0] = this.a, i[1] = this.c, i[2] = this.tx, i[3] = this.b, i[4] = this.d, i[5] = this.ty, i[6] = 0, i[7] = 0, i[8] = 1), i;
    }, r.prototype.apply = function(t, e) {
      e = e || new Ot();
      var i = t.x, n = t.y;
      return e.x = this.a * i + this.c * n + this.tx, e.y = this.b * i + this.d * n + this.ty, e;
    }, r.prototype.applyInverse = function(t, e) {
      e = e || new Ot();
      var i = 1 / (this.a * this.d + this.c * -this.b), n = t.x, s = t.y;
      return e.x = this.d * i * n + -this.c * i * s + (this.ty * this.c - this.tx * this.d) * i, e.y = this.a * i * s + -this.b * i * n + (-this.ty * this.a + this.tx * this.b) * i, e;
    }, r.prototype.translate = function(t, e) {
      return this.tx += t, this.ty += e, this;
    }, r.prototype.scale = function(t, e) {
      return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
    }, r.prototype.rotate = function(t) {
      var e = Math.cos(t), i = Math.sin(t), n = this.a, s = this.c, o = this.tx;
      return this.a = n * e - this.b * i, this.b = n * i + this.b * e, this.c = s * e - this.d * i, this.d = s * i + this.d * e, this.tx = o * e - this.ty * i, this.ty = o * i + this.ty * e, this;
    }, r.prototype.append = function(t) {
      var e = this.a, i = this.b, n = this.c, s = this.d;
      return this.a = t.a * e + t.b * n, this.b = t.a * i + t.b * s, this.c = t.c * e + t.d * n, this.d = t.c * i + t.d * s, this.tx = t.tx * e + t.ty * n + this.tx, this.ty = t.tx * i + t.ty * s + this.ty, this;
    }, r.prototype.setTransform = function(t, e, i, n, s, o, a, h, l) {
      return this.a = Math.cos(a + l) * s, this.b = Math.sin(a + l) * s, this.c = -Math.sin(a - h) * o, this.d = Math.cos(a - h) * o, this.tx = t - (i * this.a + n * this.c), this.ty = e - (i * this.b + n * this.d), this;
    }, r.prototype.prepend = function(t) {
      var e = this.tx;
      if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
        var i = this.a, n = this.c;
        this.a = i * t.a + this.b * t.c, this.b = i * t.b + this.b * t.d, this.c = n * t.a + this.d * t.c, this.d = n * t.b + this.d * t.d;
      }
      return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
    }, r.prototype.decompose = function(t) {
      var e = this.a, i = this.b, n = this.c, s = this.d, o = t.pivot, a = -Math.atan2(-n, s), h = Math.atan2(i, e), l = Math.abs(a + h);
      return l < 1e-5 || Math.abs(In - l) < 1e-5 ? (t.rotation = h, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = a, t.skew.y = h), t.scale.x = Math.sqrt(e * e + i * i), t.scale.y = Math.sqrt(n * n + s * s), t.position.x = this.tx + (o.x * e + o.y * n), t.position.y = this.ty + (o.x * i + o.y * s), t;
    }, r.prototype.invert = function() {
      var t = this.a, e = this.b, i = this.c, n = this.d, s = this.tx, o = t * n - e * i;
      return this.a = n / o, this.b = -e / o, this.c = -i / o, this.d = t / o, this.tx = (i * this.ty - n * s) / o, this.ty = -(t * this.ty - e * s) / o, this;
    }, r.prototype.identity = function() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }, r.prototype.clone = function() {
      var t = new r();
      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
    }, r.prototype.copyTo = function(t) {
      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
    }, r.prototype.copyFrom = function(t) {
      return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
    }, r.prototype.toString = function() {
      return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
    }, Object.defineProperty(r, "IDENTITY", {
      /**
       * A default (identity) matrix
       * @readonly
       */
      get: function() {
        return new r();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "TEMP_MATRIX", {
      /**
       * A temp matrix
       * @readonly
       */
      get: function() {
        return new r();
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
), mi = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], yi = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], gi = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], bi = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], Ns = [], Lh = [], Ur = Math.sign;
function Md() {
  for (var r = 0; r < 16; r++) {
    var t = [];
    Ns.push(t);
    for (var e = 0; e < 16; e++)
      for (var i = Ur(mi[r] * mi[e] + gi[r] * yi[e]), n = Ur(yi[r] * mi[e] + bi[r] * yi[e]), s = Ur(mi[r] * gi[e] + gi[r] * bi[e]), o = Ur(yi[r] * gi[e] + bi[r] * bi[e]), a = 0; a < 16; a++)
        if (mi[a] === i && yi[a] === n && gi[a] === s && bi[a] === o) {
          t.push(a);
          break;
        }
  }
  for (var r = 0; r < 16; r++) {
    var h = new Vt();
    h.set(mi[r], yi[r], gi[r], bi[r], 0, 0), Lh.push(h);
  }
}
Md();
var kt = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: function(r) {
    return mi[r];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: function(r) {
    return yi[r];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: function(r) {
    return gi[r];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: function(r) {
    return bi[r];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: function(r) {
    return r & 8 ? r & 15 : -r & 7;
  },
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {PIXI.GD8Symmetry} Composed operation
   */
  add: function(r, t) {
    return Ns[r][t];
  },
  /**
   * Reverse of `add`.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @returns {PIXI.GD8Symmetry} Result
   */
  sub: function(r, t) {
    return Ns[r][kt.inv(t)];
  },
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @memberof PIXI.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: function(r) {
    return r ^ 4;
  },
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: function(r) {
    return (r & 3) === 2;
  },
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @memberof PIXI.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: function(r, t) {
    return Math.abs(r) * 2 <= Math.abs(t) ? t >= 0 ? kt.S : kt.N : Math.abs(t) * 2 <= Math.abs(r) ? r > 0 ? kt.E : kt.W : t > 0 ? r > 0 ? kt.SE : kt.SW : r > 0 ? kt.NE : kt.NW;
  },
  /**
   * Helps sprite to compensate texture packer rotation.
   * @memberof PIXI.groupD8
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: function(r, t, e, i) {
    e === void 0 && (e = 0), i === void 0 && (i = 0);
    var n = Lh[kt.inv(t)];
    n.tx = e, n.ty = i, r.append(n);
  }
}, Fh = (
  /** @class */
  function() {
    function r() {
      this.worldTransform = new Vt(), this.localTransform = new Vt(), this.position = new Di(this.onChange, this, 0, 0), this.scale = new Di(this.onChange, this, 1, 1), this.pivot = new Di(this.onChange, this, 0, 0), this.skew = new Di(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
    }
    return r.prototype.onChange = function() {
      this._localID++;
    }, r.prototype.updateSkew = function() {
      this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
    }, r.prototype.toString = function() {
      return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
    }, r.prototype.updateLocalTransform = function() {
      var t = this.localTransform;
      this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1);
    }, r.prototype.updateTransform = function(t) {
      var e = this.localTransform;
      if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {
        var i = t.worldTransform, n = this.worldTransform;
        n.a = e.a * i.a + e.b * i.c, n.b = e.a * i.b + e.b * i.d, n.c = e.c * i.a + e.d * i.c, n.d = e.c * i.b + e.d * i.d, n.tx = e.tx * i.a + e.ty * i.c + i.tx, n.ty = e.tx * i.b + e.ty * i.d + i.ty, this._parentID = t._worldID, this._worldID++;
      }
    }, r.prototype.setFromMatrix = function(t) {
      t.decompose(this), this._localID++;
    }, Object.defineProperty(r.prototype, "rotation", {
      /** The rotation of the object in radians. */
      get: function() {
        return this._rotation;
      },
      set: function(t) {
        this._rotation !== t && (this._rotation = t, this.updateSkew());
      },
      enumerable: !1,
      configurable: !0
    }), r.IDENTITY = new r(), r;
  }()
);
/*!
 * @pixi/display - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
K.SORTABLE_CHILDREN = !1;
var On = (
  /** @class */
  function() {
    function r() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
    }
    return r.prototype.isEmpty = function() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }, r.prototype.clear = function() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
    }, r.prototype.getRectangle = function(t) {
      return this.minX > this.maxX || this.minY > this.maxY ? dt.EMPTY : (t = t || new dt(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t);
    }, r.prototype.addPoint = function(t) {
      this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y);
    }, r.prototype.addPointMatrix = function(t, e) {
      var i = t.a, n = t.b, s = t.c, o = t.d, a = t.tx, h = t.ty, l = i * e.x + s * e.y + a, u = n * e.x + o * e.y + h;
      this.minX = Math.min(this.minX, l), this.maxX = Math.max(this.maxX, l), this.minY = Math.min(this.minY, u), this.maxY = Math.max(this.maxY, u);
    }, r.prototype.addQuad = function(t) {
      var e = this.minX, i = this.minY, n = this.maxX, s = this.maxY, o = t[0], a = t[1];
      e = o < e ? o : e, i = a < i ? a : i, n = o > n ? o : n, s = a > s ? a : s, o = t[2], a = t[3], e = o < e ? o : e, i = a < i ? a : i, n = o > n ? o : n, s = a > s ? a : s, o = t[4], a = t[5], e = o < e ? o : e, i = a < i ? a : i, n = o > n ? o : n, s = a > s ? a : s, o = t[6], a = t[7], e = o < e ? o : e, i = a < i ? a : i, n = o > n ? o : n, s = a > s ? a : s, this.minX = e, this.minY = i, this.maxX = n, this.maxY = s;
    }, r.prototype.addFrame = function(t, e, i, n, s) {
      this.addFrameMatrix(t.worldTransform, e, i, n, s);
    }, r.prototype.addFrameMatrix = function(t, e, i, n, s) {
      var o = t.a, a = t.b, h = t.c, l = t.d, u = t.tx, c = t.ty, f = this.minX, d = this.minY, p = this.maxX, v = this.maxY, _ = o * e + h * i + u, m = a * e + l * i + c;
      f = _ < f ? _ : f, d = m < d ? m : d, p = _ > p ? _ : p, v = m > v ? m : v, _ = o * n + h * i + u, m = a * n + l * i + c, f = _ < f ? _ : f, d = m < d ? m : d, p = _ > p ? _ : p, v = m > v ? m : v, _ = o * e + h * s + u, m = a * e + l * s + c, f = _ < f ? _ : f, d = m < d ? m : d, p = _ > p ? _ : p, v = m > v ? m : v, _ = o * n + h * s + u, m = a * n + l * s + c, f = _ < f ? _ : f, d = m < d ? m : d, p = _ > p ? _ : p, v = m > v ? m : v, this.minX = f, this.minY = d, this.maxX = p, this.maxY = v;
    }, r.prototype.addVertexData = function(t, e, i) {
      for (var n = this.minX, s = this.minY, o = this.maxX, a = this.maxY, h = e; h < i; h += 2) {
        var l = t[h], u = t[h + 1];
        n = l < n ? l : n, s = u < s ? u : s, o = l > o ? l : o, a = u > a ? u : a;
      }
      this.minX = n, this.minY = s, this.maxX = o, this.maxY = a;
    }, r.prototype.addVertices = function(t, e, i, n) {
      this.addVerticesMatrix(t.worldTransform, e, i, n);
    }, r.prototype.addVerticesMatrix = function(t, e, i, n, s, o) {
      s === void 0 && (s = 0), o === void 0 && (o = s);
      for (var a = t.a, h = t.b, l = t.c, u = t.d, c = t.tx, f = t.ty, d = this.minX, p = this.minY, v = this.maxX, _ = this.maxY, m = i; m < n; m += 2) {
        var y = e[m], b = e[m + 1], P = a * y + l * b + c, x = u * b + h * y + f;
        d = Math.min(d, P - s), v = Math.max(v, P + s), p = Math.min(p, x - o), _ = Math.max(_, x + o);
      }
      this.minX = d, this.minY = p, this.maxX = v, this.maxY = _;
    }, r.prototype.addBounds = function(t) {
      var e = this.minX, i = this.minY, n = this.maxX, s = this.maxY;
      this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < i ? t.minY : i, this.maxX = t.maxX > n ? t.maxX : n, this.maxY = t.maxY > s ? t.maxY : s;
    }, r.prototype.addBoundsMask = function(t, e) {
      var i = t.minX > e.minX ? t.minX : e.minX, n = t.minY > e.minY ? t.minY : e.minY, s = t.maxX < e.maxX ? t.maxX : e.maxX, o = t.maxY < e.maxY ? t.maxY : e.maxY;
      if (i <= s && n <= o) {
        var a = this.minX, h = this.minY, l = this.maxX, u = this.maxY;
        this.minX = i < a ? i : a, this.minY = n < h ? n : h, this.maxX = s > l ? s : l, this.maxY = o > u ? o : u;
      }
    }, r.prototype.addBoundsMatrix = function(t, e) {
      this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);
    }, r.prototype.addBoundsArea = function(t, e) {
      var i = t.minX > e.x ? t.minX : e.x, n = t.minY > e.y ? t.minY : e.y, s = t.maxX < e.x + e.width ? t.maxX : e.x + e.width, o = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
      if (i <= s && n <= o) {
        var a = this.minX, h = this.minY, l = this.maxX, u = this.maxY;
        this.minX = i < a ? i : a, this.minY = n < h ? n : h, this.maxX = s > l ? s : l, this.maxY = o > u ? o : u;
      }
    }, r.prototype.pad = function(t, e) {
      t === void 0 && (t = 0), e === void 0 && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e);
    }, r.prototype.addFramePad = function(t, e, i, n, s, o) {
      t -= s, e -= o, i += s, n += o, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > i ? this.maxX : i, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > n ? this.maxY : n;
    }, r;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var As = function(r, t) {
  return As = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, As(r, t);
};
function Oo(r, t) {
  As(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Ut = (
  /** @class */
  function(r) {
    Oo(t, r);
    function t() {
      var e = r.call(this) || this;
      return e.tempDisplayObjectParent = null, e.transform = new Fh(), e.alpha = 1, e.visible = !0, e.renderable = !0, e.cullable = !1, e.cullArea = null, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new On(), e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._maskRefCount = 0, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e;
    }
    return t.mixin = function(e) {
      for (var i = Object.keys(e), n = 0; n < i.length; ++n) {
        var s = i[n];
        Object.defineProperty(t.prototype, s, Object.getOwnPropertyDescriptor(e, s));
      }
    }, Object.defineProperty(t.prototype, "destroyed", {
      /**
       * Fired when this DisplayObject is added to a Container.
       * @instance
       * @event added
       * @param {PIXI.Container} container - The container added to.
       */
      /**
       * Fired when this DisplayObject is removed from a Container.
       * @instance
       * @event removed
       * @param {PIXI.Container} container - The container removed from.
       */
      /**
       * Fired when this DisplayObject is destroyed. This event is emitted once
       * destroy is finished.
       * @instance
       * @event destroyed
       */
      /** Readonly flag for destroyed display objects. */
      get: function() {
        return this._destroyed;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype._recursivePostUpdateTransform = function() {
      this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }, t.prototype.updateTransform = function() {
      this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
    }, t.prototype.getBounds = function(e, i) {
      return e || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), i || (this._boundsRect || (this._boundsRect = new dt()), i = this._boundsRect), this._bounds.getRectangle(i);
    }, t.prototype.getLocalBounds = function(e) {
      e || (this._localBoundsRect || (this._localBoundsRect = new dt()), e = this._localBoundsRect), this._localBounds || (this._localBounds = new On());
      var i = this.transform, n = this.parent;
      this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
      var s = this._bounds, o = this._boundsID;
      this._bounds = this._localBounds;
      var a = this.getBounds(!1, e);
      return this.parent = n, this.transform = i, this._bounds = s, this._bounds.updateID += this._boundsID - o, a;
    }, t.prototype.toGlobal = function(e, i, n) {
      return n === void 0 && (n = !1), n || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(e, i);
    }, t.prototype.toLocal = function(e, i, n, s) {
      return i && (e = i.toGlobal(e, n, s)), s || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(e, n);
    }, t.prototype.setParent = function(e) {
      if (!e || !e.addChild)
        throw new Error("setParent: Argument must be a Container");
      return e.addChild(this), e;
    }, t.prototype.setTransform = function(e, i, n, s, o, a, h, l, u) {
      return e === void 0 && (e = 0), i === void 0 && (i = 0), n === void 0 && (n = 1), s === void 0 && (s = 1), o === void 0 && (o = 0), a === void 0 && (a = 0), h === void 0 && (h = 0), l === void 0 && (l = 0), u === void 0 && (u = 0), this.position.x = e, this.position.y = i, this.scale.x = n || 1, this.scale.y = s || 1, this.rotation = o, this.skew.x = a, this.skew.y = h, this.pivot.x = l, this.pivot.y = u, this;
    }, t.prototype.destroy = function(e) {
      this.parent && this.parent.removeChild(this), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners();
    }, Object.defineProperty(t.prototype, "_tempDisplayObjectParent", {
      /**
       * @protected
       * @member {PIXI.Container}
       */
      get: function() {
        return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new Bh()), this.tempDisplayObjectParent;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.enableTempParent = function() {
      var e = this.parent;
      return this.parent = this._tempDisplayObjectParent, e;
    }, t.prototype.disableTempParent = function(e) {
      this.parent = e;
    }, Object.defineProperty(t.prototype, "x", {
      /**
       * The position of the displayObject on the x axis relative to the local coordinates of the parent.
       * An alias to position.x
       */
      get: function() {
        return this.position.x;
      },
      set: function(e) {
        this.transform.position.x = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "y", {
      /**
       * The position of the displayObject on the y axis relative to the local coordinates of the parent.
       * An alias to position.y
       */
      get: function() {
        return this.position.y;
      },
      set: function(e) {
        this.transform.position.y = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "worldTransform", {
      /**
       * Current transform of the object based on world (parent) factors.
       * @readonly
       */
      get: function() {
        return this.transform.worldTransform;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "localTransform", {
      /**
       * Current transform of the object based on local factors: position, scale, other stuff.
       * @readonly
       */
      get: function() {
        return this.transform.localTransform;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "position", {
      /**
       * The coordinate of the object relative to the local coordinates of the parent.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.position;
      },
      set: function(e) {
        this.transform.position.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "scale", {
      /**
       * The scale factors of this object along the local coordinate axes.
       *
       * The default scale is (1, 1).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.scale;
      },
      set: function(e) {
        this.transform.scale.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "pivot", {
      /**
       * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
       * is the projection of `pivot` in the parent's local space.
       *
       * By default, the pivot is the origin (0, 0).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.pivot;
      },
      set: function(e) {
        this.transform.pivot.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "skew", {
      /**
       * The skew factor for the object in radians.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.skew;
      },
      set: function(e) {
        this.transform.skew.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "rotation", {
      /**
       * The rotation of the object in radians.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation;
      },
      set: function(e) {
        this.transform.rotation = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "angle", {
      /**
       * The angle of the object in degrees.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation * Sd;
      },
      set: function(e) {
        this.transform.rotation = e * Pd;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "zIndex", {
      /**
       * The zIndex of the displayObject.
       *
       * If a container has the sortableChildren property set to true, children will be automatically
       * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
       * and thus rendered on top of other display objects within the same container.
       * @see PIXI.Container#sortableChildren
       */
      get: function() {
        return this._zIndex;
      },
      set: function(e) {
        this._zIndex = e, this.parent && (this.parent.sortDirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "worldVisible", {
      /**
       * Indicates if the object is globally visible.
       * @readonly
       */
      get: function() {
        var e = this;
        do {
          if (!e.visible)
            return !1;
          e = e.parent;
        } while (e);
        return !0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "mask", {
      /**
       * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
       * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
       * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
       * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
       * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
       * To remove a mask, set this property to `null`.
       *
       * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
       * @example
       * const graphics = new PIXI.Graphics();
       * graphics.beginFill(0xFF3300);
       * graphics.drawRect(50, 250, 100, 100);
       * graphics.endFill();
       *
       * const sprite = new PIXI.Sprite(texture);
       * sprite.mask = graphics;
       * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
       */
      get: function() {
        return this._mask;
      },
      set: function(e) {
        if (this._mask !== e) {
          if (this._mask) {
            var i = this._mask.isMaskData ? this._mask.maskObject : this._mask;
            i && (i._maskRefCount--, i._maskRefCount === 0 && (i.renderable = !0, i.isMask = !1));
          }
          if (this._mask = e, this._mask) {
            var i = this._mask.isMaskData ? this._mask.maskObject : this._mask;
            i && (i._maskRefCount === 0 && (i.renderable = !1, i.isMask = !0), i._maskRefCount++);
          }
        }
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Pe)
), Bh = (
  /** @class */
  function(r) {
    Oo(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.sortDirty = null, e;
    }
    return t;
  }(Ut)
);
Ut.prototype.displayObjectUpdateTransform = Ut.prototype.updateTransform;
function Rd(r, t) {
  return r.zIndex === t.zIndex ? r._lastSortedIndex - t._lastSortedIndex : r.zIndex - t.zIndex;
}
var Ct = (
  /** @class */
  function(r) {
    Oo(t, r);
    function t() {
      var e = r.call(this) || this;
      return e.children = [], e.sortableChildren = K.SORTABLE_CHILDREN, e.sortDirty = !1, e;
    }
    return t.prototype.onChildrenChange = function(e) {
    }, t.prototype.addChild = function() {
      for (var e = arguments, i = [], n = 0; n < arguments.length; n++)
        i[n] = e[n];
      if (i.length > 1)
        for (var s = 0; s < i.length; s++)
          this.addChild(i[s]);
      else {
        var o = i[0];
        o.parent && o.parent.removeChild(o), o.parent = this, this.sortDirty = !0, o.transform._parentID = -1, this.children.push(o), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", o, this, this.children.length - 1), o.emit("added", this);
      }
      return i[0];
    }, t.prototype.addChildAt = function(e, i) {
      if (i < 0 || i > this.children.length)
        throw new Error(e + "addChildAt: The index " + i + " supplied is out of bounds " + this.children.length);
      return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(i, 0, e), this._boundsID++, this.onChildrenChange(i), e.emit("added", this), this.emit("childAdded", e, this, i), e;
    }, t.prototype.swapChildren = function(e, i) {
      if (e !== i) {
        var n = this.getChildIndex(e), s = this.getChildIndex(i);
        this.children[n] = i, this.children[s] = e, this.onChildrenChange(n < s ? n : s);
      }
    }, t.prototype.getChildIndex = function(e) {
      var i = this.children.indexOf(e);
      if (i === -1)
        throw new Error("The supplied DisplayObject must be a child of the caller");
      return i;
    }, t.prototype.setChildIndex = function(e, i) {
      if (i < 0 || i >= this.children.length)
        throw new Error("The index " + i + " supplied is out of bounds " + this.children.length);
      var n = this.getChildIndex(e);
      Fi(this.children, n, 1), this.children.splice(i, 0, e), this.onChildrenChange(i);
    }, t.prototype.getChildAt = function(e) {
      if (e < 0 || e >= this.children.length)
        throw new Error("getChildAt: Index (" + e + ") does not exist.");
      return this.children[e];
    }, t.prototype.removeChild = function() {
      for (var e = arguments, i = [], n = 0; n < arguments.length; n++)
        i[n] = e[n];
      if (i.length > 1)
        for (var s = 0; s < i.length; s++)
          this.removeChild(i[s]);
      else {
        var o = i[0], a = this.children.indexOf(o);
        if (a === -1)
          return null;
        o.parent = null, o.transform._parentID = -1, Fi(this.children, a, 1), this._boundsID++, this.onChildrenChange(a), o.emit("removed", this), this.emit("childRemoved", o, this, a);
      }
      return i[0];
    }, t.prototype.removeChildAt = function(e) {
      var i = this.getChildAt(e);
      return i.parent = null, i.transform._parentID = -1, Fi(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), i.emit("removed", this), this.emit("childRemoved", i, this, e), i;
    }, t.prototype.removeChildren = function(e, i) {
      e === void 0 && (e = 0), i === void 0 && (i = this.children.length);
      var n = e, s = i, o = s - n, a;
      if (o > 0 && o <= s) {
        a = this.children.splice(n, o);
        for (var h = 0; h < a.length; ++h)
          a[h].parent = null, a[h].transform && (a[h].transform._parentID = -1);
        this._boundsID++, this.onChildrenChange(e);
        for (var h = 0; h < a.length; ++h)
          a[h].emit("removed", this), this.emit("childRemoved", a[h], this, h);
        return a;
      } else if (o === 0 && this.children.length === 0)
        return [];
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    }, t.prototype.sortChildren = function() {
      for (var e = !1, i = 0, n = this.children.length; i < n; ++i) {
        var s = this.children[i];
        s._lastSortedIndex = i, !e && s.zIndex !== 0 && (e = !0);
      }
      e && this.children.length > 1 && this.children.sort(Rd), this.sortDirty = !1;
    }, t.prototype.updateTransform = function() {
      this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (var e = 0, i = this.children.length; e < i; ++e) {
        var n = this.children[e];
        n.visible && n.updateTransform();
      }
    }, t.prototype.calculateBounds = function() {
      this._bounds.clear(), this._calculateBounds();
      for (var e = 0; e < this.children.length; e++) {
        var i = this.children[e];
        if (!(!i.visible || !i.renderable))
          if (i.calculateBounds(), i._mask) {
            var n = i._mask.isMaskData ? i._mask.maskObject : i._mask;
            n ? (n.calculateBounds(), this._bounds.addBoundsMask(i._bounds, n._bounds)) : this._bounds.addBounds(i._bounds);
          } else i.filterArea ? this._bounds.addBoundsArea(i._bounds, i.filterArea) : this._bounds.addBounds(i._bounds);
      }
      this._bounds.updateID = this._boundsID;
    }, t.prototype.getLocalBounds = function(e, i) {
      i === void 0 && (i = !1);
      var n = r.prototype.getLocalBounds.call(this, e);
      if (!i)
        for (var s = 0, o = this.children.length; s < o; ++s) {
          var a = this.children[s];
          a.visible && a.updateTransform();
        }
      return n;
    }, t.prototype._calculateBounds = function() {
    }, t.prototype._renderWithCulling = function(e) {
      var i = e.renderTexture.sourceFrame;
      if (i.width > 0 && i.height > 0) {
        var n, s;
        if (this.cullArea ? (n = this.cullArea, s = this.worldTransform) : this._render !== t.prototype._render && (n = this.getBounds(!0)), n && i.intersects(n, s))
          this._render(e);
        else if (this.cullArea)
          return;
        for (var o = 0, a = this.children.length; o < a; ++o) {
          var h = this.children[o], l = h.cullable;
          h.cullable = l || !this.cullArea, h.render(e), h.cullable = l;
        }
      }
    }, t.prototype.render = function(e) {
      if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
        if (this._mask || this.filters && this.filters.length)
          this.renderAdvanced(e);
        else if (this.cullable)
          this._renderWithCulling(e);
        else {
          this._render(e);
          for (var i = 0, n = this.children.length; i < n; ++i)
            this.children[i].render(e);
        }
    }, t.prototype.renderAdvanced = function(e) {
      var i = this.filters, n = this._mask;
      if (i) {
        this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
        for (var s = 0; s < i.length; s++)
          i[s].enabled && this._enabledFilters.push(i[s]);
      }
      var o = i && this._enabledFilters && this._enabledFilters.length || n && (!n.isMaskData || n.enabled && (n.autoDetect || n.type !== jt.NONE));
      if (o && e.batch.flush(), i && this._enabledFilters && this._enabledFilters.length && e.filter.push(this, this._enabledFilters), n && e.mask.push(this, this._mask), this.cullable)
        this._renderWithCulling(e);
      else {
        this._render(e);
        for (var s = 0, a = this.children.length; s < a; ++s)
          this.children[s].render(e);
      }
      o && e.batch.flush(), n && e.mask.pop(this), i && this._enabledFilters && this._enabledFilters.length && e.filter.pop();
    }, t.prototype._render = function(e) {
    }, t.prototype.destroy = function(e) {
      r.prototype.destroy.call(this), this.sortDirty = !1;
      var i = typeof e == "boolean" ? e : e && e.children, n = this.removeChildren(0, this.children.length);
      if (i)
        for (var s = 0; s < n.length; ++s)
          n[s].destroy(e);
    }, Object.defineProperty(t.prototype, "width", {
      /** The width of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.x * this.getLocalBounds().width;
      },
      set: function(e) {
        var i = this.getLocalBounds().width;
        i !== 0 ? this.scale.x = e / i : this.scale.x = 1, this._width = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.y * this.getLocalBounds().height;
      },
      set: function(e) {
        var i = this.getLocalBounds().height;
        i !== 0 ? this.scale.y = e / i : this.scale.y = 1, this._height = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ut)
);
Ct.prototype.containerUpdateTransform = Ct.prototype.updateTransform;
/*!
 * @pixi/extensions - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/extensions is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ur = function() {
  return ur = Object.assign || function(t) {
    for (var e = arguments, i, n = 1, s = arguments.length; n < s; n++) {
      i = e[n];
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (t[o] = i[o]);
    }
    return t;
  }, ur.apply(this, arguments);
}, St;
(function(r) {
  r.Application = "application", r.RendererPlugin = "renderer-webgl-plugin", r.CanvasRendererPlugin = "renderer-canvas-plugin", r.Loader = "loader", r.LoadParser = "load-parser", r.ResolveParser = "resolve-parser", r.CacheParser = "cache-parser", r.DetectionParser = "detection-parser";
})(St || (St = {}));
var ya = function(r) {
  if (typeof r == "function" || typeof r == "object" && r.extension) {
    if (!r.extension)
      throw new Error("Extension class must have an extension object");
    var t = typeof r.extension != "object" ? { type: r.extension } : r.extension;
    r = ur(ur({}, t), { ref: r });
  }
  if (typeof r == "object")
    r = ur({}, r);
  else
    throw new Error("Invalid extension type");
  return typeof r.type == "string" && (r.type = [r.type]), r;
}, Ue = {
  /** @ignore */
  _addHandlers: null,
  /** @ignore */
  _removeHandlers: null,
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {PIXI.extensions} For chaining.
   */
  remove: function() {
    for (var r = arguments, t = this, e = [], i = 0; i < arguments.length; i++)
      e[i] = r[i];
    return e.map(ya).forEach(function(n) {
      n.type.forEach(function(s) {
        var o, a;
        return (a = (o = t._removeHandlers)[s]) === null || a === void 0 ? void 0 : a.call(o, n);
      });
    }), this;
  },
  /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {PIXI.extensions} For chaining.
   */
  add: function() {
    for (var r = arguments, t = this, e = [], i = 0; i < arguments.length; i++)
      e[i] = r[i];
    return e.map(ya).forEach(function(n) {
      n.type.forEach(function(s) {
        var o = t._addHandlers, a = t._queue;
        o[s] ? o[s](n) : (a[s] = a[s] || [], a[s].push(n));
      });
    }), this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.
   * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.
   * @returns {PIXI.extensions} For chaining.
   */
  handle: function(r, t, e) {
    var i = this._addHandlers = this._addHandlers || {}, n = this._removeHandlers = this._removeHandlers || {};
    if (i[r] || n[r])
      throw new Error("Extension type " + r + " already has a handler");
    i[r] = t, n[r] = e;
    var s = this._queue;
    return s[r] && (s[r].forEach(function(o) {
      return t(o);
    }), delete s[r]), this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByMap: function(r, t) {
    return this.handle(r, function(e) {
      t[e.name] = e.ref;
    }, function(e) {
      delete t[e.name];
    });
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByList: function(r, t) {
    return this.handle(r, function(e) {
      var i, n;
      t.includes(e.ref) || (t.push(e.ref), r === St.Loader && ((n = (i = e.ref).add) === null || n === void 0 || n.call(i)));
    }, function(e) {
      var i = t.indexOf(e.ref);
      i !== -1 && t.splice(i, 1);
    });
  }
};
/*!
 * @pixi/runner - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Zt = (
  /** @class */
  function() {
    function r(t) {
      this.items = [], this._name = t, this._aliasCount = 0;
    }
    return r.prototype.emit = function(t, e, i, n, s, o, a, h) {
      if (arguments.length > 8)
        throw new Error("max arguments reached");
      var l = this, u = l.name, c = l.items;
      this._aliasCount++;
      for (var f = 0, d = c.length; f < d; f++)
        c[f][u](t, e, i, n, s, o, a, h);
      return c === this.items && this._aliasCount--, this;
    }, r.prototype.ensureNonAliasedItems = function() {
      this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
    }, r.prototype.add = function(t) {
      return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this;
    }, r.prototype.remove = function(t) {
      var e = this.items.indexOf(t);
      return e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this;
    }, r.prototype.contains = function(t) {
      return this.items.indexOf(t) !== -1;
    }, r.prototype.removeAll = function() {
      return this.ensureNonAliasedItems(), this.items.length = 0, this;
    }, r.prototype.destroy = function() {
      this.removeAll(), this.items = null, this._name = null;
    }, Object.defineProperty(r.prototype, "empty", {
      /**
       * `true` if there are no this Runner contains no listeners
       * @readonly
       */
      get: function() {
        return this.items.length === 0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "name", {
      /**
       * The name of the runner.
       * @readonly
       */
      get: function() {
        return this._name;
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
);
Object.defineProperties(Zt.prototype, {
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method dispatch
   * @see PIXI.Runner#emit
   */
  dispatch: { value: Zt.prototype.emit },
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method run
   * @see PIXI.Runner#emit
   */
  run: { value: Zt.prototype.emit }
});
/*!
 * @pixi/ticker - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/ticker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
K.TARGET_FPMS = 0.06;
var Ze;
(function(r) {
  r[r.INTERACTION = 50] = "INTERACTION", r[r.HIGH = 25] = "HIGH", r[r.NORMAL = 0] = "NORMAL", r[r.LOW = -25] = "LOW", r[r.UTILITY = -50] = "UTILITY";
})(Ze || (Ze = {}));
var Qn = (
  /** @class */
  function() {
    function r(t, e, i, n) {
      e === void 0 && (e = null), i === void 0 && (i = 0), n === void 0 && (n = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = i, this.once = n;
    }
    return r.prototype.match = function(t, e) {
      return e === void 0 && (e = null), this.fn === t && this.context === e;
    }, r.prototype.emit = function(t) {
      this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
      var e = this.next;
      return this.once && this.destroy(!0), this._destroyed && (this.next = null), e;
    }, r.prototype.connect = function(t) {
      this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
    }, r.prototype.destroy = function(t) {
      t === void 0 && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
      var e = this.next;
      return this.next = t ? null : e, this.previous = null, e;
    }, r;
  }()
), Lt = (
  /** @class */
  function() {
    function r() {
      var t = this;
      this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new Qn(null, null, 1 / 0), this.deltaMS = 1 / K.TARGET_FPMS, this.elapsedMS = 1 / K.TARGET_FPMS, this._tick = function(e) {
        t._requestId = null, t.started && (t.update(e), t.started && t._requestId === null && t._head.next && (t._requestId = requestAnimationFrame(t._tick)));
      };
    }
    return r.prototype._requestIfNeeded = function() {
      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
    }, r.prototype._cancelIfNeeded = function() {
      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }, r.prototype._startIfPossible = function() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }, r.prototype.add = function(t, e, i) {
      return i === void 0 && (i = Ze.NORMAL), this._addListener(new Qn(t, e, i));
    }, r.prototype.addOnce = function(t, e, i) {
      return i === void 0 && (i = Ze.NORMAL), this._addListener(new Qn(t, e, i, !0));
    }, r.prototype._addListener = function(t) {
      var e = this._head.next, i = this._head;
      if (!e)
        t.connect(i);
      else {
        for (; e; ) {
          if (t.priority > e.priority) {
            t.connect(i);
            break;
          }
          i = e, e = e.next;
        }
        t.previous || t.connect(i);
      }
      return this._startIfPossible(), this;
    }, r.prototype.remove = function(t, e) {
      for (var i = this._head.next; i; )
        i.match(t, e) ? i = i.destroy() : i = i.next;
      return this._head.next || this._cancelIfNeeded(), this;
    }, Object.defineProperty(r.prototype, "count", {
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       * @readonly
       * @member {number}
       */
      get: function() {
        if (!this._head)
          return 0;
        for (var t = 0, e = this._head; e = e.next; )
          t++;
        return t;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.start = function() {
      this.started || (this.started = !0, this._requestIfNeeded());
    }, r.prototype.stop = function() {
      this.started && (this.started = !1, this._cancelIfNeeded());
    }, r.prototype.destroy = function() {
      if (!this._protected) {
        this.stop();
        for (var t = this._head.next; t; )
          t = t.destroy(!0);
        this._head.destroy(), this._head = null;
      }
    }, r.prototype.update = function(t) {
      t === void 0 && (t = performance.now());
      var e;
      if (t > this.lastTime) {
        if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
          var i = t - this._lastFrame | 0;
          if (i < this._minElapsedMS)
            return;
          this._lastFrame = t - i % this._minElapsedMS;
        }
        this.deltaMS = e, this.deltaTime = this.deltaMS * K.TARGET_FPMS;
        for (var n = this._head, s = n.next; s; )
          s = s.emit(this.deltaTime);
        n.next || this._cancelIfNeeded();
      } else
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = t;
    }, Object.defineProperty(r.prototype, "FPS", {
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link PIXI.Ticker#speed}, which is specific
       * to scaling {@link PIXI.Ticker#deltaTime}.
       * @member {number}
       * @readonly
       */
      get: function() {
        return 1e3 / this.elapsedMS;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "minFPS", {
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This value is used to cap {@link PIXI.Ticker#deltaTime},
       * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
       * @member {number}
       * @default 10
       */
      get: function() {
        return 1e3 / this._maxElapsedMS;
      },
      set: function(t) {
        var e = Math.min(this.maxFPS, t), i = Math.min(Math.max(0, e) / 1e3, K.TARGET_FPMS);
        this._maxElapsedMS = 1 / i;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "maxFPS", {
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This will effect the measured value of {@link PIXI.Ticker#FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @member {number}
       * @default 0
       */
      get: function() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
      },
      set: function(t) {
        if (t === 0)
          this._minElapsedMS = 0;
        else {
          var e = Math.max(this.minFPS, t);
          this._minElapsedMS = 1 / (e / 1e3);
        }
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "shared", {
      /**
       * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
       * {@link PIXI.VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * let ticker = PIXI.Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the PIXI.Ticker.shared instance.
       * ticker.autoStart = false;
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * // You may use the shared ticker to render...
       * let renderer = PIXI.autoDetectRenderer();
       * let stage = new PIXI.Container();
       * document.body.appendChild(renderer.view);
       * ticker.add(function (time) {
       *     renderer.render(stage);
       * });
       * @example
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * function animate(time) {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * }
       * animate(performance.now());
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!r._shared) {
          var t = r._shared = new r();
          t.autoStart = !0, t._protected = !0;
        }
        return r._shared;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "system", {
      /**
       * The system ticker instance used by {@link PIXI.InteractionManager} and by
       * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
       * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!r._system) {
          var t = r._system = new r();
          t.autoStart = !0, t._protected = !0;
        }
        return r._system;
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
), kd = (
  /** @class */
  function() {
    function r() {
    }
    return r.init = function(t) {
      var e = this;
      t = Object.assign({
        autoStart: !0,
        sharedTicker: !1
      }, t), Object.defineProperty(this, "ticker", {
        set: function(i) {
          this._ticker && this._ticker.remove(this.render, this), this._ticker = i, i && i.add(this.render, this, Ze.LOW);
        },
        get: function() {
          return this._ticker;
        }
      }), this.stop = function() {
        e._ticker.stop();
      }, this.start = function() {
        e._ticker.start();
      }, this._ticker = null, this.ticker = t.sharedTicker ? Lt.shared : new Lt(), t.autoStart && this.start();
    }, r.destroy = function() {
      if (this._ticker) {
        var t = this._ticker;
        this.ticker = null, t.destroy();
      }
    }, r.extension = St.Application, r;
  }()
);
/*!
 * @pixi/core - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
K.PREFER_ENV = Re.any ? qe.WEBGL : qe.WEBGL2;
K.STRICT_TEXTURE_CACHE = !1;
var Ds = [];
function Uh(r, t) {
  if (!r)
    return null;
  var e = "";
  if (typeof r == "string") {
    var i = /\.(\w{3,4})(?:$|\?|#)/i.exec(r);
    i && (e = i[1].toLowerCase());
  }
  for (var n = Ds.length - 1; n >= 0; --n) {
    var s = Ds[n];
    if (s.test && s.test(r, e))
      return new s(r, t);
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ls = function(r, t) {
  return Ls = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Ls(r, t);
};
function It(r, t) {
  Ls(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Fs = function() {
  return Fs = Object.assign || function(t) {
    for (var e = arguments, i, n = 1, s = arguments.length; n < s; n++) {
      i = e[n];
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (t[o] = i[o]);
    }
    return t;
  }, Fs.apply(this, arguments);
};
function Nd(r, t) {
  var e = {};
  for (var i in r)
    Object.prototype.hasOwnProperty.call(r, i) && t.indexOf(i) < 0 && (e[i] = r[i]);
  if (r != null && typeof Object.getOwnPropertySymbols == "function")
    for (var n = 0, i = Object.getOwnPropertySymbols(r); n < i.length; n++)
      t.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(r, i[n]) && (e[i[n]] = r[i[n]]);
  return e;
}
var gr = (
  /** @class */
  function() {
    function r(t, e) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new Zt("setRealSize"), this.onUpdate = new Zt("update"), this.onError = new Zt("onError");
    }
    return r.prototype.bind = function(t) {
      this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height);
    }, r.prototype.unbind = function(t) {
      this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t);
    }, r.prototype.resize = function(t, e) {
      (t !== this._width || e !== this._height) && (this._width = t, this._height = e, this.onResize.emit(t, e));
    }, Object.defineProperty(r.prototype, "valid", {
      /**
       * Has been validated
       * @readonly
       */
      get: function() {
        return !!this._width && !!this._height;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.update = function() {
      this.destroyed || this.onUpdate.emit();
    }, r.prototype.load = function() {
      return Promise.resolve(this);
    }, Object.defineProperty(r.prototype, "width", {
      /**
       * The width of the resource.
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "height", {
      /**
       * The height of the resource.
       * @readonly
       */
      get: function() {
        return this._height;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.style = function(t, e, i) {
      return !1;
    }, r.prototype.dispose = function() {
    }, r.prototype.destroy = function() {
      this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
    }, r.test = function(t, e) {
      return !1;
    }, r;
  }()
), Mr = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e, i) {
      var n = this, s = i || {}, o = s.width, a = s.height;
      if (!o || !a)
        throw new Error("BufferResource width or height invalid");
      return n = r.call(this, o, a) || this, n.data = e, n;
    }
    return t.prototype.upload = function(e, i, n) {
      var s = e.gl;
      s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.alphaMode === Se.UNPACK);
      var o = i.realWidth, a = i.realHeight;
      return n.width === o && n.height === a ? s.texSubImage2D(i.target, 0, 0, 0, o, a, i.format, n.type, this.data) : (n.width = o, n.height = a, s.texImage2D(i.target, 0, n.internalFormat, o, a, 0, i.format, n.type, this.data)), !0;
    }, t.prototype.dispose = function() {
      this.data = null;
    }, t.test = function(e) {
      return e instanceof Float32Array || e instanceof Uint8Array || e instanceof Uint32Array;
    }, t;
  }(gr)
), Ad = {
  scaleMode: Me.NEAREST,
  format: z.RGBA,
  alphaMode: Se.NPM
}, gt = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e, i) {
      e === void 0 && (e = null), i === void 0 && (i = null);
      var n = r.call(this) || this;
      i = i || {};
      var s = i.alphaMode, o = i.mipmap, a = i.anisotropicLevel, h = i.scaleMode, l = i.width, u = i.height, c = i.wrapMode, f = i.format, d = i.type, p = i.target, v = i.resolution, _ = i.resourceOptions;
      return e && !(e instanceof gr) && (e = Uh(e, _), e.internal = !0), n.resolution = v || K.RESOLUTION, n.width = Math.round((l || 0) * n.resolution) / n.resolution, n.height = Math.round((u || 0) * n.resolution) / n.resolution, n._mipmap = o !== void 0 ? o : K.MIPMAP_TEXTURES, n.anisotropicLevel = a !== void 0 ? a : K.ANISOTROPIC_LEVEL, n._wrapMode = c || K.WRAP_MODE, n._scaleMode = h !== void 0 ? h : K.SCALE_MODE, n.format = f || z.RGBA, n.type = d || st.UNSIGNED_BYTE, n.target = p || wi.TEXTURE_2D, n.alphaMode = s !== void 0 ? s : Se.UNPACK, n.uid = Pi(), n.touched = 0, n.isPowerOfTwo = !1, n._refreshPOT(), n._glTextures = {}, n.dirtyId = 0, n.dirtyStyleId = 0, n.cacheId = null, n.valid = l > 0 && u > 0, n.textureCacheIds = [], n.destroyed = !1, n.resource = null, n._batchEnabled = 0, n._batchLocation = 0, n.parentTextureArray = null, n.setResource(e), n;
    }
    return Object.defineProperty(t.prototype, "realWidth", {
      /**
       * Pixel width of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.width * this.resolution);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "realHeight", {
      /**
       * Pixel height of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.height * this.resolution);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "mipmap", {
      /**
       * Mipmap mode of the texture, affects downscaled images
       * @default PIXI.settings.MIPMAP_TEXTURES
       */
      get: function() {
        return this._mipmap;
      },
      set: function(e) {
        this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "scaleMode", {
      /**
       * The scale mode to apply when scaling this texture
       * @default PIXI.settings.SCALE_MODE
       */
      get: function() {
        return this._scaleMode;
      },
      set: function(e) {
        this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "wrapMode", {
      /**
       * How the texture wraps
       * @default PIXI.settings.WRAP_MODE
       */
      get: function() {
        return this._wrapMode;
      },
      set: function(e) {
        this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++);
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.setStyle = function(e, i) {
      var n;
      return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e, n = !0), i !== void 0 && i !== this.mipmap && (this.mipmap = i, n = !0), n && this.dirtyStyleId++, this;
    }, t.prototype.setSize = function(e, i, n) {
      return n = n || this.resolution, this.setRealSize(e * n, i * n, n);
    }, t.prototype.setRealSize = function(e, i, n) {
      return this.resolution = n || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(i) / this.resolution, this._refreshPOT(), this.update(), this;
    }, t.prototype._refreshPOT = function() {
      this.isPowerOfTwo = da(this.realWidth) && da(this.realHeight);
    }, t.prototype.setResolution = function(e) {
      var i = this.resolution;
      return i === e ? this : (this.resolution = e, this.valid && (this.width = Math.round(this.width * i) / e, this.height = Math.round(this.height * i) / e, this.emit("update", this)), this._refreshPOT(), this);
    }, t.prototype.setResource = function(e) {
      if (this.resource === e)
        return this;
      if (this.resource)
        throw new Error("Resource can be set only once");
      return e.bind(this), this.resource = e, this;
    }, t.prototype.update = function() {
      this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this));
    }, t.prototype.onError = function(e) {
      this.emit("error", this, e);
    }, t.prototype.destroy = function() {
      this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete ze[this.cacheId], delete Qt[this.cacheId], this.cacheId = null), this.dispose(), t.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0;
    }, t.prototype.dispose = function() {
      this.emit("dispose", this);
    }, t.prototype.castToBaseTexture = function() {
      return this;
    }, t.from = function(e, i, n) {
      n === void 0 && (n = K.STRICT_TEXTURE_CACHE);
      var s = typeof e == "string", o = null;
      if (s)
        o = e;
      else {
        if (!e._pixiId) {
          var a = i && i.pixiIdPrefix || "pixiid";
          e._pixiId = a + "_" + Pi();
        }
        o = e._pixiId;
      }
      var h = ze[o];
      if (s && n && !h)
        throw new Error('The cacheId "' + o + '" does not exist in BaseTextureCache.');
      return h || (h = new t(e, i), h.cacheId = o, t.addToCache(h, o)), h;
    }, t.fromBuffer = function(e, i, n, s) {
      e = e || new Float32Array(i * n * 4);
      var o = new Mr(e, { width: i, height: n }), a = e instanceof Float32Array ? st.FLOAT : st.UNSIGNED_BYTE;
      return new t(o, Object.assign({}, Ad, s || { width: i, height: n, type: a }));
    }, t.addToCache = function(e, i) {
      i && (e.textureCacheIds.indexOf(i) === -1 && e.textureCacheIds.push(i), ze[i] && console.warn("BaseTexture added to the cache with an id [" + i + "] that already had an entry"), ze[i] = e);
    }, t.removeFromCache = function(e) {
      if (typeof e == "string") {
        var i = ze[e];
        if (i) {
          var n = i.textureCacheIds.indexOf(e);
          return n > -1 && i.textureCacheIds.splice(n, 1), delete ze[e], i;
        }
      } else if (e && e.textureCacheIds) {
        for (var s = 0; s < e.textureCacheIds.length; ++s)
          delete ze[e.textureCacheIds[s]];
        return e.textureCacheIds.length = 0, e;
      }
      return null;
    }, t._globalBatch = 0, t;
  }(Pe)
), Gh = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e, i) {
      var n = this, s = i || {}, o = s.width, a = s.height;
      n = r.call(this, o, a) || this, n.items = [], n.itemDirtyIds = [];
      for (var h = 0; h < e; h++) {
        var l = new gt();
        n.items.push(l), n.itemDirtyIds.push(-2);
      }
      return n.length = e, n._load = null, n.baseTexture = null, n;
    }
    return t.prototype.initFromArray = function(e, i) {
      for (var n = 0; n < this.length; n++)
        e[n] && (e[n].castToBaseTexture ? this.addBaseTextureAt(e[n].castToBaseTexture(), n) : e[n] instanceof gr ? this.addResourceAt(e[n], n) : this.addResourceAt(Uh(e[n], i), n));
    }, t.prototype.dispose = function() {
      for (var e = 0, i = this.length; e < i; e++)
        this.items[e].destroy();
      this.items = null, this.itemDirtyIds = null, this._load = null;
    }, t.prototype.addResourceAt = function(e, i) {
      if (!this.items[i])
        throw new Error("Index " + i + " is out of bounds");
      return e.valid && !this.valid && this.resize(e.width, e.height), this.items[i].setResource(e), this;
    }, t.prototype.bind = function(e) {
      if (this.baseTexture !== null)
        throw new Error("Only one base texture per TextureArray is allowed");
      r.prototype.bind.call(this, e);
      for (var i = 0; i < this.length; i++)
        this.items[i].parentTextureArray = e, this.items[i].on("update", e.update, e);
    }, t.prototype.unbind = function(e) {
      r.prototype.unbind.call(this, e);
      for (var i = 0; i < this.length; i++)
        this.items[i].parentTextureArray = null, this.items[i].off("update", e.update, e);
    }, t.prototype.load = function() {
      var e = this;
      if (this._load)
        return this._load;
      var i = this.items.map(function(s) {
        return s.resource;
      }).filter(function(s) {
        return s;
      }), n = i.map(function(s) {
        return s.load();
      });
      return this._load = Promise.all(n).then(function() {
        var s = e.items[0], o = s.realWidth, a = s.realHeight;
        return e.resize(o, a), Promise.resolve(e);
      }), this._load;
    }, t;
  }(gr)
), Dd = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e, i) {
      var n = this, s = i || {}, o = s.width, a = s.height, h, l;
      return Array.isArray(e) ? (h = e, l = e.length) : l = e, n = r.call(this, l, { width: o, height: a }) || this, h && n.initFromArray(h, i), n;
    }
    return t.prototype.addBaseTextureAt = function(e, i) {
      if (e.resource)
        this.addResourceAt(e.resource, i);
      else
        throw new Error("ArrayResource does not support RenderTexture");
      return this;
    }, t.prototype.bind = function(e) {
      r.prototype.bind.call(this, e), e.target = wi.TEXTURE_2D_ARRAY;
    }, t.prototype.upload = function(e, i, n) {
      var s = this, o = s.length, a = s.itemDirtyIds, h = s.items, l = e.gl;
      n.dirtyId < 0 && l.texImage3D(l.TEXTURE_2D_ARRAY, 0, n.internalFormat, this._width, this._height, o, 0, i.format, n.type, null);
      for (var u = 0; u < o; u++) {
        var c = h[u];
        a[u] < c.dirtyId && (a[u] = c.dirtyId, c.valid && l.texSubImage3D(
          l.TEXTURE_2D_ARRAY,
          0,
          0,
          // xoffset
          0,
          // yoffset
          u,
          // zoffset
          c.resource.width,
          c.resource.height,
          1,
          i.format,
          n.type,
          c.resource.source
        ));
      }
      return !0;
    }, t;
  }(Gh)
), ui = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e) {
      var i = this, n = e, s = n.naturalWidth || n.videoWidth || n.width, o = n.naturalHeight || n.videoHeight || n.height;
      return i = r.call(this, s, o) || this, i.source = e, i.noSubImage = !1, i;
    }
    return t.crossOrigin = function(e, i, n) {
      n === void 0 && i.indexOf("data:") !== 0 ? e.crossOrigin = Ed(i) : n !== !1 && (e.crossOrigin = typeof n == "string" ? n : "anonymous");
    }, t.prototype.upload = function(e, i, n, s) {
      var o = e.gl, a = i.realWidth, h = i.realHeight;
      if (s = s || this.source, s instanceof HTMLImageElement) {
        if (!s.complete || s.naturalWidth === 0)
          return !1;
      } else if (s instanceof HTMLVideoElement && s.readyState <= 1)
        return !1;
      return o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.alphaMode === Se.UNPACK), !this.noSubImage && i.target === o.TEXTURE_2D && n.width === a && n.height === h ? o.texSubImage2D(o.TEXTURE_2D, 0, 0, 0, i.format, n.type, s) : (n.width = a, n.height = h, o.texImage2D(i.target, 0, n.internalFormat, i.format, n.type, s)), !0;
    }, t.prototype.update = function() {
      if (!this.destroyed) {
        var e = this.source, i = e.naturalWidth || e.videoWidth || e.width, n = e.naturalHeight || e.videoHeight || e.height;
        this.resize(i, n), r.prototype.update.call(this);
      }
    }, t.prototype.dispose = function() {
      this.source = null;
    }, t;
  }(gr)
), Ld = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e) {
      return r.call(this, e) || this;
    }
    return t.test = function(e) {
      var i = globalThis.OffscreenCanvas;
      return i && e instanceof i ? !0 : globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement;
    }, t;
  }(ui)
), Fd = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e, i) {
      var n = this, s = i || {}, o = s.width, a = s.height, h = s.autoLoad, l = s.linkBaseTexture;
      if (e && e.length !== t.SIDES)
        throw new Error("Invalid length. Got " + e.length + ", expected 6");
      n = r.call(this, 6, { width: o, height: a }) || this;
      for (var u = 0; u < t.SIDES; u++)
        n.items[u].target = wi.TEXTURE_CUBE_MAP_POSITIVE_X + u;
      return n.linkBaseTexture = l !== !1, e && n.initFromArray(e, i), h !== !1 && n.load(), n;
    }
    return t.prototype.bind = function(e) {
      r.prototype.bind.call(this, e), e.target = wi.TEXTURE_CUBE_MAP;
    }, t.prototype.addBaseTextureAt = function(e, i, n) {
      if (!this.items[i])
        throw new Error("Index " + i + " is out of bounds");
      if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)
        if (e.resource)
          this.addResourceAt(e.resource, i);
        else
          throw new Error("CubeResource does not support copying of renderTexture.");
      else
        e.target = wi.TEXTURE_CUBE_MAP_POSITIVE_X + i, e.parentTextureArray = this.baseTexture, this.items[i] = e;
      return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[i] = e, this;
    }, t.prototype.upload = function(e, i, n) {
      for (var s = this.itemDirtyIds, o = 0; o < t.SIDES; o++) {
        var a = this.items[o];
        (s[o] < a.dirtyId || n.dirtyId < i.dirtyId) && (a.valid && a.resource ? (a.resource.upload(e, a, n), s[o] = a.dirtyId) : s[o] < -1 && (e.gl.texImage2D(a.target, 0, n.internalFormat, i.realWidth, i.realHeight, 0, i.format, n.type, null), s[o] = -1));
      }
      return !0;
    }, t.test = function(e) {
      return Array.isArray(e) && e.length === t.SIDES;
    }, t.SIDES = 6, t;
  }(Gh)
), jh = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e, i) {
      var n = this;
      if (i = i || {}, !(e instanceof HTMLImageElement)) {
        var s = new Image();
        ui.crossOrigin(s, e, i.crossorigin), s.src = e, e = s;
      }
      return n = r.call(this, e) || this, !e.complete && n._width && n._height && (n._width = 0, n._height = 0), n.url = e.src, n._process = null, n.preserveBitmap = !1, n.createBitmap = (i.createBitmap !== void 0 ? i.createBitmap : K.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, n.alphaMode = typeof i.alphaMode == "number" ? i.alphaMode : null, n.bitmap = null, n._load = null, i.autoLoad !== !1 && n.load(), n;
    }
    return t.prototype.load = function(e) {
      var i = this;
      return this._load ? this._load : (e !== void 0 && (this.createBitmap = e), this._load = new Promise(function(n, s) {
        var o = i.source;
        i.url = o.src;
        var a = function() {
          i.destroyed || (o.onload = null, o.onerror = null, i.resize(o.width, o.height), i._load = null, i.createBitmap ? n(i.process()) : n(i));
        };
        o.complete && o.src ? a() : (o.onload = a, o.onerror = function(h) {
          s(h), i.onError.emit(h);
        });
      }), this._load);
    }, t.prototype.process = function() {
      var e = this, i = this.source;
      if (this._process !== null)
        return this._process;
      if (this.bitmap !== null || !globalThis.createImageBitmap)
        return Promise.resolve(this);
      var n = globalThis.createImageBitmap, s = !i.crossOrigin || i.crossOrigin === "anonymous";
      return this._process = fetch(i.src, {
        mode: s ? "cors" : "no-cors"
      }).then(function(o) {
        return o.blob();
      }).then(function(o) {
        return n(o, 0, 0, i.width, i.height, {
          premultiplyAlpha: e.alphaMode === null || e.alphaMode === Se.UNPACK ? "premultiply" : "none"
        });
      }).then(function(o) {
        return e.destroyed ? Promise.reject() : (e.bitmap = o, e.update(), e._process = null, Promise.resolve(e));
      }), this._process;
    }, t.prototype.upload = function(e, i, n) {
      if (typeof this.alphaMode == "number" && (i.alphaMode = this.alphaMode), !this.createBitmap)
        return r.prototype.upload.call(this, e, i, n);
      if (!this.bitmap && (this.process(), !this.bitmap))
        return !1;
      if (r.prototype.upload.call(this, e, i, n, this.bitmap), !this.preserveBitmap) {
        var s = !0, o = i._glTextures;
        for (var a in o) {
          var h = o[a];
          if (h !== n && h.dirtyId !== i.dirtyId) {
            s = !1;
            break;
          }
        }
        s && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
      }
      return !0;
    }, t.prototype.dispose = function() {
      this.source.onload = null, this.source.onerror = null, r.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
    }, t.test = function(e) {
      return typeof e == "string" || e instanceof HTMLImageElement;
    }, t;
  }(ui)
), Bd = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e, i) {
      var n = this;
      return i = i || {}, n = r.call(this, K.ADAPTER.createCanvas()) || this, n._width = 0, n._height = 0, n.svg = e, n.scale = i.scale || 1, n._overrideWidth = i.width, n._overrideHeight = i.height, n._resolve = null, n._crossorigin = i.crossorigin, n._load = null, i.autoLoad !== !1 && n.load(), n;
    }
    return t.prototype.load = function() {
      var e = this;
      return this._load ? this._load : (this._load = new Promise(function(i) {
        if (e._resolve = function() {
          e.resize(e.source.width, e.source.height), i(e);
        }, t.SVG_XML.test(e.svg.trim())) {
          if (!btoa)
            throw new Error("Your browser doesn't support base64 conversions.");
          e.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(e.svg)));
        }
        e._loadSvg();
      }), this._load);
    }, t.prototype._loadSvg = function() {
      var e = this, i = new Image();
      ui.crossOrigin(i, this.svg, this._crossorigin), i.src = this.svg, i.onerror = function(n) {
        e._resolve && (i.onerror = null, e.onError.emit(n));
      }, i.onload = function() {
        if (e._resolve) {
          var n = i.width, s = i.height;
          if (!n || !s)
            throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
          var o = n * e.scale, a = s * e.scale;
          (e._overrideWidth || e._overrideHeight) && (o = e._overrideWidth || e._overrideHeight / s * n, a = e._overrideHeight || e._overrideWidth / n * s), o = Math.round(o), a = Math.round(a);
          var h = e.source;
          h.width = o, h.height = a, h._pixiId = "canvas_" + Pi(), h.getContext("2d").drawImage(i, 0, 0, n, s, 0, 0, o, a), e._resolve(), e._resolve = null;
        }
      };
    }, t.getSize = function(e) {
      var i = t.SVG_SIZE.exec(e), n = {};
      return i && (n[i[1]] = Math.round(parseFloat(i[3])), n[i[5]] = Math.round(parseFloat(i[7]))), n;
    }, t.prototype.dispose = function() {
      r.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;
    }, t.test = function(e, i) {
      return i === "svg" || typeof e == "string" && e.startsWith("data:image/svg+xml") || typeof e == "string" && t.SVG_XML.test(e);
    }, t.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, t.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, t;
  }(ui)
), Ud = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e, i) {
      var n = this;
      if (i = i || {}, !(e instanceof HTMLVideoElement)) {
        var s = document.createElement("video");
        s.setAttribute("preload", "auto"), s.setAttribute("webkit-playsinline", ""), s.setAttribute("playsinline", ""), typeof e == "string" && (e = [e]);
        var o = e[0].src || e[0];
        ui.crossOrigin(s, o, i.crossorigin);
        for (var a = 0; a < e.length; ++a) {
          var h = document.createElement("source"), l = e[a], u = l.src, c = l.mime;
          u = u || e[a];
          var f = u.split("?").shift().toLowerCase(), d = f.slice(f.lastIndexOf(".") + 1);
          c = c || t.MIME_TYPES[d] || "video/" + d, h.src = u, h.type = c, s.appendChild(h);
        }
        e = s;
      }
      return n = r.call(this, e) || this, n.noSubImage = !0, n._autoUpdate = !0, n._isConnectedToTicker = !1, n._updateFPS = i.updateFPS || 0, n._msToNextUpdate = 0, n.autoPlay = i.autoPlay !== !1, n._load = null, n._resolve = null, n._onCanPlay = n._onCanPlay.bind(n), n._onError = n._onError.bind(n), i.autoLoad !== !1 && n.load(), n;
    }
    return t.prototype.update = function(e) {
      if (!this.destroyed) {
        var i = Lt.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - i), (!this._updateFPS || this._msToNextUpdate <= 0) && (r.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
      }
    }, t.prototype.load = function() {
      var e = this;
      if (this._load)
        return this._load;
      var i = this.source;
      return (i.readyState === i.HAVE_ENOUGH_DATA || i.readyState === i.HAVE_FUTURE_DATA) && i.width && i.height && (i.complete = !0), i.addEventListener("play", this._onPlayStart.bind(this)), i.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (i.addEventListener("canplay", this._onCanPlay), i.addEventListener("canplaythrough", this._onCanPlay), i.addEventListener("error", this._onError, !0)), this._load = new Promise(function(n) {
        e.valid ? n(e) : (e._resolve = n, i.load());
      }), this._load;
    }, t.prototype._onError = function(e) {
      this.source.removeEventListener("error", this._onError, !0), this.onError.emit(e);
    }, t.prototype._isSourcePlaying = function() {
      var e = this.source;
      return !e.paused && !e.ended && this._isSourceReady();
    }, t.prototype._isSourceReady = function() {
      var e = this.source;
      return e.readyState > 2;
    }, t.prototype._onPlayStart = function() {
      this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Lt.shared.add(this.update, this), this._isConnectedToTicker = !0);
    }, t.prototype._onPlayStop = function() {
      this._isConnectedToTicker && (Lt.shared.remove(this.update, this), this._isConnectedToTicker = !1);
    }, t.prototype._onCanPlay = function() {
      var e = this.source;
      e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlay);
      var i = this.valid;
      this.resize(e.videoWidth, e.videoHeight), !i && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play();
    }, t.prototype.dispose = function() {
      this._isConnectedToTicker && (Lt.shared.remove(this.update, this), this._isConnectedToTicker = !1);
      var e = this.source;
      e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), r.prototype.dispose.call(this);
    }, Object.defineProperty(t.prototype, "autoUpdate", {
      /** Should the base texture automatically update itself, set to true by default. */
      get: function() {
        return this._autoUpdate;
      },
      set: function(e) {
        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Lt.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Lt.shared.add(this.update, this), this._isConnectedToTicker = !0));
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "updateFPS", {
      /**
       * How many times a second to update the texture from the video. Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       */
      get: function() {
        return this._updateFPS;
      },
      set: function(e) {
        e !== this._updateFPS && (this._updateFPS = e);
      },
      enumerable: !1,
      configurable: !0
    }), t.test = function(e, i) {
      return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || t.TYPES.indexOf(i) > -1;
    }, t.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], t.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    }, t;
  }(ui)
), Gd = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e) {
      return r.call(this, e) || this;
    }
    return t.test = function(e) {
      return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && e instanceof ImageBitmap;
    }, t;
  }(ui)
);
Ds.push(jh, Gd, Ld, Ud, Bd, Mr, Fd, Dd);
var jd = (
  /** @class */
  function(r) {
    It(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.upload = function(e, i, n) {
      var s = e.gl;
      s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.alphaMode === Se.UNPACK);
      var o = i.realWidth, a = i.realHeight;
      return n.width === o && n.height === a ? s.texSubImage2D(i.target, 0, 0, 0, o, a, i.format, n.type, this.data) : (n.width = o, n.height = a, s.texImage2D(i.target, 0, n.internalFormat, o, a, 0, i.format, n.type, this.data)), !0;
    }, t;
  }(Mr)
), Bs = (
  /** @class */
  function() {
    function r(t, e) {
      this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Zt("disposeFramebuffer"), this.multisample = Rt.NONE;
    }
    return Object.defineProperty(r.prototype, "colorTexture", {
      /**
       * Reference to the colorTexture.
       * @readonly
       */
      get: function() {
        return this.colorTextures[0];
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.addColorTexture = function(t, e) {
      return t === void 0 && (t = 0), this.colorTextures[t] = e || new gt(null, {
        scaleMode: Me.NEAREST,
        resolution: 1,
        mipmap: Ee.OFF,
        width: this.width,
        height: this.height
      }), this.dirtyId++, this.dirtyFormat++, this;
    }, r.prototype.addDepthTexture = function(t) {
      return this.depthTexture = t || new gt(new jd(null, { width: this.width, height: this.height }), {
        scaleMode: Me.NEAREST,
        resolution: 1,
        width: this.width,
        height: this.height,
        mipmap: Ee.OFF,
        format: z.DEPTH_COMPONENT,
        type: st.UNSIGNED_SHORT
      }), this.dirtyId++, this.dirtyFormat++, this;
    }, r.prototype.enableDepth = function() {
      return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;
    }, r.prototype.enableStencil = function() {
      return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;
    }, r.prototype.resize = function(t, e) {
      if (t = Math.round(t), e = Math.round(e), !(t === this.width && e === this.height)) {
        this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;
        for (var i = 0; i < this.colorTextures.length; i++) {
          var n = this.colorTextures[i], s = n.resolution;
          n.setSize(t / s, e / s);
        }
        if (this.depthTexture) {
          var s = this.depthTexture.resolution;
          this.depthTexture.setSize(t / s, e / s);
        }
      }
    }, r.prototype.dispose = function() {
      this.disposeRunner.emit(this, !1);
    }, r.prototype.destroyDepthTexture = function() {
      this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
    }, r;
  }()
), Hh = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e) {
      e === void 0 && (e = {});
      var i = this;
      if (typeof e == "number") {
        var n = arguments[0], s = arguments[1], o = arguments[2], a = arguments[3];
        e = { width: n, height: s, scaleMode: o, resolution: a };
      }
      return e.width = e.width || 100, e.height = e.height || 100, e.multisample = e.multisample !== void 0 ? e.multisample : Rt.NONE, i = r.call(this, null, e) || this, i.mipmap = Ee.OFF, i.valid = !0, i.clearColor = [0, 0, 0, 0], i.framebuffer = new Bs(i.realWidth, i.realHeight).addColorTexture(0, i), i.framebuffer.multisample = e.multisample, i.maskStack = [], i.filterStack = [{}], i;
    }
    return t.prototype.resize = function(e, i) {
      this.framebuffer.resize(e * this.resolution, i * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
    }, t.prototype.dispose = function() {
      this.framebuffer.dispose(), r.prototype.dispose.call(this);
    }, t.prototype.destroy = function() {
      r.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
    }, t;
  }(gt)
), $h = (
  /** @class */
  function() {
    function r() {
      this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
    }
    return r.prototype.set = function(t, e, i) {
      var n = e.width, s = e.height;
      if (i) {
        var o = t.width / 2 / n, a = t.height / 2 / s, h = t.x / n + o, l = t.y / s + a;
        i = kt.add(i, kt.NW), this.x0 = h + o * kt.uX(i), this.y0 = l + a * kt.uY(i), i = kt.add(i, 2), this.x1 = h + o * kt.uX(i), this.y1 = l + a * kt.uY(i), i = kt.add(i, 2), this.x2 = h + o * kt.uX(i), this.y2 = l + a * kt.uY(i), i = kt.add(i, 2), this.x3 = h + o * kt.uX(i), this.y3 = l + a * kt.uY(i);
      } else
        this.x0 = t.x / n, this.y0 = t.y / s, this.x1 = (t.x + t.width) / n, this.y1 = t.y / s, this.x2 = (t.x + t.width) / n, this.y2 = (t.y + t.height) / s, this.x3 = t.x / n, this.y3 = (t.y + t.height) / s;
      this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
    }, r.prototype.toString = function() {
      return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
    }, r;
  }()
), ga = new $h();
function Gr(r) {
  r.destroy = function() {
  }, r.on = function() {
  }, r.once = function() {
  }, r.emit = function() {
  };
}
var ot = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e, i, n, s, o, a) {
      var h = r.call(this) || this;
      if (h.noFrame = !1, i || (h.noFrame = !0, i = new dt(0, 0, 1, 1)), e instanceof t && (e = e.baseTexture), h.baseTexture = e, h._frame = i, h.trim = s, h.valid = !1, h._uvs = ga, h.uvMatrix = null, h.orig = n || i, h._rotate = Number(o || 0), o === !0)
        h._rotate = 2;
      else if (h._rotate % 2 !== 0)
        throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
      return h.defaultAnchor = a ? new Ot(a.x, a.y) : new Ot(0, 0), h._updateID = 0, h.textureCacheIds = [], e.valid ? h.noFrame ? e.valid && h.onBaseTextureUpdated(e) : h.frame = i : e.once("loaded", h.onBaseTextureUpdated, h), h.noFrame && e.on("update", h.onBaseTextureUpdated, h), h;
    }
    return t.prototype.update = function() {
      this.baseTexture.resource && this.baseTexture.resource.update();
    }, t.prototype.onBaseTextureUpdated = function(e) {
      if (this.noFrame) {
        if (!this.baseTexture.valid)
          return;
        this._frame.width = e.width, this._frame.height = e.height, this.valid = !0, this.updateUvs();
      } else
        this.frame = this._frame;
      this.emit("update", this);
    }, t.prototype.destroy = function(e) {
      if (this.baseTexture) {
        if (e) {
          var i = this.baseTexture.resource;
          i && i.url && Qt[i.url] && t.removeFromCache(i.url), this.baseTexture.destroy();
        }
        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
      }
      this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, t.removeFromCache(this), this.textureCacheIds = null;
    }, t.prototype.clone = function() {
      var e = this._frame.clone(), i = this._frame === this.orig ? e : this.orig.clone(), n = new t(this.baseTexture, !this.noFrame && e, i, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
      return this.noFrame && (n._frame = e), n;
    }, t.prototype.updateUvs = function() {
      this._uvs === ga && (this._uvs = new $h()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
    }, t.from = function(e, i, n) {
      i === void 0 && (i = {}), n === void 0 && (n = K.STRICT_TEXTURE_CACHE);
      var s = typeof e == "string", o = null;
      if (s)
        o = e;
      else if (e instanceof gt) {
        if (!e.cacheId) {
          var a = i && i.pixiIdPrefix || "pixiid";
          e.cacheId = a + "-" + Pi(), gt.addToCache(e, e.cacheId);
        }
        o = e.cacheId;
      } else {
        if (!e._pixiId) {
          var a = i && i.pixiIdPrefix || "pixiid";
          e._pixiId = a + "_" + Pi();
        }
        o = e._pixiId;
      }
      var h = Qt[o];
      if (s && n && !h)
        throw new Error('The cacheId "' + o + '" does not exist in TextureCache.');
      return !h && !(e instanceof gt) ? (i.resolution || (i.resolution = Cn(e)), h = new t(new gt(e, i)), h.baseTexture.cacheId = o, gt.addToCache(h.baseTexture, o), t.addToCache(h, o)) : !h && e instanceof gt && (h = new t(e), t.addToCache(h, o)), h;
    }, t.fromURL = function(e, i) {
      var n = Object.assign({ autoLoad: !1 }, i?.resourceOptions), s = t.from(e, Object.assign({ resourceOptions: n }, i), !1), o = s.baseTexture.resource;
      return s.baseTexture.valid ? Promise.resolve(s) : o.load().then(function() {
        return Promise.resolve(s);
      });
    }, t.fromBuffer = function(e, i, n, s) {
      return new t(gt.fromBuffer(e, i, n, s));
    }, t.fromLoader = function(e, i, n, s) {
      var o = new gt(e, Object.assign({
        scaleMode: K.SCALE_MODE,
        resolution: Cn(i)
      }, s)), a = o.resource;
      a instanceof jh && (a.url = i);
      var h = new t(o);
      return n || (n = i), gt.addToCache(h.baseTexture, n), t.addToCache(h, n), n !== i && (gt.addToCache(h.baseTexture, i), t.addToCache(h, i)), h.baseTexture.valid ? Promise.resolve(h) : new Promise(function(l) {
        h.baseTexture.once("loaded", function() {
          return l(h);
        });
      });
    }, t.addToCache = function(e, i) {
      i && (e.textureCacheIds.indexOf(i) === -1 && e.textureCacheIds.push(i), Qt[i] && console.warn("Texture added to the cache with an id [" + i + "] that already had an entry"), Qt[i] = e);
    }, t.removeFromCache = function(e) {
      if (typeof e == "string") {
        var i = Qt[e];
        if (i) {
          var n = i.textureCacheIds.indexOf(e);
          return n > -1 && i.textureCacheIds.splice(n, 1), delete Qt[e], i;
        }
      } else if (e && e.textureCacheIds) {
        for (var s = 0; s < e.textureCacheIds.length; ++s)
          Qt[e.textureCacheIds[s]] === e && delete Qt[e.textureCacheIds[s]];
        return e.textureCacheIds.length = 0, e;
      }
      return null;
    }, Object.defineProperty(t.prototype, "resolution", {
      /**
       * Returns resolution of baseTexture
       * @readonly
       */
      get: function() {
        return this.baseTexture.resolution;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "frame", {
      /**
       * The frame specifies the region of the base texture that this texture uses.
       * Please call `updateUvs()` after you change coordinates of `frame` manually.
       */
      get: function() {
        return this._frame;
      },
      set: function(e) {
        this._frame = e, this.noFrame = !1;
        var i = e.x, n = e.y, s = e.width, o = e.height, a = i + s > this.baseTexture.width, h = n + o > this.baseTexture.height;
        if (a || h) {
          var l = a && h ? "and" : "or", u = "X: " + i + " + " + s + " = " + (i + s) + " > " + this.baseTexture.width, c = "Y: " + n + " + " + o + " = " + (n + o) + " > " + this.baseTexture.height;
          throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (u + " " + l + " " + c));
        }
        this.valid = s && o && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = e), this.valid && this.updateUvs();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "rotate", {
      /**
       * Indicates whether the texture is rotated inside the atlas
       * set to 2 to compensate for texture packer rotation
       * set to 6 to compensate for spine packer rotation
       * can be used to rotate or mirror sprites
       * See {@link PIXI.groupD8} for explanation
       */
      get: function() {
        return this._rotate;
      },
      set: function(e) {
        this._rotate = e, this.valid && this.updateUvs();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "width", {
      /** The width of the Texture in pixels. */
      get: function() {
        return this.orig.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the Texture in pixels. */
      get: function() {
        return this.orig.height;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.castToBaseTexture = function() {
      return this.baseTexture;
    }, Object.defineProperty(t, "EMPTY", {
      /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */
      get: function() {
        return t._EMPTY || (t._EMPTY = new t(new gt()), Gr(t._EMPTY), Gr(t._EMPTY.baseTexture)), t._EMPTY;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "WHITE", {
      /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */
      get: function() {
        if (!t._WHITE) {
          var e = K.ADAPTER.createCanvas(16, 16), i = e.getContext("2d");
          e.width = 16, e.height = 16, i.fillStyle = "white", i.fillRect(0, 0, 16, 16), t._WHITE = new t(gt.from(e)), Gr(t._WHITE), Gr(t._WHITE.baseTexture);
        }
        return t._WHITE;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Pe)
), ce = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e, i) {
      var n = r.call(this, e, i) || this;
      return n.valid = !0, n.filterFrame = null, n.filterPoolKey = null, n.updateUvs(), n;
    }
    return Object.defineProperty(t.prototype, "framebuffer", {
      /**
       * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
       * @readonly
       */
      get: function() {
        return this.baseTexture.framebuffer;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "multisample", {
      /**
       * Shortcut to `this.framebuffer.multisample`.
       * @default PIXI.MSAA_QUALITY.NONE
       */
      get: function() {
        return this.framebuffer.multisample;
      },
      set: function(e) {
        this.framebuffer.multisample = e;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.resize = function(e, i, n) {
      n === void 0 && (n = !0);
      var s = this.baseTexture.resolution, o = Math.round(e * s) / s, a = Math.round(i * s) / s;
      this.valid = o > 0 && a > 0, this._frame.width = this.orig.width = o, this._frame.height = this.orig.height = a, n && this.baseTexture.resize(o, a), this.updateUvs();
    }, t.prototype.setResolution = function(e) {
      var i = this.baseTexture;
      i.resolution !== e && (i.setResolution(e), this.resize(i.width, i.height, !1));
    }, t.create = function(e) {
      for (var i = arguments, n = [], s = 1; s < arguments.length; s++)
        n[s - 1] = i[s];
      return typeof e == "number" && (Te("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), e = {
        width: e,
        height: n[0],
        scaleMode: n[1],
        resolution: n[2]
      }), new t(new Hh(e));
    }, t;
  }(ot)
), Hd = (
  /** @class */
  function() {
    function r(t) {
      this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;
    }
    return r.prototype.createTexture = function(t, e, i) {
      i === void 0 && (i = Rt.NONE);
      var n = new Hh(Object.assign({
        width: t,
        height: e,
        resolution: 1,
        multisample: i
      }, this.textureOptions));
      return new ce(n);
    }, r.prototype.getOptimalTexture = function(t, e, i, n) {
      i === void 0 && (i = 1), n === void 0 && (n = Rt.NONE);
      var s;
      t = Math.ceil(t * i - 1e-6), e = Math.ceil(e * i - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || e !== this._pixelsHeight ? (t = Pn(t), e = Pn(e), s = ((t & 65535) << 16 | e & 65535) >>> 0, n > 1 && (s += n * 4294967296)) : s = n > 1 ? -n : -1, this.texturePool[s] || (this.texturePool[s] = []);
      var o = this.texturePool[s].pop();
      return o || (o = this.createTexture(t, e, n)), o.filterPoolKey = s, o.setResolution(i), o;
    }, r.prototype.getFilterTexture = function(t, e, i) {
      var n = this.getOptimalTexture(t.width, t.height, e || t.resolution, i || Rt.NONE);
      return n.filterFrame = t.filterFrame, n;
    }, r.prototype.returnTexture = function(t) {
      var e = t.filterPoolKey;
      t.filterFrame = null, this.texturePool[e].push(t);
    }, r.prototype.returnFilterTexture = function(t) {
      this.returnTexture(t);
    }, r.prototype.clear = function(t) {
      if (t = t !== !1, t)
        for (var e in this.texturePool) {
          var i = this.texturePool[e];
          if (i)
            for (var n = 0; n < i.length; n++)
              i[n].destroy(!0);
        }
      this.texturePool = {};
    }, r.prototype.setScreenSize = function(t) {
      if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {
        this.enableFullScreen = t.width > 0 && t.height > 0;
        for (var e in this.texturePool)
          if (Number(e) < 0) {
            var i = this.texturePool[e];
            if (i)
              for (var n = 0; n < i.length; n++)
                i[n].destroy(!0);
            this.texturePool[e] = [];
          }
        this._pixelsWidth = t.width, this._pixelsHeight = t.height;
      }
    }, r.SCREEN_KEY = -1, r;
  }()
), ba = (
  /** @class */
  function() {
    function r(t, e, i, n, s, o, a) {
      e === void 0 && (e = 0), i === void 0 && (i = !1), n === void 0 && (n = st.FLOAT), this.buffer = t, this.size = e, this.normalized = i, this.type = n, this.stride = s, this.start = o, this.instance = a;
    }
    return r.prototype.destroy = function() {
      this.buffer = null;
    }, r.from = function(t, e, i, n, s) {
      return new r(t, e, i, n, s);
    }, r;
  }()
), $d = 0, Xt = (
  /** @class */
  function() {
    function r(t, e, i) {
      e === void 0 && (e = !0), i === void 0 && (i = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = i, this.static = e, this.id = $d++, this.disposeRunner = new Zt("disposeBuffer");
    }
    return r.prototype.update = function(t) {
      t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++;
    }, r.prototype.dispose = function() {
      this.disposeRunner.emit(this, !1);
    }, r.prototype.destroy = function() {
      this.dispose(), this.data = null;
    }, Object.defineProperty(r.prototype, "index", {
      get: function() {
        return this.type === Ne.ELEMENT_ARRAY_BUFFER;
      },
      /**
       * Flags whether this is an index buffer.
       *
       * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make
       * the buffer of type `ARRAY_BUFFER`.
       *
       * For backwards compatibility.
       */
      set: function(t) {
        this.type = t ? Ne.ELEMENT_ARRAY_BUFFER : Ne.ARRAY_BUFFER;
      },
      enumerable: !1,
      configurable: !0
    }), r.from = function(t) {
      return t instanceof Array && (t = new Float32Array(t)), new r(t);
    }, r;
  }()
), zd = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function Xd(r, t) {
  for (var e = 0, i = 0, n = {}, s = 0; s < r.length; s++)
    i += t[s], e += r[s].length;
  for (var o = new ArrayBuffer(e * 4), a = null, h = 0, s = 0; s < r.length; s++) {
    var l = t[s], u = r[s], c = Ah(u);
    n[c] || (n[c] = new zd[c](o)), a = n[c];
    for (var f = 0; f < u.length; f++) {
      var d = (f / l | 0) * i + h, p = f % l;
      a[d + p] = u[f];
    }
    h += l;
  }
  return new Float32Array(o);
}
var xa = { 5126: 4, 5123: 2, 5121: 1 }, Vd = 0, Wd = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
}, Rr = (
  /** @class */
  function() {
    function r(t, e) {
      t === void 0 && (t = []), e === void 0 && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = Vd++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new Zt("disposeGeometry"), this.refCount = 0;
    }
    return r.prototype.addAttribute = function(t, e, i, n, s, o, a, h) {
      if (i === void 0 && (i = 0), n === void 0 && (n = !1), h === void 0 && (h = !1), !e)
        throw new Error("You must pass a buffer when creating an attribute");
      e instanceof Xt || (e instanceof Array && (e = new Float32Array(e)), e = new Xt(e));
      var l = t.split("|");
      if (l.length > 1) {
        for (var u = 0; u < l.length; u++)
          this.addAttribute(l[u], e, i, n, s);
        return this;
      }
      var c = this.buffers.indexOf(e);
      return c === -1 && (this.buffers.push(e), c = this.buffers.length - 1), this.attributes[t] = new ba(c, i, n, s, o, a, h), this.instanced = this.instanced || h, this;
    }, r.prototype.getAttribute = function(t) {
      return this.attributes[t];
    }, r.prototype.getBuffer = function(t) {
      return this.buffers[this.getAttribute(t).buffer];
    }, r.prototype.addIndex = function(t) {
      return t instanceof Xt || (t instanceof Array && (t = new Uint16Array(t)), t = new Xt(t)), t.type = Ne.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.indexOf(t) === -1 && this.buffers.push(t), this;
    }, r.prototype.getIndex = function() {
      return this.indexBuffer;
    }, r.prototype.interleave = function() {
      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
        return this;
      var t = [], e = [], i = new Xt(), n;
      for (n in this.attributes) {
        var s = this.attributes[n], o = this.buffers[s.buffer];
        t.push(o.data), e.push(s.size * xa[s.type] / 4), s.buffer = 0;
      }
      for (i.data = Xd(t, e), n = 0; n < this.buffers.length; n++)
        this.buffers[n] !== this.indexBuffer && this.buffers[n].destroy();
      return this.buffers = [i], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
    }, r.prototype.getSize = function() {
      for (var t in this.attributes) {
        var e = this.attributes[t], i = this.buffers[e.buffer];
        return i.data.length / (e.stride / 4 || e.size);
      }
      return 0;
    }, r.prototype.dispose = function() {
      this.disposeRunner.emit(this, !1);
    }, r.prototype.destroy = function() {
      this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
    }, r.prototype.clone = function() {
      for (var t = new r(), e = 0; e < this.buffers.length; e++)
        t.buffers[e] = new Xt(this.buffers[e].data.slice(0));
      for (var e in this.attributes) {
        var i = this.attributes[e];
        t.attributes[e] = new ba(i.buffer, i.size, i.normalized, i.type, i.stride, i.start, i.instance);
      }
      return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = Ne.ELEMENT_ARRAY_BUFFER), t;
    }, r.merge = function(t) {
      for (var e = new r(), i = [], n = [], s = [], o, a = 0; a < t.length; a++) {
        o = t[a];
        for (var h = 0; h < o.buffers.length; h++)
          n[h] = n[h] || 0, n[h] += o.buffers[h].data.length, s[h] = 0;
      }
      for (var a = 0; a < o.buffers.length; a++)
        i[a] = new Wd[Ah(o.buffers[a].data)](n[a]), e.buffers[a] = new Xt(i[a]);
      for (var a = 0; a < t.length; a++) {
        o = t[a];
        for (var h = 0; h < o.buffers.length; h++)
          i[h].set(o.buffers[h].data, s[h]), s[h] += o.buffers[h].data.length;
      }
      if (e.attributes = o.attributes, o.indexBuffer) {
        e.indexBuffer = e.buffers[o.buffers.indexOf(o.indexBuffer)], e.indexBuffer.type = Ne.ELEMENT_ARRAY_BUFFER;
        for (var l = 0, u = 0, c = 0, f = 0, a = 0; a < o.buffers.length; a++)
          if (o.buffers[a] !== o.indexBuffer) {
            f = a;
            break;
          }
        for (var a in o.attributes) {
          var d = o.attributes[a];
          (d.buffer | 0) === f && (u += d.size * xa[d.type] / 4);
        }
        for (var a = 0; a < t.length; a++) {
          for (var p = t[a].indexBuffer.data, h = 0; h < p.length; h++)
            e.indexBuffer.data[h + c] += l;
          l += t[a].buffers[f].data.length / u, c += p.length;
        }
      }
      return e;
    }, r;
  }()
), Yd = (
  /** @class */
  function(r) {
    It(t, r);
    function t() {
      var e = r.call(this) || this;
      return e.addAttribute("aVertexPosition", new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ])).addIndex([0, 1, 3, 2]), e;
    }
    return t;
  }(Rr)
), zh = (
  /** @class */
  function(r) {
    It(t, r);
    function t() {
      var e = r.call(this) || this;
      return e.vertices = new Float32Array([
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1
      ]), e.uvs = new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]), e.vertexBuffer = new Xt(e.vertices), e.uvBuffer = new Xt(e.uvs), e.addAttribute("aVertexPosition", e.vertexBuffer).addAttribute("aTextureCoord", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e;
    }
    return t.prototype.map = function(e, i) {
      var n = 0, s = 0;
      return this.uvs[0] = n, this.uvs[1] = s, this.uvs[2] = n + i.width / e.width, this.uvs[3] = s, this.uvs[4] = n + i.width / e.width, this.uvs[5] = s + i.height / e.height, this.uvs[6] = n, this.uvs[7] = s + i.height / e.height, n = i.x, s = i.y, this.vertices[0] = n, this.vertices[1] = s, this.vertices[2] = n + i.width, this.vertices[3] = s, this.vertices[4] = n + i.width, this.vertices[5] = s + i.height, this.vertices[6] = n, this.vertices[7] = s + i.height, this.invalidate(), this;
    }, t.prototype.invalidate = function() {
      return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
    }, t;
  }(Rr)
), qd = 0, Ti = (
  /** @class */
  function() {
    function r(t, e, i) {
      this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = qd++, this.static = !!e, this.ubo = !!i, t instanceof Xt ? (this.buffer = t, this.buffer.type = Ne.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Xt(new Float32Array(1)), this.buffer.type = Ne.UNIFORM_BUFFER, this.autoManage = !0));
    }
    return r.prototype.update = function() {
      this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
    }, r.prototype.add = function(t, e, i) {
      if (!this.ubo)
        this.uniforms[t] = new r(e, i);
      else
        throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }, r.from = function(t, e, i) {
      return new r(t, e, i);
    }, r.uboFrom = function(t, e) {
      return new r(t, e ?? !0, !0);
    }, r;
  }()
), Zd = (
  /** @class */
  function() {
    function r() {
      this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = Rt.NONE, this.sourceFrame = new dt(), this.destinationFrame = new dt(), this.bindingSourceFrame = new dt(), this.bindingDestinationFrame = new dt(), this.filters = [], this.transform = null;
    }
    return r.prototype.clear = function() {
      this.target = null, this.filters = null, this.renderTexture = null;
    }, r;
  }()
), jr = [new Ot(), new Ot(), new Ot(), new Ot()], ts = new Vt(), Kd = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new Hd(), this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new Yd(), this.quadUv = new zh(), this.tempRect = new dt(), this.activeState = {}, this.globalUniforms = new Ti({
        outputFrame: new dt(),
        inputSize: new Float32Array(4),
        inputPixel: new Float32Array(4),
        inputClamp: new Float32Array(4),
        resolution: 1,
        // legacy variables
        filterArea: new Float32Array(4),
        filterClamp: new Float32Array(4)
      }, !0), this.forceClear = !1, this.useMaxPadding = !1;
    }
    return r.prototype.push = function(t, e) {
      for (var i, n, s = this.renderer, o = this.defaultFilterStack, a = this.statePool.pop() || new Zd(), h = this.renderer.renderTexture, l = e[0].resolution, u = e[0].multisample, c = e[0].padding, f = e[0].autoFit, d = (i = e[0].legacy) !== null && i !== void 0 ? i : !0, p = 1; p < e.length; p++) {
        var v = e[p];
        l = Math.min(l, v.resolution), u = Math.min(u, v.multisample), c = this.useMaxPadding ? Math.max(c, v.padding) : c + v.padding, f = f && v.autoFit, d = d || ((n = v.legacy) !== null && n !== void 0 ? n : !0);
      }
      o.length === 1 && (this.defaultFilterStack[0].renderTexture = h.current), o.push(a), a.resolution = l, a.multisample = u, a.legacy = d, a.target = t, a.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), a.sourceFrame.pad(c);
      var _ = this.tempRect.copyFrom(h.sourceFrame);
      s.projection.transform && this.transformAABB(ts.copyFrom(s.projection.transform).invert(), _), f ? (a.sourceFrame.fit(_), (a.sourceFrame.width <= 0 || a.sourceFrame.height <= 0) && (a.sourceFrame.width = 0, a.sourceFrame.height = 0)) : a.sourceFrame.intersects(_) || (a.sourceFrame.width = 0, a.sourceFrame.height = 0), this.roundFrame(a.sourceFrame, h.current ? h.current.resolution : s.resolution, h.sourceFrame, h.destinationFrame, s.projection.transform), a.renderTexture = this.getOptimalFilterTexture(a.sourceFrame.width, a.sourceFrame.height, l, u), a.filters = e, a.destinationFrame.width = a.renderTexture.width, a.destinationFrame.height = a.renderTexture.height;
      var m = this.tempRect;
      m.x = 0, m.y = 0, m.width = a.sourceFrame.width, m.height = a.sourceFrame.height, a.renderTexture.filterFrame = a.sourceFrame, a.bindingSourceFrame.copyFrom(h.sourceFrame), a.bindingDestinationFrame.copyFrom(h.destinationFrame), a.transform = s.projection.transform, s.projection.transform = null, h.bind(a.renderTexture, a.sourceFrame, m), s.framebuffer.clear(0, 0, 0, 0);
    }, r.prototype.pop = function() {
      var t = this.defaultFilterStack, e = t.pop(), i = e.filters;
      this.activeState = e;
      var n = this.globalUniforms.uniforms;
      n.outputFrame = e.sourceFrame, n.resolution = e.resolution;
      var s = n.inputSize, o = n.inputPixel, a = n.inputClamp;
      if (s[0] = e.destinationFrame.width, s[1] = e.destinationFrame.height, s[2] = 1 / s[0], s[3] = 1 / s[1], o[0] = Math.round(s[0] * e.resolution), o[1] = Math.round(s[1] * e.resolution), o[2] = 1 / o[0], o[3] = 1 / o[1], a[0] = 0.5 * o[2], a[1] = 0.5 * o[3], a[2] = e.sourceFrame.width * s[2] - 0.5 * o[2], a[3] = e.sourceFrame.height * s[3] - 0.5 * o[3], e.legacy) {
        var h = n.filterArea;
        h[0] = e.destinationFrame.width, h[1] = e.destinationFrame.height, h[2] = e.sourceFrame.x, h[3] = e.sourceFrame.y, n.filterClamp = n.inputClamp;
      }
      this.globalUniforms.update();
      var l = t[t.length - 1];
      if (this.renderer.framebuffer.blit(), i.length === 1)
        i[0].apply(this, e.renderTexture, l.renderTexture, be.BLEND, e), this.returnFilterTexture(e.renderTexture);
      else {
        var u = e.renderTexture, c = this.getOptimalFilterTexture(u.width, u.height, e.resolution);
        c.filterFrame = u.filterFrame;
        var f = 0;
        for (f = 0; f < i.length - 1; ++f) {
          f === 1 && e.multisample > 1 && (c = this.getOptimalFilterTexture(u.width, u.height, e.resolution), c.filterFrame = u.filterFrame), i[f].apply(this, u, c, be.CLEAR, e);
          var d = u;
          u = c, c = d;
        }
        i[f].apply(this, u, l.renderTexture, be.BLEND, e), f > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture(u), this.returnFilterTexture(c);
      }
      e.clear(), this.statePool.push(e);
    }, r.prototype.bindAndClear = function(t, e) {
      e === void 0 && (e = be.CLEAR);
      var i = this.renderer, n = i.renderTexture, s = i.state;
      if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) {
        var o = this.tempRect;
        o.x = 0, o.y = 0, o.width = t.filterFrame.width, o.height = t.filterFrame.height, n.bind(t, t.filterFrame, o);
      } else t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? n.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
      var a = s.stateId & 1 || this.forceClear;
      (e === be.CLEAR || e === be.BLIT && a) && this.renderer.framebuffer.clear(0, 0, 0, 0);
    }, r.prototype.applyFilter = function(t, e, i, n) {
      var s = this.renderer;
      s.state.set(t.state), this.bindAndClear(i, n), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, s.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), s.geometry.bind(this.quadUv), s.geometry.draw(we.TRIANGLES)) : (s.geometry.bind(this.quad), s.geometry.draw(we.TRIANGLE_STRIP));
    }, r.prototype.calculateSpriteMatrix = function(t, e) {
      var i = this.activeState, n = i.sourceFrame, s = i.destinationFrame, o = e._texture.orig, a = t.set(s.width, 0, 0, s.height, n.x, n.y), h = e.worldTransform.copyTo(Vt.TEMP_MATRIX);
      return h.invert(), a.prepend(h), a.scale(1 / o.width, 1 / o.height), a.translate(e.anchor.x, e.anchor.y), a;
    }, r.prototype.destroy = function() {
      this.renderer = null, this.texturePool.clear(!1);
    }, r.prototype.getOptimalFilterTexture = function(t, e, i, n) {
      return i === void 0 && (i = 1), n === void 0 && (n = Rt.NONE), this.texturePool.getOptimalTexture(t, e, i, n);
    }, r.prototype.getFilterTexture = function(t, e, i) {
      if (typeof t == "number") {
        var n = t;
        t = e, e = n;
      }
      t = t || this.activeState.renderTexture;
      var s = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, i || Rt.NONE);
      return s.filterFrame = t.filterFrame, s;
    }, r.prototype.returnFilterTexture = function(t) {
      this.texturePool.returnTexture(t);
    }, r.prototype.emptyPool = function() {
      this.texturePool.clear(!0);
    }, r.prototype.resize = function() {
      this.texturePool.setScreenSize(this.renderer.view);
    }, r.prototype.transformAABB = function(t, e) {
      var i = jr[0], n = jr[1], s = jr[2], o = jr[3];
      i.set(e.left, e.top), n.set(e.left, e.bottom), s.set(e.right, e.top), o.set(e.right, e.bottom), t.apply(i, i), t.apply(n, n), t.apply(s, s), t.apply(o, o);
      var a = Math.min(i.x, n.x, s.x, o.x), h = Math.min(i.y, n.y, s.y, o.y), l = Math.max(i.x, n.x, s.x, o.x), u = Math.max(i.y, n.y, s.y, o.y);
      e.x = a, e.y = h, e.width = l - a, e.height = u - h;
    }, r.prototype.roundFrame = function(t, e, i, n, s) {
      if (!(t.width <= 0 || t.height <= 0 || i.width <= 0 || i.height <= 0)) {
        if (s) {
          var o = s.a, a = s.b, h = s.c, l = s.d;
          if ((Math.abs(a) > 1e-4 || Math.abs(h) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(l) > 1e-4))
            return;
        }
        s = s ? ts.copyFrom(s) : ts.identity(), s.translate(-i.x, -i.y).scale(n.width / i.width, n.height / i.height).translate(n.x, n.y), this.transformAABB(s, t), t.ceil(e), this.transformAABB(s.invert(), t);
      }
    }, r;
  }()
), Bn = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t;
    }
    return r.prototype.flush = function() {
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r.prototype.start = function() {
    }, r.prototype.stop = function() {
      this.flush();
    }, r.prototype.render = function(t) {
    }, r;
  }()
), Jd = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.emptyRenderer = new Bn(t), this.currentRenderer = this.emptyRenderer;
    }
    return r.prototype.setObjectRenderer = function(t) {
      this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start());
    }, r.prototype.flush = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, r.prototype.reset = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, r.prototype.copyBoundTextures = function(t, e) {
      for (var i = this.renderer.texture.boundTextures, n = e - 1; n >= 0; --n)
        t[n] = i[n] || null, t[n] && (t[n]._batchLocation = n);
    }, r.prototype.boundArray = function(t, e, i, n) {
      for (var s = t.elements, o = t.ids, a = t.count, h = 0, l = 0; l < a; l++) {
        var u = s[l], c = u._batchLocation;
        if (c >= 0 && c < n && e[c] === u) {
          o[l] = c;
          continue;
        }
        for (; h < n; ) {
          var f = e[h];
          if (f && f._batchEnabled === i && f._batchLocation === h) {
            h++;
            continue;
          }
          o[l] = h, u._batchLocation = h, e[h] = u;
          break;
        }
      }
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), wa = 0, Qd = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {
        uint32Indices: !1
      }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener("webglcontextlost", this.handleContextLost, !1), t.view.addEventListener("webglcontextrestored", this.handleContextRestored, !1);
    }
    return Object.defineProperty(r.prototype, "isLost", {
      /**
       * `true` if the context is lost
       * @readonly
       */
      get: function() {
        return !this.gl || this.gl.isContextLost();
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.contextChange = function(t) {
      this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = wa++;
    }, r.prototype.initFromContext = function(t) {
      this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = wa++, this.renderer.runners.contextChange.emit(t);
    }, r.prototype.initFromOptions = function(t) {
      var e = this.createContext(this.renderer.view, t);
      this.initFromContext(e);
    }, r.prototype.createContext = function(t, e) {
      var i;
      if (K.PREFER_ENV >= qe.WEBGL2 && (i = t.getContext("webgl2", e)), i)
        this.webGLVersion = 2;
      else if (this.webGLVersion = 1, i = t.getContext("webgl", e) || t.getContext("experimental-webgl", e), !i)
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      return this.gl = i, this.getExtensions(), this.gl;
    }, r.prototype.getExtensions = function() {
      var t = this.gl, e = {
        loseContext: t.getExtension("WEBGL_lose_context"),
        anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
        floatTextureLinear: t.getExtension("OES_texture_float_linear"),
        s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: t.getExtension("WEBGL_compressed_texture_etc"),
        etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: t.getExtension("WEBGL_compressed_texture_atc"),
        astc: t.getExtension("WEBGL_compressed_texture_astc")
      };
      this.webGLVersion === 1 ? Object.assign(this.extensions, e, {
        drawBuffers: t.getExtension("WEBGL_draw_buffers"),
        depthTexture: t.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: t.getExtension("OES_element_index_uint"),
        // Floats and half-floats
        floatTexture: t.getExtension("OES_texture_float"),
        floatTextureLinear: t.getExtension("OES_texture_float_linear"),
        textureHalfFloat: t.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
      }) : this.webGLVersion === 2 && Object.assign(this.extensions, e, {
        // Floats and half-floats
        colorBufferFloat: t.getExtension("EXT_color_buffer_float")
      });
    }, r.prototype.handleContextLost = function(t) {
      var e = this;
      t.preventDefault(), setTimeout(function() {
        e.gl.isContextLost() && e.extensions.loseContext && e.extensions.loseContext.restoreContext();
      }, 0);
    }, r.prototype.handleContextRestored = function() {
      this.renderer.runners.contextChange.emit(this.gl);
    }, r.prototype.destroy = function() {
      var t = this.renderer.view;
      this.renderer = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
    }, r.prototype.postrender = function() {
      this.renderer.renderingToScreen && this.gl.flush();
    }, r.prototype.validateContext = function(t) {
      var e = t.getContextAttributes(), i = "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext;
      i && (this.webGLVersion = 2), e && !e.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      var n = i || !!t.getExtension("OES_element_index_uint");
      this.supports.uint32Indices = n, n || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }, r;
  }()
), tp = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t) {
      this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = Rt.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
    }
    return r;
  }()
), ep = new dt(), ip = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new Bs(10, 10), this.msaaSamples = null;
    }
    return r.prototype.contextChange = function() {
      this.disposeAll(!0);
      var t = this.gl = this.renderer.gl;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new dt(), this.hasMRT = !0, this.writeDepthTexture = !0, this.renderer.context.webGLVersion === 1) {
        var e = this.renderer.context.extensions.drawBuffers, i = this.renderer.context.extensions.depthTexture;
        K.PREFER_ENV === qe.WEBGL_LEGACY && (e = null, i = null), e ? t.drawBuffers = function(n) {
          return e.drawBuffersWEBGL(n);
        } : (this.hasMRT = !1, t.drawBuffers = function() {
        }), i || (this.writeDepthTexture = !1);
      } else
        this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES);
    }, r.prototype.bind = function(t, e, i) {
      i === void 0 && (i = 0);
      var n = this.gl;
      if (t) {
        var s = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
        this.current !== t && (this.current = t, n.bindFramebuffer(n.FRAMEBUFFER, s.framebuffer)), s.mipLevel !== i && (t.dirtyId++, t.dirtyFormat++, s.mipLevel = i), s.dirtyId !== t.dirtyId && (s.dirtyId = t.dirtyId, s.dirtyFormat !== t.dirtyFormat ? (s.dirtyFormat = t.dirtyFormat, s.dirtySize = t.dirtySize, this.updateFramebuffer(t, i)) : s.dirtySize !== t.dirtySize && (s.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));
        for (var o = 0; o < t.colorTextures.length; o++) {
          var a = t.colorTextures[o];
          this.renderer.texture.unbind(a.parentTextureArray || a);
        }
        if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {
          var h = e.width >> i, l = e.height >> i, u = h / e.width;
          this.setViewport(e.x * u, e.y * u, h, l);
        } else {
          var h = t.width >> i, l = t.height >> i;
          this.setViewport(0, 0, h, l);
        }
      } else
        this.current && (this.current = null, n.bindFramebuffer(n.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
    }, r.prototype.setViewport = function(t, e, i, n) {
      var s = this.viewport;
      t = Math.round(t), e = Math.round(e), i = Math.round(i), n = Math.round(n), (s.width !== i || s.height !== n || s.x !== t || s.y !== e) && (s.x = t, s.y = e, s.width = i, s.height = n, this.gl.viewport(t, e, i, n));
    }, Object.defineProperty(r.prototype, "size", {
      /**
       * Get the size of the current width and height. Returns object with `width` and `height` values.
       * @readonly
       */
      get: function() {
        return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.clear = function(t, e, i, n, s) {
      s === void 0 && (s = Tn.COLOR | Tn.DEPTH);
      var o = this.gl;
      o.clearColor(t, e, i, n), o.clear(s);
    }, r.prototype.initFramebuffer = function(t) {
      var e = this.gl, i = new tp(e.createFramebuffer());
      return i.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = i, this.managedFramebuffers.push(t), t.disposeRunner.add(this), i;
    }, r.prototype.resizeFramebuffer = function(t) {
      var e = this.gl, i = t.glFramebuffers[this.CONTEXT_UID];
      i.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, i.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, i.multisample, e.RGBA8, t.width, t.height)), i.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, i.stencil), i.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, i.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));
      var n = t.colorTextures, s = n.length;
      e.drawBuffers || (s = Math.min(s, 1));
      for (var o = 0; o < s; o++) {
        var a = n[o], h = a.parentTextureArray || a;
        this.renderer.texture.bind(h, 0);
      }
      t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0);
    }, r.prototype.updateFramebuffer = function(t, e) {
      var i = this.gl, n = t.glFramebuffers[this.CONTEXT_UID], s = t.colorTextures, o = s.length;
      i.drawBuffers || (o = Math.min(o, 1)), n.multisample > 1 && this.canMultisampleFramebuffer(t) ? (n.msaaBuffer = n.msaaBuffer || i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, n.msaaBuffer), i.renderbufferStorageMultisample(i.RENDERBUFFER, n.multisample, i.RGBA8, t.width, t.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, n.msaaBuffer)) : n.msaaBuffer && (i.deleteRenderbuffer(n.msaaBuffer), n.msaaBuffer = null, n.blitFramebuffer && (n.blitFramebuffer.dispose(), n.blitFramebuffer = null));
      for (var a = [], h = 0; h < o; h++) {
        var l = s[h], u = l.parentTextureArray || l;
        this.renderer.texture.bind(u, 0), !(h === 0 && n.msaaBuffer) && (i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + h, l.target, u._glTextures[this.CONTEXT_UID].texture, e), a.push(i.COLOR_ATTACHMENT0 + h));
      }
      if (a.length > 1 && i.drawBuffers(a), t.depthTexture) {
        var c = this.writeDepthTexture;
        if (c) {
          var f = t.depthTexture;
          this.renderer.texture.bind(f, 0), i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, f._glTextures[this.CONTEXT_UID].texture, e);
        }
      }
      (t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (n.stencil = n.stencil || i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, n.stencil), n.msaaBuffer ? i.renderbufferStorageMultisample(i.RENDERBUFFER, n.multisample, i.DEPTH24_STENCIL8, t.width, t.height) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t.width, t.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, n.stencil)) : n.stencil && (i.deleteRenderbuffer(n.stencil), n.stencil = null);
    }, r.prototype.canMultisampleFramebuffer = function(t) {
      return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture;
    }, r.prototype.detectSamples = function(t) {
      var e = this.msaaSamples, i = Rt.NONE;
      if (t <= 1 || e === null)
        return i;
      for (var n = 0; n < e.length; n++)
        if (e[n] <= t) {
          i = e[n];
          break;
        }
      return i === 1 && (i = Rt.NONE), i;
    }, r.prototype.blit = function(t, e, i) {
      var n = this, s = n.current, o = n.renderer, a = n.gl, h = n.CONTEXT_UID;
      if (o.context.webGLVersion === 2 && s) {
        var l = s.glFramebuffers[h];
        if (l) {
          if (!t) {
            if (!l.msaaBuffer)
              return;
            var u = s.colorTextures[0];
            if (!u)
              return;
            l.blitFramebuffer || (l.blitFramebuffer = new Bs(s.width, s.height), l.blitFramebuffer.addColorTexture(0, u)), t = l.blitFramebuffer, t.colorTextures[0] !== u && (t.colorTextures[0] = u, t.dirtyId++, t.dirtyFormat++), (t.width !== s.width || t.height !== s.height) && (t.width = s.width, t.height = s.height, t.dirtyId++, t.dirtySize++);
          }
          e || (e = ep, e.width = s.width, e.height = s.height), i || (i = e);
          var c = e.width === i.width && e.height === i.height;
          this.bind(t), a.bindFramebuffer(a.READ_FRAMEBUFFER, l.framebuffer), a.blitFramebuffer(e.left, e.top, e.right, e.bottom, i.left, i.top, i.right, i.bottom, a.COLOR_BUFFER_BIT, c ? a.NEAREST : a.LINEAR);
        }
      }
    }, r.prototype.disposeFramebuffer = function(t, e) {
      var i = t.glFramebuffers[this.CONTEXT_UID], n = this.gl;
      if (i) {
        delete t.glFramebuffers[this.CONTEXT_UID];
        var s = this.managedFramebuffers.indexOf(t);
        s >= 0 && this.managedFramebuffers.splice(s, 1), t.disposeRunner.remove(this), e || (n.deleteFramebuffer(i.framebuffer), i.msaaBuffer && n.deleteRenderbuffer(i.msaaBuffer), i.stencil && n.deleteRenderbuffer(i.stencil)), i.blitFramebuffer && i.blitFramebuffer.dispose();
      }
    }, r.prototype.disposeAll = function(t) {
      var e = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (var i = 0; i < e.length; i++)
        this.disposeFramebuffer(e[i], t);
    }, r.prototype.forceStencil = function() {
      var t = this.current;
      if (t) {
        var e = t.glFramebuffers[this.CONTEXT_UID];
        if (!(!e || e.stencil)) {
          t.stencil = !0;
          var i = t.width, n = t.height, s = this.gl, o = s.createRenderbuffer();
          s.bindRenderbuffer(s.RENDERBUFFER, o), e.msaaBuffer ? s.renderbufferStorageMultisample(s.RENDERBUFFER, e.multisample, s.DEPTH24_STENCIL8, i, n) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, i, n), e.stencil = o, s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, o);
        }
      }
    }, r.prototype.reset = function() {
      this.current = this.unknownFramebuffer, this.viewport = new dt();
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), es = { 5126: 4, 5123: 2, 5121: 1 }, rp = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};
    }
    return r.prototype.contextChange = function() {
      this.disposeAll(!0);
      var t = this.gl = this.renderer.gl, e = this.renderer.context;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e.webGLVersion !== 2) {
        var i = this.renderer.context.extensions.vertexArrayObject;
        K.PREFER_ENV === qe.WEBGL_LEGACY && (i = null), i ? (t.createVertexArray = function() {
          return i.createVertexArrayOES();
        }, t.bindVertexArray = function(s) {
          return i.bindVertexArrayOES(s);
        }, t.deleteVertexArray = function(s) {
          return i.deleteVertexArrayOES(s);
        }) : (this.hasVao = !1, t.createVertexArray = function() {
          return null;
        }, t.bindVertexArray = function() {
          return null;
        }, t.deleteVertexArray = function() {
          return null;
        });
      }
      if (e.webGLVersion !== 2) {
        var n = t.getExtension("ANGLE_instanced_arrays");
        n ? (t.vertexAttribDivisor = function(s, o) {
          return n.vertexAttribDivisorANGLE(s, o);
        }, t.drawElementsInstanced = function(s, o, a, h, l) {
          return n.drawElementsInstancedANGLE(s, o, a, h, l);
        }, t.drawArraysInstanced = function(s, o, a, h) {
          return n.drawArraysInstancedANGLE(s, o, a, h);
        }) : this.hasInstance = !1;
      }
      this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex;
    }, r.prototype.bind = function(t, e) {
      e = e || this.renderer.shader.shader;
      var i = this.gl, n = t.glVertexArrayObjects[this.CONTEXT_UID], s = !1;
      n || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = n = {}, s = !0);
      var o = n[e.program.id] || this.initGeometryVao(t, e, s);
      this._activeGeometry = t, this._activeVao !== o && (this._activeVao = o, this.hasVao ? i.bindVertexArray(o) : this.activateVao(t, e.program)), this.updateBuffers();
    }, r.prototype.reset = function() {
      this.unbind();
    }, r.prototype.updateBuffers = function() {
      for (var t = this._activeGeometry, e = this.renderer.buffer, i = 0; i < t.buffers.length; i++) {
        var n = t.buffers[i];
        e.update(n);
      }
    }, r.prototype.checkCompatibility = function(t, e) {
      var i = t.attributes, n = e.attributeData;
      for (var s in n)
        if (!i[s])
          throw new Error('shader and geometry incompatible, geometry missing the "' + s + '" attribute');
    }, r.prototype.getSignature = function(t, e) {
      var i = t.attributes, n = e.attributeData, s = ["g", t.id];
      for (var o in i)
        n[o] && s.push(o, n[o].location);
      return s.join("-");
    }, r.prototype.initGeometryVao = function(t, e, i) {
      i === void 0 && (i = !0);
      var n = this.gl, s = this.CONTEXT_UID, o = this.renderer.buffer, a = e.program;
      a.glPrograms[s] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, a);
      var h = this.getSignature(t, a), l = t.glVertexArrayObjects[this.CONTEXT_UID], u = l[h];
      if (u)
        return l[a.id] = u, u;
      var c = t.buffers, f = t.attributes, d = {}, p = {};
      for (var v in c)
        d[v] = 0, p[v] = 0;
      for (var v in f)
        !f[v].size && a.attributeData[v] ? f[v].size = a.attributeData[v].size : f[v].size || console.warn("PIXI Geometry attribute '" + v + "' size cannot be determined (likely the bound shader does not have the attribute)"), d[f[v].buffer] += f[v].size * es[f[v].type];
      for (var v in f) {
        var _ = f[v], m = _.size;
        _.stride === void 0 && (d[_.buffer] === m * es[_.type] ? _.stride = 0 : _.stride = d[_.buffer]), _.start === void 0 && (_.start = p[_.buffer], p[_.buffer] += m * es[_.type]);
      }
      u = n.createVertexArray(), n.bindVertexArray(u);
      for (var y = 0; y < c.length; y++) {
        var b = c[y];
        o.bind(b), i && b._glBuffers[s].refCount++;
      }
      return this.activateVao(t, a), this._activeVao = u, l[a.id] = u, l[h] = u, u;
    }, r.prototype.disposeGeometry = function(t, e) {
      var i;
      if (this.managedGeometries[t.id]) {
        delete this.managedGeometries[t.id];
        var n = t.glVertexArrayObjects[this.CONTEXT_UID], s = this.gl, o = t.buffers, a = (i = this.renderer) === null || i === void 0 ? void 0 : i.buffer;
        if (t.disposeRunner.remove(this), !!n) {
          if (a)
            for (var h = 0; h < o.length; h++) {
              var l = o[h]._glBuffers[this.CONTEXT_UID];
              l && (l.refCount--, l.refCount === 0 && !e && a.dispose(o[h], e));
            }
          if (!e) {
            for (var u in n)
              if (u[0] === "g") {
                var c = n[u];
                this._activeVao === c && this.unbind(), s.deleteVertexArray(c);
              }
          }
          delete t.glVertexArrayObjects[this.CONTEXT_UID];
        }
      }
    }, r.prototype.disposeAll = function(t) {
      for (var e = Object.keys(this.managedGeometries), i = 0; i < e.length; i++)
        this.disposeGeometry(this.managedGeometries[e[i]], t);
    }, r.prototype.activateVao = function(t, e) {
      var i = this.gl, n = this.CONTEXT_UID, s = this.renderer.buffer, o = t.buffers, a = t.attributes;
      t.indexBuffer && s.bind(t.indexBuffer);
      var h = null;
      for (var l in a) {
        var u = a[l], c = o[u.buffer], f = c._glBuffers[n];
        if (e.attributeData[l]) {
          h !== f && (s.bind(c), h = f);
          var d = e.attributeData[l].location;
          if (i.enableVertexAttribArray(d), i.vertexAttribPointer(d, u.size, u.type || i.FLOAT, u.normalized, u.stride, u.start), u.instance)
            if (this.hasInstance)
              i.vertexAttribDivisor(d, 1);
            else
              throw new Error("geometry error, GPU Instancing is not supported on this device");
        }
      }
    }, r.prototype.draw = function(t, e, i, n) {
      var s = this.gl, o = this._activeGeometry;
      if (o.indexBuffer) {
        var a = o.indexBuffer.data.BYTES_PER_ELEMENT, h = a === 2 ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
        a === 2 || a === 4 && this.canUseUInt32ElementIndex ? o.instanced ? s.drawElementsInstanced(t, e || o.indexBuffer.data.length, h, (i || 0) * a, n || 1) : s.drawElements(t, e || o.indexBuffer.data.length, h, (i || 0) * a) : console.warn("unsupported index buffer type: uint32");
      } else o.instanced ? s.drawArraysInstanced(t, i, e || o.getSize(), n || 1) : s.drawArrays(t, i, e || o.getSize());
      return this;
    }, r.prototype.unbind = function() {
      this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), np = (
  /** @class */
  function() {
    function r(t) {
      t === void 0 && (t = null), this.type = jt.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = K.FILTER_MULTISAMPLE, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;
    }
    return Object.defineProperty(r.prototype, "filter", {
      /**
       * The sprite mask filter.
       * If set to `null`, the default sprite mask filter is used.
       * @default null
       */
      get: function() {
        return this._filters ? this._filters[0] : null;
      },
      set: function(t) {
        t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.reset = function() {
      this.pooled && (this.maskObject = null, this.type = jt.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;
    }, r.prototype.copyCountersOrReset = function(t) {
      t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
    }, r;
  }()
);
function Ta(r, t, e) {
  var i = r.createShader(t);
  return r.shaderSource(i, e), r.compileShader(i), i;
}
function Ea(r, t) {
  var e = r.getShaderSource(t).split(`
`).map(function(l, u) {
    return u + ": " + l;
  }), i = r.getShaderInfoLog(t), n = i.split(`
`), s = {}, o = n.map(function(l) {
    return parseFloat(l.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
  }).filter(function(l) {
    return l && !s[l] ? (s[l] = !0, !0) : !1;
  }), a = [""];
  o.forEach(function(l) {
    e[l - 1] = "%c" + e[l - 1] + "%c", a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  var h = e.join(`
`);
  a[0] = h, console.error(i), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, a), console.groupEnd();
}
function sp(r, t, e, i) {
  r.getProgramParameter(t, r.LINK_STATUS) || (r.getShaderParameter(e, r.COMPILE_STATUS) || Ea(r, e), r.getShaderParameter(i, r.COMPILE_STATUS) || Ea(r, i), console.error("PixiJS Error: Could not initialize shader."), r.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", r.getProgramInfoLog(t)));
}
function is(r) {
  for (var t = new Array(r), e = 0; e < t.length; e++)
    t[e] = !1;
  return t;
}
function Xh(r, t) {
  switch (r) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * t);
    case "vec3":
      return new Float32Array(3 * t);
    case "vec4":
      return new Float32Array(4 * t);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * t);
    case "ivec3":
      return new Int32Array(3 * t);
    case "ivec4":
      return new Int32Array(4 * t);
    case "uvec2":
      return new Uint32Array(2 * t);
    case "uvec3":
      return new Uint32Array(3 * t);
    case "uvec4":
      return new Uint32Array(4 * t);
    case "bool":
      return !1;
    case "bvec2":
      return is(2 * t);
    case "bvec3":
      return is(3 * t);
    case "bvec4":
      return is(4 * t);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var Vh = {}, qi = Vh;
function op() {
  if (qi === Vh || qi && qi.isContextLost()) {
    var r = K.ADAPTER.createCanvas(), t = void 0;
    K.PREFER_ENV >= qe.WEBGL2 && (t = r.getContext("webgl2", {})), t || (t = r.getContext("webgl", {}) || r.getContext("experimental-webgl", {}), t ? t.getExtension("WEBGL_draw_buffers") : t = null), qi = t;
  }
  return qi;
}
var Hr;
function ap() {
  if (!Hr) {
    Hr = ne.MEDIUM;
    var r = op();
    if (r && r.getShaderPrecisionFormat) {
      var t = r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT);
      Hr = t.precision ? ne.HIGH : ne.MEDIUM;
    }
  }
  return Hr;
}
function Sa(r, t, e) {
  if (r.substring(0, 9) !== "precision") {
    var i = t;
    return t === ne.HIGH && e !== ne.HIGH && (i = ne.MEDIUM), "precision " + i + ` float;
` + r;
  } else if (e !== ne.HIGH && r.substring(0, 15) === "precision highp")
    return r.replace("precision highp", "precision mediump");
  return r;
}
var hp = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function Wh(r) {
  return hp[r];
}
var $r = null, Pa = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function Yh(r, t) {
  if (!$r) {
    var e = Object.keys(Pa);
    $r = {};
    for (var i = 0; i < e.length; ++i) {
      var n = e[i];
      $r[r[n]] = Pa[n];
    }
  }
  return $r[t];
}
var Bi = [
  // a float cache layer
  {
    test: function(r) {
      return r.type === "float" && r.size === 1 && !r.isArray;
    },
    code: function(r) {
      return `
            if(uv["` + r + '"] !== ud["' + r + `"].value)
            {
                ud["` + r + '"].value = uv["' + r + `"]
                gl.uniform1f(ud["` + r + '"].location, uv["' + r + `"])
            }
            `;
    }
  },
  // handling samplers
  {
    test: function(r, t) {
      return (r.type === "sampler2D" || r.type === "samplerCube" || r.type === "sampler2DArray") && r.size === 1 && !r.isArray && (t == null || t.castToBaseTexture !== void 0);
    },
    code: function(r) {
      return `t = syncData.textureCount++;

            renderer.texture.bind(uv["` + r + `"], t);

            if(ud["` + r + `"].value !== t)
            {
                ud["` + r + `"].value = t;
                gl.uniform1i(ud["` + r + `"].location, t);
; // eslint-disable-line max-len
            }`;
    }
  },
  // uploading pixi matrix object to mat3
  {
    test: function(r, t) {
      return r.type === "mat3" && r.size === 1 && !r.isArray && t.a !== void 0;
    },
    code: function(r) {
      return `
            gl.uniformMatrix3fv(ud["` + r + '"].location, false, uv["' + r + `"].toArray(true));
            `;
    },
    codeUbo: function(r) {
      return `
                var ` + r + "_matrix = uv." + r + `.toArray(true);

                data[offset] = ` + r + `_matrix[0];
                data[offset+1] = ` + r + `_matrix[1];
                data[offset+2] = ` + r + `_matrix[2];
        
                data[offset + 4] = ` + r + `_matrix[3];
                data[offset + 5] = ` + r + `_matrix[4];
                data[offset + 6] = ` + r + `_matrix[5];
        
                data[offset + 8] = ` + r + `_matrix[6];
                data[offset + 9] = ` + r + `_matrix[7];
                data[offset + 10] = ` + r + `_matrix[8];
            `;
    }
  },
  // uploading a pixi point as a vec2 with caching layer
  {
    test: function(r, t) {
      return r.type === "vec2" && r.size === 1 && !r.isArray && t.x !== void 0;
    },
    code: function(r) {
      return `
                cv = ud["` + r + `"].value;
                v = uv["` + r + `"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["` + r + `"].location, v.x, v.y);
                }`;
    },
    codeUbo: function(r) {
      return `
                v = uv.` + r + `;

                data[offset] = v.x;
                data[offset+1] = v.y;
            `;
    }
  },
  // caching layer for a vec2
  {
    test: function(r) {
      return r.type === "vec2" && r.size === 1 && !r.isArray;
    },
    code: function(r) {
      return `
                cv = ud["` + r + `"].value;
                v = uv["` + r + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["` + r + `"].location, v[0], v[1]);
                }
            `;
    }
  },
  // upload a pixi rectangle as a vec4 with caching layer
  {
    test: function(r, t) {
      return r.type === "vec4" && r.size === 1 && !r.isArray && t.width !== void 0;
    },
    code: function(r) {
      return `
                cv = ud["` + r + `"].value;
                v = uv["` + r + `"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["` + r + `"].location, v.x, v.y, v.width, v.height)
                }`;
    },
    codeUbo: function(r) {
      return `
                    v = uv.` + r + `;

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `;
    }
  },
  // a caching layer for vec4 uploading
  {
    test: function(r) {
      return r.type === "vec4" && r.size === 1 && !r.isArray;
    },
    code: function(r) {
      return `
                cv = ud["` + r + `"].value;
                v = uv["` + r + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["` + r + `"].location, v[0], v[1], v[2], v[3])
                }`;
    }
  }
], lp = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
}, up = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function cp(r, t) {
  var e, i = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (var n in r.uniforms) {
    var s = t[n];
    if (!s) {
      !((e = r.uniforms[n]) === null || e === void 0) && e.group && (r.uniforms[n].ubo ? i.push(`
                        renderer.shader.syncUniformBufferGroup(uv.` + n + ", '" + n + `');
                    `) : i.push(`
                        renderer.shader.syncUniformGroup(uv.` + n + `, syncData);
                    `));
      continue;
    }
    for (var o = r.uniforms[n], a = !1, h = 0; h < Bi.length; h++)
      if (Bi[h].test(s, o)) {
        i.push(Bi[h].code(n, o)), a = !0;
        break;
      }
    if (!a) {
      var l = s.size === 1 && !s.isArray ? lp : up, u = l[s.type].replace("location", 'ud["' + n + '"].location');
      i.push(`
            cu = ud["` + n + `"];
            cv = cu.value;
            v = uv["` + n + `"];
            ` + u + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", i.join(`
`));
}
var fp = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function dp(r) {
  for (var t = "", e = 0; e < r; ++e)
    e > 0 && (t += `
else `), e < r - 1 && (t += "if(test == " + e + ".0){}");
  return t;
}
function pp(r, t) {
  if (r === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  for (var e = t.createShader(t.FRAGMENT_SHADER); ; ) {
    var i = fp.replace(/%forloop%/gi, dp(r));
    if (t.shaderSource(e, i), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))
      r = r / 2 | 0;
    else
      break;
  }
  return r;
}
var Zi;
function vp() {
  if (typeof Zi == "boolean")
    return Zi;
  try {
    var r = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    Zi = r({ a: "b" }, "a", "b") === !0;
  } catch {
    Zi = !1;
  }
  return Zi;
}
var _p = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`, mp = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`, yp = 0, zr = {}, kr = (
  /** @class */
  function() {
    function r(t, e, i) {
      i === void 0 && (i = "pixi-shader"), this.id = yp++, this.vertexSrc = t || r.defaultVertexSrc, this.fragmentSrc = e || r.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== "#version" && (i = i.replace(/\s+/g, "-"), zr[i] ? (zr[i]++, i += "-" + zr[i]) : zr[i] = 1, this.vertexSrc = "#define SHADER_NAME " + i + `
` + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + i + `
` + this.fragmentSrc, this.vertexSrc = Sa(this.vertexSrc, K.PRECISION_VERTEX, ne.HIGH), this.fragmentSrc = Sa(this.fragmentSrc, K.PRECISION_FRAGMENT, ap())), this.glPrograms = {}, this.syncUniforms = null;
    }
    return Object.defineProperty(r, "defaultVertexSrc", {
      /**
       * The default vertex shader source.
       * @constant
       */
      get: function() {
        return mp;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "defaultFragmentSrc", {
      /**
       * The default fragment shader source.
       * @constant
       */
      get: function() {
        return _p;
      },
      enumerable: !1,
      configurable: !0
    }), r.from = function(t, e, i) {
      var n = t + e, s = _a[n];
      return s || (_a[n] = s = new r(t, e, i)), s;
    }, r;
  }()
), hi = (
  /** @class */
  function() {
    function r(t, e) {
      this.uniformBindCount = 0, this.program = t, e ? e instanceof Ti ? this.uniformGroup = e : this.uniformGroup = new Ti(e) : this.uniformGroup = new Ti({}), this.disposeRunner = new Zt("disposeShader");
    }
    return r.prototype.checkUniformExists = function(t, e) {
      if (e.uniforms[t])
        return !0;
      for (var i in e.uniforms) {
        var n = e.uniforms[i];
        if (n.group && this.checkUniformExists(t, n))
          return !0;
      }
      return !1;
    }, r.prototype.destroy = function() {
      this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();
    }, Object.defineProperty(r.prototype, "uniforms", {
      /**
       * Shader uniform values, shortcut for `uniformGroup.uniforms`.
       * @readonly
       */
      get: function() {
        return this.uniformGroup.uniforms;
      },
      enumerable: !1,
      configurable: !0
    }), r.from = function(t, e, i) {
      var n = kr.from(t, e);
      return new r(n, i);
    }, r;
  }()
), rs = 0, ns = 1, ss = 2, os = 3, as = 4, hs = 5, Oi = (
  /** @class */
  function() {
    function r() {
      this.data = 0, this.blendMode = it.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;
    }
    return Object.defineProperty(r.prototype, "blend", {
      /**
       * Activates blending of the computed fragment color values.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << rs);
      },
      set: function(t) {
        !!(this.data & 1 << rs) !== t && (this.data ^= 1 << rs);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "offsets", {
      /**
       * Activates adding an offset to depth values of polygon's fragments
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << ns);
      },
      set: function(t) {
        !!(this.data & 1 << ns) !== t && (this.data ^= 1 << ns);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "culling", {
      /**
       * Activates culling of polygons.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << ss);
      },
      set: function(t) {
        !!(this.data & 1 << ss) !== t && (this.data ^= 1 << ss);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "depthTest", {
      /**
       * Activates depth comparisons and updates to the depth buffer.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << os);
      },
      set: function(t) {
        !!(this.data & 1 << os) !== t && (this.data ^= 1 << os);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "depthMask", {
      /**
       * Enables or disables writing to the depth buffer.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << hs);
      },
      set: function(t) {
        !!(this.data & 1 << hs) !== t && (this.data ^= 1 << hs);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "clockwiseFrontFace", {
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << as);
      },
      set: function(t) {
        !!(this.data & 1 << as) !== t && (this.data ^= 1 << as);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "blendMode", {
      /**
       * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this._blendMode;
      },
      set: function(t) {
        this.blend = t !== it.NONE, this._blendMode = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "polygonOffset", {
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       * @default 0
       */
      get: function() {
        return this._polygonOffset;
      },
      set: function(t) {
        this.offsets = !!t, this._polygonOffset = t;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.toString = function() {
      return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
    }, r.for2d = function() {
      var t = new r();
      return t.depthTest = !1, t.blend = !0, t;
    }, r;
  }()
), gp = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`, bp = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, Je = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e, i, n) {
      var s = this, o = kr.from(e || t.defaultVertexSrc, i || t.defaultFragmentSrc);
      return s = r.call(this, o, n) || this, s.padding = 0, s.resolution = K.FILTER_RESOLUTION, s.multisample = K.FILTER_MULTISAMPLE, s.enabled = !0, s.autoFit = !0, s.state = new Oi(), s;
    }
    return t.prototype.apply = function(e, i, n, s, o) {
      e.applyFilter(this, i, n, s);
    }, Object.defineProperty(t.prototype, "blendMode", {
      /**
       * Sets the blend mode of the filter.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this.state.blendMode;
      },
      set: function(e) {
        this.state.blendMode = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "resolution", {
      /**
       * The resolution of the filter. Setting this to be lower will lower the quality but
       * increase the performance of the filter.
       */
      get: function() {
        return this._resolution;
      },
      set: function(e) {
        this._resolution = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @constant
       */
      get: function() {
        return bp;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "defaultFragmentSrc", {
      /**
       * The default fragment shader source
       * @constant
       */
      get: function() {
        return gp;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(hi)
), xp = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`, wp = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`, Ca = new Vt(), Mo = (
  /** @class */
  function() {
    function r(t, e) {
      this._texture = t, this.mapCoord = new Vt(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof e > "u" ? 0.5 : e, this.isSimple = !1;
    }
    return Object.defineProperty(r.prototype, "texture", {
      /** Texture property. */
      get: function() {
        return this._texture;
      },
      set: function(t) {
        this._texture = t, this._textureID = -1;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.multiplyUvs = function(t, e) {
      e === void 0 && (e = t);
      for (var i = this.mapCoord, n = 0; n < t.length; n += 2) {
        var s = t[n], o = t[n + 1];
        e[n] = s * i.a + o * i.c + i.tx, e[n + 1] = s * i.b + o * i.d + i.ty;
      }
      return e;
    }, r.prototype.update = function(t) {
      var e = this._texture;
      if (!e || !e.valid || !t && this._textureID === e._updateID)
        return !1;
      this._textureID = e._updateID, this._updateID++;
      var i = e._uvs;
      this.mapCoord.set(i.x1 - i.x0, i.y1 - i.y0, i.x3 - i.x0, i.y3 - i.y0, i.x0, i.y0);
      var n = e.orig, s = e.trim;
      s && (Ca.set(n.width / s.width, 0, 0, n.height / s.height, -s.x / s.width, -s.y / s.height), this.mapCoord.append(Ca));
      var o = e.baseTexture, a = this.uClampFrame, h = this.clampMargin / o.resolution, l = this.clampOffset;
      return a[0] = (e._frame.x + h + l) / o.width, a[1] = (e._frame.y + h + l) / o.height, a[2] = (e._frame.x + e._frame.width - h + l) / o.width, a[3] = (e._frame.y + e._frame.height - h + l) / o.height, this.uClampOffset[0] = l / o.realWidth, this.uClampOffset[1] = l / o.realHeight, this.isSimple = e._frame.width === o.width && e._frame.height === o.height && e.rotate === 0, !0;
    }, r;
  }()
), Tp = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e, i, n) {
      var s = this, o = null;
      return typeof e != "string" && i === void 0 && n === void 0 && (o = e, e = void 0, i = void 0, n = void 0), s = r.call(this, e || xp, i || wp, n) || this, s.maskSprite = o, s.maskMatrix = new Vt(), s;
    }
    return Object.defineProperty(t.prototype, "maskSprite", {
      /**
       * Sprite mask
       * @type {PIXI.DisplayObject}
       */
      get: function() {
        return this._maskSprite;
      },
      set: function(e) {
        this._maskSprite = e, this._maskSprite && (this._maskSprite.renderable = !1);
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.apply = function(e, i, n, s) {
      var o = this._maskSprite, a = o._texture;
      a.valid && (a.uvMatrix || (a.uvMatrix = new Mo(a, 0)), a.uvMatrix.update(), this.uniforms.npmAlpha = a.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = a, this.uniforms.otherMatrix = e.calculateSpriteMatrix(this.maskMatrix, o).prepend(a.uvMatrix.mapCoord), this.uniforms.alpha = o.worldAlpha, this.uniforms.maskClamp = a.uvMatrix.uClampFrame, e.applyFilter(this, i, n, s));
    }, t;
  }(Je)
), Ep = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
    }
    return r.prototype.setMaskStack = function(t) {
      this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t);
    }, r.prototype.push = function(t, e) {
      var i = e;
      if (!i.isMaskData) {
        var n = this.maskDataPool.pop() || new np();
        n.pooled = !0, n.maskObject = e, i = n;
      }
      var s = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      if (i.copyCountersOrReset(s), i._colorMask = s ? s._colorMask : 15, i.autoDetect && this.detect(i), i._target = t, i.type !== jt.SPRITE && this.maskStack.push(i), i.enabled)
        switch (i.type) {
          case jt.SCISSOR:
            this.renderer.scissor.push(i);
            break;
          case jt.STENCIL:
            this.renderer.stencil.push(i);
            break;
          case jt.SPRITE:
            i.copyCountersOrReset(null), this.pushSpriteMask(i);
            break;
          case jt.COLOR:
            this.pushColorMask(i);
            break;
        }
      i.type === jt.SPRITE && this.maskStack.push(i);
    }, r.prototype.pop = function(t) {
      var e = this.maskStack.pop();
      if (!(!e || e._target !== t)) {
        if (e.enabled)
          switch (e.type) {
            case jt.SCISSOR:
              this.renderer.scissor.pop(e);
              break;
            case jt.STENCIL:
              this.renderer.stencil.pop(e.maskObject);
              break;
            case jt.SPRITE:
              this.popSpriteMask(e);
              break;
            case jt.COLOR:
              this.popColorMask(e);
              break;
          }
        if (e.reset(), e.pooled && this.maskDataPool.push(e), this.maskStack.length !== 0) {
          var i = this.maskStack[this.maskStack.length - 1];
          i.type === jt.SPRITE && i._filters && (i._filters[0].maskSprite = i.maskObject);
        }
      }
    }, r.prototype.detect = function(t) {
      var e = t.maskObject;
      e ? e.isSprite ? t.type = jt.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = jt.SCISSOR : t.type = jt.STENCIL : t.type = jt.COLOR;
    }, r.prototype.pushSpriteMask = function(t) {
      var e, i, n = t.maskObject, s = t._target, o = t._filters;
      o || (o = this.alphaMaskPool[this.alphaMaskIndex], o || (o = this.alphaMaskPool[this.alphaMaskIndex] = [new Tp()]));
      var a = this.renderer, h = a.renderTexture, l, u;
      if (h.current) {
        var c = h.current;
        l = t.resolution || c.resolution, u = (e = t.multisample) !== null && e !== void 0 ? e : c.multisample;
      } else
        l = t.resolution || a.resolution, u = (i = t.multisample) !== null && i !== void 0 ? i : a.multisample;
      o[0].resolution = l, o[0].multisample = u, o[0].maskSprite = n;
      var f = s.filterArea;
      s.filterArea = n.getBounds(!0), a.filter.push(s, o), s.filterArea = f, t._filters || this.alphaMaskIndex++;
    }, r.prototype.popSpriteMask = function(t) {
      this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
    }, r.prototype.pushColorMask = function(t) {
      var e = t._colorMask, i = t._colorMask = e & t.colorMask;
      i !== e && this.renderer.gl.colorMask((i & 1) !== 0, (i & 2) !== 0, (i & 4) !== 0, (i & 8) !== 0);
    }, r.prototype.popColorMask = function(t) {
      var e = t._colorMask, i = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
      i !== e && this.renderer.gl.colorMask((i & 1) !== 0, (i & 2) !== 0, (i & 4) !== 0, (i & 8) !== 0);
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), qh = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.maskStack = [], this.glConst = 0;
    }
    return r.prototype.getStackLength = function() {
      return this.maskStack.length;
    }, r.prototype.setMaskStack = function(t) {
      var e = this.renderer.gl, i = this.getStackLength();
      this.maskStack = t;
      var n = this.getStackLength();
      n !== i && (n === 0 ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()));
    }, r.prototype._useCurrent = function() {
    }, r.prototype.destroy = function() {
      this.renderer = null, this.maskStack = null;
    }, r;
  }()
), Ia = new Vt(), Oa = [], Sp = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e) {
      var i = r.call(this, e) || this;
      return i.glConst = K.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST, i;
    }
    return t.prototype.getStackLength = function() {
      var e = this.maskStack[this.maskStack.length - 1];
      return e ? e._scissorCounter : 0;
    }, t.prototype.calcScissorRect = function(e) {
      var i;
      if (!e._scissorRectLocal) {
        var n = e._scissorRect, s = e.maskObject, o = this.renderer, a = o.renderTexture, h = s.getBounds(!0, (i = Oa.pop()) !== null && i !== void 0 ? i : new dt());
        this.roundFrameToPixels(h, a.current ? a.current.resolution : o.resolution, a.sourceFrame, a.destinationFrame, o.projection.transform), n && h.fit(n), e._scissorRectLocal = h;
      }
    }, t.isMatrixRotated = function(e) {
      if (!e)
        return !1;
      var i = e.a, n = e.b, s = e.c, o = e.d;
      return (Math.abs(n) > 1e-4 || Math.abs(s) > 1e-4) && (Math.abs(i) > 1e-4 || Math.abs(o) > 1e-4);
    }, t.prototype.testScissor = function(e) {
      var i = e.maskObject;
      if (!i.isFastRect || !i.isFastRect() || t.isMatrixRotated(i.worldTransform) || t.isMatrixRotated(this.renderer.projection.transform))
        return !1;
      this.calcScissorRect(e);
      var n = e._scissorRectLocal;
      return n.width > 0 && n.height > 0;
    }, t.prototype.roundFrameToPixels = function(e, i, n, s, o) {
      t.isMatrixRotated(o) || (o = o ? Ia.copyFrom(o) : Ia.identity(), o.translate(-n.x, -n.y).scale(s.width / n.width, s.height / n.height).translate(s.x, s.y), this.renderer.filter.transformAABB(o, e), e.fit(s), e.x = Math.round(e.x * i), e.y = Math.round(e.y * i), e.width = Math.round(e.width * i), e.height = Math.round(e.height * i));
    }, t.prototype.push = function(e) {
      e._scissorRectLocal || this.calcScissorRect(e);
      var i = this.renderer.gl;
      e._scissorRect || i.enable(i.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent();
    }, t.prototype.pop = function(e) {
      var i = this.renderer.gl;
      e && Oa.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : i.disable(i.SCISSOR_TEST);
    }, t.prototype._useCurrent = function() {
      var e = this.maskStack[this.maskStack.length - 1]._scissorRect, i;
      this.renderer.renderTexture.current ? i = e.y : i = this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, i, e.width, e.height);
    }, t;
  }(qh)
), Pp = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e) {
      var i = r.call(this, e) || this;
      return i.glConst = K.ADAPTER.getWebGLRenderingContext().STENCIL_TEST, i;
    }
    return t.prototype.getStackLength = function() {
      var e = this.maskStack[this.maskStack.length - 1];
      return e ? e._stencilCounter : 0;
    }, t.prototype.push = function(e) {
      var i = e.maskObject, n = this.renderer.gl, s = e._stencilCounter;
      s === 0 && (this.renderer.framebuffer.forceStencil(), n.clearStencil(0), n.clear(n.STENCIL_BUFFER_BIT), n.enable(n.STENCIL_TEST)), e._stencilCounter++;
      var o = e._colorMask;
      o !== 0 && (e._colorMask = 0, n.colorMask(!1, !1, !1, !1)), n.stencilFunc(n.EQUAL, s, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.INCR), i.renderable = !0, i.render(this.renderer), this.renderer.batch.flush(), i.renderable = !1, o !== 0 && (e._colorMask = o, n.colorMask((o & 1) !== 0, (o & 2) !== 0, (o & 4) !== 0, (o & 8) !== 0)), this._useCurrent();
    }, t.prototype.pop = function(e) {
      var i = this.renderer.gl;
      if (this.getStackLength() === 0)
        i.disable(i.STENCIL_TEST);
      else {
        var n = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, s = n ? n._colorMask : 15;
        s !== 0 && (n._colorMask = 0, i.colorMask(!1, !1, !1, !1)), i.stencilOp(i.KEEP, i.KEEP, i.DECR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, s !== 0 && (n._colorMask = s, i.colorMask((s & 1) !== 0, (s & 2) !== 0, (s & 4) !== 0, (s & 8) !== 0)), this._useCurrent();
      }
    }, t.prototype._useCurrent = function() {
      var e = this.renderer.gl;
      e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP);
    }, t;
  }(qh)
), Cp = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Vt(), this.transform = null;
    }
    return r.prototype.update = function(t, e, i, n) {
      this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, i, n), this.transform && this.projectionMatrix.append(this.transform);
      var s = this.renderer;
      s.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, s.globalUniforms.update(), s.shader.shader && s.shader.syncUniformGroup(s.shader.shader.uniforms.globals);
    }, r.prototype.calculateProjection = function(t, e, i, n) {
      var s = this.projectionMatrix, o = n ? -1 : 1;
      s.identity(), s.a = 1 / e.width * 2, s.d = o * (1 / e.height * 2), s.tx = -1 - e.x * s.a, s.ty = -o - e.y * s.d;
    }, r.prototype.setTransform = function(t) {
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), fi = new dt(), Ki = new dt(), Ip = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new dt(), this.destinationFrame = new dt(), this.viewportFrame = new dt();
    }
    return r.prototype.bind = function(t, e, i) {
      t === void 0 && (t = null);
      var n = this.renderer;
      this.current = t;
      var s, o, a;
      t ? (s = t.baseTexture, a = s.resolution, e || (fi.width = t.frame.width, fi.height = t.frame.height, e = fi), i || (Ki.x = t.frame.x, Ki.y = t.frame.y, Ki.width = e.width, Ki.height = e.height, i = Ki), o = s.framebuffer) : (a = n.resolution, e || (fi.width = n.screen.width, fi.height = n.screen.height, e = fi), i || (i = fi, i.width = e.width, i.height = e.height));
      var h = this.viewportFrame;
      h.x = i.x * a, h.y = i.y * a, h.width = i.width * a, h.height = i.height * a, t || (h.y = n.view.height - (h.y + h.height)), h.ceil(), this.renderer.framebuffer.bind(o, h), this.renderer.projection.update(i, e, a, !o), t ? this.renderer.mask.setMaskStack(s.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(i);
    }, r.prototype.clear = function(t, e) {
      this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.clearColor;
      var i = this.destinationFrame, n = this.current ? this.current.baseTexture : this.renderer.screen, s = i.width !== n.width || i.height !== n.height;
      if (s) {
        var o = this.viewportFrame, a = o.x, h = o.y, l = o.width, u = o.height;
        a = Math.round(a), h = Math.round(h), l = Math.round(l), u = Math.round(u), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(a, h, l, u);
      }
      this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), s && this.renderer.scissor.pop();
    }, r.prototype.resize = function() {
      this.bind(null);
    }, r.prototype.reset = function() {
      this.bind(null);
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
);
function Op(r, t, e, i, n) {
  e.buffer.update(n);
}
var Mp = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}, Zh = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function Rp(r) {
  for (var t = r.map(function(h) {
    return {
      data: h,
      offset: 0,
      dataLen: 0,
      dirty: 0
    };
  }), e = 0, i = 0, n = 0, s = 0; s < t.length; s++) {
    var o = t[s];
    if (e = Zh[o.data.type], o.data.size > 1 && (e = Math.max(e, 16) * o.data.size), o.dataLen = e, i % e !== 0 && i < 16) {
      var a = i % e % 16;
      i += a, n += a;
    }
    i + e > 16 ? (n = Math.ceil(n / 16) * 16, o.offset = n, n += e, i = e) : (o.offset = n, i += e, n += e);
  }
  return n = Math.ceil(n / 16) * 16, { uboElements: t, size: n };
}
function kp(r, t) {
  var e = [];
  for (var i in r)
    t[i] && e.push(t[i]);
  return e.sort(function(n, s) {
    return n.index - s.index;
  }), e;
}
function Np(r, t) {
  if (!r.autoManage)
    return { size: 0, syncFunc: Op };
  for (var e = kp(r.uniforms, t), i = Rp(e), n = i.uboElements, s = i.size, o = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `], a = 0; a < n.length; a++) {
    for (var h = n[a], l = r.uniforms[h.data.name], u = h.data.name, c = !1, f = 0; f < Bi.length; f++) {
      var d = Bi[f];
      if (d.codeUbo && d.test(h.data, l)) {
        o.push("offset = " + h.offset / 4 + ";", Bi[f].codeUbo(h.data.name, l)), c = !0;
        break;
      }
    }
    if (!c)
      if (h.data.size > 1) {
        var p = Wh(h.data.type), v = Math.max(Zh[h.data.type] / 16, 1), _ = p / v, m = (4 - _ % 4) % 4;
        o.push(`
                cv = ud.` + u + `.value;
                v = uv.` + u + `;
                offset = ` + h.offset / 4 + `;

                t = 0;

                for(var i=0; i < ` + h.data.size * v + `; i++)
                {
                    for(var j = 0; j < ` + _ + `; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ` + m + `;
                }

                `);
      } else {
        var y = Mp[h.data.type];
        o.push(`
                cv = ud.` + u + `.value;
                v = uv.` + u + `;
                offset = ` + h.offset / 4 + `;
                ` + y + `;
                `);
      }
  }
  return o.push(`
       renderer.buffer.update(buffer);
    `), {
    size: s,
    // eslint-disable-next-line no-new-func
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", o.join(`
`))
  };
}
var Ap = (
  /** @class */
  function() {
    function r(t, e) {
      this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
    }
    return r.prototype.destroy = function() {
      this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
    }, r;
  }()
);
function Dp(r, t) {
  for (var e = {}, i = t.getProgramParameter(r, t.ACTIVE_ATTRIBUTES), n = 0; n < i; n++) {
    var s = t.getActiveAttrib(r, n);
    if (s.name.indexOf("gl_") !== 0) {
      var o = Yh(t, s.type), a = {
        type: o,
        name: s.name,
        size: Wh(o),
        location: t.getAttribLocation(r, s.name)
      };
      e[s.name] = a;
    }
  }
  return e;
}
function Lp(r, t) {
  for (var e = {}, i = t.getProgramParameter(r, t.ACTIVE_UNIFORMS), n = 0; n < i; n++) {
    var s = t.getActiveUniform(r, n), o = s.name.replace(/\[.*?\]$/, ""), a = !!s.name.match(/\[.*?\]$/), h = Yh(t, s.type);
    e[o] = {
      name: o,
      index: n,
      type: h,
      size: s.size,
      isArray: a,
      value: Xh(h, s.size)
    };
  }
  return e;
}
function Fp(r, t) {
  var e = Ta(r, r.VERTEX_SHADER, t.vertexSrc), i = Ta(r, r.FRAGMENT_SHADER, t.fragmentSrc), n = r.createProgram();
  if (r.attachShader(n, e), r.attachShader(n, i), r.linkProgram(n), r.getProgramParameter(n, r.LINK_STATUS) || sp(r, n, e, i), t.attributeData = Dp(n, r), t.uniformData = Lp(n, r), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc)) {
    var s = Object.keys(t.attributeData);
    s.sort(function(u, c) {
      return u > c ? 1 : -1;
    });
    for (var o = 0; o < s.length; o++)
      t.attributeData[s[o]].location = o, r.bindAttribLocation(n, o, s[o]);
    r.linkProgram(n);
  }
  r.deleteShader(e), r.deleteShader(i);
  var a = {};
  for (var o in t.uniformData) {
    var h = t.uniformData[o];
    a[o] = {
      location: r.getUniformLocation(n, o),
      value: Xh(h.type, h.size)
    };
  }
  var l = new Ap(n, a);
  return l;
}
var Bp = 0, Xr = { textureCount: 0, uboCount: 0 }, Up = (
  /** @class */
  function() {
    function r(t) {
      this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = Bp++;
    }
    return r.prototype.systemCheck = function() {
      if (!vp())
        throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }, r.prototype.contextChange = function(t) {
      this.gl = t, this.reset();
    }, r.prototype.bind = function(t, e) {
      t.disposeRunner.add(this), t.uniforms.globals = this.renderer.globalUniforms;
      var i = t.program, n = i.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
      return this.shader = t, this.program !== i && (this.program = i, this.gl.useProgram(n.program)), e || (Xr.textureCount = 0, Xr.uboCount = 0, this.syncUniformGroup(t.uniformGroup, Xr)), n;
    }, r.prototype.setUniforms = function(t) {
      var e = this.shader.program, i = e.glPrograms[this.renderer.CONTEXT_UID];
      e.syncUniforms(i.uniformData, t, this.renderer);
    }, r.prototype.syncUniformGroup = function(t, e) {
      var i = this.getGlProgram();
      (!t.static || t.dirtyId !== i.uniformDirtyGroups[t.id]) && (i.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, i, e));
    }, r.prototype.syncUniforms = function(t, e, i) {
      var n = t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t);
      n(e.uniformData, t.uniforms, this.renderer, i);
    }, r.prototype.createSyncGroups = function(t) {
      var e = this.getSignature(t, this.shader.program.uniformData, "u");
      return this.cache[e] || (this.cache[e] = cp(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id];
    }, r.prototype.syncUniformBufferGroup = function(t, e) {
      var i = this.getGlProgram();
      if (!t.static || t.dirtyId !== 0 || !i.uniformGroups[t.id]) {
        t.dirtyId = 0;
        var n = i.uniformGroups[t.id] || this.createSyncBufferGroup(t, i, e);
        t.buffer.update(), n(i.uniformData, t.uniforms, this.renderer, Xr, t.buffer);
      }
      this.renderer.buffer.bindBufferBase(t.buffer, i.uniformBufferBindings[e]);
    }, r.prototype.createSyncBufferGroup = function(t, e, i) {
      var n = this.renderer.gl;
      this.renderer.buffer.bind(t.buffer);
      var s = this.gl.getUniformBlockIndex(e.program, i);
      e.uniformBufferBindings[i] = this.shader.uniformBindCount, n.uniformBlockBinding(e.program, s, this.shader.uniformBindCount), this.shader.uniformBindCount++;
      var o = this.getSignature(t, this.shader.program.uniformData, "ubo"), a = this._uboCache[o];
      if (a || (a = this._uboCache[o] = Np(t, this.shader.program.uniformData)), t.autoManage) {
        var h = new Float32Array(a.size / 4);
        t.buffer.update(h);
      }
      return e.uniformGroups[t.id] = a.syncFunc, e.uniformGroups[t.id];
    }, r.prototype.getSignature = function(t, e, i) {
      var n = t.uniforms, s = [i + "-"];
      for (var o in n)
        s.push(o), e[o] && s.push(e[o].type);
      return s.join("-");
    }, r.prototype.getGlProgram = function() {
      return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
    }, r.prototype.generateProgram = function(t) {
      var e = this.gl, i = t.program, n = Fp(e, i);
      return i.glPrograms[this.renderer.CONTEXT_UID] = n, n;
    }, r.prototype.reset = function() {
      this.program = null, this.shader = null;
    }, r.prototype.disposeShader = function(t) {
      this.shader === t && (this.shader = null);
    }, r.prototype.destroy = function() {
      this.renderer = null, this.destroyed = !0;
    }, r;
  }()
);
function Gp(r, t) {
  return t === void 0 && (t = []), t[it.NORMAL] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.ADD] = [r.ONE, r.ONE], t[it.MULTIPLY] = [r.DST_COLOR, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.SCREEN] = [r.ONE, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.OVERLAY] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.DARKEN] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.LIGHTEN] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.COLOR_DODGE] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.COLOR_BURN] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.HARD_LIGHT] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.SOFT_LIGHT] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.DIFFERENCE] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.EXCLUSION] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.HUE] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.SATURATION] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.COLOR] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.LUMINOSITY] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.NONE] = [0, 0], t[it.NORMAL_NPM] = [r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.ADD_NPM] = [r.SRC_ALPHA, r.ONE, r.ONE, r.ONE], t[it.SCREEN_NPM] = [r.SRC_ALPHA, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE_MINUS_SRC_ALPHA], t[it.SRC_IN] = [r.DST_ALPHA, r.ZERO], t[it.SRC_OUT] = [r.ONE_MINUS_DST_ALPHA, r.ZERO], t[it.SRC_ATOP] = [r.DST_ALPHA, r.ONE_MINUS_SRC_ALPHA], t[it.DST_OVER] = [r.ONE_MINUS_DST_ALPHA, r.ONE], t[it.DST_IN] = [r.ZERO, r.SRC_ALPHA], t[it.DST_OUT] = [r.ZERO, r.ONE_MINUS_SRC_ALPHA], t[it.DST_ATOP] = [r.ONE_MINUS_DST_ALPHA, r.SRC_ALPHA], t[it.XOR] = [r.ONE_MINUS_DST_ALPHA, r.ONE_MINUS_SRC_ALPHA], t[it.SUBTRACT] = [r.ONE, r.ONE, r.ONE, r.ONE, r.FUNC_REVERSE_SUBTRACT, r.FUNC_ADD], t;
}
var jp = 0, Hp = 1, $p = 2, zp = 3, Xp = 4, Vp = 5, Wp = (
  /** @class */
  function() {
    function r() {
      this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = it.NONE, this._blendEq = !1, this.map = [], this.map[jp] = this.setBlend, this.map[Hp] = this.setOffset, this.map[$p] = this.setCullFace, this.map[zp] = this.setDepthTest, this.map[Xp] = this.setFrontFace, this.map[Vp] = this.setDepthMask, this.checks = [], this.defaultState = new Oi(), this.defaultState.blend = !0;
    }
    return r.prototype.contextChange = function(t) {
      this.gl = t, this.blendModes = Gp(t), this.set(this.defaultState), this.reset();
    }, r.prototype.set = function(t) {
      if (t = t || this.defaultState, this.stateId !== t.data) {
        for (var e = this.stateId ^ t.data, i = 0; e; )
          e & 1 && this.map[i].call(this, !!(t.data & 1 << i)), e = e >> 1, i++;
        this.stateId = t.data;
      }
      for (var i = 0; i < this.checks.length; i++)
        this.checks[i](this, t);
    }, r.prototype.forceState = function(t) {
      t = t || this.defaultState;
      for (var e = 0; e < this.map.length; e++)
        this.map[e].call(this, !!(t.data & 1 << e));
      for (var e = 0; e < this.checks.length; e++)
        this.checks[e](this, t);
      this.stateId = t.data;
    }, r.prototype.setBlend = function(t) {
      this.updateCheck(r.checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND);
    }, r.prototype.setOffset = function(t) {
      this.updateCheck(r.checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    }, r.prototype.setDepthTest = function(t) {
      this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST);
    }, r.prototype.setDepthMask = function(t) {
      this.gl.depthMask(t);
    }, r.prototype.setCullFace = function(t) {
      this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE);
    }, r.prototype.setFrontFace = function(t) {
      this.gl.frontFace(this.gl[t ? "CW" : "CCW"]);
    }, r.prototype.setBlendMode = function(t) {
      if (t !== this.blendMode) {
        this.blendMode = t;
        var e = this.blendModes[t], i = this.gl;
        e.length === 2 ? i.blendFunc(e[0], e[1]) : i.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, i.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD));
      }
    }, r.prototype.setPolygonOffset = function(t, e) {
      this.gl.polygonOffset(t, e);
    }, r.prototype.reset = function() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);
    }, r.prototype.updateCheck = function(t, e) {
      var i = this.checks.indexOf(t);
      e && i === -1 ? this.checks.push(t) : !e && i !== -1 && this.checks.splice(i, 1);
    }, r.checkBlendMode = function(t, e) {
      t.setBlendMode(e.blendMode);
    }, r.checkPolygonOffset = function(t, e) {
      t.setPolygonOffset(1, e.polygonOffset);
    }, r.prototype.destroy = function() {
      this.gl = null;
    }, r;
  }()
), Yp = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = K.GC_MAX_IDLE, this.checkCountMax = K.GC_MAX_CHECK_COUNT, this.mode = K.GC_MODE;
    }
    return r.prototype.postrender = function() {
      this.renderer.renderingToScreen && (this.count++, this.mode !== Sn.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
    }, r.prototype.run = function() {
      for (var t = this.renderer.texture, e = t.managedTextures, i = !1, n = 0; n < e.length; n++) {
        var s = e[n];
        !s.framebuffer && this.count - s.touched > this.maxIdle && (t.destroyTexture(s, !0), e[n] = null, i = !0);
      }
      if (i) {
        for (var o = 0, n = 0; n < e.length; n++)
          e[n] !== null && (e[o++] = e[n]);
        e.length = o;
      }
    }, r.prototype.unload = function(t) {
      var e = this.renderer.texture, i = t._texture;
      i && !i.framebuffer && e.destroyTexture(i);
      for (var n = t.children.length - 1; n >= 0; n--)
        this.unload(t.children[n]);
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
);
function qp(r) {
  var t, e, i, n, s, o, a, h, l, u, c, f, d, p, v, _, m, y, b, P, x, T, I;
  return "WebGL2RenderingContext" in globalThis && r instanceof globalThis.WebGL2RenderingContext ? I = (t = {}, t[st.UNSIGNED_BYTE] = (e = {}, e[z.RGBA] = r.RGBA8, e[z.RGB] = r.RGB8, e[z.RG] = r.RG8, e[z.RED] = r.R8, e[z.RGBA_INTEGER] = r.RGBA8UI, e[z.RGB_INTEGER] = r.RGB8UI, e[z.RG_INTEGER] = r.RG8UI, e[z.RED_INTEGER] = r.R8UI, e[z.ALPHA] = r.ALPHA, e[z.LUMINANCE] = r.LUMINANCE, e[z.LUMINANCE_ALPHA] = r.LUMINANCE_ALPHA, e), t[st.BYTE] = (i = {}, i[z.RGBA] = r.RGBA8_SNORM, i[z.RGB] = r.RGB8_SNORM, i[z.RG] = r.RG8_SNORM, i[z.RED] = r.R8_SNORM, i[z.RGBA_INTEGER] = r.RGBA8I, i[z.RGB_INTEGER] = r.RGB8I, i[z.RG_INTEGER] = r.RG8I, i[z.RED_INTEGER] = r.R8I, i), t[st.UNSIGNED_SHORT] = (n = {}, n[z.RGBA_INTEGER] = r.RGBA16UI, n[z.RGB_INTEGER] = r.RGB16UI, n[z.RG_INTEGER] = r.RG16UI, n[z.RED_INTEGER] = r.R16UI, n[z.DEPTH_COMPONENT] = r.DEPTH_COMPONENT16, n), t[st.SHORT] = (s = {}, s[z.RGBA_INTEGER] = r.RGBA16I, s[z.RGB_INTEGER] = r.RGB16I, s[z.RG_INTEGER] = r.RG16I, s[z.RED_INTEGER] = r.R16I, s), t[st.UNSIGNED_INT] = (o = {}, o[z.RGBA_INTEGER] = r.RGBA32UI, o[z.RGB_INTEGER] = r.RGB32UI, o[z.RG_INTEGER] = r.RG32UI, o[z.RED_INTEGER] = r.R32UI, o[z.DEPTH_COMPONENT] = r.DEPTH_COMPONENT24, o), t[st.INT] = (a = {}, a[z.RGBA_INTEGER] = r.RGBA32I, a[z.RGB_INTEGER] = r.RGB32I, a[z.RG_INTEGER] = r.RG32I, a[z.RED_INTEGER] = r.R32I, a), t[st.FLOAT] = (h = {}, h[z.RGBA] = r.RGBA32F, h[z.RGB] = r.RGB32F, h[z.RG] = r.RG32F, h[z.RED] = r.R32F, h[z.DEPTH_COMPONENT] = r.DEPTH_COMPONENT32F, h), t[st.HALF_FLOAT] = (l = {}, l[z.RGBA] = r.RGBA16F, l[z.RGB] = r.RGB16F, l[z.RG] = r.RG16F, l[z.RED] = r.R16F, l), t[st.UNSIGNED_SHORT_5_6_5] = (u = {}, u[z.RGB] = r.RGB565, u), t[st.UNSIGNED_SHORT_4_4_4_4] = (c = {}, c[z.RGBA] = r.RGBA4, c), t[st.UNSIGNED_SHORT_5_5_5_1] = (f = {}, f[z.RGBA] = r.RGB5_A1, f), t[st.UNSIGNED_INT_2_10_10_10_REV] = (d = {}, d[z.RGBA] = r.RGB10_A2, d[z.RGBA_INTEGER] = r.RGB10_A2UI, d), t[st.UNSIGNED_INT_10F_11F_11F_REV] = (p = {}, p[z.RGB] = r.R11F_G11F_B10F, p), t[st.UNSIGNED_INT_5_9_9_9_REV] = (v = {}, v[z.RGB] = r.RGB9_E5, v), t[st.UNSIGNED_INT_24_8] = (_ = {}, _[z.DEPTH_STENCIL] = r.DEPTH24_STENCIL8, _), t[st.FLOAT_32_UNSIGNED_INT_24_8_REV] = (m = {}, m[z.DEPTH_STENCIL] = r.DEPTH32F_STENCIL8, m), t) : I = (y = {}, y[st.UNSIGNED_BYTE] = (b = {}, b[z.RGBA] = r.RGBA, b[z.RGB] = r.RGB, b[z.ALPHA] = r.ALPHA, b[z.LUMINANCE] = r.LUMINANCE, b[z.LUMINANCE_ALPHA] = r.LUMINANCE_ALPHA, b), y[st.UNSIGNED_SHORT_5_6_5] = (P = {}, P[z.RGB] = r.RGB, P), y[st.UNSIGNED_SHORT_4_4_4_4] = (x = {}, x[z.RGBA] = r.RGBA, x), y[st.UNSIGNED_SHORT_5_5_5_1] = (T = {}, T[z.RGBA] = r.RGBA, T), y), I;
}
var ls = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t) {
      this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = st.UNSIGNED_BYTE, this.internalFormat = z.RGBA, this.samplerType = 0;
    }
    return r;
  }()
), Zp = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new gt(), this.hasIntegerTextures = !1;
    }
    return r.prototype.contextChange = function() {
      var t = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = qp(t);
      var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = e;
      for (var i = 0; i < e; i++)
        this.boundTextures[i] = null;
      this.emptyTextures = {};
      var n = new ls(t.createTexture());
      t.bindTexture(t.TEXTURE_2D, n.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = n, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new ls(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
      for (var i = 0; i < 6; i++)
        t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
      t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
      for (var i = 0; i < this.boundTextures.length; i++)
        this.bind(null, i);
    }, r.prototype.bind = function(t, e) {
      e === void 0 && (e = 0);
      var i = this.gl;
      if (t = t?.castToBaseTexture(), t && t.valid && !t.parentTextureArray) {
        t.touched = this.renderer.textureGC.count;
        var n = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
        this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, i.activeTexture(i.TEXTURE0 + e)), i.bindTexture(t.target, n.texture)), n.dirtyId !== t.dirtyId ? (this.currentLocation !== e && (this.currentLocation = e, i.activeTexture(i.TEXTURE0 + e)), this.updateTexture(t)) : n.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t), this.boundTextures[e] = t;
      } else
        this.currentLocation !== e && (this.currentLocation = e, i.activeTexture(i.TEXTURE0 + e)), i.bindTexture(i.TEXTURE_2D, this.emptyTextures[i.TEXTURE_2D].texture), this.boundTextures[e] = null;
    }, r.prototype.reset = function() {
      this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;
      for (var t = 0; t < this.boundTextures.length; t++)
        this.boundTextures[t] = this.unknownTexture;
    }, r.prototype.unbind = function(t) {
      var e = this, i = e.gl, n = e.boundTextures;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = !1;
        for (var s = 0; s < n.length; s++)
          n[s] === this.unknownTexture && this.bind(null, s);
      }
      for (var s = 0; s < n.length; s++)
        n[s] === t && (this.currentLocation !== s && (i.activeTexture(i.TEXTURE0 + s), this.currentLocation = s), i.bindTexture(t.target, this.emptyTextures[t.target].texture), n[s] = null);
    }, r.prototype.ensureSamplerType = function(t) {
      var e = this, i = e.boundTextures, n = e.hasIntegerTextures, s = e.CONTEXT_UID;
      if (n)
        for (var o = t - 1; o >= 0; --o) {
          var a = i[o];
          if (a) {
            var h = a._glTextures[s];
            h.samplerType !== En.FLOAT && this.renderer.texture.unbind(a);
          }
        }
    }, r.prototype.initTexture = function(t) {
      var e = new ls(this.gl.createTexture());
      return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), e;
    }, r.prototype.initTextureType = function(t, e) {
      var i, n;
      e.internalFormat = (n = (i = this.internalFormats[t.type]) === null || i === void 0 ? void 0 : i[t.format]) !== null && n !== void 0 ? n : t.format, this.webGLVersion === 2 && t.type === st.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type;
    }, r.prototype.updateTexture = function(t) {
      var e = t._glTextures[this.CONTEXT_UID];
      if (e) {
        var i = this.renderer;
        if (this.initTextureType(t, e), t.resource && t.resource.upload(i, t, e))
          e.samplerType !== En.FLOAT && (this.hasIntegerTextures = !0);
        else {
          var n = t.realWidth, s = t.realHeight, o = i.gl;
          (e.width !== n || e.height !== s || e.dirtyId < 0) && (e.width = n, e.height = s, o.texImage2D(t.target, 0, e.internalFormat, n, s, 0, t.format, e.type, null));
        }
        t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId;
      }
    }, r.prototype.destroyTexture = function(t, e) {
      var i = this.gl;
      if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), i.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {
        var n = this.managedTextures.indexOf(t);
        n !== -1 && Fi(this.managedTextures, n, 1);
      }
    }, r.prototype.updateTextureStyle = function(t) {
      var e = t._glTextures[this.CONTEXT_UID];
      e && ((t.mipmap === Ee.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? e.mipmap = !1 : e.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? e.wrapMode = ke.CLAMP : e.wrapMode = t.wrapMode, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId);
    }, r.prototype.setStyle = function(t, e) {
      var i = this.gl;
      if (e.mipmap && t.mipmap !== Ee.ON_MANUAL && i.generateMipmap(t.target), i.texParameteri(t.target, i.TEXTURE_WRAP_S, e.wrapMode), i.texParameteri(t.target, i.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {
        i.texParameteri(t.target, i.TEXTURE_MIN_FILTER, t.scaleMode === Me.LINEAR ? i.LINEAR_MIPMAP_LINEAR : i.NEAREST_MIPMAP_NEAREST);
        var n = this.renderer.context.extensions.anisotropicFiltering;
        if (n && t.anisotropicLevel > 0 && t.scaleMode === Me.LINEAR) {
          var s = Math.min(t.anisotropicLevel, i.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          i.texParameterf(t.target, n.TEXTURE_MAX_ANISOTROPY_EXT, s);
        }
      } else
        i.texParameteri(t.target, i.TEXTURE_MIN_FILTER, t.scaleMode === Me.LINEAR ? i.LINEAR : i.NEAREST);
      i.texParameteri(t.target, i.TEXTURE_MAG_FILTER, t.scaleMode === Me.LINEAR ? i.LINEAR : i.NEAREST);
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), us = new Vt(), Kp = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e, i) {
      e === void 0 && (e = yr.UNKNOWN);
      var n = r.call(this) || this;
      return i = Object.assign({}, K.RENDER_OPTIONS, i), n.options = i, n.type = e, n.screen = new dt(0, 0, i.width, i.height), n.view = i.view || K.ADAPTER.createCanvas(), n.resolution = i.resolution || K.RESOLUTION, n.useContextAlpha = i.useContextAlpha, n.autoDensity = !!i.autoDensity, n.preserveDrawingBuffer = i.preserveDrawingBuffer, n.clearBeforeRender = i.clearBeforeRender, n._backgroundColor = 0, n._backgroundColorRgba = [0, 0, 0, 1], n._backgroundColorString = "#000000", n.backgroundColor = i.backgroundColor || n._backgroundColor, n.backgroundAlpha = i.backgroundAlpha, i.transparent !== void 0 && (Te("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), n.useContextAlpha = i.transparent, n.backgroundAlpha = i.transparent ? 0 : 1), n._lastObjectRendered = null, n.plugins = {}, n;
    }
    return t.prototype.initPlugins = function(e) {
      for (var i in e)
        this.plugins[i] = new e[i](this);
    }, Object.defineProperty(t.prototype, "width", {
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal.
       * @member {number}
       * @readonly
       * @default 800
       */
      get: function() {
        return this.view.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /**
       * Same as view.height, actual number of pixels in the canvas by vertical.
       * @member {number}
       * @readonly
       * @default 600
       */
      get: function() {
        return this.view.height;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.resize = function(e, i) {
      this.view.width = Math.round(e * this.resolution), this.view.height = Math.round(i * this.resolution);
      var n = this.view.width / this.resolution, s = this.view.height / this.resolution;
      this.screen.width = n, this.screen.height = s, this.autoDensity && (this.view.style.width = n + "px", this.view.style.height = s + "px"), this.emit("resize", n, s);
    }, t.prototype.generateTexture = function(e, i, n, s) {
      i === void 0 && (i = {}), typeof i == "number" && (Te("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), i = { scaleMode: i, resolution: n, region: s });
      var o = i.region, a = Nd(i, ["region"]);
      s = o || e.getLocalBounds(null, !0), s.width === 0 && (s.width = 1), s.height === 0 && (s.height = 1);
      var h = ce.create(Fs({ width: s.width, height: s.height }, a));
      return us.tx = -s.x, us.ty = -s.y, this.render(e, {
        renderTexture: h,
        clear: !1,
        transform: us,
        skipUpdateTransform: !!e.parent
      }), h;
    }, t.prototype.destroy = function(e) {
      for (var i in this.plugins)
        this.plugins[i].destroy(), this.plugins[i] = null;
      e && this.view.parentNode && this.view.parentNode.removeChild(this.view);
      var n = this;
      n.plugins = null, n.type = yr.UNKNOWN, n.view = null, n.screen = null, n._tempDisplayObjectParent = null, n.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;
    }, Object.defineProperty(t.prototype, "backgroundColor", {
      /**
       * The background color to fill if not transparent
       * @member {number}
       */
      get: function() {
        return this._backgroundColor;
      },
      set: function(e) {
        this._backgroundColor = e, this._backgroundColorString = Oh(e), Gi(e, this._backgroundColorRgba);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "backgroundAlpha", {
      /**
       * The background color alpha. Setting this to 0 will make the canvas transparent.
       * @member {number}
       */
      get: function() {
        return this._backgroundColorRgba[3];
      },
      set: function(e) {
        this._backgroundColorRgba[3] = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Pe)
), Jp = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t) {
      this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
    }
    return r;
  }()
), Qp = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {};
    }
    return r.prototype.destroy = function() {
      this.renderer = null;
    }, r.prototype.contextChange = function() {
      this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    }, r.prototype.bind = function(t) {
      var e = this, i = e.gl, n = e.CONTEXT_UID, s = t._glBuffers[n] || this.createGLBuffer(t);
      i.bindBuffer(t.type, s.buffer);
    }, r.prototype.bindBufferBase = function(t, e) {
      var i = this, n = i.gl, s = i.CONTEXT_UID;
      if (this.boundBufferBases[e] !== t) {
        var o = t._glBuffers[s] || this.createGLBuffer(t);
        this.boundBufferBases[e] = t, n.bindBufferBase(n.UNIFORM_BUFFER, e, o.buffer);
      }
    }, r.prototype.bindBufferRange = function(t, e, i) {
      var n = this, s = n.gl, o = n.CONTEXT_UID;
      i = i || 0;
      var a = t._glBuffers[o] || this.createGLBuffer(t);
      s.bindBufferRange(s.UNIFORM_BUFFER, e || 0, a.buffer, i * 256, 256);
    }, r.prototype.update = function(t) {
      var e = this, i = e.gl, n = e.CONTEXT_UID, s = t._glBuffers[n];
      if (t._updateID !== s.updateID)
        if (s.updateID = t._updateID, i.bindBuffer(t.type, s.buffer), s.byteLength >= t.data.byteLength)
          i.bufferSubData(t.type, 0, t.data);
        else {
          var o = t.static ? i.STATIC_DRAW : i.DYNAMIC_DRAW;
          s.byteLength = t.data.byteLength, i.bufferData(t.type, t.data, o);
        }
    }, r.prototype.dispose = function(t, e) {
      if (this.managedBuffers[t.id]) {
        delete this.managedBuffers[t.id];
        var i = t._glBuffers[this.CONTEXT_UID], n = this.gl;
        t.disposeRunner.remove(this), i && (e || n.deleteBuffer(i.buffer), delete t._glBuffers[this.CONTEXT_UID]);
      }
    }, r.prototype.disposeAll = function(t) {
      for (var e = Object.keys(this.managedBuffers), i = 0; i < e.length; i++)
        this.dispose(this.managedBuffers[e[i]], t);
    }, r.prototype.createGLBuffer = function(t) {
      var e = this, i = e.CONTEXT_UID, n = e.gl;
      return t._glBuffers[i] = new Jp(n.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[i];
    }, r;
  }()
), Kh = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e) {
      var i = r.call(this, yr.WEBGL, e) || this;
      return e = i.options, i.gl = null, i.CONTEXT_UID = 0, i.runners = {
        destroy: new Zt("destroy"),
        contextChange: new Zt("contextChange"),
        reset: new Zt("reset"),
        update: new Zt("update"),
        postrender: new Zt("postrender"),
        prerender: new Zt("prerender"),
        resize: new Zt("resize")
      }, i.runners.contextChange.add(i), i.globalUniforms = new Ti({
        projectionMatrix: new Vt()
      }, !0), i.addSystem(Ep, "mask").addSystem(Qd, "context").addSystem(Wp, "state").addSystem(Up, "shader").addSystem(Zp, "texture").addSystem(Qp, "buffer").addSystem(rp, "geometry").addSystem(ip, "framebuffer").addSystem(Sp, "scissor").addSystem(Pp, "stencil").addSystem(Cp, "projection").addSystem(Yp, "textureGC").addSystem(Kd, "filter").addSystem(Ip, "renderTexture").addSystem(Jd, "batch"), i.initPlugins(t.__plugins), i.multisample = void 0, e.context ? i.context.initFromContext(e.context) : i.context.initFromOptions({
        alpha: !!i.useContextAlpha,
        antialias: e.antialias,
        premultipliedAlpha: i.useContextAlpha && i.useContextAlpha !== "notMultiplied",
        stencil: !0,
        preserveDrawingBuffer: e.preserveDrawingBuffer,
        powerPreference: i.options.powerPreference
      }), i.renderingToScreen = !0, Ou(i.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1"), i.resize(i.options.width, i.options.height), i;
    }
    return t.create = function(e) {
      if (Mu())
        return new t(e);
      throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
    }, t.prototype.contextChange = function() {
      var e = this.gl, i;
      if (this.context.webGLVersion === 1) {
        var n = e.getParameter(e.FRAMEBUFFER_BINDING);
        e.bindFramebuffer(e.FRAMEBUFFER, null), i = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, n);
      } else {
        var n = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);
        e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), i = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, n);
      }
      i >= Rt.HIGH ? this.multisample = Rt.HIGH : i >= Rt.MEDIUM ? this.multisample = Rt.MEDIUM : i >= Rt.LOW ? this.multisample = Rt.LOW : this.multisample = Rt.NONE;
    }, t.prototype.addSystem = function(e, i) {
      var n = new e(this);
      if (this[i])
        throw new Error('Whoops! The name "' + i + '" is already in use');
      this[i] = n;
      for (var s in this.runners)
        this.runners[s].add(n);
      return this;
    }, t.prototype.render = function(e, i) {
      var n, s, o, a;
      if (i && (i instanceof ce ? (Te("6.0.0", "Renderer#render arguments changed, use options instead."), n = i, s = arguments[2], o = arguments[3], a = arguments[4]) : (n = i.renderTexture, s = i.clear, o = i.transform, a = i.skipUpdateTransform)), this.renderingToScreen = !n, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = o, !this.context.isLost) {
        if (n || (this._lastObjectRendered = e), !a) {
          var h = e.enableTempParent();
          e.updateTransform(), e.disableTempParent(h);
        }
        this.renderTexture.bind(n), this.batch.currentRenderer.start(), (s !== void 0 ? s : this.clearBeforeRender) && this.renderTexture.clear(), e.render(this), this.batch.currentRenderer.flush(), n && n.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender");
      }
    }, t.prototype.generateTexture = function(e, i, n, s) {
      i === void 0 && (i = {});
      var o = r.prototype.generateTexture.call(this, e, i, n, s);
      return this.framebuffer.blit(), o;
    }, t.prototype.resize = function(e, i) {
      r.prototype.resize.call(this, e, i), this.runners.resize.emit(this.screen.height, this.screen.width);
    }, t.prototype.reset = function() {
      return this.runners.reset.emit(), this;
    }, t.prototype.clear = function() {
      this.renderTexture.bind(), this.renderTexture.clear();
    }, t.prototype.destroy = function(e) {
      this.runners.destroy.emit();
      for (var i in this.runners)
        this.runners[i].destroy();
      r.prototype.destroy.call(this, e), this.gl = null;
    }, Object.defineProperty(t.prototype, "extract", {
      /**
       * Please use `plugins.extract` instead.
       * @member {PIXI.Extract} extract
       * @deprecated since 6.0.0
       * @readonly
       */
      get: function() {
        return Te("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract;
      },
      enumerable: !1,
      configurable: !0
    }), t.registerPlugin = function(e, i) {
      Te("6.5.0", "Renderer.registerPlugin() has been deprecated, please use extensions.add() instead."), Ue.add({
        name: e,
        type: St.RendererPlugin,
        ref: i
      });
    }, t.__plugins = {}, t;
  }(Kp)
);
Ue.handleByMap(St.RendererPlugin, Kh.__plugins);
function Jh(r) {
  return Kh.create(r);
}
var tv = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`, ev = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, iv = tv, Qh = ev, Us = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.texArray = null, this.blend = 0, this.type = we.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
    }
    return r;
  }()
), Gs = (
  /** @class */
  function() {
    function r() {
      this.elements = [], this.ids = [], this.count = 0;
    }
    return r.prototype.clear = function() {
      for (var t = 0; t < this.count; t++)
        this.elements[t] = null;
      this.count = 0;
    }, r;
  }()
), js = (
  /** @class */
  function() {
    function r(t) {
      typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
    }
    return Object.defineProperty(r.prototype, "int8View", {
      /** View on the raw binary data as a `Int8Array`. */
      get: function() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "uint8View", {
      /** View on the raw binary data as a `Uint8Array`. */
      get: function() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "int16View", {
      /**  View on the raw binary data as a `Int16Array`. */
      get: function() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "uint16View", {
      /** View on the raw binary data as a `Uint16Array`. */
      get: function() {
        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "int32View", {
      /** View on the raw binary data as a `Int32Array`. */
      get: function() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.view = function(t) {
      return this[t + "View"];
    }, r.prototype.destroy = function() {
      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
    }, r.sizeOf = function(t) {
      switch (t) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(t + " isn't a valid view type");
      }
    }, r;
  }()
), rv = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e) {
      var i = r.call(this, e) || this;
      return i.shaderGenerator = null, i.geometryClass = null, i.vertexSize = null, i.state = Oi.for2d(), i.size = K.SPRITE_BATCH_SIZE * 4, i._vertexCount = 0, i._indexCount = 0, i._bufferedElements = [], i._bufferedTextures = [], i._bufferSize = 0, i._shader = null, i._packedGeometries = [], i._packedGeometryPoolSize = 2, i._flushId = 0, i._aBuffers = {}, i._iBuffers = {}, i.MAX_TEXTURES = 1, i.renderer.on("prerender", i.onPrerender, i), e.runners.contextChange.add(i), i._dcIndex = 0, i._aIndex = 0, i._iIndex = 0, i._attributeBuffer = null, i._indexBuffer = null, i._tempBoundTextures = [], i;
    }
    return t.prototype.contextChange = function() {
      var e = this.renderer.gl;
      K.PREFER_ENV === qe.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), K.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = pp(this.MAX_TEXTURES, e)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
      for (var i = 0; i < this._packedGeometryPoolSize; i++)
        this._packedGeometries[i] = new this.geometryClass();
      this.initFlushBuffers();
    }, t.prototype.initFlushBuffers = function() {
      for (var e = t._drawCallPool, i = t._textureArrayPool, n = this.size / 4, s = Math.floor(n / this.MAX_TEXTURES) + 1; e.length < n; )
        e.push(new Us());
      for (; i.length < s; )
        i.push(new Gs());
      for (var o = 0; o < this.MAX_TEXTURES; o++)
        this._tempBoundTextures[o] = null;
    }, t.prototype.onPrerender = function() {
      this._flushId = 0;
    }, t.prototype.render = function(e) {
      e._texture.valid && (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e);
    }, t.prototype.buildTexturesAndDrawCalls = function() {
      var e = this, i = e._bufferedTextures, n = e.MAX_TEXTURES, s = t._textureArrayPool, o = this.renderer.batch, a = this._tempBoundTextures, h = this.renderer.textureGC.count, l = ++gt._globalBatch, u = 0, c = s[0], f = 0;
      o.copyBoundTextures(a, n);
      for (var d = 0; d < this._bufferSize; ++d) {
        var p = i[d];
        i[d] = null, p._batchEnabled !== l && (c.count >= n && (o.boundArray(c, a, l, n), this.buildDrawCalls(c, f, d), f = d, c = s[++u], ++l), p._batchEnabled = l, p.touched = h, c.elements[c.count++] = p);
      }
      c.count > 0 && (o.boundArray(c, a, l, n), this.buildDrawCalls(c, f, this._bufferSize), ++u, ++l);
      for (var d = 0; d < a.length; d++)
        a[d] = null;
      gt._globalBatch = l;
    }, t.prototype.buildDrawCalls = function(e, i, n) {
      var s = this, o = s._bufferedElements, a = s._attributeBuffer, h = s._indexBuffer, l = s.vertexSize, u = t._drawCallPool, c = this._dcIndex, f = this._aIndex, d = this._iIndex, p = u[c];
      p.start = this._iIndex, p.texArray = e;
      for (var v = i; v < n; ++v) {
        var _ = o[v], m = _._texture.baseTexture, y = Rh[m.alphaMode ? 1 : 0][_.blendMode];
        o[v] = null, i < v && p.blend !== y && (p.size = d - p.start, i = v, p = u[++c], p.texArray = e, p.start = d), this.packInterleavedGeometry(_, a, h, f, d), f += _.vertexData.length / 2 * l, d += _.indices.length, p.blend = y;
      }
      i < n && (p.size = d - p.start, ++c), this._dcIndex = c, this._aIndex = f, this._iIndex = d;
    }, t.prototype.bindAndClearTexArray = function(e) {
      for (var i = this.renderer.texture, n = 0; n < e.count; n++)
        i.bind(e.elements[n], e.ids[n]), e.elements[n] = null;
      e.count = 0;
    }, t.prototype.updateGeometry = function() {
      var e = this, i = e._packedGeometries, n = e._attributeBuffer, s = e._indexBuffer;
      K.CAN_UPLOAD_SAME_BUFFER ? (i[this._flushId]._buffer.update(n.rawBinaryData), i[this._flushId]._indexBuffer.update(s), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, i[this._flushId] = new this.geometryClass()), i[this._flushId]._buffer.update(n.rawBinaryData), i[this._flushId]._indexBuffer.update(s), this.renderer.geometry.bind(i[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
    }, t.prototype.drawBatches = function() {
      for (var e = this._dcIndex, i = this.renderer, n = i.gl, s = i.state, o = t._drawCallPool, a = null, h = 0; h < e; h++) {
        var l = o[h], u = l.texArray, c = l.type, f = l.size, d = l.start, p = l.blend;
        a !== u && (a = u, this.bindAndClearTexArray(u)), this.state.blendMode = p, s.set(this.state), n.drawElements(c, f, n.UNSIGNED_SHORT, d * 2);
      }
    }, t.prototype.flush = function() {
      this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
    }, t.prototype.start = function() {
      this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), K.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }, t.prototype.stop = function() {
      this.flush();
    }, t.prototype.destroy = function() {
      for (var e = 0; e < this._packedGeometryPoolSize; e++)
        this._packedGeometries[e] && this._packedGeometries[e].destroy();
      this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), r.prototype.destroy.call(this);
    }, t.prototype.getAttributeBuffer = function(e) {
      var i = Pn(Math.ceil(e / 8)), n = pa(i), s = i * 8;
      this._aBuffers.length <= n && (this._iBuffers.length = n + 1);
      var o = this._aBuffers[s];
      return o || (this._aBuffers[s] = o = new js(s * this.vertexSize * 4)), o;
    }, t.prototype.getIndexBuffer = function(e) {
      var i = Pn(Math.ceil(e / 12)), n = pa(i), s = i * 12;
      this._iBuffers.length <= n && (this._iBuffers.length = n + 1);
      var o = this._iBuffers[n];
      return o || (this._iBuffers[n] = o = new Uint16Array(s)), o;
    }, t.prototype.packInterleavedGeometry = function(e, i, n, s, o) {
      for (var a = i.uint32View, h = i.float32View, l = s / this.vertexSize, u = e.uvs, c = e.indices, f = e.vertexData, d = e._texture.baseTexture._batchLocation, p = Math.min(e.worldAlpha, 1), v = p < 1 && e._texture.baseTexture.alphaMode ? Io(e._tintRGB, p) : e._tintRGB + (p * 255 << 24), _ = 0; _ < f.length; _ += 2)
        h[s++] = f[_], h[s++] = f[_ + 1], h[s++] = u[_], h[s++] = u[_ + 1], a[s++] = v, h[s++] = d;
      for (var _ = 0; _ < c.length; _++)
        n[o++] = l + c[_];
    }, t._drawCallPool = [], t._textureArrayPool = [], t;
  }(Bn)
), nv = (
  /** @class */
  function() {
    function r(t, e) {
      if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf("%count%") < 0)
        throw new Error('Fragment template must contain "%count%".');
      if (e.indexOf("%forloop%") < 0)
        throw new Error('Fragment template must contain "%forloop%".');
    }
    return r.prototype.generateShader = function(t) {
      if (!this.programCache[t]) {
        for (var e = new Int32Array(t), i = 0; i < t; i++)
          e[i] = i;
        this.defaultGroupCache[t] = Ti.from({ uSamplers: e }, !0);
        var n = this.fragTemplate;
        n = n.replace(/%count%/gi, "" + t), n = n.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new kr(this.vertexSrc, n);
      }
      var s = {
        tint: new Float32Array([1, 1, 1, 1]),
        translationMatrix: new Vt(),
        default: this.defaultGroupCache[t]
      };
      return new hi(this.programCache[t], s);
    }, r.prototype.generateSampleSrc = function(t) {
      var e = "";
      e += `
`, e += `
`;
      for (var i = 0; i < t; i++)
        i > 0 && (e += `
else `), i < t - 1 && (e += "if(vTextureId < " + i + ".5)"), e += `
{`, e += `
	color = texture2D(uSamplers[` + i + "], vTextureCoord);", e += `
}`;
      return e += `
`, e += `
`, e;
    }, r;
  }()
), tl = (
  /** @class */
  function(r) {
    It(t, r);
    function t(e) {
      e === void 0 && (e = !1);
      var i = r.call(this) || this;
      return i._buffer = new Xt(null, e, !1), i._indexBuffer = new Xt(null, e, !0), i.addAttribute("aVertexPosition", i._buffer, 2, !1, st.FLOAT).addAttribute("aTextureCoord", i._buffer, 2, !1, st.FLOAT).addAttribute("aColor", i._buffer, 4, !0, st.UNSIGNED_BYTE).addAttribute("aTextureId", i._buffer, 1, !0, st.FLOAT).addIndex(i._indexBuffer), i;
    }
    return t;
  }(Rr)
), Ma = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`, Ra = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`, sv = (
  /** @class */
  function() {
    function r() {
    }
    return r.create = function(t) {
      var e = Object.assign({
        vertex: Ma,
        fragment: Ra,
        geometryClass: tl,
        vertexSize: 6
      }, t), i = e.vertex, n = e.fragment, s = e.vertexSize, o = e.geometryClass;
      return (
        /** @class */
        function(a) {
          It(h, a);
          function h(l) {
            var u = a.call(this, l) || this;
            return u.shaderGenerator = new nv(i, n), u.geometryClass = o, u.vertexSize = s, u;
          }
          return h;
        }(rv)
      );
    }, Object.defineProperty(r, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @readonly
       */
      get: function() {
        return Ma;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "defaultFragmentTemplate", {
      /**
       * The default fragment shader source
       * @readonly
       */
      get: function() {
        return Ra;
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
), el = sv.create();
Object.assign(el, {
  extension: {
    name: "batch",
    type: St.RendererPlugin
  }
});
/*!
 * @pixi/accessibility - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/accessibility is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ov = {
  /**
   *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
   *   shadow div with attributes set
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  accessible: !1,
  /**
   * Sets the title attribute of the shadow div
   * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
   * @member {?string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleTitle: null,
  /**
   * Sets the aria-label attribute of the shadow div
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleHint: null,
  /**
   * @member {number}
   * @memberof PIXI.DisplayObject#
   * @private
   * @todo Needs docs.
   */
  tabIndex: 0,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleActive: !1,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleDiv: null,
  /**
   * Specify the type of div the accessible layer is. Screen readers treat the element differently
   * depending on this type. Defaults to button.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'button'
   */
  accessibleType: "button",
  /**
   * Specify the pointer-events the accessible div will use
   * Defaults to auto.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'auto'
   */
  accessiblePointerEvents: "auto",
  /**
   * Setting to false will prevent any children inside this container to
   * be accessible. Defaults to true.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @default true
   */
  accessibleChildren: !0,
  renderId: -1
};
Ut.mixin(ov);
var av = 9, Vr = 100, hv = 0, lv = 0, ka = 2, Na = 1, uv = -1e3, cv = -1e3, fv = 2, dv = (
  /** @class */
  function() {
    function r(t) {
      this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (Re.tablet || Re.phone) && this.createTouchHook();
      var e = document.createElement("div");
      e.style.width = Vr + "px", e.style.height = Vr + "px", e.style.position = "absolute", e.style.top = hv + "px", e.style.left = lv + "px", e.style.zIndex = ka.toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1);
    }
    return Object.defineProperty(r.prototype, "isActive", {
      /**
       * Value of `true` if accessibility is currently active and accessibility layers are showing.
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this._isActive;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "isMobileAccessibility", {
      /**
       * Value of `true` if accessibility is enabled for touch devices.
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this._isMobileAccessibility;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.createTouchHook = function() {
      var t = this, e = document.createElement("button");
      e.style.width = Na + "px", e.style.height = Na + "px", e.style.position = "absolute", e.style.top = uv + "px", e.style.left = cv + "px", e.style.zIndex = fv.toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessibility for this content", e.addEventListener("focus", function() {
        t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook();
      }), document.body.appendChild(e), this._hookDiv = e;
    }, r.prototype.destroyTouchHook = function() {
      this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
    }, r.prototype.activate = function() {
      var t;
      this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), (t = this.renderer.view.parentNode) === null || t === void 0 || t.appendChild(this.div));
    }, r.prototype.deactivate = function() {
      var t;
      !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), (t = this.div.parentNode) === null || t === void 0 || t.removeChild(this.div));
    }, r.prototype.updateAccessibleObjects = function(t) {
      if (!(!t.visible || !t.accessibleChildren)) {
        t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);
        var e = t.children;
        if (e)
          for (var i = 0; i < e.length; i++)
            this.updateAccessibleObjects(e[i]);
      }
    }, r.prototype.update = function() {
      var t = performance.now();
      if (!(Re.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, !!this.renderer.renderingToScreen)) {
        this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);
        var e = this.renderer.view.getBoundingClientRect(), i = e.left, n = e.top, s = e.width, o = e.height, a = this.renderer, h = a.width, l = a.height, u = a.resolution, c = s / h * u, f = o / l * u, d = this.div;
        d.style.left = i + "px", d.style.top = n + "px", d.style.width = h + "px", d.style.height = l + "px";
        for (var p = 0; p < this.children.length; p++) {
          var v = this.children[p];
          if (v.renderId !== this.renderId)
            v._accessibleActive = !1, Fi(this.children, p, 1), this.div.removeChild(v._accessibleDiv), this.pool.push(v._accessibleDiv), v._accessibleDiv = null, p--;
          else {
            d = v._accessibleDiv;
            var _ = v.hitArea, m = v.worldTransform;
            v.hitArea ? (d.style.left = (m.tx + _.x * m.a) * c + "px", d.style.top = (m.ty + _.y * m.d) * f + "px", d.style.width = _.width * m.a * c + "px", d.style.height = _.height * m.d * f + "px") : (_ = v.getBounds(), this.capHitArea(_), d.style.left = _.x * c + "px", d.style.top = _.y * f + "px", d.style.width = _.width * c + "px", d.style.height = _.height * f + "px", d.title !== v.accessibleTitle && v.accessibleTitle !== null && (d.title = v.accessibleTitle), d.getAttribute("aria-label") !== v.accessibleHint && v.accessibleHint !== null && d.setAttribute("aria-label", v.accessibleHint)), (v.accessibleTitle !== d.title || v.tabIndex !== d.tabIndex) && (d.title = v.accessibleTitle, d.tabIndex = v.tabIndex, this.debug && this.updateDebugHTML(d));
          }
        }
        this.renderId++;
      }
    }, r.prototype.updateDebugHTML = function(t) {
      t.innerHTML = "type: " + t.type + "</br> title : " + t.title + "</br> tabIndex: " + t.tabIndex;
    }, r.prototype.capHitArea = function(t) {
      t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
      var e = this.renderer, i = e.width, n = e.height;
      t.x + t.width > i && (t.width = i - t.x), t.y + t.height > n && (t.height = n - t.y);
    }, r.prototype.addChild = function(t) {
      var e = this.pool.pop();
      e || (e = document.createElement("button"), e.style.width = Vr + "px", e.style.height = Vr + "px", e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = ka.toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = "displayObject " + t.tabIndex), t.accessibleHint && t.accessibleHint !== null && e.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex;
    }, r.prototype._onClick = function(t) {
      var e = this.renderer.plugins.interaction, i = t.target.displayObject, n = e.eventData;
      e.dispatchEvent(i, "click", n), e.dispatchEvent(i, "pointertap", n), e.dispatchEvent(i, "tap", n);
    }, r.prototype._onFocus = function(t) {
      t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive");
      var e = this.renderer.plugins.interaction, i = t.target.displayObject, n = e.eventData;
      e.dispatchEvent(i, "mouseover", n);
    }, r.prototype._onFocusOut = function(t) {
      t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite");
      var e = this.renderer.plugins.interaction, i = t.target.displayObject, n = e.eventData;
      e.dispatchEvent(i, "mouseout", n);
    }, r.prototype._onKeyDown = function(t) {
      t.keyCode === av && this.activate();
    }, r.prototype._onMouseMove = function(t) {
      t.movementX === 0 && t.movementY === 0 || this.deactivate();
    }, r.prototype.destroy = function() {
      this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;
    }, r.extension = {
      name: "accessibility",
      type: [
        St.RendererPlugin,
        St.CanvasRendererPlugin
      ]
    }, r;
  }()
);
/*!
 * @pixi/interaction - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Aa = (
  /** @class */
  function() {
    function r() {
      this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new Ot(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;
    }
    return Object.defineProperty(r.prototype, "pointerId", {
      /**
       * The unique identifier of the pointer. It will be the same as `identifier`.
       * @readonly
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
       */
      get: function() {
        return this.identifier;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.getLocalPosition = function(t, e, i) {
      return t.worldTransform.applyInverse(i || this.global, e);
    }, r.prototype.copyEvent = function(t) {
      "isPrimary" in t && t.isPrimary && (this.isPrimary = !0), this.button = "button" in t && t.button;
      var e = "buttons" in t && t.buttons;
      this.buttons = Number.isInteger(e) ? e : "which" in t && t.which, this.width = "width" in t && t.width, this.height = "height" in t && t.height, this.tiltX = "tiltX" in t && t.tiltX, this.tiltY = "tiltY" in t && t.tiltY, this.pointerType = "pointerType" in t && t.pointerType, this.pressure = "pressure" in t && t.pressure, this.rotationAngle = "rotationAngle" in t && t.rotationAngle, this.twist = "twist" in t && t.twist || 0, this.tangentialPressure = "tangentialPressure" in t && t.tangentialPressure || 0;
    }, r.prototype.reset = function() {
      this.isPrimary = !1;
    }, r;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Hs = function(r, t) {
  return Hs = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Hs(r, t);
};
function pv(r, t) {
  Hs(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var vv = (
  /** @class */
  function() {
    function r() {
      this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null;
    }
    return r.prototype.stopPropagation = function() {
      this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget;
    }, r.prototype.reset = function() {
      this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null;
    }, r;
  }()
), cs = (
  /** @class */
  function() {
    function r(t) {
      this._pointerId = t, this._flags = r.FLAGS.NONE;
    }
    return r.prototype._doSet = function(t, e) {
      e ? this._flags = this._flags | t : this._flags = this._flags & ~t;
    }, Object.defineProperty(r.prototype, "pointerId", {
      /**
       * Unique pointer id of the event
       * @readonly
       * @private
       * @member {number}
       */
      get: function() {
        return this._pointerId;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "flags", {
      /**
       * State of the tracking data, expressed as bit flags
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags;
      },
      set: function(t) {
        this._flags = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "none", {
      /**
       * Is the tracked event inactive (not over or down)?
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags === r.FLAGS.NONE;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "over", {
      /**
       * Is the tracked event over the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & r.FLAGS.OVER) !== 0;
      },
      set: function(t) {
        this._doSet(r.FLAGS.OVER, t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "rightDown", {
      /**
       * Did the right mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & r.FLAGS.RIGHT_DOWN) !== 0;
      },
      set: function(t) {
        this._doSet(r.FLAGS.RIGHT_DOWN, t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "leftDown", {
      /**
       * Did the left mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & r.FLAGS.LEFT_DOWN) !== 0;
      },
      set: function(t) {
        this._doSet(r.FLAGS.LEFT_DOWN, t);
      },
      enumerable: !1,
      configurable: !0
    }), r.FLAGS = Object.freeze({
      NONE: 0,
      OVER: 1,
      LEFT_DOWN: 2,
      RIGHT_DOWN: 4
    }), r;
  }()
), _v = (
  /** @class */
  function() {
    function r() {
      this._tempPoint = new Ot();
    }
    return r.prototype.recursiveFindHit = function(t, e, i, n, s) {
      var o;
      if (!e || !e.visible)
        return !1;
      var a = t.data.global;
      s = e.interactive || s;
      var h = !1, l = s, u = !0;
      if (e.hitArea)
        n && (e.worldTransform.applyInverse(a, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? h = !0 : (n = !1, u = !1)), l = !1;
      else if (e._mask && n) {
        var c = e._mask.isMaskData ? e._mask.maskObject : e._mask;
        c && !(!((o = c.containsPoint) === null || o === void 0) && o.call(c, a)) && (n = !1);
      }
      if (u && e.interactiveChildren && e.children)
        for (var f = e.children, d = f.length - 1; d >= 0; d--) {
          var p = f[d], v = this.recursiveFindHit(t, p, i, n, l);
          if (v) {
            if (!p.parent)
              continue;
            l = !1, v && (t.target && (n = !1), h = !0);
          }
        }
      return s && (n && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(a) && (h = !0), e.interactive && (h && !t.target && (t.target = e), i && i(t, e, !!h))), h;
    }, r.prototype.findHit = function(t, e, i, n) {
      this.recursiveFindHit(t, e, i, n, !1);
    }, r;
  }()
), mv = {
  interactive: !1,
  interactiveChildren: !0,
  hitArea: null,
  /**
   * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
   * Setting this changes the 'cursor' property to `'pointer'`.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.buttonMode = true;
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  get buttonMode() {
    return this.cursor === "pointer";
  },
  set buttonMode(r) {
    r ? this.cursor = "pointer" : this.cursor === "pointer" && (this.cursor = null);
  },
  /**
   * This defines what cursor mode is used when the mouse cursor
   * is hovered over the displayObject.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.cursor = 'wait';
   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  cursor: null,
  /**
   * Internal set of all active pointers, by identifier
   * @member {Map<number, InteractionTrackingData>}
   * @memberof PIXI.DisplayObject#
   * @private
   */
  get trackedPointers() {
    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;
  },
  /**
   * Map of all tracked pointers, by identifier. Use trackedPointers to access.
   * @private
   * @type {Map<number, InteractionTrackingData>}
   */
  _trackedPointers: void 0
};
Ut.mixin(mv);
var Wr = 1, Yr = {
  target: null,
  data: {
    global: null
  }
}, yv = (
  /** @class */
  function(r) {
    pv(t, r);
    function t(e, i) {
      var n = r.call(this) || this;
      return i = i || {}, n.renderer = e, n.autoPreventDefault = i.autoPreventDefault !== void 0 ? i.autoPreventDefault : !0, n.interactionFrequency = i.interactionFrequency || 10, n.mouse = new Aa(), n.mouse.identifier = Wr, n.mouse.global.set(-999999), n.activeInteractionData = {}, n.activeInteractionData[Wr] = n.mouse, n.interactionDataPool = [], n.eventData = new vv(), n.interactionDOMElement = null, n.moveWhenInside = !1, n.eventsAdded = !1, n.tickerAdded = !1, n.mouseOverRenderer = !("PointerEvent" in globalThis), n.supportsTouchEvents = "ontouchstart" in globalThis, n.supportsPointerEvents = !!globalThis.PointerEvent, n.onPointerUp = n.onPointerUp.bind(n), n.processPointerUp = n.processPointerUp.bind(n), n.onPointerCancel = n.onPointerCancel.bind(n), n.processPointerCancel = n.processPointerCancel.bind(n), n.onPointerDown = n.onPointerDown.bind(n), n.processPointerDown = n.processPointerDown.bind(n), n.onPointerMove = n.onPointerMove.bind(n), n.processPointerMove = n.processPointerMove.bind(n), n.onPointerOut = n.onPointerOut.bind(n), n.processPointerOverOut = n.processPointerOverOut.bind(n), n.onPointerOver = n.onPointerOver.bind(n), n.cursorStyles = {
        default: "inherit",
        pointer: "pointer"
      }, n.currentCursorMode = null, n.cursor = null, n.resolution = 1, n.delayedEvents = [], n.search = new _v(), n._tempDisplayObject = new Bh(), n._eventListenerOptions = { capture: !0, passive: !1 }, n._useSystemTicker = i.useSystemTicker !== void 0 ? i.useSystemTicker : !0, n.setTargetElement(n.renderer.view, n.renderer.resolution), n;
    }
    return Object.defineProperty(t.prototype, "useSystemTicker", {
      /**
       * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.
       * @default true
       */
      get: function() {
        return this._useSystemTicker;
      },
      set: function(e) {
        this._useSystemTicker = e, e ? this.addTickerListener() : this.removeTickerListener();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastObjectRendered", {
      /**
       * Last rendered object or temp object.
       * @readonly
       * @protected
       */
      get: function() {
        return this.renderer._lastObjectRendered || this._tempDisplayObject;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.hitTest = function(e, i) {
      return Yr.target = null, Yr.data.global = e, i || (i = this.lastObjectRendered), this.processInteractive(Yr, i, null, !0), Yr.target;
    }, t.prototype.setTargetElement = function(e, i) {
      i === void 0 && (i = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = e, this.resolution = i, this.addEvents(), this.addTickerListener();
    }, t.prototype.addTickerListener = function() {
      this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker || (Lt.system.add(this.tickerUpdate, this, Ze.INTERACTION), this.tickerAdded = !0);
    }, t.prototype.removeTickerListener = function() {
      this.tickerAdded && (Lt.system.remove(this.tickerUpdate, this), this.tickerAdded = !1);
    }, t.prototype.addEvents = function() {
      if (!(this.eventsAdded || !this.interactionDOMElement)) {
        var e = this.interactionDOMElement.style;
        globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "none", e.msTouchAction = "none") : this.supportsPointerEvents && (e.touchAction = "none"), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0;
      }
    }, t.prototype.removeEvents = function() {
      if (!(!this.eventsAdded || !this.interactionDOMElement)) {
        var e = this.interactionDOMElement.style;
        globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "", e.msTouchAction = "") : this.supportsPointerEvents && (e.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1;
      }
    }, t.prototype.tickerUpdate = function(e) {
      this._deltaTime += e, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());
    }, t.prototype.update = function() {
      if (this.interactionDOMElement) {
        if (this._didMove) {
          this._didMove = !1;
          return;
        }
        this.cursor = null;
        for (var e in this.activeInteractionData)
          if (this.activeInteractionData.hasOwnProperty(e)) {
            var i = this.activeInteractionData[e];
            if (i.originalEvent && i.pointerType !== "touch") {
              var n = this.configureInteractionEventForDOMEvent(this.eventData, i.originalEvent, i);
              this.processInteractive(n, this.lastObjectRendered, this.processPointerOverOut, !0);
            }
          }
        this.setCursorMode(this.cursor);
      }
    }, t.prototype.setCursorMode = function(e) {
      e = e || "default";
      var i = !0;
      if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (i = !1), this.currentCursorMode !== e) {
        this.currentCursorMode = e;
        var n = this.cursorStyles[e];
        if (n)
          switch (typeof n) {
            case "string":
              i && (this.interactionDOMElement.style.cursor = n);
              break;
            case "function":
              n(e);
              break;
            case "object":
              i && Object.assign(this.interactionDOMElement.style, n);
              break;
          }
        else i && typeof e == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.interactionDOMElement.style.cursor = e);
      }
    }, t.prototype.dispatchEvent = function(e, i, n) {
      (!n.stopPropagationHint || e === n.stopsPropagatingAt) && (n.currentTarget = e, n.type = i, e.emit(i, n), e[i] && e[i](n));
    }, t.prototype.delayDispatchEvent = function(e, i, n) {
      this.delayedEvents.push({ displayObject: e, eventString: i, eventData: n });
    }, t.prototype.mapPositionToPoint = function(e, i, n) {
      var s;
      this.interactionDOMElement.parentElement ? s = this.interactionDOMElement.getBoundingClientRect() : s = {
        x: 0,
        y: 0,
        width: this.interactionDOMElement.width,
        height: this.interactionDOMElement.height,
        left: 0,
        top: 0
      };
      var o = 1 / this.resolution;
      e.x = (i - s.left) * (this.interactionDOMElement.width / s.width) * o, e.y = (n - s.top) * (this.interactionDOMElement.height / s.height) * o;
    }, t.prototype.processInteractive = function(e, i, n, s) {
      var o = this.search.findHit(e, i, n, s), a = this.delayedEvents;
      if (!a.length)
        return o;
      e.stopPropagationHint = !1;
      var h = a.length;
      this.delayedEvents = [];
      for (var l = 0; l < h; l++) {
        var u = a[l], c = u.displayObject, f = u.eventString, d = u.eventData;
        d.stopsPropagatingAt === c && (d.stopPropagationHint = !0), this.dispatchEvent(c, f, d);
      }
      return o;
    }, t.prototype.onPointerDown = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var i = this.normalizeToPointerData(e);
        if (this.autoPreventDefault && i[0].isNormalized) {
          var n = e.cancelable || !("cancelable" in e);
          n && e.preventDefault();
        }
        for (var s = i.length, o = 0; o < s; o++) {
          var a = i[o], h = this.getInteractionDataForPointerId(a), l = this.configureInteractionEventForDOMEvent(this.eventData, a, h);
          if (l.data.originalEvent = e, this.processInteractive(l, this.lastObjectRendered, this.processPointerDown, !0), this.emit("pointerdown", l), a.pointerType === "touch")
            this.emit("touchstart", l);
          else if (a.pointerType === "mouse" || a.pointerType === "pen") {
            var u = a.button === 2;
            this.emit(u ? "rightdown" : "mousedown", this.eventData);
          }
        }
      }
    }, t.prototype.processPointerDown = function(e, i, n) {
      var s = e.data, o = e.data.identifier;
      if (n) {
        if (i.trackedPointers[o] || (i.trackedPointers[o] = new cs(o)), this.dispatchEvent(i, "pointerdown", e), s.pointerType === "touch")
          this.dispatchEvent(i, "touchstart", e);
        else if (s.pointerType === "mouse" || s.pointerType === "pen") {
          var a = s.button === 2;
          a ? i.trackedPointers[o].rightDown = !0 : i.trackedPointers[o].leftDown = !0, this.dispatchEvent(i, a ? "rightdown" : "mousedown", e);
        }
      }
    }, t.prototype.onPointerComplete = function(e, i, n) {
      var s = this.normalizeToPointerData(e), o = s.length, a = e.target;
      e.composedPath && e.composedPath().length > 0 && (a = e.composedPath()[0]);
      for (var h = a !== this.interactionDOMElement ? "outside" : "", l = 0; l < o; l++) {
        var u = s[l], c = this.getInteractionDataForPointerId(u), f = this.configureInteractionEventForDOMEvent(this.eventData, u, c);
        if (f.data.originalEvent = e, this.processInteractive(f, this.lastObjectRendered, n, i || !h), this.emit(i ? "pointercancel" : "pointerup" + h, f), u.pointerType === "mouse" || u.pointerType === "pen") {
          var d = u.button === 2;
          this.emit(d ? "rightup" + h : "mouseup" + h, f);
        } else u.pointerType === "touch" && (this.emit(i ? "touchcancel" : "touchend" + h, f), this.releaseInteractionDataForPointerId(u.pointerId));
      }
    }, t.prototype.onPointerCancel = function(e) {
      this.supportsTouchEvents && e.pointerType === "touch" || this.onPointerComplete(e, !0, this.processPointerCancel);
    }, t.prototype.processPointerCancel = function(e, i) {
      var n = e.data, s = e.data.identifier;
      i.trackedPointers[s] !== void 0 && (delete i.trackedPointers[s], this.dispatchEvent(i, "pointercancel", e), n.pointerType === "touch" && this.dispatchEvent(i, "touchcancel", e));
    }, t.prototype.onPointerUp = function(e) {
      this.supportsTouchEvents && e.pointerType === "touch" || this.onPointerComplete(e, !1, this.processPointerUp);
    }, t.prototype.processPointerUp = function(e, i, n) {
      var s = e.data, o = e.data.identifier, a = i.trackedPointers[o], h = s.pointerType === "touch", l = s.pointerType === "mouse" || s.pointerType === "pen", u = !1;
      if (l) {
        var c = s.button === 2, f = cs.FLAGS, d = c ? f.RIGHT_DOWN : f.LEFT_DOWN, p = a !== void 0 && a.flags & d;
        n ? (this.dispatchEvent(i, c ? "rightup" : "mouseup", e), p && (this.dispatchEvent(i, c ? "rightclick" : "click", e), u = !0)) : p && this.dispatchEvent(i, c ? "rightupoutside" : "mouseupoutside", e), a && (c ? a.rightDown = !1 : a.leftDown = !1);
      }
      n ? (this.dispatchEvent(i, "pointerup", e), h && this.dispatchEvent(i, "touchend", e), a && ((!l || u) && this.dispatchEvent(i, "pointertap", e), h && (this.dispatchEvent(i, "tap", e), a.over = !1))) : a && (this.dispatchEvent(i, "pointerupoutside", e), h && this.dispatchEvent(i, "touchendoutside", e)), a && a.none && delete i.trackedPointers[o];
    }, t.prototype.onPointerMove = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var i = this.normalizeToPointerData(e);
        (i[0].pointerType === "mouse" || i[0].pointerType === "pen") && (this._didMove = !0, this.cursor = null);
        for (var n = i.length, s = 0; s < n; s++) {
          var o = i[s], a = this.getInteractionDataForPointerId(o), h = this.configureInteractionEventForDOMEvent(this.eventData, o, a);
          h.data.originalEvent = e, this.processInteractive(h, this.lastObjectRendered, this.processPointerMove, !0), this.emit("pointermove", h), o.pointerType === "touch" && this.emit("touchmove", h), (o.pointerType === "mouse" || o.pointerType === "pen") && this.emit("mousemove", h);
        }
        i[0].pointerType === "mouse" && this.setCursorMode(this.cursor);
      }
    }, t.prototype.processPointerMove = function(e, i, n) {
      var s = e.data, o = s.pointerType === "touch", a = s.pointerType === "mouse" || s.pointerType === "pen";
      a && this.processPointerOverOut(e, i, n), (!this.moveWhenInside || n) && (this.dispatchEvent(i, "pointermove", e), o && this.dispatchEvent(i, "touchmove", e), a && this.dispatchEvent(i, "mousemove", e));
    }, t.prototype.onPointerOut = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var i = this.normalizeToPointerData(e), n = i[0];
        n.pointerType === "mouse" && (this.mouseOverRenderer = !1, this.setCursorMode(null));
        var s = this.getInteractionDataForPointerId(n), o = this.configureInteractionEventForDOMEvent(this.eventData, n, s);
        o.data.originalEvent = n, this.processInteractive(o, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit("pointerout", o), n.pointerType === "mouse" || n.pointerType === "pen" ? this.emit("mouseout", o) : this.releaseInteractionDataForPointerId(s.identifier);
      }
    }, t.prototype.processPointerOverOut = function(e, i, n) {
      var s = e.data, o = e.data.identifier, a = s.pointerType === "mouse" || s.pointerType === "pen", h = i.trackedPointers[o];
      n && !h && (h = i.trackedPointers[o] = new cs(o)), h !== void 0 && (n && this.mouseOverRenderer ? (h.over || (h.over = !0, this.delayDispatchEvent(i, "pointerover", e), a && this.delayDispatchEvent(i, "mouseover", e)), a && this.cursor === null && (this.cursor = i.cursor)) : h.over && (h.over = !1, this.dispatchEvent(i, "pointerout", this.eventData), a && this.dispatchEvent(i, "mouseout", e), h.none && delete i.trackedPointers[o]));
    }, t.prototype.onPointerOver = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var i = this.normalizeToPointerData(e), n = i[0], s = this.getInteractionDataForPointerId(n), o = this.configureInteractionEventForDOMEvent(this.eventData, n, s);
        o.data.originalEvent = n, n.pointerType === "mouse" && (this.mouseOverRenderer = !0), this.emit("pointerover", o), (n.pointerType === "mouse" || n.pointerType === "pen") && this.emit("mouseover", o);
      }
    }, t.prototype.getInteractionDataForPointerId = function(e) {
      var i = e.pointerId, n;
      return i === Wr || e.pointerType === "mouse" ? n = this.mouse : this.activeInteractionData[i] ? n = this.activeInteractionData[i] : (n = this.interactionDataPool.pop() || new Aa(), n.identifier = i, this.activeInteractionData[i] = n), n.copyEvent(e), n;
    }, t.prototype.releaseInteractionDataForPointerId = function(e) {
      var i = this.activeInteractionData[e];
      i && (delete this.activeInteractionData[e], i.reset(), this.interactionDataPool.push(i));
    }, t.prototype.configureInteractionEventForDOMEvent = function(e, i, n) {
      return e.data = n, this.mapPositionToPoint(n.global, i.clientX, i.clientY), i.pointerType === "touch" && (i.globalX = n.global.x, i.globalY = n.global.y), n.originalEvent = i, e.reset(), e;
    }, t.prototype.normalizeToPointerData = function(e) {
      var i = [];
      if (this.supportsTouchEvents && e instanceof TouchEvent)
        for (var n = 0, s = e.changedTouches.length; n < s; n++) {
          var o = e.changedTouches[n];
          typeof o.button > "u" && (o.button = e.touches.length ? 1 : 0), typeof o.buttons > "u" && (o.buttons = e.touches.length ? 1 : 0), typeof o.isPrimary > "u" && (o.isPrimary = e.touches.length === 1 && e.type === "touchstart"), typeof o.width > "u" && (o.width = o.radiusX || 1), typeof o.height > "u" && (o.height = o.radiusY || 1), typeof o.tiltX > "u" && (o.tiltX = 0), typeof o.tiltY > "u" && (o.tiltY = 0), typeof o.pointerType > "u" && (o.pointerType = "touch"), typeof o.pointerId > "u" && (o.pointerId = o.identifier || 0), typeof o.pressure > "u" && (o.pressure = o.force || 0.5), typeof o.twist > "u" && (o.twist = 0), typeof o.tangentialPressure > "u" && (o.tangentialPressure = 0), typeof o.layerX > "u" && (o.layerX = o.offsetX = o.clientX), typeof o.layerY > "u" && (o.layerY = o.offsetY = o.clientY), o.isNormalized = !0, i.push(o);
        }
      else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {
        var a = e;
        typeof a.isPrimary > "u" && (a.isPrimary = !0), typeof a.width > "u" && (a.width = 1), typeof a.height > "u" && (a.height = 1), typeof a.tiltX > "u" && (a.tiltX = 0), typeof a.tiltY > "u" && (a.tiltY = 0), typeof a.pointerType > "u" && (a.pointerType = "mouse"), typeof a.pointerId > "u" && (a.pointerId = Wr), typeof a.pressure > "u" && (a.pressure = 0.5), typeof a.twist > "u" && (a.twist = 0), typeof a.tangentialPressure > "u" && (a.tangentialPressure = 0), a.isNormalized = !0, i.push(a);
      } else
        i.push(e);
      return i;
    }, t.prototype.destroy = function() {
      this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;
    }, t.extension = {
      name: "interaction",
      type: [
        St.RendererPlugin,
        St.CanvasRendererPlugin
      ]
    }, t;
  }(Pe)
);
/*!
 * @pixi/extract - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var gv = new dt(), bv = 4, xv = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t;
    }
    return r.prototype.image = function(t, e, i) {
      var n = new Image();
      return n.src = this.base64(t, e, i), n;
    }, r.prototype.base64 = function(t, e, i) {
      return this.canvas(t).toDataURL(e, i);
    }, r.prototype.canvas = function(t, e) {
      var i = this._rawPixels(t, e), n = i.pixels, s = i.width, o = i.height, a = i.flipY, h = new ma(s, o, 1), l = h.context.getImageData(0, 0, s, o);
      if (r.arrayPostDivide(n, l.data), h.context.putImageData(l, 0, 0), a) {
        var u = new ma(h.width, h.height, 1);
        u.context.scale(1, -1), u.context.drawImage(h.canvas, 0, -o), h.destroy(), h = u;
      }
      return h.canvas;
    }, r.prototype.pixels = function(t, e) {
      var i = this._rawPixels(t, e).pixels;
      return r.arrayPostDivide(i, i), i;
    }, r.prototype._rawPixels = function(t, e) {
      var i = this.renderer, n, s = !1, o, a = !1;
      if (t)
        if (t instanceof ce)
          o = t;
        else {
          var h = i.context.webGLVersion >= 2 ? i.multisample : Rt.NONE;
          if (o = this.renderer.generateTexture(t, { multisample: h }), h !== Rt.NONE) {
            var l = ce.create({
              width: o.width,
              height: o.height
            });
            i.framebuffer.bind(o.framebuffer), i.framebuffer.blit(l.framebuffer), i.framebuffer.bind(null), o.destroy(!0), o = l;
          }
          a = !0;
        }
      o ? (n = o.baseTexture.resolution, e = e ?? o.frame, s = !1, i.renderTexture.bind(o)) : (n = i.resolution, e || (e = gv, e.width = i.width, e.height = i.height), s = !0, i.renderTexture.bind(null));
      var u = Math.round(e.width * n), c = Math.round(e.height * n), f = new Uint8Array(bv * u * c), d = i.gl;
      return d.readPixels(Math.round(e.x * n), Math.round(e.y * n), u, c, d.RGBA, d.UNSIGNED_BYTE, f), a && o.destroy(!0), { pixels: f, width: u, height: c, flipY: s };
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r.arrayPostDivide = function(t, e) {
      for (var i = 0; i < t.length; i += 4) {
        var n = e[i + 3] = t[i + 3];
        n !== 0 ? (e[i] = Math.round(Math.min(t[i] * 255 / n, 255)), e[i + 1] = Math.round(Math.min(t[i + 1] * 255 / n, 255)), e[i + 2] = Math.round(Math.min(t[i + 2] * 255 / n, 255))) : (e[i] = t[i], e[i + 1] = t[i + 1], e[i + 2] = t[i + 2]);
      }
    }, r.extension = {
      name: "extract",
      type: St.RendererPlugin
    }, r;
  }()
);
/*!
 * @pixi/loaders - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var qr = (
  /** @class */
  function() {
    function r(t, e, i) {
      e === void 0 && (e = !1), this._fn = t, this._once = e, this._thisArg = i, this._next = this._prev = this._owner = null;
    }
    return r.prototype.detach = function() {
      return this._owner === null ? !1 : (this._owner.detach(this), !0);
    }, r;
  }()
);
function Da(r, t) {
  return r._head ? (r._tail._next = t, t._prev = r._tail, r._tail = t) : (r._head = t, r._tail = t), t._owner = r, t;
}
var Xe = (
  /** @class */
  function() {
    function r() {
      this._head = this._tail = void 0;
    }
    return r.prototype.handlers = function(t) {
      t === void 0 && (t = !1);
      var e = this._head;
      if (t)
        return !!e;
      for (var i = []; e; )
        i.push(e), e = e._next;
      return i;
    }, r.prototype.has = function(t) {
      if (!(t instanceof qr))
        throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
      return t._owner === this;
    }, r.prototype.dispatch = function() {
      for (var t = arguments, e = [], i = 0; i < arguments.length; i++)
        e[i] = t[i];
      var n = this._head;
      if (!n)
        return !1;
      for (; n; )
        n._once && this.detach(n), n._fn.apply(n._thisArg, e), n = n._next;
      return !0;
    }, r.prototype.add = function(t, e) {
      if (e === void 0 && (e = null), typeof t != "function")
        throw new Error("MiniSignal#add(): First arg must be a Function.");
      return Da(this, new qr(t, !1, e));
    }, r.prototype.once = function(t, e) {
      if (e === void 0 && (e = null), typeof t != "function")
        throw new Error("MiniSignal#once(): First arg must be a Function.");
      return Da(this, new qr(t, !0, e));
    }, r.prototype.detach = function(t) {
      if (!(t instanceof qr))
        throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
      return t._owner !== this ? this : (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, t._next === null && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null, this);
    }, r.prototype.detachAll = function() {
      var t = this._head;
      if (!t)
        return this;
      for (this._head = this._tail = null; t; )
        t._owner = null, t = t._next;
      return this;
    }, r;
  }()
);
function il(r, t) {
  t = t || {};
  for (var e = {
    // eslint-disable-next-line max-len
    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
    q: {
      name: "queryKey",
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      // eslint-disable-next-line max-len
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      // eslint-disable-next-line max-len
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  }, i = e.parser[t.strictMode ? "strict" : "loose"].exec(r), n = {}, s = 14; s--; )
    n[e.key[s]] = i[s] || "";
  return n[e.q.name] = {}, n[e.key[12]].replace(e.q.parser, function(o, a, h) {
    a && (n[e.q.name][a] = h);
  }), n;
}
var fs, Zr = null, wv = 0, La = 200, Tv = 204, Ev = 1223, Sv = 2;
function Fa() {
}
function Ba(r, t, e) {
  t && t.indexOf(".") === 0 && (t = t.substring(1)), t && (r[t] = e);
}
function ds(r) {
  return r.toString().replace("object ", "");
}
var ft = (
  /** @class */
  function() {
    function r(t, e, i) {
      if (this._dequeue = Fa, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof t != "string" || typeof e != "string")
        throw new Error("Both name and url are required for constructing a resource.");
      i = i || {}, this._flags = 0, this._setFlag(r.STATUS_FLAGS.DATA_URL, e.indexOf("data:") === 0), this.name = t, this.url = e, this.extension = this._getExtension(), this.data = null, this.crossOrigin = i.crossOrigin === !0 ? "anonymous" : i.crossOrigin, this.timeout = i.timeout || 0, this.loadType = i.loadType || this._determineLoadType(), this.xhrType = i.xhrType, this.metadata = i.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = r.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = Fa, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new Xe(), this.onProgress = new Xe(), this.onComplete = new Xe(), this.onAfterMiddleware = new Xe();
    }
    return r.setExtensionLoadType = function(t, e) {
      Ba(r._loadTypeMap, t, e);
    }, r.setExtensionXhrType = function(t, e) {
      Ba(r._xhrTypeMap, t, e);
    }, Object.defineProperty(r.prototype, "isDataUrl", {
      /**
       * When the resource starts to load.
       * @memberof PIXI.LoaderResource
       * @callback OnStartSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       */
      /**
       * When the resource reports loading progress.
       * @memberof PIXI.LoaderResource
       * @callback OnProgressSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       * @param {number} percentage - The progress of the load in the range [0, 1].
       */
      /**
       * When the resource finishes loading.
       * @memberof PIXI.LoaderResource
       * @callback OnCompleteSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       */
      /**
       * @memberof PIXI.LoaderResource
       * @typedef {object} IMetadata
       * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
       *      element to use for loading, instead of creating one.
       * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
       *      is useful if you want to pass in a `loadElement` that you already added load sources to.
       * @property {string|string[]} [mimeType] - The mime type to use for the source element
       *      of a video/audio elment. If the urls are an array, you can pass this as an array as well
       *      where each index is the mime type to use for the corresponding url index.
       */
      /**
       * Stores whether or not this url is a data url.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(r.STATUS_FLAGS.DATA_URL);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "isComplete", {
      /**
       * Describes if this resource has finished loading. Is true when the resource has completely
       * loaded.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(r.STATUS_FLAGS.COMPLETE);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "isLoading", {
      /**
       * Describes if this resource is currently loading. Is true when the resource starts loading,
       * and is false again when complete.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(r.STATUS_FLAGS.LOADING);
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.complete = function() {
      this._clearEvents(), this._finish();
    }, r.prototype.abort = function(t) {
      if (!this.error) {
        if (this.error = new Error(t), this._clearEvents(), this.xhr)
          this.xhr.abort();
        else if (this.xdr)
          this.xdr.abort();
        else if (this.data)
          if (this.data.src)
            this.data.src = r.EMPTY_GIF;
          else
            for (; this.data.firstChild; )
              this.data.removeChild(this.data.firstChild);
        this._finish();
      }
    }, r.prototype.load = function(t) {
      var e = this;
      if (!this.isLoading) {
        if (this.isComplete) {
          t && setTimeout(function() {
            return t(e);
          }, 1);
          return;
        } else t && this.onComplete.once(t);
        switch (this._setFlag(r.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), (this.crossOrigin === !1 || typeof this.crossOrigin != "string") && (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
          case r.LOAD_TYPE.IMAGE:
            this.type = r.TYPE.IMAGE, this._loadElement("image");
            break;
          case r.LOAD_TYPE.AUDIO:
            this.type = r.TYPE.AUDIO, this._loadSourceElement("audio");
            break;
          case r.LOAD_TYPE.VIDEO:
            this.type = r.TYPE.VIDEO, this._loadSourceElement("video");
            break;
          case r.LOAD_TYPE.XHR:
          /* falls through */
          default:
            typeof fs > "u" && (fs = !!(globalThis.XDomainRequest && !("withCredentials" in new XMLHttpRequest()))), fs && this.crossOrigin ? this._loadXdr() : this._loadXhr();
            break;
        }
      }
    }, r.prototype._hasFlag = function(t) {
      return (this._flags & t) !== 0;
    }, r.prototype._setFlag = function(t, e) {
      this._flags = e ? this._flags | t : this._flags & ~t;
    }, r.prototype._clearEvents = function() {
      clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));
    }, r.prototype._finish = function() {
      if (this.isComplete)
        throw new Error("Complete called again for an already completed resource.");
      this._setFlag(r.STATUS_FLAGS.COMPLETE, !0), this._setFlag(r.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this);
    }, r.prototype._loadElement = function(t) {
      this.metadata.loadElement ? this.data = this.metadata.loadElement : t === "image" && typeof globalThis.Image < "u" ? this.data = new Image() : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
    }, r.prototype._loadSourceElement = function(t) {
      if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t === "audio" && typeof globalThis.Audio < "u" ? this.data = new Audio() : this.data = document.createElement(t), this.data === null) {
        this.abort("Unsupported element: " + t);
        return;
      }
      if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)
        if (navigator.isCocoonJS)
          this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
        else if (Array.isArray(this.url))
          for (var e = this.metadata.mimeType, i = 0; i < this.url.length; ++i)
            this.data.appendChild(this._createSource(t, this.url[i], Array.isArray(e) ? e[i] : e));
        else {
          var e = this.metadata.mimeType;
          this.data.appendChild(this._createSource(t, this.url, Array.isArray(e) ? e[0] : e));
        }
      this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
    }, r.prototype._loadXhr = function() {
      typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
      var t = this.xhr = new XMLHttpRequest();
      this.crossOrigin === "use-credentials" && (t.withCredentials = !0), t.open("GET", this.url, !0), t.timeout = this.timeout, this.xhrType === r.XHR_RESPONSE_TYPE.JSON || this.xhrType === r.XHR_RESPONSE_TYPE.DOCUMENT ? t.responseType = r.XHR_RESPONSE_TYPE.TEXT : t.responseType = this.xhrType, t.addEventListener("error", this._boundXhrOnError, !1), t.addEventListener("timeout", this._boundXhrOnTimeout, !1), t.addEventListener("abort", this._boundXhrOnAbort, !1), t.addEventListener("progress", this._boundOnProgress, !1), t.addEventListener("load", this._boundXhrOnLoad, !1), t.send();
    }, r.prototype._loadXdr = function() {
      typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
      var t = this.xhr = new globalThis.XDomainRequest();
      t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open("GET", this.url, !0), setTimeout(function() {
        return t.send();
      }, 1);
    }, r.prototype._createSource = function(t, e, i) {
      i || (i = t + "/" + this._getExtension(e));
      var n = document.createElement("source");
      return n.src = e, n.type = i, n;
    }, r.prototype._onError = function(t) {
      this.abort("Failed to load element using: " + t.target.nodeName);
    }, r.prototype._onProgress = function(t) {
      t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total);
    }, r.prototype._onTimeout = function() {
      this.abort("Load timed out.");
    }, r.prototype._xhrOnError = function() {
      var t = this.xhr;
      this.abort(ds(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"');
    }, r.prototype._xhrOnTimeout = function() {
      var t = this.xhr;
      this.abort(ds(t) + " Request timed out.");
    }, r.prototype._xhrOnAbort = function() {
      var t = this.xhr;
      this.abort(ds(t) + " Request was aborted by the user.");
    }, r.prototype._xhrOnLoad = function() {
      var t = this.xhr, e = "", i = typeof t.status > "u" ? La : t.status;
      (t.responseType === "" || t.responseType === "text" || typeof t.responseType > "u") && (e = t.responseText), i === wv && (e.length > 0 || t.responseType === r.XHR_RESPONSE_TYPE.BUFFER) ? i = La : i === Ev && (i = Tv);
      var n = i / 100 | 0;
      if (n === Sv)
        if (this.xhrType === r.XHR_RESPONSE_TYPE.TEXT)
          this.data = e, this.type = r.TYPE.TEXT;
        else if (this.xhrType === r.XHR_RESPONSE_TYPE.JSON)
          try {
            this.data = JSON.parse(e), this.type = r.TYPE.JSON;
          } catch (a) {
            this.abort("Error trying to parse loaded json: " + a);
            return;
          }
        else if (this.xhrType === r.XHR_RESPONSE_TYPE.DOCUMENT)
          try {
            if (globalThis.DOMParser) {
              var s = new DOMParser();
              this.data = s.parseFromString(e, "text/xml");
            } else {
              var o = document.createElement("div");
              o.innerHTML = e, this.data = o;
            }
            this.type = r.TYPE.XML;
          } catch (a) {
            this.abort("Error trying to parse loaded xml: " + a);
            return;
          }
        else
          this.data = t.response || e;
      else {
        this.abort("[" + t.status + "] " + t.statusText + ": " + t.responseURL);
        return;
      }
      this.complete();
    }, r.prototype._determineCrossOrigin = function(t, e) {
      if (t.indexOf("data:") === 0)
        return "";
      if (globalThis.origin !== globalThis.location.origin)
        return "anonymous";
      e = e || globalThis.location, Zr || (Zr = document.createElement("a")), Zr.href = t;
      var i = il(Zr.href, { strictMode: !0 }), n = !i.port && e.port === "" || i.port === e.port, s = i.protocol ? i.protocol + ":" : "";
      return i.host !== e.hostname || !n || s !== e.protocol ? "anonymous" : "";
    }, r.prototype._determineXhrType = function() {
      return r._xhrTypeMap[this.extension] || r.XHR_RESPONSE_TYPE.TEXT;
    }, r.prototype._determineLoadType = function() {
      return r._loadTypeMap[this.extension] || r.LOAD_TYPE.XHR;
    }, r.prototype._getExtension = function(t) {
      t === void 0 && (t = this.url);
      var e = "";
      if (this.isDataUrl) {
        var i = t.indexOf("/");
        e = t.substring(i + 1, t.indexOf(";", i));
      } else {
        var n = t.indexOf("?"), s = t.indexOf("#"), o = Math.min(n > -1 ? n : t.length, s > -1 ? s : t.length);
        t = t.substring(0, o), e = t.substring(t.lastIndexOf(".") + 1);
      }
      return e.toLowerCase();
    }, r.prototype._getMimeFromXhrType = function(t) {
      switch (t) {
        case r.XHR_RESPONSE_TYPE.BUFFER:
          return "application/octet-binary";
        case r.XHR_RESPONSE_TYPE.BLOB:
          return "application/blob";
        case r.XHR_RESPONSE_TYPE.DOCUMENT:
          return "application/xml";
        case r.XHR_RESPONSE_TYPE.JSON:
          return "application/json";
        case r.XHR_RESPONSE_TYPE.DEFAULT:
        case r.XHR_RESPONSE_TYPE.TEXT:
        /* falls through */
        default:
          return "text/plain";
      }
    }, r;
  }()
);
(function(r) {
  (function(t) {
    t[t.NONE = 0] = "NONE", t[t.DATA_URL = 1] = "DATA_URL", t[t.COMPLETE = 2] = "COMPLETE", t[t.LOADING = 4] = "LOADING";
  })(r.STATUS_FLAGS || (r.STATUS_FLAGS = {})), function(t) {
    t[t.UNKNOWN = 0] = "UNKNOWN", t[t.JSON = 1] = "JSON", t[t.XML = 2] = "XML", t[t.IMAGE = 3] = "IMAGE", t[t.AUDIO = 4] = "AUDIO", t[t.VIDEO = 5] = "VIDEO", t[t.TEXT = 6] = "TEXT";
  }(r.TYPE || (r.TYPE = {})), function(t) {
    t[t.XHR = 1] = "XHR", t[t.IMAGE = 2] = "IMAGE", t[t.AUDIO = 3] = "AUDIO", t[t.VIDEO = 4] = "VIDEO";
  }(r.LOAD_TYPE || (r.LOAD_TYPE = {})), function(t) {
    t.DEFAULT = "text", t.BUFFER = "arraybuffer", t.BLOB = "blob", t.DOCUMENT = "document", t.JSON = "json", t.TEXT = "text";
  }(r.XHR_RESPONSE_TYPE || (r.XHR_RESPONSE_TYPE = {})), r._loadTypeMap = {
    // images
    gif: r.LOAD_TYPE.IMAGE,
    png: r.LOAD_TYPE.IMAGE,
    bmp: r.LOAD_TYPE.IMAGE,
    jpg: r.LOAD_TYPE.IMAGE,
    jpeg: r.LOAD_TYPE.IMAGE,
    tif: r.LOAD_TYPE.IMAGE,
    tiff: r.LOAD_TYPE.IMAGE,
    webp: r.LOAD_TYPE.IMAGE,
    tga: r.LOAD_TYPE.IMAGE,
    avif: r.LOAD_TYPE.IMAGE,
    svg: r.LOAD_TYPE.IMAGE,
    "svg+xml": r.LOAD_TYPE.IMAGE,
    // audio
    mp3: r.LOAD_TYPE.AUDIO,
    ogg: r.LOAD_TYPE.AUDIO,
    wav: r.LOAD_TYPE.AUDIO,
    // videos
    mp4: r.LOAD_TYPE.VIDEO,
    webm: r.LOAD_TYPE.VIDEO
  }, r._xhrTypeMap = {
    // xml
    xhtml: r.XHR_RESPONSE_TYPE.DOCUMENT,
    html: r.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: r.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: r.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: r.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: r.XHR_RESPONSE_TYPE.DOCUMENT,
    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
    // this should probably be fine.
    tsx: r.XHR_RESPONSE_TYPE.DOCUMENT,
    // images
    gif: r.XHR_RESPONSE_TYPE.BLOB,
    png: r.XHR_RESPONSE_TYPE.BLOB,
    bmp: r.XHR_RESPONSE_TYPE.BLOB,
    jpg: r.XHR_RESPONSE_TYPE.BLOB,
    jpeg: r.XHR_RESPONSE_TYPE.BLOB,
    tif: r.XHR_RESPONSE_TYPE.BLOB,
    tiff: r.XHR_RESPONSE_TYPE.BLOB,
    webp: r.XHR_RESPONSE_TYPE.BLOB,
    tga: r.XHR_RESPONSE_TYPE.BLOB,
    avif: r.XHR_RESPONSE_TYPE.BLOB,
    // json
    json: r.XHR_RESPONSE_TYPE.JSON,
    // text
    text: r.XHR_RESPONSE_TYPE.TEXT,
    txt: r.XHR_RESPONSE_TYPE.TEXT,
    // fonts
    ttf: r.XHR_RESPONSE_TYPE.BUFFER,
    otf: r.XHR_RESPONSE_TYPE.BUFFER
  }, r.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
})(ft || (ft = {}));
function di() {
}
function Pv(r) {
  return function() {
    for (var e = arguments, i = [], n = 0; n < arguments.length; n++)
      i[n] = e[n];
    if (r === null)
      throw new Error("Callback was already called.");
    var s = r;
    r = null, s.apply(this, i);
  };
}
var Cv = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t, e) {
      this.data = t, this.callback = e;
    }
    return r;
  }()
), ps = (
  /** @class */
  function() {
    function r(t, e) {
      var i = this;
      if (e === void 0 && (e = 1), this.workers = 0, this.saturated = di, this.unsaturated = di, this.empty = di, this.drain = di, this.error = di, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function(n, s, o) {
        if (o && typeof o != "function")
          throw new Error("task callback must be a function");
        if (i.started = !0, n == null && i.idle()) {
          setTimeout(function() {
            return i.drain();
          }, 1);
          return;
        }
        var a = new Cv(n, typeof o == "function" ? o : di);
        s ? i._tasks.unshift(a) : i._tasks.push(a), setTimeout(i.process, 1);
      }, this.process = function() {
        for (; !i.paused && i.workers < i.concurrency && i._tasks.length; ) {
          var n = i._tasks.shift();
          i._tasks.length === 0 && i.empty(), i.workers += 1, i.workers === i.concurrency && i.saturated(), i._worker(n.data, Pv(i._next(n)));
        }
      }, this._worker = t, e === 0)
        throw new Error("Concurrency must not be zero");
      this.concurrency = e, this.buffer = e / 4;
    }
    return r.prototype._next = function(t) {
      var e = this;
      return function() {
        for (var i = arguments, n = [], s = 0; s < arguments.length; s++)
          n[s] = i[s];
        e.workers -= 1, t.callback.apply(t, n), n[0] != null && e.error(n[0], t.data), e.workers <= e.concurrency - e.buffer && e.unsaturated(), e.idle() && e.drain(), e.process();
      };
    }, r.prototype.push = function(t, e) {
      this._insert(t, !1, e);
    }, r.prototype.kill = function() {
      this.workers = 0, this.drain = di, this.started = !1, this._tasks = [];
    }, r.prototype.unshift = function(t, e) {
      this._insert(t, !0, e);
    }, r.prototype.length = function() {
      return this._tasks.length;
    }, r.prototype.running = function() {
      return this.workers;
    }, r.prototype.idle = function() {
      return this._tasks.length + this.workers === 0;
    }, r.prototype.pause = function() {
      this.paused !== !0 && (this.paused = !0);
    }, r.prototype.resume = function() {
      if (this.paused !== !1) {
        this.paused = !1;
        for (var t = 1; t <= this.concurrency; t++)
          this.process();
      }
    }, r.eachSeries = function(t, e, i, n) {
      var s = 0, o = t.length;
      function a(h) {
        if (h || s === o) {
          i && i(h);
          return;
        }
        n ? setTimeout(function() {
          e(t[s++], a);
        }, 1) : e(t[s++], a);
      }
      a();
    }, r.queue = function(t, e) {
      return new r(t, e);
    }, r;
  }()
), vs = 100, Iv = /(#[\w-]+)?$/, ue = (
  /** @class */
  function() {
    function r(t, e) {
      var i = this;
      t === void 0 && (t = ""), e === void 0 && (e = 10), this.progress = 0, this.loading = !1, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(h, l) {
        return i._loadResource(h, l);
      }, this.resources = {}, this.baseUrl = t, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(h, l) {
        return i._loadResource(h, l);
      }, this._queue = ps.queue(this._boundLoadResource, e), this._queue.pause(), this.resources = {}, this.onProgress = new Xe(), this.onError = new Xe(), this.onLoad = new Xe(), this.onStart = new Xe(), this.onComplete = new Xe();
      for (var n = 0; n < r._plugins.length; ++n) {
        var s = r._plugins[n], o = s.pre, a = s.use;
        o && this.pre(o), a && this.use(a);
      }
      this._protected = !1;
    }
    return r.prototype._add = function(t, e, i, n) {
      if (this.loading && (!i || !i.parentResource))
        throw new Error("Cannot add resources while the loader is running.");
      if (this.resources[t])
        throw new Error('Resource named "' + t + '" already exists.');
      if (e = this._prepareUrl(e), this.resources[t] = new ft(t, e, i), typeof n == "function" && this.resources[t].onAfterMiddleware.once(n), this.loading) {
        for (var s = i.parentResource, o = [], a = 0; a < s.children.length; ++a)
          s.children[a].isComplete || o.push(s.children[a]);
        var h = s.progressChunk * (o.length + 1), l = h / (o.length + 2);
        s.children.push(this.resources[t]), s.progressChunk = l;
        for (var a = 0; a < o.length; ++a)
          o[a].progressChunk = l;
        this.resources[t].progressChunk = l;
      }
      return this._queue.push(this.resources[t]), this;
    }, r.prototype.pre = function(t) {
      return this._beforeMiddleware.push(t), this;
    }, r.prototype.use = function(t) {
      return this._afterMiddleware.push(t), this;
    }, r.prototype.reset = function() {
      this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause();
      for (var t in this.resources) {
        var e = this.resources[t];
        e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort("loader reset");
      }
      return this.resources = {}, this;
    }, r.prototype.load = function(t) {
      if (Te("6.5.0", "@pixi/loaders is being replaced with @pixi/assets in the next major release."), typeof t == "function" && this.onComplete.once(t), this.loading)
        return this;
      if (this._queue.idle())
        this._onStart(), this._onComplete();
      else {
        for (var e = this._queue._tasks.length, i = vs / e, n = 0; n < this._queue._tasks.length; ++n)
          this._queue._tasks[n].data.progressChunk = i;
        this._onStart(), this._queue.resume();
      }
      return this;
    }, Object.defineProperty(r.prototype, "concurrency", {
      /**
       * The number of resources to load concurrently.
       * @default 10
       */
      get: function() {
        return this._queue.concurrency;
      },
      set: function(t) {
        this._queue.concurrency = t;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype._prepareUrl = function(t) {
      var e = il(t, { strictMode: !0 }), i;
      if (e.protocol || !e.path || t.indexOf("//") === 0 ? i = t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && t.charAt(0) !== "/" ? i = this.baseUrl + "/" + t : i = this.baseUrl + t, this.defaultQueryString) {
        var n = Iv.exec(i)[0];
        i = i.slice(0, i.length - n.length), i.indexOf("?") !== -1 ? i += "&" + this.defaultQueryString : i += "?" + this.defaultQueryString, i += n;
      }
      return i;
    }, r.prototype._loadResource = function(t, e) {
      var i = this;
      t._dequeue = e, ps.eachSeries(this._beforeMiddleware, function(n, s) {
        n.call(i, t, function() {
          s(t.isComplete ? {} : null);
        });
      }, function() {
        t.isComplete ? i._onLoad(t) : (t._onLoadBinding = t.onComplete.once(i._onLoad, i), t.load());
      }, !0);
    }, r.prototype._onStart = function() {
      this.progress = 0, this.loading = !0, this.onStart.dispatch(this);
    }, r.prototype._onComplete = function() {
      this.progress = vs, this.loading = !1, this.onComplete.dispatch(this, this.resources);
    }, r.prototype._onLoad = function(t) {
      var e = this;
      t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), ps.eachSeries(this._afterMiddleware, function(i, n) {
        i.call(e, t, n);
      }, function() {
        t.onAfterMiddleware.dispatch(t), e.progress = Math.min(vs, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && e._resourcesParsing.length === 0 && e._onComplete();
      }, !0);
    }, r.prototype.destroy = function() {
      this._protected || this.reset();
    }, Object.defineProperty(r, "shared", {
      /** A premade instance of the loader that can be used to load resources. */
      get: function() {
        var t = r._shared;
        return t || (t = new r(), t._protected = !0, r._shared = t), t;
      },
      enumerable: !1,
      configurable: !0
    }), r.registerPlugin = function(t) {
      return Te("6.5.0", "Loader.registerPlugin() is deprecated, use extensions.add() instead."), Ue.add({
        type: St.Loader,
        ref: t
      }), r;
    }, r._plugins = [], r;
  }()
);
Ue.handleByList(St.Loader, ue._plugins);
ue.prototype.add = function(t, e, i, n) {
  if (Array.isArray(t)) {
    for (var s = 0; s < t.length; ++s)
      this.add(t[s]);
    return this;
  }
  if (typeof t == "object" && (i = t, n = e || i.callback || i.onComplete, e = i.url, t = i.name || i.key || i.url), typeof e != "string" && (n = i, i = e, e = t), typeof e != "string")
    throw new Error("No url passed to add resource to loader.");
  return typeof i == "function" && (n = i, i = null), this._add(t, e, i, n);
};
var Ov = (
  /** @class */
  function() {
    function r() {
    }
    return r.init = function(t) {
      t = Object.assign({
        sharedLoader: !1
      }, t), this.loader = t.sharedLoader ? ue.shared : new ue();
    }, r.destroy = function() {
      this.loader && (this.loader.destroy(), this.loader = null);
    }, r.extension = St.Application, r;
  }()
), Mv = (
  /** @class */
  function() {
    function r() {
    }
    return r.add = function() {
      ft.setExtensionLoadType("svg", ft.LOAD_TYPE.XHR), ft.setExtensionXhrType("svg", ft.XHR_RESPONSE_TYPE.TEXT);
    }, r.use = function(t, e) {
      if (t.data && (t.type === ft.TYPE.IMAGE || t.extension === "svg")) {
        var i = t.data, n = t.url, s = t.name, o = t.metadata;
        ot.fromLoader(i, n, s, o).then(function(a) {
          t.texture = a, e();
        }).catch(e);
      } else
        e();
    }, r.extension = St.Loader, r;
  }()
), Rv = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function kv(r) {
  for (var t = "", e = 0; e < r.length; ) {
    for (var i = [0, 0, 0], n = [0, 0, 0, 0], s = 0; s < i.length; ++s)
      e < r.length ? i[s] = r.charCodeAt(e++) & 255 : i[s] = 0;
    n[0] = i[0] >> 2, n[1] = (i[0] & 3) << 4 | i[1] >> 4, n[2] = (i[1] & 15) << 2 | i[2] >> 6, n[3] = i[2] & 63;
    var o = e - (r.length - 1);
    switch (o) {
      case 2:
        n[3] = 64, n[2] = 64;
        break;
      case 1:
        n[3] = 64;
        break;
    }
    for (var s = 0; s < n.length; ++s)
      t += Rv.charAt(n[s]);
  }
  return t;
}
function Nv(r, t) {
  if (!r.data) {
    t();
    return;
  }
  if (r.xhr && r.xhrType === ft.XHR_RESPONSE_TYPE.BLOB) {
    if (!self.Blob || typeof r.data == "string") {
      var e = r.xhr.getResponseHeader("content-type");
      if (e && e.indexOf("image") === 0) {
        r.data = new Image(), r.data.src = "data:" + e + ";base64," + kv(r.xhr.responseText), r.type = ft.TYPE.IMAGE, r.data.onload = function() {
          r.data.onload = null, t();
        };
        return;
      }
    } else if (r.data.type.indexOf("image") === 0) {
      var i = globalThis.URL || globalThis.webkitURL, n = i.createObjectURL(r.data);
      r.blob = r.data, r.data = new Image(), r.data.src = n, r.type = ft.TYPE.IMAGE, r.data.onload = function() {
        i.revokeObjectURL(n), r.data.onload = null, t();
      };
      return;
    }
  }
  t();
}
var Av = (
  /** @class */
  function() {
    function r() {
    }
    return r.extension = St.Loader, r.use = Nv, r;
  }()
);
Ue.add(Mv, Av);
/*!
 * @pixi/compressed-textures - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/compressed-textures is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Et, vt;
(function(r) {
  r[r.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", r[r.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", r[r.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", r[r.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", r[r.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", r[r.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", r[r.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", r[r.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", r[r.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", r[r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", r[r.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", r[r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", r[r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", r[r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", r[r.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", r[r.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", r[r.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", r[r.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", r[r.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
})(vt || (vt = {}));
var Mn = (Et = {}, // WEBGL_compressed_texture_s3tc
Et[vt.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, Et[vt.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, Et[vt.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, Et[vt.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_s3tc
Et[vt.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, Et[vt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, Et[vt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, Et[vt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_etc
Et[vt.COMPRESSED_R11_EAC] = 0.5, Et[vt.COMPRESSED_SIGNED_R11_EAC] = 0.5, Et[vt.COMPRESSED_RG11_EAC] = 1, Et[vt.COMPRESSED_SIGNED_RG11_EAC] = 1, Et[vt.COMPRESSED_RGB8_ETC2] = 0.5, Et[vt.COMPRESSED_RGBA8_ETC2_EAC] = 1, Et[vt.COMPRESSED_SRGB8_ETC2] = 0.5, Et[vt.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, Et[vt.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, Et[vt.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, // WEBGL_compressed_texture_pvrtc
Et[vt.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, Et[vt.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, Et[vt.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, Et[vt.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, // WEBGL_compressed_texture_etc1
Et[vt.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, // @see https://www.khronos.org/registry/OpenGL/extensions/AMD/AMD_compressed_ATC_texture.txt
// WEBGL_compressed_texture_atc
Et[vt.COMPRESSED_RGB_ATC_WEBGL] = 0.5, Et[vt.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, Et[vt.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, // @see https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt
// WEBGL_compressed_texture_astc
/* eslint-disable-next-line camelcase */
Et[vt.COMPRESSED_RGBA_ASTC_4x4_KHR] = 1, Et);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var $s = function(r, t) {
  return $s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, $s(r, t);
};
function rl(r, t) {
  $s(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function Dv(r, t, e, i) {
  function n(s) {
    return s instanceof e ? s : new e(function(o) {
      o(s);
    });
  }
  return new (e || (e = Promise))(function(s, o) {
    function a(u) {
      try {
        l(i.next(u));
      } catch (c) {
        o(c);
      }
    }
    function h(u) {
      try {
        l(i.throw(u));
      } catch (c) {
        o(c);
      }
    }
    function l(u) {
      u.done ? s(u.value) : n(u.value).then(a, h);
    }
    l((i = i.apply(r, [])).next());
  });
}
function Lv(r, t) {
  var e = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, i, n, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(l) {
    return function(u) {
      return h([l, u]);
    };
  }
  function h(l) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, n && (s = l[0] & 2 ? n.return : l[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) && !(s = s.call(n, l[1])).done)
          return s;
        switch (n = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
          case 0:
          case 1:
            s = l;
            break;
          case 4:
            return e.label++, { value: l[1], done: !1 };
          case 5:
            e.label++, n = l[1], l = [0];
            continue;
          case 7:
            l = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (s = e.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              e = 0;
              continue;
            }
            if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
              e.label = l[1];
              break;
            }
            if (l[0] === 6 && e.label < s[1]) {
              e.label = s[1], s = l;
              break;
            }
            if (s && e.label < s[2]) {
              e.label = s[2], e.ops.push(l);
              break;
            }
            s[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        l = t.call(r, e);
      } catch (u) {
        l = [6, u], n = 0;
      } finally {
        i = s = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
var Fv = (
  /** @class */
  function(r) {
    rl(t, r);
    function t(e, i) {
      i === void 0 && (i = { width: 1, height: 1, autoLoad: !0 });
      var n = this, s, o;
      return typeof e == "string" ? (s = e, o = new Uint8Array()) : (s = null, o = e), n = r.call(this, o, i) || this, n.origin = s, n.buffer = o ? new js(o) : null, n.origin && i.autoLoad !== !1 && n.load(), o && o.length && (n.loaded = !0, n.onBlobLoaded(n.buffer.rawBinaryData)), n;
    }
    return t.prototype.onBlobLoaded = function(e) {
    }, t.prototype.load = function() {
      return Dv(this, void 0, Promise, function() {
        var e, i, n;
        return Lv(this, function(s) {
          switch (s.label) {
            case 0:
              return [4, fetch(this.origin)];
            case 1:
              return e = s.sent(), [4, e.blob()];
            case 2:
              return i = s.sent(), [4, i.arrayBuffer()];
            case 3:
              return n = s.sent(), this.data = new Uint32Array(n), this.buffer = new js(n), this.loaded = !0, this.onBlobLoaded(n), this.update(), [2, this];
          }
        });
      });
    }, t;
  }(Mr)
), zs = (
  /** @class */
  function(r) {
    rl(t, r);
    function t(e, i) {
      var n = r.call(this, e, i) || this;
      return n.format = i.format, n.levels = i.levels || 1, n._width = i.width, n._height = i.height, n._extension = t._formatToExtension(n.format), (i.levelBuffers || n.buffer) && (n._levelBuffers = i.levelBuffers || t._createLevelBuffers(
        e instanceof Uint8Array ? e : n.buffer.uint8View,
        n.format,
        n.levels,
        4,
        4,
        // PVRTC has 8x4 blocks in 2bpp mode
        n.width,
        n.height
      )), n;
    }
    return t.prototype.upload = function(e, i, n) {
      var s = e.gl, o = e.context.extensions[this._extension];
      if (!o)
        throw new Error(this._extension + " textures are not supported on the current machine");
      if (!this._levelBuffers)
        return !1;
      for (var a = 0, h = this.levels; a < h; a++) {
        var l = this._levelBuffers[a], u = l.levelID, c = l.levelWidth, f = l.levelHeight, d = l.levelBuffer;
        s.compressedTexImage2D(s.TEXTURE_2D, u, this.format, c, f, 0, d);
      }
      return !0;
    }, t.prototype.onBlobLoaded = function() {
      this._levelBuffers = t._createLevelBuffers(
        this.buffer.uint8View,
        this.format,
        this.levels,
        4,
        4,
        // PVRTC has 8x4 blocks in 2bpp mode
        this.width,
        this.height
      );
    }, t._formatToExtension = function(e) {
      if (e >= 33776 && e <= 33779)
        return "s3tc";
      if (e >= 37488 && e <= 37497)
        return "etc";
      if (e >= 35840 && e <= 35843)
        return "pvrtc";
      if (e >= 36196)
        return "etc1";
      if (e >= 35986 && e <= 34798)
        return "atc";
      throw new Error("Invalid (compressed) texture format given!");
    }, t._createLevelBuffers = function(e, i, n, s, o, a, h) {
      for (var l = new Array(n), u = e.byteOffset, c = a, f = h, d = c + s - 1 & ~(s - 1), p = f + o - 1 & ~(o - 1), v = d * p * Mn[i], _ = 0; _ < n; _++)
        l[_] = {
          levelID: _,
          levelWidth: n > 1 ? c : d,
          levelHeight: n > 1 ? f : p,
          levelBuffer: new Uint8Array(e.buffer, u, v)
        }, u += v, c = c >> 1 || 1, f = f >> 1 || 1, d = c + s - 1 & ~(s - 1), p = f + o - 1 & ~(o - 1), v = d * p * Mn[i];
      return l;
    }, t;
  }(Fv)
), Bv = (
  /** @class */
  function() {
    function r() {
    }
    return r.use = function(t, e) {
      var i = t.data, n = this;
      if (t.type === ft.TYPE.JSON && i && i.cacheID && i.textures) {
        for (var s = i.textures, o = void 0, a = void 0, h = 0, l = s.length; h < l; h++) {
          var u = s[h], c = u.src, f = u.format;
          if (f || (a = c), r.textureFormats[f]) {
            o = c;
            break;
          }
        }
        if (o = o || a, !o) {
          e(new Error("Cannot load compressed-textures in " + t.url + ", make sure you provide a fallback"));
          return;
        }
        if (o === t.url) {
          e(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
          return;
        }
        var d = {
          crossOrigin: t.crossOrigin,
          metadata: t.metadata.imageMetadata,
          parentResource: t
        }, p = Ni.resolve(t.url.replace(n.baseUrl, ""), o), v = i.cacheID;
        n.add(v, p, d, function(_) {
          if (_.error) {
            e(_.error);
            return;
          }
          var m = _.texture, y = m === void 0 ? null : m, b = _.textures, P = b === void 0 ? {} : b;
          Object.assign(t, { texture: y, textures: P }), e();
        });
      } else
        e();
    }, Object.defineProperty(r, "textureExtensions", {
      /**  Map of available texture extensions. */
      get: function() {
        if (!r._textureExtensions) {
          var t = K.ADAPTER.createCanvas(), e = t.getContext("webgl");
          if (!e)
            return console.warn("WebGL not available for compressed textures. Silently failing."), {};
          var i = {
            s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: e.getExtension("WEBGL_compressed_texture_etc"),
            etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: e.getExtension("WEBGL_compressed_texture_atc"),
            astc: e.getExtension("WEBGL_compressed_texture_astc")
          };
          r._textureExtensions = i;
        }
        return r._textureExtensions;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "textureFormats", {
      /** Map of available texture formats. */
      get: function() {
        if (!r._textureFormats) {
          var t = r.textureExtensions;
          r._textureFormats = {};
          for (var e in t) {
            var i = t[e];
            i && Object.assign(r._textureFormats, Object.getPrototypeOf(i));
          }
        }
        return r._textureFormats;
      },
      enumerable: !1,
      configurable: !0
    }), r.extension = St.Loader, r;
  }()
);
function nl(r, t, e) {
  var i = {
    textures: {},
    texture: null
  };
  if (!t)
    return i;
  var n = t.map(function(s) {
    return new ot(new gt(s, Object.assign({
      mipmap: Ee.OFF,
      alphaMode: Se.NO_PREMULTIPLIED_ALPHA
    }, e)));
  });
  return n.forEach(function(s, o) {
    var a = s.baseTexture, h = r + "-" + (o + 1);
    gt.addToCache(a, h), ot.addToCache(s, h), o === 0 && (gt.addToCache(a, r), ot.addToCache(s, r), i.texture = s), i.textures[h] = s;
  }), i;
}
var Ji, _e, _s = 4, Kr = 124, Uv = 32, Ua = 20, Gv = 542327876, Jr = {
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
}, jv = {
  FOURCC: 2
}, Qr = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3
}, ye;
(function(r) {
  r[r.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", r[r.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", r[r.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", r[r.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", r[r.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", r[r.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", r[r.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", r[r.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", r[r.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", r[r.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", r[r.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", r[r.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", r[r.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", r[r.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", r[r.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", r[r.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", r[r.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", r[r.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", r[r.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", r[r.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", r[r.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", r[r.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", r[r.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", r[r.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", r[r.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", r[r.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", r[r.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", r[r.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", r[r.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", r[r.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", r[r.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", r[r.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", r[r.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", r[r.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", r[r.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", r[r.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", r[r.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", r[r.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", r[r.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", r[r.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", r[r.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", r[r.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", r[r.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", r[r.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", r[r.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", r[r.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", r[r.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", r[r.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", r[r.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", r[r.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", r[r.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", r[r.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", r[r.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", r[r.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", r[r.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", r[r.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", r[r.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", r[r.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", r[r.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", r[r.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", r[r.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", r[r.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", r[r.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", r[r.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", r[r.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", r[r.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", r[r.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", r[r.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", r[r.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", r[r.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", r[r.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", r[r.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", r[r.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", r[r.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", r[r.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", r[r.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", r[r.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", r[r.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", r[r.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", r[r.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", r[r.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", r[r.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", r[r.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", r[r.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", r[r.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", r[r.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", r[r.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", r[r.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", r[r.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", r[r.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", r[r.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", r[r.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", r[r.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", r[r.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", r[r.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", r[r.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", r[r.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", r[r.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", r[r.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", r[r.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", r[r.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV", r[r.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410", r[r.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416", r[r.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12", r[r.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010", r[r.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016", r[r.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE", r[r.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2", r[r.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210", r[r.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216", r[r.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11", r[r.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44", r[r.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44", r[r.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8", r[r.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8", r[r.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", r[r.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208", r[r.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208", r[r.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408", r[r.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", r[r.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", r[r.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT";
})(ye || (ye = {}));
var Xs;
(function(r) {
  r[r.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", r[r.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", r[r.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D";
})(Xs || (Xs = {}));
var Hv = 1, $v = 2, zv = 4, Xv = 64, Vv = 512, Wv = 131072, Yv = 827611204, qv = 861165636, Zv = 894720068, Kv = 808540228, Jv = 4, Qv = (Ji = {}, Ji[Yv] = vt.COMPRESSED_RGBA_S3TC_DXT1_EXT, Ji[qv] = vt.COMPRESSED_RGBA_S3TC_DXT3_EXT, Ji[Zv] = vt.COMPRESSED_RGBA_S3TC_DXT5_EXT, Ji), t_ = (_e = {}, // WEBGL_compressed_texture_s3tc
_e[ye.DXGI_FORMAT_BC1_TYPELESS] = vt.COMPRESSED_RGBA_S3TC_DXT1_EXT, _e[ye.DXGI_FORMAT_BC1_UNORM] = vt.COMPRESSED_RGBA_S3TC_DXT1_EXT, _e[ye.DXGI_FORMAT_BC2_TYPELESS] = vt.COMPRESSED_RGBA_S3TC_DXT3_EXT, _e[ye.DXGI_FORMAT_BC2_UNORM] = vt.COMPRESSED_RGBA_S3TC_DXT3_EXT, _e[ye.DXGI_FORMAT_BC3_TYPELESS] = vt.COMPRESSED_RGBA_S3TC_DXT5_EXT, _e[ye.DXGI_FORMAT_BC3_UNORM] = vt.COMPRESSED_RGBA_S3TC_DXT5_EXT, // WEBGL_compressed_texture_s3tc_srgb
_e[ye.DXGI_FORMAT_BC1_UNORM_SRGB] = vt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _e[ye.DXGI_FORMAT_BC2_UNORM_SRGB] = vt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _e[ye.DXGI_FORMAT_BC3_UNORM_SRGB] = vt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _e);
function e_(r) {
  var t = new Uint32Array(r), e = t[0];
  if (e !== Gv)
    throw new Error("Invalid DDS file magic word");
  var i = new Uint32Array(r, 0, Kr / Uint32Array.BYTES_PER_ELEMENT), n = i[Jr.HEIGHT], s = i[Jr.WIDTH], o = i[Jr.MIPMAP_COUNT], a = new Uint32Array(r, Jr.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, Uv / Uint32Array.BYTES_PER_ELEMENT), h = a[Hv];
  if (h & zv) {
    var l = a[jv.FOURCC];
    if (l !== Kv) {
      var u = Qv[l], c = _s + Kr, f = new Uint8Array(r, c), d = new zs(f, {
        format: u,
        width: s,
        height: n,
        levels: o
        // CompressedTextureResource will separate the levelBuffers for us!
      });
      return [d];
    }
    var p = _s + Kr, v = new Uint32Array(t.buffer, p, Ua / Uint32Array.BYTES_PER_ELEMENT), _ = v[Qr.DXGI_FORMAT], m = v[Qr.RESOURCE_DIMENSION], y = v[Qr.MISC_FLAG], b = v[Qr.ARRAY_SIZE], P = t_[_];
    if (P === void 0)
      throw new Error("DDSParser cannot parse texture data with DXGI format " + _);
    if (y === Jv)
      throw new Error("DDSParser does not support cubemap textures");
    if (m === Xs.DDS_DIMENSION_TEXTURE3D)
      throw new Error("DDSParser does not supported 3D texture data");
    var x = new Array(), T = _s + Kr + Ua;
    if (b === 1)
      x.push(new Uint8Array(r, T));
    else {
      for (var I = Mn[P], w = 0, O = s, R = n, U = 0; U < o; U++) {
        var q = Math.max(1, O + 3 & -4), tt = Math.max(1, R + 3 & -4), ct = q * tt * I;
        w += ct, O = O >>> 1, R = R >>> 1;
      }
      for (var Y = T, U = 0; U < b; U++)
        x.push(new Uint8Array(r, Y, w)), Y += w;
    }
    return x.map(function(g) {
      return new zs(g, {
        format: P,
        width: s,
        height: n,
        levels: o
      });
    });
  }
  throw h & Xv ? new Error("DDSParser does not support uncompressed texture data.") : h & Vv ? new Error("DDSParser does not supported YUV uncompressed texture data.") : h & Wv ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : h & $v ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
var ii, $e, Qi, Ga = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], i_ = 67305985, me = {
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
}, Vs = 64, ja = (ii = {}, ii[st.UNSIGNED_BYTE] = 1, ii[st.UNSIGNED_SHORT] = 2, ii[st.INT] = 4, ii[st.UNSIGNED_INT] = 4, ii[st.FLOAT] = 4, ii[st.HALF_FLOAT] = 8, ii), r_ = ($e = {}, $e[z.RGBA] = 4, $e[z.RGB] = 3, $e[z.RG] = 2, $e[z.RED] = 1, $e[z.LUMINANCE] = 1, $e[z.LUMINANCE_ALPHA] = 2, $e[z.ALPHA] = 1, $e), n_ = (Qi = {}, Qi[st.UNSIGNED_SHORT_4_4_4_4] = 2, Qi[st.UNSIGNED_SHORT_5_5_5_1] = 2, Qi[st.UNSIGNED_SHORT_5_6_5] = 2, Qi);
function s_(r, t, e) {
  e === void 0 && (e = !1);
  var i = new DataView(t);
  if (!o_(r, i))
    return null;
  var n = i.getUint32(me.ENDIANNESS, !0) === i_, s = i.getUint32(me.GL_TYPE, n), o = i.getUint32(me.GL_FORMAT, n), a = i.getUint32(me.GL_INTERNAL_FORMAT, n), h = i.getUint32(me.PIXEL_WIDTH, n), l = i.getUint32(me.PIXEL_HEIGHT, n) || 1, u = i.getUint32(me.PIXEL_DEPTH, n) || 1, c = i.getUint32(me.NUMBER_OF_ARRAY_ELEMENTS, n) || 1, f = i.getUint32(me.NUMBER_OF_FACES, n), d = i.getUint32(me.NUMBER_OF_MIPMAP_LEVELS, n), p = i.getUint32(me.BYTES_OF_KEY_VALUE_DATA, n);
  if (l === 0 || u !== 1)
    throw new Error("Only 2D textures are supported");
  if (f !== 1)
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  if (c !== 1)
    throw new Error("WebGL does not support array textures");
  var v = 4, _ = 4, m = h + 3 & -4, y = l + 3 & -4, b = new Array(c), P = h * l;
  s === 0 && (P = m * y);
  var x;
  if (s !== 0 ? ja[s] ? x = ja[s] * r_[o] : x = n_[s] : x = Mn[a], x === void 0)
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  for (var T = e ? h_(i, p, n) : null, I = P * x, w = I, O = h, R = l, U = m, q = y, tt = Vs + p, ct = 0; ct < d; ct++) {
    for (var Y = i.getUint32(tt, n), g = tt + 4, S = 0; S < c; S++) {
      var E = b[S];
      E || (E = b[S] = new Array(d)), E[ct] = {
        levelID: ct,
        // don't align mipWidth when texture not compressed! (glType not zero)
        levelWidth: d > 1 || s !== 0 ? O : U,
        levelHeight: d > 1 || s !== 0 ? R : q,
        levelBuffer: new Uint8Array(t, g, w)
      }, g += w;
    }
    tt += Y + 4, tt = tt % 4 !== 0 ? tt + 4 - tt % 4 : tt, O = O >> 1 || 1, R = R >> 1 || 1, U = O + v - 1 & -4, q = R + _ - 1 & -4, w = U * q * x;
  }
  return s !== 0 ? {
    uncompressed: b.map(function(M) {
      var N = M[0].levelBuffer, k = !1;
      return s === st.FLOAT ? N = new Float32Array(M[0].levelBuffer.buffer, M[0].levelBuffer.byteOffset, M[0].levelBuffer.byteLength / 4) : s === st.UNSIGNED_INT ? (k = !0, N = new Uint32Array(M[0].levelBuffer.buffer, M[0].levelBuffer.byteOffset, M[0].levelBuffer.byteLength / 4)) : s === st.INT && (k = !0, N = new Int32Array(M[0].levelBuffer.buffer, M[0].levelBuffer.byteOffset, M[0].levelBuffer.byteLength / 4)), {
        resource: new Mr(N, {
          width: M[0].levelWidth,
          height: M[0].levelHeight
        }),
        type: s,
        format: k ? a_(o) : o
      };
    }),
    kvData: T
  } : {
    compressed: b.map(function(M) {
      return new zs(null, {
        format: a,
        width: h,
        height: l,
        levels: d,
        levelBuffers: M
      });
    }),
    kvData: T
  };
}
function o_(r, t) {
  for (var e = 0; e < Ga.length; e++)
    if (t.getUint8(e) !== Ga[e])
      return console.error(r + " is not a valid *.ktx file!"), !1;
  return !0;
}
function a_(r) {
  switch (r) {
    case z.RGBA:
      return z.RGBA_INTEGER;
    case z.RGB:
      return z.RGB_INTEGER;
    case z.RG:
      return z.RG_INTEGER;
    case z.RED:
      return z.RED_INTEGER;
    default:
      return r;
  }
}
function h_(r, t, e) {
  for (var i = /* @__PURE__ */ new Map(), n = 0; n < t; ) {
    var s = r.getUint32(Vs + n, e), o = Vs + n + 4, a = 3 - (s + 3) % 4;
    if (s === 0 || s > t - n) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    for (var h = 0; h < s && r.getUint8(o + h) !== 0; h++)
      ;
    if (h === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    var l = new TextDecoder().decode(new Uint8Array(r.buffer, o, h)), u = new DataView(r.buffer, o + h + 1, s - h - 1);
    i.set(l, u), n += 4 + s + a;
  }
  return i;
}
ft.setExtensionXhrType("dds", ft.XHR_RESPONSE_TYPE.BUFFER);
var l_ = (
  /** @class */
  function() {
    function r() {
    }
    return r.use = function(t, e) {
      if (t.extension === "dds" && t.data)
        try {
          Object.assign(t, nl(t.name || t.url, e_(t.data), t.metadata));
        } catch (i) {
          e(i);
          return;
        }
      e();
    }, r.extension = St.Loader, r;
  }()
);
ft.setExtensionXhrType("ktx", ft.XHR_RESPONSE_TYPE.BUFFER);
var u_ = (
  /** @class */
  function() {
    function r() {
    }
    return r.use = function(t, e) {
      if (t.extension === "ktx" && t.data)
        try {
          var i = t.name || t.url, n = s_(i, t.data, this.loadKeyValueData), s = n.compressed, o = n.uncompressed, a = n.kvData;
          if (s) {
            var h = nl(i, s, t.metadata);
            if (a && h.textures)
              for (var l in h.textures)
                h.textures[l].baseTexture.ktxKeyValueData = a;
            Object.assign(t, h);
          } else if (o) {
            var u = {};
            o.forEach(function(c, f) {
              var d = new ot(new gt(c.resource, {
                mipmap: Ee.OFF,
                alphaMode: Se.NO_PREMULTIPLIED_ALPHA,
                type: c.type,
                format: c.format
              })), p = i + "-" + (f + 1);
              a && (d.baseTexture.ktxKeyValueData = a), gt.addToCache(d.baseTexture, p), ot.addToCache(d, p), f === 0 && (u[i] = d, gt.addToCache(d.baseTexture, i), ot.addToCache(d, i)), u[p] = d;
            }), Object.assign(t, { textures: u });
          }
        } catch (c) {
          e(c);
          return;
        }
      e();
    }, r.extension = St.Loader, r.loadKeyValueData = !1, r;
  }()
);
/*!
 * @pixi/particle-container - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/particle-container is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ws = function(r, t) {
  return Ws = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Ws(r, t);
};
function sl(r, t) {
  Ws(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
(function(r) {
  sl(t, r);
  function t(e, i, n, s) {
    e === void 0 && (e = 1500), n === void 0 && (n = 16384), s === void 0 && (s = !1);
    var o = r.call(this) || this, a = 16384;
    return n > a && (n = a), o._properties = [!1, !0, !1, !1, !1], o._maxSize = e, o._batchSize = n, o._buffers = null, o._bufferUpdateIDs = [], o._updateID = 0, o.interactiveChildren = !1, o.blendMode = it.NORMAL, o.autoResize = s, o.roundPixels = !0, o.baseTexture = null, o.setProperties(i), o._tint = 0, o.tintRgb = new Float32Array(4), o.tint = 16777215, o;
  }
  return t.prototype.setProperties = function(e) {
    e && (this._properties[0] = "vertices" in e || "scale" in e ? !!e.vertices || !!e.scale : this._properties[0], this._properties[1] = "position" in e ? !!e.position : this._properties[1], this._properties[2] = "rotation" in e ? !!e.rotation : this._properties[2], this._properties[3] = "uvs" in e ? !!e.uvs : this._properties[3], this._properties[4] = "tint" in e || "alpha" in e ? !!e.tint || !!e.alpha : this._properties[4]);
  }, t.prototype.updateTransform = function() {
    this.displayObjectUpdateTransform();
  }, Object.defineProperty(t.prototype, "tint", {
    /**
     * The tint applied to the container. This is a hex value.
     * A value of 0xFFFFFF will remove any tint effect.
     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
     * @default 0xFFFFFF
     */
    get: function() {
      return this._tint;
    },
    set: function(e) {
      this._tint = e, Gi(e, this.tintRgb);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.render = function(e) {
    var i = this;
    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", function() {
      return i.onChildrenChange(0);
    })), e.batch.setObjectRenderer(e.plugins.particle), e.plugins.particle.render(this));
  }, t.prototype.onChildrenChange = function(e) {
    for (var i = Math.floor(e / this._batchSize); this._bufferUpdateIDs.length < i; )
      this._bufferUpdateIDs.push(0);
    this._bufferUpdateIDs[i] = ++this._updateID;
  }, t.prototype.dispose = function() {
    if (this._buffers) {
      for (var e = 0; e < this._buffers.length; ++e)
        this._buffers[e].destroy();
      this._buffers = null;
    }
  }, t.prototype.destroy = function(e) {
    r.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;
  }, t;
})(Ct);
var Ha = (
  /** @class */
  function() {
    function r(t, e, i) {
      this.geometry = new Rr(), this.indexBuffer = null, this.size = i, this.dynamicProperties = [], this.staticProperties = [];
      for (var n = 0; n < t.length; ++n) {
        var s = t[n];
        s = {
          attributeName: s.attributeName,
          size: s.size,
          uploadFunction: s.uploadFunction,
          type: s.type || st.FLOAT,
          offset: s.offset
        }, e[n] ? this.dynamicProperties.push(s) : this.staticProperties.push(s);
      }
      this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();
    }
    return r.prototype.initBuffers = function() {
      var t = this.geometry, e = 0;
      this.indexBuffer = new Xt(xd(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;
      for (var i = 0; i < this.dynamicProperties.length; ++i) {
        var n = this.dynamicProperties[i];
        n.offset = e, e += n.size, this.dynamicStride += n.size;
      }
      var s = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
      this.dynamicData = new Float32Array(s), this.dynamicDataUint32 = new Uint32Array(s), this.dynamicBuffer = new Xt(this.dynamicData, !1, !1);
      var o = 0;
      this.staticStride = 0;
      for (var i = 0; i < this.staticProperties.length; ++i) {
        var n = this.staticProperties[i];
        n.offset = o, o += n.size, this.staticStride += n.size;
      }
      var a = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
      this.staticData = new Float32Array(a), this.staticDataUint32 = new Uint32Array(a), this.staticBuffer = new Xt(this.staticData, !0, !1);
      for (var i = 0; i < this.dynamicProperties.length; ++i) {
        var n = this.dynamicProperties[i];
        t.addAttribute(n.attributeName, this.dynamicBuffer, 0, n.type === st.UNSIGNED_BYTE, n.type, this.dynamicStride * 4, n.offset * 4);
      }
      for (var i = 0; i < this.staticProperties.length; ++i) {
        var n = this.staticProperties[i];
        t.addAttribute(n.attributeName, this.staticBuffer, 0, n.type === st.UNSIGNED_BYTE, n.type, this.staticStride * 4, n.offset * 4);
      }
    }, r.prototype.uploadDynamic = function(t, e, i) {
      for (var n = 0; n < this.dynamicProperties.length; n++) {
        var s = this.dynamicProperties[n];
        s.uploadFunction(t, e, i, s.type === st.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, s.offset);
      }
      this.dynamicBuffer._updateID++;
    }, r.prototype.uploadStatic = function(t, e, i) {
      for (var n = 0; n < this.staticProperties.length; n++) {
        var s = this.staticProperties[n];
        s.uploadFunction(t, e, i, s.type === st.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, s.offset);
      }
      this.staticBuffer._updateID++;
    }, r.prototype.destroy = function() {
      this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();
    }, r;
  }()
), c_ = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`, f_ = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`, d_ = (
  /** @class */
  function(r) {
    sl(t, r);
    function t(e) {
      var i = r.call(this, e) || this;
      return i.shader = null, i.properties = null, i.tempMatrix = new Vt(), i.properties = [
        // verticesData
        {
          attributeName: "aVertexPosition",
          size: 2,
          uploadFunction: i.uploadVertices,
          offset: 0
        },
        // positionData
        {
          attributeName: "aPositionCoord",
          size: 2,
          uploadFunction: i.uploadPosition,
          offset: 0
        },
        // rotationData
        {
          attributeName: "aRotation",
          size: 1,
          uploadFunction: i.uploadRotation,
          offset: 0
        },
        // uvsData
        {
          attributeName: "aTextureCoord",
          size: 2,
          uploadFunction: i.uploadUvs,
          offset: 0
        },
        // tintData
        {
          attributeName: "aColor",
          size: 1,
          type: st.UNSIGNED_BYTE,
          uploadFunction: i.uploadTint,
          offset: 0
        }
      ], i.shader = hi.from(f_, c_, {}), i.state = Oi.for2d(), i;
    }
    return t.prototype.render = function(e) {
      var i = e.children, n = e._maxSize, s = e._batchSize, o = this.renderer, a = i.length;
      if (a !== 0) {
        a > n && !e.autoResize && (a = n);
        var h = e._buffers;
        h || (h = e._buffers = this.generateBuffers(e));
        var l = i[0]._texture.baseTexture, u = l.alphaMode > 0;
        this.state.blendMode = kh(e.blendMode, u), o.state.set(this.state);
        var c = o.gl, f = e.worldTransform.copyTo(this.tempMatrix);
        f.prepend(o.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = f.toArray(!0), this.shader.uniforms.uColor = bd(e.tintRgb, e.worldAlpha, this.shader.uniforms.uColor, u), this.shader.uniforms.uSampler = l, this.renderer.shader.bind(this.shader);
        for (var d = !1, p = 0, v = 0; p < a; p += s, v += 1) {
          var _ = a - p;
          _ > s && (_ = s), v >= h.length && h.push(this._generateOneMoreBuffer(e));
          var m = h[v];
          m.uploadDynamic(i, p, _);
          var y = e._bufferUpdateIDs[v] || 0;
          d = d || m._updateID < y, d && (m._updateID = e._updateID, m.uploadStatic(i, p, _)), o.geometry.bind(m.geometry), c.drawElements(c.TRIANGLES, _ * 6, c.UNSIGNED_SHORT, 0);
        }
      }
    }, t.prototype.generateBuffers = function(e) {
      for (var i = [], n = e._maxSize, s = e._batchSize, o = e._properties, a = 0; a < n; a += s)
        i.push(new Ha(this.properties, o, s));
      return i;
    }, t.prototype._generateOneMoreBuffer = function(e) {
      var i = e._batchSize, n = e._properties;
      return new Ha(this.properties, n, i);
    }, t.prototype.uploadVertices = function(e, i, n, s, o, a) {
      for (var h = 0, l = 0, u = 0, c = 0, f = 0; f < n; ++f) {
        var d = e[i + f], p = d._texture, v = d.scale.x, _ = d.scale.y, m = p.trim, y = p.orig;
        m ? (l = m.x - d.anchor.x * y.width, h = l + m.width, c = m.y - d.anchor.y * y.height, u = c + m.height) : (h = y.width * (1 - d.anchor.x), l = y.width * -d.anchor.x, u = y.height * (1 - d.anchor.y), c = y.height * -d.anchor.y), s[a] = l * v, s[a + 1] = c * _, s[a + o] = h * v, s[a + o + 1] = c * _, s[a + o * 2] = h * v, s[a + o * 2 + 1] = u * _, s[a + o * 3] = l * v, s[a + o * 3 + 1] = u * _, a += o * 4;
      }
    }, t.prototype.uploadPosition = function(e, i, n, s, o, a) {
      for (var h = 0; h < n; h++) {
        var l = e[i + h].position;
        s[a] = l.x, s[a + 1] = l.y, s[a + o] = l.x, s[a + o + 1] = l.y, s[a + o * 2] = l.x, s[a + o * 2 + 1] = l.y, s[a + o * 3] = l.x, s[a + o * 3 + 1] = l.y, a += o * 4;
      }
    }, t.prototype.uploadRotation = function(e, i, n, s, o, a) {
      for (var h = 0; h < n; h++) {
        var l = e[i + h].rotation;
        s[a] = l, s[a + o] = l, s[a + o * 2] = l, s[a + o * 3] = l, a += o * 4;
      }
    }, t.prototype.uploadUvs = function(e, i, n, s, o, a) {
      for (var h = 0; h < n; ++h) {
        var l = e[i + h]._texture._uvs;
        l ? (s[a] = l.x0, s[a + 1] = l.y0, s[a + o] = l.x1, s[a + o + 1] = l.y1, s[a + o * 2] = l.x2, s[a + o * 2 + 1] = l.y2, s[a + o * 3] = l.x3, s[a + o * 3 + 1] = l.y3, a += o * 4) : (s[a] = 0, s[a + 1] = 0, s[a + o] = 0, s[a + o + 1] = 0, s[a + o * 2] = 0, s[a + o * 2 + 1] = 0, s[a + o * 3] = 0, s[a + o * 3 + 1] = 0, a += o * 4);
      }
    }, t.prototype.uploadTint = function(e, i, n, s, o, a) {
      for (var h = 0; h < n; ++h) {
        var l = e[i + h], u = l._texture.baseTexture.alphaMode > 0, c = l.alpha, f = c < 1 && u ? Io(l._tintRGB, c) : l._tintRGB + (c * 255 << 24);
        s[a] = f, s[a + o] = f, s[a + o * 2] = f, s[a + o * 3] = f, a += o * 4;
      }
    }, t.prototype.destroy = function() {
      r.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;
    }, t.extension = {
      name: "particle",
      type: St.RendererPlugin
    }, t;
  }(Bn)
);
/*!
 * @pixi/graphics - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/graphics is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Ve;
(function(r) {
  r.MITER = "miter", r.BEVEL = "bevel", r.ROUND = "round";
})(Ve || (Ve = {}));
var ai;
(function(r) {
  r.BUTT = "butt", r.ROUND = "round", r.SQUARE = "square";
})(ai || (ai = {}));
var br = {
  adaptive: !0,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount: function(r, t) {
    if (t === void 0 && (t = 20), !this.adaptive || !r || isNaN(r))
      return t;
    var e = Math.ceil(r / this.maxLength);
    return e < this.minSegments ? e = this.minSegments : e > this.maxSegments && (e = this.maxSegments), e;
  }
}, ol = (
  /** @class */
  function() {
    function r() {
      this.color = 16777215, this.alpha = 1, this.texture = ot.WHITE, this.matrix = null, this.visible = !1, this.reset();
    }
    return r.prototype.clone = function() {
      var t = new r();
      return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t;
    }, r.prototype.reset = function() {
      this.color = 16777215, this.alpha = 1, this.texture = ot.WHITE, this.matrix = null, this.visible = !1;
    }, r.prototype.destroy = function() {
      this.texture = null, this.matrix = null;
    }, r;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ys = function(r, t) {
  return Ys = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Ys(r, t);
};
function Ro(r, t) {
  Ys(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function $a(r, t) {
  var e, i;
  t === void 0 && (t = !1);
  var n = r.length;
  if (!(n < 6)) {
    for (var s = 0, o = 0, a = r[n - 2], h = r[n - 1]; o < n; o += 2) {
      var l = r[o], u = r[o + 1];
      s += (l - a) * (u + h), a = l, h = u;
    }
    if (!t && s > 0 || t && s <= 0)
      for (var c = n / 2, o = c + c % 2; o < n; o += 2) {
        var f = n - o - 2, d = n - o - 1, p = o, v = o + 1;
        e = [r[p], r[f]], r[f] = e[0], r[p] = e[1], i = [r[v], r[d]], r[d] = i[0], r[v] = i[1];
      }
  }
}
var al = {
  build: function(r) {
    r.points = r.shape.points.slice();
  },
  triangulate: function(r, t) {
    var e = r.points, i = r.holes, n = t.points, s = t.indices;
    if (e.length >= 6) {
      $a(e, !1);
      for (var o = [], a = 0; a < i.length; a++) {
        var h = i[a];
        $a(h.points, !0), o.push(e.length / 2), e = e.concat(h.points);
      }
      var l = Ih(e, o, 2);
      if (!l)
        return;
      for (var u = n.length / 2, a = 0; a < l.length; a += 3)
        s.push(l[a] + u), s.push(l[a + 1] + u), s.push(l[a + 2] + u);
      for (var a = 0; a < e.length; a++)
        n.push(e[a]);
    }
  }
}, Rn = {
  build: function(r) {
    var t = r.points, e, i, n, s, o, a;
    if (r.type === Yt.CIRC) {
      var h = r.shape;
      e = h.x, i = h.y, o = a = h.radius, n = s = 0;
    } else if (r.type === Yt.ELIP) {
      var l = r.shape;
      e = l.x, i = l.y, o = l.width, a = l.height, n = s = 0;
    } else {
      var u = r.shape, c = u.width / 2, f = u.height / 2;
      e = u.x + c, i = u.y + f, o = a = Math.max(0, Math.min(u.radius, Math.min(c, f))), n = c - o, s = f - a;
    }
    if (!(o >= 0 && a >= 0 && n >= 0 && s >= 0)) {
      t.length = 0;
      return;
    }
    var d = Math.ceil(2.3 * Math.sqrt(o + a)), p = d * 8 + (n ? 4 : 0) + (s ? 4 : 0);
    if (t.length = p, p !== 0) {
      if (d === 0) {
        t.length = 8, t[0] = t[6] = e + n, t[1] = t[3] = i + s, t[2] = t[4] = e - n, t[5] = t[7] = i - s;
        return;
      }
      var v = 0, _ = d * 4 + (n ? 2 : 0) + 2, m = _, y = p;
      {
        var b = n + o, P = s, x = e + b, T = e - b, I = i + P;
        if (t[v++] = x, t[v++] = I, t[--_] = I, t[--_] = T, s) {
          var w = i - P;
          t[m++] = T, t[m++] = w, t[--y] = w, t[--y] = x;
        }
      }
      for (var O = 1; O < d; O++) {
        var R = Math.PI / 2 * (O / d), b = n + Math.cos(R) * o, P = s + Math.sin(R) * a, x = e + b, T = e - b, I = i + P, w = i - P;
        t[v++] = x, t[v++] = I, t[--_] = I, t[--_] = T, t[m++] = T, t[m++] = w, t[--y] = w, t[--y] = x;
      }
      {
        var b = n, P = s + a, x = e + b, T = e - b, I = i + P, w = i - P;
        t[v++] = x, t[v++] = I, t[--y] = w, t[--y] = x, n && (t[v++] = T, t[v++] = I, t[--y] = w, t[--y] = T);
      }
    }
  },
  triangulate: function(r, t) {
    var e = r.points, i = t.points, n = t.indices;
    if (e.length !== 0) {
      var s = i.length / 2, o = s, a, h;
      if (r.type !== Yt.RREC) {
        var l = r.shape;
        a = l.x, h = l.y;
      } else {
        var u = r.shape;
        a = u.x + u.width / 2, h = u.y + u.height / 2;
      }
      var c = r.matrix;
      i.push(r.matrix ? c.a * a + c.c * h + c.tx : a, r.matrix ? c.b * a + c.d * h + c.ty : h), s++, i.push(e[0], e[1]);
      for (var f = 2; f < e.length; f += 2)
        i.push(e[f], e[f + 1]), n.push(s++, o, s);
      n.push(o + 1, o, s);
    }
  }
}, p_ = {
  build: function(r) {
    var t = r.shape, e = t.x, i = t.y, n = t.width, s = t.height, o = r.points;
    o.length = 0, o.push(e, i, e + n, i, e + n, i + s, e, i + s);
  },
  triangulate: function(r, t) {
    var e = r.points, i = t.points, n = i.length / 2;
    i.push(e[0], e[1], e[2], e[3], e[6], e[7], e[4], e[5]), t.indices.push(n, n + 1, n + 2, n + 1, n + 2, n + 3);
  }
};
function Ri(r, t, e) {
  var i = t - r;
  return r + i * e;
}
function tn(r, t, e, i, n, s, o) {
  o === void 0 && (o = []);
  for (var a = 20, h = o, l = 0, u = 0, c = 0, f = 0, d = 0, p = 0, v = 0, _ = 0; v <= a; ++v)
    _ = v / a, l = Ri(r, e, _), u = Ri(t, i, _), c = Ri(e, n, _), f = Ri(i, s, _), d = Ri(l, c, _), p = Ri(u, f, _), !(v === 0 && h[h.length - 2] === d && h[h.length - 1] === p) && h.push(d, p);
  return h;
}
var v_ = {
  build: function(r) {
    if (se.nextRoundedRectBehavior) {
      Rn.build(r);
      return;
    }
    var t = r.shape, e = r.points, i = t.x, n = t.y, s = t.width, o = t.height, a = Math.max(0, Math.min(t.radius, Math.min(s, o) / 2));
    e.length = 0, a ? (tn(i, n + a, i, n, i + a, n, e), tn(i + s - a, n, i + s, n, i + s, n + a, e), tn(i + s, n + o - a, i + s, n + o, i + s - a, n + o, e), tn(i + a, n + o, i, n + o, i, n + o - a, e)) : e.push(i, n, i + s, n, i + s, n + o, i, n + o);
  },
  triangulate: function(r, t) {
    if (se.nextRoundedRectBehavior) {
      Rn.triangulate(r, t);
      return;
    }
    for (var e = r.points, i = t.points, n = t.indices, s = i.length / 2, o = Ih(e, null, 2), a = 0, h = o.length; a < h; a += 3)
      n.push(o[a] + s), n.push(o[a + 1] + s), n.push(o[a + 2] + s);
    for (var a = 0, h = e.length; a < h; a++)
      i.push(e[a], e[++a]);
  }
};
function za(r, t, e, i, n, s, o, a) {
  var h = r - e * n, l = t - i * n, u = r + e * s, c = t + i * s, f, d;
  o ? (f = i, d = -e) : (f = -i, d = e);
  var p = h + f, v = l + d, _ = u + f, m = c + d;
  return a.push(p, v), a.push(_, m), 2;
}
function pi(r, t, e, i, n, s, o, a) {
  var h = e - r, l = i - t, u = Math.atan2(h, l), c = Math.atan2(n - r, s - t);
  a && u < c ? u += Math.PI * 2 : !a && u > c && (c += Math.PI * 2);
  var f = u, d = c - u, p = Math.abs(d), v = Math.sqrt(h * h + l * l), _ = (15 * p * Math.sqrt(v) / Math.PI >> 0) + 1, m = d / _;
  if (f += m, a) {
    o.push(r, t), o.push(e, i);
    for (var y = 1, b = f; y < _; y++, b += m)
      o.push(r, t), o.push(r + Math.sin(b) * v, t + Math.cos(b) * v);
    o.push(r, t), o.push(n, s);
  } else {
    o.push(e, i), o.push(r, t);
    for (var y = 1, b = f; y < _; y++, b += m)
      o.push(r + Math.sin(b) * v, t + Math.cos(b) * v), o.push(r, t);
    o.push(n, s), o.push(r, t);
  }
  return _ * 2;
}
function __(r, t) {
  var e = r.shape, i = r.points || e.points.slice(), n = t.closePointEps;
  if (i.length !== 0) {
    var s = r.lineStyle, o = new Ot(i[0], i[1]), a = new Ot(i[i.length - 2], i[i.length - 1]), h = e.type !== Yt.POLY || e.closeStroke, l = Math.abs(o.x - a.x) < n && Math.abs(o.y - a.y) < n;
    if (h) {
      i = i.slice(), l && (i.pop(), i.pop(), a.set(i[i.length - 2], i[i.length - 1]));
      var u = (o.x + a.x) * 0.5, c = (a.y + o.y) * 0.5;
      i.unshift(u, c), i.push(u, c);
    }
    var f = t.points, d = i.length / 2, p = i.length, v = f.length / 2, _ = s.width / 2, m = _ * _, y = s.miterLimit * s.miterLimit, b = i[0], P = i[1], x = i[2], T = i[3], I = 0, w = 0, O = -(P - T), R = b - x, U = 0, q = 0, tt = Math.sqrt(O * O + R * R);
    O /= tt, R /= tt, O *= _, R *= _;
    var ct = s.alignment, Y = (1 - ct) * 2, g = ct * 2;
    h || (s.cap === ai.ROUND ? p += pi(b - O * (Y - g) * 0.5, P - R * (Y - g) * 0.5, b - O * Y, P - R * Y, b + O * g, P + R * g, f, !0) + 2 : s.cap === ai.SQUARE && (p += za(b, P, O, R, Y, g, !0, f))), f.push(b - O * Y, P - R * Y), f.push(b + O * g, P + R * g);
    for (var S = 1; S < d - 1; ++S) {
      b = i[(S - 1) * 2], P = i[(S - 1) * 2 + 1], x = i[S * 2], T = i[S * 2 + 1], I = i[(S + 1) * 2], w = i[(S + 1) * 2 + 1], O = -(P - T), R = b - x, tt = Math.sqrt(O * O + R * R), O /= tt, R /= tt, O *= _, R *= _, U = -(T - w), q = x - I, tt = Math.sqrt(U * U + q * q), U /= tt, q /= tt, U *= _, q *= _;
      var E = x - b, M = P - T, N = x - I, k = w - T, B = E * N + M * k, H = M * N - k * E, Z = H < 0;
      if (Math.abs(H) < 1e-3 * Math.abs(B)) {
        f.push(x - O * Y, T - R * Y), f.push(x + O * g, T + R * g), B >= 0 && (s.join === Ve.ROUND ? p += pi(x, T, x - O * Y, T - R * Y, x - U * Y, T - q * Y, f, !1) + 4 : p += 2, f.push(x - U * g, T - q * g), f.push(x + U * Y, T + q * Y));
        continue;
      }
      var J = (-O + b) * (-R + T) - (-O + x) * (-R + P), C = (-U + I) * (-q + T) - (-U + x) * (-q + w), ut = (E * C - N * J) / H, X = (k * J - M * C) / H, xt = (ut - x) * (ut - x) + (X - T) * (X - T), lt = x + (ut - x) * Y, V = T + (X - T) * Y, Mt = x - (ut - x) * g, ht = T - (X - T) * g, F = Math.min(E * E + M * M, N * N + k * k), W = Z ? Y : g, et = F + W * W * m, G = xt <= et;
      G ? s.join === Ve.BEVEL || xt / m > y ? (Z ? (f.push(lt, V), f.push(x + O * g, T + R * g), f.push(lt, V), f.push(x + U * g, T + q * g)) : (f.push(x - O * Y, T - R * Y), f.push(Mt, ht), f.push(x - U * Y, T - q * Y), f.push(Mt, ht)), p += 2) : s.join === Ve.ROUND ? Z ? (f.push(lt, V), f.push(x + O * g, T + R * g), p += pi(x, T, x + O * g, T + R * g, x + U * g, T + q * g, f, !0) + 4, f.push(lt, V), f.push(x + U * g, T + q * g)) : (f.push(x - O * Y, T - R * Y), f.push(Mt, ht), p += pi(x, T, x - O * Y, T - R * Y, x - U * Y, T - q * Y, f, !1) + 4, f.push(x - U * Y, T - q * Y), f.push(Mt, ht)) : (f.push(lt, V), f.push(Mt, ht)) : (f.push(x - O * Y, T - R * Y), f.push(x + O * g, T + R * g), s.join === Ve.ROUND ? Z ? p += pi(x, T, x + O * g, T + R * g, x + U * g, T + q * g, f, !0) + 2 : p += pi(x, T, x - O * Y, T - R * Y, x - U * Y, T - q * Y, f, !1) + 2 : s.join === Ve.MITER && xt / m <= y && (Z ? (f.push(Mt, ht), f.push(Mt, ht)) : (f.push(lt, V), f.push(lt, V)), p += 2), f.push(x - U * Y, T - q * Y), f.push(x + U * g, T + q * g), p += 2);
    }
    b = i[(d - 2) * 2], P = i[(d - 2) * 2 + 1], x = i[(d - 1) * 2], T = i[(d - 1) * 2 + 1], O = -(P - T), R = b - x, tt = Math.sqrt(O * O + R * R), O /= tt, R /= tt, O *= _, R *= _, f.push(x - O * Y, T - R * Y), f.push(x + O * g, T + R * g), h || (s.cap === ai.ROUND ? p += pi(x - O * (Y - g) * 0.5, T - R * (Y - g) * 0.5, x - O * Y, T - R * Y, x + O * g, T + R * g, f, !1) + 2 : s.cap === ai.SQUARE && (p += za(x, T, O, R, Y, g, !1, f)));
    for (var Kt = t.indices, Ce = br.epsilon * br.epsilon, S = v; S < p + v - 2; ++S)
      b = f[S * 2], P = f[S * 2 + 1], x = f[(S + 1) * 2], T = f[(S + 1) * 2 + 1], I = f[(S + 2) * 2], w = f[(S + 2) * 2 + 1], !(Math.abs(b * (T - w) + x * (w - P) + I * (P - T)) < Ce) && Kt.push(S, S + 1, S + 2);
  }
}
function m_(r, t) {
  var e = 0, i = r.shape, n = r.points || i.points, s = i.type !== Yt.POLY || i.closeStroke;
  if (n.length !== 0) {
    var o = t.points, a = t.indices, h = n.length / 2, l = o.length / 2, u = l;
    for (o.push(n[0], n[1]), e = 1; e < h; e++)
      o.push(n[e * 2], n[e * 2 + 1]), a.push(u, u + 1), u++;
    s && a.push(u, l);
  }
}
function Xa(r, t) {
  r.lineStyle.native ? m_(r, t) : __(r, t);
}
var Va = (
  /** @class */
  function() {
    function r() {
    }
    return r.curveTo = function(t, e, i, n, s, o) {
      var a = o[o.length - 2], h = o[o.length - 1], l = h - e, u = a - t, c = n - e, f = i - t, d = Math.abs(l * f - u * c);
      if (d < 1e-8 || s === 0)
        return (o[o.length - 2] !== t || o[o.length - 1] !== e) && o.push(t, e), null;
      var p = l * l + u * u, v = c * c + f * f, _ = l * c + u * f, m = s * Math.sqrt(p) / d, y = s * Math.sqrt(v) / d, b = m * _ / p, P = y * _ / v, x = m * f + y * u, T = m * c + y * l, I = u * (y + b), w = l * (y + b), O = f * (m + P), R = c * (m + P), U = Math.atan2(w - T, I - x), q = Math.atan2(R - T, O - x);
      return {
        cx: x + t,
        cy: T + e,
        radius: s,
        startAngle: U,
        endAngle: q,
        anticlockwise: u * c > f * l
      };
    }, r.arc = function(t, e, i, n, s, o, a, h, l) {
      for (var u = a - o, c = br._segmentsCount(Math.abs(u) * s, Math.ceil(Math.abs(u) / In) * 40), f = u / (c * 2), d = f * 2, p = Math.cos(f), v = Math.sin(f), _ = c - 1, m = _ % 1 / _, y = 0; y <= _; ++y) {
        var b = y + m * y, P = f + o + d * b, x = Math.cos(P), T = -Math.sin(P);
        l.push((p * x + v * T) * s + i, (p * -T + v * x) * s + n);
      }
    }, r;
  }()
), y_ = (
  /** @class */
  function() {
    function r() {
    }
    return r.curveLength = function(t, e, i, n, s, o, a, h) {
      for (var l = 10, u = 0, c = 0, f = 0, d = 0, p = 0, v = 0, _ = 0, m = 0, y = 0, b = 0, P = 0, x = t, T = e, I = 1; I <= l; ++I)
        c = I / l, f = c * c, d = f * c, p = 1 - c, v = p * p, _ = v * p, m = _ * t + 3 * v * c * i + 3 * p * f * s + d * a, y = _ * e + 3 * v * c * n + 3 * p * f * o + d * h, b = x - m, P = T - y, x = m, T = y, u += Math.sqrt(b * b + P * P);
      return u;
    }, r.curveTo = function(t, e, i, n, s, o, a) {
      var h = a[a.length - 2], l = a[a.length - 1];
      a.length -= 2;
      var u = br._segmentsCount(r.curveLength(h, l, t, e, i, n, s, o)), c = 0, f = 0, d = 0, p = 0, v = 0;
      a.push(h, l);
      for (var _ = 1, m = 0; _ <= u; ++_)
        m = _ / u, c = 1 - m, f = c * c, d = f * c, p = m * m, v = p * m, a.push(d * h + 3 * f * m * t + 3 * c * p * i + v * s, d * l + 3 * f * m * e + 3 * c * p * n + v * o);
    }, r;
  }()
), g_ = (
  /** @class */
  function() {
    function r() {
    }
    return r.curveLength = function(t, e, i, n, s, o) {
      var a = t - 2 * i + s, h = e - 2 * n + o, l = 2 * i - 2 * t, u = 2 * n - 2 * e, c = 4 * (a * a + h * h), f = 4 * (a * l + h * u), d = l * l + u * u, p = 2 * Math.sqrt(c + f + d), v = Math.sqrt(c), _ = 2 * c * v, m = 2 * Math.sqrt(d), y = f / v;
      return (_ * p + v * f * (p - m) + (4 * d * c - f * f) * Math.log((2 * v + y + p) / (y + m))) / (4 * _);
    }, r.curveTo = function(t, e, i, n, s) {
      for (var o = s[s.length - 2], a = s[s.length - 1], h = br._segmentsCount(r.curveLength(o, a, t, e, i, n)), l = 0, u = 0, c = 1; c <= h; ++c) {
        var f = c / h;
        l = o + (t - o) * f, u = a + (e - a) * f, s.push(l + (t + (i - t) * f - l) * f, u + (e + (n - e) * f - u) * f);
      }
    }, r;
  }()
), b_ = (
  /** @class */
  function() {
    function r() {
      this.reset();
    }
    return r.prototype.begin = function(t, e, i) {
      this.reset(), this.style = t, this.start = e, this.attribStart = i;
    }, r.prototype.end = function(t, e) {
      this.attribSize = e - this.attribStart, this.size = t - this.start;
    }, r.prototype.reset = function() {
      this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;
    }, r;
  }()
), vi, ms = (vi = {}, vi[Yt.POLY] = al, vi[Yt.CIRC] = Rn, vi[Yt.ELIP] = Rn, vi[Yt.RECT] = p_, vi[Yt.RREC] = v_, vi), Wa = [], en = [], Ya = (
  /** @class */
  function() {
    function r(t, e, i, n) {
      e === void 0 && (e = null), i === void 0 && (i = null), n === void 0 && (n = null), this.points = [], this.holes = [], this.shape = t, this.lineStyle = i, this.fillStyle = e, this.matrix = n, this.type = t.type;
    }
    return r.prototype.clone = function() {
      return new r(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    }, r.prototype.destroy = function() {
      this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;
    }, r;
  }()
), ki = new Ot(), x_ = (
  /** @class */
  function(r) {
    Ro(t, r);
    function t() {
      var e = r.call(this) || this;
      return e.closePointEps = 1e-4, e.boundsPadding = 0, e.uvsFloat32 = null, e.indicesUint16 = null, e.batchable = !1, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.drawCalls = [], e.batchDirty = -1, e.batches = [], e.dirty = 0, e.cacheDirty = -1, e.clearDirty = 0, e.shapeIndex = 0, e._bounds = new On(), e.boundsDirty = -1, e;
    }
    return Object.defineProperty(t.prototype, "bounds", {
      /**
       * Get the current bounds of the graphic geometry.
       * @readonly
       */
      get: function() {
        return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.invalidate = function() {
      this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
      for (var e = 0; e < this.drawCalls.length; e++)
        this.drawCalls[e].texArray.clear(), en.push(this.drawCalls[e]);
      this.drawCalls.length = 0;
      for (var e = 0; e < this.batches.length; e++) {
        var i = this.batches[e];
        i.reset(), Wa.push(i);
      }
      this.batches.length = 0;
    }, t.prototype.clear = function() {
      return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;
    }, t.prototype.drawShape = function(e, i, n, s) {
      i === void 0 && (i = null), n === void 0 && (n = null), s === void 0 && (s = null);
      var o = new Ya(e, i, n, s);
      return this.graphicsData.push(o), this.dirty++, this;
    }, t.prototype.drawHole = function(e, i) {
      if (i === void 0 && (i = null), !this.graphicsData.length)
        return null;
      var n = new Ya(e, null, null, i), s = this.graphicsData[this.graphicsData.length - 1];
      return n.lineStyle = s.lineStyle, s.holes.push(n), this.dirty++, this;
    }, t.prototype.destroy = function() {
      r.prototype.destroy.call(this);
      for (var e = 0; e < this.graphicsData.length; ++e)
        this.graphicsData[e].destroy();
      this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;
    }, t.prototype.containsPoint = function(e) {
      for (var i = this.graphicsData, n = 0; n < i.length; ++n) {
        var s = i[n];
        if (s.fillStyle.visible && s.shape && (s.matrix ? s.matrix.applyInverse(e, ki) : ki.copyFrom(e), s.shape.contains(ki.x, ki.y))) {
          var o = !1;
          if (s.holes)
            for (var a = 0; a < s.holes.length; a++) {
              var h = s.holes[a];
              if (h.shape.contains(ki.x, ki.y)) {
                o = !0;
                break;
              }
            }
          if (!o)
            return !0;
        }
      }
      return !1;
    }, t.prototype.updateBatches = function() {
      if (!this.graphicsData.length) {
        this.batchable = !0;
        return;
      }
      if (this.validateBatching()) {
        this.cacheDirty = this.dirty;
        var e = this.uvs, i = this.graphicsData, n = null, s = null;
        this.batches.length > 0 && (n = this.batches[this.batches.length - 1], s = n.style);
        for (var o = this.shapeIndex; o < i.length; o++) {
          this.shapeIndex++;
          var a = i[o], h = a.fillStyle, l = a.lineStyle, u = ms[a.type];
          u.build(a), a.matrix && this.transformPoints(a.points, a.matrix), (h.visible || l.visible) && this.processHoles(a.holes);
          for (var c = 0; c < 2; c++) {
            var f = c === 0 ? h : l;
            if (f.visible) {
              var d = f.texture.baseTexture, p = this.indices.length, v = this.points.length / 2;
              d.wrapMode = ke.REPEAT, c === 0 ? this.processFill(a) : this.processLine(a);
              var _ = this.points.length / 2 - v;
              _ !== 0 && (n && !this._compareStyles(s, f) && (n.end(p, v), n = null), n || (n = Wa.pop() || new b_(), n.begin(f, p, v), this.batches.push(n), s = f), this.addUvs(this.points, e, f.texture, v, _, f.matrix));
            }
          }
        }
        var m = this.indices.length, y = this.points.length / 2;
        if (n && n.end(m, y), this.batches.length === 0) {
          this.batchable = !0;
          return;
        }
        var b = y > 65535;
        this.indicesUint16 && this.indices.length === this.indicesUint16.length && b === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = b ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();
      }
    }, t.prototype._compareStyles = function(e, i) {
      return !(!e || !i || e.texture.baseTexture !== i.texture.baseTexture || e.color + e.alpha !== i.color + i.alpha || !!e.native != !!i.native);
    }, t.prototype.validateBatching = function() {
      if (this.dirty === this.cacheDirty || !this.graphicsData.length)
        return !1;
      for (var e = 0, i = this.graphicsData.length; e < i; e++) {
        var n = this.graphicsData[e], s = n.fillStyle, o = n.lineStyle;
        if (s && !s.texture.baseTexture.valid || o && !o.texture.baseTexture.valid)
          return !1;
      }
      return !0;
    }, t.prototype.packBatches = function() {
      this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
      for (var e = this.batches, i = 0, n = e.length; i < n; i++)
        for (var s = e[i], o = 0; o < s.size; o++) {
          var a = s.start + o;
          this.indicesUint16[a] = this.indicesUint16[a] - s.attribStart;
        }
    }, t.prototype.isBatchable = function() {
      if (this.points.length > 65535 * 2)
        return !1;
      for (var e = this.batches, i = 0; i < e.length; i++)
        if (e[i].style.native)
          return !1;
      return this.points.length < t.BATCHABLE_SIZE * 2;
    }, t.prototype.buildDrawCalls = function() {
      for (var e = ++gt._globalBatch, i = 0; i < this.drawCalls.length; i++)
        this.drawCalls[i].texArray.clear(), en.push(this.drawCalls[i]);
      this.drawCalls.length = 0;
      var n = this.colors, s = this.textureIds, o = en.pop();
      o || (o = new Us(), o.texArray = new Gs()), o.texArray.count = 0, o.start = 0, o.size = 0, o.type = we.TRIANGLES;
      var a = 0, h = null, l = 0, u = !1, c = we.TRIANGLES, f = 0;
      this.drawCalls.push(o);
      for (var i = 0; i < this.batches.length; i++) {
        var d = this.batches[i], p = 8, v = d.style, _ = v.texture.baseTexture;
        u !== !!v.native && (u = !!v.native, c = u ? we.LINES : we.TRIANGLES, h = null, a = p, e++), h !== _ && (h = _, _._batchEnabled !== e && (a === p && (e++, a = 0, o.size > 0 && (o = en.pop(), o || (o = new Us(), o.texArray = new Gs()), this.drawCalls.push(o)), o.start = f, o.size = 0, o.texArray.count = 0, o.type = c), _.touched = 1, _._batchEnabled = e, _._batchLocation = a, _.wrapMode = ke.REPEAT, o.texArray.elements[o.texArray.count++] = _, a++)), o.size += d.size, f += d.size, l = _._batchLocation, this.addColors(n, v.color, v.alpha, d.attribSize, d.attribStart), this.addTextureIds(s, l, d.attribSize, d.attribStart);
      }
      gt._globalBatch = e, this.packAttributes();
    }, t.prototype.packAttributes = function() {
      for (var e = this.points, i = this.uvs, n = this.colors, s = this.textureIds, o = new ArrayBuffer(e.length * 3 * 4), a = new Float32Array(o), h = new Uint32Array(o), l = 0, u = 0; u < e.length / 2; u++)
        a[l++] = e[u * 2], a[l++] = e[u * 2 + 1], a[l++] = i[u * 2], a[l++] = i[u * 2 + 1], h[l++] = n[u], a[l++] = s[u];
      this._buffer.update(o), this._indexBuffer.update(this.indicesUint16);
    }, t.prototype.processFill = function(e) {
      if (e.holes.length)
        al.triangulate(e, this);
      else {
        var i = ms[e.type];
        i.triangulate(e, this);
      }
    }, t.prototype.processLine = function(e) {
      Xa(e, this);
      for (var i = 0; i < e.holes.length; i++)
        Xa(e.holes[i], this);
    }, t.prototype.processHoles = function(e) {
      for (var i = 0; i < e.length; i++) {
        var n = e[i], s = ms[n.type];
        s.build(n), n.matrix && this.transformPoints(n.points, n.matrix);
      }
    }, t.prototype.calculateBounds = function() {
      var e = this._bounds;
      e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding);
    }, t.prototype.transformPoints = function(e, i) {
      for (var n = 0; n < e.length / 2; n++) {
        var s = e[n * 2], o = e[n * 2 + 1];
        e[n * 2] = i.a * s + i.c * o + i.tx, e[n * 2 + 1] = i.b * s + i.d * o + i.ty;
      }
    }, t.prototype.addColors = function(e, i, n, s, o) {
      o === void 0 && (o = 0);
      var a = (i >> 16) + (i & 65280) + ((i & 255) << 16), h = Io(a, n);
      e.length = Math.max(e.length, o + s);
      for (var l = 0; l < s; l++)
        e[o + l] = h;
    }, t.prototype.addTextureIds = function(e, i, n, s) {
      s === void 0 && (s = 0), e.length = Math.max(e.length, s + n);
      for (var o = 0; o < n; o++)
        e[s + o] = i;
    }, t.prototype.addUvs = function(e, i, n, s, o, a) {
      a === void 0 && (a = null);
      for (var h = 0, l = i.length, u = n.frame; h < o; ) {
        var c = e[(s + h) * 2], f = e[(s + h) * 2 + 1];
        if (a) {
          var d = a.a * c + a.c * f + a.tx;
          f = a.b * c + a.d * f + a.ty, c = d;
        }
        h++, i.push(c / u.width, f / u.height);
      }
      var p = n.baseTexture;
      (u.width < p.width || u.height < p.height) && this.adjustUvs(i, n, l, o);
    }, t.prototype.adjustUvs = function(e, i, n, s) {
      for (var o = i.baseTexture, a = 1e-6, h = n + s * 2, l = i.frame, u = l.width / o.width, c = l.height / o.height, f = l.x / l.width, d = l.y / l.height, p = Math.floor(e[n] + a), v = Math.floor(e[n + 1] + a), _ = n + 2; _ < h; _ += 2)
        p = Math.min(p, Math.floor(e[_] + a)), v = Math.min(v, Math.floor(e[_ + 1] + a));
      f -= p, d -= v;
      for (var _ = n; _ < h; _ += 2)
        e[_] = (e[_] + f) * u, e[_ + 1] = (e[_ + 1] + d) * c;
    }, t.BATCHABLE_SIZE = 100, t;
  }(tl)
), w_ = (
  /** @class */
  function(r) {
    Ro(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.width = 0, e.alignment = 0.5, e.native = !1, e.cap = ai.BUTT, e.join = Ve.MITER, e.miterLimit = 10, e;
    }
    return t.prototype.clone = function() {
      var e = new t();
      return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e.width = this.width, e.alignment = this.alignment, e.native = this.native, e.cap = this.cap, e.join = this.join, e.miterLimit = this.miterLimit, e;
    }, t.prototype.reset = function() {
      r.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1;
    }, t;
  }(ol)
), T_ = new Float32Array(3), ys = {}, se = (
  /** @class */
  function(r) {
    Ro(t, r);
    function t(e) {
      e === void 0 && (e = null);
      var i = r.call(this) || this;
      return i.shader = null, i.pluginName = "batch", i.currentPath = null, i.batches = [], i.batchTint = -1, i.batchDirty = -1, i.vertexData = null, i._fillStyle = new ol(), i._lineStyle = new w_(), i._matrix = null, i._holeMode = !1, i.state = Oi.for2d(), i._geometry = e || new x_(), i._geometry.refCount++, i._transformID = -1, i.tint = 16777215, i.blendMode = it.NORMAL, i;
    }
    return Object.defineProperty(t.prototype, "geometry", {
      /**
       * Includes vertex positions, face indices, normals, colors, UVs, and
       * custom attributes within buffers, reducing the cost of passing all
       * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
       * @readonly
       */
      get: function() {
        return this._geometry;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.clone = function() {
      return this.finishPoly(), new t(this._geometry);
    }, Object.defineProperty(t.prototype, "blendMode", {
      get: function() {
        return this.state.blendMode;
      },
      /**
       * The blend mode to be applied to the graphic shape. Apply a value of
       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each
       * primitive in the GraphicsGeometry list is rendered sequentially, modes
       * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will
       * be applied per-primitive.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      set: function(e) {
        this.state.blendMode = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      /**
       * The tint applied to each graphic shape. This is a hex value. A value of
       * 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get: function() {
        return this._tint;
      },
      set: function(e) {
        this._tint = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "fill", {
      /**
       * The current fill style.
       * @readonly
       */
      get: function() {
        return this._fillStyle;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "line", {
      /**
       * The current line style.
       * @readonly
       */
      get: function() {
        return this._lineStyle;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.lineStyle = function(e, i, n, s, o) {
      return e === void 0 && (e = null), i === void 0 && (i = 0), n === void 0 && (n = 1), s === void 0 && (s = 0.5), o === void 0 && (o = !1), typeof e == "number" && (e = { width: e, color: i, alpha: n, alignment: s, native: o }), this.lineTextureStyle(e);
    }, t.prototype.lineTextureStyle = function(e) {
      e = Object.assign({
        width: 0,
        texture: ot.WHITE,
        color: e && e.texture ? 16777215 : 0,
        alpha: 1,
        matrix: null,
        alignment: 0.5,
        native: !1,
        cap: ai.BUTT,
        join: Ve.MITER,
        miterLimit: 10
      }, e), this.currentPath && this.startPoly();
      var i = e.width > 0 && e.alpha > 0;
      return i ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, { visible: i }, e)) : this._lineStyle.reset(), this;
    }, t.prototype.startPoly = function() {
      if (this.currentPath) {
        var e = this.currentPath.points, i = this.currentPath.points.length;
        i > 2 && (this.drawShape(this.currentPath), this.currentPath = new cn(), this.currentPath.closeStroke = !1, this.currentPath.points.push(e[i - 2], e[i - 1]));
      } else
        this.currentPath = new cn(), this.currentPath.closeStroke = !1;
    }, t.prototype.finishPoly = function() {
      this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);
    }, t.prototype.moveTo = function(e, i) {
      return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = i, this;
    }, t.prototype.lineTo = function(e, i) {
      this.currentPath || this.moveTo(0, 0);
      var n = this.currentPath.points, s = n[n.length - 2], o = n[n.length - 1];
      return (s !== e || o !== i) && n.push(e, i), this;
    }, t.prototype._initCurve = function(e, i) {
      e === void 0 && (e = 0), i === void 0 && (i = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, i]) : this.moveTo(e, i);
    }, t.prototype.quadraticCurveTo = function(e, i, n, s) {
      this._initCurve();
      var o = this.currentPath.points;
      return o.length === 0 && this.moveTo(0, 0), g_.curveTo(e, i, n, s, o), this;
    }, t.prototype.bezierCurveTo = function(e, i, n, s, o, a) {
      return this._initCurve(), y_.curveTo(e, i, n, s, o, a, this.currentPath.points), this;
    }, t.prototype.arcTo = function(e, i, n, s, o) {
      this._initCurve(e, i);
      var a = this.currentPath.points, h = Va.curveTo(e, i, n, s, o, a);
      if (h) {
        var l = h.cx, u = h.cy, c = h.radius, f = h.startAngle, d = h.endAngle, p = h.anticlockwise;
        this.arc(l, u, c, f, d, p);
      }
      return this;
    }, t.prototype.arc = function(e, i, n, s, o, a) {
      if (a === void 0 && (a = !1), s === o)
        return this;
      !a && o <= s ? o += In : a && s <= o && (s += In);
      var h = o - s;
      if (h === 0)
        return this;
      var l = e + Math.cos(s) * n, u = i + Math.sin(s) * n, c = this._geometry.closePointEps, f = this.currentPath ? this.currentPath.points : null;
      if (f) {
        var d = Math.abs(f[f.length - 2] - l), p = Math.abs(f[f.length - 1] - u);
        d < c && p < c || f.push(l, u);
      } else
        this.moveTo(l, u), f = this.currentPath.points;
      return Va.arc(l, u, e, i, n, s, o, a, f), this;
    }, t.prototype.beginFill = function(e, i) {
      return e === void 0 && (e = 0), i === void 0 && (i = 1), this.beginTextureFill({ texture: ot.WHITE, color: e, alpha: i });
    }, t.prototype.beginTextureFill = function(e) {
      e = Object.assign({
        texture: ot.WHITE,
        color: 16777215,
        alpha: 1,
        matrix: null
      }, e), this.currentPath && this.startPoly();
      var i = e.alpha > 0;
      return i ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, { visible: i }, e)) : this._fillStyle.reset(), this;
    }, t.prototype.endFill = function() {
      return this.finishPoly(), this._fillStyle.reset(), this;
    }, t.prototype.drawRect = function(e, i, n, s) {
      return this.drawShape(new dt(e, i, n, s));
    }, t.prototype.drawRoundedRect = function(e, i, n, s, o) {
      return this.drawShape(new Od(e, i, n, s, o));
    }, t.prototype.drawCircle = function(e, i, n) {
      return this.drawShape(new Cd(e, i, n));
    }, t.prototype.drawEllipse = function(e, i, n, s) {
      return this.drawShape(new Id(e, i, n, s));
    }, t.prototype.drawPolygon = function() {
      for (var e = arguments, i = [], n = 0; n < arguments.length; n++)
        i[n] = e[n];
      var s, o = !0, a = i[0];
      a.points ? (o = a.closeStroke, s = a.points) : Array.isArray(i[0]) ? s = i[0] : s = i;
      var h = new cn(s);
      return h.closeStroke = o, this.drawShape(h), this;
    }, t.prototype.drawShape = function(e) {
      return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;
    }, t.prototype.clear = function() {
      return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;
    }, t.prototype.isFastRect = function() {
      var e = this._geometry.graphicsData;
      return e.length === 1 && e[0].shape.type === Yt.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width);
    }, t.prototype._render = function(e) {
      this.finishPoly();
      var i = this._geometry;
      i.updateBatches(), i.batchable ? (this.batchDirty !== i.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e));
    }, t.prototype._populateBatches = function() {
      var e = this._geometry, i = this.blendMode, n = e.batches.length;
      this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = n, this.vertexData = new Float32Array(e.points);
      for (var s = 0; s < n; s++) {
        var o = e.batches[s], a = o.style.color, h = new Float32Array(this.vertexData.buffer, o.attribStart * 4 * 2, o.attribSize * 2), l = new Float32Array(e.uvsFloat32.buffer, o.attribStart * 4 * 2, o.attribSize * 2), u = new Uint16Array(e.indicesUint16.buffer, o.start * 2, o.size), c = {
          vertexData: h,
          blendMode: i,
          indices: u,
          uvs: l,
          _batchRGB: Gi(a),
          _tintRGB: a,
          _texture: o.style.texture,
          alpha: o.style.alpha,
          worldAlpha: 1
        };
        this.batches[s] = c;
      }
    }, t.prototype._renderBatched = function(e) {
      if (this.batches.length) {
        e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
        for (var i = 0, n = this.batches.length; i < n; i++) {
          var s = this.batches[i];
          s.worldAlpha = this.worldAlpha * s.alpha, e.plugins[this.pluginName].render(s);
        }
      }
    }, t.prototype._renderDirect = function(e) {
      var i = this._resolveDirectShader(e), n = this._geometry, s = this.tint, o = this.worldAlpha, a = i.uniforms, h = n.drawCalls;
      a.translationMatrix = this.transform.worldTransform, a.tint[0] = (s >> 16 & 255) / 255 * o, a.tint[1] = (s >> 8 & 255) / 255 * o, a.tint[2] = (s & 255) / 255 * o, a.tint[3] = o, e.shader.bind(i), e.geometry.bind(n, i), e.state.set(this.state);
      for (var l = 0, u = h.length; l < u; l++)
        this._renderDrawCallDirect(e, n.drawCalls[l]);
    }, t.prototype._renderDrawCallDirect = function(e, i) {
      for (var n = i.texArray, s = i.type, o = i.size, a = i.start, h = n.count, l = 0; l < h; l++)
        e.texture.bind(n.elements[l], l);
      e.geometry.draw(s, o, a);
    }, t.prototype._resolveDirectShader = function(e) {
      var i = this.shader, n = this.pluginName;
      if (!i) {
        if (!ys[n]) {
          for (var s = e.plugins[n].MAX_TEXTURES, o = new Int32Array(s), a = 0; a < s; a++)
            o[a] = a;
          var h = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Vt(),
            default: Ti.from({ uSamplers: o }, !0)
          }, l = e.plugins[n]._shader.program;
          ys[n] = new hi(l, h);
        }
        i = ys[n];
      }
      return i;
    }, t.prototype._calculateBounds = function() {
      this.finishPoly();
      var e = this._geometry;
      if (e.graphicsData.length) {
        var i = e.bounds, n = i.minX, s = i.minY, o = i.maxX, a = i.maxY;
        this._bounds.addFrame(this.transform, n, s, o, a);
      }
    }, t.prototype.containsPoint = function(e) {
      return this.worldTransform.applyInverse(e, t._TEMP_POINT), this._geometry.containsPoint(t._TEMP_POINT);
    }, t.prototype.calculateTints = function() {
      if (this.batchTint !== this.tint) {
        this.batchTint = this.tint;
        for (var e = Gi(this.tint, T_), i = 0; i < this.batches.length; i++) {
          var n = this.batches[i], s = n._batchRGB, o = e[0] * s[0] * 255, a = e[1] * s[1] * 255, h = e[2] * s[2] * 255, l = (o << 16) + (a << 8) + (h | 0);
          n._tintRGB = (l >> 16) + (l & 65280) + ((l & 255) << 16);
        }
      }
    }, t.prototype.calculateVertices = function() {
      var e = this.transform._worldID;
      if (this._transformID !== e) {
        this._transformID = e;
        for (var i = this.transform.worldTransform, n = i.a, s = i.b, o = i.c, a = i.d, h = i.tx, l = i.ty, u = this._geometry.points, c = this.vertexData, f = 0, d = 0; d < u.length; d += 2) {
          var p = u[d], v = u[d + 1];
          c[f++] = n * p + o * v + h, c[f++] = a * v + s * p + l;
        }
      }
    }, t.prototype.closePath = function() {
      var e = this.currentPath;
      return e && (e.closeStroke = !0, this.finishPoly()), this;
    }, t.prototype.setMatrix = function(e) {
      return this._matrix = e, this;
    }, t.prototype.beginHole = function() {
      return this.finishPoly(), this._holeMode = !0, this;
    }, t.prototype.endHole = function() {
      return this.finishPoly(), this._holeMode = !1, this;
    }, t.prototype.destroy = function(e) {
      this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, r.prototype.destroy.call(this, e);
    }, t.nextRoundedRectBehavior = !1, t._TEMP_POINT = new Ot(), t;
  }(Ct)
);
/*!
 * @pixi/sprite - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/sprite is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var qs = function(r, t) {
  return qs = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, qs(r, t);
};
function E_(r, t) {
  qs(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var tr = new Ot(), S_ = new Uint16Array([0, 1, 2, 0, 2, 3]), Bt = (
  /** @class */
  function(r) {
    E_(t, r);
    function t(e) {
      var i = r.call(this) || this;
      return i._anchor = new Di(i._onAnchorUpdate, i, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), i._texture = null, i._width = 0, i._height = 0, i._tint = null, i._tintRGB = null, i.tint = 16777215, i.blendMode = it.NORMAL, i._cachedTint = 16777215, i.uvs = null, i.texture = e || ot.EMPTY, i.vertexData = new Float32Array(8), i.vertexTrimmedData = null, i._transformID = -1, i._textureID = -1, i._transformTrimmedID = -1, i._textureTrimmedID = -1, i.indices = S_, i.pluginName = "batch", i.isSprite = !0, i._roundPixels = K.ROUND_PIXELS, i;
    }
    return t.prototype._onTextureUpdate = function() {
      this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = Ai(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = Ai(this.scale.y) * this._height / this._texture.orig.height);
    }, t.prototype._onAnchorUpdate = function() {
      this._transformID = -1, this._transformTrimmedID = -1;
    }, t.prototype.calculateVertices = function() {
      var e = this._texture;
      if (!(this._transformID === this.transform._worldID && this._textureID === e._updateID)) {
        this._textureID !== e._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = e._updateID;
        var i = this.transform.worldTransform, n = i.a, s = i.b, o = i.c, a = i.d, h = i.tx, l = i.ty, u = this.vertexData, c = e.trim, f = e.orig, d = this._anchor, p = 0, v = 0, _ = 0, m = 0;
        if (c ? (v = c.x - d._x * f.width, p = v + c.width, m = c.y - d._y * f.height, _ = m + c.height) : (v = -d._x * f.width, p = v + f.width, m = -d._y * f.height, _ = m + f.height), u[0] = n * v + o * m + h, u[1] = a * m + s * v + l, u[2] = n * p + o * m + h, u[3] = a * m + s * p + l, u[4] = n * p + o * _ + h, u[5] = a * _ + s * p + l, u[6] = n * v + o * _ + h, u[7] = a * _ + s * v + l, this._roundPixels)
          for (var y = K.RESOLUTION, b = 0; b < u.length; ++b)
            u[b] = Math.round((u[b] * y | 0) / y);
      }
    }, t.prototype.calculateTrimmedVertices = function() {
      if (!this.vertexTrimmedData)
        this.vertexTrimmedData = new Float32Array(8);
      else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
        return;
      this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
      var e = this._texture, i = this.vertexTrimmedData, n = e.orig, s = this._anchor, o = this.transform.worldTransform, a = o.a, h = o.b, l = o.c, u = o.d, c = o.tx, f = o.ty, d = -s._x * n.width, p = d + n.width, v = -s._y * n.height, _ = v + n.height;
      i[0] = a * d + l * v + c, i[1] = u * v + h * d + f, i[2] = a * p + l * v + c, i[3] = u * v + h * p + f, i[4] = a * p + l * _ + c, i[5] = u * _ + h * p + f, i[6] = a * d + l * _ + c, i[7] = u * _ + h * d + f;
    }, t.prototype._render = function(e) {
      this.calculateVertices(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this);
    }, t.prototype._calculateBounds = function() {
      var e = this._texture.trim, i = this._texture.orig;
      !e || e.width === i.width && e.height === i.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
    }, t.prototype.getLocalBounds = function(e) {
      return this.children.length === 0 ? (this._localBounds || (this._localBounds = new On()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new dt()), e = this._localBoundsRect), this._localBounds.getRectangle(e)) : r.prototype.getLocalBounds.call(this, e);
    }, t.prototype.containsPoint = function(e) {
      this.worldTransform.applyInverse(e, tr);
      var i = this._texture.orig.width, n = this._texture.orig.height, s = -i * this.anchor.x, o = 0;
      return tr.x >= s && tr.x < s + i && (o = -n * this.anchor.y, tr.y >= o && tr.y < o + n);
    }, t.prototype.destroy = function(e) {
      r.prototype.destroy.call(this, e), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null;
      var i = typeof e == "boolean" ? e : e && e.texture;
      if (i) {
        var n = typeof e == "boolean" ? e : e && e.baseTexture;
        this._texture.destroy(!!n);
      }
      this._texture = null;
    }, t.from = function(e, i) {
      var n = e instanceof ot ? e : ot.from(e, i);
      return new t(n);
    }, Object.defineProperty(t.prototype, "roundPixels", {
      get: function() {
        return this._roundPixels;
      },
      /**
       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
       *
       * Advantages can include sharper image quality (like text) and faster rendering on canvas.
       * The main disadvantage is movement of objects may appear less smooth.
       *
       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.
       * @default false
       */
      set: function(e) {
        this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "width", {
      /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
      },
      set: function(e) {
        var i = Ai(this.scale.x) || 1;
        this.scale.x = i * e / this._texture.orig.width, this._width = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
      },
      set: function(e) {
        var i = Ai(this.scale.y) || 1;
        this.scale.y = i * e / this._texture.orig.height, this._height = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "anchor", {
      /**
       * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}
       * and passed to the constructor.
       *
       * The default is `(0,0)`, this means the sprite's origin is the top left.
       *
       * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
       *
       * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
       *
       * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
       * @example
       * const sprite = new PIXI.Sprite(texture);
       * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
       */
      get: function() {
        return this._anchor;
      },
      set: function(e) {
        this._anchor.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      /**
       * The tint applied to the sprite. This is a hex value.
       *
       * A value of 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get: function() {
        return this._tint;
      },
      set: function(e) {
        this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "texture", {
      /** The texture that the sprite is using. */
      get: function() {
        return this._texture;
      },
      set: function(e) {
        this._texture !== e && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = e || ot.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, e && (e.baseTexture.valid ? this._onTextureUpdate() : e.once("update", this._onTextureUpdate, this)));
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ct)
);
/*!
 * @pixi/text - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/text is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Zs = function(r, t) {
  return Zs = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Zs(r, t);
};
function P_(r, t) {
  Zs(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var xr;
(function(r) {
  r[r.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", r[r.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL";
})(xr || (xr = {}));
var gs = {
  align: "left",
  breakWords: !1,
  dropShadow: !1,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: xr.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: !1,
  whiteSpace: "pre",
  wordWrap: !1,
  wordWrapWidth: 100,
  leading: 0
}, C_ = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
], Ci = (
  /** @class */
  function() {
    function r(t) {
      this.styleID = 0, this.reset(), xs(this, t, t);
    }
    return r.prototype.clone = function() {
      var t = {};
      return xs(t, this, gs), new r(t);
    }, r.prototype.reset = function() {
      xs(this, gs, gs);
    }, Object.defineProperty(r.prototype, "align", {
      /**
       * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
       *
       * @member {string}
       */
      get: function() {
        return this._align;
      },
      set: function(t) {
        this._align !== t && (this._align = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "breakWords", {
      /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
      get: function() {
        return this._breakWords;
      },
      set: function(t) {
        this._breakWords !== t && (this._breakWords = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadow", {
      /** Set a drop shadow for the text. */
      get: function() {
        return this._dropShadow;
      },
      set: function(t) {
        this._dropShadow !== t && (this._dropShadow = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadowAlpha", {
      /** Set alpha for the drop shadow. */
      get: function() {
        return this._dropShadowAlpha;
      },
      set: function(t) {
        this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadowAngle", {
      /** Set a angle of the drop shadow. */
      get: function() {
        return this._dropShadowAngle;
      },
      set: function(t) {
        this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadowBlur", {
      /** Set a shadow blur radius. */
      get: function() {
        return this._dropShadowBlur;
      },
      set: function(t) {
        this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadowColor", {
      /** A fill style to be used on the dropshadow e.g 'red', '#00FF00'. */
      get: function() {
        return this._dropShadowColor;
      },
      set: function(t) {
        var e = bs(t);
        this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadowDistance", {
      /** Set a distance of the drop shadow. */
      get: function() {
        return this._dropShadowDistance;
      },
      set: function(t) {
        this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fill", {
      /**
       * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
       *
       * Can be an array to create a gradient eg ['#000000','#FFFFFF']
       * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
       *
       * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
       */
      get: function() {
        return this._fill;
      },
      set: function(t) {
        var e = bs(t);
        this._fill !== e && (this._fill = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fillGradientType", {
      /**
       * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
       *
       * @see PIXI.TEXT_GRADIENT
       */
      get: function() {
        return this._fillGradientType;
      },
      set: function(t) {
        this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fillGradientStops", {
      /**
       * If fill is an array of colours to create a gradient, this array can set the stop points
       * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
       */
      get: function() {
        return this._fillGradientStops;
      },
      set: function(t) {
        I_(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fontFamily", {
      /** The font family. */
      get: function() {
        return this._fontFamily;
      },
      set: function(t) {
        this.fontFamily !== t && (this._fontFamily = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fontSize", {
      /**
       * The font size
       * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
       */
      get: function() {
        return this._fontSize;
      },
      set: function(t) {
        this._fontSize !== t && (this._fontSize = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fontStyle", {
      /**
       * The font style
       * ('normal', 'italic' or 'oblique')
       *
       * @member {string}
       */
      get: function() {
        return this._fontStyle;
      },
      set: function(t) {
        this._fontStyle !== t && (this._fontStyle = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fontVariant", {
      /**
       * The font variant
       * ('normal' or 'small-caps')
       *
       * @member {string}
       */
      get: function() {
        return this._fontVariant;
      },
      set: function(t) {
        this._fontVariant !== t && (this._fontVariant = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fontWeight", {
      /**
       * The font weight
       * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
       *
       * @member {string}
       */
      get: function() {
        return this._fontWeight;
      },
      set: function(t) {
        this._fontWeight !== t && (this._fontWeight = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "letterSpacing", {
      /** The amount of spacing between letters, default is 0. */
      get: function() {
        return this._letterSpacing;
      },
      set: function(t) {
        this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "lineHeight", {
      /** The line height, a number that represents the vertical space that a letter uses. */
      get: function() {
        return this._lineHeight;
      },
      set: function(t) {
        this._lineHeight !== t && (this._lineHeight = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "leading", {
      /** The space between lines. */
      get: function() {
        return this._leading;
      },
      set: function(t) {
        this._leading !== t && (this._leading = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "lineJoin", {
      /**
       * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
       * Default is 'miter' (creates a sharp corner).
       *
       * @member {string}
       */
      get: function() {
        return this._lineJoin;
      },
      set: function(t) {
        this._lineJoin !== t && (this._lineJoin = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "miterLimit", {
      /**
       * The miter limit to use when using the 'miter' lineJoin mode.
       *
       * This can reduce or increase the spikiness of rendered text.
       */
      get: function() {
        return this._miterLimit;
      },
      set: function(t) {
        this._miterLimit !== t && (this._miterLimit = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "padding", {
      /**
       * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
       * by adding padding to all sides of the text.
       */
      get: function() {
        return this._padding;
      },
      set: function(t) {
        this._padding !== t && (this._padding = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "stroke", {
      /**
       * A canvas fillstyle that will be used on the text stroke
       * e.g 'blue', '#FCFF00'
       */
      get: function() {
        return this._stroke;
      },
      set: function(t) {
        var e = bs(t);
        this._stroke !== e && (this._stroke = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "strokeThickness", {
      /**
       * A number that represents the thickness of the stroke.
       *
       * @default 0
       */
      get: function() {
        return this._strokeThickness;
      },
      set: function(t) {
        this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "textBaseline", {
      /**
       * The baseline of the text that is rendered.
       *
       * @member {string}
       */
      get: function() {
        return this._textBaseline;
      },
      set: function(t) {
        this._textBaseline !== t && (this._textBaseline = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "trim", {
      /** Trim transparent borders. */
      get: function() {
        return this._trim;
      },
      set: function(t) {
        this._trim !== t && (this._trim = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "whiteSpace", {
      /**
       * How newlines and spaces should be handled.
       * Default is 'pre' (preserve, preserve).
       *
       *  value       | New lines     |   Spaces
       *  ---         | ---           |   ---
       * 'normal'     | Collapse      |   Collapse
       * 'pre'        | Preserve      |   Preserve
       * 'pre-line'   | Preserve      |   Collapse
       *
       * @member {string}
       */
      get: function() {
        return this._whiteSpace;
      },
      set: function(t) {
        this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "wordWrap", {
      /** Indicates if word wrap should be used. */
      get: function() {
        return this._wordWrap;
      },
      set: function(t) {
        this._wordWrap !== t && (this._wordWrap = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "wordWrapWidth", {
      /** The width at which text will wrap, it needs wordWrap to be set to true. */
      get: function() {
        return this._wordWrapWidth;
      },
      set: function(t) {
        this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.toFontString = function() {
      var t = typeof this.fontSize == "number" ? this.fontSize + "px" : this.fontSize, e = this.fontFamily;
      Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
      for (var i = e.length - 1; i >= 0; i--) {
        var n = e[i].trim();
        !/([\"\'])[^\'\"]+\1/.test(n) && C_.indexOf(n) < 0 && (n = '"' + n + '"'), e[i] = n;
      }
      return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t + " " + e.join(",");
    }, r;
  }()
);
function qa(r) {
  return typeof r == "number" ? Oh(r) : (typeof r == "string" && r.indexOf("0x") === 0 && (r = r.replace("0x", "#")), r);
}
function bs(r) {
  if (Array.isArray(r)) {
    for (var t = 0; t < r.length; ++t)
      r[t] = qa(r[t]);
    return r;
  } else
    return qa(r);
}
function I_(r, t) {
  if (!Array.isArray(r) || !Array.isArray(t) || r.length !== t.length)
    return !1;
  for (var e = 0; e < r.length; ++e)
    if (r[e] !== t[e])
      return !1;
  return !0;
}
function xs(r, t, e) {
  for (var i in e)
    Array.isArray(t[i]) ? r[i] = t[i].slice() : r[i] = t[i];
}
var rn = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: !0
}, Ge = (
  /** @class */
  function() {
    function r(t, e, i, n, s, o, a, h, l) {
      this.text = t, this.style = e, this.width = i, this.height = n, this.lines = s, this.lineWidths = o, this.lineHeight = a, this.maxLineWidth = h, this.fontProperties = l;
    }
    return r.measureText = function(t, e, i, n) {
      n === void 0 && (n = r._canvas), i = i ?? e.wordWrap;
      var s = e.toFontString(), o = r.measureFont(s);
      o.fontSize === 0 && (o.fontSize = e.fontSize, o.ascent = e.fontSize);
      var a = n.getContext("2d", rn);
      a.font = s;
      for (var h = i ? r.wordWrap(t, e, n) : t, l = h.split(/(?:\r\n|\r|\n)/), u = new Array(l.length), c = 0, f = 0; f < l.length; f++) {
        var d = a.measureText(l[f]).width + (l[f].length - 1) * e.letterSpacing;
        u[f] = d, c = Math.max(c, d);
      }
      var p = c + e.strokeThickness;
      e.dropShadow && (p += e.dropShadowDistance);
      var v = e.lineHeight || o.fontSize + e.strokeThickness, _ = Math.max(v, o.fontSize + e.strokeThickness) + (l.length - 1) * (v + e.leading);
      return e.dropShadow && (_ += e.dropShadowDistance), new r(t, e, p, _, l, u, v + e.leading, c, o);
    }, r.wordWrap = function(t, e, i) {
      i === void 0 && (i = r._canvas);
      for (var n = i.getContext("2d", rn), s = 0, o = "", a = "", h = /* @__PURE__ */ Object.create(null), l = e.letterSpacing, u = e.whiteSpace, c = r.collapseSpaces(u), f = r.collapseNewlines(u), d = !c, p = e.wordWrapWidth + l, v = r.tokenize(t), _ = 0; _ < v.length; _++) {
        var m = v[_];
        if (r.isNewline(m)) {
          if (!f) {
            a += r.addLine(o), d = !c, o = "", s = 0;
            continue;
          }
          m = " ";
        }
        if (c) {
          var y = r.isBreakingSpace(m), b = r.isBreakingSpace(o[o.length - 1]);
          if (y && b)
            continue;
        }
        var P = r.getFromCache(m, l, h, n);
        if (P > p)
          if (o !== "" && (a += r.addLine(o), o = "", s = 0), r.canBreakWords(m, e.breakWords))
            for (var x = r.wordWrapSplit(m), T = 0; T < x.length; T++) {
              for (var I = x[T], w = 1; x[T + w]; ) {
                var O = x[T + w], R = I[I.length - 1];
                if (!r.canBreakChars(R, O, m, T, e.breakWords))
                  I += O;
                else
                  break;
                w++;
              }
              T += I.length - 1;
              var U = r.getFromCache(I, l, h, n);
              U + s > p && (a += r.addLine(o), d = !1, o = "", s = 0), o += I, s += U;
            }
          else {
            o.length > 0 && (a += r.addLine(o), o = "", s = 0);
            var q = _ === v.length - 1;
            a += r.addLine(m, !q), d = !1, o = "", s = 0;
          }
        else
          P + s > p && (d = !1, a += r.addLine(o), o = "", s = 0), (o.length > 0 || !r.isBreakingSpace(m) || d) && (o += m, s += P);
      }
      return a += r.addLine(o, !1), a;
    }, r.addLine = function(t, e) {
      return e === void 0 && (e = !0), t = r.trimRight(t), t = e ? t + `
` : t, t;
    }, r.getFromCache = function(t, e, i, n) {
      var s = i[t];
      if (typeof s != "number") {
        var o = t.length * e;
        s = n.measureText(t).width + o, i[t] = s;
      }
      return s;
    }, r.collapseSpaces = function(t) {
      return t === "normal" || t === "pre-line";
    }, r.collapseNewlines = function(t) {
      return t === "normal";
    }, r.trimRight = function(t) {
      if (typeof t != "string")
        return "";
      for (var e = t.length - 1; e >= 0; e--) {
        var i = t[e];
        if (!r.isBreakingSpace(i))
          break;
        t = t.slice(0, -1);
      }
      return t;
    }, r.isNewline = function(t) {
      return typeof t != "string" ? !1 : r._newlines.indexOf(t.charCodeAt(0)) >= 0;
    }, r.isBreakingSpace = function(t, e) {
      return typeof t != "string" ? !1 : r._breakingSpaces.indexOf(t.charCodeAt(0)) >= 0;
    }, r.tokenize = function(t) {
      var e = [], i = "";
      if (typeof t != "string")
        return e;
      for (var n = 0; n < t.length; n++) {
        var s = t[n], o = t[n + 1];
        if (r.isBreakingSpace(s, o) || r.isNewline(s)) {
          i !== "" && (e.push(i), i = ""), e.push(s);
          continue;
        }
        i += s;
      }
      return i !== "" && e.push(i), e;
    }, r.canBreakWords = function(t, e) {
      return e;
    }, r.canBreakChars = function(t, e, i, n, s) {
      return !0;
    }, r.wordWrapSplit = function(t) {
      return t.split("");
    }, r.measureFont = function(t) {
      if (r._fonts[t])
        return r._fonts[t];
      var e = {
        ascent: 0,
        descent: 0,
        fontSize: 0
      }, i = r._canvas, n = r._context;
      n.font = t;
      var s = r.METRICS_STRING + r.BASELINE_SYMBOL, o = Math.ceil(n.measureText(s).width), a = Math.ceil(n.measureText(r.BASELINE_SYMBOL).width), h = Math.ceil(r.HEIGHT_MULTIPLIER * a);
      a = a * r.BASELINE_MULTIPLIER | 0, i.width = o, i.height = h, n.fillStyle = "#f00", n.fillRect(0, 0, o, h), n.font = t, n.textBaseline = "alphabetic", n.fillStyle = "#000", n.fillText(s, 0, a);
      var l = n.getImageData(0, 0, o, h).data, u = l.length, c = o * 4, f = 0, d = 0, p = !1;
      for (f = 0; f < a; ++f) {
        for (var v = 0; v < c; v += 4)
          if (l[d + v] !== 255) {
            p = !0;
            break;
          }
        if (!p)
          d += c;
        else
          break;
      }
      for (e.ascent = a - f, d = u - c, p = !1, f = h; f > a; --f) {
        for (var v = 0; v < c; v += 4)
          if (l[d + v] !== 255) {
            p = !0;
            break;
          }
        if (!p)
          d -= c;
        else
          break;
      }
      return e.descent = f - a, e.fontSize = e.ascent + e.descent, r._fonts[t] = e, e;
    }, r.clearMetrics = function(t) {
      t === void 0 && (t = ""), t ? delete r._fonts[t] : r._fonts = {};
    }, Object.defineProperty(r, "_canvas", {
      /**
       * Cached canvas element for measuring text
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      get: function() {
        if (!r.__canvas) {
          var t = void 0;
          try {
            var e = new OffscreenCanvas(0, 0), i = e.getContext("2d", rn);
            if (i && i.measureText)
              return r.__canvas = e, e;
            t = K.ADAPTER.createCanvas();
          } catch {
            t = K.ADAPTER.createCanvas();
          }
          t.width = t.height = 10, r.__canvas = t;
        }
        return r.__canvas;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "_context", {
      /**
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      get: function() {
        return r.__context || (r.__context = r._canvas.getContext("2d", rn)), r.__context;
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
);
Ge._fonts = {};
Ge.METRICS_STRING = "|ÉqÅ";
Ge.BASELINE_SYMBOL = "M";
Ge.BASELINE_MULTIPLIER = 1.4;
Ge.HEIGHT_MULTIPLIER = 2;
Ge._newlines = [
  10,
  13
];
Ge._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
var O_ = {
  texture: !0,
  children: !1,
  baseTexture: !0
}, ko = (
  /** @class */
  function(r) {
    P_(t, r);
    function t(e, i, n) {
      var s = this, o = !1;
      n || (n = K.ADAPTER.createCanvas(), o = !0), n.width = 3, n.height = 3;
      var a = ot.from(n);
      return a.orig = new dt(), a.trim = new dt(), s = r.call(this, a) || this, s._ownCanvas = o, s.canvas = n, s.context = n.getContext("2d", {
        // required for trimming to work without warnings
        willReadFrequently: !0
      }), s._resolution = K.RESOLUTION, s._autoResolution = !0, s._text = null, s._style = null, s._styleListener = null, s._font = "", s.text = e, s.style = i, s.localStyleID = -1, s;
    }
    return t.prototype.updateText = function(e) {
      var i = this._style;
      if (this.localStyleID !== i.styleID && (this.dirty = !0, this.localStyleID = i.styleID), !(!this.dirty && e)) {
        this._font = this._style.toFontString();
        var n = this.context, s = Ge.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), o = s.width, a = s.height, h = s.lines, l = s.lineHeight, u = s.lineWidths, c = s.maxLineWidth, f = s.fontProperties;
        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, o) + i.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, a) + i.padding * 2) * this._resolution), n.scale(this._resolution, this._resolution), n.clearRect(0, 0, this.canvas.width, this.canvas.height), n.font = this._font, n.lineWidth = i.strokeThickness, n.textBaseline = i.textBaseline, n.lineJoin = i.lineJoin, n.miterLimit = i.miterLimit;
        for (var d, p, v = i.dropShadow ? 2 : 1, _ = 0; _ < v; ++_) {
          var m = i.dropShadow && _ === 0, y = m ? Math.ceil(Math.max(1, a) + i.padding * 2) : 0, b = y * this._resolution;
          if (m) {
            n.fillStyle = "black", n.strokeStyle = "black";
            var P = i.dropShadowColor, x = Gi(typeof P == "number" ? P : Mh(P)), T = i.dropShadowBlur * this._resolution, I = i.dropShadowDistance * this._resolution;
            n.shadowColor = "rgba(" + x[0] * 255 + "," + x[1] * 255 + "," + x[2] * 255 + "," + i.dropShadowAlpha + ")", n.shadowBlur = T, n.shadowOffsetX = Math.cos(i.dropShadowAngle) * I, n.shadowOffsetY = Math.sin(i.dropShadowAngle) * I + b;
          } else
            n.fillStyle = this._generateFillStyle(i, h, s), n.strokeStyle = i.stroke, n.shadowColor = "black", n.shadowBlur = 0, n.shadowOffsetX = 0, n.shadowOffsetY = 0;
          var w = (l - f.fontSize) / 2;
          (!t.nextLineHeightBehavior || l - f.fontSize < 0) && (w = 0);
          for (var O = 0; O < h.length; O++)
            d = i.strokeThickness / 2, p = i.strokeThickness / 2 + O * l + f.ascent + w, i.align === "right" ? d += c - u[O] : i.align === "center" && (d += (c - u[O]) / 2), i.stroke && i.strokeThickness && this.drawLetterSpacing(h[O], d + i.padding, p + i.padding - y, !0), i.fill && this.drawLetterSpacing(h[O], d + i.padding, p + i.padding - y);
        }
        this.updateTexture();
      }
    }, t.prototype.drawLetterSpacing = function(e, i, n, s) {
      s === void 0 && (s = !1);
      var o = this._style, a = o.letterSpacing, h = t.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
      if (a === 0 || h) {
        h && (this.context.letterSpacing = a, this.context.textLetterSpacing = a), s ? this.context.strokeText(e, i, n) : this.context.fillText(e, i, n);
        return;
      }
      for (var l = i, u = Array.from ? Array.from(e) : e.split(""), c = this.context.measureText(e).width, f = 0, d = 0; d < u.length; ++d) {
        var p = u[d];
        s ? this.context.strokeText(p, l, n) : this.context.fillText(p, l, n);
        for (var v = "", _ = d + 1; _ < u.length; ++_)
          v += u[_];
        f = this.context.measureText(v).width, l += c - f + a, c = f;
      }
    }, t.prototype.updateTexture = function() {
      var e = this.canvas;
      if (this._style.trim) {
        var i = Td(e);
        i.data && (e.width = i.width, e.height = i.height, this.context.putImageData(i.data, 0, 0));
      }
      var n = this._texture, s = this._style, o = s.trim ? 0 : s.padding, a = n.baseTexture;
      n.trim.width = n._frame.width = e.width / this._resolution, n.trim.height = n._frame.height = e.height / this._resolution, n.trim.x = -o, n.trim.y = -o, n.orig.width = n._frame.width - o * 2, n.orig.height = n._frame.height - o * 2, this._onTextureUpdate(), a.setRealSize(e.width, e.height, this._resolution), n.updateUvs(), this.dirty = !1;
    }, t.prototype._render = function(e) {
      this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), r.prototype._render.call(this, e);
    }, t.prototype.updateTransform = function() {
      this.updateText(!0), r.prototype.updateTransform.call(this);
    }, t.prototype.getBounds = function(e, i) {
      return this.updateText(!0), this._textureID === -1 && (e = !1), r.prototype.getBounds.call(this, e, i);
    }, t.prototype.getLocalBounds = function(e) {
      return this.updateText(!0), r.prototype.getLocalBounds.call(this, e);
    }, t.prototype._calculateBounds = function() {
      this.calculateVertices(), this._bounds.addQuad(this.vertexData);
    }, t.prototype._generateFillStyle = function(e, i, n) {
      var s = e.fill;
      if (Array.isArray(s)) {
        if (s.length === 1)
          return s[0];
      } else return s;
      var o, a = e.dropShadow ? e.dropShadowDistance : 0, h = e.padding || 0, l = this.canvas.width / this._resolution - a - h * 2, u = this.canvas.height / this._resolution - a - h * 2, c = s.slice(), f = e.fillGradientStops.slice();
      if (!f.length)
        for (var d = c.length + 1, p = 1; p < d; ++p)
          f.push(p / d);
      if (c.unshift(s[0]), f.unshift(0), c.push(s[s.length - 1]), f.push(1), e.fillGradientType === xr.LINEAR_VERTICAL) {
        o = this.context.createLinearGradient(l / 2, h, l / 2, u + h);
        for (var v = n.fontProperties.fontSize + e.strokeThickness, p = 0; p < i.length; p++) {
          var _ = n.lineHeight * (p - 1) + v, m = n.lineHeight * p, y = m;
          p > 0 && _ > m && (y = (m + _) / 2);
          var b = m + v, P = n.lineHeight * (p + 1), x = b;
          p + 1 < i.length && P < b && (x = (b + P) / 2);
          for (var T = (x - y) / u, I = 0; I < c.length; I++) {
            var w = 0;
            typeof f[I] == "number" ? w = f[I] : w = I / c.length;
            var O = Math.min(1, Math.max(0, y / u + w * T));
            O = Number(O.toFixed(5)), o.addColorStop(O, c[I]);
          }
        }
      } else {
        o = this.context.createLinearGradient(h, u / 2, l + h, u / 2);
        for (var R = c.length + 1, U = 1, p = 0; p < c.length; p++) {
          var q = void 0;
          typeof f[p] == "number" ? q = f[p] : q = U / R, o.addColorStop(q, c[p]), U++;
        }
      }
      return o;
    }, t.prototype.destroy = function(e) {
      typeof e == "boolean" && (e = { children: e }), e = Object.assign({}, O_, e), r.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;
    }, Object.defineProperty(t.prototype, "width", {
      /** The width of the Text, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;
      },
      set: function(e) {
        this.updateText(!0);
        var i = Ai(this.scale.x) || 1;
        this.scale.x = i * e / this._texture.orig.width, this._width = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the Text, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;
      },
      set: function(e) {
        this.updateText(!0);
        var i = Ai(this.scale.y) || 1;
        this.scale.y = i * e / this._texture.orig.height, this._height = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "style", {
      /**
       * Set the style of the text.
       *
       * Set up an event listener to listen for changes on the style object and mark the text as dirty.
       */
      get: function() {
        return this._style;
      },
      set: function(e) {
        e = e || {}, e instanceof Ci ? this._style = e : this._style = new Ci(e), this.localStyleID = -1, this.dirty = !0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "text", {
      /** Set the copy for the text object. To split a line you can use '\n'. */
      get: function() {
        return this._text;
      },
      set: function(e) {
        e = String(e ?? ""), this._text !== e && (this._text = e, this.dirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "resolution", {
      /**
       * The resolution / device pixel ratio of the canvas.
       *
       * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
       * @default 1
       */
      get: function() {
        return this._resolution;
      },
      set: function(e) {
        this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), t.nextLineHeightBehavior = !1, t.experimentalLetterSpacing = !1, t;
  }(Bt)
);
/*!
 * @pixi/prepare - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/prepare is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
K.UPLOADS_PER_FRAME = 4;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ks = function(r, t) {
  return Ks = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Ks(r, t);
};
function M_(r, t) {
  Ks(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var R_ = (
  /** @class */
  function() {
    function r(t) {
      this.maxItemsPerFrame = t, this.itemsLeft = 0;
    }
    return r.prototype.beginFrame = function() {
      this.itemsLeft = this.maxItemsPerFrame;
    }, r.prototype.allowedToUpload = function() {
      return this.itemsLeft-- > 0;
    }, r;
  }()
);
function k_(r, t) {
  var e = !1;
  if (r && r._textures && r._textures.length) {
    for (var i = 0; i < r._textures.length; i++)
      if (r._textures[i] instanceof ot) {
        var n = r._textures[i].baseTexture;
        t.indexOf(n) === -1 && (t.push(n), e = !0);
      }
  }
  return e;
}
function N_(r, t) {
  if (r.baseTexture instanceof gt) {
    var e = r.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function A_(r, t) {
  if (r._texture && r._texture instanceof ot) {
    var e = r._texture.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function D_(r, t) {
  return t instanceof ko ? (t.updateText(!0), !0) : !1;
}
function L_(r, t) {
  if (t instanceof Ci) {
    var e = t.toFontString();
    return Ge.measureFont(e), !0;
  }
  return !1;
}
function F_(r, t) {
  if (r instanceof ko) {
    t.indexOf(r.style) === -1 && t.push(r.style), t.indexOf(r) === -1 && t.push(r);
    var e = r._texture.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function B_(r, t) {
  return r instanceof Ci ? (t.indexOf(r) === -1 && t.push(r), !0) : !1;
}
var U_ = (
  /** @class */
  function() {
    function r(t) {
      var e = this;
      this.limiter = new R_(K.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function() {
        e.queue && e.prepareItems();
      }, this.registerFindHook(F_), this.registerFindHook(B_), this.registerFindHook(k_), this.registerFindHook(N_), this.registerFindHook(A_), this.registerUploadHook(D_), this.registerUploadHook(L_);
    }
    return r.prototype.upload = function(t, e) {
      var i = this;
      return typeof t == "function" && (e = t, t = null), e && Te("6.5.0", "BasePrepare.upload callback is deprecated, use the return Promise instead."), new Promise(function(n) {
        t && i.add(t);
        var s = function() {
          e?.(), n();
        };
        i.queue.length ? (i.completes.push(s), i.ticking || (i.ticking = !0, Lt.system.addOnce(i.tick, i, Ze.UTILITY))) : s();
      });
    }, r.prototype.tick = function() {
      setTimeout(this.delayedTick, 0);
    }, r.prototype.prepareItems = function() {
      for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
        var t = this.queue[0], e = !1;
        if (t && !t._destroyed) {
          for (var i = 0, n = this.uploadHooks.length; i < n; i++)
            if (this.uploadHooks[i](this.uploadHookHelper, t)) {
              this.queue.shift(), e = !0;
              break;
            }
        }
        e || this.queue.shift();
      }
      if (this.queue.length)
        Lt.system.addOnce(this.tick, this, Ze.UTILITY);
      else {
        this.ticking = !1;
        var s = this.completes.slice(0);
        this.completes.length = 0;
        for (var i = 0, n = s.length; i < n; i++)
          s[i]();
      }
    }, r.prototype.registerFindHook = function(t) {
      return t && this.addHooks.push(t), this;
    }, r.prototype.registerUploadHook = function(t) {
      return t && this.uploadHooks.push(t), this;
    }, r.prototype.add = function(t) {
      for (var e = 0, i = this.addHooks.length; e < i && !this.addHooks[e](t, this.queue); e++)
        ;
      if (t instanceof Ct)
        for (var e = t.children.length - 1; e >= 0; e--)
          this.add(t.children[e]);
      return this;
    }, r.prototype.destroy = function() {
      this.ticking && Lt.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;
    }, r;
  }()
);
function hl(r, t) {
  return t instanceof gt ? (t._glTextures[r.CONTEXT_UID] || r.texture.bind(t), !0) : !1;
}
function G_(r, t) {
  if (!(t instanceof se))
    return !1;
  var e = t.geometry;
  t.finishPoly(), e.updateBatches();
  for (var i = e.batches, n = 0; n < i.length; n++) {
    var s = i[n].style.texture;
    s && hl(r, s.baseTexture);
  }
  return e.batchable || r.geometry.bind(e, t._resolveDirectShader(r)), !0;
}
function j_(r, t) {
  return r instanceof se ? (t.push(r), !0) : !1;
}
var H_ = (
  /** @class */
  function(r) {
    M_(t, r);
    function t(e) {
      var i = r.call(this, e) || this;
      return i.uploadHookHelper = i.renderer, i.registerFindHook(j_), i.registerUploadHook(hl), i.registerUploadHook(G_), i;
    }
    return t.extension = {
      name: "prepare",
      type: St.RendererPlugin
    }, t;
  }(U_)
);
/*!
 * @pixi/spritesheet - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/spritesheet is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var $_ = (
  /** @class */
  function() {
    function r(t, e, i) {
      i === void 0 && (i = null), this.linkedSheets = [], this._texture = t instanceof ot ? t : null, this.baseTexture = t instanceof gt ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;
      var n = this.baseTexture.resource;
      this.resolution = this._updateResolution(i || (n ? n.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
    }
    return r.prototype._updateResolution = function(t) {
      t === void 0 && (t = null);
      var e = this.data.meta.scale, i = Cn(t, null);
      return i === null && (i = e !== void 0 ? parseFloat(e) : 1), i !== 1 && this.baseTexture.setResolution(i), i;
    }, r.prototype.parse = function(t) {
      var e = this;
      return t && Te("6.5.0", "Spritesheet.parse callback is deprecated, use the return Promise instead."), new Promise(function(i) {
        e._callback = function(n) {
          t?.(n), i(n);
        }, e._batchIndex = 0, e._frameKeys.length <= r.BATCH_SIZE ? (e._processFrames(0), e._processAnimations(), e._parseComplete()) : e._nextBatch();
      });
    }, r.prototype._processFrames = function(t) {
      for (var e = t, i = r.BATCH_SIZE; e - t < i && e < this._frameKeys.length; ) {
        var n = this._frameKeys[e], s = this._frames[n], o = s.frame;
        if (o) {
          var a = null, h = null, l = s.trimmed !== !1 && s.sourceSize ? s.sourceSize : s.frame, u = new dt(0, 0, Math.floor(l.w) / this.resolution, Math.floor(l.h) / this.resolution);
          s.rotated ? a = new dt(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.h) / this.resolution, Math.floor(o.w) / this.resolution) : a = new dt(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution), s.trimmed !== !1 && s.spriteSourceSize && (h = new dt(Math.floor(s.spriteSourceSize.x) / this.resolution, Math.floor(s.spriteSourceSize.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution)), this.textures[n] = new ot(this.baseTexture, a, u, h, s.rotated ? 2 : 0, s.anchor), ot.addToCache(this.textures[n], n);
        }
        e++;
      }
    }, r.prototype._processAnimations = function() {
      var t = this.data.animations || {};
      for (var e in t) {
        this.animations[e] = [];
        for (var i = 0; i < t[e].length; i++) {
          var n = t[e][i];
          this.animations[e].push(this.textures[n]);
        }
      }
    }, r.prototype._parseComplete = function() {
      var t = this._callback;
      this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
    }, r.prototype._nextBatch = function() {
      var t = this;
      this._processFrames(this._batchIndex * r.BATCH_SIZE), this._batchIndex++, setTimeout(function() {
        t._batchIndex * r.BATCH_SIZE < t._frameKeys.length ? t._nextBatch() : (t._processAnimations(), t._parseComplete());
      }, 0);
    }, r.prototype.destroy = function(t) {
      var e;
      t === void 0 && (t = !1);
      for (var i in this.textures)
        this.textures[i].destroy();
      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) === null || e === void 0 || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];
    }, r.BATCH_SIZE = 1e3, r;
  }()
), z_ = (
  /** @class */
  function() {
    function r() {
    }
    return r.use = function(t, e) {
      var i, n, s = this, o = t.name + "_image";
      if (!t.data || t.type !== ft.TYPE.JSON || !t.data.frames || s.resources[o]) {
        e();
        return;
      }
      var a = (n = (i = t.data) === null || i === void 0 ? void 0 : i.meta) === null || n === void 0 ? void 0 : n.related_multi_packs;
      if (Array.isArray(a))
        for (var h = function(p) {
          if (typeof p != "string")
            return "continue";
          var v = p.replace(".json", ""), _ = Ni.resolve(t.url.replace(s.baseUrl, ""), p);
          if (s.resources[v] || Object.values(s.resources).some(function(y) {
            return Ni.format(Ni.parse(y.url)) === _;
          }))
            return "continue";
          var m = {
            crossOrigin: t.crossOrigin,
            loadType: ft.LOAD_TYPE.XHR,
            xhrType: ft.XHR_RESPONSE_TYPE.JSON,
            parentResource: t,
            metadata: t.metadata
          };
          s.add(v, _, m);
        }, l = 0, u = a; l < u.length; l++) {
          var c = u[l];
          h(c);
        }
      var f = {
        crossOrigin: t.crossOrigin,
        metadata: t.metadata.imageMetadata,
        parentResource: t
      }, d = r.getResourcePath(t, s.baseUrl);
      s.add(o, d, f, function(v) {
        if (v.error) {
          e(v.error);
          return;
        }
        var _ = new $_(v.texture, t.data, t.url);
        _.parse().then(function() {
          t.spritesheet = _, t.textures = _.textures, e();
        });
      });
    }, r.getResourcePath = function(t, e) {
      return t.isDataUrl ? t.data.meta.image : Ni.resolve(t.url.replace(e, ""), t.data.meta.image);
    }, r.extension = St.Loader, r;
  }()
);
/*!
 * @pixi/sprite-tiling - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Js = function(r, t) {
  return Js = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Js(r, t);
};
function ll(r, t) {
  Js(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var er = new Ot();
(function(r) {
  ll(t, r);
  function t(e, i, n) {
    i === void 0 && (i = 100), n === void 0 && (n = 100);
    var s = r.call(this, e) || this;
    return s.tileTransform = new Fh(), s._width = i, s._height = n, s.uvMatrix = s.texture.uvMatrix || new Mo(e), s.pluginName = "tilingSprite", s.uvRespectAnchor = !1, s;
  }
  return Object.defineProperty(t.prototype, "clampMargin", {
    /**
     * Changes frame clamping in corresponding textureTransform, shortcut
     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
     * @default 0.5
     * @member {number}
     */
    get: function() {
      return this.uvMatrix.clampMargin;
    },
    set: function(e) {
      this.uvMatrix.clampMargin = e, this.uvMatrix.update(!0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tileScale", {
    /** The scaling of the image that is being tiled. */
    get: function() {
      return this.tileTransform.scale;
    },
    set: function(e) {
      this.tileTransform.scale.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tilePosition", {
    /** The offset of the image that is being tiled. */
    get: function() {
      return this.tileTransform.position;
    },
    set: function(e) {
      this.tileTransform.position.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._onTextureUpdate = function() {
    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;
  }, t.prototype._render = function(e) {
    var i = this._texture;
    !i || !i.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this));
  }, t.prototype._calculateBounds = function() {
    var e = this._width * -this._anchor._x, i = this._height * -this._anchor._y, n = this._width * (1 - this._anchor._x), s = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, e, i, n, s);
  }, t.prototype.getLocalBounds = function(e) {
    return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new dt()), e = this._localBoundsRect), this._bounds.getRectangle(e)) : r.prototype.getLocalBounds.call(this, e);
  }, t.prototype.containsPoint = function(e) {
    this.worldTransform.applyInverse(e, er);
    var i = this._width, n = this._height, s = -i * this.anchor._x;
    if (er.x >= s && er.x < s + i) {
      var o = -n * this.anchor._y;
      if (er.y >= o && er.y < o + n)
        return !0;
    }
    return !1;
  }, t.prototype.destroy = function(e) {
    r.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null;
  }, t.from = function(e, i) {
    var n = e instanceof ot ? e : ot.from(e, i);
    return new t(n, i.width, i.height);
  }, Object.defineProperty(t.prototype, "width", {
    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this._width;
    },
    set: function(e) {
      this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this._height;
    },
    set: function(e) {
      this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Bt);
var X_ = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`, Za = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, V_ = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`, W_ = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, Y_ = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`, nn = new Vt(), q_ = (
  /** @class */
  function(r) {
    ll(t, r);
    function t(e) {
      var i = r.call(this, e) || this;
      return e.runners.contextChange.add(i), i.quad = new zh(), i.state = Oi.for2d(), i;
    }
    return t.prototype.contextChange = function() {
      var e = this.renderer, i = { globals: e.globalUniforms };
      this.simpleShader = hi.from(Za, X_, i), this.shader = e.context.webGLVersion > 1 ? hi.from(W_, Y_, i) : hi.from(Za, V_, i);
    }, t.prototype.render = function(e) {
      var i = this.renderer, n = this.quad, s = n.vertices;
      s[0] = s[6] = e._width * -e.anchor.x, s[1] = s[3] = e._height * -e.anchor.y, s[2] = s[4] = e._width * (1 - e.anchor.x), s[5] = s[7] = e._height * (1 - e.anchor.y);
      var o = e.uvRespectAnchor ? e.anchor.x : 0, a = e.uvRespectAnchor ? e.anchor.y : 0;
      s = n.uvs, s[0] = s[6] = -o, s[1] = s[3] = -a, s[2] = s[4] = 1 - o, s[5] = s[7] = 1 - a, n.invalidate();
      var h = e._texture, l = h.baseTexture, u = l.alphaMode > 0, c = e.tileTransform.localTransform, f = e.uvMatrix, d = l.isPowerOfTwo && h.frame.width === l.width && h.frame.height === l.height;
      d && (l._glTextures[i.CONTEXT_UID] ? d = l.wrapMode !== ke.CLAMP : l.wrapMode === ke.CLAMP && (l.wrapMode = ke.REPEAT));
      var p = d ? this.simpleShader : this.shader, v = h.width, _ = h.height, m = e._width, y = e._height;
      nn.set(c.a * v / m, c.b * v / y, c.c * _ / m, c.d * _ / y, c.tx / m, c.ty / y), nn.invert(), d ? nn.prepend(f.mapCoord) : (p.uniforms.uMapCoord = f.mapCoord.toArray(!0), p.uniforms.uClampFrame = f.uClampFrame, p.uniforms.uClampOffset = f.uClampOffset), p.uniforms.uTransform = nn.toArray(!0), p.uniforms.uColor = Nh(e.tint, e.worldAlpha, p.uniforms.uColor, u), p.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0), p.uniforms.uSampler = h, i.shader.bind(p), i.geometry.bind(n), this.state.blendMode = kh(e.blendMode, u), i.state.set(this.state), i.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    }, t.extension = {
      name: "tilingSprite",
      type: St.RendererPlugin
    }, t;
  }(Bn)
);
/*!
 * @pixi/mesh - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mesh is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Qs = function(r, t) {
  return Qs = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Qs(r, t);
};
function No(r, t) {
  Qs(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Z_ = (
  /** @class */
  function() {
    function r(t, e) {
      this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;
    }
    return r.prototype.update = function(t) {
      if (!(!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)) {
        this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
        var e = this.uvBuffer.data;
        (!this.data || this.data.length !== e.length) && (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++;
      }
    }, r;
  }()
), ws = new Ot(), Ka = new cn(), wr = (
  /** @class */
  function(r) {
    No(t, r);
    function t(e, i, n, s) {
      s === void 0 && (s = we.TRIANGLES);
      var o = r.call(this) || this;
      return o.geometry = e, o.shader = i, o.state = n || Oi.for2d(), o.drawMode = s, o.start = 0, o.size = 0, o.uvs = null, o.indices = null, o.vertexData = new Float32Array(1), o.vertexDirty = -1, o._transformID = -1, o._roundPixels = K.ROUND_PIXELS, o.batchUvs = null, o;
    }
    return Object.defineProperty(t.prototype, "geometry", {
      /**
       * Includes vertex positions, face indices, normals, colors, UVs, and
       * custom attributes within buffers, reducing the cost of passing all
       * this data to the GPU. Can be shared between multiple Mesh objects.
       */
      get: function() {
        return this._geometry;
      },
      set: function(e) {
        this._geometry !== e && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "uvBuffer", {
      /**
       * To change mesh uv's, change its uvBuffer data and increment its _updateID.
       * @readonly
       */
      get: function() {
        return this.geometry.buffers[1];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "verticesBuffer", {
      /**
       * To change mesh vertices, change its uvBuffer data and increment its _updateID.
       * Incrementing _updateID is optional because most of Mesh objects do it anyway.
       * @readonly
       */
      get: function() {
        return this.geometry.buffers[0];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "material", {
      get: function() {
        return this.shader;
      },
      /** Alias for {@link PIXI.Mesh#shader}. */
      set: function(e) {
        this.shader = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "blendMode", {
      get: function() {
        return this.state.blendMode;
      },
      /**
       * The blend mode to be applied to the Mesh. Apply a value of
       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * @default PIXI.BLEND_MODES.NORMAL;
       */
      set: function(e) {
        this.state.blendMode = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "roundPixels", {
      get: function() {
        return this._roundPixels;
      },
      /**
       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
       * Advantages can include sharper image quality (like text) and faster rendering on canvas.
       * The main disadvantage is movement of objects may appear less smooth.
       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
       * @default false
       */
      set: function(e) {
        this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      /**
       * The multiply tint applied to the Mesh. This is a hex value. A value of
       * `0xFFFFFF` will remove any tint effect.
       *
       * Null for non-MeshMaterial shaders
       * @default 0xFFFFFF
       */
      get: function() {
        return "tint" in this.shader ? this.shader.tint : null;
      },
      set: function(e) {
        this.shader.tint = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "texture", {
      /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
      get: function() {
        return "texture" in this.shader ? this.shader.texture : null;
      },
      set: function(e) {
        this.shader.texture = e;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype._render = function(e) {
      var i = this.geometry.buffers[0].data, n = this.shader;
      n.batchable && this.drawMode === we.TRIANGLES && i.length < t.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e);
    }, t.prototype._renderDefault = function(e) {
      var i = this.shader;
      i.alpha = this.worldAlpha, i.update && i.update(), e.batch.flush(), i.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(i), e.state.set(this.state), e.geometry.bind(this.geometry, i), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    }, t.prototype._renderToBatch = function(e) {
      var i = this.geometry, n = this.shader;
      n.uvMatrix && (n.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = i.indexBuffer.data, this._tintRGB = n._tintRGB, this._texture = n.texture;
      var s = this.material.pluginName;
      e.batch.setObjectRenderer(e.plugins[s]), e.plugins[s].render(this);
    }, t.prototype.calculateVertices = function() {
      var e = this.geometry, i = e.buffers[0], n = i.data, s = i._updateID;
      if (!(s === this.vertexDirty && this._transformID === this.transform._worldID)) {
        this._transformID = this.transform._worldID, this.vertexData.length !== n.length && (this.vertexData = new Float32Array(n.length));
        for (var o = this.transform.worldTransform, a = o.a, h = o.b, l = o.c, u = o.d, c = o.tx, f = o.ty, d = this.vertexData, p = 0; p < d.length / 2; p++) {
          var v = n[p * 2], _ = n[p * 2 + 1];
          d[p * 2] = a * v + l * _ + c, d[p * 2 + 1] = h * v + u * _ + f;
        }
        if (this._roundPixels)
          for (var m = K.RESOLUTION, p = 0; p < d.length; ++p)
            d[p] = Math.round((d[p] * m | 0) / m);
        this.vertexDirty = s;
      }
    }, t.prototype.calculateUvs = function() {
      var e = this.geometry.buffers[1], i = this.shader;
      i.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new Z_(e, i.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);
    }, t.prototype._calculateBounds = function() {
      this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    }, t.prototype.containsPoint = function(e) {
      if (!this.getBounds().contains(e.x, e.y))
        return !1;
      this.worldTransform.applyInverse(e, ws);
      for (var i = this.geometry.getBuffer("aVertexPosition").data, n = Ka.points, s = this.geometry.getIndex().data, o = s.length, a = this.drawMode === 4 ? 3 : 1, h = 0; h + 2 < o; h += a) {
        var l = s[h] * 2, u = s[h + 1] * 2, c = s[h + 2] * 2;
        if (n[0] = i[l], n[1] = i[l + 1], n[2] = i[u], n[3] = i[u + 1], n[4] = i[c], n[5] = i[c + 1], Ka.contains(ws.x, ws.y))
          return !0;
      }
      return !1;
    }, t.prototype.destroy = function(e) {
      r.prototype.destroy.call(this, e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;
    }, t.BATCHABLE_SIZE = 100, t;
  }(Ct)
), K_ = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`, J_ = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`, Tr = (
  /** @class */
  function(r) {
    No(t, r);
    function t(e, i) {
      var n = this, s = {
        uSampler: e,
        alpha: 1,
        uTextureMatrix: Vt.IDENTITY,
        uColor: new Float32Array([1, 1, 1, 1])
      };
      return i = Object.assign({
        tint: 16777215,
        alpha: 1,
        pluginName: "batch"
      }, i), i.uniforms && Object.assign(s, i.uniforms), n = r.call(this, i.program || kr.from(J_, K_), s) || this, n._colorDirty = !1, n.uvMatrix = new Mo(e), n.batchable = i.program === void 0, n.pluginName = i.pluginName, n.tint = i.tint, n.alpha = i.alpha, n;
    }
    return Object.defineProperty(t.prototype, "texture", {
      /** Reference to the texture being rendered. */
      get: function() {
        return this.uniforms.uSampler;
      },
      set: function(e) {
        this.uniforms.uSampler !== e && (!this.uniforms.uSampler.baseTexture.alphaMode != !e.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = e, this.uvMatrix.texture = e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "alpha", {
      get: function() {
        return this._alpha;
      },
      /**
       * This gets automatically set by the object using this.
       * @default 1
       */
      set: function(e) {
        e !== this._alpha && (this._alpha = e, this._colorDirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      get: function() {
        return this._tint;
      },
      /**
       * Multiply tint for the material.
       * @default 0xFFFFFF
       */
      set: function(e) {
        e !== this._tint && (this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16), this._colorDirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.update = function() {
      if (this._colorDirty) {
        this._colorDirty = !1;
        var e = this.texture.baseTexture;
        Nh(this._tint, this._alpha, this.uniforms.uColor, e.alphaMode);
      }
      this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
    }, t;
  }(hi)
), Un = (
  /** @class */
  function(r) {
    No(t, r);
    function t(e, i, n) {
      var s = r.call(this) || this, o = new Xt(e), a = new Xt(i, !0), h = new Xt(n, !0, !0);
      return s.addAttribute("aVertexPosition", o, 2, !1, st.FLOAT).addAttribute("aTextureCoord", a, 2, !1, st.FLOAT).addIndex(h), s._updateId = -1, s;
    }
    return Object.defineProperty(t.prototype, "vertexDirtyId", {
      /**
       * If the vertex position is updated.
       * @readonly
       * @private
       */
      get: function() {
        return this.buffers[0]._updateID;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Rr)
);
/*!
 * @pixi/text-bitmap - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/text-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var to = function(r, t) {
  return to = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, to(r, t);
};
function Q_(r, t) {
  to(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var kn = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];
    }
    return r;
  }()
), tm = (
  /** @class */
  function() {
    function r() {
    }
    return r.test = function(t) {
      return typeof t == "string" && t.indexOf("info face=") === 0;
    }, r.parse = function(t) {
      var e = t.match(/^[a-z]+\s+.+$/gm), i = {
        info: [],
        common: [],
        page: [],
        char: [],
        chars: [],
        kerning: [],
        kernings: [],
        distanceField: []
      };
      for (var n in e) {
        var s = e[n].match(/^[a-z]+/gm)[0], o = e[n].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), a = {};
        for (var h in o) {
          var l = o[h].split("="), u = l[0], c = l[1].replace(/"/gm, ""), f = parseFloat(c), d = isNaN(f) ? c : f;
          a[u] = d;
        }
        i[s].push(a);
      }
      var p = new kn();
      return i.info.forEach(function(v) {
        return p.info.push({
          face: v.face,
          size: parseInt(v.size, 10)
        });
      }), i.common.forEach(function(v) {
        return p.common.push({
          lineHeight: parseInt(v.lineHeight, 10)
        });
      }), i.page.forEach(function(v) {
        return p.page.push({
          id: parseInt(v.id, 10),
          file: v.file
        });
      }), i.char.forEach(function(v) {
        return p.char.push({
          id: parseInt(v.id, 10),
          page: parseInt(v.page, 10),
          x: parseInt(v.x, 10),
          y: parseInt(v.y, 10),
          width: parseInt(v.width, 10),
          height: parseInt(v.height, 10),
          xoffset: parseInt(v.xoffset, 10),
          yoffset: parseInt(v.yoffset, 10),
          xadvance: parseInt(v.xadvance, 10)
        });
      }), i.kerning.forEach(function(v) {
        return p.kerning.push({
          first: parseInt(v.first, 10),
          second: parseInt(v.second, 10),
          amount: parseInt(v.amount, 10)
        });
      }), i.distanceField.forEach(function(v) {
        return p.distanceField.push({
          distanceRange: parseInt(v.distanceRange, 10),
          fieldType: v.fieldType
        });
      }), p;
    }, r;
  }()
), eo = (
  /** @class */
  function() {
    function r() {
    }
    return r.test = function(t) {
      return t instanceof XMLDocument && t.getElementsByTagName("page").length && t.getElementsByTagName("info")[0].getAttribute("face") !== null;
    }, r.parse = function(t) {
      for (var e = new kn(), i = t.getElementsByTagName("info"), n = t.getElementsByTagName("common"), s = t.getElementsByTagName("page"), o = t.getElementsByTagName("char"), a = t.getElementsByTagName("kerning"), h = t.getElementsByTagName("distanceField"), l = 0; l < i.length; l++)
        e.info.push({
          face: i[l].getAttribute("face"),
          size: parseInt(i[l].getAttribute("size"), 10)
        });
      for (var l = 0; l < n.length; l++)
        e.common.push({
          lineHeight: parseInt(n[l].getAttribute("lineHeight"), 10)
        });
      for (var l = 0; l < s.length; l++)
        e.page.push({
          id: parseInt(s[l].getAttribute("id"), 10) || 0,
          file: s[l].getAttribute("file")
        });
      for (var l = 0; l < o.length; l++) {
        var u = o[l];
        e.char.push({
          id: parseInt(u.getAttribute("id"), 10),
          page: parseInt(u.getAttribute("page"), 10) || 0,
          x: parseInt(u.getAttribute("x"), 10),
          y: parseInt(u.getAttribute("y"), 10),
          width: parseInt(u.getAttribute("width"), 10),
          height: parseInt(u.getAttribute("height"), 10),
          xoffset: parseInt(u.getAttribute("xoffset"), 10),
          yoffset: parseInt(u.getAttribute("yoffset"), 10),
          xadvance: parseInt(u.getAttribute("xadvance"), 10)
        });
      }
      for (var l = 0; l < a.length; l++)
        e.kerning.push({
          first: parseInt(a[l].getAttribute("first"), 10),
          second: parseInt(a[l].getAttribute("second"), 10),
          amount: parseInt(a[l].getAttribute("amount"), 10)
        });
      for (var l = 0; l < h.length; l++)
        e.distanceField.push({
          fieldType: h[l].getAttribute("fieldType"),
          distanceRange: parseInt(h[l].getAttribute("distanceRange"), 10)
        });
      return e;
    }, r;
  }()
), em = (
  /** @class */
  function() {
    function r() {
    }
    return r.test = function(t) {
      if (typeof t == "string" && t.indexOf("<font>") > -1) {
        var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
        return eo.test(e);
      }
      return !1;
    }, r.parse = function(t) {
      var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
      return eo.parse(e);
    }, r;
  }()
), Ts = [
  tm,
  eo,
  em
];
function ul(r) {
  for (var t = 0; t < Ts.length; t++)
    if (Ts[t].test(r))
      return Ts[t];
  return null;
}
function im(r, t, e, i, n, s) {
  var o = e.fill;
  if (Array.isArray(o)) {
    if (o.length === 1)
      return o[0];
  } else return o;
  var a, h = e.dropShadow ? e.dropShadowDistance : 0, l = e.padding || 0, u = r.width / i - h - l * 2, c = r.height / i - h - l * 2, f = o.slice(), d = e.fillGradientStops.slice();
  if (!d.length)
    for (var p = f.length + 1, v = 1; v < p; ++v)
      d.push(v / p);
  if (f.unshift(o[0]), d.unshift(0), f.push(o[o.length - 1]), d.push(1), e.fillGradientType === xr.LINEAR_VERTICAL) {
    a = t.createLinearGradient(u / 2, l, u / 2, c + l);
    for (var _ = 0, m = s.fontProperties.fontSize + e.strokeThickness, y = m / c, v = 0; v < n.length; v++)
      for (var b = s.lineHeight * v, P = 0; P < f.length; P++) {
        var x = 0;
        typeof d[P] == "number" ? x = d[P] : x = P / f.length;
        var T = b / c + x * y, I = Math.max(_, T);
        I = Math.min(I, 1), a.addColorStop(I, f[P]), _ = I;
      }
  } else {
    a = t.createLinearGradient(l, c / 2, u + l, c / 2);
    for (var w = f.length + 1, O = 1, v = 0; v < f.length; v++) {
      var R = void 0;
      typeof d[v] == "number" ? R = d[v] : R = O / w, a.addColorStop(R, f[v]), O++;
    }
  }
  return a;
}
function rm(r, t, e, i, n, s, o) {
  var a = e.text, h = e.fontProperties;
  t.translate(i, n), t.scale(s, s);
  var l = o.strokeThickness / 2, u = -(o.strokeThickness / 2);
  if (t.font = o.toFontString(), t.lineWidth = o.strokeThickness, t.textBaseline = o.textBaseline, t.lineJoin = o.lineJoin, t.miterLimit = o.miterLimit, t.fillStyle = im(r, t, o, s, [a], e), t.strokeStyle = o.stroke, o.dropShadow) {
    var c = o.dropShadowColor, f = Gi(typeof c == "number" ? c : Mh(c)), d = o.dropShadowBlur * s, p = o.dropShadowDistance * s;
    t.shadowColor = "rgba(" + f[0] * 255 + "," + f[1] * 255 + "," + f[2] * 255 + "," + o.dropShadowAlpha + ")", t.shadowBlur = d, t.shadowOffsetX = Math.cos(o.dropShadowAngle) * p, t.shadowOffsetY = Math.sin(o.dropShadowAngle) * p;
  } else
    t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
  o.stroke && o.strokeThickness && t.strokeText(a, l, u + e.lineHeight - h.descent), o.fill && t.fillText(a, l, u + e.lineHeight - h.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = "rgba(0, 0, 0, 0)";
}
function cl(r) {
  return Array.from ? Array.from(r) : r.split("");
}
function nm(r) {
  typeof r == "string" && (r = [r]);
  for (var t = [], e = 0, i = r.length; e < i; e++) {
    var n = r[e];
    if (Array.isArray(n)) {
      if (n.length !== 2)
        throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + n.length + ".");
      var s = n[0].charCodeAt(0), o = n[1].charCodeAt(0);
      if (o < s)
        throw new Error("[BitmapFont]: Invalid character range.");
      for (var a = s, h = o; a <= h; a++)
        t.push(String.fromCharCode(a));
    } else
      t.push.apply(t, cl(n));
  }
  if (t.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return t;
}
function fn(r) {
  return r.codePointAt ? r.codePointAt(0) : r.charCodeAt(0);
}
var ni = (
  /** @class */
  function() {
    function r(t, e, i) {
      var n, s, o = t.info[0], a = t.common[0], h = t.page[0], l = t.distanceField[0], u = Cn(h.file), c = {};
      this._ownsTextures = i, this.font = o.face, this.size = o.size, this.lineHeight = a.lineHeight / u, this.chars = {}, this.pageTextures = c;
      for (var f = 0; f < t.page.length; f++) {
        var d = t.page[f], p = d.id, v = d.file;
        c[p] = e instanceof Array ? e[f] : e[v], l?.fieldType && l.fieldType !== "none" && (c[p].baseTexture.alphaMode = Se.NO_PREMULTIPLIED_ALPHA, c[p].baseTexture.mipmap = Ee.OFF);
      }
      for (var f = 0; f < t.char.length; f++) {
        var _ = t.char[f], p = _.id, m = _.page, y = t.char[f], b = y.x, P = y.y, x = y.width, T = y.height, I = y.xoffset, w = y.yoffset, O = y.xadvance;
        b /= u, P /= u, x /= u, T /= u, I /= u, w /= u, O /= u;
        var R = new dt(b + c[m].frame.x / u, P + c[m].frame.y / u, x, T);
        this.chars[p] = {
          xOffset: I,
          yOffset: w,
          xAdvance: O,
          kerning: {},
          texture: new ot(c[m].baseTexture, R),
          page: m
        };
      }
      for (var f = 0; f < t.kerning.length; f++) {
        var U = t.kerning[f], q = U.first, tt = U.second, ct = U.amount;
        q /= u, tt /= u, ct /= u, this.chars[tt] && (this.chars[tt].kerning[q] = ct);
      }
      this.distanceFieldRange = l?.distanceRange, this.distanceFieldType = (s = (n = l?.fieldType) === null || n === void 0 ? void 0 : n.toLowerCase()) !== null && s !== void 0 ? s : "none";
    }
    return r.prototype.destroy = function() {
      for (var t in this.chars)
        this.chars[t].texture.destroy(), this.chars[t].texture = null;
      for (var t in this.pageTextures)
        this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;
      this.chars = null, this.pageTextures = null;
    }, r.install = function(t, e, i) {
      var n;
      if (t instanceof kn)
        n = t;
      else {
        var s = ul(t);
        if (!s)
          throw new Error("Unrecognized data format for font.");
        n = s.parse(t);
      }
      e instanceof ot && (e = [e]);
      var o = new r(n, e, i);
      return r.available[o.font] = o, o;
    }, r.uninstall = function(t) {
      var e = r.available[t];
      if (!e)
        throw new Error("No font found named '" + t + "'");
      e.destroy(), delete r.available[t];
    }, r.from = function(t, e, i) {
      if (!t)
        throw new Error("[BitmapFont] Property `name` is required.");
      var n = Object.assign({}, r.defaultOptions, i), s = n.chars, o = n.padding, a = n.resolution, h = n.textureWidth, l = n.textureHeight, u = nm(s), c = e instanceof Ci ? e : new Ci(e), f = h, d = new kn();
      d.info[0] = {
        face: c.fontFamily,
        size: c.fontSize
      }, d.common[0] = {
        lineHeight: c.fontSize
      };
      for (var p = 0, v = 0, _, m, y, b = 0, P = [], x = 0; x < u.length; x++) {
        _ || (_ = K.ADAPTER.createCanvas(), _.width = h, _.height = l, m = _.getContext("2d"), y = new gt(_, { resolution: a }), P.push(new ot(y)), d.page.push({
          id: P.length - 1,
          file: ""
        }));
        var T = u[x], I = Ge.measureText(T, c, !1, _), w = I.width, O = Math.ceil(I.height), R = Math.ceil((c.fontStyle === "italic" ? 2 : 1) * w);
        if (v >= l - O * a) {
          if (v === 0)
            throw new Error("[BitmapFont] textureHeight " + l + "px is too small " + ("(fontFamily: '" + c.fontFamily + "', fontSize: " + c.fontSize + "px, char: '" + T + "')"));
          --x, _ = null, m = null, y = null, v = 0, p = 0, b = 0;
          continue;
        }
        if (b = Math.max(O + I.fontProperties.descent, b), R * a + p >= f) {
          if (p === 0)
            throw new Error("[BitmapFont] textureWidth " + h + "px is too small " + ("(fontFamily: '" + c.fontFamily + "', fontSize: " + c.fontSize + "px, char: '" + T + "')"));
          --x, v += b * a, v = Math.ceil(v), p = 0, b = 0;
          continue;
        }
        rm(_, m, I, p, v, a, c);
        var U = fn(I.text);
        d.char.push({
          id: U,
          page: P.length - 1,
          x: p / a,
          y: v / a,
          width: R,
          height: O,
          xoffset: 0,
          yoffset: 0,
          xadvance: Math.ceil(w - (c.dropShadow ? c.dropShadowDistance : 0) - (c.stroke ? c.strokeThickness : 0))
        }), p += (R + 2 * o) * a, p = Math.ceil(p);
      }
      if (!i?.skipKerning)
        for (var x = 0, q = u.length; x < q; x++)
          for (var tt = u[x], ct = 0; ct < q; ct++) {
            var Y = u[ct], g = m.measureText(tt).width, S = m.measureText(Y).width, E = m.measureText(tt + Y).width, M = E - (g + S);
            M && d.kerning.push({
              first: fn(tt),
              second: fn(Y),
              amount: M
            });
          }
      var N = new r(d, P, !0);
      return r.available[t] !== void 0 && r.uninstall(t), r.available[t] = N, N;
    }, r.ALPHA = [["a", "z"], ["A", "Z"], " "], r.NUMERIC = [["0", "9"]], r.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], r.ASCII = [[" ", "~"]], r.defaultOptions = {
      resolution: 1,
      textureWidth: 512,
      textureHeight: 512,
      padding: 4,
      chars: r.ALPHANUMERIC
    }, r.available = {}, r;
  }()
), sm = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r
\r
}\r
`, om = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`, Ja = [], Qa = [], th = [];
(function(r) {
  Q_(t, r);
  function t(e, i) {
    i === void 0 && (i = {});
    var n = r.call(this) || this;
    n._tint = 16777215;
    var s = Object.assign({}, t.styleDefaults, i), o = s.align, a = s.tint, h = s.maxWidth, l = s.letterSpacing, u = s.fontName, c = s.fontSize;
    if (!ni.available[u])
      throw new Error('Missing BitmapFont "' + u + '"');
    return n._activePagesMeshData = [], n._textWidth = 0, n._textHeight = 0, n._align = o, n._tint = a, n._font = void 0, n._fontName = u, n._fontSize = c, n.text = e, n._maxWidth = h, n._maxLineHeight = 0, n._letterSpacing = l, n._anchor = new Di(function() {
      n.dirty = !0;
    }, n, 0, 0), n._roundPixels = K.ROUND_PIXELS, n.dirty = !0, n._resolution = K.RESOLUTION, n._autoResolution = !0, n._textureCache = {}, n;
  }
  return t.prototype.updateText = function() {
    for (var e, i = ni.available[this._fontName], n = this.fontSize, s = n / i.size, o = new Ot(), a = [], h = [], l = [], u = this._text.replace(/(?:\r\n|\r)/g, `
`) || " ", c = cl(u), f = this._maxWidth * i.size / n, d = i.distanceFieldType === "none" ? Ja : Qa, p = null, v = 0, _ = 0, m = 0, y = -1, b = 0, P = 0, x = 0, T = 0, I = 0; I < c.length; I++) {
      var w = c[I], O = fn(w);
      if (/(?:\s)/.test(w) && (y = I, b = v, T++), w === "\r" || w === `
`) {
        h.push(v), l.push(-1), _ = Math.max(_, v), ++m, ++P, o.x = 0, o.y += i.lineHeight, p = null, T = 0;
        continue;
      }
      var R = i.chars[O];
      if (R) {
        p && R.kerning[p] && (o.x += R.kerning[p]);
        var U = th.pop() || {
          texture: ot.EMPTY,
          line: 0,
          charCode: 0,
          prevSpaces: 0,
          position: new Ot()
        };
        U.texture = R.texture, U.line = m, U.charCode = O, U.position.x = o.x + R.xOffset + this._letterSpacing / 2, U.position.y = o.y + R.yOffset, U.prevSpaces = T, a.push(U), v = U.position.x + Math.max(R.xAdvance - R.xOffset, R.texture.orig.width), o.x += R.xAdvance + this._letterSpacing, x = Math.max(x, R.yOffset + R.texture.height), p = O, y !== -1 && f > 0 && o.x > f && (++P, Fi(a, 1 + y - P, 1 + I - y), I = y, y = -1, h.push(b), l.push(a.length > 0 ? a[a.length - 1].prevSpaces : 0), _ = Math.max(_, b), m++, o.x = 0, o.y += i.lineHeight, p = null, T = 0);
      }
    }
    var q = c[c.length - 1];
    q !== "\r" && q !== `
` && (/(?:\s)/.test(q) && (v = b), h.push(v), _ = Math.max(_, v), l.push(-1));
    for (var tt = [], I = 0; I <= m; I++) {
      var ct = 0;
      this._align === "right" ? ct = _ - h[I] : this._align === "center" ? ct = (_ - h[I]) / 2 : this._align === "justify" && (ct = l[I] < 0 ? 0 : (_ - h[I]) / l[I]), tt.push(ct);
    }
    var Y = a.length, g = {}, S = [], E = this._activePagesMeshData;
    d.push.apply(d, E);
    for (var I = 0; I < Y; I++) {
      var M = a[I].texture, N = M.baseTexture.uid;
      if (!g[N]) {
        var k = d.pop();
        if (!k) {
          var B = new Un(), H = void 0, Z = void 0;
          i.distanceFieldType === "none" ? (H = new Tr(ot.EMPTY), Z = it.NORMAL) : (H = new Tr(ot.EMPTY, { program: kr.from(om, sm), uniforms: { uFWidth: 0 } }), Z = it.NORMAL_NPM);
          var J = new wr(B, H);
          J.blendMode = Z, k = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh: J,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        k.index = 0, k.indexCount = 0, k.vertexCount = 0, k.uvsCount = 0, k.total = 0;
        var C = this._textureCache;
        C[N] = C[N] || new ot(M.baseTexture), k.mesh.texture = C[N], k.mesh.tint = this._tint, S.push(k), g[N] = k;
      }
      g[N].total++;
    }
    for (var I = 0; I < E.length; I++)
      S.indexOf(E[I]) === -1 && this.removeChild(E[I].mesh);
    for (var I = 0; I < S.length; I++)
      S[I].mesh.parent !== this && this.addChild(S[I].mesh);
    this._activePagesMeshData = S;
    for (var I in g) {
      var k = g[I], ut = k.total;
      if (!(((e = k.indices) === null || e === void 0 ? void 0 : e.length) > 6 * ut) || k.vertices.length < wr.BATCHABLE_SIZE * 2)
        k.vertices = new Float32Array(4 * 2 * ut), k.uvs = new Float32Array(4 * 2 * ut), k.indices = new Uint16Array(6 * ut);
      else
        for (var X = k.total, xt = k.vertices, lt = X * 4 * 2; lt < xt.length; lt++)
          xt[lt] = 0;
      k.mesh.size = 6 * ut;
    }
    for (var I = 0; I < Y; I++) {
      var w = a[I], V = w.position.x + tt[w.line] * (this._align === "justify" ? w.prevSpaces : 1);
      this._roundPixels && (V = Math.round(V));
      var Mt = V * s, ht = w.position.y * s, M = w.texture, F = g[M.baseTexture.uid], W = M.frame, et = M._uvs, G = F.index++;
      F.indices[G * 6 + 0] = 0 + G * 4, F.indices[G * 6 + 1] = 1 + G * 4, F.indices[G * 6 + 2] = 2 + G * 4, F.indices[G * 6 + 3] = 0 + G * 4, F.indices[G * 6 + 4] = 2 + G * 4, F.indices[G * 6 + 5] = 3 + G * 4, F.vertices[G * 8 + 0] = Mt, F.vertices[G * 8 + 1] = ht, F.vertices[G * 8 + 2] = Mt + W.width * s, F.vertices[G * 8 + 3] = ht, F.vertices[G * 8 + 4] = Mt + W.width * s, F.vertices[G * 8 + 5] = ht + W.height * s, F.vertices[G * 8 + 6] = Mt, F.vertices[G * 8 + 7] = ht + W.height * s, F.uvs[G * 8 + 0] = et.x0, F.uvs[G * 8 + 1] = et.y0, F.uvs[G * 8 + 2] = et.x1, F.uvs[G * 8 + 3] = et.y1, F.uvs[G * 8 + 4] = et.x2, F.uvs[G * 8 + 5] = et.y2, F.uvs[G * 8 + 6] = et.x3, F.uvs[G * 8 + 7] = et.y3;
    }
    this._textWidth = _ * s, this._textHeight = (o.y + i.lineHeight) * s;
    for (var I in g) {
      var k = g[I];
      if (this.anchor.x !== 0 || this.anchor.y !== 0)
        for (var Kt = 0, Ce = this._textWidth * this.anchor.x, Jt = this._textHeight * this.anchor.y, je = 0; je < k.total; je++)
          k.vertices[Kt++] -= Ce, k.vertices[Kt++] -= Jt, k.vertices[Kt++] -= Ce, k.vertices[Kt++] -= Jt, k.vertices[Kt++] -= Ce, k.vertices[Kt++] -= Jt, k.vertices[Kt++] -= Ce, k.vertices[Kt++] -= Jt;
      this._maxLineHeight = x * s;
      var Qe = k.mesh.geometry.getBuffer("aVertexPosition"), ti = k.mesh.geometry.getBuffer("aTextureCoord"), ei = k.mesh.geometry.getIndex();
      Qe.data = k.vertices, ti.data = k.uvs, ei.data = k.indices, Qe.update(), ti.update(), ei.update();
    }
    for (var I = 0; I < a.length; I++)
      th.push(a[I]);
    this._font = i, this.dirty = !1;
  }, t.prototype.updateTransform = function() {
    this.validate(), this.containerUpdateTransform();
  }, t.prototype._render = function(e) {
    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);
    var i = ni.available[this._fontName], n = i.distanceFieldRange, s = i.distanceFieldType, o = i.size;
    if (s !== "none")
      for (var a = this.worldTransform, h = a.a, l = a.b, u = a.c, c = a.d, f = Math.sqrt(h * h + l * l), d = Math.sqrt(u * u + c * c), p = (Math.abs(f) + Math.abs(d)) / 2, v = this.fontSize / o, _ = 0, m = this._activePagesMeshData; _ < m.length; _++) {
        var y = m[_];
        y.mesh.shader.uniforms.uFWidth = p * n * v * this._resolution;
      }
    r.prototype._render.call(this, e);
  }, t.prototype.getLocalBounds = function() {
    return this.validate(), r.prototype.getLocalBounds.call(this);
  }, t.prototype.validate = function() {
    var e = ni.available[this._fontName];
    if (!e)
      throw new Error('Missing BitmapFont "' + this._fontName + '"');
    this._font !== e && (this.dirty = !0), this.dirty && this.updateText();
  }, Object.defineProperty(t.prototype, "tint", {
    /**
     * The tint of the BitmapText object.
     * @default 0xffffff
     */
    get: function() {
      return this._tint;
    },
    set: function(e) {
      if (this._tint !== e) {
        this._tint = e;
        for (var i = 0; i < this._activePagesMeshData.length; i++)
          this._activePagesMeshData[i].mesh.tint = e;
      }
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "align", {
    /**
     * The alignment of the BitmapText object.
     * @member {string}
     * @default 'left'
     */
    get: function() {
      return this._align;
    },
    set: function(e) {
      this._align !== e && (this._align = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fontName", {
    /** The name of the BitmapFont. */
    get: function() {
      return this._fontName;
    },
    set: function(e) {
      if (!ni.available[e])
        throw new Error('Missing BitmapFont "' + e + '"');
      this._fontName !== e && (this._fontName = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fontSize", {
    /** The size of the font to display. */
    get: function() {
      var e;
      return (e = this._fontSize) !== null && e !== void 0 ? e : ni.available[this._fontName].size;
    },
    set: function(e) {
      this._fontSize !== e && (this._fontSize = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "anchor", {
    /**
     * The anchor sets the origin point of the text.
     *
     * The default is `(0,0)`, this means the text's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
     */
    get: function() {
      return this._anchor;
    },
    set: function(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "text", {
    /** The text of the BitmapText object. */
    get: function() {
      return this._text;
    },
    set: function(e) {
      e = String(e ?? ""), this._text !== e && (this._text = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "maxWidth", {
    /**
     * The max width of this bitmap text in pixels. If the text provided is longer than the
     * value provided, line breaks will be automatically inserted in the last whitespace.
     * Disable by setting the value to 0.
     */
    get: function() {
      return this._maxWidth;
    },
    set: function(e) {
      this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "maxLineHeight", {
    /**
     * The max line height. This is useful when trying to use the total height of the Text,
     * i.e. when trying to vertically align.
     * @readonly
     */
    get: function() {
      return this.validate(), this._maxLineHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textWidth", {
    /**
     * The width of the overall text, different from fontSize,
     * which is defined in the style object.
     * @readonly
     */
    get: function() {
      return this.validate(), this._textWidth;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "letterSpacing", {
    /** Additional space between characters. */
    get: function() {
      return this._letterSpacing;
    },
    set: function(e) {
      this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "roundPixels", {
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     * @default PIXI.settings.ROUND_PIXELS
     */
    get: function() {
      return this._roundPixels;
    },
    set: function(e) {
      e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textHeight", {
    /**
     * The height of the overall text, different from fontSize,
     * which is defined in the style object.
     * @readonly
     */
    get: function() {
      return this.validate(), this._textHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "resolution", {
    /**
     * The resolution / device pixel ratio of the canvas.
     *
     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
     * @default 1
     */
    get: function() {
      return this._resolution;
    },
    set: function(e) {
      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.destroy = function(e) {
    var i = this._textureCache, n = ni.available[this._fontName], s = n.distanceFieldType === "none" ? Ja : Qa;
    s.push.apply(s, this._activePagesMeshData);
    for (var o = 0, a = this._activePagesMeshData; o < a.length; o++) {
      var h = a[o];
      this.removeChild(h.mesh);
    }
    this._activePagesMeshData = [], s.filter(function(c) {
      return i[c.mesh.texture.baseTexture.uid];
    }).forEach(function(c) {
      c.mesh.texture = ot.EMPTY;
    });
    for (var l in i) {
      var u = i[l];
      u.destroy(), delete i[l];
    }
    this._font = null, this._textureCache = null, r.prototype.destroy.call(this, e);
  }, t.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
  }, t;
})(Ct);
var am = (
  /** @class */
  function() {
    function r() {
    }
    return r.add = function() {
      ft.setExtensionXhrType("fnt", ft.XHR_RESPONSE_TYPE.TEXT);
    }, r.use = function(t, e) {
      var i = ul(t.data);
      if (!i) {
        e();
        return;
      }
      for (var n = r.getBaseUrl(this, t), s = i.parse(t.data), o = {}, a = function(v) {
        o[v.metadata.pageFile] = v.texture, Object.keys(o).length === s.page.length && (t.bitmapFont = ni.install(s, o, !0), e());
      }, h = 0; h < s.page.length; ++h) {
        var l = s.page[h].file, u = n + l, c = !1;
        for (var f in this.resources) {
          var d = this.resources[f];
          if (d.url === u) {
            d.metadata.pageFile = l, d.texture ? a(d) : d.onAfterMiddleware.add(a), c = !0;
            break;
          }
        }
        if (!c) {
          var p = {
            crossOrigin: t.crossOrigin,
            loadType: ft.LOAD_TYPE.IMAGE,
            metadata: Object.assign({ pageFile: l }, t.metadata.imageMetadata),
            parentResource: t
          };
          this.add(u, p, a);
        }
      }
    }, r.getBaseUrl = function(t, e) {
      var i = e.isDataUrl ? "" : r.dirname(e.url);
      return e.isDataUrl && (i === "." && (i = ""), t.baseUrl && i && t.baseUrl.charAt(t.baseUrl.length - 1) === "/" && (i += "/")), i = i.replace(t.baseUrl, ""), i && i.charAt(i.length - 1) !== "/" && (i += "/"), i;
    }, r.dirname = function(t) {
      var e = t.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
      return e === t ? "." : e === "" ? "/" : e;
    }, r.extension = St.Loader, r;
  }()
);
/*!
 * @pixi/filter-alpha - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-alpha is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var io = function(r, t) {
  return io = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, io(r, t);
};
function hm(r, t) {
  io(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var lm = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
(function(r) {
  hm(t, r);
  function t(e) {
    e === void 0 && (e = 1);
    var i = r.call(this, iv, lm, { uAlpha: 1 }) || this;
    return i.alpha = e, i;
  }
  return Object.defineProperty(t.prototype, "alpha", {
    /**
     * Coefficient for alpha multiplication
     * @default 1
     */
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(e) {
      this.uniforms.uAlpha = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Je);
/*!
 * @pixi/filter-blur - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ro = function(r, t) {
  return ro = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, ro(r, t);
};
function fl(r, t) {
  ro(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var um = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function cm(r, t) {
  var e = Math.ceil(r / 2), i = um, n = "", s;
  t ? s = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : s = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  for (var o = 0; o < r; o++) {
    var a = s.replace("%index%", o.toString());
    a = a.replace("%sampleIndex%", o - (e - 1) + ".0"), n += a, n += `
`;
  }
  return i = i.replace("%blur%", n), i = i.replace("%size%", r.toString()), i;
}
var fm = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
}, dm = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join(`
`);
function pm(r) {
  for (var t = fm[r], e = t.length, i = dm, n = "", s = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;", o, a = 0; a < r; a++) {
    var h = s.replace("%index%", a.toString());
    o = a, a >= e && (o = r - a - 1), h = h.replace("%value%", t[o].toString()), n += h, n += `
`;
  }
  return i = i.replace("%blur%", n), i = i.replace("%size%", r.toString()), i;
}
var eh = (
  /** @class */
  function(r) {
    fl(t, r);
    function t(e, i, n, s, o) {
      i === void 0 && (i = 8), n === void 0 && (n = 4), s === void 0 && (s = K.FILTER_RESOLUTION), o === void 0 && (o = 5);
      var a = this, h = cm(o, e), l = pm(o);
      return a = r.call(
        this,
        // vertex shader
        h,
        // fragment shader
        l
      ) || this, a.horizontal = e, a.resolution = s, a._quality = 0, a.quality = n, a.blur = i, a;
    }
    return t.prototype.apply = function(e, i, n, s) {
      if (n ? this.horizontal ? this.uniforms.strength = 1 / n.width * (n.width / i.width) : this.uniforms.strength = 1 / n.height * (n.height / i.height) : this.horizontal ? this.uniforms.strength = 1 / e.renderer.width * (e.renderer.width / i.width) : this.uniforms.strength = 1 / e.renderer.height * (e.renderer.height / i.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)
        e.applyFilter(this, i, n, s);
      else {
        var o = e.getFilterTexture(), a = e.renderer, h = i, l = o;
        this.state.blend = !1, e.applyFilter(this, h, l, be.CLEAR);
        for (var u = 1; u < this.passes - 1; u++) {
          e.bindAndClear(h, be.BLIT), this.uniforms.uSampler = l;
          var c = l;
          l = h, h = c, a.shader.bind(this), a.geometry.draw(5);
        }
        this.state.blend = !0, e.applyFilter(this, l, n, s), e.returnFilterTexture(o);
      }
    }, Object.defineProperty(t.prototype, "blur", {
      /**
       * Sets the strength of both the blur.
       * @default 16
       */
      get: function() {
        return this.strength;
      },
      set: function(e) {
        this.padding = 1 + Math.abs(e) * 2, this.strength = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "quality", {
      /**
       * Sets the quality of the blur by modifying the number of passes. More passes means higher
       * quality bluring but the lower the performance.
       * @default 4
       */
      get: function() {
        return this._quality;
      },
      set: function(e) {
        this._quality = e, this.passes = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Je)
), vm = (
  /** @class */
  function(r) {
    fl(t, r);
    function t(e, i, n, s) {
      e === void 0 && (e = 8), i === void 0 && (i = 4), n === void 0 && (n = K.FILTER_RESOLUTION), s === void 0 && (s = 5);
      var o = r.call(this) || this;
      return o.blurXFilter = new eh(!0, e, i, n, s), o.blurYFilter = new eh(!1, e, i, n, s), o.resolution = n, o.quality = i, o.blur = e, o.repeatEdgePixels = !1, o;
    }
    return t.prototype.apply = function(e, i, n, s) {
      var o = Math.abs(this.blurXFilter.strength), a = Math.abs(this.blurYFilter.strength);
      if (o && a) {
        var h = e.getFilterTexture();
        this.blurXFilter.apply(e, i, h, be.CLEAR), this.blurYFilter.apply(e, h, n, s), e.returnFilterTexture(h);
      } else a ? this.blurYFilter.apply(e, i, n, s) : this.blurXFilter.apply(e, i, n, s);
    }, t.prototype.updatePadding = function() {
      this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
    }, Object.defineProperty(t.prototype, "blur", {
      /**
       * Sets the strength of both the blurX and blurY properties simultaneously
       * @default 2
       */
      get: function() {
        return this.blurXFilter.blur;
      },
      set: function(e) {
        this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "quality", {
      /**
       * Sets the number of passes for blur. More passes means higher quality bluring.
       * @default 1
       */
      get: function() {
        return this.blurXFilter.quality;
      },
      set: function(e) {
        this.blurXFilter.quality = this.blurYFilter.quality = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "blurX", {
      /**
       * Sets the strength of the blurX property
       * @default 2
       */
      get: function() {
        return this.blurXFilter.blur;
      },
      set: function(e) {
        this.blurXFilter.blur = e, this.updatePadding();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "blurY", {
      /**
       * Sets the strength of the blurY property
       * @default 2
       */
      get: function() {
        return this.blurYFilter.blur;
      },
      set: function(e) {
        this.blurYFilter.blur = e, this.updatePadding();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "blendMode", {
      /**
       * Sets the blendmode of the filter
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this.blurYFilter.blendMode;
      },
      set: function(e) {
        this.blurYFilter.blendMode = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "repeatEdgePixels", {
      /**
       * If set to true the edge of the target will be clamped
       * @default false
       */
      get: function() {
        return this._repeatEdgePixels;
      },
      set: function(e) {
        this._repeatEdgePixels = e, this.updatePadding();
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Je)
);
/*!
 * @pixi/filter-color-matrix - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-color-matrix is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var no = function(r, t) {
  return no = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, no(r, t);
};
function _m(r, t) {
  no(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var mm = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`, so = (
  /** @class */
  function(r) {
    _m(t, r);
    function t() {
      var e = this, i = {
        m: new Float32Array([
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]),
        uAlpha: 1
      };
      return e = r.call(this, Qh, mm, i) || this, e.alpha = 1, e;
    }
    return t.prototype._loadMatrix = function(e, i) {
      i === void 0 && (i = !1);
      var n = e;
      i && (this._multiply(n, this.uniforms.m, e), n = this._colorMatrix(n)), this.uniforms.m = n;
    }, t.prototype._multiply = function(e, i, n) {
      return e[0] = i[0] * n[0] + i[1] * n[5] + i[2] * n[10] + i[3] * n[15], e[1] = i[0] * n[1] + i[1] * n[6] + i[2] * n[11] + i[3] * n[16], e[2] = i[0] * n[2] + i[1] * n[7] + i[2] * n[12] + i[3] * n[17], e[3] = i[0] * n[3] + i[1] * n[8] + i[2] * n[13] + i[3] * n[18], e[4] = i[0] * n[4] + i[1] * n[9] + i[2] * n[14] + i[3] * n[19] + i[4], e[5] = i[5] * n[0] + i[6] * n[5] + i[7] * n[10] + i[8] * n[15], e[6] = i[5] * n[1] + i[6] * n[6] + i[7] * n[11] + i[8] * n[16], e[7] = i[5] * n[2] + i[6] * n[7] + i[7] * n[12] + i[8] * n[17], e[8] = i[5] * n[3] + i[6] * n[8] + i[7] * n[13] + i[8] * n[18], e[9] = i[5] * n[4] + i[6] * n[9] + i[7] * n[14] + i[8] * n[19] + i[9], e[10] = i[10] * n[0] + i[11] * n[5] + i[12] * n[10] + i[13] * n[15], e[11] = i[10] * n[1] + i[11] * n[6] + i[12] * n[11] + i[13] * n[16], e[12] = i[10] * n[2] + i[11] * n[7] + i[12] * n[12] + i[13] * n[17], e[13] = i[10] * n[3] + i[11] * n[8] + i[12] * n[13] + i[13] * n[18], e[14] = i[10] * n[4] + i[11] * n[9] + i[12] * n[14] + i[13] * n[19] + i[14], e[15] = i[15] * n[0] + i[16] * n[5] + i[17] * n[10] + i[18] * n[15], e[16] = i[15] * n[1] + i[16] * n[6] + i[17] * n[11] + i[18] * n[16], e[17] = i[15] * n[2] + i[16] * n[7] + i[17] * n[12] + i[18] * n[17], e[18] = i[15] * n[3] + i[16] * n[8] + i[17] * n[13] + i[18] * n[18], e[19] = i[15] * n[4] + i[16] * n[9] + i[17] * n[14] + i[18] * n[19] + i[19], e;
    }, t.prototype._colorMatrix = function(e) {
      var i = new Float32Array(e);
      return i[4] /= 255, i[9] /= 255, i[14] /= 255, i[19] /= 255, i;
    }, t.prototype.brightness = function(e, i) {
      var n = [
        e,
        0,
        0,
        0,
        0,
        0,
        e,
        0,
        0,
        0,
        0,
        0,
        e,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, i);
    }, t.prototype.tint = function(e, i) {
      var n = e >> 16 & 255, s = e >> 8 & 255, o = e & 255, a = [
        n / 255,
        0,
        0,
        0,
        0,
        0,
        s / 255,
        0,
        0,
        0,
        0,
        0,
        o / 255,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(a, i);
    }, t.prototype.greyscale = function(e, i) {
      var n = [
        e,
        e,
        e,
        0,
        0,
        e,
        e,
        e,
        0,
        0,
        e,
        e,
        e,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, i);
    }, t.prototype.blackAndWhite = function(e) {
      var i = [
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.hue = function(e, i) {
      e = (e || 0) / 180 * Math.PI;
      var n = Math.cos(e), s = Math.sin(e), o = Math.sqrt, a = 1 / 3, h = o(a), l = n + (1 - n) * a, u = a * (1 - n) - h * s, c = a * (1 - n) + h * s, f = a * (1 - n) + h * s, d = n + a * (1 - n), p = a * (1 - n) - h * s, v = a * (1 - n) - h * s, _ = a * (1 - n) + h * s, m = n + a * (1 - n), y = [
        l,
        u,
        c,
        0,
        0,
        f,
        d,
        p,
        0,
        0,
        v,
        _,
        m,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(y, i);
    }, t.prototype.contrast = function(e, i) {
      var n = (e || 0) + 1, s = -0.5 * (n - 1), o = [
        n,
        0,
        0,
        0,
        s,
        0,
        n,
        0,
        0,
        s,
        0,
        0,
        n,
        0,
        s,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(o, i);
    }, t.prototype.saturate = function(e, i) {
      e === void 0 && (e = 0);
      var n = e * 2 / 3 + 1, s = (n - 1) * -0.5, o = [
        n,
        s,
        s,
        0,
        0,
        s,
        n,
        s,
        0,
        0,
        s,
        s,
        n,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(o, i);
    }, t.prototype.desaturate = function() {
      this.saturate(-1);
    }, t.prototype.negative = function(e) {
      var i = [
        -1,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        -1,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.sepia = function(e) {
      var i = [
        0.393,
        0.7689999,
        0.18899999,
        0,
        0,
        0.349,
        0.6859999,
        0.16799999,
        0,
        0,
        0.272,
        0.5339999,
        0.13099999,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.technicolor = function(e) {
      var i = [
        1.9125277891456083,
        -0.8545344976951645,
        -0.09155508482755585,
        0,
        11.793603434377337,
        -0.3087833385928097,
        1.7658908555458428,
        -0.10601743074722245,
        0,
        -70.35205161461398,
        -0.231103377548616,
        -0.7501899197440212,
        1.847597816108189,
        0,
        30.950940869491138,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.polaroid = function(e) {
      var i = [
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.toBGR = function(e) {
      var i = [
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.kodachrome = function(e) {
      var i = [
        1.1285582396593525,
        -0.3967382283601348,
        -0.03992559172921793,
        0,
        63.72958762196502,
        -0.16404339962244616,
        1.0835251566291304,
        -0.05498805115633132,
        0,
        24.732407896706203,
        -0.16786010706155763,
        -0.5603416277695248,
        1.6014850761964943,
        0,
        35.62982807460946,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.browni = function(e) {
      var i = [
        0.5997023498159715,
        0.34553243048391263,
        -0.2708298674538042,
        0,
        47.43192855600873,
        -0.037703249837783157,
        0.8609577587992641,
        0.15059552388459913,
        0,
        -36.96841498319127,
        0.24113635128153335,
        -0.07441037908422492,
        0.44972182064877153,
        0,
        -7.562075277591283,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.vintage = function(e) {
      var i = [
        0.6279345635605994,
        0.3202183420819367,
        -0.03965408211312453,
        0,
        9.651285835294123,
        0.02578397704808868,
        0.6441188644374771,
        0.03259127616149294,
        0,
        7.462829176470591,
        0.0466055556782719,
        -0.0851232987247891,
        0.5241648018700465,
        0,
        5.159190588235296,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.colorTone = function(e, i, n, s, o) {
      e = e || 0.2, i = i || 0.15, n = n || 16770432, s = s || 3375104;
      var a = (n >> 16 & 255) / 255, h = (n >> 8 & 255) / 255, l = (n & 255) / 255, u = (s >> 16 & 255) / 255, c = (s >> 8 & 255) / 255, f = (s & 255) / 255, d = [
        0.3,
        0.59,
        0.11,
        0,
        0,
        a,
        h,
        l,
        e,
        0,
        u,
        c,
        f,
        i,
        0,
        a - u,
        h - c,
        l - f,
        0,
        0
      ];
      this._loadMatrix(d, o);
    }, t.prototype.night = function(e, i) {
      e = e || 0.1;
      var n = [
        e * -2,
        -e,
        0,
        0,
        0,
        -e,
        0,
        e,
        0,
        0,
        0,
        e,
        e * 2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, i);
    }, t.prototype.predator = function(e, i) {
      var n = [
        // row 1
        11.224130630493164 * e,
        -4.794486999511719 * e,
        -2.8746118545532227 * e,
        0 * e,
        0.40342438220977783 * e,
        // row 2
        -3.6330697536468506 * e,
        9.193157196044922 * e,
        -2.951810836791992 * e,
        0 * e,
        -1.316135048866272 * e,
        // row 3
        -3.2184197902679443 * e,
        -4.2375030517578125 * e,
        7.476448059082031 * e,
        0 * e,
        0.8044459223747253 * e,
        // row 4
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, i);
    }, t.prototype.lsd = function(e) {
      var i = [
        2,
        -0.4,
        0.5,
        0,
        0,
        -0.5,
        2,
        -0.4,
        0,
        0,
        -0.4,
        -0.5,
        3,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.reset = function() {
      var e = [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(e, !1);
    }, Object.defineProperty(t.prototype, "matrix", {
      /**
       * The matrix of the color matrix filter
       * @member {number[]}
       * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
       */
      get: function() {
        return this.uniforms.m;
      },
      set: function(e) {
        this.uniforms.m = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "alpha", {
      /**
       * The opacity value to use when mixing the original and resultant colors.
       *
       * When the value is 0, the original color is used without modification.
       * When the value is 1, the result color is used.
       * When in the range (0, 1) the color is interpolated between the original and result by this amount.
       * @default 1
       */
      get: function() {
        return this.uniforms.uAlpha;
      },
      set: function(e) {
        this.uniforms.uAlpha = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Je)
);
so.prototype.grayscale = so.prototype.greyscale;
/*!
 * @pixi/filter-displacement - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-displacement is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var oo = function(r, t) {
  return oo = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, oo(r, t);
};
function ym(r, t) {
  oo(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var gm = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`, bm = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
(function(r) {
  ym(t, r);
  function t(e, i) {
    var n = this, s = new Vt();
    return e.renderable = !1, n = r.call(this, bm, gm, {
      mapSampler: e._texture,
      filterMatrix: s,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    }) || this, n.maskSprite = e, n.maskMatrix = s, i == null && (i = 20), n.scale = new Ot(i, i), n;
  }
  return t.prototype.apply = function(e, i, n, s) {
    this.uniforms.filterMatrix = e.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
    var o = this.maskSprite.worldTransform, a = Math.sqrt(o.a * o.a + o.b * o.b), h = Math.sqrt(o.c * o.c + o.d * o.d);
    a !== 0 && h !== 0 && (this.uniforms.rotation[0] = o.a / a, this.uniforms.rotation[1] = o.b / a, this.uniforms.rotation[2] = o.c / h, this.uniforms.rotation[3] = o.d / h), e.applyFilter(this, i, n, s);
  }, Object.defineProperty(t.prototype, "map", {
    /** The texture used for the displacement map. Must be power of 2 sized texture. */
    get: function() {
      return this.uniforms.mapSampler;
    },
    set: function(e) {
      this.uniforms.mapSampler = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Je);
/*!
 * @pixi/filter-fxaa - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-fxaa is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ao = function(r, t) {
  return ao = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, ao(r, t);
};
function xm(r, t) {
  ao(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var wm = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`, Tm = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
(function(r) {
  xm(t, r);
  function t() {
    return r.call(this, wm, Tm) || this;
  }
  return t;
})(Je);
/*!
 * @pixi/filter-noise - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-noise is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ho = function(r, t) {
  return ho = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, ho(r, t);
};
function Em(r, t) {
  ho(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Sm = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`, Pm = (
  /** @class */
  function(r) {
    Em(t, r);
    function t(e, i) {
      e === void 0 && (e = 0.5), i === void 0 && (i = Math.random());
      var n = r.call(this, Qh, Sm, {
        uNoise: 0,
        uSeed: 0
      }) || this;
      return n.noise = e, n.seed = i, n;
    }
    return Object.defineProperty(t.prototype, "noise", {
      /**
       * The amount of noise to apply, this value should be in the range (0, 1].
       * @default 0.5
       */
      get: function() {
        return this.uniforms.uNoise;
      },
      set: function(e) {
        this.uniforms.uNoise = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "seed", {
      /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */
      get: function() {
        return this.uniforms.uSeed;
      },
      set: function(e) {
        this.uniforms.uSeed = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Je)
);
/*!
 * @pixi/mixin-cache-as-bitmap - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var dl = new Vt();
Ut.prototype._cacheAsBitmap = !1;
Ut.prototype._cacheData = null;
Ut.prototype._cacheAsBitmapResolution = null;
Ut.prototype._cacheAsBitmapMultisample = Rt.NONE;
var Cm = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;
    }
    return r;
  }()
);
Object.defineProperties(Ut.prototype, {
  /**
   * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution
   * but can be overriden for performance. Lower values will reduce memory usage at the expense
   * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.
   * @member {number} cacheAsBitmapResolution
   * @memberof PIXI.DisplayObject#
   * @default null
   */
  cacheAsBitmapResolution: {
    get: function() {
      return this._cacheAsBitmapResolution;
    },
    set: function(r) {
      r !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = r, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  /**
   * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's
   * sample count is used.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.
   * @member {number} cacheAsBitmapMultisample
   * @memberof PIXI.DisplayObject#
   * @default PIXI.MSAA_QUALITY.NONE
   */
  cacheAsBitmapMultisample: {
    get: function() {
      return this._cacheAsBitmapMultisample;
    },
    set: function(r) {
      r !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = r, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  /**
   * Set this to true if you want this display object to be cached as a bitmap.
   * This basically takes a snap shot of the display object as it is at that moment. It can
   * provide a performance benefit for complex static displayObjects.
   * To remove simply set this property to `false`
   *
   * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
   * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  cacheAsBitmap: {
    get: function() {
      return this._cacheAsBitmap;
    },
    set: function(r) {
      if (this._cacheAsBitmap !== r) {
        this._cacheAsBitmap = r;
        var t;
        r ? (this._cacheData || (this._cacheData = new Cm()), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea);
      }
    }
  }
});
Ut.prototype._renderCached = function(t) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t));
};
Ut.prototype._initCachedDisplayObject = function(t) {
  var e;
  if (!(this._cacheData && this._cacheData.sprite)) {
    var i = this.alpha;
    this.alpha = 1, t.batch.flush();
    var n = this.getLocalBounds(null, !0).clone();
    if (this.filters && this.filters.length) {
      var s = this.filters[0].padding;
      n.pad(s);
    }
    n.ceil(K.RESOLUTION);
    var o = t.renderTexture.current, a = t.renderTexture.sourceFrame.clone(), h = t.renderTexture.destinationFrame.clone(), l = t.projection.transform, u = ce.create({
      width: n.width,
      height: n.height,
      resolution: this.cacheAsBitmapResolution || t.resolution,
      multisample: (e = this.cacheAsBitmapMultisample) !== null && e !== void 0 ? e : t.multisample
    }), c = "cacheAsBitmap_" + Pi();
    this._cacheData.textureCacheId = c, gt.addToCache(u.baseTexture, c), ot.addToCache(u, c);
    var f = this.transform.localTransform.copyTo(dl).invert().translate(-n.x, -n.y);
    this.render = this._cacheData.originalRender, t.render(this, { renderTexture: u, clear: !0, transform: f, skipUpdateTransform: !1 }), t.framebuffer.blit(), t.projection.transform = l, t.renderTexture.bind(o, a, h), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = i;
    var d = new Bt(u);
    d.transform.worldTransform = this.transform.worldTransform, d.anchor.x = -(n.x / n.width), d.anchor.y = -(n.y / n.height), d.alpha = i, d._bounds = this._bounds, this._cacheData.sprite = d, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = d.containsPoint.bind(d);
  }
};
Ut.prototype._renderCachedCanvas = function(t) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t));
};
Ut.prototype._initCachedDisplayObjectCanvas = function(t) {
  if (!(this._cacheData && this._cacheData.sprite)) {
    var e = this.getLocalBounds(null, !0), i = this.alpha;
    this.alpha = 1;
    var n = t.context, s = t._projTransform;
    e.ceil(K.RESOLUTION);
    var o = ce.create({ width: e.width, height: e.height }), a = "cacheAsBitmap_" + Pi();
    this._cacheData.textureCacheId = a, gt.addToCache(o.baseTexture, a), ot.addToCache(o, a);
    var h = dl;
    this.transform.localTransform.copyTo(h), h.invert(), h.tx -= e.x, h.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, { renderTexture: o, clear: !0, transform: h, skipUpdateTransform: !1 }), t.context = n, t._projTransform = s, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = i;
    var l = new Bt(o);
    l.transform.worldTransform = this.transform.worldTransform, l.anchor.x = -(e.x / e.width), l.anchor.y = -(e.y / e.height), l.alpha = i, l._bounds = this._bounds, this._cacheData.sprite = l, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = l.containsPoint.bind(l);
  }
};
Ut.prototype._calculateCachedBounds = function() {
  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;
};
Ut.prototype._getCachedLocalBounds = function() {
  return this._cacheData.sprite.getLocalBounds(null);
};
Ut.prototype._destroyCachedDisplayObject = function() {
  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, gt.removeFromCache(this._cacheData.textureCacheId), ot.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;
};
Ut.prototype._cacheAsBitmapDestroy = function(t) {
  this.cacheAsBitmap = !1, this.destroy(t);
};
/*!
 * @pixi/mixin-get-child-by-name - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
Ut.prototype.name = null;
Ct.prototype.getChildByName = function(t, e) {
  for (var i = 0, n = this.children.length; i < n; i++)
    if (this.children[i].name === t)
      return this.children[i];
  if (e)
    for (var i = 0, n = this.children.length; i < n; i++) {
      var s = this.children[i];
      if (s.getChildByName) {
        var o = s.getChildByName(t, !0);
        if (o)
          return o;
      }
    }
  return null;
};
/*!
 * @pixi/mixin-get-global-position - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
Ut.prototype.getGlobalPosition = function(t, e) {
  return t === void 0 && (t = new Ot()), e === void 0 && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t;
};
/*!
 * @pixi/app - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/app is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Im = (
  /** @class */
  function() {
    function r() {
    }
    return r.init = function(t) {
      var e = this;
      Object.defineProperty(
        this,
        "resizeTo",
        /**
         * The HTML element or window to automatically resize the
         * renderer's view element to match width and height.
         * @member {Window|HTMLElement}
         * @name resizeTo
         * @memberof PIXI.Application#
         */
        {
          set: function(i) {
            globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = i, i && (globalThis.addEventListener("resize", this.queueResize), this.resize());
          },
          get: function() {
            return this._resizeTo;
          }
        }
      ), this.queueResize = function() {
        e._resizeTo && (e.cancelResize(), e._resizeId = requestAnimationFrame(function() {
          return e.resize();
        }));
      }, this.cancelResize = function() {
        e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null);
      }, this.resize = function() {
        if (e._resizeTo) {
          e.cancelResize();
          var i, n;
          if (e._resizeTo === globalThis.window)
            i = globalThis.innerWidth, n = globalThis.innerHeight;
          else {
            var s = e._resizeTo, o = s.clientWidth, a = s.clientHeight;
            i = o, n = a;
          }
          e.renderer.resize(i, n);
        }
      }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;
    }, r.destroy = function() {
      globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
    }, r.extension = St.Application, r;
  }()
), pl = (
  /** @class */
  function() {
    function r(t) {
      var e = this;
      this.stage = new Ct(), t = Object.assign({
        forceCanvas: !1
      }, t), this.renderer = Jh(t), r._plugins.forEach(function(i) {
        i.init.call(e, t);
      });
    }
    return r.registerPlugin = function(t) {
      Te("6.5.0", "Application.registerPlugin() is deprecated, use extensions.add()"), Ue.add({
        type: St.Application,
        ref: t
      });
    }, r.prototype.render = function() {
      this.renderer.render(this.stage);
    }, Object.defineProperty(r.prototype, "view", {
      /**
       * Reference to the renderer's canvas element.
       * @member {HTMLCanvasElement}
       * @readonly
       */
      get: function() {
        return this.renderer.view;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "screen", {
      /**
       * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
       * @member {PIXI.Rectangle}
       * @readonly
       */
      get: function() {
        return this.renderer.screen;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.destroy = function(t, e) {
      var i = this, n = r._plugins.slice(0);
      n.reverse(), n.forEach(function(s) {
        s.destroy.call(i);
      }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;
    }, r._plugins = [], r;
  }()
);
Ue.handleByList(St.Application, pl._plugins);
Ue.add(Im);
/*!
 * @pixi/mesh-extras - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mesh-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var lo = function(r, t) {
  return lo = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, lo(r, t);
};
function Vi(r, t) {
  lo(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Om = (
  /** @class */
  function(r) {
    Vi(t, r);
    function t(e, i, n, s) {
      e === void 0 && (e = 100), i === void 0 && (i = 100), n === void 0 && (n = 10), s === void 0 && (s = 10);
      var o = r.call(this) || this;
      return o.segWidth = n, o.segHeight = s, o.width = e, o.height = i, o.build(), o;
    }
    return t.prototype.build = function() {
      for (var e = this.segWidth * this.segHeight, i = [], n = [], s = [], o = this.segWidth - 1, a = this.segHeight - 1, h = this.width / o, l = this.height / a, u = 0; u < e; u++) {
        var c = u % this.segWidth, f = u / this.segWidth | 0;
        i.push(c * h, f * l), n.push(c / o, f / a);
      }
      for (var d = o * a, u = 0; u < d; u++) {
        var p = u % o, v = u / o | 0, _ = v * this.segWidth + p, m = v * this.segWidth + p + 1, y = (v + 1) * this.segWidth + p, b = (v + 1) * this.segWidth + p + 1;
        s.push(_, m, y, m, b, y);
      }
      this.buffers[0].data = new Float32Array(i), this.buffers[1].data = new Float32Array(n), this.indexBuffer.data = new Uint16Array(s), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
    }, t;
  }(Un)
), Mm = (
  /** @class */
  function(r) {
    Vi(t, r);
    function t(e, i, n) {
      e === void 0 && (e = 200), n === void 0 && (n = 0);
      var s = r.call(this, new Float32Array(i.length * 4), new Float32Array(i.length * 4), new Uint16Array((i.length - 1) * 6)) || this;
      return s.points = i, s._width = e, s.textureScale = n, s.build(), s;
    }
    return Object.defineProperty(t.prototype, "width", {
      /**
       * The width (i.e., thickness) of the rope.
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.build = function() {
      var e = this.points;
      if (e) {
        var i = this.getBuffer("aVertexPosition"), n = this.getBuffer("aTextureCoord"), s = this.getIndex();
        if (!(e.length < 1)) {
          i.data.length / 4 !== e.length && (i.data = new Float32Array(e.length * 4), n.data = new Float32Array(e.length * 4), s.data = new Uint16Array((e.length - 1) * 6));
          var o = n.data, a = s.data;
          o[0] = 0, o[1] = 0, o[2] = 0, o[3] = 1;
          for (var h = 0, l = e[0], u = this._width * this.textureScale, c = e.length, f = 0; f < c; f++) {
            var d = f * 4;
            if (this.textureScale > 0) {
              var p = l.x - e[f].x, v = l.y - e[f].y, _ = Math.sqrt(p * p + v * v);
              l = e[f], h += _ / u;
            } else
              h = f / (c - 1);
            o[d] = h, o[d + 1] = 0, o[d + 2] = h, o[d + 3] = 1;
          }
          for (var m = 0, f = 0; f < c - 1; f++) {
            var d = f * 2;
            a[m++] = d, a[m++] = d + 1, a[m++] = d + 2, a[m++] = d + 2, a[m++] = d + 1, a[m++] = d + 3;
          }
          n.update(), s.update(), this.updateVertices();
        }
      }
    }, t.prototype.updateVertices = function() {
      var e = this.points;
      if (!(e.length < 1)) {
        for (var i = e[0], n, s = 0, o = 0, a = this.buffers[0].data, h = e.length, l = 0; l < h; l++) {
          var u = e[l], c = l * 4;
          l < e.length - 1 ? n = e[l + 1] : n = u, o = -(n.x - i.x), s = n.y - i.y;
          var f = Math.sqrt(s * s + o * o), d = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
          s /= f, o /= f, s *= d, o *= d, a[c] = u.x + s, a[c + 1] = u.y + o, a[c + 2] = u.x - s, a[c + 3] = u.y - o, i = u;
        }
        this.buffers[0].update();
      }
    }, t.prototype.update = function() {
      this.textureScale > 0 ? this.build() : this.updateVertices();
    }, t;
  }(Un)
);
(function(r) {
  Vi(t, r);
  function t(e, i, n) {
    n === void 0 && (n = 0);
    var s = this, o = new Mm(e.height, i, n), a = new Tr(e);
    return n > 0 && (e.baseTexture.wrapMode = ke.REPEAT), s = r.call(this, o, a) || this, s.autoUpdate = !0, s;
  }
  return t.prototype._render = function(e) {
    var i = this.geometry;
    (this.autoUpdate || i._width !== this.shader.texture.height) && (i._width = this.shader.texture.height, i.update()), r.prototype._render.call(this, e);
  }, t;
})(wr);
var Rm = (
  /** @class */
  function(r) {
    Vi(t, r);
    function t(e, i, n) {
      var s = this, o = new Om(e.width, e.height, i, n), a = new Tr(ot.WHITE);
      return s = r.call(this, o, a) || this, s.texture = e, s.autoResize = !0, s;
    }
    return t.prototype.textureUpdated = function() {
      this._textureID = this.shader.texture._updateID;
      var e = this.geometry, i = this.shader.texture, n = i.width, s = i.height;
      this.autoResize && (e.width !== n || e.height !== s) && (e.width = this.shader.texture.width, e.height = this.shader.texture.height, e.build());
    }, Object.defineProperty(t.prototype, "texture", {
      get: function() {
        return this.shader.texture;
      },
      set: function(e) {
        this.shader.texture !== e && (this.shader.texture = e, this._textureID = -1, e.baseTexture.valid ? this.textureUpdated() : e.once("update", this.textureUpdated, this));
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype._render = function(e) {
      this._textureID !== this.shader.texture._updateID && this.textureUpdated(), r.prototype._render.call(this, e);
    }, t.prototype.destroy = function(e) {
      this.shader.texture.off("update", this.textureUpdated, this), r.prototype.destroy.call(this, e);
    }, t;
  }(wr)
);
(function(r) {
  Vi(t, r);
  function t(e, i, n, s, o) {
    e === void 0 && (e = ot.EMPTY);
    var a = this, h = new Un(i, n, s);
    h.getBuffer("aVertexPosition").static = !1;
    var l = new Tr(e);
    return a = r.call(this, h, l, null, o) || this, a.autoUpdate = !0, a;
  }
  return Object.defineProperty(t.prototype, "vertices", {
    /**
     * Collection of vertices data.
     * @type {Float32Array}
     */
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(e) {
      this.geometry.getBuffer("aVertexPosition").data = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._render = function(e) {
    this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), r.prototype._render.call(this, e);
  }, t;
})(wr);
var sn = 10;
(function(r) {
  Vi(t, r);
  function t(e, i, n, s, o) {
    i === void 0 && (i = sn), n === void 0 && (n = sn), s === void 0 && (s = sn), o === void 0 && (o = sn);
    var a = r.call(this, ot.WHITE, 4, 4) || this;
    return a._origWidth = e.orig.width, a._origHeight = e.orig.height, a._width = a._origWidth, a._height = a._origHeight, a._leftWidth = i, a._rightWidth = s, a._topHeight = n, a._bottomHeight = o, a.texture = e, a;
  }
  return t.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID, this._refresh();
  }, Object.defineProperty(t.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(e) {
      this.geometry.getBuffer("aVertexPosition").data = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.updateHorizontalVertices = function() {
    var e = this.vertices, i = this._getMinScale();
    e[9] = e[11] = e[13] = e[15] = this._topHeight * i, e[17] = e[19] = e[21] = e[23] = this._height - this._bottomHeight * i, e[25] = e[27] = e[29] = e[31] = this._height;
  }, t.prototype.updateVerticalVertices = function() {
    var e = this.vertices, i = this._getMinScale();
    e[2] = e[10] = e[18] = e[26] = this._leftWidth * i, e[4] = e[12] = e[20] = e[28] = this._width - this._rightWidth * i, e[6] = e[14] = e[22] = e[30] = this._width;
  }, t.prototype._getMinScale = function() {
    var e = this._leftWidth + this._rightWidth, i = this._width > e ? 1 : this._width / e, n = this._topHeight + this._bottomHeight, s = this._height > n ? 1 : this._height / n, o = Math.min(i, s);
    return o;
  }, Object.defineProperty(t.prototype, "width", {
    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    get: function() {
      return this._width;
    },
    set: function(e) {
      this._width = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    get: function() {
      return this._height;
    },
    set: function(e) {
      this._height = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "leftWidth", {
    /** The width of the left column. */
    get: function() {
      return this._leftWidth;
    },
    set: function(e) {
      this._leftWidth = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "rightWidth", {
    /** The width of the right column. */
    get: function() {
      return this._rightWidth;
    },
    set: function(e) {
      this._rightWidth = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "topHeight", {
    /** The height of the top row. */
    get: function() {
      return this._topHeight;
    },
    set: function(e) {
      this._topHeight = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "bottomHeight", {
    /** The height of the bottom row. */
    get: function() {
      return this._bottomHeight;
    },
    set: function(e) {
      this._bottomHeight = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._refresh = function() {
    var e = this.texture, i = this.geometry.buffers[1].data;
    this._origWidth = e.orig.width, this._origHeight = e.orig.height;
    var n = 1 / this._origWidth, s = 1 / this._origHeight;
    i[0] = i[8] = i[16] = i[24] = 0, i[1] = i[3] = i[5] = i[7] = 0, i[6] = i[14] = i[22] = i[30] = 1, i[25] = i[27] = i[29] = i[31] = 1, i[2] = i[10] = i[18] = i[26] = n * this._leftWidth, i[4] = i[12] = i[20] = i[28] = 1 - n * this._rightWidth, i[9] = i[11] = i[13] = i[15] = s * this._topHeight, i[17] = i[19] = i[21] = i[23] = 1 - s * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();
  }, t;
})(Rm);
/*!
 * @pixi/sprite-animated - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/sprite-animated is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var uo = function(r, t) {
  return uo = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, uo(r, t);
};
function km(r, t) {
  uo(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var vl = (
  /** @class */
  function(r) {
    km(t, r);
    function t(e, i) {
      i === void 0 && (i = !0);
      var n = r.call(this, e[0] instanceof ot ? e[0] : e[0].texture) || this;
      return n._textures = null, n._durations = null, n._autoUpdate = i, n._isConnectedToTicker = !1, n.animationSpeed = 1, n.loop = !0, n.updateAnchor = !1, n.onComplete = null, n.onFrameChange = null, n.onLoop = null, n._currentTime = 0, n._playing = !1, n._previousFrame = null, n.textures = e, n;
    }
    return t.prototype.stop = function() {
      this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Lt.shared.remove(this.update, this), this._isConnectedToTicker = !1));
    }, t.prototype.play = function() {
      this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Lt.shared.add(this.update, this, Ze.HIGH), this._isConnectedToTicker = !0));
    }, t.prototype.gotoAndStop = function(e) {
      this.stop();
      var i = this.currentFrame;
      this._currentTime = e, i !== this.currentFrame && this.updateTexture();
    }, t.prototype.gotoAndPlay = function(e) {
      var i = this.currentFrame;
      this._currentTime = e, i !== this.currentFrame && this.updateTexture(), this.play();
    }, t.prototype.update = function(e) {
      if (this._playing) {
        var i = this.animationSpeed * e, n = this.currentFrame;
        if (this._durations !== null) {
          var s = this._currentTime % 1 * this._durations[this.currentFrame];
          for (s += i / 60 * 1e3; s < 0; )
            this._currentTime--, s += this._durations[this.currentFrame];
          var o = Math.sign(this.animationSpeed * e);
          for (this._currentTime = Math.floor(this._currentTime); s >= this._durations[this.currentFrame]; )
            s -= this._durations[this.currentFrame] * o, this._currentTime += o;
          this._currentTime += s / this._durations[this.currentFrame];
        } else
          this._currentTime += i;
        this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : n !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < n ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > n && this.onLoop()), this.updateTexture());
      }
    }, t.prototype.updateTexture = function() {
      var e = this.currentFrame;
      this._previousFrame !== e && (this._previousFrame = e, this._texture = this._textures[e], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));
    }, t.prototype.destroy = function(e) {
      this.stop(), r.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;
    }, t.fromFrames = function(e) {
      for (var i = [], n = 0; n < e.length; ++n)
        i.push(ot.from(e[n]));
      return new t(i);
    }, t.fromImages = function(e) {
      for (var i = [], n = 0; n < e.length; ++n)
        i.push(ot.from(e[n]));
      return new t(i);
    }, Object.defineProperty(t.prototype, "totalFrames", {
      /**
       * The total number of frames in the AnimatedSprite. This is the same as number of textures
       * assigned to the AnimatedSprite.
       * @readonly
       * @default 0
       */
      get: function() {
        return this._textures.length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "textures", {
      /** The array of textures used for this AnimatedSprite. */
      get: function() {
        return this._textures;
      },
      set: function(e) {
        if (e[0] instanceof ot)
          this._textures = e, this._durations = null;
        else {
          this._textures = [], this._durations = [];
          for (var i = 0; i < e.length; i++)
            this._textures.push(e[i].texture), this._durations.push(e[i].time);
        }
        this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "currentFrame", {
      /**
       * The AnimatedSprites current frame index.
       * @readonly
       */
      get: function() {
        var e = Math.floor(this._currentTime) % this._textures.length;
        return e < 0 && (e += this._textures.length), e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "playing", {
      /**
       * Indicates if the AnimatedSprite is currently playing.
       * @readonly
       */
      get: function() {
        return this._playing;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "autoUpdate", {
      /** Whether to use PIXI.Ticker.shared to auto update animation time. */
      get: function() {
        return this._autoUpdate;
      },
      set: function(e) {
        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Lt.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Lt.shared.add(this.update, this), this._isConnectedToTicker = !0));
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Bt)
);
/*!
 * pixi.js - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
Ue.add(
  // Install renderer plugins
  dv,
  xv,
  yv,
  d_,
  H_,
  el,
  q_,
  // Install loader plugins
  am,
  Bv,
  l_,
  u_,
  z_,
  // Install application plugins
  kd,
  Ov
);
var Nm = {
  BlurFilter: vm,
  ColorMatrixFilter: so,
  NoiseFilter: Pm
};
class Wi {
  // リソースリーク対策
  #e = [];
  addC(t, e, i, n = {}) {
    t.on(e, i, n), this.#e.push(() => t.off(e, i, n));
  }
  add(t, e, i, n = {}) {
    if (t instanceof Pe) {
      t.on(e, i, n), this.#e.push(() => t.off(e, i, n));
      return;
    }
    t.addEventListener(e, i, n), this.#e.push(() => t.removeEventListener(e, i, { capture: n.capture ?? !1 }));
  }
  clear() {
    for (const t of this.#e) t();
    this.#e = [];
  }
  get isEmpty() {
    return this.#e.length === 0;
  }
}
var qt = /* @__PURE__ */ ((r) => (r.DEFAULT = "", r.SP_GSM = "png|jpg|jpeg|json|svg|webp|mp4|webm", r.SCRIPT = "sn|ssn", r.FONT = "woff2|woff|otf|ttf", r.SOUND = "mp3|m4a|ogg|aac|flac|wav", r.HTML = "htm|html", r.CSS = "css", r.SN = "sn", r.TST_PNGPNG_ = "png|png_", r.TST_HH = "hh", r.TST_EEE = "eee", r.TST_GGG = "ggg", r.TST_PNGXML = "png|xml", r))(qt || {});
const Am = {
  save_ns: "",
  // 扱うセーブデータを一意に識別するキーワード文字列
  window: {
    // アプリケーションウインドウサイズ
    width: 300,
    height: 300
  },
  book: {
    // プロジェクトの詳細情報です
    title: "",
    //作品タイトル
    creator: "",
    //著作者。同人ならペンネーム
    cre_url: "",
    //著作者URL。ツイッターやメール、サイトなど
    publisher: "",
    //出版社。同人ならサークル名
    pub_url: "",
    //出版社URL。無ければ省略します
    detail: "",
    // 内容紹介。端的に記入
    version: "1.0"
  },
  log: { max_len: 64 },
  // プレイヤーが読んだ文章を読み返せる履歴のページ数
  init: {
    bg_color: "#000000",
    // 背景色
    tagch_msecwait: 10,
    // 通常文字表示待ち時間（未読／既読）
    auto_msecpagewait: 3500,
    // 自動文字表示、行クリック待ち時間（未読／既読）
    escape: ""
    // エスケープ文字
  },
  debug: {
    devtool: !1,
    token: !1,
    tag: !1,
    putCh: !1,
    debugLog: !1,
    baseTx: !1,
    masume: !1,
    // テキストレイヤ：ガイドマス目を表示するか
    variable: !1,
    dumpHtm: !1
  },
  code: {},
  // 暗号化しないフォルダ
  debuger_token: ""
  // デバッガとの接続トークン
};
class Dm {
  constructor(t) {
    this.sys = t;
  }
  oCfg = Am;
  userFnTail = "";
  // 4tst public
  hPathFn2Exts = {};
  async load(t) {
    if (this.oCfg.save_ns = t?.save_ns ?? this.oCfg.save_ns, this.oCfg.window.width = Number(t?.window?.width ?? this.oCfg.window.width), this.oCfg.window.height = Number(t?.window?.height ?? this.oCfg.window.height), this.oCfg.book = { ...this.oCfg.book, ...t.book }, this.oCfg.log.max_len = t.log?.max_len ?? this.oCfg.log.max_len, this.oCfg.init = { ...this.oCfg.init, ...t.init }, this.oCfg.debug = { ...this.oCfg.debug, ...t.debug }, this.oCfg.debuger_token = t.debuger_token, await this.sys.loadPath(this.hPathFn2Exts, this), this.#e = this.matchPath(
      "^breakline$",
      "png|jpg|jpeg|json|svg|webp|mp4|webm"
      /* SP_GSM */
    ).length > 0, this.#t = this.matchPath(
      "^breakpage$",
      "png|jpg|jpeg|json|svg|webp|mp4|webm"
      /* SP_GSM */
    ).length > 0, this.sys.arg.crypto)
      for (const [e, i] of Object.entries(this.hPathFn2Exts))
        for (const [n, s] of Object.entries(i)) {
          if (!n.startsWith(":") || !n.endsWith(":id")) continue;
          const o = s.slice(s.lastIndexOf("/") + 1), a = i[n.slice(0, -10)] ?? "", l = await (await this.sys.fetch(a)).text(), u = this.sys.hash(l);
          if (o !== u) throw `ファイル改竄エラーです fn:${a}`;
        }
    else
      for (const [e, i] of Object.entries(this.hPathFn2Exts))
        for (const n of Object.keys(i))
          n.startsWith(":");
  }
  #e = !1;
  get existsBreakline() {
    return this.#e;
  }
  #t = !1;
  get existsBreakpage() {
    return this.#t;
  }
  getNs() {
    return `skynovel.${this.oCfg.save_ns} - `;
  }
  #i = /([^\/\s]+)\.([^\d]\w+)/;
  // 4 match 498 step(~1ms)  https://regex101.com/r/tpVgmI/1
  searchPath(t, e = "") {
    if (!t) throw "[searchPath] fnが空です";
    if (t.startsWith("http://")) return t;
    const i = t.match(this.#i);
    let n = i ? i[1] : t;
    const s = i ? i[2] : "";
    if (this.userFnTail) {
      const h = n + "@@" + this.userFnTail;
      if (h in this.hPathFn2Exts) {
        if (e === "") n = h;
        else for (const l of Object.keys(this.hPathFn2Exts[h] ?? {}))
          if (`|${e}|`.includes(`|${l}|`)) {
            n = h;
            break;
          }
      }
    }
    const o = this.hPathFn2Exts[n];
    if (!o) throw `サーチパスに存在しないファイル【${t}】です`;
    if (!s) {
      const h = Ye(o[":cnt"]);
      if (e === "") {
        if (h > 1) throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;
        return t;
      }
      const l = `|${e}|`;
      if (h > 1) {
        let u = 0;
        for (const c of Object.keys(o))
          if (l.includes(`|${c}|`) && ++u > 1)
            throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;
      }
      for (const u of Object.keys(o))
        if (l.includes(`|${u}|`)) return o[u];
      throw `サーチ対象拡張子群【${e}】にマッチするファイルがサーチパスに存在しません。探索ファイル名=【${t}】`;
    }
    if (e !== "" && !`|${e}|`.includes(`|${s}|`))
      throw `指定ファイルの拡張子【${s}】は、サーチ対象拡張子群【${e}】にマッチしません。探索ファイル名=【${t}】`;
    const a = o[s];
    if (!a) throw `サーチパスに存在しない拡張子【${s}】です。探索ファイル名=【${t}】、サーチ対象拡張子群【${e}】`;
    return a;
  }
  matchPath(t, e = "") {
    const i = [], n = new RegExp(t), s = new RegExp(e);
    for (const [o, a] of Object.entries(this.hPathFn2Exts)) {
      if (o.search(n) === -1) continue;
      if (e === "") {
        i.push(a);
        continue;
      }
      const h = {};
      let l = !1;
      for (const u of Object.keys(a))
        u.search(s) !== -1 && (h[u] = o, l = !0);
      l && i.push(h);
    }
    return i;
  }
  addPath(t, e) {
    const i = {};
    for (const [n, s] of Object.entries(e))
      i[n] = (n.startsWith(":") ? "" : this.sys.arg.cur) + s;
    this.hPathFn2Exts[t] = i;
  }
}
const { BlurFilter: Lm, ColorMatrixFilter: Gt, NoiseFilter: Fm } = Nm;
class Nt {
  layname = "";
  name_ = "";
  set name(t) {
    this.name_ = t;
  }
  get name() {
    return this.name_;
  }
  ctn = new Bt(ot.EMPTY);
  // tsy用
  get alpha() {
    return this.ctn.alpha;
  }
  set alpha(t) {
    this.ctn.alpha = t;
  }
  get height() {
    return this.ctn.height;
  }
  get rotation() {
    return this.ctn.angle;
  }
  set rotation(t) {
    this.ctn.angle = t;
  }
  get scale_x() {
    return this.ctn.scale.x;
  }
  set scale_x(t) {
    this.ctn.scale.x = t;
  }
  get scale_y() {
    return this.ctn.scale.y;
  }
  set scale_y(t) {
    this.ctn.scale.y = t;
  }
  get width() {
    return this.ctn.width;
  }
  get x() {
    return this.ctn.x;
  }
  set x(t) {
    this.procSetX(t), this.ctn.x = t;
  }
  procSetX(t) {
  }
  // set を override できないので
  get y() {
    return this.ctn.y;
  }
  set y(t) {
    this.procSetY(t), this.ctn.y = t;
  }
  procSetY(t) {
  }
  // set を override できないので
  destroy() {
  }
  lay(t) {
    const e = this.ctn;
    return "alpha" in t && (e.alpha = L(t, "alpha", 1)), Nt.setBlendmode(e, t), ("pivot_x" in t || "pivot_y" in t) && e.pivot.set(
      L(t, "pivot_x", e.pivot.x),
      L(t, "pivot_y", e.pivot.y)
    ), "rotation" in t && (e.angle = L(t, "rotation", 0)), ("scale_x" in t || "scale_y" in t) && e.scale.set(
      L(t, "scale_x", e.scale.x),
      L(t, "scale_y", e.scale.y)
    ), "visible" in t && (e.visible = $(t, "visible", !0)), "filter" in t && (e.filters = [Nt.bldFilters(t)], this.aFltHArg = [t]), !1;
  }
  aFltHArg = [];
  /*
  * 現状未サポート
  	* FXAAFilter		geeks3d.com のコードに基づいた基本的な FXAA (高速近似アンチエイリアシング) の実装ですが、WebGL でサポートされていないため、texture2DLod 要素が削除されたという変更が加えられています。
  	* 	https://pixijs.download/v6.5.10/docs/PIXI.filters.FXAAFilter.html
  	* DisplacementFilter	指定されたテクスチャ (ディスプレイスメント マップと呼ばれる) のピクセル値を使用して、オブジェクトのディスプレイスメントを実行します。
  	* 	https://pixijs.download/v6.5.10/docs/PIXI.filters.DisplacementFilter.html
  	* 		人形城のヒビキとかのやつ？
  */
  // フィルター生成
  static bldFilters(t) {
    const { filter: e = "" } = t, i = Nt.hBldFilter[e];
    if (!i) throw "filter が異常です";
    const n = i(t);
    n.enabled = $(t, "enable_filter", !0);
    const { blendmode: s } = t;
    return s && (n.blendMode = Nt.getBlendmodeNum(s)), n;
  }
  // https://github.com/pixijs/filters
  static hBldFilter = {
    // https://pixijs.download/v6.5.10/docs/PIXI.filters.BlurFilter.html
    blur: (t) => {
      const e = new Lm(
        L(t, "strength", 8),
        // 強さ
        L(t, "quality", 4),
        // 品質
        "resolution" in t ? L(t, "resolution", 0) : void 0,
        // 解像度
        L(t, "kernel_size", 5)
        // カーネルサイズ。値は 5、7、9、11、13、15。
      );
      return e.blurX = bt(L(t, "blur_x", 2)), e.blurY = bt(L(t, "blur_y", 2)), e.repeatEdgePixels = $(t, "repeat_edge_pixels", !1), e;
    },
    // https://pixijs.download/v6.5.10/docs/PIXI.filters.NoiseFilter.html
    noise: (t) => new Fm(
      // ノイズエフェクト
      L(t, "noise", 0.5),
      // 適用するノイズの量。この値は (0, 1] の範囲内
      "seed" in t ? L(t, "seed", 0) : void 0
      // ランダム ノイズの生成に適用するシード値。 Math.random() を使用するのが適切な値です。
    ),
    // https://pixijs.download/v6.5.10/docs/PIXI.filters.ColorMatrixFilter.html
    color_matrix: (t) => {
      const e = new Gt();
      e.alpha = bt(L(t, "alpha", 1));
      const { matrix: i = "" } = t;
      if (i) {
        const n = i.split(","), s = n.length;
        if (s !== 20) throw `matrix の個数（${s}）が 20 ではありません`;
        for (let o = 0; o < s; ++o) e.matrix[o] = bt(n[o]);
      } else
        e.matrix[0] = bt(L(t, "rtor", 1)), e.matrix[1] = bt(L(t, "gtor", 0)), e.matrix[2] = bt(L(t, "btor", 0)), e.matrix[3] = bt(L(t, "ator", 0)), e.matrix[4] = bt(L(t, "pr", 0)), e.matrix[5] = bt(L(t, "rtog", 0)), e.matrix[6] = bt(L(t, "gtog", 1)), e.matrix[7] = bt(L(t, "btog", 0)), e.matrix[8] = bt(L(t, "atog", 0)), e.matrix[9] = bt(L(t, "pg", 0)), e.matrix[10] = bt(L(t, "rtob", 0)), e.matrix[11] = bt(L(t, "gtob", 0)), e.matrix[12] = bt(L(t, "btob", 1)), e.matrix[13] = bt(L(t, "atob", 0)), e.matrix[14] = bt(L(t, "pb", 0)), e.matrix[15] = bt(L(t, "rtoa", 0)), e.matrix[16] = bt(L(t, "gtoa", 0)), e.matrix[17] = bt(L(t, "btoa", 0)), e.matrix[18] = bt(L(t, "atoa", 1)), e.matrix[19] = bt(L(t, "pa", 0));
      return e;
    },
    black_and_white: (t) => {
      const e = new Gt();
      return e.blackAndWhite(
        $(t, "multiply", !1)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    brightness: (t) => {
      const e = new Gt();
      return e.brightness(
        L(t, "b", 0.5),
        // 明るさの値 (0 ～ 1、0 は黒)
        $(t, "multiply", !1)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    browni: (t) => {
      const e = new Gt();
      return e.browni(
        $(t, "multiply", !0)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    color_tone: (t) => {
      const e = new Gt();
      return e.colorTone(
        L(t, "desaturation", 0.5),
        L(t, "toned", 0.5),
        L(t, "light_color", 16770432),
        L(t, "dark_color", 16770432),
        $(t, "multiply", !1)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    contrast: (t) => {
      const e = new Gt();
      return e.contrast(
        L(t, "amount", 0.5),
        // コントラストの値 (0-1)
        $(t, "multiply", !1)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    grayscale: (t) => {
      const e = new Gt();
      return e.grayscale(
        L(t, "scale", 0.5),
        // グレーの値 (0 ～ 1、0 は黒)
        $(t, "multiply", !1)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    hue: (t) => {
      const e = new Gt();
      return e.hue(
        L(t, "f_rotation", 90),
        // 0だと変化なしで分かりづらいので
        // 度単位
        $(t, "multiply", !1)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    kodachrome: (t) => {
      const e = new Gt();
      return e.kodachrome(
        $(t, "multiply", !0)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    lsd: (t) => {
      const e = new Gt();
      return e.lsd(
        $(t, "multiply", !1)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    negative: (t) => {
      const e = new Gt();
      return e.negative(
        $(t, "multiply", !1)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    night: (t) => {
      const e = new Gt();
      return e.night(
        L(t, "intensity", 0.5),
        // 夜の効果の強さ
        $(t, "multiply", !1)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    polaroid: (t) => {
      const e = new Gt();
      return e.polaroid(
        $(t, "multiply", !1)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    predator: (t) => {
      const e = new Gt();
      return e.predator(
        L(t, "amount", 0.5),
        // 捕食者は自分の将来の犠牲者をどれほど感じているか
        $(t, "multiply", !1)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    saturate: (t) => {
      const e = new Gt();
      return e.saturate(
        L(t, "amount", 0.5),
        // 飽和量(0～1)
        $(t, "multiply", !1)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    sepia: (t) => {
      const e = new Gt();
      return e.sepia(
        $(t, "multiply", !1)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    technicolor: (t) => {
      const e = new Gt();
      return e.technicolor(
        $(t, "multiply", !0)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    tint: (t) => {
      const e = new Gt();
      return e.tint(
        L(t, "f_color", 8947848),
        // 色合いの色。 これは 16 進数値です。
        $(t, "multiply", !1)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    to_bgr: (t) => {
      const e = new Gt();
      return e.toBGR(
        $(t, "multiply", !1)
        // true の場合、現在の行列と行列を乗算
      ), e;
    },
    vintage: (t) => {
      const e = new Gt();
      return e.vintage(
        $(t, "multiply", !0)
        // true の場合、現在の行列と行列を乗算
      ), e;
    }
  };
  static setBlendmode(t, e) {
    const { blendmode: i } = e;
    if (!i) return;
    const n = Nt.getBlendmodeNum(i);
    t instanceof Bt && (t.blendMode = n);
    for (const s of t.children)
      s instanceof Bt && (s.blendMode = n);
  }
  static getBlendmodeNum(t) {
    if (!t) return it.NORMAL;
    const e = Nt.#e[t];
    if (e !== void 0) return e;
    throw `${t} はサポートされない blendmode です`;
  }
  static #e = {
    normal: it.NORMAL,
    add: it.ADD,
    multiply: it.MULTIPLY,
    screen: it.SCREEN
    /*
    		'overlay'		: BLEND_MODES.OVERLAY,
    		'darken'		: BLEND_MODES.DARKEN,
    		'lighten'		: BLEND_MODES.LIGHTEN,
    		'color_dodge'	: BLEND_MODES.COLOR_DODGE,
    		'color_burn'	: BLEND_MODES.COLOR_BURN,
    		'hard_light'	: BLEND_MODES.HARD_LIGHT,
    		'soft_light'	: BLEND_MODES.SOFT_LIGHT,
    		'difference'	: BLEND_MODES.DIFFERENCE,
    		'exclusion'		: BLEND_MODES.EXCLUSION,
    		'hue'			: BLEND_MODES.HUE,
    		'saturation'	: BLEND_MODES.SATURATION,
    		'color'			: BLEND_MODES.COLOR,
    		'luminosity'	: BLEND_MODES.LUMINOSITY,
    
    		'normal_npm'	: BLEND_MODES.NORMAL_NPM,
    		'add_npm'		: BLEND_MODES.ADD_NPM,
    		'screen_npm'	: BLEND_MODES.SCREEN_NPM,
    		'none'			: BLEND_MODES.NONE,
    		'src_in'		: BLEND_MODES.SRC_IN,
    		'src_out'		: BLEND_MODES.SRC_OUT,
    		'src_atop'		: BLEND_MODES.SRC_ATOP,
    		'dst_over'		: BLEND_MODES.DST_OVER,
    		'dst_in'		: BLEND_MODES.DST_IN,
    		'dst_out'		: BLEND_MODES.DST_OUT,
    		'dst_atop'		: BLEND_MODES.DST_ATOP,
    		'subtract'		: BLEND_MODES.SUBTRACT,
    		'src_over'		: BLEND_MODES.SRC_OVER,
    		'erase'			: BLEND_MODES.ERASE,
    		'xor'			: BLEND_MODES.XOR,
    */
  };
  static getNum2Blendmode(t) {
    return Nt.#t[t] ?? "normal";
  }
  static #t = {
    0: "normal",
    1: "add",
    2: "multiply",
    3: "screen"
  };
  // アニメ・動画があるか
  get containMovement() {
    return !1;
  }
  renderStart() {
  }
  renderEnd() {
  }
  clearLay(t) {
    this.ctn.alpha = 1, this.ctn.blendMode = it.NORMAL, this.ctn.pivot.set(0, 0), this.ctn.angle = 0, this.ctn.scale.set(1, 1), $(t, "clear_filter", !1) && (this.ctn.filters = null, this.aFltHArg = []);
  }
  copy(t, e) {
    const i = this.name_;
    this.playback(t.record(), e), this.name = i;
  }
  record() {
    return {
      name: this.name_,
      idx: this.ctn.parent.getChildIndex(this.ctn),
      alpha: this.ctn.alpha,
      blendMode: this.ctn.blendMode,
      rotation: this.ctn.angle,
      scale_x: this.ctn.scale.x,
      scale_y: this.ctn.scale.y,
      pivot_x: this.ctn.pivot.x,
      pivot_y: this.ctn.pivot.y,
      x: this.ctn.x,
      y: this.ctn.y,
      visible: this.ctn.visible,
      aFltHArg: this.aFltHArg
    };
  }
  playback(t, e) {
    this.name = t.name, this.clearLay({ clear_filter: !0 }), this.ctn.alpha = t.alpha, this.ctn.blendMode = t.blendMode, this.ctn.angle = t.rotation, this.ctn.scale.set(t.scale_x, t.scale_y), this.ctn.pivot.set(t.pivot_x, t.pivot_y), this.ctn.position.set(t.x, t.y), this.ctn.visible = t.visible, this.aFltHArg = t.aFltHArg ?? [], this.ctn.filters = this.aFltHArg.length === 0 ? null : this.aFltHArg.map((i) => Nt.bldFilters(i));
  }
  snapshot(t, e) {
    t.render(this.ctn, { clear: !1 }), e();
  }
  snapshot_end() {
  }
  makeDesignCast(t) {
  }
  makeDesignCastChildren(t) {
  }
  showDesignCast() {
  }
  showDesignCastChildren() {
  }
  cvsResize() {
  }
  cvsResizeChildren() {
  }
  dump() {
    return ` "idx":${this.ctn.parent.getChildIndex(this.ctn)}, "visible":"${this.ctn.visible}", "left":${this.ctn.x}, "top":${this.ctn.y}, "alpha":${this.ctn.alpha}, "rotation":${this.ctn.angle}, "name":"${this.name_}", "scale_x":${this.ctn.scale.x}, "scale_y":${this.ctn.scale.y}, "filters": [${this.aFltHArg.map((t) => `"${t.filter}"`).join(",")}]`;
  }
  static setXY(t, e, i, n = !1, s = !1) {
    if (e.pos) {
      Nt.setXYByPos(t, e.pos, i);
      return;
    }
    const o = t.getBounds(), a = i.scale.x < 0 ? -i.scale.x : i.scale.x, h = a === 1 ? o.width : o.width * a, l = i.scale.y < 0 ? -i.scale.y : i.scale.y, u = l === 1 ? o.height : o.height * l;
    let c = i.x;
    "left" in e ? (c = L(e, "left", 0), c > -1 && c < 1 && (c *= A.stageW)) : "center" in e ? (c = L(e, "center", 0), c > -1 && c < 1 && (c *= A.stageW), c = c - (s ? h / 3 : h) / 2) : "right" in e ? (c = L(e, "right", 0), c > -1 && c < 1 && (c *= A.stageW), c = c - (s ? h / 3 : h)) : "s_right" in e && (c = L(e, "s_right", 0), c > -1 && c < 1 && (c *= A.stageW), c = A.stageW - c - (s ? h / 3 : h)), i.x = Ye(i.scale.x < 0 ? c + (s ? h / 3 : h) : c);
    let f = i.y;
    "top" in e ? (f = L(e, "top", 0), f > -1 && f < 1 && (f *= A.stageH)) : "middle" in e ? (f = L(e, "middle", 0), f > -1 && f < 1 && (f *= A.stageH), f = f - u / 2) : "bottom" in e ? (f = L(e, "bottom", 0), f > -1 && f < 1 && (f *= A.stageH), f = f - u) : "s_bottom" in e && (f = L(e, "s_bottom", 0), f > -1 && f < 1 && (f *= A.stageH), f = A.stageH - f - u), i.y = Ye(i.scale.y < 0 ? f + u : f), n && !("left" in e) && !("center" in e) && !("right" in e) && !("s_right" in e) && !("top" in e) && !("middle" in e) && !("bottom" in e) && !("s_bottom" in e) && Nt.setXYByPos(t, "c", i);
  }
  static setXYByPos(t, e, i) {
    if (e === "stay") return;
    if (t === void 0) throw "setXYByPos base === undefined";
    if (i === void 0) throw "setXYByPos result === undefined";
    const n = t.getBounds(), s = i.scale.x < 0 ? -i.scale.x : i.scale.x, o = s === 1 ? n.width : n.width * s, a = i.scale.y < 0 ? -i.scale.y : i.scale.y, h = a === 1 ? n.height : n.height * a;
    let l = 0;
    !e || e === "c" ? l = A.stageW * 0.5 : e === "r" ? l = A.stageW - o * 0.5 : e === "l" ? l = o * 0.5 : l = Ye(e), i.x = Ye(l - o * 0.5), i.y = A.stageH - h, i.scale.x < 0 && (i.x += o), i.scale.y < 0 && (i.y += h);
  }
  static setXYCenter(t) {
    const e = t.getBounds();
    t.x = (A.stageW - e.width) * 0.5, t.y = (A.stageH - e.height) * 0.5;
  }
}
var _t = Object.freeze({
  Linear: Object.freeze({
    None: function(r) {
      return r;
    },
    In: function(r) {
      return r;
    },
    Out: function(r) {
      return r;
    },
    InOut: function(r) {
      return r;
    }
  }),
  Quadratic: Object.freeze({
    In: function(r) {
      return r * r;
    },
    Out: function(r) {
      return r * (2 - r);
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1);
    }
  }),
  Cubic: Object.freeze({
    In: function(r) {
      return r * r * r;
    },
    Out: function(r) {
      return --r * r * r + 1;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2);
    }
  }),
  Quartic: Object.freeze({
    In: function(r) {
      return r * r * r * r;
    },
    Out: function(r) {
      return 1 - --r * r * r * r;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r : -0.5 * ((r -= 2) * r * r * r - 2);
    }
  }),
  Quintic: Object.freeze({
    In: function(r) {
      return r * r * r * r * r;
    },
    Out: function(r) {
      return --r * r * r * r * r + 1;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r * r : 0.5 * ((r -= 2) * r * r * r * r + 2);
    }
  }),
  Sinusoidal: Object.freeze({
    In: function(r) {
      return 1 - Math.sin((1 - r) * Math.PI / 2);
    },
    Out: function(r) {
      return Math.sin(r * Math.PI / 2);
    },
    InOut: function(r) {
      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - r)));
    }
  }),
  Exponential: Object.freeze({
    In: function(r) {
      return r === 0 ? 0 : Math.pow(1024, r - 1);
    },
    Out: function(r) {
      return r === 1 ? 1 : 1 - Math.pow(2, -10 * r);
    },
    InOut: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2) < 1 ? 0.5 * Math.pow(1024, r - 1) : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2);
    }
  }),
  Circular: Object.freeze({
    In: function(r) {
      return 1 - Math.sqrt(1 - r * r);
    },
    Out: function(r) {
      return Math.sqrt(1 - --r * r);
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r * r) - 1) : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1);
    }
  }),
  Elastic: Object.freeze({
    In: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : -Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI);
    },
    Out: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : Math.pow(2, -10 * r) * Math.sin((r - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2, r < 1 ? -0.5 * Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) + 1);
    }
  }),
  Back: Object.freeze({
    In: function(r) {
      var t = 1.70158;
      return r === 1 ? 1 : r * r * ((t + 1) * r - t);
    },
    Out: function(r) {
      var t = 1.70158;
      return r === 0 ? 0 : --r * r * ((t + 1) * r + t) + 1;
    },
    InOut: function(r) {
      var t = 2.5949095;
      return (r *= 2) < 1 ? 0.5 * (r * r * ((t + 1) * r - t)) : 0.5 * ((r -= 2) * r * ((t + 1) * r + t) + 2);
    }
  }),
  Bounce: Object.freeze({
    In: function(r) {
      return 1 - _t.Bounce.Out(1 - r);
    },
    Out: function(r) {
      return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;
    },
    InOut: function(r) {
      return r < 0.5 ? _t.Bounce.In(r * 2) * 0.5 : _t.Bounce.Out(r * 2 - 1) * 0.5 + 0.5;
    }
  }),
  generatePow: function(r) {
    return r === void 0 && (r = 4), r = r < Number.EPSILON ? Number.EPSILON : r, r = r > 1e4 ? 1e4 : r, {
      In: function(t) {
        return Math.pow(t, r);
      },
      Out: function(t) {
        return 1 - Math.pow(1 - t, r);
      },
      InOut: function(t) {
        return t < 0.5 ? Math.pow(t * 2, r) / 2 : (1 - Math.pow(2 - t * 2, r)) / 2 + 0.5;
      }
    };
  }
}), or = function() {
  return performance.now();
}, Bm = (
  /** @class */
  function() {
    function r() {
      this._tweens = {}, this._tweensAddedDuringUpdate = {};
    }
    return r.prototype.getAll = function() {
      var t = this;
      return Object.keys(this._tweens).map(function(e) {
        return t._tweens[e];
      });
    }, r.prototype.removeAll = function() {
      this._tweens = {};
    }, r.prototype.add = function(t) {
      this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t;
    }, r.prototype.remove = function(t) {
      delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()];
    }, r.prototype.update = function(t, e) {
      t === void 0 && (t = or()), e === void 0 && (e = !1);
      var i = Object.keys(this._tweens);
      if (i.length === 0)
        return !1;
      for (; i.length > 0; ) {
        this._tweensAddedDuringUpdate = {};
        for (var n = 0; n < i.length; n++) {
          var s = this._tweens[i[n]], o = !e;
          s && s.update(t, o) === !1 && !e && delete this._tweens[i[n]];
        }
        i = Object.keys(this._tweensAddedDuringUpdate);
      }
      return !0;
    }, r;
  }()
), co = {
  Linear: function(r, t) {
    var e = r.length - 1, i = e * t, n = Math.floor(i), s = co.Utils.Linear;
    return t < 0 ? s(r[0], r[1], i) : t > 1 ? s(r[e], r[e - 1], e - i) : s(r[n], r[n + 1 > e ? e : n + 1], i - n);
  },
  Utils: {
    Linear: function(r, t, e) {
      return (t - r) * e + r;
    }
  }
}, _l = (
  /** @class */
  function() {
    function r() {
    }
    return r.nextId = function() {
      return r._nextId++;
    }, r._nextId = 0, r;
  }()
), fo = new Bm(), Er = (
  /** @class */
  function() {
    function r(t, e) {
      e === void 0 && (e = fo), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = !1, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = _t.Linear.None, this._interpolationFunction = co.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = _l.nextId(), this._isChainStopped = !1, this._propertiesAreSetUp = !1, this._goToEnd = !1;
    }
    return r.prototype.getId = function() {
      return this._id;
    }, r.prototype.isPlaying = function() {
      return this._isPlaying;
    }, r.prototype.isPaused = function() {
      return this._isPaused;
    }, r.prototype.getDuration = function() {
      return this._duration;
    }, r.prototype.to = function(t, e) {
      if (e === void 0 && (e = 1e3), this._isPlaying)
        throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
      return this._valuesEnd = t, this._propertiesAreSetUp = !1, this._duration = e < 0 ? 0 : e, this;
    }, r.prototype.duration = function(t) {
      return t === void 0 && (t = 1e3), this._duration = t < 0 ? 0 : t, this;
    }, r.prototype.dynamic = function(t) {
      return t === void 0 && (t = !1), this._isDynamic = t, this;
    }, r.prototype.start = function(t, e) {
      if (t === void 0 && (t = or()), e === void 0 && (e = !1), this._isPlaying)
        return this;
      if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {
        this._reversed = !1;
        for (var i in this._valuesStartRepeat)
          this._swapEndStartRepeatValues(i), this._valuesStart[i] = this._valuesStartRepeat[i];
      }
      if (this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t, this._startTime += this._delayTime, !this._propertiesAreSetUp || e) {
        if (this._propertiesAreSetUp = !0, !this._isDynamic) {
          var n = {};
          for (var s in this._valuesEnd)
            n[s] = this._valuesEnd[s];
          this._valuesEnd = n;
        }
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, e);
      }
      return this;
    }, r.prototype.startFromCurrentValues = function(t) {
      return this.start(t, !0);
    }, r.prototype._setupProperties = function(t, e, i, n, s) {
      for (var o in i) {
        var a = t[o], h = Array.isArray(a), l = h ? "array" : typeof a, u = !h && Array.isArray(i[o]);
        if (!(l === "undefined" || l === "function")) {
          if (u) {
            var c = i[o];
            if (c.length === 0)
              continue;
            for (var f = [a], d = 0, p = c.length; d < p; d += 1) {
              var v = this._handleRelativeValue(a, c[d]);
              if (isNaN(v)) {
                u = !1, console.warn("Found invalid interpolation list. Skipping.");
                break;
              }
              f.push(v);
            }
            u && (i[o] = f);
          }
          if ((l === "object" || h) && a && !u) {
            e[o] = h ? [] : {};
            var _ = a;
            for (var m in _)
              e[o][m] = _[m];
            n[o] = h ? [] : {};
            var c = i[o];
            if (!this._isDynamic) {
              var y = {};
              for (var m in c)
                y[m] = c[m];
              i[o] = c = y;
            }
            this._setupProperties(_, e[o], c, n[o], s);
          } else
            (typeof e[o] > "u" || s) && (e[o] = a), h || (e[o] *= 1), u ? n[o] = i[o].slice().reverse() : n[o] = e[o] || 0;
        }
      }
    }, r.prototype.stop = function() {
      return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
    }, r.prototype.end = function() {
      return this._goToEnd = !0, this.update(1 / 0), this;
    }, r.prototype.pause = function(t) {
      return t === void 0 && (t = or()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this), this);
    }, r.prototype.resume = function(t) {
      return t === void 0 && (t = or()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);
    }, r.prototype.stopChainedTweens = function() {
      for (var t = 0, e = this._chainedTweens.length; t < e; t++)
        this._chainedTweens[t].stop();
      return this;
    }, r.prototype.group = function(t) {
      return t === void 0 && (t = fo), this._group = t, this;
    }, r.prototype.delay = function(t) {
      return t === void 0 && (t = 0), this._delayTime = t, this;
    }, r.prototype.repeat = function(t) {
      return t === void 0 && (t = 0), this._initialRepeat = t, this._repeat = t, this;
    }, r.prototype.repeatDelay = function(t) {
      return this._repeatDelayTime = t, this;
    }, r.prototype.yoyo = function(t) {
      return t === void 0 && (t = !1), this._yoyo = t, this;
    }, r.prototype.easing = function(t) {
      return t === void 0 && (t = _t.Linear.None), this._easingFunction = t, this;
    }, r.prototype.interpolation = function(t) {
      return t === void 0 && (t = co.Linear), this._interpolationFunction = t, this;
    }, r.prototype.chain = function() {
      for (var t = [], e = 0; e < arguments.length; e++)
        t[e] = arguments[e];
      return this._chainedTweens = t, this;
    }, r.prototype.onStart = function(t) {
      return this._onStartCallback = t, this;
    }, r.prototype.onEveryStart = function(t) {
      return this._onEveryStartCallback = t, this;
    }, r.prototype.onUpdate = function(t) {
      return this._onUpdateCallback = t, this;
    }, r.prototype.onRepeat = function(t) {
      return this._onRepeatCallback = t, this;
    }, r.prototype.onComplete = function(t) {
      return this._onCompleteCallback = t, this;
    }, r.prototype.onStop = function(t) {
      return this._onStopCallback = t, this;
    }, r.prototype.update = function(t, e) {
      var i = this, n;
      if (t === void 0 && (t = or()), e === void 0 && (e = !0), this._isPaused)
        return !0;
      var s, o = this._startTime + this._duration;
      if (!this._goToEnd && !this._isPlaying) {
        if (t > o)
          return !1;
        e && this.start(t, !0);
      }
      if (this._goToEnd = !1, t < this._startTime)
        return !0;
      this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), this._onEveryStartCallbackFired === !1 && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0);
      var a = t - this._startTime, h = this._duration + ((n = this._repeatDelayTime) !== null && n !== void 0 ? n : this._delayTime), l = this._duration + this._repeat * h, u = function() {
        if (i._duration === 0 || a > l)
          return 1;
        var _ = Math.trunc(a / h), m = a - _ * h, y = Math.min(m / i._duration, 1);
        return y === 0 && a === i._duration ? 1 : y;
      }, c = u(), f = this._easingFunction(c);
      if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, f), this._onUpdateCallback && this._onUpdateCallback(this._object, c), this._duration === 0 || a >= this._duration)
        if (this._repeat > 0) {
          var d = Math.min(Math.trunc((a - this._duration) / h) + 1, this._repeat);
          isFinite(this._repeat) && (this._repeat -= d);
          for (s in this._valuesStartRepeat)
            !this._yoyo && typeof this._valuesEnd[s] == "string" && (this._valuesStartRepeat[s] = // eslint-disable-next-line
            // @ts-ignore FIXME?
            this._valuesStartRepeat[s] + parseFloat(this._valuesEnd[s])), this._yoyo && this._swapEndStartRepeatValues(s), this._valuesStart[s] = this._valuesStartRepeat[s];
          return this._yoyo && (this._reversed = !this._reversed), this._startTime += h * d, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0;
        } else {
          this._onCompleteCallback && this._onCompleteCallback(this._object);
          for (var p = 0, v = this._chainedTweens.length; p < v; p++)
            this._chainedTweens[p].start(this._startTime + this._duration, !1);
          return this._isPlaying = !1, !1;
        }
      return !0;
    }, r.prototype._updateProperties = function(t, e, i, n) {
      for (var s in i)
        if (e[s] !== void 0) {
          var o = e[s] || 0, a = i[s], h = Array.isArray(t[s]), l = Array.isArray(a), u = !h && l;
          u ? t[s] = this._interpolationFunction(a, n) : typeof a == "object" && a ? this._updateProperties(t[s], o, a, n) : (a = this._handleRelativeValue(o, a), typeof a == "number" && (t[s] = o + (a - o) * n));
        }
    }, r.prototype._handleRelativeValue = function(t, e) {
      return typeof e != "string" ? e : e.charAt(0) === "+" || e.charAt(0) === "-" ? t + parseFloat(e) : parseFloat(e);
    }, r.prototype._swapEndStartRepeatValues = function(t) {
      var e = this._valuesStartRepeat[t], i = this._valuesEnd[t];
      typeof i == "string" ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(i) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = e;
    }, r;
  }()
);
_l.nextId;
var Le = fo;
Le.getAll.bind(Le);
var Um = Le.removeAll.bind(Le);
Le.add.bind(Le);
var ml = Le.remove.bind(Le), Gm = Le.update.bind(Le);
class j {
  static #e;
  static get rs() {
    return this.#e;
  }
  constructor() {
    j.#e = this;
  }
  static #t = {};
  static #i = {};
  static setEvt2Fnc(t, e, i) {
    t ? this.#i[e] = i : this.#t[e] = i;
  }
  static getEvt2Fnc = (t) => this.#t[t] ?? this.#i[t];
  static clear_eventer(t, e, i) {
    if (!t.startsWith("dom=")) return;
    const n = e ? this.#i[i] : this.#t[i];
    n && this.getHtmlElmList(t).el.forEach((s) => s.removeEventListener("click", n)), e ? delete this.#i[i] : delete this.#t[i];
  }
  static popLocalEvts() {
    const t = this.#t;
    return this.#t = {}, t;
  }
  static pushLocalEvts(t) {
    this.#t = t;
  }
  static clear_event(t) {
    const e = $(t, "global", !1), i = e ? this.#i : this.#t;
    for (const [n, s] of Object.entries(i))
      n.startsWith("dom=") && this.getHtmlElmList(n).el.forEach((o) => o.removeEventListener("click", s));
    return e ? this.#i = {} : this.#t = {}, !1;
  }
  static getHtmlElmList(t) {
    const e = t.indexOf(":");
    let i = "";
    if (e >= 0) {
      const n = t.slice(4, e), s = `const.sn.frm.${n}`;
      if (!D.val.getVal(`tmp:${s}`, 0)) throw `HTML【${n}】が読み込まれていません`;
      const a = document.getElementById(n).contentWindow;
      return i = t.slice(e + 1), { el: a.document.querySelectorAll(i), id: n, sel: i };
    }
    return i = t.slice(4), { el: document.querySelectorAll(i), id: "", sel: i };
  }
  // 予約イベントの発生待ち
  static waitRsvEvent(t, e) {
    if (D.val.saveKidoku(), e ? this.#t.click = this.#t.enter = this.#t.arrowdown = // hTag.event({key:'downwheel', breakout: fnc});
    this.#t["wheel.y>0"] = () => e() : (delete this.#t.click, delete this.#t.enter, delete this.#t.arrowdown, delete this.#t["wheel.y>0"]), this.getEvt2Fnc = t ? (i) => this.#t[i] ?? this.#i[i] : (i) => this.#t[i], D.scrItr.noticeWait(), A.debugLog) {
      const i = /* @__PURE__ */ Object.create(null);
      i.local = Object.keys(this.#t), i.global = Object.keys(this.#i), console.log("🎍 wait event... %o", i);
    }
  }
  static waitRsvEvent4Paging() {
    if (this.waitRsvEvent(!0), this.aKeysAtPaging.length === 0) {
      this.getEvt2Fnc = (e) => this.#t[e] ?? this.#i[e];
      return;
    }
    const t = {};
    for (const e of this.aKeysAtPaging) {
      const i = this.#i[e];
      i && (t[e] = i);
    }
    this.getEvt2Fnc = (e) => this.#t[e] ?? t[e];
  }
  fire(t, e) {
    const i = t.toLowerCase();
    switch (i) {
      case "click":
      case "rightclick":
      // 右クリックメニューに入って出られない
      case "middleclick":
      // 〃
      case "enter":
      case "arrowdown":
        if (!j.isFirstFire()) return;
        break;
    }
    if (i === "enter") {
      const s = D.fcs.getFocus();
      if (s instanceof Ct) {
        s.emit(Or, new PointerEvent(Or));
        return;
      }
    }
    const n = j.getEvt2Fnc(i);
    n && (e.stopImmediatePropagation(), !(!i.startsWith("dom=") && D.layMng.clickTxtLay()) && n(e));
  }
  get isSkipping() {
    return D.skip_enabled;
  }
  isWait = !1;
  // イベント複数発生回避（ボタンとステージクリックなど）
  static #n = !1;
  static isFirstFire() {
    return j.#n ? !1 : (j.#n = !0, !0);
  }
  static resetFired() {
    j.#n = !1;
  }
  static aPage;
  static lenPage = 0;
  static posPage = 0;
  static styPaging;
  static INI_STYPAGE = "color: yellow; text-shadow: 1px 1px 0 #000, -1px 1px 0 #000, 1px -1px 0 #000, -1px -1px 0 #000;";
  static aKeysAtPaging = [];
  static recodePage(t = !1) {
    if (!D.val.getVal("save:sn.doRecLog")) return;
    const { fn: e, idx: i } = D.scrItr.nowScrIdx(), n = `${i - 1}:` + e;
    if (this.aPage.findIndex((o) => o.key === n) > -1) return;
    A.debugLog && console.log(`📜 %crecodePage === week:${t} lenPage:${this.lenPage} len:${this.aPage.length} POP:${!!this.aPage.at(-1)?.week}`, "color:#3B0;"), this.aPage.at(-1)?.week && this.aPage.pop();
    const { max_len: s } = D.cfg.oCfg.log;
    if (this.aPage.push({
      key: n,
      week: t,
      fn: D.val.getVal("save:const.sn.scriptFn", e),
      index: D.val.getVal("save:const.sn.scriptIdx", 0),
      mark: D.scrItr.nowMark()
    }) > s && (this.aPage = this.aPage.slice(-s)), this.lenPage = this.aPage.length, A.debugLog) {
      const o = D.scrItr.nowMark();
      console.log(`   %clenPage:${this.lenPage} (base=${o.hPages.base.fore.sBkFn} 0=${o.hPages[0].fore.sBkFn} mes=${o.hPages.mes.fore.txs.cssText.match(/color: \w+;/)})%c mark:%o`, "color:#3B0;", "", o), console.table(this.aPage);
    }
    D.val.setVal_Nochk("sys", "const.sn.aPageLog", JSON.stringify(this.aPage));
  }
  static playbackPage(t, e) {
    this.aPage = JSON.parse(t), this.lenPage = this.aPage.length, this.posPage >= this.lenPage && (this.posPage = this.lenPage - 1), this.styPaging = e;
  }
  beginProc() {
    new yl();
  }
  endProc() {
    new Sr();
  }
  // タグ処理
  l(t) {
    if (!D.tagL_enabled) return !1;
    if (j.recodePage(!0), D.auto_enabled)
      return t.time = Number(D.val.getVal(`sys:sn.auto.msecLineWait${D.scrItr.isKidoku ? "_Kidoku" : ""}`)), this.wait(t);
    if (D.skip_enabled) {
      if (!D.skip_all && !D.scrItr.isNextKidoku)
        D.cancelAutoSkip();
      else if ("ps".includes(D.val.getVal("sys:sn.skip.mode")))
        return t.time = 50, this.wait(t);
    }
    return $(t, "visible", !0) && (D.layMng.breakLine(t), D.goTxt()), new dn(t), !0;
  }
  p(t) {
    if (j.recodePage(), D.auto_enabled)
      return t.time = Number(D.val.getVal(`sys:sn.auto.msecPageWait${D.scrItr.isKidoku ? "_Kidoku" : ""}`)), this.wait(t);
    if (D.skip_enabled) {
      if (!D.skip_all && !D.scrItr.isNextKidoku)
        D.cancelAutoSkip();
      else if (D.val.getVal("sys:sn.skip.mode") == "s")
        return t.time = 50, this.wait(t);
    }
    return $(t, "visible", !0) && (D.layMng.breakPage(t), D.goTxt()), new dn(t), !0;
  }
  s(t) {
    return j.recodePage(), D.cancelAutoSkip(), new dn(t), !0;
  }
  wait(t) {
    const e = L(t, "time", NaN);
    if (D.skip_enabled)
      return !D.skip_all && !D.scrItr.isNextKidoku && D.cancelAutoSkip(), !1;
    const i = new Er({}), n = "wait", s = () => {
      ml(i), D.notifyEndProc(n);
    };
    i.to({}, e).onComplete(s).start();
    const o = $(t, "canskip", !0);
    return D.beginProc(n, s, !0, o ? s : void 0), !0;
  }
  page(t) {
    if (!("clear" in t || "to" in t || "style" in t)) throw "clear,style,to いずれかは必須です";
    const { key: e, style: i } = t;
    return e && (j.aKeysAtPaging = e.split(",")), i ? (j.styPaging = i, D.val.setVal_Nochk("save", "const.sn.styPaging", i), !1) : ($(t, "clear", !1) && (j.aPage = [], j.lenPage = 0, j.posPage = 0, D.val.setVal_Nochk("sys", "const.sn.aPageLog", "[]"), D.val.setVal_Nochk("save", "const.sn.styPaging", j.INI_STYPAGE)), !1);
  }
  static destroy() {
    this.#t = {}, this.#i = {}, this.aPage = [], this.lenPage = 0, this.posPage = 0;
  }
}
class Sr extends j {
  constructor() {
    super(), A.debugLog && console.log("📖 => %cReadingState_go", "color:#3B0;"), D.main.resume();
  }
  fire(t, e) {
  }
  // システムボタンなど無効化
}
class yl extends j {
  constructor() {
    super(), A.debugLog && console.log("📖 => %cReadingState_proc", "color:#3B0;");
  }
  fire(t, e) {
  }
  // システムボタンなど無効化
}
class dn extends j {
  constructor(t) {
    super(), A.debugLog && console.log("📖 => %cReadingState_wait", "color:#3B0;");
    let e = () => {
    };
    const i = $(t, "global", !0);
    switch (t[":タグ名"]) {
      case "wait":
        return;
      // 予約イベント待ち【しない】
      case "s":
        j.waitRsvEvent(i);
        return;
      case "p":
        e = () => {
          $(t, "er", !1) && D.hTag.er(t), D.sndMng.clearCache(), new Sr();
        };
        break;
      default:
        e = () => new Sr();
    }
    j.waitRsvEvent(i, e);
  }
  isWait = !0;
  page(t) {
    const e = super.page(t), { to: i } = t;
    if (!i) return e;
    if (j.lenPage < 2) return !1;
    switch (i) {
      case "oldest":
        t.to = "prev", j.posPage = 1;
        break;
      case "newest":
      case "prev":
        t.to = "prev", j.posPage = j.lenPage - 1;
        break;
      // case 'next':		// スルー
      default:
        return !1;
    }
    return Ao.go(t);
  }
}
class Ao extends j {
  constructor() {
    super(), A.debugLog && console.log("📖 => %cReadingState_page", "color:#3B0;"), D.val.setVal_Nochk("tmp", "const.sn.isPaging", !0);
  }
  static go(t) {
    return new Ao().page(t);
  }
  #e = !0;
  get isSkipping() {
    return this.#e;
  }
  isWait = !1;
  beginProc() {
    D.main.stop();
  }
  endProc() {
    D.main.resume();
  }
  // タグ処理
  l(t) {
    return this.#e ? j.posPage === j.lenPage - 1 ? (this.#t(), new Sr().l(t)) : ($(t, "visible", !0) && D.layMng.breakLine(t), D.layMng.setAllStyle2TxtLay(j.styPaging), D.goTxt(), j.aPage[j.posPage]?.week ? (j.waitRsvEvent4Paging(), !0) : !1) : super.l(t);
  }
  p(t) {
    return this.#e ? j.posPage === j.lenPage - 1 ? (this.#t(), new Sr().p(t)) : ($(t, "visible", !0) && D.layMng.breakPage(t), D.layMng.setAllStyle2TxtLay(j.styPaging), D.goTxt(), j.waitRsvEvent4Paging(), !0) : super.p(t);
  }
  s(t) {
    return new dn(t), !0;
  }
  wait() {
    return !1;
  }
  page(t) {
    const { to: e, style: i, clear: n } = t;
    if (i || n) return !1;
    switch (A.debugLog && console.log(`📜 %cpage() pos:${j.posPage}%c len:${j.lenPage} to:${e}`, "color:#3B0;", ""), e) {
      case "oldest":
        if (j.posPage === 0) return !1;
        j.posPage = 0;
        break;
      case "prev":
        if (j.posPage === 0) return !1;
        --j.posPage;
        break;
      case "next":
        if (j.posPage === j.lenPage - 1) return !1;
        ++j.posPage;
        break;
      case "newest":
        if (j.posPage === j.lenPage - 1) return !1;
        j.posPage = j.lenPage - 1;
        break;
      case "exit":
        j.posPage = j.lenPage - 1;
        break;
      case "load":
        j.lenPage = j.posPage + 1, j.aPage = j.aPage.slice(0, j.lenPage), this.#t();
        break;
      default:
        throw `属性to「${e}」は異常です`;
    }
    j.posPage === j.lenPage - 1 && this.#t();
    const s = j.aPage[j.posPage];
    if (!s) throw `posPage異常:${j.posPage}`;
    const { fn: o, index: a, mark: h } = s;
    if (A.debugLog) {
      const l = D.scrItr.nowMark(), { week: u } = j.aPage[j.posPage] ?? { week: !1 };
      console.log(`   -- fn:${o} i:${a} pos:${j.posPage} (base=%c${l.hPages.base.fore.sBkFn}%c 0=%c${l.hPages[0].fore.sBkFn}%c mes=%c${l.hPages.mes.fore.txs.cssText.match(/color: \w+;/)}%c) week:${u} A:${j.posPage === j.lenPage - 1}
   styPaging=%c${j.styPaging}%c
   mark:%o`, "background-color:#3B0; color:#000;", "", "background-color:#B4F; color:#000;", "", "color:#B68;", "", j.styPaging, "", h);
    }
    return D.scrItr.loadFromMark({ fn: o, index: a }, h);
  }
  #t() {
    D.val.setVal_Nochk("tmp", "const.sn.isPaging", !1), this.#e = !1;
  }
}
class D {
  static beginProc(t, e, i = !0, n) {
    if (A.debugLog && console.log(`📖.beginProc id:%c${t}%c onNotify:${!!e} endProc:${i} onClickSkip:${!!n}`, "color:#3B0;", ""), this.#e(), this.#n = t, e) {
      const { promise: s, resolve: o } = Promise.withResolvers();
      s.then((a) => {
        A.debugLog && console.log(`📖.callBack id:%c${a}%c`, "color:#3B0;", ""), e(), i ? this.endProc(a) : this.#e();
      }), this.#i = o;
    }
    if (n) {
      const s = () => {
        this.cancelAutoSkip(), n(), i && this.endProc(t);
      };
      this.#t.add(this.main.cvs, Or, (o) => {
        o.stopPropagation(), s();
      }), this.#t.add(document, Ie, (o) => {
        o.isComposing || (o.stopPropagation(), s());
      }), this.procWheel4wle(this.#t, s);
    }
    j.rs.beginProc();
  }
  static #e() {
    this.#n = "", this.#i = () => {
    }, this.#t.clear();
  }
  static #t = new Wi();
  static #i = () => {
  };
  static notifyEndProc(t) {
    A.debugLog && console.log(`📖.notifyEndProc id:%c${t}%c=${this.#n === t}`, "color:#3B0;", ""), this.#n === t && this.#i(t);
  }
  static endProc(t) {
    A.debugLog && console.log(`📖.endProc id:%c${t}%c=${this.#n === t}`, "color:#3B0;", ""), this.#n === t && (j.rs.endProc(), this.#e());
  }
  static #n = "";
  static get procID() {
    return `RP_${this.scrItr.scriptFn}:${this.scrItr.idxToken}_`;
  }
  static fire(t, e, i = !1) {
    i && this.cancelAutoSkip(), j.rs.fire(t, e);
  }
  static get isSkipping() {
    return j.rs.isSkipping;
  }
  static get isWait() {
    return j.rs.isWait;
  }
  // 予約イベントの発生待ち中か
  static tagL_enabled = !0;
  // 頁末まで一気に読み進むか(l無視)
  static skip_all = !1;
  // falseなら既読のみをスキップ
  static skip_enabled = !1;
  // 次の選択肢(/未読)まで進むが有効か
  static auto_enabled = !1;
  // 自動読みすすみモードかどうか
  static cfg;
  static hTag;
  static main;
  static val;
  static scrItr;
  static layMng;
  static goTxt = () => {
  };
  static get needGoTxt() {
    return this.layMng.needGoTxt;
  }
  static evtMng;
  static sndMng;
  static procWheel4wle;
  static fcs;
  static init(t, e, i, n, s, o, a, h, l) {
    this.cfg = t, this.hTag = e, this.main = i, this.val = n, this.scrItr = s, this.layMng = o, this.goTxt = () => o.goTxt(), this.evtMng = a, this.sndMng = h, this.procWheel4wle = l, n.defTmp("sn.tagL.enabled", () => this.tagL_enabled), n.defValTrg("tmp:sn.tagL.enabled", (u, c) => this.tagL_enabled = String(c) !== "false"), n.defTmp("sn.skip.all", () => this.skip_all), n.defValTrg("tmp:sn.skip.all", (u, c) => this.skip_all = String(c) !== "false"), n.defTmp("sn.skip.enabled", () => this.skip_enabled), n.defValTrg("tmp:sn.skip.enabled", (u, c) => this.skip_enabled = String(c) !== "false"), n.defTmp("sn.auto.enabled", () => this.auto_enabled), n.defValTrg("tmp:sn.auto.enabled", (u, c) => this.auto_enabled = String(c) !== "false"), e.l = (u) => j.rs.l(u), e.p = (u) => j.rs.p(u), e.s = (u) => j.rs.s(u), e.wait = (u) => j.rs.wait(u), e.waitclick = (u) => j.rs.s(u), e.page = (u) => j.rs.page(u), new yl(), e.jump({ fn: "main" });
  }
  static setFcs(t) {
    this.fcs = t;
  }
  static cancelAutoSkip() {
    this.tagL_enabled || (this.tagL_enabled = !0, this.val.setVal_Nochk("tmp", "sn.tagL.enabled", !0)), this.skip_enabled && (this.skip_enabled = !1, this.val.setVal_Nochk("tmp", "sn.skip.enabled", !1)), this.auto_enabled && (this.auto_enabled = !1, this.val.setVal_Nochk("tmp", "sn.auto.enabled", !1));
  }
}
const Oe = `trans
`, Li = "tsy nm:";
class Ft {
  static #e = {};
  static #t;
  static #i;
  static init(t, e) {
    this.#e = {}, this.#t = t, this.#i = e, this.#i.ticker.add(this.#n);
  }
  static #n = () => Gm();
  static destroy() {
    this.stopAllTw(), this.#i.ticker.remove(this.#n);
  }
  static setTwProp(t, e) {
    const i = L(e, "repeat", 1);
    return t.delay(L(e, "delay", 0)).easing(this.ease(e.ease)).repeat(i > 0 ? i - 1 : 1 / 0).yoyo($(e, "yoyo", !1));
  }
  static #r = {
    "Back.In": (t) => _t.Back.In(t),
    "Back.InOut": (t) => _t.Back.InOut(t),
    "Back.Out": (t) => _t.Back.Out(t),
    "Bounce.In": (t) => _t.Bounce.In(t),
    "Bounce.InOut": (t) => _t.Bounce.InOut(t),
    "Bounce.Out": (t) => _t.Bounce.Out(t),
    "Circular.In": (t) => _t.Circular.In(t),
    "Circular.InOut": (t) => _t.Circular.InOut(t),
    "Circular.Out": (t) => _t.Circular.Out(t),
    "Cubic.In": (t) => _t.Cubic.In(t),
    "Cubic.InOut": (t) => _t.Cubic.InOut(t),
    "Cubic.Out": (t) => _t.Cubic.Out(t),
    "Elastic.In": (t) => _t.Elastic.In(t),
    "Elastic.InOut": (t) => _t.Elastic.InOut(t),
    "Elastic.Out": (t) => _t.Elastic.Out(t),
    "Exponential.In": (t) => _t.Exponential.In(t),
    "Exponential.InOut": (t) => _t.Exponential.InOut(t),
    "Exponential.Out": (t) => _t.Exponential.Out(t),
    "Linear.None": (t) => _t.Linear.None(t),
    "Quadratic.In": (t) => _t.Quadratic.In(t),
    "Quadratic.InOut": (t) => _t.Quadratic.InOut(t),
    "Quadratic.Out": (t) => _t.Quadratic.Out(t),
    "Quartic.In": (t) => _t.Quartic.In(t),
    "Quartic.InOut": (t) => _t.Quartic.InOut(t),
    "Quartic.Out": (t) => _t.Quartic.Out(t),
    "Quintic.In": (t) => _t.Quintic.In(t),
    "Quintic.InOut": (t) => _t.Quintic.InOut(t),
    "Quintic.Out": (t) => _t.Quintic.Out(t),
    "Sinusoidal.In": (t) => _t.Sinusoidal.In(t),
    "Sinusoidal.InOut": (t) => _t.Sinusoidal.InOut(t),
    "Sinusoidal.Out": (t) => _t.Sinusoidal.Out(t)
  };
  static ease(t) {
    if (!t) return (i) => _t.Linear.None(i);
    const e = this.#r[t];
    if (!e) throw "異常なease指定です";
    return e;
  }
  static hMemberCnt = {
    alpha: 0,
    height: 0,
    rotation: 0,
    // rotationX〜Z、scaleZ、zは設定すると
    scale_x: 0,
    // 三次元方向の拡大縮小ルーチンが働き画像がぼやけるので
    scale_y: 0,
    // backlayで設定しない方針
    pivot_x: 0,
    pivot_y: 0,
    width: 0,
    x: 0,
    y: 0
  };
  static cnvTweenArg(t, e) {
    const i = {};
    for (const n of Object.keys(this.hMemberCnt)) {
      const s = t[n];
      if (!s) continue;
      const o = String(s), a = o.startsWith("="), h = a ? o.slice(1) : o;
      if (!h) continue;
      const [l, u] = h.split(","), c = i[n] = parseFloat(l);
      u && (i[n] += Math.round(
        Math.random() * (parseFloat(u) - c + 1)
      )), a && (i[n] += parseFloat(e[n]));
    }
    return i;
  }
  // トゥイーン全停止
  static stopAllTw() {
    this.#e = {}, Um();
  }
  static tween(t, e, i, n, s, o, a, h = !0) {
    const l = this.#t.isSkipping ? 0 : L(e, "time", NaN), u = new Er(i).to(n, l).onUpdate(s);
    this.setTwProp(u, e), this.#e[t] = { tw: u, onEnd: a };
    const { path: c } = e;
    let f = u;
    if (c) {
      A.debugLog && console.group(`🍝 [${e[":タグ名"]}] path=${c}= start(${i.x},${i.y},${i.alpha})`);
      for (const { groups: p } of c.matchAll(this.#a)) {
        const { x: v, x2: _, y: m, y2: y, o: b, o2: P, json: x } = p;
        let T = {};
        if (x) try {
          T = JSON.parse(x);
        } catch (O) {
          console.error(`🍝 json=${x} ` + O);
          continue;
        }
        else
          (v ?? _) && (T.x = v ?? _), (m ?? y) && (T.y = m ?? y), (b ?? P) && (T.alpha = b ?? P);
        const I = this.cnvTweenArg(T, i);
        A.debugLog && console.info(`🍝 ${x ?? `{x:${v} y:${m} o:${b}}`} => hTo:${JSON.stringify(I)}`);
        const w = new Er(i).to(I, l);
        this.setTwProp(w, e), f.chain(w), f = w;
      }
      A.debugLog && console.groupEnd();
    }
    f.onComplete(() => {
      const p = this.#e[t];
      p?.tw && (delete this.#e[t], p.tw = void 0, u.stop(), p.onEnd?.(), o(), D.notifyEndProc(Li + t));
    });
    const { chain: d } = e;
    if (d) {
      const p = this.#e[d];
      if (!p?.tw) throw `${d}は存在しない・または終了したトゥイーンです`;
      delete p.onEnd, p.tw.chain(u);
    } else h && u.start();
    return u;
  }
  // 11 match 301 step (0.1ms) PCRE2 https://regex101.com/r/reinpq/1
  // List ${x}${x2}/${y}${y2}/${o}${o2}=${json}\n
  /*
  \(\s*
  (?:	(?<x>[-=\d\.]+)	|	(['"])	(?<x2>.*?)	\2	)?
  (?:
  	\s*,\s*
  	(?:	(?<y>[-=\d\.]+)	|	(['"])	(?<y2>.*?)	\5	)?
  	(?:
  		\s*,\s*
  		(?:	(?<o>[-=\d\.]+)	|	(['"])	(?<o2>.*?)	\8	)
  
  	)?
  )?
  |
  (?<json>\{[^{}]*})
  */
  static #a = /\(\s*(?:(?<x>[-=\d\.]+)|(['"])(?<x2>.*?)\2)?(?:\s*,\s*(?:(?<y>[-=\d\.]+)|(['"])(?<y2>.*?)\5)?(?:\s*,\s*(?:(?<o>[-=\d\.]+)|(['"])(?<o2>.*?)\8))?)?|(?<json>\{[^{}]*})/g;
  // トランス終了待ち
  static wt(t) {
    if (!this.#e[Oe]?.tw) return !1;
    const i = () => this.#h();
    return D.beginProc(Li + Oe, i, !0, i), !0;
  }
  // レイヤのトランジションの停止
  static #h() {
    this.#e[Oe]?.tw?.stop().end();
  }
  // stop()とend()は別
  static async closeTrans() {
    if (!this.#e[Oe]?.tw) return;
    const { promise: e, resolve: i } = Promise.withResolvers();
    D.beginProc(Li + Oe, i, !1, i), this.#h(), await e;
  }
  // トゥイーン終了待ち
  static wait_tsy(t) {
    const e = this.#d(t), i = this.#e[e];
    if (!i?.tw) {
      const { layer: s = "", id: o, name: a } = t;
      if ($(t, "chk_exist_tw", !1)) throw o ? `フレームトゥイーン ${o} が見つかりません。` : `トゥイーン ${e} が見つかりません。(layer:${s} name:${a})`;
      return !1;
    }
    const n = () => i.tw?.end();
    return D.beginProc(Li + e, n, !0, n), !0;
  }
  static #d(t) {
    const { layer: e = "", id: i, name: n } = t, s = i ? `frm
${i}` : n ?? e;
    if (!s) throw "トゥイーンが指定されていません";
    return s;
  }
  // トゥイーン中断
  static stop_tsy(t) {
    const e = this.#d(t);
    return this.#e[e]?.tw?.stop().end(), !1;
  }
  // 一時停止
  static pause_tsy(t) {
    const e = this.#d(t);
    return this.#e[e]?.tw?.pause(), !1;
  }
  // 一時停止再開
  static resume_tsy(t) {
    const e = this.#d(t);
    return this.#e[e]?.tw?.resume(), !1;
  }
}
class rt {
  constructor(t, e, i) {
    this.sys = t, rt.#e = i, rt.#t = e, rt.#i = e.title, rt.myTrace = rt.#d, e.log = (n) => this.#a(n), e.trace = (n) => this.#h(n), rt.#n = document.createElement("span"), rt.#n.hidden = !0, rt.#n.textContent = "", rt.#n.style.cssText = `	z-index: ${Number.MAX_SAFE_INTEGER};
			position: absolute; left: 0; top: 0;
			color: black;
			background-color: rgba(255, 255, 255, 0.7);`, document.body.appendChild(rt.#n);
  }
  static #e;
  static #t;
  static #i;
  static #n;
  destroy() {
    rt.#i = () => !1, document.body.removeChild(rt.#n), rt.myTrace = rt.trace_beforeNew;
  }
  // ログ出力
  #r = !0;
  #a(t) {
    let e = "";
    return this.#r && (this.#r = !1, e = `== ${ru.description} ==
`), this.sys.appendFile(
      this.sys.path_downloads + "log.txt",
      `${e}--- ${Po("-", "_", "")} [fn:${rt.#e.scriptFn} line:${rt.#e.lineNum}] prj:${this.sys.arg.cur}
${t.text || `(text is ${t.text})`}
`
    ), !1;
  }
  #h(t) {
    return rt.myTrace(t.text || `(text is ${t.text})`, "I"), !1;
  }
  // private禁止、galleryでエラーになる
  static trace_beforeNew = (t, e = "E") => {
    let i = `{${e}} ` + t, n = "";
    switch (e) {
      case "D":
        n = `color:#${A.isDarkMode ? "49F" : "05A"};`;
        break;
      case "W":
        n = "color:#FF8800;";
        break;
      case "F":
        n = "color:#BB0000;";
        break;
      case "ET":
        throw i;
      case "E":
        console.error("%c" + i, "color:#FF3300;");
        return;
      default:
        n = "color:black;", i = " " + i;
    }
    console.info("%c" + i, n);
  };
  static myTrace = rt.trace_beforeNew;
  static strPos = () => rt.#e.lineNum > 0 ? `(fn:${rt.#e.scriptFn} line:${rt.#e.lineNum}) ` : "";
  static #d = (t, e = "E") => {
    let i = `{${e}} ` + rt.strPos() + t;
    rt.#l(i, e);
    let n = "";
    switch (e) {
      case "D":
        n = `color:#${A.isDarkMode ? "49F" : "05A"};`;
        break;
      case "W":
        n = "color:#F80;";
        break;
      case "F":
        n = "color:#B00;";
        break;
      case "ET":
      case "E":
        if (rt.#i({ text: t }), this.#t.dump_lay({}), this.#t.dump_val({}), rt.#e.dumpErrForeLine(), this.#t.dump_stack({}), e === "ET") throw i;
        console.error("%c" + i, "color:#F30;");
        return;
      default:
        n = "", i = " " + i;
    }
    console.info("%c" + i, n);
  };
  static #l = (t, e) => {
    let i = "";
    switch (e) {
      case "D":
        i = "color:#05A;";
        break;
      case "W":
        i = "color:#F80;";
        break;
      case "F":
        i = "color:#B00;";
        break;
      case "ET":
      case "E":
        i = "color:#F30;";
        break;
      default:
        i = "";
    }
    rt.#n.innerHTML += `<span style='${i}'>${t}</span><br/>`, rt.#n.hidden = !1;
  };
}
class Q {
  constructor(t = "", e, i = () => {
  }, n = () => {
  }) {
    this.csvFn = t, this.ctn = e, this.fncFirstComp = i, this.fncAllComp = n, t && (this.#d = e ? (s) => {
      e.addChild(s), this.#l.push(s);
    } : () => {
    }, this.ret = Q.#f(
      t,
      (s) => this.fncFirstComp(s),
      // 差し替え考慮
      (s) => this.fncAllComp(s),
      // 差し替え考慮
      (s) => this.#d(s)
      // 差し替え考慮
    ));
  }
  static #e;
  static #t;
  static #i;
  static #n;
  static init(t, e, i, n, s) {
    Q.#e = t, Q.#t = e, Q.#i = i, Q.#n = n, i.arg.crypto && (Q.#v = Q.#p, Q.#u = Q.#C);
    const o = () => {
      const a = Q.#a * Q.#r;
      for (const h of Object.values(Q.#m)) h.volume = a;
    };
    s.setNoticeChgVolume(
      (a) => {
        Q.#a = a, o();
      },
      (a) => {
        Q.#r = a, o();
      }
    );
  }
  static #r = 1;
  static #a = 1;
  static #h;
  static setEvtMng(t) {
    Q.#h = t;
  }
  ret = !1;
  #d;
  #l = [];
  destroy() {
    this.fncFirstComp = () => {
    }, this.fncAllComp = () => {
    }, this.#d = (t) => t.destroy();
    for (const t of this.#l)
      Q.stopVideo(t.name), t.parent?.removeChild(t), t.destroy();
    this.#l = [];
  }
  static destroy() {
    Q.#s = {}, Q.#c = {}, Q.#m = {};
  }
  //static #ldrHFn: {[fn: string]: 1} = {};
  static #f(t, e, i, n) {
    if (!t) return !1;
    let s = !1;
    if (t.startsWith("data:")) {
      const c = () => {
        const f = Bt.from(t);
        n(f), e(f), i(s);
      };
      return t in Qt ? c() : (s = !0, new ue().add(t, t).load(c)), s;
    }
    const o = [], a = new ue(), h = t.split(","), l = h.length;
    for (let c = 0; c < l; ++c) {
      const f = h[c];
      if (!f) throw "face属性に空要素が含まれます";
      const { dx: d, dy: p, blendmode: v, fn: _ } = Q.#s[f] || {
        fn: f,
        dx: 0,
        dy: 0,
        blendmode: it.NORMAL
      }, m = c === 0 ? e : (P) => {
        P.transform !== null && (P.x = d, P.y = p, P.blendMode = v);
      };
      if (o.push({ fn: _, fnc: m }), _ in Q.#c || _ in Qt || _ in ue.shared.resources) continue;
      s = !0;
      const y = Q.#e.searchPath(_, qt.SP_GSM), b = this.#i.arg.crypto ? { xhrType: y.slice(-5) === ".json" ? ft.XHR_RESPONSE_TYPE.TEXT : ft.XHR_RESPONSE_TYPE.BUFFER } : {};
      a.add({ ...b, name: _, url: y });
    }
    const u = (c, f) => {
      for (const { fn: d, fnc: p } of o) {
        const v = Q.#g(d, f);
        v.name = d, n(v), p(v);
      }
      i(s);
    };
    return s ? a.use(async (c, f) => {
      try {
        if (c.extension === "json") {
          const p = await this.#i.dec("json", c.data);
          Q.#u(p, c, f);
          return;
        }
        const d = await this.#i.decAB(c.data);
        Q.#v(d, c, f);
      } catch (d) {
        const p = `画像/動画ロード失敗です fn:${c.name} ${d}`;
        Q.#h.isSkipping ? console.warn(p) : console.error("%c" + p, "color:#FF3300;");
      }
    }).load(u) : queueMicrotask(() => u(0, {})), s;
  }
  static #s = {};
  static #c = {};
  static #v = (t, { type: e, name: i, data: n }, s) => {
    switch (e) {
      case ft.TYPE.VIDEO:
        const o = n;
        o.volume = Q.#a, Q.#m[i] = Q.#y(o);
    }
    s();
  };
  static #_(t) {
    const e = /([^\d]+)\d+\.(\w+)/.exec(t[0] ?? "");
    if (!e) return [];
    const i = e[1].length, n = -e[2].length - 1;
    return t.sort((s, o) => Ye(s.slice(i, n)) > Ye(o.slice(i, n)) ? 1 : -1);
  }
  static async #p(t, e, i) {
    e.data = t, e.extension !== "bin" && i(), t instanceof HTMLImageElement ? (e.texture = await ot.fromLoader(t, e.url, e.name), e.type = ft.TYPE.IMAGE) : t instanceof HTMLVideoElement && (t.volume = Q.#a, Q.#m[e.name] = Q.#y(t), e.type = ft.TYPE.VIDEO), i();
  }
  static #y(t) {
    return Q.#t.getVal("const.sn.needClick2Play") && (rt.trace_beforeNew(`[lay系] ${rt.strPos()}未クリック状態で動画を自動再生します。音声はミュートされます`, "W"), t.muted = !0), t.setAttribute("playsinline", ""), t;
  }
  static #u = (t, { type: e, spritesheet: i, name: n, data: s }, o) => {
    switch (e) {
      case ft.TYPE.JSON:
        const a = i._frameKeys;
        Q.#_(a), Q.#c[n] = {
          aTex: a.map((h) => ot.from(h)),
          meta: s.meta
        };
    }
    o();
  };
  static #C(t, e, i) {
    const { meta: n, frames: s } = e.data = JSON.parse(t);
    if (e.type = ft.TYPE.JSON, !n?.image) {
      i();
      return;
    }
    const o = lr(n.image), a = Q.#e.searchPath(o, qt.SP_GSM);
    new ue().use((h, l) => {
      this.#i.decAB(h.data).then((u) => {
        h.data = u, u instanceof HTMLImageElement && (h.type = ft.TYPE.IMAGE, URL.revokeObjectURL(u.src)), l();
      }).catch((u) => this.#n.errScript(`画像/動画ロード失敗です dec2res4Cripto fn:${h.name} ${u}`, !1));
    }).add({ name: o, url: a, xhrType: ft.XHR_RESPONSE_TYPE.BUFFER }).load((h, l) => {
      for (const { data: u } of Object.values(h.resources)) {
        const { baseTexture: c } = ot.from(u), f = Object.values(s);
        Q.#c[e.name] = {
          aTex: f.map(({ frame: { x: d, y: p, w: v, h: _ } }) => new ot(
            c,
            new dt(d, p, v, _)
          )),
          meta: n
        };
      }
      i();
    });
  }
  static #g(t, e) {
    const i = Q.#c[t];
    if (i) {
      const o = new vl(i.aTex);
      return o.animationSpeed = i.meta.animationSpeed ?? 1, o.play(), o;
    }
    if (t in Qt) return Bt.from(t);
    const n = Q.#m[t];
    if (n) return Bt.from(n);
    const s = e[t];
    return s ? new Bt(s.texture) : new Bt();
  }
  static #m = {};
  static getHFn2VElm(t) {
    return Q.#m[t];
  }
  static wv(t) {
    const { fn: e } = t;
    if (!e) throw "fnは必須です";
    const i = Q.#m[e];
    if (!i || i.loop) return !1;
    if (Q.#h.isSkipping || i.ended)
      return Q.stopVideo(e), !1;
    const n = "wv fn:" + e, s = $(t, "stop", !0), o = () => {
      s && Q.stopVideo(e);
    };
    return D.beginProc(n, o, !0, o), i.addEventListener("ended", () => D.notifyEndProc(n), { once: !0, passive: !0 }), !0;
  }
  static stopVideo(t) {
    const e = Q.#m[t];
    e && (delete Q.#m[t], e.pause(), e.currentTime = e.duration);
  }
  static add_face(t) {
    const { name: e } = t;
    if (!e) throw "nameは必須です";
    if (e in Q.#s) throw "一つのname（" + e + "）に対して同じ画像を複数割り当てられません";
    const { fn: i = e } = t;
    return Q.#s[e] = {
      fn: i,
      dx: L(t, "dx", 0),
      dy: L(t, "dy", 0),
      blendmode: Nt.getBlendmodeNum(t.blendmode || "")
    }, !1;
  }
  //	static	clearFace2Name(): void {SpritesMng.hFace = {}}
}
const cr = "、。，．）］｝〉」』】〕”〟ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ！？!?‼⁉・ーゝゞヽヾ々", pn = "［（｛〈「『【〔“〝", vn = "─‥…", Es = cr, gl = new RegExp(`[${cr}]`), jm = new RegExp(`[${pn}]`), Hm = new RegExp(`[${vn}]`), $m = gl;
class zm {
  #e = cr;
  #t = pn;
  #i = vn;
  #n = Es;
  get 行頭禁則() {
    return this.#e;
  }
  get 行末禁則() {
    return this.#t;
  }
  get 分割禁止() {
    return this.#i;
  }
  get ぶら下げ() {
    return this.#n;
  }
  #r = gl;
  #a = jm;
  #h = Hm;
  #d = $m;
  break_fixed = !1;
  break_fixed_left = 0;
  break_fixed_top = 0;
  bura = !1;
  lay(t) {
    t.kinsoku_sol && (this.#e = t.kinsoku_sol, this.#r = new RegExp(`[${this.#e}]`)), t.kinsoku_eol && (this.#t = t.kinsoku_eol, this.#l(), this.#a = new RegExp(`[${this.#t}]`)), t.kinsoku_dns && (this.#i = t.kinsoku_dns, this.#f(), this.#h = new RegExp(`[${this.#i}]`)), t.kinsoku_bura && (this.#n = t.kinsoku_bura, this.#l(), this.#f(), this.#d = new RegExp(`[${this.#n}]`)), "bura" in t && (this.bura = $(t, "bura", !1)), this.break_fixed = $(t, "break_fixed", this.break_fixed), this.break_fixed_left = L(t, "break_fixed_left", this.break_fixed_left), this.break_fixed_top = L(t, "break_fixed_top", this.break_fixed_top);
  }
  // 禁則の競合（ぶら下げ と 行末禁則 の両方に含まれる文字があってはならない）
  #l() {
    const t = this.#t.length, e = this.#n.length;
    if (t < e)
      for (let i = 0; i < t; ++i) {
        const n = this.#t[i];
        if (this.#n.includes(n)) throw `禁則の競合があります。文字 ${n} がぶら下げ と 行末禁則 の両方に含まれます`;
      }
    else
      for (let i = 0; i < e; ++i) {
        const n = this.#n[i];
        if (this.#t.includes(n)) throw `禁則の競合があります。文字 ${n} がぶら下げ と 行末禁則 の両方に含まれます`;
      }
  }
  // 禁則の競合（ぶら下げ と 分割禁止 の両方に含まれる文字があってはならない）
  #f() {
    const t = this.#i.length, e = this.#n.length;
    if (t < e)
      for (let i = 0; i < t; ++i) {
        const n = this.#i[i];
        if (this.#n.includes(n)) throw `禁則の競合があります。文字 ${n} がぶら下げ と 分割禁止 の両方に含まれます`;
      }
    else
      for (let i = 0; i < e; ++i) {
        const n = this.#n[i];
        if (this.#i.includes(n)) throw `禁則の競合があります。文字 ${n} がぶら下げ と 分割禁止 の両方に含まれます`;
      }
  }
  reNew(t) {
    t.#s(this.#e, this.#t, this.#i, this.#n), t.break_fixed = this.break_fixed, t.break_fixed_left = this.break_fixed_left, t.break_fixed_top = this.break_fixed_top, t.bura = this.bura;
  }
  #s(t, e, i, n) {
    this.#e != t && (this.#e = t, this.#r = new RegExp(`[${t}]`)), this.#t != e && (this.#t = e, this.#a = new RegExp(`[${e}]`)), this.#i != i && (this.#i = i, this.#h = new RegExp(`[${i}]`)), this.#n != n && (this.#n = n, this.#d = new RegExp(`[${n}]`));
  }
  record() {
    const t = {
      break_fixed: this.break_fixed,
      break_fixed_left: this.break_fixed_left,
      break_fixed_top: this.break_fixed_top,
      bura: this.bura
    };
    return this.#e === cr && (t.行頭禁則 = this.#e), this.#t === pn && (t.行末禁則 = this.#t), this.#i === vn && (t.分割禁止 = this.#i), this.#n === Es && (t.ぶら下げ = this.#n), t;
  }
  playback(t) {
    t && (this.#s(
      t.行頭禁則 ?? cr,
      t.行末禁則 ?? pn,
      t.分割禁止 ?? vn,
      t.ぶら下げ ?? Es
    ), this.break_fixed = t.break_fixed, this.break_fixed_left = t.break_fixed_left, this.break_fixed_top = t.break_fixed_top, this.bura = t.bura);
  }
  hyph(t, e, i, n, s) {
    let o, a = 0, h = 2, l = (u) => (l = () => !1, n === u ? (n > 0 && (t.innerHTML = s.replaceAll('class="sn_ch"', 'class="sn_ch sn_ch_in_default"')), !0) : u < 2);
    do {
      if (o = this.#v(t, e), a = o.length, l(a)) break;
      let u = -1 / 0;
      for (; h < a; ++h) {
        const { elm: c, rect: f, ch: d } = o[h];
        if (c.tagName === "RT") continue;
        const p = i ? f.y : f.x;
        if (u <= p || c.previousElementSibling?.tagName === "SPAN" && c.previousElementSibling?.innerHTML.includes("<br>") || c.parentElement?.previousElementSibling?.tagName === "SPAN" && c.parentElement?.previousElementSibling?.innerHTML.includes("<br>")) {
          u = p, this.break_fixed || (this.break_fixed_left = f.x, this.break_fixed_top = f.y);
          continue;
        }
        const v = this.#c(o, h), { elm: _, rect: m, ch: y } = o[v];
        if (!this.break_fixed) {
          this.break_fixed_left = m.x, this.break_fixed_top = m.y;
          const O = globalThis.getComputedStyle(_), R = parseFloat(O.fontSize);
          i ? this.break_fixed_top += R : this.break_fixed_left += R;
        }
        u = -1 / 0;
        const b = h, { cont: P, ins: x } = this.bura ? this.hyph_alg_bura(o, v, y, h) : this.hyph_alg(o, v, y, h, d);
        if (h = x, P) continue;
        const T = o[h].elm, I = T.parentElement, w = document.createElement("br");
        if (I.classList.contains("sn_tx")) I.insertBefore(w, T);
        else {
          const O = I.parentElement;
          O.classList.contains("sn_ch") ? O.parentElement.insertBefore(w, O) : O.insertBefore(w, I);
        }
        h += 2, h < b && (h = b), a = -1;
        break;
      }
    } while (a < 0);
    return [o, a];
  }
  // 一つ前の要素を探す（ルビ対応）
  #c(t, e) {
    const i = e - 1, { elm: n } = t[i];
    return n.tagName !== "RT" ? i - (n.style.textCombineUpright === "all" ? Array.from(n.textContent ?? "").length - 1 : 0) : i - Array.from(n.textContent ?? "").length;
  }
  #v(t, e) {
    const i = [];
    if (t.nodeType !== t.TEXT_NODE) return Array.from(t.childNodes).map((a) => this.#v(a, e)).flat();
    const n = t.ownerDocument.createRange();
    n.selectNodeContents(t);
    let s = 0;
    const o = n.endOffset;
    for (; s < o; ) {
      n.setStart(t, s), n.setEnd(t, ++s);
      const a = n.toString();
      i.push({
        ch: a,
        rect: e(n, a),
        elm: n.startContainer.parentElement
      });
    }
    return n.detach(), i;
  }
  /**
   * 抽象化した禁則処理アルゴリズム
   * @method hyph_alg
   * @param {IChRect[]} a - 文章の抽象化配列
   * @param {number} p_i - 処理要素の一つ前の添字
   * @param {string} p_ch - 処理要素の一つ前の文字
   * @param {number} i - 処理要素の添字
   * @param {string} ch - 処理要素の文字
   * @return {Object} result 戻り値
   * @return {boolean} result.cont - true: 呼び元で改行挿入せず continue
   * @return {number} result.ins - 手前に改行を挿入すべき要素の添字
   */
  hyph_alg(t, e, i, n, s) {
    if (!this.#a.test(i)) {
      if (this.#r.test(s))
        for (; (n = this.#c(t, n)) >= 0 && this.#r.test(t[n].ch); )
          ;
      else if (!(i === s && this.#h.test(i))) return { cont: !0, ins: n + 1 };
    }
    for (n = e; (n = this.#c(t, n)) >= 0 && this.#a.test(t[n].ch); )
      ;
    return { cont: !1, ins: n + 1 };
  }
  /**
   * 抽象化した禁則処理アルゴリズム
   * @method hyph_alg
   * @param {IChRect[]} a - 文章の抽象化配列
   * @param {number} p_i - 処理要素の一つ前の添字
   * @param {string} p_ch - 処理要素の一つ前の文字
   * @param {number} i - 処理要素の添字
   * @return {Object} result 戻り値
   * @return {boolean} result.cont - true: 呼び元で改行挿入せず continue
   * @return {number} result.ins - 手前に改行を挿入すべき要素の添字
   */
  hyph_alg_bura(t, e, i, n) {
    const s = this.#c(t, e), { ch: o } = t[s];
    if (this.#d.test(o) || this.#r.test(o)) {
      let h = e;
      (this.#d.test(i) || this.#r.test(i)) && ++h;
      const l = this.#c(t, h), { ch: u } = t[l], { ch: c } = t[h];
      if (u === c && this.#h.test(c)) return { cont: !1, ins: l };
      if (!this.#a.test(u)) return { cont: !1, ins: h };
      h = l;
      do
        if (!this.#a.test(t[h].ch)) break;
      while ((h = this.#c(t, h)) >= 0);
      return { cont: !1, ins: h + 1 };
    }
    const a = this.#c(t, s);
    if (n >= 3) {
      const { ch: h } = t[a];
      if (this.#h.test(o) && h === o)
        return { cont: !1, ins: a };
      if (this.#a.test(h)) {
        let l = a;
        for (; (l = this.#c(t, l)) >= 0 && this.#a.test(t[l].ch); )
          ;
        return { cont: !1, ins: l + 1 };
      }
    }
    return { cont: !1, ins: s };
  }
}
class ih {
  constructor(t = "", e = 0, i = { ":hEvt1Time": {}, ":hMp": {}, ":lenIfStk": 1 }) {
    this.fn = t, this.idx = e, this.csArg = i;
  }
  toString = () => `[fn:${this.fn}, idx:${this.idx}, csArg:${this.csArg}]`;
}
class bl {
  // 87 match 2725 step(0.5ms) PCRE2 https://regex101.com/r/aeN57J/1
  /*
  ;[^\n]*
  |	(?<key>[^\s="'#|;]+)
  	(?: \s | ;[^\n]*\n)*
  	=
  	(?: \s | ;[^\n]*\n)*
  	(?:	(?<val> [^\s"'#|;]+)
  	|	(["'#]) (?<val2>.*?) \3 )
  	(?: \|
  		(?: (?<def> [^\s"'#;]+)
  	|	(["'#]) (?<def2>.*?) \6 ) )?
  |	(?<literal>[^\s;]+)
  	*/
  #e = /;[^\n]*|(?<key>[^\s="'#|;]+)(?:\s|;[^\n]*\n)*=(?:\s|;[^\n]*\n)*(?:(?<val>[^\s"'#|;]+)|(["'#])(?<val2>.*?)\3)(?:\|(?:(?<def>[^\s"'#;]+)|(["'#])(?<def2>.*?)\6))?|(?<literal>[^\s;]+)/g;
  // 【属性 = 値 | 省略値】の分析
  parse(t) {
    this.#i = {}, this.#n = !1;
    for (const { groups: e } of t.matchAll(this.#e)) {
      const { key: i, val: n, val2: s, def: o, def2: a, literal: h } = e;
      i ? this.#i[i] = {
        val: n ?? s ?? "",
        def: o ?? a
      } : h && (h === "*" ? this.#n = !0 : this.#i[h] = { val: "1" });
    }
  }
  // 属性と値の位置をまとめて返す
  parseinDetail(t, e, i, n) {
    const s = {}, o = t.slice(1 + e, -1);
    for (const { groups: a, index: h, 0: l } of o.matchAll(this.#e)) {
      if (h === void 0) continue;
      const { key: u, val: c, val2: f = "", literal: d } = a;
      if (d) {
        if (d.endsWith("=")) {
          const y = d.length - 1, { ch: b } = this.#t(e, i, n, o, h + y);
          s[d.slice(0, -1)] = {
            k_ln: i,
            k_ch: b - y,
            v_ln: i,
            v_ch: b + 1,
            //	v_ch: ch +1+lenNm +literal.length +1,
            v_len: 0
          };
        }
        continue;
      }
      if (!u) continue;
      const { ln: p, ch: v } = this.#t(e, i, n, o, h), { ln: _, ch: m } = this.#t(e, i, n, o, h + l.lastIndexOf(c ?? f ?? "") - (c ? 0 : 1));
      s[u] = { k_ln: p, k_ch: v, v_ln: _, v_ch: m, v_len: c ? c.length : f.length + 2 };
    }
    return s;
  }
  #t(t, e, i, n, s) {
    const a = n.slice(0, s).split(`
`), h = a.length;
    return {
      ln: e + h - 1,
      ch: h < 2 ? i + 1 + t + s : a.at(-1).length
    };
  }
  #i = {};
  get hPrm() {
    return this.#i;
  }
  #n = !1;
  get isKomeParam() {
    return this.#n;
  }
}
const xl = /(?<name>[^\s;\]]+)/;
function Nn(r) {
  const e = xl.exec(r.slice(1, -1))?.groups;
  if (!e) throw `タグ記述【${r}】異常です(タグ解析)`;
  const i = e.name;
  return [i, r.slice(1 + i.length, -1)];
}
function Ss(r) {
  const e = xl.exec(r.slice(1))?.groups;
  if (!e) throw `タグ記述【${r}】異常です(タグ解析)`;
  return e.name;
}
function Xm(r) {
  const t = r.replaceAll("==", "＝").replaceAll("!=", "≠").split("="), e = t.length;
  if (e < 2 || e > 3) throw "「&計算」書式では「=」指定が一つか二つ必要です";
  const [i, n, s] = t;
  if (n.startsWith("&")) throw "「&計算」書式では「&」指定が不要です";
  return {
    name: i.replaceAll("＝", "==").replaceAll("≠", "!="),
    text: n.replaceAll("＝", "==").replaceAll("≠", "!="),
    cast: e === 3 ? s.trim() : void 0
  };
}
class Vm {
  constructor(t) {
    this.cfg = t, this.setEscape("");
  }
  #e;
  setEscape(t) {
    if (this.#f && t in this.#f) throw "[エスケープ文字] char【" + t + "】が登録済みの括弧マクロまたは一文字マクロです";
    this.#e = new RegExp(
      (t ? `\\${t}\\S|` : "") + // エスケープシーケンス
      `\\n+|\\t+|\\[let_ml\\s+[^\\]]+\\].+?(?=\\[endlet_ml[\\]\\s])|\\[(?:[^"'#;\\]]+|(["'#]).*?\\1|;[^\\n]*)*?]|;[^\\n]*|&[^&\\n]+&|&&?(?:[^"'#;\\n&]+|(["'#]).*?\\2)+|^\\*[^\\s\\[&;\\\\]+|[^\\n\\t\\[;${t ? `\\${t}` : ""}]+`,
      // 本文
      "gs"
    ), this.#t = new RegExp(`[\\w\\s;[\\]*=&｜《》${t ? `\\${t}` : ""}]`), this.#s = new RegExp(`[\\n\\t;\\[*&${t ? `\\${t}` : ""}]`);
  }
  // 括弧マクロの定義
  bracket2macro(t, e, i, n) {
    const { name: s, text: o } = t;
    if (!s) throw "[bracket2macro] nameは必須です";
    if (!o) throw "[bracket2macro] textは必須です";
    const a = o.at(0);
    if (!a) throw "[bracket2macro] textは必須です";
    if (o.length !== 2) throw "[bracket2macro] textは括弧の前後を示す二文字を指定してください";
    if (!(s in e)) throw `[bracket2macro] 未定義のタグ又はマクロ[${s}]です`;
    this.#f ??= {};
    const h = o.charAt(1);
    if (a in this.#f) throw "[bracket2macro] text【" + a + "】が登録済みの括弧マクロまたは一文字マクロです";
    if (h in this.#f) throw "[bracket2macro] text【" + h + "】が登録済みの括弧マクロまたは一文字マクロです";
    if (this.#t.test(a)) throw "[bracket2macro] text【" + a + "】は括弧マクロに使用できない文字です";
    if (this.#t.test(h)) throw "[bracket2macro] text【" + h + "】は括弧マクロに使用できない文字です";
    this.#f[h] = "0", this.#f[a] = `[${s} text=`, this.addC2M(`\\${a}[^\\${h}]*\\${h}`, `\\${a}\\${h}`), this.#c(i, n);
  }
  // 一文字マクロの定義
  char2macro(t, e, i, n) {
    const { char: s, name: o } = t;
    if (!s) throw "[char2macro] charは必須です";
    if (this.#f ??= {}, s in this.#f) throw "[char2macro] char【" + s + "】が登録済みの括弧マクロまたは一文字マクロです";
    if (this.#t.test(s)) throw "[char2macro] char【" + s + "】は一文字マクロに使用できない文字です";
    if (!o) throw "[char2macro] nameは必須です";
    if (!(o in e)) throw `[char2macro] 未定義のタグ又はマクロ[${o}]です`;
    this.#f[s] = `[${o}]`, this.addC2M(`\\${s}`, `\\${s}`), this.#c(i, n);
  }
  #t;
  #i = new RegExp("");
  #n = "";
  #r = "";
  addC2M(t, e) {
    this.#n += `${t}|`, this.#r += `${e}`, this.#i = new RegExp(
      `(${this.#n}[^${this.#r}]+)`,
      "g"
    );
  }
  resolveScript(t) {
    const e = t.replaceAll(/\r\n?/g, `
`).match(this.#e)?.flatMap((n) => {
      if (!this.testTagLetml(n)) return n;
      const s = /^([^\]]+?])(.*)$/s.exec(n);
      if (!s) return n;
      const [, o, a] = s;
      return [o, a];
    }) ?? [], i = { aToken: e, len: e.length, aLNum: [] };
    return this.#c(i), this.#d(i), i;
  }
  #a = /^\[(call|loadplugin)\s/;
  #h = /\bfn\s*=\s*[^\s\]]+/;
  #d(t) {
    for (let e = t.len - 1; e >= 0; --e) {
      const i = t.aToken[e];
      if (!this.#a.test(i)) continue;
      const [n, s] = Nn(i);
      this.#l.parse(s);
      const o = this.#l.hPrm.fn;
      if (!o) continue;
      const { val: a } = o;
      if (!a || !a.endsWith("*")) continue;
      t.aToken.splice(e, 1, "	", "; " + i), t.aLNum.splice(e, 1, NaN, NaN);
      const h = n === "loadplugin" ? qt.CSS : qt.SN, l = this.cfg.matchPath("^" + a.slice(0, -1) + ".*", h);
      for (const u of l) {
        const c = i.replace(
          this.#h,
          "fn=" + decodeURIComponent(lr(u[h]))
        );
        t.aToken.splice(e, 0, c), t.aLNum.splice(e, 0, NaN);
      }
    }
    t.len = t.aToken.length;
  }
  #l = new bl();
  testTagLetml(t) {
    return /^\[let_ml\s/.test(t);
  }
  testTagEndLetml(t) {
    return /^\[endlet_ml\s*]/.test(t);
  }
  analyzToken(t) {
    return this.#e.lastIndex = 0, this.#e.exec(t);
  }
  #f;
  #s;
  #c(t, e = 0) {
    if (this.#f) {
      for (let i = t.len - 1; i >= e; --i) {
        const n = t.aToken[i];
        if (this.testNoTxt(n.at(0) ?? `
`)) continue;
        const s = t.aLNum[i], o = n.match(this.#i);
        if (!o) continue;
        let a = 1;
        for (let h = o.length - 1; h >= 0; --h) {
          let l = o[h];
          const u = this.#f[l.at(0) ?? " "];
          u && (l = u + (u.endsWith("]") ? "" : `'${l.slice(1, -1)}']`)), t.aToken.splice(i, a, l), t.aLNum.splice(i, a, s), a = 0;
        }
      }
      t.len = t.aToken.length;
    }
  }
  testNoTxt(t) {
    return this.#s.test(t);
  }
  //4tst
}
class xe {
  static #e = "ヽ";
  static setting(t) {
    t.sesame && (xe.#e = t.sesame);
  }
  static getSesame() {
    return xe.#e;
  }
  static destroy() {
    xe.#e = "ヽ";
  }
  #t = () => {
  };
  init(t) {
    this.#t = t;
  }
  /*
  		★Unicodeで「漢字」の正規表現 – ものかの http://tama-san.com/kanji-regex/
  		2E80..2FDF CJK部首補助＋康熙部首
  		3005 々（漢字の踊り字）
  		3007 〇（漢数字のゼロ）
  		303B 〻（漢字の踊り字）
  		3400..4DBF CJK統合漢字拡張A
  		4E00..9FFF CJK統合漢字
  		F900..FAFF CJK互換漢字
  		20000..2FFFF CJK統合漢字拡張B〜F＋CJK互換漢字追加＋念のためU+2FFFFまで
  
  		[\x{2E80}-\x{2FDF}々〇〻\x{3400}-\x{4DBF}\x{4E00}-\x{9FFF}\x{F900}-\x{FAFF}\x{20000}-\x{2FFFF}]
  		[\u2E80-\u2FDF々〇〻\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\u20000-\u2FFFF]
  		[⺀-⿟々〇〻㐀-䶿一-鿿豈-﫿\u20000-\u2FFFF]		// 含まれない文字がある
  		[⺀-⿟々〇〻㐀-鿿豈-﫿\u20000-\u2FFFF]			// ヽ--30FD が変に引っかかる。多分\u2000-\u2FFF解釈
  		\\u{20000}-\\u{2FFFF}	// 五桁だとエラー
  
  		【2022/10/03】ruby正規表現のUnicode プロパティ(とPOSIX文字クラス) - Qiita https://qiita.com/Takayuki_Nakano/items/8d38beaddb84b488d683
  			> このHiraganaプロパティ、長音記号は含まれていません。
  			> \p{Han}…簡体字や繁体字、韓国語の漢字…ベトナム語の漢字にもマッチ
  		
  		・Unicode文字一覧表 - instant tools https://tools.m-bsys.com/ex/unicode_table.php
  */
  static #i;
  static setEscape(t) {
    xe.#i = new RegExp(
      `${t ? `(?<ce>\\${t}\\S)|` : ""}｜(?<str>[^《\\n]+)《(?<ruby>[^》\\n]+)》|(?:(?<kan>[⺀-⿟々〇〻㐀-鿿豈-﫿]+[ぁ-ヿ]*|[^　｜《》\\n])《(?<kan_ruby>[^》\\n]+)》)|(?<txt>[\uD800-\uDBFF][\uDC00-\uDFFF]|[^｜《》]+?|.)`,
      "gs"
    );
  }
  putTxt(t) {
    for (const { groups: e } of t.matchAll(xe.#i)) {
      const { ruby: i, kan_ruby: n, kan: s = "", ce: o, txt: a = "", str: h = "" } = e;
      if (i) {
        this.putTxtRb(decodeURIComponent(h), i);
        continue;
      }
      if (n) {
        this.putTxtRb(s, n);
        continue;
      }
      if (o) {
        this.#t(o.slice(1), "");
        continue;
      }
      for (const l of Array.from(a)) this.#t(l, "");
    }
  }
  putTxtRb(t, e) {
    if (/^\w+｜{"/.test(e)) {
      this.#t(t, e);
      return;
    }
    const i = Array.from(t), n = i.length;
    if (/^\*.?$/.test(e)) {
      const h = "center｜" + (e === "*" ? xe.#e : e.charAt(1));
      for (let l = 0; l < n; ++l) this.#t(i[l], h);
      return;
    }
    if (n === 1 || !e.includes(" ")) {
      this.#t(t, decodeURIComponent(e));
      return;
    }
    const s = e.split(" "), o = s.length, a = o > n ? o : n;
    for (let h = 0; h < a; ++h) this.#t(
      h < n ? i[h] : "",
      h < o ? decodeURIComponent(s[h]) : ""
    );
  }
}
/*!
 * @pixi/sound - v4.4.1
 * https://github.com/pixijs/pixi-sound
 * Compiled Tue, 15 Aug 2023 19:22:13 UTC
 *
 * @pixi/sound is licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license
 */
var wl;
function Ht() {
  return wl;
}
var Tl = function(r, t) {
  return (Tl = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n]);
  })(r, t);
};
function re(r, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function e() {
    this.constructor = r;
  }
  Tl(r, t), r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var ji = function() {
  return (ji = Object.assign || function(r) {
    for (var t, e = 1, i = arguments.length; e < i; e++) for (var n in t = arguments[e]) Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
    return r;
  }).apply(this, arguments);
}, El = ["mp3", "ogg", "oga", "opus", "mpeg", "wav", "m4a", "aiff", "wma", "mid", "caf"], Gn = {};
function Wm(r) {
  var t = ji({ m4a: "audio/mp4", oga: "audio/ogg", opus: 'audio/ogg; codecs="opus"', caf: 'audio/x-caf; codecs="opus"' }, r || {}), e = document.createElement("audio"), i = {}, n = /^no$/;
  El.forEach(function(s) {
    var o = e.canPlayType("audio/".concat(s)).replace(n, ""), a = t[s] ? e.canPlayType(t[s]).replace(n, "") : "";
    i[s] = !!o || !!a;
  }), Object.assign(Gn, i);
}
Wm();
var Ym = /\.(\{([^\}]+)\})(\?.*)?$/;
function Sl(r) {
  var t = Ym, e = typeof r == "string" ? r : r.url;
  if (!t.test(e)) return e;
  for (var i = t.exec(e), n = i[2].split(","), s = n[n.length - 1], o = 0, a = n.length; o < a; o++) {
    var h = n[o];
    if (Gn[h]) {
      s = h;
      break;
    }
  }
  var l = e.replace(i[1], s);
  if (typeof r != "string") {
    var u = r;
    u.extension = s, u.url = l;
  }
  return l;
}
var Ps = El.filter(function(r) {
  return Gn[r];
}), Pl = function() {
  function r() {
  }
  return r.add = function() {
    r.setLegacy(Ht().useLegacy);
  }, r.setLegacy = function(t) {
    t ? Ps.forEach(function(e) {
      ft.setExtensionXhrType(e, ft.XHR_RESPONSE_TYPE.DEFAULT), ft.setExtensionLoadType(e, ft.LOAD_TYPE.AUDIO);
    }) : Ps.forEach(function(e) {
      ft.setExtensionXhrType(e, ft.XHR_RESPONSE_TYPE.BUFFER), ft.setExtensionLoadType(e, ft.LOAD_TYPE.XHR);
    });
  }, r.pre = function(t, e) {
    Sl(t), e();
  }, r.use = function(t, e) {
    t.data && Ps.indexOf(t.extension) > -1 ? t.sound = Ht().add(t.name, { loaded: e, preload: !0, url: t.url, source: t.data }) : e();
  }, r.extension = "loader", r;
}(), qm = 0, Zm = function(r) {
  function t(e) {
    var i = r.call(this) || this;
    return i.id = qm++, i.init(e), i;
  }
  return re(t, r), t.prototype.set = function(e, i) {
    if (this[e] === void 0) throw new Error("Property with name ".concat(e, " does not exist."));
    switch (e) {
      case "speed":
        this.speed = i;
        break;
      case "volume":
        this.volume = i;
        break;
      case "paused":
        this.paused = i;
        break;
      case "loop":
        this.loop = i;
        break;
      case "muted":
        this.muted = i;
    }
    return this;
  }, Object.defineProperty(t.prototype, "progress", { get: function() {
    return this._source.currentTime / this._duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    this._paused = e, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), t.prototype._onPlay = function() {
    this._playing = !0;
  }, t.prototype._onPause = function() {
    this._playing = !1;
  }, t.prototype.init = function(e) {
    this._playing = !1, this._duration = e.source.duration;
    var i = this._source = e.source.cloneNode(!1);
    i.src = e.parent.url, i.onplay = this._onPlay.bind(this), i.onpause = this._onPause.bind(this), e.context.on("refresh", this.refresh, this), e.context.on("refreshPaused", this.refreshPaused, this), this._media = e;
  }, t.prototype._internalStop = function() {
    this._source && this._playing && (this._source.onended = null, this._source.pause());
  }, t.prototype.stop = function() {
    this._internalStop(), this._source && this.emit("stop");
  }, Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(e) {
    this._speed = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(e) {
    this._volume = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(e) {
    this._loop = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(e) {
    this._muted = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    var e = this._media.context, i = this._media.parent;
    this._source.loop = this._loop || i.loop;
    var n = e.volume * (e.muted ? 0 : 1), s = i.volume * (i.muted ? 0 : 1), o = this._volume * (this._muted ? 0 : 1);
    this._source.volume = o * n * s, this._source.playbackRate = this._speed * e.speed * i.speed;
  }, t.prototype.refreshPaused = function() {
    var e = this._media.context, i = this._media.parent, n = this._paused || i.paused || e.paused;
    n !== this._pausedReal && (this._pausedReal = n, n ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop })), this.emit("pause", n));
  }, t.prototype.play = function(e) {
    var i = this, n = e.start, s = e.end, o = e.speed, a = e.loop, h = e.volume, l = e.muted;
    this._speed = o, this._volume = h, this._loop = !!a, this._muted = l, this.refresh(), this.loop && s !== null && (this.loop = !1), this._start = n, this._end = s || this._duration, this._start = Math.max(0, this._start - t.PADDING), this._end = Math.min(this._end + t.PADDING, this._duration), this._source.onloadedmetadata = function() {
      i._source && (i._source.currentTime = n, i._source.onloadedmetadata = null, i.emit("progress", n, i._duration), Lt.shared.add(i._onUpdate, i));
    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit("start");
  }, t.prototype._onUpdate = function() {
    this.emit("progress", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();
  }, t.prototype._onComplete = function() {
    Lt.shared.remove(this._onUpdate, this), this._internalStop(), this.emit("progress", 1, this._duration), this.emit("end", this);
  }, t.prototype.destroy = function() {
    Lt.shared.remove(this._onUpdate, this), this.removeAllListeners();
    var e = this._source;
    e && (e.onended = null, e.onplay = null, e.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = !1, this._end = null, this._start = 0, this._duration = 0, this._playing = !1, this._pausedReal = !1, this._paused = !1, this._muted = !1, this._media && (this._media.context.off("refresh", this.refresh, this), this._media.context.off("refreshPaused", this.refreshPaused, this), this._media = null);
  }, t.prototype.toString = function() {
    return "[HTMLAudioInstance id=".concat(this.id, "]");
  }, t.PADDING = 0.1, t;
}(Pe), Km = function(r) {
  function t() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return re(t, r), t.prototype.init = function(e) {
    this.parent = e, this._source = e.options.source || new Audio(), e.url && (this._source.src = e.url);
  }, t.prototype.create = function() {
    return new Zm(this);
  }, Object.defineProperty(t.prototype, "isPlayable", { get: function() {
    return !!this._source && this._source.readyState === 4;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "duration", { get: function() {
    return this._source.duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = "", this._source.load(), this._source = null);
  }, Object.defineProperty(t.prototype, "source", { get: function() {
    return this._source;
  }, enumerable: !1, configurable: !0 }), t.prototype.load = function(e) {
    var i = this._source, n = this.parent;
    if (i.readyState !== 4) if (n.url) {
      i.src = n.url;
      var s = function() {
        h(), n.isLoaded = !0;
        var u = n.autoPlayStart();
        e && e(null, n, u);
      }, o = function() {
        h(), e && e(new Error("Sound loading has been aborted"));
      }, a = function() {
        h();
        var u = "Failed to load audio element (code: ".concat(i.error.code, ")");
        e && e(new Error(u));
      }, h = function() {
        i.removeEventListener("canplaythrough", s), i.removeEventListener("load", s), i.removeEventListener("abort", o), i.removeEventListener("error", a);
      };
      i.addEventListener("canplaythrough", s, !1), i.addEventListener("load", s, !1), i.addEventListener("abort", o, !1), i.addEventListener("error", a, !1), i.load();
    } else e(new Error("sound.url or sound.source must be set"));
    else {
      n.isLoaded = !0;
      var l = n.autoPlayStart();
      e && setTimeout(function() {
        e(null, n, l);
      }, 0);
    }
  }, t;
}(Pe), Jm = function() {
  function r(t, e) {
    this.parent = t, Object.assign(this, e), this.duration = this.end - this.start;
  }
  return r.prototype.play = function(t) {
    return this.parent.play({ complete: t, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop });
  }, r.prototype.destroy = function() {
    this.parent = null;
  }, r;
}(), ae = function() {
  function r() {
  }
  return r.setParamValue = function(t, e) {
    if (t.setValueAtTime) {
      var i = Ht().context;
      t.setValueAtTime(e, i.audioContext.currentTime);
    } else t.value = e;
    return e;
  }, r;
}(), Qm = 0, ty = function(r) {
  function t(e) {
    var i = r.call(this) || this;
    return i.id = Qm++, i._media = null, i._paused = !1, i._muted = !1, i._elapsed = 0, i.init(e), i;
  }
  return re(t, r), t.prototype.set = function(e, i) {
    if (this[e] === void 0) throw new Error("Property with name ".concat(e, " does not exist."));
    switch (e) {
      case "speed":
        this.speed = i;
        break;
      case "volume":
        this.volume = i;
        break;
      case "muted":
        this.muted = i;
        break;
      case "loop":
        this.loop = i;
        break;
      case "paused":
        this.paused = i;
    }
    return this;
  }, t.prototype.stop = function() {
    this._source && (this._internalStop(), this.emit("stop"));
  }, Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(e) {
    this._speed = e, this.refresh(), this._update(!0);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(e) {
    this._volume = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(e) {
    this._muted = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(e) {
    this._loop = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(e) {
    var i;
    this._filters && ((i = this._filters) === null || i === void 0 || i.filter(function(n) {
      return n;
    }).forEach(function(n) {
      return n.disconnect();
    }), this._filters = null, this._source.connect(this._gain)), this._filters = e?.length ? e.slice(0) : null, this.refresh();
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    if (this._source) {
      var e = this._media.context, i = this._media.parent;
      this._source.loop = this._loop || i.loop;
      var n = e.volume * (e.muted ? 0 : 1), s = i.volume * (i.muted ? 0 : 1), o = this._volume * (this._muted ? 0 : 1);
      ae.setParamValue(this._gain.gain, o * s * n), ae.setParamValue(this._source.playbackRate, this._speed * i.speed * e.speed), this.applyFilters();
    }
  }, t.prototype.applyFilters = function() {
    var e;
    if (!((e = this._filters) === null || e === void 0) && e.length) {
      this._source.disconnect();
      var i = this._source;
      this._filters.forEach(function(n) {
        i.connect(n.destination), i = n;
      }), i.connect(this._gain);
    }
  }, t.prototype.refreshPaused = function() {
    var e = this._media.context, i = this._media.parent, n = this._paused || i.paused || e.paused;
    n !== this._pausedReal && (this._pausedReal = n, n ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume })), this.emit("pause", n));
  }, t.prototype.play = function(e) {
    var i = e.start, n = e.end, s = e.speed, o = e.loop, a = e.volume, h = e.muted, l = e.filters;
    this._paused = !1;
    var u = this._media.nodes.cloneBufferSource(), c = u.source, f = u.gain;
    this._source = c, this._gain = f, this._speed = s, this._volume = a, this._loop = !!o, this._muted = h, this._filters = l, this.refresh();
    var d = this._source.buffer.duration;
    this._duration = d, this._end = n, this._lastUpdate = this._now(), this._elapsed = i, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = n, this._source.loopStart = i, this._source.start(0, i)) : n ? this._source.start(0, i, n - i) : this._source.start(0, i), this.emit("start"), this._update(!0), this.enableTicker(!0);
  }, t.prototype.enableTicker = function(e) {
    Lt.shared.remove(this._updateListener, this), e && Lt.shared.add(this._updateListener, this);
  }, Object.defineProperty(t.prototype, "progress", { get: function() {
    return this._progress;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    this._paused = e, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    var e;
    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off("refresh", this.refresh, this), this._media.context.events.off("refreshPaused", this.refreshPaused, this), this._media = null), (e = this._filters) === null || e === void 0 || e.forEach(function(i) {
      return i.disconnect();
    }), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = !1, this._elapsed = 0, this._duration = 0, this._paused = !1, this._muted = !1, this._pausedReal = !1;
  }, t.prototype.toString = function() {
    return "[WebAudioInstance id=".concat(this.id, "]");
  }, t.prototype._now = function() {
    return this._media.context.audioContext.currentTime;
  }, t.prototype._updateListener = function() {
    this._update();
  }, t.prototype._update = function(e) {
    if (e === void 0 && (e = !1), this._source) {
      var i = this._now(), n = i - this._lastUpdate;
      if (n > 0 || e) {
        var s = this._source.playbackRate.value;
        this._elapsed += n * s, this._lastUpdate = i;
        var o = this._duration, a = void 0;
        if (this._source.loopStart) {
          var h = this._source.loopEnd - this._source.loopStart;
          a = (this._source.loopStart + this._elapsed % h) / o;
        } else a = this._elapsed % o / o;
        this._progress = a, this.emit("progress", this._progress, o);
      }
    }
  }, t.prototype.init = function(e) {
    this._media = e, e.context.events.on("refresh", this.refresh, this), e.context.events.on("refreshPaused", this.refreshPaused, this);
  }, t.prototype._internalStop = function() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.stop(0), this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch {
      }
      this._source = null;
    }
  }, t.prototype._onComplete = function() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch {
      }
    }
    this._source = null, this._progress = 1, this.emit("progress", 1, this._duration), this.emit("end", this);
  }, t;
}(Pe), Cl = function() {
  function r(t, e) {
    this._output = e, this._input = t;
  }
  return Object.defineProperty(r.prototype, "destination", { get: function() {
    return this._input;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(t) {
    var e = this;
    if (this._filters && (this._filters.forEach(function(n) {
      n && n.disconnect();
    }), this._filters = null, this._input.connect(this._output)), t && t.length) {
      this._filters = t.slice(0), this._input.disconnect();
      var i = null;
      t.forEach(function(n) {
        i === null ? e._input.connect(n.destination) : i.connect(n.destination), i = n;
      }), i.connect(this._output);
    }
  }, enumerable: !1, configurable: !0 }), r.prototype.destroy = function() {
    this.filters = null, this._input = null, this._output = null;
  }, r;
}(), ey = function(r) {
  function t(e) {
    var i = this, n = e.audioContext, s = n.createBufferSource(), o = n.createGain(), a = n.createAnalyser();
    return s.connect(a), a.connect(o), o.connect(e.destination), (i = r.call(this, a, o) || this).context = e, i.bufferSource = s, i.gain = o, i.analyser = a, i;
  }
  return re(t, r), Object.defineProperty(t.prototype, "script", { get: function() {
    return this._script || (this._script = this.context.audioContext.createScriptProcessor(t.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    r.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;
  }, t.prototype.cloneBufferSource = function() {
    var e = this.bufferSource, i = this.context.audioContext.createBufferSource();
    i.buffer = e.buffer, ae.setParamValue(i.playbackRate, e.playbackRate.value), i.loop = e.loop;
    var n = this.context.audioContext.createGain();
    return i.connect(n), n.connect(this.destination), { source: i, gain: n };
  }, Object.defineProperty(t.prototype, "bufferSize", { get: function() {
    return this.script.bufferSize;
  }, enumerable: !1, configurable: !0 }), t.BUFFER_SIZE = 0, t;
}(Cl), iy = function() {
  function r() {
  }
  return r.prototype.init = function(t) {
    this.parent = t, this._nodes = new ey(this.context), this._source = this._nodes.bufferSource, this.source = t.options.source;
  }, r.prototype.destroy = function() {
    this.parent = null, this._nodes.destroy(), this._nodes = null;
    try {
      this._source.buffer = null;
    } catch {
    }
    this._source = null, this.source = null;
  }, r.prototype.create = function() {
    return new ty(this);
  }, Object.defineProperty(r.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "isPlayable", { get: function() {
    return !!this._source && !!this._source.buffer;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "filters", { get: function() {
    return this._nodes.filters;
  }, set: function(t) {
    this._nodes.filters = t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "duration", { get: function() {
    return this._source.buffer.duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "buffer", { get: function() {
    return this._source.buffer;
  }, set: function(t) {
    this._source.buffer = t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "nodes", { get: function() {
    return this._nodes;
  }, enumerable: !1, configurable: !0 }), r.prototype.load = function(t) {
    this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t && t(new Error("sound.url or sound.source must be set"));
  }, r.prototype._loadUrl = function(t) {
    var e = this, i = new XMLHttpRequest(), n = this.parent.url;
    i.open("GET", n, !0), i.responseType = "arraybuffer", i.onload = function() {
      e.source = i.response, e._decode(i.response, t);
    }, i.send();
  }, r.prototype._decode = function(t, e) {
    var i = this, n = function(s, o) {
      if (s) e && e(s);
      else {
        i.parent.isLoaded = !0, i.buffer = o;
        var a = i.parent.autoPlayStart();
        e && e(null, i.parent, a);
      }
    };
    t instanceof AudioBuffer ? n(null, t) : this.parent.context.decode(t, n);
  }, r;
}(), fr = function() {
  function r(t, e) {
    this.media = t, this.options = e, this._instances = [], this._sprites = {}, this.media.init(this);
    var i = e.complete;
    this._autoPlayOptions = i ? { complete: i } : null, this.isLoaded = !1, this.isPlaying = !1, this.autoPlay = e.autoPlay, this.singleInstance = e.singleInstance, this.preload = e.preload || this.autoPlay, this.url = e.url, this.speed = e.speed, this.volume = e.volume, this.loop = e.loop, e.sprites && this.addSprites(e.sprites), this.preload && this._preload(e.loaded);
  }
  return r.from = function(t) {
    var e = {};
    return typeof t == "string" ? e.url = t : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? e.source = t : e = t, (e = ji({ autoPlay: !1, singleInstance: !1, url: null, source: null, preload: !1, volume: 1, speed: 1, complete: null, loaded: null, loop: !1 }, e)).url && (e.url = Sl(e.url)), Object.freeze(e), new r(Ht().useLegacy ? new Km() : new iy(), e);
  }, Object.defineProperty(r.prototype, "context", { get: function() {
    return Ht().context;
  }, enumerable: !1, configurable: !0 }), r.prototype.pause = function() {
    return this.isPlaying = !1, this.paused = !0, this;
  }, r.prototype.resume = function() {
    return this.isPlaying = this._instances.length > 0, this.paused = !1, this;
  }, Object.defineProperty(r.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(t) {
    this._paused = t, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(t) {
    this._speed = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "filters", { get: function() {
    return this.media.filters;
  }, set: function(t) {
    this.media.filters = t;
  }, enumerable: !1, configurable: !0 }), r.prototype.addSprites = function(t, e) {
    if (typeof t == "object") {
      var i = {};
      for (var n in t) i[n] = this.addSprites(n, t[n]);
      return i;
    }
    var s = new Jm(this, e);
    return this._sprites[t] = s, s;
  }, r.prototype.destroy = function() {
    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;
  }, r.prototype.removeSprites = function(t) {
    if (t) {
      var e = this._sprites[t];
      e !== void 0 && (e.destroy(), delete this._sprites[t]);
    } else for (var i in this._sprites) this.removeSprites(i);
    return this;
  }, Object.defineProperty(r.prototype, "isPlayable", { get: function() {
    return this.isLoaded && this.media && this.media.isPlayable;
  }, enumerable: !1, configurable: !0 }), r.prototype.stop = function() {
    if (!this.isPlayable) return this.autoPlay = !1, this._autoPlayOptions = null, this;
    this.isPlaying = !1;
    for (var t = this._instances.length - 1; t >= 0; t--) this._instances[t].stop();
    return this;
  }, r.prototype.play = function(t, e) {
    var i, n = this;
    if (typeof t == "string" ? i = { sprite: o = t, loop: this.loop, complete: e } : typeof t == "function" ? (i = {}).complete = t : i = t, (i = ji({ complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: !1, loop: !1 }, i || {})).sprite) {
      var s = i.sprite, o = this._sprites[s];
      i.start = o.start + (i.start || 0), i.end = o.end, i.speed = o.speed || 1, i.loop = o.loop || i.loop, delete i.sprite;
    }
    if (i.offset && (i.start = i.offset), !this.isLoaded) return new Promise(function(h, l) {
      n.autoPlay = !0, n._autoPlayOptions = i, n._preload(function(u, c, f) {
        u ? l(u) : (i.loaded && i.loaded(u, c, f), h(f));
      });
    });
    (this.singleInstance || i.singleInstance) && this._removeInstances();
    var a = this._createInstance();
    return this._instances.push(a), this.isPlaying = !0, a.once("end", function() {
      i.complete && i.complete(n), n._onComplete(a);
    }), a.once("stop", function() {
      n._onComplete(a);
    }), a.play(i), a;
  }, r.prototype.refresh = function() {
    for (var t = this._instances.length, e = 0; e < t; e++) this._instances[e].refresh();
  }, r.prototype.refreshPaused = function() {
    for (var t = this._instances.length, e = 0; e < t; e++) this._instances[e].refreshPaused();
  }, Object.defineProperty(r.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(t) {
    this._volume = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(t) {
    this._muted = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(t) {
    this._loop = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), r.prototype._preload = function(t) {
    this.media.load(t);
  }, Object.defineProperty(r.prototype, "instances", { get: function() {
    return this._instances;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "sprites", { get: function() {
    return this._sprites;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "duration", { get: function() {
    return this.media.duration;
  }, enumerable: !1, configurable: !0 }), r.prototype.autoPlayStart = function() {
    var t;
    return this.autoPlay && (t = this.play(this._autoPlayOptions)), t;
  }, r.prototype._removeInstances = function() {
    for (var t = this._instances.length - 1; t >= 0; t--) this._poolInstance(this._instances[t]);
    this._instances.length = 0;
  }, r.prototype._onComplete = function(t) {
    if (this._instances) {
      var e = this._instances.indexOf(t);
      e > -1 && this._instances.splice(e, 1), this.isPlaying = this._instances.length > 0;
    }
    this._poolInstance(t);
  }, r.prototype._createInstance = function() {
    if (r._pool.length > 0) {
      var t = r._pool.pop();
      return t.init(this.media), t;
    }
    return this.media.create();
  }, r.prototype._poolInstance = function(t) {
    t.destroy(), r._pool.indexOf(t) < 0 && r._pool.push(t);
  }, r._pool = [], r;
}(), ry = function(r) {
  function t() {
    var e = r !== null && r.apply(this, arguments) || this;
    return e.speed = 1, e.muted = !1, e.volume = 1, e.paused = !1, e;
  }
  return re(t, r), t.prototype.refresh = function() {
    this.emit("refresh");
  }, t.prototype.refreshPaused = function() {
    this.emit("refreshPaused");
  }, Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "audioContext", { get: function() {
    return null;
  }, enumerable: !1, configurable: !0 }), t.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, t.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this.paused;
  }, t.prototype.destroy = function() {
    this.removeAllListeners();
  }, t;
}(Pe), rh = function(r) {
  function t() {
    var e = r.call(this, null, null) || this;
    e.autoPause = !0;
    var i = window, n = new t.AudioContext(), s = n.createDynamicsCompressor(), o = n.createAnalyser();
    return o.connect(s), s.connect(n.destination), e._input = o, e._output = n.destination, e._ctx = n, e._offlineCtx = new t.OfflineAudioContext(1, 2, i.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, n.sampleRate)) : 44100), e.compressor = s, e.analyser = o, e.events = new Pe(), e.volume = 1, e.speed = 1, e.muted = !1, e.paused = !1, e._locked = n.state === "suspended" && ("ontouchstart" in globalThis || "onclick" in globalThis), e._locked && (e._unlock(), e._unlock = e._unlock.bind(e), document.addEventListener("mousedown", e._unlock, !0), document.addEventListener("touchstart", e._unlock, !0), document.addEventListener("touchend", e._unlock, !0)), e.onFocus = e.onFocus.bind(e), e.onBlur = e.onBlur.bind(e), globalThis.addEventListener("focus", e.onFocus), globalThis.addEventListener("blur", e.onBlur), e;
  }
  return re(t, r), t.prototype.onFocus = function() {
    if (this.autoPause) {
      var e = this._ctx.state;
      e !== "suspended" && e !== "interrupted" && this._locked || (this.paused = this._pausedOnBlur, this.refreshPaused());
    }
  }, t.prototype.onBlur = function() {
    this.autoPause && (this._locked || (this._pausedOnBlur = this._paused, this.paused = !0, this.refreshPaused()));
  }, t.prototype._unlock = function() {
    this._locked && (this.playEmptySound(), this._ctx.state === "running" && (document.removeEventListener("mousedown", this._unlock, !0), document.removeEventListener("touchend", this._unlock, !0), document.removeEventListener("touchstart", this._unlock, !0), this._locked = !1));
  }, t.prototype.playEmptySound = function() {
    var e = this._ctx.createBufferSource();
    e.buffer = this._ctx.createBuffer(1, 1, 22050), e.connect(this._ctx.destination), e.start(0, 0, 0), e.context.state === "suspended" && e.context.resume();
  }, Object.defineProperty(t, "AudioContext", { get: function() {
    var e = window;
    return e.AudioContext || e.webkitAudioContext || null;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "OfflineAudioContext", { get: function() {
    var e = window;
    return e.OfflineAudioContext || e.webkitOfflineAudioContext || null;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    r.prototype.destroy.call(this);
    var e = this._ctx;
    e.close !== void 0 && e.close(), globalThis.removeEventListener("focus", this.onFocus), globalThis.removeEventListener("blur", this.onBlur), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;
  }, Object.defineProperty(t.prototype, "audioContext", { get: function() {
    return this._ctx;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "offlineContext", { get: function() {
    return this._offlineCtx;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    e && this._ctx.state === "running" ? this._ctx.suspend() : e || this._ctx.state !== "suspended" || this._ctx.resume(), this._paused = e;
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    this.events.emit("refresh");
  }, t.prototype.refreshPaused = function() {
    this.events.emit("refreshPaused");
  }, t.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, t.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this._paused;
  }, t.prototype.decode = function(e, i) {
    var n = function(o) {
      i(new Error(o?.message || "Unable to decode file"));
    }, s = this._offlineCtx.decodeAudioData(e, function(o) {
      i(null, o);
    }, n);
    s && s.catch(n);
  }, t;
}(Cl), ny = function() {
  function r() {
    this.init();
  }
  return r.prototype.init = function() {
    return this.supported && (this._webAudioContext = new rh()), this._htmlAudioContext = new ry(), this._sounds = {}, this.useLegacy = !this.supported, this;
  }, Object.defineProperty(r.prototype, "context", { get: function() {
    return this._context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "filtersAll", { get: function() {
    return this.useLegacy ? [] : this._context.filters;
  }, set: function(t) {
    this.useLegacy || (this._context.filters = t);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "supported", { get: function() {
    return rh.AudioContext !== null;
  }, enumerable: !1, configurable: !0 }), r.prototype.add = function(t, e) {
    if (typeof t == "object") {
      var i = {};
      for (var n in t) {
        var s = this._getOptions(t[n], e);
        i[n] = this.add(n, s);
      }
      return i;
    }
    if (e instanceof fr) return this._sounds[t] = e, e;
    var o = this._getOptions(e), a = fr.from(o);
    return this._sounds[t] = a, a;
  }, r.prototype._getOptions = function(t, e) {
    var i;
    return i = typeof t == "string" ? { url: t } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? { source: t } : t, i = ji(ji({}, i), e || {});
  }, Object.defineProperty(r.prototype, "useLegacy", { get: function() {
    return this._useLegacy;
  }, set: function(t) {
    Pl.setLegacy(t), this._useLegacy = t, this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "disableAutoPause", { get: function() {
    return !this._webAudioContext.autoPause;
  }, set: function(t) {
    this._webAudioContext.autoPause = !t;
  }, enumerable: !1, configurable: !0 }), r.prototype.remove = function(t) {
    return this.exists(t, !0), this._sounds[t].destroy(), delete this._sounds[t], this;
  }, Object.defineProperty(r.prototype, "volumeAll", { get: function() {
    return this._context.volume;
  }, set: function(t) {
    this._context.volume = t, this._context.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "speedAll", { get: function() {
    return this._context.speed;
  }, set: function(t) {
    this._context.speed = t, this._context.refresh();
  }, enumerable: !1, configurable: !0 }), r.prototype.togglePauseAll = function() {
    return this._context.togglePause();
  }, r.prototype.pauseAll = function() {
    return this._context.paused = !0, this._context.refreshPaused(), this;
  }, r.prototype.resumeAll = function() {
    return this._context.paused = !1, this._context.refreshPaused(), this;
  }, r.prototype.toggleMuteAll = function() {
    return this._context.toggleMute();
  }, r.prototype.muteAll = function() {
    return this._context.muted = !0, this._context.refresh(), this;
  }, r.prototype.unmuteAll = function() {
    return this._context.muted = !1, this._context.refresh(), this;
  }, r.prototype.removeAll = function() {
    for (var t in this._sounds) this._sounds[t].destroy(), delete this._sounds[t];
    return this;
  }, r.prototype.stopAll = function() {
    for (var t in this._sounds) this._sounds[t].stop();
    return this;
  }, r.prototype.exists = function(t, e) {
    return !!this._sounds[t];
  }, r.prototype.find = function(t) {
    return this.exists(t, !0), this._sounds[t];
  }, r.prototype.play = function(t, e) {
    return this.find(t).play(e);
  }, r.prototype.stop = function(t) {
    return this.find(t).stop();
  }, r.prototype.pause = function(t) {
    return this.find(t).pause();
  }, r.prototype.resume = function(t) {
    return this.find(t).resume();
  }, r.prototype.volume = function(t, e) {
    var i = this.find(t);
    return e !== void 0 && (i.volume = e), i.volume;
  }, r.prototype.speed = function(t, e) {
    var i = this.find(t);
    return e !== void 0 && (i.speed = e), i.speed;
  }, r.prototype.duration = function(t) {
    return this.find(t).duration;
  }, r.prototype.close = function() {
    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;
  }, r;
}(), _i = function() {
  function r(t, e) {
    this.init(t, e);
  }
  return r.prototype.init = function(t, e) {
    this.destination = t, this.source = e || t;
  }, r.prototype.connect = function(t) {
    this.source.connect(t);
  }, r.prototype.disconnect = function() {
    this.source.disconnect();
  }, r.prototype.destroy = function() {
    this.disconnect(), this.destination = null, this.source = null;
  }, r;
}(), _n = { __proto__: null, EqualizerFilter: function(r) {
  function t(e, i, n, s, o, a, h, l, u, c) {
    e === void 0 && (e = 0), i === void 0 && (i = 0), n === void 0 && (n = 0), s === void 0 && (s = 0), o === void 0 && (o = 0), a === void 0 && (a = 0), h === void 0 && (h = 0), l === void 0 && (l = 0), u === void 0 && (u = 0), c === void 0 && (c = 0);
    var f = this;
    if (!Ht().useLegacy) {
      var d = [{ f: t.F32, type: "lowshelf", gain: e }, { f: t.F64, type: "peaking", gain: i }, { f: t.F125, type: "peaking", gain: n }, { f: t.F250, type: "peaking", gain: s }, { f: t.F500, type: "peaking", gain: o }, { f: t.F1K, type: "peaking", gain: a }, { f: t.F2K, type: "peaking", gain: h }, { f: t.F4K, type: "peaking", gain: l }, { f: t.F8K, type: "peaking", gain: u }, { f: t.F16K, type: "highshelf", gain: c }].map(function(_) {
        var m = Ht().context.audioContext.createBiquadFilter();
        return m.type = _.type, ae.setParamValue(m.Q, 1), m.frequency.value = _.f, ae.setParamValue(m.gain, _.gain), m;
      });
      (f = r.call(this, d[0], d[d.length - 1]) || this).bands = d, f.bandsMap = {};
      for (var p = 0; p < f.bands.length; p++) {
        var v = f.bands[p];
        p > 0 && f.bands[p - 1].connect(v), f.bandsMap[v.frequency.value] = v;
      }
      return f;
    }
    f = r.call(this, null) || this;
  }
  return re(t, r), t.prototype.setGain = function(e, i) {
    if (i === void 0 && (i = 0), !this.bandsMap[e]) throw new Error("No band found for frequency ".concat(e));
    ae.setParamValue(this.bandsMap[e].gain, i);
  }, t.prototype.getGain = function(e) {
    if (!this.bandsMap[e]) throw new Error("No band found for frequency ".concat(e));
    return this.bandsMap[e].gain.value;
  }, Object.defineProperty(t.prototype, "f32", { get: function() {
    return this.getGain(t.F32);
  }, set: function(e) {
    this.setGain(t.F32, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f64", { get: function() {
    return this.getGain(t.F64);
  }, set: function(e) {
    this.setGain(t.F64, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f125", { get: function() {
    return this.getGain(t.F125);
  }, set: function(e) {
    this.setGain(t.F125, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f250", { get: function() {
    return this.getGain(t.F250);
  }, set: function(e) {
    this.setGain(t.F250, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f500", { get: function() {
    return this.getGain(t.F500);
  }, set: function(e) {
    this.setGain(t.F500, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f1k", { get: function() {
    return this.getGain(t.F1K);
  }, set: function(e) {
    this.setGain(t.F1K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f2k", { get: function() {
    return this.getGain(t.F2K);
  }, set: function(e) {
    this.setGain(t.F2K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f4k", { get: function() {
    return this.getGain(t.F4K);
  }, set: function(e) {
    this.setGain(t.F4K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f8k", { get: function() {
    return this.getGain(t.F8K);
  }, set: function(e) {
    this.setGain(t.F8K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f16k", { get: function() {
    return this.getGain(t.F16K);
  }, set: function(e) {
    this.setGain(t.F16K, e);
  }, enumerable: !1, configurable: !0 }), t.prototype.reset = function() {
    this.bands.forEach(function(e) {
      ae.setParamValue(e.gain, 0);
    });
  }, t.prototype.destroy = function() {
    this.bands.forEach(function(e) {
      e.disconnect();
    }), this.bands = null, this.bandsMap = null;
  }, t.F32 = 32, t.F64 = 64, t.F125 = 125, t.F250 = 250, t.F500 = 500, t.F1K = 1e3, t.F2K = 2e3, t.F4K = 4e3, t.F8K = 8e3, t.F16K = 16e3, t;
}(_i), DistortionFilter: function(r) {
  function t(e) {
    e === void 0 && (e = 0);
    var i = this;
    if (!Ht().useLegacy) {
      var n = Ht().context.audioContext.createWaveShaper();
      return (i = r.call(this, n) || this)._distortion = n, i.amount = e, i;
    }
    i = r.call(this, null) || this;
  }
  return re(t, r), Object.defineProperty(t.prototype, "amount", { get: function() {
    return this._amount;
  }, set: function(e) {
    this._amount = e;
    for (var i, n = 1e3 * e, s = 44100, o = new Float32Array(s), a = Math.PI / 180, h = 0; h < s; ++h) i = 2 * h / s - 1, o[h] = (3 + n) * i * 20 * a / (Math.PI + n * Math.abs(i));
    this._distortion.curve = o, this._distortion.oversample = "4x";
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this._distortion = null, r.prototype.destroy.call(this);
  }, t;
}(_i), StereoFilter: function(r) {
  function t(e) {
    e === void 0 && (e = 0);
    var i = this;
    if (!Ht().useLegacy) {
      var n, s, o, a = Ht().context.audioContext;
      return a.createStereoPanner ? o = n = a.createStereoPanner() : ((s = a.createPanner()).panningModel = "equalpower", o = s), (i = r.call(this, o) || this)._stereo = n, i._panner = s, i.pan = e, i;
    }
    i = r.call(this, null) || this;
  }
  return re(t, r), Object.defineProperty(t.prototype, "pan", { get: function() {
    return this._pan;
  }, set: function(e) {
    this._pan = e, this._stereo ? ae.setParamValue(this._stereo.pan, e) : this._panner.setPosition(e, 0, 1 - Math.abs(e));
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    r.prototype.destroy.call(this), this._stereo = null, this._panner = null;
  }, t;
}(_i), ReverbFilter: function(r) {
  function t(e, i, n) {
    e === void 0 && (e = 3), i === void 0 && (i = 2), n === void 0 && (n = !1);
    var s = this;
    if (!Ht().useLegacy) return (s = r.call(this, null) || this)._seconds = s._clamp(e, 1, 50), s._decay = s._clamp(i, 0, 100), s._reverse = n, s._rebuild(), s;
    s = r.call(this, null) || this;
  }
  return re(t, r), t.prototype._clamp = function(e, i, n) {
    return Math.min(n, Math.max(i, e));
  }, Object.defineProperty(t.prototype, "seconds", { get: function() {
    return this._seconds;
  }, set: function(e) {
    this._seconds = this._clamp(e, 1, 50), this._rebuild();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "decay", { get: function() {
    return this._decay;
  }, set: function(e) {
    this._decay = this._clamp(e, 0, 100), this._rebuild();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "reverse", { get: function() {
    return this._reverse;
  }, set: function(e) {
    this._reverse = e, this._rebuild();
  }, enumerable: !1, configurable: !0 }), t.prototype._rebuild = function() {
    for (var e, i = Ht().context.audioContext, n = i.sampleRate, s = n * this._seconds, o = i.createBuffer(2, s, n), a = o.getChannelData(0), h = o.getChannelData(1), l = 0; l < s; l++) e = this._reverse ? s - l : l, a[l] = (2 * Math.random() - 1) * Math.pow(1 - e / s, this._decay), h[l] = (2 * Math.random() - 1) * Math.pow(1 - e / s, this._decay);
    var u = Ht().context.audioContext.createConvolver();
    u.buffer = o, this.init(u);
  }, t;
}(_i), MonoFilter: function(r) {
  function t() {
    var e = this;
    if (!Ht().useLegacy) {
      var i = Ht().context.audioContext, n = i.createChannelSplitter(), s = i.createChannelMerger();
      return s.connect(n), (e = r.call(this, s, n) || this)._merger = s, e;
    }
    e = r.call(this, null) || this;
  }
  return re(t, r), t.prototype.destroy = function() {
    this._merger.disconnect(), this._merger = null, r.prototype.destroy.call(this);
  }, t;
}(_i), StreamFilter: function(r) {
  function t() {
    var e = this;
    if (!Ht().useLegacy) {
      var i = Ht().context.audioContext, n = i.createMediaStreamDestination(), s = i.createMediaStreamSource(n.stream);
      return (e = r.call(this, n, s) || this)._stream = n.stream, e;
    }
    e = r.call(this, null) || this;
  }
  return re(t, r), Object.defineProperty(t.prototype, "stream", { get: function() {
    return this._stream;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this._stream = null, r.prototype.destroy.call(this);
  }, t;
}(_i), TelephoneFilter: function(r) {
  function t() {
    if (!Ht().useLegacy) {
      var e = Ht().context.audioContext, i = e.createBiquadFilter(), n = e.createBiquadFilter(), s = e.createBiquadFilter(), o = e.createBiquadFilter();
      return i.type = "lowpass", ae.setParamValue(i.frequency, 2e3), n.type = "lowpass", ae.setParamValue(n.frequency, 2e3), s.type = "highpass", ae.setParamValue(s.frequency, 500), o.type = "highpass", ae.setParamValue(o.frequency, 500), i.connect(n), n.connect(s), s.connect(o), r.call(this, i, o) || this;
    }
    r.call(this, null);
  }
  return re(t, r), t;
}(_i) }, m0 = { __proto__: null, supported: Gn }, nh = function(r) {
  return wl = r, r;
}(new ny());
Ue.add(Pl);
class si {
  constructor(t, e, i, n, s, o, a, h) {
    this.fn = t, this.buf = e, this.start_ms = i, this.end_ms = n, this.ret_ms = s, this.volume = o, this.pan = a, this.snd = h, this.stt = h ? new Pr(this) : new sy(), this.#t = D.procID, h && this.addSnd(h);
  }
  static #e = 1;
  stt;
  loop = !1;
  #t;
  get procID() {
    return this.#t;
  }
  addSnd(t) {
    switch (this.loop = t.loop, this.stt.onLoad(this), this.pan !== 0 && (t.filters = [new _n.StereoFilter(this.pan)]), this.setVol = (e) => t.volume = e, this.tw = () => new Er(t), this.onPlayEnd = () => {
      this.stt.onPlayEnd(this.buf), this.#i();
    }, this.stop = () => {
      t.stop(), this.#i();
    }, this.destroy = () => t.destroy(), this.buf) {
      // セリフ再生中はBGM音量を絞る
      case ah:
        const e = Number(Tt.getVal("sys:sn.sound.BGM.vol_mul_talking") ?? 1);
        if (e === 1) break;
        si.#e = e;
        const i = po[mn];
        i && i.setVol(this.volume * si.#e);
        break;
      case mn:
        t.volume = this.volume * si.#e;
        break;
    }
  }
  #i = () => {
    if (this.#i = () => {
    }, si.#e === 1 || this.buf !== ah) return;
    si.#e = 1;
    const t = po[mn];
    t && t.setVol(this.volume * si.#e);
  };
  setVol(t) {
  }
  tw() {
  }
  onPlayEnd() {
  }
  stop() {
  }
  destroy() {
  }
}
let sh, Tt, ri, oh, po, An;
const mn = "BGM", dr = "SE", ah = "VOICE";
class Dt {
  constructor(t, e, i) {
    this.hArg = t, this.buf = e, this.fn = i;
    const n = L(t, "start_ms", 0), s = L(t, "end_ms", Dt.#t), o = L(t, "ret_ms", 0), a = L(t, "pan", 0), h = L(t, "speed", 1);
    if (n < 0) throw `[playse] start_ms:${n} が負の値です`;
    if (o < 0) throw `[playse] ret_ms:${o} が負の値です`;
    if (0 < s) {
      if (s <= n) throw `[playse] start_ms:${n} >= end_ms:${s} は異常値です`;
      if (s <= o) throw `[playse] ret_ms:${o} >= end_ms:${s} は異常値です`;
    }
    const l = "const.sn.sound." + e + ".";
    Tt.setVal_Nochk("save", l + "fn", i);
    const u = Dt.getVol(t, 1);
    Tt.setVal_Nochk("save", l + "volume", u);
    const c = u * Number(Tt.getVal("sys:" + l + "volume", 1)), f = $(t, "loop", !1);
    f ? (Dt.#e[e] = i, Tt.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(Dt.#e))) : Dt.delLoopPlay(e), Tt.setVal_Nochk("save", l + "start_ms", n), Tt.setVal_Nochk("save", l + "end_ms", s), Tt.setVal_Nochk("save", l + "ret_ms", o), Tt.setVal_Nochk("tmp", l + "playing", !0), Tt.flush();
    const d = nh.find(i);
    this.#i = new si(
      i,
      e,
      n,
      s,
      o,
      c,
      a,
      d
    );
    const p = {
      loop: f,
      speed: h,
      volume: c,
      loaded: (m, y) => {
        if (!this.#i.stt.isDestroy) {
          if (m) {
            ri.errScript(`ロード失敗です SndBuf fn:${i} ${m}`, !1);
            return;
          }
          y && (this.#i.addSnd(y), a !== 0 && (y.filters = [new _n.StereoFilter(a)]), t.fnc?.());
        }
      }
    };
    let v = "";
    if (0 < n || s < Dt.#t) {
      v = `${i};${n};${s};${o}`;
      const m = (p.sprites ??= {})[v] = {
        start: n / 1e3,
        end: s / 1e3
      };
      p.preload = !0;
      const y = p.loaded;
      p.loaded = (b, P) => {
        if (this.#i.stt.isDestroy) return;
        y(b, P);
        const x = P, T = x.duration;
        m.end < 0 && (m.end += T, x.removeSprites(v), x.addSprites(v, m)), m.end <= m.start && ri.errScript(`[playse] end_ms:${s}(${m.end * 1e3}) >= start_ms:${n} は異常値です`), m.end * 1e3 <= o && ri.errScript(`[playse] end_ms:${s}(${m.end * 1e3}) <= ret_ms:${o} は異常値です`), T <= m.start && ri.errScript(`[playse] 音声ファイル再生時間:${T * 1e3} <= start_ms:${n} は異常値です`), s !== Dt.#t && T <= m.end && ri.errScript(`[playse] 音声ファイル再生時間:${T * 1e3} <= end_ms:${s} は異常値です`), x.play(v, (I) => p.complete?.(I));
      };
    } else p.autoPlay = !0;
    if (f ? o !== 0 && (p.loop = !1, p.complete = async (m) => {
      const y = m.duration, b = o / 1e3, P = s / 1e3;
      y <= b && ri.errScript(`[playse] 音声ファイル再生時間:${y * 1e3} <=  ret_ms:${o} は異常値です`), await m.play({
        // 一周目はループなし、なのでキャッシュされてる
        ...p,
        start: b,
        end: P < 0 ? P + y : P,
        // 負の値は末尾から
        //	speed,		// 重複
        loop: !0,
        //	volume,		// 重複
        //-	muted?: boolean;
        filters: a !== 0 ? [new _n.StereoFilter(a)] : []
        //-	complete?: CompleteCallback;
        //-	loaded?: LoadedCallback;
        //-	singleInstance?: boolean;
      });
    }) : p.complete = () => {
      vo(this.#i, e), this.#i.onPlayEnd();
    }, this.#n(), d) {
      if (d.volume = c, v) this.#r(i, p);
      else if (d.isPlayable) {
        const m = d.options.source;
        !(m instanceof ArrayBuffer) || m.byteLength === 0 ? d.play(p) : this.#i.addSnd(fr.from({
          ...p,
          url: d.options.url,
          source: m
        }));
      }
      a !== 0 && (d.filters = [new _n.StereoFilter(a)]), this.needLoad = !1;
      return;
    }
    if (this.needLoad = $(t, "join", !0)) {
      const m = this.#i.procID + `loaded buf:${e} fn:${i}`;
      D.beginProc(m);
      const y = p.loaded;
      p.loaded = (b, P) => {
        y(b, P), D.endProc(m);
      };
    }
    this.#r(i, p);
  }
  static #e = {};
  static init(t, e, i, n, s) {
    Dt.#e = {}, sh = t, Tt = e, ri = i, oh = n, po = s;
  }
  static setEvtMng(t) {
    An = t;
  }
  static delLoopPlay(t) {
    delete Dt.#e[t];
    const e = "const.sn.sound." + t + ".";
    Tt.setVal_Nochk("save", e + "fn", ""), Tt.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(Dt.#e)), Tt.flush();
  }
  static getVol(t, e) {
    const i = L(t, "volume", e);
    return i < 0 ? 0 : i > 1 ? 1 : i;
  }
  static xchgbuf({ buf: t = dr, buf2: e = dr }) {
    if (t === e) throw `[xchgbuf] buf:${t} が同じ値です`;
    const i = "const.sn.sound." + t + ".", n = Number(Tt.getVal("save:" + i + "volume")), s = String(Tt.getVal("save:" + i + "fn")), o = "const.sn.sound." + e + ".", a = Number(Tt.getVal("save:" + o + "volume")), h = String(Tt.getVal("save:" + o + "fn"));
    Tt.setVal_Nochk("save", i + "volume", a), Tt.setVal_Nochk("save", o + "volume", n), Tt.setVal_Nochk("save", i + "fn", h), Tt.setVal_Nochk("save", o + "fn", s), t in Dt.#e != e in Dt.#e && (t in Dt.#e ? (delete Dt.#e[t], Dt.#e[e] = s) : (delete Dt.#e[e], Dt.#e[t] = h), Tt.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(Dt.#e))), Tt.flush();
  }
  static #t = 999e3;
  #i;
  needLoad;
  #n = () => {
    nh.volumeAll = Number(Tt.getVal("sys:sn.sound.global_volume", 1)), this.#n = () => {
    };
  };
  #r(t, e) {
    const i = sh.searchPath(t, qt.SOUND);
    if (!i.endsWith(".bin")) {
      e.url = i, fr.from(e);
      return;
    }
    new ue().add({ name: t, url: i, xhrType: ft.XHR_RESPONSE_TYPE.BUFFER }).use(async (n, s) => {
      try {
        n.data = await oh.decAB(n.data);
      } catch (o) {
        ri.errScript(`Sound ロード失敗ですc fn:${n.name} ${o}`, !1);
      }
      s();
    }).load((n, s) => {
      e.source = s[t]?.data, fr.from(e);
    });
  }
  setVol(t) {
    this.#i.setVol(t);
  }
  ws = (t) => this.#i.stt.ws(this.#i, t);
  stopse({ buf: t = dr }) {
    vo(this.#i, t), this.#i.stt.stopse(this.#i);
  }
  fade = (t) => this.#i.stt.fade(this.#i, t);
  wf = (t) => this.#i.stt.wf(this.#i, t);
  stopfadese = (t) => this.#i.stt.stopfadese(this.#i, t);
}
function vo({ loop: r }, t) {
  if (r) {
    Dt.delLoopPlay(t);
    return;
  }
  const e = "const.sn.sound." + t + ".";
  Tt.setVal_Nochk("tmp", e + "playing", !1), Tt.flush();
}
class sy {
  onLoad(t) {
    t.stt = new Pr(t);
  }
  stopse(t) {
    t.stt = new Ei(t, !1);
  }
  ws = () => !1;
  onPlayEnd() {
  }
  // ok
  fade() {
  }
  // ok
  wf = () => !1;
  // ok
  compFade() {
  }
  // ok
  stopfadese() {
  }
  // ok
  isDestroy = !1;
}
class Pr {
  constructor(t) {
    this.si = t;
  }
  onLoad() {
  }
  // ok
  stopse(t) {
    t.stt = new Ei(t);
  }
  ws(t, e) {
    if (t.loop) return !1;
    t.stt = new oy(t);
    const i = $(e, "canskip", !1), n = $(e, "stop", !0);
    if (i && An.isSkipping)
      return n ? t.stt.stopse(t) : t.stt.onPlayEnd = () => {
      }, !1;
    const { buf: s = dr } = e, o = () => {
      vo(t, s), t.onPlayEnd(), n ? t.stt.stopse(t) : t.stt.onPlayEnd = () => {
      };
    };
    return D.beginProc(t.procID + "ws", o, !0, i ? o : void 0), !0;
  }
  onPlayEnd() {
  }
  // ok
  fade(t, e) {
    const { buf: i = dr } = e, s = "const.sn.sound." + i + "." + "volume", o = Dt.getVol(e, NaN);
    Tt.setVal_Nochk("save", s, o);
    const a = o * Number(Tt.getVal("sys:" + s, 1)), h = $(e, "stop", o === 0);
    h && Dt.delLoopPlay(i), Tt.flush();
    const l = L(e, "time", NaN), u = L(e, "delay", 0);
    if (l === 0 && u === 0 || An.isSkipping) {
      t.setVol(a), t.stt = h ? new Ei(t) : new Pr(t);
      return;
    }
    const c = t.tw();
    c && (Ft.setTwProp(c, e).to({ volume: a }, l).onComplete(() => {
      ml(c), t.stt.compFade(i), t.stt = h ? new Ei(t) : new Pr(t);
    }).start(), t.stt = new ay(c, t));
  }
  wf = () => !1;
  // ok
  compFade() {
  }
  // ok
  stopfadese() {
  }
  // ok
  isDestroy = !1;
}
class oy {
  constructor(t) {
    this.si = t;
  }
  onLoad() {
  }
  // ok
  stopse(t) {
    t.stt = new Ei(t);
  }
  ws = () => !1;
  // ok
  onPlayEnd() {
    D.notifyEndProc(this.si.procID + "ws");
  }
  fade() {
  }
  // ok
  wf = () => !1;
  // ok
  compFade() {
  }
  // ok
  stopfadese() {
  }
  // ok
  isDestroy = !1;
}
class ay {
  constructor(t, e) {
    this.tw = t, this.si = e;
  }
  onLoad() {
  }
  // ok
  stopse(t) {
    this.stopfadese(), t.stt = new Ei(t);
  }
  // 順番厳守
  ws = () => !1;
  // ok ?
  onPlayEnd() {
  }
  // ok
  fade() {
  }
  // ok
  wf(t, e) {
    t.stt = new hy(t);
    const i = $(e, "canskip", !1);
    if (i && An.isSkipping)
      return this.stopfadese(), !1;
    const n = () => this.stopfadese();
    return D.beginProc(t.procID + "wf", n, !0, i ? n : void 0), !0;
  }
  compFade() {
  }
  // ok
  stopfadese = () => this.si.stop();
  isDestroy = !1;
}
class hy {
  constructor(t) {
    this.si = t;
  }
  onLoad() {
  }
  // ok
  stopse(t) {
    this.stopfadese(), t.stt = new Ei(t);
  }
  ws = () => !1;
  // ok
  onPlayEnd() {
  }
  // ok
  fade() {
  }
  // ok
  wf = () => !1;
  // ok
  compFade() {
    D.notifyEndProc(this.si.procID + "wf");
  }
  stopfadese = () => this.si.stop();
  isDestroy = !1;
}
class Ei {
  constructor(t, e = !0) {
    this.si = t, this.stop = e, e && (t.stop(), t.loop && (t.destroy(), t.destroy = () => {
    }));
  }
  onLoad() {
  }
  // ok
  stopse() {
  }
  // ok
  ws = () => !1;
  // ok
  onPlayEnd() {
  }
  // ok
  fade() {
  }
  // ok
  wf = () => !1;
  // ok
  compFade() {
  }
  // ok
  stopfadese() {
  }
  // ok
  isDestroy = !0;
}
const Dn = "compChIn";
class ie {
  //MARK: コンストラクタ
  constructor(t, e, i, n, s, o, a) {
    this.cfg = t, this.hTag = e, this.main = i, this.val = n, this.prpPrs = s, this.sndMng = o, this.sys = a, e.let_ml = (l) => this.#j(l), e.endlet_ml = () => !1, e.dump_stack = () => this.#b(), e.dump_script = (l) => this.#M(l), e.else = // その他ifブロック開始
    e.elsif = // 別条件のifブロック開始
    e.endif = () => this.#Q(), e.if = (l) => this.#W(l), e.call = (l) => this.#z(l), e.jump = (l) => this.#F(l), e.pop_stack = (l) => this.#T(l), e.return = (l) => this.#tt(l), e.bracket2macro = (l) => this.#pt(l), e.char2macro = (l) => this.#vt(l), e.endmacro = (l) => this.#tt(l), e.macro = (l) => this.#bt(l), e.load = (l) => this.#xt(l), e.reload_script = (l) => this.#wt(l), e.record_place = () => this.#yt(), e.save = (l) => this.#Tt(l), t.oCfg.debug.token && (this.#B = (l) => {
      l.trim() !== "" && console.log(`🌱 トークン ${this.#t}:${this.#n} (i:${this.#i} cs:${this.#r.length}) %c【${l}】`, "background-color:#350;");
    }), t.oCfg.debug.tag && (this.#G = (l) => console.log(`🌲 タグ解析 ${this.#t}:${this.#n} (i:${this.#i} cs:${this.#r.length}) %c[${l} %o]`, "background-color:#30B;", this.#h.hPrm)), n.defTmp("const.sn.aIfStk.length", () => this.#P.length), n.defTmp("const.sn.vctCallStk.length", () => this.#r.length), this.#a = new Vm(t);
    const h = t.oCfg.init.escape;
    if (this.#a.setEscape(h), xe.setEscape(h), A.isDbg) {
      a.addHook((u, c) => this.#l[u]?.(c)), this.isBreak = this.#o;
      const l = this.analyzeInit;
      this.analyzeInit = () => {
        this.analyzeInit = () => {
        }, this.sys.send2Dbg("hi", {});
      }, this.#l.auth = (u) => {
        const c = u.hBreakpoint.hFn2hLineBP;
        for (const [f, d] of Object.entries(c)) this.#d(f, d);
        ie.#g = {};
        for (const f of u.hBreakpoint.aFunc)
          ie.#g[f.name] = 1;
        if (u.stopOnEntry) {
          for (; ; ) {
            let f = this.nextToken();
            if (!f) break;
            const d = f.charCodeAt(0);
            if (d === 91 || d === 38 || d === 42 && f.length === 1) break;
            d === 10 && (this.#n += f.length);
          }
          this.sys.callHook("stopOnEntry", {}), this.analyzeInit = l, this.analyzeInit();
        } else
          this.noticeWait = () => {
            this.noticeWait = () => {
            }, this.sys.callHook("stopOnEntry", {});
          }, this.analyzeInit = l, this.analyzeInit();
      };
    } else this.recodeDesign = () => {
    };
  }
  #e = { aToken: [""], len: 1, aLNum: [1] };
  #t = "";
  get scriptFn() {
    return this.#t;
  }
  #i = 0;
  get idxToken() {
    return this.#i;
  }
  subIdxToken() {
    --this.#i;
  }
  #n = 0;
  get lineNum() {
    return this.#n;
  }
  addLineNum = (t) => this.#n += t;
  jumpJustBefore() {
    this.#k(this.#t, "", --this.#i);
  }
  // 直前にジャンプ
  #r = [];
  // FILOバッファ（push/pop）
  #a;
  #h = new bl();
  noticeWait = () => {
  };
  #d(t, e) {
    ie.#C[this.#c(t)] = e;
  }
  destroy() {
    this.isBreak = this.#yt = () => !1;
  }
  #l = {
    //auth: // constructorで
    //launch:	// ここでは冒頭停止に間に合わないのでanalyzeInit()で
    disconnect: () => {
      ie.#C = {}, ie.#g = {}, this.isBreak = () => !1, this.#l.continue({}), this.#m = 0;
    },
    restart: () => this.isBreak = () => !1,
    // ブレークポイント登録
    add_break: (t) => this.#d(t.fn, t.o),
    data_break: (t) => {
      this.#m === 0 && (this.#m = 1, this.main.setLoop(!1, `変数 ${t.dataId}【${t.old_v}】→【${t.new_v}】データブレーク`), this.sys.callHook("stopOnDataBreakpoint", {}), this.sys.send2Dbg("stopOnDataBreakpoint", {}));
    },
    set_func_break: (t) => {
      ie.#g = {};
      for (const e of t.a) ie.#g[e.name] = 1;
      this.sys.send2Dbg(t.ri, {});
    },
    // 情報問い合わせ系
    stack: (t) => this.sys.send2Dbg(t.ri, { a: this.#N() }),
    eval: (t) => {
      this.sys.send2Dbg(t.ri, { v: this.prpPrs.parse(t.txt) });
    },
    // デバッガからの操作系
    continue: () => {
      this.#u() || (this.#i -= this.#y, this.#m = 3, this.main.setLoop(!0), this.main.resume());
    },
    stepover: (t) => this.#v(t),
    stepin: () => {
      if (this.#u()) return;
      const t = this.#e.aToken[this.#i - this.#y];
      this.sys.callHook(`stopOnStep${this.#_t.test(t ?? "") ? "In" : ""}`, {}), this.#i -= this.#y, this.#m = this.#m === 1 ? 4 : 5, this.main.setLoop(!0), this.main.resume();
    },
    stepout: (t) => {
      this.#u() || (this.#r.length > 0 ? this.#_(!0) : this.#v(t));
    },
    pause: () => {
      this.#m = 4, this.main.setLoop(!1, "一時停止"), this.sys.send2Dbg("stopOnStep", {});
    },
    stopOnEntry: () => {
      this.#m = 4, this.main.setLoop(!1, "一時停止"), this.sys.send2Dbg("stopOnEntry", {});
    }
  };
  #f = (t) => this.cfg.searchPath(t, qt.SCRIPT);
  static #s = /(.+)\/crypto_prj\/([^\/]+)\/[^\.]+(\.\w+)/;
  // https://regex101.com/r/Km54EK/1 141 steps (~0ms)
  #c = (t) => (this.sys.pathBaseCnvSnPath4Dbg + this.#f(t)).replace(ie.#s, `$1/prj/$2/${this.#t}$3`);
  cnvPath4Dbg = (t) => this.sys.pathBaseCnvSnPath4Dbg + t.replace("/crypto_prj/", "/prj/");
  #v(t) {
    if (this.#u()) return;
    const e = this.#e.aToken[this.#i - this.#y];
    this.#_t.test(e ?? "") ? this.#_(!1) : (this.sys.callHook("stopOnStep", {}), this.#l.stepin(t));
  }
  #_(t) {
    this.sys.callHook(`stopOnStep${t ? "Out" : ""}`, {}), this.#p = this.#r.length - (t ? 1 : 0), this.#i -= this.#y, this.#m = t ? 7 : 6, this.main.setLoop(!0), this.main.resume();
  }
  #p = 0;
  get #y() {
    return this.#m === 2 || this.#m === 4 ? 1 : 0;
  }
  #u() {
    return this.#i < this.#e.len ? !1 : (this.sys.callHook("stopOnEntry", {}), this.main.setLoop(!1, "スクリプト終端です isIdxOverLast"), !0);
  }
  // reload 再生成 Main に受け渡すため static
  static #C = {};
  static #g = {};
  #m = 0;
  // https://raw.githubusercontent.com/famibee/SKYNovel-vscode-extension/master/src/doc/BreakStateSMD.pu
  isBreak = (t) => !1;
  #o(t) {
    switch (this.#m) {
      case 6:
        this.#x(), this.#m = 7;
        break;
      case 7:
        if (this.#r.length !== this.#p) break;
        return this.#m = 4, this.main.setLoop(!1, "ステップ実行"), this.sys.send2Dbg("stopOnStep", {}), !0;
      // タグを実行せず、直前停止
      case 5:
        this.#x(), this.#m = 4;
        break;
      case 4:
        return this.#x(), this.main.setLoop(!1, "ステップ実行"), this.sys.send2Dbg("stopOnStep", {}), !0;
      // タグを実行せず、直前停止
      case 3:
        this.#x(), this.#m = 0;
        break;
      default:
        if (Ss(t) in ie.#g)
          return this.#m = 2, this.main.setLoop(!1, `関数 ${t} ブレーク`), this.sys.callHook("stopOnBreakpoint", {}), this.sys.send2Dbg("stopOnBreakpoint", {}), !0;
        {
          const e = ie.#C[this.#c(this.#t)];
          if (!e) break;
          const i = e[this.#n];
          if (!i) break;
          if (i.condition) {
            if (!this.prpPrs.parse(i.condition)) break;
          } else if ("hitCondition" in i && --i.hitCondition > 0) break;
          const n = this.#m === 0;
          this.#m = 2, this.main.setLoop(!1, n ? (i.condition ? "条件" : "ヒットカウント") + "ブレーク" : "ステップ実行");
          const s = n ? "stopOnBreakpoint" : "stopOnStep";
          this.sys.callHook(s, {}), this.sys.send2Dbg(s, {});
        }
        return !0;
    }
    return !1;
  }
  #x() {
    const t = ie.#C[lr(this.#t)]?.[this.#n];
    t?.hitCondition && --t.hitCondition;
  }
  #N() {
    const t = this.#m === 3 ? 1 : 0, e = this.#e.aToken[this.#i - 1 + t], i = this.#c(this.#t), n = Ss(e), s = n ? `[${n}]` : e, o = this.val.getVal("mp:const.sn.macro") ?? "{}";
    if (this.#i === 0) return [{ fn: i, ln: 1, col: 1, nm: s, ma: o }];
    const a = this.#O(this.#e, this.#i), h = [{ fn: i, ln: a.ln, col: a.col_s + 1, nm: s, ma: o }], l = this.#r.length;
    if (l === 0) return h;
    for (let u = l - 1; u >= 0; --u) {
      const c = this.#r[u], f = this.#U[c.fn];
      if (!f) continue;
      const d = f.aToken[c.idx - 1];
      if (!d) continue;
      const p = this.#O(f, c.idx), v = Ss(d);
      h.push({
        fn: this.#c(c.fn),
        ln: p.ln,
        col: p.col_s + 1,
        nm: v ? `[${v}]` : d,
        ma: c.csArg[":hMp"]["const.sn.macro"] ?? "{}"
      });
    }
    return h;
  }
  // result = true : waitする  resume()で再開
  #G = (t) => {
  };
  //MARK: タグ解析
  async タグ解析(t, e) {
    const i = this.hTag[t];
    if (!i) throw `未定義のタグ【${t}】です`;
    this.#h.parse(e), this.#G(t);
    const n = this.#h.hPrm;
    if (n.cond) {
      const l = n.cond.val;
      if (!l || l.startsWith("&")) throw "属性condは「&」が不要です";
      const u = this.prpPrs.parse(l), c = String(u);
      if (c === "null" || c === "undefined" || !u) return !1;
    }
    let s = {};
    const o = this.#r.length, a = o === 0 ? {} : this.#r[o - 1].csArg;
    if (this.#h.isKomeParam) {
      if (o === 0) throw "属性「*」はマクロのみ有効です";
      s = { ...a };
    }
    s[":タグ名"] = t;
    for (const [l, { val: u, def: c }] of Object.entries(n)) {
      let f = u;
      if (f?.startsWith("%")) {
        if (o === 0) throw "属性「%」はマクロ定義内でのみ使用できます（そのマクロの引数を示す簡略文法であるため）";
        const d = a[f.slice(1)];
        if (d) {
          s[l] = d;
          continue;
        }
        if (c === void 0 || c === "null") continue;
        f = c;
      }
      if (f = this.prpPrs.getValAmpersand(f ?? ""), f !== "undefined") {
        s[l] = f;
        continue;
      }
      c !== void 0 && (f = this.prpPrs.getValAmpersand(c), f !== "undefined" && (s[l] = f));
    }
    if (D.needGoTxt && this.#X.has(t)) {
      const { promise: l, resolve: u } = Promise.withResolvers();
      D.beginProc(Dn, u, !1, u), D.goTxt(), this.val.saveKidoku(), await l;
    }
    this.#H.has(t) && (this.#I.hideHint(), await Ft.closeTrans());
    const h = this.#$[t];
    return h && $(s, "canskip", this.#q[t] ?? !0) && this.#I.isSkipping ? h(n) : i(s);
  }
  // 文字出現演出を待つタグ
  //	ここで列挙せずタグ処理で文字表示を始めたい場合、goTxt()すること
  #X = /* @__PURE__ */ new Set([
    // 変数操作
    // 'clearsysvar',	// システム変数の全消去
    // 'clearvar',		// ゲーム変数の全消去 
    // 'let_abs',		// 絶対値
    // 'let_char_at',	// 文字列から一字取りだし
    // 'let_index_of',	// 文字列で検索
    // 'let_length',	// 文字列の長さ
    // 'let_ml',		// インラインテキスト代入
    // 'let_replace',	// 正規表現で置換
    // 'let_round',		// 四捨五入
    // 'let_search',	// 正規表現で検索
    // 'let_substr',	// 文字列から抜きだし
    // 'let',			// 変数代入・演算
    // レイヤ共通
    // 'add_lay',		// レイヤを追加する
    // 'clear_lay',	// レイヤ設定の消去
    // 'finish_trans',	// トランス強制終了
    // 'lay',	// レイヤ設定
    "trans",
    // ページ裏表を交換
    "wt",
    // トランス終了待ち
    // 'add_filter',	// フィルター追加
    // 'clear_filter',	// フィルター全削除
    // 'enable_filter',// フィルター個別切替
    // トゥイーンアニメ
    // 'pause_tsy',	// 一時停止
    // 'resume_tsy',	// 一時停止再開
    // 'stop_tsy',	// トゥイーン中断
    // 'tsy',		// トゥイーン開始
    "wait_tsy",
    // トゥイーン終了待ち
    // 文字・文字レイヤ
    // 'autowc',	// 文字ごとのウェイト
    // 'ch',		// 文字を追加する
    // 'ch_in_style',	// 文字出現演出定義
    // 'ch_out_style',	// 文字消去演出定義
    // 'clear_text',	// 文字消去
    // 'current',	// デフォルト文字レイヤ設定
    // 'endlet_ml',	// インラインテキスト代入の終端
    // 'endlink',	// ハイパーリンクの終了
    // 'er',		// ページ両面の文字消去
    // 'graph',		// インライン画像表示
    // 'link',		// ハイパーリンク
    // 'r',			// 改行
    // 'rec_ch',	// 履歴書き込み
    // 'rec_r',		// 履歴改行
    // 'reset_rec',	// 履歴リセット
    // 'ruby2',		// 文字列と複数ルビの追加
    // 'set_focus',	// フォーカス移動
    // 'span',		// インラインスタイル設定
    // 'tcy',		// 縦中横を表示する
    // 画像・画像レイヤ
    // 'add_face',	// 差分名称の定義
    "wv",
    // 動画再生終了待ち
    // HTMLフレーム
    // 'add_frame',	// フレーム追加
    // 'frame',	// フレームに設定
    // 'let_frame',	// フレーム変数を取得
    // 'set_frame',	// フレーム変数に設定
    // 'tsy_frame',	// フレームをトゥイーン開始
    // イベント
    // 'clear_event',	// イベントを全消去
    // 'enable_event',	// イベント有無の切替
    // 'event',	// イベントを予約
    "l",
    // 行末クリック待ち
    "p",
    // 改ページクリック待ち
    "s",
    // 停止する
    "wait",
    // ウェイトを入れる
    "waitclick",
    // クリックを待つ
    // ＢＧＭ・効果音
    // 'fadebgm',	// BGMのフェード
    // 'fadeoutbgm',// BGMのフェードアウト
    // 'fadeoutse',	// 効果音のフェードアウト
    // 'fadese',	// 効果音のフェード
    // 'playbgm',	// BGM の演奏
    // 'playse',	// 効果音の再生
    // 'stop_allse',// 全効果音再生の停止
    // 'stopbgm',	// BGM 演奏の停止
    // 'stopfadese',// 音声フェードの停止
    // 'stopse',	// 効果音再生の停止
    // 'volume',	// BGMや効果音の音量を指定
    "wb",
    // BGM フェードの終了待ち
    "wf",
    // 効果音フェードの終了待ち
    "wl",
    // BGM 再生の終了待ち
    "ws",
    // 効果音再生の終了待ち
    // 'xchgbuf',	// サウンドバッファの交換
    // 条件分岐
    // 'else',	// その他ifブロック開始
    // 'elsif',	// 別条件のifブロック開始
    // 'endif',	// ifブロックの終端
    // 'if',	// ifブロックの開始
    // ラベル・ジャンプ
    // 'button',	// ボタンを表示
    // 'call',		// サブルーチンコール
    // 'jump',		// シナリオジャンプ
    // 'page',		// ページ移動
    // 'pop_stack',	// コールスタック破棄
    // 'return',	// サブルーチンから戻る
    // マクロ
    // 'bracket2macro',	// 括弧マクロの定義
    // 'char2macro',	// 一文字マクロの定義
    // 'endmacro',	// マクロ定義の終了
    // 'macro',		// マクロ定義の開始
    // しおり
    // 'copybookmark',	// しおりの複写
    // 'erasebookmark',	// しおりの消去
    // 'load',			// しおりの読込
    // 'record_place',	// セーブポイント指定
    // 'reload_script',	// スクリプト再読込
    // 'save',			// しおりの保存
    // 画面揺らし
    "quake",
    // 画面を揺らす
    // 'stop_quake',// 画面揺らし中断
    "wq"
    // 画面揺らし終了待ち
    // システム
    // 'close',		// アプリの終了
    // 'export',	// プレイデータをエクスポート
    // 'import',	// プレイデータをインポート
    // 'loadplugin',	// プラグインの読み込み
    // 'navigate_to',	// ＵＲＬを開く
    // 'snapshot',		// スナップショット
    // 'title',		// タイトル指定
    // 'toggle_full_screen',	// 全画面状態切替
    // 'update_check',	// 更新チェック機能
    // 'window',	// アプリウインドウ設定
    // デバッグ・その他
    // 'dump_lay',		// レイヤのダンプ
    // 'dump_script',	// 外部へスクリプトを表示
    // 'dump_stack',	// スタックのダンプ
    // 'dump_val',		// 変数のダンプ
    // 'log',		// ログ出力
    // 'trace',		// デバッグ表示へ出力
  ]);
  #H = /* @__PURE__ */ new Set([
    "finish_trans",
    // トランス強制終了
    "trans",
    // ページ裏表を交換
    "quake",
    // 画面を揺らす
    "stop_quake",
    // 画面揺らし中断
    "add_filter"
    // フィルター追加
  ]);
  // キー押しっぱなしスキップで処理せずスルーするタグ
  #$ = {
    wt: () => !1,
    // トランス終了待ち
    wait_tsy: (t) => this.hTag.stop_tsy(t),
    // トゥイーン終了待ち
    // 'wv',		：タグ内部で処理	// 動画再生終了待ち
    wait: () => !1,
    // ウェイトを入れる
    // 'playbgm',	：スルー不可		// BGM の演奏
    // 'playse',	：タグ内部で処理	// 効果音の再生
    wb: () => this.hTag.stopfadese({ buf: mn }),
    // BGM フェードの終了待ち
    wf: (t) => this.hTag.stopfadese(t),
    // 効果音フェードの終了待ち
    // 'ws'		：タグ内部で処理	// 効果音再生の終了待ち
    wq: () => this.hTag.stop_quake({}),
    // 画面揺らし終了待ち
    // fade系	：タグ内部で処理
    // 'ch'		：タグ内部で処理	// 文字を追加する
    // 'tsy'	：タグ内部で処理	// トゥイーン開始
    // 'trans'	：タグ内部で処理	// ページ裏表を交換
    quake: () => !1
    // 画面を揺らす
  };
  // タグ処理中にクリックなどで即終わらせられるタグ（canskip 属性がある）
  #q = {
    // デフォルト値
    wt: !0,
    // [wt]トランス終了待ち
    wait_tsy: !0,
    // [wait_tsy]トゥイーン終了待ち
    wv: !0,
    // [wv]動画再生終了待ち
    wait: !0,
    // [wait]ウェイトを入れる
    playbgm: !1,
    // [playbgm]BGM の演奏
    playse: !0,
    // [playse]効果音の再生
    wb: !1,
    // [wb]BGM フェードの終了待ち
    wf: !1,
    // [wf]効果音フェードの終了待ち
    ws: !1,
    // [ws]効果音再生の終了待ち
    wq: !0
    // [wq]画面揺らし終了待ち
  };
  #I;
  #E;
  setOtherObj(t, e) {
    this.#I = t, this.#E = e;
  }
  //MARK: インラインテキスト代入
  #j(t) {
    const { name: e } = t;
    if (!e) throw "nameは必須です";
    let i = "";
    const n = this.#e.len;
    for (; this.#i < n && (i = this.#e.aToken[this.#i], i === ""); ++this.#i)
      ;
    return t.text = i, t.cast = "str", this.hTag.let(t), this.#i += 2, this.#n += (i.match(/\n/g) ?? []).length, !1;
  }
  //MARK: スタックのダンプ
  #b() {
    if (this.#i === 0)
      return console.group(`🥟 [dump_stack] スクリプト現在地 fn:${this.#t} line:1 col:0`), console.groupEnd(), !1;
    const t = this.#O(this.#e, this.#i), e = `スクリプト現在地 fn:${this.#t} line:${t.ln} col:${t.col_s + 1}`;
    console.group(`🥟 [dump_stack] ${e}`);
    const i = this.#r.length;
    if (i > 0) {
      console.info(e);
      for (let n = i - 1; n >= 0; --n) {
        const s = this.#r[n], o = s.csArg[":hMp"], a = o ? o[":タグ名"] : void 0, h = s.csArg[":タグ名"] ?? "", l = this.#O(this.#U[s.fn], s.idx);
        console.info(
          `${i - n}つ前のコール元 fn:${s.fn} line:${l.ln} col:${l.col_s + 1}` + (a ? "（[" + a + "]マクロ内）" : " ") + `で [${h} ...]をコール`
        );
      }
    }
    return console.groupEnd(), !1;
  }
  #O(t, e) {
    const i = { ln: 1, col_s: 0, col_e: 0 };
    if (!t) return i;
    let n = e - 1;
    const s = i.ln = t.aLNum[n];
    for (; t.aLNum[n] === s; ) {
      if (!t.aToken[n].startsWith(`
`)) {
        const o = t.aToken[n].length;
        i.col_e > 0 && (i.col_s += o), i.col_e += o;
      }
      if (--n < 0) break;
    }
    return i;
  }
  //MARK: 外部へスクリプトを表示
  #M(t) {
    const { set_fnc: e, break_fnc: i } = t;
    if (!e) throw "set_fncは必須です";
    if (this.#S = globalThis[e], !this.#S) {
      if ($(t, "need_err", !0)) throw `HTML内に関数${e}が見つかりません`;
      return this.#S = () => {
      }, !1;
    }
    if (this.noticeBreak = (n) => {
      this.#A !== this.#t && (this.#A = this.#t, this.#S(
        this.#it[this.#t] ??= this.#e.aToken.join("")
      )), this.#w(this.#n, n);
    }, this.noticeBreak(!0), !i) return !1;
    if (this.#w = globalThis[i], !this.#w) {
      if ($(t, "need_err", !0)) throw `HTML内に関数${i}が見つかりません`;
      this.#w = () => {
      };
    }
    return !1;
  }
  #S = () => {
  };
  #w = () => {
  };
  #A = "";
  #it = {};
  noticeBreak = (t) => {
  };
  #D = 5;
  dumpErrForeLine() {
    if (this.#i === 0) {
      console.group(`🥟 Error line (from 0 rows before) fn:${this.#t}`), console.groupEnd();
      return;
    }
    let t = "";
    for (let o = this.#i - 1; o >= 0 && (t = this.#e.aToken[o] + t, !((t.match(/\n/g) ?? []).length >= this.#D)); --o)
      ;
    const e = t.split(`
`).slice(-this.#D), i = e.length;
    console.group(`🥟 Error line (from ${i} rows before) fn:${this.#t}`);
    const n = String(this.#n).length, s = this.#O(this.#e, this.#i);
    for (let o = 0; o < i; ++o) {
      const a = this.#n - i + o + 1, h = `${String(a).padStart(n, " ")}: %c`, l = e[o], u = l.length > 75 ? l.slice(0, 75) + "…" : l;
      o === i - 1 ? console.info(
        h + u.slice(0, s.col_s) + "%c" + u.slice(s.col_s),
        "color: black; background-color: skyblue;",
        "color: black; background-color: pink;"
      ) : console.info(h + u, "color: black; background-color: skyblue;");
    }
    console.groupEnd();
  }
  #P = [-1];
  // 先頭に積む FIFOバッファ（unshift / shift）
  //MARK: ifブロックの終端
  #Q() {
    const t = this.#P[0];
    if (!t) throw "this.#aIfStk が異常です";
    if (t === -1) throw "ifブロック内ではありません";
    return this.#i = t, this.#P.shift(), !1;
  }
  //MARK: ifブロックの開始
  #W(t) {
    const { exp: e } = t;
    if (!e) throw "expは必須です";
    if (e.startsWith("&")) throw "属性expは「&」が不要です";
    let i = 0, n = this.prpPrs.parse(e) ? this.#i : -1;
    const s = this.#e.aLNum[this.#i];
    let o = this.#n - (s || 0);
    const a = this.#e.len;
    for (; this.#i < a; ++this.#i) {
      const h = this.#e.aLNum[this.#i];
      this.#e.aLNum[this.#i] = (h || 0) + o;
      const l = this.#e.aToken[this.#i];
      if (!l) continue;
      const u = l.charCodeAt(0);
      if (u === 10) {
        this.#n += l.length;
        continue;
      }
      if (u !== 91) continue;
      const [c, f] = Nn(l);
      if (!(c in this.hTag)) throw `未定義のタグ[${c}]です`;
      switch (this.#h.parse(f), c) {
        case "if":
          ++i;
          break;
        case "elsif":
          if (i > 0 || n > -1) break;
          const d = this.#h.hPrm.exp?.val;
          if (!d) throw "expは必須です";
          if (d.startsWith("&")) throw "属性expは「&」が不要です";
          this.prpPrs.parse(d) && (n = this.#i + 1);
          break;
        case "else":
          if (i > 0) break;
          n === -1 && (n = this.#i + 1);
          break;
        case "endif":
          if (i > 0) {
            --i;
            break;
          }
          return n === -1 ? (++this.#i, this.#e.aLNum[this.#i] += o) : (this.#P.unshift(this.#i + 1), this.#i = n, this.#n = this.#e.aLNum[this.#i]), !1;
      }
    }
    throw "[endif]がないままスクリプト終端です";
  }
  //MARK: サブルーチンコール
  #z(t) {
    $(t, "count", !1) || this.#ot();
    const { fn: e } = t;
    return e && this.#f(e), this.#L({ ...t, ":hEvt1Time": j.popLocalEvts() }), $(t, "clear_local_event", !1) && this.hTag.clear_event({}), this.#k(e, t.label);
  }
  #L(t) {
    const e = { ...t, ":hMp": this.val.cloneMp(), ":lenIfStk": this.#P.length };
    this.#e.aLNum[this.#i] = this.#n, this.#Z || (e[":resvToken"] = "", this.#K()), this.#r.push(new ih(this.#t, this.#i, e)), this.#P.unshift(-1);
  }
  //MARK: シナリオジャンプ
  #F(t) {
    return $(t, "count", !0) || this.#ot(), this.#P[0] = -1, this.#k(t.fn, t.label);
  }
  //MARK: コールスタック破棄
  #T(t) {
    if ($(t, "clear", !1)) this.#r = [];
    else if (!this.#r.pop()) throw "スタックが空です";
    return this.#K(), this.#P = [-1], this.val.setMp({}), !1;
  }
  //MARK: サブルーチンから戻る
  #tt(t) {
    const e = this.#r.pop();
    if (!e) throw "スタックが空です";
    const i = e.csArg;
    this.#P = this.#P.slice(-i[":lenIfStk"]);
    const n = i[":hMp"];
    n && this.val.setMp(n);
    const s = i[":resvToken"];
    s ? this.nextToken = () => (this.#K(), s) : this.#K(), i[":hEvt1Time"] && j.pushLocalEvts(i[":hEvt1Time"]);
    const { fn: o, label: a } = t;
    return o || a ? this.#k(o, a) : e.fn in this.#U ? (this.#nt(e), !1) : this.#k(e.fn, "", e.idx);
  }
  #Z = "";
  #K() {
    this.#Z = "", this.nextToken = this.#V;
  }
  #R = "";
  #k(t = "", e = "", i = 0) {
    if (A.debugLog && console.log(`📜 %c1:jumpWork%c fn:${t} lbl:${e} idx:${i}`, "color:#3B0;", ""), !t && !e && this.main.errScript("[jump系] fnまたはlabelは必須です"), e ? (e.startsWith("*") || this.main.errScript("[jump系] labelは*で始まります"), this.#R = e, this.#R.startsWith("**") || (this.#i = i)) : (this.#R = "", this.#i = i), !t)
      return this.analyzeInit(), !1;
    if (t.includes("@")) throw "[jump系] fn には文字「@」は禁止です";
    const n = this.#f(t);
    if (t === this.#t)
      return this.analyzeInit(), !1;
    this.#t = t;
    const s = this.#U[t];
    if (s)
      return this.#e = s, this.analyzeInit(), !1;
    const o = `jumpWork fn:${t}`;
    D.beginProc(o);
    let a = "";
    const h = new ue();
    try {
      a = this.#f(t + "@"), h.add({ name: t + ":base", url: n }), h.add({ name: t, url: a });
    } catch {
      h.add({ name: t, url: n });
    }
    return h.use(async (l, u) => {
      try {
        l.data = await this.sys.dec(l.extension, l.data);
      } catch (c) {
        this.main.errScript(`[jump系]snロード失敗です fn:${l.name} ${c}`, !1);
      }
      u();
    }).load((l, u) => {
      if (D.endProc(o), a) {
        const c = u[t + ":base"].data, f = u[t].data, d = c.split(`
`), p = f.split(`
`), v = d.length, _ = p.length;
        for (let m = 0; m < _ && m < v; ++m) p[m] ||= d[m];
        u[t].data = p.join(`
`), delete u[t + ":base"];
      }
      this.nextToken = this.#V, this.#n = 1, this.#ut(u[t].data), this.hTag.record_place({}), this.analyzeInit();
    }), !0;
  }
  analyzeInit() {
    A.debugLog && console.log(`📜 %c9:analyzeInit%c fn:${this.#t} lbl:${this.#R} idx:${this.#i}`, "color:#3B0;", "");
    const t = this.#lt(this.#e, !!this.val.getVal("mp:const.sn.macro.name"), this.#n, this.#R, this.#i);
    this.#i = t.idx, this.#n = t.ln;
  }
  // シナリオ解析処理ループ・冒頭処理
  nextToken = () => "";
  // 初期化前に終了した場合向け
  #V() {
    if (this.#Y()) return "";
    this.#dt(), this.#e.aLNum[this.#i] ||= this.#n;
    const t = this.#e.aToken[this.#i];
    return this.#B(t), ++this.#i, t;
  }
  #B = (t) => {
  };
  #Y() {
    return this.#i < this.#e.len ? !1 : (this.main.errScript("スクリプト終端です errOverScr"), !0);
  }
  #at = /(\*{2,})([^\|]*)/;
  #ht = /^\[macro\s/;
  #rt = /^\[endmacro[\s\]]/;
  #lt(t, e, i, n, s) {
    const o = t.aToken.length;
    if (!n) {
      if (this.#Y()) return { idx: s, ln: i };
      if (t.aLNum[s])
        i = t.aLNum[s];
      else {
        i = 1;
        for (let u = 0; u < s; ++u) {
          t.aLNum[u] ||= i;
          const c = t.aToken[u];
          c.startsWith(`
`) ? i += c.length : i += (c.match(/\n/g) ?? []).length;
        }
        t.aLNum[s] = i;
      }
      return { idx: s, ln: i };
    }
    t.aLNum[0] = 1;
    const a = n.match(this.#at);
    if (a) {
      n = a[1];
      let u = s;
      switch (a[2]) {
        case "before":
          for (; t.aToken[--u] !== n; )
            u === 0 && rt.myTrace("[jump系 無名ラベルbefore] " + i + "行目以前で" + (e ? "マクロ内に" : "") + "ラベル【" + n + "】がありません", "ET"), e && t.aToken[u].search(this.#ht) > -1 && rt.myTrace("[jump系 無名ラベルbefore] マクロ内にラベル【" + n + "】がありません", "ET");
          return { idx: u + 1, ln: t.aLNum[u] };
        //	break;
        case "after":
          for (; t.aToken[++u] !== n; )
            u === o && rt.myTrace("[jump系 無名ラベルafter] " + i + "行目以後でマクロ内にラベル【" + n + "】がありません", "ET"), t.aToken[u].search(this.#rt) > -1 && rt.myTrace("[jump系 無名ラベルafter] " + i + "行目以後でマクロ内にラベル【" + n + "】がありません", "ET");
          return { idx: u + 1, ln: t.aLNum[u] };
        //	break;
        default:
          rt.myTrace("[jump系] 無名ラベル指定【label=" + n + "】が間違っています", "ET");
      }
    }
    i = 1;
    const h = new RegExp(
      "^" + n.replaceAll("*", "\\*") + "(?=\\s|;|\\[|\\||$)"
    );
    let l = !1;
    for (let u = 0; u < o; ++u) {
      t.aLNum[u] ||= i;
      const c = t.aToken[u];
      if (l) {
        this.#a.testTagEndLetml(c) ? l = !1 : i += (c.match(/\n/g) ?? []).length;
        continue;
      }
      const f = c.charCodeAt(0);
      if (f === 10) {
        i += c.length;
        continue;
      }
      if (f === 42) {
        if (c.search(h) > -1) return { idx: u + 1, ln: i };
        continue;
      }
      f === 91 && (i += (c.match(/\n/g) ?? []).length, this.#a.testTagLetml(c) && (l = !0));
    }
    throw l ? "[let_ml]の終端・[endlet_ml]がありません" : (rt.myTrace(`[jump系] ラベル【${n}】がありません`, "ET"), "Dummy");
  }
  #U = /* @__PURE__ */ Object.create(null);
  //{} シナリオキャッシュ
  #ut(t) {
    let e = "";
    try {
      e = "ScriptIterator.resolveScript";
      const i = this.#a.resolveScript(t);
      e = "ScriptIterator.replaceScript_Wildcard", this.#ft(i), this.#U[this.#t] = this.#e = i;
    } catch (i) {
      i instanceof Error ? e += `例外 mes=${i.message}(${i.name})` : e = String(i), this.main.errScript(e, !1);
    }
    this.val.touchAreaKidoku(this.#t);
  }
  #nt(t) {
    this.#t = t.fn, this.#i = t.idx;
    const e = this.#U[this.#t];
    e && (this.#e = e), this.#n = this.#e.aLNum[t.idx];
  }
  #st = /^\[(call|loadplugin)\s/;
  #ct = /\bfn\s*=\s*[^\s\]]+/;
  #ft(t) {
    for (let e = t.len - 1; e >= 0; --e) {
      const i = t.aToken[e];
      if (!this.#st.test(i)) continue;
      const [n, s] = Nn(i);
      this.#h.parse(s);
      const o = this.#h.hPrm.fn;
      if (!o) continue;
      const { val: a } = o;
      if (!a || !a.endsWith("*")) continue;
      t.aToken.splice(e, 1, "	", "; " + i), t.aLNum.splice(e, 1, NaN, NaN);
      const h = n === "loadplugin" ? qt.CSS : qt.SN, l = this.cfg.matchPath("^" + a.slice(0, -1) + ".*", h);
      for (const u of l) {
        const c = i.replace(
          this.#ct,
          "fn=" + decodeURIComponent(lr(u[h]))
        );
        t.aToken.splice(e, 0, c), t.aLNum.splice(e, 0, NaN);
      }
    }
    t.len = t.aToken.length;
  }
  #dt() {
    const t = this.val.touchAreaKidoku(this.#t);
    if (this.#r.length > 0) {
      t.record(this.#i);
      return;
    }
    this.#J = t.search(this.#i), this.val.setVal_Nochk("tmp", "const.sn.isKidoku", this.#J), !this.#J && t.record(this.#i);
  }
  #J = !1;
  get isKidoku() {
    return this.#J;
  }
  #ot() {
    this.val.getAreaKidoku(this.#t)?.erase(this.#i), this.#J = !1;
  }
  get isNextKidoku() {
    let t = this.#t, e = this.#i, i = this.#e.len;
    if (this.#r.length > 0) {
      const s = this.#r[0];
      t = s.fn, e = s.idx;
      const o = this.#U[t];
      o && (i = o.len);
    }
    const n = this.val.getAreaKidoku(t);
    return e === i ? !1 : n.search(e);
  }
  get normalWait() {
    return this.#J ? this.val.tagCh_doWait_Kidoku ? this.val.tagCh_msecWait_Kidoku : 0 : this.val.tagCh_doWait ? this.val.tagCh_msecWait : 0;
  }
  //MARK: 括弧マクロの定義
  #pt(t) {
    return this.#a.bracket2macro(t, this.hTag, this.#e, this.#i), !1;
  }
  //MARK: 一文字マクロの定義
  #vt(t) {
    return this.#a.char2macro(t, this.hTag, this.#e, this.#i), !1;
  }
  //MARK: マクロ定義の開始
  #gt = /["'#;\\]　]+/;
  #bt(t) {
    const { name: e } = t;
    if (!e) throw "nameは必須です";
    if (e in this.hTag) throw `[${e}]はタグかすでに定義済みのマクロです`;
    if (this.#gt.test(e)) throw `[${e}]はマクロ名として異常です`;
    const i = this.#n, n = new ih(this.#t, this.#i);
    for (this.#mt += "|" + e, this.#_t = new RegExp(`\\[(${this.#mt})\\b`), this.hTag[e] = (s) => (s.design_unit = t.design_unit, this.#L(s), this.val.setMp(s), this.val.setVal_Nochk("mp", "const.sn.macro", JSON.stringify({
      name: t.name
    })), this.val.setVal_Nochk("mp", "const.sn.me_call_scriptFn", this.#t), this.#n = i, this.#nt(n), !1); this.#i < this.#e.len; ++this.#i) {
      this.#e.aLNum[this.#i] ||= this.#n;
      const s = this.#e.aToken[this.#i];
      if (s.search(this.#rt) > -1)
        return ++this.#i, !1;
      const o = s.charCodeAt(0);
      o === 10 ? this.#n += s.length : o === 91 && (this.#n += (s.match(/\n/g) ?? []).length);
    }
    throw `マクロ[${e}]定義の終端・[endmacro]がありません`;
  }
  #mt = "call";
  #_t = /\[(call)\b/;
  // https://regex101.com/r/Lk9ASK/1
  //MARK: しおりの読込
  #xt(t) {
    if ("fn" in t != "label" in t) throw "fnとlabelはセットで指定して下さい";
    const e = L(t, "place", 0), i = this.val.getMark(e);
    return this.loadFromMark(
      t,
      i,
      2
      /* ALL_STOP_AND_PLAY */
    );
  }
  loadFromMark(t, e, i = 0) {
    this.hTag.clear_event({}), this.val.mark2save(e), this.val.setMp({}), this.#E.recPagebreak();
    let n = [];
    i !== 1 && (n = this.sndMng.playLoopFromSaveObj(
      i === 2
      /* ALL_STOP_AND_PLAY */
    )), $(t, "do_rec", !0) && (this.#et = {
      hSave: this.val.cloneSave(),
      hPages: { ...e.hPages },
      aIfStk: [...e.aIfStk]
    });
    const s = {
      enabled: this.val.getVal("save:const.sn.autowc.enabled"),
      text: this.val.getVal("save:const.sn.autowc.text"),
      time: Number(this.val.getVal("save:const.sn.autowc.time"))
    };
    this.hTag.autowc(s), this.#P = [...this.#et.aIfStk], this.#r = [], Ft.stopAllTw();
    const o = Promise.allSettled([...n, ...this.#E.playback(this.#et.hPages)]).then(() => this.#E.cover(!1)).catch((f) => console.error("loadFromMark e:%o", f)), { index: a, fn: h } = t;
    if (a)
      return A.debugLog && console.log(`📜 %cloadFromMark index:${a} move!%c fn:${h}`, "color:#3B0;", ""), o.then(() => {
        this.#k(h, "", a) || this.main.resume();
      }), !0;
    this.#E.cover(!0);
    const l = String(this.val.getVal("save:const.sn.scriptFn")), u = Number(this.val.getVal("save:const.sn.scriptIdx"));
    delete this.#U[l];
    const { label: c } = t;
    return c ? o.then(() => {
      this.#t = l, this.#i = u, this.hTag.call({ fn: h, label: c }) || this.main.resume();
    }) : o.then(() => {
      this.#k(l, "", u) || this.main.resume();
    }), !0;
  }
  //MARK: スクリプト再読込
  #wt(t) {
    const e = this.val.getMark(0);
    delete this.#U[lr(e.hSave["const.sn.scriptFn"])];
    const i = {};
    for (const n in this.#U)
      try {
        this.#f(n + "@");
      } catch {
        i[n] = this.#U[n];
      }
    return this.#U = i, t.do_rec = !1, this.loadFromMark(
      t,
      e,
      1
      /* NO_TOUCH */
    );
  }
  //MARK: セーブポイント指定
  #et = {
    hSave: {},
    hPages: {},
    aIfStk: [-1]
  };
  #yt = () => {
    const { fn: t, idx: e } = this.nowScrIdx();
    return this.val.setVal_Nochk("save", "const.sn.scriptFn", t), this.val.setVal_Nochk("save", "const.sn.scriptIdx", e), this.#et = {
      hSave: this.val.cloneSave(),
      hPages: this.#E.record(),
      aIfStk: this.#P.slice(this.#r.length)
    }, !1;
  };
  nowScrIdx() {
    if (this.#r.length === 0) return {
      fn: this.#t,
      idx: this.#i
    };
    const e = this.#r[0];
    return {
      fn: e.fn,
      idx: e.idx
    };
  }
  nowMark() {
    return { ...this.#et };
  }
  //MARK: スクリプト停止位置（マクロなどなら最上位の呼び元）
  nowScrFnLn() {
    const { fn: t, idx: e } = this.nowScrIdx(), i = this.#U[t], n = this.#O(i, e);
    return { fn: t, ...n };
  }
  //MARK: しおりの保存
  #Tt(t) {
    if (!("place" in t)) throw "placeは必須です";
    const e = Number(t.place);
    delete t[":タグ名"], delete t.place, t.text = t.text ?? "", this.#et.json = t, this.val.setMark(e, this.#et);
    const i = Number(this.val.getVal("sys:const.sn.save.place"));
    return e === i && this.val.setVal_Nochk("sys", "const.sn.save.place", i + 1), !1;
  }
  recodeDesign(t) {
    let e = "", i = 0;
    const n = this.#r.length;
    if (t.design_unit && n > 0) {
      const h = this.#r[0];
      e = h.fn, i = h.idx;
    } else
      e = this.#t, i = this.#i;
    t[":path"] = this.#c(e);
    const s = this.#U[e], o = this.#O(s, i);
    t[":ln"] = o.ln, t[":col_s"] = o.col_s, t[":col_e"] = o.col_e;
    const a = i - 1;
    t[":idx_tkn"] = a, t[":token"] = s.aToken[a], this.sys.send2Dbg("_recodeDesign", t);
  }
  replace(t, e) {
    this.#e.aToken[t] = e;
  }
}
const ly = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RPN_COMP_CHIN: Dn,
  ScriptIterator: ie
}, Symbol.toStringTag, { value: "Module" }));
class at extends Ct {
  constructor(t, e, i) {
    super(), this.ctn = t, this.canFocus = e, this.sys = i, this.#r.classList.add("sn_tx"), this.#r.style.position = "absolute", at.#t.view.parentElement.appendChild(this.#r), this.addChild(this.#a), this.addChild(this.#h), this.#h.name = "grpDbgMasume";
    const n = A.debugLog ? ({ ch: s, rect: { x: o, y: a, width: h, height: l } }) => console.log(`🍌 masume ch:${s} x:${o} y:${a} w:${h} h:${l}`) : () => {
    };
    this.#f = at.#e.oCfg.debug.masume ? (s) => {
      n(s);
      const { x: o, y: a, width: h, height: l } = s.rect;
      this.#h.beginFill(6737151, 0.5).lineStyle(2, 16724736, 1).drawRect(o, a, h, l).endFill();
    } : () => {
    }, this.noticeCompTxt = i.isApp && at.#e.oCfg.debug.dumpHtm ? () => {
      D.notifyEndProc(Dn);
      const s = this.#r.innerHTML;
      if (s === "") return;
      const { fn: o, ln: a } = at.#n.nowScrFnLn(), h = `dumpHtm ${t.name.slice(0, -7).replaceAll(":", "=")}(fn=${o} line=${a})`;
      i.outputFile(
        i.path_downloads + h + ".htm",
        `<!doctype html><html><head><meta charset=utf-8><title>${h}</title>
<h1>${h}</h1>${s.replaceAll(/ class="sn_ch"|animation-delay: \d+ms; ?| data-add="{&quot;ch_in_style&quot;:&quot;default&quot;, &quot;ch_out_style&quot;:&quot;default&quot;}"/g, "").replaceAll(' style=""', "").replaceAll(/(<\/?ruby>)/g, `
$1
`).replaceAll(/<(br|\/span)>/g, `<$1>
`)}`
      );
    } : () => D.notifyEndProc(Dn);
  }
  static #e;
  static #t;
  static init(t, e) {
    at.#e = t, at.#t = e;
  }
  static #i;
  static #n;
  static setEvtMng(t, e) {
    at.#i = t, at.#n = e;
  }
  static destroy() {
    at.#$ = /* @__PURE__ */ Object.create(null), at.#I = /* @__PURE__ */ Object.create(null), at.delBreak();
  }
  #r = document.createElement("span");
  // サンプリング元
  #a = new Ct();
  // サンプリング先
  #h = new se();
  static #d = {
    "background-color": 0,
    "border-bottom-width": 0,
    "border-left-width": 0,
    "border-right-width": 0,
    "border-top-width": 0,
    "margin-bottom": 0,
    "margin-left": 0,
    "margin-right": 0,
    "margin-top": 0
  };
  #l = new zm();
  noticeCompTxt = () => {
  };
  #f;
  //	readonly	#idc	:TxtLayDesignCast;
  //	readonly	#idcCh	= new TxtLayPadDesignCast(this);
  #s = {
    fontsize: 24,
    $width: 0,
    // レイヤサイズであり、背景色（画像）サイズ
    $height: 0,
    pad_left: 0,
    // paddingLeft（レイヤサイズの内側のスペーサー）
    pad_right: 0,
    // paddingRight
    pad_top: 0,
    // paddingTop
    pad_bottom: 0
    // paddingBottom
  };
  lay(t) {
    const e = this.#r.style;
    if ("style" in t)
      if (t.style) {
        const i = document.createElement("span");
        i.style.cssText = t.style;
        const n = i.style.length;
        for (let s = 0; s < n; ++s) {
          const o = i.style[s];
          if (o in at.#d) {
            rt.myTrace(`${o}は指定できません`, "W");
            continue;
          }
          e[o] = i.style[o];
        }
        !i.style.opacity && "alpha" in t && (e.opacity = String(this.ctn.alpha));
      } else this.#r.style.cssText = "";
    else "alpha" in t && (e.opacity = String(this.ctn.alpha));
    if ("width" in t && (e.width = (t.width ?? "0") + "px"), "height" in t && (e.height = (t.height ?? "0") + "px"), "pl" in t && (e.paddingLeft = (t.pl ?? "0") + "px"), "pr" in t && (e.paddingRight = (t.pr ?? "0") + "px"), "pt" in t && (e.paddingTop = (t.pt ?? "0") + "px"), "pb" in t && (e.paddingBottom = (t.pb ?? "0") + "px"), this.#l.lay(t), this.#v(), this.#_ = this.ctn.position.x, e.transformOrigin = `${this.ctn.pivot.x}px ${this.ctn.pivot.y}px`, this.cvsResize(), e.display = this.ctn.visible ? "inline" : "none", ":redraw" in t && this.#o > 0) {
      const i = [
        this.#r.innerHTML.replaceAll(/(animation-delay: )\d+ms/g, "$10ms"),
        `<span class='sn_ch' data-add='{"ch_in_style":"default"}'>&emsp;</span>`
      ];
      this.#M(), this.goTxt(i, !0);
    }
  }
  #c = 0;
  // 「g」などで下が欠ける問題対策
  #v() {
    const t = this.#r.style, e = parseFloat(t.fontSize || "0");
    this.#s.fontsize = e, this.#s.pad_left = parseFloat(t.paddingLeft || "0"), this.#s.pad_right = parseFloat(t.paddingRight || "0"), this.#s.pad_top = parseFloat(t.paddingTop || "0"), this.#s.pad_bottom = parseFloat(t.paddingBottom || "0"), this.#s.$width = parseFloat(t.width || "0"), this.#s.$height = parseFloat(t.height || "0"), this.position.set(this.#s.pad_left, this.#s.pad_top), this.#p = t.writingMode === "vertical-rl", this.#y = 0, this.#u = 0;
    const i = t.lineHeight ?? "0";
    this.#c = this.#p ? 0 : (i.endsWith("px") ? parseFloat(i) : e * parseFloat(i) - e) / 2;
  }
  cvsResize() {
    const t = this.#r.style, e = this.sys.cvsScale;
    t.left = `${this.sys.ofsLeft4elm + this.#_ * e}px`, t.top = `${this.sys.ofsTop4elm + this.ctn.position.y * e}px`, t.transform = `rotate(${this.ctn.angle}deg) scale(${this.ctn.scale.x * e}, ${this.ctn.scale.y * e})`;
  }
  #_ = 0;
  #p = !1;
  get tategaki() {
    return this.#p;
  }
  #y = 0;
  #u = 0;
  get infTL() {
    return this.#s;
  }
  get getWidth() {
    return this.#s.$width;
  }
  get getHeight() {
    return this.#s.$height;
  }
  setMySize(t, e) {
    this.#s.$width = t, this.#s.$height = e, this.#r.style.width = this.#s.$width + "px", this.#r.style.height = this.#s.$height + "px";
  }
  #C(t, e = !0) {
    const i = {
      escape: (v) => v.replaceAll(/([.*+?^${}()|\[\]\/\\])/g, "\\$1"),
      mimeType: (v) => {
        const _ = h(v).toLowerCase();
        return n()[_] || "";
      },
      dataAsUrl: f,
      isDataUrl: l,
      resolveUrl: u,
      getAndEncode: c,
      asArray: (v) => {
        const _ = [], m = v.length;
        for (let y = 0; y < m; ++y) _.push(v[y]);
        return _;
      }
    };
    function n() {
      const v = "application/font-woff", _ = "image/jpeg";
      return {
        woff: v,
        woff2: v,
        ttf: "application/font-truetype",
        eot: "application/vnd.ms-fontobject",
        png: "image/png",
        jpg: _,
        jpeg: _,
        gif: "image/gif",
        tiff: "image/tiff",
        svg: "image/svg+xml"
      };
    }
    const s = d(), o = p();
    function a(v) {
      return o.resolveAll().then((_) => {
        const m = document.createElement("style");
        return v.appendChild(m), m.appendChild(document.createTextNode(_)), v;
      });
    }
    function h(v) {
      return /\.([^\.\/]*?)$/g.exec(v)?.[1] ?? "";
    }
    function l(v) {
      return v.search(/^(data:)/) !== -1;
    }
    function u(v, _) {
      const m = document.implementation.createHTMLDocument(), y = m.createElement("base");
      m.head.appendChild(y);
      const b = m.createElement("a");
      return m.body.appendChild(b), y.href = _, b.href = v, b.href;
    }
    function c(v) {
      let _ = 3e4;
      return new Promise(function(m) {
        const y = new XMLHttpRequest();
        y.onreadystatechange = b, y.ontimeout = P, y.responseType = "blob", y.timeout = _, y.open("GET", v, !0), y.send();
        function b() {
          if (y.readyState !== 4) return;
          if (y.status !== 200) {
            x("cannot fetch resource: " + v + ", status: " + y.status);
            return;
          }
          const T = new FileReader();
          T.onloadend = function() {
            const I = T.result.toString().split(/,/)[1];
            m(I);
          }, T.readAsDataURL(y.response);
        }
        function P() {
          x("timeout of " + _ + "ms occured while fetching resource: " + v);
        }
        function x(T) {
          console.error(T), m("");
        }
      });
    }
    function f(v, _) {
      return "data:" + _ + ";base64," + v;
    }
    function d() {
      const v = /url\(['"]?([^'"]+?)['"]?\)/g;
      return {
        inlineAll: b,
        shouldProcess: _
      };
      function _(P) {
        return P.search(v) !== -1;
      }
      function m(P) {
        const x = [];
        let T;
        for (; T = v.exec(P); )
          x.push(T[1]);
        return x.filter(function(I) {
          return !i.isDataUrl(I);
        });
      }
      function y(P, x, T, I) {
        return Promise.resolve(x).then((O) => T ? i.resolveUrl(O, T) : O).then(I || i.getAndEncode).then((O) => i.dataAsUrl(O, i.mimeType(x))).then((O) => P.replace(w(x), "$1" + O + "$3"));
        function w(O) {
          return new RegExp(`(url\\(['"]?)(` + i.escape(O) + `)(['"]?\\))`, "g");
        }
      }
      function b(P, x, T) {
        if (I()) return Promise.resolve(P);
        return Promise.resolve(P).then(m).then((w) => {
          let O = Promise.resolve(P);
          for (const R of w) O = O.then((U) => y(U, R, x, T));
          return O;
        });
        function I() {
          return !_(P);
        }
      }
    }
    function p() {
      return {
        resolveAll: v,
        impl: { readAll: _ }
      };
      function v() {
        return _().then((m) => Promise.allSettled(
          m.map((y) => y.resolve())
        )).then((m) => m.join(`
`));
      }
      function _() {
        return Promise.resolve(i.asArray(document.styleSheets)).then(y).then(m).then((P) => P.map(b));
        function m(P) {
          return P.filter((x) => x.type === CSSRule.FONT_FACE_RULE).filter((x) => s.shouldProcess(x.style.getPropertyValue("src")));
        }
        function y(P) {
          const x = [];
          for (const T of P)
            try {
              if (T.href) continue;
              i.asArray(T.cssRules || []).forEach(x.push.bind(x));
            } catch (I) {
              console.error("Error while reading CSS rules from " + T.href, String(I));
            }
          return x;
        }
        function b(P) {
          return {
            resolve: function() {
              const T = (P.parentStyleSheet || {}).href;
              return s.inlineAll(P.cssText, T);
            },
            src: function() {
              return P.style.getPropertyValue("src");
            }
          };
        }
      }
    }
    Promise.resolve(this.#r).then((v) => {
      const _ = v.cloneNode(!0);
      return _.style.padding = "0px", _.style.paddingRight = this.#y + "px", _.style.paddingTop = this.#u + "px", _.style.left = "0px", _.style.top = "0px", _.style.width = this.#s.$width - this.#s.pad_left - this.#s.pad_right + "px", _.style.height = this.#s.$height - this.#s.pad_top - this.#s.pad_bottom + "px", this.#r.hidden = e, _;
    }).then(a).then((v) => {
      v.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
      const _ = new Image();
      return _.src = `data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="${this.#s.$width}px" height="${this.#s.$height}px"><foreignObject x="0" y="0" width="100%" height="100%">${new XMLSerializer().serializeToString(v).replaceAll("#", "%23").replaceAll(`
`, "%0A")}</foreignObject></svg>`, new Promise((m) => _.onload = () => m(_));
    }).then((v) => new Promise((_) => setTimeout(() => _(v), 100))).then((v) => {
      const _ = document.createElement("canvas");
      _.width = this.#s.$width, _.height = this.#s.$height, _.getContext("2d").drawImage(v, 0, 0), t(ot.from(_));
    }).catch((v) => rt.myTrace(`goTxt() = ${v}`));
  }
  #g = [];
  // FIFO実行バッファ
  goTxt(t, e) {
    const i = () => this.#N(t, e);
    this.#g.push(i) === 1 && i();
  }
  #m = [];
  #o = 0;
  static #x = "<span class='sn_ch sn_ch_last'>&emsp;</span>";
  #N(t, e) {
    at.#E.visible = !1;
    let i = this.#m.length, n = "";
    if (i === 0) {
      if (at.#e.oCfg.debug.masume && (A.debugLog && console.log(`🍌 masume ${this.name} v:${this.visible} l:${this.x} t:${this.y} a:${this.alpha} pl:${this.#s.pad_left} pr:${this.#s.pad_right} pt:${this.#s.pad_top} pb:${this.#s.pad_bottom} w:${this.#s.$width} h:${this.#s.$height}`), this.#h.clear().beginFill(3407616, 0.2).lineStyle(1, 3407616, 1).drawRect(-this.#s.pad_left, -this.#s.pad_top, this.#s.$width, this.#s.$height).endFill().beginFill(13311, 0.2).lineStyle(2, 13311, 1).drawRect(
        0,
        0,
        this.#s.$width - this.#s.pad_left - this.#s.pad_right,
        this.#s.$height - this.#s.pad_top - this.#s.pad_bottom
      ).endFill()), this.#r.innerHTML = [...t].join("").replaceAll(/[\n\t]/g, "") + at.#x, !this.#l.break_fixed) {
        const v = globalThis.getComputedStyle(this.#r), _ = parseFloat(v.fontSize);
        this.#p ? (this.#l.break_fixed_left = (this.#s.$width - this.#s.pad_left - this.#s.pad_right - _ * 1.5) * this.sys.cvsScale, this.#l.break_fixed_top = 0) : (this.#l.break_fixed_left = 0, this.#l.break_fixed_top = _ / 2 * this.sys.cvsScale);
      }
    } else
      n = this.#r.innerHTML, --i, this.#r.getElementsByClassName("sn_ch_last").item(0)?.remove(), this.#r.querySelectorAll(":scope > br").forEach((v) => v.remove()), this.#r.insertAdjacentHTML(
        "beforeend",
        t.slice(this.#o).join("").replaceAll(/[\n\t]/g, "") + at.#x
        // 末尾改行削除挙動対策
      );
    this.#r.querySelectorAll(".sn_ch:has(> ruby)").forEach((v) => v.style.background = ""), this.#o = t.length;
    const s = this.sys.cvsScale, o = this.#r.getBoundingClientRect(), a = o.left + this.#s.pad_left, h = o.top + this.#s.pad_top;
    let l;
    if (s === 1) l = (v, _) => {
      const m = v.getBoundingClientRect();
      return new dt(
        m.left - a,
        m.top - h,
        m.width,
        m.height + ("gjqy".includes(_) ? this.#c : 0)
      );
    };
    else {
      const v = this.sys.ofsPadLeft_Dom2PIXI + o.left * (1 - s), _ = this.sys.ofsPadTop_Dom2PIXI + o.top * (1 - s);
      l = (m, y) => {
        const b = m.getBoundingClientRect();
        return new dt(
          (b.left - v) / s - a,
          (b.top - _) / s - h,
          b.width / s,
          (b.height + ("gjqy".includes(y) ? this.#c : 0)) / s
        );
      };
    }
    const [u, c] = this.#l.hyph(this.#r, l, this.#p, i, n);
    this.#m = u;
    const f = Ft.ease(this.#b);
    for (let v = i; v < c; ++v) {
      const _ = this.#m[v], { elm: { dataset: m, parentElement: y }, rect: b } = _, P = JSON.parse(m.arg ?? '{"delay": 0}'), x = JSON.parse(m.add ?? "{}"), T = at.#$[x.ch_in_style];
      if (this.#f(_), m.cmd === "grp") {
        const I = new Ct();
        this.#a.addChild(I), new Q(P.pic, I, (w) => {
          this.#X(I, P, x, b, f, T ?? {}), I.parent || I.removeChild(w);
        });
      }
      if (m.lnk) {
        const I = y.closest("[data-arg]"), w = JSON.parse(I.dataset.arg ?? "{}");
        w.key = `lnk=[${v}] ` + this.name;
        const O = new Bt();
        this.#X(O, w, x, b, f, T ?? {});
        const R = w.style ?? "", U = R + (w.style_hover ?? ""), q = R + (w.style_clicked ?? ""), tt = w.r_style ?? "", ct = tt + (w.r_style_hover ?? ""), Y = tt + (w.r_style_clicked ?? ""), g = Array.from(I.getElementsByTagName("rt"));
        for (const N of g) N.dataset.st_r_bk = N.style.cssText;
        const S = I.style.cssText, E = (N, k) => {
          I.style.cssText = S + N;
          for (const B of g) B.style.cssText = B.dataset.st_r_bk + k;
        };
        $(w, "enabled", !0) ? at.#i.button(
          w,
          O,
          () => E(R, tt),
          () => this.canFocus() ? (E(U, ct), !0) : !1,
          () => E(q, Y)
        ) : E(
          R + (w.style_disable ?? "color: gray;"),
          tt + (w.r_style_disable ?? "color: gray;")
        ), this.#a.addChild(O);
      }
    }
    const d = Array.from(this.#r.getElementsByClassName("sn_ch_yet"));
    this.#G = () => {
      this.#G = () => !1;
      for (const _ of d) _.className = "sn_ch";
      at.#E.position.set(
        this.#l.break_fixed_left,
        this.#l.break_fixed_top
      ), at.#E.visible = !0, this.noticeCompTxt();
      const v = this.#g.shift();
      return this.#g.length > 0 && v(), !0;
    };
    for (const v of d) v.className = v.className.replace("sn_ch_yet sn", "go");
    i > 0 && ++i;
    let p;
    for (let v = c - 2; v >= 0; --v) {
      const { elm: _ } = this.#m[v];
      if (_.tagName === "SPAN") {
        p = _.parentElement?.tagName === "RUBY" ? _.parentElement.parentElement ?? _ : _;
        break;
      }
    }
    if (!p || e || i === c) {
      this.#G();
      return;
    }
    p.addEventListener("animationend", () => this.#G(), { once: !0 });
  }
  #G = () => !1;
  #X(t, e, i, n, s, o) {
    t.alpha = 0, e.x && (n.x = e.x.startsWith("=") ? n.x + parseInt(e.x.slice(1)) : parseInt(e.x)), e.y && (n.y = e.y.startsWith("=") ? n.y + parseInt(e.y.slice(1)) : parseInt(e.y)), e.width && (n.width = parseInt(e.width)), e.height && (n.height = parseInt(e.height)), e.wait && (o.wait = parseInt(e.wait)), t.width = n.width, t.height = n.height, o.x ? t.position.set(
      o.x.startsWith("=") ? n.x + t.width * o.nx : o.nx,
      o.y.startsWith("=") ? n.y + t.height * o.ny : o.ny
    ) : t.position.set(n.x, n.y);
    const a = {
      sp: t,
      tw: new Er(t).to({ alpha: 1, x: n.x, y: n.y, width: n.width, height: n.height, angle: 0 }, o.wait ?? 0).easing(s).delay((i.wait ?? 0) + (e.delay ?? 0)).onComplete(() => {
        a.tw = void 0;
      }).start()
    };
    this.#H.push(a);
  }
  #H = [];
  skipChIn() {
    let t = this.#G();
    for (const e of this.#H)
      e.tw && (e.tw.stop().end(), t = !0);
    return this.#H = [], t;
  }
  static #$ = /* @__PURE__ */ Object.create(null);
  static #q = /[{\s\.,*\{]/;
  // https://regex101.com/r/APC91I/1
  static initChStyle() {
    at.#$ = /* @__PURE__ */ Object.create(null), at.#I = /* @__PURE__ */ Object.create(null);
  }
  static getChInStyle(t) {
    return at.#$[t];
  }
  static ch_in_style(t) {
    const { name: e } = t;
    if (!e) throw "nameは必須です";
    if (at.#q.test(e)) throw `name【${e}】に使えない文字が含まれます`;
    if (e in at.#$) throw `name【${e}】はすでにあります`;
    const i = String(t.x ?? "=0"), n = String(t.y ?? "=0");
    return at.#$[e] = {
      wait: L(t, "wait", 500),
      // アニメ・FI時間
      alpha: L(t, "alpha", 0),
      x: i,
      // 初期x値
      y: n,
      // [tsy]と同様に絶対・相対指定可能
      // {x:500}			X位置を500に
      // {x:'=500'}		現在のX位置に+500加算した位置
      // {x:'=-500'}		現在のX位置に-500加算した位置
      // {x:'250,500'}	+250から＋500までの間でランダムな値をX位置に
      // {x:'=250,500'}	+250から＋500までの間でランダムな値を現在のX位置に加算
      nx: parseFloat(i.at(0) === "=" ? i.slice(1) : i),
      ny: parseFloat(n.at(0) === "=" ? n.slice(1) : n),
      scale_x: L(t, "scale_x", 1),
      scale_y: L(t, "scale_y", 1),
      rotate: L(t, "rotate", 0),
      join: $(t, "join", !0),
      // 文字を順番に出すか（true）同時か（false）
      ease: t.ease ?? "ease-out"
    };
  }
  static #I = /* @__PURE__ */ Object.create(null);
  static getChOutStyle(t) {
    return at.#I[t];
  }
  static ch_out_style(t) {
    const { name: e } = t;
    if (!e) throw "nameは必須です";
    if (at.#q.test(e)) throw `name【${e}】に使えない文字が含まれます`;
    if (e in at.#I) throw `name【${e}】はすでにあります`;
    const i = String(t.x ?? "=0"), n = String(t.y ?? "=0");
    return at.#I[e] = {
      wait: L(t, "wait", 500),
      // アニメ・FI時間
      alpha: L(t, "alpha", 0),
      x: i,
      // 初期x値
      y: n,
      // [tsy]と同様に絶対・相対指定可能
      // {x:500}			X位置を500に
      // {x:'=500'}		現在のX位置に+500加算した位置
      // {x:'=-500'}		現在のX位置に-500加算した位置
      // {x:'250,500'}	+250から＋500までの間でランダムな値をX位置に
      // {x:'=250,500'}	+250から＋500までの間でランダムな値を現在のX位置に加算
      nx: parseFloat(i.at(0) === "=" ? i.slice(1) : i),
      ny: parseFloat(n.at(0) === "=" ? n.slice(1) : n),
      scale_x: L(t, "scale_x", 1),
      scale_y: L(t, "scale_y", 1),
      rotate: L(t, "rotate", 0),
      join: $(t, "join", !1),
      // 文字を順番に出すか（true）同時か（false）
      ease: t.ease ?? "ease-out"
    };
  }
  static #E = new Ct();
  static #j = new Q();
  dispBreak(t) {
    at.delBreak();
    const e = at.#E;
    e.visible = !1, this.addChild(e), at.#j.destroy(), at.#j = new Q(t.pic, e, (i) => {
      e.parent ? (i.x = L(t, "x", 0), i.y = L(t, "y", 0), i.width = L(t, "width", this.#s.fontsize), i.height = L(t, "height", this.#s.fontsize)) : e.removeChild(i);
    });
  }
  static delBreak() {
    const t = at.#E;
    t.parent?.removeChild(t), at.#j.destroy();
  }
  #b = "Quadratic.Out";
  #O = "Quadratic.Out";
  #M() {
    this.#h.clear(), this.#m = [], this.#o = 0, this.#g = [], this.skipChIn();
    const t = this.#r.cloneNode(!0);
    t.textContent = "";
    const e = this.#r, i = Array.from(e.getElementsByClassName("sn_ch"));
    e.parentElement.insertBefore(t, e);
    let n = 0;
    i.forEach((o) => {
      const a = JSON.parse(
        o.dataset.add ?? // 通常文字
        o.children[0]?.getAttribute("data-add") ?? // ルビ
        o.children[0]?.children[0]?.getAttribute("data-add") ?? "{}"
        // 縦中横
      );
      if (!a.ch_out_style) return;
      const h = at.#I[a.ch_out_style];
      if (h) {
        if (h.wait === 0) {
          o.style.display = "none";
          return;
        }
        n += h.wait, h.join || (o.style.animationDelay = "0ms"), o.classList.add(`go_ch_out_${a.ch_out_style}`);
      }
    });
    const s = () => {
      e.parentElement.removeChild(e);
      for (const o of this.#a.removeChildren())
        o instanceof Ct && at.#i.unButton(o), o.destroy();
    };
    n === 0 ? (this.#r.textContent = "", s()) : e.lastElementChild?.addEventListener("animationend", s, { once: !0 }), this.#r = t;
  }
  reNew() {
    this.#M();
    const t = new at(this.ctn, () => this.canFocus(), this.sys);
    return t.#s = this.#s, t.#r.style.cssText = this.#r.style.cssText, t.#_ = this.#_, t.name = this.name, t.#v(), t.#S = this.#S, t.#b = this.#b, t.#O = this.#O, this.#l.reNew(t.#l), this.destroy(), t;
  }
  #S = void 0;
  // 文字にかけるフィルター
  record() {
    return {
      infTL: this.#s,
      cssText: this.#r.style.cssText,
      left: this.#_,
      //		idc_hArg	: this.#idc.gethArg(),
      ch_filter: this.#S,
      fi_easing: this.#b,
      fo_easing: this.#O,
      hyph: this.#l.record()
    };
  }
  playback(t) {
    this.#s = t.infTL, this.position.set(this.#s.pad_left, this.#s.pad_top), this.#r.style.cssText = t.cssText, this.#_ = t.left, this.#v(), this.#S = t.ch_filter, this.#b = t.fi_easing, this.#O = t.fo_easing, this.#l.playback(t.hyph);
  }
  get cssText() {
    return this.#r.style.cssText;
  }
  set cssText(t) {
    this.#r.style.cssText = t;
  }
  #w = void 0;
  snapshot(t, e) {
    this.#C((i) => {
      this.#w = Bt.from(i), this.#p && (this.#w.x += A.stageW - (this.#_ + this.#s.$width)), this.#w.y -= this.#u, this.#w.texture.frame = new dt(
        0,
        0,
        Math.min(this.#w.width, this.#s.$width - this.#_),
        Math.min(this.#w.height, this.#s.$height)
      ), this.#a.addChild(this.#w), t.render(this.#w, { clear: !1 }), e();
    }, !1);
  }
  snapshot_end() {
    this.#w && (this.#a.removeChild(this.#w), this.#w = void 0);
  }
  makeDesignCast(t) {
  }
  showDesignCast() {
  }
  //	showDesignCast() {this.#idc.visible = true; this.#idcCh.visible = true}
  dump() {
    const t = [], e = this.#r.style, i = e.length;
    for (let n = 0; n < i; ++n) {
      const s = e[n];
      t.push(`"${s}":"${e[s].replaceAll(/(["\\])/g, "\\$1")}"`);
    }
    return `"txt":"${this.#r.textContent.replaceAll(/(["\\])/g, "\\$1")}", "style":{${t.join(",")}}`;
  }
  destroy() {
    at.delBreak(), this.#r.parentElement.removeChild(this.#r), this.removeChild(this.#a), this.removeChild(this.#h), super.destroy();
  }
}
class le extends Ct {
  constructor(t, e, i, n) {
    if (super(), this.hArg = t, this.evtMng = e, this.resolve = i, this.canFocus = n, this.#r = {
      type: "pic",
      enabled: $(t, "enabled", !0),
      x: this.x = bt(t.left ?? 0),
      y: this.y = bt(t.top ?? 0),
      rotation: this.angle = L(t, "rotation", this.angle),
      // flash : rotation is in degrees.
      // pixijs: rotation is in radians, angle is in degrees.
      pivot_x: this.pivot.x = L(t, "pivot_x", this.pivot.x),
      pivot_y: this.pivot.y = L(t, "pivot_y", this.pivot.y),
      scale_x: this.scale.x = L(t, "scale_x", this.scale.x),
      scale_y: this.scale.y = L(t, "scale_y", this.scale.y),
      alpha: 1,
      text: "",
      b_pic: "",
      width: 0,
      height: 0
    }, this.getBtnBounds = () => (this.#i.x = this.#r.x, this.#i.y = this.#r.y, this.#i), this.#r.enabled && e.button(t, this, () => this.normal(), () => this.#h(), () => this.#d()), t.pic) {
      this.#r.type = "pic", this.#n = new Q(
        t.pic,
        this,
        (c) => {
          this.#l(c), this.#i.width = c.width * this.#r.scale_x, this.#i.height = c.height * this.#r.scale_y;
        },
        (c) => i
      );
      return;
    }
    if (!t.text) throw "textまたはpic属性は必須です";
    const s = L(t, "height", 30), o = new Ci({
      align: "center",
      dropShadow: !0,
      dropShadowAlpha: 0.7,
      dropShadowColor: "white",
      dropShadowBlur: 7,
      dropShadowDistance: 0,
      fill: this.#r.enabled ? "black" : "gray",
      fontFamily: le.fontFamily,
      fontSize: s,
      padding: 5
    });
    if (t.style) try {
      const c = JSON.parse(t.style);
      for (const [f, d] of Object.entries(c)) o[f] = d;
      this.#r = { ...this.#r, ...c };
    } catch (c) {
      throw c instanceof SyntaxError ? new Error(un(t, "style", c.message)) : "fn:Button.ts style";
    }
    const a = new ko(t.text ?? "", o);
    a.alpha = L(t, "alpha", a.alpha), a.width = L(t, "width", 100), a.height = t.height = s, this.setText = (c) => a.text = c, this.#r = {
      ...this.#r,
      type: "text",
      // dump用
      alpha: a.alpha,
      text: a.text,
      width: a.width,
      height: a.height
    };
    let h = !1;
    if (this.#r.width = this.width, this.#r.height = this.height, t.b_pic && (this.#r.b_pic = t.b_pic, this.#n = new Q(
      t.b_pic,
      this,
      (c) => {
        this.#a(c, a), this.#r.width = this.width, this.#r.height = this.height, a.name = JSON.stringify(this.#r);
      },
      (c) => {
        Nt.setBlendmode(this, t), c && i();
      }
    ), h = this.#n.ret), a.name = JSON.stringify(this.#r), this.addChild(a), this.#i.width = a.width, this.#i.height = a.height, t.b_pic || Nt.setBlendmode(this, t), le.#e(this, a), !this.#r.enabled) {
      h || i();
      return;
    }
    const l = o.clone();
    if (t.style_hover) try {
      const c = JSON.parse(t.style_hover);
      for (const [f, d] of Object.entries(c)) l[f] = d;
    } catch (c) {
      throw c instanceof SyntaxError ? new Error(un(t, "style_hover", c.message)) : "fn:Button.ts style_hover";
    }
    else l.fill = "white";
    const u = l.clone();
    if (t.style_clicked) try {
      const c = JSON.parse(t.style_clicked);
      for (const [f, d] of Object.entries(c)) u[f] = d;
    } catch (c) {
      throw c instanceof SyntaxError ? new Error(un(t, "style_clicked", c.message)) : "fn:Button.ts style_clicked";
    }
    else u.dropShadow = !1;
    this.normal = () => a.style = o, this.#h = () => n() ? (a.style = l, !0) : !1, this.#d = () => a.style = u, h || i();
  }
  static fontFamily = "'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif";
  static #e = (t, e) => {
  };
  static #t = (t, e, i, n) => {
  };
  static init(t) {
    t.oCfg.debug.masume && (le.#e = (e, i) => e.addChild(
      new se().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(i.x, i.y, i.width, i.height).endFill()
    ), le.#t = (e, i, n, s) => e.addChild(
      new se().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(i.x, i.y, n, s).endFill()
    ));
  }
  setText(t) {
  }
  getBtnBounds = () => this.#i;
  // 文字ボタンは背景画像を含まない位置指定なので、その当たり判定用
  #i = new dt();
  #n = new Q();
  //	#idc		: DesignCast;
  #r;
  destroy() {
    this.evtMng.unButton(this), this.#n.destroy(), super.destroy();
  }
  makeDesignCast(t) {
  }
  showDesignCast() {
  }
  //	showDesignCast() {this.#idc.visible = true}
  cvsResize() {
  }
  #a(t, e) {
    this.setChildIndex(t, 0), t.alpha = e.alpha, t.setTransform(
      e.x,
      e.y,
      1,
      1,
      e.rotation,
      0,
      0,
      (t.width - e.width) / 2,
      (t.height - e.height) / 2
    ), t.name = e.name;
  }
  normal = () => {
  };
  #h = () => !1;
  #d = () => {
  };
  #l(t) {
    this.#r.alpha = t.alpha = L(this.hArg, "alpha", t.alpha);
    const e = t.width / 3, i = this.#r.enabled ? e : t.width, n = t.height, s = t.texture.baseTexture, o = new ot(s, new dt(0, 0, e, n)), a = new ot(s, new dt(e, 0, e, n)), h = new ot(s, new dt(e * 2, 0, e, n)), l = () => t.texture = o;
    this.#r.enabled && l(), this.normal = l, this.#h = () => this.canFocus() ? (t.texture = h, !0) : !1, this.#d = () => t.texture = a, "width" in this.hArg ? (this.#r.width = bt(this.hArg.width), this.scale.x *= this.#r.width / i) : this.#r.width = i, "height" in this.hArg ? (this.#r.height = bt(this.hArg.height), this.scale.y *= this.#r.height / n) : this.#r.height = n, t.name = JSON.stringify(this.#r), le.#t(this, t, i, n);
  }
}
class pr {
  constructor(t, e, i, n, s, o, a, h) {
    this.cls = e, this.hArg = s, this.sys = o, this.val = a, this.ret = h;
    const l = o.hFactoryCls[e];
    if (!l) throw `属性 class【${e}】が不正です`;
    const u = l(), c = l();
    u.layname = c.layname = t;
    const f = s[":id_tag"] = `layer:${t} cls:${e} page:`;
    u.ctn.name = u.name = f + "A", c.ctn.name = c.name = f + "B", i.addChild(u.ctn), n.addChild(c.ctn), $(s, "visible", !0), $(s, "visible", !0), h.isWait = u.lay(s) || c.lay(s), this.#e = { fore: u, back: c }, n.visible = !1;
    const d = `const.sn.lay.${t}`;
    a.setVal_Nochk("tmp", d, !0), a.defTmp(d + ".fore.alpha", () => this.#e.fore.alpha), a.defTmp(d + ".back.alpha", () => this.#e.back.alpha), a.defTmp(d + ".fore.height", () => this.#e.fore.height), a.defTmp(d + ".back.height", () => this.#e.back.height), a.defTmp(d + ".fore.visible", () => this.#e.fore.ctn.visible), a.defTmp(d + ".back.visible", () => this.#e.back.ctn.visible), a.defTmp(d + ".fore.width", () => this.#e.fore.width), a.defTmp(d + ".back.width", () => this.#e.back.width), a.defTmp(d + ".fore.x", () => this.#e.fore.x), a.defTmp(d + ".back.x", () => this.#e.back.x), a.defTmp(d + ".fore.y", () => this.#e.fore.y), a.defTmp(d + ".back.y", () => this.#e.back.y);
  }
  #e;
  destroy() {
    this.#e.fore.destroy(), this.#e.back.destroy();
  }
  lay = (t) => this.getPage(t).lay(t);
  getPage = (t) => pr.argChk_page(t, "fore") !== "back" ? this.#e.fore : this.#e.back;
  static argChk_page(t, e) {
    const i = t.page ?? e;
    if (i === "fore" || i === "back") return t.page = i;
    throw Error("属性 page【" + i + "】が不正です");
  }
  get fore() {
    return this.#e.fore;
  }
  get back() {
    return this.#e.back;
  }
  transPage(t) {
    [this.#e.back, this.#e.fore] = [this.#e.fore, this.#e.back], this.#e.back.copy(this.#e.fore, t);
  }
}
class _o {
  //	static	readonly	#alzTagArg	= new AnalyzeTagArg;
  constructor(t, e = !1) {
    this.bg_col = t, this.isLay = e;
  }
  static init(t, e, i, n, s, o) {
  }
  static cvsResizeDesign() {
  }
  destroy() {
  }
  gethArg() {
    return this.hArg;
  }
  hArg = {};
  sethArg(t) {
    this.hArg = t;
  }
  setOther(t) {
  }
  adopt(t) {
  }
  static enterMode() {
  }
  static allHide() {
  }
  set visible(t) {
  }
  static leaveMode() {
  }
  cvsResize() {
  }
  make() {
  }
  static replaceToken(t) {
  }
}
class uy extends _o {
  constructor(t, e) {
    super("#29e", !0);
  }
  setSp(t) {
  }
}
class We extends Nt {
  static #e = new Wi();
  static #t;
  static init(t, e, i, n, s, o) {
    We.#t = i, Q.init(e, o, n, t, s);
  }
  static destroy() {
    We.#e.clear(), Q.destroy();
  }
  #i = new uy(this.ctn, this);
  constructor() {
    super(), A.isDbg && (this.#n = (t) => this.#i.setSp(t), this.cvsResize = () => {
      super.cvsResize(), this.#i.cvsResize();
    });
  }
  #n = () => {
  };
  #r = "";
  #a = "";
  #h = "";
  lay = (t) => {
    const e = D.procID + `GrpLayer lay name:${this.name_}`, i = this.#d(t, (n) => {
      n && D.endProc(e);
    });
    return i && D.beginProc(e), i;
  };
  #d(t, e) {
    const { fn: i, face: n = "" } = t;
    if (this.#i.sethArg(t), !i)
      return super.lay(t), this.ctn.children.length > 0 && this.setPos(t), this.#a = "", this.#r = this.#h = n, e(!1), !1;
    const s = "fn" in t, o = "face" in t;
    return this.clearLay({ clear_filter: $(t, "clear_filter", !0) }), s && (this.#a = i), o && (this.#h = n), super.lay(t), t.dx = 0, t.dy = 0, this.#l.destroy(), this.#l = new Q(
      this.#r = i + (n ? "," + n : ""),
      this.ctn,
      (a) => {
        ("width" in t || "height" in t) && (a.width = L(t, "width", 0), a.height = L(t, "height", 0)), this.#f = a.width, this.#s = a.height, Nt.setXY(a, t, this.ctn, !0), Nt.setBlendmode(this.ctn, t), this.#n(a);
      },
      (a) => e(a)
    ), this.#l.ret;
  }
  #l = new Q();
  #f = 0;
  #s = 0;
  get width() {
    return this.#f;
  }
  get height() {
    return this.#s;
  }
  renderStart() {
    this.#v = new Bt(this.#c), this.#v.visible = !1, this.ctn.addChildAt(this.#v, 0), this.#v.position.set(-this.ctn.x, -this.ctn.y);
    let t = () => {
      const e = this.ctn.alpha;
      this.ctn.alpha = 1;
      for (const i of this.ctn.children) i.visible = !0;
      this.#v.visible = !1, We.#t.renderer.render(this.ctn, { renderTexture: this.#c }), this.ctn.alpha = e;
      for (const i of this.ctn.children) i.visible = !1;
    };
    if (!this.containMovement) {
      let e = t;
      t = () => {
        t = () => {
        }, e();
      };
    }
    this.#_ = () => {
      t(), this.#v.visible = !0;
    }, We.#t.ticker.add(this.#_);
  }
  #c = ce.create({
    width: A.stageW,
    height: A.stageH
  });
  #v = new Bt();
  #_ = () => {
  };
  renderEnd() {
    We.#t.ticker.remove(this.#_), this.ctn.removeChild(this.#v);
    for (const t of this.ctn.children) t.visible = !0;
    this.#v.destroy(!0), this.#c = ce.create({
      width: A.stageW,
      height: A.stageH
    });
  }
  setPos(t) {
    Nt.setXY(
      this.ctn.children[0] ?? this.ctn,
      t,
      this.ctn,
      !0
    );
  }
  // アニメ・動画を含むか
  get containMovement() {
    if (this.#r === "") return !1;
    const t = this.ctn.children;
    return this.#r.split(",").some(
      (e, i) => t[i] instanceof vl || Q.getHFn2VElm(e)
    );
  }
  clearLay(t) {
    super.clearLay(t), this.#l.destroy(), this.#a = "", this.#h = "", this.#r = "";
  }
  record = () => ({
    ...super.record(),
    sBkFn: this.#a,
    sBkFace: this.#h
    //		idc_hArg	: this.#idc.gethArg(),
  });
  playback(t, e) {
    if (super.playback(t, e), t.sBkFn === "" && t.sBkFace === "") {
      this.#a = "", this.#h = "";
      return;
    }
    e.push(new Promise((i) => this.#d(
      { fn: t.sBkFn, face: t.sBkFace, left: t.x, top: t.y, alpha: t.alpha, blendmode: Nt.getNum2Blendmode(t.blendMode), rotation: t.rotation, scale_x: t.scale_x, scale_y: t.scale_y },
      (n) => {
        this.ctn.position.set(t.x, t.y), i();
      }
      // Layer.setXY()の後に再度移動
    )));
  }
  makeDesignCast(t) {
    this.ctn.visible && t(this.#i);
  }
  //makeDesignCastChildren(_gdc: IMakeDesignCast) {}
  cvsResize() {
    super.cvsResize();
  }
  showDesignCast() {
    this.#i.visible = !0;
  }
  //showDesignCastChildren() {}
  dump = () => super.dump() + `, "pic":"${this.#r}"`;
}
const Il = "userdata:/", mo = "downloads:/";
class Do extends Dm {
  constructor(t) {
    super(t), this.sys = t;
  }
  static async generate(t) {
    const e = new Do(t), i = t.arg.cur + "prj.json", n = await t.fetch(i);
    if (!n.ok) throw Error(n.statusText);
    const s = await t.dec(i, await n.text());
    return await e.load(JSON.parse(s)), e;
  }
  async load(t) {
    await super.load(t), A.stageW = t.window.width, A.stageH = t.window.height, A.debugLog = t.debug.debugLog;
  }
  searchPath(t, e = qt.DEFAULT) {
    return t.startsWith(mo) ? this.sys.path_downloads + t.slice(11) : t.startsWith(Il) ? this.sys.path_userdata + "storage/" + t.slice(10) : super.searchPath(t, e);
  }
}
class pt {
  constructor(t, e, i) {
    this.appPixi = e, this.val = i, t.add_frame = (n) => this.#h(n), t.let_frame = (n) => this.#v(n), t.set_frame = (n) => this.#_(n), t.frame = (n) => this.#y(n), t.tsy_frame = (n) => this.#u(n);
  }
  static #e;
  static #t;
  static #i;
  static init(t, e, i) {
    pt.#e = t, pt.#t = e, pt.#i = i;
  }
  #n;
  setEvtMng(t) {
    this.#n = t;
  }
  #r = /* @__PURE__ */ Object.create(null);
  destroy() {
    for (const t of Object.values(this.#r)) t.parentElement.removeChild(t);
    this.#r = /* @__PURE__ */ Object.create(null);
  }
  hideAllFrame() {
    for (const [t, { style: e }] of Object.entries(this.#r))
      this.#a[t] = e.display !== "none", e.display = "none";
  }
  #a = /* @__PURE__ */ Object.create(null);
  restoreAllFrame() {
    for (const [t, e] of Object.entries(this.#a)) {
      const i = this.#r[t];
      i && (i.style.display = e ? "inline" : "none");
    }
    this.#a = /* @__PURE__ */ Object.create(null);
  }
  //	HTMLフレーム
  // フレーム追加
  #h(t) {
    const { id: e, src: i, alpha: n = 1, scale_x: s = 1, scale_y: o = 1, rotate: a = 0 } = t;
    if (!e) throw "idは必須です";
    if (!i) throw "srcは必須です";
    const h = "const.sn.frm." + e;
    if (this.val.getVal(`tmp:${h}`)) throw `frame【${e}】はすでにあります`;
    const l = $(t, "visible", !0), u = t.b_color ? ` background-color: ${t.b_color};` : "", c = this.#l(t);
    pt.#i.cvs.insertAdjacentHTML("beforebegin", `<iframe id="${e}" style="opacity: ${n}; ${u} position: absolute; left:${pt.#t.ofsLeft4elm + c.x * pt.#t.cvsScale}px; top: ${pt.#t.ofsTop4elm + c.y * pt.#t.cvsScale}px; z-index: 1; border: 0px; overflow: hidden; display: ${l ? "inline" : "none"}; transform: scale(${s}, ${o}) rotate(${a}deg);" width="${c.width * pt.#t.cvsScale}" height="${c.height * pt.#t.cvsScale}"></iframe>`);
    const f = D.procID + `add_frame id:${e}`;
    D.beginProc(f);
    const d = pt.#e.searchPath(i, qt.HTML), p = new ue().add({ name: i, url: d, xhrType: ft.XHR_RESPONSE_TYPE.TEXT });
    return pt.#t.arg.crypto && p.use(async (v, _) => {
      try {
        v.data = await pt.#t.dec(v.extension, v.data);
      } catch (m) {
        pt.#i.errScript(`[add_frame]Html ロード失敗です src:${v.name} ${m}`, !1);
      }
      _();
    }), p.load((v, _) => {
      const m = document.getElementById(e);
      this.#r[e] = m, this.#d[e] = !1;
      const y = d.lastIndexOf("/") + 1, b = d.slice(0, y), P = b.slice(0, y);
      m.srcdoc = String(_[i]?.data).replace("sn_repRes();", "").replaceAll(
        /\s(?:src|href)=(["'])(\S+?)\1/g,
        // 【\s】が大事、data-src弾く
        (x, T, I) => I.startsWith("../") ? P + x.slice(3) : x.replace("./", "").replace(T, T + b)
      ), m.srcdoc.includes("true/*WEBP*/;") && (m.srcdoc = m.srcdoc.replaceAll(
        /data-src="(.+?\.)(?:jpe?g|png)/g,
        (x, T) => `data-src="${T}webp`
      )), m.onload = () => {
        D.endProc(f), this.val.setVal_Nochk("tmp", h, !0), this.val.setVal_Nochk("tmp", h + ".alpha", n), this.val.setVal_Nochk("tmp", h + ".x", c.x), this.val.setVal_Nochk("tmp", h + ".y", c.y), this.val.setVal_Nochk("tmp", h + ".scale_x", s), this.val.setVal_Nochk("tmp", h + ".scale_y", o), this.val.setVal_Nochk("tmp", h + ".rotate", a), this.val.setVal_Nochk("tmp", h + ".width", c.width), this.val.setVal_Nochk("tmp", h + ".height", c.height), this.val.setVal_Nochk("tmp", h + ".visible", l);
        const x = m.contentWindow;
        this.#n.resvFlameEvent(x.document.body), x.sn_repRes?.((T) => pt.#f(T.dataset.src ?? "", T));
      };
    }), !0;
  }
  #d = {};
  getFrmDisabled(t) {
    return this.#d[t];
  }
  #l(t) {
    const e = { ...t }, i = pt.#t.resolution;
    return new DOMRect(
      L(e, "x", 0) * i,
      L(e, "y", 0) * i,
      L(e, "width", A.stageW) * i,
      L(e, "height", A.stageH) * i
    );
  }
  static #f(t, e, i) {
    const n = this.#c[t];
    if (n) {
      e.src = n, i && (e.onload = () => i(e));
      return;
    }
    const s = this.#s[t];
    if (s) {
      s.push(e);
      return;
    }
    this.#s[t] = [e];
    const [o = "", a = ""] = t.split("?"), h = pt.#e.searchPath(o, qt.SP_GSM), l = new ue().add({ name: t, url: h, xhrType: ft.XHR_RESPONSE_TYPE.BUFFER });
    pt.#t.arg.crypto && h.endsWith(".bin") && l.use(async (u, c) => {
      try {
        const f = await pt.#t.decAB(u.data);
        if (u.extension !== "bin") {
          c();
          return;
        }
        u.data = f, f instanceof HTMLImageElement && (u.type = ft.TYPE.IMAGE);
      } catch (f) {
        pt.#i.errScript(`FrameMng loadPic ロード失敗です fn:${u.name} ${f}`, !1);
      }
      c();
    }), l.load((u, c) => {
      for (const [f, { data: { src: d } }] of Object.entries(c)) {
        const p = this.#c[f] = d + (d.startsWith("blob:") || d.startsWith("data:") ? "" : a ? "?" + a : ""), v = this.#s[f];
        if (v) for (const _ of v)
          _.src = p, i && (_.onload = () => i(_));
        delete this.#s[f];
      }
    });
  }
  static #s = {};
  static #c = {};
  cvsResize() {
    for (const [t, e] of Object.entries(this.#r)) {
      const i = "const.sn.frm." + t, n = Number(this.val.getVal(i + ".x")), s = Number(this.val.getVal(i + ".y")), o = Number(this.val.getVal(i + ".width")), a = Number(this.val.getVal(i + ".height"));
      e.style.left = `${pt.#t.ofsLeft4elm + n * pt.#t.cvsScale}px`, e.style.top = `${pt.#t.ofsTop4elm + s * pt.#t.cvsScale}px`, e.width = String(o * pt.#t.cvsScale), e.height = String(a * pt.#t.cvsScale);
    }
  }
  // フレーム変数を取得
  #v(t) {
    const { id: e, var_name: i } = t;
    if (!e) throw "idは必須です";
    const n = document.getElementById(e);
    if (!n) throw `id【${e}】はフレームではありません`;
    const s = "const.sn.frm." + e;
    if (!this.val.getVal(`tmp:${s}`)) throw `frame【${e}】が読み込まれていません`;
    if (!i) throw "var_nameは必須です";
    const o = n.contentWindow;
    if (!Object.hasOwn(o, i)) throw `frame【${e}】に変数/関数【${i}】がありません。変数は var付きにして下さい`;
    const a = o[i];
    return this.val.setVal_Nochk(
      "tmp",
      s + "." + i,
      $(t, "function", !1) ? a() : a
    ), !1;
  }
  // フレーム変数に設定
  #_(t) {
    const { id: e, var_name: i, text: n } = t;
    if (!e) throw "idは必須です";
    const s = document.getElementById(e);
    if (!s) throw `id【${e}】はフレームではありません`;
    const o = "const.sn.frm." + e;
    if (!this.val.getVal(`tmp:${o}`)) throw `frame【${e}】が読み込まれていません`;
    if (!i) throw "var_nameは必須です";
    if (!n) throw "textは必須です";
    this.val.setVal_Nochk("tmp", o + "." + i, n);
    const a = s.contentWindow;
    return a[i] = n, !1;
  }
  // フレームに設定
  #p = 1;
  #y(t) {
    const { id: e } = t;
    if (!e) throw "idは必須です";
    const i = document.getElementById(e);
    if (!i) throw `id【${e}】はフレームではありません`;
    const n = "const.sn.frm." + e;
    if (!this.val.getVal("tmp:" + n)) throw `frame【${e}】が読み込まれていません`;
    const s = i.style;
    if ($(t, "float", !1) ? s.zIndex = `${++this.#p}` : "index" in t ? s.zIndex = `${L(t, "index", 0)}` : t.dive && (s.zIndex = `-${++this.#p}`), "alpha" in t) {
      const a = s.opacity = String(t.alpha);
      this.val.setVal_Nochk("tmp", n + ".alpha", a);
    }
    const o = this.#l(t);
    if (("x" in t || "y" in t) && (s.left = `${pt.#t.ofsLeft4elm + o.x * pt.#t.cvsScale}px`, s.top = `${pt.#t.ofsTop4elm + o.y * pt.#t.cvsScale}px`, this.val.setVal_Nochk("tmp", n + ".x", o.x), this.val.setVal_Nochk("tmp", n + ".y", o.y)), "scale_x" in t || "scale_y" in t || "rotate" in t) {
      const a = L(t, "scale_x", 1), h = L(t, "scale_y", 1), l = L(t, "rotate", 0);
      s.transform = `scale(${a}, ${h}) rotate(${l}deg)`, this.val.setVal_Nochk("tmp", n + ".scale_x", a), this.val.setVal_Nochk("tmp", n + ".scale_y", h), this.val.setVal_Nochk("tmp", n + ".rotate", l);
    }
    if ("width" in t && (i.width = String(o.width * pt.#t.cvsScale), this.val.setVal_Nochk("tmp", n + ".width", o.width)), "height" in t && (i.height = String(o.height * pt.#t.cvsScale), this.val.setVal_Nochk("tmp", n + ".height", o.height)), "visible" in t) {
      const a = $(t, "visible", !0);
      s.display = a ? "inline" : "none", this.val.setVal_Nochk("tmp", n + ".visible", a);
    }
    if ("b_color" in t && (s.backgroundColor = t.b_color), "disabled" in t) {
      const a = this.#d[e] = $(t, "disabled", !0), h = i.contentDocument.body;
      for (const l of [
        ...Array.from(h.getElementsByTagName("input")),
        ...Array.from(h.getElementsByTagName("select"))
      ]) l.disabled = a;
    }
    return !1;
  }
  // フレームをトゥイーン開始
  #u(t) {
    const { id: e, alpha: i, x: n, y: s, scale_x: o, scale_y: a, rotate: h, width: l, height: u } = t;
    if (!e) throw "idは必須です";
    const c = document.getElementById(e);
    if (!c) throw `id【${e}】はフレームではありません`;
    const f = "const.sn.frm." + e;
    if (!this.val.getVal(`tmp:${f}`, 0)) throw `frame【${e}】が読み込まれていません`;
    const d = {};
    i && (d.a = c.style.opacity), (n || s || o || a || h) && (d.x = Number(this.val.getVal(`tmp:${f}.x`)), d.y = Number(this.val.getVal(`tmp:${f}.y`)), d.sx = Number(this.val.getVal(`tmp:${f}.scale_x`)), d.sy = Number(this.val.getVal(`tmp:${f}.scale_y`)), d.r = Number(this.val.getVal(`tmp:${f}.rotate`))), l && (d.w = this.val.getVal(`tmp:${f}.width`)), u && (d.h = this.val.getVal(`tmp:${f}.height`));
    const p = Ft.cnvTweenArg(t, d);
    let v = () => {
    };
    i && (L(p, "alpha", 0), v = () => {
      c.style.opacity = d.a, this.val.setVal_Nochk("tmp", "alpha", d.a);
    });
    let _ = () => {
    };
    const m = this.#l(p);
    (n || s || o || a || h) && (m.x, m.y, L(p, "scale_x", 1), L(p, "scale_y", 1), L(p, "rotate", 0), _ = () => {
      c.style.left = pt.#t.ofsLeft4elm + d.x * pt.#t.cvsScale + "px", c.style.top = pt.#t.ofsTop4elm + d.y * pt.#t.cvsScale + "px", c.style.transform = `scale(${d.sx}, ${d.sy}) rotate(${d.r}deg)`, this.val.setVal_Nochk("tmp", f + ".x", d.x), this.val.setVal_Nochk("tmp", f + ".y", d.y), this.val.setVal_Nochk("tmp", f + ".scale_x", d.sx), this.val.setVal_Nochk("tmp", f + ".scale_y", d.sy), this.val.setVal_Nochk("tmp", f + ".rotate", d.r);
    });
    let y = () => {
    };
    l && (m.width, y = () => {
      c.width = d.w * pt.#t.cvsScale + "px", this.val.setVal_Nochk("tmp", f + ".width", d.w);
    });
    let b = () => {
    };
    return u && (m.height, b = () => {
      c.height = d.h * pt.#t.cvsScale + "px", this.val.setVal_Nochk("tmp", f + ".height", d.h);
    }), this.appPixi.stage.interactive = !1, Ft.tween(`frm
${e}`, t, d, Ft.cnvTweenArg(t, d), () => {
      v(), _(), y(), b();
    }, () => this.appPixi.stage.interactive = !0, () => {
    }), !1;
  }
}
class oi {
  //MARK: コンストラクタ
  constructor(t, e, i, n, s, o, a, h, l) {
    this.cfg = t, this.hTag = e, this.appPixi = i, this.val = n, this.main = s, this.scrItr = o, this.sys = a, this.sndMng = h, this.prpPrs = l;
    const u = () => {
      if (a.cvsResize(), this.cvsResizeDesign(), this.#l) for (const p of this.#x)
        this.#o[p].fore.cvsResizeChildren();
      else for (const p of this.#x)
        this.#o[p].fore.cvsResize();
      this.#n.cvsResize(), this.#c.cvsResize();
    };
    if (A.isMobile)
      this.#a.add(globalThis, "orientationchange", u, { passive: !0 });
    else {
      let p;
      this.#a.add(globalThis, "resize", () => {
        p || (p = setTimeout(() => {
          p = void 0, u();
        }, 1e3 / 60 * 10));
      }, { passive: !0 });
    }
    a.cvsResize(), nt.init(t, e, n, this, (p) => this.#o[p.layname].fore === p, i), We.init(s, t, i, a, h, n), pt.init(t, a, s), le.init(t), this.#n = new pt(e, i, n), a.hFactoryCls.grp = () => new We(), a.hFactoryCls.txt = () => new nt(), e.loadplugin = (p) => this.#g(p), e.snapshot = (p) => this.#p(p), this.#y = this.sys.isApp ? this.#u : this.#C, e.add_lay = (p) => this.#m(p), e.clear_lay = (p) => this.#$(p), e.finish_trans = () => !1, e.lay = (p) => this.#X(p), e.trans = (p) => this.#O(p), e.wt = (p) => Ft.wt(p), e.quake = (p) => this.#A(p), e.stop_quake = e.finish_trans, e.wq = e.wt, e.pause_tsy = (p) => Ft.pause_tsy(p), e.resume_tsy = (p) => Ft.resume_tsy(p), e.stop_tsy = (p) => Ft.stop_tsy(p), e.tsy = (p) => this.#it(p), e.wait_tsy = (p) => Ft.wait_tsy(p), e.add_filter = (p) => this.#D(p), e.clear_filter = (p) => this.#Q(p), e.enable_filter = (p) => this.#W(p), e.ch = (p) => this.#F(p), e.clear_text = (p) => this.#at(p), e.current = (p) => this.#Z(p), e.endlink = (p) => this.#ht(p), e.er = (p) => this.#rt(p), e.graph = (p) => this.#lt(p), e.link = (p) => this.#U(p), e.r = (p) => this.#ut(p), e.rec_ch = (p) => this.#st(p), e.rec_r = (p) => this.#nt(p), e.reset_rec = (p) => this.#ct(p), e.ruby2 = (p) => this.#ft(p), e.span = (p) => this.#dt(p), e.tcy = (p) => this.#J(p), e.add_face = (p) => Q.add_face(p), e.wv = (p) => Q.wv(p), e.dump_lay = (p) => this.#ot(p), e.enable_event = (p) => this.#pt(p), e.button = (p) => this.#vt(p), t.existsBreakline && (this.breakLine = (p) => {
      delete p.visible, p.id = "break", p.pic = "breakline";
      const v = encodeURIComponent(JSON.stringify(p));
      this.#_("grp｜" + v);
    }), t.existsBreakpage && (this.breakPage = (p) => {
      delete p.visible, p.id = "break", p.pic = "breakpage";
      const v = encodeURIComponent(JSON.stringify(p));
      this.#_("grp｜" + v);
    }), this.#r = Co(String(t.oCfg.init.bg_color));
    const c = new se();
    c.beginFill(this.#r).lineStyle(0, this.#r).drawRect(0, 0, A.stageW, A.stageH).endFill(), this.#t.addChild(c.clone()), this.#i.addChild(c), this.#i.visible = !1, this.#t.name = "page:A", this.#i.name = "page:B", this.#e = i.stage, this.#e.addChild(this.#i), this.#e.addChild(this.#t), this.#e.addChild(this.#E), this.#e.addChild(this.#b), this.#e.name = "stage";
    const f = (p, v) => {
      this.#v(Number(v));
    };
    f("", n.getVal("sys:TextLayer.Back.Alpha", 1)), n.defValTrg("sys:TextLayer.Back.Alpha", f);
    const d = (p, v) => le.fontFamily = v;
    d("", n.getVal("tmp:sn.button.fontFamily", le.fontFamily)), n.defValTrg("tmp:sn.button.fontFamily", d), n.defTmp("const.sn.log.json", () => JSON.stringify(
      (this.#B.text = this.#B.text?.replaceAll("</span><span class='sn_ch'>", "") ?? "") ? [...this.#Y, this.#B] : this.#Y
    )), n.defTmp("const.sn.last_page_text", () => this.currentTxtlayFore?.pageText ?? ""), n.defTmp("const.sn.last_page_plain_text", () => this.currentTxtlayFore?.pagePlainText ?? ""), A.isDbg && (_o.init(i, a, o, l, t, this.#o), this.cvsResizeDesign = () => _o.cvsResizeDesign(), a.addHook((p, v) => {
      this.#h[p]?.(p, v) && delete this.#h[p];
    }));
  }
  #e;
  #t = new Ct();
  #i = new Ct();
  #n;
  #r;
  #a = new Wi();
  cvsResizeDesign() {
  }
  #h = {
    attach: (t) => !1,
    continue: (t) => !1,
    disconnect: (t) => !1,
    _enterDesign: (t) => {
      for (const e of this.#x) {
        const i = this.#o[e].fore;
        i.makeDesignCastChildren((n) => n.make()), i.makeDesignCast((n) => n.make());
      }
      return this.#f(this.#N), !1;
    },
    _replaceToken: (t, e) => !1,
    _selectNode: (t, e) => (this.#f(e.node), !1)
  };
  #d = "";
  #l = "";
  #f(t) {
    [this.#d = "", this.#l = ""] = t.split("/");
    const e = this.#o[this.#d];
    e && (this.#l ? e.fore.showDesignCastChildren() : e.fore.showDesignCast());
  }
  getFrmDisabled = (t) => this.#n.getFrmDisabled(t);
  #s = void 0;
  cover(t, e = 0) {
    this.#s && (this.#e.removeChild(this.#s), this.#s.destroy(), this.#s = void 0), t && this.#e.addChild(
      (this.#s = new se()).beginFill(e).lineStyle(0, e).drawRect(0, 0, A.stageW, A.stageH).endFill()
    );
  }
  #c;
  setEvtMng(t) {
    this.#c = t, this.#n.setEvtMng(t), Q.setEvtMng(t), Ft.init(t, this.appPixi);
  }
  destroy() {
    for (const t of Object.values(this.#o)) t.destroy();
    this.#a.clear(), We.destroy(), xe.destroy(), at.destroy(), nt.destroy(), this.#n.destroy(), Ft.destroy(), oi.#L = 10;
  }
  // 既存の全文字レイヤの実際のバック不透明度、を再計算
  #v(t) {
    for (const e of this.#x) {
      const { fore: i, back: n } = this.#o[e];
      i instanceof nt && (i.chgBackAlpha(t), n.chgBackAlpha(t));
    }
  }
  #_ = (t, e = this.currentTxtlayForeNeedErr, i = !0) => e.tagCh("｜&emsp;《" + t + "》");
  goTxt = () => {
  };
  get needGoTxt() {
    return this.currentTxtlayFore?.needGoTxt ?? !1;
  }
  breakLine = (t) => {
  };
  breakPage = (t) => {
  };
  clearBreak() {
    this.currentTxtlayFore && (this.clearBreak = () => this.#_("del｜break"), this.clearBreak());
  }
  clickTxtLay() {
    return this.currentTxtlayFore ? this.#x.map((t) => this.#o[t].fore).some((t) => t instanceof nt && t.click()) : !1;
  }
  //	//	システム
  //MARK: スナップショット
  #p(t) {
    const e = Po("-", "_", "", "_"), i = t.fn ? t.fn.startsWith(Il) ? t.fn : `${mo + t.fn + e}.png` : `${mo}snapshot${e}.png`, n = this.cfg.searchPath(i), s = L(t, "width", A.stageW), o = L(t, "height", A.stageH);
    return this.#y(t, n, s, o, `snapshot dt:${e}`);
  }
  #y = () => !1;
  #u({ layer: t }, e, i, n, s) {
    if (this.#n.hideAllFrame(), D.beginProc(s), !t)
      return this.sys.capturePage(e, i, n, () => {
        this.#n.restoreAllFrame(), D.endProc(s);
      }), !0;
    const o = this.#x.map((a) => {
      const { ctn: h } = this.#o[a].fore, l = [h, h.visible];
      return h.visible = !1, l;
    });
    for (const a of this.#M(t)) this.#o[a].fore.ctn.visible = !0;
    return this.sys.capturePage(e, i, n, () => {
      for (const [a, h] of o) a.visible = h;
      this.#n.restoreAllFrame(), D.endProc(s);
    }), !0;
  }
  #C(t, e, i, n, s) {
    D.beginProc(s);
    const o = Th(t, "b_color", this.#r), a = Jh({
      width: i,
      height: n,
      backgroundAlpha: o > 16777216 && e.endsWith(".png") ? 0 : 1,
      antialias: $(t, "smoothing", !1),
      preserveDrawingBuffer: !0,
      backgroundColor: o & 16777215,
      autoDensity: !0
    }), h = t.page !== "back" ? "fore" : "back", { layer: l } = t;
    return Promise.allSettled(
      this.#M(l).map((u) => new Promise(
        (c) => this.#o[u][h].snapshot(a, c)
      ))
    ).then(async () => {
      const u = ce.create({ width: a.width, height: a.height });
      a.render(this.#e, { renderTexture: u }), await this.sys.savePic(
        e,
        a.plugins.extract.base64(u)
      ), u.destroy();
      for (const c of this.#M(l)) this.#o[c][h].snapshot_end();
      a.destroy(!0), D.endProc(s);
    }), !0;
  }
  //MARK: プラグインの読み込み
  #g(t) {
    const { fn: e } = t;
    if (!e) throw "fnは必須です";
    if (!e.endsWith(".css")) throw "サポートされない拡張子です";
    const i = $(t, "join", !0), n = D.procID + `loadplugin fn:${e}`;
    return i && D.beginProc(n), (async () => {
      const s = await fetch(e);
      if (!s.ok) throw new Error("Network response was not ok.");
      hr(await s.text()), i && D.endProc(n);
    })(), i;
  }
  //	//	レイヤ共通
  //MARK: レイヤを追加する
  #m(t) {
    const { layer: e, class: i } = t;
    if (!e) throw "layerは必須です";
    if (e.includes(",")) throw "layer名に「,」は使えません";
    if (e in this.#o) throw `layer【${e}】はすでにあります`;
    if (!i) throw "clsは必須です";
    const n = { isWait: !1 };
    switch (this.#o[e] = new pr(e, i, this.#t, this.#i, t, this.sys, this.val, n), this.#x.push(e), i) {
      case "txt":
        this.#N || (this.#k = () => {
        }, this.#T = this.#tt, this.#Z = this.#K, this.hTag.current({ layer: e }), this.goTxt = () => {
          this.#c.isSkipping ? oi.#L = 0 : this.setNormalChWait();
          for (const s of this.#x) {
            const o = this.#o[s].fore;
            o instanceof nt && this.#_("gotxt｜", o, !1);
          }
        }), this.val.setVal_Nochk(
          "save",
          "const.sn.layer." + (e ?? this.#N) + ".enabled",
          !0
        );
        break;
      case "grp":
        if (this.#G) break;
        this.#G = e;
        break;
    }
    return this.scrItr.recodeDesign(t), n.isWait;
  }
  #o = {};
  // しおりLoad時再読込
  #x = [];
  // 最適化用・重なり順つき全レイヤ名
  #N = "";
  #G = "";
  #X(t) {
    const e = this.#V(t), i = this.#o[e], n = i.back.ctn, s = i.fore.ctn;
    if ($(t, "float", !1))
      this.#i.setChildIndex(n, this.#i.children.length - 1), this.#t.setChildIndex(s, this.#t.children.length - 1), this.#H();
    else if (t.index)
      L(t, "index", 0) && (this.#i.setChildIndex(n, t.index), this.#t.setChildIndex(s, t.index), this.#H());
    else if (t.dive) {
      const { dive: o } = t;
      let a = 0;
      if (e === o) throw "[lay] 属性 layerとdiveが同じ【" + o + "】です";
      const h = this.#o[o];
      if (!h) throw "[lay] 属性 dive【" + o + "】が不正です。レイヤーがありません";
      const l = h.back, u = h.fore, c = this.#i.getChildIndex(l.ctn), f = this.#t.getChildIndex(u.ctn);
      a = c < f ? c : f, a > this.#i.getChildIndex(n) && --a, this.#t.setChildIndex(s, a), this.#i.setChildIndex(n, a), this.#H();
    }
    return t[":id_tag"] = i.fore.name.slice(0, -7), this.scrItr.recodeDesign(t), i.lay(t);
  }
  #H() {
    this.#x = this.#w();
  }
  //MARK: レイヤ設定の消去
  #$(t) {
    return this.#S(t, (e) => {
      const i = this.#o[this.#V({ layer: e })];
      if (t.page === "both") {
        i.fore.clearLay(t), i.back.clearLay(t);
        return;
      }
      i.getPage(t).clearLay(t);
    }), !1;
  }
  //===================================================
  //MARK: WebGL フラグメントシェーダー GLSL
  static #q = (
    /* glsl */
    `
precision mediump float;

varying vec2 vTextureCoord;
uniform sampler2D uSampler;

uniform sampler2D rule;
uniform float vague;
uniform float tick;

uniform vec4 inputPixel;
uniform highp vec4 outputFrame;
vec2 getUV(vec2 coord) {
	return coord * inputPixel.xy / outputFrame.zw;
}

void main() {
	vec4 fg = texture2D(uSampler, vTextureCoord);
	vec4 ru = texture2D(rule, getUV(vTextureCoord));

	float v = ru.r - tick;
	gl_FragColor = abs(v) < vague
		? vec4(fg.rgb, 1) *fg.a *(0.5 +v /vague *0.5)
		: 0.0 <= v ? fg : vec4(0);
}`
  );
  /*
  	末尾が読みづらいが、以下のif文を消して三項演算子にしている。
  
  	if (abs(v) < vague) {
  		float f_a = fg.a *(0.5 +v /vague *0.5);
  		gl_FragColor.rgb = fg.rgb *f_a;
  		gl_FragColor.a = f_a;
  		return;
  	}
  	gl_FragColor = v >= 0.0 ? fg : vec4(0);
  
  		★GLSL : don't use "if"｜Nobu note.com/nobuhirosaijo/n/n606a3f5d8e89
  			> if文はあまり使わない方がいいらしい (処理負荷が高い)
  */
  #I = ce.create({
    width: A.stageW,
    height: A.stageH
  });
  #E = new Bt(this.#I);
  #j = ce.create({
    width: A.stageW,
    height: A.stageH
  });
  #b = new Bt(this.#j);
  //MARK: ページ裏表を交換
  #O(t) {
    const { layer: e } = t, i = /* @__PURE__ */ new Set(), n = this.#M(e).map((x) => (i.add(x), this.#o[x].fore)), s = async () => {
      [this.#t, this.#i] = [this.#i, this.#t];
      const x = [];
      for (const [T, I] of Object.entries(this.#o)) {
        if (i.has(T)) {
          I.transPage(x);
          continue;
        }
        const { fore: { ctn: w }, back: { ctn: O } } = I, R = this.#t.getChildIndex(O);
        this.#t.removeChild(O), this.#i.removeChild(w), this.#t.addChildAt(w, R), this.#i.addChildAt(O, R);
      }
      await Promise.allSettled(x), this.#t.visible = !0, this.#i.visible = !1, this.#E.visible = !1, this.#b.visible = !1, D.notifyEndProc(Li + Oe);
    };
    if (this.#b.filters = [], this.#b.alpha = 1, L(t, "time", 0) === 0 || this.#c.isSkipping)
      return D.beginProc(Li + Oe, () => {
      }), queueMicrotask(() => s()), !0;
    const a = [], h = this.#x.map((x) => {
      const { fore: T, back: I } = this.#o[x], w = i.has(x) ? I : T;
      return w.ctn.visible && a.push(w.ctn), w;
    }), { ticker: l, renderer: u } = this.appPixi;
    u.render(this.#i, { renderTexture: this.#I });
    let c = () => {
      for (const x of a) u.render(
        x,
        { renderTexture: this.#I, clear: !1 }
      );
    };
    if (!h.some((x) => x.containMovement)) {
      const x = c;
      c = () => {
        c = () => {
        }, x();
      };
    }
    const f = () => u.render(this.#t, { renderTexture: this.#j });
    f();
    let d = () => {
      this.#t.visible = !0, f(), this.#t.visible = !1;
    };
    if (!n.some((x) => x.containMovement)) {
      const x = d;
      d = () => {
        d = () => {
        }, x();
      };
    }
    const p = () => {
      c(), this.#E.visible = !0, d(), this.#b.visible = !0;
    }, { glsl: v, rule: _ } = t, m = async () => {
      l.remove(p), await s();
    };
    if (!v && !_)
      return Ft.tween(Oe, t, this.#b, { alpha: 0 }, () => {
      }, m, () => {
      }), l.add(p), !1;
    const y = {
      rule: ot.EMPTY,
      vague: L(t, "vague", 0.04),
      tick: 0
    };
    this.#b.filters = [new Je(
      void 0,
      v ?? oi.#q,
      y
    )];
    const b = Ft.tween(Oe, t, y, { tick: 1 }, () => {
    }, m, () => {
    }, !_);
    return _ ? new Q(_, void 0, (x) => {
      y.rule = x.texture, x.destroy(), b.start(), l.add(p);
    }, (x) => {
      x && this.main.resume();
    }).ret : (l.add(p), !1);
  }
  #M(t = "") {
    return t ? t.split(",") : this.#x;
  }
  #S(t, e) {
    const i = this.#M(t.layer);
    for (const n of i) {
      const s = this.#o[n];
      if (!s) throw `存在しないlayer【${n}】です`;
      e(n, s);
    }
    return i;
  }
  #w(t = "") {
    return this.#M(t).sort((e, i) => {
      const n = this.#t.getChildIndex(this.#o[e].fore.ctn), s = this.#t.getChildIndex(this.#o[i].fore.ctn);
      return n < s ? -1 : n > s ? 1 : 0;
    });
  }
  setAllStyle2TxtLay(t) {
    for (const e of this.#x) {
      const i = this.#o[e].fore;
      i instanceof nt && i.lay({ style: t });
    }
  }
  //MARK: 画面を揺らす
  #A(t) {
    if (L(t, "time", NaN) === 0) return !1;
    const e = this.#M(t.layer).map((u) => this.#o[u].fore.ctn), { renderer: i, ticker: n } = this.appPixi;
    this.#j.resize(A.stageW, A.stageH);
    const s = () => {
      this.#t.visible = !0;
      for (const u of e) i.render(
        u,
        { renderTexture: this.#j, clear: !1 }
      );
      this.#t.visible = !1;
    };
    this.#b.visible = !0, this.#b.alpha = 1;
    const o = bt(L(t, "hmax", 10)), a = bt(L(t, "vmax", 10)), h = o === 0 ? () => {
    } : () => this.#b.x = Math.round(Math.random() * o * 2) - o, l = a === 0 ? () => {
    } : () => this.#b.y = Math.round(Math.random() * a * 2) - a;
    return this.#b.filters = [], Ft.tween(Oe, t, this.#b, { x: 0, y: 0 }, () => {
      h(), l();
    }, () => {
      n.remove(s), this.#t.visible = !0, this.#b.visible = !1, this.#b.x = 0, this.#b.y = 0;
    }, () => {
    }), n.add(s), !1;
  }
  //MARK: トゥイーン開始
  #it(t) {
    const { layer: e, render: i, name: n } = t;
    if (!e) throw "layerは必須です";
    const s = this.#o[this.#V(t)], o = s.fore;
    let a = () => {
    };
    i && !this.#c.isSkipping && (o.renderStart(), a = () => o.renderEnd());
    const h = Ft.cnvTweenArg(t, o), l = $(t, "arrive", !1), u = $(t, "backlay", !1), c = s.back.ctn;
    return Ft.tween(n ?? e, t, o, Ft.cnvTweenArg(t, o), () => {
    }, a, () => {
      if (l && Object.assign(o, h), u) for (const f of Object.keys(Ft.hMemberCnt)) c[f] = o[f];
    }), "filter" in t && (o.ctn.filters = [Nt.bldFilters(t)], o.aFltHArg = [t]), !1;
  }
  //MARK: フィルター追加
  #D(t) {
    return this.#S(t, (e) => {
      const i = this.#o[this.#V({ layer: e })];
      if (t.page === "both") {
        this.#P(i.fore, t), this.#P(i.back, t);
        return;
      }
      const n = i.getPage(t);
      this.#P(n, t);
    }), !1;
  }
  #P(t, e) {
    const i = t.ctn;
    i.filters ??= [], i.filters = [...i.filters, Nt.bldFilters(e)], t.aFltHArg.push(e);
  }
  //MARK: フィルター全削除
  #Q(t) {
    return this.#S(t, (e) => {
      const i = this.#o[this.#V({ layer: e })];
      if (t.page === "both") {
        const s = i.fore, o = i.back;
        s.ctn.filters = null, o.ctn.filters = null, s.aFltHArg = [], o.aFltHArg = [];
        return;
      }
      const n = i.getPage(t);
      n.ctn.filters = null, n.aFltHArg = [];
    }), !1;
  }
  //MARK: フィルター個別切替
  #W(t) {
    return this.#S(t, (e) => {
      const i = this.#o[this.#V({ layer: e })];
      if (t.page === "both") {
        this.#z(i.fore, t), this.#z(i.back, t);
        return;
      }
      const n = i.getPage(t);
      this.#z(n, t);
    }), !1;
  }
  #z(t, e) {
    const i = t.ctn;
    if (!i.filters) throw "フィルターがありません";
    const n = bt(L(e, "index", 0)), s = i.filters.length;
    if (s <= n) throw `フィルターの個数（${s}）を越えています`;
    t.aFltHArg[n].enabled = i.filters[n].enabled = $(e, "enabled", !0);
  }
  //	// 文字・文字レイヤ
  static #L = 10;
  static get msecChWait() {
    return oi.#L;
  }
  //MARK: 文字を追加する
  #F(t) {
    const { text: e } = t;
    if (!e) throw "textは必須です";
    const i = this.#T(t);
    delete t.text, this.setNormalChWait(), this.#c.isSkipping ? t.wait = 0 : "wait" in t && L(t, "wait", NaN);
    const n = encodeURIComponent(JSON.stringify(t));
    this.#_("add｜" + n, i);
    const s = $(t, "record", !0), o = this.val.doRecLog();
    return s || this.val.setVal_Nochk("save", "sn.doRecLog", s), i.tagCh(e.replaceAll("[r]", `
`)), this.val.setVal_Nochk("save", "sn.doRecLog", o), this.#_("add_close｜", i), !1;
  }
  #T = (t) => {
    throw this.#k(), 0;
  };
  #tt(t) {
    const e = this.#V(t, this.#N), n = this.#o[e].getPage(t);
    if (!(n instanceof nt)) throw e + "はTxtLayerではありません";
    return n;
  }
  setNormalChWait() {
    oi.#L = this.scrItr.normalWait;
  }
  //MARK: 操作対象のメッセージレイヤの指定
  #Z = (t) => {
    throw this.#k(), 0;
  };
  #K(t) {
    const { layer: e } = t;
    if (!e) throw "[current] layerは必須です";
    const i = this.#o[e];
    if (!i || !(i.getPage(t) instanceof nt)) throw `${e}はTxtLayerではありません`;
    this.#R = i, this.recPagebreak(), this.#N = e, this.val.setVal_Nochk("save", "const.sn.mesLayer", e);
    for (const n of this.#x) {
      const { fore: s, back: o } = this.#o[n];
      s instanceof nt && (s.isCur = o.isCur = n === e);
    }
    return !1;
  }
  get currentTxtlayForeNeedErr() {
    return this.#k(), this.currentTxtlayFore;
  }
  get currentTxtlayFore() {
    return this.#R ? this.#R.fore : null;
  }
  #R;
  // カレントテキストレイヤ
  #k = () => {
    throw "文字レイヤーがありません。文字表示や操作する前に、[add_lay layer=（レイヤ名） class=txt]で文字レイヤを追加して下さい";
  };
  #V(t, e = "") {
    const i = t.layer ?? e;
    if (i.includes(",")) throw "layer名に「,」は使えません";
    if (!(i in this.#o)) throw "属性 layer【" + i + "】が不正です。レイヤーがありません";
    return t.layer = i;
  }
  #B = { text: "" };
  #Y = [];
  recText(t) {
    this.#B = { text: t }, this.val.setVal_Nochk(
      "save",
      "const.sn.sLog",
      String(this.val.getVal("const.sn.log.json"))
      // これを起動したい
    );
  }
  recPagebreak() {
    this.#B.text && (this.#B.text = this.#B.text.replaceAll("</span><span class='sn_ch'>", ""), this.#Y.push(this.#B) > this.cfg.oCfg.log.max_len && (this.#Y = this.#Y.slice(-this.cfg.oCfg.log.max_len)), this.#B = { text: "" });
  }
  //MARK: 文字消去
  #at(t) {
    const e = this.#T(t);
    return t.layer === this.#N && t.page === "fore" && this.recPagebreak(), e.clearText(), !1;
  }
  //MARK: ハイパーリンクの終了
  #ht(t) {
    return this.#_("endlink｜", this.#T(t)), !1;
  }
  //MARK: ページ両面の文字消去
  #rt(t) {
    return $(t, "rec_page_break", !0) && this.recPagebreak(), this.#R && (this.#R.fore.clearLay(t), this.#R.back.clearLay(t)), !1;
  }
  //MARK: インライン画像表示
  #lt(t) {
    if (!t.pic) throw "[graph] picは必須です";
    const e = encodeURIComponent(JSON.stringify(t));
    return this.#_("grp｜" + e, this.#T(t)), !1;
  }
  //MARK: ハイパーリンク
  #U(t) {
    if (!t.fn && !t.label && !t.url) throw "fn,label,url いずれかは必須です";
    t.fn ??= this.scrItr.scriptFn, t.style ??= "background-color: rgba(255,0,0,0.5);", t.style_hover ??= "background-color: rgba(255,0,0,0.9);", t.style_clicked ??= t.style;
    const e = encodeURIComponent(JSON.stringify(t));
    return this.#_("link｜" + e, this.#T(t)), !1;
  }
  //MARK: 改行
  #ut(t) {
    return t.text = `
`, this.#F(t);
  }
  //MARK: 履歴改行
  #nt(t) {
    return this.#st({ ...t, text: "[r]" });
  }
  //MARK: 履歴書き込み
  #st(t) {
    return this.#B = { ...t, text: this.#B.text }, t.text ? (t.record = !0, t.style ??= "", t.style += "display: none;", t.wait = 0, this.#F(t)) : !1;
  }
  //MARK: 履歴リセット
  #ct(t) {
    return this.#Y = [], this.#B = { text: t.text ?? "" }, this.val.setVal_Nochk(
      "save",
      "const.sn.sLog",
      t.text ? `[{text:"${t.text}"}]` : "[]"
    ), !1;
  }
  //MARK: 文字列と複数ルビの追加
  #ft(t) {
    const { t: e, r: i } = t;
    if (!e) throw "[ruby2] tは必須です";
    if (!i) throw "[ruby2] rは必須です";
    return t.text = "｜" + encodeURIComponent(e) + "《" + encodeURIComponent(i) + "》", delete t.t, delete t.r, this.#F(t);
  }
  //MARK: インラインスタイル設定
  #dt(t) {
    const e = encodeURIComponent(JSON.stringify(t));
    return this.#_("span｜" + e, this.#T(t)), !1;
  }
  //MARK: tcy縦中横を表示する
  #J(t) {
    if (!t.t) throw "[tcy] tは必須です";
    const e = encodeURIComponent(JSON.stringify(t));
    return this.#_("tcy｜" + e, this.#T(t)), !1;
  }
  //MARK: レイヤのダンプ
  #ot({ layer: t }) {
    console.group("🥟 [dump_lay]");
    for (const e of this.#M(t)) {
      const { fore: i, back: n } = this.#o[e];
      try {
        console.info(
          `%c${i.name.slice(0, -7)} %o`,
          `color:#${A.isDarkMode ? "49F" : "05A"};`,
          JSON.parse(`{"back":{${n.dump()}}, "fore":{${i.dump()}}}`)
        );
      } catch (s) {
        console.error("dump_lay err:%o", s), console.error(`   back:${n.dump()}`), console.error(`   fore:${i.dump()}`);
      }
    }
    return console.groupEnd(), !1;
  }
  //MARK: イベント有無の切替
  #pt(t) {
    const e = this.#V(t, this.#N), i = $(t, "enabled", !0);
    return this.#T(t).enabled = i, this.val.setVal_Nochk("save", "const.sn.layer." + e + ".enabled", i), !1;
  }
  //MARK: ボタンを表示
  #vt(t) {
    return pr.argChk_page(t, "back"), t.fn ??= this.scrItr.scriptFn, this.#T(t).addButton(t), this.scrItr.recodeDesign(t), !1;
  }
  record() {
    const t = {};
    for (const e of this.#x) {
      const i = this.#o[e];
      t[e] = {
        cls: i.cls,
        fore: i.fore.record(),
        back: i.back.record()
      };
    }
    return t;
  }
  playback(t) {
    this.#Y = JSON.parse(String(this.val.getVal("save:const.sn.sLog"))), this.#B = { text: "" };
    const e = [], i = [];
    for (const [s, { fore: o, fore: { idx: a }, back: h, cls: l }] of Object.entries(t)) {
      i.push({ ln: s, idx: a });
      const u = this.#o[s] ??= new pr(s, l, this.#t, this.#i, {}, this.sys, this.val, { isWait: !1 });
      u.fore.playback(o, e), u.back.playback(h, e);
    }
    const n = this.#t.children.length;
    return e.push(new Promise((s) => {
      for (const { ln: o, idx: a } of i.sort(({ idx: h }, { idx: l }) => h === l ? 0 : h < l ? -1 : 1)) {
        const { fore: h, back: l } = this.#o[o];
        if (!h) continue;
        const u = n > a ? a : n - 1;
        this.#t.setChildIndex(h.ctn, u), this.#i.setChildIndex(l.ctn, u);
      }
      s();
    })), e;
  }
}
const cy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LayerMng: oi
}, Symbol.toStringTag, { value: "Module" }));
class nt extends Nt {
  static #e;
  static #t;
  static #i;
  static #n;
  static init(t, e, i, n, s, o) {
    nt.#e = t, at.init(t, o), nt.#t = i, nt.#n = n, nt.#i = s, i.setDoRecProc(nt.chgDoRec), e.autowc = (a) => nt.#s(a), e.autowc({ enabled: !1, text: "", time: 0 }), e.ch_in_style = (a) => nt.#r(a), e.ch_out_style = (a) => nt.#a(a), at.initChStyle(), nu(), hr(
      t.matchPath(".+", qt.FONT).flatMap((a) => Object.values(a).map((h) => `
@font-face {
	font-family: '${h}';
	src: url('${this.#e.searchPath(h, qt.FONT)}');
}
`)).join("") + `
.sn_tx {
	pointer-events: none;
	user-select: none;
	-webkit-touch-callout: none;
	box-sizing: border-box;
}
.sn_ch {
	position: relative;
	display: inline-block;
}
`
      // 「sn_ch」と「sn_ch_in_〜」の中身が重複しているが、これは必須
    ), nt.#r({
      name: "default",
      wait: 500,
      alpha: 0,
      x: "=0.3",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: !0,
      ease: "ease-out"
    }), nt.#a({
      name: "default",
      wait: 0,
      alpha: 0,
      x: "=0",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: !1,
      ease: "ease-out"
    });
  }
  // 文字出現演出
  static #r(t) {
    const e = at.ch_in_style(t), i = e.x.startsWith("=") ? `${e.nx * 100}%` : `${e.nx}px`, n = e.y.startsWith("=") ? `${e.ny * 100}%` : `${e.ny}px`, { name: s } = t;
    return hr(`
.sn_ch_in_${s} {
	position: relative;
	display: inline-block;
}
.go_ch_in_${s} {
	opacity: ${e.alpha};
	position: relative;
	display: inline-block;
	animation: sn_ch_in_${s} ${e.wait}ms ${e.ease} 0s both;
}
@keyframes sn_ch_in_${s} {
	from {transform: rotate(${e.rotate}deg) scale(${e.scale_x}, ${e.scale_y}) translate(${i}, ${n})}
	to {opacity: 1; transform: none;}
}
`), !1;
  }
  // 文字消去演出
  static #a(t) {
    const e = at.ch_out_style(t), i = e.x.startsWith("=") ? `${e.nx * 100}%` : `${e.nx}px`, n = e.y.startsWith("=") ? `${e.ny * 100}%` : `${e.ny}px`, { name: s } = t;
    return hr(`
.go_ch_out_${s} {
	position: relative;
	display: inline-block;
	animation: go_ch_out_${s} ${e.wait}ms ${e.ease} 0s both;
}
@keyframes go_ch_out_${s} {
	to {
		opacity: ${e.alpha};
		transform: rotate(${e.rotate}deg) scale(${e.scale_x}, ${e.scale_y}) translate(${i}, ${n});
	}
`), !1;
  }
  static #h;
  static #d;
  static setEvtMng(t, e, i) {
    nt.#h = t, nt.#d = e, at.setEvtMng(t, i);
  }
  // 文字ごとのウェイト
  static #l = !1;
  static #f = {};
  static #s(t) {
    nt.#l = $(t, "enabled", nt.#l), nt.#t.setVal_Nochk("save", "const.sn.autowc.enabled", nt.#l);
    const { text: e } = t;
    if ("text" in t != "time" in t) throw "[autowc] textとtimeは同時指定必須です";
    if (nt.#t.setVal_Nochk("save", "const.sn.autowc.text", e), !e)
      return nt.#t.setVal_Nochk("save", "const.sn.autowc.time", ""), !1;
    const i = e.length;
    if (nt.#l && i === 0) throw '[autowc] enabled === false かつ text === "" は許されません';
    const n = String(t.time).split(",");
    if (n.length !== i) throw "[autowc] text文字数とtimeに記述された待ち時間（コンマ区切り）は同数にして下さい";
    nt.#f = {};
    for (let s = 0; s < i; ++s) nt.#f[e[s]] = bt(n[s]);
    return nt.#t.setVal_Nochk("save", "const.sn.autowc.time", t.time), !1;
  }
  // バック
  #c = 0;
  #v = 0;
  #_ = !1;
  #p = void 0;
  #y = "";
  // 背景画像無し（＝単色塗り）
  // 文字表示
  #u = new at(this.ctn, () => this.canFocus(), nt.#d);
  #C = new xe();
  #g = document.createElement("span");
  // cssチェック・保存用
  static #m = {
    "text-align": 0,
    "text-align-last": 0,
    height: 0,
    width: 0,
    "padding-left": 0,
    "padding-right": 0,
    "padding-top": 0,
    "padding-bottom": 0
  };
  #o = new Ct();
  constructor() {
    super(), this.ctn.addChild(this.#u), this.#C.init(this.#P), this.ctn.addChild(this.#o), this.#o.name = "cntBtn", this.lay({ style: `width: ${A.stageW}px; height: ${A.stageH}px; font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif; color: white; font-size: 24px; line-height: 1.5; padding: 16px;`, in_style: "default", out_style: "default", back_clear: "true" });
  }
  destroy() {
    this.#p && (this.ctn.removeChild(this.#p).destroy(), this.#p = void 0), nt.#n.recPagebreak(), this.#u.destroy();
  }
  static destroy() {
    nt.#l = !1, nt.#f = {}, nt.#M = (t) => t;
  }
  set name(t) {
    this.name_ = t, this.#u.name = t;
  }
  get name() {
    return this.name_;
  }
  // getは継承しないらしい
  cvsResize() {
    this.#u.cvsResize();
  }
  cvsResizeChildren() {
    for (const t of this.#o.children) t.cvsResize();
  }
  procSetX(t) {
    this.#u.lay({ x: t });
  }
  procSetY(t) {
    this.#u.lay({ y: t });
  }
  lay(t) {
    if (super.lay(t), Nt.setXY(this.ctn, t, this.ctn), t[":id_tag"] = this.name_.slice(0, -7), xe.setting(t), this.#I(t), this.#u.lay(t), "r_align" in t && (this.#A = t.r_align ?? ""), this.#S = A.isSafari ? this.#u.tategaki ? (n, s) => `text-align: start; height: ${s}em; padding-top: ${n}; padding-bottom: ${n};` : (n, s) => `text-align: start; width: ${s}em; padding-left: ${n}; padding-right: ${n};` : this.#u.tategaki ? (n) => `text-align: justify; text-align-last: justify; padding-top: ${n}; padding-bottom: ${n};` : (n) => `text-align: justify; text-align-last: justify; padding-left: ${n}; padding-right: ${n};`, A.isFirefox && (this.#w = this.#it), "r_style" in t)
      if (t.r_style) {
        const n = document.createElement("span");
        n.style.cssText = t.r_style;
        const s = n.style.length, o = this.#g.style;
        for (let a = 0; a < s; ++a) {
          const h = n.style[a];
          if (h in nt.#m) {
            rt.myTrace(`${h}は指定できません`, "W");
            continue;
          }
          const l = n.style[h];
          l && (o[h] = l);
        }
      } else this.#g.style.cssText = "";
    if ("alpha" in t) for (const n of this.#o.children) n.alpha = this.ctn.alpha;
    this.#x(t), this.#X(t);
    const e = D.procID + `TxtLayer lay name:${this.name_}`, i = this.#q(t, (n) => {
      n && D.endProc(e);
    });
    return i && D.beginProc(e), i;
  }
  #x(t) {
    const { in_style: e } = t;
    if (!e) return;
    const i = at.getChInStyle(e);
    if (!i) throw `存在しないin_style【${e}】です`;
    this.#N = e, this.#G = i.join;
  }
  #N = "";
  #G = !0;
  get width() {
    return this.#u.getWidth;
  }
  get height() {
    return this.#u.getHeight;
  }
  #X(t) {
    const { out_style: e } = t;
    if (!e) return;
    if (!at.getChOutStyle(e)) throw `存在しないout_style【${e}】です`;
    this.#H = e;
  }
  #H = "";
  #$ = new Q();
  #q(t, e) {
    if ("back_clear" in t)
      return $(t, "back_clear", !1) && (this.#c = 0, this.#v = 0, this.#_ = !1, this.#y = ""), e(!1), !1;
    this.#v = L(t, "b_alpha", this.#v), this.#_ = $(t, "b_alpha_isfixed", this.#_);
    const i = (this.#_ ? 1 : Number(nt.#t.getVal("sys:TextLayer.Back.Alpha"))) * this.#v;
    if (t.b_pic) {
      if (this.#y !== t.b_pic)
        return this.#y = t.b_pic, this.#p && (this.ctn.removeChild(this.#p), this.#p.destroy()), this.#$ = new Q(this.#y, this.ctn, (n) => {
          this.#p = n, n.name = "back(pic)", n.visible = i > 0, n.alpha = i, this.#u.setMySize(n.width, n.height), this.ctn.setChildIndex(n, 0), e(!0);
        }), this.#$.ret;
    } else "b_color" in t && (this.#c = Th(t, "b_color", 0), this.#p && (this.ctn.removeChild(this.#p), this.#p.destroy()), this.#y = "", this.ctn.addChildAt(
      (this.#p = new se()).beginFill(this.#c, i).lineStyle(void 0).drawRect(0, 0, this.#u.getWidth, this.#u.getHeight).endFill(),
      0
    ), this.#p.name = "back(color)");
    return this.#p && (this.#p.visible = i > 0, this.#p.alpha = i), e(!1), !1;
  }
  chgBackAlpha(t) {
    const e = this.#_ ? this.#v : t * this.#v;
    this.#p instanceof se && (this.#p && (this.ctn.removeChild(this.#p), this.#p.destroy()), this.ctn.addChildAt(
      (this.#p = new se()).beginFill(this.#c, e).lineStyle(void 0).drawRect(0, 0, this.#u.getWidth, this.#u.getHeight).endFill(),
      0
    ), this.#p.name = "back(color)"), this.#p && (this.#p.visible = e > 0, this.#p.alpha = e);
  }
  #I(t) {
    "noffs" in t && (this.#b = t.noffs ?? "", this.#O = new RegExp(`[　${this.#b}]`)), "ffs" in t && (this.#E ??= "", this.#j = this.#E === "" ? () => "" : (e) => this.#O.test(e) ? "" : ` font-feature-settings: ${this.#E};`);
  }
  #E = "";
  #j = (t) => "";
  #b = "";
  #O = /[　]/;
  // Safariが全体に「font-feature-settings」した後、特定文字の「font-feature-settings: initial;」を受け付けてくれないのでわざわざ一つずつ指定
  static chgDoRec(t) {
    nt.#M = t ? (e) => e : (e) => `<span class='offrec'>${e}</span>`;
  }
  static #M = (t) => t;
  isCur = !1;
  #S = () => "";
  #w = (t, e, i, n = "") => {
    if (!i) return ` style='${n}'`;
    const s = t.length * 2;
    if (s - e.length < 0) return ` style='text-align: ${i}; ${n}'`;
    let o = "";
    switch (i) {
      case "justify":
        o = this.#S("0", s);
        break;
      case "121":
        o = this.#S(`calc(${(s - e.length) / (e.length * 2)}em)`, s);
        break;
      case "even":
        o = this.#S(`calc(${(s - e.length) / (e.length + 1)}em)`, s);
        break;
      case "1ruby":
        o = this.#S("1em", s);
        break;
      default:
        o = `text-align: ${i};`;
    }
    return ` style='${o} ${n}'`;
  };
  #A = "";
  #it(t, e, i, n = "") {
    if (!i) return ` style='${n}'`;
    const s = t.length * 2;
    if (s - e.length < 0) return ` style='text-align: ${i}; ${n}'`;
    let o = "";
    switch (i) {
      case "left":
        o = "ruby-align: start;";
        break;
      case "center":
        o = "ruby-align: center;";
        break;
      case "right":
        o = "ruby-align: start;";
        break;
      case "justify":
        o = "ruby-align: space-between;";
        break;
      case "121":
        o = "ruby-align: space-around;";
        break;
      case "even":
        const a = (s - e.length) / (e.length + 1);
        o = "ruby-align: space-between; " + (this.#u.tategaki ? `padding-top: ${a}em; padding-bottom: ${a}em;` : `padding-left: ${a}em; padding-right: ${a}em;`);
        break;
      case "1ruby":
        o = "ruby-align: space-between; " + (this.#u.tategaki ? "padding-top: 1em; padding-bottom: 1em;" : "padding-left: 1em; padding-right: 1em;");
        break;
      default:
        o = `text-align: ${i};`;
    }
    return ` style='${o} ${n}'`;
  }
  tagCh(t) {
    this.#C.putTxt(t);
  }
  #D = !1;
  get needGoTxt() {
    return this.#D;
  }
  #P = (t, e) => {
    nt.#e.oCfg.debug.putCh && console.log(`🖊 文字表示 text:\`${t}\`(${t.charCodeAt(0).toString(16)}) ruby:\`${e}\` name:\`${this.name_}\``);
    const i = e.split("｜");
    let n = "";
    const [s, ...o] = i, a = o.join("｜");
    switch (i.length) {
      case 1:
        if (this.#D = !0, t === `
`) {
          this.#L ? (this.#L = !1, n = "<ruby>&emsp;<rt>&emsp;</rt></ruby><br/>") : n = "<br/>";
          break;
        }
        this.#L && (this.#L = !1, e === "" && (e = "&emsp;")), n = this.#Q(t, e, this.#A);
        break;
      default:
        switch (s) {
          // ルビ揃え指定と同時シリーズ
          case "start":
          // 初期値
          case "left":
          //（肩付き）先頭親文字から、ルビ間は密着
          case "center":
          //（中付き）センター合わせ、〃
          case "right":
          //（右／下揃え）末尾親文字から、〃
          case "justify":
          //（両端揃え）先頭から末尾親文字間に、ルビ間は均等にあける
          case "121":
          //（1-2-1(JIS)）ルビの前後を比率1、ルビ間を比率2であける
          case "even":
          //（均等アキ）ルビの前後、ルビ間も均等にあける
          case "1ruby":
            this.#L = !1, this.#D = !0, n = this.#Q(t, a, s);
            break;
          case "gotxt":
            this.#Z(), this.#D ? (this.isCur && nt.#n.recText(
              this.#F.join("").replace(/^<ruby>&emsp;<rt>&emsp;<\/rt><\/ruby>(<br\/>)+/, "").replaceAll(/style='(anim\S+ [^;]+;\s*)+/g, "style='").replaceAll(/( style=''| data-(add|arg|cmd)='[^']+'|\n+|\t+)/g, "").replaceAll(/class='sn_ch[^']+/g, "class='sn_ch").replaceAll("display: none;", "").replaceAll("class='offrec'", "style='display: none;'")
              // 囲んだ領域は履歴で非表示
            ), this.#u.goTxt(this.#F, this.#z === 0), this.#D = !1, this.#z = 0) : this.isCur && this.#u.noticeCompTxt();
            return;
          // breakではない
          case "add":
            {
              const h = JSON.parse(a), { style: l = "", wait: u = null } = h, { cl: c, sty: f } = this.#W(!0, u);
              this.#F.push(`<span${c} style='${f} display: inline; ${l}'>`), delete h.style, this.#tt(h);
            }
            return;
          // breakではない
          case "add_close":
            this.#F.push("</span>"), this.#Z();
            return;
          // breakではない
          case "grp":
            this.#D = !0;
            {
              const h = JSON.parse(a);
              if (h.id ??= this.#F.length, h.id === "break") {
                this.#u.dispBreak(h);
                return;
              }
              this.#L = !1, h.delay = this.#z, h.r ??= "", h.style ??= "", h.r_style ??= "";
              const { cl: l, sty: u, lnk: c } = this.#W(!0, h.wait);
              n = `<span${l} style='${u} ${h.style}'><ruby><span data-cmd='grp' data-arg='${JSON.stringify(h)}'${c} style='${u} display: inline;'>&emsp;</span><rt${c}${this.#w(
                "　",
                h.r,
                this.#A,
                this.#g.style.cssText + (this.#T.at(-1)?.o.r_style ?? "") + h.r_style
              )}>${h.r}</rt></ruby></span>`;
            }
            break;
          case "tcy":
            this.#L = !1, this.#D = !0;
            {
              const { t: h, r: l = "", wait: u = null, style: c = "", r_style: f = "" } = JSON.parse(a);
              nt.#t.doRecLog() && (this.#R += t + (e ? `《${e}》` : ""), this.#k += h);
              const d = A.isSafari ? l.replaceAll(/[A-Za-z0-9]/g, (m) => String.fromCharCode(m.charCodeAt(0) + 65248)) : l, { cl: p, sty: v, lnk: _ } = this.#W(!0, u);
              n = `<span${p} style='${v}${this.#j(h)} ${c}'><ruby><span${_} style='${v} display: inline; text-combine-upright: all;'>${h}</span><rt${_}${this.#w(
                h,
                d,
                this.#A,
                this.#g.style.cssText + (this.#T.at(-1)?.o.r_style ?? "") + f
              )}>${d}</rt></ruby></span>`;
            }
            break;
          case "del":
            at.delBreak();
            return;
          // breakではない
          case "span":
            this.#D = !0, this.#K(JSON.parse(a));
            return;
          // breakではない
          case "link":
            this.#D = !0;
            {
              const h = JSON.parse(a);
              h[":link"] = " data-lnk='@'";
              const { cl: l, sty: u, curpos: c } = this.#W(!1, h.wait);
              this.#F.push(`<span${l} style='${u} display: inline; ${h.style ?? ""}' ${c} data-arg='${a}'>`), delete h.style, this.#K(h);
            }
            return;
          // breakではない
          case "endlink":
            this.#D = !0, this.#F.push("</span>"), this.#Z();
            return;
          // breakではない
          default:
            this.#D = !0, n = this.#Q(t, e, this.#A);
        }
        break;
    }
    this.#F.push(nt.#M(n));
  };
  #Q(t, e, i) {
    const n = t === " " ? "&nbsp;" : t === "　" ? "&emsp;" : t;
    nt.#t.doRecLog() && (this.#R += n + (e ? `《${e}》` : ""), t !== " " && (this.#k += t));
    const { cl: s, sty: o, lnk: a } = this.#W(!0, null, t);
    return e ? `<span${s} style='${o} ${this.#j(t)}'><ruby>${// 文字個別に出現させるため以下にも ${cl} が必要
    Array.from(t).map((h, l) => `<span${s}${a} style='${l > 0 ? this.#W(!0, null, t).sty : o} display: inline;'>${h === " " ? "&nbsp;" : h === "　" ? "&emsp;" : h}</span>`).join("")}<rt${a}${this.#w(
      t,
      e,
      i,
      this.#g.style.cssText + (this.#T.at(-1)?.o.r_style ?? "")
    )}>${e}</rt></ruby></span>` : `<span${s} style='${o} ${this.#j(t)}'${a}>${n}</span>`;
  }
  #W(t, e, i = `
`) {
    const n = this.#G ? e ?? this.#T.at(0)?.o.wait ?? (nt.#l ? nt.#f[i.at(0) ?? ""] ?? 0 : oi.msecChWait) : 0;
    nt.#h.isSkipping ? this.#z = 0 : t && this.#G && (this.#z += Number(n));
    const s = `data-add='{"ch_in_style":"${this.#N}", "ch_out_style":"${this.#H}"}'`;
    return {
      cl: ` class='sn_ch sn_ch_yet sn_ch_in_${this.#N}'`,
      // TxtStage.goTxt()はこれ単位で文字出現させる
      sty: `animation-delay: ${this.#z}ms;${this.#T.at(-1)?.o.style ?? ""}`,
      // TxtStage.goTxt()はこれ単位で文字出現させる
      lnk: (this.#T.at(0)?.o[":link"] ?? "") + " " + s,
      curpos: s
    };
  }
  #z = 0;
  #L = !0;
  #F = [];
  #T = [];
  #tt(t) {
    this.#T.push({
      o: t,
      r_align: this.#A,
      ch_in_style: this.#N,
      ch_out_style: this.#H
    }), "r_align" in t && (this.#A = t.r_align), this.#x(t), this.#X(t);
  }
  #Z() {
    const t = this.#T.pop();
    t && (this.#A = t.r_align, this.#x({ in_style: t.ch_in_style }), this.#X({ out_style: t.ch_out_style }));
  }
  #K(t) {
    const e = this.#T.at(-1);
    if (!e) {
      this.#tt(t);
      return;
    }
    e.o = { ...e.o, ...t }, !t.style && !t.r_style && (e.o.style = "", e.o.r_style = ""), "r_align" in t && (this.#A = t.r_align), this.#x(t), this.#X(t);
  }
  click = () => !this.ctn.interactiveChildren || !this.ctn.visible ? !1 : this.#u.skipChIn();
  clearText() {
    this.ctn.addChild(this.#u = this.#u.reNew()), this.#z = 0, this.#L = !0, this.#F = [], this.#R = "", this.#k = "", nt.#n.recPagebreak();
  }
  #R = "";
  #k = "";
  get pageText() {
    return this.#R.replace("《&emsp;》", "");
  }
  get pagePlainText() {
    return this.#k;
  }
  get enabled() {
    return this.ctn.interactiveChildren;
  }
  set enabled(t) {
    this.ctn.interactiveChildren = t;
  }
  addButton = (t) => new Promise((e) => {
    t.key = `btn=[${this.#o.children.length}] ` + this.name_, t[":id_tag"] = t.key.slice(0, -7), $(t, "hint_tate", this.#u.tategaki);
    const i = new le(t, nt.#h, () => e(), () => this.canFocus());
    i.name = JSON.stringify(t).replaceAll('"', "'"), this.#o.addChild(i);
  });
  canFocus() {
    return (this.ctn.interactiveChildren ?? !1) && this.ctn.visible && nt.#i(this);
  }
  clearLay(t) {
    super.clearLay(t), this.clearText();
    for (const e of this.#o.removeChildren()) e.destroy();
  }
  record = () => ({
    ...super.record(),
    enabled: this.enabled,
    r_cssText: this.#g.style.cssText,
    r_align: this.#A,
    // バック
    b_do: this.#p === void 0 ? void 0 : this.#p instanceof Bt ? "Sprite" : "Graphics",
    b_pic: this.#y,
    b_color: this.#c,
    b_alpha: this.#v,
    b_alpha_isfixed: this.#_,
    ffs: this.#E,
    txs: this.#u.record(),
    strNoFFS: this.#b,
    btns: this.#o.children.map((t) => t.name)
  });
  playback(t, e) {
    super.playback(t, e), this.enabled = t.enabled, this.#g.style.cssText = t.r_cssText, this.#A = t.r_align, this.cvsResize(), this.#I(t), this.#u.playback(t.txs), this.#v = t.b_alpha, this.#_ = t.b_alpha_isfixed, e = [
      e,
      new Promise((i) => {
        const n = t.b_do ? t.b_do === "Sprite" ? { b_pic: t.b_pic } : { b_color: t.b_color } : { b_pic: "" };
        n.b_alpha = t.b_alpha, n.b_alpha_isfixed = t.b_alpha_isfixed, this.#q(n, (s) => {
          s && i();
        }) || i();
      }),
      t.btns.map((i) => new Promise((n) => {
        this.addButton(JSON.parse(i.replaceAll("'", '"'))), n();
      }))
    ].flat();
  }
  get cssText() {
    return this.#u.cssText;
  }
  set cssText(t) {
    this.#u.cssText = t;
  }
  snapshot(t, e) {
    t.render(this.ctn, { clear: !1 }), this.#u.snapshot(t, e);
  }
  snapshot_end() {
    this.#u.snapshot_end();
  }
  makeDesignCast(t) {
    this.ctn.visible && this.#u.makeDesignCast(t);
  }
  makeDesignCastChildren(t) {
    if (this.ctn.visible)
      for (const e of this.#o.children) e.makeDesignCast(t);
  }
  showDesignCast() {
    this.#u.showDesignCast();
  }
  showDesignCastChildren() {
    for (const t of this.#o.children) t.showDesignCast();
  }
  dump() {
    return this.#P("", "gotxt｜"), super.dump() + `, "enabled":"${this.enabled}", ${this.#u.dump()}, "b_pic":"${this.#y}", "b_color":"${this.#c}", "b_alpha":${this.#v}, "b_alpha_isfixed":"${this.#_}", "width":${this.#u.getWidth}, "height":${this.#u.getHeight}, "pixi_obj":[${this.ctn.children.map((t) => `{"class":"${t instanceof Bt ? "Sprite" : t instanceof se ? "Graphics" : t instanceof Ct ? "Container" : "?"}", "name":"${t.name}", "alpha":${t.alpha}, "x":${t.x}, "y":${t.y}, "visible":"${t.visible}"}`).join(",")}], "button":[${this.#o.children.map((t) => t.children[0]?.name ?? "{}").join(",")}]`;
  }
}
class fy {
  #e = [];
  #t = -1;
  #i = new Wi();
  destroy() {
    this.#e = [], this.#t = -1, this.#i.clear();
  }
  add(t, e, i) {
    if (this.#e.findIndex((a) => a.btn === t) >= 0) return;
    if (t instanceof Ct) {
      t.on("pointerdown", () => {
        for (let a = this.#e.length - 1; a >= 0; --a)
          if (this.#e[a].btn === t) {
            this.#t = a;
            return;
          }
        this.#t = -1;
      }), this.#e.push({ btn: t, on: e, off: i });
      return;
    }
    this.#i.add(t, "focus", () => {
      for (let a = this.#e.length - 1; a >= 0; --a)
        if (this.#e[a].btn === t) {
          this.#t = a;
          return;
        }
      this.#t = -1;
    });
    let n = (a) => {
    }, s = t.localName === "button" || t.localName === "a" ? (a) => !a.isTrusted && a.key === "Enter" : (a) => a.key === "Enter";
    const o = t;
    switch (o.type ?? "") {
      //	switch (btn.getAttribute('type') ?? '') {	// textareaで''になる
      case "checkbox":
        n = () => o.checked = !o.checked;
        break;
      case "":
        t.querySelectorAll("input[type]").length > 0 && (n = (a) => this.#n(t, a.key), s = () => !1);
        break;
      case "range":
        n = (a) => {
          a.isTrusted || (a.key === "ArrowUp" ? o.stepUp() : o.stepDown());
        };
        break;
      case "text":
      case "textarea":
        n = (a) => {
          if (a.isTrusted) return;
          let h = (o.selectionStart ?? 0) + (a.key === "ArrowUp" ? -1 : 1);
          h < 0 && (h = 0), o.setSelectionRange(h, h);
        };
        break;
    }
    this.#i.add(t, Ie, (a) => {
      if (!(a.key !== "ArrowUp" && a.key !== "ArrowDown" && a.key !== "Enter")) {
        if (a.stopImmediatePropagation(), s(a)) {
          t.dispatchEvent(new MouseEvent("click"));
          return;
        }
        n(a);
      }
    }, { passive: !0 }), t.hasAttribute("tabindex") || (t.tabIndex = 0), this.#e.push({ btn: t, on: e, off: i });
  }
  remove(t) {
    const e = this.#e.findIndex((i) => i.btn === t);
    e < 0 || (this.#e.splice(e, 1), this.#e.length === 0 ? this.#t = -1 : e <= this.#t && --this.#t);
  }
  #n(t, e) {
    const i = t.querySelectorAll("input[type]"), n = i.length;
    for (let s = 0; s < n; ++s)
      if (i[s].checked) {
        i[(s + n + (e === "ArrowUp" ? -1 : 1)) % n].checked = !0;
        break;
      }
  }
  isFocus(t) {
    return this.#t < 0 ? !1 : this.#e[this.#t].btn === t;
  }
  prev() {
    this.#a();
    const t = this.#e.length;
    if (t !== 0) {
      --this.#t < 0 && (this.#t = t - 1);
      for (let e = t; e >= 1; --e) {
        const i = (this.#t + e) % t;
        if (this.#e[i].on()) {
          this.#t = i, this.#r(i);
          return;
        }
      }
      this.#t = -1;
    }
  }
  next() {
    this.#a();
    const t = this.#e.length;
    if (t !== 0) {
      ++this.#t >= t && (this.#t = 0);
      for (let e = 0; e < t; ++e) {
        const i = (this.#t + e) % t;
        if (this.#e[i].on()) {
          this.#t = i, this.#r(i);
          return;
        }
      }
      this.#t = -1;
    }
  }
  #r = A.debugLog ? (t) => console.log(`👾 <FocusMng idx:${t} btn:%o`, this.#e[t].btn) : () => {
  };
  getFocus() {
    if (this.#t < 0) return null;
    this.#a(), this.#t >= this.#e.length && (this.#t = 0);
    const t = this.#e[this.#t];
    return t.on() ? t.btn : null;
  }
  blur() {
    this.#a(), this.#t = -1, globalThis.focus();
  }
  #a() {
    for (let t = this.#e.length - 1; t >= 0; --t) {
      const e = this.#e[t];
      !(e.btn instanceof Ct) || e.btn.parent ? e.off() : this.#e.splice(t, 1);
    }
  }
}
var te = "top", de = "bottom", pe = "right", ee = "left", Lo = "auto", Nr = [te, de, pe, ee], Hi = "start", Cr = "end", dy = "clippingParents", Ol = "viewport", ir = "popper", py = "reference", hh = /* @__PURE__ */ Nr.reduce(function(r, t) {
  return r.concat([t + "-" + Hi, t + "-" + Cr]);
}, []), Ml = /* @__PURE__ */ [].concat(Nr, [Lo]).reduce(function(r, t) {
  return r.concat([t, t + "-" + Hi, t + "-" + Cr]);
}, []), vy = "beforeRead", _y = "read", my = "afterRead", yy = "beforeMain", gy = "main", by = "afterMain", xy = "beforeWrite", wy = "write", Ty = "afterWrite", Ey = [vy, _y, my, yy, gy, by, xy, wy, Ty];
function Fe(r) {
  return r ? (r.nodeName || "").toLowerCase() : null;
}
function oe(r) {
  if (r == null)
    return window;
  if (r.toString() !== "[object Window]") {
    var t = r.ownerDocument;
    return t && t.defaultView || window;
  }
  return r;
}
function Ii(r) {
  var t = oe(r).Element;
  return r instanceof t || r instanceof Element;
}
function fe(r) {
  var t = oe(r).HTMLElement;
  return r instanceof t || r instanceof HTMLElement;
}
function Fo(r) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = oe(r).ShadowRoot;
  return r instanceof t || r instanceof ShadowRoot;
}
function Sy(r) {
  var t = r.state;
  Object.keys(t.elements).forEach(function(e) {
    var i = t.styles[e] || {}, n = t.attributes[e] || {}, s = t.elements[e];
    !fe(s) || !Fe(s) || (Object.assign(s.style, i), Object.keys(n).forEach(function(o) {
      var a = n[o];
      a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a);
    }));
  });
}
function Py(r) {
  var t = r.state, e = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
    Object.keys(t.elements).forEach(function(i) {
      var n = t.elements[i], s = t.attributes[i] || {}, o = Object.keys(t.styles.hasOwnProperty(i) ? t.styles[i] : e[i]), a = o.reduce(function(h, l) {
        return h[l] = "", h;
      }, {});
      !fe(n) || !Fe(n) || (Object.assign(n.style, a), Object.keys(s).forEach(function(h) {
        n.removeAttribute(h);
      }));
    });
  };
}
const Cy = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: Sy,
  effect: Py,
  requires: ["computeStyles"]
};
function Ae(r) {
  return r.split("-")[0];
}
var Si = Math.max, Ln = Math.min, $i = Math.round;
function yo() {
  var r = navigator.userAgentData;
  return r != null && r.brands && Array.isArray(r.brands) ? r.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function Rl() {
  return !/^((?!chrome|android).)*safari/i.test(yo());
}
function zi(r, t, e) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  var i = r.getBoundingClientRect(), n = 1, s = 1;
  t && fe(r) && (n = r.offsetWidth > 0 && $i(i.width) / r.offsetWidth || 1, s = r.offsetHeight > 0 && $i(i.height) / r.offsetHeight || 1);
  var o = Ii(r) ? oe(r) : window, a = o.visualViewport, h = !Rl() && e, l = (i.left + (h && a ? a.offsetLeft : 0)) / n, u = (i.top + (h && a ? a.offsetTop : 0)) / s, c = i.width / n, f = i.height / s;
  return {
    width: c,
    height: f,
    top: u,
    right: l + c,
    bottom: u + f,
    left: l,
    x: l,
    y: u
  };
}
function Bo(r) {
  var t = zi(r), e = r.offsetWidth, i = r.offsetHeight;
  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - i) <= 1 && (i = t.height), {
    x: r.offsetLeft,
    y: r.offsetTop,
    width: e,
    height: i
  };
}
function kl(r, t) {
  var e = t.getRootNode && t.getRootNode();
  if (r.contains(t))
    return !0;
  if (e && Fo(e)) {
    var i = t;
    do {
      if (i && r.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function Ke(r) {
  return oe(r).getComputedStyle(r);
}
function Iy(r) {
  return ["table", "td", "th"].indexOf(Fe(r)) >= 0;
}
function ci(r) {
  return ((Ii(r) ? r.ownerDocument : (
    // $FlowFixMe[prop-missing]
    r.document
  )) || window.document).documentElement;
}
function jn(r) {
  return Fe(r) === "html" ? r : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    r.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    r.parentNode || // DOM Element detected
    (Fo(r) ? r.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    ci(r)
  );
}
function lh(r) {
  return !fe(r) || // https://github.com/popperjs/popper-core/issues/837
  Ke(r).position === "fixed" ? null : r.offsetParent;
}
function Oy(r) {
  var t = /firefox/i.test(yo()), e = /Trident/i.test(yo());
  if (e && fe(r)) {
    var i = Ke(r);
    if (i.position === "fixed")
      return null;
  }
  var n = jn(r);
  for (Fo(n) && (n = n.host); fe(n) && ["html", "body"].indexOf(Fe(n)) < 0; ) {
    var s = Ke(n);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || t && s.willChange === "filter" || t && s.filter && s.filter !== "none")
      return n;
    n = n.parentNode;
  }
  return null;
}
function Ar(r) {
  for (var t = oe(r), e = lh(r); e && Iy(e) && Ke(e).position === "static"; )
    e = lh(e);
  return e && (Fe(e) === "html" || Fe(e) === "body" && Ke(e).position === "static") ? t : e || Oy(r) || t;
}
function Uo(r) {
  return ["top", "bottom"].indexOf(r) >= 0 ? "x" : "y";
}
function vr(r, t, e) {
  return Si(r, Ln(t, e));
}
function My(r, t, e) {
  var i = vr(r, t, e);
  return i > e ? e : i;
}
function Nl() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function Al(r) {
  return Object.assign({}, Nl(), r);
}
function Dl(r, t) {
  return t.reduce(function(e, i) {
    return e[i] = r, e;
  }, {});
}
var Ry = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, Al(typeof t != "number" ? t : Dl(t, Nr));
};
function ky(r) {
  var t, e = r.state, i = r.name, n = r.options, s = e.elements.arrow, o = e.modifiersData.popperOffsets, a = Ae(e.placement), h = Uo(a), l = [ee, pe].indexOf(a) >= 0, u = l ? "height" : "width";
  if (!(!s || !o)) {
    var c = Ry(n.padding, e), f = Bo(s), d = h === "y" ? te : ee, p = h === "y" ? de : pe, v = e.rects.reference[u] + e.rects.reference[h] - o[h] - e.rects.popper[u], _ = o[h] - e.rects.reference[h], m = Ar(s), y = m ? h === "y" ? m.clientHeight || 0 : m.clientWidth || 0 : 0, b = v / 2 - _ / 2, P = c[d], x = y - f[u] - c[p], T = y / 2 - f[u] / 2 + b, I = vr(P, T, x), w = h;
    e.modifiersData[i] = (t = {}, t[w] = I, t.centerOffset = I - T, t);
  }
}
function Ny(r) {
  var t = r.state, e = r.options, i = e.element, n = i === void 0 ? "[data-popper-arrow]" : i;
  n != null && (typeof n == "string" && (n = t.elements.popper.querySelector(n), !n) || kl(t.elements.popper, n) && (t.elements.arrow = n));
}
const Ay = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: ky,
  effect: Ny,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Xi(r) {
  return r.split("-")[1];
}
var Dy = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function Ly(r, t) {
  var e = r.x, i = r.y, n = t.devicePixelRatio || 1;
  return {
    x: $i(e * n) / n || 0,
    y: $i(i * n) / n || 0
  };
}
function uh(r) {
  var t, e = r.popper, i = r.popperRect, n = r.placement, s = r.variation, o = r.offsets, a = r.position, h = r.gpuAcceleration, l = r.adaptive, u = r.roundOffsets, c = r.isFixed, f = o.x, d = f === void 0 ? 0 : f, p = o.y, v = p === void 0 ? 0 : p, _ = typeof u == "function" ? u({
    x: d,
    y: v
  }) : {
    x: d,
    y: v
  };
  d = _.x, v = _.y;
  var m = o.hasOwnProperty("x"), y = o.hasOwnProperty("y"), b = ee, P = te, x = window;
  if (l) {
    var T = Ar(e), I = "clientHeight", w = "clientWidth";
    if (T === oe(e) && (T = ci(e), Ke(T).position !== "static" && a === "absolute" && (I = "scrollHeight", w = "scrollWidth")), T = T, n === te || (n === ee || n === pe) && s === Cr) {
      P = de;
      var O = c && T === x && x.visualViewport ? x.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        T[I]
      );
      v -= O - i.height, v *= h ? 1 : -1;
    }
    if (n === ee || (n === te || n === de) && s === Cr) {
      b = pe;
      var R = c && T === x && x.visualViewport ? x.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        T[w]
      );
      d -= R - i.width, d *= h ? 1 : -1;
    }
  }
  var U = Object.assign({
    position: a
  }, l && Dy), q = u === !0 ? Ly({
    x: d,
    y: v
  }, oe(e)) : {
    x: d,
    y: v
  };
  if (d = q.x, v = q.y, h) {
    var tt;
    return Object.assign({}, U, (tt = {}, tt[P] = y ? "0" : "", tt[b] = m ? "0" : "", tt.transform = (x.devicePixelRatio || 1) <= 1 ? "translate(" + d + "px, " + v + "px)" : "translate3d(" + d + "px, " + v + "px, 0)", tt));
  }
  return Object.assign({}, U, (t = {}, t[P] = y ? v + "px" : "", t[b] = m ? d + "px" : "", t.transform = "", t));
}
function Fy(r) {
  var t = r.state, e = r.options, i = e.gpuAcceleration, n = i === void 0 ? !0 : i, s = e.adaptive, o = s === void 0 ? !0 : s, a = e.roundOffsets, h = a === void 0 ? !0 : a, l = {
    placement: Ae(t.placement),
    variation: Xi(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: n,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, uh(Object.assign({}, l, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: o,
    roundOffsets: h
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, uh(Object.assign({}, l, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: h
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const By = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: Fy,
  data: {}
};
var on = {
  passive: !0
};
function Uy(r) {
  var t = r.state, e = r.instance, i = r.options, n = i.scroll, s = n === void 0 ? !0 : n, o = i.resize, a = o === void 0 ? !0 : o, h = oe(t.elements.popper), l = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return s && l.forEach(function(u) {
    u.addEventListener("scroll", e.update, on);
  }), a && h.addEventListener("resize", e.update, on), function() {
    s && l.forEach(function(u) {
      u.removeEventListener("scroll", e.update, on);
    }), a && h.removeEventListener("resize", e.update, on);
  };
}
const Gy = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: Uy,
  data: {}
};
var jy = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function yn(r) {
  return r.replace(/left|right|bottom|top/g, function(t) {
    return jy[t];
  });
}
var Hy = {
  start: "end",
  end: "start"
};
function ch(r) {
  return r.replace(/start|end/g, function(t) {
    return Hy[t];
  });
}
function Go(r) {
  var t = oe(r), e = t.pageXOffset, i = t.pageYOffset;
  return {
    scrollLeft: e,
    scrollTop: i
  };
}
function jo(r) {
  return zi(ci(r)).left + Go(r).scrollLeft;
}
function $y(r, t) {
  var e = oe(r), i = ci(r), n = e.visualViewport, s = i.clientWidth, o = i.clientHeight, a = 0, h = 0;
  if (n) {
    s = n.width, o = n.height;
    var l = Rl();
    (l || !l && t === "fixed") && (a = n.offsetLeft, h = n.offsetTop);
  }
  return {
    width: s,
    height: o,
    x: a + jo(r),
    y: h
  };
}
function zy(r) {
  var t, e = ci(r), i = Go(r), n = (t = r.ownerDocument) == null ? void 0 : t.body, s = Si(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), o = Si(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -i.scrollLeft + jo(r), h = -i.scrollTop;
  return Ke(n || e).direction === "rtl" && (a += Si(e.clientWidth, n ? n.clientWidth : 0) - s), {
    width: s,
    height: o,
    x: a,
    y: h
  };
}
function Ho(r) {
  var t = Ke(r), e = t.overflow, i = t.overflowX, n = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + n + i);
}
function Ll(r) {
  return ["html", "body", "#document"].indexOf(Fe(r)) >= 0 ? r.ownerDocument.body : fe(r) && Ho(r) ? r : Ll(jn(r));
}
function _r(r, t) {
  var e;
  t === void 0 && (t = []);
  var i = Ll(r), n = i === ((e = r.ownerDocument) == null ? void 0 : e.body), s = oe(i), o = n ? [s].concat(s.visualViewport || [], Ho(i) ? i : []) : i, a = t.concat(o);
  return n ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(_r(jn(o)))
  );
}
function go(r) {
  return Object.assign({}, r, {
    left: r.x,
    top: r.y,
    right: r.x + r.width,
    bottom: r.y + r.height
  });
}
function Xy(r, t) {
  var e = zi(r, !1, t === "fixed");
  return e.top = e.top + r.clientTop, e.left = e.left + r.clientLeft, e.bottom = e.top + r.clientHeight, e.right = e.left + r.clientWidth, e.width = r.clientWidth, e.height = r.clientHeight, e.x = e.left, e.y = e.top, e;
}
function fh(r, t, e) {
  return t === Ol ? go($y(r, e)) : Ii(t) ? Xy(t, e) : go(zy(ci(r)));
}
function Vy(r) {
  var t = _r(jn(r)), e = ["absolute", "fixed"].indexOf(Ke(r).position) >= 0, i = e && fe(r) ? Ar(r) : r;
  return Ii(i) ? t.filter(function(n) {
    return Ii(n) && kl(n, i) && Fe(n) !== "body";
  }) : [];
}
function Wy(r, t, e, i) {
  var n = t === "clippingParents" ? Vy(r) : [].concat(t), s = [].concat(n, [e]), o = s[0], a = s.reduce(function(h, l) {
    var u = fh(r, l, i);
    return h.top = Si(u.top, h.top), h.right = Ln(u.right, h.right), h.bottom = Ln(u.bottom, h.bottom), h.left = Si(u.left, h.left), h;
  }, fh(r, o, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function Fl(r) {
  var t = r.reference, e = r.element, i = r.placement, n = i ? Ae(i) : null, s = i ? Xi(i) : null, o = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, h;
  switch (n) {
    case te:
      h = {
        x: o,
        y: t.y - e.height
      };
      break;
    case de:
      h = {
        x: o,
        y: t.y + t.height
      };
      break;
    case pe:
      h = {
        x: t.x + t.width,
        y: a
      };
      break;
    case ee:
      h = {
        x: t.x - e.width,
        y: a
      };
      break;
    default:
      h = {
        x: t.x,
        y: t.y
      };
  }
  var l = n ? Uo(n) : null;
  if (l != null) {
    var u = l === "y" ? "height" : "width";
    switch (s) {
      case Hi:
        h[l] = h[l] - (t[u] / 2 - e[u] / 2);
        break;
      case Cr:
        h[l] = h[l] + (t[u] / 2 - e[u] / 2);
        break;
    }
  }
  return h;
}
function Ir(r, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = i === void 0 ? r.placement : i, s = e.strategy, o = s === void 0 ? r.strategy : s, a = e.boundary, h = a === void 0 ? dy : a, l = e.rootBoundary, u = l === void 0 ? Ol : l, c = e.elementContext, f = c === void 0 ? ir : c, d = e.altBoundary, p = d === void 0 ? !1 : d, v = e.padding, _ = v === void 0 ? 0 : v, m = Al(typeof _ != "number" ? _ : Dl(_, Nr)), y = f === ir ? py : ir, b = r.rects.popper, P = r.elements[p ? y : f], x = Wy(Ii(P) ? P : P.contextElement || ci(r.elements.popper), h, u, o), T = zi(r.elements.reference), I = Fl({
    reference: T,
    element: b,
    placement: n
  }), w = go(Object.assign({}, b, I)), O = f === ir ? w : T, R = {
    top: x.top - O.top + m.top,
    bottom: O.bottom - x.bottom + m.bottom,
    left: x.left - O.left + m.left,
    right: O.right - x.right + m.right
  }, U = r.modifiersData.offset;
  if (f === ir && U) {
    var q = U[n];
    Object.keys(R).forEach(function(tt) {
      var ct = [pe, de].indexOf(tt) >= 0 ? 1 : -1, Y = [te, de].indexOf(tt) >= 0 ? "y" : "x";
      R[tt] += q[Y] * ct;
    });
  }
  return R;
}
function Yy(r, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = e.boundary, s = e.rootBoundary, o = e.padding, a = e.flipVariations, h = e.allowedAutoPlacements, l = h === void 0 ? Ml : h, u = Xi(i), c = u ? a ? hh : hh.filter(function(p) {
    return Xi(p) === u;
  }) : Nr, f = c.filter(function(p) {
    return l.indexOf(p) >= 0;
  });
  f.length === 0 && (f = c);
  var d = f.reduce(function(p, v) {
    return p[v] = Ir(r, {
      placement: v,
      boundary: n,
      rootBoundary: s,
      padding: o
    })[Ae(v)], p;
  }, {});
  return Object.keys(d).sort(function(p, v) {
    return d[p] - d[v];
  });
}
function qy(r) {
  if (Ae(r) === Lo)
    return [];
  var t = yn(r);
  return [ch(r), t, ch(t)];
}
function Zy(r) {
  var t = r.state, e = r.options, i = r.name;
  if (!t.modifiersData[i]._skip) {
    for (var n = e.mainAxis, s = n === void 0 ? !0 : n, o = e.altAxis, a = o === void 0 ? !0 : o, h = e.fallbackPlacements, l = e.padding, u = e.boundary, c = e.rootBoundary, f = e.altBoundary, d = e.flipVariations, p = d === void 0 ? !0 : d, v = e.allowedAutoPlacements, _ = t.options.placement, m = Ae(_), y = m === _, b = h || (y || !p ? [yn(_)] : qy(_)), P = [_].concat(b).reduce(function(Z, J) {
      return Z.concat(Ae(J) === Lo ? Yy(t, {
        placement: J,
        boundary: u,
        rootBoundary: c,
        padding: l,
        flipVariations: p,
        allowedAutoPlacements: v
      }) : J);
    }, []), x = t.rects.reference, T = t.rects.popper, I = /* @__PURE__ */ new Map(), w = !0, O = P[0], R = 0; R < P.length; R++) {
      var U = P[R], q = Ae(U), tt = Xi(U) === Hi, ct = [te, de].indexOf(q) >= 0, Y = ct ? "width" : "height", g = Ir(t, {
        placement: U,
        boundary: u,
        rootBoundary: c,
        altBoundary: f,
        padding: l
      }), S = ct ? tt ? pe : ee : tt ? de : te;
      x[Y] > T[Y] && (S = yn(S));
      var E = yn(S), M = [];
      if (s && M.push(g[q] <= 0), a && M.push(g[S] <= 0, g[E] <= 0), M.every(function(Z) {
        return Z;
      })) {
        O = U, w = !1;
        break;
      }
      I.set(U, M);
    }
    if (w)
      for (var N = p ? 3 : 1, k = function(J) {
        var C = P.find(function(ut) {
          var X = I.get(ut);
          if (X)
            return X.slice(0, J).every(function(xt) {
              return xt;
            });
        });
        if (C)
          return O = C, "break";
      }, B = N; B > 0; B--) {
        var H = k(B);
        if (H === "break") break;
      }
    t.placement !== O && (t.modifiersData[i]._skip = !0, t.placement = O, t.reset = !0);
  }
}
const Ky = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Zy,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function dh(r, t, e) {
  return e === void 0 && (e = {
    x: 0,
    y: 0
  }), {
    top: r.top - t.height - e.y,
    right: r.right - t.width + e.x,
    bottom: r.bottom - t.height + e.y,
    left: r.left - t.width - e.x
  };
}
function ph(r) {
  return [te, pe, de, ee].some(function(t) {
    return r[t] >= 0;
  });
}
function Jy(r) {
  var t = r.state, e = r.name, i = t.rects.reference, n = t.rects.popper, s = t.modifiersData.preventOverflow, o = Ir(t, {
    elementContext: "reference"
  }), a = Ir(t, {
    altBoundary: !0
  }), h = dh(o, i), l = dh(a, n, s), u = ph(h), c = ph(l);
  t.modifiersData[e] = {
    referenceClippingOffsets: h,
    popperEscapeOffsets: l,
    isReferenceHidden: u,
    hasPopperEscaped: c
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": c
  });
}
const Qy = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Jy
};
function tg(r, t, e) {
  var i = Ae(r), n = [ee, te].indexOf(i) >= 0 ? -1 : 1, s = typeof e == "function" ? e(Object.assign({}, t, {
    placement: r
  })) : e, o = s[0], a = s[1];
  return o = o || 0, a = (a || 0) * n, [ee, pe].indexOf(i) >= 0 ? {
    x: a,
    y: o
  } : {
    x: o,
    y: a
  };
}
function eg(r) {
  var t = r.state, e = r.options, i = r.name, n = e.offset, s = n === void 0 ? [0, 0] : n, o = Ml.reduce(function(u, c) {
    return u[c] = tg(c, t.rects, s), u;
  }, {}), a = o[t.placement], h = a.x, l = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += h, t.modifiersData.popperOffsets.y += l), t.modifiersData[i] = o;
}
const ig = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: eg
};
function rg(r) {
  var t = r.state, e = r.name;
  t.modifiersData[e] = Fl({
    reference: t.rects.reference,
    element: t.rects.popper,
    placement: t.placement
  });
}
const ng = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: rg,
  data: {}
};
function sg(r) {
  return r === "x" ? "y" : "x";
}
function og(r) {
  var t = r.state, e = r.options, i = r.name, n = e.mainAxis, s = n === void 0 ? !0 : n, o = e.altAxis, a = o === void 0 ? !1 : o, h = e.boundary, l = e.rootBoundary, u = e.altBoundary, c = e.padding, f = e.tether, d = f === void 0 ? !0 : f, p = e.tetherOffset, v = p === void 0 ? 0 : p, _ = Ir(t, {
    boundary: h,
    rootBoundary: l,
    padding: c,
    altBoundary: u
  }), m = Ae(t.placement), y = Xi(t.placement), b = !y, P = Uo(m), x = sg(P), T = t.modifiersData.popperOffsets, I = t.rects.reference, w = t.rects.popper, O = typeof v == "function" ? v(Object.assign({}, t.rects, {
    placement: t.placement
  })) : v, R = typeof O == "number" ? {
    mainAxis: O,
    altAxis: O
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, O), U = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, q = {
    x: 0,
    y: 0
  };
  if (T) {
    if (s) {
      var tt, ct = P === "y" ? te : ee, Y = P === "y" ? de : pe, g = P === "y" ? "height" : "width", S = T[P], E = S + _[ct], M = S - _[Y], N = d ? -w[g] / 2 : 0, k = y === Hi ? I[g] : w[g], B = y === Hi ? -w[g] : -I[g], H = t.elements.arrow, Z = d && H ? Bo(H) : {
        width: 0,
        height: 0
      }, J = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : Nl(), C = J[ct], ut = J[Y], X = vr(0, I[g], Z[g]), xt = b ? I[g] / 2 - N - X - C - R.mainAxis : k - X - C - R.mainAxis, lt = b ? -I[g] / 2 + N + X + ut + R.mainAxis : B + X + ut + R.mainAxis, V = t.elements.arrow && Ar(t.elements.arrow), Mt = V ? P === "y" ? V.clientTop || 0 : V.clientLeft || 0 : 0, ht = (tt = U?.[P]) != null ? tt : 0, F = S + xt - ht - Mt, W = S + lt - ht, et = vr(d ? Ln(E, F) : E, S, d ? Si(M, W) : M);
      T[P] = et, q[P] = et - S;
    }
    if (a) {
      var G, Kt = P === "x" ? te : ee, Ce = P === "x" ? de : pe, Jt = T[x], je = x === "y" ? "height" : "width", Qe = Jt + _[Kt], ti = Jt - _[Ce], ei = [te, ee].indexOf(m) !== -1, Wt = (G = U?.[x]) != null ? G : 0, zt = ei ? Qe : Jt - I[je] - w[je] - Wt + R.altAxis, Pt = ei ? Jt + I[je] + w[je] - Wt - R.altAxis : ti, yt = d && ei ? My(zt, Jt, Pt) : vr(d ? zt : Qe, Jt, d ? Pt : ti);
      T[x] = yt, q[x] = yt - Jt;
    }
    t.modifiersData[i] = q;
  }
}
const ag = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: og,
  requiresIfExists: ["offset"]
};
function hg(r) {
  return {
    scrollLeft: r.scrollLeft,
    scrollTop: r.scrollTop
  };
}
function lg(r) {
  return r === oe(r) || !fe(r) ? Go(r) : hg(r);
}
function ug(r) {
  var t = r.getBoundingClientRect(), e = $i(t.width) / r.offsetWidth || 1, i = $i(t.height) / r.offsetHeight || 1;
  return e !== 1 || i !== 1;
}
function cg(r, t, e) {
  e === void 0 && (e = !1);
  var i = fe(t), n = fe(t) && ug(t), s = ci(t), o = zi(r, n, e), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, h = {
    x: 0,
    y: 0
  };
  return (i || !i && !e) && ((Fe(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  Ho(s)) && (a = lg(t)), fe(t) ? (h = zi(t, !0), h.x += t.clientLeft, h.y += t.clientTop) : s && (h.x = jo(s))), {
    x: o.left + a.scrollLeft - h.x,
    y: o.top + a.scrollTop - h.y,
    width: o.width,
    height: o.height
  };
}
function fg(r) {
  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), i = [];
  r.forEach(function(s) {
    t.set(s.name, s);
  });
  function n(s) {
    e.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function(a) {
      if (!e.has(a)) {
        var h = t.get(a);
        h && n(h);
      }
    }), i.push(s);
  }
  return r.forEach(function(s) {
    e.has(s.name) || n(s);
  }), i;
}
function dg(r) {
  var t = fg(r);
  return Ey.reduce(function(e, i) {
    return e.concat(t.filter(function(n) {
      return n.phase === i;
    }));
  }, []);
}
function pg(r) {
  var t;
  return function() {
    return t || (t = new Promise(function(e) {
      Promise.resolve().then(function() {
        t = void 0, e(r());
      });
    })), t;
  };
}
function vg(r) {
  var t = r.reduce(function(e, i) {
    var n = e[i.name];
    return e[i.name] = n ? Object.assign({}, n, i, {
      options: Object.assign({}, n.options, i.options),
      data: Object.assign({}, n.data, i.data)
    }) : i, e;
  }, {});
  return Object.keys(t).map(function(e) {
    return t[e];
  });
}
var vh = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function _h() {
  for (var r = arguments.length, t = new Array(r), e = 0; e < r; e++)
    t[e] = arguments[e];
  return !t.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function _g(r) {
  r === void 0 && (r = {});
  var t = r, e = t.defaultModifiers, i = e === void 0 ? [] : e, n = t.defaultOptions, s = n === void 0 ? vh : n;
  return function(a, h, l) {
    l === void 0 && (l = s);
    var u = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, vh, s),
      modifiersData: {},
      elements: {
        reference: a,
        popper: h
      },
      attributes: {},
      styles: {}
    }, c = [], f = !1, d = {
      state: u,
      setOptions: function(m) {
        var y = typeof m == "function" ? m(u.options) : m;
        v(), u.options = Object.assign({}, s, u.options, y), u.scrollParents = {
          reference: Ii(a) ? _r(a) : a.contextElement ? _r(a.contextElement) : [],
          popper: _r(h)
        };
        var b = dg(vg([].concat(i, u.options.modifiers)));
        return u.orderedModifiers = b.filter(function(P) {
          return P.enabled;
        }), p(), d.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var m = u.elements, y = m.reference, b = m.popper;
          if (_h(y, b)) {
            u.rects = {
              reference: cg(y, Ar(b), u.options.strategy === "fixed"),
              popper: Bo(b)
            }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(R) {
              return u.modifiersData[R.name] = Object.assign({}, R.data);
            });
            for (var P = 0; P < u.orderedModifiers.length; P++) {
              if (u.reset === !0) {
                u.reset = !1, P = -1;
                continue;
              }
              var x = u.orderedModifiers[P], T = x.fn, I = x.options, w = I === void 0 ? {} : I, O = x.name;
              typeof T == "function" && (u = T({
                state: u,
                options: w,
                name: O,
                instance: d
              }) || u);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: pg(function() {
        return new Promise(function(_) {
          d.forceUpdate(), _(u);
        });
      }),
      destroy: function() {
        v(), f = !0;
      }
    };
    if (!_h(a, h))
      return d;
    d.setOptions(l).then(function(_) {
      !f && l.onFirstUpdate && l.onFirstUpdate(_);
    });
    function p() {
      u.orderedModifiers.forEach(function(_) {
        var m = _.name, y = _.options, b = y === void 0 ? {} : y, P = _.effect;
        if (typeof P == "function") {
          var x = P({
            state: u,
            name: m,
            instance: d,
            options: b
          }), T = function() {
          };
          c.push(x || T);
        }
      });
    }
    function v() {
      c.forEach(function(_) {
        return _();
      }), c = [];
    }
    return d;
  };
}
var mg = [Gy, ng, By, Cy, ig, Ky, ag, Ay, Qy], yg = /* @__PURE__ */ _g({
  defaultModifiers: mg
});
class Hn {
  constructor(t, e) {
    this.element = t, this.touch1 = null, this.touch2 = null, this.touchStartX = null, this.touchStartY = null, this.touchEndX = null, this.touchEndY = null, this.touchMove1 = null, this.touchMove2 = null, this.touchMoveX = null, this.touchMoveY = null, this.velocityX = null, this.velocityY = null, this.longPressTimer = null, this.doubleTapTimer = null, this.doubleTapWaiting = !1, this.thresholdX = 0, this.thresholdY = 0, this.disregardVelocityThresholdX = 0, this.disregardVelocityThresholdY = 0, this.swipingHorizontal = !1, this.swipingVertical = !1, this.swipingDirection = null, this.swipedHorizontal = !1, this.swipedVertical = !1, this.originalDistance = null, this.newDistance = null, this.scale = null, this.originalAngle = null, this.newAngle = null, this.rotation = null, this.handlers = {
      panstart: [],
      panmove: [],
      panend: [],
      swipeleft: [],
      swiperight: [],
      swipeup: [],
      swipedown: [],
      tap: [],
      doubletap: [],
      longpress: [],
      pinch: [],
      pinchend: [],
      rotate: [],
      rotateend: []
    }, this._onTouchStart = this.onTouchStart.bind(this), this._onTouchMove = this.onTouchMove.bind(this), this._onTouchEnd = this.onTouchEnd.bind(this), this.opts = Object.assign({}, Hn.defaults, e), this.element.addEventListener("touchstart", this._onTouchStart, xi), this.element.addEventListener("touchmove", this._onTouchMove, xi), this.element.addEventListener("touchend", this._onTouchEnd, xi), this.opts.mouseSupport && !("ontouchstart" in window) && (this.element.addEventListener("mousedown", this._onTouchStart, xi), document.addEventListener("mousemove", this._onTouchMove, xi), document.addEventListener("mouseup", this._onTouchEnd, xi));
  }
  destroy() {
    var t, e;
    this.element.removeEventListener("touchstart", this._onTouchStart), this.element.removeEventListener("touchmove", this._onTouchMove), this.element.removeEventListener("touchend", this._onTouchEnd), this.element.removeEventListener("mousedown", this._onTouchStart), document.removeEventListener("mousemove", this._onTouchMove), document.removeEventListener("mouseup", this._onTouchEnd), clearTimeout((t = this.longPressTimer) !== null && t !== void 0 ? t : void 0), clearTimeout((e = this.doubleTapTimer) !== null && e !== void 0 ? e : void 0);
  }
  on(t, e) {
    if (this.handlers[t])
      return this.handlers[t].push(e), {
        type: t,
        fn: e,
        cancel: () => this.off(t, e)
      };
  }
  off(t, e) {
    if (this.handlers[t]) {
      const i = this.handlers[t].indexOf(e);
      i !== -1 && this.handlers[t].splice(i, 1);
    }
  }
  fire(t, e) {
    for (let i = 0; i < this.handlers[t].length; i++)
      this.handlers[t][i](e);
  }
  onTouchStart(t) {
    var e, i, n, s, o, a, h, l, u, c, f, d, p, v, _, m, y, b, P, x, T, I, w, O, R, U;
    let q = !1;
    if (t.type !== "mousedown") {
      if (this.touch1 || (this.touch1 = t.changedTouches[0], q = !0), (q && t.changedTouches.length > 1 || !q) && !this.touch2) {
        this.touch2 = [...t.changedTouches].find((tt) => {
          var ct;
          return tt.identifier !== ((ct = this.touch1) === null || ct === void 0 ? void 0 : ct.identifier);
        }) || null, this.originalDistance = Math.sqrt(Math.pow(((i = (e = this.touch2) === null || e === void 0 ? void 0 : e.screenX) !== null && i !== void 0 ? i : 0) - ((a = (s = (n = this.touchMove1) === null || n === void 0 ? void 0 : n.screenX) !== null && s !== void 0 ? s : (o = this.touch1) === null || o === void 0 ? void 0 : o.screenX) !== null && a !== void 0 ? a : 0), 2) + Math.pow(((l = (h = this.touch2) === null || h === void 0 ? void 0 : h.screenY) !== null && l !== void 0 ? l : 0) - ((d = (c = (u = this.touchMove1) === null || u === void 0 ? void 0 : u.screenY) !== null && c !== void 0 ? c : (f = this.touch1) === null || f === void 0 ? void 0 : f.screenY) !== null && d !== void 0 ? d : 0), 2)), this.originalAngle = Math.atan2(((v = (p = this.touch2) === null || p === void 0 ? void 0 : p.screenY) !== null && v !== void 0 ? v : 0) - ((b = (m = (_ = this.touchMove1) === null || _ === void 0 ? void 0 : _.screenY) !== null && m !== void 0 ? m : (y = this.touch1) === null || y === void 0 ? void 0 : y.screenY) !== null && b !== void 0 ? b : 0), ((x = (P = this.touch2) === null || P === void 0 ? void 0 : P.screenX) !== null && x !== void 0 ? x : 0) - ((O = (I = (T = this.touchMove1) === null || T === void 0 ? void 0 : T.screenX) !== null && I !== void 0 ? I : (w = this.touch1) === null || w === void 0 ? void 0 : w.screenX) !== null && O !== void 0 ? O : 0)) / (Math.PI / 180);
        return;
      }
      if (!q)
        return;
    }
    (q || t.type === "mousedown") && (this.thresholdX = this.opts.threshold("x", this), this.thresholdY = this.opts.threshold("y", this), this.disregardVelocityThresholdX = this.opts.disregardVelocityThreshold("x", this), this.disregardVelocityThresholdY = this.opts.disregardVelocityThreshold("y", this), this.touchStartX = t.type === "mousedown" ? t.screenX : ((R = this.touch1) === null || R === void 0 ? void 0 : R.screenX) || 0, this.touchStartY = t.type === "mousedown" ? t.screenY : ((U = this.touch1) === null || U === void 0 ? void 0 : U.screenY) || 0, this.touchMoveX = null, this.touchMoveY = null, this.touchEndX = null, this.touchEndY = null, this.swipingDirection = null, this.longPressTimer = setTimeout(() => this.fire("longpress", t), this.opts.longPressTime), this.scale = 1, this.rotation = 0, this.fire("panstart", t));
  }
  onTouchMove(t) {
    var e, i, n, s, o, a, h, l, u, c, f, d, p;
    if (t.type === "mousemove" && (!this.touchStartX || this.touchEndX !== null))
      return;
    let v, _;
    if (t.type !== "mousemove" && (v = [...t.changedTouches].find((m) => {
      var y;
      return m.identifier === ((y = this.touch1) === null || y === void 0 ? void 0 : y.identifier);
    }), this.touchMove1 = v || this.touchMove1, _ = [...t.changedTouches].find((m) => {
      var y;
      return m.identifier === ((y = this.touch2) === null || y === void 0 ? void 0 : y.identifier);
    }), this.touchMove2 = _ || this.touchMove2), t.type === "mousemove" || v) {
      const m = (t.type === "mousemove" ? t.screenX : (e = v?.screenX) !== null && e !== void 0 ? e : 0) - ((i = this.touchStartX) !== null && i !== void 0 ? i : 0);
      this.velocityX = m - ((n = this.touchMoveX) !== null && n !== void 0 ? n : 0), this.touchMoveX = m;
      const y = (t.type === "mousemove" ? t.screenY : (s = v?.screenY) !== null && s !== void 0 ? s : 0) - ((o = this.touchStartY) !== null && o !== void 0 ? o : 0);
      this.velocityY = y - ((a = this.touchMoveY) !== null && a !== void 0 ? a : 0), this.touchMoveY = y;
      const b = Math.abs(this.touchMoveX), P = Math.abs(this.touchMoveY);
      this.swipingHorizontal = b > this.thresholdX, this.swipingVertical = P > this.thresholdY, this.swipingDirection = b > P ? this.swipingHorizontal ? "horizontal" : "pre-horizontal" : this.swipingVertical ? "vertical" : "pre-vertical", Math.max(b, P) > this.opts.pressThreshold && clearTimeout((h = this.longPressTimer) !== null && h !== void 0 ? h : void 0), this.fire("panmove", t);
    }
    t.type !== "mousemove" && this.touchMove1 != null && this.touchMove2 != null && (this.newDistance = Math.sqrt(Math.pow(this.touchMove2.screenX - this.touchMove1.screenX, 2) + Math.pow(this.touchMove2.screenY - this.touchMove1.screenY, 2)), this.scale = this.newDistance / ((l = this.originalDistance) !== null && l !== void 0 ? l : 0), this.fire("pinch", t), this.newAngle = Math.atan2(((u = this.touchMove2.screenY) !== null && u !== void 0 ? u : 0) - ((c = this.touchMove1.screenY) !== null && c !== void 0 ? c : 0), ((f = this.touchMove2.screenX) !== null && f !== void 0 ? f : 0) - ((d = this.touchMove1.screenX) !== null && d !== void 0 ? d : 0)) / (Math.PI / 180), this.rotation = this.newAngle - ((p = this.originalAngle) !== null && p !== void 0 ? p : 0), this.fire("rotate", t));
  }
  onTouchEnd(t) {
    var e, i, n, s, o, a, h, l, u, c;
    let f;
    if (t.type !== "mouseup" && (f = [...t.changedTouches].find((d) => {
      var p;
      return d.identifier === ((p = this.touch1) === null || p === void 0 ? void 0 : p.identifier);
    }), [...t.touches].find((d) => {
      var p;
      return d.identifier === ((p = this.touch1) === null || p === void 0 ? void 0 : p.identifier);
    }) || (this.touch1 = null, this.touchMove1 = null), [...t.touches].find((d) => {
      var p;
      return d.identifier === ((p = this.touch2) === null || p === void 0 ? void 0 : p.identifier);
    }) || (this.touch2 = null, this.touchMove2 = null)), !(t.type === "mouseup" && (!this.touchStartX || this.touchEndX !== null))) {
      if (t.type === "mouseup" || f) {
        this.touchEndX = t.type === "mouseup" ? t.screenX : (e = f?.screenX) !== null && e !== void 0 ? e : 0, this.touchEndY = t.type === "mouseup" ? t.screenY : (i = f?.screenY) !== null && i !== void 0 ? i : 0, this.fire("panend", t), clearTimeout((n = this.longPressTimer) !== null && n !== void 0 ? n : void 0);
        const d = this.touchEndX - ((s = this.touchStartX) !== null && s !== void 0 ? s : 0), p = Math.abs(d), v = this.touchEndY - ((o = this.touchStartY) !== null && o !== void 0 ? o : 0), _ = Math.abs(v), m = Math.sqrt(Math.pow(d, 2) + Math.pow(v, 2)), y = Math.abs(m), b = _ / p;
        p > this.thresholdX || _ > this.thresholdY || this.opts.diagonalSwipes && (y > this.thresholdX || y > this.thresholdY) ? (this.swipedHorizontal = p > this.thresholdX || this.opts.diagonalSwipes && y > this.thresholdX, this.swipedVertical = _ > this.thresholdY || this.opts.diagonalSwipes && y > this.thresholdY, (!this.opts.diagonalSwipes || b < Math.tan((45 - this.opts.diagonalLimit) * Math.PI / 180) || b > Math.tan((45 + this.opts.diagonalLimit) * Math.PI / 180)) && (p >= _ && (this.swipedVertical = !1), _ > p && (this.swipedHorizontal = !1)), this.swipedHorizontal && (d < 0 ? (((a = this.velocityX) !== null && a !== void 0 ? a : 0) < -this.opts.velocityThreshold || m < -this.disregardVelocityThresholdX) && this.fire("swipeleft", t) : (((h = this.velocityX) !== null && h !== void 0 ? h : 0) > this.opts.velocityThreshold || m > this.disregardVelocityThresholdX) && this.fire("swiperight", t)), this.swipedVertical && (v < 0 ? (((l = this.velocityY) !== null && l !== void 0 ? l : 0) < -this.opts.velocityThreshold || m < -this.disregardVelocityThresholdY) && this.fire("swipeup", t) : (((u = this.velocityY) !== null && u !== void 0 ? u : 0) > this.opts.velocityThreshold || m > this.disregardVelocityThresholdY) && this.fire("swipedown", t))) : p < this.opts.pressThreshold && _ < this.opts.pressThreshold && (this.doubleTapWaiting ? (this.doubleTapWaiting = !1, clearTimeout((c = this.doubleTapTimer) !== null && c !== void 0 ? c : void 0), this.fire("doubletap", t)) : (this.doubleTapWaiting = !0, this.doubleTapTimer = setTimeout(() => this.doubleTapWaiting = !1, this.opts.doubleTapTime), this.fire("tap", t)));
      }
      !this.touch1 && !this.touch2 && (this.fire("pinchend", t), this.fire("rotateend", t), this.originalDistance = null, this.newDistance = null, this.scale = null, this.originalAngle = null, this.newAngle = null, this.rotation = null);
    }
  }
}
Hn.defaults = {
  threshold: (r, t) => Math.max(25, Math.floor(0.15 * (r === "x" ? window.innerWidth || document.body.clientWidth : window.innerHeight || document.body.clientHeight))),
  velocityThreshold: 10,
  disregardVelocityThreshold: (r, t) => Math.floor(0.5 * (r === "x" ? t.element.clientWidth : t.element.clientHeight)),
  pressThreshold: 8,
  diagonalSwipes: !1,
  diagonalLimit: 15,
  longPressTime: 500,
  doubleTapTime: 300,
  mouseSupport: !0
};
let xi = !1;
try {
  window.addEventListener("test", null, Object.defineProperty({}, "passive", {
    get: function() {
      xi = { passive: !0 };
    }
  }));
} catch {
}
const Bl = "pointerdown", Or = "pointerdown", Ie = "keydown";
class gg {
  constructor(t, e, i, n, s, o, a, h, l) {
    if (this.cfg = t, this.hTag = e, this.appPixi = i, this.main = n, this.layMng = s, this.val = o, this.scrItr = h, this.sys = l, e.clear_event = (y) => j.clear_event(y), e.event = (y) => this.#C(y), e.set_cancel_skip = () => !1, e.set_focus = (y) => this.#m(y), a.setEvtMng(this), h.setOtherObj(this, s), nt.setEvtMng(this, l, h), s.setEvtMng(this), D.setFcs(this.#t), l.setFire((y, b) => D.fire(y, b)), A.isDbg) {
      const y = {
        pause: () => {
          if (!D.isWait) return;
          const b = {};
          h.recodeDesign(b), l.callHook("_enterDesign", b), l.send2Dbg("_enterDesign", b);
        }
        //				stopOnBreakpoint		: ()=> this.#isDbgBreak = true,
        //				stopOnDataBreakpoint	: ()=> this.#isDbgBreak = true,
        //				continue				: ()=> this.#isDbgBreak = false,
        //				disconnect				: ()=> this.#isDbgBreak = false,
      };
      y.attach = y.stopOnEntry = y.stopOnStep = y.stopOnStepIn = y.stopOnStepOut = y.stopOnBackstep = y.pause, l.addHook((b) => y[b]?.());
    }
    hr(`
.sn_hint {
	background-color: #3c3225;
	color: white;
	padding: 4px 8px;
	border-radius: 4px;
	font-size: 1.2em;
	z-index: 10000;
	pointer-events: none;
	user-select: none;
}

.sn_hint_ar,
.sn_hint_ar::before {
	position: absolute;
	width: 8px;
	height: 8px;
	background: inherit;
}
.sn_hint_ar {
	visibility: hidden;
}
.sn_hint_ar::before {
	visibility: visible;
	content: '';
	transform: rotate(45deg);
}

.sn_hint[data-popper-placement^='top']		> .sn_hint_ar {bottom: -4px;}
.sn_hint[data-popper-placement^='bottom']	> .sn_hint_ar {top: -4px;}
.sn_hint[data-popper-placement^='left']		> .sn_hint_ar {right: -4px;}
.sn_hint[data-popper-placement^='right']	> .sn_hint_ar {left: -4px;}
`), n.cvs.parentElement?.insertAdjacentHTML("beforeend", `
<div class="sn_hint" role="tooltip">
	<span>Dummy</span>
	<div class="sn_hint_ar" data-popper-arrow></div>
</div>`), this.#v = document.querySelector(".sn_hint"), this.#_ = this.#v.querySelector("span"), this.#p = yg(this.#c, this.#v), this.#v.hidden = !0, i.stage.interactive = !0, this.#e.add(document.body, Ie, (y) => this.#a(y)), this.#e.add(document.body, "keyup", () => j.resetFired()), this.#e.add(n.cvs, "contextmenu", (y) => {
      const b = this.#h(y) + "rightclick";
      D.fire(b, y, !0), y.preventDefault();
    });
    const u = t.oCfg.window.width, c = t.oCfg.window.height, f = Math.floor(u > c ? c / 3 : u / 3);
    this.#i = new Hn(n.cvs, {
      velocityThreshold: 0,
      disregardVelocityThreshold: (y) => Math.floor(f * (y === "x" ? 1 : 0.5))
    });
    let d = !1;
    this.#i.on("tap", (y) => {
      if (d) return;
      if (y instanceof TouchEvent) {
        D.fire("click", y, !0), j.resetFired();
        return;
      }
      if (y.button > 1) return;
      const b = this.#h(y) + `${this.#n.get(y.button) ?? ""}click`;
      D.fire(b, y, !0), j.resetFired();
    }), this.#e.add(window, "pointerup", () => j.resetFired()), this.#e.add(window, "pointerout", () => j.resetFired()), this.#i.on("longpress", (y) => {
      if (d = !0, y instanceof TouchEvent) {
        D.fire("longpress", y, !0);
        return;
      }
      const b = this.#h(y) + `${this.#n.get(y.button) ?? ""}longpress`;
      D.fire(b, y, !0);
    }), this.#i.on("panend", () => {
      d && queueMicrotask(() => d = !1);
    }), [
      "swiperight",
      "swipeleft",
      "swipeup",
      "swipedown"
    ].forEach((y) => {
      this.#i.on(y, (b) => {
        if (b instanceof TouchEvent) {
          D.fire(y, b, !0);
          return;
        }
        const P = this.#h(b) + y;
        D.fire(P, b, !0);
      });
    });
    const p = () => o.setVal_Nochk("tmp", "const.sn.navigator.language", navigator.language);
    this.#e.add(globalThis, "languagechange", (y) => {
      p(), D.fire("sn:chgNavLang", y), Dh();
    }), p();
    const v = (y) => {
      A.isDarkMode = y.matches, o.setVal_Nochk("tmp", "const.sn.isDarkMode", A.isDarkMode);
    }, _ = globalThis.matchMedia("(prefers-color-scheme: dark)");
    v(_), this.#e.add(_, "change", (y) => {
      v(y), D.fire("sn:chgDarkMode", y);
    });
    let m = (y, b) => {
    };
    "WheelEvent" in globalThis && (this.#e.add(n.cvs, "wheel", (y) => this.#d(y), { passive: !0 }), this.#r = (y) => this.#e.add(y, "wheel", (b) => this.#d(b), { passive: !0 }), m = (y, b) => y.add(n.cvs, "wheel", (P) => {
      P.isComposing || P.deltaY <= 0 || (P.stopPropagation(), b());
    })), D.init(t, e, n, o, h, s, this, a, m), import("./gamepad.js").then((y) => y.g).then(({ GamepadListener: y }) => {
      const b = new y({
        analog: !1,
        deadZone: 0.3
      });
      A.debugLog && (b.on("gamepad:connected", (T) => console.log(`👺<'gamepad:connected' index:${T.detail.index} id:${T.detail.gamepad.id}`)), b.on("gamepad:disconnected", (T) => console.log(`👺<'gamepad:disconnected' index:${T.detail.index} id:${T.detail.gamepad?.id}`)));
      const P = [
        "",
        "ArrowUp",
        "",
        // '7', '8', '9',
        "ArrowLeft",
        "",
        "ArrowRight",
        // '4', '5', '6',
        "",
        "ArrowDown",
        ""
        // '1', '2', '3',
      ], x = [0, 0];
      b.on("gamepad:axis", (T) => {
        if (!document.hasFocus()) return;
        x[T.detail.axis] = T.detail.value;
        const [I = 0, w = 0] = x, O = (w + 1) * 3 + (I + 1), R = P[O];
        if (!R) return;
        const U = this.#t.getFocus();
        (!U || U instanceof Ct ? globalThis : U).dispatchEvent(new KeyboardEvent(Ie, { key: R, bubbles: !0 })), !(!U || U instanceof Ct) && (D.cancelAutoSkip(), U.getAttribute("type") === "range" && U.dispatchEvent(new InputEvent("input", { bubbles: !0 })));
      }), b.on("gamepad:button", (T) => {
        if (document.hasFocus())
          if (T.detail.button % 2 === 0) {
            D.cancelAutoSkip();
            const I = this.#t.getFocus();
            (!I || I instanceof Ct ? document.body : I).dispatchEvent(new KeyboardEvent(Ie, { key: "Enter", bubbles: !0 }));
          } else D.fire("middleclick", T, !0);
      }), b.start();
    }), this.#e.add(document, "keyup", (y) => {
      y.isComposing || y.key in this.#o && (this.#o[y.key] = 0);
    }), o.defTmp(
      "const.sn.key.alternate",
      () => this.#o.Alt > 0
      /* NO_PUSH */
    ), o.defTmp(
      "const.sn.key.command",
      () => this.#o.Meta > 0
      /* NO_PUSH */
    ), o.defTmp(
      "const.sn.key.control",
      () => this.#o.Control > 0
      /* NO_PUSH */
    ), o.defTmp(
      "const.sn.key.end",
      () => this.#o.End > 0
      /* NO_PUSH */
    ), o.defTmp(
      "const.sn.key.escape",
      () => this.#o.Escape > 0
      /* NO_PUSH */
    ), o.defTmp(
      "const.sn.key.back",
      () => this.#o.GoBack > 0
      /* NO_PUSH */
    );
  }
  #e = new Wi();
  #t = new fy();
  #i;
  #n = /* @__PURE__ */ new Map([
    [0, ""],
    [1, "middle"]
    // [2, 'right'],
  ]);
  resvFlameEvent(t) {
    this.#e.add(t, Ie, (e) => this.#a(e)), this.#e.add(t, "contextmenu", (e) => {
      D.fire(this.#h(e) + "rightclick", e, !0), e.preventDefault();
    }), this.#r(t), this.#e.add(t, Or, (e) => {
      if (e instanceof TouchEvent) {
        D.fire("click", e, !0);
        return;
      }
      if (e.button > 1) return;
      const i = this.#h(e) + `${this.#n.get(e.button) ?? ""}click`;
      D.fire(i, e, !0);
    }), this.#e.add(t, "pointerup", () => j.resetFired()), this.#e.add(t, "pointerout", () => j.resetFired());
  }
  #r = (t) => {
  };
  #a(t) {
    t.isComposing || (t.key in this.#o && (this.#o[t.key] = t.repeat ? 2 : 1), t.preventDefault(), D.fire(Ui.modKey(t) + t.key, t, !0));
  }
  #h(t) {
    return (t.altKey ? "alt+" : "") + (t.ctrlKey ? "ctrl+" : "") + (t.metaKey ? "meta+" : "") + (t.shiftKey ? "shift+" : "");
  }
  // 縦回転ホイール
  #d(t) {
    if (this.#l) {
      this.#f = !0;
      return;
    }
    this.#l = !0, this.#s();
    const e = this.#h(t) + (t.deltaY > 0 ? "downwheel" : "upwheel");
    D.fire(e, t, !0);
  }
  #l = !1;
  #f = !1;
  #s() {
    setTimeout(() => {
      if (this.#f) {
        this.#f = !1, this.#s();
        return;
      }
      this.#l = !1;
    }, 250);
  }
  destroy() {
    for (const t of Array.from(document.getElementsByClassName("sn_hint"))) t.parentElement?.removeChild(t);
    this.#i.destroy(), j.destroy(), this.#t.destroy(), this.#e.clear();
  }
  unButton(t) {
    this.#t.remove(t);
  }
  button(t, e, i, n, s) {
    !t.fn && !t.label && !t.url && this.main.errScript("fnまたはlabelまたはurlは必須です"), t.fn ??= this.scrItr.scriptFn, e.interactive = !0, e.cursor = "pointer";
    const o = t.key?.toLowerCase() ?? " ", a = $(t, "global", !1);
    j.setEvt2Fnc(a, o, () => this.main.resumeByJumpOrCall(t)), e.on(Bl, ({ data: c }) => {
      const f = c.originalEvent;
      f.preventDefault(), j.isFirstFire() && D.fire(o, f, !0);
    });
    const h = t.hint ? () => this.#u(t, e) : () => {
    }, l = () => {
      i(), this.#v.hidden = !0;
    }, u = () => (h(), n());
    if (e.on("pointerover", u), e.on("pointerout", () => {
      this.#t.isFocus(e) ? u() : l();
    }), e.on("pointerdown", () => {
      this.#v.hidden = !0;
      const c = this.#t.getFocus();
      s(), c instanceof le && c.normal();
    }), e.on(
      "pointerup",
      A.isMobile ? l : () => {
        this.#t.isFocus(e) ? u() : l();
      }
    ), this.#t.add(e, u, l), t.clickse && (t.clicksebuf ??= "SYS", this.cfg.searchPath(t.clickse, qt.SOUND), e.on("pointerdown", () => {
      this.hTag.playse({ fn: t.clickse, buf: t.clicksebuf, join: !1 });
    })), t.enterse && (t.entersebuf ??= "SYS", this.cfg.searchPath(t.enterse, qt.SOUND), e.on("pointerover", () => {
      this.hTag.playse({ fn: t.enterse, buf: t.entersebuf, join: !1 });
    })), t.leavese && (t.leavesebuf ??= "SYS", this.cfg.searchPath(t.leavese, qt.SOUND), e.on("pointerout", () => {
      this.hTag.playse({ fn: t.leavese, buf: t.leavesebuf, join: !1 });
    })), t.onenter) {
      const c = o + t.onenter.toLowerCase(), f = { fn: t.fn, label: t.onenter, call: !0, key: c };
      j.setEvt2Fnc(a, c, () => this.main.resumeByJumpOrCall(f)), e.on("pointerover", (d) => D.fire(c, d));
    }
    if (t.onleave) {
      const c = o + t.onleave.toLowerCase(), f = { fn: t.fn, label: t.onleave, call: !0, key: c };
      j.setEvt2Fnc(a, c, () => this.main.resumeByJumpOrCall(f)), e.on("pointerout", (d) => D.fire(c, d));
    }
  }
  #c = {
    getBoundingClientRect: (t = 0, e = 0) => DOMRect.fromRect({ x: t, y: e, width: 0, height: 0 })
  };
  #v;
  #_;
  #p;
  #y = {
    placement: "bottom",
    modifiers: [
      {
        // Flip | Popper https://popper.js.org/docs/v2/modifiers/flip/
        name: "flip",
        options: {
          fallbackPlacements: ["top", "bottom"]
        }
      }
    ]
  };
  #u(t, e) {
    const i = e instanceof le ? e.getBtnBounds() : e.getBounds();
    if (!(t[":タグ名"] === "link")) {
      const s = e.parent.parent;
      i.x += s.x, i.y += s.y;
    }
    if (!t.hint) {
      this.#v.hidden = !0;
      return;
    }
    this.#v.style.cssText = `position:${this.#v.style.position}; transform:${this.#v.style.transform};` + (t.hint_style ?? ""), this.#_.style.cssText = "", this.#_.textContent = t.hint ?? "";
    try {
      const s = t.hint_opt ? { ...this.#y, ...JSON.parse(t.hint_opt) } : this.#y;
      this.#p.setOptions(s);
    } catch (s) {
      console.error(un(
        t,
        "hint_opt",
        `dispHint 引数 hint_opt エラー ${s instanceof SyntaxError ? s.message : ""}`
      ));
    }
    this.#c.getBoundingClientRect = () => DOMRect.fromRect({
      x: this.sys.ofsLeft4elm + i.x * this.sys.cvsScale,
      y: this.sys.ofsTop4elm + i.y * this.sys.cvsScale,
      width: i.width,
      height: i.height
    }), this.#p.update(), this.#v.hidden = !1;
  }
  hideHint() {
    this.#v.hidden = !0;
  }
  cvsResize() {
    this.hideHint();
  }
  #C(t) {
    const e = t.key;
    if (!e) throw "keyは必須です";
    const i = e.toLowerCase(), n = $(t, "call", !1), s = $(t, "global", !1), { fn: o, label: a, url: h } = t;
    if ($(t, "del", !1)) {
      if (o || a || n || h) throw "fn/label/callとdelは同時指定できません";
      return j.clear_eventer(e, s, i), !1;
    }
    if (!o && !a && !h) throw "fn,label,url いずれかは必須です";
    if (t.fn ??= this.scrItr.scriptFn, e.startsWith("dom=")) {
      const l = j.getHtmlElmList(e);
      if (l.el.length === 0) {
        if ($(t, "need_err", !0)) throw `HTML内にセレクタ（${l.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;
        return !1;
      }
      let u = ["click", Ie];
      switch (l.el[0].type ?? "") {
        //	switch (g.el[0].getAttribute('type') ?? '') { textareaで''になる
        case "checkbox":
          u = ["input"];
          break;
        case "range":
          u = ["input"];
          break;
        case "text":
        case "textarea":
          u = ["input", "change"];
          break;
      }
      const f = u.length;
      for (let d = 0; d < f; ++d) {
        const p = u[d];
        l.el.forEach((v) => {
          this.#e.add(v, p, (_) => {
            if (!D.isWait || this.layMng.getFrmDisabled(l.id) || p === Ie && _.key !== "Enter") return;
            const m = v.dataset;
            for (const [y, b] of Object.entries(m)) this.val.setVal_Nochk("tmp", `sn.event.domdata.${y}`, b);
            D.fire(e, _);
          }), d === 0 && this.#t.add(
            v,
            () => this.#g(v) ? (v.focus(), !0) : !1,
            () => {
            }
          );
        });
      }
    }
    return j.setEvt2Fnc(s, i, () => this.main.resumeByJumpOrCall(t)), !1;
  }
  #g(t) {
    if (t.offsetParent === null) return !1;
    let e = t;
    do {
      if (getComputedStyle(e).display === "none" || e.dataset.focus === "false" || e?.disabled) return !1;
      e = e.parentElement;
    } while (e !== null);
    return !0;
  }
  // フォーカス移動
  #m(t) {
    const { add: e, del: i, to: n } = t;
    if (e?.startsWith("dom=")) {
      const s = j.getHtmlElmList(e);
      if (s.el.length === 0 && $(t, "need_err", !0)) throw `HTML内にセレクタ（${s.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;
      return s.el.forEach((o) => this.#t.add(
        o,
        () => this.#g(o) ? (o.focus(), !0) : !1,
        () => {
        }
      )), !1;
    }
    if (i?.startsWith("dom=")) {
      const s = j.getHtmlElmList(i);
      if (s.el.length === 0 && $(t, "need_err", !0)) throw `HTML内にセレクタ（${s.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;
      return s.el.forEach((o) => this.#t.remove(o)), !1;
    }
    if (!n) throw "[set_focus] add か to は必須です";
    switch (n) {
      case "null":
        this.#t.blur();
        break;
      case "next":
        this.#t.next();
        break;
      case "prev":
        this.#t.prev();
        break;
    }
    return !1;
  }
  // キー押しっぱなしスキップ中か
  get isSkipping() {
    return D.isSkipping ? !0 : Object.keys(this.#o).some(
      (t) => this.#o[t] === 2
      /* PUSH_REPEATING */
    );
  }
  // 0:no push  1:one push  2:push repeating
  #o = {
    Alt: 0,
    Meta: 0,
    // COMMANDキー
    Control: 0,
    ArrowDown: 0,
    End: 0,
    Enter: 0,
    Escape: 0,
    " ": 0,
    GoBack: 0
    /* NO_PUSH */
    // AndroidのBackキーだと思う
  };
}
const bg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EVNM_BUTTON: Bl,
  EVNM_CLICK: Or,
  EVNM_KEY: Ie,
  EventMng: gg
}, Symbol.toStringTag, { value: "Module" })), Be = /* @__PURE__ */ Object.create(null);
Be.open = "0";
Be.close = "1";
Be.ping = "2";
Be.pong = "3";
Be.message = "4";
Be.upgrade = "5";
Be.noop = "6";
const gn = /* @__PURE__ */ Object.create(null);
Object.keys(Be).forEach((r) => {
  gn[Be[r]] = r;
});
const bo = { type: "error", data: "parser error" }, Ul = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", Gl = typeof ArrayBuffer == "function", jl = (r) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(r) : r && r.buffer instanceof ArrayBuffer, $o = ({ type: r, data: t }, e, i) => Ul && t instanceof Blob ? e ? i(t) : mh(t, i) : Gl && (t instanceof ArrayBuffer || jl(t)) ? e ? i(t) : mh(new Blob([t]), i) : i(Be[r] + (t || "")), mh = (r, t) => {
  const e = new FileReader();
  return e.onload = function() {
    const i = e.result.split(",")[1];
    t("b" + (i || ""));
  }, e.readAsDataURL(r);
};
function yh(r) {
  return r instanceof Uint8Array ? r : r instanceof ArrayBuffer ? new Uint8Array(r) : new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
}
let Cs;
function xg(r, t) {
  if (Ul && r.data instanceof Blob)
    return r.data.arrayBuffer().then(yh).then(t);
  if (Gl && (r.data instanceof ArrayBuffer || jl(r.data)))
    return t(yh(r.data));
  $o(r, !1, (e) => {
    Cs || (Cs = new TextEncoder()), t(Cs.encode(e));
  });
}
const gh = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ar = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let r = 0; r < gh.length; r++)
  ar[gh.charCodeAt(r)] = r;
const wg = (r) => {
  let t = r.length * 0.75, e = r.length, i, n = 0, s, o, a, h;
  r[r.length - 1] === "=" && (t--, r[r.length - 2] === "=" && t--);
  const l = new ArrayBuffer(t), u = new Uint8Array(l);
  for (i = 0; i < e; i += 4)
    s = ar[r.charCodeAt(i)], o = ar[r.charCodeAt(i + 1)], a = ar[r.charCodeAt(i + 2)], h = ar[r.charCodeAt(i + 3)], u[n++] = s << 2 | o >> 4, u[n++] = (o & 15) << 4 | a >> 2, u[n++] = (a & 3) << 6 | h & 63;
  return l;
}, Tg = typeof ArrayBuffer == "function", zo = (r, t) => {
  if (typeof r != "string")
    return {
      type: "message",
      data: Hl(r, t)
    };
  const e = r.charAt(0);
  return e === "b" ? {
    type: "message",
    data: Eg(r.substring(1), t)
  } : gn[e] ? r.length > 1 ? {
    type: gn[e],
    data: r.substring(1)
  } : {
    type: gn[e]
  } : bo;
}, Eg = (r, t) => {
  if (Tg) {
    const e = wg(r);
    return Hl(e, t);
  } else
    return { base64: !0, data: r };
}, Hl = (r, t) => {
  switch (t) {
    case "blob":
      return r instanceof Blob ? r : new Blob([r]);
    case "arraybuffer":
    default:
      return r instanceof ArrayBuffer ? r : r.buffer;
  }
}, $l = "", Sg = (r, t) => {
  const e = r.length, i = new Array(e);
  let n = 0;
  r.forEach((s, o) => {
    $o(s, !1, (a) => {
      i[o] = a, ++n === e && t(i.join($l));
    });
  });
}, Pg = (r, t) => {
  const e = r.split($l), i = [];
  for (let n = 0; n < e.length; n++) {
    const s = zo(e[n], t);
    if (i.push(s), s.type === "error")
      break;
  }
  return i;
};
function Cg() {
  return new TransformStream({
    transform(r, t) {
      xg(r, (e) => {
        const i = e.length;
        let n;
        if (i < 126)
          n = new Uint8Array(1), new DataView(n.buffer).setUint8(0, i);
        else if (i < 65536) {
          n = new Uint8Array(3);
          const s = new DataView(n.buffer);
          s.setUint8(0, 126), s.setUint16(1, i);
        } else {
          n = new Uint8Array(9);
          const s = new DataView(n.buffer);
          s.setUint8(0, 127), s.setBigUint64(1, BigInt(i));
        }
        r.data && typeof r.data != "string" && (n[0] |= 128), t.enqueue(n), t.enqueue(e);
      });
    }
  });
}
let Is;
function an(r) {
  return r.reduce((t, e) => t + e.length, 0);
}
function hn(r, t) {
  if (r[0].length === t)
    return r.shift();
  const e = new Uint8Array(t);
  let i = 0;
  for (let n = 0; n < t; n++)
    e[n] = r[0][i++], i === r[0].length && (r.shift(), i = 0);
  return r.length && i < r[0].length && (r[0] = r[0].slice(i)), e;
}
function Ig(r, t) {
  Is || (Is = new TextDecoder());
  const e = [];
  let i = 0, n = -1, s = !1;
  return new TransformStream({
    transform(o, a) {
      for (e.push(o); ; ) {
        if (i === 0) {
          if (an(e) < 1)
            break;
          const h = hn(e, 1);
          s = (h[0] & 128) === 128, n = h[0] & 127, n < 126 ? i = 3 : n === 126 ? i = 1 : i = 2;
        } else if (i === 1) {
          if (an(e) < 2)
            break;
          const h = hn(e, 2);
          n = new DataView(h.buffer, h.byteOffset, h.length).getUint16(0), i = 3;
        } else if (i === 2) {
          if (an(e) < 8)
            break;
          const h = hn(e, 8), l = new DataView(h.buffer, h.byteOffset, h.length), u = l.getUint32(0);
          if (u > Math.pow(2, 21) - 1) {
            a.enqueue(bo);
            break;
          }
          n = u * Math.pow(2, 32) + l.getUint32(4), i = 3;
        } else {
          if (an(e) < n)
            break;
          const h = hn(e, n);
          a.enqueue(zo(s ? h : Is.decode(h), t)), i = 0;
        }
        if (n === 0 || n > r) {
          a.enqueue(bo);
          break;
        }
      }
    }
  });
}
const zl = 4;
function $t(r) {
  if (r) return Og(r);
}
function Og(r) {
  for (var t in $t.prototype)
    r[t] = $t.prototype[t];
  return r;
}
$t.prototype.on = $t.prototype.addEventListener = function(r, t) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + r] = this._callbacks["$" + r] || []).push(t), this;
};
$t.prototype.once = function(r, t) {
  function e() {
    this.off(r, e), t.apply(this, arguments);
  }
  return e.fn = t, this.on(r, e), this;
};
$t.prototype.off = $t.prototype.removeListener = $t.prototype.removeAllListeners = $t.prototype.removeEventListener = function(r, t) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var e = this._callbacks["$" + r];
  if (!e) return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + r], this;
  for (var i, n = 0; n < e.length; n++)
    if (i = e[n], i === t || i.fn === t) {
      e.splice(n, 1);
      break;
    }
  return e.length === 0 && delete this._callbacks["$" + r], this;
};
$t.prototype.emit = function(r) {
  this._callbacks = this._callbacks || {};
  for (var t = new Array(arguments.length - 1), e = this._callbacks["$" + r], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  if (e) {
    e = e.slice(0);
    for (var i = 0, n = e.length; i < n; ++i)
      e[i].apply(this, t);
  }
  return this;
};
$t.prototype.emitReserved = $t.prototype.emit;
$t.prototype.listeners = function(r) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + r] || [];
};
$t.prototype.hasListeners = function(r) {
  return !!this.listeners(r).length;
};
const $n = typeof Promise == "function" && typeof Promise.resolve == "function" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0), he = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")(), Mg = "arraybuffer";
function Xl(r, ...t) {
  return t.reduce((e, i) => (r.hasOwnProperty(i) && (e[i] = r[i]), e), {});
}
const Rg = he.setTimeout, kg = he.clearTimeout;
function zn(r, t) {
  t.useNativeTimers ? (r.setTimeoutFn = Rg.bind(he), r.clearTimeoutFn = kg.bind(he)) : (r.setTimeoutFn = he.setTimeout.bind(he), r.clearTimeoutFn = he.clearTimeout.bind(he));
}
const Ng = 1.33;
function Ag(r) {
  return typeof r == "string" ? Dg(r) : Math.ceil((r.byteLength || r.size) * Ng);
}
function Dg(r) {
  let t = 0, e = 0;
  for (let i = 0, n = r.length; i < n; i++)
    t = r.charCodeAt(i), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (i++, e += 4);
  return e;
}
function Vl() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function Lg(r) {
  let t = "";
  for (let e in r)
    r.hasOwnProperty(e) && (t.length && (t += "&"), t += encodeURIComponent(e) + "=" + encodeURIComponent(r[e]));
  return t;
}
function Fg(r) {
  let t = {}, e = r.split("&");
  for (let i = 0, n = e.length; i < n; i++) {
    let s = e[i].split("=");
    t[decodeURIComponent(s[0])] = decodeURIComponent(s[1]);
  }
  return t;
}
class Bg extends Error {
  constructor(t, e, i) {
    super(t), this.description = e, this.context = i, this.type = "TransportError";
  }
}
class Xo extends $t {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(t) {
    super(), this.writable = !1, zn(this, t), this.opts = t, this.query = t.query, this.socket = t.socket, this.supportsBinary = !t.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(t, e, i) {
    return super.emitReserved("error", new Bg(t, e, i)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(t) {
    this.readyState === "open" && this.write(t);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(t) {
    const e = zo(t, this.socket.binaryType);
    this.onPacket(e);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(t) {
    super.emitReserved("packet", t);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(t) {
    this.readyState = "closed", super.emitReserved("close", t);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(t) {
  }
  createUri(t, e = {}) {
    return t + "://" + this._hostname() + this._port() + this.opts.path + this._query(e);
  }
  _hostname() {
    const t = this.opts.hostname;
    return t.indexOf(":") === -1 ? t : "[" + t + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(t) {
    const e = Lg(t);
    return e.length ? "?" + e : "";
  }
}
class Ug extends Xo {
  constructor() {
    super(...arguments), this._polling = !1;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(t) {
    this.readyState = "pausing";
    const e = () => {
      this.readyState = "paused", t();
    };
    if (this._polling || !this.writable) {
      let i = 0;
      this._polling && (i++, this.once("pollComplete", function() {
        --i || e();
      })), this.writable || (i++, this.once("drain", function() {
        --i || e();
      }));
    } else
      e();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(t) {
    const e = (i) => {
      if (this.readyState === "opening" && i.type === "open" && this.onOpen(), i.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(i);
    };
    Pg(t, this.socket.binaryType).forEach(e), this.readyState !== "closed" && (this._polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const t = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? t() : this.once("open", t);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(t) {
    this.writable = !1, Sg(t, (e) => {
      this.doWrite(e, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "https" : "http", e = this.query || {};
    return this.opts.timestampRequests !== !1 && (e[this.opts.timestampParam] = Vl()), !this.supportsBinary && !e.sid && (e.b64 = 1), this.createUri(t, e);
  }
}
let Wl = !1;
try {
  Wl = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const Gg = Wl;
function jg() {
}
class Hg extends Ug {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(t) {
    if (super(t), typeof location < "u") {
      const e = location.protocol === "https:";
      let i = location.port;
      i || (i = e ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || i !== t.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(t, e) {
    const i = this.request({
      method: "POST",
      data: t
    });
    i.on("success", e), i.on("error", (n, s) => {
      this.onError("xhr post error", n, s);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const t = this.request();
    t.on("data", this.onData.bind(this)), t.on("error", (e, i) => {
      this.onError("xhr poll error", e, i);
    }), this.pollXhr = t;
  }
}
class De extends $t {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(t, e, i) {
    super(), this.createRequest = t, zn(this, i), this._opts = i, this._method = i.method || "GET", this._uri = e, this._data = i.data !== void 0 ? i.data : null, this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var t;
    const e = Xl(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    e.xdomain = !!this._opts.xd;
    const i = this._xhr = this.createRequest(e);
    try {
      i.open(this._method, this._uri, !0);
      try {
        if (this._opts.extraHeaders) {
          i.setDisableHeaderCheck && i.setDisableHeaderCheck(!0);
          for (let n in this._opts.extraHeaders)
            this._opts.extraHeaders.hasOwnProperty(n) && i.setRequestHeader(n, this._opts.extraHeaders[n]);
        }
      } catch {
      }
      if (this._method === "POST")
        try {
          i.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        i.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (t = this._opts.cookieJar) === null || t === void 0 || t.addCookies(i), "withCredentials" in i && (i.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (i.timeout = this._opts.requestTimeout), i.onreadystatechange = () => {
        var n;
        i.readyState === 3 && ((n = this._opts.cookieJar) === null || n === void 0 || n.parseCookies(
          // @ts-ignore
          i.getResponseHeader("set-cookie")
        )), i.readyState === 4 && (i.status === 200 || i.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => {
          this._onError(typeof i.status == "number" ? i.status : 0);
        }, 0));
      }, i.send(this._data);
    } catch (n) {
      this.setTimeoutFn(() => {
        this._onError(n);
      }, 0);
      return;
    }
    typeof document < "u" && (this._index = De.requestsCount++, De.requests[this._index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(t) {
    this.emitReserved("error", t, this._xhr), this._cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(t) {
    if (!(typeof this._xhr > "u" || this._xhr === null)) {
      if (this._xhr.onreadystatechange = jg, t)
        try {
          this._xhr.abort();
        } catch {
        }
      typeof document < "u" && delete De.requests[this._index], this._xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const t = this._xhr.responseText;
    t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this._cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
}
De.requestsCount = 0;
De.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", bh);
  else if (typeof addEventListener == "function") {
    const r = "onpagehide" in he ? "pagehide" : "unload";
    addEventListener(r, bh, !1);
  }
}
function bh() {
  for (let r in De.requests)
    De.requests.hasOwnProperty(r) && De.requests[r].abort();
}
const $g = function() {
  const r = Yl({
    xdomain: !1
  });
  return r && r.responseType !== null;
}();
class zg extends Hg {
  constructor(t) {
    super(t);
    const e = t && t.forceBase64;
    this.supportsBinary = $g && !e;
  }
  request(t = {}) {
    return Object.assign(t, { xd: this.xd }, this.opts), new De(Yl, this.uri(), t);
  }
}
function Yl(r) {
  const t = r.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!t || Gg))
      return new XMLHttpRequest();
  } catch {
  }
  if (!t)
    try {
      return new he[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
const ql = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class Xg extends Xo {
  get name() {
    return "websocket";
  }
  doOpen() {
    const t = this.uri(), e = this.opts.protocols, i = ql ? {} : Xl(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (i.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(t, e, i);
    } catch (n) {
      return this.emitReserved("error", n);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const i = t[e], n = e === t.length - 1;
      $o(i, this.supportsBinary, (s) => {
        try {
          this.doWrite(i, s);
        } catch {
        }
        n && $n(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.onerror = () => {
    }, this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "wss" : "ws", e = this.query || {};
    return this.opts.timestampRequests && (e[this.opts.timestampParam] = Vl()), this.supportsBinary || (e.b64 = 1), this.createUri(t, e);
  }
}
const Os = he.WebSocket || he.MozWebSocket;
class Vg extends Xg {
  createSocket(t, e, i) {
    return ql ? new Os(t, e, i) : e ? new Os(t, e) : new Os(t);
  }
  doWrite(t, e) {
    this.ws.send(e);
  }
}
class Wg extends Xo {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (t) {
      return this.emitReserved("error", t);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((t) => {
      this.onError("webtransport error", t);
    }), this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((t) => {
        const e = Ig(Number.MAX_SAFE_INTEGER, this.socket.binaryType), i = t.readable.pipeThrough(e).getReader(), n = Cg();
        n.readable.pipeTo(t.writable), this._writer = n.writable.getWriter();
        const s = () => {
          i.read().then(({ done: a, value: h }) => {
            a || (this.onPacket(h), s());
          }).catch((a) => {
          });
        };
        s();
        const o = { type: "open" };
        this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`), this._writer.write(o).then(() => this.onOpen());
      });
    });
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const i = t[e], n = e === t.length - 1;
      this._writer.write(i).then(() => {
        n && $n(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var t;
    (t = this._transport) === null || t === void 0 || t.close();
  }
}
const Yg = {
  websocket: Vg,
  webtransport: Wg,
  polling: zg
}, qg = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, Zg = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function xo(r) {
  if (r.length > 8e3)
    throw "URI too long";
  const t = r, e = r.indexOf("["), i = r.indexOf("]");
  e != -1 && i != -1 && (r = r.substring(0, e) + r.substring(e, i).replace(/:/g, ";") + r.substring(i, r.length));
  let n = qg.exec(r || ""), s = {}, o = 14;
  for (; o--; )
    s[Zg[o]] = n[o] || "";
  return e != -1 && i != -1 && (s.source = t, s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ":"), s.authority = s.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), s.ipv6uri = !0), s.pathNames = Kg(s, s.path), s.queryKey = Jg(s, s.query), s;
}
function Kg(r, t) {
  const e = /\/{2,9}/g, i = t.replace(e, "/").split("/");
  return (t.slice(0, 1) == "/" || t.length === 0) && i.splice(0, 1), t.slice(-1) == "/" && i.splice(i.length - 1, 1), i;
}
function Jg(r, t) {
  const e = {};
  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(i, n, s) {
    n && (e[n] = s);
  }), e;
}
const wo = typeof addEventListener == "function" && typeof removeEventListener == "function", bn = [];
wo && addEventListener("offline", () => {
  bn.forEach((r) => r());
}, !1);
class li extends $t {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(t, e) {
    if (super(), this.binaryType = Mg, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, t && typeof t == "object" && (e = t, t = null), t) {
      const i = xo(t);
      e.hostname = i.host, e.secure = i.protocol === "https" || i.protocol === "wss", e.port = i.port, i.query && (e.query = i.query);
    } else e.host && (e.hostname = xo(e.host).host);
    zn(this, e), this.secure = e.secure != null ? e.secure : typeof location < "u" && location.protocol === "https:", e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.hostname = e.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = e.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, e.transports.forEach((i) => {
      const n = i.prototype.name;
      this.transports.push(n), this._transportsByName[n] = i;
    }), this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, e), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = Fg(this.opts.query)), wo && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this._offlineEventListener = () => {
      this._onClose("transport close", {
        description: "network connection lost"
      });
    }, bn.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(t) {
    const e = Object.assign({}, this.opts.query);
    e.EIO = zl, e.transport = t, this.id && (e.sid = this.id);
    const i = Object.assign({}, this.opts, {
      query: e,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[t]);
    return new this._transportsByName[t](i);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const t = this.opts.rememberUpgrade && li.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const e = this.createTransport(t);
    e.open(), this.setTransport(e);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(t) {
    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (e) => this._onClose("transport close", e));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open", li.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;
        case "ping":
          this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout();
          break;
        case "error":
          const e = new Error("server error");
          e.code = t.data, this._onError(e);
          break;
        case "message":
          this.emitReserved("data", t.data), this.emitReserved("message", t.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(t) {
    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this._pingInterval = t.pingInterval, this._pingTimeout = t.pingTimeout, this._maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const t = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + t, this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, t), this.opts.autoUnref && this._pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const t = this._getWritablePackets();
      this.transport.send(t), this._prevBufferLen = t.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let e = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const n = this.writeBuffer[i].data;
      if (n && (e += Ag(n)), i > 0 && e > this._maxPayload)
        return this.writeBuffer.slice(0, i);
      e += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return !0;
    const t = Date.now() > this._pingTimeoutTime;
    return t && (this._pingTimeoutTime = 0, $n(() => {
      this._onClose("ping timeout");
    }, this.setTimeoutFn)), t;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(t, e, i) {
    return this._sendPacket("message", t, e, i), this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(t, e, i) {
    return this._sendPacket("message", t, e, i), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(t, e, i, n) {
    if (typeof e == "function" && (n = e, e = void 0), typeof i == "function" && (n = i, i = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    i = i || {}, i.compress = i.compress !== !1;
    const s = {
      type: t,
      data: e,
      options: i
    };
    this.emitReserved("packetCreate", s), this.writeBuffer.push(s), n && this.once("flush", n), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const t = () => {
      this._onClose("forced close"), this.transport.close();
    }, e = () => {
      this.off("upgrade", e), this.off("upgradeError", e), t();
    }, i = () => {
      this.once("upgrade", e), this.once("upgradeError", e);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? i() : t();
    }) : this.upgrading ? i() : t()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(t) {
    if (li.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening")
      return this.transports.shift(), this._open();
    this.emitReserved("error", t), this._onClose("transport error", t);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(t, e) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), wo && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) {
        const i = bn.indexOf(this._offlineEventListener);
        i !== -1 && bn.splice(i, 1);
      }
      this.readyState = "closed", this.id = null, this.emitReserved("close", t, e), this.writeBuffer = [], this._prevBufferLen = 0;
    }
  }
}
li.protocol = zl;
class Qg extends li {
  constructor() {
    super(...arguments), this._upgrades = [];
  }
  onOpen() {
    if (super.onOpen(), this.readyState === "open" && this.opts.upgrade)
      for (let t = 0; t < this._upgrades.length; t++)
        this._probe(this._upgrades[t]);
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(t) {
    let e = this.createTransport(t), i = !1;
    li.priorWebsocketSuccess = !1;
    const n = () => {
      i || (e.send([{ type: "ping", data: "probe" }]), e.once("packet", (c) => {
        if (!i)
          if (c.type === "pong" && c.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", e), !e)
              return;
            li.priorWebsocketSuccess = e.name === "websocket", this.transport.pause(() => {
              i || this.readyState !== "closed" && (u(), this.setTransport(e), e.send([{ type: "upgrade" }]), this.emitReserved("upgrade", e), e = null, this.upgrading = !1, this.flush());
            });
          } else {
            const f = new Error("probe error");
            f.transport = e.name, this.emitReserved("upgradeError", f);
          }
      }));
    };
    function s() {
      i || (i = !0, u(), e.close(), e = null);
    }
    const o = (c) => {
      const f = new Error("probe error: " + c);
      f.transport = e.name, s(), this.emitReserved("upgradeError", f);
    };
    function a() {
      o("transport closed");
    }
    function h() {
      o("socket closed");
    }
    function l(c) {
      e && c.name !== e.name && s();
    }
    const u = () => {
      e.removeListener("open", n), e.removeListener("error", o), e.removeListener("close", a), this.off("close", h), this.off("upgrading", l);
    };
    e.once("open", n), e.once("error", o), e.once("close", a), this.once("close", h), this.once("upgrading", l), this._upgrades.indexOf("webtransport") !== -1 && t !== "webtransport" ? this.setTimeoutFn(() => {
      i || e.open();
    }, 200) : e.open();
  }
  onHandshake(t) {
    this._upgrades = this._filterUpgrades(t.upgrades), super.onHandshake(t);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(t) {
    const e = [];
    for (let i = 0; i < t.length; i++)
      ~this.transports.indexOf(t[i]) && e.push(t[i]);
    return e;
  }
}
let t0 = class extends Qg {
  constructor(t, e = {}) {
    const i = typeof t == "object" ? t : e;
    (!i.transports || i.transports && typeof i.transports[0] == "string") && (i.transports = (i.transports || ["polling", "websocket", "webtransport"]).map((n) => Yg[n]).filter((n) => !!n)), super(t, i);
  }
};
function e0(r, t = "", e) {
  let i = r;
  e = e || typeof location < "u" && location, r == null && (r = e.protocol + "//" + e.host), typeof r == "string" && (r.charAt(0) === "/" && (r.charAt(1) === "/" ? r = e.protocol + r : r = e.host + r), /^(https?|wss?):\/\//.test(r) || (typeof e < "u" ? r = e.protocol + "//" + r : r = "https://" + r), i = xo(r)), i.port || (/^(http|ws)$/.test(i.protocol) ? i.port = "80" : /^(http|ws)s$/.test(i.protocol) && (i.port = "443")), i.path = i.path || "/";
  const s = i.host.indexOf(":") !== -1 ? "[" + i.host + "]" : i.host;
  return i.id = i.protocol + "://" + s + ":" + i.port + t, i.href = i.protocol + "://" + s + (e && e.port === i.port ? "" : ":" + i.port), i;
}
const i0 = typeof ArrayBuffer == "function", r0 = (r) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(r) : r.buffer instanceof ArrayBuffer, Zl = Object.prototype.toString, n0 = typeof Blob == "function" || typeof Blob < "u" && Zl.call(Blob) === "[object BlobConstructor]", s0 = typeof File == "function" || typeof File < "u" && Zl.call(File) === "[object FileConstructor]";
function Vo(r) {
  return i0 && (r instanceof ArrayBuffer || r0(r)) || n0 && r instanceof Blob || s0 && r instanceof File;
}
function xn(r, t) {
  if (!r || typeof r != "object")
    return !1;
  if (Array.isArray(r)) {
    for (let e = 0, i = r.length; e < i; e++)
      if (xn(r[e]))
        return !0;
    return !1;
  }
  if (Vo(r))
    return !0;
  if (r.toJSON && typeof r.toJSON == "function" && arguments.length === 1)
    return xn(r.toJSON(), !0);
  for (const e in r)
    if (Object.prototype.hasOwnProperty.call(r, e) && xn(r[e]))
      return !0;
  return !1;
}
function o0(r) {
  const t = [], e = r.data, i = r;
  return i.data = To(e, t), i.attachments = t.length, { packet: i, buffers: t };
}
function To(r, t) {
  if (!r)
    return r;
  if (Vo(r)) {
    const e = { _placeholder: !0, num: t.length };
    return t.push(r), e;
  } else if (Array.isArray(r)) {
    const e = new Array(r.length);
    for (let i = 0; i < r.length; i++)
      e[i] = To(r[i], t);
    return e;
  } else if (typeof r == "object" && !(r instanceof Date)) {
    const e = {};
    for (const i in r)
      Object.prototype.hasOwnProperty.call(r, i) && (e[i] = To(r[i], t));
    return e;
  }
  return r;
}
function a0(r, t) {
  return r.data = Eo(r.data, t), delete r.attachments, r;
}
function Eo(r, t) {
  if (!r)
    return r;
  if (r && r._placeholder === !0) {
    if (typeof r.num == "number" && r.num >= 0 && r.num < t.length)
      return t[r.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(r))
    for (let e = 0; e < r.length; e++)
      r[e] = Eo(r[e], t);
  else if (typeof r == "object")
    for (const e in r)
      Object.prototype.hasOwnProperty.call(r, e) && (r[e] = Eo(r[e], t));
  return r;
}
const h0 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
], l0 = 5;
var mt;
(function(r) {
  r[r.CONNECT = 0] = "CONNECT", r[r.DISCONNECT = 1] = "DISCONNECT", r[r.EVENT = 2] = "EVENT", r[r.ACK = 3] = "ACK", r[r.CONNECT_ERROR = 4] = "CONNECT_ERROR", r[r.BINARY_EVENT = 5] = "BINARY_EVENT", r[r.BINARY_ACK = 6] = "BINARY_ACK";
})(mt || (mt = {}));
class u0 {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(t) {
    this.replacer = t;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(t) {
    return (t.type === mt.EVENT || t.type === mt.ACK) && xn(t) ? this.encodeAsBinary({
      type: t.type === mt.EVENT ? mt.BINARY_EVENT : mt.BINARY_ACK,
      nsp: t.nsp,
      data: t.data,
      id: t.id
    }) : [this.encodeAsString(t)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(t) {
    let e = "" + t.type;
    return (t.type === mt.BINARY_EVENT || t.type === mt.BINARY_ACK) && (e += t.attachments + "-"), t.nsp && t.nsp !== "/" && (e += t.nsp + ","), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(t) {
    const e = o0(t), i = this.encodeAsString(e.packet), n = e.buffers;
    return n.unshift(i), n;
  }
}
function xh(r) {
  return Object.prototype.toString.call(r) === "[object Object]";
}
class Wo extends $t {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(t) {
    super(), this.reviver = t;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(t) {
    let e;
    if (typeof t == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      e = this.decodeString(t);
      const i = e.type === mt.BINARY_EVENT;
      i || e.type === mt.BINARY_ACK ? (e.type = i ? mt.EVENT : mt.ACK, this.reconstructor = new c0(e), e.attachments === 0 && super.emitReserved("decoded", e)) : super.emitReserved("decoded", e);
    } else if (Vo(t) || t.base64)
      if (this.reconstructor)
        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved("decoded", e));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + t);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(t) {
    let e = 0;
    const i = {
      type: Number(t.charAt(0))
    };
    if (mt[i.type] === void 0)
      throw new Error("unknown packet type " + i.type);
    if (i.type === mt.BINARY_EVENT || i.type === mt.BINARY_ACK) {
      const s = e + 1;
      for (; t.charAt(++e) !== "-" && e != t.length; )
        ;
      const o = t.substring(s, e);
      if (o != Number(o) || t.charAt(e) !== "-")
        throw new Error("Illegal attachments");
      i.attachments = Number(o);
    }
    if (t.charAt(e + 1) === "/") {
      const s = e + 1;
      for (; ++e && !(t.charAt(e) === "," || e === t.length); )
        ;
      i.nsp = t.substring(s, e);
    } else
      i.nsp = "/";
    const n = t.charAt(e + 1);
    if (n !== "" && Number(n) == n) {
      const s = e + 1;
      for (; ++e; ) {
        const o = t.charAt(e);
        if (o == null || Number(o) != o) {
          --e;
          break;
        }
        if (e === t.length)
          break;
      }
      i.id = Number(t.substring(s, e + 1));
    }
    if (t.charAt(++e)) {
      const s = this.tryParse(t.substr(e));
      if (Wo.isPayloadValid(i.type, s))
        i.data = s;
      else
        throw new Error("invalid payload");
    }
    return i;
  }
  tryParse(t) {
    try {
      return JSON.parse(t, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(t, e) {
    switch (t) {
      case mt.CONNECT:
        return xh(e);
      case mt.DISCONNECT:
        return e === void 0;
      case mt.CONNECT_ERROR:
        return typeof e == "string" || xh(e);
      case mt.EVENT:
      case mt.BINARY_EVENT:
        return Array.isArray(e) && (typeof e[0] == "number" || typeof e[0] == "string" && h0.indexOf(e[0]) === -1);
      case mt.ACK:
      case mt.BINARY_ACK:
        return Array.isArray(e);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class c0 {
  constructor(t) {
    this.packet = t, this.buffers = [], this.reconPack = t;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(t) {
    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
      const e = a0(this.reconPack, this.buffers);
      return this.finishedReconstruction(), e;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const f0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder: Wo,
  Encoder: u0,
  get PacketType() {
    return mt;
  },
  protocol: l0
}, Symbol.toStringTag, { value: "Module" }));
function ge(r, t, e) {
  return r.on(t, e), function() {
    r.off(t, e);
  };
}
const d0 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Kl extends $t {
  /**
   * `Socket` constructor.
   */
  constructor(t, e, i) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, i && i.auth && (this.auth = i.auth), this._opts = Object.assign({}, i), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const t = this.io;
    this.subs = [
      ge(t, "open", this.onopen.bind(this)),
      ge(t, "packet", this.onpacket.bind(this)),
      ge(t, "error", this.onerror.bind(this)),
      ge(t, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...t) {
    return t.unshift("message"), this.emit.apply(this, t), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(t, ...e) {
    var i, n, s;
    if (d0.hasOwnProperty(t))
      throw new Error('"' + t.toString() + '" is a reserved event name');
    if (e.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(e), this;
    const o = {
      type: mt.EVENT,
      data: e
    };
    if (o.options = {}, o.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == "function") {
      const u = this.ids++, c = e.pop();
      this._registerAckCallback(u, c), o.id = u;
    }
    const a = (n = (i = this.io.engine) === null || i === void 0 ? void 0 : i.transport) === null || n === void 0 ? void 0 : n.writable, h = this.connected && !(!((s = this.io.engine) === null || s === void 0) && s._hasPingExpired());
    return this.flags.volatile && !a || (h ? (this.notifyOutgoingListeners(o), this.packet(o)) : this.sendBuffer.push(o)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(t, e) {
    var i;
    const n = (i = this.flags.timeout) !== null && i !== void 0 ? i : this._opts.ackTimeout;
    if (n === void 0) {
      this.acks[t] = e;
      return;
    }
    const s = this.io.setTimeoutFn(() => {
      delete this.acks[t];
      for (let a = 0; a < this.sendBuffer.length; a++)
        this.sendBuffer[a].id === t && this.sendBuffer.splice(a, 1);
      e.call(this, new Error("operation has timed out"));
    }, n), o = (...a) => {
      this.io.clearTimeoutFn(s), e.apply(this, a);
    };
    o.withError = !0, this.acks[t] = o;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(t, ...e) {
    return new Promise((i, n) => {
      const s = (o, a) => o ? n(o) : i(a);
      s.withError = !0, e.push(s), this.emit(t, ...e);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(t) {
    let e;
    typeof t[t.length - 1] == "function" && (e = t.pop());
    const i = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: t,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    t.push((n, ...s) => i !== this._queue[0] ? void 0 : (n !== null ? i.tryCount > this._opts.retries && (this._queue.shift(), e && e(n)) : (this._queue.shift(), e && e(null, ...s)), i.pending = !1, this._drainQueue())), this._queue.push(i), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(t = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const e = this._queue[0];
    e.pending && !t || (e.pending = !0, e.tryCount++, this.flags = e.flags, this.emit.apply(this, e.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(t) {
    t.nsp = this.nsp, this.io._packet(t);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((t) => {
      this._sendConnectPacket(t);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(t) {
    this.packet({
      type: mt.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(t) {
    this.connected || this.emitReserved("connect_error", t);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(t, e) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", t, e), this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((t) => {
      if (!this.sendBuffer.some((i) => String(i.id) === t)) {
        const i = this.acks[t];
        delete this.acks[t], i.withError && i.call(this, new Error("socket has been disconnected"));
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case mt.CONNECT:
          t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case mt.EVENT:
        case mt.BINARY_EVENT:
          this.onevent(t);
          break;
        case mt.ACK:
        case mt.BINARY_ACK:
          this.onack(t);
          break;
        case mt.DISCONNECT:
          this.ondisconnect();
          break;
        case mt.CONNECT_ERROR:
          this.destroy();
          const i = new Error(t.data.message);
          i.data = t.data.data, this.emitReserved("connect_error", i);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(t) {
    const e = t.data || [];
    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const e = this._anyListeners.slice();
      for (const i of e)
        i.apply(this, t);
    }
    super.emit.apply(this, t), this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(t) {
    const e = this;
    let i = !1;
    return function(...n) {
      i || (i = !0, e.packet({
        type: mt.ACK,
        id: t,
        data: n
      }));
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(t) {
    const e = this.acks[t.id];
    typeof e == "function" && (delete this.acks[t.id], e.withError && t.data.unshift(null), e.apply(this, t.data));
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(t, e) {
    this.id = t, this.recovered = e && this._pid === e, this._pid = e, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {
      this.notifyOutgoingListeners(t), this.packet(t);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: mt.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(t) {
    return this.flags.compress = t, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(t) {
    return this.flags.timeout = t, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(t) {
    if (!this._anyListeners)
      return this;
    if (t) {
      const e = this._anyListeners;
      for (let i = 0; i < e.length; i++)
        if (t === e[i])
          return e.splice(i, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners)
      return this;
    if (t) {
      const e = this._anyOutgoingListeners;
      for (let i = 0; i < e.length; i++)
        if (t === e[i])
          return e.splice(i, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const e = this._anyOutgoingListeners.slice();
      for (const i of e)
        i.apply(this, t.data);
    }
  }
}
function Yi(r) {
  r = r || {}, this.ms = r.min || 100, this.max = r.max || 1e4, this.factor = r.factor || 2, this.jitter = r.jitter > 0 && r.jitter <= 1 ? r.jitter : 0, this.attempts = 0;
}
Yi.prototype.duration = function() {
  var r = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t = Math.random(), e = Math.floor(t * this.jitter * r);
    r = (Math.floor(t * 10) & 1) == 0 ? r - e : r + e;
  }
  return Math.min(r, this.max) | 0;
};
Yi.prototype.reset = function() {
  this.attempts = 0;
};
Yi.prototype.setMin = function(r) {
  this.ms = r;
};
Yi.prototype.setMax = function(r) {
  this.max = r;
};
Yi.prototype.setJitter = function(r) {
  this.jitter = r;
};
class So extends $t {
  constructor(t, e) {
    var i;
    super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (e = t, t = void 0), e = e || {}, e.path = e.path || "/socket.io", this.opts = e, zn(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((i = e.randomizationFactor) !== null && i !== void 0 ? i : 0.5), this.backoff = new Yi({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = "closed", this.uri = t;
    const n = e.parser || f0;
    this.encoder = new n.Encoder(), this.decoder = new n.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(t) {
    return arguments.length ? (this._reconnection = !!t, t || (this.skipReconnect = !0), this) : this._reconnection;
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);
  }
  reconnectionDelay(t) {
    var e;
    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);
  }
  randomizationFactor(t) {
    var e;
    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);
  }
  reconnectionDelayMax(t) {
    var e;
    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);
  }
  timeout(t) {
    return arguments.length ? (this._timeout = t, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(t) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new t0(this.uri, this.opts);
    const e = this.engine, i = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const n = ge(e, "open", function() {
      i.onopen(), t && t();
    }), s = (a) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", a), t ? t(a) : this.maybeReconnectOnOpen();
    }, o = ge(e, "error", s);
    if (this._timeout !== !1) {
      const a = this._timeout, h = this.setTimeoutFn(() => {
        n(), s(new Error("timeout")), e.close();
      }, a);
      this.opts.autoUnref && h.unref(), this.subs.push(() => {
        this.clearTimeoutFn(h);
      });
    }
    return this.subs.push(n), this.subs.push(o), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(t) {
    return this.open(t);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const t = this.engine;
    this.subs.push(
      ge(t, "ping", this.onping.bind(this)),
      ge(t, "data", this.ondata.bind(this)),
      ge(t, "error", this.onerror.bind(this)),
      ge(t, "close", this.onclose.bind(this)),
      // @ts-ignore
      ge(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(t) {
    try {
      this.decoder.add(t);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(t) {
    $n(() => {
      this.emitReserved("packet", t);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(t) {
    this.emitReserved("error", t);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(t, e) {
    let i = this.nsps[t];
    return i ? this._autoConnect && !i.active && i.connect() : (i = new Kl(this, t, e), this.nsps[t] = i), i;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(t) {
    const e = Object.keys(this.nsps);
    for (const i of e)
      if (this.nsps[i].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(t) {
    const e = this.encoder.encode(t);
    for (let i = 0; i < e.length; i++)
      this.engine.write(e[i], t.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(t, e) {
    var i;
    this.cleanup(), (i = this.engine) === null || i === void 0 || i.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, e), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const t = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const e = this.backoff.duration();
      this._reconnecting = !0;
      const i = this.setTimeoutFn(() => {
        t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open((n) => {
          n ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", n)) : t.onreconnect();
        }));
      }, e);
      this.opts.autoUnref && i.unref(), this.subs.push(() => {
        this.clearTimeoutFn(i);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const t = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t);
  }
}
const rr = {};
function wn(r, t) {
  typeof r == "object" && (t = r, r = void 0), t = t || {};
  const e = e0(r, t.path || "/socket.io"), i = e.source, n = e.id, s = e.path, o = rr[n] && s in rr[n].nsps, a = t.forceNew || t["force new connection"] || t.multiplex === !1 || o;
  let h;
  return a ? h = new So(i, t) : (rr[n] || (rr[n] = new So(i, t)), h = rr[n]), e.query && !t.query && (t.query = e.queryKey), h.socket(e.path, t);
}
Object.assign(wn, {
  Manager: So,
  Socket: Kl,
  io: wn,
  connect: wn
});
class Ui {
  constructor(t = {}, e) {
    this.hPlg = t, this.arg = e;
  }
  hFactoryCls = {};
  elc = new Wi();
  async loaded(...[t]) {
    const e = t.snsys_pre;
    return delete t.snsys_pre, e?.init({
      getInfo: this.#i,
      addTag: () => {
      },
      addLayCls: () => {
      },
      searchPath: () => "",
      getVal: () => ({}),
      resume: () => {
      },
      render: () => {
      },
      setDec: (i) => this.dec = i,
      setDecAB: (i) => this.#C = i,
      setEnc: (i) => this.enc = i,
      getStK: (i) => this.stk = i,
      getHash: (i) => this.hash = i
    });
  }
  fetch = (t, e) => fetch(t, e);
  destroy() {
    this.elc.clear();
  }
  resolution = 1;
  cfg;
  async loadPath(t, e) {
    this.cfg = e;
  }
  data = { sys: {}, mark: {}, kidoku: {} };
  async initVal(t, e, i) {
  }
  flush() {
    if (this.#e) {
      this.#t = !0;
      return;
    }
    this.flushSub(), this.#e = setTimeout(() => {
      this.#e = void 0, this.#t && (this.#t = !1, this.flush());
    }, 500);
  }
  #e = void 0;
  #t = !1;
  flushSub() {
  }
  async run() {
  }
  val;
  main;
  init(t, e, i, n) {
    this.val = i, this.main = n;
    let s = "";
    try {
      i.setSys(this), s = "sys", s += Number(i.getVal("sys:TextLayer.Back.Alpha", 1)), s = "kidoku", i.saveKidoku();
    } catch (o) {
      console.error(`セーブデータ（${s}）が壊れています。一度クリアする必要があります(b) %o`, o);
    }
    return t.close = (o) => this.close(o), t.export = (o) => this._export(o), t.import = (o) => this._import(o), t.navigate_to = (o) => this.navigate_to(o), t.title = (o) => this.title(o), t.toggle_full_screen = (o) => this.#y(o), t.update_check = (o) => this.update_check(o), t.window = (o) => this.window(o), i.setVal_Nochk("tmp", "const.sn.isApp", () => this.isApp), i.setVal_Nochk("tmp", "const.sn.isDbg", () => A.isDbg), i.setVal_Nochk("tmp", "const.sn.isPackaged", () => A.isPackaged), i.defTmp("const.sn.displayState", () => this.isFullScr), i.setVal_Nochk("sys", Ui.VALNM_CFG_NS, this.cfg.oCfg.save_ns), i.flush(), A.isDbg && this.attach_debug(n), this.hFactoryCls = {}, Object.values(this.hPlg).map((o) => o.init({
      getInfo: this.#i,
      addTag: (a, h) => {
        if (t[a]) throw `すでに定義済みのタグ[${a}]です`;
        t[a] = h;
      },
      addLayCls: (a, h) => {
        if (this.hFactoryCls[a]) throw `すでに定義済みのレイヤcls【${a}】です`;
        this.hFactoryCls[a] = h;
      },
      searchPath: (a, h = qt.DEFAULT) => this.cfg.searchPath(a, h),
      getVal: i.getVal,
      resume: () => n.resume(),
      render: (a, h, l = !1) => e.renderer.render(a, { renderTexture: h, clear: l }),
      setDec: () => {
      },
      setDecAB: () => {
      },
      setEnc: () => {
      },
      getStK: () => {
      },
      getHash: () => {
      }
    }));
  }
  static VALNM_CFG_NS = "const.sn.cfg.ns";
  #i = () => ({
    window: {
      width: A.stageW,
      height: A.stageH
    }
  });
  #n = 0;
  #r = 0;
  #a = 1;
  #h = 0;
  #d = 0;
  #l = 0;
  #f = 0;
  get cvsWidth() {
    return this.#n;
  }
  get cvsHeight() {
    return this.#r;
  }
  get cvsScale() {
    return this.#a;
  }
  get ofsLeft4elm() {
    return this.#h;
  }
  get ofsTop4elm() {
    return this.#d;
  }
  get ofsPadLeft_Dom2PIXI() {
    return this.#l;
  }
  get ofsPadTop_Dom2PIXI() {
    return this.#f;
  }
  isFullScr = !1;
  cvsResize() {
    let t = globalThis.innerWidth, e = globalThis.innerHeight;
    const i = this.main.cvs, n = i.parentElement !== document.body;
    if (n) {
      const h = globalThis.getComputedStyle(i);
      t = parseFloat(h.width), e = parseFloat(h.height);
    }
    if (A.isMobile) {
      const l = (screen.orientation?.angle ?? 0) % 180 === 0;
      (l && t > e || !l && t < e) && ([t, e] = [e, t]);
    }
    const s = i.getBoundingClientRect();
    if ($(A.hDip, "expanding", !0) || n || A.stageW > t || A.stageH > e)
      if (A.stageW / A.stageH <= t / e ? (this.#r = e, this.#n = A.stageW / A.stageH * e) : (this.#n = t, this.#r = A.stageH / A.stageW * t), this.#a = this.#n / A.stageW, n)
        this.#l = 0, this.#f = 0;
      else {
        const h = 1 - this.#a;
        A.isMobile ? (this.#l = (t - this.#n) / 2 * h, this.#f = (e - this.#r) / 2 * h) : (this.#l = s.left * h, this.#f = s.top * h);
      }
    else
      this.#n = A.stageW, this.#r = A.stageH, this.#a = 1, this.#l = 0, this.#f = 0;
    const o = i.parentElement.style;
    n || (o.position = "relative", o.width = `${this.#n}px`, o.height = `${this.#r}px`);
    const a = i.style;
    a.width = o.width, a.height = o.height, n ? (this.#h = s.left, this.#d = s.top) : (this.#h = 0, this.#d = 0), this.isFullScr && (this.#h += (t - this.#n) / 2, this.#d += (e - this.#r) / 2);
  }
  // デバッガ接続
  attach_debug(t) {
    this.attach_debug = () => {
    };
    const e = document.createElement("style");
    e.innerHTML = `/* SKYNovel Dbg */
.sn_BounceInOut { animation: sn_kfBounceInOut linear 1.5s; }
@keyframes sn_kfBounceInOut{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
10%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
20%	{				transform: scaleX(0.95) scaleY(0.95);}
30%	{				transform: scaleX(1.00) scaleY(1.00);}
70%	{opacity: 1;}
100%{opacity: 0;}
}
.sn_BounceIn { animation: sn_kfBounceIn linear 0.3s; }
@keyframes sn_kfBounceIn{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
50%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
100%{				transform: scaleX(0.95) scaleY(0.95);}
}
.sn_HopIn { animation: sn_kfHopIn linear 0.8s; }
@keyframes sn_kfHopIn{
0%	{transform:	translate(0px,   0px);}
15% {transform:	translate(0px, -25px);}
30% {transform:	translate(0px,   0px);}
45% {transform:	translate(0px, -15px);}
60% {transform:	translate(0px,   0px);}
75% {transform:	translate(0px,  -5px);}
100%{transform:	translate(0px,   0px);}
}`, document.getElementsByTagName("head")[0].appendChild(e), this.addHook((i, n) => this.#c[i]?.(n)), this.#s = wn(`http://localhost:${this.extPort}`), this.#s.on("data", (i, n) => {
      this.callHook(i, n);
    }).on("disconnect", () => t.setLoop(!0)), this.callHook = (i, n) => {
      for (const s of this.#_) s(i, n);
    };
  }
  extPort = 3776;
  end() {
    this.#s?.disconnect(), this.#s = void 0;
  }
  #s = void 0;
  #c = {
    auth: (t) => {
      if (t.t !== this.cfg.oCfg.debuger_token) {
        this.end();
        return;
      }
      this.toast("接続");
    },
    continue: () => this.toast("再生"),
    disconnect: () => this.toast("切断"),
    restart: async (t) => {
      this.send2Dbg(t?.ri ?? "", {}), this.end(), await this.run();
    },
    pause: () => this.toast("一時停止"),
    stopOnEntry: () => this.toast("一時停止"),
    stopOnDataBreakpoint: () => this.toast("注意"),
    stopOnBreakpoint: () => this.toast("注意"),
    stopOnStep: () => this.toast("一歩進む"),
    stopOnStepIn: () => this.toast("ステップイン"),
    stopOnStepOut: () => this.toast("ステップアウト"),
    stopOnBackstep: () => this.toast("一歩戻る"),
    _addPath: (t) => this.cfg.addPath(t.fn, t.o)
  };
  toast(t) {
    const e = document.body;
    for (const o of [
      ...Array.from(e.getElementsByClassName("sn_BounceIn")),
      ...Array.from(e.getElementsByClassName("sn_HopIn"))
    ]) o.remove();
    const i = document.createElement("img"), n = Ui.#v[t];
    if (!n) throw new Error(`toast 名ミス=${t}`);
    i.src = `data:image/svg+xml;base64,${n.dat}`;
    const s = Math.min(A.stageW, A.stageH) / 4 * this.#a;
    i.width = i.height = s, i.style.cssText = `position: absolute;
left: ${(A.stageW - s) / 2 * this.#a + s * (n.dx ?? 0)}px;
top: ${(A.stageH - s) / 2 * this.#a + s * (n.dy ?? 0)}px;`, i.classList.add("sn_toast", n.ease ?? "sn_BounceInOut"), n.ease || i.addEventListener("animationend", () => e.removeChild(i), { once: !0, passive: !0 }), e.insertBefore(i, this.main.cvs);
  }
  static #v = {
    // Thanks ICOOON MONO https://icooon-mono.com/ 、 https://vectr.com/ で 640x640化、ImageOptim経由、Base64エンコーダー https://lab.syncer.jp/Tool/Base64-encode/ 
    接続: { dx: -1, dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMCAyOTJ2NTUuODhoMTI3LjEzYzEyLjM3IDQ2IDU0LjEyIDc5Ljg3IDEwNCA3OS44N2g3Ny44N3YtMjE1LjYyYy00Ni43MyAwLTcyLjY4IDAtNzcuODggMC00OS43NCAwLTkxLjYyIDMzLjg3LTEwMy45OSA3OS44Ny0xNi45NSAwLTU5LjMzIDAtMTI3LjEzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im01MTIuODggMjkyYy0xMi4zOC00Ni01NC4xMy03OS44Ny0xMDQtNzkuODctNS4yMSAwLTMxLjIxIDAtNzggMHYyMTUuNzRoNzcuODdjNDkuODggMCA5MS43NS0zMy44NyAxMDQtNzkuODdoMTI3LjI1di01NmMtNzYuMjcgMC0xMTguNjUgMC0xMjcuMTIgMHoiLz48L2RlZnM+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9IiMzYWFiZDIiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYiIvPjx1c2UgZmlsbD0iIzNhYWJkMiIgeGxpbms6aHJlZj0iI2MiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNjIi8+PC9zdmc+" },
    切断: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMTkxLjUzIDIyMS4yNGMtNDUuNjggMC04NC4wMSAzMS4wNC05NS4zIDczLjE2LTYuNDEgMC0zOC40OSAwLTk2LjIzIDB2NTEuMjFoOTYuMjNjMTEuMyA0Mi4xMSA0OS42MyA3My4xNiA5NS4zIDczLjE2aDcxLjMzdi00OC4yNGg1My43OHYtMTAxLjA1aC01My43OHYtNDguMjRjLTQyLjggMC02Ni41NyAwLTcxLjMzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im00NDguNDcgMjIxLjIzYy00Ljc2IDAtMjguNTMgMC03MS4zMyAwdjE5Ny41M2g3MS4zM2M0NS42OCAwIDgzLjk5LTMxLjA0IDk1LjI5LTczLjE1aDk2LjI0di01MS4yMWgtOTYuMjRjLTMzLjA4LTQ4Ljc4LTY0Ljg0LTczLjE3LTk1LjI5LTczLjE3eiIvPjwvZGVmcz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0iI2RmNTY1NiIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSIjZGY1NjU2IiB4bGluazpocmVmPSIjYyIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2MiLz48L3N2Zz4=" },
    再生: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yNTguODMgMTExLjA1Yy0xLjI5Ljc5LTIuOTMuODMtNC4yNi4wNC0xLjI5LS43NC0yLjExLTIuMTItMi4xMS0zLjY3IDAtNy4xNiAwLTQyLjk3IDAtMTA3LjQzczAtMTAwLjI3IDAtMTA3LjQzYzAtMS41My44Mi0yLjkzIDIuMTEtMy42OCAxLjMzLS43NiAyLjk3LS43MiA0LjI2LjA0IDE4IDEwLjc1IDE2MiA5Ni43MSAxODAgMTA3LjQ2IDEuMjkuNzMgMi4wNSAyLjE0IDIuMDUgMy42MSAwIDEuNDktLjc2IDIuODgtMi4wNSAzLjYzLTM2IDIxLjQ5LTE2MiA5Ni42OS0xODAgMTA3LjQzeiIvPjwvZGVmcz48cGF0aCBkPSJtMTU0LjU3IDE3MC4xOWgzNDYuMTV2MzA3LjY5aC0zNDYuMTV6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
    一時停止: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yMDAgMTAwdi0yMDBoODB2MjAwem0xNjAgMHYtMjAwaDgwdjIwMHoiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxODAuNDFoMzUyLjR2MjgyLjY5aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
    注意: { ease: "sn_HopIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMzQzLjM0IDI5LjJjLTEwLjM3LTE3Ljk3LTM2LjMxLTE3Ljk3LTQ2LjY5IDAtMjkuMyA1MC43NS0yNjMuNyA0NTYuNzQtMjkzIDUwNy40OS0xMC4zNyAxNy45NyAyLjU5IDQwLjQ0IDIzLjM0IDQwLjQ0aDU4Ni4wMWMyMC43NSAwIDMzLjcyLTIyLjQ2IDIzLjM1LTQwLjQ0LTU4LjYtMTAxLjUtMjYzLjctNDU2Ljc0LTI5My4wMS01MDcuNDl6bS0yMy4zNCA0ODIuODNjLTE0LjUyIDAtMjYuMjktMi43MS0yNi4yOS02LjA2IDAtNC4yMSAwLTM3Ljg2IDAtNDIuMDcgMC0zLjM1IDExLjc3LTYuMDcgMjYuMjktNi4wN3MyNi4yOSAyLjcyIDI2LjI5IDYuMDd2NDIuMDdjLTcuODQgNC4wNC0xNi42MSA2LjA2LTI2LjI5IDYuMDZ6bTIxLjk5LTEwMy44NGMwIDUuNDMtOS44NSA5LjgzLTIxLjk5IDkuODMtMTIuMTUgMC0yMS45OS00LjQtMjEuOTktOS44MyAwLS4xMy4wNy0uMjUuMDgtLjM4LTEuMzctMTcuNTYtMTIuMy0xNTguMDYtMTMuNjctMTc1LjYyIDAtNS40MyAxNS45My05Ljg0IDM1LjU4LTkuODRzMzUuNTggNC40MSAzNS41OCA5Ljg0Yy0uOTEgMTEuNy01LjQ3IDcwLjI1LTEzLjY3IDE3NS42Mi4wNi4xNi4wOC4yOS4wOC4zOHoiLz48L2RlZnM+PHBhdGggZD0ibTI0MS4yOSAxOTEuNDRoMTQ1LjQ5djM1MS42NmgtMTQ1LjQ5eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iI2QyYmYzYSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
    一歩進む: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0zNzYuOTMgOTEuOTdjMC01My41MSAwLTgzLjI0IDAtODkuMTktLjE1LjE0LS4yNS4zNC0uNDQuNDUtMTYuMTEgOS42Mi0xNDQuOTUgODYuNTQtMTYxLjA2IDk2LjE1LTEuMTUuNjktMi42Mi43My0zLjgxLjAyLTEuMTUtLjY0LTEuODktMS44OS0xLjg5LTMuMjggMC02LjQxIDAtMzguNDQgMC05Ni4xMSAwLTU3LjY5IDAtODkuNzQgMC05Ni4xNSAwLTEuMzUuNzQtMi42MiAxLjg5LTMuMjkgMS4xOS0uNjggMi42Ni0uNjQgMy44MS4wNCAxNi4xMSA5LjYyIDE0NC45NSA4Ni41NCAxNjEuMDYgOTYuMTYuMTkuMS4yOS4zMS40NC40NSAwLTYuMTMgMC0zNi43NyAwLTkxLjkyaDUzLjMydjE4Ni42N3oiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxNTQuMmgzNTIuNHYzMDguOWgtMzUyLjR6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
    一歩戻る: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem00MzAuMjcgOTYuMTRjMCAxLjM1LS43NCAyLjYyLTEuODkgMy4yOC0xLjE5LjY5LTIuNjYuNjUtMy44MS0uMDMtMTYuMTEtOS42Mi0xNDQuOTUtODYuNTQtMTYxLjA1LTk2LjE2LS4yLS4xLS4yOS0uMzEtLjQ1LS40NXY5MS45MmgtNTMuMzJ2LTE4Ni42N2g1My4zMnY4OS4xOWMuMTYtLjE0LjI1LS4zNC40NS0uNDUgMTYuMS05LjYyIDE0NC45NC04Ni41NCAxNjEuMDUtOTYuMTYgMS4xNS0uNjggMi42Mi0uNzIgMy44MS0uMDEgMS4xNS42NCAxLjg5IDEuODkgMS44OSAzLjI4djk2LjExeiIvPjwvZGVmcz48cGF0aCBkPSJtMTQ3LjQ5IDE1NC4yaDM1Mi40djMwOC45aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
    ステップイン: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMTkuOTljMCAxNzYuNzQgMTQzLjI3IDMyMC4wMSAzMjAuMDEgMzIwLjAxIDE3Ni43MiAwIDMxOS45OS0xNDMuMjcgMzE5Ljk5LTMyMC4wMSAwLTE3Ni43Mi0xNDMuMjctMzE5Ljk5LTMxOS45OS0zMTkuOTktMTc2Ljc0IDAtMzIwLjAxIDE0My4yNy0zMjAuMDEgMzE5Ljk5em0xNTMuMDUtMjkuNzIgNTUuMTItNTUuMTMgMTExLjg0IDExMS44MiAxMTEuODItMTExLjgyIDU1LjEyIDU1LjEyLTE2Ni45NCAxNjYuOTd6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
    ステップアウト: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjAuMDFjMCAxNzYuNzIgMTQzLjI3IDMxOS45OSAzMTkuOTkgMzE5Ljk5IDE3Ni43NCAwIDMyMC4wMS0xNDMuMjcgMzIwLjAxLTMxOS45OSAwLTE3Ni43NC0xNDMuMjctMzIwLjAxLTMyMC4wMS0zMjAuMDEtMTc2LjcyIDAtMzE5Ljk5IDE0My4yNy0zMTkuOTkgMzIwLjAxem0zMTkuOTktMjYuOTgtMTExLjgyIDExMS44My01NS4xMi01NS4xMyAxNjYuOTQtMTY2Ljk2IDE2Ni45NiAxNjYuOTYtNTUuMTIgNTUuMTN6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" }
  };
  pathBaseCnvSnPath4Dbg = "";
  fire;
  setFire(t) {
    this.fire = t;
  }
  #_ = [];
  addHook(t) {
    this.#_.push(t);
  }
  callHook = (t, e) => {
  };
  send2Dbg = (t, e) => {
    this.#s?.emit("data", t, e);
  };
  copyBMFolder = (t, e) => {
  };
  eraseBMFolder = (t) => {
  };
  close = () => !1;
  _export = () => !1;
  _import = () => !1;
  navigate_to = () => !1;
  title = (t) => {
    const { text: e } = t;
    if (!e) throw "[title] textは必須です";
    return this.#p = e, this.titleSub(this.#p + this.#u), !1;
  };
  #p = "";
  titleSub(t) {
  }
  #y = (t) => {
    if (!t.key)
      return this.tglFlscr_sub(), !1;
    const e = t.key.toLowerCase();
    return this.elc.add(document, Ie, (i) => {
      Ui.modKey(i) + i.key.toLowerCase() === e && (i.stopPropagation(), this.tglFlscr_sub());
    }, { passive: !0 }), !1;
  };
  static modKey(t) {
    return (t.altKey ? t.key === "Alt" ? "" : "alt+" : "") + (t.ctrlKey ? t.key === "Control" ? "" : "ctrl+" : "") + (t.metaKey ? t.key === "Meta" ? "" : "meta+" : "") + (t.shiftKey ? t.key === "Shift" ? "" : "shift+" : "");
  }
  tglFlscr_sub() {
  }
  update_check = () => !1;
  window = () => !1;
  #u = "";
  setTitleInfo(t) {
    this.#u = t, this.titleSub(this.#p + this.#u);
  }
  #C = () => Promise.resolve({ ext_num: 0, ab: new ArrayBuffer(0) });
  dec = (t, e) => Promise.resolve(e);
  async decAB(t) {
    const { ext_num: e, ab: i } = await this.#C(t), n = this.#g[e];
    return n?.fnc ? await n.fnc(i) : i;
  }
  #g = {
    1: { ext: "jpeg", fnc: (t) => this.#m(t, "image/jpeg") },
    2: { ext: "png", fnc: (t) => this.#m(t, "image/png") },
    3: { ext: "svg", fnc: (t) => this.#m(t, "image/svg+xml") },
    4: { ext: "webp", fnc: (t) => this.#m(t, "image/webp") },
    //	10	: {ext: 'mp3', fnc: async ab=> ab},
    //	11	: {ext: 'm4a', fnc: async ab=> ab},
    //	12	: {ext: 'ogg', fnc: async ab=> ab},
    //	13	: {ext: 'aac', fnc: async ab=> ab},
    //	14	: {ext: 'flac', fnc: async ab=> ab},
    //	15	: {ext: 'wav', fnc: async ab=> ab},
    20: { ext: "mp4", fnc: (t) => this.#o(t, "video/mp4") },
    21: { ext: "webm", fnc: (t) => this.#o(t, "video/webm") },
    22: { ext: "ogv", fnc: (t) => this.#o(t, "video/ogv") }
  };
  #m = (t, e) => new Promise((i, n) => {
    const s = new Blob([t], { type: e }), o = new Image();
    o.onload = () => i(o), o.onerror = (a) => n(a), o.src = URL.createObjectURL(s);
  });
  #o = (t, e) => new Promise((i, n) => {
    const s = new Blob([t], { type: e }), o = document.createElement("video");
    this.elc.add(o, "error", () => n(o?.error?.message ?? "")), this.elc.add(o, "canplay", () => i(o)), o.src = URL.createObjectURL(s);
  });
  enc = async (t) => t;
  stk = () => "";
  hash = (t) => "";
  isApp = !1;
  $path_downloads = "";
  get path_downloads() {
    return this.$path_downloads;
  }
  $path_userdata = "";
  get path_userdata() {
    return this.$path_userdata;
  }
  capturePage(t, e, i, n) {
  }
  async savePic(t, e) {
  }
  async ensureFileSync(t) {
  }
  async appendFile(t, e) {
  }
  async outputFile(t, e) {
  }
}
class p0 extends Ui {
  async loadPath(t, e) {
    await super.loadPath(t, e);
    const i = this.arg.cur + "path.json", n = await (await this.fetch(i)).text(), s = JSON.parse(await this.dec(i, n));
    for (const [o, a] of Object.entries(s)) {
      const h = t[o] = a;
      for (const [l, u] of Object.entries(h))
        l !== ":cnt" && (h[l] = this.arg.cur + u);
    }
  }
  init(t, e, i, n) {
    const s = super.init(t, e, i, n);
    return document.body.style.backgroundColor = "#000", s;
  }
  isApp = !0;
  async savePic(t, e) {
    const i = e.slice(e.indexOf(",", 20) + 1);
    try {
      this.ensureFileSync(t), await this.writeFileSync(t, i), A.debugLog && console.log(`画像ファイル ${t} を保存しました`);
    } catch (n) {
      throw n;
    }
  }
  async writeFileSync(t, e, i) {
  }
}
const ln = "skynovel";
class v0 {
  constructor(t) {
    this.sys = t, Iu(), Do.generate(t).then((e) => this.#a(e)).catch((e) => console.error("load err fn:prj.json e:%o", e));
  }
  cvs;
  #e = /* @__PURE__ */ Object.create(null);
  // タグ処理辞書
  #t;
  #i;
  #n;
  #r = [];
  async #a(t) {
    const e = {
      width: t.oCfg.window.width,
      height: t.oCfg.window.height,
      backgroundColor: Co(String(t.oCfg.init.bg_color)),
      // このString()は後方互換性のため必須
      //	resolution		: sys.resolution,
      resolution: globalThis.devicePixelRatio ?? 1
      // 理想
    }, i = document.getElementById(ln);
    if (i) {
      const o = i.cloneNode(!0);
      o.id = ln, e.view = i;
      const a = i.parentNode;
      this.#r.unshift(() => a.appendChild(o));
    } else {
      const o = document.createElement("canvas");
      o.id = ln, e.view = o, document.body.appendChild(o), this.#r.unshift(() => document.body.removeChild(o));
    }
    const n = new pl(e);
    this.#r.unshift(() => {
      Dh(), this.sys.destroy(), n.destroy(!1);
    }), this.cvs = n.view, this.cvs.id = ln + "_act", i || document.body.appendChild(this.cvs);
    const s = document.createElement("canvas")?.getContext("2d");
    if (!s) throw "#init cc err";
    A.cc4ColorName = s, await Promise.all([
      import("./Variable.js"),
      import("./PropParser.js"),
      import("./SoundMng.js"),
      Promise.resolve().then(() => ly),
      Promise.resolve().then(() => cy),
      Promise.resolve().then(() => bg)
    ]).then(async ([
      { Variable: o },
      { PropParser: a },
      { SoundMng: h },
      { ScriptIterator: l },
      { LayerMng: u },
      { EventMng: c }
    ]) => {
      const f = new o(t, this.#e), d = new a(f, t.oCfg.init.escape ?? "\\");
      this.#h = (_, m, y, b) => f.setVal_Nochk(_, m, y, b), this.#f = (_) => d.getValAmpersand(_), this.#s = (_) => d.parse(_), await Promise.allSettled(this.sys.init(this.#e, n, f, this)), this.#e.title({ text: t.oCfg.book.title || "SKYNovel" });
      const p = new h(t, this.#e, f, this, this.sys);
      this.#r.unshift(() => p.destroy()), this.#t = new l(t, this.#e, this, f, d, p, this.sys), this.#r.unshift(() => this.#t.destroy());
      const v = new rt(this.sys, this.#e, this.#t);
      this.#r.unshift(() => v.destroy()), this.errScript = (_, m = !0) => {
        if (this.stop(), rt.myTrace(_), A.debugLog && console.log("🍜 SKYNovel err!"), m) throw _;
      }, this.#i = new u(t, this.#e, n, f, this, this.#t, this.sys, p, d), this.#r.unshift(() => this.#i.destroy()), this.#n = new c(t, this.#e, n, this, this.#i, f, p, this.#t, this.sys), this.#r.unshift(() => this.#n.destroy()), this.#r.unshift(() => {
        this.stop(), this.#d = !1;
        const _ = () => !0;
        for (const m in this.#e) this.#e[m] = _;
      });
    });
  }
  destroy() {
    this.resume = this.destroy = () => {
    }, this.cvs.parentElement?.removeChild(this.cvs);
    for (const t of this.#r) t();
    this.#r = [];
  }
  errScript = (t, e = !0) => {
  };
  resumeByJumpOrCall(t) {
    if (t.url) {
      this.#e.navigate_to(t), this.#t.jumpJustBefore();
      return;
    }
    if (this.#h("tmp", "sn.eventArg", t.arg ?? ""), this.#h("tmp", "sn.eventLabel", t.label ?? ""), $(t, "call", !1)) {
      if (this.#t.subIdxToken(), this.#e.call(t)) return;
    } else if (this.#e.clear_event({}), this.#e.jump(t)) return;
    this.resume();
  }
  #h = (t, e, i, n = !1) => {
  };
  resume() {
    this.#i.clearBreak(), this.#t.noticeBreak(!1), this.#n.hideHint(), queueMicrotask(() => this.#l());
  }
  stop = () => {
    this.#t.noticeBreak(!0);
  };
  setLoop(t, e = "") {
    (this.#d = t) ? this.resume() : this.stop(), this.sys.setTitleInfo(e ? ` -- ${e}中` : "");
  }
  #d = !0;
  //MARK: メイン処理（シナリオ解析）
  async #l() {
    let t = "";
    try {
      for (; this.#d; ) {
        let e = this.#t.nextToken();
        if (!e) return;
        const i = e.charCodeAt(0);
        if (i === 9) continue;
        if (i === 10) {
          this.#t.addLineNum(e.length);
          continue;
        }
        if (i === 91) {
          if (t = "タグ開始", this.#t.isBreak(e)) return;
          const [s, o] = Nn(e);
          t = `[${s}]例外`;
          const a = (e.match(/\n/g) ?? []).length;
          if (a > 0 && this.#t.addLineNum(a), await this.#t.タグ解析(s, o)) {
            this.stop();
            return;
          }
          continue;
        }
        if (i === 38) {
          if (!e.endsWith("&")) {
            if (t = "変数計算", this.#t.isBreak(e)) return;
            const s = Xm(e.slice(1));
            s.name = this.#f(s.name), s.text = String(this.#s(s.text)), this.#e.let(s);
            continue;
          }
          if (t = "変数操作", e.charAt(1) === "&") throw new Error("「&表示&」書式では「&」指定が不要です");
          e = String(this.#s(e.slice(1, -1)));
        } else {
          if (i === 59) continue;
          if (i === 42 && e.length > 1) continue;
        }
        t = "文字表示", this.#i.setNormalChWait(), this.#i.currentTxtlayForeNeedErr.tagCh(e);
      }
    } catch (e) {
      this.errScript(`${t} ${e instanceof Error ? `mes=${e.message}(${e.name})` : e}`, !1);
    }
  }
  #f = (t) => "";
  #s = (t) => {
  };
}
const wt = globalThis.to_app;
class g0 extends p0 {
  constructor(...[t = {}, e = { cur: "prj/", crypto: !1, dip: "" }]) {
    super(t, e), queueMicrotask(async () => this.loaded(t, e));
  }
  async loaded(...[t, e]) {
    await super.loaded(t, e), this.#e = await wt.getInfo(), A.isPackaged = this.#e.isPackaged, this.arg = e = { ...e, cur: this.#e.getAppPath.replaceAll("\\", "/") + (A.isPackaged ? "/doc/" : "/") + e.cur }, this.$path_downloads = this.#e.downloads.replaceAll("\\", "/") + "/", wt.on("log", (i, n) => console.info("main: %o", n)), A.isDbg = !!this.#e.env.SKYNOVEL_DBG && !A.isPackaged, A.isDbg && (this.extPort = bt(this.#e.env.SKYNOVEL_PORT ?? "3776")), await this.run();
  }
  #e = {
    getAppPath: "",
    isPackaged: !1,
    downloads: "",
    userData: "",
    getVersion: "",
    env: {},
    platform: "",
    arch: ""
  };
  fetch = (t) => fetch(t, { cache: "no-store" });
  ensureFileSync = wt.ensureFileSync;
  writeFileSync = wt.writeFileSync;
  appendFile = wt.appendFile;
  outputFile = wt.outputFile;
  $path_userdata = "";
  $path_downloads = "";
  async initVal(t, e, i) {
    e["const.sn.isDebugger"] = !1, this.$path_userdata = A.isDbg ? this.#e.getAppPath.slice(0, -3) + ".vscode/" : this.#e.userData.replaceAll("\\", "/") + "/", this.flushSub = () => {
      wt.flush(JSON.parse(JSON.stringify(this.data)));
    }, this.#t().then(async () => {
      const n = e["const.sn.isFirstBoot"] = await wt.Store_isEmpty();
      if (n)
        this.data.sys = t.sys, this.data.mark = t.mark, this.data.kidoku = t.kidoku, this.flush();
      else {
        const l = await wt.Store_get();
        this.data.sys = l.sys, this.data.mark = l.mark, this.data.kidoku = l.kidoku;
      }
      const s = this.data.sys["const.sn.nativeWindow.x"] ?? 0, o = this.data.sys["const.sn.nativeWindow.y"] ?? 0, a = this.data.sys["const.sn.nativeWindow.w"] ?? A.stageW, h = this.data.sys["const.sn.nativeWindow.h"] ?? A.stageH;
      wt.inited(this.cfg.oCfg, { c: n, x: s, y: o, w: a, h }), wt.on("save_win_inf", (l, { x: u, y: c, w: f, h: d, scrw: p, scrh: v }) => {
        this.val.setVal_Nochk("sys", "const.sn.nativeWindow.x", u), this.val.setVal_Nochk("sys", "const.sn.nativeWindow.y", c), this.val.setVal_Nochk("sys", "const.sn.nativeWindow.w", f), this.val.setVal_Nochk("sys", "const.sn.nativeWindow.h", d), this.flush(), e["const.sn.screenResolutionX"] = p, e["const.sn.screenResolutionY"] = v;
      }), i(this.data);
    });
  }
  #t = () => wt.Store({
    cwd: this.$path_userdata + "storage",
    name: this.arg.crypto ? "data_" : "data",
    encryptionKey: this.arg.crypto ? this.stk() : void 0
  });
  #i;
  async run() {
    this.#i && this.#i.destroy(), this.#i = new v0(this);
  }
  init(t, e, i, n) {
    const s = super.init(t, e, i, n);
    wt.on("shutdown", (a) => n.destroy());
    const o = new MouseEvent("click");
    return wt.on("fire", (a, h) => this.fire(h, o)), s;
  }
  cvsResize() {
    super.cvsResize();
    const t = this.main.cvs, e = t.parentElement.style, i = t.style;
    this.isFullScr ? (e.position = "", e.width = "", e.height = "", i.position = "fixed", i.left = `${this.ofsLeft4elm}px`, i.top = `${this.ofsTop4elm}px`) : (e.position = "relative", e.width = `${this.cvsWidth}px`, e.height = `${this.cvsHeight}px`, i.position = "relative", i.left = "", i.top = "");
  }
  copyBMFolder = async (t, e) => {
    const i = `${this.$path_userdata}storage/${t}/`, n = `${this.$path_userdata}storage/${e}/`;
    await wt.existsSync(i) && wt.copySync(i, n);
  };
  eraseBMFolder = async (t) => {
    await wt.removeSync(`${this.$path_userdata}storage/${t}/`);
  };
  // アプリの終了
  close = () => (wt.win_close(), !1);
  // プレイデータをエクスポート
  _export = () => (wt.zip(
    this.$path_userdata + "storage/",
    this.$path_downloads + (this.arg.crypto ? "" : "no_crypto_") + this.cfg.getNs() + Po("-", "_", "") + ".spd"
  ).then(() => {
    A.debugLog && console.log("プレイデータをエクスポートしました"), this.fire("sn:exported", new MouseEvent("click"));
  }), !1);
  // プレイデータをインポート
  _import = () => (wt.showOpenDialog({
    title: "play data import",
    filters: [{ name: "sn import", extensions: ["spd"] }],
    properties: [
      "openFile"
      // - ファイルを選択するのを許可します。
      // openDirectory - ディレクトリを選択するのを許可します。
      // multiSelections - 複数のパスを選択するのを許可します。
    ]
  }).then(async ({ canceled: t, filePaths: [e] }) => {
    if (t) return;
    const i = this.flush;
    this.flush = () => {
    }, await wt.unzip(e, this.$path_userdata + "storage/"), await this.#t();
    const n = await wt.Store_get();
    this.data.sys = n.sys, this.data.mark = n.mark, this.data.kidoku = n.kidoku, this.flush = i, this.flush(), this.val.updateData(n), A.debugLog && console.log("プレイデータをインポートしました"), this.fire("sn:imported", new MouseEvent("click"));
  }).catch((t) => console.log(`[import] err: ${t}`)), !1);
  // ＵＲＬを開く
  navigate_to = (t) => {
    const { url: e } = t;
    if (!e) throw "[navigate_to] urlは必須です";
    return wt.navigate_to(e), !1;
  };
  // タイトル指定
  titleSub(t) {
    wt.win_setTitle(t);
  }
  // 全画面状態切替
  tglFlscr_sub = async () => wt.setSimpleFullScreen(
    this.isFullScr = !await wt.isSimpleFullScreen()
  );
  // 更新チェック
  update_check = (t) => {
    const { url: e } = t;
    if (!e) throw "[update_check] urlは必須です";
    if (!e.endsWith("/")) throw "[update_check] urlの最後は/です";
    return A.debugLog && rt.myTrace(`[update_check] url=${e}`, "D"), (async () => {
      let i = {}, n = "", s = "";
      const o = await this.fetch(e + "_index.json");
      if (o.ok)
        A.debugLog && rt.myTrace("[update_check] _index.jsonを取得しました", "D"), i = await o.json(), s = i.version;
      else {
        const u = await this.fetch(e + `latest${A.isMac ? "-mac" : ""}.yml`);
        if (!u.ok) {
          A.debugLog && rt.myTrace("[update_check] .ymlが見つかりません");
          return;
        }
        A.debugLog && rt.myTrace("[update_check] .ymlを取得しました", "D"), n = await u.text();
        const f = /version: (.+)/.exec(n)?.[1];
        if (!f) throw "[update_check] .yml に version が見つかりません";
        s = f;
      }
      const a = this.#e.getVersion;
      if (A.debugLog && rt.myTrace(`[update_check] 現在ver=${a} 新規ver=${s}`, "D"), s === a) {
        A.debugLog && rt.myTrace("[update_check] バージョン更新なし", "I");
        return;
      }
      const h = {
        title: "アプリ更新",
        icon: this.#e.getAppPath + "/app/icon.png",
        buttons: ["OK", "Cancel"],
        defaultId: 0,
        cancelId: 1,
        message: `アプリ【${this.cfg.oCfg.book.title}】に更新があります。
ダウンロードしますか？`,
        detail: `現在 NOW ver ${a}
新規 NEW ver ${s}`
      }, { response: l } = await wt.showMessageBox(h);
      if (!(l > 0)) {
        if (A.debugLog && rt.myTrace("[update_check] アプリダウンロード開始", "D"), o.ok) {
          const u = this.#e.platform + "_" + this.#e.arch, { cn: c, path: f } = i[u];
          if (c) await this.#n(e, u + "-" + c, f);
          else {
            let d = "";
            const p = new RegExp("^" + this.#e.platform + "_"), v = Object.entries(i).flatMap(([m, { path: y, cn: b }]) => p.test(m) ? (d += `
- ` + y, () => this.#n(e, m + "-" + b, y)) : []);
            h.message = `CPU = ${this.#e.arch}
に対応するファイルが見つかりません。同じOSのファイルをすべてダウンロードしますか？`, h.detail = v.length + " 個ファイルがあります" + d;
            const { response: _ } = await wt.showMessageBox(h);
            if (_ > 0) return;
            await Promise.allSettled(v);
          }
        } else {
          const u = /path: (.+)/.exec(n);
          if (!u) throw "[update_check] path が見つかりません";
          const [, c] = u;
          if (!c) throw "[update_check] path が見つかりません.";
          A.debugLog && rt.myTrace(`[update_check] path=${c}`, "D");
          const f = /sha512: (.+)/.exec(n);
          if (!f) throw "[update_check] sha512 が見つかりません";
          const [, d] = f;
          A.debugLog && rt.myTrace(`[update_check] sha=${d}=`, "D");
          const [, p, v] = /(.+)(\.\w+)/.exec(c) ?? ["", "", ""];
          await this.#n(e, p + "-" + this.#e.arch + v, c);
        }
        A.debugLog && rt.myTrace("アプリファイルを保存しました", "D"), h.buttons.pop(), h.message = `アプリ【${this.cfg.oCfg.book.title}】の更新パッケージを
ダウンロードしました`, wt.showMessageBox(h);
      }
    })(), !1;
  };
  async #n(t, e, i) {
    A.debugLog && rt.myTrace(`[update_check] アプリファイルDL試行... url=${t + e}`, "D");
    const n = await this.fetch(t + e);
    if (!n.ok) {
      A.debugLog && rt.myTrace(`[update_check] アプリファイルが見つかりません url=${t + i}`);
      return;
    }
    const s = this.#e.downloads + "/" + i;
    A.debugLog && rt.myTrace(`[update_check] pathDL=${s}`, "D");
    const o = await n.arrayBuffer();
    await this.writeFileSync(s, new DataView(o));
  }
  // アプリウインドウ設定
  window = (t) => {
    const e = L(t, "x", Number(this.val.getVal("sys:const.sn.nativeWindow.x", 0))), i = L(t, "y", Number(this.val.getVal("sys:const.sn.nativeWindow.y", 0))), n = L(t, "w", Number(this.val.getVal("sys:const.sn.nativeWindow.w", A.stageW))), s = L(t, "h", Number(this.val.getVal("sys:const.sn.nativeWindow.h", A.stageH)));
    return wt.window($(t, "centering", !1), e, i, A.stageW, A.stageH), this.val.setVal_Nochk("sys", "const.sn.nativeWindow.x", e), this.val.setVal_Nochk("sys", "const.sn.nativeWindow.y", i), this.val.setVal_Nochk("sys", "const.sn.nativeWindow.w", n), this.val.setVal_Nochk("sys", "const.sn.nativeWindow.h", s), this.flush(), !1;
  };
  capturePage(t, e, i, n) {
    wt.capturePage(t, e, i).then(() => n());
  }
}
export {
  dr as B,
  A as C,
  m0 as I,
  Nt as L,
  j as R,
  Dt as S,
  $ as a,
  L as b,
  nh as c,
  mn as d,
  g0 as e,
  Po as g,
  Ye as i,
  ru as p,
  bt as u
};
//# sourceMappingURL=app2.js.map
