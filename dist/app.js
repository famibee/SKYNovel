var qP = Object.defineProperty;
var ZP = (i, t, e) => t in i ? qP(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var K = (i, t, e) => (ZP(i, typeof t != "symbol" ? t + "" : t, e), e), S0 = (i, t, e) => {
  if (!t.has(i))
    throw TypeError("Cannot " + e);
};
var c = (i, t, e) => (S0(i, t, "read from private field"), e ? e.call(i) : t.get(i)), E = (i, t, e) => {
  if (t.has(i))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(i) : t.set(i, e);
}, P = (i, t, e, r) => (S0(i, t, "write to private field"), r ? r.call(i, e) : t.set(i, e), e), Ve = (i, t, e, r) => ({
  set _(n) {
    P(i, t, n, e);
  },
  get _() {
    return c(i, t, r);
  }
}), O = (i, t, e) => (S0(i, t, "access private method"), e);
import { parse as KP, format as JP, resolve as QP } from "url";
import { Buffer as bE } from "buffer";
var Sp = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Jm(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var sv = { exports: {} };
/*!
 * Platform.js v1.3.6
 * Copyright 2014-2020 Benjamin Tan
 * Copyright 2011-2013 John-David Dalton
 * Available under MIT license
 */
sv.exports;
(function(i, t) {
  (function() {
    var e = {
      function: !0,
      object: !0
    }, r = e[typeof window] && window || this, n = t, s = i && !i.nodeType && i, a = n && s && typeof Sp == "object" && Sp;
    a && (a.global === a || a.window === a || a.self === a) && (r = a);
    var o = Math.pow(2, 53) - 1, u = /\bOpera/, l = Object.prototype, h = l.hasOwnProperty, d = l.toString;
    function f(C) {
      return C = String(C), C.charAt(0).toUpperCase() + C.slice(1);
    }
    function p(C, M, I) {
      var R = {
        "10.0": "10",
        "6.4": "10 Technical Preview",
        "6.3": "8.1",
        "6.2": "8",
        "6.1": "Server 2008 R2 / 7",
        "6.0": "Server 2008 / Vista",
        "5.2": "Server 2003 / XP 64-bit",
        "5.1": "XP",
        "5.01": "2000 SP1",
        "5.0": "2000",
        "4.0": "NT",
        "4.90": "ME"
      };
      return M && I && /^Win/i.test(C) && !/^Windows Phone /i.test(C) && (R = R[/[\d.]+$/.exec(C)]) && (C = "Windows " + R), C = String(C), M && I && (C = C.replace(RegExp(M, "i"), I)), C = g(
        C.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]
      ), C;
    }
    function v(C, M) {
      var I = -1, R = C ? C.length : 0;
      if (typeof R == "number" && R > -1 && R <= o)
        for (; ++I < R; )
          M(C[I], I, C);
      else
        m(C, M);
    }
    function g(C) {
      return C = T(C), /^(?:webOS|i(?:OS|P))/.test(C) ? C : f(C);
    }
    function m(C, M) {
      for (var I in C)
        h.call(C, I) && M(C[I], I, C);
    }
    function y(C) {
      return C == null ? f(C) : d.call(C).slice(8, -1);
    }
    function _(C, M) {
      var I = C != null ? typeof C[M] : "number";
      return !/^(?:boolean|number|string|undefined)$/.test(I) && (I == "object" ? !!C[M] : !0);
    }
    function b(C) {
      return String(C).replace(/([ -])(?!$)/g, "$1?");
    }
    function w(C, M) {
      var I = null;
      return v(C, function(R, N) {
        I = M(I, R, N, C);
      }), I;
    }
    function T(C) {
      return String(C).replace(/^ +| +$/g, "");
    }
    function x(C) {
      var M = r, I = C && typeof C == "object" && y(C) != "String";
      I && (M = C, C = null);
      var R = M.navigator || {}, N = R.userAgent || "";
      C || (C = N);
      var A = I ? !!R.likeChrome : /\bChrome\b/.test(C) && !/internal|\n/i.test(d.toString()), G = "Object", B = I ? G : "ScriptBridgingProxyObject", U = I ? G : "Environment", $ = I && M.java ? "JavaPackage" : y(M.java), Z = I ? G : "RuntimeObject", H = /\bJava/.test($) && M.java, z = H && y(M.environment) == U, X = H ? "a" : "α", ct = H ? "b" : "β", it = M.document || {}, lt = M.operamini || M.opera, et = u.test(et = I && lt ? lt["[[Class]]"] : y(lt)) ? et : lt = null, k, ft = C, Q = [], St = null, at = C == N, q = at && lt && typeof lt.version == "function" && lt.version(), bt, st = xt([
        { label: "EdgeHTML", pattern: "Edge" },
        "Trident",
        { label: "WebKit", pattern: "AppleWebKit" },
        "iCab",
        "Presto",
        "NetFront",
        "Tasman",
        "KHTML",
        "Gecko"
      ]), W = Ct([
        "Adobe AIR",
        "Arora",
        "Avant Browser",
        "Breach",
        "Camino",
        "Electron",
        "Epiphany",
        "Fennec",
        "Flock",
        "Galeon",
        "GreenBrowser",
        "iCab",
        "Iceweasel",
        "K-Meleon",
        "Konqueror",
        "Lunascape",
        "Maxthon",
        { label: "Microsoft Edge", pattern: "(?:Edge|Edg|EdgA|EdgiOS)" },
        "Midori",
        "Nook Browser",
        "PaleMoon",
        "PhantomJS",
        "Raven",
        "Rekonq",
        "RockMelt",
        { label: "Samsung Internet", pattern: "SamsungBrowser" },
        "SeaMonkey",
        { label: "Silk", pattern: "(?:Cloud9|Silk-Accelerated)" },
        "Sleipnir",
        "SlimBrowser",
        { label: "SRWare Iron", pattern: "Iron" },
        "Sunrise",
        "Swiftfox",
        "Vivaldi",
        "Waterfox",
        "WebPositive",
        { label: "Yandex Browser", pattern: "YaBrowser" },
        { label: "UC Browser", pattern: "UCBrowser" },
        "Opera Mini",
        { label: "Opera Mini", pattern: "OPiOS" },
        "Opera",
        { label: "Opera", pattern: "OPR" },
        "Chromium",
        "Chrome",
        { label: "Chrome", pattern: "(?:HeadlessChrome)" },
        { label: "Chrome Mobile", pattern: "(?:CriOS|CrMo)" },
        { label: "Firefox", pattern: "(?:Firefox|Minefield)" },
        { label: "Firefox for iOS", pattern: "FxiOS" },
        { label: "IE", pattern: "IEMobile" },
        { label: "IE", pattern: "MSIE" },
        "Safari"
      ]), nt = je([
        { label: "BlackBerry", pattern: "BB10" },
        "BlackBerry",
        { label: "Galaxy S", pattern: "GT-I9000" },
        { label: "Galaxy S2", pattern: "GT-I9100" },
        { label: "Galaxy S3", pattern: "GT-I9300" },
        { label: "Galaxy S4", pattern: "GT-I9500" },
        { label: "Galaxy S5", pattern: "SM-G900" },
        { label: "Galaxy S6", pattern: "SM-G920" },
        { label: "Galaxy S6 Edge", pattern: "SM-G925" },
        { label: "Galaxy S7", pattern: "SM-G930" },
        { label: "Galaxy S7 Edge", pattern: "SM-G935" },
        "Google TV",
        "Lumia",
        "iPad",
        "iPod",
        "iPhone",
        "Kindle",
        { label: "Kindle Fire", pattern: "(?:Cloud9|Silk-Accelerated)" },
        "Nexus",
        "Nook",
        "PlayBook",
        "PlayStation Vita",
        "PlayStation",
        "TouchPad",
        "Transformer",
        { label: "Wii U", pattern: "WiiU" },
        "Wii",
        "Xbox One",
        { label: "Xbox 360", pattern: "Xbox" },
        "Xoom"
      ]), dt = Dt({
        Apple: { iPad: 1, iPhone: 1, iPod: 1 },
        Alcatel: {},
        Archos: {},
        Amazon: { Kindle: 1, "Kindle Fire": 1 },
        Asus: { Transformer: 1 },
        "Barnes & Noble": { Nook: 1 },
        BlackBerry: { PlayBook: 1 },
        Google: { "Google TV": 1, Nexus: 1 },
        HP: { TouchPad: 1 },
        HTC: {},
        Huawei: {},
        Lenovo: {},
        LG: {},
        Microsoft: { Xbox: 1, "Xbox One": 1 },
        Motorola: { Xoom: 1 },
        Nintendo: { "Wii U": 1, Wii: 1 },
        Nokia: { Lumia: 1 },
        Oppo: {},
        Samsung: { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 },
        Sony: { PlayStation: 1, "PlayStation Vita": 1 },
        Xiaomi: { Mi: 1, Redmi: 1 }
      }), V = be([
        "Windows Phone",
        "KaiOS",
        "Android",
        "CentOS",
        { label: "Chrome OS", pattern: "CrOS" },
        "Debian",
        { label: "DragonFly BSD", pattern: "DragonFly" },
        "Fedora",
        "FreeBSD",
        "Gentoo",
        "Haiku",
        "Kubuntu",
        "Linux Mint",
        "OpenBSD",
        "Red Hat",
        "SuSE",
        "Ubuntu",
        "Xubuntu",
        "Cygwin",
        "Symbian OS",
        "hpwOS",
        "webOS ",
        "webOS",
        "Tablet OS",
        "Tizen",
        "Linux",
        "Mac OS X",
        "Macintosh",
        "Mac",
        "Windows 98;",
        "Windows "
      ]);
      function xt(ae) {
        return w(ae, function(ne, Ht) {
          return ne || RegExp("\\b" + (Ht.pattern || b(Ht)) + "\\b", "i").exec(C) && (Ht.label || Ht);
        });
      }
      function Dt(ae) {
        return w(ae, function(ne, Ht, xr) {
          return ne || (Ht[nt] || Ht[/^[a-z]+(?: +[a-z]+\b)*/i.exec(nt)] || RegExp("\\b" + b(xr) + "(?:\\b|\\w*\\d)", "i").exec(C)) && xr;
        });
      }
      function Ct(ae) {
        return w(ae, function(ne, Ht) {
          return ne || RegExp("\\b" + (Ht.pattern || b(Ht)) + "\\b", "i").exec(C) && (Ht.label || Ht);
        });
      }
      function be(ae) {
        return w(ae, function(ne, Ht) {
          var xr = Ht.pattern || b(Ht);
          return !ne && (ne = RegExp("\\b" + xr + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(C)) && (ne = p(ne, xr, Ht.label || Ht)), ne;
        });
      }
      function je(ae) {
        return w(ae, function(ne, Ht) {
          var xr = Ht.pattern || b(Ht);
          return !ne && (ne = RegExp("\\b" + xr + " *\\d+[.\\w_]*", "i").exec(C) || RegExp("\\b" + xr + " *\\w+-[\\w]*", "i").exec(C) || RegExp("\\b" + xr + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(C)) && ((ne = String(Ht.label && !RegExp(xr, "i").test(Ht.label) ? Ht.label : ne).split("/"))[1] && !/[\d.]+/.test(ne[0]) && (ne[0] += " " + ne[1]), Ht = Ht.label || Ht, ne = g(ne[0].replace(RegExp(xr, "i"), Ht).replace(RegExp("; *(?:" + Ht + "[_-])?", "i"), " ").replace(RegExp("(" + Ht + ")[-_.]?(\\w)", "i"), "$1 $2"))), ne;
        });
      }
      function ee(ae) {
        return w(ae, function(ne, Ht) {
          return ne || (RegExp(Ht + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(C) || 0)[1] || null;
        });
      }
      function pe() {
        return this.description || "";
      }
      if (st && (st = [st]), /\bAndroid\b/.test(V) && !nt && (k = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(C)) && (nt = T(k[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null), dt && !nt ? nt = je([dt]) : dt && nt && (nt = nt.replace(RegExp("^(" + b(dt) + ")[-_.\\s]", "i"), dt + " ").replace(RegExp("^(" + b(dt) + ")[-_.]?(\\w)", "i"), dt + " $2")), (k = /\bGoogle TV\b/.exec(nt)) && (nt = k[0]), /\bSimulator\b/i.test(C) && (nt = (nt ? nt + " " : "") + "Simulator"), W == "Opera Mini" && /\bOPiOS\b/.test(C) && Q.push("running in Turbo/Uncompressed mode"), W == "IE" && /\blike iPhone OS\b/.test(C) ? (k = x(C.replace(/like iPhone OS/, "")), dt = k.manufacturer, nt = k.product) : /^iP/.test(nt) ? (W || (W = "Safari"), V = "iOS" + ((k = / OS ([\d_]+)/i.exec(C)) ? " " + k[1].replace(/_/g, ".") : "")) : W == "Konqueror" && /^Linux\b/i.test(V) ? V = "Kubuntu" : dt && dt != "Google" && (/Chrome/.test(W) && !/\bMobile Safari\b/i.test(C) || /\bVita\b/.test(nt)) || /\bAndroid\b/.test(V) && /^Chrome/.test(W) && /\bVersion\//i.test(C) ? (W = "Android Browser", V = /\bAndroid\b/.test(V) ? V : "Android") : W == "Silk" ? (/\bMobi/i.test(C) || (V = "Android", Q.unshift("desktop mode")), /Accelerated *= *true/i.test(C) && Q.unshift("accelerated")) : W == "UC Browser" && /\bUCWEB\b/.test(C) ? Q.push("speed mode") : W == "PaleMoon" && (k = /\bFirefox\/([\d.]+)\b/.exec(C)) ? Q.push("identifying as Firefox " + k[1]) : W == "Firefox" && (k = /\b(Mobile|Tablet|TV)\b/i.exec(C)) ? (V || (V = "Firefox OS"), nt || (nt = k[1])) : !W || (k = !/\bMinefield\b/i.test(C) && /\b(?:Firefox|Safari)\b/.exec(W)) ? (W && !nt && /[\/,]|^[^(]+?\)/.test(C.slice(C.indexOf(k + "/") + 8)) && (W = null), (k = nt || dt || V) && (nt || dt || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(V)) && (W = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(V) ? V : k) + " Browser")) : W == "Electron" && (k = (/\bChrome\/([\d.]+)\b/.exec(C) || 0)[1]) && Q.push("Chromium " + k), q || (q = ee([
        "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
        "Version",
        b(W),
        "(?:Firefox|Minefield|NetFront)"
      ])), (k = st == "iCab" && parseFloat(q) > 3 && "WebKit" || /\bOpera\b/.test(W) && (/\bOPR\b/.test(C) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(C) && !/^(?:Trident|EdgeHTML)$/.test(st) && "WebKit" || !st && /\bMSIE\b/i.test(C) && (V == "Mac OS" ? "Tasman" : "Trident") || st == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(W) && "NetFront") && (st = [k]), W == "IE" && (k = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(C) || 0)[1]) ? (W += " Mobile", V = "Windows Phone " + (/\+$/.test(k) ? k : k + ".x"), Q.unshift("desktop mode")) : /\bWPDesktop\b/i.test(C) ? (W = "IE Mobile", V = "Windows Phone 8.x", Q.unshift("desktop mode"), q || (q = (/\brv:([\d.]+)/.exec(C) || 0)[1])) : W != "IE" && st == "Trident" && (k = /\brv:([\d.]+)/.exec(C)) && (W && Q.push("identifying as " + W + (q ? " " + q : "")), W = "IE", q = k[1]), at) {
        if (_(M, "global"))
          if (H && (k = H.lang.System, ft = k.getProperty("os.arch"), V = V || k.getProperty("os.name") + " " + k.getProperty("os.version")), z) {
            try {
              q = M.require("ringo/engine").version.join("."), W = "RingoJS";
            } catch {
              (k = M.system) && k.global.system == M.system && (W = "Narwhal", V || (V = k[0].os || null));
            }
            W || (W = "Rhino");
          } else
            typeof M.process == "object" && !M.process.browser && (k = M.process) && (typeof k.versions == "object" && (typeof k.versions.electron == "string" ? (Q.push("Node " + k.versions.node), W = "Electron", q = k.versions.electron) : typeof k.versions.nw == "string" && (Q.push("Chromium " + q, "Node " + k.versions.node), W = "NW.js", q = k.versions.nw)), W || (W = "Node.js", ft = k.arch, V = k.platform, q = /[\d.]+/.exec(k.version), q = q ? q[0] : null));
        else
          y(k = M.runtime) == B ? (W = "Adobe AIR", V = k.flash.system.Capabilities.os) : y(k = M.phantom) == Z ? (W = "PhantomJS", q = (k = k.version || null) && k.major + "." + k.minor + "." + k.patch) : typeof it.documentMode == "number" && (k = /\bTrident\/(\d+)/i.exec(C)) ? (q = [q, it.documentMode], (k = +k[1] + 4) != q[1] && (Q.push("IE " + q[1] + " mode"), st && (st[1] = ""), q[1] = k), q = W == "IE" ? String(q[1].toFixed(1)) : q[0]) : typeof it.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(W) && (Q.push("masking as " + W + " " + q), W = "IE", q = "11.0", st = ["Trident"], V = "Windows");
        V = V && g(V);
      }
      if (q && (k = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(q) || /(?:alpha|beta)(?: ?\d)?/i.exec(C + ";" + (at && R.appMinorVersion)) || /\bMinefield\b/i.test(C) && "a") && (St = /b/i.test(k) ? "beta" : "alpha", q = q.replace(RegExp(k + "\\+?$"), "") + (St == "beta" ? ct : X) + (/\d+\+?/.exec(k) || "")), W == "Fennec" || W == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(V))
        W = "Firefox Mobile";
      else if (W == "Maxthon" && q)
        q = q.replace(/\.[\d.]+/, ".x");
      else if (/\bXbox\b/i.test(nt))
        nt == "Xbox 360" && (V = null), nt == "Xbox 360" && /\bIEMobile\b/.test(C) && Q.unshift("mobile mode");
      else if ((/^(?:Chrome|IE|Opera)$/.test(W) || W && !nt && !/Browser|Mobi/.test(W)) && (V == "Windows CE" || /Mobi/i.test(C)))
        W += " Mobile";
      else if (W == "IE" && at)
        try {
          M.external === null && Q.unshift("platform preview");
        } catch {
          Q.unshift("embedded");
        }
      else
        (/\bBlackBerry\b/.test(nt) || /\bBB10\b/.test(C)) && (k = (RegExp(nt.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(C) || 0)[1] || q) ? (k = [k, /BB10/.test(C)], V = (k[1] ? (nt = null, dt = "BlackBerry") : "Device Software") + " " + k[0], q = null) : this != m && nt != "Wii" && (at && lt || /Opera/.test(W) && /\b(?:MSIE|Firefox)\b/i.test(C) || W == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(V) || W == "IE" && (V && !/^Win/.test(V) && q > 5.5 || /\bWindows XP\b/.test(V) && q > 8 || q == 8 && !/\bTrident\b/.test(C))) && !u.test(k = x.call(m, C.replace(u, "") + ";")) && k.name && (k = "ing as " + k.name + ((k = k.version) ? " " + k : ""), u.test(W) ? (/\bIE\b/.test(k) && V == "Mac OS" && (V = null), k = "identify" + k) : (k = "mask" + k, et ? W = g(et.replace(/([a-z])([A-Z])/g, "$1 $2")) : W = "Opera", /\bIE\b/.test(k) && (V = null), at || (q = null)), st = ["Presto"], Q.push(k));
      (k = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(C) || 0)[1]) && (k = [parseFloat(k.replace(/\.(\d)$/, ".0$1")), k], W == "Safari" && k[1].slice(-1) == "+" ? (W = "WebKit Nightly", St = "alpha", q = k[1].slice(0, -1)) : (q == k[1] || q == (k[2] = (/\bSafari\/([\d.]+\+?)/i.exec(C) || 0)[1])) && (q = null), k[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(C) || 0)[1], k[0] == 537.36 && k[2] == 537.36 && parseFloat(k[1]) >= 28 && st == "WebKit" && (st = ["Blink"]), !at || !A && !k[1] ? (st && (st[1] = "like Safari"), k = (k = k[0], k < 400 ? 1 : k < 500 ? 2 : k < 526 ? 3 : k < 533 ? 4 : k < 534 ? "4+" : k < 535 ? 5 : k < 537 ? 6 : k < 538 ? 7 : k < 601 ? 8 : k < 602 ? 9 : k < 604 ? 10 : k < 606 ? 11 : k < 608 ? 12 : "12")) : (st && (st[1] = "like Chrome"), k = k[1] || (k = k[0], k < 530 ? 1 : k < 532 ? 2 : k < 532.05 ? 3 : k < 533 ? 4 : k < 534.03 ? 5 : k < 534.07 ? 6 : k < 534.1 ? 7 : k < 534.13 ? 8 : k < 534.16 ? 9 : k < 534.24 ? 10 : k < 534.3 ? 11 : k < 535.01 ? 12 : k < 535.02 ? "13+" : k < 535.07 ? 15 : k < 535.11 ? 16 : k < 535.19 ? 17 : k < 536.05 ? 18 : k < 536.1 ? 19 : k < 537.01 ? 20 : k < 537.11 ? "21+" : k < 537.13 ? 23 : k < 537.18 ? 24 : k < 537.24 ? 25 : k < 537.36 ? 26 : st != "Blink" ? "27" : "28")), st && (st[1] += " " + (k += typeof k == "number" ? ".x" : /[.+]/.test(k) ? "" : "+")), W == "Safari" && (!q || parseInt(q) > 45) ? q = k : W == "Chrome" && /\bHeadlessChrome/i.test(C) && Q.unshift("headless")), W == "Opera" && (k = /\bzbov|zvav$/.exec(V)) ? (W += " ", Q.unshift("desktop mode"), k == "zvav" ? (W += "Mini", q = null) : W += "Mobile", V = V.replace(RegExp(" *" + k + "$"), "")) : W == "Safari" && /\bChrome\b/.exec(st && st[1]) ? (Q.unshift("desktop mode"), W = "Chrome Mobile", q = null, /\bOS X\b/.test(V) ? (dt = "Apple", V = "iOS 4.3+") : V = null) : /\bSRWare Iron\b/.test(W) && !q && (q = ee("Chrome")), q && q.indexOf(k = /[\d.]+$/.exec(V)) == 0 && C.indexOf("/" + k + "-") > -1 && (V = T(V.replace(k, ""))), V && V.indexOf(W) != -1 && !RegExp(W + " OS").test(V) && (V = V.replace(RegExp(" *" + b(W) + " *"), "")), st && !/\b(?:Avant|Nook)\b/.test(W) && (/Browser|Lunascape|Maxthon/.test(W) || W != "Safari" && /^iOS/.test(V) && /\bSafari\b/.test(st[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(W) && st[1]) && (k = st[st.length - 1]) && Q.push(k), Q.length && (Q = ["(" + Q.join("; ") + ")"]), dt && nt && nt.indexOf(dt) < 0 && Q.push("on " + dt), nt && Q.push((/^on /.test(Q[Q.length - 1]) ? "" : "on ") + nt), V && (k = / ([\d.+]+)$/.exec(V), bt = k && V.charAt(V.length - k[0].length - 1) == "/", V = {
        architecture: 32,
        family: k && !bt ? V.replace(k[0], "") : V,
        version: k ? k[1] : null,
        toString: function() {
          var ae = this.version;
          return this.family + (ae && !bt ? " " + ae : "") + (this.architecture == 64 ? " 64-bit" : "");
        }
      }), (k = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(ft)) && !/\bi686\b/i.test(ft) ? (V && (V.architecture = 64, V.family = V.family.replace(RegExp(" *" + k), "")), W && (/\bWOW64\b/i.test(C) || at && /\w(?:86|32)$/.test(R.cpuClass || R.platform) && !/\bWin64; x64\b/i.test(C)) && Q.unshift("32-bit")) : V && /^OS X/.test(V.family) && W == "Chrome" && parseFloat(q) >= 39 && (V.architecture = 64), C || (C = null);
      var le = {};
      return le.description = C, le.layout = st && st[0], le.manufacturer = dt, le.name = W, le.prerelease = St, le.product = nt, le.ua = C, le.version = W && q, le.os = V || {
        /**
         * The CPU architecture the OS is built for.
         *
         * @memberOf platform.os
         * @type number|null
         */
        architecture: null,
        /**
         * The family of the OS.
         *
         * Common values include:
         * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
         * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
         * "SuSE", "Android", "iOS" and "Windows Phone"
         *
         * @memberOf platform.os
         * @type string|null
         */
        family: null,
        /**
         * The version of the OS.
         *
         * @memberOf platform.os
         * @type string|null
         */
        version: null,
        /**
         * Returns the OS string.
         *
         * @memberOf platform.os
         * @returns {string} The OS string.
         */
        toString: function() {
          return "null";
        }
      }, le.parse = x, le.toString = pe, le.version && Q.unshift(q), le.name && Q.unshift(W), V && W && !(V == String(V).split(" ")[0] && (V == W.split(" ")[0] || nt)) && Q.push(nt ? "(" + V + ")" : "on " + V), Q.length && (le.description = Q.join(" ")), le;
    }
    var S = x();
    n && s ? m(S, function(C, M) {
      n[M] = C;
    }) : r.platform = S;
  }).call(Sp);
})(sv, sv.exports);
var Mh = sv.exports;
const xE = /* @__PURE__ */ Jm(Mh);
function $t(i) {
  return parseInt(String(i), 10);
}
function ii(i) {
  const t = parseInt(String(i), 10);
  return t < 0 ? -t : t;
}
"toInt" in String.prototype || (String.prototype.toInt = function() {
  return $t(this);
});
"toUint" in String.prototype || (String.prototype.toUint = function() {
  const i = $t(this);
  return i < 0 ? -i : i;
});
function ec(i = "/", t = " ", e = ":", r = "") {
  const n = /* @__PURE__ */ new Date();
  return n.getFullYear() + i + String(100 + n.getMonth() + 1).slice(1, 3) + i + String(100 + n.getDate()).slice(1, 3) + t + String(100 + n.getHours()).slice(1, 3) + e + String(100 + n.getMinutes()).slice(1, 3) + (r === "" ? "" : r + String(n.getMilliseconds()));
}
const wE = {
  alpha: 0,
  height: 0,
  rotation: 0,
  scale_x: 0,
  scale_y: 0,
  pivot_x: 0,
  pivot_y: 0,
  width: 0,
  x: 0,
  y: 0
};
function av(i, t) {
  const e = {};
  for (const r of Object.keys(wE)) {
    if (!(r in i))
      continue;
    const n = String(i[r]), s = (n.at(0) === "=" ? n.slice(1) : n).split(","), a = e[r] = parseFloat(s[0]);
    s.length > 1 && (e[r] += Math.round(Math.random() * (parseFloat(s[1]) - a + 1))), n.at(0) === "=" && (e[r] += parseFloat(t[r]));
  }
  return e;
}
const EE = "/* SKYNovel */";
function tO() {
  const i = document.getElementsByTagName("head")[0], t = i.children.length;
  for (let e = t - 1; e >= 0; --e) {
    const r = i.children[e];
    r instanceof HTMLStyleElement && r.innerText.slice(0, 14) === EE && i.removeChild(r);
  }
}
function Au(i) {
  const t = document.createElement("style");
  t.innerHTML = EE + i, document.getElementsByTagName("head")[0].appendChild(t);
}
function tt(i, t, e) {
  const r = i[t];
  if (!(t in i)) {
    if (isNaN(e))
      throw `[${i[":タグ名"]}]属性 ${t} は必須です`;
    return i[t] = e, e;
  }
  const n = String(r).slice(0, 2) === "0x" ? parseInt(r) : parseFloat(r);
  if (isNaN(n))
    throw `[${i[":タグ名"]}]属性 ${t} の値【${r}】が数値ではありません`;
  return i[t] = n;
}
function vt(i, t, e) {
  if (!(t in i))
    return i[t] = e;
  const r = i[t];
  if (r === null)
    return !1;
  const n = String(r);
  return i[t] = n === "false" ? !1 : !!n;
}
function xb(i) {
  if (i.at(0) === "#")
    return parseInt(i.slice(1), 16);
  const t = Number(i);
  if (!isNaN(t))
    return t;
  if (i === "black")
    return 0;
  Y.cc4ColorName.fillStyle = i;
  const e = Y.cc4ColorName.fillStyle;
  if (e === "#000000")
    throw `色名前 ${i} が異常です`;
  return parseInt(e.slice(1), 16);
}
function SE(i, t, e) {
  const r = i[t];
  return r ? i[t] = xb(String(r)) : i[t] = e;
}
const eO = /JSON at position (\d+)$/;
function Tp(i, t = "", e = "") {
  const r = (e.match(eO) ?? ["", ""])[1];
  return `[${i[":タグ名"]}] ${t} 属性の解析エラー : ${e}
${i[t]}${r ? `
${"^".padStart(Number(r))}` : ""}`;
}
const rO = /^[^\/\.]+$|[^\/]+(?=\.)/;
function Vh(i) {
  return (i.match(rO) ?? [""])[0];
}
const iO = /\.([^\.]+)$/;
function ov(i) {
  return (i.match(iO) ?? ["", ""])[1];
}
var yE, _E;
class Y {
}
K(Y, "stageW", 0), K(Y, "stageH", 0), K(Y, "debugLog", !1), K(Y, "isSafari", Mh.name === "Safari"), K(Y, "isFirefox", Mh.name === "Firefox"), K(Y, "isMac", new RegExp("OS X").test(((yE = Mh.os) == null ? void 0 : yE.family) ?? "")), K(Y, "isMobile", !new RegExp("(Windows|OS X)").test(((_E = Mh.os) == null ? void 0 : _E.family) ?? "")), K(Y, "hDip", {}), K(Y, "isDbg", !1), K(Y, "isPackaged", !1), K(Y, "isDarkMode", !1), K(Y, "cc4ColorName");
function nO(i) {
  var t = this.constructor;
  return this.then(
    function(e) {
      return t.resolve(i()).then(function() {
        return e;
      });
    },
    function(e) {
      return t.resolve(i()).then(function() {
        return t.reject(e);
      });
    }
  );
}
function sO(i) {
  var t = this;
  return new t(function(e, r) {
    if (!(i && typeof i.length < "u"))
      return r(
        new TypeError(
          typeof i + " " + i + " is not iterable(cannot read property Symbol(Symbol.iterator))"
        )
      );
    var n = Array.prototype.slice.call(i);
    if (n.length === 0)
      return e([]);
    var s = n.length;
    function a(u, l) {
      if (l && (typeof l == "object" || typeof l == "function")) {
        var h = l.then;
        if (typeof h == "function") {
          h.call(
            l,
            function(d) {
              a(u, d);
            },
            function(d) {
              n[u] = { status: "rejected", reason: d }, --s === 0 && e(n);
            }
          );
          return;
        }
      }
      n[u] = { status: "fulfilled", value: l }, --s === 0 && e(n);
    }
    for (var o = 0; o < n.length; o++)
      a(o, n[o]);
  });
}
function TE(i, t) {
  this.name = "AggregateError", this.errors = i, this.message = t || "";
}
TE.prototype = Error.prototype;
function aO(i) {
  var t = this;
  return new t(function(e, r) {
    if (!(i && typeof i.length < "u"))
      return r(new TypeError("Promise.any accepts an array"));
    var n = Array.prototype.slice.call(i);
    if (n.length === 0)
      return r();
    for (var s = [], a = 0; a < n.length; a++)
      try {
        t.resolve(n[a]).then(e).catch(function(o) {
          s.push(o), s.length === n.length && r(
            new TE(
              s,
              "All promises were rejected"
            )
          );
        });
      } catch (o) {
        r(o);
      }
  });
}
var oO = setTimeout;
function CE(i) {
  return !!(i && typeof i.length < "u");
}
function uO() {
}
function lO(i, t) {
  return function() {
    i.apply(t, arguments);
  };
}
function Fe(i) {
  if (!(this instanceof Fe))
    throw new TypeError("Promises must be constructed via new");
  if (typeof i != "function")
    throw new TypeError("not a function");
  this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], PE(i, this);
}
function ME(i, t) {
  for (; i._state === 3; )
    i = i._value;
  if (i._state === 0) {
    i._deferreds.push(t);
    return;
  }
  i._handled = !0, Fe._immediateFn(function() {
    var e = i._state === 1 ? t.onFulfilled : t.onRejected;
    if (e === null) {
      (i._state === 1 ? dy : rc)(t.promise, i._value);
      return;
    }
    var r;
    try {
      r = e(i._value);
    } catch (n) {
      rc(t.promise, n);
      return;
    }
    dy(t.promise, r);
  });
}
function dy(i, t) {
  try {
    if (t === i)
      throw new TypeError("A promise cannot be resolved with itself.");
    if (t && (typeof t == "object" || typeof t == "function")) {
      var e = t.then;
      if (t instanceof Fe) {
        i._state = 3, i._value = t, py(i);
        return;
      } else if (typeof e == "function") {
        PE(lO(e, t), i);
        return;
      }
    }
    i._state = 1, i._value = t, py(i);
  } catch (r) {
    rc(i, r);
  }
}
function rc(i, t) {
  i._state = 2, i._value = t, py(i);
}
function py(i) {
  i._state === 2 && i._deferreds.length === 0 && Fe._immediateFn(function() {
    i._handled || Fe._unhandledRejectionFn(i._value);
  });
  for (var t = 0, e = i._deferreds.length; t < e; t++)
    ME(i, i._deferreds[t]);
  i._deferreds = null;
}
function hO(i, t, e) {
  this.onFulfilled = typeof i == "function" ? i : null, this.onRejected = typeof t == "function" ? t : null, this.promise = e;
}
function PE(i, t) {
  var e = !1;
  try {
    i(
      function(r) {
        e || (e = !0, dy(t, r));
      },
      function(r) {
        e || (e = !0, rc(t, r));
      }
    );
  } catch (r) {
    if (e)
      return;
    e = !0, rc(t, r);
  }
}
Fe.prototype.catch = function(i) {
  return this.then(null, i);
};
Fe.prototype.then = function(i, t) {
  var e = new this.constructor(uO);
  return ME(this, new hO(i, t, e)), e;
};
Fe.prototype.finally = nO;
Fe.all = function(i) {
  return new Fe(function(t, e) {
    if (!CE(i))
      return e(new TypeError("Promise.all accepts an array"));
    var r = Array.prototype.slice.call(i);
    if (r.length === 0)
      return t([]);
    var n = r.length;
    function s(o, u) {
      try {
        if (u && (typeof u == "object" || typeof u == "function")) {
          var l = u.then;
          if (typeof l == "function") {
            l.call(
              u,
              function(h) {
                s(o, h);
              },
              e
            );
            return;
          }
        }
        r[o] = u, --n === 0 && t(r);
      } catch (h) {
        e(h);
      }
    }
    for (var a = 0; a < r.length; a++)
      s(a, r[a]);
  });
};
Fe.any = aO;
Fe.allSettled = sO;
Fe.resolve = function(i) {
  return i && typeof i == "object" && i.constructor === Fe ? i : new Fe(function(t) {
    t(i);
  });
};
Fe.reject = function(i) {
  return new Fe(function(t, e) {
    e(i);
  });
};
Fe.race = function(i) {
  return new Fe(function(t, e) {
    if (!CE(i))
      return e(new TypeError("Promise.race accepts an array"));
    for (var r = 0, n = i.length; r < n; r++)
      Fe.resolve(i[r]).then(t, e);
  });
};
Fe._immediateFn = // @ts-ignore
typeof setImmediate == "function" && function(i) {
  setImmediate(i);
} || function(i) {
  oO(i, 0);
};
Fe._unhandledRejectionFn = function(t) {
  typeof console < "u" && console && console.warn("Possible Unhandled Promise Rejection:", t);
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Qx = Object.getOwnPropertySymbols, cO = Object.prototype.hasOwnProperty, fO = Object.prototype.propertyIsEnumerable;
function dO(i) {
  if (i == null)
    throw new TypeError("Object.assign cannot be called with null or undefined");
  return Object(i);
}
function pO() {
  try {
    if (!Object.assign)
      return !1;
    var i = new String("abc");
    if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
      return !1;
    for (var t = {}, e = 0; e < 10; e++)
      t["_" + String.fromCharCode(e)] = e;
    var r = Object.getOwnPropertyNames(t).map(function(s) {
      return t[s];
    });
    if (r.join("") !== "0123456789")
      return !1;
    var n = {};
    return "abcdefghijklmnopqrst".split("").forEach(function(s) {
      n[s] = s;
    }), Object.keys(Object.assign({}, n)).join("") === "abcdefghijklmnopqrst";
  } catch {
    return !1;
  }
}
var vO = pO() ? Object.assign : function(i, t) {
  for (var e, r = dO(i), n, s = 1; s < arguments.length; s++) {
    e = Object(arguments[s]);
    for (var a in e)
      cO.call(e, a) && (r[a] = e[a]);
    if (Qx) {
      n = Qx(e);
      for (var o = 0; o < n.length; o++)
        fO.call(e, n[o]) && (r[n[o]] = e[n[o]]);
    }
  }
  return r;
};
const gO = /* @__PURE__ */ Jm(vO);
/*!
 * @pixi/polyfill - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/polyfill is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
typeof globalThis > "u" && (typeof self < "u" ? self.globalThis = self : typeof global < "u" && (global.globalThis = global));
globalThis.Promise || (globalThis.Promise = Fe);
Object.assign || (Object.assign = gO);
var mO = 16;
Date.now && Date.prototype.getTime || (Date.now = function() {
  return (/* @__PURE__ */ new Date()).getTime();
});
if (!(globalThis.performance && globalThis.performance.now)) {
  var yO = Date.now();
  globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {
    return Date.now() - yO;
  };
}
var T0 = Date.now(), t1 = ["ms", "moz", "webkit", "o"];
for (var C0 = 0; C0 < t1.length && !globalThis.requestAnimationFrame; ++C0) {
  var M0 = t1[C0];
  globalThis.requestAnimationFrame = globalThis[M0 + "RequestAnimationFrame"], globalThis.cancelAnimationFrame = globalThis[M0 + "CancelAnimationFrame"] || globalThis[M0 + "CancelRequestAnimationFrame"];
}
globalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(i) {
  if (typeof i != "function")
    throw new TypeError(i + "is not a function");
  var t = Date.now(), e = mO + T0 - t;
  return e < 0 && (e = 0), T0 = t, globalThis.self.setTimeout(function() {
    T0 = Date.now(), i(performance.now());
  }, e);
});
globalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(i) {
  return clearTimeout(i);
});
Math.sign || (Math.sign = function(t) {
  return t = Number(t), t === 0 || isNaN(t) ? t : t > 0 ? 1 : -1;
});
Number.isInteger || (Number.isInteger = function(t) {
  return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
});
globalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array);
globalThis.Float32Array || (globalThis.Float32Array = Array);
globalThis.Uint32Array || (globalThis.Uint32Array = Array);
globalThis.Uint16Array || (globalThis.Uint16Array = Array);
globalThis.Uint8Array || (globalThis.Uint8Array = Array);
globalThis.Int32Array || (globalThis.Int32Array = Array);
/*!
 * @pixi/constants - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Ts;
(function(i) {
  i[i.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", i[i.WEBGL = 1] = "WEBGL", i[i.WEBGL2 = 2] = "WEBGL2";
})(Ts || (Ts = {}));
var ic;
(function(i) {
  i[i.UNKNOWN = 0] = "UNKNOWN", i[i.WEBGL = 1] = "WEBGL", i[i.CANVAS = 2] = "CANVAS";
})(ic || (ic = {}));
var uv;
(function(i) {
  i[i.COLOR = 16384] = "COLOR", i[i.DEPTH = 256] = "DEPTH", i[i.STENCIL = 1024] = "STENCIL";
})(uv || (uv = {}));
var Et;
(function(i) {
  i[i.NORMAL = 0] = "NORMAL", i[i.ADD = 1] = "ADD", i[i.MULTIPLY = 2] = "MULTIPLY", i[i.SCREEN = 3] = "SCREEN", i[i.OVERLAY = 4] = "OVERLAY", i[i.DARKEN = 5] = "DARKEN", i[i.LIGHTEN = 6] = "LIGHTEN", i[i.COLOR_DODGE = 7] = "COLOR_DODGE", i[i.COLOR_BURN = 8] = "COLOR_BURN", i[i.HARD_LIGHT = 9] = "HARD_LIGHT", i[i.SOFT_LIGHT = 10] = "SOFT_LIGHT", i[i.DIFFERENCE = 11] = "DIFFERENCE", i[i.EXCLUSION = 12] = "EXCLUSION", i[i.HUE = 13] = "HUE", i[i.SATURATION = 14] = "SATURATION", i[i.COLOR = 15] = "COLOR", i[i.LUMINOSITY = 16] = "LUMINOSITY", i[i.NORMAL_NPM = 17] = "NORMAL_NPM", i[i.ADD_NPM = 18] = "ADD_NPM", i[i.SCREEN_NPM = 19] = "SCREEN_NPM", i[i.NONE = 20] = "NONE", i[i.SRC_OVER = 0] = "SRC_OVER", i[i.SRC_IN = 21] = "SRC_IN", i[i.SRC_OUT = 22] = "SRC_OUT", i[i.SRC_ATOP = 23] = "SRC_ATOP", i[i.DST_OVER = 24] = "DST_OVER", i[i.DST_IN = 25] = "DST_IN", i[i.DST_OUT = 26] = "DST_OUT", i[i.DST_ATOP = 27] = "DST_ATOP", i[i.ERASE = 26] = "ERASE", i[i.SUBTRACT = 28] = "SUBTRACT", i[i.XOR = 29] = "XOR";
})(Et || (Et = {}));
var qi;
(function(i) {
  i[i.POINTS = 0] = "POINTS", i[i.LINES = 1] = "LINES", i[i.LINE_LOOP = 2] = "LINE_LOOP", i[i.LINE_STRIP = 3] = "LINE_STRIP", i[i.TRIANGLES = 4] = "TRIANGLES", i[i.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", i[i.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(qi || (qi = {}));
var ht;
(function(i) {
  i[i.RGBA = 6408] = "RGBA", i[i.RGB = 6407] = "RGB", i[i.RG = 33319] = "RG", i[i.RED = 6403] = "RED", i[i.RGBA_INTEGER = 36249] = "RGBA_INTEGER", i[i.RGB_INTEGER = 36248] = "RGB_INTEGER", i[i.RG_INTEGER = 33320] = "RG_INTEGER", i[i.RED_INTEGER = 36244] = "RED_INTEGER", i[i.ALPHA = 6406] = "ALPHA", i[i.LUMINANCE = 6409] = "LUMINANCE", i[i.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", i[i.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", i[i.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(ht || (ht = {}));
var Xo;
(function(i) {
  i[i.TEXTURE_2D = 3553] = "TEXTURE_2D", i[i.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", i[i.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", i[i.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", i[i.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", i[i.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", i[i.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", i[i.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", i[i.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(Xo || (Xo = {}));
var It;
(function(i) {
  i[i.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", i[i.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", i[i.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", i[i.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", i[i.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", i[i.UNSIGNED_INT = 5125] = "UNSIGNED_INT", i[i.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", i[i.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", i[i.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", i[i.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", i[i.BYTE = 5120] = "BYTE", i[i.SHORT = 5122] = "SHORT", i[i.INT = 5124] = "INT", i[i.FLOAT = 5126] = "FLOAT", i[i.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", i[i.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(It || (It = {}));
var lv;
(function(i) {
  i[i.FLOAT = 0] = "FLOAT", i[i.INT = 1] = "INT", i[i.UINT = 2] = "UINT";
})(lv || (lv = {}));
var Cn;
(function(i) {
  i[i.NEAREST = 0] = "NEAREST", i[i.LINEAR = 1] = "LINEAR";
})(Cn || (Cn = {}));
var On;
(function(i) {
  i[i.CLAMP = 33071] = "CLAMP", i[i.REPEAT = 10497] = "REPEAT", i[i.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(On || (On = {}));
var tn;
(function(i) {
  i[i.OFF = 0] = "OFF", i[i.POW2 = 1] = "POW2", i[i.ON = 2] = "ON", i[i.ON_MANUAL = 3] = "ON_MANUAL";
})(tn || (tn = {}));
var en;
(function(i) {
  i[i.NPM = 0] = "NPM", i[i.UNPACK = 1] = "UNPACK", i[i.PMA = 2] = "PMA", i[i.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", i[i.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", i[i.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", i[i.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(en || (en = {}));
var Wi;
(function(i) {
  i[i.NO = 0] = "NO", i[i.YES = 1] = "YES", i[i.AUTO = 2] = "AUTO", i[i.BLEND = 0] = "BLEND", i[i.CLEAR = 1] = "CLEAR", i[i.BLIT = 2] = "BLIT";
})(Wi || (Wi = {}));
var hv;
(function(i) {
  i[i.AUTO = 0] = "AUTO", i[i.MANUAL = 1] = "MANUAL";
})(hv || (hv = {}));
var ni;
(function(i) {
  i.LOW = "lowp", i.MEDIUM = "mediump", i.HIGH = "highp";
})(ni || (ni = {}));
var Ze;
(function(i) {
  i[i.NONE = 0] = "NONE", i[i.SCISSOR = 1] = "SCISSOR", i[i.STENCIL = 2] = "STENCIL", i[i.SPRITE = 3] = "SPRITE", i[i.COLOR = 4] = "COLOR";
})(Ze || (Ze = {}));
var e1;
(function(i) {
  i[i.RED = 1] = "RED", i[i.GREEN = 2] = "GREEN", i[i.BLUE = 4] = "BLUE", i[i.ALPHA = 8] = "ALPHA";
})(e1 || (e1 = {}));
var ke;
(function(i) {
  i[i.NONE = 0] = "NONE", i[i.LOW = 2] = "LOW", i[i.MEDIUM = 4] = "MEDIUM", i[i.HIGH = 8] = "HIGH";
})(ke || (ke = {}));
var In;
(function(i) {
  i[i.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", i[i.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", i[i.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(In || (In = {}));
/*!
 * @pixi/settings - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var _O = {
  /**
   * Creates a canvas element of the given size.
   * This canvas is created using the browser's native canvas element.
   * @param width - width of the canvas
   * @param height - height of the canvas
   */
  createCanvas: function(i, t) {
    var e = document.createElement("canvas");
    return e.width = i, e.height = t, e;
  },
  getWebGLRenderingContext: function() {
    return WebGLRenderingContext;
  },
  getNavigator: function() {
    return navigator;
  },
  getBaseUrl: function() {
    var i;
    return (i = document.baseURI) !== null && i !== void 0 ? i : window.location.href;
  },
  fetch: function(i, t) {
    return fetch(i, t);
  }
}, P0 = /iPhone/i, r1 = /iPod/i, i1 = /iPad/i, n1 = /\biOS-universal(?:.+)Mac\b/i, O0 = /\bAndroid(?:.+)Mobile\b/i, s1 = /Android/i, pu = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, Ad = /Silk/i, Hn = /Windows Phone/i, a1 = /\bWindows(?:.+)ARM\b/i, o1 = /BlackBerry/i, u1 = /BB10/i, l1 = /Opera Mini/i, h1 = /\b(CriOS|Chrome)(?:.+)Mobile/i, c1 = /Mobile(?:.+)Firefox\b/i, f1 = function(i) {
  return typeof i < "u" && i.platform === "MacIntel" && typeof i.maxTouchPoints == "number" && i.maxTouchPoints > 1 && typeof MSStream > "u";
};
function bO(i) {
  return function(t) {
    return t.test(i);
  };
}
function xO(i) {
  var t = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  !i && typeof navigator < "u" ? t = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    maxTouchPoints: navigator.maxTouchPoints || 0
  } : typeof i == "string" ? t.userAgent = i : i && i.userAgent && (t = {
    userAgent: i.userAgent,
    platform: i.platform,
    maxTouchPoints: i.maxTouchPoints || 0
  });
  var e = t.userAgent, r = e.split("[FBAN");
  typeof r[1] < "u" && (e = r[0]), r = e.split("Twitter"), typeof r[1] < "u" && (e = r[0]);
  var n = bO(e), s = {
    apple: {
      phone: n(P0) && !n(Hn),
      ipod: n(r1),
      tablet: !n(P0) && (n(i1) || f1(t)) && !n(Hn),
      universal: n(n1),
      device: (n(P0) || n(r1) || n(i1) || n(n1) || f1(t)) && !n(Hn)
    },
    amazon: {
      phone: n(pu),
      tablet: !n(pu) && n(Ad),
      device: n(pu) || n(Ad)
    },
    android: {
      phone: !n(Hn) && n(pu) || !n(Hn) && n(O0),
      tablet: !n(Hn) && !n(pu) && !n(O0) && (n(Ad) || n(s1)),
      device: !n(Hn) && (n(pu) || n(Ad) || n(O0) || n(s1)) || n(/\bokhttp\b/i)
    },
    windows: {
      phone: n(Hn),
      tablet: n(a1),
      device: n(Hn) || n(a1)
    },
    other: {
      blackberry: n(o1),
      blackberry10: n(u1),
      opera: n(l1),
      firefox: n(c1),
      chrome: n(h1),
      device: n(o1) || n(u1) || n(l1) || n(c1) || n(h1)
    },
    any: !1,
    phone: !1,
    tablet: !1
  };
  return s.any = s.apple.device || s.android.device || s.windows.device || s.other.device, s.phone = s.apple.phone || s.android.phone || s.windows.phone, s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet, s;
}
var Mn = xO(globalThis.navigator);
function wO() {
  return !Mn.apple.device;
}
function EO(i) {
  var t = !0;
  if (Mn.tablet || Mn.phone) {
    if (Mn.apple.device) {
      var e = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (e) {
        var r = parseInt(e[1], 10);
        r < 11 && (t = !1);
      }
    }
    if (Mn.android.device) {
      var e = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (e) {
        var r = parseInt(e[1], 10);
        r < 7 && (t = !1);
      }
    }
  }
  return t ? i : 4;
}
var gt = {
  /**
   * This adapter is used to call methods that are platform dependent.
   * For example `document.createElement` only runs on the web but fails in node environments.
   * This allows us to support more platforms by abstracting away specific implementations per platform.
   *
   * By default the adapter is set to work in the browser. However you can create your own
   * by implementing the `IAdapter` interface. See `IAdapter` for more information.
   * @name ADAPTER
   * @memberof PIXI.settings
   * @type {PIXI.IAdapter}
   * @default PIXI.BrowserAdapter
   */
  ADAPTER: _O,
  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  MIPMAP_TEXTURES: tn.POW2,
  /**
   * Default anisotropic filtering level of textures.
   * Usually from 0 to 16
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @default 0
   */
  ANISOTROPIC_LEVEL: 0,
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Default filter resolution.
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,
  /**
   * Default filter samples.
   * @static
   * @name FILTER_MULTISAMPLE
   * @memberof PIXI.settings
   * @type {PIXI.MSAA_QUALITY}
   * @default PIXI.MSAA_QUALITY.NONE
   */
  FILTER_MULTISAMPLE: ke.NONE,
  /**
   * The maximum textures that this device supports.
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @type {number}
   * @default 32
   */
  SPRITE_MAX_TEXTURES: EO(32),
  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,
  /**
   * The default render options if none are supplied to {@link PIXI.Renderer}
   * or {@link PIXI.CanvasRenderer}.
   * @static
   * @name RENDER_OPTIONS
   * @memberof PIXI.settings
   * @type {object}
   * @property {HTMLCanvasElement} [view=null] -
   * @property {boolean} [antialias=false] -
   * @property {boolean} [autoDensity=false] -
   * @property {boolean} [useContextAlpha=true]  -
   * @property {number} [backgroundColor=0x000000] -
   * @property {number} [backgroundAlpha=1] -
   * @property {boolean} [clearBeforeRender=true] -
   * @property {boolean} [preserveDrawingBuffer=false] -
   * @property {number} [width=800] -
   * @property {number} [height=600] -
   * @property {boolean} [legacy=false] -
   */
  RENDER_OPTIONS: {
    view: null,
    antialias: !1,
    autoDensity: !1,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: !0,
    clearBeforeRender: !0,
    preserveDrawingBuffer: !1,
    width: 800,
    height: 600,
    legacy: !1
  },
  /**
   * Default Garbage Collection mode.
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: hv.AUTO,
  /**
   * Default Garbage Collection max idle.
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,
  /**
   * Default Garbage Collection maximum check count.
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,
  /**
   * Default wrap modes that are supported by pixi.
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: On.CLAMP,
  /**
   * Default scale mode for textures.
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: Cn.LINEAR,
  /**
   * Default specify float precision in vertex shader.
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.HIGH
   */
  PRECISION_VERTEX: ni.HIGH,
  /**
   * Default specify float precision in fragment shader.
   * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION_FRAGMENT: Mn.apple.device ? ni.HIGH : ni.MEDIUM,
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: wO(),
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: !1,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: !1
}, OE = { exports: {} };
(function(i) {
  var t = Object.prototype.hasOwnProperty, e = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (e = !1));
  function n(u, l, h) {
    this.fn = u, this.context = l, this.once = h || !1;
  }
  function s(u, l, h, d, f) {
    if (typeof h != "function")
      throw new TypeError("The listener must be a function");
    var p = new n(h, d || u, f), v = e ? e + l : l;
    return u._events[v] ? u._events[v].fn ? u._events[v] = [u._events[v], p] : u._events[v].push(p) : (u._events[v] = p, u._eventsCount++), u;
  }
  function a(u, l) {
    --u._eventsCount === 0 ? u._events = new r() : delete u._events[l];
  }
  function o() {
    this._events = new r(), this._eventsCount = 0;
  }
  o.prototype.eventNames = function() {
    var l = [], h, d;
    if (this._eventsCount === 0)
      return l;
    for (d in h = this._events)
      t.call(h, d) && l.push(e ? d.slice(1) : d);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(h)) : l;
  }, o.prototype.listeners = function(l) {
    var h = e ? e + l : l, d = this._events[h];
    if (!d)
      return [];
    if (d.fn)
      return [d.fn];
    for (var f = 0, p = d.length, v = new Array(p); f < p; f++)
      v[f] = d[f].fn;
    return v;
  }, o.prototype.listenerCount = function(l) {
    var h = e ? e + l : l, d = this._events[h];
    return d ? d.fn ? 1 : d.length : 0;
  }, o.prototype.emit = function(l, h, d, f, p, v) {
    var g = e ? e + l : l;
    if (!this._events[g])
      return !1;
    var m = this._events[g], y = arguments.length, _, b;
    if (m.fn) {
      switch (m.once && this.removeListener(l, m.fn, void 0, !0), y) {
        case 1:
          return m.fn.call(m.context), !0;
        case 2:
          return m.fn.call(m.context, h), !0;
        case 3:
          return m.fn.call(m.context, h, d), !0;
        case 4:
          return m.fn.call(m.context, h, d, f), !0;
        case 5:
          return m.fn.call(m.context, h, d, f, p), !0;
        case 6:
          return m.fn.call(m.context, h, d, f, p, v), !0;
      }
      for (b = 1, _ = new Array(y - 1); b < y; b++)
        _[b - 1] = arguments[b];
      m.fn.apply(m.context, _);
    } else {
      var w = m.length, T;
      for (b = 0; b < w; b++)
        switch (m[b].once && this.removeListener(l, m[b].fn, void 0, !0), y) {
          case 1:
            m[b].fn.call(m[b].context);
            break;
          case 2:
            m[b].fn.call(m[b].context, h);
            break;
          case 3:
            m[b].fn.call(m[b].context, h, d);
            break;
          case 4:
            m[b].fn.call(m[b].context, h, d, f);
            break;
          default:
            if (!_)
              for (T = 1, _ = new Array(y - 1); T < y; T++)
                _[T - 1] = arguments[T];
            m[b].fn.apply(m[b].context, _);
        }
    }
    return !0;
  }, o.prototype.on = function(l, h, d) {
    return s(this, l, h, d, !1);
  }, o.prototype.once = function(l, h, d) {
    return s(this, l, h, d, !0);
  }, o.prototype.removeListener = function(l, h, d, f) {
    var p = e ? e + l : l;
    if (!this._events[p])
      return this;
    if (!h)
      return a(this, p), this;
    var v = this._events[p];
    if (v.fn)
      v.fn === h && (!f || v.once) && (!d || v.context === d) && a(this, p);
    else {
      for (var g = 0, m = [], y = v.length; g < y; g++)
        (v[g].fn !== h || f && !v[g].once || d && v[g].context !== d) && m.push(v[g]);
      m.length ? this._events[p] = m.length === 1 ? m[0] : m : a(this, p);
    }
    return this;
  }, o.prototype.removeAllListeners = function(l) {
    var h;
    return l ? (h = e ? e + l : l, this._events[h] && a(this, h)) : (this._events = new r(), this._eventsCount = 0), this;
  }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = e, o.EventEmitter = o, i.exports = o;
})(OE);
var SO = OE.exports;
const Pi = /* @__PURE__ */ Jm(SO);
var wb = { exports: {} };
wb.exports = Qm;
wb.exports.default = Qm;
function Qm(i, t, e) {
  e = e || 2;
  var r = t && t.length, n = r ? t[0] * e : i.length, s = IE(i, 0, n, e, !0), a = [];
  if (!s || s.next === s.prev)
    return a;
  var o, u, l, h, d, f, p;
  if (r && (s = OO(i, t, s, e)), i.length > 80 * e) {
    o = l = i[0], u = h = i[1];
    for (var v = e; v < n; v += e)
      d = i[v], f = i[v + 1], d < o && (o = d), f < u && (u = f), d > l && (l = d), f > h && (h = f);
    p = Math.max(l - o, h - u), p = p !== 0 ? 32767 / p : 0;
  }
  return nc(s, a, e, o, u, p, 0), a;
}
function IE(i, t, e, r, n) {
  var s, a;
  if (n === my(i, t, e, r) > 0)
    for (s = t; s < e; s += r)
      a = d1(s, i[s], i[s + 1], a);
  else
    for (s = e - r; s >= t; s -= r)
      a = d1(s, i[s], i[s + 1], a);
  return a && t0(a, a.next) && (ac(a), a = a.next), a;
}
function qo(i, t) {
  if (!i)
    return i;
  t || (t = i);
  var e = i, r;
  do
    if (r = !1, !e.steiner && (t0(e, e.next) || Be(e.prev, e, e.next) === 0)) {
      if (ac(e), e = t = e.prev, e === e.next)
        break;
      r = !0;
    } else
      e = e.next;
  while (r || e !== t);
  return t;
}
function nc(i, t, e, r, n, s, a) {
  if (i) {
    !a && s && NO(i, r, n, s);
    for (var o = i, u, l; i.prev !== i.next; ) {
      if (u = i.prev, l = i.next, s ? CO(i, r, n, s) : TO(i)) {
        t.push(u.i / e | 0), t.push(i.i / e | 0), t.push(l.i / e | 0), ac(i), i = l.next, o = l.next;
        continue;
      }
      if (i = l, i === o) {
        a ? a === 1 ? (i = MO(qo(i), t, e), nc(i, t, e, r, n, s, 2)) : a === 2 && PO(i, t, e, r, n, s) : nc(qo(i), t, e, r, n, s, 1);
        break;
      }
    }
  }
}
function TO(i) {
  var t = i.prev, e = i, r = i.next;
  if (Be(t, e, r) >= 0)
    return !1;
  for (var n = t.x, s = e.x, a = r.x, o = t.y, u = e.y, l = r.y, h = n < s ? n < a ? n : a : s < a ? s : a, d = o < u ? o < l ? o : l : u < l ? u : l, f = n > s ? n > a ? n : a : s > a ? s : a, p = o > u ? o > l ? o : l : u > l ? u : l, v = r.next; v !== t; ) {
    if (v.x >= h && v.x <= f && v.y >= d && v.y <= p && Tu(n, o, s, u, a, l, v.x, v.y) && Be(v.prev, v, v.next) >= 0)
      return !1;
    v = v.next;
  }
  return !0;
}
function CO(i, t, e, r) {
  var n = i.prev, s = i, a = i.next;
  if (Be(n, s, a) >= 0)
    return !1;
  for (var o = n.x, u = s.x, l = a.x, h = n.y, d = s.y, f = a.y, p = o < u ? o < l ? o : l : u < l ? u : l, v = h < d ? h < f ? h : f : d < f ? d : f, g = o > u ? o > l ? o : l : u > l ? u : l, m = h > d ? h > f ? h : f : d > f ? d : f, y = vy(p, v, t, e, r), _ = vy(g, m, t, e, r), b = i.prevZ, w = i.nextZ; b && b.z >= y && w && w.z <= _; ) {
    if (b.x >= p && b.x <= g && b.y >= v && b.y <= m && b !== n && b !== a && Tu(o, h, u, d, l, f, b.x, b.y) && Be(b.prev, b, b.next) >= 0 || (b = b.prevZ, w.x >= p && w.x <= g && w.y >= v && w.y <= m && w !== n && w !== a && Tu(o, h, u, d, l, f, w.x, w.y) && Be(w.prev, w, w.next) >= 0))
      return !1;
    w = w.nextZ;
  }
  for (; b && b.z >= y; ) {
    if (b.x >= p && b.x <= g && b.y >= v && b.y <= m && b !== n && b !== a && Tu(o, h, u, d, l, f, b.x, b.y) && Be(b.prev, b, b.next) >= 0)
      return !1;
    b = b.prevZ;
  }
  for (; w && w.z <= _; ) {
    if (w.x >= p && w.x <= g && w.y >= v && w.y <= m && w !== n && w !== a && Tu(o, h, u, d, l, f, w.x, w.y) && Be(w.prev, w, w.next) >= 0)
      return !1;
    w = w.nextZ;
  }
  return !0;
}
function MO(i, t, e) {
  var r = i;
  do {
    var n = r.prev, s = r.next.next;
    !t0(n, s) && RE(n, r, r.next, s) && sc(n, s) && sc(s, n) && (t.push(n.i / e | 0), t.push(r.i / e | 0), t.push(s.i / e | 0), ac(r), ac(r.next), r = i = s), r = r.next;
  } while (r !== i);
  return qo(r);
}
function PO(i, t, e, r, n, s) {
  var a = i;
  do {
    for (var o = a.next.next; o !== a.prev; ) {
      if (a.i !== o.i && BO(a, o)) {
        var u = DE(a, o);
        a = qo(a, a.next), u = qo(u, u.next), nc(a, t, e, r, n, s, 0), nc(u, t, e, r, n, s, 0);
        return;
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== i);
}
function OO(i, t, e, r) {
  var n = [], s, a, o, u, l;
  for (s = 0, a = t.length; s < a; s++)
    o = t[s] * r, u = s < a - 1 ? t[s + 1] * r : i.length, l = IE(i, o, u, r, !1), l === l.next && (l.steiner = !0), n.push(LO(l));
  for (n.sort(IO), s = 0; s < n.length; s++)
    e = RO(n[s], e);
  return e;
}
function IO(i, t) {
  return i.x - t.x;
}
function RO(i, t) {
  var e = DO(i, t);
  if (!e)
    return t;
  var r = DE(e, i);
  return qo(r, r.next), qo(e, e.next);
}
function DO(i, t) {
  var e = t, r = i.x, n = i.y, s = -1 / 0, a;
  do {
    if (n <= e.y && n >= e.next.y && e.next.y !== e.y) {
      var o = e.x + (n - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (o <= r && o > s && (s = o, a = e.x < e.next.x ? e : e.next, o === r))
        return a;
    }
    e = e.next;
  } while (e !== t);
  if (!a)
    return null;
  var u = a, l = a.x, h = a.y, d = 1 / 0, f;
  e = a;
  do
    r >= e.x && e.x >= l && r !== e.x && Tu(n < h ? r : s, n, l, h, n < h ? s : r, n, e.x, e.y) && (f = Math.abs(n - e.y) / (r - e.x), sc(e, i) && (f < d || f === d && (e.x > a.x || e.x === a.x && kO(a, e))) && (a = e, d = f)), e = e.next;
  while (e !== u);
  return a;
}
function kO(i, t) {
  return Be(i.prev, i, t.prev) < 0 && Be(t.next, i, i.next) < 0;
}
function NO(i, t, e, r) {
  var n = i;
  do
    n.z === 0 && (n.z = vy(n.x, n.y, t, e, r)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== i);
  n.prevZ.nextZ = null, n.prevZ = null, AO(n);
}
function AO(i) {
  var t, e, r, n, s, a, o, u, l = 1;
  do {
    for (e = i, i = null, s = null, a = 0; e; ) {
      for (a++, r = e, o = 0, t = 0; t < l && (o++, r = r.nextZ, !!r); t++)
        ;
      for (u = l; o > 0 || u > 0 && r; )
        o !== 0 && (u === 0 || !r || e.z <= r.z) ? (n = e, e = e.nextZ, o--) : (n = r, r = r.nextZ, u--), s ? s.nextZ = n : i = n, n.prevZ = s, s = n;
      e = r;
    }
    s.nextZ = null, l *= 2;
  } while (a > 1);
  return i;
}
function vy(i, t, e, r, n) {
  return i = (i - e) * n | 0, t = (t - r) * n | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, i | t << 1;
}
function LO(i) {
  var t = i, e = i;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== i);
  return e;
}
function Tu(i, t, e, r, n, s, a, o) {
  return (n - a) * (t - o) >= (i - a) * (s - o) && (i - a) * (r - o) >= (e - a) * (t - o) && (e - a) * (s - o) >= (n - a) * (r - o);
}
function BO(i, t) {
  return i.next.i !== t.i && i.prev.i !== t.i && !FO(i, t) && // dones't intersect other edges
  (sc(i, t) && sc(t, i) && GO(i, t) && // locally visible
  (Be(i.prev, i, t.prev) || Be(i, t.prev, t)) || // does not create opposite-facing sectors
  t0(i, t) && Be(i.prev, i, i.next) > 0 && Be(t.prev, t, t.next) > 0);
}
function Be(i, t, e) {
  return (t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y);
}
function t0(i, t) {
  return i.x === t.x && i.y === t.y;
}
function RE(i, t, e, r) {
  var n = Bd(Be(i, t, e)), s = Bd(Be(i, t, r)), a = Bd(Be(e, r, i)), o = Bd(Be(e, r, t));
  return !!(n !== s && a !== o || n === 0 && Ld(i, e, t) || s === 0 && Ld(i, r, t) || a === 0 && Ld(e, i, r) || o === 0 && Ld(e, t, r));
}
function Ld(i, t, e) {
  return t.x <= Math.max(i.x, e.x) && t.x >= Math.min(i.x, e.x) && t.y <= Math.max(i.y, e.y) && t.y >= Math.min(i.y, e.y);
}
function Bd(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function FO(i, t) {
  var e = i;
  do {
    if (e.i !== i.i && e.next.i !== i.i && e.i !== t.i && e.next.i !== t.i && RE(e, e.next, i, t))
      return !0;
    e = e.next;
  } while (e !== i);
  return !1;
}
function sc(i, t) {
  return Be(i.prev, i, i.next) < 0 ? Be(i, t, i.next) >= 0 && Be(i, i.prev, t) >= 0 : Be(i, t, i.prev) < 0 || Be(i, i.next, t) < 0;
}
function GO(i, t) {
  var e = i, r = !1, n = (i.x + t.x) / 2, s = (i.y + t.y) / 2;
  do
    e.y > s != e.next.y > s && e.next.y !== e.y && n < (e.next.x - e.x) * (s - e.y) / (e.next.y - e.y) + e.x && (r = !r), e = e.next;
  while (e !== i);
  return r;
}
function DE(i, t) {
  var e = new gy(i.i, i.x, i.y), r = new gy(t.i, t.x, t.y), n = i.next, s = t.prev;
  return i.next = t, t.prev = i, e.next = n, n.prev = e, r.next = e, e.prev = r, s.next = r, r.prev = s, r;
}
function d1(i, t, e, r) {
  var n = new gy(i, t, e);
  return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n;
}
function ac(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function gy(i, t, e) {
  this.i = i, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
Qm.deviation = function(i, t, e, r) {
  var n = t && t.length, s = n ? t[0] * e : i.length, a = Math.abs(my(i, 0, s, e));
  if (n)
    for (var o = 0, u = t.length; o < u; o++) {
      var l = t[o] * e, h = o < u - 1 ? t[o + 1] * e : i.length;
      a -= Math.abs(my(i, l, h, e));
    }
  var d = 0;
  for (o = 0; o < r.length; o += 3) {
    var f = r[o] * e, p = r[o + 1] * e, v = r[o + 2] * e;
    d += Math.abs(
      (i[f] - i[v]) * (i[p + 1] - i[f + 1]) - (i[f] - i[p]) * (i[v + 1] - i[f + 1])
    );
  }
  return a === 0 && d === 0 ? 0 : Math.abs((d - a) / a);
};
function my(i, t, e, r) {
  for (var n = 0, s = t, a = e - r; s < e; s += r)
    n += (i[a] - i[s]) * (i[s + 1] + i[a + 1]), a = s;
  return n;
}
Qm.flatten = function(i) {
  for (var t = i[0][0].length, e = { vertices: [], holes: [], dimensions: t }, r = 0, n = 0; n < i.length; n++) {
    for (var s = 0; s < i[n].length; s++)
      for (var a = 0; a < t; a++)
        e.vertices.push(i[n][s][a]);
    n > 0 && (r += i[n - 1].length, e.holes.push(r));
  }
  return e;
};
var UO = wb.exports;
const kE = /* @__PURE__ */ Jm(UO);
/*!
 * @pixi/utils - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Cu = {
  parse: KP,
  format: JP,
  resolve: QP
};
gt.RETINA_PREFIX = /@([0-9\.]+)x/;
gt.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var yy = !1, p1 = "6.5.9";
function jO() {
  yy = !0;
}
function zO(i) {
  var t;
  if (!yy) {
    if (gt.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      var e = [
        `
 %c %c %c PixiJS ` + p1 + " - ✰ " + i + ` ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ 

`,
        "background: #ff66a5; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff66a5; background: #030307; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "background: #ffc3dc; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;"
      ];
      (t = globalThis.console).log.apply(t, e);
    } else
      globalThis.console && globalThis.console.log("PixiJS " + p1 + " - " + i + " - http://www.pixijs.com/");
    yy = !0;
  }
}
var I0;
function HO() {
  return typeof I0 > "u" && (I0 = function() {
    var t = {
      stencil: !0,
      failIfMajorPerformanceCaveat: gt.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
    };
    try {
      if (!gt.ADAPTER.getWebGLRenderingContext())
        return !1;
      var e = gt.ADAPTER.createCanvas(), r = e.getContext("webgl", t) || e.getContext("experimental-webgl", t), n = !!(r && r.getContextAttributes().stencil);
      if (r) {
        var s = r.getExtension("WEBGL_lose_context");
        s && s.loseContext();
      }
      return r = null, n;
    } catch {
      return !1;
    }
  }()), I0;
}
var $O = "#f0f8ff", VO = "#faebd7", XO = "#00ffff", WO = "#7fffd4", YO = "#f0ffff", qO = "#f5f5dc", ZO = "#ffe4c4", KO = "#000000", JO = "#ffebcd", QO = "#0000ff", tI = "#8a2be2", eI = "#a52a2a", rI = "#deb887", iI = "#5f9ea0", nI = "#7fff00", sI = "#d2691e", aI = "#ff7f50", oI = "#6495ed", uI = "#fff8dc", lI = "#dc143c", hI = "#00ffff", cI = "#00008b", fI = "#008b8b", dI = "#b8860b", pI = "#a9a9a9", vI = "#006400", gI = "#a9a9a9", mI = "#bdb76b", yI = "#8b008b", _I = "#556b2f", bI = "#ff8c00", xI = "#9932cc", wI = "#8b0000", EI = "#e9967a", SI = "#8fbc8f", TI = "#483d8b", CI = "#2f4f4f", MI = "#2f4f4f", PI = "#00ced1", OI = "#9400d3", II = "#ff1493", RI = "#00bfff", DI = "#696969", kI = "#696969", NI = "#1e90ff", AI = "#b22222", LI = "#fffaf0", BI = "#228b22", FI = "#ff00ff", GI = "#dcdcdc", UI = "#f8f8ff", jI = "#daa520", zI = "#ffd700", HI = "#808080", $I = "#008000", VI = "#adff2f", XI = "#808080", WI = "#f0fff0", YI = "#ff69b4", qI = "#cd5c5c", ZI = "#4b0082", KI = "#fffff0", JI = "#f0e68c", QI = "#fff0f5", tR = "#e6e6fa", eR = "#7cfc00", rR = "#fffacd", iR = "#add8e6", nR = "#f08080", sR = "#e0ffff", aR = "#fafad2", oR = "#d3d3d3", uR = "#90ee90", lR = "#d3d3d3", hR = "#ffb6c1", cR = "#ffa07a", fR = "#20b2aa", dR = "#87cefa", pR = "#778899", vR = "#778899", gR = "#b0c4de", mR = "#ffffe0", yR = "#00ff00", _R = "#32cd32", bR = "#faf0e6", xR = "#ff00ff", wR = "#800000", ER = "#66cdaa", SR = "#0000cd", TR = "#ba55d3", CR = "#9370db", MR = "#3cb371", PR = "#7b68ee", OR = "#00fa9a", IR = "#48d1cc", RR = "#c71585", DR = "#191970", kR = "#f5fffa", NR = "#ffe4e1", AR = "#ffe4b5", LR = "#ffdead", BR = "#000080", FR = "#fdf5e6", GR = "#808000", UR = "#6b8e23", jR = "#ffa500", zR = "#ff4500", HR = "#da70d6", $R = "#eee8aa", VR = "#98fb98", XR = "#afeeee", WR = "#db7093", YR = "#ffefd5", qR = "#ffdab9", ZR = "#cd853f", KR = "#ffc0cb", JR = "#dda0dd", QR = "#b0e0e6", tD = "#800080", eD = "#663399", rD = "#ff0000", iD = "#bc8f8f", nD = "#4169e1", sD = "#8b4513", aD = "#fa8072", oD = "#f4a460", uD = "#2e8b57", lD = "#fff5ee", hD = "#a0522d", cD = "#c0c0c0", fD = "#87ceeb", dD = "#6a5acd", pD = "#708090", vD = "#708090", gD = "#fffafa", mD = "#00ff7f", yD = "#4682b4", _D = "#d2b48c", bD = "#008080", xD = "#d8bfd8", wD = "#ff6347", ED = "#40e0d0", SD = "#ee82ee", TD = "#f5deb3", CD = "#ffffff", MD = "#f5f5f5", PD = "#ffff00", OD = "#9acd32", ID = {
  aliceblue: $O,
  antiquewhite: VO,
  aqua: XO,
  aquamarine: WO,
  azure: YO,
  beige: qO,
  bisque: ZO,
  black: KO,
  blanchedalmond: JO,
  blue: QO,
  blueviolet: tI,
  brown: eI,
  burlywood: rI,
  cadetblue: iI,
  chartreuse: nI,
  chocolate: sI,
  coral: aI,
  cornflowerblue: oI,
  cornsilk: uI,
  crimson: lI,
  cyan: hI,
  darkblue: cI,
  darkcyan: fI,
  darkgoldenrod: dI,
  darkgray: pI,
  darkgreen: vI,
  darkgrey: gI,
  darkkhaki: mI,
  darkmagenta: yI,
  darkolivegreen: _I,
  darkorange: bI,
  darkorchid: xI,
  darkred: wI,
  darksalmon: EI,
  darkseagreen: SI,
  darkslateblue: TI,
  darkslategray: CI,
  darkslategrey: MI,
  darkturquoise: PI,
  darkviolet: OI,
  deeppink: II,
  deepskyblue: RI,
  dimgray: DI,
  dimgrey: kI,
  dodgerblue: NI,
  firebrick: AI,
  floralwhite: LI,
  forestgreen: BI,
  fuchsia: FI,
  gainsboro: GI,
  ghostwhite: UI,
  goldenrod: jI,
  gold: zI,
  gray: HI,
  green: $I,
  greenyellow: VI,
  grey: XI,
  honeydew: WI,
  hotpink: YI,
  indianred: qI,
  indigo: ZI,
  ivory: KI,
  khaki: JI,
  lavenderblush: QI,
  lavender: tR,
  lawngreen: eR,
  lemonchiffon: rR,
  lightblue: iR,
  lightcoral: nR,
  lightcyan: sR,
  lightgoldenrodyellow: aR,
  lightgray: oR,
  lightgreen: uR,
  lightgrey: lR,
  lightpink: hR,
  lightsalmon: cR,
  lightseagreen: fR,
  lightskyblue: dR,
  lightslategray: pR,
  lightslategrey: vR,
  lightsteelblue: gR,
  lightyellow: mR,
  lime: yR,
  limegreen: _R,
  linen: bR,
  magenta: xR,
  maroon: wR,
  mediumaquamarine: ER,
  mediumblue: SR,
  mediumorchid: TR,
  mediumpurple: CR,
  mediumseagreen: MR,
  mediumslateblue: PR,
  mediumspringgreen: OR,
  mediumturquoise: IR,
  mediumvioletred: RR,
  midnightblue: DR,
  mintcream: kR,
  mistyrose: NR,
  moccasin: AR,
  navajowhite: LR,
  navy: BR,
  oldlace: FR,
  olive: GR,
  olivedrab: UR,
  orange: jR,
  orangered: zR,
  orchid: HR,
  palegoldenrod: $R,
  palegreen: VR,
  paleturquoise: XR,
  palevioletred: WR,
  papayawhip: YR,
  peachpuff: qR,
  peru: ZR,
  pink: KR,
  plum: JR,
  powderblue: QR,
  purple: tD,
  rebeccapurple: eD,
  red: rD,
  rosybrown: iD,
  royalblue: nD,
  saddlebrown: sD,
  salmon: aD,
  sandybrown: oD,
  seagreen: uD,
  seashell: lD,
  sienna: hD,
  silver: cD,
  skyblue: fD,
  slateblue: dD,
  slategray: pD,
  slategrey: vD,
  snow: gD,
  springgreen: mD,
  steelblue: yD,
  tan: _D,
  teal: bD,
  thistle: xD,
  tomato: wD,
  turquoise: ED,
  violet: SD,
  wheat: TD,
  white: CD,
  whitesmoke: MD,
  yellow: PD,
  yellowgreen: OD
};
function Kl(i, t) {
  return t === void 0 && (t = []), t[0] = (i >> 16 & 255) / 255, t[1] = (i >> 8 & 255) / 255, t[2] = (i & 255) / 255, t;
}
function NE(i) {
  var t = i.toString(16);
  return t = "000000".substring(0, 6 - t.length) + t, "#" + t;
}
function AE(i) {
  return typeof i == "string" && (i = ID[i.toLowerCase()] || i, i[0] === "#" && (i = i.slice(1))), parseInt(i, 16);
}
function RD() {
  for (var i = [], t = [], e = 0; e < 32; e++)
    i[e] = e, t[e] = e;
  i[Et.NORMAL_NPM] = Et.NORMAL, i[Et.ADD_NPM] = Et.ADD, i[Et.SCREEN_NPM] = Et.SCREEN, t[Et.NORMAL] = Et.NORMAL_NPM, t[Et.ADD] = Et.ADD_NPM, t[Et.SCREEN] = Et.SCREEN_NPM;
  var r = [];
  return r.push(t), r.push(i), r;
}
var LE = RD();
function BE(i, t) {
  return LE[t ? 1 : 0][i];
}
function DD(i, t, e, r) {
  return e = e || new Float32Array(4), r || r === void 0 ? (e[0] = i[0] * t, e[1] = i[1] * t, e[2] = i[2] * t) : (e[0] = i[0], e[1] = i[1], e[2] = i[2]), e[3] = t, e;
}
function Eb(i, t) {
  if (t === 1)
    return (t * 255 << 24) + i;
  if (t === 0)
    return 0;
  var e = i >> 16 & 255, r = i >> 8 & 255, n = i & 255;
  return e = e * t + 0.5 | 0, r = r * t + 0.5 | 0, n = n * t + 0.5 | 0, (t * 255 << 24) + (e << 16) + (r << 8) + n;
}
function FE(i, t, e, r) {
  return e = e || new Float32Array(4), e[0] = (i >> 16 & 255) / 255, e[1] = (i >> 8 & 255) / 255, e[2] = (i & 255) / 255, (r || r === void 0) && (e[0] *= t, e[1] *= t, e[2] *= t), e[3] = t, e;
}
function kD(i, t) {
  t === void 0 && (t = null);
  var e = i * 6;
  if (t = t || new Uint16Array(e), t.length !== e)
    throw new Error("Out buffer length is incorrect, got " + t.length + " and expected " + e);
  for (var r = 0, n = 0; r < e; r += 6, n += 4)
    t[r + 0] = n + 0, t[r + 1] = n + 1, t[r + 2] = n + 2, t[r + 3] = n + 0, t[r + 4] = n + 2, t[r + 5] = n + 3;
  return t;
}
function GE(i) {
  if (i.BYTES_PER_ELEMENT === 4)
    return i instanceof Float32Array ? "Float32Array" : i instanceof Uint32Array ? "Uint32Array" : "Int32Array";
  if (i.BYTES_PER_ELEMENT === 2) {
    if (i instanceof Uint16Array)
      return "Uint16Array";
  } else if (i.BYTES_PER_ELEMENT === 1 && i instanceof Uint8Array)
    return "Uint8Array";
  return null;
}
function cv(i) {
  return i += i === 0 ? 1 : 0, --i, i |= i >>> 1, i |= i >>> 2, i |= i >>> 4, i |= i >>> 8, i |= i >>> 16, i + 1;
}
function v1(i) {
  return !(i & i - 1) && !!i;
}
function g1(i) {
  var t = (i > 65535 ? 1 : 0) << 4;
  i >>>= t;
  var e = (i > 255 ? 1 : 0) << 3;
  return i >>>= e, t |= e, e = (i > 15 ? 1 : 0) << 2, i >>>= e, t |= e, e = (i > 3 ? 1 : 0) << 1, i >>>= e, t |= e, t | i >> 1;
}
function Lu(i, t, e) {
  var r = i.length, n;
  if (!(t >= r || e === 0)) {
    e = t + e > r ? r - t : e;
    var s = r - e;
    for (n = t; n < s; ++n)
      i[n] = i[n + e];
    i.length = s;
  }
}
function Mu(i) {
  return i === 0 ? 0 : i < 0 ? -1 : 1;
}
var ND = 0;
function Zo() {
  return ++ND;
}
var m1 = {};
function jr(i, t, e) {
  if (e === void 0 && (e = 3), !m1[t]) {
    var r = new Error().stack;
    typeof r > "u" ? console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + i) : (r = r.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", t + `
Deprecated since v` + i), console.warn(r), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + i), console.warn(r))), m1[t] = !0;
  }
}
var y1 = {}, Gr = /* @__PURE__ */ Object.create(null), Xn = /* @__PURE__ */ Object.create(null);
function UE() {
  var i;
  for (i in Gr)
    delete Gr[i];
  for (i in Xn)
    delete Xn[i];
}
var _1 = (
  /** @class */
  function() {
    function i(t, e, r) {
      this.canvas = gt.ADAPTER.createCanvas(), this.context = this.canvas.getContext("2d"), this.resolution = r || gt.RESOLUTION, this.resize(t, e);
    }
    return i.prototype.clear = function() {
      this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }, i.prototype.resize = function(t, e) {
      this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);
    }, i.prototype.destroy = function() {
      this.context = null, this.canvas = null;
    }, Object.defineProperty(i.prototype, "width", {
      /**
       * The width of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.width;
      },
      set: function(t) {
        this.canvas.width = Math.round(t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "height", {
      /**
       * The height of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.height;
      },
      set: function(t) {
        this.canvas.height = Math.round(t);
      },
      enumerable: !1,
      configurable: !0
    }), i;
  }()
);
function AD(i) {
  var t = i.width, e = i.height, r = i.getContext("2d", {
    willReadFrequently: !0
  }), n = r.getImageData(0, 0, t, e), s = n.data, a = s.length, o = {
    top: null,
    left: null,
    right: null,
    bottom: null
  }, u = null, l, h, d;
  for (l = 0; l < a; l += 4)
    s[l + 3] !== 0 && (h = l / 4 % t, d = ~~(l / 4 / t), o.top === null && (o.top = d), (o.left === null || h < o.left) && (o.left = h), (o.right === null || o.right < h) && (o.right = h + 1), (o.bottom === null || o.bottom < d) && (o.bottom = d));
  return o.top !== null && (t = o.right - o.left, e = o.bottom - o.top + 1, u = r.getImageData(o.left, o.top, t, e)), {
    height: e,
    width: t,
    data: u
  };
}
var Fd;
function LD(i, t) {
  if (t === void 0 && (t = globalThis.location), i.indexOf("data:") === 0)
    return "";
  t = t || globalThis.location, Fd || (Fd = document.createElement("a")), Fd.href = i;
  var e = Cu.parse(Fd.href), r = !e.port && t.port === "" || e.port === t.port;
  return e.hostname !== t.hostname || !r || e.protocol !== t.protocol ? "anonymous" : "";
}
function fv(i, t) {
  var e = gt.RETINA_PREFIX.exec(i);
  return e ? parseFloat(e[1]) : t !== void 0 ? t : 1;
}
/*!
 * @pixi/math - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var dv = Math.PI * 2, BD = 180 / Math.PI, FD = Math.PI / 180, ur;
(function(i) {
  i[i.POLY = 0] = "POLY", i[i.RECT = 1] = "RECT", i[i.CIRC = 2] = "CIRC", i[i.ELIP = 3] = "ELIP", i[i.RREC = 4] = "RREC";
})(ur || (ur = {}));
var xe = (
  /** @class */
  function() {
    function i(t, e) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e;
    }
    return i.prototype.clone = function() {
      return new i(this.x, this.y);
    }, i.prototype.copyFrom = function(t) {
      return this.set(t.x, t.y), this;
    }, i.prototype.copyTo = function(t) {
      return t.set(this.x, this.y), t;
    }, i.prototype.equals = function(t) {
      return t.x === this.x && t.y === this.y;
    }, i.prototype.set = function(t, e) {
      return t === void 0 && (t = 0), e === void 0 && (e = t), this.x = t, this.y = e, this;
    }, i.prototype.toString = function() {
      return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
    }, i;
  }()
), Gd = [new xe(), new xe(), new xe(), new xe()], Nt = (
  /** @class */
  function() {
    function i(t, e, r, n) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), n === void 0 && (n = 0), this.x = Number(t), this.y = Number(e), this.width = Number(r), this.height = Number(n), this.type = ur.RECT;
    }
    return Object.defineProperty(i.prototype, "left", {
      /** Returns the left edge of the rectangle. */
      get: function() {
        return this.x;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "right", {
      /** Returns the right edge of the rectangle. */
      get: function() {
        return this.x + this.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "top", {
      /** Returns the top edge of the rectangle. */
      get: function() {
        return this.y;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "bottom", {
      /** Returns the bottom edge of the rectangle. */
      get: function() {
        return this.y + this.height;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i, "EMPTY", {
      /** A constant empty rectangle. */
      get: function() {
        return new i(0, 0, 0, 0);
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.clone = function() {
      return new i(this.x, this.y, this.width, this.height);
    }, i.prototype.copyFrom = function(t) {
      return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
    }, i.prototype.copyTo = function(t) {
      return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
    }, i.prototype.contains = function(t, e) {
      return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
    }, i.prototype.intersects = function(t, e) {
      if (!e) {
        var r = this.x < t.x ? t.x : this.x, n = this.right > t.right ? t.right : this.right;
        if (n <= r)
          return !1;
        var s = this.y < t.y ? t.y : this.y, a = this.bottom > t.bottom ? t.bottom : this.bottom;
        return a > s;
      }
      var o = this.left, u = this.right, l = this.top, h = this.bottom;
      if (u <= o || h <= l)
        return !1;
      var d = Gd[0].set(t.left, t.top), f = Gd[1].set(t.left, t.bottom), p = Gd[2].set(t.right, t.top), v = Gd[3].set(t.right, t.bottom);
      if (p.x <= d.x || f.y <= d.y)
        return !1;
      var g = Math.sign(e.a * e.d - e.b * e.c);
      if (g === 0 || (e.apply(d, d), e.apply(f, f), e.apply(p, p), e.apply(v, v), Math.max(d.x, f.x, p.x, v.x) <= o || Math.min(d.x, f.x, p.x, v.x) >= u || Math.max(d.y, f.y, p.y, v.y) <= l || Math.min(d.y, f.y, p.y, v.y) >= h))
        return !1;
      var m = g * (f.y - d.y), y = g * (d.x - f.x), _ = m * o + y * l, b = m * u + y * l, w = m * o + y * h, T = m * u + y * h;
      if (Math.max(_, b, w, T) <= m * d.x + y * d.y || Math.min(_, b, w, T) >= m * v.x + y * v.y)
        return !1;
      var x = g * (d.y - p.y), S = g * (p.x - d.x), C = x * o + S * l, M = x * u + S * l, I = x * o + S * h, R = x * u + S * h;
      return !(Math.max(C, M, I, R) <= x * d.x + S * d.y || Math.min(C, M, I, R) >= x * v.x + S * v.y);
    }, i.prototype.pad = function(t, e) {
      return t === void 0 && (t = 0), e === void 0 && (e = t), this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
    }, i.prototype.fit = function(t) {
      var e = Math.max(this.x, t.x), r = Math.min(this.x + this.width, t.x + t.width), n = Math.max(this.y, t.y), s = Math.min(this.y + this.height, t.y + t.height);
      return this.x = e, this.width = Math.max(r - e, 0), this.y = n, this.height = Math.max(s - n, 0), this;
    }, i.prototype.ceil = function(t, e) {
      t === void 0 && (t = 1), e === void 0 && (e = 1e-3);
      var r = Math.ceil((this.x + this.width - e) * t) / t, n = Math.ceil((this.y + this.height - e) * t) / t;
      return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = r - this.x, this.height = n - this.y, this;
    }, i.prototype.enlarge = function(t) {
      var e = Math.min(this.x, t.x), r = Math.max(this.x + this.width, t.x + t.width), n = Math.min(this.y, t.y), s = Math.max(this.y + this.height, t.y + t.height);
      return this.x = e, this.width = r - e, this.y = n, this.height = s - n, this;
    }, i.prototype.toString = function() {
      return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    }, i;
  }()
), GD = (
  /** @class */
  function() {
    function i(t, e, r) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), this.x = t, this.y = e, this.radius = r, this.type = ur.CIRC;
    }
    return i.prototype.clone = function() {
      return new i(this.x, this.y, this.radius);
    }, i.prototype.contains = function(t, e) {
      if (this.radius <= 0)
        return !1;
      var r = this.radius * this.radius, n = this.x - t, s = this.y - e;
      return n *= n, s *= s, n + s <= r;
    }, i.prototype.getBounds = function() {
      return new Nt(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }, i.prototype.toString = function() {
      return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
    }, i;
  }()
), UD = (
  /** @class */
  function() {
    function i(t, e, r, n) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), n === void 0 && (n = 0), this.x = t, this.y = e, this.width = r, this.height = n, this.type = ur.ELIP;
    }
    return i.prototype.clone = function() {
      return new i(this.x, this.y, this.width, this.height);
    }, i.prototype.contains = function(t, e) {
      if (this.width <= 0 || this.height <= 0)
        return !1;
      var r = (t - this.x) / this.width, n = (e - this.y) / this.height;
      return r *= r, n *= n, r + n <= 1;
    }, i.prototype.getBounds = function() {
      return new Nt(this.x - this.width, this.y - this.height, this.width, this.height);
    }, i.prototype.toString = function() {
      return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    }, i;
  }()
), Cp = (
  /** @class */
  function() {
    function i() {
      for (var t = arguments, e = [], r = 0; r < arguments.length; r++)
        e[r] = t[r];
      var n = Array.isArray(e[0]) ? e[0] : e;
      if (typeof n[0] != "number") {
        for (var s = [], a = 0, o = n.length; a < o; a++)
          s.push(n[a].x, n[a].y);
        n = s;
      }
      this.points = n, this.type = ur.POLY, this.closeStroke = !0;
    }
    return i.prototype.clone = function() {
      var t = this.points.slice(), e = new i(t);
      return e.closeStroke = this.closeStroke, e;
    }, i.prototype.contains = function(t, e) {
      for (var r = !1, n = this.points.length / 2, s = 0, a = n - 1; s < n; a = s++) {
        var o = this.points[s * 2], u = this.points[s * 2 + 1], l = this.points[a * 2], h = this.points[a * 2 + 1], d = u > e != h > e && t < (l - o) * ((e - u) / (h - u)) + o;
        d && (r = !r);
      }
      return r;
    }, i.prototype.toString = function() {
      return "[@pixi/math:Polygon" + ("closeStroke=" + this.closeStroke) + ("points=" + this.points.reduce(function(t, e) {
        return t + ", " + e;
      }, "") + "]");
    }, i;
  }()
), jD = (
  /** @class */
  function() {
    function i(t, e, r, n, s) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), n === void 0 && (n = 0), s === void 0 && (s = 20), this.x = t, this.y = e, this.width = r, this.height = n, this.radius = s, this.type = ur.RREC;
    }
    return i.prototype.clone = function() {
      return new i(this.x, this.y, this.width, this.height, this.radius);
    }, i.prototype.contains = function(t, e) {
      if (this.width <= 0 || this.height <= 0)
        return !1;
      if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
        var r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (e >= this.y + r && e <= this.y + this.height - r || t >= this.x + r && t <= this.x + this.width - r)
          return !0;
        var n = t - (this.x + r), s = e - (this.y + r), a = r * r;
        if (n * n + s * s <= a || (n = t - (this.x + this.width - r), n * n + s * s <= a) || (s = e - (this.y + this.height - r), n * n + s * s <= a) || (n = t - (this.x + r), n * n + s * s <= a))
          return !0;
      }
      return !1;
    }, i.prototype.toString = function() {
      return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + ("width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]");
    }, i;
  }()
), Pu = (
  /** @class */
  function() {
    function i(t, e, r, n) {
      r === void 0 && (r = 0), n === void 0 && (n = 0), this._x = r, this._y = n, this.cb = t, this.scope = e;
    }
    return i.prototype.clone = function(t, e) {
      return t === void 0 && (t = this.cb), e === void 0 && (e = this.scope), new i(t, e, this._x, this._y);
    }, i.prototype.set = function(t, e) {
      return t === void 0 && (t = 0), e === void 0 && (e = t), (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this.cb.call(this.scope)), this;
    }, i.prototype.copyFrom = function(t) {
      return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this;
    }, i.prototype.copyTo = function(t) {
      return t.set(this._x, this._y), t;
    }, i.prototype.equals = function(t) {
      return t.x === this._x && t.y === this._y;
    }, i.prototype.toString = function() {
      return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
    }, Object.defineProperty(i.prototype, "x", {
      /** Position of the observable point on the x axis. */
      get: function() {
        return this._x;
      },
      set: function(t) {
        this._x !== t && (this._x = t, this.cb.call(this.scope));
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "y", {
      /** Position of the observable point on the y axis. */
      get: function() {
        return this._y;
      },
      set: function(t) {
        this._y !== t && (this._y = t, this.cb.call(this.scope));
      },
      enumerable: !1,
      configurable: !0
    }), i;
  }()
), ar = (
  /** @class */
  function() {
    function i(t, e, r, n, s, a) {
      t === void 0 && (t = 1), e === void 0 && (e = 0), r === void 0 && (r = 0), n === void 0 && (n = 1), s === void 0 && (s = 0), a === void 0 && (a = 0), this.array = null, this.a = t, this.b = e, this.c = r, this.d = n, this.tx = s, this.ty = a;
    }
    return i.prototype.fromArray = function(t) {
      this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
    }, i.prototype.set = function(t, e, r, n, s, a) {
      return this.a = t, this.b = e, this.c = r, this.d = n, this.tx = s, this.ty = a, this;
    }, i.prototype.toArray = function(t, e) {
      this.array || (this.array = new Float32Array(9));
      var r = e || this.array;
      return t ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r;
    }, i.prototype.apply = function(t, e) {
      e = e || new xe();
      var r = t.x, n = t.y;
      return e.x = this.a * r + this.c * n + this.tx, e.y = this.b * r + this.d * n + this.ty, e;
    }, i.prototype.applyInverse = function(t, e) {
      e = e || new xe();
      var r = 1 / (this.a * this.d + this.c * -this.b), n = t.x, s = t.y;
      return e.x = this.d * r * n + -this.c * r * s + (this.ty * this.c - this.tx * this.d) * r, e.y = this.a * r * s + -this.b * r * n + (-this.ty * this.a + this.tx * this.b) * r, e;
    }, i.prototype.translate = function(t, e) {
      return this.tx += t, this.ty += e, this;
    }, i.prototype.scale = function(t, e) {
      return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
    }, i.prototype.rotate = function(t) {
      var e = Math.cos(t), r = Math.sin(t), n = this.a, s = this.c, a = this.tx;
      return this.a = n * e - this.b * r, this.b = n * r + this.b * e, this.c = s * e - this.d * r, this.d = s * r + this.d * e, this.tx = a * e - this.ty * r, this.ty = a * r + this.ty * e, this;
    }, i.prototype.append = function(t) {
      var e = this.a, r = this.b, n = this.c, s = this.d;
      return this.a = t.a * e + t.b * n, this.b = t.a * r + t.b * s, this.c = t.c * e + t.d * n, this.d = t.c * r + t.d * s, this.tx = t.tx * e + t.ty * n + this.tx, this.ty = t.tx * r + t.ty * s + this.ty, this;
    }, i.prototype.setTransform = function(t, e, r, n, s, a, o, u, l) {
      return this.a = Math.cos(o + l) * s, this.b = Math.sin(o + l) * s, this.c = -Math.sin(o - u) * a, this.d = Math.cos(o - u) * a, this.tx = t - (r * this.a + n * this.c), this.ty = e - (r * this.b + n * this.d), this;
    }, i.prototype.prepend = function(t) {
      var e = this.tx;
      if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
        var r = this.a, n = this.c;
        this.a = r * t.a + this.b * t.c, this.b = r * t.b + this.b * t.d, this.c = n * t.a + this.d * t.c, this.d = n * t.b + this.d * t.d;
      }
      return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
    }, i.prototype.decompose = function(t) {
      var e = this.a, r = this.b, n = this.c, s = this.d, a = t.pivot, o = -Math.atan2(-n, s), u = Math.atan2(r, e), l = Math.abs(o + u);
      return l < 1e-5 || Math.abs(dv - l) < 1e-5 ? (t.rotation = u, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = o, t.skew.y = u), t.scale.x = Math.sqrt(e * e + r * r), t.scale.y = Math.sqrt(n * n + s * s), t.position.x = this.tx + (a.x * e + a.y * n), t.position.y = this.ty + (a.x * r + a.y * s), t;
    }, i.prototype.invert = function() {
      var t = this.a, e = this.b, r = this.c, n = this.d, s = this.tx, a = t * n - e * r;
      return this.a = n / a, this.b = -e / a, this.c = -r / a, this.d = t / a, this.tx = (r * this.ty - n * s) / a, this.ty = -(t * this.ty - e * s) / a, this;
    }, i.prototype.identity = function() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }, i.prototype.clone = function() {
      var t = new i();
      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
    }, i.prototype.copyTo = function(t) {
      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
    }, i.prototype.copyFrom = function(t) {
      return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
    }, i.prototype.toString = function() {
      return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
    }, Object.defineProperty(i, "IDENTITY", {
      /**
       * A default (identity) matrix
       * @readonly
       */
      get: function() {
        return new i();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i, "TEMP_MATRIX", {
      /**
       * A temp matrix
       * @readonly
       */
      get: function() {
        return new i();
      },
      enumerable: !1,
      configurable: !0
    }), i;
  }()
), Ea = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], Sa = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], Ta = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], Ca = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], _y = [], jE = [], Ud = Math.sign;
function zD() {
  for (var i = 0; i < 16; i++) {
    var t = [];
    _y.push(t);
    for (var e = 0; e < 16; e++)
      for (var r = Ud(Ea[i] * Ea[e] + Ta[i] * Sa[e]), n = Ud(Sa[i] * Ea[e] + Ca[i] * Sa[e]), s = Ud(Ea[i] * Ta[e] + Ta[i] * Ca[e]), a = Ud(Sa[i] * Ta[e] + Ca[i] * Ca[e]), o = 0; o < 16; o++)
        if (Ea[o] === r && Sa[o] === n && Ta[o] === s && Ca[o] === a) {
          t.push(o);
          break;
        }
  }
  for (var i = 0; i < 16; i++) {
    var u = new ar();
    u.set(Ea[i], Sa[i], Ta[i], Ca[i], 0, 0), jE.push(u);
  }
}
zD();
var Le = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: function(i) {
    return Ea[i];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: function(i) {
    return Sa[i];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: function(i) {
    return Ta[i];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: function(i) {
    return Ca[i];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: function(i) {
    return i & 8 ? i & 15 : -i & 7;
  },
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {PIXI.GD8Symmetry} Composed operation
   */
  add: function(i, t) {
    return _y[i][t];
  },
  /**
   * Reverse of `add`.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @returns {PIXI.GD8Symmetry} Result
   */
  sub: function(i, t) {
    return _y[i][Le.inv(t)];
  },
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @memberof PIXI.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: function(i) {
    return i ^ 4;
  },
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: function(i) {
    return (i & 3) === 2;
  },
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @memberof PIXI.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: function(i, t) {
    return Math.abs(i) * 2 <= Math.abs(t) ? t >= 0 ? Le.S : Le.N : Math.abs(t) * 2 <= Math.abs(i) ? i > 0 ? Le.E : Le.W : t > 0 ? i > 0 ? Le.SE : Le.SW : i > 0 ? Le.NE : Le.NW;
  },
  /**
   * Helps sprite to compensate texture packer rotation.
   * @memberof PIXI.groupD8
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: function(i, t, e, r) {
    e === void 0 && (e = 0), r === void 0 && (r = 0);
    var n = jE[Le.inv(t)];
    n.tx = e, n.ty = r, i.append(n);
  }
}, zE = (
  /** @class */
  function() {
    function i() {
      this.worldTransform = new ar(), this.localTransform = new ar(), this.position = new Pu(this.onChange, this, 0, 0), this.scale = new Pu(this.onChange, this, 1, 1), this.pivot = new Pu(this.onChange, this, 0, 0), this.skew = new Pu(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
    }
    return i.prototype.onChange = function() {
      this._localID++;
    }, i.prototype.updateSkew = function() {
      this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
    }, i.prototype.toString = function() {
      return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
    }, i.prototype.updateLocalTransform = function() {
      var t = this.localTransform;
      this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1);
    }, i.prototype.updateTransform = function(t) {
      var e = this.localTransform;
      if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {
        var r = t.worldTransform, n = this.worldTransform;
        n.a = e.a * r.a + e.b * r.c, n.b = e.a * r.b + e.b * r.d, n.c = e.c * r.a + e.d * r.c, n.d = e.c * r.b + e.d * r.d, n.tx = e.tx * r.a + e.ty * r.c + r.tx, n.ty = e.tx * r.b + e.ty * r.d + r.ty, this._parentID = t._worldID, this._worldID++;
      }
    }, i.prototype.setFromMatrix = function(t) {
      t.decompose(this), this._localID++;
    }, Object.defineProperty(i.prototype, "rotation", {
      /** The rotation of the object in radians. */
      get: function() {
        return this._rotation;
      },
      set: function(t) {
        this._rotation !== t && (this._rotation = t, this.updateSkew());
      },
      enumerable: !1,
      configurable: !0
    }), i.IDENTITY = new i(), i;
  }()
);
/*!
 * @pixi/display - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
gt.SORTABLE_CHILDREN = !1;
var pv = (
  /** @class */
  function() {
    function i() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
    }
    return i.prototype.isEmpty = function() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }, i.prototype.clear = function() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
    }, i.prototype.getRectangle = function(t) {
      return this.minX > this.maxX || this.minY > this.maxY ? Nt.EMPTY : (t = t || new Nt(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t);
    }, i.prototype.addPoint = function(t) {
      this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y);
    }, i.prototype.addPointMatrix = function(t, e) {
      var r = t.a, n = t.b, s = t.c, a = t.d, o = t.tx, u = t.ty, l = r * e.x + s * e.y + o, h = n * e.x + a * e.y + u;
      this.minX = Math.min(this.minX, l), this.maxX = Math.max(this.maxX, l), this.minY = Math.min(this.minY, h), this.maxY = Math.max(this.maxY, h);
    }, i.prototype.addQuad = function(t) {
      var e = this.minX, r = this.minY, n = this.maxX, s = this.maxY, a = t[0], o = t[1];
      e = a < e ? a : e, r = o < r ? o : r, n = a > n ? a : n, s = o > s ? o : s, a = t[2], o = t[3], e = a < e ? a : e, r = o < r ? o : r, n = a > n ? a : n, s = o > s ? o : s, a = t[4], o = t[5], e = a < e ? a : e, r = o < r ? o : r, n = a > n ? a : n, s = o > s ? o : s, a = t[6], o = t[7], e = a < e ? a : e, r = o < r ? o : r, n = a > n ? a : n, s = o > s ? o : s, this.minX = e, this.minY = r, this.maxX = n, this.maxY = s;
    }, i.prototype.addFrame = function(t, e, r, n, s) {
      this.addFrameMatrix(t.worldTransform, e, r, n, s);
    }, i.prototype.addFrameMatrix = function(t, e, r, n, s) {
      var a = t.a, o = t.b, u = t.c, l = t.d, h = t.tx, d = t.ty, f = this.minX, p = this.minY, v = this.maxX, g = this.maxY, m = a * e + u * r + h, y = o * e + l * r + d;
      f = m < f ? m : f, p = y < p ? y : p, v = m > v ? m : v, g = y > g ? y : g, m = a * n + u * r + h, y = o * n + l * r + d, f = m < f ? m : f, p = y < p ? y : p, v = m > v ? m : v, g = y > g ? y : g, m = a * e + u * s + h, y = o * e + l * s + d, f = m < f ? m : f, p = y < p ? y : p, v = m > v ? m : v, g = y > g ? y : g, m = a * n + u * s + h, y = o * n + l * s + d, f = m < f ? m : f, p = y < p ? y : p, v = m > v ? m : v, g = y > g ? y : g, this.minX = f, this.minY = p, this.maxX = v, this.maxY = g;
    }, i.prototype.addVertexData = function(t, e, r) {
      for (var n = this.minX, s = this.minY, a = this.maxX, o = this.maxY, u = e; u < r; u += 2) {
        var l = t[u], h = t[u + 1];
        n = l < n ? l : n, s = h < s ? h : s, a = l > a ? l : a, o = h > o ? h : o;
      }
      this.minX = n, this.minY = s, this.maxX = a, this.maxY = o;
    }, i.prototype.addVertices = function(t, e, r, n) {
      this.addVerticesMatrix(t.worldTransform, e, r, n);
    }, i.prototype.addVerticesMatrix = function(t, e, r, n, s, a) {
      s === void 0 && (s = 0), a === void 0 && (a = s);
      for (var o = t.a, u = t.b, l = t.c, h = t.d, d = t.tx, f = t.ty, p = this.minX, v = this.minY, g = this.maxX, m = this.maxY, y = r; y < n; y += 2) {
        var _ = e[y], b = e[y + 1], w = o * _ + l * b + d, T = h * b + u * _ + f;
        p = Math.min(p, w - s), g = Math.max(g, w + s), v = Math.min(v, T - a), m = Math.max(m, T + a);
      }
      this.minX = p, this.minY = v, this.maxX = g, this.maxY = m;
    }, i.prototype.addBounds = function(t) {
      var e = this.minX, r = this.minY, n = this.maxX, s = this.maxY;
      this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < r ? t.minY : r, this.maxX = t.maxX > n ? t.maxX : n, this.maxY = t.maxY > s ? t.maxY : s;
    }, i.prototype.addBoundsMask = function(t, e) {
      var r = t.minX > e.minX ? t.minX : e.minX, n = t.minY > e.minY ? t.minY : e.minY, s = t.maxX < e.maxX ? t.maxX : e.maxX, a = t.maxY < e.maxY ? t.maxY : e.maxY;
      if (r <= s && n <= a) {
        var o = this.minX, u = this.minY, l = this.maxX, h = this.maxY;
        this.minX = r < o ? r : o, this.minY = n < u ? n : u, this.maxX = s > l ? s : l, this.maxY = a > h ? a : h;
      }
    }, i.prototype.addBoundsMatrix = function(t, e) {
      this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);
    }, i.prototype.addBoundsArea = function(t, e) {
      var r = t.minX > e.x ? t.minX : e.x, n = t.minY > e.y ? t.minY : e.y, s = t.maxX < e.x + e.width ? t.maxX : e.x + e.width, a = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
      if (r <= s && n <= a) {
        var o = this.minX, u = this.minY, l = this.maxX, h = this.maxY;
        this.minX = r < o ? r : o, this.minY = n < u ? n : u, this.maxX = s > l ? s : l, this.maxY = a > h ? a : h;
      }
    }, i.prototype.pad = function(t, e) {
      t === void 0 && (t = 0), e === void 0 && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e);
    }, i.prototype.addFramePad = function(t, e, r, n, s, a) {
      t -= s, e -= a, r += s, n += a, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > r ? this.maxX : r, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > n ? this.maxY : n;
    }, i;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var by = function(i, t) {
  return by = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, by(i, t);
};
function Sb(i, t) {
  by(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var He = (
  /** @class */
  function(i) {
    Sb(t, i);
    function t() {
      var e = i.call(this) || this;
      return e.tempDisplayObjectParent = null, e.transform = new zE(), e.alpha = 1, e.visible = !0, e.renderable = !0, e.cullable = !1, e.cullArea = null, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new pv(), e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._maskRefCount = 0, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e;
    }
    return t.mixin = function(e) {
      for (var r = Object.keys(e), n = 0; n < r.length; ++n) {
        var s = r[n];
        Object.defineProperty(t.prototype, s, Object.getOwnPropertyDescriptor(e, s));
      }
    }, Object.defineProperty(t.prototype, "destroyed", {
      /**
       * Fired when this DisplayObject is added to a Container.
       * @instance
       * @event added
       * @param {PIXI.Container} container - The container added to.
       */
      /**
       * Fired when this DisplayObject is removed from a Container.
       * @instance
       * @event removed
       * @param {PIXI.Container} container - The container removed from.
       */
      /**
       * Fired when this DisplayObject is destroyed. This event is emitted once
       * destroy is finished.
       * @instance
       * @event destroyed
       */
      /** Readonly flag for destroyed display objects. */
      get: function() {
        return this._destroyed;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype._recursivePostUpdateTransform = function() {
      this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }, t.prototype.updateTransform = function() {
      this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
    }, t.prototype.getBounds = function(e, r) {
      return e || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), r || (this._boundsRect || (this._boundsRect = new Nt()), r = this._boundsRect), this._bounds.getRectangle(r);
    }, t.prototype.getLocalBounds = function(e) {
      e || (this._localBoundsRect || (this._localBoundsRect = new Nt()), e = this._localBoundsRect), this._localBounds || (this._localBounds = new pv());
      var r = this.transform, n = this.parent;
      this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
      var s = this._bounds, a = this._boundsID;
      this._bounds = this._localBounds;
      var o = this.getBounds(!1, e);
      return this.parent = n, this.transform = r, this._bounds = s, this._bounds.updateID += this._boundsID - a, o;
    }, t.prototype.toGlobal = function(e, r, n) {
      return n === void 0 && (n = !1), n || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(e, r);
    }, t.prototype.toLocal = function(e, r, n, s) {
      return r && (e = r.toGlobal(e, n, s)), s || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(e, n);
    }, t.prototype.setParent = function(e) {
      if (!e || !e.addChild)
        throw new Error("setParent: Argument must be a Container");
      return e.addChild(this), e;
    }, t.prototype.setTransform = function(e, r, n, s, a, o, u, l, h) {
      return e === void 0 && (e = 0), r === void 0 && (r = 0), n === void 0 && (n = 1), s === void 0 && (s = 1), a === void 0 && (a = 0), o === void 0 && (o = 0), u === void 0 && (u = 0), l === void 0 && (l = 0), h === void 0 && (h = 0), this.position.x = e, this.position.y = r, this.scale.x = n || 1, this.scale.y = s || 1, this.rotation = a, this.skew.x = o, this.skew.y = u, this.pivot.x = l, this.pivot.y = h, this;
    }, t.prototype.destroy = function(e) {
      this.parent && this.parent.removeChild(this), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners();
    }, Object.defineProperty(t.prototype, "_tempDisplayObjectParent", {
      /**
       * @protected
       * @member {PIXI.Container}
       */
      get: function() {
        return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new HE()), this.tempDisplayObjectParent;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.enableTempParent = function() {
      var e = this.parent;
      return this.parent = this._tempDisplayObjectParent, e;
    }, t.prototype.disableTempParent = function(e) {
      this.parent = e;
    }, Object.defineProperty(t.prototype, "x", {
      /**
       * The position of the displayObject on the x axis relative to the local coordinates of the parent.
       * An alias to position.x
       */
      get: function() {
        return this.position.x;
      },
      set: function(e) {
        this.transform.position.x = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "y", {
      /**
       * The position of the displayObject on the y axis relative to the local coordinates of the parent.
       * An alias to position.y
       */
      get: function() {
        return this.position.y;
      },
      set: function(e) {
        this.transform.position.y = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "worldTransform", {
      /**
       * Current transform of the object based on world (parent) factors.
       * @readonly
       */
      get: function() {
        return this.transform.worldTransform;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "localTransform", {
      /**
       * Current transform of the object based on local factors: position, scale, other stuff.
       * @readonly
       */
      get: function() {
        return this.transform.localTransform;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "position", {
      /**
       * The coordinate of the object relative to the local coordinates of the parent.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.position;
      },
      set: function(e) {
        this.transform.position.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "scale", {
      /**
       * The scale factors of this object along the local coordinate axes.
       *
       * The default scale is (1, 1).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.scale;
      },
      set: function(e) {
        this.transform.scale.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "pivot", {
      /**
       * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
       * is the projection of `pivot` in the parent's local space.
       *
       * By default, the pivot is the origin (0, 0).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.pivot;
      },
      set: function(e) {
        this.transform.pivot.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "skew", {
      /**
       * The skew factor for the object in radians.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.skew;
      },
      set: function(e) {
        this.transform.skew.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "rotation", {
      /**
       * The rotation of the object in radians.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation;
      },
      set: function(e) {
        this.transform.rotation = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "angle", {
      /**
       * The angle of the object in degrees.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation * BD;
      },
      set: function(e) {
        this.transform.rotation = e * FD;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "zIndex", {
      /**
       * The zIndex of the displayObject.
       *
       * If a container has the sortableChildren property set to true, children will be automatically
       * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
       * and thus rendered on top of other display objects within the same container.
       * @see PIXI.Container#sortableChildren
       */
      get: function() {
        return this._zIndex;
      },
      set: function(e) {
        this._zIndex = e, this.parent && (this.parent.sortDirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "worldVisible", {
      /**
       * Indicates if the object is globally visible.
       * @readonly
       */
      get: function() {
        var e = this;
        do {
          if (!e.visible)
            return !1;
          e = e.parent;
        } while (e);
        return !0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "mask", {
      /**
       * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
       * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
       * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
       * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
       * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
       * To remove a mask, set this property to `null`.
       *
       * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
       * @example
       * const graphics = new PIXI.Graphics();
       * graphics.beginFill(0xFF3300);
       * graphics.drawRect(50, 250, 100, 100);
       * graphics.endFill();
       *
       * const sprite = new PIXI.Sprite(texture);
       * sprite.mask = graphics;
       * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
       */
      get: function() {
        return this._mask;
      },
      set: function(e) {
        if (this._mask !== e) {
          if (this._mask) {
            var r = this._mask.isMaskData ? this._mask.maskObject : this._mask;
            r && (r._maskRefCount--, r._maskRefCount === 0 && (r.renderable = !0, r.isMask = !1));
          }
          if (this._mask = e, this._mask) {
            var r = this._mask.isMaskData ? this._mask.maskObject : this._mask;
            r && (r._maskRefCount === 0 && (r.renderable = !1, r.isMask = !0), r._maskRefCount++);
          }
        }
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Pi)
), HE = (
  /** @class */
  function(i) {
    Sb(t, i);
    function t() {
      var e = i !== null && i.apply(this, arguments) || this;
      return e.sortDirty = null, e;
    }
    return t;
  }(He)
);
He.prototype.displayObjectUpdateTransform = He.prototype.updateTransform;
function HD(i, t) {
  return i.zIndex === t.zIndex ? i._lastSortedIndex - t._lastSortedIndex : i.zIndex - t.zIndex;
}
var ye = (
  /** @class */
  function(i) {
    Sb(t, i);
    function t() {
      var e = i.call(this) || this;
      return e.children = [], e.sortableChildren = gt.SORTABLE_CHILDREN, e.sortDirty = !1, e;
    }
    return t.prototype.onChildrenChange = function(e) {
    }, t.prototype.addChild = function() {
      for (var e = arguments, r = [], n = 0; n < arguments.length; n++)
        r[n] = e[n];
      if (r.length > 1)
        for (var s = 0; s < r.length; s++)
          this.addChild(r[s]);
      else {
        var a = r[0];
        a.parent && a.parent.removeChild(a), a.parent = this, this.sortDirty = !0, a.transform._parentID = -1, this.children.push(a), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", a, this, this.children.length - 1), a.emit("added", this);
      }
      return r[0];
    }, t.prototype.addChildAt = function(e, r) {
      if (r < 0 || r > this.children.length)
        throw new Error(e + "addChildAt: The index " + r + " supplied is out of bounds " + this.children.length);
      return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(r, 0, e), this._boundsID++, this.onChildrenChange(r), e.emit("added", this), this.emit("childAdded", e, this, r), e;
    }, t.prototype.swapChildren = function(e, r) {
      if (e !== r) {
        var n = this.getChildIndex(e), s = this.getChildIndex(r);
        this.children[n] = r, this.children[s] = e, this.onChildrenChange(n < s ? n : s);
      }
    }, t.prototype.getChildIndex = function(e) {
      var r = this.children.indexOf(e);
      if (r === -1)
        throw new Error("The supplied DisplayObject must be a child of the caller");
      return r;
    }, t.prototype.setChildIndex = function(e, r) {
      if (r < 0 || r >= this.children.length)
        throw new Error("The index " + r + " supplied is out of bounds " + this.children.length);
      var n = this.getChildIndex(e);
      Lu(this.children, n, 1), this.children.splice(r, 0, e), this.onChildrenChange(r);
    }, t.prototype.getChildAt = function(e) {
      if (e < 0 || e >= this.children.length)
        throw new Error("getChildAt: Index (" + e + ") does not exist.");
      return this.children[e];
    }, t.prototype.removeChild = function() {
      for (var e = arguments, r = [], n = 0; n < arguments.length; n++)
        r[n] = e[n];
      if (r.length > 1)
        for (var s = 0; s < r.length; s++)
          this.removeChild(r[s]);
      else {
        var a = r[0], o = this.children.indexOf(a);
        if (o === -1)
          return null;
        a.parent = null, a.transform._parentID = -1, Lu(this.children, o, 1), this._boundsID++, this.onChildrenChange(o), a.emit("removed", this), this.emit("childRemoved", a, this, o);
      }
      return r[0];
    }, t.prototype.removeChildAt = function(e) {
      var r = this.getChildAt(e);
      return r.parent = null, r.transform._parentID = -1, Lu(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), r.emit("removed", this), this.emit("childRemoved", r, this, e), r;
    }, t.prototype.removeChildren = function(e, r) {
      e === void 0 && (e = 0), r === void 0 && (r = this.children.length);
      var n = e, s = r, a = s - n, o;
      if (a > 0 && a <= s) {
        o = this.children.splice(n, a);
        for (var u = 0; u < o.length; ++u)
          o[u].parent = null, o[u].transform && (o[u].transform._parentID = -1);
        this._boundsID++, this.onChildrenChange(e);
        for (var u = 0; u < o.length; ++u)
          o[u].emit("removed", this), this.emit("childRemoved", o[u], this, u);
        return o;
      } else if (a === 0 && this.children.length === 0)
        return [];
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    }, t.prototype.sortChildren = function() {
      for (var e = !1, r = 0, n = this.children.length; r < n; ++r) {
        var s = this.children[r];
        s._lastSortedIndex = r, !e && s.zIndex !== 0 && (e = !0);
      }
      e && this.children.length > 1 && this.children.sort(HD), this.sortDirty = !1;
    }, t.prototype.updateTransform = function() {
      this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (var e = 0, r = this.children.length; e < r; ++e) {
        var n = this.children[e];
        n.visible && n.updateTransform();
      }
    }, t.prototype.calculateBounds = function() {
      this._bounds.clear(), this._calculateBounds();
      for (var e = 0; e < this.children.length; e++) {
        var r = this.children[e];
        if (!(!r.visible || !r.renderable))
          if (r.calculateBounds(), r._mask) {
            var n = r._mask.isMaskData ? r._mask.maskObject : r._mask;
            n ? (n.calculateBounds(), this._bounds.addBoundsMask(r._bounds, n._bounds)) : this._bounds.addBounds(r._bounds);
          } else
            r.filterArea ? this._bounds.addBoundsArea(r._bounds, r.filterArea) : this._bounds.addBounds(r._bounds);
      }
      this._bounds.updateID = this._boundsID;
    }, t.prototype.getLocalBounds = function(e, r) {
      r === void 0 && (r = !1);
      var n = i.prototype.getLocalBounds.call(this, e);
      if (!r)
        for (var s = 0, a = this.children.length; s < a; ++s) {
          var o = this.children[s];
          o.visible && o.updateTransform();
        }
      return n;
    }, t.prototype._calculateBounds = function() {
    }, t.prototype._renderWithCulling = function(e) {
      var r = e.renderTexture.sourceFrame;
      if (r.width > 0 && r.height > 0) {
        var n, s;
        if (this.cullArea ? (n = this.cullArea, s = this.worldTransform) : this._render !== t.prototype._render && (n = this.getBounds(!0)), n && r.intersects(n, s))
          this._render(e);
        else if (this.cullArea)
          return;
        for (var a = 0, o = this.children.length; a < o; ++a) {
          var u = this.children[a], l = u.cullable;
          u.cullable = l || !this.cullArea, u.render(e), u.cullable = l;
        }
      }
    }, t.prototype.render = function(e) {
      if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
        if (this._mask || this.filters && this.filters.length)
          this.renderAdvanced(e);
        else if (this.cullable)
          this._renderWithCulling(e);
        else {
          this._render(e);
          for (var r = 0, n = this.children.length; r < n; ++r)
            this.children[r].render(e);
        }
    }, t.prototype.renderAdvanced = function(e) {
      var r = this.filters, n = this._mask;
      if (r) {
        this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
        for (var s = 0; s < r.length; s++)
          r[s].enabled && this._enabledFilters.push(r[s]);
      }
      var a = r && this._enabledFilters && this._enabledFilters.length || n && (!n.isMaskData || n.enabled && (n.autoDetect || n.type !== Ze.NONE));
      if (a && e.batch.flush(), r && this._enabledFilters && this._enabledFilters.length && e.filter.push(this, this._enabledFilters), n && e.mask.push(this, this._mask), this.cullable)
        this._renderWithCulling(e);
      else {
        this._render(e);
        for (var s = 0, o = this.children.length; s < o; ++s)
          this.children[s].render(e);
      }
      a && e.batch.flush(), n && e.mask.pop(this), r && this._enabledFilters && this._enabledFilters.length && e.filter.pop();
    }, t.prototype._render = function(e) {
    }, t.prototype.destroy = function(e) {
      i.prototype.destroy.call(this), this.sortDirty = !1;
      var r = typeof e == "boolean" ? e : e && e.children, n = this.removeChildren(0, this.children.length);
      if (r)
        for (var s = 0; s < n.length; ++s)
          n[s].destroy(e);
    }, Object.defineProperty(t.prototype, "width", {
      /** The width of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.x * this.getLocalBounds().width;
      },
      set: function(e) {
        var r = this.getLocalBounds().width;
        r !== 0 ? this.scale.x = e / r : this.scale.x = 1, this._width = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.y * this.getLocalBounds().height;
      },
      set: function(e) {
        var r = this.getLocalBounds().height;
        r !== 0 ? this.scale.y = e / r : this.scale.y = 1, this._height = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(He)
);
ye.prototype.containerUpdateTransform = ye.prototype.updateTransform;
/*!
 * @pixi/extensions - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/extensions is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Xh = function() {
  return Xh = Object.assign || function(t) {
    for (var e = arguments, r, n = 1, s = arguments.length; n < s; n++) {
      r = e[n];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (t[a] = r[a]);
    }
    return t;
  }, Xh.apply(this, arguments);
}, de;
(function(i) {
  i.Application = "application", i.RendererPlugin = "renderer-webgl-plugin", i.CanvasRendererPlugin = "renderer-canvas-plugin", i.Loader = "loader", i.LoadParser = "load-parser", i.ResolveParser = "resolve-parser", i.CacheParser = "cache-parser", i.DetectionParser = "detection-parser";
})(de || (de = {}));
var b1 = function(i) {
  if (typeof i == "function" || typeof i == "object" && i.extension) {
    if (!i.extension)
      throw new Error("Extension class must have an extension object");
    var t = typeof i.extension != "object" ? { type: i.extension } : i.extension;
    i = Xh(Xh({}, t), { ref: i });
  }
  if (typeof i == "object")
    i = Xh({}, i);
  else
    throw new Error("Invalid extension type");
  return typeof i.type == "string" && (i.type = [i.type]), i;
}, an = {
  /** @ignore */
  _addHandlers: null,
  /** @ignore */
  _removeHandlers: null,
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {PIXI.extensions} For chaining.
   */
  remove: function() {
    for (var i = arguments, t = this, e = [], r = 0; r < arguments.length; r++)
      e[r] = i[r];
    return e.map(b1).forEach(function(n) {
      n.type.forEach(function(s) {
        var a, o;
        return (o = (a = t._removeHandlers)[s]) === null || o === void 0 ? void 0 : o.call(a, n);
      });
    }), this;
  },
  /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {PIXI.extensions} For chaining.
   */
  add: function() {
    for (var i = arguments, t = this, e = [], r = 0; r < arguments.length; r++)
      e[r] = i[r];
    return e.map(b1).forEach(function(n) {
      n.type.forEach(function(s) {
        var a = t._addHandlers, o = t._queue;
        a[s] ? a[s](n) : (o[s] = o[s] || [], o[s].push(n));
      });
    }), this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.
   * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.
   * @returns {PIXI.extensions} For chaining.
   */
  handle: function(i, t, e) {
    var r = this._addHandlers = this._addHandlers || {}, n = this._removeHandlers = this._removeHandlers || {};
    if (r[i] || n[i])
      throw new Error("Extension type " + i + " already has a handler");
    r[i] = t, n[i] = e;
    var s = this._queue;
    return s[i] && (s[i].forEach(function(a) {
      return t(a);
    }), delete s[i]), this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByMap: function(i, t) {
    return this.handle(i, function(e) {
      t[e.name] = e.ref;
    }, function(e) {
      delete t[e.name];
    });
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByList: function(i, t) {
    return this.handle(i, function(e) {
      var r, n;
      t.includes(e.ref) || (t.push(e.ref), i === de.Loader && ((n = (r = e.ref).add) === null || n === void 0 || n.call(r)));
    }, function(e) {
      var r = t.indexOf(e.ref);
      r !== -1 && t.splice(r, 1);
    });
  }
};
/*!
 * @pixi/runner - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var pr = (
  /** @class */
  function() {
    function i(t) {
      this.items = [], this._name = t, this._aliasCount = 0;
    }
    return i.prototype.emit = function(t, e, r, n, s, a, o, u) {
      if (arguments.length > 8)
        throw new Error("max arguments reached");
      var l = this, h = l.name, d = l.items;
      this._aliasCount++;
      for (var f = 0, p = d.length; f < p; f++)
        d[f][h](t, e, r, n, s, a, o, u);
      return d === this.items && this._aliasCount--, this;
    }, i.prototype.ensureNonAliasedItems = function() {
      this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
    }, i.prototype.add = function(t) {
      return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this;
    }, i.prototype.remove = function(t) {
      var e = this.items.indexOf(t);
      return e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this;
    }, i.prototype.contains = function(t) {
      return this.items.indexOf(t) !== -1;
    }, i.prototype.removeAll = function() {
      return this.ensureNonAliasedItems(), this.items.length = 0, this;
    }, i.prototype.destroy = function() {
      this.removeAll(), this.items = null, this._name = null;
    }, Object.defineProperty(i.prototype, "empty", {
      /**
       * `true` if there are no this Runner contains no listeners
       * @readonly
       */
      get: function() {
        return this.items.length === 0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "name", {
      /**
       * The name of the runner.
       * @readonly
       */
      get: function() {
        return this._name;
      },
      enumerable: !1,
      configurable: !0
    }), i;
  }()
);
Object.defineProperties(pr.prototype, {
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method dispatch
   * @see PIXI.Runner#emit
   */
  dispatch: { value: pr.prototype.emit },
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method run
   * @see PIXI.Runner#emit
   */
  run: { value: pr.prototype.emit }
});
/*!
 * @pixi/ticker - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/ticker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
gt.TARGET_FPMS = 0.06;
var Cs;
(function(i) {
  i[i.INTERACTION = 50] = "INTERACTION", i[i.HIGH = 25] = "HIGH", i[i.NORMAL = 0] = "NORMAL", i[i.LOW = -25] = "LOW", i[i.UTILITY = -50] = "UTILITY";
})(Cs || (Cs = {}));
var R0 = (
  /** @class */
  function() {
    function i(t, e, r, n) {
      e === void 0 && (e = null), r === void 0 && (r = 0), n === void 0 && (n = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = r, this.once = n;
    }
    return i.prototype.match = function(t, e) {
      return e === void 0 && (e = null), this.fn === t && this.context === e;
    }, i.prototype.emit = function(t) {
      this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
      var e = this.next;
      return this.once && this.destroy(!0), this._destroyed && (this.next = null), e;
    }, i.prototype.connect = function(t) {
      this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
    }, i.prototype.destroy = function(t) {
      t === void 0 && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
      var e = this.next;
      return this.next = t ? null : e, this.previous = null, e;
    }, i;
  }()
), Ge = (
  /** @class */
  function() {
    function i() {
      var t = this;
      this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new R0(null, null, 1 / 0), this.deltaMS = 1 / gt.TARGET_FPMS, this.elapsedMS = 1 / gt.TARGET_FPMS, this._tick = function(e) {
        t._requestId = null, t.started && (t.update(e), t.started && t._requestId === null && t._head.next && (t._requestId = requestAnimationFrame(t._tick)));
      };
    }
    return i.prototype._requestIfNeeded = function() {
      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
    }, i.prototype._cancelIfNeeded = function() {
      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }, i.prototype._startIfPossible = function() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }, i.prototype.add = function(t, e, r) {
      return r === void 0 && (r = Cs.NORMAL), this._addListener(new R0(t, e, r));
    }, i.prototype.addOnce = function(t, e, r) {
      return r === void 0 && (r = Cs.NORMAL), this._addListener(new R0(t, e, r, !0));
    }, i.prototype._addListener = function(t) {
      var e = this._head.next, r = this._head;
      if (!e)
        t.connect(r);
      else {
        for (; e; ) {
          if (t.priority > e.priority) {
            t.connect(r);
            break;
          }
          r = e, e = e.next;
        }
        t.previous || t.connect(r);
      }
      return this._startIfPossible(), this;
    }, i.prototype.remove = function(t, e) {
      for (var r = this._head.next; r; )
        r.match(t, e) ? r = r.destroy() : r = r.next;
      return this._head.next || this._cancelIfNeeded(), this;
    }, Object.defineProperty(i.prototype, "count", {
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       * @readonly
       * @member {number}
       */
      get: function() {
        if (!this._head)
          return 0;
        for (var t = 0, e = this._head; e = e.next; )
          t++;
        return t;
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.start = function() {
      this.started || (this.started = !0, this._requestIfNeeded());
    }, i.prototype.stop = function() {
      this.started && (this.started = !1, this._cancelIfNeeded());
    }, i.prototype.destroy = function() {
      if (!this._protected) {
        this.stop();
        for (var t = this._head.next; t; )
          t = t.destroy(!0);
        this._head.destroy(), this._head = null;
      }
    }, i.prototype.update = function(t) {
      t === void 0 && (t = performance.now());
      var e;
      if (t > this.lastTime) {
        if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
          var r = t - this._lastFrame | 0;
          if (r < this._minElapsedMS)
            return;
          this._lastFrame = t - r % this._minElapsedMS;
        }
        this.deltaMS = e, this.deltaTime = this.deltaMS * gt.TARGET_FPMS;
        for (var n = this._head, s = n.next; s; )
          s = s.emit(this.deltaTime);
        n.next || this._cancelIfNeeded();
      } else
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = t;
    }, Object.defineProperty(i.prototype, "FPS", {
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link PIXI.Ticker#speed}, which is specific
       * to scaling {@link PIXI.Ticker#deltaTime}.
       * @member {number}
       * @readonly
       */
      get: function() {
        return 1e3 / this.elapsedMS;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "minFPS", {
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This value is used to cap {@link PIXI.Ticker#deltaTime},
       * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
       * @member {number}
       * @default 10
       */
      get: function() {
        return 1e3 / this._maxElapsedMS;
      },
      set: function(t) {
        var e = Math.min(this.maxFPS, t), r = Math.min(Math.max(0, e) / 1e3, gt.TARGET_FPMS);
        this._maxElapsedMS = 1 / r;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "maxFPS", {
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This will effect the measured value of {@link PIXI.Ticker#FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @member {number}
       * @default 0
       */
      get: function() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
      },
      set: function(t) {
        if (t === 0)
          this._minElapsedMS = 0;
        else {
          var e = Math.max(this.minFPS, t);
          this._minElapsedMS = 1 / (e / 1e3);
        }
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i, "shared", {
      /**
       * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
       * {@link PIXI.VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * let ticker = PIXI.Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the PIXI.Ticker.shared instance.
       * ticker.autoStart = false;
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * // You may use the shared ticker to render...
       * let renderer = PIXI.autoDetectRenderer();
       * let stage = new PIXI.Container();
       * document.body.appendChild(renderer.view);
       * ticker.add(function (time) {
       *     renderer.render(stage);
       * });
       * @example
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * function animate(time) {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * }
       * animate(performance.now());
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!i._shared) {
          var t = i._shared = new i();
          t.autoStart = !0, t._protected = !0;
        }
        return i._shared;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i, "system", {
      /**
       * The system ticker instance used by {@link PIXI.InteractionManager} and by
       * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
       * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!i._system) {
          var t = i._system = new i();
          t.autoStart = !0, t._protected = !0;
        }
        return i._system;
      },
      enumerable: !1,
      configurable: !0
    }), i;
  }()
), $D = (
  /** @class */
  function() {
    function i() {
    }
    return i.init = function(t) {
      var e = this;
      t = Object.assign({
        autoStart: !0,
        sharedTicker: !1
      }, t), Object.defineProperty(this, "ticker", {
        set: function(r) {
          this._ticker && this._ticker.remove(this.render, this), this._ticker = r, r && r.add(this.render, this, Cs.LOW);
        },
        get: function() {
          return this._ticker;
        }
      }), this.stop = function() {
        e._ticker.stop();
      }, this.start = function() {
        e._ticker.start();
      }, this._ticker = null, this.ticker = t.sharedTicker ? Ge.shared : new Ge(), t.autoStart && this.start();
    }, i.destroy = function() {
      if (this._ticker) {
        var t = this._ticker;
        this.ticker = null, t.destroy();
      }
    }, i.extension = de.Application, i;
  }()
);
/*!
 * @pixi/core - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
gt.PREFER_ENV = Mn.any ? Ts.WEBGL : Ts.WEBGL2;
gt.STRICT_TEXTURE_CACHE = !1;
var oc = [];
function e0(i, t) {
  if (!i)
    return null;
  var e = "";
  if (typeof i == "string") {
    var r = /\.(\w{3,4})(?:$|\?|#)/i.exec(i);
    r && (e = r[1].toLowerCase());
  }
  for (var n = oc.length - 1; n >= 0; --n) {
    var s = oc[n];
    if (s.test && s.test(i, e))
      return new s(i, t);
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var xy = function(i, t) {
  return xy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, xy(i, t);
};
function Ce(i, t) {
  xy(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var wy = function() {
  return wy = Object.assign || function(t) {
    for (var e = arguments, r, n = 1, s = arguments.length; n < s; n++) {
      r = e[n];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (t[a] = r[a]);
    }
    return t;
  }, wy.apply(this, arguments);
};
function VD(i, t) {
  var e = {};
  for (var r in i)
    Object.prototype.hasOwnProperty.call(i, r) && t.indexOf(r) < 0 && (e[r] = i[r]);
  if (i != null && typeof Object.getOwnPropertySymbols == "function")
    for (var n = 0, r = Object.getOwnPropertySymbols(i); n < r.length; n++)
      t.indexOf(r[n]) < 0 && Object.prototype.propertyIsEnumerable.call(i, r[n]) && (e[r[n]] = i[r[n]]);
  return e;
}
var Ko = (
  /** @class */
  function() {
    function i(t, e) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new pr("setRealSize"), this.onUpdate = new pr("update"), this.onError = new pr("onError");
    }
    return i.prototype.bind = function(t) {
      this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height);
    }, i.prototype.unbind = function(t) {
      this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t);
    }, i.prototype.resize = function(t, e) {
      (t !== this._width || e !== this._height) && (this._width = t, this._height = e, this.onResize.emit(t, e));
    }, Object.defineProperty(i.prototype, "valid", {
      /**
       * Has been validated
       * @readonly
       */
      get: function() {
        return !!this._width && !!this._height;
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.update = function() {
      this.destroyed || this.onUpdate.emit();
    }, i.prototype.load = function() {
      return Promise.resolve(this);
    }, Object.defineProperty(i.prototype, "width", {
      /**
       * The width of the resource.
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "height", {
      /**
       * The height of the resource.
       * @readonly
       */
      get: function() {
        return this._height;
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.style = function(t, e, r) {
      return !1;
    }, i.prototype.dispose = function() {
    }, i.prototype.destroy = function() {
      this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
    }, i.test = function(t, e) {
      return !1;
    }, i;
  }()
), su = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e, r) {
      var n = this, s = r || {}, a = s.width, o = s.height;
      if (!a || !o)
        throw new Error("BufferResource width or height invalid");
      return n = i.call(this, a, o) || this, n.data = e, n;
    }
    return t.prototype.upload = function(e, r, n) {
      var s = e.gl;
      s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === en.UNPACK);
      var a = r.realWidth, o = r.realHeight;
      return n.width === a && n.height === o ? s.texSubImage2D(r.target, 0, 0, 0, a, o, r.format, n.type, this.data) : (n.width = a, n.height = o, s.texImage2D(r.target, 0, n.internalFormat, a, o, 0, r.format, n.type, this.data)), !0;
    }, t.prototype.dispose = function() {
      this.data = null;
    }, t.test = function(e) {
      return e instanceof Float32Array || e instanceof Uint8Array || e instanceof Uint32Array;
    }, t;
  }(Ko)
), XD = {
  scaleMode: Cn.NEAREST,
  format: ht.RGBA,
  alphaMode: en.NPM
}, Kt = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e, r) {
      e === void 0 && (e = null), r === void 0 && (r = null);
      var n = i.call(this) || this;
      r = r || {};
      var s = r.alphaMode, a = r.mipmap, o = r.anisotropicLevel, u = r.scaleMode, l = r.width, h = r.height, d = r.wrapMode, f = r.format, p = r.type, v = r.target, g = r.resolution, m = r.resourceOptions;
      return e && !(e instanceof Ko) && (e = e0(e, m), e.internal = !0), n.resolution = g || gt.RESOLUTION, n.width = Math.round((l || 0) * n.resolution) / n.resolution, n.height = Math.round((h || 0) * n.resolution) / n.resolution, n._mipmap = a !== void 0 ? a : gt.MIPMAP_TEXTURES, n.anisotropicLevel = o !== void 0 ? o : gt.ANISOTROPIC_LEVEL, n._wrapMode = d || gt.WRAP_MODE, n._scaleMode = u !== void 0 ? u : gt.SCALE_MODE, n.format = f || ht.RGBA, n.type = p || It.UNSIGNED_BYTE, n.target = v || Xo.TEXTURE_2D, n.alphaMode = s !== void 0 ? s : en.UNPACK, n.uid = Zo(), n.touched = 0, n.isPowerOfTwo = !1, n._refreshPOT(), n._glTextures = {}, n.dirtyId = 0, n.dirtyStyleId = 0, n.cacheId = null, n.valid = l > 0 && h > 0, n.textureCacheIds = [], n.destroyed = !1, n.resource = null, n._batchEnabled = 0, n._batchLocation = 0, n.parentTextureArray = null, n.setResource(e), n;
    }
    return Object.defineProperty(t.prototype, "realWidth", {
      /**
       * Pixel width of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.width * this.resolution);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "realHeight", {
      /**
       * Pixel height of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.height * this.resolution);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "mipmap", {
      /**
       * Mipmap mode of the texture, affects downscaled images
       * @default PIXI.settings.MIPMAP_TEXTURES
       */
      get: function() {
        return this._mipmap;
      },
      set: function(e) {
        this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "scaleMode", {
      /**
       * The scale mode to apply when scaling this texture
       * @default PIXI.settings.SCALE_MODE
       */
      get: function() {
        return this._scaleMode;
      },
      set: function(e) {
        this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "wrapMode", {
      /**
       * How the texture wraps
       * @default PIXI.settings.WRAP_MODE
       */
      get: function() {
        return this._wrapMode;
      },
      set: function(e) {
        this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++);
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.setStyle = function(e, r) {
      var n;
      return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e, n = !0), r !== void 0 && r !== this.mipmap && (this.mipmap = r, n = !0), n && this.dirtyStyleId++, this;
    }, t.prototype.setSize = function(e, r, n) {
      return n = n || this.resolution, this.setRealSize(e * n, r * n, n);
    }, t.prototype.setRealSize = function(e, r, n) {
      return this.resolution = n || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(r) / this.resolution, this._refreshPOT(), this.update(), this;
    }, t.prototype._refreshPOT = function() {
      this.isPowerOfTwo = v1(this.realWidth) && v1(this.realHeight);
    }, t.prototype.setResolution = function(e) {
      var r = this.resolution;
      return r === e ? this : (this.resolution = e, this.valid && (this.width = Math.round(this.width * r) / e, this.height = Math.round(this.height * r) / e, this.emit("update", this)), this._refreshPOT(), this);
    }, t.prototype.setResource = function(e) {
      if (this.resource === e)
        return this;
      if (this.resource)
        throw new Error("Resource can be set only once");
      return e.bind(this), this.resource = e, this;
    }, t.prototype.update = function() {
      this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this));
    }, t.prototype.onError = function(e) {
      this.emit("error", this, e);
    }, t.prototype.destroy = function() {
      this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete Xn[this.cacheId], delete Gr[this.cacheId], this.cacheId = null), this.dispose(), t.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0;
    }, t.prototype.dispose = function() {
      this.emit("dispose", this);
    }, t.prototype.castToBaseTexture = function() {
      return this;
    }, t.from = function(e, r, n) {
      n === void 0 && (n = gt.STRICT_TEXTURE_CACHE);
      var s = typeof e == "string", a = null;
      if (s)
        a = e;
      else {
        if (!e._pixiId) {
          var o = r && r.pixiIdPrefix || "pixiid";
          e._pixiId = o + "_" + Zo();
        }
        a = e._pixiId;
      }
      var u = Xn[a];
      if (s && n && !u)
        throw new Error('The cacheId "' + a + '" does not exist in BaseTextureCache.');
      return u || (u = new t(e, r), u.cacheId = a, t.addToCache(u, a)), u;
    }, t.fromBuffer = function(e, r, n, s) {
      e = e || new Float32Array(r * n * 4);
      var a = new su(e, { width: r, height: n }), o = e instanceof Float32Array ? It.FLOAT : It.UNSIGNED_BYTE;
      return new t(a, Object.assign({}, XD, s || { width: r, height: n, type: o }));
    }, t.addToCache = function(e, r) {
      r && (e.textureCacheIds.indexOf(r) === -1 && e.textureCacheIds.push(r), Xn[r] && console.warn("BaseTexture added to the cache with an id [" + r + "] that already had an entry"), Xn[r] = e);
    }, t.removeFromCache = function(e) {
      if (typeof e == "string") {
        var r = Xn[e];
        if (r) {
          var n = r.textureCacheIds.indexOf(e);
          return n > -1 && r.textureCacheIds.splice(n, 1), delete Xn[e], r;
        }
      } else if (e && e.textureCacheIds) {
        for (var s = 0; s < e.textureCacheIds.length; ++s)
          delete Xn[e.textureCacheIds[s]];
        return e.textureCacheIds.length = 0, e;
      }
      return null;
    }, t._globalBatch = 0, t;
  }(Pi)
), r0 = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e, r) {
      var n = this, s = r || {}, a = s.width, o = s.height;
      n = i.call(this, a, o) || this, n.items = [], n.itemDirtyIds = [];
      for (var u = 0; u < e; u++) {
        var l = new Kt();
        n.items.push(l), n.itemDirtyIds.push(-2);
      }
      return n.length = e, n._load = null, n.baseTexture = null, n;
    }
    return t.prototype.initFromArray = function(e, r) {
      for (var n = 0; n < this.length; n++)
        e[n] && (e[n].castToBaseTexture ? this.addBaseTextureAt(e[n].castToBaseTexture(), n) : e[n] instanceof Ko ? this.addResourceAt(e[n], n) : this.addResourceAt(e0(e[n], r), n));
    }, t.prototype.dispose = function() {
      for (var e = 0, r = this.length; e < r; e++)
        this.items[e].destroy();
      this.items = null, this.itemDirtyIds = null, this._load = null;
    }, t.prototype.addResourceAt = function(e, r) {
      if (!this.items[r])
        throw new Error("Index " + r + " is out of bounds");
      return e.valid && !this.valid && this.resize(e.width, e.height), this.items[r].setResource(e), this;
    }, t.prototype.bind = function(e) {
      if (this.baseTexture !== null)
        throw new Error("Only one base texture per TextureArray is allowed");
      i.prototype.bind.call(this, e);
      for (var r = 0; r < this.length; r++)
        this.items[r].parentTextureArray = e, this.items[r].on("update", e.update, e);
    }, t.prototype.unbind = function(e) {
      i.prototype.unbind.call(this, e);
      for (var r = 0; r < this.length; r++)
        this.items[r].parentTextureArray = null, this.items[r].off("update", e.update, e);
    }, t.prototype.load = function() {
      var e = this;
      if (this._load)
        return this._load;
      var r = this.items.map(function(s) {
        return s.resource;
      }).filter(function(s) {
        return s;
      }), n = r.map(function(s) {
        return s.load();
      });
      return this._load = Promise.all(n).then(function() {
        var s = e.items[0], a = s.realWidth, o = s.realHeight;
        return e.resize(a, o), Promise.resolve(e);
      }), this._load;
    }, t;
  }(Ko)
), Tb = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e, r) {
      var n = this, s = r || {}, a = s.width, o = s.height, u, l;
      return Array.isArray(e) ? (u = e, l = e.length) : l = e, n = i.call(this, l, { width: a, height: o }) || this, u && n.initFromArray(u, r), n;
    }
    return t.prototype.addBaseTextureAt = function(e, r) {
      if (e.resource)
        this.addResourceAt(e.resource, r);
      else
        throw new Error("ArrayResource does not support RenderTexture");
      return this;
    }, t.prototype.bind = function(e) {
      i.prototype.bind.call(this, e), e.target = Xo.TEXTURE_2D_ARRAY;
    }, t.prototype.upload = function(e, r, n) {
      var s = this, a = s.length, o = s.itemDirtyIds, u = s.items, l = e.gl;
      n.dirtyId < 0 && l.texImage3D(l.TEXTURE_2D_ARRAY, 0, n.internalFormat, this._width, this._height, a, 0, r.format, n.type, null);
      for (var h = 0; h < a; h++) {
        var d = u[h];
        o[h] < d.dirtyId && (o[h] = d.dirtyId, d.valid && l.texSubImage3D(
          l.TEXTURE_2D_ARRAY,
          0,
          0,
          // xoffset
          0,
          // yoffset
          h,
          // zoffset
          d.resource.width,
          d.resource.height,
          1,
          r.format,
          n.type,
          d.resource.source
        ));
      }
      return !0;
    }, t;
  }(r0)
), Dn = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e) {
      var r = this, n = e, s = n.naturalWidth || n.videoWidth || n.width, a = n.naturalHeight || n.videoHeight || n.height;
      return r = i.call(this, s, a) || this, r.source = e, r.noSubImage = !1, r;
    }
    return t.crossOrigin = function(e, r, n) {
      n === void 0 && r.indexOf("data:") !== 0 ? e.crossOrigin = LD(r) : n !== !1 && (e.crossOrigin = typeof n == "string" ? n : "anonymous");
    }, t.prototype.upload = function(e, r, n, s) {
      var a = e.gl, o = r.realWidth, u = r.realHeight;
      if (s = s || this.source, s instanceof HTMLImageElement) {
        if (!s.complete || s.naturalWidth === 0)
          return !1;
      } else if (s instanceof HTMLVideoElement && s.readyState <= 1)
        return !1;
      return a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === en.UNPACK), !this.noSubImage && r.target === a.TEXTURE_2D && n.width === o && n.height === u ? a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, r.format, n.type, s) : (n.width = o, n.height = u, a.texImage2D(r.target, 0, n.internalFormat, r.format, n.type, s)), !0;
    }, t.prototype.update = function() {
      if (!this.destroyed) {
        var e = this.source, r = e.naturalWidth || e.videoWidth || e.width, n = e.naturalHeight || e.videoHeight || e.height;
        this.resize(r, n), i.prototype.update.call(this);
      }
    }, t.prototype.dispose = function() {
      this.source = null;
    }, t;
  }(Ko)
), Cb = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e) {
      return i.call(this, e) || this;
    }
    return t.test = function(e) {
      var r = globalThis.OffscreenCanvas;
      return r && e instanceof r ? !0 : globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement;
    }, t;
  }(Dn)
), Mb = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e, r) {
      var n = this, s = r || {}, a = s.width, o = s.height, u = s.autoLoad, l = s.linkBaseTexture;
      if (e && e.length !== t.SIDES)
        throw new Error("Invalid length. Got " + e.length + ", expected 6");
      n = i.call(this, 6, { width: a, height: o }) || this;
      for (var h = 0; h < t.SIDES; h++)
        n.items[h].target = Xo.TEXTURE_CUBE_MAP_POSITIVE_X + h;
      return n.linkBaseTexture = l !== !1, e && n.initFromArray(e, r), u !== !1 && n.load(), n;
    }
    return t.prototype.bind = function(e) {
      i.prototype.bind.call(this, e), e.target = Xo.TEXTURE_CUBE_MAP;
    }, t.prototype.addBaseTextureAt = function(e, r, n) {
      if (!this.items[r])
        throw new Error("Index " + r + " is out of bounds");
      if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)
        if (e.resource)
          this.addResourceAt(e.resource, r);
        else
          throw new Error("CubeResource does not support copying of renderTexture.");
      else
        e.target = Xo.TEXTURE_CUBE_MAP_POSITIVE_X + r, e.parentTextureArray = this.baseTexture, this.items[r] = e;
      return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[r] = e, this;
    }, t.prototype.upload = function(e, r, n) {
      for (var s = this.itemDirtyIds, a = 0; a < t.SIDES; a++) {
        var o = this.items[a];
        (s[a] < o.dirtyId || n.dirtyId < r.dirtyId) && (o.valid && o.resource ? (o.resource.upload(e, o, n), s[a] = o.dirtyId) : s[a] < -1 && (e.gl.texImage2D(o.target, 0, n.internalFormat, r.realWidth, r.realHeight, 0, r.format, n.type, null), s[a] = -1));
      }
      return !0;
    }, t.test = function(e) {
      return Array.isArray(e) && e.length === t.SIDES;
    }, t.SIDES = 6, t;
  }(r0)
), i0 = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e, r) {
      var n = this;
      if (r = r || {}, !(e instanceof HTMLImageElement)) {
        var s = new Image();
        Dn.crossOrigin(s, e, r.crossorigin), s.src = e, e = s;
      }
      return n = i.call(this, e) || this, !e.complete && n._width && n._height && (n._width = 0, n._height = 0), n.url = e.src, n._process = null, n.preserveBitmap = !1, n.createBitmap = (r.createBitmap !== void 0 ? r.createBitmap : gt.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, n.alphaMode = typeof r.alphaMode == "number" ? r.alphaMode : null, n.bitmap = null, n._load = null, r.autoLoad !== !1 && n.load(), n;
    }
    return t.prototype.load = function(e) {
      var r = this;
      return this._load ? this._load : (e !== void 0 && (this.createBitmap = e), this._load = new Promise(function(n, s) {
        var a = r.source;
        r.url = a.src;
        var o = function() {
          r.destroyed || (a.onload = null, a.onerror = null, r.resize(a.width, a.height), r._load = null, r.createBitmap ? n(r.process()) : n(r));
        };
        a.complete && a.src ? o() : (a.onload = o, a.onerror = function(u) {
          s(u), r.onError.emit(u);
        });
      }), this._load);
    }, t.prototype.process = function() {
      var e = this, r = this.source;
      if (this._process !== null)
        return this._process;
      if (this.bitmap !== null || !globalThis.createImageBitmap)
        return Promise.resolve(this);
      var n = globalThis.createImageBitmap, s = !r.crossOrigin || r.crossOrigin === "anonymous";
      return this._process = fetch(r.src, {
        mode: s ? "cors" : "no-cors"
      }).then(function(a) {
        return a.blob();
      }).then(function(a) {
        return n(a, 0, 0, r.width, r.height, {
          premultiplyAlpha: e.alphaMode === null || e.alphaMode === en.UNPACK ? "premultiply" : "none"
        });
      }).then(function(a) {
        return e.destroyed ? Promise.reject() : (e.bitmap = a, e.update(), e._process = null, Promise.resolve(e));
      }), this._process;
    }, t.prototype.upload = function(e, r, n) {
      if (typeof this.alphaMode == "number" && (r.alphaMode = this.alphaMode), !this.createBitmap)
        return i.prototype.upload.call(this, e, r, n);
      if (!this.bitmap && (this.process(), !this.bitmap))
        return !1;
      if (i.prototype.upload.call(this, e, r, n, this.bitmap), !this.preserveBitmap) {
        var s = !0, a = r._glTextures;
        for (var o in a) {
          var u = a[o];
          if (u !== n && u.dirtyId !== r.dirtyId) {
            s = !1;
            break;
          }
        }
        s && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
      }
      return !0;
    }, t.prototype.dispose = function() {
      this.source.onload = null, this.source.onerror = null, i.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
    }, t.test = function(e) {
      return typeof e == "string" || e instanceof HTMLImageElement;
    }, t;
  }(Dn)
), Pb = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e, r) {
      var n = this;
      return r = r || {}, n = i.call(this, gt.ADAPTER.createCanvas()) || this, n._width = 0, n._height = 0, n.svg = e, n.scale = r.scale || 1, n._overrideWidth = r.width, n._overrideHeight = r.height, n._resolve = null, n._crossorigin = r.crossorigin, n._load = null, r.autoLoad !== !1 && n.load(), n;
    }
    return t.prototype.load = function() {
      var e = this;
      return this._load ? this._load : (this._load = new Promise(function(r) {
        if (e._resolve = function() {
          e.resize(e.source.width, e.source.height), r(e);
        }, t.SVG_XML.test(e.svg.trim())) {
          if (!btoa)
            throw new Error("Your browser doesn't support base64 conversions.");
          e.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(e.svg)));
        }
        e._loadSvg();
      }), this._load);
    }, t.prototype._loadSvg = function() {
      var e = this, r = new Image();
      Dn.crossOrigin(r, this.svg, this._crossorigin), r.src = this.svg, r.onerror = function(n) {
        e._resolve && (r.onerror = null, e.onError.emit(n));
      }, r.onload = function() {
        if (e._resolve) {
          var n = r.width, s = r.height;
          if (!n || !s)
            throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
          var a = n * e.scale, o = s * e.scale;
          (e._overrideWidth || e._overrideHeight) && (a = e._overrideWidth || e._overrideHeight / s * n, o = e._overrideHeight || e._overrideWidth / n * s), a = Math.round(a), o = Math.round(o);
          var u = e.source;
          u.width = a, u.height = o, u._pixiId = "canvas_" + Zo(), u.getContext("2d").drawImage(r, 0, 0, n, s, 0, 0, a, o), e._resolve(), e._resolve = null;
        }
      };
    }, t.getSize = function(e) {
      var r = t.SVG_SIZE.exec(e), n = {};
      return r && (n[r[1]] = Math.round(parseFloat(r[3])), n[r[5]] = Math.round(parseFloat(r[7]))), n;
    }, t.prototype.dispose = function() {
      i.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;
    }, t.test = function(e, r) {
      return r === "svg" || typeof e == "string" && e.startsWith("data:image/svg+xml") || typeof e == "string" && t.SVG_XML.test(e);
    }, t.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, t.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, t;
  }(Dn)
), Ob = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e, r) {
      var n = this;
      if (r = r || {}, !(e instanceof HTMLVideoElement)) {
        var s = document.createElement("video");
        s.setAttribute("preload", "auto"), s.setAttribute("webkit-playsinline", ""), s.setAttribute("playsinline", ""), typeof e == "string" && (e = [e]);
        var a = e[0].src || e[0];
        Dn.crossOrigin(s, a, r.crossorigin);
        for (var o = 0; o < e.length; ++o) {
          var u = document.createElement("source"), l = e[o], h = l.src, d = l.mime;
          h = h || e[o];
          var f = h.split("?").shift().toLowerCase(), p = f.slice(f.lastIndexOf(".") + 1);
          d = d || t.MIME_TYPES[p] || "video/" + p, u.src = h, u.type = d, s.appendChild(u);
        }
        e = s;
      }
      return n = i.call(this, e) || this, n.noSubImage = !0, n._autoUpdate = !0, n._isConnectedToTicker = !1, n._updateFPS = r.updateFPS || 0, n._msToNextUpdate = 0, n.autoPlay = r.autoPlay !== !1, n._load = null, n._resolve = null, n._onCanPlay = n._onCanPlay.bind(n), n._onError = n._onError.bind(n), r.autoLoad !== !1 && n.load(), n;
    }
    return t.prototype.update = function(e) {
      if (!this.destroyed) {
        var r = Ge.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - r), (!this._updateFPS || this._msToNextUpdate <= 0) && (i.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
      }
    }, t.prototype.load = function() {
      var e = this;
      if (this._load)
        return this._load;
      var r = this.source;
      return (r.readyState === r.HAVE_ENOUGH_DATA || r.readyState === r.HAVE_FUTURE_DATA) && r.width && r.height && (r.complete = !0), r.addEventListener("play", this._onPlayStart.bind(this)), r.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (r.addEventListener("canplay", this._onCanPlay), r.addEventListener("canplaythrough", this._onCanPlay), r.addEventListener("error", this._onError, !0)), this._load = new Promise(function(n) {
        e.valid ? n(e) : (e._resolve = n, r.load());
      }), this._load;
    }, t.prototype._onError = function(e) {
      this.source.removeEventListener("error", this._onError, !0), this.onError.emit(e);
    }, t.prototype._isSourcePlaying = function() {
      var e = this.source;
      return !e.paused && !e.ended && this._isSourceReady();
    }, t.prototype._isSourceReady = function() {
      var e = this.source;
      return e.readyState > 2;
    }, t.prototype._onPlayStart = function() {
      this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Ge.shared.add(this.update, this), this._isConnectedToTicker = !0);
    }, t.prototype._onPlayStop = function() {
      this._isConnectedToTicker && (Ge.shared.remove(this.update, this), this._isConnectedToTicker = !1);
    }, t.prototype._onCanPlay = function() {
      var e = this.source;
      e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlay);
      var r = this.valid;
      this.resize(e.videoWidth, e.videoHeight), !r && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play();
    }, t.prototype.dispose = function() {
      this._isConnectedToTicker && (Ge.shared.remove(this.update, this), this._isConnectedToTicker = !1);
      var e = this.source;
      e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), i.prototype.dispose.call(this);
    }, Object.defineProperty(t.prototype, "autoUpdate", {
      /** Should the base texture automatically update itself, set to true by default. */
      get: function() {
        return this._autoUpdate;
      },
      set: function(e) {
        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ge.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Ge.shared.add(this.update, this), this._isConnectedToTicker = !0));
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "updateFPS", {
      /**
       * How many times a second to update the texture from the video. Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       */
      get: function() {
        return this._updateFPS;
      },
      set: function(e) {
        e !== this._updateFPS && (this._updateFPS = e);
      },
      enumerable: !1,
      configurable: !0
    }), t.test = function(e, r) {
      return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || t.TYPES.indexOf(r) > -1;
    }, t.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], t.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    }, t;
  }(Dn)
), Ib = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e) {
      return i.call(this, e) || this;
    }
    return t.test = function(e) {
      return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && e instanceof ImageBitmap;
    }, t;
  }(Dn)
);
oc.push(i0, Ib, Cb, Ob, Pb, su, Mb, Tb);
var $E = {
  __proto__: null,
  Resource: Ko,
  BaseImageResource: Dn,
  INSTALLED: oc,
  autoDetectResource: e0,
  AbstractMultiResource: r0,
  ArrayResource: Tb,
  BufferResource: su,
  CanvasResource: Cb,
  CubeResource: Mb,
  ImageResource: i0,
  SVGResource: Pb,
  VideoResource: Ob,
  ImageBitmapResource: Ib
}, WD = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return t.prototype.upload = function(e, r, n) {
      var s = e.gl;
      s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === en.UNPACK);
      var a = r.realWidth, o = r.realHeight;
      return n.width === a && n.height === o ? s.texSubImage2D(r.target, 0, 0, 0, a, o, r.format, n.type, this.data) : (n.width = a, n.height = o, s.texImage2D(r.target, 0, n.internalFormat, a, o, 0, r.format, n.type, this.data)), !0;
    }, t;
  }(su)
), vv = (
  /** @class */
  function() {
    function i(t, e) {
      this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new pr("disposeFramebuffer"), this.multisample = ke.NONE;
    }
    return Object.defineProperty(i.prototype, "colorTexture", {
      /**
       * Reference to the colorTexture.
       * @readonly
       */
      get: function() {
        return this.colorTextures[0];
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.addColorTexture = function(t, e) {
      return t === void 0 && (t = 0), this.colorTextures[t] = e || new Kt(null, {
        scaleMode: Cn.NEAREST,
        resolution: 1,
        mipmap: tn.OFF,
        width: this.width,
        height: this.height
      }), this.dirtyId++, this.dirtyFormat++, this;
    }, i.prototype.addDepthTexture = function(t) {
      return this.depthTexture = t || new Kt(new WD(null, { width: this.width, height: this.height }), {
        scaleMode: Cn.NEAREST,
        resolution: 1,
        width: this.width,
        height: this.height,
        mipmap: tn.OFF,
        format: ht.DEPTH_COMPONENT,
        type: It.UNSIGNED_SHORT
      }), this.dirtyId++, this.dirtyFormat++, this;
    }, i.prototype.enableDepth = function() {
      return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;
    }, i.prototype.enableStencil = function() {
      return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;
    }, i.prototype.resize = function(t, e) {
      if (t = Math.round(t), e = Math.round(e), !(t === this.width && e === this.height)) {
        this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;
        for (var r = 0; r < this.colorTextures.length; r++) {
          var n = this.colorTextures[r], s = n.resolution;
          n.setSize(t / s, e / s);
        }
        if (this.depthTexture) {
          var s = this.depthTexture.resolution;
          this.depthTexture.setSize(t / s, e / s);
        }
      }
    }, i.prototype.dispose = function() {
      this.disposeRunner.emit(this, !1);
    }, i.prototype.destroyDepthTexture = function() {
      this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
    }, i;
  }()
), Rb = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e) {
      e === void 0 && (e = {});
      var r = this;
      if (typeof e == "number") {
        var n = arguments[0], s = arguments[1], a = arguments[2], o = arguments[3];
        e = { width: n, height: s, scaleMode: a, resolution: o };
      }
      return e.width = e.width || 100, e.height = e.height || 100, e.multisample = e.multisample !== void 0 ? e.multisample : ke.NONE, r = i.call(this, null, e) || this, r.mipmap = tn.OFF, r.valid = !0, r.clearColor = [0, 0, 0, 0], r.framebuffer = new vv(r.realWidth, r.realHeight).addColorTexture(0, r), r.framebuffer.multisample = e.multisample, r.maskStack = [], r.filterStack = [{}], r;
    }
    return t.prototype.resize = function(e, r) {
      this.framebuffer.resize(e * this.resolution, r * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
    }, t.prototype.dispose = function() {
      this.framebuffer.dispose(), i.prototype.dispose.call(this);
    }, t.prototype.destroy = function() {
      i.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
    }, t;
  }(Kt)
), Db = (
  /** @class */
  function() {
    function i() {
      this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
    }
    return i.prototype.set = function(t, e, r) {
      var n = e.width, s = e.height;
      if (r) {
        var a = t.width / 2 / n, o = t.height / 2 / s, u = t.x / n + a, l = t.y / s + o;
        r = Le.add(r, Le.NW), this.x0 = u + a * Le.uX(r), this.y0 = l + o * Le.uY(r), r = Le.add(r, 2), this.x1 = u + a * Le.uX(r), this.y1 = l + o * Le.uY(r), r = Le.add(r, 2), this.x2 = u + a * Le.uX(r), this.y2 = l + o * Le.uY(r), r = Le.add(r, 2), this.x3 = u + a * Le.uX(r), this.y3 = l + o * Le.uY(r);
      } else
        this.x0 = t.x / n, this.y0 = t.y / s, this.x1 = (t.x + t.width) / n, this.y1 = t.y / s, this.x2 = (t.x + t.width) / n, this.y2 = (t.y + t.height) / s, this.x3 = t.x / n, this.y3 = (t.y + t.height) / s;
      this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
    }, i.prototype.toString = function() {
      return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
    }, i;
  }()
), x1 = new Db();
function jd(i) {
  i.destroy = function() {
  }, i.on = function() {
  }, i.once = function() {
  }, i.emit = function() {
  };
}
var Ot = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e, r, n, s, a, o) {
      var u = i.call(this) || this;
      if (u.noFrame = !1, r || (u.noFrame = !0, r = new Nt(0, 0, 1, 1)), e instanceof t && (e = e.baseTexture), u.baseTexture = e, u._frame = r, u.trim = s, u.valid = !1, u._uvs = x1, u.uvMatrix = null, u.orig = n || r, u._rotate = Number(a || 0), a === !0)
        u._rotate = 2;
      else if (u._rotate % 2 !== 0)
        throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
      return u.defaultAnchor = o ? new xe(o.x, o.y) : new xe(0, 0), u._updateID = 0, u.textureCacheIds = [], e.valid ? u.noFrame ? e.valid && u.onBaseTextureUpdated(e) : u.frame = r : e.once("loaded", u.onBaseTextureUpdated, u), u.noFrame && e.on("update", u.onBaseTextureUpdated, u), u;
    }
    return t.prototype.update = function() {
      this.baseTexture.resource && this.baseTexture.resource.update();
    }, t.prototype.onBaseTextureUpdated = function(e) {
      if (this.noFrame) {
        if (!this.baseTexture.valid)
          return;
        this._frame.width = e.width, this._frame.height = e.height, this.valid = !0, this.updateUvs();
      } else
        this.frame = this._frame;
      this.emit("update", this);
    }, t.prototype.destroy = function(e) {
      if (this.baseTexture) {
        if (e) {
          var r = this.baseTexture.resource;
          r && r.url && Gr[r.url] && t.removeFromCache(r.url), this.baseTexture.destroy();
        }
        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
      }
      this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, t.removeFromCache(this), this.textureCacheIds = null;
    }, t.prototype.clone = function() {
      var e = this._frame.clone(), r = this._frame === this.orig ? e : this.orig.clone(), n = new t(this.baseTexture, !this.noFrame && e, r, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
      return this.noFrame && (n._frame = e), n;
    }, t.prototype.updateUvs = function() {
      this._uvs === x1 && (this._uvs = new Db()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
    }, t.from = function(e, r, n) {
      r === void 0 && (r = {}), n === void 0 && (n = gt.STRICT_TEXTURE_CACHE);
      var s = typeof e == "string", a = null;
      if (s)
        a = e;
      else if (e instanceof Kt) {
        if (!e.cacheId) {
          var o = r && r.pixiIdPrefix || "pixiid";
          e.cacheId = o + "-" + Zo(), Kt.addToCache(e, e.cacheId);
        }
        a = e.cacheId;
      } else {
        if (!e._pixiId) {
          var o = r && r.pixiIdPrefix || "pixiid";
          e._pixiId = o + "_" + Zo();
        }
        a = e._pixiId;
      }
      var u = Gr[a];
      if (s && n && !u)
        throw new Error('The cacheId "' + a + '" does not exist in TextureCache.');
      return !u && !(e instanceof Kt) ? (r.resolution || (r.resolution = fv(e)), u = new t(new Kt(e, r)), u.baseTexture.cacheId = a, Kt.addToCache(u.baseTexture, a), t.addToCache(u, a)) : !u && e instanceof Kt && (u = new t(e), t.addToCache(u, a)), u;
    }, t.fromURL = function(e, r) {
      var n = Object.assign({ autoLoad: !1 }, r == null ? void 0 : r.resourceOptions), s = t.from(e, Object.assign({ resourceOptions: n }, r), !1), a = s.baseTexture.resource;
      return s.baseTexture.valid ? Promise.resolve(s) : a.load().then(function() {
        return Promise.resolve(s);
      });
    }, t.fromBuffer = function(e, r, n, s) {
      return new t(Kt.fromBuffer(e, r, n, s));
    }, t.fromLoader = function(e, r, n, s) {
      var a = new Kt(e, Object.assign({
        scaleMode: gt.SCALE_MODE,
        resolution: fv(r)
      }, s)), o = a.resource;
      o instanceof i0 && (o.url = r);
      var u = new t(a);
      return n || (n = r), Kt.addToCache(u.baseTexture, n), t.addToCache(u, n), n !== r && (Kt.addToCache(u.baseTexture, r), t.addToCache(u, r)), u.baseTexture.valid ? Promise.resolve(u) : new Promise(function(l) {
        u.baseTexture.once("loaded", function() {
          return l(u);
        });
      });
    }, t.addToCache = function(e, r) {
      r && (e.textureCacheIds.indexOf(r) === -1 && e.textureCacheIds.push(r), Gr[r] && console.warn("Texture added to the cache with an id [" + r + "] that already had an entry"), Gr[r] = e);
    }, t.removeFromCache = function(e) {
      if (typeof e == "string") {
        var r = Gr[e];
        if (r) {
          var n = r.textureCacheIds.indexOf(e);
          return n > -1 && r.textureCacheIds.splice(n, 1), delete Gr[e], r;
        }
      } else if (e && e.textureCacheIds) {
        for (var s = 0; s < e.textureCacheIds.length; ++s)
          Gr[e.textureCacheIds[s]] === e && delete Gr[e.textureCacheIds[s]];
        return e.textureCacheIds.length = 0, e;
      }
      return null;
    }, Object.defineProperty(t.prototype, "resolution", {
      /**
       * Returns resolution of baseTexture
       * @readonly
       */
      get: function() {
        return this.baseTexture.resolution;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "frame", {
      /**
       * The frame specifies the region of the base texture that this texture uses.
       * Please call `updateUvs()` after you change coordinates of `frame` manually.
       */
      get: function() {
        return this._frame;
      },
      set: function(e) {
        this._frame = e, this.noFrame = !1;
        var r = e.x, n = e.y, s = e.width, a = e.height, o = r + s > this.baseTexture.width, u = n + a > this.baseTexture.height;
        if (o || u) {
          var l = o && u ? "and" : "or", h = "X: " + r + " + " + s + " = " + (r + s) + " > " + this.baseTexture.width, d = "Y: " + n + " + " + a + " = " + (n + a) + " > " + this.baseTexture.height;
          throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (h + " " + l + " " + d));
        }
        this.valid = s && a && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = e), this.valid && this.updateUvs();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "rotate", {
      /**
       * Indicates whether the texture is rotated inside the atlas
       * set to 2 to compensate for texture packer rotation
       * set to 6 to compensate for spine packer rotation
       * can be used to rotate or mirror sprites
       * See {@link PIXI.groupD8} for explanation
       */
      get: function() {
        return this._rotate;
      },
      set: function(e) {
        this._rotate = e, this.valid && this.updateUvs();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "width", {
      /** The width of the Texture in pixels. */
      get: function() {
        return this.orig.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the Texture in pixels. */
      get: function() {
        return this.orig.height;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.castToBaseTexture = function() {
      return this.baseTexture;
    }, Object.defineProperty(t, "EMPTY", {
      /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */
      get: function() {
        return t._EMPTY || (t._EMPTY = new t(new Kt()), jd(t._EMPTY), jd(t._EMPTY.baseTexture)), t._EMPTY;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "WHITE", {
      /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */
      get: function() {
        if (!t._WHITE) {
          var e = gt.ADAPTER.createCanvas(16, 16), r = e.getContext("2d");
          e.width = 16, e.height = 16, r.fillStyle = "white", r.fillRect(0, 0, 16, 16), t._WHITE = new t(Kt.from(e)), jd(t._WHITE), jd(t._WHITE.baseTexture);
        }
        return t._WHITE;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Pi)
), Ei = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e, r) {
      var n = i.call(this, e, r) || this;
      return n.valid = !0, n.filterFrame = null, n.filterPoolKey = null, n.updateUvs(), n;
    }
    return Object.defineProperty(t.prototype, "framebuffer", {
      /**
       * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
       * @readonly
       */
      get: function() {
        return this.baseTexture.framebuffer;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "multisample", {
      /**
       * Shortcut to `this.framebuffer.multisample`.
       * @default PIXI.MSAA_QUALITY.NONE
       */
      get: function() {
        return this.framebuffer.multisample;
      },
      set: function(e) {
        this.framebuffer.multisample = e;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.resize = function(e, r, n) {
      n === void 0 && (n = !0);
      var s = this.baseTexture.resolution, a = Math.round(e * s) / s, o = Math.round(r * s) / s;
      this.valid = a > 0 && o > 0, this._frame.width = this.orig.width = a, this._frame.height = this.orig.height = o, n && this.baseTexture.resize(a, o), this.updateUvs();
    }, t.prototype.setResolution = function(e) {
      var r = this.baseTexture;
      r.resolution !== e && (r.setResolution(e), this.resize(r.width, r.height, !1));
    }, t.create = function(e) {
      for (var r = arguments, n = [], s = 1; s < arguments.length; s++)
        n[s - 1] = r[s];
      return typeof e == "number" && (jr("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), e = {
        width: e,
        height: n[0],
        scaleMode: n[1],
        resolution: n[2]
      }), new t(new Rb(e));
    }, t;
  }(Ot)
), VE = (
  /** @class */
  function() {
    function i(t) {
      this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;
    }
    return i.prototype.createTexture = function(t, e, r) {
      r === void 0 && (r = ke.NONE);
      var n = new Rb(Object.assign({
        width: t,
        height: e,
        resolution: 1,
        multisample: r
      }, this.textureOptions));
      return new Ei(n);
    }, i.prototype.getOptimalTexture = function(t, e, r, n) {
      r === void 0 && (r = 1), n === void 0 && (n = ke.NONE);
      var s;
      t = Math.ceil(t * r - 1e-6), e = Math.ceil(e * r - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || e !== this._pixelsHeight ? (t = cv(t), e = cv(e), s = ((t & 65535) << 16 | e & 65535) >>> 0, n > 1 && (s += n * 4294967296)) : s = n > 1 ? -n : -1, this.texturePool[s] || (this.texturePool[s] = []);
      var a = this.texturePool[s].pop();
      return a || (a = this.createTexture(t, e, n)), a.filterPoolKey = s, a.setResolution(r), a;
    }, i.prototype.getFilterTexture = function(t, e, r) {
      var n = this.getOptimalTexture(t.width, t.height, e || t.resolution, r || ke.NONE);
      return n.filterFrame = t.filterFrame, n;
    }, i.prototype.returnTexture = function(t) {
      var e = t.filterPoolKey;
      t.filterFrame = null, this.texturePool[e].push(t);
    }, i.prototype.returnFilterTexture = function(t) {
      this.returnTexture(t);
    }, i.prototype.clear = function(t) {
      if (t = t !== !1, t)
        for (var e in this.texturePool) {
          var r = this.texturePool[e];
          if (r)
            for (var n = 0; n < r.length; n++)
              r[n].destroy(!0);
        }
      this.texturePool = {};
    }, i.prototype.setScreenSize = function(t) {
      if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {
        this.enableFullScreen = t.width > 0 && t.height > 0;
        for (var e in this.texturePool)
          if (Number(e) < 0) {
            var r = this.texturePool[e];
            if (r)
              for (var n = 0; n < r.length; n++)
                r[n].destroy(!0);
            this.texturePool[e] = [];
          }
        this._pixelsWidth = t.width, this._pixelsHeight = t.height;
      }
    }, i.SCREEN_KEY = -1, i;
  }()
), Ey = (
  /** @class */
  function() {
    function i(t, e, r, n, s, a, o) {
      e === void 0 && (e = 0), r === void 0 && (r = !1), n === void 0 && (n = It.FLOAT), this.buffer = t, this.size = e, this.normalized = r, this.type = n, this.stride = s, this.start = a, this.instance = o;
    }
    return i.prototype.destroy = function() {
      this.buffer = null;
    }, i.from = function(t, e, r, n, s) {
      return new i(t, e, r, n, s);
    }, i;
  }()
), YD = 0, Ke = (
  /** @class */
  function() {
    function i(t, e, r) {
      e === void 0 && (e = !0), r === void 0 && (r = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = r, this.static = e, this.id = YD++, this.disposeRunner = new pr("disposeBuffer");
    }
    return i.prototype.update = function(t) {
      t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++;
    }, i.prototype.dispose = function() {
      this.disposeRunner.emit(this, !1);
    }, i.prototype.destroy = function() {
      this.dispose(), this.data = null;
    }, Object.defineProperty(i.prototype, "index", {
      get: function() {
        return this.type === In.ELEMENT_ARRAY_BUFFER;
      },
      /**
       * Flags whether this is an index buffer.
       *
       * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make
       * the buffer of type `ARRAY_BUFFER`.
       *
       * For backwards compatibility.
       */
      set: function(t) {
        this.type = t ? In.ELEMENT_ARRAY_BUFFER : In.ARRAY_BUFFER;
      },
      enumerable: !1,
      configurable: !0
    }), i.from = function(t) {
      return t instanceof Array && (t = new Float32Array(t)), new i(t);
    }, i;
  }()
), qD = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function ZD(i, t) {
  for (var e = 0, r = 0, n = {}, s = 0; s < i.length; s++)
    r += t[s], e += i[s].length;
  for (var a = new ArrayBuffer(e * 4), o = null, u = 0, s = 0; s < i.length; s++) {
    var l = t[s], h = i[s], d = GE(h);
    n[d] || (n[d] = new qD[d](a)), o = n[d];
    for (var f = 0; f < h.length; f++) {
      var p = (f / l | 0) * r + u, v = f % l;
      o[p + v] = h[f];
    }
    u += l;
  }
  return new Float32Array(a);
}
var w1 = { 5126: 4, 5123: 2, 5121: 1 }, KD = 0, JD = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
}, uh = (
  /** @class */
  function() {
    function i(t, e) {
      t === void 0 && (t = []), e === void 0 && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = KD++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new pr("disposeGeometry"), this.refCount = 0;
    }
    return i.prototype.addAttribute = function(t, e, r, n, s, a, o, u) {
      if (r === void 0 && (r = 0), n === void 0 && (n = !1), u === void 0 && (u = !1), !e)
        throw new Error("You must pass a buffer when creating an attribute");
      e instanceof Ke || (e instanceof Array && (e = new Float32Array(e)), e = new Ke(e));
      var l = t.split("|");
      if (l.length > 1) {
        for (var h = 0; h < l.length; h++)
          this.addAttribute(l[h], e, r, n, s);
        return this;
      }
      var d = this.buffers.indexOf(e);
      return d === -1 && (this.buffers.push(e), d = this.buffers.length - 1), this.attributes[t] = new Ey(d, r, n, s, a, o, u), this.instanced = this.instanced || u, this;
    }, i.prototype.getAttribute = function(t) {
      return this.attributes[t];
    }, i.prototype.getBuffer = function(t) {
      return this.buffers[this.getAttribute(t).buffer];
    }, i.prototype.addIndex = function(t) {
      return t instanceof Ke || (t instanceof Array && (t = new Uint16Array(t)), t = new Ke(t)), t.type = In.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.indexOf(t) === -1 && this.buffers.push(t), this;
    }, i.prototype.getIndex = function() {
      return this.indexBuffer;
    }, i.prototype.interleave = function() {
      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
        return this;
      var t = [], e = [], r = new Ke(), n;
      for (n in this.attributes) {
        var s = this.attributes[n], a = this.buffers[s.buffer];
        t.push(a.data), e.push(s.size * w1[s.type] / 4), s.buffer = 0;
      }
      for (r.data = ZD(t, e), n = 0; n < this.buffers.length; n++)
        this.buffers[n] !== this.indexBuffer && this.buffers[n].destroy();
      return this.buffers = [r], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
    }, i.prototype.getSize = function() {
      for (var t in this.attributes) {
        var e = this.attributes[t], r = this.buffers[e.buffer];
        return r.data.length / (e.stride / 4 || e.size);
      }
      return 0;
    }, i.prototype.dispose = function() {
      this.disposeRunner.emit(this, !1);
    }, i.prototype.destroy = function() {
      this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
    }, i.prototype.clone = function() {
      for (var t = new i(), e = 0; e < this.buffers.length; e++)
        t.buffers[e] = new Ke(this.buffers[e].data.slice(0));
      for (var e in this.attributes) {
        var r = this.attributes[e];
        t.attributes[e] = new Ey(r.buffer, r.size, r.normalized, r.type, r.stride, r.start, r.instance);
      }
      return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = In.ELEMENT_ARRAY_BUFFER), t;
    }, i.merge = function(t) {
      for (var e = new i(), r = [], n = [], s = [], a, o = 0; o < t.length; o++) {
        a = t[o];
        for (var u = 0; u < a.buffers.length; u++)
          n[u] = n[u] || 0, n[u] += a.buffers[u].data.length, s[u] = 0;
      }
      for (var o = 0; o < a.buffers.length; o++)
        r[o] = new JD[GE(a.buffers[o].data)](n[o]), e.buffers[o] = new Ke(r[o]);
      for (var o = 0; o < t.length; o++) {
        a = t[o];
        for (var u = 0; u < a.buffers.length; u++)
          r[u].set(a.buffers[u].data, s[u]), s[u] += a.buffers[u].data.length;
      }
      if (e.attributes = a.attributes, a.indexBuffer) {
        e.indexBuffer = e.buffers[a.buffers.indexOf(a.indexBuffer)], e.indexBuffer.type = In.ELEMENT_ARRAY_BUFFER;
        for (var l = 0, h = 0, d = 0, f = 0, o = 0; o < a.buffers.length; o++)
          if (a.buffers[o] !== a.indexBuffer) {
            f = o;
            break;
          }
        for (var o in a.attributes) {
          var p = a.attributes[o];
          (p.buffer | 0) === f && (h += p.size * w1[p.type] / 4);
        }
        for (var o = 0; o < t.length; o++) {
          for (var v = t[o].indexBuffer.data, u = 0; u < v.length; u++)
            e.indexBuffer.data[u + d] += l;
          l += t[o].buffers[f].data.length / h, d += v.length;
        }
      }
      return e;
    }, i;
  }()
), XE = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t() {
      var e = i.call(this) || this;
      return e.addAttribute("aVertexPosition", new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ])).addIndex([0, 1, 3, 2]), e;
    }
    return t;
  }(uh)
), kb = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t() {
      var e = i.call(this) || this;
      return e.vertices = new Float32Array([
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1
      ]), e.uvs = new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]), e.vertexBuffer = new Ke(e.vertices), e.uvBuffer = new Ke(e.uvs), e.addAttribute("aVertexPosition", e.vertexBuffer).addAttribute("aTextureCoord", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e;
    }
    return t.prototype.map = function(e, r) {
      var n = 0, s = 0;
      return this.uvs[0] = n, this.uvs[1] = s, this.uvs[2] = n + r.width / e.width, this.uvs[3] = s, this.uvs[4] = n + r.width / e.width, this.uvs[5] = s + r.height / e.height, this.uvs[6] = n, this.uvs[7] = s + r.height / e.height, n = r.x, s = r.y, this.vertices[0] = n, this.vertices[1] = s, this.vertices[2] = n + r.width, this.vertices[3] = s, this.vertices[4] = n + r.width, this.vertices[5] = s + r.height, this.vertices[6] = n, this.vertices[7] = s + r.height, this.invalidate(), this;
    }, t.prototype.invalidate = function() {
      return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
    }, t;
  }(uh)
), QD = 0, la = (
  /** @class */
  function() {
    function i(t, e, r) {
      this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = QD++, this.static = !!e, this.ubo = !!r, t instanceof Ke ? (this.buffer = t, this.buffer.type = In.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Ke(new Float32Array(1)), this.buffer.type = In.UNIFORM_BUFFER, this.autoManage = !0));
    }
    return i.prototype.update = function() {
      this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
    }, i.prototype.add = function(t, e, r) {
      if (!this.ubo)
        this.uniforms[t] = new i(e, r);
      else
        throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }, i.from = function(t, e, r) {
      return new i(t, e, r);
    }, i.uboFrom = function(t, e) {
      return new i(t, e ?? !0, !0);
    }, i;
  }()
), WE = (
  /** @class */
  function() {
    function i() {
      this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = ke.NONE, this.sourceFrame = new Nt(), this.destinationFrame = new Nt(), this.bindingSourceFrame = new Nt(), this.bindingDestinationFrame = new Nt(), this.filters = [], this.transform = null;
    }
    return i.prototype.clear = function() {
      this.target = null, this.filters = null, this.renderTexture = null;
    }, i;
  }()
), zd = [new xe(), new xe(), new xe(), new xe()], D0 = new ar(), Nb = (
  /** @class */
  function() {
    function i(t) {
      this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new VE(), this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new XE(), this.quadUv = new kb(), this.tempRect = new Nt(), this.activeState = {}, this.globalUniforms = new la({
        outputFrame: new Nt(),
        inputSize: new Float32Array(4),
        inputPixel: new Float32Array(4),
        inputClamp: new Float32Array(4),
        resolution: 1,
        // legacy variables
        filterArea: new Float32Array(4),
        filterClamp: new Float32Array(4)
      }, !0), this.forceClear = !1, this.useMaxPadding = !1;
    }
    return i.prototype.push = function(t, e) {
      for (var r, n, s = this.renderer, a = this.defaultFilterStack, o = this.statePool.pop() || new WE(), u = this.renderer.renderTexture, l = e[0].resolution, h = e[0].multisample, d = e[0].padding, f = e[0].autoFit, p = (r = e[0].legacy) !== null && r !== void 0 ? r : !0, v = 1; v < e.length; v++) {
        var g = e[v];
        l = Math.min(l, g.resolution), h = Math.min(h, g.multisample), d = this.useMaxPadding ? Math.max(d, g.padding) : d + g.padding, f = f && g.autoFit, p = p || ((n = g.legacy) !== null && n !== void 0 ? n : !0);
      }
      a.length === 1 && (this.defaultFilterStack[0].renderTexture = u.current), a.push(o), o.resolution = l, o.multisample = h, o.legacy = p, o.target = t, o.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), o.sourceFrame.pad(d);
      var m = this.tempRect.copyFrom(u.sourceFrame);
      s.projection.transform && this.transformAABB(D0.copyFrom(s.projection.transform).invert(), m), f ? (o.sourceFrame.fit(m), (o.sourceFrame.width <= 0 || o.sourceFrame.height <= 0) && (o.sourceFrame.width = 0, o.sourceFrame.height = 0)) : o.sourceFrame.intersects(m) || (o.sourceFrame.width = 0, o.sourceFrame.height = 0), this.roundFrame(o.sourceFrame, u.current ? u.current.resolution : s.resolution, u.sourceFrame, u.destinationFrame, s.projection.transform), o.renderTexture = this.getOptimalFilterTexture(o.sourceFrame.width, o.sourceFrame.height, l, h), o.filters = e, o.destinationFrame.width = o.renderTexture.width, o.destinationFrame.height = o.renderTexture.height;
      var y = this.tempRect;
      y.x = 0, y.y = 0, y.width = o.sourceFrame.width, y.height = o.sourceFrame.height, o.renderTexture.filterFrame = o.sourceFrame, o.bindingSourceFrame.copyFrom(u.sourceFrame), o.bindingDestinationFrame.copyFrom(u.destinationFrame), o.transform = s.projection.transform, s.projection.transform = null, u.bind(o.renderTexture, o.sourceFrame, y), s.framebuffer.clear(0, 0, 0, 0);
    }, i.prototype.pop = function() {
      var t = this.defaultFilterStack, e = t.pop(), r = e.filters;
      this.activeState = e;
      var n = this.globalUniforms.uniforms;
      n.outputFrame = e.sourceFrame, n.resolution = e.resolution;
      var s = n.inputSize, a = n.inputPixel, o = n.inputClamp;
      if (s[0] = e.destinationFrame.width, s[1] = e.destinationFrame.height, s[2] = 1 / s[0], s[3] = 1 / s[1], a[0] = Math.round(s[0] * e.resolution), a[1] = Math.round(s[1] * e.resolution), a[2] = 1 / a[0], a[3] = 1 / a[1], o[0] = 0.5 * a[2], o[1] = 0.5 * a[3], o[2] = e.sourceFrame.width * s[2] - 0.5 * a[2], o[3] = e.sourceFrame.height * s[3] - 0.5 * a[3], e.legacy) {
        var u = n.filterArea;
        u[0] = e.destinationFrame.width, u[1] = e.destinationFrame.height, u[2] = e.sourceFrame.x, u[3] = e.sourceFrame.y, n.filterClamp = n.inputClamp;
      }
      this.globalUniforms.update();
      var l = t[t.length - 1];
      if (this.renderer.framebuffer.blit(), r.length === 1)
        r[0].apply(this, e.renderTexture, l.renderTexture, Wi.BLEND, e), this.returnFilterTexture(e.renderTexture);
      else {
        var h = e.renderTexture, d = this.getOptimalFilterTexture(h.width, h.height, e.resolution);
        d.filterFrame = h.filterFrame;
        var f = 0;
        for (f = 0; f < r.length - 1; ++f) {
          f === 1 && e.multisample > 1 && (d = this.getOptimalFilterTexture(h.width, h.height, e.resolution), d.filterFrame = h.filterFrame), r[f].apply(this, h, d, Wi.CLEAR, e);
          var p = h;
          h = d, d = p;
        }
        r[f].apply(this, h, l.renderTexture, Wi.BLEND, e), f > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture(h), this.returnFilterTexture(d);
      }
      e.clear(), this.statePool.push(e);
    }, i.prototype.bindAndClear = function(t, e) {
      e === void 0 && (e = Wi.CLEAR);
      var r = this.renderer, n = r.renderTexture, s = r.state;
      if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) {
        var a = this.tempRect;
        a.x = 0, a.y = 0, a.width = t.filterFrame.width, a.height = t.filterFrame.height, n.bind(t, t.filterFrame, a);
      } else
        t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? n.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
      var o = s.stateId & 1 || this.forceClear;
      (e === Wi.CLEAR || e === Wi.BLIT && o) && this.renderer.framebuffer.clear(0, 0, 0, 0);
    }, i.prototype.applyFilter = function(t, e, r, n) {
      var s = this.renderer;
      s.state.set(t.state), this.bindAndClear(r, n), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, s.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), s.geometry.bind(this.quadUv), s.geometry.draw(qi.TRIANGLES)) : (s.geometry.bind(this.quad), s.geometry.draw(qi.TRIANGLE_STRIP));
    }, i.prototype.calculateSpriteMatrix = function(t, e) {
      var r = this.activeState, n = r.sourceFrame, s = r.destinationFrame, a = e._texture.orig, o = t.set(s.width, 0, 0, s.height, n.x, n.y), u = e.worldTransform.copyTo(ar.TEMP_MATRIX);
      return u.invert(), o.prepend(u), o.scale(1 / a.width, 1 / a.height), o.translate(e.anchor.x, e.anchor.y), o;
    }, i.prototype.destroy = function() {
      this.renderer = null, this.texturePool.clear(!1);
    }, i.prototype.getOptimalFilterTexture = function(t, e, r, n) {
      return r === void 0 && (r = 1), n === void 0 && (n = ke.NONE), this.texturePool.getOptimalTexture(t, e, r, n);
    }, i.prototype.getFilterTexture = function(t, e, r) {
      if (typeof t == "number") {
        var n = t;
        t = e, e = n;
      }
      t = t || this.activeState.renderTexture;
      var s = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, r || ke.NONE);
      return s.filterFrame = t.filterFrame, s;
    }, i.prototype.returnFilterTexture = function(t) {
      this.texturePool.returnTexture(t);
    }, i.prototype.emptyPool = function() {
      this.texturePool.clear(!0);
    }, i.prototype.resize = function() {
      this.texturePool.setScreenSize(this.renderer.view);
    }, i.prototype.transformAABB = function(t, e) {
      var r = zd[0], n = zd[1], s = zd[2], a = zd[3];
      r.set(e.left, e.top), n.set(e.left, e.bottom), s.set(e.right, e.top), a.set(e.right, e.bottom), t.apply(r, r), t.apply(n, n), t.apply(s, s), t.apply(a, a);
      var o = Math.min(r.x, n.x, s.x, a.x), u = Math.min(r.y, n.y, s.y, a.y), l = Math.max(r.x, n.x, s.x, a.x), h = Math.max(r.y, n.y, s.y, a.y);
      e.x = o, e.y = u, e.width = l - o, e.height = h - u;
    }, i.prototype.roundFrame = function(t, e, r, n, s) {
      if (!(t.width <= 0 || t.height <= 0 || r.width <= 0 || r.height <= 0)) {
        if (s) {
          var a = s.a, o = s.b, u = s.c, l = s.d;
          if ((Math.abs(o) > 1e-4 || Math.abs(u) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(l) > 1e-4))
            return;
        }
        s = s ? D0.copyFrom(s) : D0.identity(), s.translate(-r.x, -r.y).scale(n.width / r.width, n.height / r.height).translate(n.x, n.y), this.transformAABB(s, t), t.ceil(e), this.transformAABB(s.invert(), t);
      }
    }, i;
  }()
), bd = (
  /** @class */
  function() {
    function i(t) {
      this.renderer = t;
    }
    return i.prototype.flush = function() {
    }, i.prototype.destroy = function() {
      this.renderer = null;
    }, i.prototype.start = function() {
    }, i.prototype.stop = function() {
      this.flush();
    }, i.prototype.render = function(t) {
    }, i;
  }()
), Ab = (
  /** @class */
  function() {
    function i(t) {
      this.renderer = t, this.emptyRenderer = new bd(t), this.currentRenderer = this.emptyRenderer;
    }
    return i.prototype.setObjectRenderer = function(t) {
      this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start());
    }, i.prototype.flush = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, i.prototype.reset = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, i.prototype.copyBoundTextures = function(t, e) {
      for (var r = this.renderer.texture.boundTextures, n = e - 1; n >= 0; --n)
        t[n] = r[n] || null, t[n] && (t[n]._batchLocation = n);
    }, i.prototype.boundArray = function(t, e, r, n) {
      for (var s = t.elements, a = t.ids, o = t.count, u = 0, l = 0; l < o; l++) {
        var h = s[l], d = h._batchLocation;
        if (d >= 0 && d < n && e[d] === h) {
          a[l] = d;
          continue;
        }
        for (; u < n; ) {
          var f = e[u];
          if (f && f._batchEnabled === r && f._batchLocation === u) {
            u++;
            continue;
          }
          a[l] = u, h._batchLocation = u, e[u] = h;
          break;
        }
      }
    }, i.prototype.destroy = function() {
      this.renderer = null;
    }, i;
  }()
), E1 = 0, Lb = (
  /** @class */
  function() {
    function i(t) {
      this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {
        uint32Indices: !1
      }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener("webglcontextlost", this.handleContextLost, !1), t.view.addEventListener("webglcontextrestored", this.handleContextRestored, !1);
    }
    return Object.defineProperty(i.prototype, "isLost", {
      /**
       * `true` if the context is lost
       * @readonly
       */
      get: function() {
        return !this.gl || this.gl.isContextLost();
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.contextChange = function(t) {
      this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = E1++;
    }, i.prototype.initFromContext = function(t) {
      this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = E1++, this.renderer.runners.contextChange.emit(t);
    }, i.prototype.initFromOptions = function(t) {
      var e = this.createContext(this.renderer.view, t);
      this.initFromContext(e);
    }, i.prototype.createContext = function(t, e) {
      var r;
      if (gt.PREFER_ENV >= Ts.WEBGL2 && (r = t.getContext("webgl2", e)), r)
        this.webGLVersion = 2;
      else if (this.webGLVersion = 1, r = t.getContext("webgl", e) || t.getContext("experimental-webgl", e), !r)
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      return this.gl = r, this.getExtensions(), this.gl;
    }, i.prototype.getExtensions = function() {
      var t = this.gl, e = {
        loseContext: t.getExtension("WEBGL_lose_context"),
        anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
        floatTextureLinear: t.getExtension("OES_texture_float_linear"),
        s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: t.getExtension("WEBGL_compressed_texture_etc"),
        etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: t.getExtension("WEBGL_compressed_texture_atc"),
        astc: t.getExtension("WEBGL_compressed_texture_astc")
      };
      this.webGLVersion === 1 ? Object.assign(this.extensions, e, {
        drawBuffers: t.getExtension("WEBGL_draw_buffers"),
        depthTexture: t.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: t.getExtension("OES_element_index_uint"),
        // Floats and half-floats
        floatTexture: t.getExtension("OES_texture_float"),
        floatTextureLinear: t.getExtension("OES_texture_float_linear"),
        textureHalfFloat: t.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
      }) : this.webGLVersion === 2 && Object.assign(this.extensions, e, {
        // Floats and half-floats
        colorBufferFloat: t.getExtension("EXT_color_buffer_float")
      });
    }, i.prototype.handleContextLost = function(t) {
      var e = this;
      t.preventDefault(), setTimeout(function() {
        e.gl.isContextLost() && e.extensions.loseContext && e.extensions.loseContext.restoreContext();
      }, 0);
    }, i.prototype.handleContextRestored = function() {
      this.renderer.runners.contextChange.emit(this.gl);
    }, i.prototype.destroy = function() {
      var t = this.renderer.view;
      this.renderer = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
    }, i.prototype.postrender = function() {
      this.renderer.renderingToScreen && this.gl.flush();
    }, i.prototype.validateContext = function(t) {
      var e = t.getContextAttributes(), r = "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext;
      r && (this.webGLVersion = 2), e && !e.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      var n = r || !!t.getExtension("OES_element_index_uint");
      this.supports.uint32Indices = n, n || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }, i;
  }()
), YE = (
  /** @class */
  function() {
    function i(t) {
      this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = ke.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
    }
    return i;
  }()
), t2 = new Nt(), Bb = (
  /** @class */
  function() {
    function i(t) {
      this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new vv(10, 10), this.msaaSamples = null;
    }
    return i.prototype.contextChange = function() {
      this.disposeAll(!0);
      var t = this.gl = this.renderer.gl;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Nt(), this.hasMRT = !0, this.writeDepthTexture = !0, this.renderer.context.webGLVersion === 1) {
        var e = this.renderer.context.extensions.drawBuffers, r = this.renderer.context.extensions.depthTexture;
        gt.PREFER_ENV === Ts.WEBGL_LEGACY && (e = null, r = null), e ? t.drawBuffers = function(n) {
          return e.drawBuffersWEBGL(n);
        } : (this.hasMRT = !1, t.drawBuffers = function() {
        }), r || (this.writeDepthTexture = !1);
      } else
        this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES);
    }, i.prototype.bind = function(t, e, r) {
      r === void 0 && (r = 0);
      var n = this.gl;
      if (t) {
        var s = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
        this.current !== t && (this.current = t, n.bindFramebuffer(n.FRAMEBUFFER, s.framebuffer)), s.mipLevel !== r && (t.dirtyId++, t.dirtyFormat++, s.mipLevel = r), s.dirtyId !== t.dirtyId && (s.dirtyId = t.dirtyId, s.dirtyFormat !== t.dirtyFormat ? (s.dirtyFormat = t.dirtyFormat, s.dirtySize = t.dirtySize, this.updateFramebuffer(t, r)) : s.dirtySize !== t.dirtySize && (s.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));
        for (var a = 0; a < t.colorTextures.length; a++) {
          var o = t.colorTextures[a];
          this.renderer.texture.unbind(o.parentTextureArray || o);
        }
        if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {
          var u = e.width >> r, l = e.height >> r, h = u / e.width;
          this.setViewport(e.x * h, e.y * h, u, l);
        } else {
          var u = t.width >> r, l = t.height >> r;
          this.setViewport(0, 0, u, l);
        }
      } else
        this.current && (this.current = null, n.bindFramebuffer(n.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
    }, i.prototype.setViewport = function(t, e, r, n) {
      var s = this.viewport;
      t = Math.round(t), e = Math.round(e), r = Math.round(r), n = Math.round(n), (s.width !== r || s.height !== n || s.x !== t || s.y !== e) && (s.x = t, s.y = e, s.width = r, s.height = n, this.gl.viewport(t, e, r, n));
    }, Object.defineProperty(i.prototype, "size", {
      /**
       * Get the size of the current width and height. Returns object with `width` and `height` values.
       * @readonly
       */
      get: function() {
        return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.clear = function(t, e, r, n, s) {
      s === void 0 && (s = uv.COLOR | uv.DEPTH);
      var a = this.gl;
      a.clearColor(t, e, r, n), a.clear(s);
    }, i.prototype.initFramebuffer = function(t) {
      var e = this.gl, r = new YE(e.createFramebuffer());
      return r.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = r, this.managedFramebuffers.push(t), t.disposeRunner.add(this), r;
    }, i.prototype.resizeFramebuffer = function(t) {
      var e = this.gl, r = t.glFramebuffers[this.CONTEXT_UID];
      r.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, r.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.RGBA8, t.width, t.height)), r.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, r.stencil), r.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));
      var n = t.colorTextures, s = n.length;
      e.drawBuffers || (s = Math.min(s, 1));
      for (var a = 0; a < s; a++) {
        var o = n[a], u = o.parentTextureArray || o;
        this.renderer.texture.bind(u, 0);
      }
      t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0);
    }, i.prototype.updateFramebuffer = function(t, e) {
      var r = this.gl, n = t.glFramebuffers[this.CONTEXT_UID], s = t.colorTextures, a = s.length;
      r.drawBuffers || (a = Math.min(a, 1)), n.multisample > 1 && this.canMultisampleFramebuffer(t) ? (n.msaaBuffer = n.msaaBuffer || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, n.msaaBuffer), r.renderbufferStorageMultisample(r.RENDERBUFFER, n.multisample, r.RGBA8, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, n.msaaBuffer)) : n.msaaBuffer && (r.deleteRenderbuffer(n.msaaBuffer), n.msaaBuffer = null, n.blitFramebuffer && (n.blitFramebuffer.dispose(), n.blitFramebuffer = null));
      for (var o = [], u = 0; u < a; u++) {
        var l = s[u], h = l.parentTextureArray || l;
        this.renderer.texture.bind(h, 0), !(u === 0 && n.msaaBuffer) && (r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + u, l.target, h._glTextures[this.CONTEXT_UID].texture, e), o.push(r.COLOR_ATTACHMENT0 + u));
      }
      if (o.length > 1 && r.drawBuffers(o), t.depthTexture) {
        var d = this.writeDepthTexture;
        if (d) {
          var f = t.depthTexture;
          this.renderer.texture.bind(f, 0), r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, f._glTextures[this.CONTEXT_UID].texture, e);
        }
      }
      (t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (n.stencil = n.stencil || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, n.stencil), n.msaaBuffer ? r.renderbufferStorageMultisample(r.RENDERBUFFER, n.multisample, r.DEPTH24_STENCIL8, t.width, t.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, n.stencil)) : n.stencil && (r.deleteRenderbuffer(n.stencil), n.stencil = null);
    }, i.prototype.canMultisampleFramebuffer = function(t) {
      return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture;
    }, i.prototype.detectSamples = function(t) {
      var e = this.msaaSamples, r = ke.NONE;
      if (t <= 1 || e === null)
        return r;
      for (var n = 0; n < e.length; n++)
        if (e[n] <= t) {
          r = e[n];
          break;
        }
      return r === 1 && (r = ke.NONE), r;
    }, i.prototype.blit = function(t, e, r) {
      var n = this, s = n.current, a = n.renderer, o = n.gl, u = n.CONTEXT_UID;
      if (a.context.webGLVersion === 2 && s) {
        var l = s.glFramebuffers[u];
        if (l) {
          if (!t) {
            if (!l.msaaBuffer)
              return;
            var h = s.colorTextures[0];
            if (!h)
              return;
            l.blitFramebuffer || (l.blitFramebuffer = new vv(s.width, s.height), l.blitFramebuffer.addColorTexture(0, h)), t = l.blitFramebuffer, t.colorTextures[0] !== h && (t.colorTextures[0] = h, t.dirtyId++, t.dirtyFormat++), (t.width !== s.width || t.height !== s.height) && (t.width = s.width, t.height = s.height, t.dirtyId++, t.dirtySize++);
          }
          e || (e = t2, e.width = s.width, e.height = s.height), r || (r = e);
          var d = e.width === r.width && e.height === r.height;
          this.bind(t), o.bindFramebuffer(o.READ_FRAMEBUFFER, l.framebuffer), o.blitFramebuffer(e.left, e.top, e.right, e.bottom, r.left, r.top, r.right, r.bottom, o.COLOR_BUFFER_BIT, d ? o.NEAREST : o.LINEAR);
        }
      }
    }, i.prototype.disposeFramebuffer = function(t, e) {
      var r = t.glFramebuffers[this.CONTEXT_UID], n = this.gl;
      if (r) {
        delete t.glFramebuffers[this.CONTEXT_UID];
        var s = this.managedFramebuffers.indexOf(t);
        s >= 0 && this.managedFramebuffers.splice(s, 1), t.disposeRunner.remove(this), e || (n.deleteFramebuffer(r.framebuffer), r.msaaBuffer && n.deleteRenderbuffer(r.msaaBuffer), r.stencil && n.deleteRenderbuffer(r.stencil)), r.blitFramebuffer && r.blitFramebuffer.dispose();
      }
    }, i.prototype.disposeAll = function(t) {
      var e = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (var r = 0; r < e.length; r++)
        this.disposeFramebuffer(e[r], t);
    }, i.prototype.forceStencil = function() {
      var t = this.current;
      if (t) {
        var e = t.glFramebuffers[this.CONTEXT_UID];
        if (!(!e || e.stencil)) {
          t.stencil = !0;
          var r = t.width, n = t.height, s = this.gl, a = s.createRenderbuffer();
          s.bindRenderbuffer(s.RENDERBUFFER, a), e.msaaBuffer ? s.renderbufferStorageMultisample(s.RENDERBUFFER, e.multisample, s.DEPTH24_STENCIL8, r, n) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, r, n), e.stencil = a, s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, a);
        }
      }
    }, i.prototype.reset = function() {
      this.current = this.unknownFramebuffer, this.viewport = new Nt();
    }, i.prototype.destroy = function() {
      this.renderer = null;
    }, i;
  }()
), k0 = { 5126: 4, 5123: 2, 5121: 1 }, Fb = (
  /** @class */
  function() {
    function i(t) {
      this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};
    }
    return i.prototype.contextChange = function() {
      this.disposeAll(!0);
      var t = this.gl = this.renderer.gl, e = this.renderer.context;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e.webGLVersion !== 2) {
        var r = this.renderer.context.extensions.vertexArrayObject;
        gt.PREFER_ENV === Ts.WEBGL_LEGACY && (r = null), r ? (t.createVertexArray = function() {
          return r.createVertexArrayOES();
        }, t.bindVertexArray = function(s) {
          return r.bindVertexArrayOES(s);
        }, t.deleteVertexArray = function(s) {
          return r.deleteVertexArrayOES(s);
        }) : (this.hasVao = !1, t.createVertexArray = function() {
          return null;
        }, t.bindVertexArray = function() {
          return null;
        }, t.deleteVertexArray = function() {
          return null;
        });
      }
      if (e.webGLVersion !== 2) {
        var n = t.getExtension("ANGLE_instanced_arrays");
        n ? (t.vertexAttribDivisor = function(s, a) {
          return n.vertexAttribDivisorANGLE(s, a);
        }, t.drawElementsInstanced = function(s, a, o, u, l) {
          return n.drawElementsInstancedANGLE(s, a, o, u, l);
        }, t.drawArraysInstanced = function(s, a, o, u) {
          return n.drawArraysInstancedANGLE(s, a, o, u);
        }) : this.hasInstance = !1;
      }
      this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex;
    }, i.prototype.bind = function(t, e) {
      e = e || this.renderer.shader.shader;
      var r = this.gl, n = t.glVertexArrayObjects[this.CONTEXT_UID], s = !1;
      n || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = n = {}, s = !0);
      var a = n[e.program.id] || this.initGeometryVao(t, e, s);
      this._activeGeometry = t, this._activeVao !== a && (this._activeVao = a, this.hasVao ? r.bindVertexArray(a) : this.activateVao(t, e.program)), this.updateBuffers();
    }, i.prototype.reset = function() {
      this.unbind();
    }, i.prototype.updateBuffers = function() {
      for (var t = this._activeGeometry, e = this.renderer.buffer, r = 0; r < t.buffers.length; r++) {
        var n = t.buffers[r];
        e.update(n);
      }
    }, i.prototype.checkCompatibility = function(t, e) {
      var r = t.attributes, n = e.attributeData;
      for (var s in n)
        if (!r[s])
          throw new Error('shader and geometry incompatible, geometry missing the "' + s + '" attribute');
    }, i.prototype.getSignature = function(t, e) {
      var r = t.attributes, n = e.attributeData, s = ["g", t.id];
      for (var a in r)
        n[a] && s.push(a, n[a].location);
      return s.join("-");
    }, i.prototype.initGeometryVao = function(t, e, r) {
      r === void 0 && (r = !0);
      var n = this.gl, s = this.CONTEXT_UID, a = this.renderer.buffer, o = e.program;
      o.glPrograms[s] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, o);
      var u = this.getSignature(t, o), l = t.glVertexArrayObjects[this.CONTEXT_UID], h = l[u];
      if (h)
        return l[o.id] = h, h;
      var d = t.buffers, f = t.attributes, p = {}, v = {};
      for (var g in d)
        p[g] = 0, v[g] = 0;
      for (var g in f)
        !f[g].size && o.attributeData[g] ? f[g].size = o.attributeData[g].size : f[g].size || console.warn("PIXI Geometry attribute '" + g + "' size cannot be determined (likely the bound shader does not have the attribute)"), p[f[g].buffer] += f[g].size * k0[f[g].type];
      for (var g in f) {
        var m = f[g], y = m.size;
        m.stride === void 0 && (p[m.buffer] === y * k0[m.type] ? m.stride = 0 : m.stride = p[m.buffer]), m.start === void 0 && (m.start = v[m.buffer], v[m.buffer] += y * k0[m.type]);
      }
      h = n.createVertexArray(), n.bindVertexArray(h);
      for (var _ = 0; _ < d.length; _++) {
        var b = d[_];
        a.bind(b), r && b._glBuffers[s].refCount++;
      }
      return this.activateVao(t, o), this._activeVao = h, l[o.id] = h, l[u] = h, h;
    }, i.prototype.disposeGeometry = function(t, e) {
      var r;
      if (this.managedGeometries[t.id]) {
        delete this.managedGeometries[t.id];
        var n = t.glVertexArrayObjects[this.CONTEXT_UID], s = this.gl, a = t.buffers, o = (r = this.renderer) === null || r === void 0 ? void 0 : r.buffer;
        if (t.disposeRunner.remove(this), !!n) {
          if (o)
            for (var u = 0; u < a.length; u++) {
              var l = a[u]._glBuffers[this.CONTEXT_UID];
              l && (l.refCount--, l.refCount === 0 && !e && o.dispose(a[u], e));
            }
          if (!e) {
            for (var h in n)
              if (h[0] === "g") {
                var d = n[h];
                this._activeVao === d && this.unbind(), s.deleteVertexArray(d);
              }
          }
          delete t.glVertexArrayObjects[this.CONTEXT_UID];
        }
      }
    }, i.prototype.disposeAll = function(t) {
      for (var e = Object.keys(this.managedGeometries), r = 0; r < e.length; r++)
        this.disposeGeometry(this.managedGeometries[e[r]], t);
    }, i.prototype.activateVao = function(t, e) {
      var r = this.gl, n = this.CONTEXT_UID, s = this.renderer.buffer, a = t.buffers, o = t.attributes;
      t.indexBuffer && s.bind(t.indexBuffer);
      var u = null;
      for (var l in o) {
        var h = o[l], d = a[h.buffer], f = d._glBuffers[n];
        if (e.attributeData[l]) {
          u !== f && (s.bind(d), u = f);
          var p = e.attributeData[l].location;
          if (r.enableVertexAttribArray(p), r.vertexAttribPointer(p, h.size, h.type || r.FLOAT, h.normalized, h.stride, h.start), h.instance)
            if (this.hasInstance)
              r.vertexAttribDivisor(p, 1);
            else
              throw new Error("geometry error, GPU Instancing is not supported on this device");
        }
      }
    }, i.prototype.draw = function(t, e, r, n) {
      var s = this.gl, a = this._activeGeometry;
      if (a.indexBuffer) {
        var o = a.indexBuffer.data.BYTES_PER_ELEMENT, u = o === 2 ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
        o === 2 || o === 4 && this.canUseUInt32ElementIndex ? a.instanced ? s.drawElementsInstanced(t, e || a.indexBuffer.data.length, u, (r || 0) * o, n || 1) : s.drawElements(t, e || a.indexBuffer.data.length, u, (r || 0) * o) : console.warn("unsupported index buffer type: uint32");
      } else
        a.instanced ? s.drawArraysInstanced(t, r, e || a.getSize(), n || 1) : s.drawArrays(t, r, e || a.getSize());
      return this;
    }, i.prototype.unbind = function() {
      this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
    }, i.prototype.destroy = function() {
      this.renderer = null;
    }, i;
  }()
), qE = (
  /** @class */
  function() {
    function i(t) {
      t === void 0 && (t = null), this.type = Ze.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = gt.FILTER_MULTISAMPLE, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;
    }
    return Object.defineProperty(i.prototype, "filter", {
      /**
       * The sprite mask filter.
       * If set to `null`, the default sprite mask filter is used.
       * @default null
       */
      get: function() {
        return this._filters ? this._filters[0] : null;
      },
      set: function(t) {
        t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null;
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.reset = function() {
      this.pooled && (this.maskObject = null, this.type = Ze.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;
    }, i.prototype.copyCountersOrReset = function(t) {
      t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
    }, i;
  }()
);
function S1(i, t, e) {
  var r = i.createShader(t);
  return i.shaderSource(r, e), i.compileShader(r), r;
}
function T1(i, t) {
  var e = i.getShaderSource(t).split(`
`).map(function(l, h) {
    return h + ": " + l;
  }), r = i.getShaderInfoLog(t), n = r.split(`
`), s = {}, a = n.map(function(l) {
    return parseFloat(l.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
  }).filter(function(l) {
    return l && !s[l] ? (s[l] = !0, !0) : !1;
  }), o = [""];
  a.forEach(function(l) {
    e[l - 1] = "%c" + e[l - 1] + "%c", o.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  var u = e.join(`
`);
  o[0] = u, console.error(r), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, o), console.groupEnd();
}
function e2(i, t, e, r) {
  i.getProgramParameter(t, i.LINK_STATUS) || (i.getShaderParameter(e, i.COMPILE_STATUS) || T1(i, e), i.getShaderParameter(r, i.COMPILE_STATUS) || T1(i, r), console.error("PixiJS Error: Could not initialize shader."), i.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", i.getProgramInfoLog(t)));
}
function N0(i) {
  for (var t = new Array(i), e = 0; e < t.length; e++)
    t[e] = !1;
  return t;
}
function ZE(i, t) {
  switch (i) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * t);
    case "vec3":
      return new Float32Array(3 * t);
    case "vec4":
      return new Float32Array(4 * t);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * t);
    case "ivec3":
      return new Int32Array(3 * t);
    case "ivec4":
      return new Int32Array(4 * t);
    case "uvec2":
      return new Uint32Array(2 * t);
    case "uvec3":
      return new Uint32Array(3 * t);
    case "uvec4":
      return new Uint32Array(4 * t);
    case "bool":
      return !1;
    case "bvec2":
      return N0(2 * t);
    case "bvec3":
      return N0(3 * t);
    case "bvec4":
      return N0(4 * t);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var KE = {}, mh = KE;
function JE() {
  if (mh === KE || mh && mh.isContextLost()) {
    var i = gt.ADAPTER.createCanvas(), t = void 0;
    gt.PREFER_ENV >= Ts.WEBGL2 && (t = i.getContext("webgl2", {})), t || (t = i.getContext("webgl", {}) || i.getContext("experimental-webgl", {}), t ? t.getExtension("WEBGL_draw_buffers") : t = null), mh = t;
  }
  return mh;
}
var Hd;
function r2() {
  if (!Hd) {
    Hd = ni.MEDIUM;
    var i = JE();
    if (i && i.getShaderPrecisionFormat) {
      var t = i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT);
      Hd = t.precision ? ni.HIGH : ni.MEDIUM;
    }
  }
  return Hd;
}
function C1(i, t, e) {
  if (i.substring(0, 9) !== "precision") {
    var r = t;
    return t === ni.HIGH && e !== ni.HIGH && (r = ni.MEDIUM), "precision " + r + ` float;
` + i;
  } else if (e !== ni.HIGH && i.substring(0, 15) === "precision highp")
    return i.replace("precision highp", "precision mediump");
  return i;
}
var i2 = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function QE(i) {
  return i2[i];
}
var $d = null, M1 = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function tS(i, t) {
  if (!$d) {
    var e = Object.keys(M1);
    $d = {};
    for (var r = 0; r < e.length; ++r) {
      var n = e[r];
      $d[i[n]] = M1[n];
    }
  }
  return $d[t];
}
var Wo = [
  // a float cache layer
  {
    test: function(i) {
      return i.type === "float" && i.size === 1 && !i.isArray;
    },
    code: function(i) {
      return `
            if(uv["` + i + '"] !== ud["' + i + `"].value)
            {
                ud["` + i + '"].value = uv["' + i + `"]
                gl.uniform1f(ud["` + i + '"].location, uv["' + i + `"])
            }
            `;
    }
  },
  // handling samplers
  {
    test: function(i, t) {
      return (i.type === "sampler2D" || i.type === "samplerCube" || i.type === "sampler2DArray") && i.size === 1 && !i.isArray && (t == null || t.castToBaseTexture !== void 0);
    },
    code: function(i) {
      return `t = syncData.textureCount++;

            renderer.texture.bind(uv["` + i + `"], t);

            if(ud["` + i + `"].value !== t)
            {
                ud["` + i + `"].value = t;
                gl.uniform1i(ud["` + i + `"].location, t);
; // eslint-disable-line max-len
            }`;
    }
  },
  // uploading pixi matrix object to mat3
  {
    test: function(i, t) {
      return i.type === "mat3" && i.size === 1 && !i.isArray && t.a !== void 0;
    },
    code: function(i) {
      return `
            gl.uniformMatrix3fv(ud["` + i + '"].location, false, uv["' + i + `"].toArray(true));
            `;
    },
    codeUbo: function(i) {
      return `
                var ` + i + "_matrix = uv." + i + `.toArray(true);

                data[offset] = ` + i + `_matrix[0];
                data[offset+1] = ` + i + `_matrix[1];
                data[offset+2] = ` + i + `_matrix[2];
        
                data[offset + 4] = ` + i + `_matrix[3];
                data[offset + 5] = ` + i + `_matrix[4];
                data[offset + 6] = ` + i + `_matrix[5];
        
                data[offset + 8] = ` + i + `_matrix[6];
                data[offset + 9] = ` + i + `_matrix[7];
                data[offset + 10] = ` + i + `_matrix[8];
            `;
    }
  },
  // uploading a pixi point as a vec2 with caching layer
  {
    test: function(i, t) {
      return i.type === "vec2" && i.size === 1 && !i.isArray && t.x !== void 0;
    },
    code: function(i) {
      return `
                cv = ud["` + i + `"].value;
                v = uv["` + i + `"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["` + i + `"].location, v.x, v.y);
                }`;
    },
    codeUbo: function(i) {
      return `
                v = uv.` + i + `;

                data[offset] = v.x;
                data[offset+1] = v.y;
            `;
    }
  },
  // caching layer for a vec2
  {
    test: function(i) {
      return i.type === "vec2" && i.size === 1 && !i.isArray;
    },
    code: function(i) {
      return `
                cv = ud["` + i + `"].value;
                v = uv["` + i + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["` + i + `"].location, v[0], v[1]);
                }
            `;
    }
  },
  // upload a pixi rectangle as a vec4 with caching layer
  {
    test: function(i, t) {
      return i.type === "vec4" && i.size === 1 && !i.isArray && t.width !== void 0;
    },
    code: function(i) {
      return `
                cv = ud["` + i + `"].value;
                v = uv["` + i + `"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["` + i + `"].location, v.x, v.y, v.width, v.height)
                }`;
    },
    codeUbo: function(i) {
      return `
                    v = uv.` + i + `;

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `;
    }
  },
  // a caching layer for vec4 uploading
  {
    test: function(i) {
      return i.type === "vec4" && i.size === 1 && !i.isArray;
    },
    code: function(i) {
      return `
                cv = ud["` + i + `"].value;
                v = uv["` + i + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["` + i + `"].location, v[0], v[1], v[2], v[3])
                }`;
    }
  }
], n2 = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
}, s2 = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function a2(i, t) {
  var e, r = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (var n in i.uniforms) {
    var s = t[n];
    if (!s) {
      !((e = i.uniforms[n]) === null || e === void 0) && e.group && (i.uniforms[n].ubo ? r.push(`
                        renderer.shader.syncUniformBufferGroup(uv.` + n + ", '" + n + `');
                    `) : r.push(`
                        renderer.shader.syncUniformGroup(uv.` + n + `, syncData);
                    `));
      continue;
    }
    for (var a = i.uniforms[n], o = !1, u = 0; u < Wo.length; u++)
      if (Wo[u].test(s, a)) {
        r.push(Wo[u].code(n, a)), o = !0;
        break;
      }
    if (!o) {
      var l = s.size === 1 && !s.isArray ? n2 : s2, h = l[s.type].replace("location", 'ud["' + n + '"].location');
      r.push(`
            cu = ud["` + n + `"];
            cv = cu.value;
            v = uv["` + n + `"];
            ` + h + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", r.join(`
`));
}
var o2 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function u2(i) {
  for (var t = "", e = 0; e < i; ++e)
    e > 0 && (t += `
else `), e < i - 1 && (t += "if(test == " + e + ".0){}");
  return t;
}
function eS(i, t) {
  if (i === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  for (var e = t.createShader(t.FRAGMENT_SHADER); ; ) {
    var r = o2.replace(/%forloop%/gi, u2(i));
    if (t.shaderSource(e, r), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))
      i = i / 2 | 0;
    else
      break;
  }
  return i;
}
var yh;
function l2() {
  if (typeof yh == "boolean")
    return yh;
  try {
    var i = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    yh = i({ a: "b" }, "a", "b") === !0;
  } catch {
    yh = !1;
  }
  return yh;
}
var h2 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`, c2 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`, f2 = 0, Vd = {}, lh = (
  /** @class */
  function() {
    function i(t, e, r) {
      r === void 0 && (r = "pixi-shader"), this.id = f2++, this.vertexSrc = t || i.defaultVertexSrc, this.fragmentSrc = e || i.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== "#version" && (r = r.replace(/\s+/g, "-"), Vd[r] ? (Vd[r]++, r += "-" + Vd[r]) : Vd[r] = 1, this.vertexSrc = "#define SHADER_NAME " + r + `
` + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + r + `
` + this.fragmentSrc, this.vertexSrc = C1(this.vertexSrc, gt.PRECISION_VERTEX, ni.HIGH), this.fragmentSrc = C1(this.fragmentSrc, gt.PRECISION_FRAGMENT, r2())), this.glPrograms = {}, this.syncUniforms = null;
    }
    return Object.defineProperty(i, "defaultVertexSrc", {
      /**
       * The default vertex shader source.
       * @constant
       */
      get: function() {
        return c2;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i, "defaultFragmentSrc", {
      /**
       * The default fragment shader source.
       * @constant
       */
      get: function() {
        return h2;
      },
      enumerable: !1,
      configurable: !0
    }), i.from = function(t, e, r) {
      var n = t + e, s = y1[n];
      return s || (y1[n] = s = new i(t, e, r)), s;
    }, i;
  }()
), xs = (
  /** @class */
  function() {
    function i(t, e) {
      this.uniformBindCount = 0, this.program = t, e ? e instanceof la ? this.uniformGroup = e : this.uniformGroup = new la(e) : this.uniformGroup = new la({}), this.disposeRunner = new pr("disposeShader");
    }
    return i.prototype.checkUniformExists = function(t, e) {
      if (e.uniforms[t])
        return !0;
      for (var r in e.uniforms) {
        var n = e.uniforms[r];
        if (n.group && this.checkUniformExists(t, n))
          return !0;
      }
      return !1;
    }, i.prototype.destroy = function() {
      this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();
    }, Object.defineProperty(i.prototype, "uniforms", {
      /**
       * Shader uniform values, shortcut for `uniformGroup.uniforms`.
       * @readonly
       */
      get: function() {
        return this.uniformGroup.uniforms;
      },
      enumerable: !1,
      configurable: !0
    }), i.from = function(t, e, r) {
      var n = lh.from(t, e);
      return new i(n, r);
    }, i;
  }()
), A0 = 0, L0 = 1, B0 = 2, F0 = 3, G0 = 4, U0 = 5, va = (
  /** @class */
  function() {
    function i() {
      this.data = 0, this.blendMode = Et.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;
    }
    return Object.defineProperty(i.prototype, "blend", {
      /**
       * Activates blending of the computed fragment color values.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << A0);
      },
      set: function(t) {
        !!(this.data & 1 << A0) !== t && (this.data ^= 1 << A0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "offsets", {
      /**
       * Activates adding an offset to depth values of polygon's fragments
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << L0);
      },
      set: function(t) {
        !!(this.data & 1 << L0) !== t && (this.data ^= 1 << L0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "culling", {
      /**
       * Activates culling of polygons.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << B0);
      },
      set: function(t) {
        !!(this.data & 1 << B0) !== t && (this.data ^= 1 << B0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "depthTest", {
      /**
       * Activates depth comparisons and updates to the depth buffer.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << F0);
      },
      set: function(t) {
        !!(this.data & 1 << F0) !== t && (this.data ^= 1 << F0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "depthMask", {
      /**
       * Enables or disables writing to the depth buffer.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << U0);
      },
      set: function(t) {
        !!(this.data & 1 << U0) !== t && (this.data ^= 1 << U0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "clockwiseFrontFace", {
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << G0);
      },
      set: function(t) {
        !!(this.data & 1 << G0) !== t && (this.data ^= 1 << G0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "blendMode", {
      /**
       * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this._blendMode;
      },
      set: function(t) {
        this.blend = t !== Et.NONE, this._blendMode = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "polygonOffset", {
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       * @default 0
       */
      get: function() {
        return this._polygonOffset;
      },
      set: function(t) {
        this.offsets = !!t, this._polygonOffset = t;
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.toString = function() {
      return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
    }, i.for2d = function() {
      var t = new i();
      return t.depthTest = !1, t.blend = !0, t;
    }, i;
  }()
), d2 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`, p2 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, rn = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e, r, n) {
      var s = this, a = lh.from(e || t.defaultVertexSrc, r || t.defaultFragmentSrc);
      return s = i.call(this, a, n) || this, s.padding = 0, s.resolution = gt.FILTER_RESOLUTION, s.multisample = gt.FILTER_MULTISAMPLE, s.enabled = !0, s.autoFit = !0, s.state = new va(), s;
    }
    return t.prototype.apply = function(e, r, n, s, a) {
      e.applyFilter(this, r, n, s);
    }, Object.defineProperty(t.prototype, "blendMode", {
      /**
       * Sets the blend mode of the filter.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this.state.blendMode;
      },
      set: function(e) {
        this.state.blendMode = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "resolution", {
      /**
       * The resolution of the filter. Setting this to be lower will lower the quality but
       * increase the performance of the filter.
       */
      get: function() {
        return this._resolution;
      },
      set: function(e) {
        this._resolution = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @constant
       */
      get: function() {
        return p2;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "defaultFragmentSrc", {
      /**
       * The default fragment shader source
       * @constant
       */
      get: function() {
        return d2;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(xs)
), v2 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`, g2 = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`, P1 = new ar(), n0 = (
  /** @class */
  function() {
    function i(t, e) {
      this._texture = t, this.mapCoord = new ar(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof e > "u" ? 0.5 : e, this.isSimple = !1;
    }
    return Object.defineProperty(i.prototype, "texture", {
      /** Texture property. */
      get: function() {
        return this._texture;
      },
      set: function(t) {
        this._texture = t, this._textureID = -1;
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.multiplyUvs = function(t, e) {
      e === void 0 && (e = t);
      for (var r = this.mapCoord, n = 0; n < t.length; n += 2) {
        var s = t[n], a = t[n + 1];
        e[n] = s * r.a + a * r.c + r.tx, e[n + 1] = s * r.b + a * r.d + r.ty;
      }
      return e;
    }, i.prototype.update = function(t) {
      var e = this._texture;
      if (!e || !e.valid || !t && this._textureID === e._updateID)
        return !1;
      this._textureID = e._updateID, this._updateID++;
      var r = e._uvs;
      this.mapCoord.set(r.x1 - r.x0, r.y1 - r.y0, r.x3 - r.x0, r.y3 - r.y0, r.x0, r.y0);
      var n = e.orig, s = e.trim;
      s && (P1.set(n.width / s.width, 0, 0, n.height / s.height, -s.x / s.width, -s.y / s.height), this.mapCoord.append(P1));
      var a = e.baseTexture, o = this.uClampFrame, u = this.clampMargin / a.resolution, l = this.clampOffset;
      return o[0] = (e._frame.x + u + l) / a.width, o[1] = (e._frame.y + u + l) / a.height, o[2] = (e._frame.x + e._frame.width - u + l) / a.width, o[3] = (e._frame.y + e._frame.height - u + l) / a.height, this.uClampOffset[0] = l / a.realWidth, this.uClampOffset[1] = l / a.realHeight, this.isSimple = e._frame.width === a.width && e._frame.height === a.height && e.rotate === 0, !0;
    }, i;
  }()
), rS = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e, r, n) {
      var s = this, a = null;
      return typeof e != "string" && r === void 0 && n === void 0 && (a = e, e = void 0, r = void 0, n = void 0), s = i.call(this, e || v2, r || g2, n) || this, s.maskSprite = a, s.maskMatrix = new ar(), s;
    }
    return Object.defineProperty(t.prototype, "maskSprite", {
      /**
       * Sprite mask
       * @type {PIXI.DisplayObject}
       */
      get: function() {
        return this._maskSprite;
      },
      set: function(e) {
        this._maskSprite = e, this._maskSprite && (this._maskSprite.renderable = !1);
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.apply = function(e, r, n, s) {
      var a = this._maskSprite, o = a._texture;
      o.valid && (o.uvMatrix || (o.uvMatrix = new n0(o, 0)), o.uvMatrix.update(), this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o, this.uniforms.otherMatrix = e.calculateSpriteMatrix(this.maskMatrix, a).prepend(o.uvMatrix.mapCoord), this.uniforms.alpha = a.worldAlpha, this.uniforms.maskClamp = o.uvMatrix.uClampFrame, e.applyFilter(this, r, n, s));
    }, t;
  }(rn)
), Gb = (
  /** @class */
  function() {
    function i(t) {
      this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
    }
    return i.prototype.setMaskStack = function(t) {
      this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t);
    }, i.prototype.push = function(t, e) {
      var r = e;
      if (!r.isMaskData) {
        var n = this.maskDataPool.pop() || new qE();
        n.pooled = !0, n.maskObject = e, r = n;
      }
      var s = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      if (r.copyCountersOrReset(s), r._colorMask = s ? s._colorMask : 15, r.autoDetect && this.detect(r), r._target = t, r.type !== Ze.SPRITE && this.maskStack.push(r), r.enabled)
        switch (r.type) {
          case Ze.SCISSOR:
            this.renderer.scissor.push(r);
            break;
          case Ze.STENCIL:
            this.renderer.stencil.push(r);
            break;
          case Ze.SPRITE:
            r.copyCountersOrReset(null), this.pushSpriteMask(r);
            break;
          case Ze.COLOR:
            this.pushColorMask(r);
            break;
        }
      r.type === Ze.SPRITE && this.maskStack.push(r);
    }, i.prototype.pop = function(t) {
      var e = this.maskStack.pop();
      if (!(!e || e._target !== t)) {
        if (e.enabled)
          switch (e.type) {
            case Ze.SCISSOR:
              this.renderer.scissor.pop(e);
              break;
            case Ze.STENCIL:
              this.renderer.stencil.pop(e.maskObject);
              break;
            case Ze.SPRITE:
              this.popSpriteMask(e);
              break;
            case Ze.COLOR:
              this.popColorMask(e);
              break;
          }
        if (e.reset(), e.pooled && this.maskDataPool.push(e), this.maskStack.length !== 0) {
          var r = this.maskStack[this.maskStack.length - 1];
          r.type === Ze.SPRITE && r._filters && (r._filters[0].maskSprite = r.maskObject);
        }
      }
    }, i.prototype.detect = function(t) {
      var e = t.maskObject;
      e ? e.isSprite ? t.type = Ze.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = Ze.SCISSOR : t.type = Ze.STENCIL : t.type = Ze.COLOR;
    }, i.prototype.pushSpriteMask = function(t) {
      var e, r, n = t.maskObject, s = t._target, a = t._filters;
      a || (a = this.alphaMaskPool[this.alphaMaskIndex], a || (a = this.alphaMaskPool[this.alphaMaskIndex] = [new rS()]));
      var o = this.renderer, u = o.renderTexture, l, h;
      if (u.current) {
        var d = u.current;
        l = t.resolution || d.resolution, h = (e = t.multisample) !== null && e !== void 0 ? e : d.multisample;
      } else
        l = t.resolution || o.resolution, h = (r = t.multisample) !== null && r !== void 0 ? r : o.multisample;
      a[0].resolution = l, a[0].multisample = h, a[0].maskSprite = n;
      var f = s.filterArea;
      s.filterArea = n.getBounds(!0), o.filter.push(s, a), s.filterArea = f, t._filters || this.alphaMaskIndex++;
    }, i.prototype.popSpriteMask = function(t) {
      this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
    }, i.prototype.pushColorMask = function(t) {
      var e = t._colorMask, r = t._colorMask = e & t.colorMask;
      r !== e && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0);
    }, i.prototype.popColorMask = function(t) {
      var e = t._colorMask, r = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
      r !== e && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0);
    }, i.prototype.destroy = function() {
      this.renderer = null;
    }, i;
  }()
), iS = (
  /** @class */
  function() {
    function i(t) {
      this.renderer = t, this.maskStack = [], this.glConst = 0;
    }
    return i.prototype.getStackLength = function() {
      return this.maskStack.length;
    }, i.prototype.setMaskStack = function(t) {
      var e = this.renderer.gl, r = this.getStackLength();
      this.maskStack = t;
      var n = this.getStackLength();
      n !== r && (n === 0 ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()));
    }, i.prototype._useCurrent = function() {
    }, i.prototype.destroy = function() {
      this.renderer = null, this.maskStack = null;
    }, i;
  }()
), O1 = new ar(), I1 = [], Ub = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e) {
      var r = i.call(this, e) || this;
      return r.glConst = gt.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST, r;
    }
    return t.prototype.getStackLength = function() {
      var e = this.maskStack[this.maskStack.length - 1];
      return e ? e._scissorCounter : 0;
    }, t.prototype.calcScissorRect = function(e) {
      var r;
      if (!e._scissorRectLocal) {
        var n = e._scissorRect, s = e.maskObject, a = this.renderer, o = a.renderTexture, u = s.getBounds(!0, (r = I1.pop()) !== null && r !== void 0 ? r : new Nt());
        this.roundFrameToPixels(u, o.current ? o.current.resolution : a.resolution, o.sourceFrame, o.destinationFrame, a.projection.transform), n && u.fit(n), e._scissorRectLocal = u;
      }
    }, t.isMatrixRotated = function(e) {
      if (!e)
        return !1;
      var r = e.a, n = e.b, s = e.c, a = e.d;
      return (Math.abs(n) > 1e-4 || Math.abs(s) > 1e-4) && (Math.abs(r) > 1e-4 || Math.abs(a) > 1e-4);
    }, t.prototype.testScissor = function(e) {
      var r = e.maskObject;
      if (!r.isFastRect || !r.isFastRect() || t.isMatrixRotated(r.worldTransform) || t.isMatrixRotated(this.renderer.projection.transform))
        return !1;
      this.calcScissorRect(e);
      var n = e._scissorRectLocal;
      return n.width > 0 && n.height > 0;
    }, t.prototype.roundFrameToPixels = function(e, r, n, s, a) {
      t.isMatrixRotated(a) || (a = a ? O1.copyFrom(a) : O1.identity(), a.translate(-n.x, -n.y).scale(s.width / n.width, s.height / n.height).translate(s.x, s.y), this.renderer.filter.transformAABB(a, e), e.fit(s), e.x = Math.round(e.x * r), e.y = Math.round(e.y * r), e.width = Math.round(e.width * r), e.height = Math.round(e.height * r));
    }, t.prototype.push = function(e) {
      e._scissorRectLocal || this.calcScissorRect(e);
      var r = this.renderer.gl;
      e._scissorRect || r.enable(r.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent();
    }, t.prototype.pop = function(e) {
      var r = this.renderer.gl;
      e && I1.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : r.disable(r.SCISSOR_TEST);
    }, t.prototype._useCurrent = function() {
      var e = this.maskStack[this.maskStack.length - 1]._scissorRect, r;
      this.renderer.renderTexture.current ? r = e.y : r = this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, r, e.width, e.height);
    }, t;
  }(iS)
), jb = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e) {
      var r = i.call(this, e) || this;
      return r.glConst = gt.ADAPTER.getWebGLRenderingContext().STENCIL_TEST, r;
    }
    return t.prototype.getStackLength = function() {
      var e = this.maskStack[this.maskStack.length - 1];
      return e ? e._stencilCounter : 0;
    }, t.prototype.push = function(e) {
      var r = e.maskObject, n = this.renderer.gl, s = e._stencilCounter;
      s === 0 && (this.renderer.framebuffer.forceStencil(), n.clearStencil(0), n.clear(n.STENCIL_BUFFER_BIT), n.enable(n.STENCIL_TEST)), e._stencilCounter++;
      var a = e._colorMask;
      a !== 0 && (e._colorMask = 0, n.colorMask(!1, !1, !1, !1)), n.stencilFunc(n.EQUAL, s, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.INCR), r.renderable = !0, r.render(this.renderer), this.renderer.batch.flush(), r.renderable = !1, a !== 0 && (e._colorMask = a, n.colorMask((a & 1) !== 0, (a & 2) !== 0, (a & 4) !== 0, (a & 8) !== 0)), this._useCurrent();
    }, t.prototype.pop = function(e) {
      var r = this.renderer.gl;
      if (this.getStackLength() === 0)
        r.disable(r.STENCIL_TEST);
      else {
        var n = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, s = n ? n._colorMask : 15;
        s !== 0 && (n._colorMask = 0, r.colorMask(!1, !1, !1, !1)), r.stencilOp(r.KEEP, r.KEEP, r.DECR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, s !== 0 && (n._colorMask = s, r.colorMask((s & 1) !== 0, (s & 2) !== 0, (s & 4) !== 0, (s & 8) !== 0)), this._useCurrent();
      }
    }, t.prototype._useCurrent = function() {
      var e = this.renderer.gl;
      e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP);
    }, t;
  }(iS)
), zb = (
  /** @class */
  function() {
    function i(t) {
      this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new ar(), this.transform = null;
    }
    return i.prototype.update = function(t, e, r, n) {
      this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, r, n), this.transform && this.projectionMatrix.append(this.transform);
      var s = this.renderer;
      s.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, s.globalUniforms.update(), s.shader.shader && s.shader.syncUniformGroup(s.shader.shader.uniforms.globals);
    }, i.prototype.calculateProjection = function(t, e, r, n) {
      var s = this.projectionMatrix, a = n ? -1 : 1;
      s.identity(), s.a = 1 / e.width * 2, s.d = a * (1 / e.height * 2), s.tx = -1 - e.x * s.a, s.ty = -a - e.y * s.d;
    }, i.prototype.setTransform = function(t) {
    }, i.prototype.destroy = function() {
      this.renderer = null;
    }, i;
  }()
), ya = new Nt(), _h = new Nt(), Hb = (
  /** @class */
  function() {
    function i(t) {
      this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Nt(), this.destinationFrame = new Nt(), this.viewportFrame = new Nt();
    }
    return i.prototype.bind = function(t, e, r) {
      t === void 0 && (t = null);
      var n = this.renderer;
      this.current = t;
      var s, a, o;
      t ? (s = t.baseTexture, o = s.resolution, e || (ya.width = t.frame.width, ya.height = t.frame.height, e = ya), r || (_h.x = t.frame.x, _h.y = t.frame.y, _h.width = e.width, _h.height = e.height, r = _h), a = s.framebuffer) : (o = n.resolution, e || (ya.width = n.screen.width, ya.height = n.screen.height, e = ya), r || (r = ya, r.width = e.width, r.height = e.height));
      var u = this.viewportFrame;
      u.x = r.x * o, u.y = r.y * o, u.width = r.width * o, u.height = r.height * o, t || (u.y = n.view.height - (u.y + u.height)), u.ceil(), this.renderer.framebuffer.bind(a, u), this.renderer.projection.update(r, e, o, !a), t ? this.renderer.mask.setMaskStack(s.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(r);
    }, i.prototype.clear = function(t, e) {
      this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.clearColor;
      var r = this.destinationFrame, n = this.current ? this.current.baseTexture : this.renderer.screen, s = r.width !== n.width || r.height !== n.height;
      if (s) {
        var a = this.viewportFrame, o = a.x, u = a.y, l = a.width, h = a.height;
        o = Math.round(o), u = Math.round(u), l = Math.round(l), h = Math.round(h), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(o, u, l, h);
      }
      this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), s && this.renderer.scissor.pop();
    }, i.prototype.resize = function() {
      this.bind(null);
    }, i.prototype.reset = function() {
      this.bind(null);
    }, i.prototype.destroy = function() {
      this.renderer = null;
    }, i;
  }()
);
function m2(i, t, e, r, n) {
  e.buffer.update(n);
}
var y2 = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}, nS = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function sS(i) {
  for (var t = i.map(function(u) {
    return {
      data: u,
      offset: 0,
      dataLen: 0,
      dirty: 0
    };
  }), e = 0, r = 0, n = 0, s = 0; s < t.length; s++) {
    var a = t[s];
    if (e = nS[a.data.type], a.data.size > 1 && (e = Math.max(e, 16) * a.data.size), a.dataLen = e, r % e !== 0 && r < 16) {
      var o = r % e % 16;
      r += o, n += o;
    }
    r + e > 16 ? (n = Math.ceil(n / 16) * 16, a.offset = n, n += e, r = e) : (a.offset = n, r += e, n += e);
  }
  return n = Math.ceil(n / 16) * 16, { uboElements: t, size: n };
}
function aS(i, t) {
  var e = [];
  for (var r in i)
    t[r] && e.push(t[r]);
  return e.sort(function(n, s) {
    return n.index - s.index;
  }), e;
}
function oS(i, t) {
  if (!i.autoManage)
    return { size: 0, syncFunc: m2 };
  for (var e = aS(i.uniforms, t), r = sS(e), n = r.uboElements, s = r.size, a = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `], o = 0; o < n.length; o++) {
    for (var u = n[o], l = i.uniforms[u.data.name], h = u.data.name, d = !1, f = 0; f < Wo.length; f++) {
      var p = Wo[f];
      if (p.codeUbo && p.test(u.data, l)) {
        a.push("offset = " + u.offset / 4 + ";", Wo[f].codeUbo(u.data.name, l)), d = !0;
        break;
      }
    }
    if (!d)
      if (u.data.size > 1) {
        var v = QE(u.data.type), g = Math.max(nS[u.data.type] / 16, 1), m = v / g, y = (4 - m % 4) % 4;
        a.push(`
                cv = ud.` + h + `.value;
                v = uv.` + h + `;
                offset = ` + u.offset / 4 + `;

                t = 0;

                for(var i=0; i < ` + u.data.size * g + `; i++)
                {
                    for(var j = 0; j < ` + m + `; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ` + y + `;
                }

                `);
      } else {
        var _ = y2[u.data.type];
        a.push(`
                cv = ud.` + h + `.value;
                v = uv.` + h + `;
                offset = ` + u.offset / 4 + `;
                ` + _ + `;
                `);
      }
  }
  return a.push(`
       renderer.buffer.update(buffer);
    `), {
    size: s,
    // eslint-disable-next-line no-new-func
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", a.join(`
`))
  };
}
var _2 = (
  /** @class */
  function() {
    function i() {
    }
    return i;
  }()
), uS = (
  /** @class */
  function() {
    function i(t, e) {
      this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
    }
    return i.prototype.destroy = function() {
      this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
    }, i;
  }()
);
function b2(i, t) {
  for (var e = {}, r = t.getProgramParameter(i, t.ACTIVE_ATTRIBUTES), n = 0; n < r; n++) {
    var s = t.getActiveAttrib(i, n);
    if (s.name.indexOf("gl_") !== 0) {
      var a = tS(t, s.type), o = {
        type: a,
        name: s.name,
        size: QE(a),
        location: t.getAttribLocation(i, s.name)
      };
      e[s.name] = o;
    }
  }
  return e;
}
function x2(i, t) {
  for (var e = {}, r = t.getProgramParameter(i, t.ACTIVE_UNIFORMS), n = 0; n < r; n++) {
    var s = t.getActiveUniform(i, n), a = s.name.replace(/\[.*?\]$/, ""), o = !!s.name.match(/\[.*?\]$/), u = tS(t, s.type);
    e[a] = {
      name: a,
      index: n,
      type: u,
      size: s.size,
      isArray: o,
      value: ZE(u, s.size)
    };
  }
  return e;
}
function lS(i, t) {
  var e = S1(i, i.VERTEX_SHADER, t.vertexSrc), r = S1(i, i.FRAGMENT_SHADER, t.fragmentSrc), n = i.createProgram();
  if (i.attachShader(n, e), i.attachShader(n, r), i.linkProgram(n), i.getProgramParameter(n, i.LINK_STATUS) || e2(i, n, e, r), t.attributeData = b2(n, i), t.uniformData = x2(n, i), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc)) {
    var s = Object.keys(t.attributeData);
    s.sort(function(h, d) {
      return h > d ? 1 : -1;
    });
    for (var a = 0; a < s.length; a++)
      t.attributeData[s[a]].location = a, i.bindAttribLocation(n, a, s[a]);
    i.linkProgram(n);
  }
  i.deleteShader(e), i.deleteShader(r);
  var o = {};
  for (var a in t.uniformData) {
    var u = t.uniformData[a];
    o[a] = {
      location: i.getUniformLocation(n, a),
      value: ZE(u.type, u.size)
    };
  }
  var l = new uS(n, o);
  return l;
}
var w2 = 0, Xd = { textureCount: 0, uboCount: 0 }, $b = (
  /** @class */
  function() {
    function i(t) {
      this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = w2++;
    }
    return i.prototype.systemCheck = function() {
      if (!l2())
        throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }, i.prototype.contextChange = function(t) {
      this.gl = t, this.reset();
    }, i.prototype.bind = function(t, e) {
      t.disposeRunner.add(this), t.uniforms.globals = this.renderer.globalUniforms;
      var r = t.program, n = r.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
      return this.shader = t, this.program !== r && (this.program = r, this.gl.useProgram(n.program)), e || (Xd.textureCount = 0, Xd.uboCount = 0, this.syncUniformGroup(t.uniformGroup, Xd)), n;
    }, i.prototype.setUniforms = function(t) {
      var e = this.shader.program, r = e.glPrograms[this.renderer.CONTEXT_UID];
      e.syncUniforms(r.uniformData, t, this.renderer);
    }, i.prototype.syncUniformGroup = function(t, e) {
      var r = this.getGlProgram();
      (!t.static || t.dirtyId !== r.uniformDirtyGroups[t.id]) && (r.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, r, e));
    }, i.prototype.syncUniforms = function(t, e, r) {
      var n = t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t);
      n(e.uniformData, t.uniforms, this.renderer, r);
    }, i.prototype.createSyncGroups = function(t) {
      var e = this.getSignature(t, this.shader.program.uniformData, "u");
      return this.cache[e] || (this.cache[e] = a2(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id];
    }, i.prototype.syncUniformBufferGroup = function(t, e) {
      var r = this.getGlProgram();
      if (!t.static || t.dirtyId !== 0 || !r.uniformGroups[t.id]) {
        t.dirtyId = 0;
        var n = r.uniformGroups[t.id] || this.createSyncBufferGroup(t, r, e);
        t.buffer.update(), n(r.uniformData, t.uniforms, this.renderer, Xd, t.buffer);
      }
      this.renderer.buffer.bindBufferBase(t.buffer, r.uniformBufferBindings[e]);
    }, i.prototype.createSyncBufferGroup = function(t, e, r) {
      var n = this.renderer.gl;
      this.renderer.buffer.bind(t.buffer);
      var s = this.gl.getUniformBlockIndex(e.program, r);
      e.uniformBufferBindings[r] = this.shader.uniformBindCount, n.uniformBlockBinding(e.program, s, this.shader.uniformBindCount), this.shader.uniformBindCount++;
      var a = this.getSignature(t, this.shader.program.uniformData, "ubo"), o = this._uboCache[a];
      if (o || (o = this._uboCache[a] = oS(t, this.shader.program.uniformData)), t.autoManage) {
        var u = new Float32Array(o.size / 4);
        t.buffer.update(u);
      }
      return e.uniformGroups[t.id] = o.syncFunc, e.uniformGroups[t.id];
    }, i.prototype.getSignature = function(t, e, r) {
      var n = t.uniforms, s = [r + "-"];
      for (var a in n)
        s.push(a), e[a] && s.push(e[a].type);
      return s.join("-");
    }, i.prototype.getGlProgram = function() {
      return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
    }, i.prototype.generateProgram = function(t) {
      var e = this.gl, r = t.program, n = lS(e, r);
      return r.glPrograms[this.renderer.CONTEXT_UID] = n, n;
    }, i.prototype.reset = function() {
      this.program = null, this.shader = null;
    }, i.prototype.disposeShader = function(t) {
      this.shader === t && (this.shader = null);
    }, i.prototype.destroy = function() {
      this.renderer = null, this.destroyed = !0;
    }, i;
  }()
);
function E2(i, t) {
  return t === void 0 && (t = []), t[Et.NORMAL] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.ADD] = [i.ONE, i.ONE], t[Et.MULTIPLY] = [i.DST_COLOR, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.SCREEN] = [i.ONE, i.ONE_MINUS_SRC_COLOR, i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.OVERLAY] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.DARKEN] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.LIGHTEN] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.COLOR_DODGE] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.COLOR_BURN] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.HARD_LIGHT] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.SOFT_LIGHT] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.DIFFERENCE] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.EXCLUSION] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.HUE] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.SATURATION] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.COLOR] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.LUMINOSITY] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.NONE] = [0, 0], t[Et.NORMAL_NPM] = [i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.ADD_NPM] = [i.SRC_ALPHA, i.ONE, i.ONE, i.ONE], t[Et.SCREEN_NPM] = [i.SRC_ALPHA, i.ONE_MINUS_SRC_COLOR, i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.SRC_IN] = [i.DST_ALPHA, i.ZERO], t[Et.SRC_OUT] = [i.ONE_MINUS_DST_ALPHA, i.ZERO], t[Et.SRC_ATOP] = [i.DST_ALPHA, i.ONE_MINUS_SRC_ALPHA], t[Et.DST_OVER] = [i.ONE_MINUS_DST_ALPHA, i.ONE], t[Et.DST_IN] = [i.ZERO, i.SRC_ALPHA], t[Et.DST_OUT] = [i.ZERO, i.ONE_MINUS_SRC_ALPHA], t[Et.DST_ATOP] = [i.ONE_MINUS_DST_ALPHA, i.SRC_ALPHA], t[Et.XOR] = [i.ONE_MINUS_DST_ALPHA, i.ONE_MINUS_SRC_ALPHA], t[Et.SUBTRACT] = [i.ONE, i.ONE, i.ONE, i.ONE, i.FUNC_REVERSE_SUBTRACT, i.FUNC_ADD], t;
}
var S2 = 0, T2 = 1, C2 = 2, M2 = 3, P2 = 4, O2 = 5, Vb = (
  /** @class */
  function() {
    function i() {
      this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = Et.NONE, this._blendEq = !1, this.map = [], this.map[S2] = this.setBlend, this.map[T2] = this.setOffset, this.map[C2] = this.setCullFace, this.map[M2] = this.setDepthTest, this.map[P2] = this.setFrontFace, this.map[O2] = this.setDepthMask, this.checks = [], this.defaultState = new va(), this.defaultState.blend = !0;
    }
    return i.prototype.contextChange = function(t) {
      this.gl = t, this.blendModes = E2(t), this.set(this.defaultState), this.reset();
    }, i.prototype.set = function(t) {
      if (t = t || this.defaultState, this.stateId !== t.data) {
        for (var e = this.stateId ^ t.data, r = 0; e; )
          e & 1 && this.map[r].call(this, !!(t.data & 1 << r)), e = e >> 1, r++;
        this.stateId = t.data;
      }
      for (var r = 0; r < this.checks.length; r++)
        this.checks[r](this, t);
    }, i.prototype.forceState = function(t) {
      t = t || this.defaultState;
      for (var e = 0; e < this.map.length; e++)
        this.map[e].call(this, !!(t.data & 1 << e));
      for (var e = 0; e < this.checks.length; e++)
        this.checks[e](this, t);
      this.stateId = t.data;
    }, i.prototype.setBlend = function(t) {
      this.updateCheck(i.checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND);
    }, i.prototype.setOffset = function(t) {
      this.updateCheck(i.checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    }, i.prototype.setDepthTest = function(t) {
      this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST);
    }, i.prototype.setDepthMask = function(t) {
      this.gl.depthMask(t);
    }, i.prototype.setCullFace = function(t) {
      this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE);
    }, i.prototype.setFrontFace = function(t) {
      this.gl.frontFace(this.gl[t ? "CW" : "CCW"]);
    }, i.prototype.setBlendMode = function(t) {
      if (t !== this.blendMode) {
        this.blendMode = t;
        var e = this.blendModes[t], r = this.gl;
        e.length === 2 ? r.blendFunc(e[0], e[1]) : r.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, r.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD));
      }
    }, i.prototype.setPolygonOffset = function(t, e) {
      this.gl.polygonOffset(t, e);
    }, i.prototype.reset = function() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);
    }, i.prototype.updateCheck = function(t, e) {
      var r = this.checks.indexOf(t);
      e && r === -1 ? this.checks.push(t) : !e && r !== -1 && this.checks.splice(r, 1);
    }, i.checkBlendMode = function(t, e) {
      t.setBlendMode(e.blendMode);
    }, i.checkPolygonOffset = function(t, e) {
      t.setPolygonOffset(1, e.polygonOffset);
    }, i.prototype.destroy = function() {
      this.gl = null;
    }, i;
  }()
), Xb = (
  /** @class */
  function() {
    function i(t) {
      this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = gt.GC_MAX_IDLE, this.checkCountMax = gt.GC_MAX_CHECK_COUNT, this.mode = gt.GC_MODE;
    }
    return i.prototype.postrender = function() {
      this.renderer.renderingToScreen && (this.count++, this.mode !== hv.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
    }, i.prototype.run = function() {
      for (var t = this.renderer.texture, e = t.managedTextures, r = !1, n = 0; n < e.length; n++) {
        var s = e[n];
        !s.framebuffer && this.count - s.touched > this.maxIdle && (t.destroyTexture(s, !0), e[n] = null, r = !0);
      }
      if (r) {
        for (var a = 0, n = 0; n < e.length; n++)
          e[n] !== null && (e[a++] = e[n]);
        e.length = a;
      }
    }, i.prototype.unload = function(t) {
      var e = this.renderer.texture, r = t._texture;
      r && !r.framebuffer && e.destroyTexture(r);
      for (var n = t.children.length - 1; n >= 0; n--)
        this.unload(t.children[n]);
    }, i.prototype.destroy = function() {
      this.renderer = null;
    }, i;
  }()
);
function I2(i) {
  var t, e, r, n, s, a, o, u, l, h, d, f, p, v, g, m, y, _, b, w, T, x, S;
  return "WebGL2RenderingContext" in globalThis && i instanceof globalThis.WebGL2RenderingContext ? S = (t = {}, t[It.UNSIGNED_BYTE] = (e = {}, e[ht.RGBA] = i.RGBA8, e[ht.RGB] = i.RGB8, e[ht.RG] = i.RG8, e[ht.RED] = i.R8, e[ht.RGBA_INTEGER] = i.RGBA8UI, e[ht.RGB_INTEGER] = i.RGB8UI, e[ht.RG_INTEGER] = i.RG8UI, e[ht.RED_INTEGER] = i.R8UI, e[ht.ALPHA] = i.ALPHA, e[ht.LUMINANCE] = i.LUMINANCE, e[ht.LUMINANCE_ALPHA] = i.LUMINANCE_ALPHA, e), t[It.BYTE] = (r = {}, r[ht.RGBA] = i.RGBA8_SNORM, r[ht.RGB] = i.RGB8_SNORM, r[ht.RG] = i.RG8_SNORM, r[ht.RED] = i.R8_SNORM, r[ht.RGBA_INTEGER] = i.RGBA8I, r[ht.RGB_INTEGER] = i.RGB8I, r[ht.RG_INTEGER] = i.RG8I, r[ht.RED_INTEGER] = i.R8I, r), t[It.UNSIGNED_SHORT] = (n = {}, n[ht.RGBA_INTEGER] = i.RGBA16UI, n[ht.RGB_INTEGER] = i.RGB16UI, n[ht.RG_INTEGER] = i.RG16UI, n[ht.RED_INTEGER] = i.R16UI, n[ht.DEPTH_COMPONENT] = i.DEPTH_COMPONENT16, n), t[It.SHORT] = (s = {}, s[ht.RGBA_INTEGER] = i.RGBA16I, s[ht.RGB_INTEGER] = i.RGB16I, s[ht.RG_INTEGER] = i.RG16I, s[ht.RED_INTEGER] = i.R16I, s), t[It.UNSIGNED_INT] = (a = {}, a[ht.RGBA_INTEGER] = i.RGBA32UI, a[ht.RGB_INTEGER] = i.RGB32UI, a[ht.RG_INTEGER] = i.RG32UI, a[ht.RED_INTEGER] = i.R32UI, a[ht.DEPTH_COMPONENT] = i.DEPTH_COMPONENT24, a), t[It.INT] = (o = {}, o[ht.RGBA_INTEGER] = i.RGBA32I, o[ht.RGB_INTEGER] = i.RGB32I, o[ht.RG_INTEGER] = i.RG32I, o[ht.RED_INTEGER] = i.R32I, o), t[It.FLOAT] = (u = {}, u[ht.RGBA] = i.RGBA32F, u[ht.RGB] = i.RGB32F, u[ht.RG] = i.RG32F, u[ht.RED] = i.R32F, u[ht.DEPTH_COMPONENT] = i.DEPTH_COMPONENT32F, u), t[It.HALF_FLOAT] = (l = {}, l[ht.RGBA] = i.RGBA16F, l[ht.RGB] = i.RGB16F, l[ht.RG] = i.RG16F, l[ht.RED] = i.R16F, l), t[It.UNSIGNED_SHORT_5_6_5] = (h = {}, h[ht.RGB] = i.RGB565, h), t[It.UNSIGNED_SHORT_4_4_4_4] = (d = {}, d[ht.RGBA] = i.RGBA4, d), t[It.UNSIGNED_SHORT_5_5_5_1] = (f = {}, f[ht.RGBA] = i.RGB5_A1, f), t[It.UNSIGNED_INT_2_10_10_10_REV] = (p = {}, p[ht.RGBA] = i.RGB10_A2, p[ht.RGBA_INTEGER] = i.RGB10_A2UI, p), t[It.UNSIGNED_INT_10F_11F_11F_REV] = (v = {}, v[ht.RGB] = i.R11F_G11F_B10F, v), t[It.UNSIGNED_INT_5_9_9_9_REV] = (g = {}, g[ht.RGB] = i.RGB9_E5, g), t[It.UNSIGNED_INT_24_8] = (m = {}, m[ht.DEPTH_STENCIL] = i.DEPTH24_STENCIL8, m), t[It.FLOAT_32_UNSIGNED_INT_24_8_REV] = (y = {}, y[ht.DEPTH_STENCIL] = i.DEPTH32F_STENCIL8, y), t) : S = (_ = {}, _[It.UNSIGNED_BYTE] = (b = {}, b[ht.RGBA] = i.RGBA, b[ht.RGB] = i.RGB, b[ht.ALPHA] = i.ALPHA, b[ht.LUMINANCE] = i.LUMINANCE, b[ht.LUMINANCE_ALPHA] = i.LUMINANCE_ALPHA, b), _[It.UNSIGNED_SHORT_5_6_5] = (w = {}, w[ht.RGB] = i.RGB, w), _[It.UNSIGNED_SHORT_4_4_4_4] = (T = {}, T[ht.RGBA] = i.RGBA, T), _[It.UNSIGNED_SHORT_5_5_5_1] = (x = {}, x[ht.RGBA] = i.RGBA, x), _), S;
}
var Mp = (
  /** @class */
  function() {
    function i(t) {
      this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = It.UNSIGNED_BYTE, this.internalFormat = ht.RGBA, this.samplerType = 0;
    }
    return i;
  }()
), Wb = (
  /** @class */
  function() {
    function i(t) {
      this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new Kt(), this.hasIntegerTextures = !1;
    }
    return i.prototype.contextChange = function() {
      var t = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = I2(t);
      var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = e;
      for (var r = 0; r < e; r++)
        this.boundTextures[r] = null;
      this.emptyTextures = {};
      var n = new Mp(t.createTexture());
      t.bindTexture(t.TEXTURE_2D, n.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = n, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new Mp(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
      for (var r = 0; r < 6; r++)
        t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
      t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
      for (var r = 0; r < this.boundTextures.length; r++)
        this.bind(null, r);
    }, i.prototype.bind = function(t, e) {
      e === void 0 && (e = 0);
      var r = this.gl;
      if (t = t == null ? void 0 : t.castToBaseTexture(), t && t.valid && !t.parentTextureArray) {
        t.touched = this.renderer.textureGC.count;
        var n = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
        this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(t.target, n.texture)), n.dirtyId !== t.dirtyId ? (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), this.updateTexture(t)) : n.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t), this.boundTextures[e] = t;
      } else
        this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(r.TEXTURE_2D, this.emptyTextures[r.TEXTURE_2D].texture), this.boundTextures[e] = null;
    }, i.prototype.reset = function() {
      this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;
      for (var t = 0; t < this.boundTextures.length; t++)
        this.boundTextures[t] = this.unknownTexture;
    }, i.prototype.unbind = function(t) {
      var e = this, r = e.gl, n = e.boundTextures;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = !1;
        for (var s = 0; s < n.length; s++)
          n[s] === this.unknownTexture && this.bind(null, s);
      }
      for (var s = 0; s < n.length; s++)
        n[s] === t && (this.currentLocation !== s && (r.activeTexture(r.TEXTURE0 + s), this.currentLocation = s), r.bindTexture(t.target, this.emptyTextures[t.target].texture), n[s] = null);
    }, i.prototype.ensureSamplerType = function(t) {
      var e = this, r = e.boundTextures, n = e.hasIntegerTextures, s = e.CONTEXT_UID;
      if (n)
        for (var a = t - 1; a >= 0; --a) {
          var o = r[a];
          if (o) {
            var u = o._glTextures[s];
            u.samplerType !== lv.FLOAT && this.renderer.texture.unbind(o);
          }
        }
    }, i.prototype.initTexture = function(t) {
      var e = new Mp(this.gl.createTexture());
      return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), e;
    }, i.prototype.initTextureType = function(t, e) {
      var r, n;
      e.internalFormat = (n = (r = this.internalFormats[t.type]) === null || r === void 0 ? void 0 : r[t.format]) !== null && n !== void 0 ? n : t.format, this.webGLVersion === 2 && t.type === It.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type;
    }, i.prototype.updateTexture = function(t) {
      var e = t._glTextures[this.CONTEXT_UID];
      if (e) {
        var r = this.renderer;
        if (this.initTextureType(t, e), t.resource && t.resource.upload(r, t, e))
          e.samplerType !== lv.FLOAT && (this.hasIntegerTextures = !0);
        else {
          var n = t.realWidth, s = t.realHeight, a = r.gl;
          (e.width !== n || e.height !== s || e.dirtyId < 0) && (e.width = n, e.height = s, a.texImage2D(t.target, 0, e.internalFormat, n, s, 0, t.format, e.type, null));
        }
        t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId;
      }
    }, i.prototype.destroyTexture = function(t, e) {
      var r = this.gl;
      if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), r.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {
        var n = this.managedTextures.indexOf(t);
        n !== -1 && Lu(this.managedTextures, n, 1);
      }
    }, i.prototype.updateTextureStyle = function(t) {
      var e = t._glTextures[this.CONTEXT_UID];
      e && ((t.mipmap === tn.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? e.mipmap = !1 : e.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? e.wrapMode = On.CLAMP : e.wrapMode = t.wrapMode, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId);
    }, i.prototype.setStyle = function(t, e) {
      var r = this.gl;
      if (e.mipmap && t.mipmap !== tn.ON_MANUAL && r.generateMipmap(t.target), r.texParameteri(t.target, r.TEXTURE_WRAP_S, e.wrapMode), r.texParameteri(t.target, r.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {
        r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === Cn.LINEAR ? r.LINEAR_MIPMAP_LINEAR : r.NEAREST_MIPMAP_NEAREST);
        var n = this.renderer.context.extensions.anisotropicFiltering;
        if (n && t.anisotropicLevel > 0 && t.scaleMode === Cn.LINEAR) {
          var s = Math.min(t.anisotropicLevel, r.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          r.texParameterf(t.target, n.TEXTURE_MAX_ANISOTROPY_EXT, s);
        }
      } else
        r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === Cn.LINEAR ? r.LINEAR : r.NEAREST);
      r.texParameteri(t.target, r.TEXTURE_MAG_FILTER, t.scaleMode === Cn.LINEAR ? r.LINEAR : r.NEAREST);
    }, i.prototype.destroy = function() {
      this.renderer = null;
    }, i;
  }()
), hS = {
  __proto__: null,
  FilterSystem: Nb,
  BatchSystem: Ab,
  ContextSystem: Lb,
  FramebufferSystem: Bb,
  GeometrySystem: Fb,
  MaskSystem: Gb,
  ScissorSystem: Ub,
  StencilSystem: jb,
  ProjectionSystem: zb,
  RenderTextureSystem: Hb,
  ShaderSystem: $b,
  StateSystem: Vb,
  TextureGCSystem: Xb,
  TextureSystem: Wb
}, j0 = new ar(), cS = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e, r) {
      e === void 0 && (e = ic.UNKNOWN);
      var n = i.call(this) || this;
      return r = Object.assign({}, gt.RENDER_OPTIONS, r), n.options = r, n.type = e, n.screen = new Nt(0, 0, r.width, r.height), n.view = r.view || gt.ADAPTER.createCanvas(), n.resolution = r.resolution || gt.RESOLUTION, n.useContextAlpha = r.useContextAlpha, n.autoDensity = !!r.autoDensity, n.preserveDrawingBuffer = r.preserveDrawingBuffer, n.clearBeforeRender = r.clearBeforeRender, n._backgroundColor = 0, n._backgroundColorRgba = [0, 0, 0, 1], n._backgroundColorString = "#000000", n.backgroundColor = r.backgroundColor || n._backgroundColor, n.backgroundAlpha = r.backgroundAlpha, r.transparent !== void 0 && (jr("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), n.useContextAlpha = r.transparent, n.backgroundAlpha = r.transparent ? 0 : 1), n._lastObjectRendered = null, n.plugins = {}, n;
    }
    return t.prototype.initPlugins = function(e) {
      for (var r in e)
        this.plugins[r] = new e[r](this);
    }, Object.defineProperty(t.prototype, "width", {
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal.
       * @member {number}
       * @readonly
       * @default 800
       */
      get: function() {
        return this.view.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /**
       * Same as view.height, actual number of pixels in the canvas by vertical.
       * @member {number}
       * @readonly
       * @default 600
       */
      get: function() {
        return this.view.height;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.resize = function(e, r) {
      this.view.width = Math.round(e * this.resolution), this.view.height = Math.round(r * this.resolution);
      var n = this.view.width / this.resolution, s = this.view.height / this.resolution;
      this.screen.width = n, this.screen.height = s, this.autoDensity && (this.view.style.width = n + "px", this.view.style.height = s + "px"), this.emit("resize", n, s);
    }, t.prototype.generateTexture = function(e, r, n, s) {
      r === void 0 && (r = {}), typeof r == "number" && (jr("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), r = { scaleMode: r, resolution: n, region: s });
      var a = r.region, o = VD(r, ["region"]);
      s = a || e.getLocalBounds(null, !0), s.width === 0 && (s.width = 1), s.height === 0 && (s.height = 1);
      var u = Ei.create(wy({ width: s.width, height: s.height }, o));
      return j0.tx = -s.x, j0.ty = -s.y, this.render(e, {
        renderTexture: u,
        clear: !1,
        transform: j0,
        skipUpdateTransform: !!e.parent
      }), u;
    }, t.prototype.destroy = function(e) {
      for (var r in this.plugins)
        this.plugins[r].destroy(), this.plugins[r] = null;
      e && this.view.parentNode && this.view.parentNode.removeChild(this.view);
      var n = this;
      n.plugins = null, n.type = ic.UNKNOWN, n.view = null, n.screen = null, n._tempDisplayObjectParent = null, n.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;
    }, Object.defineProperty(t.prototype, "backgroundColor", {
      /**
       * The background color to fill if not transparent
       * @member {number}
       */
      get: function() {
        return this._backgroundColor;
      },
      set: function(e) {
        this._backgroundColor = e, this._backgroundColorString = NE(e), Kl(e, this._backgroundColorRgba);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "backgroundAlpha", {
      /**
       * The background color alpha. Setting this to 0 will make the canvas transparent.
       * @member {number}
       */
      get: function() {
        return this._backgroundColorRgba[3];
      },
      set: function(e) {
        this._backgroundColorRgba[3] = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Pi)
), R2 = (
  /** @class */
  function() {
    function i(t) {
      this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
    }
    return i;
  }()
), D2 = (
  /** @class */
  function() {
    function i(t) {
      this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {};
    }
    return i.prototype.destroy = function() {
      this.renderer = null;
    }, i.prototype.contextChange = function() {
      this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    }, i.prototype.bind = function(t) {
      var e = this, r = e.gl, n = e.CONTEXT_UID, s = t._glBuffers[n] || this.createGLBuffer(t);
      r.bindBuffer(t.type, s.buffer);
    }, i.prototype.bindBufferBase = function(t, e) {
      var r = this, n = r.gl, s = r.CONTEXT_UID;
      if (this.boundBufferBases[e] !== t) {
        var a = t._glBuffers[s] || this.createGLBuffer(t);
        this.boundBufferBases[e] = t, n.bindBufferBase(n.UNIFORM_BUFFER, e, a.buffer);
      }
    }, i.prototype.bindBufferRange = function(t, e, r) {
      var n = this, s = n.gl, a = n.CONTEXT_UID;
      r = r || 0;
      var o = t._glBuffers[a] || this.createGLBuffer(t);
      s.bindBufferRange(s.UNIFORM_BUFFER, e || 0, o.buffer, r * 256, 256);
    }, i.prototype.update = function(t) {
      var e = this, r = e.gl, n = e.CONTEXT_UID, s = t._glBuffers[n];
      if (t._updateID !== s.updateID)
        if (s.updateID = t._updateID, r.bindBuffer(t.type, s.buffer), s.byteLength >= t.data.byteLength)
          r.bufferSubData(t.type, 0, t.data);
        else {
          var a = t.static ? r.STATIC_DRAW : r.DYNAMIC_DRAW;
          s.byteLength = t.data.byteLength, r.bufferData(t.type, t.data, a);
        }
    }, i.prototype.dispose = function(t, e) {
      if (this.managedBuffers[t.id]) {
        delete this.managedBuffers[t.id];
        var r = t._glBuffers[this.CONTEXT_UID], n = this.gl;
        t.disposeRunner.remove(this), r && (e || n.deleteBuffer(r.buffer), delete t._glBuffers[this.CONTEXT_UID]);
      }
    }, i.prototype.disposeAll = function(t) {
      for (var e = Object.keys(this.managedBuffers), r = 0; r < e.length; r++)
        this.dispose(this.managedBuffers[e[r]], t);
    }, i.prototype.createGLBuffer = function(t) {
      var e = this, r = e.CONTEXT_UID, n = e.gl;
      return t._glBuffers[r] = new R2(n.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[r];
    }, i;
  }()
), Yb = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e) {
      var r = i.call(this, ic.WEBGL, e) || this;
      return e = r.options, r.gl = null, r.CONTEXT_UID = 0, r.runners = {
        destroy: new pr("destroy"),
        contextChange: new pr("contextChange"),
        reset: new pr("reset"),
        update: new pr("update"),
        postrender: new pr("postrender"),
        prerender: new pr("prerender"),
        resize: new pr("resize")
      }, r.runners.contextChange.add(r), r.globalUniforms = new la({
        projectionMatrix: new ar()
      }, !0), r.addSystem(Gb, "mask").addSystem(Lb, "context").addSystem(Vb, "state").addSystem($b, "shader").addSystem(Wb, "texture").addSystem(D2, "buffer").addSystem(Fb, "geometry").addSystem(Bb, "framebuffer").addSystem(Ub, "scissor").addSystem(jb, "stencil").addSystem(zb, "projection").addSystem(Xb, "textureGC").addSystem(Nb, "filter").addSystem(Hb, "renderTexture").addSystem(Ab, "batch"), r.initPlugins(t.__plugins), r.multisample = void 0, e.context ? r.context.initFromContext(e.context) : r.context.initFromOptions({
        alpha: !!r.useContextAlpha,
        antialias: e.antialias,
        premultipliedAlpha: r.useContextAlpha && r.useContextAlpha !== "notMultiplied",
        stencil: !0,
        preserveDrawingBuffer: e.preserveDrawingBuffer,
        powerPreference: r.options.powerPreference
      }), r.renderingToScreen = !0, zO(r.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1"), r.resize(r.options.width, r.options.height), r;
    }
    return t.create = function(e) {
      if (HO())
        return new t(e);
      throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
    }, t.prototype.contextChange = function() {
      var e = this.gl, r;
      if (this.context.webGLVersion === 1) {
        var n = e.getParameter(e.FRAMEBUFFER_BINDING);
        e.bindFramebuffer(e.FRAMEBUFFER, null), r = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, n);
      } else {
        var n = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);
        e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), r = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, n);
      }
      r >= ke.HIGH ? this.multisample = ke.HIGH : r >= ke.MEDIUM ? this.multisample = ke.MEDIUM : r >= ke.LOW ? this.multisample = ke.LOW : this.multisample = ke.NONE;
    }, t.prototype.addSystem = function(e, r) {
      var n = new e(this);
      if (this[r])
        throw new Error('Whoops! The name "' + r + '" is already in use');
      this[r] = n;
      for (var s in this.runners)
        this.runners[s].add(n);
      return this;
    }, t.prototype.render = function(e, r) {
      var n, s, a, o;
      if (r && (r instanceof Ei ? (jr("6.0.0", "Renderer#render arguments changed, use options instead."), n = r, s = arguments[2], a = arguments[3], o = arguments[4]) : (n = r.renderTexture, s = r.clear, a = r.transform, o = r.skipUpdateTransform)), this.renderingToScreen = !n, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = a, !this.context.isLost) {
        if (n || (this._lastObjectRendered = e), !o) {
          var u = e.enableTempParent();
          e.updateTransform(), e.disableTempParent(u);
        }
        this.renderTexture.bind(n), this.batch.currentRenderer.start(), (s !== void 0 ? s : this.clearBeforeRender) && this.renderTexture.clear(), e.render(this), this.batch.currentRenderer.flush(), n && n.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender");
      }
    }, t.prototype.generateTexture = function(e, r, n, s) {
      r === void 0 && (r = {});
      var a = i.prototype.generateTexture.call(this, e, r, n, s);
      return this.framebuffer.blit(), a;
    }, t.prototype.resize = function(e, r) {
      i.prototype.resize.call(this, e, r), this.runners.resize.emit(this.screen.height, this.screen.width);
    }, t.prototype.reset = function() {
      return this.runners.reset.emit(), this;
    }, t.prototype.clear = function() {
      this.renderTexture.bind(), this.renderTexture.clear();
    }, t.prototype.destroy = function(e) {
      this.runners.destroy.emit();
      for (var r in this.runners)
        this.runners[r].destroy();
      i.prototype.destroy.call(this, e), this.gl = null;
    }, Object.defineProperty(t.prototype, "extract", {
      /**
       * Please use `plugins.extract` instead.
       * @member {PIXI.Extract} extract
       * @deprecated since 6.0.0
       * @readonly
       */
      get: function() {
        return jr("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract;
      },
      enumerable: !1,
      configurable: !0
    }), t.registerPlugin = function(e, r) {
      jr("6.5.0", "Renderer.registerPlugin() has been deprecated, please use extensions.add() instead."), an.add({
        name: e,
        type: de.RendererPlugin,
        ref: r
      });
    }, t.__plugins = {}, t;
  }(cS)
);
an.handleByMap(de.RendererPlugin, Yb.__plugins);
function qb(i) {
  return Yb.create(i);
}
var k2 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`, N2 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, fS = k2, Zb = N2, A2 = (
  /** @class */
  function() {
    function i(t) {
      jr("6.1.0", "System class is deprecated, implemement ISystem interface instead."), this.renderer = t;
    }
    return i.prototype.destroy = function() {
      this.renderer = null;
    }, i;
  }()
), gv = (
  /** @class */
  function() {
    function i() {
      this.texArray = null, this.blend = 0, this.type = qi.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
    }
    return i;
  }()
), mv = (
  /** @class */
  function() {
    function i() {
      this.elements = [], this.ids = [], this.count = 0;
    }
    return i.prototype.clear = function() {
      for (var t = 0; t < this.count; t++)
        this.elements[t] = null;
      this.count = 0;
    }, i;
  }()
), yv = (
  /** @class */
  function() {
    function i(t) {
      typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
    }
    return Object.defineProperty(i.prototype, "int8View", {
      /** View on the raw binary data as a `Int8Array`. */
      get: function() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "uint8View", {
      /** View on the raw binary data as a `Uint8Array`. */
      get: function() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "int16View", {
      /**  View on the raw binary data as a `Int16Array`. */
      get: function() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "uint16View", {
      /** View on the raw binary data as a `Uint16Array`. */
      get: function() {
        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "int32View", {
      /** View on the raw binary data as a `Int32Array`. */
      get: function() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.view = function(t) {
      return this[t + "View"];
    }, i.prototype.destroy = function() {
      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
    }, i.sizeOf = function(t) {
      switch (t) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(t + " isn't a valid view type");
      }
    }, i;
  }()
), dS = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e) {
      var r = i.call(this, e) || this;
      return r.shaderGenerator = null, r.geometryClass = null, r.vertexSize = null, r.state = va.for2d(), r.size = gt.SPRITE_BATCH_SIZE * 4, r._vertexCount = 0, r._indexCount = 0, r._bufferedElements = [], r._bufferedTextures = [], r._bufferSize = 0, r._shader = null, r._packedGeometries = [], r._packedGeometryPoolSize = 2, r._flushId = 0, r._aBuffers = {}, r._iBuffers = {}, r.MAX_TEXTURES = 1, r.renderer.on("prerender", r.onPrerender, r), e.runners.contextChange.add(r), r._dcIndex = 0, r._aIndex = 0, r._iIndex = 0, r._attributeBuffer = null, r._indexBuffer = null, r._tempBoundTextures = [], r;
    }
    return t.prototype.contextChange = function() {
      var e = this.renderer.gl;
      gt.PREFER_ENV === Ts.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), gt.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = eS(this.MAX_TEXTURES, e)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
      for (var r = 0; r < this._packedGeometryPoolSize; r++)
        this._packedGeometries[r] = new this.geometryClass();
      this.initFlushBuffers();
    }, t.prototype.initFlushBuffers = function() {
      for (var e = t._drawCallPool, r = t._textureArrayPool, n = this.size / 4, s = Math.floor(n / this.MAX_TEXTURES) + 1; e.length < n; )
        e.push(new gv());
      for (; r.length < s; )
        r.push(new mv());
      for (var a = 0; a < this.MAX_TEXTURES; a++)
        this._tempBoundTextures[a] = null;
    }, t.prototype.onPrerender = function() {
      this._flushId = 0;
    }, t.prototype.render = function(e) {
      e._texture.valid && (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e);
    }, t.prototype.buildTexturesAndDrawCalls = function() {
      var e = this, r = e._bufferedTextures, n = e.MAX_TEXTURES, s = t._textureArrayPool, a = this.renderer.batch, o = this._tempBoundTextures, u = this.renderer.textureGC.count, l = ++Kt._globalBatch, h = 0, d = s[0], f = 0;
      a.copyBoundTextures(o, n);
      for (var p = 0; p < this._bufferSize; ++p) {
        var v = r[p];
        r[p] = null, v._batchEnabled !== l && (d.count >= n && (a.boundArray(d, o, l, n), this.buildDrawCalls(d, f, p), f = p, d = s[++h], ++l), v._batchEnabled = l, v.touched = u, d.elements[d.count++] = v);
      }
      d.count > 0 && (a.boundArray(d, o, l, n), this.buildDrawCalls(d, f, this._bufferSize), ++h, ++l);
      for (var p = 0; p < o.length; p++)
        o[p] = null;
      Kt._globalBatch = l;
    }, t.prototype.buildDrawCalls = function(e, r, n) {
      var s = this, a = s._bufferedElements, o = s._attributeBuffer, u = s._indexBuffer, l = s.vertexSize, h = t._drawCallPool, d = this._dcIndex, f = this._aIndex, p = this._iIndex, v = h[d];
      v.start = this._iIndex, v.texArray = e;
      for (var g = r; g < n; ++g) {
        var m = a[g], y = m._texture.baseTexture, _ = LE[y.alphaMode ? 1 : 0][m.blendMode];
        a[g] = null, r < g && v.blend !== _ && (v.size = p - v.start, r = g, v = h[++d], v.texArray = e, v.start = p), this.packInterleavedGeometry(m, o, u, f, p), f += m.vertexData.length / 2 * l, p += m.indices.length, v.blend = _;
      }
      r < n && (v.size = p - v.start, ++d), this._dcIndex = d, this._aIndex = f, this._iIndex = p;
    }, t.prototype.bindAndClearTexArray = function(e) {
      for (var r = this.renderer.texture, n = 0; n < e.count; n++)
        r.bind(e.elements[n], e.ids[n]), e.elements[n] = null;
      e.count = 0;
    }, t.prototype.updateGeometry = function() {
      var e = this, r = e._packedGeometries, n = e._attributeBuffer, s = e._indexBuffer;
      gt.CAN_UPLOAD_SAME_BUFFER ? (r[this._flushId]._buffer.update(n.rawBinaryData), r[this._flushId]._indexBuffer.update(s), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, r[this._flushId] = new this.geometryClass()), r[this._flushId]._buffer.update(n.rawBinaryData), r[this._flushId]._indexBuffer.update(s), this.renderer.geometry.bind(r[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
    }, t.prototype.drawBatches = function() {
      for (var e = this._dcIndex, r = this.renderer, n = r.gl, s = r.state, a = t._drawCallPool, o = null, u = 0; u < e; u++) {
        var l = a[u], h = l.texArray, d = l.type, f = l.size, p = l.start, v = l.blend;
        o !== h && (o = h, this.bindAndClearTexArray(h)), this.state.blendMode = v, s.set(this.state), n.drawElements(d, f, n.UNSIGNED_SHORT, p * 2);
      }
    }, t.prototype.flush = function() {
      this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
    }, t.prototype.start = function() {
      this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), gt.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }, t.prototype.stop = function() {
      this.flush();
    }, t.prototype.destroy = function() {
      for (var e = 0; e < this._packedGeometryPoolSize; e++)
        this._packedGeometries[e] && this._packedGeometries[e].destroy();
      this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), i.prototype.destroy.call(this);
    }, t.prototype.getAttributeBuffer = function(e) {
      var r = cv(Math.ceil(e / 8)), n = g1(r), s = r * 8;
      this._aBuffers.length <= n && (this._iBuffers.length = n + 1);
      var a = this._aBuffers[s];
      return a || (this._aBuffers[s] = a = new yv(s * this.vertexSize * 4)), a;
    }, t.prototype.getIndexBuffer = function(e) {
      var r = cv(Math.ceil(e / 12)), n = g1(r), s = r * 12;
      this._iBuffers.length <= n && (this._iBuffers.length = n + 1);
      var a = this._iBuffers[n];
      return a || (this._iBuffers[n] = a = new Uint16Array(s)), a;
    }, t.prototype.packInterleavedGeometry = function(e, r, n, s, a) {
      for (var o = r.uint32View, u = r.float32View, l = s / this.vertexSize, h = e.uvs, d = e.indices, f = e.vertexData, p = e._texture.baseTexture._batchLocation, v = Math.min(e.worldAlpha, 1), g = v < 1 && e._texture.baseTexture.alphaMode ? Eb(e._tintRGB, v) : e._tintRGB + (v * 255 << 24), m = 0; m < f.length; m += 2)
        u[s++] = f[m], u[s++] = f[m + 1], u[s++] = h[m], u[s++] = h[m + 1], o[s++] = g, u[s++] = p;
      for (var m = 0; m < d.length; m++)
        n[a++] = l + d[m];
    }, t._drawCallPool = [], t._textureArrayPool = [], t;
  }(bd)
), pS = (
  /** @class */
  function() {
    function i(t, e) {
      if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf("%count%") < 0)
        throw new Error('Fragment template must contain "%count%".');
      if (e.indexOf("%forloop%") < 0)
        throw new Error('Fragment template must contain "%forloop%".');
    }
    return i.prototype.generateShader = function(t) {
      if (!this.programCache[t]) {
        for (var e = new Int32Array(t), r = 0; r < t; r++)
          e[r] = r;
        this.defaultGroupCache[t] = la.from({ uSamplers: e }, !0);
        var n = this.fragTemplate;
        n = n.replace(/%count%/gi, "" + t), n = n.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new lh(this.vertexSrc, n);
      }
      var s = {
        tint: new Float32Array([1, 1, 1, 1]),
        translationMatrix: new ar(),
        default: this.defaultGroupCache[t]
      };
      return new xs(this.programCache[t], s);
    }, i.prototype.generateSampleSrc = function(t) {
      var e = "";
      e += `
`, e += `
`;
      for (var r = 0; r < t; r++)
        r > 0 && (e += `
else `), r < t - 1 && (e += "if(vTextureId < " + r + ".5)"), e += `
{`, e += `
	color = texture2D(uSamplers[` + r + "], vTextureCoord);", e += `
}`;
      return e += `
`, e += `
`, e;
    }, i;
  }()
), Kb = (
  /** @class */
  function(i) {
    Ce(t, i);
    function t(e) {
      e === void 0 && (e = !1);
      var r = i.call(this) || this;
      return r._buffer = new Ke(null, e, !1), r._indexBuffer = new Ke(null, e, !0), r.addAttribute("aVertexPosition", r._buffer, 2, !1, It.FLOAT).addAttribute("aTextureCoord", r._buffer, 2, !1, It.FLOAT).addAttribute("aColor", r._buffer, 4, !0, It.UNSIGNED_BYTE).addAttribute("aTextureId", r._buffer, 1, !0, It.FLOAT).addIndex(r._indexBuffer), r;
    }
    return t;
  }(uh)
), R1 = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`, D1 = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`, vS = (
  /** @class */
  function() {
    function i() {
    }
    return i.create = function(t) {
      var e = Object.assign({
        vertex: R1,
        fragment: D1,
        geometryClass: Kb,
        vertexSize: 6
      }, t), r = e.vertex, n = e.fragment, s = e.vertexSize, a = e.geometryClass;
      return (
        /** @class */
        function(o) {
          Ce(u, o);
          function u(l) {
            var h = o.call(this, l) || this;
            return h.shaderGenerator = new pS(r, n), h.geometryClass = a, h.vertexSize = s, h;
          }
          return u;
        }(dS)
      );
    }, Object.defineProperty(i, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @readonly
       */
      get: function() {
        return R1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i, "defaultFragmentTemplate", {
      /**
       * The default fragment shader source
       * @readonly
       */
      get: function() {
        return D1;
      },
      enumerable: !1,
      configurable: !0
    }), i;
  }()
), Jb = vS.create();
Object.assign(Jb, {
  extension: {
    name: "batch",
    type: de.RendererPlugin
  }
});
var gS = {}, L2 = function(i) {
  Object.defineProperty(gS, i, {
    get: function() {
      return jr("6.0.0", "PIXI.systems." + i + " has moved to PIXI." + i), $E[i];
    }
  });
};
for (var Qb in $E)
  L2(Qb);
var mS = {}, B2 = function(i) {
  Object.defineProperty(mS, i, {
    get: function() {
      return jr("6.0.0", "PIXI.resources." + i + " has moved to PIXI." + i), hS[i];
    }
  });
};
for (var Qb in hS)
  B2(Qb);
var F2 = "6.5.9";
const G2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbstractBatchRenderer: dS,
  AbstractMultiResource: r0,
  AbstractRenderer: cS,
  ArrayResource: Tb,
  Attribute: Ey,
  BaseImageResource: Dn,
  BaseRenderTexture: Rb,
  BaseTexture: Kt,
  BatchDrawCall: gv,
  BatchGeometry: Kb,
  BatchPluginFactory: vS,
  BatchRenderer: Jb,
  BatchShaderGenerator: pS,
  BatchSystem: Ab,
  BatchTextureArray: mv,
  Buffer: Ke,
  BufferResource: su,
  CanvasResource: Cb,
  ContextSystem: Lb,
  CubeResource: Mb,
  get ExtensionType() {
    return de;
  },
  Filter: rn,
  FilterState: WE,
  FilterSystem: Nb,
  Framebuffer: vv,
  FramebufferSystem: Bb,
  GLFramebuffer: YE,
  GLProgram: uS,
  GLTexture: Mp,
  Geometry: uh,
  GeometrySystem: Fb,
  IGLUniformData: _2,
  INSTALLED: oc,
  ImageBitmapResource: Ib,
  ImageResource: i0,
  MaskData: qE,
  MaskSystem: Gb,
  ObjectRenderer: bd,
  Program: lh,
  ProjectionSystem: zb,
  Quad: XE,
  QuadUv: kb,
  RenderTexture: Ei,
  RenderTexturePool: VE,
  RenderTextureSystem: Hb,
  Renderer: Yb,
  Resource: Ko,
  SVGResource: Pb,
  ScissorSystem: Ub,
  Shader: xs,
  ShaderSystem: $b,
  SpriteMaskFilter: rS,
  State: va,
  StateSystem: Vb,
  StencilSystem: jb,
  System: A2,
  Texture: Ot,
  TextureGCSystem: Xb,
  TextureMatrix: n0,
  TextureSystem: Wb,
  TextureUvs: Db,
  UniformGroup: la,
  VERSION: F2,
  VideoResource: Ob,
  ViewableBuffer: yv,
  autoDetectRenderer: qb,
  autoDetectResource: e0,
  checkMaxIfStatementsInShader: eS,
  createUBOElements: sS,
  defaultFilterVertex: Zb,
  defaultVertex: fS,
  extensions: an,
  generateProgram: lS,
  generateUniformBufferSync: oS,
  getTestContext: JE,
  getUBOData: aS,
  resources: gS,
  systems: mS,
  uniformParsers: Wo
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * @pixi/accessibility - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/accessibility is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var U2 = {
  /**
   *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
   *   shadow div with attributes set
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  accessible: !1,
  /**
   * Sets the title attribute of the shadow div
   * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
   * @member {?string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleTitle: null,
  /**
   * Sets the aria-label attribute of the shadow div
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleHint: null,
  /**
   * @member {number}
   * @memberof PIXI.DisplayObject#
   * @private
   * @todo Needs docs.
   */
  tabIndex: 0,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleActive: !1,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleDiv: null,
  /**
   * Specify the type of div the accessible layer is. Screen readers treat the element differently
   * depending on this type. Defaults to button.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'button'
   */
  accessibleType: "button",
  /**
   * Specify the pointer-events the accessible div will use
   * Defaults to auto.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'auto'
   */
  accessiblePointerEvents: "auto",
  /**
   * Setting to false will prevent any children inside this container to
   * be accessible. Defaults to true.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @default true
   */
  accessibleChildren: !0,
  renderId: -1
};
He.mixin(U2);
var j2 = 9, Wd = 100, z2 = 0, H2 = 0, k1 = 2, N1 = 1, $2 = -1e3, V2 = -1e3, X2 = 2, W2 = (
  /** @class */
  function() {
    function i(t) {
      this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (Mn.tablet || Mn.phone) && this.createTouchHook();
      var e = document.createElement("div");
      e.style.width = Wd + "px", e.style.height = Wd + "px", e.style.position = "absolute", e.style.top = z2 + "px", e.style.left = H2 + "px", e.style.zIndex = k1.toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1);
    }
    return Object.defineProperty(i.prototype, "isActive", {
      /**
       * Value of `true` if accessibility is currently active and accessibility layers are showing.
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this._isActive;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "isMobileAccessibility", {
      /**
       * Value of `true` if accessibility is enabled for touch devices.
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this._isMobileAccessibility;
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.createTouchHook = function() {
      var t = this, e = document.createElement("button");
      e.style.width = N1 + "px", e.style.height = N1 + "px", e.style.position = "absolute", e.style.top = $2 + "px", e.style.left = V2 + "px", e.style.zIndex = X2.toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessibility for this content", e.addEventListener("focus", function() {
        t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook();
      }), document.body.appendChild(e), this._hookDiv = e;
    }, i.prototype.destroyTouchHook = function() {
      this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
    }, i.prototype.activate = function() {
      var t;
      this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), (t = this.renderer.view.parentNode) === null || t === void 0 || t.appendChild(this.div));
    }, i.prototype.deactivate = function() {
      var t;
      !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), (t = this.div.parentNode) === null || t === void 0 || t.removeChild(this.div));
    }, i.prototype.updateAccessibleObjects = function(t) {
      if (!(!t.visible || !t.accessibleChildren)) {
        t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);
        var e = t.children;
        if (e)
          for (var r = 0; r < e.length; r++)
            this.updateAccessibleObjects(e[r]);
      }
    }, i.prototype.update = function() {
      var t = performance.now();
      if (!(Mn.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, !!this.renderer.renderingToScreen)) {
        this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);
        var e = this.renderer.view.getBoundingClientRect(), r = e.left, n = e.top, s = e.width, a = e.height, o = this.renderer, u = o.width, l = o.height, h = o.resolution, d = s / u * h, f = a / l * h, p = this.div;
        p.style.left = r + "px", p.style.top = n + "px", p.style.width = u + "px", p.style.height = l + "px";
        for (var v = 0; v < this.children.length; v++) {
          var g = this.children[v];
          if (g.renderId !== this.renderId)
            g._accessibleActive = !1, Lu(this.children, v, 1), this.div.removeChild(g._accessibleDiv), this.pool.push(g._accessibleDiv), g._accessibleDiv = null, v--;
          else {
            p = g._accessibleDiv;
            var m = g.hitArea, y = g.worldTransform;
            g.hitArea ? (p.style.left = (y.tx + m.x * y.a) * d + "px", p.style.top = (y.ty + m.y * y.d) * f + "px", p.style.width = m.width * y.a * d + "px", p.style.height = m.height * y.d * f + "px") : (m = g.getBounds(), this.capHitArea(m), p.style.left = m.x * d + "px", p.style.top = m.y * f + "px", p.style.width = m.width * d + "px", p.style.height = m.height * f + "px", p.title !== g.accessibleTitle && g.accessibleTitle !== null && (p.title = g.accessibleTitle), p.getAttribute("aria-label") !== g.accessibleHint && g.accessibleHint !== null && p.setAttribute("aria-label", g.accessibleHint)), (g.accessibleTitle !== p.title || g.tabIndex !== p.tabIndex) && (p.title = g.accessibleTitle, p.tabIndex = g.tabIndex, this.debug && this.updateDebugHTML(p));
          }
        }
        this.renderId++;
      }
    }, i.prototype.updateDebugHTML = function(t) {
      t.innerHTML = "type: " + t.type + "</br> title : " + t.title + "</br> tabIndex: " + t.tabIndex;
    }, i.prototype.capHitArea = function(t) {
      t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
      var e = this.renderer, r = e.width, n = e.height;
      t.x + t.width > r && (t.width = r - t.x), t.y + t.height > n && (t.height = n - t.y);
    }, i.prototype.addChild = function(t) {
      var e = this.pool.pop();
      e || (e = document.createElement("button"), e.style.width = Wd + "px", e.style.height = Wd + "px", e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = k1.toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = "displayObject " + t.tabIndex), t.accessibleHint && t.accessibleHint !== null && e.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex;
    }, i.prototype._onClick = function(t) {
      var e = this.renderer.plugins.interaction, r = t.target.displayObject, n = e.eventData;
      e.dispatchEvent(r, "click", n), e.dispatchEvent(r, "pointertap", n), e.dispatchEvent(r, "tap", n);
    }, i.prototype._onFocus = function(t) {
      t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive");
      var e = this.renderer.plugins.interaction, r = t.target.displayObject, n = e.eventData;
      e.dispatchEvent(r, "mouseover", n);
    }, i.prototype._onFocusOut = function(t) {
      t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite");
      var e = this.renderer.plugins.interaction, r = t.target.displayObject, n = e.eventData;
      e.dispatchEvent(r, "mouseout", n);
    }, i.prototype._onKeyDown = function(t) {
      t.keyCode === j2 && this.activate();
    }, i.prototype._onMouseMove = function(t) {
      t.movementX === 0 && t.movementY === 0 || this.deactivate();
    }, i.prototype.destroy = function() {
      this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;
    }, i.extension = {
      name: "accessibility",
      type: [
        de.RendererPlugin,
        de.CanvasRendererPlugin
      ]
    }, i;
  }()
);
/*!
 * @pixi/interaction - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var A1 = (
  /** @class */
  function() {
    function i() {
      this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new xe(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;
    }
    return Object.defineProperty(i.prototype, "pointerId", {
      /**
       * The unique identifier of the pointer. It will be the same as `identifier`.
       * @readonly
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
       */
      get: function() {
        return this.identifier;
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.getLocalPosition = function(t, e, r) {
      return t.worldTransform.applyInverse(r || this.global, e);
    }, i.prototype.copyEvent = function(t) {
      "isPrimary" in t && t.isPrimary && (this.isPrimary = !0), this.button = "button" in t && t.button;
      var e = "buttons" in t && t.buttons;
      this.buttons = Number.isInteger(e) ? e : "which" in t && t.which, this.width = "width" in t && t.width, this.height = "height" in t && t.height, this.tiltX = "tiltX" in t && t.tiltX, this.tiltY = "tiltY" in t && t.tiltY, this.pointerType = "pointerType" in t && t.pointerType, this.pressure = "pressure" in t && t.pressure, this.rotationAngle = "rotationAngle" in t && t.rotationAngle, this.twist = "twist" in t && t.twist || 0, this.tangentialPressure = "tangentialPressure" in t && t.tangentialPressure || 0;
    }, i.prototype.reset = function() {
      this.isPrimary = !1;
    }, i;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Sy = function(i, t) {
  return Sy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, Sy(i, t);
};
function Y2(i, t) {
  Sy(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var q2 = (
  /** @class */
  function() {
    function i() {
      this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null;
    }
    return i.prototype.stopPropagation = function() {
      this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget;
    }, i.prototype.reset = function() {
      this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null;
    }, i;
  }()
), z0 = (
  /** @class */
  function() {
    function i(t) {
      this._pointerId = t, this._flags = i.FLAGS.NONE;
    }
    return i.prototype._doSet = function(t, e) {
      e ? this._flags = this._flags | t : this._flags = this._flags & ~t;
    }, Object.defineProperty(i.prototype, "pointerId", {
      /**
       * Unique pointer id of the event
       * @readonly
       * @private
       * @member {number}
       */
      get: function() {
        return this._pointerId;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "flags", {
      /**
       * State of the tracking data, expressed as bit flags
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags;
      },
      set: function(t) {
        this._flags = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "none", {
      /**
       * Is the tracked event inactive (not over or down)?
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags === i.FLAGS.NONE;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "over", {
      /**
       * Is the tracked event over the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & i.FLAGS.OVER) !== 0;
      },
      set: function(t) {
        this._doSet(i.FLAGS.OVER, t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "rightDown", {
      /**
       * Did the right mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & i.FLAGS.RIGHT_DOWN) !== 0;
      },
      set: function(t) {
        this._doSet(i.FLAGS.RIGHT_DOWN, t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "leftDown", {
      /**
       * Did the left mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & i.FLAGS.LEFT_DOWN) !== 0;
      },
      set: function(t) {
        this._doSet(i.FLAGS.LEFT_DOWN, t);
      },
      enumerable: !1,
      configurable: !0
    }), i.FLAGS = Object.freeze({
      NONE: 0,
      OVER: 1 << 0,
      LEFT_DOWN: 1 << 1,
      RIGHT_DOWN: 1 << 2
    }), i;
  }()
), Z2 = (
  /** @class */
  function() {
    function i() {
      this._tempPoint = new xe();
    }
    return i.prototype.recursiveFindHit = function(t, e, r, n, s) {
      var a;
      if (!e || !e.visible)
        return !1;
      var o = t.data.global;
      s = e.interactive || s;
      var u = !1, l = s, h = !0;
      if (e.hitArea)
        n && (e.worldTransform.applyInverse(o, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? u = !0 : (n = !1, h = !1)), l = !1;
      else if (e._mask && n) {
        var d = e._mask.isMaskData ? e._mask.maskObject : e._mask;
        d && !(!((a = d.containsPoint) === null || a === void 0) && a.call(d, o)) && (n = !1);
      }
      if (h && e.interactiveChildren && e.children)
        for (var f = e.children, p = f.length - 1; p >= 0; p--) {
          var v = f[p], g = this.recursiveFindHit(t, v, r, n, l);
          if (g) {
            if (!v.parent)
              continue;
            l = !1, g && (t.target && (n = !1), u = !0);
          }
        }
      return s && (n && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(o) && (u = !0), e.interactive && (u && !t.target && (t.target = e), r && r(t, e, !!u))), u;
    }, i.prototype.findHit = function(t, e, r, n) {
      this.recursiveFindHit(t, e, r, n, !1);
    }, i;
  }()
), K2 = {
  interactive: !1,
  interactiveChildren: !0,
  hitArea: null,
  /**
   * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
   * Setting this changes the 'cursor' property to `'pointer'`.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.buttonMode = true;
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  get buttonMode() {
    return this.cursor === "pointer";
  },
  set buttonMode(i) {
    i ? this.cursor = "pointer" : this.cursor === "pointer" && (this.cursor = null);
  },
  /**
   * This defines what cursor mode is used when the mouse cursor
   * is hovered over the displayObject.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.cursor = 'wait';
   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  cursor: null,
  /**
   * Internal set of all active pointers, by identifier
   * @member {Map<number, InteractionTrackingData>}
   * @memberof PIXI.DisplayObject#
   * @private
   */
  get trackedPointers() {
    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;
  },
  /**
   * Map of all tracked pointers, by identifier. Use trackedPointers to access.
   * @private
   * @type {Map<number, InteractionTrackingData>}
   */
  _trackedPointers: void 0
};
He.mixin(K2);
var Yd = 1, qd = {
  target: null,
  data: {
    global: null
  }
}, J2 = (
  /** @class */
  function(i) {
    Y2(t, i);
    function t(e, r) {
      var n = i.call(this) || this;
      return r = r || {}, n.renderer = e, n.autoPreventDefault = r.autoPreventDefault !== void 0 ? r.autoPreventDefault : !0, n.interactionFrequency = r.interactionFrequency || 10, n.mouse = new A1(), n.mouse.identifier = Yd, n.mouse.global.set(-999999), n.activeInteractionData = {}, n.activeInteractionData[Yd] = n.mouse, n.interactionDataPool = [], n.eventData = new q2(), n.interactionDOMElement = null, n.moveWhenInside = !1, n.eventsAdded = !1, n.tickerAdded = !1, n.mouseOverRenderer = !("PointerEvent" in globalThis), n.supportsTouchEvents = "ontouchstart" in globalThis, n.supportsPointerEvents = !!globalThis.PointerEvent, n.onPointerUp = n.onPointerUp.bind(n), n.processPointerUp = n.processPointerUp.bind(n), n.onPointerCancel = n.onPointerCancel.bind(n), n.processPointerCancel = n.processPointerCancel.bind(n), n.onPointerDown = n.onPointerDown.bind(n), n.processPointerDown = n.processPointerDown.bind(n), n.onPointerMove = n.onPointerMove.bind(n), n.processPointerMove = n.processPointerMove.bind(n), n.onPointerOut = n.onPointerOut.bind(n), n.processPointerOverOut = n.processPointerOverOut.bind(n), n.onPointerOver = n.onPointerOver.bind(n), n.cursorStyles = {
        default: "inherit",
        pointer: "pointer"
      }, n.currentCursorMode = null, n.cursor = null, n.resolution = 1, n.delayedEvents = [], n.search = new Z2(), n._tempDisplayObject = new HE(), n._eventListenerOptions = { capture: !0, passive: !1 }, n._useSystemTicker = r.useSystemTicker !== void 0 ? r.useSystemTicker : !0, n.setTargetElement(n.renderer.view, n.renderer.resolution), n;
    }
    return Object.defineProperty(t.prototype, "useSystemTicker", {
      /**
       * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.
       * @default true
       */
      get: function() {
        return this._useSystemTicker;
      },
      set: function(e) {
        this._useSystemTicker = e, e ? this.addTickerListener() : this.removeTickerListener();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastObjectRendered", {
      /**
       * Last rendered object or temp object.
       * @readonly
       * @protected
       */
      get: function() {
        return this.renderer._lastObjectRendered || this._tempDisplayObject;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.hitTest = function(e, r) {
      return qd.target = null, qd.data.global = e, r || (r = this.lastObjectRendered), this.processInteractive(qd, r, null, !0), qd.target;
    }, t.prototype.setTargetElement = function(e, r) {
      r === void 0 && (r = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = e, this.resolution = r, this.addEvents(), this.addTickerListener();
    }, t.prototype.addTickerListener = function() {
      this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker || (Ge.system.add(this.tickerUpdate, this, Cs.INTERACTION), this.tickerAdded = !0);
    }, t.prototype.removeTickerListener = function() {
      this.tickerAdded && (Ge.system.remove(this.tickerUpdate, this), this.tickerAdded = !1);
    }, t.prototype.addEvents = function() {
      if (!(this.eventsAdded || !this.interactionDOMElement)) {
        var e = this.interactionDOMElement.style;
        globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "none", e.msTouchAction = "none") : this.supportsPointerEvents && (e.touchAction = "none"), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0;
      }
    }, t.prototype.removeEvents = function() {
      if (!(!this.eventsAdded || !this.interactionDOMElement)) {
        var e = this.interactionDOMElement.style;
        globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "", e.msTouchAction = "") : this.supportsPointerEvents && (e.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1;
      }
    }, t.prototype.tickerUpdate = function(e) {
      this._deltaTime += e, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());
    }, t.prototype.update = function() {
      if (this.interactionDOMElement) {
        if (this._didMove) {
          this._didMove = !1;
          return;
        }
        this.cursor = null;
        for (var e in this.activeInteractionData)
          if (this.activeInteractionData.hasOwnProperty(e)) {
            var r = this.activeInteractionData[e];
            if (r.originalEvent && r.pointerType !== "touch") {
              var n = this.configureInteractionEventForDOMEvent(this.eventData, r.originalEvent, r);
              this.processInteractive(n, this.lastObjectRendered, this.processPointerOverOut, !0);
            }
          }
        this.setCursorMode(this.cursor);
      }
    }, t.prototype.setCursorMode = function(e) {
      e = e || "default";
      var r = !0;
      if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (r = !1), this.currentCursorMode !== e) {
        this.currentCursorMode = e;
        var n = this.cursorStyles[e];
        if (n)
          switch (typeof n) {
            case "string":
              r && (this.interactionDOMElement.style.cursor = n);
              break;
            case "function":
              n(e);
              break;
            case "object":
              r && Object.assign(this.interactionDOMElement.style, n);
              break;
          }
        else
          r && typeof e == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.interactionDOMElement.style.cursor = e);
      }
    }, t.prototype.dispatchEvent = function(e, r, n) {
      (!n.stopPropagationHint || e === n.stopsPropagatingAt) && (n.currentTarget = e, n.type = r, e.emit(r, n), e[r] && e[r](n));
    }, t.prototype.delayDispatchEvent = function(e, r, n) {
      this.delayedEvents.push({ displayObject: e, eventString: r, eventData: n });
    }, t.prototype.mapPositionToPoint = function(e, r, n) {
      var s;
      this.interactionDOMElement.parentElement ? s = this.interactionDOMElement.getBoundingClientRect() : s = {
        x: 0,
        y: 0,
        width: this.interactionDOMElement.width,
        height: this.interactionDOMElement.height,
        left: 0,
        top: 0
      };
      var a = 1 / this.resolution;
      e.x = (r - s.left) * (this.interactionDOMElement.width / s.width) * a, e.y = (n - s.top) * (this.interactionDOMElement.height / s.height) * a;
    }, t.prototype.processInteractive = function(e, r, n, s) {
      var a = this.search.findHit(e, r, n, s), o = this.delayedEvents;
      if (!o.length)
        return a;
      e.stopPropagationHint = !1;
      var u = o.length;
      this.delayedEvents = [];
      for (var l = 0; l < u; l++) {
        var h = o[l], d = h.displayObject, f = h.eventString, p = h.eventData;
        p.stopsPropagatingAt === d && (p.stopPropagationHint = !0), this.dispatchEvent(d, f, p);
      }
      return a;
    }, t.prototype.onPointerDown = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var r = this.normalizeToPointerData(e);
        if (this.autoPreventDefault && r[0].isNormalized) {
          var n = e.cancelable || !("cancelable" in e);
          n && e.preventDefault();
        }
        for (var s = r.length, a = 0; a < s; a++) {
          var o = r[a], u = this.getInteractionDataForPointerId(o), l = this.configureInteractionEventForDOMEvent(this.eventData, o, u);
          if (l.data.originalEvent = e, this.processInteractive(l, this.lastObjectRendered, this.processPointerDown, !0), this.emit("pointerdown", l), o.pointerType === "touch")
            this.emit("touchstart", l);
          else if (o.pointerType === "mouse" || o.pointerType === "pen") {
            var h = o.button === 2;
            this.emit(h ? "rightdown" : "mousedown", this.eventData);
          }
        }
      }
    }, t.prototype.processPointerDown = function(e, r, n) {
      var s = e.data, a = e.data.identifier;
      if (n) {
        if (r.trackedPointers[a] || (r.trackedPointers[a] = new z0(a)), this.dispatchEvent(r, "pointerdown", e), s.pointerType === "touch")
          this.dispatchEvent(r, "touchstart", e);
        else if (s.pointerType === "mouse" || s.pointerType === "pen") {
          var o = s.button === 2;
          o ? r.trackedPointers[a].rightDown = !0 : r.trackedPointers[a].leftDown = !0, this.dispatchEvent(r, o ? "rightdown" : "mousedown", e);
        }
      }
    }, t.prototype.onPointerComplete = function(e, r, n) {
      var s = this.normalizeToPointerData(e), a = s.length, o = e.target;
      e.composedPath && e.composedPath().length > 0 && (o = e.composedPath()[0]);
      for (var u = o !== this.interactionDOMElement ? "outside" : "", l = 0; l < a; l++) {
        var h = s[l], d = this.getInteractionDataForPointerId(h), f = this.configureInteractionEventForDOMEvent(this.eventData, h, d);
        if (f.data.originalEvent = e, this.processInteractive(f, this.lastObjectRendered, n, r || !u), this.emit(r ? "pointercancel" : "pointerup" + u, f), h.pointerType === "mouse" || h.pointerType === "pen") {
          var p = h.button === 2;
          this.emit(p ? "rightup" + u : "mouseup" + u, f);
        } else
          h.pointerType === "touch" && (this.emit(r ? "touchcancel" : "touchend" + u, f), this.releaseInteractionDataForPointerId(h.pointerId));
      }
    }, t.prototype.onPointerCancel = function(e) {
      this.supportsTouchEvents && e.pointerType === "touch" || this.onPointerComplete(e, !0, this.processPointerCancel);
    }, t.prototype.processPointerCancel = function(e, r) {
      var n = e.data, s = e.data.identifier;
      r.trackedPointers[s] !== void 0 && (delete r.trackedPointers[s], this.dispatchEvent(r, "pointercancel", e), n.pointerType === "touch" && this.dispatchEvent(r, "touchcancel", e));
    }, t.prototype.onPointerUp = function(e) {
      this.supportsTouchEvents && e.pointerType === "touch" || this.onPointerComplete(e, !1, this.processPointerUp);
    }, t.prototype.processPointerUp = function(e, r, n) {
      var s = e.data, a = e.data.identifier, o = r.trackedPointers[a], u = s.pointerType === "touch", l = s.pointerType === "mouse" || s.pointerType === "pen", h = !1;
      if (l) {
        var d = s.button === 2, f = z0.FLAGS, p = d ? f.RIGHT_DOWN : f.LEFT_DOWN, v = o !== void 0 && o.flags & p;
        n ? (this.dispatchEvent(r, d ? "rightup" : "mouseup", e), v && (this.dispatchEvent(r, d ? "rightclick" : "click", e), h = !0)) : v && this.dispatchEvent(r, d ? "rightupoutside" : "mouseupoutside", e), o && (d ? o.rightDown = !1 : o.leftDown = !1);
      }
      n ? (this.dispatchEvent(r, "pointerup", e), u && this.dispatchEvent(r, "touchend", e), o && ((!l || h) && this.dispatchEvent(r, "pointertap", e), u && (this.dispatchEvent(r, "tap", e), o.over = !1))) : o && (this.dispatchEvent(r, "pointerupoutside", e), u && this.dispatchEvent(r, "touchendoutside", e)), o && o.none && delete r.trackedPointers[a];
    }, t.prototype.onPointerMove = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var r = this.normalizeToPointerData(e);
        (r[0].pointerType === "mouse" || r[0].pointerType === "pen") && (this._didMove = !0, this.cursor = null);
        for (var n = r.length, s = 0; s < n; s++) {
          var a = r[s], o = this.getInteractionDataForPointerId(a), u = this.configureInteractionEventForDOMEvent(this.eventData, a, o);
          u.data.originalEvent = e, this.processInteractive(u, this.lastObjectRendered, this.processPointerMove, !0), this.emit("pointermove", u), a.pointerType === "touch" && this.emit("touchmove", u), (a.pointerType === "mouse" || a.pointerType === "pen") && this.emit("mousemove", u);
        }
        r[0].pointerType === "mouse" && this.setCursorMode(this.cursor);
      }
    }, t.prototype.processPointerMove = function(e, r, n) {
      var s = e.data, a = s.pointerType === "touch", o = s.pointerType === "mouse" || s.pointerType === "pen";
      o && this.processPointerOverOut(e, r, n), (!this.moveWhenInside || n) && (this.dispatchEvent(r, "pointermove", e), a && this.dispatchEvent(r, "touchmove", e), o && this.dispatchEvent(r, "mousemove", e));
    }, t.prototype.onPointerOut = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var r = this.normalizeToPointerData(e), n = r[0];
        n.pointerType === "mouse" && (this.mouseOverRenderer = !1, this.setCursorMode(null));
        var s = this.getInteractionDataForPointerId(n), a = this.configureInteractionEventForDOMEvent(this.eventData, n, s);
        a.data.originalEvent = n, this.processInteractive(a, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit("pointerout", a), n.pointerType === "mouse" || n.pointerType === "pen" ? this.emit("mouseout", a) : this.releaseInteractionDataForPointerId(s.identifier);
      }
    }, t.prototype.processPointerOverOut = function(e, r, n) {
      var s = e.data, a = e.data.identifier, o = s.pointerType === "mouse" || s.pointerType === "pen", u = r.trackedPointers[a];
      n && !u && (u = r.trackedPointers[a] = new z0(a)), u !== void 0 && (n && this.mouseOverRenderer ? (u.over || (u.over = !0, this.delayDispatchEvent(r, "pointerover", e), o && this.delayDispatchEvent(r, "mouseover", e)), o && this.cursor === null && (this.cursor = r.cursor)) : u.over && (u.over = !1, this.dispatchEvent(r, "pointerout", this.eventData), o && this.dispatchEvent(r, "mouseout", e), u.none && delete r.trackedPointers[a]));
    }, t.prototype.onPointerOver = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var r = this.normalizeToPointerData(e), n = r[0], s = this.getInteractionDataForPointerId(n), a = this.configureInteractionEventForDOMEvent(this.eventData, n, s);
        a.data.originalEvent = n, n.pointerType === "mouse" && (this.mouseOverRenderer = !0), this.emit("pointerover", a), (n.pointerType === "mouse" || n.pointerType === "pen") && this.emit("mouseover", a);
      }
    }, t.prototype.getInteractionDataForPointerId = function(e) {
      var r = e.pointerId, n;
      return r === Yd || e.pointerType === "mouse" ? n = this.mouse : this.activeInteractionData[r] ? n = this.activeInteractionData[r] : (n = this.interactionDataPool.pop() || new A1(), n.identifier = r, this.activeInteractionData[r] = n), n.copyEvent(e), n;
    }, t.prototype.releaseInteractionDataForPointerId = function(e) {
      var r = this.activeInteractionData[e];
      r && (delete this.activeInteractionData[e], r.reset(), this.interactionDataPool.push(r));
    }, t.prototype.configureInteractionEventForDOMEvent = function(e, r, n) {
      return e.data = n, this.mapPositionToPoint(n.global, r.clientX, r.clientY), r.pointerType === "touch" && (r.globalX = n.global.x, r.globalY = n.global.y), n.originalEvent = r, e.reset(), e;
    }, t.prototype.normalizeToPointerData = function(e) {
      var r = [];
      if (this.supportsTouchEvents && e instanceof TouchEvent)
        for (var n = 0, s = e.changedTouches.length; n < s; n++) {
          var a = e.changedTouches[n];
          typeof a.button > "u" && (a.button = e.touches.length ? 1 : 0), typeof a.buttons > "u" && (a.buttons = e.touches.length ? 1 : 0), typeof a.isPrimary > "u" && (a.isPrimary = e.touches.length === 1 && e.type === "touchstart"), typeof a.width > "u" && (a.width = a.radiusX || 1), typeof a.height > "u" && (a.height = a.radiusY || 1), typeof a.tiltX > "u" && (a.tiltX = 0), typeof a.tiltY > "u" && (a.tiltY = 0), typeof a.pointerType > "u" && (a.pointerType = "touch"), typeof a.pointerId > "u" && (a.pointerId = a.identifier || 0), typeof a.pressure > "u" && (a.pressure = a.force || 0.5), typeof a.twist > "u" && (a.twist = 0), typeof a.tangentialPressure > "u" && (a.tangentialPressure = 0), typeof a.layerX > "u" && (a.layerX = a.offsetX = a.clientX), typeof a.layerY > "u" && (a.layerY = a.offsetY = a.clientY), a.isNormalized = !0, r.push(a);
        }
      else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {
        var o = e;
        typeof o.isPrimary > "u" && (o.isPrimary = !0), typeof o.width > "u" && (o.width = 1), typeof o.height > "u" && (o.height = 1), typeof o.tiltX > "u" && (o.tiltX = 0), typeof o.tiltY > "u" && (o.tiltY = 0), typeof o.pointerType > "u" && (o.pointerType = "mouse"), typeof o.pointerId > "u" && (o.pointerId = Yd), typeof o.pressure > "u" && (o.pressure = 0.5), typeof o.twist > "u" && (o.twist = 0), typeof o.tangentialPressure > "u" && (o.tangentialPressure = 0), o.isNormalized = !0, r.push(o);
      } else
        r.push(e);
      return r;
    }, t.prototype.destroy = function() {
      this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;
    }, t.extension = {
      name: "interaction",
      type: [
        de.RendererPlugin,
        de.CanvasRendererPlugin
      ]
    }, t;
  }(Pi)
);
/*!
 * @pixi/extract - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Q2 = new Nt(), tk = 4, ek = (
  /** @class */
  function() {
    function i(t) {
      this.renderer = t;
    }
    return i.prototype.image = function(t, e, r) {
      var n = new Image();
      return n.src = this.base64(t, e, r), n;
    }, i.prototype.base64 = function(t, e, r) {
      return this.canvas(t).toDataURL(e, r);
    }, i.prototype.canvas = function(t, e) {
      var r = this._rawPixels(t, e), n = r.pixels, s = r.width, a = r.height, o = r.flipY, u = new _1(s, a, 1), l = u.context.getImageData(0, 0, s, a);
      if (i.arrayPostDivide(n, l.data), u.context.putImageData(l, 0, 0), o) {
        var h = new _1(u.width, u.height, 1);
        h.context.scale(1, -1), h.context.drawImage(u.canvas, 0, -a), u.destroy(), u = h;
      }
      return u.canvas;
    }, i.prototype.pixels = function(t, e) {
      var r = this._rawPixels(t, e).pixels;
      return i.arrayPostDivide(r, r), r;
    }, i.prototype._rawPixels = function(t, e) {
      var r = this.renderer, n, s = !1, a, o = !1;
      if (t)
        if (t instanceof Ei)
          a = t;
        else {
          var u = r.context.webGLVersion >= 2 ? r.multisample : ke.NONE;
          if (a = this.renderer.generateTexture(t, { multisample: u }), u !== ke.NONE) {
            var l = Ei.create({
              width: a.width,
              height: a.height
            });
            r.framebuffer.bind(a.framebuffer), r.framebuffer.blit(l.framebuffer), r.framebuffer.bind(null), a.destroy(!0), a = l;
          }
          o = !0;
        }
      a ? (n = a.baseTexture.resolution, e = e ?? a.frame, s = !1, r.renderTexture.bind(a)) : (n = r.resolution, e || (e = Q2, e.width = r.width, e.height = r.height), s = !0, r.renderTexture.bind(null));
      var h = Math.round(e.width * n), d = Math.round(e.height * n), f = new Uint8Array(tk * h * d), p = r.gl;
      return p.readPixels(Math.round(e.x * n), Math.round(e.y * n), h, d, p.RGBA, p.UNSIGNED_BYTE, f), o && a.destroy(!0), { pixels: f, width: h, height: d, flipY: s };
    }, i.prototype.destroy = function() {
      this.renderer = null;
    }, i.arrayPostDivide = function(t, e) {
      for (var r = 0; r < t.length; r += 4) {
        var n = e[r + 3] = t[r + 3];
        n !== 0 ? (e[r] = Math.round(Math.min(t[r] * 255 / n, 255)), e[r + 1] = Math.round(Math.min(t[r + 1] * 255 / n, 255)), e[r + 2] = Math.round(Math.min(t[r + 2] * 255 / n, 255))) : (e[r] = t[r], e[r + 1] = t[r + 1], e[r + 2] = t[r + 2]);
      }
    }, i.extension = {
      name: "extract",
      type: de.RendererPlugin
    }, i;
  }()
);
/*!
 * @pixi/loaders - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Zd = (
  /** @class */
  function() {
    function i(t, e, r) {
      e === void 0 && (e = !1), this._fn = t, this._once = e, this._thisArg = r, this._next = this._prev = this._owner = null;
    }
    return i.prototype.detach = function() {
      return this._owner === null ? !1 : (this._owner.detach(this), !0);
    }, i;
  }()
);
function L1(i, t) {
  return i._head ? (i._tail._next = t, t._prev = i._tail, i._tail = t) : (i._head = t, i._tail = t), t._owner = i, t;
}
var _s = (
  /** @class */
  function() {
    function i() {
      this._head = this._tail = void 0;
    }
    return i.prototype.handlers = function(t) {
      t === void 0 && (t = !1);
      var e = this._head;
      if (t)
        return !!e;
      for (var r = []; e; )
        r.push(e), e = e._next;
      return r;
    }, i.prototype.has = function(t) {
      if (!(t instanceof Zd))
        throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
      return t._owner === this;
    }, i.prototype.dispatch = function() {
      for (var t = arguments, e = [], r = 0; r < arguments.length; r++)
        e[r] = t[r];
      var n = this._head;
      if (!n)
        return !1;
      for (; n; )
        n._once && this.detach(n), n._fn.apply(n._thisArg, e), n = n._next;
      return !0;
    }, i.prototype.add = function(t, e) {
      if (e === void 0 && (e = null), typeof t != "function")
        throw new Error("MiniSignal#add(): First arg must be a Function.");
      return L1(this, new Zd(t, !1, e));
    }, i.prototype.once = function(t, e) {
      if (e === void 0 && (e = null), typeof t != "function")
        throw new Error("MiniSignal#once(): First arg must be a Function.");
      return L1(this, new Zd(t, !0, e));
    }, i.prototype.detach = function(t) {
      if (!(t instanceof Zd))
        throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
      return t._owner !== this ? this : (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, t._next === null && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null, this);
    }, i.prototype.detachAll = function() {
      var t = this._head;
      if (!t)
        return this;
      for (this._head = this._tail = null; t; )
        t._owner = null, t = t._next;
      return this;
    }, i;
  }()
);
function yS(i, t) {
  t = t || {};
  for (var e = {
    // eslint-disable-next-line max-len
    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
    q: {
      name: "queryKey",
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      // eslint-disable-next-line max-len
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      // eslint-disable-next-line max-len
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  }, r = e.parser[t.strictMode ? "strict" : "loose"].exec(i), n = {}, s = 14; s--; )
    n[e.key[s]] = r[s] || "";
  return n[e.q.name] = {}, n[e.key[12]].replace(e.q.parser, function(a, o, u) {
    o && (n[e.q.name][o] = u);
  }), n;
}
var H0, Kd = null, rk = 0, B1 = 200, ik = 204, nk = 1223, sk = 2;
function F1() {
}
function G1(i, t, e) {
  t && t.indexOf(".") === 0 && (t = t.substring(1)), t && (i[t] = e);
}
function $0(i) {
  return i.toString().replace("object ", "");
}
var Ft = (
  /** @class */
  function() {
    function i(t, e, r) {
      if (this._dequeue = F1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof t != "string" || typeof e != "string")
        throw new Error("Both name and url are required for constructing a resource.");
      r = r || {}, this._flags = 0, this._setFlag(i.STATUS_FLAGS.DATA_URL, e.indexOf("data:") === 0), this.name = t, this.url = e, this.extension = this._getExtension(), this.data = null, this.crossOrigin = r.crossOrigin === !0 ? "anonymous" : r.crossOrigin, this.timeout = r.timeout || 0, this.loadType = r.loadType || this._determineLoadType(), this.xhrType = r.xhrType, this.metadata = r.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = i.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = F1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new _s(), this.onProgress = new _s(), this.onComplete = new _s(), this.onAfterMiddleware = new _s();
    }
    return i.setExtensionLoadType = function(t, e) {
      G1(i._loadTypeMap, t, e);
    }, i.setExtensionXhrType = function(t, e) {
      G1(i._xhrTypeMap, t, e);
    }, Object.defineProperty(i.prototype, "isDataUrl", {
      /**
       * When the resource starts to load.
       * @memberof PIXI.LoaderResource
       * @callback OnStartSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       */
      /**
       * When the resource reports loading progress.
       * @memberof PIXI.LoaderResource
       * @callback OnProgressSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       * @param {number} percentage - The progress of the load in the range [0, 1].
       */
      /**
       * When the resource finishes loading.
       * @memberof PIXI.LoaderResource
       * @callback OnCompleteSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       */
      /**
       * @memberof PIXI.LoaderResource
       * @typedef {object} IMetadata
       * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
       *      element to use for loading, instead of creating one.
       * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
       *      is useful if you want to pass in a `loadElement` that you already added load sources to.
       * @property {string|string[]} [mimeType] - The mime type to use for the source element
       *      of a video/audio elment. If the urls are an array, you can pass this as an array as well
       *      where each index is the mime type to use for the corresponding url index.
       */
      /**
       * Stores whether or not this url is a data url.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(i.STATUS_FLAGS.DATA_URL);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "isComplete", {
      /**
       * Describes if this resource has finished loading. Is true when the resource has completely
       * loaded.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(i.STATUS_FLAGS.COMPLETE);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "isLoading", {
      /**
       * Describes if this resource is currently loading. Is true when the resource starts loading,
       * and is false again when complete.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(i.STATUS_FLAGS.LOADING);
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.complete = function() {
      this._clearEvents(), this._finish();
    }, i.prototype.abort = function(t) {
      if (!this.error) {
        if (this.error = new Error(t), this._clearEvents(), this.xhr)
          this.xhr.abort();
        else if (this.xdr)
          this.xdr.abort();
        else if (this.data)
          if (this.data.src)
            this.data.src = i.EMPTY_GIF;
          else
            for (; this.data.firstChild; )
              this.data.removeChild(this.data.firstChild);
        this._finish();
      }
    }, i.prototype.load = function(t) {
      var e = this;
      if (!this.isLoading) {
        if (this.isComplete) {
          t && setTimeout(function() {
            return t(e);
          }, 1);
          return;
        } else
          t && this.onComplete.once(t);
        switch (this._setFlag(i.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), (this.crossOrigin === !1 || typeof this.crossOrigin != "string") && (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
          case i.LOAD_TYPE.IMAGE:
            this.type = i.TYPE.IMAGE, this._loadElement("image");
            break;
          case i.LOAD_TYPE.AUDIO:
            this.type = i.TYPE.AUDIO, this._loadSourceElement("audio");
            break;
          case i.LOAD_TYPE.VIDEO:
            this.type = i.TYPE.VIDEO, this._loadSourceElement("video");
            break;
          case i.LOAD_TYPE.XHR:
          default:
            typeof H0 > "u" && (H0 = !!(globalThis.XDomainRequest && !("withCredentials" in new XMLHttpRequest()))), H0 && this.crossOrigin ? this._loadXdr() : this._loadXhr();
            break;
        }
      }
    }, i.prototype._hasFlag = function(t) {
      return (this._flags & t) !== 0;
    }, i.prototype._setFlag = function(t, e) {
      this._flags = e ? this._flags | t : this._flags & ~t;
    }, i.prototype._clearEvents = function() {
      clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));
    }, i.prototype._finish = function() {
      if (this.isComplete)
        throw new Error("Complete called again for an already completed resource.");
      this._setFlag(i.STATUS_FLAGS.COMPLETE, !0), this._setFlag(i.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this);
    }, i.prototype._loadElement = function(t) {
      this.metadata.loadElement ? this.data = this.metadata.loadElement : t === "image" && typeof globalThis.Image < "u" ? this.data = new Image() : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
    }, i.prototype._loadSourceElement = function(t) {
      if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t === "audio" && typeof globalThis.Audio < "u" ? this.data = new Audio() : this.data = document.createElement(t), this.data === null) {
        this.abort("Unsupported element: " + t);
        return;
      }
      if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)
        if (navigator.isCocoonJS)
          this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
        else if (Array.isArray(this.url))
          for (var e = this.metadata.mimeType, r = 0; r < this.url.length; ++r)
            this.data.appendChild(this._createSource(t, this.url[r], Array.isArray(e) ? e[r] : e));
        else {
          var e = this.metadata.mimeType;
          this.data.appendChild(this._createSource(t, this.url, Array.isArray(e) ? e[0] : e));
        }
      this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
    }, i.prototype._loadXhr = function() {
      typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
      var t = this.xhr = new XMLHttpRequest();
      this.crossOrigin === "use-credentials" && (t.withCredentials = !0), t.open("GET", this.url, !0), t.timeout = this.timeout, this.xhrType === i.XHR_RESPONSE_TYPE.JSON || this.xhrType === i.XHR_RESPONSE_TYPE.DOCUMENT ? t.responseType = i.XHR_RESPONSE_TYPE.TEXT : t.responseType = this.xhrType, t.addEventListener("error", this._boundXhrOnError, !1), t.addEventListener("timeout", this._boundXhrOnTimeout, !1), t.addEventListener("abort", this._boundXhrOnAbort, !1), t.addEventListener("progress", this._boundOnProgress, !1), t.addEventListener("load", this._boundXhrOnLoad, !1), t.send();
    }, i.prototype._loadXdr = function() {
      typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
      var t = this.xhr = new globalThis.XDomainRequest();
      t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open("GET", this.url, !0), setTimeout(function() {
        return t.send();
      }, 1);
    }, i.prototype._createSource = function(t, e, r) {
      r || (r = t + "/" + this._getExtension(e));
      var n = document.createElement("source");
      return n.src = e, n.type = r, n;
    }, i.prototype._onError = function(t) {
      this.abort("Failed to load element using: " + t.target.nodeName);
    }, i.prototype._onProgress = function(t) {
      t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total);
    }, i.prototype._onTimeout = function() {
      this.abort("Load timed out.");
    }, i.prototype._xhrOnError = function() {
      var t = this.xhr;
      this.abort($0(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"');
    }, i.prototype._xhrOnTimeout = function() {
      var t = this.xhr;
      this.abort($0(t) + " Request timed out.");
    }, i.prototype._xhrOnAbort = function() {
      var t = this.xhr;
      this.abort($0(t) + " Request was aborted by the user.");
    }, i.prototype._xhrOnLoad = function() {
      var t = this.xhr, e = "", r = typeof t.status > "u" ? B1 : t.status;
      (t.responseType === "" || t.responseType === "text" || typeof t.responseType > "u") && (e = t.responseText), r === rk && (e.length > 0 || t.responseType === i.XHR_RESPONSE_TYPE.BUFFER) ? r = B1 : r === nk && (r = ik);
      var n = r / 100 | 0;
      if (n === sk)
        if (this.xhrType === i.XHR_RESPONSE_TYPE.TEXT)
          this.data = e, this.type = i.TYPE.TEXT;
        else if (this.xhrType === i.XHR_RESPONSE_TYPE.JSON)
          try {
            this.data = JSON.parse(e), this.type = i.TYPE.JSON;
          } catch (o) {
            this.abort("Error trying to parse loaded json: " + o);
            return;
          }
        else if (this.xhrType === i.XHR_RESPONSE_TYPE.DOCUMENT)
          try {
            if (globalThis.DOMParser) {
              var s = new DOMParser();
              this.data = s.parseFromString(e, "text/xml");
            } else {
              var a = document.createElement("div");
              a.innerHTML = e, this.data = a;
            }
            this.type = i.TYPE.XML;
          } catch (o) {
            this.abort("Error trying to parse loaded xml: " + o);
            return;
          }
        else
          this.data = t.response || e;
      else {
        this.abort("[" + t.status + "] " + t.statusText + ": " + t.responseURL);
        return;
      }
      this.complete();
    }, i.prototype._determineCrossOrigin = function(t, e) {
      if (t.indexOf("data:") === 0)
        return "";
      if (globalThis.origin !== globalThis.location.origin)
        return "anonymous";
      e = e || globalThis.location, Kd || (Kd = document.createElement("a")), Kd.href = t;
      var r = yS(Kd.href, { strictMode: !0 }), n = !r.port && e.port === "" || r.port === e.port, s = r.protocol ? r.protocol + ":" : "";
      return r.host !== e.hostname || !n || s !== e.protocol ? "anonymous" : "";
    }, i.prototype._determineXhrType = function() {
      return i._xhrTypeMap[this.extension] || i.XHR_RESPONSE_TYPE.TEXT;
    }, i.prototype._determineLoadType = function() {
      return i._loadTypeMap[this.extension] || i.LOAD_TYPE.XHR;
    }, i.prototype._getExtension = function(t) {
      t === void 0 && (t = this.url);
      var e = "";
      if (this.isDataUrl) {
        var r = t.indexOf("/");
        e = t.substring(r + 1, t.indexOf(";", r));
      } else {
        var n = t.indexOf("?"), s = t.indexOf("#"), a = Math.min(n > -1 ? n : t.length, s > -1 ? s : t.length);
        t = t.substring(0, a), e = t.substring(t.lastIndexOf(".") + 1);
      }
      return e.toLowerCase();
    }, i.prototype._getMimeFromXhrType = function(t) {
      switch (t) {
        case i.XHR_RESPONSE_TYPE.BUFFER:
          return "application/octet-binary";
        case i.XHR_RESPONSE_TYPE.BLOB:
          return "application/blob";
        case i.XHR_RESPONSE_TYPE.DOCUMENT:
          return "application/xml";
        case i.XHR_RESPONSE_TYPE.JSON:
          return "application/json";
        case i.XHR_RESPONSE_TYPE.DEFAULT:
        case i.XHR_RESPONSE_TYPE.TEXT:
        default:
          return "text/plain";
      }
    }, i;
  }()
);
(function(i) {
  (function(t) {
    t[t.NONE = 0] = "NONE", t[t.DATA_URL = 1] = "DATA_URL", t[t.COMPLETE = 2] = "COMPLETE", t[t.LOADING = 4] = "LOADING";
  })(i.STATUS_FLAGS || (i.STATUS_FLAGS = {})), function(t) {
    t[t.UNKNOWN = 0] = "UNKNOWN", t[t.JSON = 1] = "JSON", t[t.XML = 2] = "XML", t[t.IMAGE = 3] = "IMAGE", t[t.AUDIO = 4] = "AUDIO", t[t.VIDEO = 5] = "VIDEO", t[t.TEXT = 6] = "TEXT";
  }(i.TYPE || (i.TYPE = {})), function(t) {
    t[t.XHR = 1] = "XHR", t[t.IMAGE = 2] = "IMAGE", t[t.AUDIO = 3] = "AUDIO", t[t.VIDEO = 4] = "VIDEO";
  }(i.LOAD_TYPE || (i.LOAD_TYPE = {})), function(t) {
    t.DEFAULT = "text", t.BUFFER = "arraybuffer", t.BLOB = "blob", t.DOCUMENT = "document", t.JSON = "json", t.TEXT = "text";
  }(i.XHR_RESPONSE_TYPE || (i.XHR_RESPONSE_TYPE = {})), i._loadTypeMap = {
    // images
    gif: i.LOAD_TYPE.IMAGE,
    png: i.LOAD_TYPE.IMAGE,
    bmp: i.LOAD_TYPE.IMAGE,
    jpg: i.LOAD_TYPE.IMAGE,
    jpeg: i.LOAD_TYPE.IMAGE,
    tif: i.LOAD_TYPE.IMAGE,
    tiff: i.LOAD_TYPE.IMAGE,
    webp: i.LOAD_TYPE.IMAGE,
    tga: i.LOAD_TYPE.IMAGE,
    avif: i.LOAD_TYPE.IMAGE,
    svg: i.LOAD_TYPE.IMAGE,
    "svg+xml": i.LOAD_TYPE.IMAGE,
    // audio
    mp3: i.LOAD_TYPE.AUDIO,
    ogg: i.LOAD_TYPE.AUDIO,
    wav: i.LOAD_TYPE.AUDIO,
    // videos
    mp4: i.LOAD_TYPE.VIDEO,
    webm: i.LOAD_TYPE.VIDEO
  }, i._xhrTypeMap = {
    // xml
    xhtml: i.XHR_RESPONSE_TYPE.DOCUMENT,
    html: i.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: i.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: i.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: i.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: i.XHR_RESPONSE_TYPE.DOCUMENT,
    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
    // this should probably be fine.
    tsx: i.XHR_RESPONSE_TYPE.DOCUMENT,
    // images
    gif: i.XHR_RESPONSE_TYPE.BLOB,
    png: i.XHR_RESPONSE_TYPE.BLOB,
    bmp: i.XHR_RESPONSE_TYPE.BLOB,
    jpg: i.XHR_RESPONSE_TYPE.BLOB,
    jpeg: i.XHR_RESPONSE_TYPE.BLOB,
    tif: i.XHR_RESPONSE_TYPE.BLOB,
    tiff: i.XHR_RESPONSE_TYPE.BLOB,
    webp: i.XHR_RESPONSE_TYPE.BLOB,
    tga: i.XHR_RESPONSE_TYPE.BLOB,
    avif: i.XHR_RESPONSE_TYPE.BLOB,
    // json
    json: i.XHR_RESPONSE_TYPE.JSON,
    // text
    text: i.XHR_RESPONSE_TYPE.TEXT,
    txt: i.XHR_RESPONSE_TYPE.TEXT,
    // fonts
    ttf: i.XHR_RESPONSE_TYPE.BUFFER,
    otf: i.XHR_RESPONSE_TYPE.BUFFER
  }, i.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
})(Ft || (Ft = {}));
function _a() {
}
function ak(i) {
  return function() {
    for (var e = arguments, r = [], n = 0; n < arguments.length; n++)
      r[n] = e[n];
    if (i === null)
      throw new Error("Callback was already called.");
    var s = i;
    i = null, s.apply(this, r);
  };
}
var ok = (
  /** @class */
  function() {
    function i(t, e) {
      this.data = t, this.callback = e;
    }
    return i;
  }()
), V0 = (
  /** @class */
  function() {
    function i(t, e) {
      var r = this;
      if (e === void 0 && (e = 1), this.workers = 0, this.saturated = _a, this.unsaturated = _a, this.empty = _a, this.drain = _a, this.error = _a, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function(n, s, a) {
        if (a && typeof a != "function")
          throw new Error("task callback must be a function");
        if (r.started = !0, n == null && r.idle()) {
          setTimeout(function() {
            return r.drain();
          }, 1);
          return;
        }
        var o = new ok(n, typeof a == "function" ? a : _a);
        s ? r._tasks.unshift(o) : r._tasks.push(o), setTimeout(r.process, 1);
      }, this.process = function() {
        for (; !r.paused && r.workers < r.concurrency && r._tasks.length; ) {
          var n = r._tasks.shift();
          r._tasks.length === 0 && r.empty(), r.workers += 1, r.workers === r.concurrency && r.saturated(), r._worker(n.data, ak(r._next(n)));
        }
      }, this._worker = t, e === 0)
        throw new Error("Concurrency must not be zero");
      this.concurrency = e, this.buffer = e / 4;
    }
    return i.prototype._next = function(t) {
      var e = this;
      return function() {
        for (var r = arguments, n = [], s = 0; s < arguments.length; s++)
          n[s] = r[s];
        e.workers -= 1, t.callback.apply(t, n), n[0] != null && e.error(n[0], t.data), e.workers <= e.concurrency - e.buffer && e.unsaturated(), e.idle() && e.drain(), e.process();
      };
    }, i.prototype.push = function(t, e) {
      this._insert(t, !1, e);
    }, i.prototype.kill = function() {
      this.workers = 0, this.drain = _a, this.started = !1, this._tasks = [];
    }, i.prototype.unshift = function(t, e) {
      this._insert(t, !0, e);
    }, i.prototype.length = function() {
      return this._tasks.length;
    }, i.prototype.running = function() {
      return this.workers;
    }, i.prototype.idle = function() {
      return this._tasks.length + this.workers === 0;
    }, i.prototype.pause = function() {
      this.paused !== !0 && (this.paused = !0);
    }, i.prototype.resume = function() {
      if (this.paused !== !1) {
        this.paused = !1;
        for (var t = 1; t <= this.concurrency; t++)
          this.process();
      }
    }, i.eachSeries = function(t, e, r, n) {
      var s = 0, a = t.length;
      function o(u) {
        if (u || s === a) {
          r && r(u);
          return;
        }
        n ? setTimeout(function() {
          e(t[s++], o);
        }, 1) : e(t[s++], o);
      }
      o();
    }, i.queue = function(t, e) {
      return new i(t, e);
    }, i;
  }()
), X0 = 100, uk = /(#[\w-]+)?$/, ri = (
  /** @class */
  function() {
    function i(t, e) {
      var r = this;
      t === void 0 && (t = ""), e === void 0 && (e = 10), this.progress = 0, this.loading = !1, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(u, l) {
        return r._loadResource(u, l);
      }, this.resources = {}, this.baseUrl = t, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(u, l) {
        return r._loadResource(u, l);
      }, this._queue = V0.queue(this._boundLoadResource, e), this._queue.pause(), this.resources = {}, this.onProgress = new _s(), this.onError = new _s(), this.onLoad = new _s(), this.onStart = new _s(), this.onComplete = new _s();
      for (var n = 0; n < i._plugins.length; ++n) {
        var s = i._plugins[n], a = s.pre, o = s.use;
        a && this.pre(a), o && this.use(o);
      }
      this._protected = !1;
    }
    return i.prototype._add = function(t, e, r, n) {
      if (this.loading && (!r || !r.parentResource))
        throw new Error("Cannot add resources while the loader is running.");
      if (this.resources[t])
        throw new Error('Resource named "' + t + '" already exists.');
      if (e = this._prepareUrl(e), this.resources[t] = new Ft(t, e, r), typeof n == "function" && this.resources[t].onAfterMiddleware.once(n), this.loading) {
        for (var s = r.parentResource, a = [], o = 0; o < s.children.length; ++o)
          s.children[o].isComplete || a.push(s.children[o]);
        var u = s.progressChunk * (a.length + 1), l = u / (a.length + 2);
        s.children.push(this.resources[t]), s.progressChunk = l;
        for (var o = 0; o < a.length; ++o)
          a[o].progressChunk = l;
        this.resources[t].progressChunk = l;
      }
      return this._queue.push(this.resources[t]), this;
    }, i.prototype.pre = function(t) {
      return this._beforeMiddleware.push(t), this;
    }, i.prototype.use = function(t) {
      return this._afterMiddleware.push(t), this;
    }, i.prototype.reset = function() {
      this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause();
      for (var t in this.resources) {
        var e = this.resources[t];
        e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort("loader reset");
      }
      return this.resources = {}, this;
    }, i.prototype.load = function(t) {
      if (jr("6.5.0", "@pixi/loaders is being replaced with @pixi/assets in the next major release."), typeof t == "function" && this.onComplete.once(t), this.loading)
        return this;
      if (this._queue.idle())
        this._onStart(), this._onComplete();
      else {
        for (var e = this._queue._tasks.length, r = X0 / e, n = 0; n < this._queue._tasks.length; ++n)
          this._queue._tasks[n].data.progressChunk = r;
        this._onStart(), this._queue.resume();
      }
      return this;
    }, Object.defineProperty(i.prototype, "concurrency", {
      /**
       * The number of resources to load concurrently.
       * @default 10
       */
      get: function() {
        return this._queue.concurrency;
      },
      set: function(t) {
        this._queue.concurrency = t;
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype._prepareUrl = function(t) {
      var e = yS(t, { strictMode: !0 }), r;
      if (e.protocol || !e.path || t.indexOf("//") === 0 ? r = t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && t.charAt(0) !== "/" ? r = this.baseUrl + "/" + t : r = this.baseUrl + t, this.defaultQueryString) {
        var n = uk.exec(r)[0];
        r = r.slice(0, r.length - n.length), r.indexOf("?") !== -1 ? r += "&" + this.defaultQueryString : r += "?" + this.defaultQueryString, r += n;
      }
      return r;
    }, i.prototype._loadResource = function(t, e) {
      var r = this;
      t._dequeue = e, V0.eachSeries(this._beforeMiddleware, function(n, s) {
        n.call(r, t, function() {
          s(t.isComplete ? {} : null);
        });
      }, function() {
        t.isComplete ? r._onLoad(t) : (t._onLoadBinding = t.onComplete.once(r._onLoad, r), t.load());
      }, !0);
    }, i.prototype._onStart = function() {
      this.progress = 0, this.loading = !0, this.onStart.dispatch(this);
    }, i.prototype._onComplete = function() {
      this.progress = X0, this.loading = !1, this.onComplete.dispatch(this, this.resources);
    }, i.prototype._onLoad = function(t) {
      var e = this;
      t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), V0.eachSeries(this._afterMiddleware, function(r, n) {
        r.call(e, t, n);
      }, function() {
        t.onAfterMiddleware.dispatch(t), e.progress = Math.min(X0, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && e._resourcesParsing.length === 0 && e._onComplete();
      }, !0);
    }, i.prototype.destroy = function() {
      this._protected || this.reset();
    }, Object.defineProperty(i, "shared", {
      /** A premade instance of the loader that can be used to load resources. */
      get: function() {
        var t = i._shared;
        return t || (t = new i(), t._protected = !0, i._shared = t), t;
      },
      enumerable: !1,
      configurable: !0
    }), i.registerPlugin = function(t) {
      return jr("6.5.0", "Loader.registerPlugin() is deprecated, use extensions.add() instead."), an.add({
        type: de.Loader,
        ref: t
      }), i;
    }, i._plugins = [], i;
  }()
);
an.handleByList(de.Loader, ri._plugins);
ri.prototype.add = function(t, e, r, n) {
  if (Array.isArray(t)) {
    for (var s = 0; s < t.length; ++s)
      this.add(t[s]);
    return this;
  }
  if (typeof t == "object" && (r = t, n = e || r.callback || r.onComplete, e = r.url, t = r.name || r.key || r.url), typeof e != "string" && (n = r, r = e, e = t), typeof e != "string")
    throw new Error("No url passed to add resource to loader.");
  return typeof r == "function" && (n = r, r = null), this._add(t, e, r, n);
};
var lk = (
  /** @class */
  function() {
    function i() {
    }
    return i.init = function(t) {
      t = Object.assign({
        sharedLoader: !1
      }, t), this.loader = t.sharedLoader ? ri.shared : new ri();
    }, i.destroy = function() {
      this.loader && (this.loader.destroy(), this.loader = null);
    }, i.extension = de.Application, i;
  }()
), hk = (
  /** @class */
  function() {
    function i() {
    }
    return i.add = function() {
      Ft.setExtensionLoadType("svg", Ft.LOAD_TYPE.XHR), Ft.setExtensionXhrType("svg", Ft.XHR_RESPONSE_TYPE.TEXT);
    }, i.use = function(t, e) {
      if (t.data && (t.type === Ft.TYPE.IMAGE || t.extension === "svg")) {
        var r = t.data, n = t.url, s = t.name, a = t.metadata;
        Ot.fromLoader(r, n, s, a).then(function(o) {
          t.texture = o, e();
        }).catch(e);
      } else
        e();
    }, i.extension = de.Loader, i;
  }()
), ck = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function fk(i) {
  for (var t = "", e = 0; e < i.length; ) {
    for (var r = [0, 0, 0], n = [0, 0, 0, 0], s = 0; s < r.length; ++s)
      e < i.length ? r[s] = i.charCodeAt(e++) & 255 : r[s] = 0;
    n[0] = r[0] >> 2, n[1] = (r[0] & 3) << 4 | r[1] >> 4, n[2] = (r[1] & 15) << 2 | r[2] >> 6, n[3] = r[2] & 63;
    var a = e - (i.length - 1);
    switch (a) {
      case 2:
        n[3] = 64, n[2] = 64;
        break;
      case 1:
        n[3] = 64;
        break;
    }
    for (var s = 0; s < n.length; ++s)
      t += ck.charAt(n[s]);
  }
  return t;
}
function dk(i, t) {
  if (!i.data) {
    t();
    return;
  }
  if (i.xhr && i.xhrType === Ft.XHR_RESPONSE_TYPE.BLOB) {
    if (!self.Blob || typeof i.data == "string") {
      var e = i.xhr.getResponseHeader("content-type");
      if (e && e.indexOf("image") === 0) {
        i.data = new Image(), i.data.src = "data:" + e + ";base64," + fk(i.xhr.responseText), i.type = Ft.TYPE.IMAGE, i.data.onload = function() {
          i.data.onload = null, t();
        };
        return;
      }
    } else if (i.data.type.indexOf("image") === 0) {
      var r = globalThis.URL || globalThis.webkitURL, n = r.createObjectURL(i.data);
      i.blob = i.data, i.data = new Image(), i.data.src = n, i.type = Ft.TYPE.IMAGE, i.data.onload = function() {
        r.revokeObjectURL(n), i.data.onload = null, t();
      };
      return;
    }
  }
  t();
}
var pk = (
  /** @class */
  function() {
    function i() {
    }
    return i.extension = de.Loader, i.use = dk, i;
  }()
);
an.add(hk, pk);
/*!
 * @pixi/compressed-textures - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/compressed-textures is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var he, jt;
(function(i) {
  i[i.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", i[i.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", i[i.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", i[i.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", i[i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", i[i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", i[i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", i[i.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", i[i.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", i[i.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", i[i.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", i[i.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", i[i.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", i[i.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", i[i.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", i[i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", i[i.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", i[i.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", i[i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", i[i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", i[i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", i[i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", i[i.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", i[i.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", i[i.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", i[i.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", i[i.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
})(jt || (jt = {}));
var _v = (he = {}, // WEBGL_compressed_texture_s3tc
he[jt.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, he[jt.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, he[jt.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, he[jt.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_s3tc
he[jt.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, he[jt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, he[jt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, he[jt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_etc
he[jt.COMPRESSED_R11_EAC] = 0.5, he[jt.COMPRESSED_SIGNED_R11_EAC] = 0.5, he[jt.COMPRESSED_RG11_EAC] = 1, he[jt.COMPRESSED_SIGNED_RG11_EAC] = 1, he[jt.COMPRESSED_RGB8_ETC2] = 0.5, he[jt.COMPRESSED_RGBA8_ETC2_EAC] = 1, he[jt.COMPRESSED_SRGB8_ETC2] = 0.5, he[jt.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, he[jt.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, he[jt.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, // WEBGL_compressed_texture_pvrtc
he[jt.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, he[jt.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, he[jt.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, he[jt.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, // WEBGL_compressed_texture_etc1
he[jt.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, // @see https://www.khronos.org/registry/OpenGL/extensions/AMD/AMD_compressed_ATC_texture.txt
// WEBGL_compressed_texture_atc
he[jt.COMPRESSED_RGB_ATC_WEBGL] = 0.5, he[jt.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, he[jt.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, // @see https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt
// WEBGL_compressed_texture_astc
/* eslint-disable-next-line camelcase */
he[jt.COMPRESSED_RGBA_ASTC_4x4_KHR] = 1, he);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ty = function(i, t) {
  return Ty = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, Ty(i, t);
};
function _S(i, t) {
  Ty(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function vk(i, t, e, r) {
  function n(s) {
    return s instanceof e ? s : new e(function(a) {
      a(s);
    });
  }
  return new (e || (e = Promise))(function(s, a) {
    function o(h) {
      try {
        l(r.next(h));
      } catch (d) {
        a(d);
      }
    }
    function u(h) {
      try {
        l(r.throw(h));
      } catch (d) {
        a(d);
      }
    }
    function l(h) {
      h.done ? s(h.value) : n(h.value).then(o, u);
    }
    l((r = r.apply(i, t || [])).next());
  });
}
function gk(i, t) {
  var e = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, n, s, a;
  return a = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(l) {
    return function(h) {
      return u([l, h]);
    };
  }
  function u(l) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (r = 1, n && (s = l[0] & 2 ? n.return : l[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) && !(s = s.call(n, l[1])).done)
          return s;
        switch (n = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
          case 0:
          case 1:
            s = l;
            break;
          case 4:
            return e.label++, { value: l[1], done: !1 };
          case 5:
            e.label++, n = l[1], l = [0];
            continue;
          case 7:
            l = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (s = e.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              e = 0;
              continue;
            }
            if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
              e.label = l[1];
              break;
            }
            if (l[0] === 6 && e.label < s[1]) {
              e.label = s[1], s = l;
              break;
            }
            if (s && e.label < s[2]) {
              e.label = s[2], e.ops.push(l);
              break;
            }
            s[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        l = t.call(i, e);
      } catch (h) {
        l = [6, h], n = 0;
      } finally {
        r = s = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
var mk = (
  /** @class */
  function(i) {
    _S(t, i);
    function t(e, r) {
      r === void 0 && (r = { width: 1, height: 1, autoLoad: !0 });
      var n = this, s, a;
      return typeof e == "string" ? (s = e, a = new Uint8Array()) : (s = null, a = e), n = i.call(this, a, r) || this, n.origin = s, n.buffer = a ? new yv(a) : null, n.origin && r.autoLoad !== !1 && n.load(), a && a.length && (n.loaded = !0, n.onBlobLoaded(n.buffer.rawBinaryData)), n;
    }
    return t.prototype.onBlobLoaded = function(e) {
    }, t.prototype.load = function() {
      return vk(this, void 0, Promise, function() {
        var e, r, n;
        return gk(this, function(s) {
          switch (s.label) {
            case 0:
              return [4, fetch(this.origin)];
            case 1:
              return e = s.sent(), [4, e.blob()];
            case 2:
              return r = s.sent(), [4, r.arrayBuffer()];
            case 3:
              return n = s.sent(), this.data = new Uint32Array(n), this.buffer = new yv(n), this.loaded = !0, this.onBlobLoaded(n), this.update(), [2, this];
          }
        });
      });
    }, t;
  }(su)
), Cy = (
  /** @class */
  function(i) {
    _S(t, i);
    function t(e, r) {
      var n = i.call(this, e, r) || this;
      return n.format = r.format, n.levels = r.levels || 1, n._width = r.width, n._height = r.height, n._extension = t._formatToExtension(n.format), (r.levelBuffers || n.buffer) && (n._levelBuffers = r.levelBuffers || t._createLevelBuffers(
        e instanceof Uint8Array ? e : n.buffer.uint8View,
        n.format,
        n.levels,
        4,
        4,
        // PVRTC has 8x4 blocks in 2bpp mode
        n.width,
        n.height
      )), n;
    }
    return t.prototype.upload = function(e, r, n) {
      var s = e.gl, a = e.context.extensions[this._extension];
      if (!a)
        throw new Error(this._extension + " textures are not supported on the current machine");
      if (!this._levelBuffers)
        return !1;
      for (var o = 0, u = this.levels; o < u; o++) {
        var l = this._levelBuffers[o], h = l.levelID, d = l.levelWidth, f = l.levelHeight, p = l.levelBuffer;
        s.compressedTexImage2D(s.TEXTURE_2D, h, this.format, d, f, 0, p);
      }
      return !0;
    }, t.prototype.onBlobLoaded = function() {
      this._levelBuffers = t._createLevelBuffers(
        this.buffer.uint8View,
        this.format,
        this.levels,
        4,
        4,
        // PVRTC has 8x4 blocks in 2bpp mode
        this.width,
        this.height
      );
    }, t._formatToExtension = function(e) {
      if (e >= 33776 && e <= 33779)
        return "s3tc";
      if (e >= 37488 && e <= 37497)
        return "etc";
      if (e >= 35840 && e <= 35843)
        return "pvrtc";
      if (e >= 36196)
        return "etc1";
      if (e >= 35986 && e <= 34798)
        return "atc";
      throw new Error("Invalid (compressed) texture format given!");
    }, t._createLevelBuffers = function(e, r, n, s, a, o, u) {
      for (var l = new Array(n), h = e.byteOffset, d = o, f = u, p = d + s - 1 & ~(s - 1), v = f + a - 1 & ~(a - 1), g = p * v * _v[r], m = 0; m < n; m++)
        l[m] = {
          levelID: m,
          levelWidth: n > 1 ? d : p,
          levelHeight: n > 1 ? f : v,
          levelBuffer: new Uint8Array(e.buffer, h, g)
        }, h += g, d = d >> 1 || 1, f = f >> 1 || 1, p = d + s - 1 & ~(s - 1), v = f + a - 1 & ~(a - 1), g = p * v * _v[r];
      return l;
    }, t;
  }(mk)
), yk = (
  /** @class */
  function() {
    function i() {
    }
    return i.use = function(t, e) {
      var r = t.data, n = this;
      if (t.type === Ft.TYPE.JSON && r && r.cacheID && r.textures) {
        for (var s = r.textures, a = void 0, o = void 0, u = 0, l = s.length; u < l; u++) {
          var h = s[u], d = h.src, f = h.format;
          if (f || (o = d), i.textureFormats[f]) {
            a = d;
            break;
          }
        }
        if (a = a || o, !a) {
          e(new Error("Cannot load compressed-textures in " + t.url + ", make sure you provide a fallback"));
          return;
        }
        if (a === t.url) {
          e(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
          return;
        }
        var p = {
          crossOrigin: t.crossOrigin,
          metadata: t.metadata.imageMetadata,
          parentResource: t
        }, v = Cu.resolve(t.url.replace(n.baseUrl, ""), a), g = r.cacheID;
        n.add(g, v, p, function(m) {
          if (m.error) {
            e(m.error);
            return;
          }
          var y = m.texture, _ = y === void 0 ? null : y, b = m.textures, w = b === void 0 ? {} : b;
          Object.assign(t, { texture: _, textures: w }), e();
        });
      } else
        e();
    }, Object.defineProperty(i, "textureExtensions", {
      /**  Map of available texture extensions. */
      get: function() {
        if (!i._textureExtensions) {
          var t = gt.ADAPTER.createCanvas(), e = t.getContext("webgl");
          if (!e)
            return console.warn("WebGL not available for compressed textures. Silently failing."), {};
          var r = {
            s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: e.getExtension("WEBGL_compressed_texture_etc"),
            etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: e.getExtension("WEBGL_compressed_texture_atc"),
            astc: e.getExtension("WEBGL_compressed_texture_astc")
          };
          i._textureExtensions = r;
        }
        return i._textureExtensions;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i, "textureFormats", {
      /** Map of available texture formats. */
      get: function() {
        if (!i._textureFormats) {
          var t = i.textureExtensions;
          i._textureFormats = {};
          for (var e in t) {
            var r = t[e];
            r && Object.assign(i._textureFormats, Object.getPrototypeOf(r));
          }
        }
        return i._textureFormats;
      },
      enumerable: !1,
      configurable: !0
    }), i.extension = de.Loader, i;
  }()
);
function bS(i, t, e) {
  var r = {
    textures: {},
    texture: null
  };
  if (!t)
    return r;
  var n = t.map(function(s) {
    return new Ot(new Kt(s, Object.assign({
      mipmap: tn.OFF,
      alphaMode: en.NO_PREMULTIPLIED_ALPHA
    }, e)));
  });
  return n.forEach(function(s, a) {
    var o = s.baseTexture, u = i + "-" + (a + 1);
    Kt.addToCache(o, u), Ot.addToCache(s, u), a === 0 && (Kt.addToCache(o, i), Ot.addToCache(s, i), r.texture = s), r.textures[u] = s;
  }), r;
}
var bh, Oi, W0 = 4, Jd = 124, _k = 32, U1 = 20, bk = 542327876, Qd = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
}, xk = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
}, tp = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
}, Ri;
(function(i) {
  i[i.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", i[i.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", i[i.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", i[i.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", i[i.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", i[i.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", i[i.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", i[i.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", i[i.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", i[i.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", i[i.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", i[i.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", i[i.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", i[i.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", i[i.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", i[i.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", i[i.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", i[i.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", i[i.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", i[i.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", i[i.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", i[i.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", i[i.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", i[i.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", i[i.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", i[i.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", i[i.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", i[i.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", i[i.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", i[i.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", i[i.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", i[i.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", i[i.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", i[i.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", i[i.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", i[i.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", i[i.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", i[i.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", i[i.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", i[i.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", i[i.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", i[i.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", i[i.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", i[i.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", i[i.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", i[i.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", i[i.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", i[i.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", i[i.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", i[i.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", i[i.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", i[i.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", i[i.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", i[i.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", i[i.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", i[i.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", i[i.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", i[i.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", i[i.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", i[i.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", i[i.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", i[i.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", i[i.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", i[i.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", i[i.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", i[i.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", i[i.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", i[i.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", i[i.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", i[i.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", i[i.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", i[i.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", i[i.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", i[i.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", i[i.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", i[i.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", i[i.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", i[i.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", i[i.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", i[i.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", i[i.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", i[i.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", i[i.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", i[i.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", i[i.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", i[i.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", i[i.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", i[i.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", i[i.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", i[i.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", i[i.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", i[i.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", i[i.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", i[i.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", i[i.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", i[i.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", i[i.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", i[i.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", i[i.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", i[i.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", i[i.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV", i[i.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410", i[i.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416", i[i.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12", i[i.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010", i[i.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016", i[i.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE", i[i.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2", i[i.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210", i[i.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216", i[i.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11", i[i.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44", i[i.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44", i[i.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8", i[i.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8", i[i.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", i[i.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208", i[i.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208", i[i.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408", i[i.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", i[i.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", i[i.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT";
})(Ri || (Ri = {}));
var My;
(function(i) {
  i[i.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", i[i.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", i[i.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D";
})(My || (My = {}));
var wk = 1, Ek = 2, Sk = 4, Tk = 64, Ck = 512, Mk = 131072, Pk = 827611204, Ok = 861165636, Ik = 894720068, Rk = 808540228, Dk = 4, kk = (bh = {}, bh[Pk] = jt.COMPRESSED_RGBA_S3TC_DXT1_EXT, bh[Ok] = jt.COMPRESSED_RGBA_S3TC_DXT3_EXT, bh[Ik] = jt.COMPRESSED_RGBA_S3TC_DXT5_EXT, bh), Nk = (Oi = {}, // WEBGL_compressed_texture_s3tc
Oi[Ri.DXGI_FORMAT_BC1_TYPELESS] = jt.COMPRESSED_RGBA_S3TC_DXT1_EXT, Oi[Ri.DXGI_FORMAT_BC1_UNORM] = jt.COMPRESSED_RGBA_S3TC_DXT1_EXT, Oi[Ri.DXGI_FORMAT_BC2_TYPELESS] = jt.COMPRESSED_RGBA_S3TC_DXT3_EXT, Oi[Ri.DXGI_FORMAT_BC2_UNORM] = jt.COMPRESSED_RGBA_S3TC_DXT3_EXT, Oi[Ri.DXGI_FORMAT_BC3_TYPELESS] = jt.COMPRESSED_RGBA_S3TC_DXT5_EXT, Oi[Ri.DXGI_FORMAT_BC3_UNORM] = jt.COMPRESSED_RGBA_S3TC_DXT5_EXT, // WEBGL_compressed_texture_s3tc_srgb
Oi[Ri.DXGI_FORMAT_BC1_UNORM_SRGB] = jt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, Oi[Ri.DXGI_FORMAT_BC2_UNORM_SRGB] = jt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, Oi[Ri.DXGI_FORMAT_BC3_UNORM_SRGB] = jt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, Oi);
function Ak(i) {
  var t = new Uint32Array(i), e = t[0];
  if (e !== bk)
    throw new Error("Invalid DDS file magic word");
  var r = new Uint32Array(i, 0, Jd / Uint32Array.BYTES_PER_ELEMENT), n = r[Qd.HEIGHT], s = r[Qd.WIDTH], a = r[Qd.MIPMAP_COUNT], o = new Uint32Array(i, Qd.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, _k / Uint32Array.BYTES_PER_ELEMENT), u = o[wk];
  if (u & Sk) {
    var l = o[xk.FOURCC];
    if (l !== Rk) {
      var h = kk[l], d = W0 + Jd, f = new Uint8Array(i, d), p = new Cy(f, {
        format: h,
        width: s,
        height: n,
        levels: a
        // CompressedTextureResource will separate the levelBuffers for us!
      });
      return [p];
    }
    var v = W0 + Jd, g = new Uint32Array(t.buffer, v, U1 / Uint32Array.BYTES_PER_ELEMENT), m = g[tp.DXGI_FORMAT], y = g[tp.RESOURCE_DIMENSION], _ = g[tp.MISC_FLAG], b = g[tp.ARRAY_SIZE], w = Nk[m];
    if (w === void 0)
      throw new Error("DDSParser cannot parse texture data with DXGI format " + m);
    if (_ === Dk)
      throw new Error("DDSParser does not support cubemap textures");
    if (y === My.DDS_DIMENSION_TEXTURE3D)
      throw new Error("DDSParser does not supported 3D texture data");
    var T = new Array(), x = W0 + Jd + U1;
    if (b === 1)
      T.push(new Uint8Array(i, x));
    else {
      for (var S = _v[w], C = 0, M = s, I = n, R = 0; R < a; R++) {
        var N = Math.max(1, M + 3 & -4), A = Math.max(1, I + 3 & -4), G = N * A * S;
        C += G, M = M >>> 1, I = I >>> 1;
      }
      for (var B = x, R = 0; R < b; R++)
        T.push(new Uint8Array(i, B, C)), B += C;
    }
    return T.map(function(U) {
      return new Cy(U, {
        format: w,
        width: s,
        height: n,
        levels: a
      });
    });
  }
  throw u & Tk ? new Error("DDSParser does not support uncompressed texture data.") : u & Ck ? new Error("DDSParser does not supported YUV uncompressed texture data.") : u & Mk ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : u & Ek ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
var Os, $n, xh, j1 = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], Lk = 67305985, Ii = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
}, Py = 64, z1 = (Os = {}, Os[It.UNSIGNED_BYTE] = 1, Os[It.UNSIGNED_SHORT] = 2, Os[It.INT] = 4, Os[It.UNSIGNED_INT] = 4, Os[It.FLOAT] = 4, Os[It.HALF_FLOAT] = 8, Os), Bk = ($n = {}, $n[ht.RGBA] = 4, $n[ht.RGB] = 3, $n[ht.RG] = 2, $n[ht.RED] = 1, $n[ht.LUMINANCE] = 1, $n[ht.LUMINANCE_ALPHA] = 2, $n[ht.ALPHA] = 1, $n), Fk = (xh = {}, xh[It.UNSIGNED_SHORT_4_4_4_4] = 2, xh[It.UNSIGNED_SHORT_5_5_5_1] = 2, xh[It.UNSIGNED_SHORT_5_6_5] = 2, xh);
function Gk(i, t, e) {
  e === void 0 && (e = !1);
  var r = new DataView(t);
  if (!Uk(i, r))
    return null;
  var n = r.getUint32(Ii.ENDIANNESS, !0) === Lk, s = r.getUint32(Ii.GL_TYPE, n), a = r.getUint32(Ii.GL_FORMAT, n), o = r.getUint32(Ii.GL_INTERNAL_FORMAT, n), u = r.getUint32(Ii.PIXEL_WIDTH, n), l = r.getUint32(Ii.PIXEL_HEIGHT, n) || 1, h = r.getUint32(Ii.PIXEL_DEPTH, n) || 1, d = r.getUint32(Ii.NUMBER_OF_ARRAY_ELEMENTS, n) || 1, f = r.getUint32(Ii.NUMBER_OF_FACES, n), p = r.getUint32(Ii.NUMBER_OF_MIPMAP_LEVELS, n), v = r.getUint32(Ii.BYTES_OF_KEY_VALUE_DATA, n);
  if (l === 0 || h !== 1)
    throw new Error("Only 2D textures are supported");
  if (f !== 1)
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  if (d !== 1)
    throw new Error("WebGL does not support array textures");
  var g = 4, m = 4, y = u + 3 & -4, _ = l + 3 & -4, b = new Array(d), w = u * l;
  s === 0 && (w = y * _);
  var T;
  if (s !== 0 ? z1[s] ? T = z1[s] * Bk[a] : T = Fk[s] : T = _v[o], T === void 0)
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  for (var x = e ? zk(r, v, n) : null, S = w * T, C = S, M = u, I = l, R = y, N = _, A = Py + v, G = 0; G < p; G++) {
    for (var B = r.getUint32(A, n), U = A + 4, $ = 0; $ < d; $++) {
      var Z = b[$];
      Z || (Z = b[$] = new Array(p)), Z[G] = {
        levelID: G,
        // don't align mipWidth when texture not compressed! (glType not zero)
        levelWidth: p > 1 || s !== 0 ? M : R,
        levelHeight: p > 1 || s !== 0 ? I : N,
        levelBuffer: new Uint8Array(t, U, C)
      }, U += C;
    }
    A += B + 4, A = A % 4 !== 0 ? A + 4 - A % 4 : A, M = M >> 1 || 1, I = I >> 1 || 1, R = M + g - 1 & ~(g - 1), N = I + m - 1 & ~(m - 1), C = R * N * T;
  }
  return s !== 0 ? {
    uncompressed: b.map(function(H) {
      var z = H[0].levelBuffer, X = !1;
      return s === It.FLOAT ? z = new Float32Array(H[0].levelBuffer.buffer, H[0].levelBuffer.byteOffset, H[0].levelBuffer.byteLength / 4) : s === It.UNSIGNED_INT ? (X = !0, z = new Uint32Array(H[0].levelBuffer.buffer, H[0].levelBuffer.byteOffset, H[0].levelBuffer.byteLength / 4)) : s === It.INT && (X = !0, z = new Int32Array(H[0].levelBuffer.buffer, H[0].levelBuffer.byteOffset, H[0].levelBuffer.byteLength / 4)), {
        resource: new su(z, {
          width: H[0].levelWidth,
          height: H[0].levelHeight
        }),
        type: s,
        format: X ? jk(a) : a
      };
    }),
    kvData: x
  } : {
    compressed: b.map(function(H) {
      return new Cy(null, {
        format: o,
        width: u,
        height: l,
        levels: p,
        levelBuffers: H
      });
    }),
    kvData: x
  };
}
function Uk(i, t) {
  for (var e = 0; e < j1.length; e++)
    if (t.getUint8(e) !== j1[e])
      return console.error(i + " is not a valid *.ktx file!"), !1;
  return !0;
}
function jk(i) {
  switch (i) {
    case ht.RGBA:
      return ht.RGBA_INTEGER;
    case ht.RGB:
      return ht.RGB_INTEGER;
    case ht.RG:
      return ht.RG_INTEGER;
    case ht.RED:
      return ht.RED_INTEGER;
    default:
      return i;
  }
}
function zk(i, t, e) {
  for (var r = /* @__PURE__ */ new Map(), n = 0; n < t; ) {
    var s = i.getUint32(Py + n, e), a = Py + n + 4, o = 3 - (s + 3) % 4;
    if (s === 0 || s > t - n) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    for (var u = 0; u < s && i.getUint8(a + u) !== 0; u++)
      ;
    if (u === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    var l = new TextDecoder().decode(new Uint8Array(i.buffer, a, u)), h = new DataView(i.buffer, a + u + 1, s - u - 1);
    r.set(l, h), n += 4 + s + o;
  }
  return r;
}
Ft.setExtensionXhrType("dds", Ft.XHR_RESPONSE_TYPE.BUFFER);
var Hk = (
  /** @class */
  function() {
    function i() {
    }
    return i.use = function(t, e) {
      if (t.extension === "dds" && t.data)
        try {
          Object.assign(t, bS(t.name || t.url, Ak(t.data), t.metadata));
        } catch (r) {
          e(r);
          return;
        }
      e();
    }, i.extension = de.Loader, i;
  }()
);
Ft.setExtensionXhrType("ktx", Ft.XHR_RESPONSE_TYPE.BUFFER);
var $k = (
  /** @class */
  function() {
    function i() {
    }
    return i.use = function(t, e) {
      if (t.extension === "ktx" && t.data)
        try {
          var r = t.name || t.url, n = Gk(r, t.data, this.loadKeyValueData), s = n.compressed, a = n.uncompressed, o = n.kvData;
          if (s) {
            var u = bS(r, s, t.metadata);
            if (o && u.textures)
              for (var l in u.textures)
                u.textures[l].baseTexture.ktxKeyValueData = o;
            Object.assign(t, u);
          } else if (a) {
            var h = {};
            a.forEach(function(d, f) {
              var p = new Ot(new Kt(d.resource, {
                mipmap: tn.OFF,
                alphaMode: en.NO_PREMULTIPLIED_ALPHA,
                type: d.type,
                format: d.format
              })), v = r + "-" + (f + 1);
              o && (p.baseTexture.ktxKeyValueData = o), Kt.addToCache(p.baseTexture, v), Ot.addToCache(p, v), f === 0 && (h[r] = p, Kt.addToCache(p.baseTexture, r), Ot.addToCache(p, r)), h[v] = p;
            }), Object.assign(t, { textures: h });
          }
        } catch (d) {
          e(d);
          return;
        }
      e();
    }, i.extension = de.Loader, i.loadKeyValueData = !1, i;
  }()
);
/*!
 * @pixi/particle-container - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/particle-container is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Oy = function(i, t) {
  return Oy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, Oy(i, t);
};
function xS(i, t) {
  Oy(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
(function(i) {
  xS(t, i);
  function t(e, r, n, s) {
    e === void 0 && (e = 1500), n === void 0 && (n = 16384), s === void 0 && (s = !1);
    var a = i.call(this) || this, o = 16384;
    return n > o && (n = o), a._properties = [!1, !0, !1, !1, !1], a._maxSize = e, a._batchSize = n, a._buffers = null, a._bufferUpdateIDs = [], a._updateID = 0, a.interactiveChildren = !1, a.blendMode = Et.NORMAL, a.autoResize = s, a.roundPixels = !0, a.baseTexture = null, a.setProperties(r), a._tint = 0, a.tintRgb = new Float32Array(4), a.tint = 16777215, a;
  }
  return t.prototype.setProperties = function(e) {
    e && (this._properties[0] = "vertices" in e || "scale" in e ? !!e.vertices || !!e.scale : this._properties[0], this._properties[1] = "position" in e ? !!e.position : this._properties[1], this._properties[2] = "rotation" in e ? !!e.rotation : this._properties[2], this._properties[3] = "uvs" in e ? !!e.uvs : this._properties[3], this._properties[4] = "tint" in e || "alpha" in e ? !!e.tint || !!e.alpha : this._properties[4]);
  }, t.prototype.updateTransform = function() {
    this.displayObjectUpdateTransform();
  }, Object.defineProperty(t.prototype, "tint", {
    /**
     * The tint applied to the container. This is a hex value.
     * A value of 0xFFFFFF will remove any tint effect.
     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
     * @default 0xFFFFFF
     */
    get: function() {
      return this._tint;
    },
    set: function(e) {
      this._tint = e, Kl(e, this.tintRgb);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.render = function(e) {
    var r = this;
    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", function() {
      return r.onChildrenChange(0);
    })), e.batch.setObjectRenderer(e.plugins.particle), e.plugins.particle.render(this));
  }, t.prototype.onChildrenChange = function(e) {
    for (var r = Math.floor(e / this._batchSize); this._bufferUpdateIDs.length < r; )
      this._bufferUpdateIDs.push(0);
    this._bufferUpdateIDs[r] = ++this._updateID;
  }, t.prototype.dispose = function() {
    if (this._buffers) {
      for (var e = 0; e < this._buffers.length; ++e)
        this._buffers[e].destroy();
      this._buffers = null;
    }
  }, t.prototype.destroy = function(e) {
    i.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;
  }, t;
})(ye);
var H1 = (
  /** @class */
  function() {
    function i(t, e, r) {
      this.geometry = new uh(), this.indexBuffer = null, this.size = r, this.dynamicProperties = [], this.staticProperties = [];
      for (var n = 0; n < t.length; ++n) {
        var s = t[n];
        s = {
          attributeName: s.attributeName,
          size: s.size,
          uploadFunction: s.uploadFunction,
          type: s.type || It.FLOAT,
          offset: s.offset
        }, e[n] ? this.dynamicProperties.push(s) : this.staticProperties.push(s);
      }
      this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();
    }
    return i.prototype.initBuffers = function() {
      var t = this.geometry, e = 0;
      this.indexBuffer = new Ke(kD(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;
      for (var r = 0; r < this.dynamicProperties.length; ++r) {
        var n = this.dynamicProperties[r];
        n.offset = e, e += n.size, this.dynamicStride += n.size;
      }
      var s = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
      this.dynamicData = new Float32Array(s), this.dynamicDataUint32 = new Uint32Array(s), this.dynamicBuffer = new Ke(this.dynamicData, !1, !1);
      var a = 0;
      this.staticStride = 0;
      for (var r = 0; r < this.staticProperties.length; ++r) {
        var n = this.staticProperties[r];
        n.offset = a, a += n.size, this.staticStride += n.size;
      }
      var o = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
      this.staticData = new Float32Array(o), this.staticDataUint32 = new Uint32Array(o), this.staticBuffer = new Ke(this.staticData, !0, !1);
      for (var r = 0; r < this.dynamicProperties.length; ++r) {
        var n = this.dynamicProperties[r];
        t.addAttribute(n.attributeName, this.dynamicBuffer, 0, n.type === It.UNSIGNED_BYTE, n.type, this.dynamicStride * 4, n.offset * 4);
      }
      for (var r = 0; r < this.staticProperties.length; ++r) {
        var n = this.staticProperties[r];
        t.addAttribute(n.attributeName, this.staticBuffer, 0, n.type === It.UNSIGNED_BYTE, n.type, this.staticStride * 4, n.offset * 4);
      }
    }, i.prototype.uploadDynamic = function(t, e, r) {
      for (var n = 0; n < this.dynamicProperties.length; n++) {
        var s = this.dynamicProperties[n];
        s.uploadFunction(t, e, r, s.type === It.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, s.offset);
      }
      this.dynamicBuffer._updateID++;
    }, i.prototype.uploadStatic = function(t, e, r) {
      for (var n = 0; n < this.staticProperties.length; n++) {
        var s = this.staticProperties[n];
        s.uploadFunction(t, e, r, s.type === It.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, s.offset);
      }
      this.staticBuffer._updateID++;
    }, i.prototype.destroy = function() {
      this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();
    }, i;
  }()
), Vk = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`, Xk = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`, Wk = (
  /** @class */
  function(i) {
    xS(t, i);
    function t(e) {
      var r = i.call(this, e) || this;
      return r.shader = null, r.properties = null, r.tempMatrix = new ar(), r.properties = [
        // verticesData
        {
          attributeName: "aVertexPosition",
          size: 2,
          uploadFunction: r.uploadVertices,
          offset: 0
        },
        // positionData
        {
          attributeName: "aPositionCoord",
          size: 2,
          uploadFunction: r.uploadPosition,
          offset: 0
        },
        // rotationData
        {
          attributeName: "aRotation",
          size: 1,
          uploadFunction: r.uploadRotation,
          offset: 0
        },
        // uvsData
        {
          attributeName: "aTextureCoord",
          size: 2,
          uploadFunction: r.uploadUvs,
          offset: 0
        },
        // tintData
        {
          attributeName: "aColor",
          size: 1,
          type: It.UNSIGNED_BYTE,
          uploadFunction: r.uploadTint,
          offset: 0
        }
      ], r.shader = xs.from(Xk, Vk, {}), r.state = va.for2d(), r;
    }
    return t.prototype.render = function(e) {
      var r = e.children, n = e._maxSize, s = e._batchSize, a = this.renderer, o = r.length;
      if (o !== 0) {
        o > n && !e.autoResize && (o = n);
        var u = e._buffers;
        u || (u = e._buffers = this.generateBuffers(e));
        var l = r[0]._texture.baseTexture, h = l.alphaMode > 0;
        this.state.blendMode = BE(e.blendMode, h), a.state.set(this.state);
        var d = a.gl, f = e.worldTransform.copyTo(this.tempMatrix);
        f.prepend(a.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = f.toArray(!0), this.shader.uniforms.uColor = DD(e.tintRgb, e.worldAlpha, this.shader.uniforms.uColor, h), this.shader.uniforms.uSampler = l, this.renderer.shader.bind(this.shader);
        for (var p = !1, v = 0, g = 0; v < o; v += s, g += 1) {
          var m = o - v;
          m > s && (m = s), g >= u.length && u.push(this._generateOneMoreBuffer(e));
          var y = u[g];
          y.uploadDynamic(r, v, m);
          var _ = e._bufferUpdateIDs[g] || 0;
          p = p || y._updateID < _, p && (y._updateID = e._updateID, y.uploadStatic(r, v, m)), a.geometry.bind(y.geometry), d.drawElements(d.TRIANGLES, m * 6, d.UNSIGNED_SHORT, 0);
        }
      }
    }, t.prototype.generateBuffers = function(e) {
      for (var r = [], n = e._maxSize, s = e._batchSize, a = e._properties, o = 0; o < n; o += s)
        r.push(new H1(this.properties, a, s));
      return r;
    }, t.prototype._generateOneMoreBuffer = function(e) {
      var r = e._batchSize, n = e._properties;
      return new H1(this.properties, n, r);
    }, t.prototype.uploadVertices = function(e, r, n, s, a, o) {
      for (var u = 0, l = 0, h = 0, d = 0, f = 0; f < n; ++f) {
        var p = e[r + f], v = p._texture, g = p.scale.x, m = p.scale.y, y = v.trim, _ = v.orig;
        y ? (l = y.x - p.anchor.x * _.width, u = l + y.width, d = y.y - p.anchor.y * _.height, h = d + y.height) : (u = _.width * (1 - p.anchor.x), l = _.width * -p.anchor.x, h = _.height * (1 - p.anchor.y), d = _.height * -p.anchor.y), s[o] = l * g, s[o + 1] = d * m, s[o + a] = u * g, s[o + a + 1] = d * m, s[o + a * 2] = u * g, s[o + a * 2 + 1] = h * m, s[o + a * 3] = l * g, s[o + a * 3 + 1] = h * m, o += a * 4;
      }
    }, t.prototype.uploadPosition = function(e, r, n, s, a, o) {
      for (var u = 0; u < n; u++) {
        var l = e[r + u].position;
        s[o] = l.x, s[o + 1] = l.y, s[o + a] = l.x, s[o + a + 1] = l.y, s[o + a * 2] = l.x, s[o + a * 2 + 1] = l.y, s[o + a * 3] = l.x, s[o + a * 3 + 1] = l.y, o += a * 4;
      }
    }, t.prototype.uploadRotation = function(e, r, n, s, a, o) {
      for (var u = 0; u < n; u++) {
        var l = e[r + u].rotation;
        s[o] = l, s[o + a] = l, s[o + a * 2] = l, s[o + a * 3] = l, o += a * 4;
      }
    }, t.prototype.uploadUvs = function(e, r, n, s, a, o) {
      for (var u = 0; u < n; ++u) {
        var l = e[r + u]._texture._uvs;
        l ? (s[o] = l.x0, s[o + 1] = l.y0, s[o + a] = l.x1, s[o + a + 1] = l.y1, s[o + a * 2] = l.x2, s[o + a * 2 + 1] = l.y2, s[o + a * 3] = l.x3, s[o + a * 3 + 1] = l.y3, o += a * 4) : (s[o] = 0, s[o + 1] = 0, s[o + a] = 0, s[o + a + 1] = 0, s[o + a * 2] = 0, s[o + a * 2 + 1] = 0, s[o + a * 3] = 0, s[o + a * 3 + 1] = 0, o += a * 4);
      }
    }, t.prototype.uploadTint = function(e, r, n, s, a, o) {
      for (var u = 0; u < n; ++u) {
        var l = e[r + u], h = l._texture.baseTexture.alphaMode > 0, d = l.alpha, f = d < 1 && h ? Eb(l._tintRGB, d) : l._tintRGB + (d * 255 << 24);
        s[o] = f, s[o + a] = f, s[o + a * 2] = f, s[o + a * 3] = f, o += a * 4;
      }
    }, t.prototype.destroy = function() {
      i.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;
    }, t.extension = {
      name: "particle",
      type: de.RendererPlugin
    }, t;
  }(bd)
);
/*!
 * @pixi/graphics - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/graphics is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var bs;
(function(i) {
  i.MITER = "miter", i.BEVEL = "bevel", i.ROUND = "round";
})(bs || (bs = {}));
var aa;
(function(i) {
  i.BUTT = "butt", i.ROUND = "round", i.SQUARE = "square";
})(aa || (aa = {}));
var uc = {
  adaptive: !0,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount: function(i, t) {
    if (t === void 0 && (t = 20), !this.adaptive || !i || isNaN(i))
      return t;
    var e = Math.ceil(i / this.maxLength);
    return e < this.minSegments ? e = this.minSegments : e > this.maxSegments && (e = this.maxSegments), e;
  }
}, wS = (
  /** @class */
  function() {
    function i() {
      this.color = 16777215, this.alpha = 1, this.texture = Ot.WHITE, this.matrix = null, this.visible = !1, this.reset();
    }
    return i.prototype.clone = function() {
      var t = new i();
      return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t;
    }, i.prototype.reset = function() {
      this.color = 16777215, this.alpha = 1, this.texture = Ot.WHITE, this.matrix = null, this.visible = !1;
    }, i.prototype.destroy = function() {
      this.texture = null, this.matrix = null;
    }, i;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Iy = function(i, t) {
  return Iy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, Iy(i, t);
};
function tx(i, t) {
  Iy(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function $1(i, t) {
  var e, r;
  t === void 0 && (t = !1);
  var n = i.length;
  if (!(n < 6)) {
    for (var s = 0, a = 0, o = i[n - 2], u = i[n - 1]; a < n; a += 2) {
      var l = i[a], h = i[a + 1];
      s += (l - o) * (h + u), o = l, u = h;
    }
    if (!t && s > 0 || t && s <= 0)
      for (var d = n / 2, a = d + d % 2; a < n; a += 2) {
        var f = n - a - 2, p = n - a - 1, v = a, g = a + 1;
        e = [i[v], i[f]], i[f] = e[0], i[v] = e[1], r = [i[g], i[p]], i[p] = r[0], i[g] = r[1];
      }
  }
}
var ES = {
  build: function(i) {
    i.points = i.shape.points.slice();
  },
  triangulate: function(i, t) {
    var e = i.points, r = i.holes, n = t.points, s = t.indices;
    if (e.length >= 6) {
      $1(e, !1);
      for (var a = [], o = 0; o < r.length; o++) {
        var u = r[o];
        $1(u.points, !0), a.push(e.length / 2), e = e.concat(u.points);
      }
      var l = kE(e, a, 2);
      if (!l)
        return;
      for (var h = n.length / 2, o = 0; o < l.length; o += 3)
        s.push(l[o] + h), s.push(l[o + 1] + h), s.push(l[o + 2] + h);
      for (var o = 0; o < e.length; o++)
        n.push(e[o]);
    }
  }
}, bv = {
  build: function(i) {
    var t = i.points, e, r, n, s, a, o;
    if (i.type === ur.CIRC) {
      var u = i.shape;
      e = u.x, r = u.y, a = o = u.radius, n = s = 0;
    } else if (i.type === ur.ELIP) {
      var l = i.shape;
      e = l.x, r = l.y, a = l.width, o = l.height, n = s = 0;
    } else {
      var h = i.shape, d = h.width / 2, f = h.height / 2;
      e = h.x + d, r = h.y + f, a = o = Math.max(0, Math.min(h.radius, Math.min(d, f))), n = d - a, s = f - o;
    }
    if (!(a >= 0 && o >= 0 && n >= 0 && s >= 0)) {
      t.length = 0;
      return;
    }
    var p = Math.ceil(2.3 * Math.sqrt(a + o)), v = p * 8 + (n ? 4 : 0) + (s ? 4 : 0);
    if (t.length = v, v !== 0) {
      if (p === 0) {
        t.length = 8, t[0] = t[6] = e + n, t[1] = t[3] = r + s, t[2] = t[4] = e - n, t[5] = t[7] = r - s;
        return;
      }
      var g = 0, m = p * 4 + (n ? 2 : 0) + 2, y = m, _ = v;
      {
        var b = n + a, w = s, T = e + b, x = e - b, S = r + w;
        if (t[g++] = T, t[g++] = S, t[--m] = S, t[--m] = x, s) {
          var C = r - w;
          t[y++] = x, t[y++] = C, t[--_] = C, t[--_] = T;
        }
      }
      for (var M = 1; M < p; M++) {
        var I = Math.PI / 2 * (M / p), b = n + Math.cos(I) * a, w = s + Math.sin(I) * o, T = e + b, x = e - b, S = r + w, C = r - w;
        t[g++] = T, t[g++] = S, t[--m] = S, t[--m] = x, t[y++] = x, t[y++] = C, t[--_] = C, t[--_] = T;
      }
      {
        var b = n, w = s + o, T = e + b, x = e - b, S = r + w, C = r - w;
        t[g++] = T, t[g++] = S, t[--_] = C, t[--_] = T, n && (t[g++] = x, t[g++] = S, t[--_] = C, t[--_] = x);
      }
    }
  },
  triangulate: function(i, t) {
    var e = i.points, r = t.points, n = t.indices;
    if (e.length !== 0) {
      var s = r.length / 2, a = s, o, u;
      if (i.type !== ur.RREC) {
        var l = i.shape;
        o = l.x, u = l.y;
      } else {
        var h = i.shape;
        o = h.x + h.width / 2, u = h.y + h.height / 2;
      }
      var d = i.matrix;
      r.push(i.matrix ? d.a * o + d.c * u + d.tx : o, i.matrix ? d.b * o + d.d * u + d.ty : u), s++, r.push(e[0], e[1]);
      for (var f = 2; f < e.length; f += 2)
        r.push(e[f], e[f + 1]), n.push(s++, a, s);
      n.push(a + 1, a, s);
    }
  }
}, Yk = {
  build: function(i) {
    var t = i.shape, e = t.x, r = t.y, n = t.width, s = t.height, a = i.points;
    a.length = 0, a.push(e, r, e + n, r, e + n, r + s, e, r + s);
  },
  triangulate: function(i, t) {
    var e = i.points, r = t.points, n = r.length / 2;
    r.push(e[0], e[1], e[2], e[3], e[6], e[7], e[4], e[5]), t.indices.push(n, n + 1, n + 2, n + 1, n + 2, n + 3);
  }
};
function vu(i, t, e) {
  var r = t - i;
  return i + r * e;
}
function ep(i, t, e, r, n, s, a) {
  a === void 0 && (a = []);
  for (var o = 20, u = a, l = 0, h = 0, d = 0, f = 0, p = 0, v = 0, g = 0, m = 0; g <= o; ++g)
    m = g / o, l = vu(i, e, m), h = vu(t, r, m), d = vu(e, n, m), f = vu(r, s, m), p = vu(l, d, m), v = vu(h, f, m), !(g === 0 && u[u.length - 2] === p && u[u.length - 1] === v) && u.push(p, v);
  return u;
}
var qk = {
  build: function(i) {
    if (si.nextRoundedRectBehavior) {
      bv.build(i);
      return;
    }
    var t = i.shape, e = i.points, r = t.x, n = t.y, s = t.width, a = t.height, o = Math.max(0, Math.min(t.radius, Math.min(s, a) / 2));
    e.length = 0, o ? (ep(r, n + o, r, n, r + o, n, e), ep(r + s - o, n, r + s, n, r + s, n + o, e), ep(r + s, n + a - o, r + s, n + a, r + s - o, n + a, e), ep(r + o, n + a, r, n + a, r, n + a - o, e)) : e.push(r, n, r + s, n, r + s, n + a, r, n + a);
  },
  triangulate: function(i, t) {
    if (si.nextRoundedRectBehavior) {
      bv.triangulate(i, t);
      return;
    }
    for (var e = i.points, r = t.points, n = t.indices, s = r.length / 2, a = kE(e, null, 2), o = 0, u = a.length; o < u; o += 3)
      n.push(a[o] + s), n.push(a[o + 1] + s), n.push(a[o + 2] + s);
    for (var o = 0, u = e.length; o < u; o++)
      r.push(e[o], e[++o]);
  }
};
function V1(i, t, e, r, n, s, a, o) {
  var u = i - e * n, l = t - r * n, h = i + e * s, d = t + r * s, f, p;
  a ? (f = r, p = -e) : (f = -r, p = e);
  var v = u + f, g = l + p, m = h + f, y = d + p;
  return o.push(v, g), o.push(m, y), 2;
}
function ba(i, t, e, r, n, s, a, o) {
  var u = e - i, l = r - t, h = Math.atan2(u, l), d = Math.atan2(n - i, s - t);
  o && h < d ? h += Math.PI * 2 : !o && h > d && (d += Math.PI * 2);
  var f = h, p = d - h, v = Math.abs(p), g = Math.sqrt(u * u + l * l), m = (15 * v * Math.sqrt(g) / Math.PI >> 0) + 1, y = p / m;
  if (f += y, o) {
    a.push(i, t), a.push(e, r);
    for (var _ = 1, b = f; _ < m; _++, b += y)
      a.push(i, t), a.push(i + Math.sin(b) * g, t + Math.cos(b) * g);
    a.push(i, t), a.push(n, s);
  } else {
    a.push(e, r), a.push(i, t);
    for (var _ = 1, b = f; _ < m; _++, b += y)
      a.push(i + Math.sin(b) * g, t + Math.cos(b) * g), a.push(i, t);
    a.push(n, s), a.push(i, t);
  }
  return m * 2;
}
function Zk(i, t) {
  var e = i.shape, r = i.points || e.points.slice(), n = t.closePointEps;
  if (r.length !== 0) {
    var s = i.lineStyle, a = new xe(r[0], r[1]), o = new xe(r[r.length - 2], r[r.length - 1]), u = e.type !== ur.POLY || e.closeStroke, l = Math.abs(a.x - o.x) < n && Math.abs(a.y - o.y) < n;
    if (u) {
      r = r.slice(), l && (r.pop(), r.pop(), o.set(r[r.length - 2], r[r.length - 1]));
      var h = (a.x + o.x) * 0.5, d = (o.y + a.y) * 0.5;
      r.unshift(h, d), r.push(h, d);
    }
    var f = t.points, p = r.length / 2, v = r.length, g = f.length / 2, m = s.width / 2, y = m * m, _ = s.miterLimit * s.miterLimit, b = r[0], w = r[1], T = r[2], x = r[3], S = 0, C = 0, M = -(w - x), I = b - T, R = 0, N = 0, A = Math.sqrt(M * M + I * I);
    M /= A, I /= A, M *= m, I *= m;
    var G = s.alignment, B = (1 - G) * 2, U = G * 2;
    u || (s.cap === aa.ROUND ? v += ba(b - M * (B - U) * 0.5, w - I * (B - U) * 0.5, b - M * B, w - I * B, b + M * U, w + I * U, f, !0) + 2 : s.cap === aa.SQUARE && (v += V1(b, w, M, I, B, U, !0, f))), f.push(b - M * B, w - I * B), f.push(b + M * U, w + I * U);
    for (var $ = 1; $ < p - 1; ++$) {
      b = r[($ - 1) * 2], w = r[($ - 1) * 2 + 1], T = r[$ * 2], x = r[$ * 2 + 1], S = r[($ + 1) * 2], C = r[($ + 1) * 2 + 1], M = -(w - x), I = b - T, A = Math.sqrt(M * M + I * I), M /= A, I /= A, M *= m, I *= m, R = -(x - C), N = T - S, A = Math.sqrt(R * R + N * N), R /= A, N /= A, R *= m, N *= m;
      var Z = T - b, H = w - x, z = T - S, X = C - x, ct = Z * z + H * X, it = H * z - X * Z, lt = it < 0;
      if (Math.abs(it) < 1e-3 * Math.abs(ct)) {
        f.push(T - M * B, x - I * B), f.push(T + M * U, x + I * U), ct >= 0 && (s.join === bs.ROUND ? v += ba(T, x, T - M * B, x - I * B, T - R * B, x - N * B, f, !1) + 4 : v += 2, f.push(T - R * U, x - N * U), f.push(T + R * B, x + N * B));
        continue;
      }
      var et = (-M + b) * (-I + x) - (-M + T) * (-I + w), k = (-R + S) * (-N + x) - (-R + T) * (-N + C), ft = (Z * k - z * et) / it, Q = (X * et - H * k) / it, St = (ft - T) * (ft - T) + (Q - x) * (Q - x), at = T + (ft - T) * B, q = x + (Q - x) * B, bt = T - (ft - T) * U, st = x - (Q - x) * U, W = Math.min(Z * Z + H * H, z * z + X * X), nt = lt ? B : U, dt = W + nt * nt * y, V = St <= dt;
      V ? s.join === bs.BEVEL || St / y > _ ? (lt ? (f.push(at, q), f.push(T + M * U, x + I * U), f.push(at, q), f.push(T + R * U, x + N * U)) : (f.push(T - M * B, x - I * B), f.push(bt, st), f.push(T - R * B, x - N * B), f.push(bt, st)), v += 2) : s.join === bs.ROUND ? lt ? (f.push(at, q), f.push(T + M * U, x + I * U), v += ba(T, x, T + M * U, x + I * U, T + R * U, x + N * U, f, !0) + 4, f.push(at, q), f.push(T + R * U, x + N * U)) : (f.push(T - M * B, x - I * B), f.push(bt, st), v += ba(T, x, T - M * B, x - I * B, T - R * B, x - N * B, f, !1) + 4, f.push(T - R * B, x - N * B), f.push(bt, st)) : (f.push(at, q), f.push(bt, st)) : (f.push(T - M * B, x - I * B), f.push(T + M * U, x + I * U), s.join === bs.ROUND ? lt ? v += ba(T, x, T + M * U, x + I * U, T + R * U, x + N * U, f, !0) + 2 : v += ba(T, x, T - M * B, x - I * B, T - R * B, x - N * B, f, !1) + 2 : s.join === bs.MITER && St / y <= _ && (lt ? (f.push(bt, st), f.push(bt, st)) : (f.push(at, q), f.push(at, q)), v += 2), f.push(T - R * B, x - N * B), f.push(T + R * U, x + N * U), v += 2);
    }
    b = r[(p - 2) * 2], w = r[(p - 2) * 2 + 1], T = r[(p - 1) * 2], x = r[(p - 1) * 2 + 1], M = -(w - x), I = b - T, A = Math.sqrt(M * M + I * I), M /= A, I /= A, M *= m, I *= m, f.push(T - M * B, x - I * B), f.push(T + M * U, x + I * U), u || (s.cap === aa.ROUND ? v += ba(T - M * (B - U) * 0.5, x - I * (B - U) * 0.5, T - M * B, x - I * B, T + M * U, x + I * U, f, !1) + 2 : s.cap === aa.SQUARE && (v += V1(T, x, M, I, B, U, !1, f)));
    for (var xt = t.indices, Dt = uc.epsilon * uc.epsilon, $ = g; $ < v + g - 2; ++$)
      b = f[$ * 2], w = f[$ * 2 + 1], T = f[($ + 1) * 2], x = f[($ + 1) * 2 + 1], S = f[($ + 2) * 2], C = f[($ + 2) * 2 + 1], !(Math.abs(b * (x - C) + T * (C - w) + S * (w - x)) < Dt) && xt.push($, $ + 1, $ + 2);
  }
}
function Kk(i, t) {
  var e = 0, r = i.shape, n = i.points || r.points, s = r.type !== ur.POLY || r.closeStroke;
  if (n.length !== 0) {
    var a = t.points, o = t.indices, u = n.length / 2, l = a.length / 2, h = l;
    for (a.push(n[0], n[1]), e = 1; e < u; e++)
      a.push(n[e * 2], n[e * 2 + 1]), o.push(h, h + 1), h++;
    s && o.push(h, l);
  }
}
function X1(i, t) {
  i.lineStyle.native ? Kk(i, t) : Zk(i, t);
}
var W1 = (
  /** @class */
  function() {
    function i() {
    }
    return i.curveTo = function(t, e, r, n, s, a) {
      var o = a[a.length - 2], u = a[a.length - 1], l = u - e, h = o - t, d = n - e, f = r - t, p = Math.abs(l * f - h * d);
      if (p < 1e-8 || s === 0)
        return (a[a.length - 2] !== t || a[a.length - 1] !== e) && a.push(t, e), null;
      var v = l * l + h * h, g = d * d + f * f, m = l * d + h * f, y = s * Math.sqrt(v) / p, _ = s * Math.sqrt(g) / p, b = y * m / v, w = _ * m / g, T = y * f + _ * h, x = y * d + _ * l, S = h * (_ + b), C = l * (_ + b), M = f * (y + w), I = d * (y + w), R = Math.atan2(C - x, S - T), N = Math.atan2(I - x, M - T);
      return {
        cx: T + t,
        cy: x + e,
        radius: s,
        startAngle: R,
        endAngle: N,
        anticlockwise: h * d > f * l
      };
    }, i.arc = function(t, e, r, n, s, a, o, u, l) {
      for (var h = o - a, d = uc._segmentsCount(Math.abs(h) * s, Math.ceil(Math.abs(h) / dv) * 40), f = h / (d * 2), p = f * 2, v = Math.cos(f), g = Math.sin(f), m = d - 1, y = m % 1 / m, _ = 0; _ <= m; ++_) {
        var b = _ + y * _, w = f + a + p * b, T = Math.cos(w), x = -Math.sin(w);
        l.push((v * T + g * x) * s + r, (v * -x + g * T) * s + n);
      }
    }, i;
  }()
), Jk = (
  /** @class */
  function() {
    function i() {
    }
    return i.curveLength = function(t, e, r, n, s, a, o, u) {
      for (var l = 10, h = 0, d = 0, f = 0, p = 0, v = 0, g = 0, m = 0, y = 0, _ = 0, b = 0, w = 0, T = t, x = e, S = 1; S <= l; ++S)
        d = S / l, f = d * d, p = f * d, v = 1 - d, g = v * v, m = g * v, y = m * t + 3 * g * d * r + 3 * v * f * s + p * o, _ = m * e + 3 * g * d * n + 3 * v * f * a + p * u, b = T - y, w = x - _, T = y, x = _, h += Math.sqrt(b * b + w * w);
      return h;
    }, i.curveTo = function(t, e, r, n, s, a, o) {
      var u = o[o.length - 2], l = o[o.length - 1];
      o.length -= 2;
      var h = uc._segmentsCount(i.curveLength(u, l, t, e, r, n, s, a)), d = 0, f = 0, p = 0, v = 0, g = 0;
      o.push(u, l);
      for (var m = 1, y = 0; m <= h; ++m)
        y = m / h, d = 1 - y, f = d * d, p = f * d, v = y * y, g = v * y, o.push(p * u + 3 * f * y * t + 3 * d * v * r + g * s, p * l + 3 * f * y * e + 3 * d * v * n + g * a);
    }, i;
  }()
), Qk = (
  /** @class */
  function() {
    function i() {
    }
    return i.curveLength = function(t, e, r, n, s, a) {
      var o = t - 2 * r + s, u = e - 2 * n + a, l = 2 * r - 2 * t, h = 2 * n - 2 * e, d = 4 * (o * o + u * u), f = 4 * (o * l + u * h), p = l * l + h * h, v = 2 * Math.sqrt(d + f + p), g = Math.sqrt(d), m = 2 * d * g, y = 2 * Math.sqrt(p), _ = f / g;
      return (m * v + g * f * (v - y) + (4 * p * d - f * f) * Math.log((2 * g + _ + v) / (_ + y))) / (4 * m);
    }, i.curveTo = function(t, e, r, n, s) {
      for (var a = s[s.length - 2], o = s[s.length - 1], u = uc._segmentsCount(i.curveLength(a, o, t, e, r, n)), l = 0, h = 0, d = 1; d <= u; ++d) {
        var f = d / u;
        l = a + (t - a) * f, h = o + (e - o) * f, s.push(l + (t + (r - t) * f - l) * f, h + (e + (n - e) * f - h) * f);
      }
    }, i;
  }()
), tN = (
  /** @class */
  function() {
    function i() {
      this.reset();
    }
    return i.prototype.begin = function(t, e, r) {
      this.reset(), this.style = t, this.start = e, this.attribStart = r;
    }, i.prototype.end = function(t, e) {
      this.attribSize = e - this.attribStart, this.size = t - this.start;
    }, i.prototype.reset = function() {
      this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;
    }, i;
  }()
), xa, Y0 = (xa = {}, xa[ur.POLY] = ES, xa[ur.CIRC] = bv, xa[ur.ELIP] = bv, xa[ur.RECT] = Yk, xa[ur.RREC] = qk, xa), Y1 = [], rp = [], q1 = (
  /** @class */
  function() {
    function i(t, e, r, n) {
      e === void 0 && (e = null), r === void 0 && (r = null), n === void 0 && (n = null), this.points = [], this.holes = [], this.shape = t, this.lineStyle = r, this.fillStyle = e, this.matrix = n, this.type = t.type;
    }
    return i.prototype.clone = function() {
      return new i(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    }, i.prototype.destroy = function() {
      this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;
    }, i;
  }()
), gu = new xe(), eN = (
  /** @class */
  function(i) {
    tx(t, i);
    function t() {
      var e = i.call(this) || this;
      return e.closePointEps = 1e-4, e.boundsPadding = 0, e.uvsFloat32 = null, e.indicesUint16 = null, e.batchable = !1, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.drawCalls = [], e.batchDirty = -1, e.batches = [], e.dirty = 0, e.cacheDirty = -1, e.clearDirty = 0, e.shapeIndex = 0, e._bounds = new pv(), e.boundsDirty = -1, e;
    }
    return Object.defineProperty(t.prototype, "bounds", {
      /**
       * Get the current bounds of the graphic geometry.
       * @readonly
       */
      get: function() {
        return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.invalidate = function() {
      this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
      for (var e = 0; e < this.drawCalls.length; e++)
        this.drawCalls[e].texArray.clear(), rp.push(this.drawCalls[e]);
      this.drawCalls.length = 0;
      for (var e = 0; e < this.batches.length; e++) {
        var r = this.batches[e];
        r.reset(), Y1.push(r);
      }
      this.batches.length = 0;
    }, t.prototype.clear = function() {
      return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;
    }, t.prototype.drawShape = function(e, r, n, s) {
      r === void 0 && (r = null), n === void 0 && (n = null), s === void 0 && (s = null);
      var a = new q1(e, r, n, s);
      return this.graphicsData.push(a), this.dirty++, this;
    }, t.prototype.drawHole = function(e, r) {
      if (r === void 0 && (r = null), !this.graphicsData.length)
        return null;
      var n = new q1(e, null, null, r), s = this.graphicsData[this.graphicsData.length - 1];
      return n.lineStyle = s.lineStyle, s.holes.push(n), this.dirty++, this;
    }, t.prototype.destroy = function() {
      i.prototype.destroy.call(this);
      for (var e = 0; e < this.graphicsData.length; ++e)
        this.graphicsData[e].destroy();
      this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;
    }, t.prototype.containsPoint = function(e) {
      for (var r = this.graphicsData, n = 0; n < r.length; ++n) {
        var s = r[n];
        if (s.fillStyle.visible && s.shape && (s.matrix ? s.matrix.applyInverse(e, gu) : gu.copyFrom(e), s.shape.contains(gu.x, gu.y))) {
          var a = !1;
          if (s.holes)
            for (var o = 0; o < s.holes.length; o++) {
              var u = s.holes[o];
              if (u.shape.contains(gu.x, gu.y)) {
                a = !0;
                break;
              }
            }
          if (!a)
            return !0;
        }
      }
      return !1;
    }, t.prototype.updateBatches = function() {
      if (!this.graphicsData.length) {
        this.batchable = !0;
        return;
      }
      if (this.validateBatching()) {
        this.cacheDirty = this.dirty;
        var e = this.uvs, r = this.graphicsData, n = null, s = null;
        this.batches.length > 0 && (n = this.batches[this.batches.length - 1], s = n.style);
        for (var a = this.shapeIndex; a < r.length; a++) {
          this.shapeIndex++;
          var o = r[a], u = o.fillStyle, l = o.lineStyle, h = Y0[o.type];
          h.build(o), o.matrix && this.transformPoints(o.points, o.matrix), (u.visible || l.visible) && this.processHoles(o.holes);
          for (var d = 0; d < 2; d++) {
            var f = d === 0 ? u : l;
            if (f.visible) {
              var p = f.texture.baseTexture, v = this.indices.length, g = this.points.length / 2;
              p.wrapMode = On.REPEAT, d === 0 ? this.processFill(o) : this.processLine(o);
              var m = this.points.length / 2 - g;
              m !== 0 && (n && !this._compareStyles(s, f) && (n.end(v, g), n = null), n || (n = Y1.pop() || new tN(), n.begin(f, v, g), this.batches.push(n), s = f), this.addUvs(this.points, e, f.texture, g, m, f.matrix));
            }
          }
        }
        var y = this.indices.length, _ = this.points.length / 2;
        if (n && n.end(y, _), this.batches.length === 0) {
          this.batchable = !0;
          return;
        }
        var b = _ > 65535;
        this.indicesUint16 && this.indices.length === this.indicesUint16.length && b === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = b ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();
      }
    }, t.prototype._compareStyles = function(e, r) {
      return !(!e || !r || e.texture.baseTexture !== r.texture.baseTexture || e.color + e.alpha !== r.color + r.alpha || !!e.native != !!r.native);
    }, t.prototype.validateBatching = function() {
      if (this.dirty === this.cacheDirty || !this.graphicsData.length)
        return !1;
      for (var e = 0, r = this.graphicsData.length; e < r; e++) {
        var n = this.graphicsData[e], s = n.fillStyle, a = n.lineStyle;
        if (s && !s.texture.baseTexture.valid || a && !a.texture.baseTexture.valid)
          return !1;
      }
      return !0;
    }, t.prototype.packBatches = function() {
      this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
      for (var e = this.batches, r = 0, n = e.length; r < n; r++)
        for (var s = e[r], a = 0; a < s.size; a++) {
          var o = s.start + a;
          this.indicesUint16[o] = this.indicesUint16[o] - s.attribStart;
        }
    }, t.prototype.isBatchable = function() {
      if (this.points.length > 65535 * 2)
        return !1;
      for (var e = this.batches, r = 0; r < e.length; r++)
        if (e[r].style.native)
          return !1;
      return this.points.length < t.BATCHABLE_SIZE * 2;
    }, t.prototype.buildDrawCalls = function() {
      for (var e = ++Kt._globalBatch, r = 0; r < this.drawCalls.length; r++)
        this.drawCalls[r].texArray.clear(), rp.push(this.drawCalls[r]);
      this.drawCalls.length = 0;
      var n = this.colors, s = this.textureIds, a = rp.pop();
      a || (a = new gv(), a.texArray = new mv()), a.texArray.count = 0, a.start = 0, a.size = 0, a.type = qi.TRIANGLES;
      var o = 0, u = null, l = 0, h = !1, d = qi.TRIANGLES, f = 0;
      this.drawCalls.push(a);
      for (var r = 0; r < this.batches.length; r++) {
        var p = this.batches[r], v = 8, g = p.style, m = g.texture.baseTexture;
        h !== !!g.native && (h = !!g.native, d = h ? qi.LINES : qi.TRIANGLES, u = null, o = v, e++), u !== m && (u = m, m._batchEnabled !== e && (o === v && (e++, o = 0, a.size > 0 && (a = rp.pop(), a || (a = new gv(), a.texArray = new mv()), this.drawCalls.push(a)), a.start = f, a.size = 0, a.texArray.count = 0, a.type = d), m.touched = 1, m._batchEnabled = e, m._batchLocation = o, m.wrapMode = On.REPEAT, a.texArray.elements[a.texArray.count++] = m, o++)), a.size += p.size, f += p.size, l = m._batchLocation, this.addColors(n, g.color, g.alpha, p.attribSize, p.attribStart), this.addTextureIds(s, l, p.attribSize, p.attribStart);
      }
      Kt._globalBatch = e, this.packAttributes();
    }, t.prototype.packAttributes = function() {
      for (var e = this.points, r = this.uvs, n = this.colors, s = this.textureIds, a = new ArrayBuffer(e.length * 3 * 4), o = new Float32Array(a), u = new Uint32Array(a), l = 0, h = 0; h < e.length / 2; h++)
        o[l++] = e[h * 2], o[l++] = e[h * 2 + 1], o[l++] = r[h * 2], o[l++] = r[h * 2 + 1], u[l++] = n[h], o[l++] = s[h];
      this._buffer.update(a), this._indexBuffer.update(this.indicesUint16);
    }, t.prototype.processFill = function(e) {
      if (e.holes.length)
        ES.triangulate(e, this);
      else {
        var r = Y0[e.type];
        r.triangulate(e, this);
      }
    }, t.prototype.processLine = function(e) {
      X1(e, this);
      for (var r = 0; r < e.holes.length; r++)
        X1(e.holes[r], this);
    }, t.prototype.processHoles = function(e) {
      for (var r = 0; r < e.length; r++) {
        var n = e[r], s = Y0[n.type];
        s.build(n), n.matrix && this.transformPoints(n.points, n.matrix);
      }
    }, t.prototype.calculateBounds = function() {
      var e = this._bounds;
      e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding);
    }, t.prototype.transformPoints = function(e, r) {
      for (var n = 0; n < e.length / 2; n++) {
        var s = e[n * 2], a = e[n * 2 + 1];
        e[n * 2] = r.a * s + r.c * a + r.tx, e[n * 2 + 1] = r.b * s + r.d * a + r.ty;
      }
    }, t.prototype.addColors = function(e, r, n, s, a) {
      a === void 0 && (a = 0);
      var o = (r >> 16) + (r & 65280) + ((r & 255) << 16), u = Eb(o, n);
      e.length = Math.max(e.length, a + s);
      for (var l = 0; l < s; l++)
        e[a + l] = u;
    }, t.prototype.addTextureIds = function(e, r, n, s) {
      s === void 0 && (s = 0), e.length = Math.max(e.length, s + n);
      for (var a = 0; a < n; a++)
        e[s + a] = r;
    }, t.prototype.addUvs = function(e, r, n, s, a, o) {
      o === void 0 && (o = null);
      for (var u = 0, l = r.length, h = n.frame; u < a; ) {
        var d = e[(s + u) * 2], f = e[(s + u) * 2 + 1];
        if (o) {
          var p = o.a * d + o.c * f + o.tx;
          f = o.b * d + o.d * f + o.ty, d = p;
        }
        u++, r.push(d / h.width, f / h.height);
      }
      var v = n.baseTexture;
      (h.width < v.width || h.height < v.height) && this.adjustUvs(r, n, l, a);
    }, t.prototype.adjustUvs = function(e, r, n, s) {
      for (var a = r.baseTexture, o = 1e-6, u = n + s * 2, l = r.frame, h = l.width / a.width, d = l.height / a.height, f = l.x / l.width, p = l.y / l.height, v = Math.floor(e[n] + o), g = Math.floor(e[n + 1] + o), m = n + 2; m < u; m += 2)
        v = Math.min(v, Math.floor(e[m] + o)), g = Math.min(g, Math.floor(e[m + 1] + o));
      f -= v, p -= g;
      for (var m = n; m < u; m += 2)
        e[m] = (e[m] + f) * h, e[m + 1] = (e[m + 1] + p) * d;
    }, t.BATCHABLE_SIZE = 100, t;
  }(Kb)
), rN = (
  /** @class */
  function(i) {
    tx(t, i);
    function t() {
      var e = i !== null && i.apply(this, arguments) || this;
      return e.width = 0, e.alignment = 0.5, e.native = !1, e.cap = aa.BUTT, e.join = bs.MITER, e.miterLimit = 10, e;
    }
    return t.prototype.clone = function() {
      var e = new t();
      return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e.width = this.width, e.alignment = this.alignment, e.native = this.native, e.cap = this.cap, e.join = this.join, e.miterLimit = this.miterLimit, e;
    }, t.prototype.reset = function() {
      i.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1;
    }, t;
  }(wS)
), iN = new Float32Array(3), q0 = {}, si = (
  /** @class */
  function(i) {
    tx(t, i);
    function t(e) {
      e === void 0 && (e = null);
      var r = i.call(this) || this;
      return r.shader = null, r.pluginName = "batch", r.currentPath = null, r.batches = [], r.batchTint = -1, r.batchDirty = -1, r.vertexData = null, r._fillStyle = new wS(), r._lineStyle = new rN(), r._matrix = null, r._holeMode = !1, r.state = va.for2d(), r._geometry = e || new eN(), r._geometry.refCount++, r._transformID = -1, r.tint = 16777215, r.blendMode = Et.NORMAL, r;
    }
    return Object.defineProperty(t.prototype, "geometry", {
      /**
       * Includes vertex positions, face indices, normals, colors, UVs, and
       * custom attributes within buffers, reducing the cost of passing all
       * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
       * @readonly
       */
      get: function() {
        return this._geometry;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.clone = function() {
      return this.finishPoly(), new t(this._geometry);
    }, Object.defineProperty(t.prototype, "blendMode", {
      get: function() {
        return this.state.blendMode;
      },
      /**
       * The blend mode to be applied to the graphic shape. Apply a value of
       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each
       * primitive in the GraphicsGeometry list is rendered sequentially, modes
       * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will
       * be applied per-primitive.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      set: function(e) {
        this.state.blendMode = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      /**
       * The tint applied to each graphic shape. This is a hex value. A value of
       * 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get: function() {
        return this._tint;
      },
      set: function(e) {
        this._tint = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "fill", {
      /**
       * The current fill style.
       * @readonly
       */
      get: function() {
        return this._fillStyle;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "line", {
      /**
       * The current line style.
       * @readonly
       */
      get: function() {
        return this._lineStyle;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.lineStyle = function(e, r, n, s, a) {
      return e === void 0 && (e = null), r === void 0 && (r = 0), n === void 0 && (n = 1), s === void 0 && (s = 0.5), a === void 0 && (a = !1), typeof e == "number" && (e = { width: e, color: r, alpha: n, alignment: s, native: a }), this.lineTextureStyle(e);
    }, t.prototype.lineTextureStyle = function(e) {
      e = Object.assign({
        width: 0,
        texture: Ot.WHITE,
        color: e && e.texture ? 16777215 : 0,
        alpha: 1,
        matrix: null,
        alignment: 0.5,
        native: !1,
        cap: aa.BUTT,
        join: bs.MITER,
        miterLimit: 10
      }, e), this.currentPath && this.startPoly();
      var r = e.width > 0 && e.alpha > 0;
      return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, { visible: r }, e)) : this._lineStyle.reset(), this;
    }, t.prototype.startPoly = function() {
      if (this.currentPath) {
        var e = this.currentPath.points, r = this.currentPath.points.length;
        r > 2 && (this.drawShape(this.currentPath), this.currentPath = new Cp(), this.currentPath.closeStroke = !1, this.currentPath.points.push(e[r - 2], e[r - 1]));
      } else
        this.currentPath = new Cp(), this.currentPath.closeStroke = !1;
    }, t.prototype.finishPoly = function() {
      this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);
    }, t.prototype.moveTo = function(e, r) {
      return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = r, this;
    }, t.prototype.lineTo = function(e, r) {
      this.currentPath || this.moveTo(0, 0);
      var n = this.currentPath.points, s = n[n.length - 2], a = n[n.length - 1];
      return (s !== e || a !== r) && n.push(e, r), this;
    }, t.prototype._initCurve = function(e, r) {
      e === void 0 && (e = 0), r === void 0 && (r = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, r]) : this.moveTo(e, r);
    }, t.prototype.quadraticCurveTo = function(e, r, n, s) {
      this._initCurve();
      var a = this.currentPath.points;
      return a.length === 0 && this.moveTo(0, 0), Qk.curveTo(e, r, n, s, a), this;
    }, t.prototype.bezierCurveTo = function(e, r, n, s, a, o) {
      return this._initCurve(), Jk.curveTo(e, r, n, s, a, o, this.currentPath.points), this;
    }, t.prototype.arcTo = function(e, r, n, s, a) {
      this._initCurve(e, r);
      var o = this.currentPath.points, u = W1.curveTo(e, r, n, s, a, o);
      if (u) {
        var l = u.cx, h = u.cy, d = u.radius, f = u.startAngle, p = u.endAngle, v = u.anticlockwise;
        this.arc(l, h, d, f, p, v);
      }
      return this;
    }, t.prototype.arc = function(e, r, n, s, a, o) {
      if (o === void 0 && (o = !1), s === a)
        return this;
      !o && a <= s ? a += dv : o && s <= a && (s += dv);
      var u = a - s;
      if (u === 0)
        return this;
      var l = e + Math.cos(s) * n, h = r + Math.sin(s) * n, d = this._geometry.closePointEps, f = this.currentPath ? this.currentPath.points : null;
      if (f) {
        var p = Math.abs(f[f.length - 2] - l), v = Math.abs(f[f.length - 1] - h);
        p < d && v < d || f.push(l, h);
      } else
        this.moveTo(l, h), f = this.currentPath.points;
      return W1.arc(l, h, e, r, n, s, a, o, f), this;
    }, t.prototype.beginFill = function(e, r) {
      return e === void 0 && (e = 0), r === void 0 && (r = 1), this.beginTextureFill({ texture: Ot.WHITE, color: e, alpha: r });
    }, t.prototype.beginTextureFill = function(e) {
      e = Object.assign({
        texture: Ot.WHITE,
        color: 16777215,
        alpha: 1,
        matrix: null
      }, e), this.currentPath && this.startPoly();
      var r = e.alpha > 0;
      return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, { visible: r }, e)) : this._fillStyle.reset(), this;
    }, t.prototype.endFill = function() {
      return this.finishPoly(), this._fillStyle.reset(), this;
    }, t.prototype.drawRect = function(e, r, n, s) {
      return this.drawShape(new Nt(e, r, n, s));
    }, t.prototype.drawRoundedRect = function(e, r, n, s, a) {
      return this.drawShape(new jD(e, r, n, s, a));
    }, t.prototype.drawCircle = function(e, r, n) {
      return this.drawShape(new GD(e, r, n));
    }, t.prototype.drawEllipse = function(e, r, n, s) {
      return this.drawShape(new UD(e, r, n, s));
    }, t.prototype.drawPolygon = function() {
      for (var e = arguments, r = [], n = 0; n < arguments.length; n++)
        r[n] = e[n];
      var s, a = !0, o = r[0];
      o.points ? (a = o.closeStroke, s = o.points) : Array.isArray(r[0]) ? s = r[0] : s = r;
      var u = new Cp(s);
      return u.closeStroke = a, this.drawShape(u), this;
    }, t.prototype.drawShape = function(e) {
      return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;
    }, t.prototype.clear = function() {
      return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;
    }, t.prototype.isFastRect = function() {
      var e = this._geometry.graphicsData;
      return e.length === 1 && e[0].shape.type === ur.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width);
    }, t.prototype._render = function(e) {
      this.finishPoly();
      var r = this._geometry;
      r.updateBatches(), r.batchable ? (this.batchDirty !== r.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e));
    }, t.prototype._populateBatches = function() {
      var e = this._geometry, r = this.blendMode, n = e.batches.length;
      this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = n, this.vertexData = new Float32Array(e.points);
      for (var s = 0; s < n; s++) {
        var a = e.batches[s], o = a.style.color, u = new Float32Array(this.vertexData.buffer, a.attribStart * 4 * 2, a.attribSize * 2), l = new Float32Array(e.uvsFloat32.buffer, a.attribStart * 4 * 2, a.attribSize * 2), h = new Uint16Array(e.indicesUint16.buffer, a.start * 2, a.size), d = {
          vertexData: u,
          blendMode: r,
          indices: h,
          uvs: l,
          _batchRGB: Kl(o),
          _tintRGB: o,
          _texture: a.style.texture,
          alpha: a.style.alpha,
          worldAlpha: 1
        };
        this.batches[s] = d;
      }
    }, t.prototype._renderBatched = function(e) {
      if (this.batches.length) {
        e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
        for (var r = 0, n = this.batches.length; r < n; r++) {
          var s = this.batches[r];
          s.worldAlpha = this.worldAlpha * s.alpha, e.plugins[this.pluginName].render(s);
        }
      }
    }, t.prototype._renderDirect = function(e) {
      var r = this._resolveDirectShader(e), n = this._geometry, s = this.tint, a = this.worldAlpha, o = r.uniforms, u = n.drawCalls;
      o.translationMatrix = this.transform.worldTransform, o.tint[0] = (s >> 16 & 255) / 255 * a, o.tint[1] = (s >> 8 & 255) / 255 * a, o.tint[2] = (s & 255) / 255 * a, o.tint[3] = a, e.shader.bind(r), e.geometry.bind(n, r), e.state.set(this.state);
      for (var l = 0, h = u.length; l < h; l++)
        this._renderDrawCallDirect(e, n.drawCalls[l]);
    }, t.prototype._renderDrawCallDirect = function(e, r) {
      for (var n = r.texArray, s = r.type, a = r.size, o = r.start, u = n.count, l = 0; l < u; l++)
        e.texture.bind(n.elements[l], l);
      e.geometry.draw(s, a, o);
    }, t.prototype._resolveDirectShader = function(e) {
      var r = this.shader, n = this.pluginName;
      if (!r) {
        if (!q0[n]) {
          for (var s = e.plugins[n].MAX_TEXTURES, a = new Int32Array(s), o = 0; o < s; o++)
            a[o] = o;
          var u = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new ar(),
            default: la.from({ uSamplers: a }, !0)
          }, l = e.plugins[n]._shader.program;
          q0[n] = new xs(l, u);
        }
        r = q0[n];
      }
      return r;
    }, t.prototype._calculateBounds = function() {
      this.finishPoly();
      var e = this._geometry;
      if (e.graphicsData.length) {
        var r = e.bounds, n = r.minX, s = r.minY, a = r.maxX, o = r.maxY;
        this._bounds.addFrame(this.transform, n, s, a, o);
      }
    }, t.prototype.containsPoint = function(e) {
      return this.worldTransform.applyInverse(e, t._TEMP_POINT), this._geometry.containsPoint(t._TEMP_POINT);
    }, t.prototype.calculateTints = function() {
      if (this.batchTint !== this.tint) {
        this.batchTint = this.tint;
        for (var e = Kl(this.tint, iN), r = 0; r < this.batches.length; r++) {
          var n = this.batches[r], s = n._batchRGB, a = e[0] * s[0] * 255, o = e[1] * s[1] * 255, u = e[2] * s[2] * 255, l = (a << 16) + (o << 8) + (u | 0);
          n._tintRGB = (l >> 16) + (l & 65280) + ((l & 255) << 16);
        }
      }
    }, t.prototype.calculateVertices = function() {
      var e = this.transform._worldID;
      if (this._transformID !== e) {
        this._transformID = e;
        for (var r = this.transform.worldTransform, n = r.a, s = r.b, a = r.c, o = r.d, u = r.tx, l = r.ty, h = this._geometry.points, d = this.vertexData, f = 0, p = 0; p < h.length; p += 2) {
          var v = h[p], g = h[p + 1];
          d[f++] = n * v + a * g + u, d[f++] = o * g + s * v + l;
        }
      }
    }, t.prototype.closePath = function() {
      var e = this.currentPath;
      return e && (e.closeStroke = !0, this.finishPoly()), this;
    }, t.prototype.setMatrix = function(e) {
      return this._matrix = e, this;
    }, t.prototype.beginHole = function() {
      return this.finishPoly(), this._holeMode = !0, this;
    }, t.prototype.endHole = function() {
      return this.finishPoly(), this._holeMode = !1, this;
    }, t.prototype.destroy = function(e) {
      this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, i.prototype.destroy.call(this, e);
    }, t.nextRoundedRectBehavior = !1, t._TEMP_POINT = new xe(), t;
  }(ye)
);
/*!
 * @pixi/sprite - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/sprite is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ry = function(i, t) {
  return Ry = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, Ry(i, t);
};
function nN(i, t) {
  Ry(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var wh = new xe(), sN = new Uint16Array([0, 1, 2, 0, 2, 3]), Ue = (
  /** @class */
  function(i) {
    nN(t, i);
    function t(e) {
      var r = i.call(this) || this;
      return r._anchor = new Pu(r._onAnchorUpdate, r, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), r._texture = null, r._width = 0, r._height = 0, r._tint = null, r._tintRGB = null, r.tint = 16777215, r.blendMode = Et.NORMAL, r._cachedTint = 16777215, r.uvs = null, r.texture = e || Ot.EMPTY, r.vertexData = new Float32Array(8), r.vertexTrimmedData = null, r._transformID = -1, r._textureID = -1, r._transformTrimmedID = -1, r._textureTrimmedID = -1, r.indices = sN, r.pluginName = "batch", r.isSprite = !0, r._roundPixels = gt.ROUND_PIXELS, r;
    }
    return t.prototype._onTextureUpdate = function() {
      this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = Mu(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = Mu(this.scale.y) * this._height / this._texture.orig.height);
    }, t.prototype._onAnchorUpdate = function() {
      this._transformID = -1, this._transformTrimmedID = -1;
    }, t.prototype.calculateVertices = function() {
      var e = this._texture;
      if (!(this._transformID === this.transform._worldID && this._textureID === e._updateID)) {
        this._textureID !== e._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = e._updateID;
        var r = this.transform.worldTransform, n = r.a, s = r.b, a = r.c, o = r.d, u = r.tx, l = r.ty, h = this.vertexData, d = e.trim, f = e.orig, p = this._anchor, v = 0, g = 0, m = 0, y = 0;
        if (d ? (g = d.x - p._x * f.width, v = g + d.width, y = d.y - p._y * f.height, m = y + d.height) : (g = -p._x * f.width, v = g + f.width, y = -p._y * f.height, m = y + f.height), h[0] = n * g + a * y + u, h[1] = o * y + s * g + l, h[2] = n * v + a * y + u, h[3] = o * y + s * v + l, h[4] = n * v + a * m + u, h[5] = o * m + s * v + l, h[6] = n * g + a * m + u, h[7] = o * m + s * g + l, this._roundPixels)
          for (var _ = gt.RESOLUTION, b = 0; b < h.length; ++b)
            h[b] = Math.round((h[b] * _ | 0) / _);
      }
    }, t.prototype.calculateTrimmedVertices = function() {
      if (!this.vertexTrimmedData)
        this.vertexTrimmedData = new Float32Array(8);
      else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
        return;
      this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
      var e = this._texture, r = this.vertexTrimmedData, n = e.orig, s = this._anchor, a = this.transform.worldTransform, o = a.a, u = a.b, l = a.c, h = a.d, d = a.tx, f = a.ty, p = -s._x * n.width, v = p + n.width, g = -s._y * n.height, m = g + n.height;
      r[0] = o * p + l * g + d, r[1] = h * g + u * p + f, r[2] = o * v + l * g + d, r[3] = h * g + u * v + f, r[4] = o * v + l * m + d, r[5] = h * m + u * v + f, r[6] = o * p + l * m + d, r[7] = h * m + u * p + f;
    }, t.prototype._render = function(e) {
      this.calculateVertices(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this);
    }, t.prototype._calculateBounds = function() {
      var e = this._texture.trim, r = this._texture.orig;
      !e || e.width === r.width && e.height === r.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
    }, t.prototype.getLocalBounds = function(e) {
      return this.children.length === 0 ? (this._localBounds || (this._localBounds = new pv()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Nt()), e = this._localBoundsRect), this._localBounds.getRectangle(e)) : i.prototype.getLocalBounds.call(this, e);
    }, t.prototype.containsPoint = function(e) {
      this.worldTransform.applyInverse(e, wh);
      var r = this._texture.orig.width, n = this._texture.orig.height, s = -r * this.anchor.x, a = 0;
      return wh.x >= s && wh.x < s + r && (a = -n * this.anchor.y, wh.y >= a && wh.y < a + n);
    }, t.prototype.destroy = function(e) {
      i.prototype.destroy.call(this, e), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null;
      var r = typeof e == "boolean" ? e : e && e.texture;
      if (r) {
        var n = typeof e == "boolean" ? e : e && e.baseTexture;
        this._texture.destroy(!!n);
      }
      this._texture = null;
    }, t.from = function(e, r) {
      var n = e instanceof Ot ? e : Ot.from(e, r);
      return new t(n);
    }, Object.defineProperty(t.prototype, "roundPixels", {
      get: function() {
        return this._roundPixels;
      },
      /**
       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
       *
       * Advantages can include sharper image quality (like text) and faster rendering on canvas.
       * The main disadvantage is movement of objects may appear less smooth.
       *
       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.
       * @default false
       */
      set: function(e) {
        this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "width", {
      /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
      },
      set: function(e) {
        var r = Mu(this.scale.x) || 1;
        this.scale.x = r * e / this._texture.orig.width, this._width = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
      },
      set: function(e) {
        var r = Mu(this.scale.y) || 1;
        this.scale.y = r * e / this._texture.orig.height, this._height = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "anchor", {
      /**
       * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}
       * and passed to the constructor.
       *
       * The default is `(0,0)`, this means the sprite's origin is the top left.
       *
       * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
       *
       * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
       *
       * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
       * @example
       * const sprite = new PIXI.Sprite(texture);
       * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
       */
      get: function() {
        return this._anchor;
      },
      set: function(e) {
        this._anchor.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      /**
       * The tint applied to the sprite. This is a hex value.
       *
       * A value of 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get: function() {
        return this._tint;
      },
      set: function(e) {
        this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "texture", {
      /** The texture that the sprite is using. */
      get: function() {
        return this._texture;
      },
      set: function(e) {
        this._texture !== e && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = e || Ot.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, e && (e.baseTexture.valid ? this._onTextureUpdate() : e.once("update", this._onTextureUpdate, this)));
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ye)
);
/*!
 * @pixi/text - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/text is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Dy = function(i, t) {
  return Dy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, Dy(i, t);
};
function aN(i, t) {
  Dy(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var lc;
(function(i) {
  i[i.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", i[i.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL";
})(lc || (lc = {}));
var Z0 = {
  align: "left",
  breakWords: !1,
  dropShadow: !1,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: lc.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: !1,
  whiteSpace: "pre",
  wordWrap: !1,
  wordWrapWidth: 100,
  leading: 0
}, oN = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
], Jo = (
  /** @class */
  function() {
    function i(t) {
      this.styleID = 0, this.reset(), J0(this, t, t);
    }
    return i.prototype.clone = function() {
      var t = {};
      return J0(t, this, Z0), new i(t);
    }, i.prototype.reset = function() {
      J0(this, Z0, Z0);
    }, Object.defineProperty(i.prototype, "align", {
      /**
       * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
       *
       * @member {string}
       */
      get: function() {
        return this._align;
      },
      set: function(t) {
        this._align !== t && (this._align = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "breakWords", {
      /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
      get: function() {
        return this._breakWords;
      },
      set: function(t) {
        this._breakWords !== t && (this._breakWords = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "dropShadow", {
      /** Set a drop shadow for the text. */
      get: function() {
        return this._dropShadow;
      },
      set: function(t) {
        this._dropShadow !== t && (this._dropShadow = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "dropShadowAlpha", {
      /** Set alpha for the drop shadow. */
      get: function() {
        return this._dropShadowAlpha;
      },
      set: function(t) {
        this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "dropShadowAngle", {
      /** Set a angle of the drop shadow. */
      get: function() {
        return this._dropShadowAngle;
      },
      set: function(t) {
        this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "dropShadowBlur", {
      /** Set a shadow blur radius. */
      get: function() {
        return this._dropShadowBlur;
      },
      set: function(t) {
        this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "dropShadowColor", {
      /** A fill style to be used on the dropshadow e.g 'red', '#00FF00'. */
      get: function() {
        return this._dropShadowColor;
      },
      set: function(t) {
        var e = K0(t);
        this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "dropShadowDistance", {
      /** Set a distance of the drop shadow. */
      get: function() {
        return this._dropShadowDistance;
      },
      set: function(t) {
        this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "fill", {
      /**
       * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
       *
       * Can be an array to create a gradient eg ['#000000','#FFFFFF']
       * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
       *
       * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
       */
      get: function() {
        return this._fill;
      },
      set: function(t) {
        var e = K0(t);
        this._fill !== e && (this._fill = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "fillGradientType", {
      /**
       * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
       *
       * @see PIXI.TEXT_GRADIENT
       */
      get: function() {
        return this._fillGradientType;
      },
      set: function(t) {
        this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "fillGradientStops", {
      /**
       * If fill is an array of colours to create a gradient, this array can set the stop points
       * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
       */
      get: function() {
        return this._fillGradientStops;
      },
      set: function(t) {
        uN(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "fontFamily", {
      /** The font family. */
      get: function() {
        return this._fontFamily;
      },
      set: function(t) {
        this.fontFamily !== t && (this._fontFamily = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "fontSize", {
      /**
       * The font size
       * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
       */
      get: function() {
        return this._fontSize;
      },
      set: function(t) {
        this._fontSize !== t && (this._fontSize = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "fontStyle", {
      /**
       * The font style
       * ('normal', 'italic' or 'oblique')
       *
       * @member {string}
       */
      get: function() {
        return this._fontStyle;
      },
      set: function(t) {
        this._fontStyle !== t && (this._fontStyle = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "fontVariant", {
      /**
       * The font variant
       * ('normal' or 'small-caps')
       *
       * @member {string}
       */
      get: function() {
        return this._fontVariant;
      },
      set: function(t) {
        this._fontVariant !== t && (this._fontVariant = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "fontWeight", {
      /**
       * The font weight
       * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
       *
       * @member {string}
       */
      get: function() {
        return this._fontWeight;
      },
      set: function(t) {
        this._fontWeight !== t && (this._fontWeight = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "letterSpacing", {
      /** The amount of spacing between letters, default is 0. */
      get: function() {
        return this._letterSpacing;
      },
      set: function(t) {
        this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "lineHeight", {
      /** The line height, a number that represents the vertical space that a letter uses. */
      get: function() {
        return this._lineHeight;
      },
      set: function(t) {
        this._lineHeight !== t && (this._lineHeight = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "leading", {
      /** The space between lines. */
      get: function() {
        return this._leading;
      },
      set: function(t) {
        this._leading !== t && (this._leading = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "lineJoin", {
      /**
       * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
       * Default is 'miter' (creates a sharp corner).
       *
       * @member {string}
       */
      get: function() {
        return this._lineJoin;
      },
      set: function(t) {
        this._lineJoin !== t && (this._lineJoin = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "miterLimit", {
      /**
       * The miter limit to use when using the 'miter' lineJoin mode.
       *
       * This can reduce or increase the spikiness of rendered text.
       */
      get: function() {
        return this._miterLimit;
      },
      set: function(t) {
        this._miterLimit !== t && (this._miterLimit = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "padding", {
      /**
       * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
       * by adding padding to all sides of the text.
       */
      get: function() {
        return this._padding;
      },
      set: function(t) {
        this._padding !== t && (this._padding = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "stroke", {
      /**
       * A canvas fillstyle that will be used on the text stroke
       * e.g 'blue', '#FCFF00'
       */
      get: function() {
        return this._stroke;
      },
      set: function(t) {
        var e = K0(t);
        this._stroke !== e && (this._stroke = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "strokeThickness", {
      /**
       * A number that represents the thickness of the stroke.
       *
       * @default 0
       */
      get: function() {
        return this._strokeThickness;
      },
      set: function(t) {
        this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "textBaseline", {
      /**
       * The baseline of the text that is rendered.
       *
       * @member {string}
       */
      get: function() {
        return this._textBaseline;
      },
      set: function(t) {
        this._textBaseline !== t && (this._textBaseline = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "trim", {
      /** Trim transparent borders. */
      get: function() {
        return this._trim;
      },
      set: function(t) {
        this._trim !== t && (this._trim = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "whiteSpace", {
      /**
       * How newlines and spaces should be handled.
       * Default is 'pre' (preserve, preserve).
       *
       *  value       | New lines     |   Spaces
       *  ---         | ---           |   ---
       * 'normal'     | Collapse      |   Collapse
       * 'pre'        | Preserve      |   Preserve
       * 'pre-line'   | Preserve      |   Collapse
       *
       * @member {string}
       */
      get: function() {
        return this._whiteSpace;
      },
      set: function(t) {
        this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "wordWrap", {
      /** Indicates if word wrap should be used. */
      get: function() {
        return this._wordWrap;
      },
      set: function(t) {
        this._wordWrap !== t && (this._wordWrap = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "wordWrapWidth", {
      /** The width at which text will wrap, it needs wordWrap to be set to true. */
      get: function() {
        return this._wordWrapWidth;
      },
      set: function(t) {
        this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.toFontString = function() {
      var t = typeof this.fontSize == "number" ? this.fontSize + "px" : this.fontSize, e = this.fontFamily;
      Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
      for (var r = e.length - 1; r >= 0; r--) {
        var n = e[r].trim();
        !/([\"\'])[^\'\"]+\1/.test(n) && oN.indexOf(n) < 0 && (n = '"' + n + '"'), e[r] = n;
      }
      return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t + " " + e.join(",");
    }, i;
  }()
);
function Z1(i) {
  return typeof i == "number" ? NE(i) : (typeof i == "string" && i.indexOf("0x") === 0 && (i = i.replace("0x", "#")), i);
}
function K0(i) {
  if (Array.isArray(i)) {
    for (var t = 0; t < i.length; ++t)
      i[t] = Z1(i[t]);
    return i;
  } else
    return Z1(i);
}
function uN(i, t) {
  if (!Array.isArray(i) || !Array.isArray(t) || i.length !== t.length)
    return !1;
  for (var e = 0; e < i.length; ++e)
    if (i[e] !== t[e])
      return !1;
  return !0;
}
function J0(i, t, e) {
  for (var r in e)
    Array.isArray(t[r]) ? i[r] = t[r].slice() : i[r] = t[r];
}
var ip = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: !0
}, Gn = (
  /** @class */
  function() {
    function i(t, e, r, n, s, a, o, u, l) {
      this.text = t, this.style = e, this.width = r, this.height = n, this.lines = s, this.lineWidths = a, this.lineHeight = o, this.maxLineWidth = u, this.fontProperties = l;
    }
    return i.measureText = function(t, e, r, n) {
      n === void 0 && (n = i._canvas), r = r ?? e.wordWrap;
      var s = e.toFontString(), a = i.measureFont(s);
      a.fontSize === 0 && (a.fontSize = e.fontSize, a.ascent = e.fontSize);
      var o = n.getContext("2d", ip);
      o.font = s;
      for (var u = r ? i.wordWrap(t, e, n) : t, l = u.split(/(?:\r\n|\r|\n)/), h = new Array(l.length), d = 0, f = 0; f < l.length; f++) {
        var p = o.measureText(l[f]).width + (l[f].length - 1) * e.letterSpacing;
        h[f] = p, d = Math.max(d, p);
      }
      var v = d + e.strokeThickness;
      e.dropShadow && (v += e.dropShadowDistance);
      var g = e.lineHeight || a.fontSize + e.strokeThickness, m = Math.max(g, a.fontSize + e.strokeThickness) + (l.length - 1) * (g + e.leading);
      return e.dropShadow && (m += e.dropShadowDistance), new i(t, e, v, m, l, h, g + e.leading, d, a);
    }, i.wordWrap = function(t, e, r) {
      r === void 0 && (r = i._canvas);
      for (var n = r.getContext("2d", ip), s = 0, a = "", o = "", u = /* @__PURE__ */ Object.create(null), l = e.letterSpacing, h = e.whiteSpace, d = i.collapseSpaces(h), f = i.collapseNewlines(h), p = !d, v = e.wordWrapWidth + l, g = i.tokenize(t), m = 0; m < g.length; m++) {
        var y = g[m];
        if (i.isNewline(y)) {
          if (!f) {
            o += i.addLine(a), p = !d, a = "", s = 0;
            continue;
          }
          y = " ";
        }
        if (d) {
          var _ = i.isBreakingSpace(y), b = i.isBreakingSpace(a[a.length - 1]);
          if (_ && b)
            continue;
        }
        var w = i.getFromCache(y, l, u, n);
        if (w > v)
          if (a !== "" && (o += i.addLine(a), a = "", s = 0), i.canBreakWords(y, e.breakWords))
            for (var T = i.wordWrapSplit(y), x = 0; x < T.length; x++) {
              for (var S = T[x], C = 1; T[x + C]; ) {
                var M = T[x + C], I = S[S.length - 1];
                if (!i.canBreakChars(I, M, y, x, e.breakWords))
                  S += M;
                else
                  break;
                C++;
              }
              x += S.length - 1;
              var R = i.getFromCache(S, l, u, n);
              R + s > v && (o += i.addLine(a), p = !1, a = "", s = 0), a += S, s += R;
            }
          else {
            a.length > 0 && (o += i.addLine(a), a = "", s = 0);
            var N = m === g.length - 1;
            o += i.addLine(y, !N), p = !1, a = "", s = 0;
          }
        else
          w + s > v && (p = !1, o += i.addLine(a), a = "", s = 0), (a.length > 0 || !i.isBreakingSpace(y) || p) && (a += y, s += w);
      }
      return o += i.addLine(a, !1), o;
    }, i.addLine = function(t, e) {
      return e === void 0 && (e = !0), t = i.trimRight(t), t = e ? t + `
` : t, t;
    }, i.getFromCache = function(t, e, r, n) {
      var s = r[t];
      if (typeof s != "number") {
        var a = t.length * e;
        s = n.measureText(t).width + a, r[t] = s;
      }
      return s;
    }, i.collapseSpaces = function(t) {
      return t === "normal" || t === "pre-line";
    }, i.collapseNewlines = function(t) {
      return t === "normal";
    }, i.trimRight = function(t) {
      if (typeof t != "string")
        return "";
      for (var e = t.length - 1; e >= 0; e--) {
        var r = t[e];
        if (!i.isBreakingSpace(r))
          break;
        t = t.slice(0, -1);
      }
      return t;
    }, i.isNewline = function(t) {
      return typeof t != "string" ? !1 : i._newlines.indexOf(t.charCodeAt(0)) >= 0;
    }, i.isBreakingSpace = function(t, e) {
      return typeof t != "string" ? !1 : i._breakingSpaces.indexOf(t.charCodeAt(0)) >= 0;
    }, i.tokenize = function(t) {
      var e = [], r = "";
      if (typeof t != "string")
        return e;
      for (var n = 0; n < t.length; n++) {
        var s = t[n], a = t[n + 1];
        if (i.isBreakingSpace(s, a) || i.isNewline(s)) {
          r !== "" && (e.push(r), r = ""), e.push(s);
          continue;
        }
        r += s;
      }
      return r !== "" && e.push(r), e;
    }, i.canBreakWords = function(t, e) {
      return e;
    }, i.canBreakChars = function(t, e, r, n, s) {
      return !0;
    }, i.wordWrapSplit = function(t) {
      return t.split("");
    }, i.measureFont = function(t) {
      if (i._fonts[t])
        return i._fonts[t];
      var e = {
        ascent: 0,
        descent: 0,
        fontSize: 0
      }, r = i._canvas, n = i._context;
      n.font = t;
      var s = i.METRICS_STRING + i.BASELINE_SYMBOL, a = Math.ceil(n.measureText(s).width), o = Math.ceil(n.measureText(i.BASELINE_SYMBOL).width), u = Math.ceil(i.HEIGHT_MULTIPLIER * o);
      o = o * i.BASELINE_MULTIPLIER | 0, r.width = a, r.height = u, n.fillStyle = "#f00", n.fillRect(0, 0, a, u), n.font = t, n.textBaseline = "alphabetic", n.fillStyle = "#000", n.fillText(s, 0, o);
      var l = n.getImageData(0, 0, a, u).data, h = l.length, d = a * 4, f = 0, p = 0, v = !1;
      for (f = 0; f < o; ++f) {
        for (var g = 0; g < d; g += 4)
          if (l[p + g] !== 255) {
            v = !0;
            break;
          }
        if (!v)
          p += d;
        else
          break;
      }
      for (e.ascent = o - f, p = h - d, v = !1, f = u; f > o; --f) {
        for (var g = 0; g < d; g += 4)
          if (l[p + g] !== 255) {
            v = !0;
            break;
          }
        if (!v)
          p -= d;
        else
          break;
      }
      return e.descent = f - o, e.fontSize = e.ascent + e.descent, i._fonts[t] = e, e;
    }, i.clearMetrics = function(t) {
      t === void 0 && (t = ""), t ? delete i._fonts[t] : i._fonts = {};
    }, Object.defineProperty(i, "_canvas", {
      /**
       * Cached canvas element for measuring text
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      get: function() {
        if (!i.__canvas) {
          var t = void 0;
          try {
            var e = new OffscreenCanvas(0, 0), r = e.getContext("2d", ip);
            if (r && r.measureText)
              return i.__canvas = e, e;
            t = gt.ADAPTER.createCanvas();
          } catch {
            t = gt.ADAPTER.createCanvas();
          }
          t.width = t.height = 10, i.__canvas = t;
        }
        return i.__canvas;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i, "_context", {
      /**
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      get: function() {
        return i.__context || (i.__context = i._canvas.getContext("2d", ip)), i.__context;
      },
      enumerable: !1,
      configurable: !0
    }), i;
  }()
);
Gn._fonts = {};
Gn.METRICS_STRING = "|ÉqÅ";
Gn.BASELINE_SYMBOL = "M";
Gn.BASELINE_MULTIPLIER = 1.4;
Gn.HEIGHT_MULTIPLIER = 2;
Gn._newlines = [
  10,
  13
];
Gn._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
var lN = {
  texture: !0,
  children: !1,
  baseTexture: !0
}, ex = (
  /** @class */
  function(i) {
    aN(t, i);
    function t(e, r, n) {
      var s = this, a = !1;
      n || (n = gt.ADAPTER.createCanvas(), a = !0), n.width = 3, n.height = 3;
      var o = Ot.from(n);
      return o.orig = new Nt(), o.trim = new Nt(), s = i.call(this, o) || this, s._ownCanvas = a, s.canvas = n, s.context = n.getContext("2d", {
        // required for trimming to work without warnings
        willReadFrequently: !0
      }), s._resolution = gt.RESOLUTION, s._autoResolution = !0, s._text = null, s._style = null, s._styleListener = null, s._font = "", s.text = e, s.style = r, s.localStyleID = -1, s;
    }
    return t.prototype.updateText = function(e) {
      var r = this._style;
      if (this.localStyleID !== r.styleID && (this.dirty = !0, this.localStyleID = r.styleID), !(!this.dirty && e)) {
        this._font = this._style.toFontString();
        var n = this.context, s = Gn.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), a = s.width, o = s.height, u = s.lines, l = s.lineHeight, h = s.lineWidths, d = s.maxLineWidth, f = s.fontProperties;
        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, a) + r.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, o) + r.padding * 2) * this._resolution), n.scale(this._resolution, this._resolution), n.clearRect(0, 0, this.canvas.width, this.canvas.height), n.font = this._font, n.lineWidth = r.strokeThickness, n.textBaseline = r.textBaseline, n.lineJoin = r.lineJoin, n.miterLimit = r.miterLimit;
        for (var p, v, g = r.dropShadow ? 2 : 1, m = 0; m < g; ++m) {
          var y = r.dropShadow && m === 0, _ = y ? Math.ceil(Math.max(1, o) + r.padding * 2) : 0, b = _ * this._resolution;
          if (y) {
            n.fillStyle = "black", n.strokeStyle = "black";
            var w = r.dropShadowColor, T = Kl(typeof w == "number" ? w : AE(w)), x = r.dropShadowBlur * this._resolution, S = r.dropShadowDistance * this._resolution;
            n.shadowColor = "rgba(" + T[0] * 255 + "," + T[1] * 255 + "," + T[2] * 255 + "," + r.dropShadowAlpha + ")", n.shadowBlur = x, n.shadowOffsetX = Math.cos(r.dropShadowAngle) * S, n.shadowOffsetY = Math.sin(r.dropShadowAngle) * S + b;
          } else
            n.fillStyle = this._generateFillStyle(r, u, s), n.strokeStyle = r.stroke, n.shadowColor = "black", n.shadowBlur = 0, n.shadowOffsetX = 0, n.shadowOffsetY = 0;
          var C = (l - f.fontSize) / 2;
          (!t.nextLineHeightBehavior || l - f.fontSize < 0) && (C = 0);
          for (var M = 0; M < u.length; M++)
            p = r.strokeThickness / 2, v = r.strokeThickness / 2 + M * l + f.ascent + C, r.align === "right" ? p += d - h[M] : r.align === "center" && (p += (d - h[M]) / 2), r.stroke && r.strokeThickness && this.drawLetterSpacing(u[M], p + r.padding, v + r.padding - _, !0), r.fill && this.drawLetterSpacing(u[M], p + r.padding, v + r.padding - _);
        }
        this.updateTexture();
      }
    }, t.prototype.drawLetterSpacing = function(e, r, n, s) {
      s === void 0 && (s = !1);
      var a = this._style, o = a.letterSpacing, u = t.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
      if (o === 0 || u) {
        u && (this.context.letterSpacing = o, this.context.textLetterSpacing = o), s ? this.context.strokeText(e, r, n) : this.context.fillText(e, r, n);
        return;
      }
      for (var l = r, h = Array.from ? Array.from(e) : e.split(""), d = this.context.measureText(e).width, f = 0, p = 0; p < h.length; ++p) {
        var v = h[p];
        s ? this.context.strokeText(v, l, n) : this.context.fillText(v, l, n);
        for (var g = "", m = p + 1; m < h.length; ++m)
          g += h[m];
        f = this.context.measureText(g).width, l += d - f + o, d = f;
      }
    }, t.prototype.updateTexture = function() {
      var e = this.canvas;
      if (this._style.trim) {
        var r = AD(e);
        r.data && (e.width = r.width, e.height = r.height, this.context.putImageData(r.data, 0, 0));
      }
      var n = this._texture, s = this._style, a = s.trim ? 0 : s.padding, o = n.baseTexture;
      n.trim.width = n._frame.width = e.width / this._resolution, n.trim.height = n._frame.height = e.height / this._resolution, n.trim.x = -a, n.trim.y = -a, n.orig.width = n._frame.width - a * 2, n.orig.height = n._frame.height - a * 2, this._onTextureUpdate(), o.setRealSize(e.width, e.height, this._resolution), n.updateUvs(), this.dirty = !1;
    }, t.prototype._render = function(e) {
      this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), i.prototype._render.call(this, e);
    }, t.prototype.updateTransform = function() {
      this.updateText(!0), i.prototype.updateTransform.call(this);
    }, t.prototype.getBounds = function(e, r) {
      return this.updateText(!0), this._textureID === -1 && (e = !1), i.prototype.getBounds.call(this, e, r);
    }, t.prototype.getLocalBounds = function(e) {
      return this.updateText(!0), i.prototype.getLocalBounds.call(this, e);
    }, t.prototype._calculateBounds = function() {
      this.calculateVertices(), this._bounds.addQuad(this.vertexData);
    }, t.prototype._generateFillStyle = function(e, r, n) {
      var s = e.fill;
      if (Array.isArray(s)) {
        if (s.length === 1)
          return s[0];
      } else
        return s;
      var a, o = e.dropShadow ? e.dropShadowDistance : 0, u = e.padding || 0, l = this.canvas.width / this._resolution - o - u * 2, h = this.canvas.height / this._resolution - o - u * 2, d = s.slice(), f = e.fillGradientStops.slice();
      if (!f.length)
        for (var p = d.length + 1, v = 1; v < p; ++v)
          f.push(v / p);
      if (d.unshift(s[0]), f.unshift(0), d.push(s[s.length - 1]), f.push(1), e.fillGradientType === lc.LINEAR_VERTICAL) {
        a = this.context.createLinearGradient(l / 2, u, l / 2, h + u);
        for (var g = n.fontProperties.fontSize + e.strokeThickness, v = 0; v < r.length; v++) {
          var m = n.lineHeight * (v - 1) + g, y = n.lineHeight * v, _ = y;
          v > 0 && m > y && (_ = (y + m) / 2);
          var b = y + g, w = n.lineHeight * (v + 1), T = b;
          v + 1 < r.length && w < b && (T = (b + w) / 2);
          for (var x = (T - _) / h, S = 0; S < d.length; S++) {
            var C = 0;
            typeof f[S] == "number" ? C = f[S] : C = S / d.length;
            var M = Math.min(1, Math.max(0, _ / h + C * x));
            M = Number(M.toFixed(5)), a.addColorStop(M, d[S]);
          }
        }
      } else {
        a = this.context.createLinearGradient(u, h / 2, l + u, h / 2);
        for (var I = d.length + 1, R = 1, v = 0; v < d.length; v++) {
          var N = void 0;
          typeof f[v] == "number" ? N = f[v] : N = R / I, a.addColorStop(N, d[v]), R++;
        }
      }
      return a;
    }, t.prototype.destroy = function(e) {
      typeof e == "boolean" && (e = { children: e }), e = Object.assign({}, lN, e), i.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;
    }, Object.defineProperty(t.prototype, "width", {
      /** The width of the Text, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;
      },
      set: function(e) {
        this.updateText(!0);
        var r = Mu(this.scale.x) || 1;
        this.scale.x = r * e / this._texture.orig.width, this._width = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the Text, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;
      },
      set: function(e) {
        this.updateText(!0);
        var r = Mu(this.scale.y) || 1;
        this.scale.y = r * e / this._texture.orig.height, this._height = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "style", {
      /**
       * Set the style of the text.
       *
       * Set up an event listener to listen for changes on the style object and mark the text as dirty.
       */
      get: function() {
        return this._style;
      },
      set: function(e) {
        e = e || {}, e instanceof Jo ? this._style = e : this._style = new Jo(e), this.localStyleID = -1, this.dirty = !0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "text", {
      /** Set the copy for the text object. To split a line you can use '\n'. */
      get: function() {
        return this._text;
      },
      set: function(e) {
        e = String(e ?? ""), this._text !== e && (this._text = e, this.dirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "resolution", {
      /**
       * The resolution / device pixel ratio of the canvas.
       *
       * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
       * @default 1
       */
      get: function() {
        return this._resolution;
      },
      set: function(e) {
        this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), t.nextLineHeightBehavior = !1, t.experimentalLetterSpacing = !1, t;
  }(Ue)
);
/*!
 * @pixi/prepare - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/prepare is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
gt.UPLOADS_PER_FRAME = 4;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ky = function(i, t) {
  return ky = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, ky(i, t);
};
function hN(i, t) {
  ky(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var cN = (
  /** @class */
  function() {
    function i(t) {
      this.maxItemsPerFrame = t, this.itemsLeft = 0;
    }
    return i.prototype.beginFrame = function() {
      this.itemsLeft = this.maxItemsPerFrame;
    }, i.prototype.allowedToUpload = function() {
      return this.itemsLeft-- > 0;
    }, i;
  }()
);
function fN(i, t) {
  var e = !1;
  if (i && i._textures && i._textures.length) {
    for (var r = 0; r < i._textures.length; r++)
      if (i._textures[r] instanceof Ot) {
        var n = i._textures[r].baseTexture;
        t.indexOf(n) === -1 && (t.push(n), e = !0);
      }
  }
  return e;
}
function dN(i, t) {
  if (i.baseTexture instanceof Kt) {
    var e = i.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function pN(i, t) {
  if (i._texture && i._texture instanceof Ot) {
    var e = i._texture.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function vN(i, t) {
  return t instanceof ex ? (t.updateText(!0), !0) : !1;
}
function gN(i, t) {
  if (t instanceof Jo) {
    var e = t.toFontString();
    return Gn.measureFont(e), !0;
  }
  return !1;
}
function mN(i, t) {
  if (i instanceof ex) {
    t.indexOf(i.style) === -1 && t.push(i.style), t.indexOf(i) === -1 && t.push(i);
    var e = i._texture.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function yN(i, t) {
  return i instanceof Jo ? (t.indexOf(i) === -1 && t.push(i), !0) : !1;
}
var _N = (
  /** @class */
  function() {
    function i(t) {
      var e = this;
      this.limiter = new cN(gt.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function() {
        e.queue && e.prepareItems();
      }, this.registerFindHook(mN), this.registerFindHook(yN), this.registerFindHook(fN), this.registerFindHook(dN), this.registerFindHook(pN), this.registerUploadHook(vN), this.registerUploadHook(gN);
    }
    return i.prototype.upload = function(t, e) {
      var r = this;
      return typeof t == "function" && (e = t, t = null), e && jr("6.5.0", "BasePrepare.upload callback is deprecated, use the return Promise instead."), new Promise(function(n) {
        t && r.add(t);
        var s = function() {
          e == null || e(), n();
        };
        r.queue.length ? (r.completes.push(s), r.ticking || (r.ticking = !0, Ge.system.addOnce(r.tick, r, Cs.UTILITY))) : s();
      });
    }, i.prototype.tick = function() {
      setTimeout(this.delayedTick, 0);
    }, i.prototype.prepareItems = function() {
      for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
        var t = this.queue[0], e = !1;
        if (t && !t._destroyed) {
          for (var r = 0, n = this.uploadHooks.length; r < n; r++)
            if (this.uploadHooks[r](this.uploadHookHelper, t)) {
              this.queue.shift(), e = !0;
              break;
            }
        }
        e || this.queue.shift();
      }
      if (this.queue.length)
        Ge.system.addOnce(this.tick, this, Cs.UTILITY);
      else {
        this.ticking = !1;
        var s = this.completes.slice(0);
        this.completes.length = 0;
        for (var r = 0, n = s.length; r < n; r++)
          s[r]();
      }
    }, i.prototype.registerFindHook = function(t) {
      return t && this.addHooks.push(t), this;
    }, i.prototype.registerUploadHook = function(t) {
      return t && this.uploadHooks.push(t), this;
    }, i.prototype.add = function(t) {
      for (var e = 0, r = this.addHooks.length; e < r && !this.addHooks[e](t, this.queue); e++)
        ;
      if (t instanceof ye)
        for (var e = t.children.length - 1; e >= 0; e--)
          this.add(t.children[e]);
      return this;
    }, i.prototype.destroy = function() {
      this.ticking && Ge.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;
    }, i;
  }()
);
function SS(i, t) {
  return t instanceof Kt ? (t._glTextures[i.CONTEXT_UID] || i.texture.bind(t), !0) : !1;
}
function bN(i, t) {
  if (!(t instanceof si))
    return !1;
  var e = t.geometry;
  t.finishPoly(), e.updateBatches();
  for (var r = e.batches, n = 0; n < r.length; n++) {
    var s = r[n].style.texture;
    s && SS(i, s.baseTexture);
  }
  return e.batchable || i.geometry.bind(e, t._resolveDirectShader(i)), !0;
}
function xN(i, t) {
  return i instanceof si ? (t.push(i), !0) : !1;
}
var wN = (
  /** @class */
  function(i) {
    hN(t, i);
    function t(e) {
      var r = i.call(this, e) || this;
      return r.uploadHookHelper = r.renderer, r.registerFindHook(xN), r.registerUploadHook(SS), r.registerUploadHook(bN), r;
    }
    return t.extension = {
      name: "prepare",
      type: de.RendererPlugin
    }, t;
  }(_N)
);
/*!
 * @pixi/spritesheet - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/spritesheet is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var EN = (
  /** @class */
  function() {
    function i(t, e, r) {
      r === void 0 && (r = null), this.linkedSheets = [], this._texture = t instanceof Ot ? t : null, this.baseTexture = t instanceof Kt ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;
      var n = this.baseTexture.resource;
      this.resolution = this._updateResolution(r || (n ? n.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
    }
    return i.prototype._updateResolution = function(t) {
      t === void 0 && (t = null);
      var e = this.data.meta.scale, r = fv(t, null);
      return r === null && (r = e !== void 0 ? parseFloat(e) : 1), r !== 1 && this.baseTexture.setResolution(r), r;
    }, i.prototype.parse = function(t) {
      var e = this;
      return t && jr("6.5.0", "Spritesheet.parse callback is deprecated, use the return Promise instead."), new Promise(function(r) {
        e._callback = function(n) {
          t == null || t(n), r(n);
        }, e._batchIndex = 0, e._frameKeys.length <= i.BATCH_SIZE ? (e._processFrames(0), e._processAnimations(), e._parseComplete()) : e._nextBatch();
      });
    }, i.prototype._processFrames = function(t) {
      for (var e = t, r = i.BATCH_SIZE; e - t < r && e < this._frameKeys.length; ) {
        var n = this._frameKeys[e], s = this._frames[n], a = s.frame;
        if (a) {
          var o = null, u = null, l = s.trimmed !== !1 && s.sourceSize ? s.sourceSize : s.frame, h = new Nt(0, 0, Math.floor(l.w) / this.resolution, Math.floor(l.h) / this.resolution);
          s.rotated ? o = new Nt(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.h) / this.resolution, Math.floor(a.w) / this.resolution) : o = new Nt(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution), s.trimmed !== !1 && s.spriteSourceSize && (u = new Nt(Math.floor(s.spriteSourceSize.x) / this.resolution, Math.floor(s.spriteSourceSize.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution)), this.textures[n] = new Ot(this.baseTexture, o, h, u, s.rotated ? 2 : 0, s.anchor), Ot.addToCache(this.textures[n], n);
        }
        e++;
      }
    }, i.prototype._processAnimations = function() {
      var t = this.data.animations || {};
      for (var e in t) {
        this.animations[e] = [];
        for (var r = 0; r < t[e].length; r++) {
          var n = t[e][r];
          this.animations[e].push(this.textures[n]);
        }
      }
    }, i.prototype._parseComplete = function() {
      var t = this._callback;
      this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
    }, i.prototype._nextBatch = function() {
      var t = this;
      this._processFrames(this._batchIndex * i.BATCH_SIZE), this._batchIndex++, setTimeout(function() {
        t._batchIndex * i.BATCH_SIZE < t._frameKeys.length ? t._nextBatch() : (t._processAnimations(), t._parseComplete());
      }, 0);
    }, i.prototype.destroy = function(t) {
      var e;
      t === void 0 && (t = !1);
      for (var r in this.textures)
        this.textures[r].destroy();
      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) === null || e === void 0 || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];
    }, i.BATCH_SIZE = 1e3, i;
  }()
), SN = (
  /** @class */
  function() {
    function i() {
    }
    return i.use = function(t, e) {
      var r, n, s = this, a = t.name + "_image";
      if (!t.data || t.type !== Ft.TYPE.JSON || !t.data.frames || s.resources[a]) {
        e();
        return;
      }
      var o = (n = (r = t.data) === null || r === void 0 ? void 0 : r.meta) === null || n === void 0 ? void 0 : n.related_multi_packs;
      if (Array.isArray(o))
        for (var u = function(v) {
          if (typeof v != "string")
            return "continue";
          var g = v.replace(".json", ""), m = Cu.resolve(t.url.replace(s.baseUrl, ""), v);
          if (s.resources[g] || Object.values(s.resources).some(function(_) {
            return Cu.format(Cu.parse(_.url)) === m;
          }))
            return "continue";
          var y = {
            crossOrigin: t.crossOrigin,
            loadType: Ft.LOAD_TYPE.XHR,
            xhrType: Ft.XHR_RESPONSE_TYPE.JSON,
            parentResource: t,
            metadata: t.metadata
          };
          s.add(g, m, y);
        }, l = 0, h = o; l < h.length; l++) {
          var d = h[l];
          u(d);
        }
      var f = {
        crossOrigin: t.crossOrigin,
        metadata: t.metadata.imageMetadata,
        parentResource: t
      }, p = i.getResourcePath(t, s.baseUrl);
      s.add(a, p, f, function(g) {
        if (g.error) {
          e(g.error);
          return;
        }
        var m = new EN(g.texture, t.data, t.url);
        m.parse().then(function() {
          t.spritesheet = m, t.textures = m.textures, e();
        });
      });
    }, i.getResourcePath = function(t, e) {
      return t.isDataUrl ? t.data.meta.image : Cu.resolve(t.url.replace(e, ""), t.data.meta.image);
    }, i.extension = de.Loader, i;
  }()
);
/*!
 * @pixi/sprite-tiling - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ny = function(i, t) {
  return Ny = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, Ny(i, t);
};
function TS(i, t) {
  Ny(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Eh = new xe();
(function(i) {
  TS(t, i);
  function t(e, r, n) {
    r === void 0 && (r = 100), n === void 0 && (n = 100);
    var s = i.call(this, e) || this;
    return s.tileTransform = new zE(), s._width = r, s._height = n, s.uvMatrix = s.texture.uvMatrix || new n0(e), s.pluginName = "tilingSprite", s.uvRespectAnchor = !1, s;
  }
  return Object.defineProperty(t.prototype, "clampMargin", {
    /**
     * Changes frame clamping in corresponding textureTransform, shortcut
     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
     * @default 0.5
     * @member {number}
     */
    get: function() {
      return this.uvMatrix.clampMargin;
    },
    set: function(e) {
      this.uvMatrix.clampMargin = e, this.uvMatrix.update(!0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tileScale", {
    /** The scaling of the image that is being tiled. */
    get: function() {
      return this.tileTransform.scale;
    },
    set: function(e) {
      this.tileTransform.scale.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tilePosition", {
    /** The offset of the image that is being tiled. */
    get: function() {
      return this.tileTransform.position;
    },
    set: function(e) {
      this.tileTransform.position.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._onTextureUpdate = function() {
    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;
  }, t.prototype._render = function(e) {
    var r = this._texture;
    !r || !r.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this));
  }, t.prototype._calculateBounds = function() {
    var e = this._width * -this._anchor._x, r = this._height * -this._anchor._y, n = this._width * (1 - this._anchor._x), s = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, e, r, n, s);
  }, t.prototype.getLocalBounds = function(e) {
    return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Nt()), e = this._localBoundsRect), this._bounds.getRectangle(e)) : i.prototype.getLocalBounds.call(this, e);
  }, t.prototype.containsPoint = function(e) {
    this.worldTransform.applyInverse(e, Eh);
    var r = this._width, n = this._height, s = -r * this.anchor._x;
    if (Eh.x >= s && Eh.x < s + r) {
      var a = -n * this.anchor._y;
      if (Eh.y >= a && Eh.y < a + n)
        return !0;
    }
    return !1;
  }, t.prototype.destroy = function(e) {
    i.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null;
  }, t.from = function(e, r) {
    var n = e instanceof Ot ? e : Ot.from(e, r);
    return new t(n, r.width, r.height);
  }, Object.defineProperty(t.prototype, "width", {
    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this._width;
    },
    set: function(e) {
      this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this._height;
    },
    set: function(e) {
      this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Ue);
var TN = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`, K1 = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, CN = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`, MN = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, PN = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`, np = new ar(), ON = (
  /** @class */
  function(i) {
    TS(t, i);
    function t(e) {
      var r = i.call(this, e) || this;
      return e.runners.contextChange.add(r), r.quad = new kb(), r.state = va.for2d(), r;
    }
    return t.prototype.contextChange = function() {
      var e = this.renderer, r = { globals: e.globalUniforms };
      this.simpleShader = xs.from(K1, TN, r), this.shader = e.context.webGLVersion > 1 ? xs.from(MN, PN, r) : xs.from(K1, CN, r);
    }, t.prototype.render = function(e) {
      var r = this.renderer, n = this.quad, s = n.vertices;
      s[0] = s[6] = e._width * -e.anchor.x, s[1] = s[3] = e._height * -e.anchor.y, s[2] = s[4] = e._width * (1 - e.anchor.x), s[5] = s[7] = e._height * (1 - e.anchor.y);
      var a = e.uvRespectAnchor ? e.anchor.x : 0, o = e.uvRespectAnchor ? e.anchor.y : 0;
      s = n.uvs, s[0] = s[6] = -a, s[1] = s[3] = -o, s[2] = s[4] = 1 - a, s[5] = s[7] = 1 - o, n.invalidate();
      var u = e._texture, l = u.baseTexture, h = l.alphaMode > 0, d = e.tileTransform.localTransform, f = e.uvMatrix, p = l.isPowerOfTwo && u.frame.width === l.width && u.frame.height === l.height;
      p && (l._glTextures[r.CONTEXT_UID] ? p = l.wrapMode !== On.CLAMP : l.wrapMode === On.CLAMP && (l.wrapMode = On.REPEAT));
      var v = p ? this.simpleShader : this.shader, g = u.width, m = u.height, y = e._width, _ = e._height;
      np.set(d.a * g / y, d.b * g / _, d.c * m / y, d.d * m / _, d.tx / y, d.ty / _), np.invert(), p ? np.prepend(f.mapCoord) : (v.uniforms.uMapCoord = f.mapCoord.toArray(!0), v.uniforms.uClampFrame = f.uClampFrame, v.uniforms.uClampOffset = f.uClampOffset), v.uniforms.uTransform = np.toArray(!0), v.uniforms.uColor = FE(e.tint, e.worldAlpha, v.uniforms.uColor, h), v.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0), v.uniforms.uSampler = u, r.shader.bind(v), r.geometry.bind(n), this.state.blendMode = BE(e.blendMode, h), r.state.set(this.state), r.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    }, t.extension = {
      name: "tilingSprite",
      type: de.RendererPlugin
    }, t;
  }(bd)
);
/*!
 * @pixi/mesh - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/mesh is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ay = function(i, t) {
  return Ay = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, Ay(i, t);
};
function rx(i, t) {
  Ay(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var IN = (
  /** @class */
  function() {
    function i(t, e) {
      this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;
    }
    return i.prototype.update = function(t) {
      if (!(!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)) {
        this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
        var e = this.uvBuffer.data;
        (!this.data || this.data.length !== e.length) && (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++;
      }
    }, i;
  }()
), Q0 = new xe(), J1 = new Cp(), hc = (
  /** @class */
  function(i) {
    rx(t, i);
    function t(e, r, n, s) {
      s === void 0 && (s = qi.TRIANGLES);
      var a = i.call(this) || this;
      return a.geometry = e, a.shader = r, a.state = n || va.for2d(), a.drawMode = s, a.start = 0, a.size = 0, a.uvs = null, a.indices = null, a.vertexData = new Float32Array(1), a.vertexDirty = -1, a._transformID = -1, a._roundPixels = gt.ROUND_PIXELS, a.batchUvs = null, a;
    }
    return Object.defineProperty(t.prototype, "geometry", {
      /**
       * Includes vertex positions, face indices, normals, colors, UVs, and
       * custom attributes within buffers, reducing the cost of passing all
       * this data to the GPU. Can be shared between multiple Mesh objects.
       */
      get: function() {
        return this._geometry;
      },
      set: function(e) {
        this._geometry !== e && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "uvBuffer", {
      /**
       * To change mesh uv's, change its uvBuffer data and increment its _updateID.
       * @readonly
       */
      get: function() {
        return this.geometry.buffers[1];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "verticesBuffer", {
      /**
       * To change mesh vertices, change its uvBuffer data and increment its _updateID.
       * Incrementing _updateID is optional because most of Mesh objects do it anyway.
       * @readonly
       */
      get: function() {
        return this.geometry.buffers[0];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "material", {
      get: function() {
        return this.shader;
      },
      /** Alias for {@link PIXI.Mesh#shader}. */
      set: function(e) {
        this.shader = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "blendMode", {
      get: function() {
        return this.state.blendMode;
      },
      /**
       * The blend mode to be applied to the Mesh. Apply a value of
       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * @default PIXI.BLEND_MODES.NORMAL;
       */
      set: function(e) {
        this.state.blendMode = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "roundPixels", {
      get: function() {
        return this._roundPixels;
      },
      /**
       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
       * Advantages can include sharper image quality (like text) and faster rendering on canvas.
       * The main disadvantage is movement of objects may appear less smooth.
       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
       * @default false
       */
      set: function(e) {
        this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      /**
       * The multiply tint applied to the Mesh. This is a hex value. A value of
       * `0xFFFFFF` will remove any tint effect.
       *
       * Null for non-MeshMaterial shaders
       * @default 0xFFFFFF
       */
      get: function() {
        return "tint" in this.shader ? this.shader.tint : null;
      },
      set: function(e) {
        this.shader.tint = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "texture", {
      /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
      get: function() {
        return "texture" in this.shader ? this.shader.texture : null;
      },
      set: function(e) {
        this.shader.texture = e;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype._render = function(e) {
      var r = this.geometry.buffers[0].data, n = this.shader;
      n.batchable && this.drawMode === qi.TRIANGLES && r.length < t.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e);
    }, t.prototype._renderDefault = function(e) {
      var r = this.shader;
      r.alpha = this.worldAlpha, r.update && r.update(), e.batch.flush(), r.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(r), e.state.set(this.state), e.geometry.bind(this.geometry, r), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    }, t.prototype._renderToBatch = function(e) {
      var r = this.geometry, n = this.shader;
      n.uvMatrix && (n.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = r.indexBuffer.data, this._tintRGB = n._tintRGB, this._texture = n.texture;
      var s = this.material.pluginName;
      e.batch.setObjectRenderer(e.plugins[s]), e.plugins[s].render(this);
    }, t.prototype.calculateVertices = function() {
      var e = this.geometry, r = e.buffers[0], n = r.data, s = r._updateID;
      if (!(s === this.vertexDirty && this._transformID === this.transform._worldID)) {
        this._transformID = this.transform._worldID, this.vertexData.length !== n.length && (this.vertexData = new Float32Array(n.length));
        for (var a = this.transform.worldTransform, o = a.a, u = a.b, l = a.c, h = a.d, d = a.tx, f = a.ty, p = this.vertexData, v = 0; v < p.length / 2; v++) {
          var g = n[v * 2], m = n[v * 2 + 1];
          p[v * 2] = o * g + l * m + d, p[v * 2 + 1] = u * g + h * m + f;
        }
        if (this._roundPixels)
          for (var y = gt.RESOLUTION, v = 0; v < p.length; ++v)
            p[v] = Math.round((p[v] * y | 0) / y);
        this.vertexDirty = s;
      }
    }, t.prototype.calculateUvs = function() {
      var e = this.geometry.buffers[1], r = this.shader;
      r.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new IN(e, r.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);
    }, t.prototype._calculateBounds = function() {
      this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    }, t.prototype.containsPoint = function(e) {
      if (!this.getBounds().contains(e.x, e.y))
        return !1;
      this.worldTransform.applyInverse(e, Q0);
      for (var r = this.geometry.getBuffer("aVertexPosition").data, n = J1.points, s = this.geometry.getIndex().data, a = s.length, o = this.drawMode === 4 ? 3 : 1, u = 0; u + 2 < a; u += o) {
        var l = s[u] * 2, h = s[u + 1] * 2, d = s[u + 2] * 2;
        if (n[0] = r[l], n[1] = r[l + 1], n[2] = r[h], n[3] = r[h + 1], n[4] = r[d], n[5] = r[d + 1], J1.contains(Q0.x, Q0.y))
          return !0;
      }
      return !1;
    }, t.prototype.destroy = function(e) {
      i.prototype.destroy.call(this, e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;
    }, t.BATCHABLE_SIZE = 100, t;
  }(ye)
), RN = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`, DN = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`, cc = (
  /** @class */
  function(i) {
    rx(t, i);
    function t(e, r) {
      var n = this, s = {
        uSampler: e,
        alpha: 1,
        uTextureMatrix: ar.IDENTITY,
        uColor: new Float32Array([1, 1, 1, 1])
      };
      return r = Object.assign({
        tint: 16777215,
        alpha: 1,
        pluginName: "batch"
      }, r), r.uniforms && Object.assign(s, r.uniforms), n = i.call(this, r.program || lh.from(DN, RN), s) || this, n._colorDirty = !1, n.uvMatrix = new n0(e), n.batchable = r.program === void 0, n.pluginName = r.pluginName, n.tint = r.tint, n.alpha = r.alpha, n;
    }
    return Object.defineProperty(t.prototype, "texture", {
      /** Reference to the texture being rendered. */
      get: function() {
        return this.uniforms.uSampler;
      },
      set: function(e) {
        this.uniforms.uSampler !== e && (!this.uniforms.uSampler.baseTexture.alphaMode != !e.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = e, this.uvMatrix.texture = e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "alpha", {
      get: function() {
        return this._alpha;
      },
      /**
       * This gets automatically set by the object using this.
       * @default 1
       */
      set: function(e) {
        e !== this._alpha && (this._alpha = e, this._colorDirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      get: function() {
        return this._tint;
      },
      /**
       * Multiply tint for the material.
       * @default 0xFFFFFF
       */
      set: function(e) {
        e !== this._tint && (this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16), this._colorDirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.update = function() {
      if (this._colorDirty) {
        this._colorDirty = !1;
        var e = this.texture.baseTexture;
        FE(this._tint, this._alpha, this.uniforms.uColor, e.alphaMode);
      }
      this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
    }, t;
  }(xs)
), s0 = (
  /** @class */
  function(i) {
    rx(t, i);
    function t(e, r, n) {
      var s = i.call(this) || this, a = new Ke(e), o = new Ke(r, !0), u = new Ke(n, !0, !0);
      return s.addAttribute("aVertexPosition", a, 2, !1, It.FLOAT).addAttribute("aTextureCoord", o, 2, !1, It.FLOAT).addIndex(u), s._updateId = -1, s;
    }
    return Object.defineProperty(t.prototype, "vertexDirtyId", {
      /**
       * If the vertex position is updated.
       * @readonly
       * @private
       */
      get: function() {
        return this.buffers[0]._updateID;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uh)
);
/*!
 * @pixi/text-bitmap - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/text-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ly = function(i, t) {
  return Ly = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, Ly(i, t);
};
function kN(i, t) {
  Ly(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var xv = (
  /** @class */
  function() {
    function i() {
      this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];
    }
    return i;
  }()
), NN = (
  /** @class */
  function() {
    function i() {
    }
    return i.test = function(t) {
      return typeof t == "string" && t.indexOf("info face=") === 0;
    }, i.parse = function(t) {
      var e = t.match(/^[a-z]+\s+.+$/gm), r = {
        info: [],
        common: [],
        page: [],
        char: [],
        chars: [],
        kerning: [],
        kernings: [],
        distanceField: []
      };
      for (var n in e) {
        var s = e[n].match(/^[a-z]+/gm)[0], a = e[n].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), o = {};
        for (var u in a) {
          var l = a[u].split("="), h = l[0], d = l[1].replace(/"/gm, ""), f = parseFloat(d), p = isNaN(f) ? d : f;
          o[h] = p;
        }
        r[s].push(o);
      }
      var v = new xv();
      return r.info.forEach(function(g) {
        return v.info.push({
          face: g.face,
          size: parseInt(g.size, 10)
        });
      }), r.common.forEach(function(g) {
        return v.common.push({
          lineHeight: parseInt(g.lineHeight, 10)
        });
      }), r.page.forEach(function(g) {
        return v.page.push({
          id: parseInt(g.id, 10),
          file: g.file
        });
      }), r.char.forEach(function(g) {
        return v.char.push({
          id: parseInt(g.id, 10),
          page: parseInt(g.page, 10),
          x: parseInt(g.x, 10),
          y: parseInt(g.y, 10),
          width: parseInt(g.width, 10),
          height: parseInt(g.height, 10),
          xoffset: parseInt(g.xoffset, 10),
          yoffset: parseInt(g.yoffset, 10),
          xadvance: parseInt(g.xadvance, 10)
        });
      }), r.kerning.forEach(function(g) {
        return v.kerning.push({
          first: parseInt(g.first, 10),
          second: parseInt(g.second, 10),
          amount: parseInt(g.amount, 10)
        });
      }), r.distanceField.forEach(function(g) {
        return v.distanceField.push({
          distanceRange: parseInt(g.distanceRange, 10),
          fieldType: g.fieldType
        });
      }), v;
    }, i;
  }()
), By = (
  /** @class */
  function() {
    function i() {
    }
    return i.test = function(t) {
      return t instanceof XMLDocument && t.getElementsByTagName("page").length && t.getElementsByTagName("info")[0].getAttribute("face") !== null;
    }, i.parse = function(t) {
      for (var e = new xv(), r = t.getElementsByTagName("info"), n = t.getElementsByTagName("common"), s = t.getElementsByTagName("page"), a = t.getElementsByTagName("char"), o = t.getElementsByTagName("kerning"), u = t.getElementsByTagName("distanceField"), l = 0; l < r.length; l++)
        e.info.push({
          face: r[l].getAttribute("face"),
          size: parseInt(r[l].getAttribute("size"), 10)
        });
      for (var l = 0; l < n.length; l++)
        e.common.push({
          lineHeight: parseInt(n[l].getAttribute("lineHeight"), 10)
        });
      for (var l = 0; l < s.length; l++)
        e.page.push({
          id: parseInt(s[l].getAttribute("id"), 10) || 0,
          file: s[l].getAttribute("file")
        });
      for (var l = 0; l < a.length; l++) {
        var h = a[l];
        e.char.push({
          id: parseInt(h.getAttribute("id"), 10),
          page: parseInt(h.getAttribute("page"), 10) || 0,
          x: parseInt(h.getAttribute("x"), 10),
          y: parseInt(h.getAttribute("y"), 10),
          width: parseInt(h.getAttribute("width"), 10),
          height: parseInt(h.getAttribute("height"), 10),
          xoffset: parseInt(h.getAttribute("xoffset"), 10),
          yoffset: parseInt(h.getAttribute("yoffset"), 10),
          xadvance: parseInt(h.getAttribute("xadvance"), 10)
        });
      }
      for (var l = 0; l < o.length; l++)
        e.kerning.push({
          first: parseInt(o[l].getAttribute("first"), 10),
          second: parseInt(o[l].getAttribute("second"), 10),
          amount: parseInt(o[l].getAttribute("amount"), 10)
        });
      for (var l = 0; l < u.length; l++)
        e.distanceField.push({
          fieldType: u[l].getAttribute("fieldType"),
          distanceRange: parseInt(u[l].getAttribute("distanceRange"), 10)
        });
      return e;
    }, i;
  }()
), AN = (
  /** @class */
  function() {
    function i() {
    }
    return i.test = function(t) {
      if (typeof t == "string" && t.indexOf("<font>") > -1) {
        var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
        return By.test(e);
      }
      return !1;
    }, i.parse = function(t) {
      var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
      return By.parse(e);
    }, i;
  }()
), ty = [
  NN,
  By,
  AN
];
function CS(i) {
  for (var t = 0; t < ty.length; t++)
    if (ty[t].test(i))
      return ty[t];
  return null;
}
function LN(i, t, e, r, n, s) {
  var a = e.fill;
  if (Array.isArray(a)) {
    if (a.length === 1)
      return a[0];
  } else
    return a;
  var o, u = e.dropShadow ? e.dropShadowDistance : 0, l = e.padding || 0, h = i.width / r - u - l * 2, d = i.height / r - u - l * 2, f = a.slice(), p = e.fillGradientStops.slice();
  if (!p.length)
    for (var v = f.length + 1, g = 1; g < v; ++g)
      p.push(g / v);
  if (f.unshift(a[0]), p.unshift(0), f.push(a[a.length - 1]), p.push(1), e.fillGradientType === lc.LINEAR_VERTICAL) {
    o = t.createLinearGradient(h / 2, l, h / 2, d + l);
    for (var m = 0, y = s.fontProperties.fontSize + e.strokeThickness, _ = y / d, g = 0; g < n.length; g++)
      for (var b = s.lineHeight * g, w = 0; w < f.length; w++) {
        var T = 0;
        typeof p[w] == "number" ? T = p[w] : T = w / f.length;
        var x = b / d + T * _, S = Math.max(m, x);
        S = Math.min(S, 1), o.addColorStop(S, f[w]), m = S;
      }
  } else {
    o = t.createLinearGradient(l, d / 2, h + l, d / 2);
    for (var C = f.length + 1, M = 1, g = 0; g < f.length; g++) {
      var I = void 0;
      typeof p[g] == "number" ? I = p[g] : I = M / C, o.addColorStop(I, f[g]), M++;
    }
  }
  return o;
}
function BN(i, t, e, r, n, s, a) {
  var o = e.text, u = e.fontProperties;
  t.translate(r, n), t.scale(s, s);
  var l = a.strokeThickness / 2, h = -(a.strokeThickness / 2);
  if (t.font = a.toFontString(), t.lineWidth = a.strokeThickness, t.textBaseline = a.textBaseline, t.lineJoin = a.lineJoin, t.miterLimit = a.miterLimit, t.fillStyle = LN(i, t, a, s, [o], e), t.strokeStyle = a.stroke, a.dropShadow) {
    var d = a.dropShadowColor, f = Kl(typeof d == "number" ? d : AE(d)), p = a.dropShadowBlur * s, v = a.dropShadowDistance * s;
    t.shadowColor = "rgba(" + f[0] * 255 + "," + f[1] * 255 + "," + f[2] * 255 + "," + a.dropShadowAlpha + ")", t.shadowBlur = p, t.shadowOffsetX = Math.cos(a.dropShadowAngle) * v, t.shadowOffsetY = Math.sin(a.dropShadowAngle) * v;
  } else
    t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
  a.stroke && a.strokeThickness && t.strokeText(o, l, h + e.lineHeight - u.descent), a.fill && t.fillText(o, l, h + e.lineHeight - u.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = "rgba(0, 0, 0, 0)";
}
function MS(i) {
  return Array.from ? Array.from(i) : i.split("");
}
function FN(i) {
  typeof i == "string" && (i = [i]);
  for (var t = [], e = 0, r = i.length; e < r; e++) {
    var n = i[e];
    if (Array.isArray(n)) {
      if (n.length !== 2)
        throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + n.length + ".");
      var s = n[0].charCodeAt(0), a = n[1].charCodeAt(0);
      if (a < s)
        throw new Error("[BitmapFont]: Invalid character range.");
      for (var o = s, u = a; o <= u; o++)
        t.push(String.fromCharCode(o));
    } else
      t.push.apply(t, MS(n));
  }
  if (t.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return t;
}
function Pp(i) {
  return i.codePointAt ? i.codePointAt(0) : i.charCodeAt(0);
}
var ks = (
  /** @class */
  function() {
    function i(t, e, r) {
      var n, s, a = t.info[0], o = t.common[0], u = t.page[0], l = t.distanceField[0], h = fv(u.file), d = {};
      this._ownsTextures = r, this.font = a.face, this.size = a.size, this.lineHeight = o.lineHeight / h, this.chars = {}, this.pageTextures = d;
      for (var f = 0; f < t.page.length; f++) {
        var p = t.page[f], v = p.id, g = p.file;
        d[v] = e instanceof Array ? e[f] : e[g], l != null && l.fieldType && l.fieldType !== "none" && (d[v].baseTexture.alphaMode = en.NO_PREMULTIPLIED_ALPHA, d[v].baseTexture.mipmap = tn.OFF);
      }
      for (var f = 0; f < t.char.length; f++) {
        var m = t.char[f], v = m.id, y = m.page, _ = t.char[f], b = _.x, w = _.y, T = _.width, x = _.height, S = _.xoffset, C = _.yoffset, M = _.xadvance;
        b /= h, w /= h, T /= h, x /= h, S /= h, C /= h, M /= h;
        var I = new Nt(b + d[y].frame.x / h, w + d[y].frame.y / h, T, x);
        this.chars[v] = {
          xOffset: S,
          yOffset: C,
          xAdvance: M,
          kerning: {},
          texture: new Ot(d[y].baseTexture, I),
          page: y
        };
      }
      for (var f = 0; f < t.kerning.length; f++) {
        var R = t.kerning[f], N = R.first, A = R.second, G = R.amount;
        N /= h, A /= h, G /= h, this.chars[A] && (this.chars[A].kerning[N] = G);
      }
      this.distanceFieldRange = l == null ? void 0 : l.distanceRange, this.distanceFieldType = (s = (n = l == null ? void 0 : l.fieldType) === null || n === void 0 ? void 0 : n.toLowerCase()) !== null && s !== void 0 ? s : "none";
    }
    return i.prototype.destroy = function() {
      for (var t in this.chars)
        this.chars[t].texture.destroy(), this.chars[t].texture = null;
      for (var t in this.pageTextures)
        this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;
      this.chars = null, this.pageTextures = null;
    }, i.install = function(t, e, r) {
      var n;
      if (t instanceof xv)
        n = t;
      else {
        var s = CS(t);
        if (!s)
          throw new Error("Unrecognized data format for font.");
        n = s.parse(t);
      }
      e instanceof Ot && (e = [e]);
      var a = new i(n, e, r);
      return i.available[a.font] = a, a;
    }, i.uninstall = function(t) {
      var e = i.available[t];
      if (!e)
        throw new Error("No font found named '" + t + "'");
      e.destroy(), delete i.available[t];
    }, i.from = function(t, e, r) {
      if (!t)
        throw new Error("[BitmapFont] Property `name` is required.");
      var n = Object.assign({}, i.defaultOptions, r), s = n.chars, a = n.padding, o = n.resolution, u = n.textureWidth, l = n.textureHeight, h = FN(s), d = e instanceof Jo ? e : new Jo(e), f = u, p = new xv();
      p.info[0] = {
        face: d.fontFamily,
        size: d.fontSize
      }, p.common[0] = {
        lineHeight: d.fontSize
      };
      for (var v = 0, g = 0, m, y, _, b = 0, w = [], T = 0; T < h.length; T++) {
        m || (m = gt.ADAPTER.createCanvas(), m.width = u, m.height = l, y = m.getContext("2d"), _ = new Kt(m, { resolution: o }), w.push(new Ot(_)), p.page.push({
          id: w.length - 1,
          file: ""
        }));
        var x = h[T], S = Gn.measureText(x, d, !1, m), C = S.width, M = Math.ceil(S.height), I = Math.ceil((d.fontStyle === "italic" ? 2 : 1) * C);
        if (g >= l - M * o) {
          if (g === 0)
            throw new Error("[BitmapFont] textureHeight " + l + "px is too small " + ("(fontFamily: '" + d.fontFamily + "', fontSize: " + d.fontSize + "px, char: '" + x + "')"));
          --T, m = null, y = null, _ = null, g = 0, v = 0, b = 0;
          continue;
        }
        if (b = Math.max(M + S.fontProperties.descent, b), I * o + v >= f) {
          if (v === 0)
            throw new Error("[BitmapFont] textureWidth " + u + "px is too small " + ("(fontFamily: '" + d.fontFamily + "', fontSize: " + d.fontSize + "px, char: '" + x + "')"));
          --T, g += b * o, g = Math.ceil(g), v = 0, b = 0;
          continue;
        }
        BN(m, y, S, v, g, o, d);
        var R = Pp(S.text);
        p.char.push({
          id: R,
          page: w.length - 1,
          x: v / o,
          y: g / o,
          width: I,
          height: M,
          xoffset: 0,
          yoffset: 0,
          xadvance: Math.ceil(C - (d.dropShadow ? d.dropShadowDistance : 0) - (d.stroke ? d.strokeThickness : 0))
        }), v += (I + 2 * a) * o, v = Math.ceil(v);
      }
      for (var T = 0, N = h.length; T < N; T++)
        for (var A = h[T], G = 0; G < N; G++) {
          var B = h[G], U = y.measureText(A).width, $ = y.measureText(B).width, Z = y.measureText(A + B).width, H = Z - (U + $);
          H && p.kerning.push({
            first: Pp(A),
            second: Pp(B),
            amount: H
          });
        }
      var z = new i(p, w, !0);
      return i.available[t] !== void 0 && i.uninstall(t), i.available[t] = z, z;
    }, i.ALPHA = [["a", "z"], ["A", "Z"], " "], i.NUMERIC = [["0", "9"]], i.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], i.ASCII = [[" ", "~"]], i.defaultOptions = {
      resolution: 1,
      textureWidth: 512,
      textureHeight: 512,
      padding: 4,
      chars: i.ALPHANUMERIC
    }, i.available = {}, i;
  }()
), GN = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r
\r
}\r
`, UN = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`, Q1 = [], tw = [], ew = [];
(function(i) {
  kN(t, i);
  function t(e, r) {
    r === void 0 && (r = {});
    var n = i.call(this) || this;
    n._tint = 16777215;
    var s = Object.assign({}, t.styleDefaults, r), a = s.align, o = s.tint, u = s.maxWidth, l = s.letterSpacing, h = s.fontName, d = s.fontSize;
    if (!ks.available[h])
      throw new Error('Missing BitmapFont "' + h + '"');
    return n._activePagesMeshData = [], n._textWidth = 0, n._textHeight = 0, n._align = a, n._tint = o, n._font = void 0, n._fontName = h, n._fontSize = d, n.text = e, n._maxWidth = u, n._maxLineHeight = 0, n._letterSpacing = l, n._anchor = new Pu(function() {
      n.dirty = !0;
    }, n, 0, 0), n._roundPixels = gt.ROUND_PIXELS, n.dirty = !0, n._resolution = gt.RESOLUTION, n._autoResolution = !0, n._textureCache = {}, n;
  }
  return t.prototype.updateText = function() {
    for (var e, r = ks.available[this._fontName], n = this.fontSize, s = n / r.size, a = new xe(), o = [], u = [], l = [], h = this._text.replace(/(?:\r\n|\r)/g, `
`) || " ", d = MS(h), f = this._maxWidth * r.size / n, p = r.distanceFieldType === "none" ? Q1 : tw, v = null, g = 0, m = 0, y = 0, _ = -1, b = 0, w = 0, T = 0, x = 0, S = 0; S < d.length; S++) {
      var C = d[S], M = Pp(C);
      if (/(?:\s)/.test(C) && (_ = S, b = g, x++), C === "\r" || C === `
`) {
        u.push(g), l.push(-1), m = Math.max(m, g), ++y, ++w, a.x = 0, a.y += r.lineHeight, v = null, x = 0;
        continue;
      }
      var I = r.chars[M];
      if (I) {
        v && I.kerning[v] && (a.x += I.kerning[v]);
        var R = ew.pop() || {
          texture: Ot.EMPTY,
          line: 0,
          charCode: 0,
          prevSpaces: 0,
          position: new xe()
        };
        R.texture = I.texture, R.line = y, R.charCode = M, R.position.x = a.x + I.xOffset + this._letterSpacing / 2, R.position.y = a.y + I.yOffset, R.prevSpaces = x, o.push(R), g = R.position.x + Math.max(I.xAdvance - I.xOffset, I.texture.orig.width), a.x += I.xAdvance + this._letterSpacing, T = Math.max(T, I.yOffset + I.texture.height), v = M, _ !== -1 && f > 0 && a.x > f && (++w, Lu(o, 1 + _ - w, 1 + S - _), S = _, _ = -1, u.push(b), l.push(o.length > 0 ? o[o.length - 1].prevSpaces : 0), m = Math.max(m, b), y++, a.x = 0, a.y += r.lineHeight, v = null, x = 0);
      }
    }
    var N = d[d.length - 1];
    N !== "\r" && N !== `
` && (/(?:\s)/.test(N) && (g = b), u.push(g), m = Math.max(m, g), l.push(-1));
    for (var A = [], S = 0; S <= y; S++) {
      var G = 0;
      this._align === "right" ? G = m - u[S] : this._align === "center" ? G = (m - u[S]) / 2 : this._align === "justify" && (G = l[S] < 0 ? 0 : (m - u[S]) / l[S]), A.push(G);
    }
    var B = o.length, U = {}, $ = [], Z = this._activePagesMeshData;
    p.push.apply(p, Z);
    for (var S = 0; S < B; S++) {
      var H = o[S].texture, z = H.baseTexture.uid;
      if (!U[z]) {
        var X = p.pop();
        if (!X) {
          var ct = new s0(), it = void 0, lt = void 0;
          r.distanceFieldType === "none" ? (it = new cc(Ot.EMPTY), lt = Et.NORMAL) : (it = new cc(Ot.EMPTY, { program: lh.from(UN, GN), uniforms: { uFWidth: 0 } }), lt = Et.NORMAL_NPM);
          var et = new hc(ct, it);
          et.blendMode = lt, X = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh: et,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        X.index = 0, X.indexCount = 0, X.vertexCount = 0, X.uvsCount = 0, X.total = 0;
        var k = this._textureCache;
        k[z] = k[z] || new Ot(H.baseTexture), X.mesh.texture = k[z], X.mesh.tint = this._tint, $.push(X), U[z] = X;
      }
      U[z].total++;
    }
    for (var S = 0; S < Z.length; S++)
      $.indexOf(Z[S]) === -1 && this.removeChild(Z[S].mesh);
    for (var S = 0; S < $.length; S++)
      $[S].mesh.parent !== this && this.addChild($[S].mesh);
    this._activePagesMeshData = $;
    for (var S in U) {
      var X = U[S], ft = X.total;
      if (!(((e = X.indices) === null || e === void 0 ? void 0 : e.length) > 6 * ft) || X.vertices.length < hc.BATCHABLE_SIZE * 2)
        X.vertices = new Float32Array(4 * 2 * ft), X.uvs = new Float32Array(4 * 2 * ft), X.indices = new Uint16Array(6 * ft);
      else
        for (var Q = X.total, St = X.vertices, at = Q * 4 * 2; at < St.length; at++)
          St[at] = 0;
      X.mesh.size = 6 * ft;
    }
    for (var S = 0; S < B; S++) {
      var C = o[S], q = C.position.x + A[C.line] * (this._align === "justify" ? C.prevSpaces : 1);
      this._roundPixels && (q = Math.round(q));
      var bt = q * s, st = C.position.y * s, H = C.texture, W = U[H.baseTexture.uid], nt = H.frame, dt = H._uvs, V = W.index++;
      W.indices[V * 6 + 0] = 0 + V * 4, W.indices[V * 6 + 1] = 1 + V * 4, W.indices[V * 6 + 2] = 2 + V * 4, W.indices[V * 6 + 3] = 0 + V * 4, W.indices[V * 6 + 4] = 2 + V * 4, W.indices[V * 6 + 5] = 3 + V * 4, W.vertices[V * 8 + 0] = bt, W.vertices[V * 8 + 1] = st, W.vertices[V * 8 + 2] = bt + nt.width * s, W.vertices[V * 8 + 3] = st, W.vertices[V * 8 + 4] = bt + nt.width * s, W.vertices[V * 8 + 5] = st + nt.height * s, W.vertices[V * 8 + 6] = bt, W.vertices[V * 8 + 7] = st + nt.height * s, W.uvs[V * 8 + 0] = dt.x0, W.uvs[V * 8 + 1] = dt.y0, W.uvs[V * 8 + 2] = dt.x1, W.uvs[V * 8 + 3] = dt.y1, W.uvs[V * 8 + 4] = dt.x2, W.uvs[V * 8 + 5] = dt.y2, W.uvs[V * 8 + 6] = dt.x3, W.uvs[V * 8 + 7] = dt.y3;
    }
    this._textWidth = m * s, this._textHeight = (a.y + r.lineHeight) * s;
    for (var S in U) {
      var X = U[S];
      if (this.anchor.x !== 0 || this.anchor.y !== 0)
        for (var xt = 0, Dt = this._textWidth * this.anchor.x, Ct = this._textHeight * this.anchor.y, be = 0; be < X.total; be++)
          X.vertices[xt++] -= Dt, X.vertices[xt++] -= Ct, X.vertices[xt++] -= Dt, X.vertices[xt++] -= Ct, X.vertices[xt++] -= Dt, X.vertices[xt++] -= Ct, X.vertices[xt++] -= Dt, X.vertices[xt++] -= Ct;
      this._maxLineHeight = T * s;
      var je = X.mesh.geometry.getBuffer("aVertexPosition"), ee = X.mesh.geometry.getBuffer("aTextureCoord"), pe = X.mesh.geometry.getIndex();
      je.data = X.vertices, ee.data = X.uvs, pe.data = X.indices, je.update(), ee.update(), pe.update();
    }
    for (var S = 0; S < o.length; S++)
      ew.push(o[S]);
    this._font = r, this.dirty = !1;
  }, t.prototype.updateTransform = function() {
    this.validate(), this.containerUpdateTransform();
  }, t.prototype._render = function(e) {
    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);
    var r = ks.available[this._fontName], n = r.distanceFieldRange, s = r.distanceFieldType, a = r.size;
    if (s !== "none")
      for (var o = this.worldTransform, u = o.a, l = o.b, h = o.c, d = o.d, f = Math.sqrt(u * u + l * l), p = Math.sqrt(h * h + d * d), v = (Math.abs(f) + Math.abs(p)) / 2, g = this.fontSize / a, m = 0, y = this._activePagesMeshData; m < y.length; m++) {
        var _ = y[m];
        _.mesh.shader.uniforms.uFWidth = v * n * g * this._resolution;
      }
    i.prototype._render.call(this, e);
  }, t.prototype.getLocalBounds = function() {
    return this.validate(), i.prototype.getLocalBounds.call(this);
  }, t.prototype.validate = function() {
    var e = ks.available[this._fontName];
    if (!e)
      throw new Error('Missing BitmapFont "' + this._fontName + '"');
    this._font !== e && (this.dirty = !0), this.dirty && this.updateText();
  }, Object.defineProperty(t.prototype, "tint", {
    /**
     * The tint of the BitmapText object.
     * @default 0xffffff
     */
    get: function() {
      return this._tint;
    },
    set: function(e) {
      if (this._tint !== e) {
        this._tint = e;
        for (var r = 0; r < this._activePagesMeshData.length; r++)
          this._activePagesMeshData[r].mesh.tint = e;
      }
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "align", {
    /**
     * The alignment of the BitmapText object.
     * @member {string}
     * @default 'left'
     */
    get: function() {
      return this._align;
    },
    set: function(e) {
      this._align !== e && (this._align = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fontName", {
    /** The name of the BitmapFont. */
    get: function() {
      return this._fontName;
    },
    set: function(e) {
      if (!ks.available[e])
        throw new Error('Missing BitmapFont "' + e + '"');
      this._fontName !== e && (this._fontName = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fontSize", {
    /** The size of the font to display. */
    get: function() {
      var e;
      return (e = this._fontSize) !== null && e !== void 0 ? e : ks.available[this._fontName].size;
    },
    set: function(e) {
      this._fontSize !== e && (this._fontSize = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "anchor", {
    /**
     * The anchor sets the origin point of the text.
     *
     * The default is `(0,0)`, this means the text's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
     */
    get: function() {
      return this._anchor;
    },
    set: function(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "text", {
    /** The text of the BitmapText object. */
    get: function() {
      return this._text;
    },
    set: function(e) {
      e = String(e ?? ""), this._text !== e && (this._text = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "maxWidth", {
    /**
     * The max width of this bitmap text in pixels. If the text provided is longer than the
     * value provided, line breaks will be automatically inserted in the last whitespace.
     * Disable by setting the value to 0.
     */
    get: function() {
      return this._maxWidth;
    },
    set: function(e) {
      this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "maxLineHeight", {
    /**
     * The max line height. This is useful when trying to use the total height of the Text,
     * i.e. when trying to vertically align.
     * @readonly
     */
    get: function() {
      return this.validate(), this._maxLineHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textWidth", {
    /**
     * The width of the overall text, different from fontSize,
     * which is defined in the style object.
     * @readonly
     */
    get: function() {
      return this.validate(), this._textWidth;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "letterSpacing", {
    /** Additional space between characters. */
    get: function() {
      return this._letterSpacing;
    },
    set: function(e) {
      this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "roundPixels", {
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     * @default PIXI.settings.ROUND_PIXELS
     */
    get: function() {
      return this._roundPixels;
    },
    set: function(e) {
      e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textHeight", {
    /**
     * The height of the overall text, different from fontSize,
     * which is defined in the style object.
     * @readonly
     */
    get: function() {
      return this.validate(), this._textHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "resolution", {
    /**
     * The resolution / device pixel ratio of the canvas.
     *
     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
     * @default 1
     */
    get: function() {
      return this._resolution;
    },
    set: function(e) {
      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.destroy = function(e) {
    var r = this._textureCache, n = ks.available[this._fontName], s = n.distanceFieldType === "none" ? Q1 : tw;
    s.push.apply(s, this._activePagesMeshData);
    for (var a = 0, o = this._activePagesMeshData; a < o.length; a++) {
      var u = o[a];
      this.removeChild(u.mesh);
    }
    this._activePagesMeshData = [], s.filter(function(d) {
      return r[d.mesh.texture.baseTexture.uid];
    }).forEach(function(d) {
      d.mesh.texture = Ot.EMPTY;
    });
    for (var l in r) {
      var h = r[l];
      h.destroy(), delete r[l];
    }
    this._font = null, this._textureCache = null, i.prototype.destroy.call(this, e);
  }, t.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
  }, t;
})(ye);
var jN = (
  /** @class */
  function() {
    function i() {
    }
    return i.add = function() {
      Ft.setExtensionXhrType("fnt", Ft.XHR_RESPONSE_TYPE.TEXT);
    }, i.use = function(t, e) {
      var r = CS(t.data);
      if (!r) {
        e();
        return;
      }
      for (var n = i.getBaseUrl(this, t), s = r.parse(t.data), a = {}, o = function(g) {
        a[g.metadata.pageFile] = g.texture, Object.keys(a).length === s.page.length && (t.bitmapFont = ks.install(s, a, !0), e());
      }, u = 0; u < s.page.length; ++u) {
        var l = s.page[u].file, h = n + l, d = !1;
        for (var f in this.resources) {
          var p = this.resources[f];
          if (p.url === h) {
            p.metadata.pageFile = l, p.texture ? o(p) : p.onAfterMiddleware.add(o), d = !0;
            break;
          }
        }
        if (!d) {
          var v = {
            crossOrigin: t.crossOrigin,
            loadType: Ft.LOAD_TYPE.IMAGE,
            metadata: Object.assign({ pageFile: l }, t.metadata.imageMetadata),
            parentResource: t
          };
          this.add(h, v, o);
        }
      }
    }, i.getBaseUrl = function(t, e) {
      var r = e.isDataUrl ? "" : i.dirname(e.url);
      return e.isDataUrl && (r === "." && (r = ""), t.baseUrl && r && t.baseUrl.charAt(t.baseUrl.length - 1) === "/" && (r += "/")), r = r.replace(t.baseUrl, ""), r && r.charAt(r.length - 1) !== "/" && (r += "/"), r;
    }, i.dirname = function(t) {
      var e = t.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
      return e === t ? "." : e === "" ? "/" : e;
    }, i.extension = de.Loader, i;
  }()
);
/*!
 * @pixi/filter-alpha - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-alpha is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Fy = function(i, t) {
  return Fy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, Fy(i, t);
};
function zN(i, t) {
  Fy(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var HN = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
(function(i) {
  zN(t, i);
  function t(e) {
    e === void 0 && (e = 1);
    var r = i.call(this, fS, HN, { uAlpha: 1 }) || this;
    return r.alpha = e, r;
  }
  return Object.defineProperty(t.prototype, "alpha", {
    /**
     * Coefficient for alpha multiplication
     * @default 1
     */
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(e) {
      this.uniforms.uAlpha = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(rn);
/*!
 * @pixi/filter-blur - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Gy = function(i, t) {
  return Gy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, Gy(i, t);
};
function PS(i, t) {
  Gy(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var $N = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function VN(i, t) {
  var e = Math.ceil(i / 2), r = $N, n = "", s;
  t ? s = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : s = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  for (var a = 0; a < i; a++) {
    var o = s.replace("%index%", a.toString());
    o = o.replace("%sampleIndex%", a - (e - 1) + ".0"), n += o, n += `
`;
  }
  return r = r.replace("%blur%", n), r = r.replace("%size%", i.toString()), r;
}
var XN = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
}, WN = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join(`
`);
function YN(i) {
  for (var t = XN[i], e = t.length, r = WN, n = "", s = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;", a, o = 0; o < i; o++) {
    var u = s.replace("%index%", o.toString());
    a = o, o >= e && (a = i - o - 1), u = u.replace("%value%", t[a].toString()), n += u, n += `
`;
  }
  return r = r.replace("%blur%", n), r = r.replace("%size%", i.toString()), r;
}
var rw = (
  /** @class */
  function(i) {
    PS(t, i);
    function t(e, r, n, s, a) {
      r === void 0 && (r = 8), n === void 0 && (n = 4), s === void 0 && (s = gt.FILTER_RESOLUTION), a === void 0 && (a = 5);
      var o = this, u = VN(a, e), l = YN(a);
      return o = i.call(
        this,
        // vertex shader
        u,
        // fragment shader
        l
      ) || this, o.horizontal = e, o.resolution = s, o._quality = 0, o.quality = n, o.blur = r, o;
    }
    return t.prototype.apply = function(e, r, n, s) {
      if (n ? this.horizontal ? this.uniforms.strength = 1 / n.width * (n.width / r.width) : this.uniforms.strength = 1 / n.height * (n.height / r.height) : this.horizontal ? this.uniforms.strength = 1 / e.renderer.width * (e.renderer.width / r.width) : this.uniforms.strength = 1 / e.renderer.height * (e.renderer.height / r.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)
        e.applyFilter(this, r, n, s);
      else {
        var a = e.getFilterTexture(), o = e.renderer, u = r, l = a;
        this.state.blend = !1, e.applyFilter(this, u, l, Wi.CLEAR);
        for (var h = 1; h < this.passes - 1; h++) {
          e.bindAndClear(u, Wi.BLIT), this.uniforms.uSampler = l;
          var d = l;
          l = u, u = d, o.shader.bind(this), o.geometry.draw(5);
        }
        this.state.blend = !0, e.applyFilter(this, l, n, s), e.returnFilterTexture(a);
      }
    }, Object.defineProperty(t.prototype, "blur", {
      /**
       * Sets the strength of both the blur.
       * @default 16
       */
      get: function() {
        return this.strength;
      },
      set: function(e) {
        this.padding = 1 + Math.abs(e) * 2, this.strength = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "quality", {
      /**
       * Sets the quality of the blur by modifying the number of passes. More passes means higher
       * quality bluring but the lower the performance.
       * @default 4
       */
      get: function() {
        return this._quality;
      },
      set: function(e) {
        this._quality = e, this.passes = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rn)
);
(function(i) {
  PS(t, i);
  function t(e, r, n, s) {
    e === void 0 && (e = 8), r === void 0 && (r = 4), n === void 0 && (n = gt.FILTER_RESOLUTION), s === void 0 && (s = 5);
    var a = i.call(this) || this;
    return a.blurXFilter = new rw(!0, e, r, n, s), a.blurYFilter = new rw(!1, e, r, n, s), a.resolution = n, a.quality = r, a.blur = e, a.repeatEdgePixels = !1, a;
  }
  return t.prototype.apply = function(e, r, n, s) {
    var a = Math.abs(this.blurXFilter.strength), o = Math.abs(this.blurYFilter.strength);
    if (a && o) {
      var u = e.getFilterTexture();
      this.blurXFilter.apply(e, r, u, Wi.CLEAR), this.blurYFilter.apply(e, u, n, s), e.returnFilterTexture(u);
    } else
      o ? this.blurYFilter.apply(e, r, n, s) : this.blurXFilter.apply(e, r, n, s);
  }, t.prototype.updatePadding = function() {
    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
  }, Object.defineProperty(t.prototype, "blur", {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     * @default 2
     */
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(e) {
      this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "quality", {
    /**
     * Sets the number of passes for blur. More passes means higher quality bluring.
     * @default 1
     */
    get: function() {
      return this.blurXFilter.quality;
    },
    set: function(e) {
      this.blurXFilter.quality = this.blurYFilter.quality = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blurX", {
    /**
     * Sets the strength of the blurX property
     * @default 2
     */
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(e) {
      this.blurXFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blurY", {
    /**
     * Sets the strength of the blurY property
     * @default 2
     */
    get: function() {
      return this.blurYFilter.blur;
    },
    set: function(e) {
      this.blurYFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blendMode", {
    /**
     * Sets the blendmode of the filter
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get: function() {
      return this.blurYFilter.blendMode;
    },
    set: function(e) {
      this.blurYFilter.blendMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "repeatEdgePixels", {
    /**
     * If set to true the edge of the target will be clamped
     * @default false
     */
    get: function() {
      return this._repeatEdgePixels;
    },
    set: function(e) {
      this._repeatEdgePixels = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(rn);
/*!
 * @pixi/filter-color-matrix - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-color-matrix is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Uy = function(i, t) {
  return Uy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, Uy(i, t);
};
function qN(i, t) {
  Uy(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var ZN = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`, iw = (
  /** @class */
  function(i) {
    qN(t, i);
    function t() {
      var e = this, r = {
        m: new Float32Array([
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]),
        uAlpha: 1
      };
      return e = i.call(this, Zb, ZN, r) || this, e.alpha = 1, e;
    }
    return t.prototype._loadMatrix = function(e, r) {
      r === void 0 && (r = !1);
      var n = e;
      r && (this._multiply(n, this.uniforms.m, e), n = this._colorMatrix(n)), this.uniforms.m = n;
    }, t.prototype._multiply = function(e, r, n) {
      return e[0] = r[0] * n[0] + r[1] * n[5] + r[2] * n[10] + r[3] * n[15], e[1] = r[0] * n[1] + r[1] * n[6] + r[2] * n[11] + r[3] * n[16], e[2] = r[0] * n[2] + r[1] * n[7] + r[2] * n[12] + r[3] * n[17], e[3] = r[0] * n[3] + r[1] * n[8] + r[2] * n[13] + r[3] * n[18], e[4] = r[0] * n[4] + r[1] * n[9] + r[2] * n[14] + r[3] * n[19] + r[4], e[5] = r[5] * n[0] + r[6] * n[5] + r[7] * n[10] + r[8] * n[15], e[6] = r[5] * n[1] + r[6] * n[6] + r[7] * n[11] + r[8] * n[16], e[7] = r[5] * n[2] + r[6] * n[7] + r[7] * n[12] + r[8] * n[17], e[8] = r[5] * n[3] + r[6] * n[8] + r[7] * n[13] + r[8] * n[18], e[9] = r[5] * n[4] + r[6] * n[9] + r[7] * n[14] + r[8] * n[19] + r[9], e[10] = r[10] * n[0] + r[11] * n[5] + r[12] * n[10] + r[13] * n[15], e[11] = r[10] * n[1] + r[11] * n[6] + r[12] * n[11] + r[13] * n[16], e[12] = r[10] * n[2] + r[11] * n[7] + r[12] * n[12] + r[13] * n[17], e[13] = r[10] * n[3] + r[11] * n[8] + r[12] * n[13] + r[13] * n[18], e[14] = r[10] * n[4] + r[11] * n[9] + r[12] * n[14] + r[13] * n[19] + r[14], e[15] = r[15] * n[0] + r[16] * n[5] + r[17] * n[10] + r[18] * n[15], e[16] = r[15] * n[1] + r[16] * n[6] + r[17] * n[11] + r[18] * n[16], e[17] = r[15] * n[2] + r[16] * n[7] + r[17] * n[12] + r[18] * n[17], e[18] = r[15] * n[3] + r[16] * n[8] + r[17] * n[13] + r[18] * n[18], e[19] = r[15] * n[4] + r[16] * n[9] + r[17] * n[14] + r[18] * n[19] + r[19], e;
    }, t.prototype._colorMatrix = function(e) {
      var r = new Float32Array(e);
      return r[4] /= 255, r[9] /= 255, r[14] /= 255, r[19] /= 255, r;
    }, t.prototype.brightness = function(e, r) {
      var n = [
        e,
        0,
        0,
        0,
        0,
        0,
        e,
        0,
        0,
        0,
        0,
        0,
        e,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, r);
    }, t.prototype.tint = function(e, r) {
      var n = e >> 16 & 255, s = e >> 8 & 255, a = e & 255, o = [
        n / 255,
        0,
        0,
        0,
        0,
        0,
        s / 255,
        0,
        0,
        0,
        0,
        0,
        a / 255,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(o, r);
    }, t.prototype.greyscale = function(e, r) {
      var n = [
        e,
        e,
        e,
        0,
        0,
        e,
        e,
        e,
        0,
        0,
        e,
        e,
        e,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, r);
    }, t.prototype.blackAndWhite = function(e) {
      var r = [
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.hue = function(e, r) {
      e = (e || 0) / 180 * Math.PI;
      var n = Math.cos(e), s = Math.sin(e), a = Math.sqrt, o = 1 / 3, u = a(o), l = n + (1 - n) * o, h = o * (1 - n) - u * s, d = o * (1 - n) + u * s, f = o * (1 - n) + u * s, p = n + o * (1 - n), v = o * (1 - n) - u * s, g = o * (1 - n) - u * s, m = o * (1 - n) + u * s, y = n + o * (1 - n), _ = [
        l,
        h,
        d,
        0,
        0,
        f,
        p,
        v,
        0,
        0,
        g,
        m,
        y,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(_, r);
    }, t.prototype.contrast = function(e, r) {
      var n = (e || 0) + 1, s = -0.5 * (n - 1), a = [
        n,
        0,
        0,
        0,
        s,
        0,
        n,
        0,
        0,
        s,
        0,
        0,
        n,
        0,
        s,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(a, r);
    }, t.prototype.saturate = function(e, r) {
      e === void 0 && (e = 0);
      var n = e * 2 / 3 + 1, s = (n - 1) * -0.5, a = [
        n,
        s,
        s,
        0,
        0,
        s,
        n,
        s,
        0,
        0,
        s,
        s,
        n,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(a, r);
    }, t.prototype.desaturate = function() {
      this.saturate(-1);
    }, t.prototype.negative = function(e) {
      var r = [
        -1,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        -1,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.sepia = function(e) {
      var r = [
        0.393,
        0.7689999,
        0.18899999,
        0,
        0,
        0.349,
        0.6859999,
        0.16799999,
        0,
        0,
        0.272,
        0.5339999,
        0.13099999,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.technicolor = function(e) {
      var r = [
        1.9125277891456083,
        -0.8545344976951645,
        -0.09155508482755585,
        0,
        11.793603434377337,
        -0.3087833385928097,
        1.7658908555458428,
        -0.10601743074722245,
        0,
        -70.35205161461398,
        -0.231103377548616,
        -0.7501899197440212,
        1.847597816108189,
        0,
        30.950940869491138,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.polaroid = function(e) {
      var r = [
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.toBGR = function(e) {
      var r = [
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.kodachrome = function(e) {
      var r = [
        1.1285582396593525,
        -0.3967382283601348,
        -0.03992559172921793,
        0,
        63.72958762196502,
        -0.16404339962244616,
        1.0835251566291304,
        -0.05498805115633132,
        0,
        24.732407896706203,
        -0.16786010706155763,
        -0.5603416277695248,
        1.6014850761964943,
        0,
        35.62982807460946,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.browni = function(e) {
      var r = [
        0.5997023498159715,
        0.34553243048391263,
        -0.2708298674538042,
        0,
        47.43192855600873,
        -0.037703249837783157,
        0.8609577587992641,
        0.15059552388459913,
        0,
        -36.96841498319127,
        0.24113635128153335,
        -0.07441037908422492,
        0.44972182064877153,
        0,
        -7.562075277591283,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.vintage = function(e) {
      var r = [
        0.6279345635605994,
        0.3202183420819367,
        -0.03965408211312453,
        0,
        9.651285835294123,
        0.02578397704808868,
        0.6441188644374771,
        0.03259127616149294,
        0,
        7.462829176470591,
        0.0466055556782719,
        -0.0851232987247891,
        0.5241648018700465,
        0,
        5.159190588235296,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.colorTone = function(e, r, n, s, a) {
      e = e || 0.2, r = r || 0.15, n = n || 16770432, s = s || 3375104;
      var o = (n >> 16 & 255) / 255, u = (n >> 8 & 255) / 255, l = (n & 255) / 255, h = (s >> 16 & 255) / 255, d = (s >> 8 & 255) / 255, f = (s & 255) / 255, p = [
        0.3,
        0.59,
        0.11,
        0,
        0,
        o,
        u,
        l,
        e,
        0,
        h,
        d,
        f,
        r,
        0,
        o - h,
        u - d,
        l - f,
        0,
        0
      ];
      this._loadMatrix(p, a);
    }, t.prototype.night = function(e, r) {
      e = e || 0.1;
      var n = [
        e * -2,
        -e,
        0,
        0,
        0,
        -e,
        0,
        e,
        0,
        0,
        0,
        e,
        e * 2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, r);
    }, t.prototype.predator = function(e, r) {
      var n = [
        // row 1
        11.224130630493164 * e,
        -4.794486999511719 * e,
        -2.8746118545532227 * e,
        0 * e,
        0.40342438220977783 * e,
        // row 2
        -3.6330697536468506 * e,
        9.193157196044922 * e,
        -2.951810836791992 * e,
        0 * e,
        -1.316135048866272 * e,
        // row 3
        -3.2184197902679443 * e,
        -4.2375030517578125 * e,
        7.476448059082031 * e,
        0 * e,
        0.8044459223747253 * e,
        // row 4
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, r);
    }, t.prototype.lsd = function(e) {
      var r = [
        2,
        -0.4,
        0.5,
        0,
        0,
        -0.5,
        2,
        -0.4,
        0,
        0,
        -0.4,
        -0.5,
        3,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.reset = function() {
      var e = [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(e, !1);
    }, Object.defineProperty(t.prototype, "matrix", {
      /**
       * The matrix of the color matrix filter
       * @member {number[]}
       * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
       */
      get: function() {
        return this.uniforms.m;
      },
      set: function(e) {
        this.uniforms.m = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "alpha", {
      /**
       * The opacity value to use when mixing the original and resultant colors.
       *
       * When the value is 0, the original color is used without modification.
       * When the value is 1, the result color is used.
       * When in the range (0, 1) the color is interpolated between the original and result by this amount.
       * @default 1
       */
      get: function() {
        return this.uniforms.uAlpha;
      },
      set: function(e) {
        this.uniforms.uAlpha = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rn)
);
iw.prototype.grayscale = iw.prototype.greyscale;
/*!
 * @pixi/filter-displacement - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-displacement is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var jy = function(i, t) {
  return jy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, jy(i, t);
};
function KN(i, t) {
  jy(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var JN = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`, QN = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
(function(i) {
  KN(t, i);
  function t(e, r) {
    var n = this, s = new ar();
    return e.renderable = !1, n = i.call(this, QN, JN, {
      mapSampler: e._texture,
      filterMatrix: s,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    }) || this, n.maskSprite = e, n.maskMatrix = s, r == null && (r = 20), n.scale = new xe(r, r), n;
  }
  return t.prototype.apply = function(e, r, n, s) {
    this.uniforms.filterMatrix = e.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
    var a = this.maskSprite.worldTransform, o = Math.sqrt(a.a * a.a + a.b * a.b), u = Math.sqrt(a.c * a.c + a.d * a.d);
    o !== 0 && u !== 0 && (this.uniforms.rotation[0] = a.a / o, this.uniforms.rotation[1] = a.b / o, this.uniforms.rotation[2] = a.c / u, this.uniforms.rotation[3] = a.d / u), e.applyFilter(this, r, n, s);
  }, Object.defineProperty(t.prototype, "map", {
    /** The texture used for the displacement map. Must be power of 2 sized texture. */
    get: function() {
      return this.uniforms.mapSampler;
    },
    set: function(e) {
      this.uniforms.mapSampler = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(rn);
/*!
 * @pixi/filter-fxaa - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-fxaa is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var zy = function(i, t) {
  return zy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, zy(i, t);
};
function tA(i, t) {
  zy(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var eA = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`, rA = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
(function(i) {
  tA(t, i);
  function t() {
    return i.call(this, eA, rA) || this;
  }
  return t;
})(rn);
/*!
 * @pixi/filter-noise - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-noise is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Hy = function(i, t) {
  return Hy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, Hy(i, t);
};
function iA(i, t) {
  Hy(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var nA = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
(function(i) {
  iA(t, i);
  function t(e, r) {
    e === void 0 && (e = 0.5), r === void 0 && (r = Math.random());
    var n = i.call(this, Zb, nA, {
      uNoise: 0,
      uSeed: 0
    }) || this;
    return n.noise = e, n.seed = r, n;
  }
  return Object.defineProperty(t.prototype, "noise", {
    /**
     * The amount of noise to apply, this value should be in the range (0, 1].
     * @default 0.5
     */
    get: function() {
      return this.uniforms.uNoise;
    },
    set: function(e) {
      this.uniforms.uNoise = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "seed", {
    /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */
    get: function() {
      return this.uniforms.uSeed;
    },
    set: function(e) {
      this.uniforms.uSeed = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(rn);
/*!
 * @pixi/mixin-cache-as-bitmap - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var OS = new ar();
He.prototype._cacheAsBitmap = !1;
He.prototype._cacheData = null;
He.prototype._cacheAsBitmapResolution = null;
He.prototype._cacheAsBitmapMultisample = ke.NONE;
var sA = (
  /** @class */
  function() {
    function i() {
      this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;
    }
    return i;
  }()
);
Object.defineProperties(He.prototype, {
  /**
   * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution
   * but can be overriden for performance. Lower values will reduce memory usage at the expense
   * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.
   * @member {number} cacheAsBitmapResolution
   * @memberof PIXI.DisplayObject#
   * @default null
   */
  cacheAsBitmapResolution: {
    get: function() {
      return this._cacheAsBitmapResolution;
    },
    set: function(i) {
      i !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = i, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  /**
   * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's
   * sample count is used.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.
   * @member {number} cacheAsBitmapMultisample
   * @memberof PIXI.DisplayObject#
   * @default PIXI.MSAA_QUALITY.NONE
   */
  cacheAsBitmapMultisample: {
    get: function() {
      return this._cacheAsBitmapMultisample;
    },
    set: function(i) {
      i !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = i, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  /**
   * Set this to true if you want this display object to be cached as a bitmap.
   * This basically takes a snap shot of the display object as it is at that moment. It can
   * provide a performance benefit for complex static displayObjects.
   * To remove simply set this property to `false`
   *
   * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
   * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  cacheAsBitmap: {
    get: function() {
      return this._cacheAsBitmap;
    },
    set: function(i) {
      if (this._cacheAsBitmap !== i) {
        this._cacheAsBitmap = i;
        var t;
        i ? (this._cacheData || (this._cacheData = new sA()), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea);
      }
    }
  }
});
He.prototype._renderCached = function(t) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t));
};
He.prototype._initCachedDisplayObject = function(t) {
  var e;
  if (!(this._cacheData && this._cacheData.sprite)) {
    var r = this.alpha;
    this.alpha = 1, t.batch.flush();
    var n = this.getLocalBounds(null, !0).clone();
    if (this.filters && this.filters.length) {
      var s = this.filters[0].padding;
      n.pad(s);
    }
    n.ceil(gt.RESOLUTION);
    var a = t.renderTexture.current, o = t.renderTexture.sourceFrame.clone(), u = t.renderTexture.destinationFrame.clone(), l = t.projection.transform, h = Ei.create({
      width: n.width,
      height: n.height,
      resolution: this.cacheAsBitmapResolution || t.resolution,
      multisample: (e = this.cacheAsBitmapMultisample) !== null && e !== void 0 ? e : t.multisample
    }), d = "cacheAsBitmap_" + Zo();
    this._cacheData.textureCacheId = d, Kt.addToCache(h.baseTexture, d), Ot.addToCache(h, d);
    var f = this.transform.localTransform.copyTo(OS).invert().translate(-n.x, -n.y);
    this.render = this._cacheData.originalRender, t.render(this, { renderTexture: h, clear: !0, transform: f, skipUpdateTransform: !1 }), t.framebuffer.blit(), t.projection.transform = l, t.renderTexture.bind(a, o, u), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r;
    var p = new Ue(h);
    p.transform.worldTransform = this.transform.worldTransform, p.anchor.x = -(n.x / n.width), p.anchor.y = -(n.y / n.height), p.alpha = r, p._bounds = this._bounds, this._cacheData.sprite = p, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = p.containsPoint.bind(p);
  }
};
He.prototype._renderCachedCanvas = function(t) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t));
};
He.prototype._initCachedDisplayObjectCanvas = function(t) {
  if (!(this._cacheData && this._cacheData.sprite)) {
    var e = this.getLocalBounds(null, !0), r = this.alpha;
    this.alpha = 1;
    var n = t.context, s = t._projTransform;
    e.ceil(gt.RESOLUTION);
    var a = Ei.create({ width: e.width, height: e.height }), o = "cacheAsBitmap_" + Zo();
    this._cacheData.textureCacheId = o, Kt.addToCache(a.baseTexture, o), Ot.addToCache(a, o);
    var u = OS;
    this.transform.localTransform.copyTo(u), u.invert(), u.tx -= e.x, u.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, { renderTexture: a, clear: !0, transform: u, skipUpdateTransform: !1 }), t.context = n, t._projTransform = s, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r;
    var l = new Ue(a);
    l.transform.worldTransform = this.transform.worldTransform, l.anchor.x = -(e.x / e.width), l.anchor.y = -(e.y / e.height), l.alpha = r, l._bounds = this._bounds, this._cacheData.sprite = l, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = l.containsPoint.bind(l);
  }
};
He.prototype._calculateCachedBounds = function() {
  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;
};
He.prototype._getCachedLocalBounds = function() {
  return this._cacheData.sprite.getLocalBounds(null);
};
He.prototype._destroyCachedDisplayObject = function() {
  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, Kt.removeFromCache(this._cacheData.textureCacheId), Ot.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;
};
He.prototype._cacheAsBitmapDestroy = function(t) {
  this.cacheAsBitmap = !1, this.destroy(t);
};
/*!
 * @pixi/mixin-get-child-by-name - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
He.prototype.name = null;
ye.prototype.getChildByName = function(t, e) {
  for (var r = 0, n = this.children.length; r < n; r++)
    if (this.children[r].name === t)
      return this.children[r];
  if (e)
    for (var r = 0, n = this.children.length; r < n; r++) {
      var s = this.children[r];
      if (s.getChildByName) {
        var a = s.getChildByName(t, !0);
        if (a)
          return a;
      }
    }
  return null;
};
/*!
 * @pixi/mixin-get-global-position - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
He.prototype.getGlobalPosition = function(t, e) {
  return t === void 0 && (t = new xe()), e === void 0 && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t;
};
/*!
 * @pixi/app - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/app is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var aA = (
  /** @class */
  function() {
    function i() {
    }
    return i.init = function(t) {
      var e = this;
      Object.defineProperty(
        this,
        "resizeTo",
        /**
         * The HTML element or window to automatically resize the
         * renderer's view element to match width and height.
         * @member {Window|HTMLElement}
         * @name resizeTo
         * @memberof PIXI.Application#
         */
        {
          set: function(r) {
            globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = r, r && (globalThis.addEventListener("resize", this.queueResize), this.resize());
          },
          get: function() {
            return this._resizeTo;
          }
        }
      ), this.queueResize = function() {
        e._resizeTo && (e.cancelResize(), e._resizeId = requestAnimationFrame(function() {
          return e.resize();
        }));
      }, this.cancelResize = function() {
        e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null);
      }, this.resize = function() {
        if (e._resizeTo) {
          e.cancelResize();
          var r, n;
          if (e._resizeTo === globalThis.window)
            r = globalThis.innerWidth, n = globalThis.innerHeight;
          else {
            var s = e._resizeTo, a = s.clientWidth, o = s.clientHeight;
            r = a, n = o;
          }
          e.renderer.resize(r, n);
        }
      }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;
    }, i.destroy = function() {
      globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
    }, i.extension = de.Application, i;
  }()
), IS = (
  /** @class */
  function() {
    function i(t) {
      var e = this;
      this.stage = new ye(), t = Object.assign({
        forceCanvas: !1
      }, t), this.renderer = qb(t), i._plugins.forEach(function(r) {
        r.init.call(e, t);
      });
    }
    return i.registerPlugin = function(t) {
      jr("6.5.0", "Application.registerPlugin() is deprecated, use extensions.add()"), an.add({
        type: de.Application,
        ref: t
      });
    }, i.prototype.render = function() {
      this.renderer.render(this.stage);
    }, Object.defineProperty(i.prototype, "view", {
      /**
       * Reference to the renderer's canvas element.
       * @member {HTMLCanvasElement}
       * @readonly
       */
      get: function() {
        return this.renderer.view;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "screen", {
      /**
       * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
       * @member {PIXI.Rectangle}
       * @readonly
       */
      get: function() {
        return this.renderer.screen;
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.destroy = function(t, e) {
      var r = this, n = i._plugins.slice(0);
      n.reverse(), n.forEach(function(s) {
        s.destroy.call(r);
      }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;
    }, i._plugins = [], i;
  }()
);
an.handleByList(de.Application, IS._plugins);
an.add(aA);
/*!
 * @pixi/mesh-extras - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/mesh-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var $y = function(i, t) {
  return $y = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, $y(i, t);
};
function hh(i, t) {
  $y(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var oA = (
  /** @class */
  function(i) {
    hh(t, i);
    function t(e, r, n, s) {
      e === void 0 && (e = 100), r === void 0 && (r = 100), n === void 0 && (n = 10), s === void 0 && (s = 10);
      var a = i.call(this) || this;
      return a.segWidth = n, a.segHeight = s, a.width = e, a.height = r, a.build(), a;
    }
    return t.prototype.build = function() {
      for (var e = this.segWidth * this.segHeight, r = [], n = [], s = [], a = this.segWidth - 1, o = this.segHeight - 1, u = this.width / a, l = this.height / o, h = 0; h < e; h++) {
        var d = h % this.segWidth, f = h / this.segWidth | 0;
        r.push(d * u, f * l), n.push(d / a, f / o);
      }
      for (var p = a * o, h = 0; h < p; h++) {
        var v = h % a, g = h / a | 0, m = g * this.segWidth + v, y = g * this.segWidth + v + 1, _ = (g + 1) * this.segWidth + v, b = (g + 1) * this.segWidth + v + 1;
        s.push(m, y, _, y, b, _);
      }
      this.buffers[0].data = new Float32Array(r), this.buffers[1].data = new Float32Array(n), this.indexBuffer.data = new Uint16Array(s), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
    }, t;
  }(s0)
), uA = (
  /** @class */
  function(i) {
    hh(t, i);
    function t(e, r, n) {
      e === void 0 && (e = 200), n === void 0 && (n = 0);
      var s = i.call(this, new Float32Array(r.length * 4), new Float32Array(r.length * 4), new Uint16Array((r.length - 1) * 6)) || this;
      return s.points = r, s._width = e, s.textureScale = n, s.build(), s;
    }
    return Object.defineProperty(t.prototype, "width", {
      /**
       * The width (i.e., thickness) of the rope.
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.build = function() {
      var e = this.points;
      if (e) {
        var r = this.getBuffer("aVertexPosition"), n = this.getBuffer("aTextureCoord"), s = this.getIndex();
        if (!(e.length < 1)) {
          r.data.length / 4 !== e.length && (r.data = new Float32Array(e.length * 4), n.data = new Float32Array(e.length * 4), s.data = new Uint16Array((e.length - 1) * 6));
          var a = n.data, o = s.data;
          a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1;
          for (var u = 0, l = e[0], h = this._width * this.textureScale, d = e.length, f = 0; f < d; f++) {
            var p = f * 4;
            if (this.textureScale > 0) {
              var v = l.x - e[f].x, g = l.y - e[f].y, m = Math.sqrt(v * v + g * g);
              l = e[f], u += m / h;
            } else
              u = f / (d - 1);
            a[p] = u, a[p + 1] = 0, a[p + 2] = u, a[p + 3] = 1;
          }
          for (var y = 0, f = 0; f < d - 1; f++) {
            var p = f * 2;
            o[y++] = p, o[y++] = p + 1, o[y++] = p + 2, o[y++] = p + 2, o[y++] = p + 1, o[y++] = p + 3;
          }
          n.update(), s.update(), this.updateVertices();
        }
      }
    }, t.prototype.updateVertices = function() {
      var e = this.points;
      if (!(e.length < 1)) {
        for (var r = e[0], n, s = 0, a = 0, o = this.buffers[0].data, u = e.length, l = 0; l < u; l++) {
          var h = e[l], d = l * 4;
          l < e.length - 1 ? n = e[l + 1] : n = h, a = -(n.x - r.x), s = n.y - r.y;
          var f = Math.sqrt(s * s + a * a), p = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
          s /= f, a /= f, s *= p, a *= p, o[d] = h.x + s, o[d + 1] = h.y + a, o[d + 2] = h.x - s, o[d + 3] = h.y - a, r = h;
        }
        this.buffers[0].update();
      }
    }, t.prototype.update = function() {
      this.textureScale > 0 ? this.build() : this.updateVertices();
    }, t;
  }(s0)
);
(function(i) {
  hh(t, i);
  function t(e, r, n) {
    n === void 0 && (n = 0);
    var s = this, a = new uA(e.height, r, n), o = new cc(e);
    return n > 0 && (e.baseTexture.wrapMode = On.REPEAT), s = i.call(this, a, o) || this, s.autoUpdate = !0, s;
  }
  return t.prototype._render = function(e) {
    var r = this.geometry;
    (this.autoUpdate || r._width !== this.shader.texture.height) && (r._width = this.shader.texture.height, r.update()), i.prototype._render.call(this, e);
  }, t;
})(hc);
var lA = (
  /** @class */
  function(i) {
    hh(t, i);
    function t(e, r, n) {
      var s = this, a = new oA(e.width, e.height, r, n), o = new cc(Ot.WHITE);
      return s = i.call(this, a, o) || this, s.texture = e, s.autoResize = !0, s;
    }
    return t.prototype.textureUpdated = function() {
      this._textureID = this.shader.texture._updateID;
      var e = this.geometry, r = this.shader.texture, n = r.width, s = r.height;
      this.autoResize && (e.width !== n || e.height !== s) && (e.width = this.shader.texture.width, e.height = this.shader.texture.height, e.build());
    }, Object.defineProperty(t.prototype, "texture", {
      get: function() {
        return this.shader.texture;
      },
      set: function(e) {
        this.shader.texture !== e && (this.shader.texture = e, this._textureID = -1, e.baseTexture.valid ? this.textureUpdated() : e.once("update", this.textureUpdated, this));
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype._render = function(e) {
      this._textureID !== this.shader.texture._updateID && this.textureUpdated(), i.prototype._render.call(this, e);
    }, t.prototype.destroy = function(e) {
      this.shader.texture.off("update", this.textureUpdated, this), i.prototype.destroy.call(this, e);
    }, t;
  }(hc)
);
(function(i) {
  hh(t, i);
  function t(e, r, n, s, a) {
    e === void 0 && (e = Ot.EMPTY);
    var o = this, u = new s0(r, n, s);
    u.getBuffer("aVertexPosition").static = !1;
    var l = new cc(e);
    return o = i.call(this, u, l, null, a) || this, o.autoUpdate = !0, o;
  }
  return Object.defineProperty(t.prototype, "vertices", {
    /**
     * Collection of vertices data.
     * @type {Float32Array}
     */
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(e) {
      this.geometry.getBuffer("aVertexPosition").data = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._render = function(e) {
    this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), i.prototype._render.call(this, e);
  }, t;
})(hc);
var sp = 10;
(function(i) {
  hh(t, i);
  function t(e, r, n, s, a) {
    r === void 0 && (r = sp), n === void 0 && (n = sp), s === void 0 && (s = sp), a === void 0 && (a = sp);
    var o = i.call(this, Ot.WHITE, 4, 4) || this;
    return o._origWidth = e.orig.width, o._origHeight = e.orig.height, o._width = o._origWidth, o._height = o._origHeight, o._leftWidth = r, o._rightWidth = s, o._topHeight = n, o._bottomHeight = a, o.texture = e, o;
  }
  return t.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID, this._refresh();
  }, Object.defineProperty(t.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(e) {
      this.geometry.getBuffer("aVertexPosition").data = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.updateHorizontalVertices = function() {
    var e = this.vertices, r = this._getMinScale();
    e[9] = e[11] = e[13] = e[15] = this._topHeight * r, e[17] = e[19] = e[21] = e[23] = this._height - this._bottomHeight * r, e[25] = e[27] = e[29] = e[31] = this._height;
  }, t.prototype.updateVerticalVertices = function() {
    var e = this.vertices, r = this._getMinScale();
    e[2] = e[10] = e[18] = e[26] = this._leftWidth * r, e[4] = e[12] = e[20] = e[28] = this._width - this._rightWidth * r, e[6] = e[14] = e[22] = e[30] = this._width;
  }, t.prototype._getMinScale = function() {
    var e = this._leftWidth + this._rightWidth, r = this._width > e ? 1 : this._width / e, n = this._topHeight + this._bottomHeight, s = this._height > n ? 1 : this._height / n, a = Math.min(r, s);
    return a;
  }, Object.defineProperty(t.prototype, "width", {
    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    get: function() {
      return this._width;
    },
    set: function(e) {
      this._width = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    get: function() {
      return this._height;
    },
    set: function(e) {
      this._height = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "leftWidth", {
    /** The width of the left column. */
    get: function() {
      return this._leftWidth;
    },
    set: function(e) {
      this._leftWidth = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "rightWidth", {
    /** The width of the right column. */
    get: function() {
      return this._rightWidth;
    },
    set: function(e) {
      this._rightWidth = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "topHeight", {
    /** The height of the top row. */
    get: function() {
      return this._topHeight;
    },
    set: function(e) {
      this._topHeight = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "bottomHeight", {
    /** The height of the bottom row. */
    get: function() {
      return this._bottomHeight;
    },
    set: function(e) {
      this._bottomHeight = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._refresh = function() {
    var e = this.texture, r = this.geometry.buffers[1].data;
    this._origWidth = e.orig.width, this._origHeight = e.orig.height;
    var n = 1 / this._origWidth, s = 1 / this._origHeight;
    r[0] = r[8] = r[16] = r[24] = 0, r[1] = r[3] = r[5] = r[7] = 0, r[6] = r[14] = r[22] = r[30] = 1, r[25] = r[27] = r[29] = r[31] = 1, r[2] = r[10] = r[18] = r[26] = n * this._leftWidth, r[4] = r[12] = r[20] = r[28] = 1 - n * this._rightWidth, r[9] = r[11] = r[13] = r[15] = s * this._topHeight, r[17] = r[19] = r[21] = r[23] = 1 - s * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();
  }, t;
})(lA);
/*!
 * @pixi/sprite-animated - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/sprite-animated is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Vy = function(i, t) {
  return Vy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, Vy(i, t);
};
function hA(i, t) {
  Vy(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var nw = (
  /** @class */
  function(i) {
    hA(t, i);
    function t(e, r) {
      r === void 0 && (r = !0);
      var n = i.call(this, e[0] instanceof Ot ? e[0] : e[0].texture) || this;
      return n._textures = null, n._durations = null, n._autoUpdate = r, n._isConnectedToTicker = !1, n.animationSpeed = 1, n.loop = !0, n.updateAnchor = !1, n.onComplete = null, n.onFrameChange = null, n.onLoop = null, n._currentTime = 0, n._playing = !1, n._previousFrame = null, n.textures = e, n;
    }
    return t.prototype.stop = function() {
      this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Ge.shared.remove(this.update, this), this._isConnectedToTicker = !1));
    }, t.prototype.play = function() {
      this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Ge.shared.add(this.update, this, Cs.HIGH), this._isConnectedToTicker = !0));
    }, t.prototype.gotoAndStop = function(e) {
      this.stop();
      var r = this.currentFrame;
      this._currentTime = e, r !== this.currentFrame && this.updateTexture();
    }, t.prototype.gotoAndPlay = function(e) {
      var r = this.currentFrame;
      this._currentTime = e, r !== this.currentFrame && this.updateTexture(), this.play();
    }, t.prototype.update = function(e) {
      if (this._playing) {
        var r = this.animationSpeed * e, n = this.currentFrame;
        if (this._durations !== null) {
          var s = this._currentTime % 1 * this._durations[this.currentFrame];
          for (s += r / 60 * 1e3; s < 0; )
            this._currentTime--, s += this._durations[this.currentFrame];
          var a = Math.sign(this.animationSpeed * e);
          for (this._currentTime = Math.floor(this._currentTime); s >= this._durations[this.currentFrame]; )
            s -= this._durations[this.currentFrame] * a, this._currentTime += a;
          this._currentTime += s / this._durations[this.currentFrame];
        } else
          this._currentTime += r;
        this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : n !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < n ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > n && this.onLoop()), this.updateTexture());
      }
    }, t.prototype.updateTexture = function() {
      var e = this.currentFrame;
      this._previousFrame !== e && (this._previousFrame = e, this._texture = this._textures[e], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));
    }, t.prototype.destroy = function(e) {
      this.stop(), i.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;
    }, t.fromFrames = function(e) {
      for (var r = [], n = 0; n < e.length; ++n)
        r.push(Ot.from(e[n]));
      return new t(r);
    }, t.fromImages = function(e) {
      for (var r = [], n = 0; n < e.length; ++n)
        r.push(Ot.from(e[n]));
      return new t(r);
    }, Object.defineProperty(t.prototype, "totalFrames", {
      /**
       * The total number of frames in the AnimatedSprite. This is the same as number of textures
       * assigned to the AnimatedSprite.
       * @readonly
       * @default 0
       */
      get: function() {
        return this._textures.length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "textures", {
      /** The array of textures used for this AnimatedSprite. */
      get: function() {
        return this._textures;
      },
      set: function(e) {
        if (e[0] instanceof Ot)
          this._textures = e, this._durations = null;
        else {
          this._textures = [], this._durations = [];
          for (var r = 0; r < e.length; r++)
            this._textures.push(e[r].texture), this._durations.push(e[r].time);
        }
        this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "currentFrame", {
      /**
       * The AnimatedSprites current frame index.
       * @readonly
       */
      get: function() {
        var e = Math.floor(this._currentTime) % this._textures.length;
        return e < 0 && (e += this._textures.length), e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "playing", {
      /**
       * Indicates if the AnimatedSprite is currently playing.
       * @readonly
       */
      get: function() {
        return this._playing;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "autoUpdate", {
      /** Whether to use PIXI.Ticker.shared to auto update animation time. */
      get: function() {
        return this._autoUpdate;
      },
      set: function(e) {
        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ge.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Ge.shared.add(this.update, this), this._isConnectedToTicker = !0));
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ue)
);
/*!
 * pixi.js - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
an.add(
  // Install renderer plugins
  W2,
  ek,
  J2,
  Wk,
  wN,
  Jb,
  ON,
  // Install loader plugins
  jN,
  yk,
  Hk,
  $k,
  SN,
  // Install application plugins
  $D,
  lk
);
var Bs;
class Jl {
  constructor() {
    // リソースリーク対策
    E(this, Bs, []);
  }
  add(t, e, r, n = {}) {
    if (t instanceof Kt) {
      switch (e) {
        case "loaded":
        case "update":
        case "error":
        case "dispose":
          t.on(e, r, n), c(this, Bs).push(() => t.off(e, r, n));
          break;
      }
      return;
    }
    if (t instanceof Pi) {
      t.on(e, r, n), c(this, Bs).push(() => t.off(e, r, n));
      return;
    }
    t.addEventListener(e, r, n), c(this, Bs).push(() => t.removeEventListener(e, r, { capture: n.capture ?? !1 }));
  }
  clear() {
    for (const t of c(this, Bs))
      t();
    P(this, Bs, []);
  }
}
Bs = new WeakMap();
var vr = /* @__PURE__ */ ((i) => (i.DEFAULT = "", i.SP_GSM = "png|jpg|jpeg|json|svg|webp|mp4|webm", i.SCRIPT = "sn|ssn", i.FONT = "woff2|woff|otf|ttf", i.SOUND = "mp3|m4a|ogg|aac|flac|wav", i.HTML = "htm|html", i.CSS = "css", i.SN = "sn", i.PSD = "psd", i.TST_PNGPNG_ = "png|png_", i.TST_HH = "hh", i.TST_EEE = "eee", i.TST_GGG = "ggg", i.TST_PNGXML = "png|xml", i))(vr || {}), xc, wc, Dv;
class cA {
  constructor(t) {
    K(this, "oCfg", {
      save_ns: "",
      // 扱うセーブデータを一意に識別するキーワード文字列
      window: {
        // アプリケーションウインドウサイズ
        width: 300,
        height: 300
      },
      book: {
        // プロジェクトの詳細情報です
        title: "",
        //作品タイトル
        creator: "",
        //著作者。同人ならペンネーム
        cre_url: "",
        //著作者URL。ツイッターやメール、サイトなど
        publisher: "",
        //出版社。同人ならサークル名
        pub_url: "",
        //出版社URL。無ければ省略します
        detail: "",
        // 内容紹介。端的に記入
        version: "1.0"
      },
      log: { max_len: 1024 },
      // プレイヤーが読んだ文章を読み返せる履歴の長さ
      init: {
        bg_color: "#000000",
        // 背景色
        tagch_msecwait: 10,
        // 通常文字表示待ち時間（未読／既読）
        auto_msecpagewait: 3500,
        // 自動文字表示、行クリック待ち時間（未読／既読）
        escape: ""
        // エスケープ文字
      },
      debug: {
        devtool: !1,
        token: !1,
        tag: !1,
        putCh: !1,
        debugLog: !1,
        baseTx: !1,
        masume: !1,
        // テキストレイヤ：ガイドマス目を表示するか
        variable: !1
      },
      code: {},
      // 暗号化しないフォルダ
      debuger_token: ""
      // デバッガとの接続トークン
    });
    K(this, "userFnTail", "");
    // 4tst public
    K(this, "hPathFn2Exts", {});
    E(this, xc, !1);
    E(this, wc, !1);
    E(this, Dv, /([^\/\s]+)\.([^\d]\w+)/);
    this.sys = t;
  }
  async load(t) {
    var e, r, n, s;
    if (this.oCfg.save_ns = (t == null ? void 0 : t.save_ns) ?? this.oCfg.save_ns, this.oCfg.window.width = Number(((e = t == null ? void 0 : t.window) == null ? void 0 : e.width) ?? this.oCfg.window.width), this.oCfg.window.height = Number(((r = t == null ? void 0 : t.window) == null ? void 0 : r.height) ?? this.oCfg.window.height), this.oCfg.book = { ...this.oCfg.book, ...t.book }, this.oCfg.log.max_len = ((s = (n = t.log) == null ? void 0 : n.max_len) == null ? void 0 : s.max_len) ?? this.oCfg.log.max_len, this.oCfg.init = { ...this.oCfg.init, ...t.init }, this.oCfg.debug = { ...this.oCfg.debug, ...t.debug }, this.oCfg.debuger_token = t.debuger_token, await this.sys.loadPath(this.hPathFn2Exts, this), P(this, xc, this.matchPath(
      "^breakline$",
      "png|jpg|jpeg|json|svg|webp|mp4|webm"
      /* SP_GSM */
    ).length > 0), P(this, wc, this.matchPath(
      "^breakpage$",
      "png|jpg|jpeg|json|svg|webp|mp4|webm"
      /* SP_GSM */
    ).length > 0), !!this.sys.crypto)
      for (const a of Object.values(this.hPathFn2Exts))
        for (const [o, u] of Object.entries(a)) {
          if (o.slice(-10) !== ":RIPEMD160")
            continue;
          const l = u.slice(u.lastIndexOf("/") + 1), h = a[o.slice(0, -10)], f = await (await this.sys.fetch(h)).text(), p = this.sys.hash(f);
          if (l !== p)
            throw `ファイル改竄エラーです fn:${h}`;
        }
  }
  get existsBreakline() {
    return c(this, xc);
  }
  get existsBreakpage() {
    return c(this, wc);
  }
  getNs() {
    return `skynovel.${this.oCfg.save_ns} - `;
  }
  // 4 match 498 step(~1ms)  https://regex101.com/r/tpVgmI/1
  searchPath(t, e = "") {
    if (!t)
      throw "[searchPath] fnが空です";
    if (t.slice(0, 7) === "http://")
      return t;
    const r = t.match(c(this, Dv));
    let n = r ? r[1] : t;
    const s = r ? r[2] : "";
    if (this.userFnTail) {
      const u = n + "@@" + this.userFnTail;
      if (u in this.hPathFn2Exts) {
        if (e === "")
          n = u;
        else
          for (const l of Object.keys(this.hPathFn2Exts[u]))
            if (`|${e}|`.indexOf(`|${l}|`) !== -1) {
              n = u;
              break;
            }
      }
    }
    const a = this.hPathFn2Exts[n];
    if (!a)
      throw `サーチパスに存在しないファイル【${t}】です`;
    let o = "";
    if (!s) {
      const u = $t(a[":cnt"]);
      if (e === "") {
        if (u > 1)
          throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;
        return t;
      }
      const l = `|${e}|`;
      if (u > 1) {
        let h = 0;
        for (const d of Object.keys(a))
          if (l.indexOf(`|${d}|`) !== -1 && ++h > 1)
            throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;
      }
      for (let h of Object.keys(a))
        if (l.indexOf(`|${h}|`) > -1)
          return a[h];
      throw `サーチ対象拡張子群【${e}】にマッチするファイルがサーチパスに存在しません。探索ファイル名=【${t}】`;
    }
    if (e !== "" && `|${e}|`.indexOf(`|${s}|`) === -1)
      throw `指定ファイルの拡張子【${s}】は、サーチ対象拡張子群【${e}】にマッチしません。探索ファイル名=【${t}】`;
    if (o = a[s], !o)
      throw `サーチパスに存在しない拡張子【${s}】です。探索ファイル名=【${t}】、サーチ対象拡張子群【${e}】`;
    return o;
  }
  matchPath(t, e = "") {
    const r = [], n = new RegExp(t), s = new RegExp(e);
    for (const [a, o] of Object.entries(this.hPathFn2Exts)) {
      if (a.search(n) === -1)
        continue;
      if (e === "") {
        r.push(o);
        continue;
      }
      const u = {};
      let l = !1;
      for (const h of Object.keys(o))
        h.search(s) !== -1 && (u[h] = a, l = !0);
      l && r.push(u);
    }
    return r;
  }
  addPath(t, e) {
    const r = {};
    for (const [n, s] of Object.entries(e))
      r[n] = (n.at(0) === ":" ? "" : this.sys.cur) + s;
    this.hPathFn2Exts[t] = r;
  }
}
xc = new WeakMap(), wc = new WeakMap(), Dv = new WeakMap();
class ix extends cA {
  constructor(t) {
    super(t), this.sys = t;
  }
  static async generate(t) {
    const e = new ix(t), r = t.cur + "prj.json", n = await (await t.fetch(r)).text(), s = JSON.parse(t.decStr(r, n));
    return await e.load(s), e;
  }
  async load(t) {
    await super.load(t), Y.stageW = this.oCfg.window.width, Y.stageH = this.oCfg.window.height, Y.debugLog = this.oCfg.debug.debugLog;
  }
  searchPath(t, e = vr.DEFAULT) {
    return t.slice(0, 11) === "downloads:/" ? this.sys.path_downloads + t.slice(11) : t.slice(0, 10) === "userdata:/" ? this.sys.path_userdata + "storage/" + t.slice(10) : super.searchPath(t, e);
  }
}
const RS = /(?<name>[^\s;\]]+)/;
function Op(i) {
  const t = RS.exec(i.slice(1, -1)), e = t == null ? void 0 : t.groups;
  if (!e)
    throw `タグ記述【${i}】異常です(タグ解析)`;
  const r = e.name;
  return [r, i.slice(1 + r.length, -1)];
}
function Ip(i) {
  const t = RS.exec(i.slice(1)), e = t == null ? void 0 : t.groups;
  if (!e)
    throw `タグ記述【${i}】異常です(タグ解析)`;
  return e.name;
}
function fA(i) {
  const t = i.replaceAll("==", "＝").replaceAll("!=", "≠").split("="), e = t.length;
  if (e < 2 || e > 3)
    throw "「&計算」書式では「=」指定が一つか二つ必要です";
  if (t[1].at(0) === "&")
    throw "「&計算」書式では「&」指定が不要です";
  return {
    name: t[0].replaceAll("＝", "==").replaceAll("≠", "!="),
    text: t[1].replaceAll("＝", "==").replaceAll("≠", "!="),
    cast: e === 3 ? t[2].trim() : void 0
  };
}
var Ua, ja, Ec, Sc, Tc, Er, Cc, Gu, Rp;
class dA {
  constructor() {
    E(this, Gu);
    E(this, Ua, void 0);
    E(this, ja, void 0);
    E(this, Ec, new RegExp(""));
    E(this, Sc, "");
    E(this, Tc, "");
    E(this, Er, void 0);
    E(this, Cc, void 0);
    this.setEscape("");
  }
  setEscape(t) {
    if (c(this, Er) && t in c(this, Er))
      throw "[エスケープ文字] char【" + t + "】が登録済みの括弧マクロまたは一文字マクロです";
    P(this, Ua, new RegExp(
      (t ? `\\${t}\\S|` : "") + // エスケープシーケンス
      `\\n+|\\t+|\\[let_ml\\s+[^\\]]+\\].+?(?=\\[endlet_ml[\\]\\s])|\\[(?:(?=([^"'#;\\]]+))\\1|(["'#]).*?\\2|;[^\\n]*)*?]|;[^\\n]*|&[^&\\n]+&|&&?[^&;\\n\\t]+|^\\*[^\\s\\[&;\\\\]+|[^\\n\\t\\[;${t ? `\\${t}` : ""}]+`,
      // 本文
      "gs"
    )), P(this, ja, new RegExp(`[\\w\\s;[\\]*=&｜《》${t ? `\\${t}` : ""}]`)), P(this, Cc, new RegExp(`[\\n\\t;\\[*&${t ? `\\${t}` : ""}]`));
  }
  // 括弧マクロの定義
  bracket2macro(t, e, r, n) {
    const { name: s, text: a } = t;
    if (!s)
      throw "[bracket2macro] nameは必須です";
    if (!a)
      throw "[bracket2macro] textは必須です";
    const o = a.at(0);
    if (!o)
      throw "[bracket2macro] textは必須です";
    if (a.length !== 2)
      throw "[bracket2macro] textは括弧の前後を示す二文字を指定してください";
    if (!(s in e))
      throw `[bracket2macro] 未定義のタグ又はマクロ[${s}]です`;
    c(this, Er) ?? P(this, Er, {});
    const u = a.charAt(1);
    if (o in c(this, Er))
      throw "[bracket2macro] text【" + o + "】が登録済みの括弧マクロまたは一文字マクロです";
    if (u in c(this, Er))
      throw "[bracket2macro] text【" + u + "】が登録済みの括弧マクロまたは一文字マクロです";
    if (c(this, ja).test(o))
      throw "[bracket2macro] text【" + o + "】は括弧マクロに使用できない文字です";
    if (c(this, ja).test(u))
      throw "[bracket2macro] text【" + u + "】は括弧マクロに使用できない文字です";
    c(this, Er)[u] = "0", c(this, Er)[o] = `[${s} text=`, this.addC2M(`\\${o}[^\\${u}]*\\${u}`, `\\${o}\\${u}`), O(this, Gu, Rp).call(this, r, n);
  }
  // 一文字マクロの定義
  char2macro(t, e, r, n) {
    const { char: s, name: a } = t;
    if (!s)
      throw "[char2macro] charは必須です";
    if (c(this, Er) ?? P(this, Er, {}), s in c(this, Er))
      throw "[char2macro] char【" + s + "】が登録済みの括弧マクロまたは一文字マクロです";
    if (c(this, ja).test(s))
      throw "[char2macro] char【" + s + "】は一文字マクロに使用できない文字です";
    if (!a)
      throw "[char2macro] nameは必須です";
    if (!(a in e))
      throw `[char2macro] 未定義のタグ又はマクロ[${a}]です`;
    c(this, Er)[s] = `[${a}]`, this.addC2M(`\\${s}`, `\\${s}`), O(this, Gu, Rp).call(this, r, n);
  }
  addC2M(t, e) {
    P(this, Sc, c(this, Sc) + `${t}|`), P(this, Tc, c(this, Tc) + `${e}`), P(this, Ec, new RegExp(
      `(${c(this, Sc)}[^${c(this, Tc)}]+)`,
      "g"
    ));
  }
  resolveScript(t) {
    var n;
    const e = ((n = t.replaceAll(/(\r\n|\r)/g, `
`).match(c(this, Ua))) == null ? void 0 : n.flatMap((s) => {
      if (!this.testTagLetml(s))
        return s;
      const a = /^([^\]]+?])(.*)$/s.exec(s);
      if (!a)
        return s;
      const [, o, u] = a;
      return [o, u];
    })) ?? [], r = { aToken: e, len: e.length, aLNum: [] };
    return O(this, Gu, Rp).call(this, r), r;
  }
  testTagLetml(t) {
    return /^\[let_ml\s/.test(t);
  }
  testTagEndLetml(t) {
    return /^\[endlet_ml\s*]/.test(t);
  }
  analyzToken(t) {
    return c(this, Ua).lastIndex = 0, c(this, Ua).exec(t);
  }
  testNoTxt(t) {
    return c(this, Cc).test(t);
  }
  //4tst
}
Ua = new WeakMap(), ja = new WeakMap(), Ec = new WeakMap(), Sc = new WeakMap(), Tc = new WeakMap(), Er = new WeakMap(), Cc = new WeakMap(), Gu = new WeakSet(), Rp = function(t, e = 0) {
  if (c(this, Er)) {
    for (let r = t.len - 1; r >= e; --r) {
      const n = t.aToken[r];
      if (this.testNoTxt(n.at(0) ?? `
`))
        continue;
      const s = t.aLNum[r], a = n.match(c(this, Ec));
      if (!a)
        continue;
      let o = 1;
      for (let u = a.length - 1; u >= 0; --u) {
        let l = a[u];
        const h = c(this, Er)[l.at(0) ?? " "];
        h && (l = h + (h.at(-1) === "]" ? "" : `'${l.slice(1, -1)}']`)), t.aToken.splice(r, o, l), t.aLNum.splice(r, o, s), o = 0;
      }
    }
    t.len = t.aToken.length;
  }
};
var Mc, Uu, Dp, za, ju;
class pA {
  constructor() {
    E(this, Uu);
    // 87 match 2725 step(0.5ms) PCRE2 https://regex101.com/r/aeN57J/1
    /*
    ;[^\n]*
    |	(?<key>[^\s="'#|;]+)
    	(?: \s | ;[^\n]*\n)*
    	=
    	(?: \s | ;[^\n]*\n)*
    	(?:	(?<val> [^\s"'#|;]+)
    	|	(["'#]) (?<val2>.*?) \3 )
    	(?: \|
    		(?: (?<def> [^\s"'#;]+)
    	|	(["'#]) (?<def2>.*?) \6 ) )?
    |	(?<literal>[^\s;]+)
    	*/
    E(this, Mc, /;[^\n]*|(?<key>[^\s="'#|;]+)(?:\s|;[^\n]*\n)*=(?:\s|;[^\n]*\n)*(?:(?<val>[^\s"'#|;]+)|(["'#])(?<val2>.*?)\3)(?:\|(?:(?<def>[^\s"'#;]+)|(["'#])(?<def2>.*?)\6))?|(?<literal>[^\s;]+)/g);
    E(this, za, {});
    E(this, ju, !1);
  }
  // 【属性 = 値 | 省略値】の分析
  parse(t) {
    P(this, za, {}), P(this, ju, !1);
    for (const { groups: e } of t.matchAll(c(this, Mc))) {
      const { key: r, val: n, val2: s, def: a, def2: o, literal: u } = e;
      r ? c(this, za)[r] = {
        val: n ?? s,
        def: a ?? o
      } : u && (u === "*" ? P(this, ju, !0) : c(this, za)[u] = { val: "1" });
    }
  }
  // 属性と値の位置をまとめて返す
  parseinDetail(t, e, r, n) {
    const s = {}, a = t.slice(1 + e, -1);
    for (const { groups: o, index: u, 0: l } of a.matchAll(c(this, Mc))) {
      if (u === void 0)
        continue;
      const { key: h, val: d, val2: f, literal: p } = o;
      if (p) {
        if (p.at(-1) === "=") {
          const _ = p.length - 1, { ch: b } = O(this, Uu, Dp).call(this, e, r, n, a, u + _);
          s[p.slice(0, -1)] = {
            k_ln: r,
            k_ch: b - _,
            v_ln: r,
            v_ch: b + 1,
            //	v_ch: ch +1+lenNm +literal.length +1,
            v_len: 0
          };
        }
        continue;
      }
      if (!h)
        continue;
      const { ln: v, ch: g } = O(this, Uu, Dp).call(this, e, r, n, a, u), { ln: m, ch: y } = O(this, Uu, Dp).call(this, e, r, n, a, u + l.lastIndexOf(d ?? f) - (d ? 0 : 1));
      s[h] = { k_ln: v, k_ch: g, v_ln: m, v_ch: y, v_len: d ? d.length : f.length + 2 };
    }
    return s;
  }
  get hPrm() {
    return c(this, za);
  }
  get isKomeParam() {
    return c(this, ju);
  }
}
Mc = new WeakMap(), Uu = new WeakSet(), Dp = function(t, e, r, n, s) {
  const o = n.slice(0, s).split(`
`), u = o.length;
  return {
    ln: e + u - 1,
    ch: u < 2 ? r + 1 + t + s : o.at(-1).length
  };
}, za = new WeakMap(), ju = new WeakMap();
var DS = { exports: {} };
(function(i, t) {
  (function(e, r) {
    i.exports = r();
  })(typeof self < "u" ? self : Sp, function() {
    return function(e) {
      var r = {};
      function n(s) {
        if (r[s])
          return r[s].exports;
        var a = r[s] = { i: s, l: !1, exports: {} };
        return e[s].call(a.exports, a, a.exports, n), a.l = !0, a.exports;
      }
      return n.m = e, n.c = r, n.d = function(s, a, o) {
        n.o(s, a) || Object.defineProperty(s, a, { configurable: !1, enumerable: !0, get: o });
      }, n.r = function(s) {
        Object.defineProperty(s, "__esModule", { value: !0 });
      }, n.n = function(s) {
        var a = s && s.__esModule ? function() {
          return s.default;
        } : function() {
          return s;
        };
        return n.d(a, "a", a), a;
      }, n.o = function(s, a) {
        return Object.prototype.hasOwnProperty.call(s, a);
      }, n.p = "", n(n.s = 0);
    }([function(e, r, n) {
      function s(D) {
        if (!(this instanceof s))
          return new s(D);
        this._ = D;
      }
      var a = s.prototype;
      function o(D, L) {
        for (var j = 0; j < D; j++)
          L(j);
      }
      function u(D, L, j) {
        return function(J, rt) {
          o(rt.length, function(ot) {
            J(rt[ot], ot, rt);
          });
        }(function(J, rt, ot) {
          L = D(L, J, rt, ot);
        }, j), L;
      }
      function l(D, L) {
        return u(function(j, J, rt, ot) {
          return j.concat([D(J, rt, ot)]);
        }, [], L);
      }
      function h(D, L) {
        var j = { v: 0, buf: L };
        return o(D, function() {
          var J;
          j = { v: j.v << 1 | (J = j.buf, J[0] >> 7), buf: function(rt) {
            var ot = u(function(ut, Lt, we, wr) {
              return ut.concat(we === wr.length - 1 ? Buffer.from([Lt, 0]).readUInt16BE(0) : wr.readUInt16BE(we));
            }, [], rt);
            return Buffer.from(l(function(ut) {
              return (ut << 1 & 65535) >> 8;
            }, ot));
          }(j.buf) };
        }), j;
      }
      function d() {
        return typeof Buffer < "u";
      }
      function f() {
        if (!d())
          throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
      }
      function p(D) {
        f();
        var L = u(function(ot, ut) {
          return ot + ut;
        }, 0, D);
        if (L % 8 != 0)
          throw new Error("The bits [" + D.join(", ") + "] add up to " + L + " which is not an even number of bytes; the total should be divisible by 8");
        var j, J = L / 8, rt = (j = function(ot) {
          return ot > 48;
        }, u(function(ot, ut) {
          return ot || (j(ut) ? ut : ot);
        }, null, D));
        if (rt)
          throw new Error(rt + " bit range requested exceeds 48 bit (6 byte) Number max.");
        return new s(function(ot, ut) {
          var Lt = J + ut;
          return Lt > ot.length ? C(ut, J.toString() + " bytes") : S(Lt, u(function(we, wr) {
            var lr = h(wr, we.buf);
            return { coll: we.coll.concat(lr.v), buf: lr.buf };
          }, { coll: [], buf: ot.slice(ut, Lt) }, D).coll);
        });
      }
      function v(D, L) {
        return new s(function(j, J) {
          return f(), J + L > j.length ? C(J, L + " bytes for " + D) : S(J + L, j.slice(J, J + L));
        });
      }
      function g(D, L) {
        if (typeof (j = L) != "number" || Math.floor(j) !== j || L < 0 || L > 6)
          throw new Error(D + " requires integer length in range [0, 6].");
        var j;
      }
      function m(D) {
        return g("uintBE", D), v("uintBE(" + D + ")", D).map(function(L) {
          return L.readUIntBE(0, D);
        });
      }
      function y(D) {
        return g("uintLE", D), v("uintLE(" + D + ")", D).map(function(L) {
          return L.readUIntLE(0, D);
        });
      }
      function _(D) {
        return g("intBE", D), v("intBE(" + D + ")", D).map(function(L) {
          return L.readIntBE(0, D);
        });
      }
      function b(D) {
        return g("intLE", D), v("intLE(" + D + ")", D).map(function(L) {
          return L.readIntLE(0, D);
        });
      }
      function w(D) {
        return D instanceof s;
      }
      function T(D) {
        return {}.toString.call(D) === "[object Array]";
      }
      function x(D) {
        return d() && Buffer.isBuffer(D);
      }
      function S(D, L) {
        return { status: !0, index: D, value: L, furthest: -1, expected: [] };
      }
      function C(D, L) {
        return T(L) || (L = [L]), { status: !1, index: -1, value: null, furthest: D, expected: L };
      }
      function M(D, L) {
        if (!L || D.furthest > L.furthest)
          return D;
        var j = D.furthest === L.furthest ? function(J, rt) {
          if (function() {
            if (s._supportsSet !== void 0)
              return s._supportsSet;
            var zn = typeof Set < "u";
            return s._supportsSet = zn, zn;
          }() && Array.from) {
            for (var ot = new Set(J), ut = 0; ut < rt.length; ut++)
              ot.add(rt[ut]);
            var Lt = Array.from(ot);
            return Lt.sort(), Lt;
          }
          for (var we = {}, wr = 0; wr < J.length; wr++)
            we[J[wr]] = !0;
          for (var lr = 0; lr < rt.length; lr++)
            we[rt[lr]] = !0;
          var jn = [];
          for (var Vr in we)
            ({}).hasOwnProperty.call(we, Vr) && jn.push(Vr);
          return jn.sort(), jn;
        }(D.expected, L.expected) : L.expected;
        return { status: D.status, index: D.index, value: D.value, furthest: L.furthest, expected: j };
      }
      var I = {};
      function R(D, L) {
        if (x(D))
          return { offset: L, line: -1, column: -1 };
        D in I || (I[D] = {});
        for (var j = I[D], J = 0, rt = 0, ot = 0, ut = L; ut >= 0; ) {
          if (ut in j) {
            J = j[ut].line, ot === 0 && (ot = j[ut].lineStart);
            break;
          }
          (D.charAt(ut) === `
` || D.charAt(ut) === "\r" && D.charAt(ut + 1) !== `
`) && (rt++, ot === 0 && (ot = ut + 1)), ut--;
        }
        var Lt = J + rt, we = L - ot;
        return j[L] = { line: Lt, lineStart: ot }, { offset: L, line: Lt + 1, column: we + 1 };
      }
      function N(D) {
        if (!w(D))
          throw new Error("not a parser: " + D);
      }
      function A(D, L) {
        return typeof D == "string" ? D.charAt(L) : D[L];
      }
      function G(D) {
        if (typeof D != "number")
          throw new Error("not a number: " + D);
      }
      function B(D) {
        if (typeof D != "function")
          throw new Error("not a function: " + D);
      }
      function U(D) {
        if (typeof D != "string")
          throw new Error("not a string: " + D);
      }
      var $ = 2, Z = 3, H = 8, z = 5 * H, X = 4 * H, ct = "  ";
      function it(D, L) {
        return new Array(L + 1).join(D);
      }
      function lt(D, L, j) {
        var J = L - D.length;
        return J <= 0 ? D : it(j, J) + D;
      }
      function et(D, L, j, J) {
        return { from: D - L > 0 ? D - L : 0, to: D + j > J ? J : D + j };
      }
      function k(D, L) {
        var j, J, rt, ot, ut, Lt = L.index, we = Lt.offset, wr = 1;
        if (we === D.length)
          return "Got the end of the input";
        if (x(D)) {
          var lr = we - we % H, jn = we - lr, Vr = et(lr, z, X + H, D.length), zn = l(function(er) {
            return l(function(hu) {
              return lt(hu.toString(16), 2, "0");
            }, er);
          }, function(er, hu) {
            var cu = er.length, ma = [], fu = 0;
            if (cu <= hu)
              return [er.slice()];
            for (var du = 0; du < cu; du++)
              ma[fu] || ma.push([]), ma[fu].push(er[du]), (du + 1) % hu == 0 && fu++;
            return ma;
          }(D.slice(Vr.from, Vr.to).toJSON().data, H));
          ot = function(er) {
            return er.from === 0 && er.to === 1 ? { from: er.from, to: er.to } : { from: er.from / H, to: Math.floor(er.to / H) };
          }(Vr), J = lr / H, j = 3 * jn, jn >= 4 && (j += 1), wr = 2, rt = l(function(er) {
            return er.length <= 4 ? er.join(" ") : er.slice(0, 4).join(" ") + "  " + er.slice(4).join(" ");
          }, zn), (ut = (8 * (ot.to > 0 ? ot.to - 1 : ot.to)).toString(16).length) < 2 && (ut = 2);
        } else {
          var lu = D.split(/\r\n|[\n\r\u2028\u2029]/);
          j = Lt.column - 1, J = Lt.line - 1, ot = et(J, $, Z, lu.length), rt = lu.slice(ot.from, ot.to), ut = ot.to.toString().length;
        }
        var YP = J - ot.from;
        return x(D) && (ut = (8 * (ot.to > 0 ? ot.to - 1 : ot.to)).toString(16).length) < 2 && (ut = 2), u(function(er, hu, cu) {
          var ma, fu = cu === YP, du = fu ? "> " : ct;
          return ma = x(D) ? lt((8 * (ot.from + cu)).toString(16), ut, "0") : lt((ot.from + cu + 1).toString(), ut, " "), [].concat(er, [du + ma + " | " + hu], fu ? [ct + it(" ", ut) + " | " + lt("", j, " ") + it("^", wr)] : []);
        }, [], rt).join(`
`);
      }
      function ft(D, L) {
        return [`
`, "-- PARSING FAILED " + it("-", 50), `

`, k(D, L), `

`, (j = L.expected, j.length === 1 ? `Expected:

` + j[0] : `Expected one of the following: 

` + j.join(", ")), `
`].join("");
        var j;
      }
      function Q(D) {
        return D.flags !== void 0 ? D.flags : [D.global ? "g" : "", D.ignoreCase ? "i" : "", D.multiline ? "m" : "", D.unicode ? "u" : "", D.sticky ? "y" : ""].join("");
      }
      function St() {
        for (var D = [].slice.call(arguments), L = D.length, j = 0; j < L; j += 1)
          N(D[j]);
        return s(function(J, rt) {
          for (var ot, ut = new Array(L), Lt = 0; Lt < L; Lt += 1) {
            if (!(ot = M(D[Lt]._(J, rt), ot)).status)
              return ot;
            ut[Lt] = ot.value, rt = ot.index;
          }
          return M(S(rt, ut), ot);
        });
      }
      function at() {
        var D = [].slice.call(arguments);
        if (D.length === 0)
          throw new Error("seqMap needs at least one argument");
        var L = D.pop();
        return B(L), St.apply(null, D).map(function(j) {
          return L.apply(null, j);
        });
      }
      function q() {
        var D = [].slice.call(arguments), L = D.length;
        if (L === 0)
          return V("zero alternates");
        for (var j = 0; j < L; j += 1)
          N(D[j]);
        return s(function(J, rt) {
          for (var ot, ut = 0; ut < D.length; ut += 1)
            if ((ot = M(D[ut]._(J, rt), ot)).status)
              return ot;
          return ot;
        });
      }
      function bt(D, L) {
        return st(D, L).or(dt([]));
      }
      function st(D, L) {
        return N(D), N(L), at(D, L.then(D).many(), function(j, J) {
          return [j].concat(J);
        });
      }
      function W(D) {
        U(D);
        var L = "'" + D + "'";
        return s(function(j, J) {
          var rt = J + D.length, ot = j.slice(J, rt);
          return ot === D ? S(rt, ot) : C(J, L);
        });
      }
      function nt(D, L) {
        (function(rt) {
          if (!(rt instanceof RegExp))
            throw new Error("not a regexp: " + rt);
          for (var ot = Q(rt), ut = 0; ut < ot.length; ut++) {
            var Lt = ot.charAt(ut);
            if (Lt !== "i" && Lt !== "m" && Lt !== "u" && Lt !== "s")
              throw new Error('unsupported regexp flag "' + Lt + '": ' + rt);
          }
        })(D), arguments.length >= 2 ? G(L) : L = 0;
        var j = function(rt) {
          return RegExp("^(?:" + rt.source + ")", Q(rt));
        }(D), J = "" + D;
        return s(function(rt, ot) {
          var ut = j.exec(rt.slice(ot));
          if (ut) {
            if (0 <= L && L <= ut.length) {
              var Lt = ut[0], we = ut[L];
              return S(ot + Lt.length, we);
            }
            return C(ot, "valid match group (0 to " + ut.length + ") in " + J);
          }
          return C(ot, J);
        });
      }
      function dt(D) {
        return s(function(L, j) {
          return S(j, D);
        });
      }
      function V(D) {
        return s(function(L, j) {
          return C(j, D);
        });
      }
      function xt(D) {
        if (w(D))
          return s(function(L, j) {
            var J = D._(L, j);
            return J.index = j, J.value = "", J;
          });
        if (typeof D == "string")
          return xt(W(D));
        if (D instanceof RegExp)
          return xt(nt(D));
        throw new Error("not a string, regexp, or parser: " + D);
      }
      function Dt(D) {
        return N(D), s(function(L, j) {
          var J = D._(L, j), rt = L.slice(j, J.index);
          return J.status ? C(j, 'not "' + rt + '"') : S(j, null);
        });
      }
      function Ct(D) {
        return B(D), s(function(L, j) {
          var J = A(L, j);
          return j < L.length && D(J) ? S(j + 1, J) : C(j, "a character/byte matching " + D);
        });
      }
      function be(D, L) {
        arguments.length < 2 && (L = D, D = void 0);
        var j = s(function(J, rt) {
          return j._ = L()._, j._(J, rt);
        });
        return D ? j.desc(D) : j;
      }
      function je() {
        return V("fantasy-land/empty");
      }
      a.parse = function(D) {
        if (typeof D != "string" && !x(D))
          throw new Error(".parse must be called with a string or Buffer as its argument");
        var L, j = this.skip(ae)._(D, 0);
        return L = j.status ? { status: !0, value: j.value } : { status: !1, index: R(D, j.furthest), expected: j.expected }, delete I[D], L;
      }, a.tryParse = function(D) {
        var L = this.parse(D);
        if (L.status)
          return L.value;
        var j = ft(D, L), J = new Error(j);
        throw J.type = "ParsimmonError", J.result = L, J;
      }, a.assert = function(D, L) {
        return this.chain(function(j) {
          return D(j) ? dt(j) : V(L);
        });
      }, a.or = function(D) {
        return q(this, D);
      }, a.trim = function(D) {
        return this.wrap(D, D);
      }, a.wrap = function(D, L) {
        return at(D, this, L, function(j, J) {
          return J;
        });
      }, a.thru = function(D) {
        return D(this);
      }, a.then = function(D) {
        return N(D), St(this, D).map(function(L) {
          return L[1];
        });
      }, a.many = function() {
        var D = this;
        return s(function(L, j) {
          for (var J = [], rt = void 0; ; ) {
            if (!(rt = M(D._(L, j), rt)).status)
              return M(S(j, J), rt);
            if (j === rt.index)
              throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
            j = rt.index, J.push(rt.value);
          }
        });
      }, a.tieWith = function(D) {
        return U(D), this.map(function(L) {
          if (function(rt) {
            if (!T(rt))
              throw new Error("not an array: " + rt);
          }(L), L.length) {
            U(L[0]);
            for (var j = L[0], J = 1; J < L.length; J++)
              U(L[J]), j += D + L[J];
            return j;
          }
          return "";
        });
      }, a.tie = function() {
        return this.tieWith("");
      }, a.times = function(D, L) {
        var j = this;
        return arguments.length < 2 && (L = D), G(D), G(L), s(function(J, rt) {
          for (var ot = [], ut = void 0, Lt = void 0, we = 0; we < D; we += 1) {
            if (Lt = M(ut = j._(J, rt), Lt), !ut.status)
              return Lt;
            rt = ut.index, ot.push(ut.value);
          }
          for (; we < L && (Lt = M(ut = j._(J, rt), Lt), ut.status); we += 1)
            rt = ut.index, ot.push(ut.value);
          return M(S(rt, ot), Lt);
        });
      }, a.result = function(D) {
        return this.map(function() {
          return D;
        });
      }, a.atMost = function(D) {
        return this.times(0, D);
      }, a.atLeast = function(D) {
        return at(this.times(D), this.many(), function(L, j) {
          return L.concat(j);
        });
      }, a.map = function(D) {
        B(D);
        var L = this;
        return s(function(j, J) {
          var rt = L._(j, J);
          return rt.status ? M(S(rt.index, D(rt.value)), rt) : rt;
        });
      }, a.contramap = function(D) {
        B(D);
        var L = this;
        return s(function(j, J) {
          var rt = L.parse(D(j.slice(J)));
          return rt.status ? S(J + j.length, rt.value) : rt;
        });
      }, a.promap = function(D, L) {
        return B(D), B(L), this.contramap(D).map(L);
      }, a.skip = function(D) {
        return St(this, D).map(function(L) {
          return L[0];
        });
      }, a.mark = function() {
        return at(ee, this, ee, function(D, L, j) {
          return { start: D, value: L, end: j };
        });
      }, a.node = function(D) {
        return at(ee, this, ee, function(L, j, J) {
          return { name: D, value: j, start: L, end: J };
        });
      }, a.sepBy = function(D) {
        return bt(this, D);
      }, a.sepBy1 = function(D) {
        return st(this, D);
      }, a.lookahead = function(D) {
        return this.skip(xt(D));
      }, a.notFollowedBy = function(D) {
        return this.skip(Dt(D));
      }, a.desc = function(D) {
        T(D) || (D = [D]);
        var L = this;
        return s(function(j, J) {
          var rt = L._(j, J);
          return rt.status || (rt.expected = D), rt;
        });
      }, a.fallback = function(D) {
        return this.or(dt(D));
      }, a.ap = function(D) {
        return at(D, this, function(L, j) {
          return L(j);
        });
      }, a.chain = function(D) {
        var L = this;
        return s(function(j, J) {
          var rt = L._(j, J);
          return rt.status ? M(D(rt.value)._(j, rt.index), rt) : rt;
        });
      }, a.concat = a.or, a.empty = je, a.of = dt, a["fantasy-land/ap"] = a.ap, a["fantasy-land/chain"] = a.chain, a["fantasy-land/concat"] = a.concat, a["fantasy-land/empty"] = a.empty, a["fantasy-land/of"] = a.of, a["fantasy-land/map"] = a.map;
      var ee = s(function(D, L) {
        return S(L, R(D, L));
      }), pe = s(function(D, L) {
        return L >= D.length ? C(L, "any character/byte") : S(L + 1, A(D, L));
      }), le = s(function(D, L) {
        return S(D.length, D.slice(L));
      }), ae = s(function(D, L) {
        return L < D.length ? C(L, "EOF") : S(L, null);
      }), ne = nt(/[0-9]/).desc("a digit"), Ht = nt(/[0-9]*/).desc("optional digits"), xr = nt(/[a-z]/i).desc("a letter"), ou = nt(/[a-z]*/i).desc("optional letters"), vh = nt(/\s*/).desc("optional whitespace"), w0 = nt(/\s+/).desc("whitespace"), gh = W("\r"), uu = W(`
`), kd = W(`\r
`), Nd = q(kd, uu, gh).desc("newline"), E0 = q(Nd, ae);
      s.all = le, s.alt = q, s.any = pe, s.cr = gh, s.createLanguage = function(D) {
        var L = {};
        for (var j in D)
          ({}).hasOwnProperty.call(D, j) && function(J) {
            L[J] = be(function() {
              return D[J](L);
            });
          }(j);
        return L;
      }, s.crlf = kd, s.custom = function(D) {
        return s(D(S, C));
      }, s.digit = ne, s.digits = Ht, s.empty = je, s.end = E0, s.eof = ae, s.fail = V, s.formatError = ft, s.index = ee, s.isParser = w, s.lazy = be, s.letter = xr, s.letters = ou, s.lf = uu, s.lookahead = xt, s.makeFailure = C, s.makeSuccess = S, s.newline = Nd, s.noneOf = function(D) {
        return Ct(function(L) {
          return D.indexOf(L) < 0;
        }).desc("none of '" + D + "'");
      }, s.notFollowedBy = Dt, s.of = dt, s.oneOf = function(D) {
        for (var L = D.split(""), j = 0; j < L.length; j++)
          L[j] = "'" + L[j] + "'";
        return Ct(function(J) {
          return D.indexOf(J) >= 0;
        }).desc(L);
      }, s.optWhitespace = vh, s.Parser = s, s.range = function(D, L) {
        return Ct(function(j) {
          return D <= j && j <= L;
        }).desc(D + "-" + L);
      }, s.regex = nt, s.regexp = nt, s.sepBy = bt, s.sepBy1 = st, s.seq = St, s.seqMap = at, s.seqObj = function() {
        for (var D, L = {}, j = 0, J = (D = arguments, Array.prototype.slice.call(D)), rt = J.length, ot = 0; ot < rt; ot += 1) {
          var ut = J[ot];
          if (!w(ut)) {
            if (T(ut) && ut.length === 2 && typeof ut[0] == "string" && w(ut[1])) {
              var Lt = ut[0];
              if (Object.prototype.hasOwnProperty.call(L, Lt))
                throw new Error("seqObj: duplicate key " + Lt);
              L[Lt] = !0, j++;
              continue;
            }
            throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
          }
        }
        if (j === 0)
          throw new Error("seqObj expects at least one named parser, found zero");
        return s(function(we, wr) {
          for (var lr, jn = {}, Vr = 0; Vr < rt; Vr += 1) {
            var zn, lu;
            if (T(J[Vr]) ? (zn = J[Vr][0], lu = J[Vr][1]) : (zn = null, lu = J[Vr]), !(lr = M(lu._(we, wr), lr)).status)
              return lr;
            zn && (jn[zn] = lr.value), wr = lr.index;
          }
          return M(S(wr, jn), lr);
        });
      }, s.string = W, s.succeed = dt, s.takeWhile = function(D) {
        return B(D), s(function(L, j) {
          for (var J = j; J < L.length && D(A(L, J)); )
            J++;
          return S(J, L.slice(j, J));
        });
      }, s.test = Ct, s.whitespace = w0, s["fantasy-land/empty"] = je, s["fantasy-land/of"] = dt, s.Binary = { bitSeq: p, bitSeqObj: function(D) {
        f();
        var L = {}, j = 0, J = l(function(ot) {
          if (T(ot)) {
            var ut = ot;
            if (ut.length !== 2)
              throw new Error("[" + ut.join(", ") + "] should be length 2, got length " + ut.length);
            if (U(ut[0]), G(ut[1]), Object.prototype.hasOwnProperty.call(L, ut[0]))
              throw new Error("duplicate key in bitSeqObj: " + ut[0]);
            return L[ut[0]] = !0, j++, ut;
          }
          return G(ot), [null, ot];
        }, D);
        if (j < 1)
          throw new Error("bitSeqObj expects at least one named pair, got [" + D.join(", ") + "]");
        var rt = l(function(ot) {
          return ot[0];
        }, J);
        return p(l(function(ot) {
          return ot[1];
        }, J)).map(function(ot) {
          return u(function(ut, Lt) {
            return Lt[0] !== null && (ut[Lt[0]] = Lt[1]), ut;
          }, {}, l(function(ut, Lt) {
            return [ut, ot[Lt]];
          }, rt));
        });
      }, byte: function(D) {
        if (f(), G(D), D > 255)
          throw new Error("Value specified to byte constructor (" + D + "=0x" + D.toString(16) + ") is larger in value than a single byte.");
        var L = (D > 15 ? "0x" : "0x0") + D.toString(16);
        return s(function(j, J) {
          var rt = A(j, J);
          return rt === D ? S(J + 1, rt) : C(J, L);
        });
      }, buffer: function(D) {
        return v("buffer", D).map(function(L) {
          return Buffer.from(L);
        });
      }, encodedString: function(D, L) {
        return v("string", L).map(function(j) {
          return j.toString(D);
        });
      }, uintBE: m, uint8BE: m(1), uint16BE: m(2), uint32BE: m(4), uintLE: y, uint8LE: y(1), uint16LE: y(2), uint32LE: y(4), intBE: _, int8BE: _(1), int16BE: _(2), int32BE: _(4), intLE: b, int8LE: b(1), int16LE: b(2), int32LE: b(4), floatBE: v("floatBE", 4).map(function(D) {
        return D.readFloatBE(0);
      }), floatLE: v("floatLE", 4).map(function(D) {
        return D.readFloatLE(0);
      }), doubleBE: v("doubleBE", 8).map(function(D) {
        return D.readDoubleBE(0);
      }), doubleLE: v("doubleLE", 8).map(function(D) {
        return D.readDoubleLE(0);
      }) }, e.exports = s;
    }]);
  });
})(DS);
var se = DS.exports, Ha, Rt, kt, Yn, Fs, yu, kv, Pc, Xy, Nv, Av, kS;
const Kx = class {
  constructor(t, e = "\\") {
    E(this, Rt);
    E(this, Fs);
    E(this, Pc);
    E(this, Ha, null);
    E(this, Yn, {
      "!num!": (t) => t.shift(),
      "!str!": (t) => O(this, Pc, Xy).call(this, t.shift()),
      "!bool!": (t) => t.shift(),
      PostfixInc: (t) => {
        throw Error("(PropParser)後置インクリメントは未サポートです");
      },
      PostfixDec: (t) => {
        throw Error("(PropParser)後置デクリメントは未サポートです");
      },
      PrefixInc: (t) => {
        throw Error("(PropParser)前置インクリメントは未サポートです");
      },
      PrefixDec: (t) => {
        throw Error("(PropParser)前置デクリメントは未サポートです");
      },
      // 論理 NOT
      "!": (t) => {
        const e = t.shift();
        return e[0] === "!bool!" ? !e[1] : String(O(this, Rt, kt).call(this, e)) !== "true";
      },
      // チルダ演算子（ビット反転）
      "~": (t) => ~Number(O(this, Rt, kt).call(this, t.shift())),
      //		UnaryNegate:	a=> - Number(this.#calc(a.shift())),
      UnaryNegate: (t) => -c(this, Yn).Number(t),
      //	Unaryplus:		a=> this.#hFnc['Number'](a),
      // 乗算、除算、剰余
      "**": (t) => Number(O(this, Rt, kt).call(this, t.shift())) ** Number(O(this, Rt, kt).call(this, t.shift())),
      "*": (t) => Number(O(this, Rt, kt).call(this, t.shift())) * Number(O(this, Rt, kt).call(this, t.shift())),
      "/": (t) => Number(O(this, Rt, kt).call(this, t.shift())) / Number(O(this, Rt, kt).call(this, t.shift())),
      "¥": (t) => Math.floor(c(this, Yn)["/"](t)),
      "%": (t) => Number(O(this, Rt, kt).call(this, t.shift())) % Number(O(this, Rt, kt).call(this, t.shift())),
      // 加算、減算、文字列の連結
      "+": (t) => {
        const e = O(this, Rt, kt).call(this, t.shift()), r = O(this, Rt, kt).call(this, t.shift());
        return Object.prototype.toString.call(e) === "[object String]" || Object.prototype.toString.call(r) === "[object String]" ? String(e) + String(r) : Number(e) + Number(r);
      },
      "-": (t) => Number(O(this, Rt, kt).call(this, t.shift())) - Number(O(this, Rt, kt).call(this, t.shift())),
      // 関数
      int: (t) => $t(O(this, Fs, yu).call(this, t.shift())),
      parseInt: (t) => $t(c(this, Yn).Number(t)),
      Number: (t) => {
        const e = O(this, Rt, kt).call(this, t.shift());
        return Object.prototype.toString.call(e) === "[object String]" ? O(this, Fs, yu).call(this, c(this, Ha).parse(String(e)).value) : Number(e);
      },
      ceil: (t) => Math.ceil(O(this, Fs, yu).call(this, t.shift())),
      floor: (t) => Math.floor(O(this, Fs, yu).call(this, t.shift())),
      round: (t) => Math.round(O(this, Fs, yu).call(this, t.shift())),
      isNaN: (t) => isNaN(Number(O(this, Rt, kt).call(this, t.shift()))),
      // ビットシフト
      "<<": (t) => Number(O(this, Rt, kt).call(this, t.shift())) << Number(O(this, Rt, kt).call(this, t.shift())),
      ">>": (t) => Number(O(this, Rt, kt).call(this, t.shift())) >> Number(O(this, Rt, kt).call(this, t.shift())),
      ">>>": (t) => Number(O(this, Rt, kt).call(this, t.shift())) >>> Number(O(this, Rt, kt).call(this, t.shift())),
      // 等値、非等値、厳密等価、厳密非等価
      "<": (t) => Number(O(this, Rt, kt).call(this, t.shift())) < Number(O(this, Rt, kt).call(this, t.shift())),
      "<=": (t) => Number(O(this, Rt, kt).call(this, t.shift())) <= Number(O(this, Rt, kt).call(this, t.shift())),
      ">": (t) => Number(O(this, Rt, kt).call(this, t.shift())) > Number(O(this, Rt, kt).call(this, t.shift())),
      ">=": (t) => Number(O(this, Rt, kt).call(this, t.shift())) >= Number(O(this, Rt, kt).call(this, t.shift())),
      // 小なり、以下、大なり、以上
      "==": (t) => {
        const e = O(this, Rt, kt).call(this, t.shift()), r = O(this, Rt, kt).call(this, t.shift());
        return e == null && r == null && (!e || !r) ? e == r : String(e) === String(r);
      },
      "!=": (t) => !c(this, Yn)["=="](t),
      "===": (t) => {
        const e = O(this, Rt, kt).call(this, t.shift()), r = O(this, Rt, kt).call(this, t.shift());
        return Object.prototype.toString.call(e) != Object.prototype.toString.call(r) ? !1 : String(e) === String(r);
      },
      "!==": (t) => !c(this, Yn)["==="](t),
      // ビット演算子
      "&": (t) => Number(O(this, Rt, kt).call(this, t.shift())) & Number(O(this, Rt, kt).call(this, t.shift())),
      "^": (t) => Number(O(this, Rt, kt).call(this, t.shift())) ^ Number(O(this, Rt, kt).call(this, t.shift())),
      "|": (t) => Number(O(this, Rt, kt).call(this, t.shift())) | Number(O(this, Rt, kt).call(this, t.shift())),
      // 論理 AND,OR
      "&&": (t) => String(O(this, Rt, kt).call(this, t.shift())) === "true" && String(O(this, Rt, kt).call(this, t.shift())) === "true",
      "||": (t) => String(O(this, Rt, kt).call(this, t.shift())) === "true" || String(O(this, Rt, kt).call(this, t.shift())) === "true",
      // 条件
      "?": (t) => {
        const e = t.shift();
        let r = !1;
        if (e[0] === "!bool!")
          r = !!e[1];
        else {
          const s = String(O(this, Rt, kt).call(this, e));
          r = s !== "true" && s !== "false" ? $t(s) !== 0 : s === "true";
        }
        const n = t.shift();
        if (n[0] !== ":")
          throw Error("(PropParser)三項演算子の文法エラーです。: が見つかりません");
        return O(this, Rt, kt).call(this, n[r ? 1 : 2]);
      },
      ":": () => {
        throw Error("(PropParser)三項演算子の文法エラーです。? が見つかりません");
      }
    });
    E(this, kv, /(\$((tmp|sys|save|mp):)?[^\s!--\/:-@[-^`{-~]+|\#\{[^\}]+})/g);
    K(this, "getValAmpersand", (t) => t.at(0) === "&" ? String(this.parse(t.slice(1))) : t);
    this.val = t;
    function r(_) {
      const b = [];
      for (const w of _)
        b.push(
          (typeof w == "string" ? se.string(w) : se.regex(w)).trim(se.optWhitespace)
        );
      return se.alt.apply(null, b);
    }
    function n(_) {
      let w = Object.keys(_).sort().map(
        (T) => (typeof _[T] == "string" ? se.string(_[T]) : se.regex(_[T])).trim(se.optWhitespace).result(T)
      );
      return se.alt.apply(null, w);
    }
    function s(_, b) {
      const w = se.lazy(() => se.seq(_, w).or(b));
      return w;
    }
    function a(_, b) {
      return se.seqMap(b, _.many(), (w, T) => T.reduce((x, S) => [S, x], w));
    }
    function o(_, b) {
      let w = se.lazy(
        () => b.chain(
          (T) => se.seq(
            _,
            se.of(T),
            w
          ).or(se.of(T))
        )
      );
      return w;
    }
    function u(_, b) {
      return se.seqMap(
        b,
        se.seq(_, b).many(),
        (w, T) => T.reduce((x, S) => [S[0], x, S[1]], w)
      );
    }
    const l = se.alt(
      se.alt(
        se.regex(/-?(0|[1-9][0-9]*)\.[0-9]+/),
        se.regex(/0x[0-9a-fA-F]+/)
      ).map(Number),
      se.alt(
        se.regex(/-?(0|[1-9][0-9]*)/)
      ).map((_) => $t(_))
    ).map((_) => ["!num!", _]).desc("number"), h = se.string("null").map(() => ["!str!", null]), d = se.regex(/(true|false)/).map((_) => ["!bool!", _ === "true"]).desc("boolean"), f = se.regex(new RegExp(`(?:"(?:\\${e}["'#\\n]|[^"])*"|'(?:\\${e}["'#\\n]|[^'])*'|\\#(?:\\${e}["'#\\n]|[^#])*\\#)`)).map((_) => ["!str!", _.slice(1, -1).replaceAll(e, "")]).desc("string"), p = /\[[^\]]+\]/g, v = se.regex(/-?(?:(?:tmp|sys|save|mp):)?[^\s!-\/:-@[-^`{-~]+(?:\.[^\s!-\/:-@[-^`{-~]+|\[[^\]]+\])*(?:@str)?/).map((_) => {
      const b = String(_).replaceAll(
        p,
        (T) => "." + this.parse(T.slice(1, -1))
      ), w = this.val.getVal(b);
      return w == null ? ["!str!", w] : typeof w == "boolean" ? ["!bool!", w] : Object.prototype.toString.call(w) === "[object String]" ? ["!str!", String(w)] : ["!num!", Number(w)];
    }).desc("string"), g = se.lazy(
      () => se.string("(").then(c(this, Ha)).skip(se.string(")")).or(l).or(h).or(d).or(f).or(v)
    ), y = [
      // 演算子の優先順位 - JavaScript | MDN https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Operator_precedence
      // 優先順位：18（メンバーへのアクセス、計算値によるメンバーへのアクセス）
      // a.b  a[b]
      { type: s, ops: r([/[A-Za-z_][A-Za-z0-9_]*(?=\()/]) },
      // 優先順位：16
      { type: a, ops: n({ PostfixInc: "++" }) },
      { type: a, ops: n({ PostfixDec: "--" }) },
      // 【未サポート】後置インクリメント・デクリメント
      // 優先順位：15
      { type: s, ops: r([/!(?!=)|~/]) },
      // 論理 NOT (!)、ビット単位 NOT (~)
      { type: s, ops: n({ PrefixInc: "++" }) },
      { type: s, ops: n({ PrefixDec: "--" }) },
      // 【未サポート】前置インクリメント・デクリメント
      //	{type: PREFIX, ops: opeH({Unaryplus: /\+(?!\+)/})},	// 単項プラス
      { type: s, ops: n({ UnaryNegate: /-(?!-)/ }) },
      // 単項マイナス
      // 優先順位：14以下（並びに注意）
      { type: o, ops: r(["**"]) },
      { type: u, ops: r(["*", "/", "¥", "%"]) },
      { type: u, ops: r(["+", "-"]) },
      { type: u, ops: r([/>>>|<<|>>/]) },
      { type: u, ops: r([/<=|<|>=|>/]) },
      { type: u, ops: r([/===|!==|==|!=/]) },
      { type: u, ops: r([/&(?!&)/]) },
      { type: u, ops: r(["^"]) },
      { type: u, ops: r([/\|(?!\|)/]) },
      { type: u, ops: r(["&&"]) },
      { type: u, ops: r(["||"]) },
      { type: o, ops: r([":"]) },
      { type: o, ops: r(["?"]) }
    ].reduce(
      (_, b) => b.type(b.ops, _),
      g
    );
    P(this, Ha, y.trim(se.optWhitespace));
  }
  parse(t) {
    const e = c(this, Ha).parse(t);
    if (!e.status)
      throw Error("(PropParser)文法エラー【" + t + "】");
    const r = e.value;
    return r[0] === "!str!" ? O(this, Pc, Xy).call(this, r[1]) : O(this, Rt, kt).call(this, r);
  }
  // 522 match 18413 step(~10ms) https://regex101.com/r/tmCKuE/1
  // →これは改良しようがない。いい意味で改善の余地なし
  static getValName(t) {
    var o;
    const e = c(this, Nv).exec(t.trim()), r = e == null ? void 0 : e.groups;
    if (!r)
      return null;
    const { scope: n = "tmp", name: s, at: a = "" } = r;
    return {
      scope: n,
      name: O(o = Kx, Av, kS).call(o, s),
      at: a
    };
  }
};
let Ba = Kx;
Ha = new WeakMap(), Rt = new WeakSet(), kt = function(t) {
  const e = t.shift();
  if (e instanceof Array)
    return O(this, Rt, kt).call(this, e);
  const r = c(this, Yn)[e];
  return r ? r(t) : Object(null);
}, Yn = new WeakMap(), Fs = new WeakSet(), yu = function(t) {
  const e = O(this, Rt, kt).call(this, t);
  if (Object.prototype.toString.call(e) !== "[object Number]")
    throw Error("(PropParser)引数【" + e + "】が数値ではありません");
  return Number(e);
}, kv = new WeakMap(), Pc = new WeakSet(), Xy = function(t) {
  return t == null ? t : String(t).replaceAll(
    c(this, kv),
    (e) => e.at(0) === "$" ? this.val.getVal(e.slice(1)) : this.parse(e.slice(2, -1))
  );
}, Nv = new WeakMap(), Av = new WeakSet(), kS = function(t) {
  let e = 0, r = 0;
  for (; ; ) {
    if (e = t.indexOf('["'), e < 0) {
      if (e = t.indexOf("['"), e < 0)
        break;
      r = t.indexOf("']", e + 2);
    } else
      r = t.indexOf('"]', e + 2);
    if (r < 0)
      break;
    t = t.slice(0, e) + "." + t.slice(e + 2, r) + t.slice(r + 2), e = r - 2;
  }
  return t;
}, E(Ba, Av), E(Ba, Nv, /^((?<scope>\w+?):)?(?<name>[^\s :@]+)(?<at>\@str)?$/);
var Di, $a, zu, ki, Oc, Lv, NS, Bv, AS, Fv, LS, Gv, BS;
const ue = class {
  constructor(t, e, r) {
    E(this, Lv);
    E(this, Bv);
    // ログ出力
    E(this, Oc, !0);
    this.sys = t, P(ue, Di, r), P(ue, $a, e), P(ue, zu, e.title), ue.myTrace = O(ue, Fv, LS), e.log = (n) => O(this, Lv, NS).call(this, n), e.trace = (n) => O(this, Bv, AS).call(this, n), P(ue, ki, document.createElement("span")), c(ue, ki).hidden = !0, c(ue, ki).textContent = "", c(ue, ki).style.cssText = `	z-index: ${Number.MAX_SAFE_INTEGER};
			position: absolute; left: 0; top: 0;
			color: black;
			background-color: rgba(255, 255, 255, 0.7);`, document.body.appendChild(c(ue, ki));
  }
  destroy() {
    P(ue, zu, () => !1), document.body.removeChild(c(ue, ki)), ue.myTrace = ue.trace_beforeNew;
  }
  // private禁止、galleryでエラーになる
  static trace_beforeNew(t, e = "E") {
    let r = `{${e}} ` + t, n = "";
    switch (e) {
      case "D":
        n = `color:#${Y.isDarkMode ? "49F" : "05A"};`;
        break;
      case "W":
        n = "color:#FF8800;";
        break;
      case "F":
        n = "color:#BB0000;";
        break;
      case "ET":
        throw r;
      case "E":
        console.error("%c" + r, "color:#FF3300;");
        return;
      default:
        n = "color:black;", r = " " + r;
    }
    console.info("%c" + r, n);
  }
};
let zt = ue;
Di = new WeakMap(), $a = new WeakMap(), zu = new WeakMap(), ki = new WeakMap(), Oc = new WeakMap(), Lv = new WeakSet(), NS = function(t) {
  let e = "";
  return c(this, Oc) && (P(this, Oc, !1), e = `== ${xE.description} ==
`), this.sys.appendFile(
    this.sys.path_downloads + "log.txt",
    `${e}--- ${ec("-", "_", "")} [fn:${c(ue, Di).scriptFn} line:${c(ue, Di).lineNum}] prj:${this.sys.cur}
${t.text || `(text is ${t.text})`}
`,
    (r) => {
      r && console.log(r);
    }
  ), !1;
}, Bv = new WeakSet(), AS = function(t) {
  return ue.myTrace(t.text || `(text is ${t.text})`, "I"), !1;
}, Fv = new WeakSet(), LS = function(t, e = "E") {
  var s, a;
  let r = `{${e}} ` + ue.strPos() + t;
  O(s = ue, Gv, BS).call(s, r, e);
  let n = "";
  switch (e) {
    case "D":
      n = `color:#${Y.isDarkMode ? "49F" : "05A"};`;
      break;
    case "W":
      n = "color:#F80;";
      break;
    case "F":
      n = "color:#B00;";
      break;
    case "ET":
    case "E":
      if (c(a = ue, zu).call(a, { text: t }), c(this, $a).dump_lay({}), c(this, $a).dump_val({}), c(ue, Di).dumpErrForeLine(), c(this, $a).dump_stack({}), e === "ET")
        throw r;
      console.error("%c" + r, "color:#F30;");
      return;
    default:
      n = "", r = " " + r;
  }
  console.info("%c" + r, n);
}, Gv = new WeakSet(), BS = function(t, e) {
  let r = "";
  switch (e) {
    case "D":
      r = "color:#05A;";
      break;
    case "W":
      r = "color:#F80;";
      break;
    case "F":
      r = "color:#B00;";
      break;
    case "ET":
    case "E":
      r = "color:#F30;";
      break;
    default:
      r = "";
  }
  c(ue, ki).innerHTML += `<span style='${r}'>${t}</span><br/>`, c(ue, ki).hidden = !1;
}, E(zt, Fv), E(zt, Gv), E(zt, Di, void 0), E(zt, $a, void 0), E(zt, zu, void 0), E(zt, ki, void 0), K(zt, "myTrace", ue.trace_beforeNew), K(zt, "strPos", () => c(ue, Di) && c(ue, Di).lineNum > 0 ? `(fn:${c(ue, Di).scriptFn} line:${c(ue, Di).lineNum}) ` : "");
class sw {
  constructor() {
    K(this, "hAreas", /* @__PURE__ */ Object.create(null));
  }
  clear() {
    this.hAreas = {};
  }
  search(t) {
    return Object.entries(this.hAreas).some(([e, r]) => t >= parseInt(e) && t <= r);
  }
  record(t) {
    if (!this.search(t)) {
      for (const [e, r] of Object.entries(this.hAreas))
        if (r + 1 === t) {
          String(t + 1) in this.hAreas ? (this.hAreas[e] = this.hAreas[t + 1], delete this.hAreas[t + 1]) : this.hAreas[e] = t;
          return;
        }
      if (String(t + 1) in this.hAreas) {
        this.hAreas[t] = this.hAreas[t + 1], delete this.hAreas[t + 1];
        return;
      }
      this.hAreas[t] = t;
    }
  }
  erase(t) {
    if (this.search(t)) {
      if (String(t) in this.hAreas) {
        this.hAreas[t] > t && (this.hAreas[t + 1] = this.hAreas[t]), delete this.hAreas[t];
        return;
      }
      for (const [e, r] of Object.entries(this.hAreas))
        if (!(t < parseInt(e) || r < t)) {
          if (this.hAreas[e] === t) {
            this.hAreas[e] = t - 1;
            return;
          }
          this.hAreas[t + 1] = r, this.hAreas[e] = t - 1;
          return;
        }
    }
  }
  get count() {
    return Object.keys(this.hAreas).length;
  }
  // 4tst
  toString() {
    let t = ",";
    for (const e of Object.keys(this.hAreas).map((r) => parseInt(r)).sort((r, n) => r - n))
      t += e === this.hAreas[e] ? "," + e : "," + e + "~" + this.hAreas[e];
    return t.slice(1);
  }
}
var rr, ci, Me, qn, We, Yr, un, Ic, Uv, Rc, Wy, Dc, kc, jv, FS, zv, GS, fi, on, Hv, US, $v, jS, Vv, zS, Xv, HS, Wv, $S, Yv, VS, qv, XS, Zv, WS, Hu, Np, Nc, Yy, Ac, Va, Lc, qy, Kv, Jv, $u, Bc, Vu, Ap, Qv, YS, tg, qS, Fc, Zy, Gc, Ky, eg, ZS, rg, KS, Xu, Lp;
const ku = class {
  constructor(t, e) {
    E(this, Rc);
    //	// しおり
    // しおりの複写
    E(this, jv);
    // しおりの消去
    E(this, zv);
    //	//	変数操作
    // 変数代入・演算
    E(this, fi);
    // 絶対値
    E(this, Hv);
    // 文字列から一字取りだし
    E(this, $v);
    // 文字列で検索
    E(this, Vv);
    // 文字列の長さ
    E(this, Xv);
    // 正規表現で置換
    E(this, Wv);
    // 四捨五入
    E(this, Yv);
    // 正規表現で検索
    E(this, qv);
    // 文字列から抜きだし
    E(this, Zv);
    //	// デバッグ・その他
    // システム変数の全消去
    E(this, Hu);
    // ゲーム変数の全消去
    E(this, Nc);
    E(this, Lc);
    E(this, Vu);
    E(this, Qv);
    E(this, tg);
    E(this, Fc);
    E(this, Gc);
    E(this, eg);
    E(this, rg);
    E(this, Xu);
    E(this, rr, { sys: {}, save: {}, tmp: {}, mp: {} });
    E(this, ci, c(this, rr).save);
    E(this, Me, c(this, rr).tmp);
    E(this, qn, void 0);
    E(this, We, { sys: {}, mark: {}, kidoku: {} });
    E(this, Yr, void 0);
    E(this, un, {});
    E(this, Ic, void 0);
    E(this, Uv, {
      auth: (t, e) => O(this, Rc, Wy).call(this, e.hBreakpoint.aData),
      var: (t, e) => c(this, qn).send2Dbg(e.ri, { v: c(this, rr)[e.scope] ?? {} }),
      set_var: (t, e) => {
        try {
          c(this, Ac).call(this, e.nm, e.val), c(this, qn).send2Dbg(e.ri, {});
        } catch {
        }
      },
      set_data_break: (t, e) => {
        O(this, Rc, Wy).call(this, e.a), c(this, qn).send2Dbg(e.ri, {});
      },
      disconnect: (t) => P(ku, Va, {})
    });
    E(this, Dc, () => {
    });
    E(this, kc, (t) => {
    });
    K(this, "getMark", (t) => c(this, We).mark[t]);
    K(this, "getAreaKidoku", (t) => c(this, un)[t]);
    E(this, Ac, (t, e, r = !0) => {
      if (!t)
        throw "[変数に値セット] nameは必須です";
      if (e == null)
        throw "[変数に値セット] textは必須です（空文字はOK）";
      const n = Ba.getValName(t);
      if (n === null)
        throw "[変数参照] name(" + t + ")が変数名として異常です";
      const s = c(this, rr)[n.scope];
      if (!s)
        throw "[変数に値セット] scopeが異常【" + n.scope + "】です";
      const a = n.name;
      if (a.slice(0, 6) === "const." && a in s)
        throw "[変数に値セット] 変数【" + a + "】は書き換え不可です";
      this.setVal_Nochk(n.scope, a, e, r);
    });
    K(this, "getVal", (t, e) => {
      if (!t)
        throw "[変数参照] nameは必須です";
      const r = Ba.getValName(t);
      if (r === null)
        throw "[変数参照] name(" + t + ")が変数名として異常です";
      const n = c(this, rr)[r.scope];
      if (!n)
        throw "[変数参照] scopeが異常【" + r.scope + "】です";
      const s = r.name;
      let a = n[s];
      if (!(s in n)) {
        a = e;
        let o = "";
        const u = s.split("."), l = u.length;
        for (let h = 0; h < l; ++h, o += ".") {
          if (o += u[h], !(o in n))
            continue;
          let d = JSON.parse(n[o]);
          if (Object.prototype.toString.call(d) !== "[object Object]") {
            if (h + 1 === l) {
              a = d;
              break;
            }
            continue;
          }
          let f = h;
          for (; ++f < l; ) {
            if (!(u[f] in d)) {
              a = e;
              break;
            }
            if (d = d[u[f]], Object.prototype.toString.call(d) !== "[object Object]" || f + 1 === l) {
              a = d;
              break;
            }
          }
          a instanceof Object && (a = JSON.stringify(a));
          break;
        }
      }
      return a instanceof Function && (a = a()), r.at === "@str" ? a : O(this, Lc, qy).call(this, a);
    });
    E(this, Kv, /^-?[\d\.]+$/);
    // 変数のダンプ
    E(this, Jv, () => {
      const t = { tmp: {}, sys: {}, save: {}, mp: {} };
      for (let e in t) {
        const r = c(this, rr)[e], n = t[e];
        for (let [s, a] of Object.entries(r))
          n[s] = Object.prototype.toString.call(a) === "[object Function]" ? a() : a;
      }
      return console.info("🥟 [dump_val]", t), !1;
    });
    E(this, $u, !1);
    E(this, Bc, {
      // sys
      "sys:sn.tagCh.doWait": (t) => O(this, Vu, Ap).call(this, t),
      "sys:sn.tagCh.doWait_Kidoku": (t) => O(this, Vu, Ap).call(this, t),
      "sys:sn.tagCh.msecWait": (t) => O(this, Qv, YS).call(this, t),
      "sys:sn.tagCh.msecWait_Kidoku": (t) => O(this, tg, qS).call(this, t),
      "sys:sn.tagCh.canskip": (t) => O(this, Vu, Ap).call(this, t),
      "sys:sn.auto.msecPageWait": (t) => O(this, Fc, Zy).call(this, t),
      "sys:sn.auto.msecPageWait_Kidoku": (t) => O(this, Fc, Zy).call(this, t),
      "sys:sn.auto.msecLineWait": (t) => O(this, Gc, Ky).call(this, t),
      "sys:sn.auto.msecLineWait_Kidoku": (t) => O(this, Gc, Ky).call(this, t),
      // save
      "save:sn.doRecLog": (t) => {
        c(this, kc).call(this, P(this, $u, O(this, eg, ZS).call(this, t)));
      },
      "save:sn.userFnTail": (t, e) => {
        if (e.includes("@"))
          throw "この変数では文字「@」は禁止です";
        this.cfg.userFnTail = e;
      },
      // tmp
      "tmp:sn.tagL.enabled": (t) => O(this, rg, KS).call(this, t),
      "tmp:sn.skip.all": (t) => O(this, Xu, Lp).call(this, t),
      "tmp:sn.skip.enabled": (t) => O(this, Xu, Lp).call(this, t),
      "tmp:sn.auto.enabled": (t) => O(this, Xu, Lp).call(this, t),
      "tmp:flash.desktop.NativeApplication.nativeApplication.systemIdleMode": () => {
      }
    });
    if (this.cfg = t, e.let = (s) => O(this, fi, on).call(this, s), e.let_abs = (s) => O(this, Hv, US).call(this, s), e.let_char_at = (s) => O(this, $v, jS).call(this, s), e.let_index_of = (s) => O(this, Vv, zS).call(this, s), e.let_length = (s) => O(this, Xv, HS).call(this, s), e.let_replace = (s) => O(this, Wv, $S).call(this, s), e.let_round = (s) => O(this, Yv, VS).call(this, s), e.let_search = (s) => O(this, qv, XS).call(this, s), e.let_substr = (s) => O(this, Zv, WS).call(this, s), e.clearsysvar = () => O(this, Hu, Np).call(this), e.clearvar = () => O(this, Nc, Yy).call(this), e.dump_val = () => c(this, Jv).call(this), e.copybookmark = (s) => O(this, jv, FS).call(this, s), e.erasebookmark = (s) => O(this, zv, GS).call(this, s), c(this, ci)["sn.userFnTail"] = "", this.defTmp("const.sn.bookmark.json", () => {
      const s = [];
      for (const a of Object.keys(c(this, We).mark).sort()) {
        const o = { ...c(this, We).mark[a].json };
        o.place = a, s.push(o);
      }
      return JSON.stringify(s);
    }), c(this, Me)["const.sn.isFirstBoot"] = !0, c(this, Me)["sn.tagL.enabled"] = !0, c(this, Me)["sn.skip.all"] = !1, c(this, Me)["sn.skip.enabled"] = !1, c(this, Me)["sn.auto.enabled"] = !1, c(this, Me)["const.sn.last_page_text"] = "", c(this, Me)["const.sn.displayState"] = !1, c(this, Me)["const.Date.getTime"] = () => (/* @__PURE__ */ new Date()).getTime(), c(this, Me)["const.Date.getDateStr"] = () => ec(), c(this, Me)["const.sn.platform"] = JSON.stringify(xE), O(this, Hu, Np).call(this), O(this, Nc, Yy).call(this), c(this, Me)["const.sn.config.window.width"] = t.oCfg.window.width, c(this, Me)["const.sn.config.window.height"] = t.oCfg.window.height, c(this, Me)["const.sn.config.book.title"] = t.oCfg.book.title, c(this, Me)["const.sn.config.book.version"] = t.oCfg.book.version, c(this, Me)["const.sn.Math.PI"] = Math.PI, typeof window > "u")
      return;
    const r = window, n = r.AudioContext ?? r.webkitAudioContext;
    c(this, Me)["const.sn.needClick2Play"] = () => new n().state === "suspended";
  }
  setSys(t) {
    P(this, qn, t), t.initVal(c(this, We), c(this, Me), (e) => {
      this.updateData(e), sessionStorage.clear();
      const r = this.cfg.getNs();
      P(this, Dc, this.cfg.oCfg.debug.variable ? () => {
        const s = {};
        for (const [d, f] of Object.entries(c(this, Yr)))
          s["sys:" + d] = f instanceof Function ? f() : f;
        sessionStorage[r + "sys"] = JSON.stringify(s);
        const a = {};
        for (const [d, f] of Object.entries(c(this, ci)))
          a["save:" + d] = f instanceof Function ? f() : f;
        sessionStorage[r + "save"] = JSON.stringify(a);
        const o = {};
        for (const [d, f] of Object.entries(c(this, Me)))
          o[d] = f instanceof Function ? f() : f;
        sessionStorage[r + "tmp"] = JSON.stringify(o);
        const u = {};
        for (const [d, f] of Object.entries(c(this, rr).mp))
          u[d] = f instanceof Function ? f() : f;
        sessionStorage[r + "mp"] = JSON.stringify(u);
        const l = {};
        for (const [d, f] of Object.entries(c(this, We).mark))
          l[d] = f instanceof Function ? f() : f;
        sessionStorage[r + "mark"] = JSON.stringify(l);
        const h = {};
        for (const [d, f] of Object.entries(c(this, We).kidoku))
          h[d] = f instanceof Function ? f() : f;
        sessionStorage[r + "kidoku"] = JSON.stringify(h), t.flush();
      } : () => t.flush()), P(this, Ic, (s, a) => t.callHook(s, a)), t.addHook((s, a) => {
        var o, u;
        return (u = (o = c(this, Uv))[s]) == null ? void 0 : u.call(o, s, a);
      });
      const n = this.getVal("sys:sn.tagCh.msecWait", -1);
      (c(this, Me)["const.sn.isFirstBoot"] || n === -1) && O(this, Hu, Np).call(this);
    });
  }
  updateData(t) {
    P(this, We, t), P(this, Yr, c(this, rr).sys = c(this, We).sys), P(this, un, {});
    for (const [e, r] of Object.entries(c(this, We).kidoku)) {
      const n = new sw();
      n.hAreas = { ...r }, c(this, un)[e] = n;
    }
  }
  flush() {
    c(this, Dc).call(this);
  }
  // 先にこのメソッドへの参照を配ってしまうので、中身を入れ替える
  setDoRecProc(t) {
    P(this, kc, t);
  }
  defTmp(t, e) {
    c(this, Me)[t] = e;
  }
  cloneMp() {
    return { ...c(this, rr).mp };
  }
  setMp(t) {
    c(this, rr).mp = t;
  }
  setMark(t, e) {
    c(this, We).mark[t] = e, this.flush();
  }
  cloneSave() {
    return { ...c(this, rr).save };
  }
  mark2save(t) {
    P(this, ci, c(this, rr).save = { ...t.hSave }), P(this, $u, c(this, ci)["sn.doRecLog"] ?? !1);
  }
  // 既読系
  loadScrWork(t) {
    t in c(this, un) || (c(this, un)[t] = new sw());
  }
  saveKidoku() {
    for (const [t, { hAreas: e }] of Object.entries(c(this, un)))
      c(this, We).kidoku[t] = { ...e };
    this.flush();
  }
  setVal_Nochk(t, e, r, n = !1) {
    var o, u;
    const s = c(this, rr)[t];
    n && (r = O(this, Lc, qy).call(this, r));
    const a = t + ":" + e;
    if (a in c(ku, Va)) {
      const l = s[e], h = r;
      l != h && c(this, Ic).call(this, "data_break", {
        dataId: a,
        old_v: l,
        new_v: h
      });
    }
    s[e] = r, (u = (o = c(this, Bc))[a]) == null || u.call(o, e, r);
  }
  doRecLog() {
    return c(this, $u);
  }
  defValTrg(t, e) {
    c(this, Bc)[t] = e;
  }
};
let kp = ku;
rr = new WeakMap(), ci = new WeakMap(), Me = new WeakMap(), qn = new WeakMap(), We = new WeakMap(), Yr = new WeakMap(), un = new WeakMap(), Ic = new WeakMap(), Uv = new WeakMap(), Rc = new WeakSet(), Wy = function(t) {
  P(ku, Va, {});
  for (const e of t)
    c(ku, Va)[e.dataId] = 1;
}, Dc = new WeakMap(), kc = new WeakMap(), jv = new WeakSet(), FS = function(t) {
  if (!("from" in t))
    throw "fromは必須です";
  if (!("to" in t))
    throw "toは必須です";
  const e = Number(t.from), r = Number(t.to);
  if (e === r)
    return !1;
  if (!(e in c(this, We).mark))
    throw `from:${e} のセーブデータは存在しません`;
  return this.setMark(r, { ...c(this, We).mark[e] }), c(this, qn).copyBMFolder(e, r), !1;
}, zv = new WeakSet(), GS = function(t) {
  const { place: e } = t;
  if (!e)
    throw "placeは必須です";
  return delete c(this, We).mark[e], this.flush(), c(this, qn).eraseBMFolder(e), !1;
}, fi = new WeakSet(), on = function(t) {
  if (!t.name)
    throw "nameは必須です";
  let e = !0;
  if (t.cast)
    switch (t.cast) {
      case "num":
        tt(t, "text", NaN);
        break;
      case "int":
        t.text = String($t(tt(t, "text", NaN)));
        break;
      case "uint":
        t.text = String(ii(tt(t, "text", NaN)));
        break;
      case "bool":
        vt(t, "text", !1);
        break;
      case "str":
        e = !1;
        break;
      default:
        throw "cast【" + t.cast + "】は未定義です";
    }
  return c(this, Ac).call(this, t.name, t.text, e), !1;
}, Hv = new WeakSet(), US = function(t) {
  const e = tt(t, "text", 0);
  return t.text = String(e < 0 ? -e : e), O(this, fi, on).call(this, t), !1;
}, $v = new WeakSet(), jS = function(t) {
  return t.text = (t.text ?? "").charAt(tt(t, "pos", 0)), O(this, fi, on).call(this, t), !1;
}, Vv = new WeakSet(), zS = function(t) {
  const { val: e } = t;
  if (!e)
    throw "valは必須です";
  const r = tt(t, "start", 0);
  return t.text = String((t.text ?? "").indexOf(e, r)), O(this, fi, on).call(this, t), !1;
}, Xv = new WeakSet(), HS = function(t) {
  return t.text = String((t.text ?? "").length), O(this, fi, on).call(this, t), !1;
}, Wv = new WeakSet(), $S = function(t) {
  if (!t.reg)
    throw "regは必須です";
  const { flags: e } = t, r = e ? new RegExp(t.reg, e) : new RegExp(t.reg);
  return t.text = String(t.text ?? "").replace(r, String(t.val)), O(this, fi, on).call(this, t), !1;
}, Yv = new WeakSet(), VS = function(t) {
  const e = tt(t, "text", 0);
  return t.text = String(Math.round(e)), O(this, fi, on).call(this, t), !1;
}, qv = new WeakSet(), XS = function(t) {
  if (!t.reg)
    throw "regは必須です";
  const { flags: e } = t, r = e ? new RegExp(t.reg, e) : new RegExp(t.reg);
  return t.text = String((t.text ?? "").search(r)), O(this, fi, on).call(this, t), !1;
}, Zv = new WeakSet(), WS = function(t) {
  const e = tt(t, "pos", 0);
  return t.text = t.len !== "all" ? (t.text ?? "").slice(e, e + $t(tt(t, "len", 1))) : (t.text ?? "").slice(e), O(this, fi, on).call(this, t), !1;
}, Hu = new WeakSet(), Np = function() {
  const t = P(this, Yr, c(this, rr).sys = c(this, We).sys = {});
  typeof process < "u" || (this.setVal_Nochk("sys", "const.sn.window.x", 0), this.setVal_Nochk("sys", "const.sn.window.y", 0)), this.setVal_Nochk("sys", "sn.tagCh.doWait", !0), this.setVal_Nochk("sys", "sn.tagCh.doWait_Kidoku", !0), this.setVal_Nochk("sys", "sn.tagCh.msecWait", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk("sys", "sn.tagCh.msecWait_Kidoku", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk("sys", "sn.tagCh.canskip", !0), this.setVal_Nochk("sys", "sn.skip.mode", "s"), this.setVal_Nochk("sys", "sn.auto.msecPageWait", tt(t, "sn.auto.msecPageWait", this.cfg.oCfg.init.auto_msecpagewait ?? 3500)), this.setVal_Nochk("sys", "sn.auto.msecPageWait_Kidoku", tt(t, "sn.auto.msecPageWait", this.cfg.oCfg.init.auto_msecpagewait ?? 3500)), this.setVal_Nochk("sys", "sn.auto.msecLineWait", 500), this.setVal_Nochk("sys", "sn.auto.msecLineWait_Kidoku", 500), this.setVal_Nochk("sys", "const.sn.sound.BGM.volume", 1), this.setVal_Nochk("sys", "const.sn.sound.SE.volume", 1), this.setVal_Nochk("sys", "const.sn.sound.SYS.volume", 1);
  for (const [r, n] of Object.entries(c(this, We).kidoku))
    n.hAreas = {}, c(this, un)[r].clear();
  return this.setVal_Nochk("sys", "TextLayer.Back.Alpha", 0.5), c(this, rr).mark = c(this, We).mark = {}, this.setVal_Nochk("sys", "const.sn.save.place", 1), this.flush(), !1;
}, Nc = new WeakSet(), Yy = function() {
  const t = c(this, ci)["const.sn.mesLayer"] ?? "", e = c(this, ci)["sn.doRecLog"] ?? !1, r = c(this, ci)["const.sn.sLog"] ?? "[]";
  return P(this, ci, c(this, rr).save = {}), this.setVal_Nochk("save", "const.sn.mesLayer", t), this.setVal_Nochk("save", "sn.doRecLog", e), this.setVal_Nochk("save", "const.sn.sLog", r), !1;
}, Ac = new WeakMap(), Va = new WeakMap(), Lc = new WeakSet(), qy = function(t) {
  const e = t;
  if (e === "true")
    return !0;
  if (e === "false")
    return !1;
  if (e === "null")
    return null;
  if (e !== "undefined")
    return c(this, Kv).test(e) ? parseFloat(e) : t;
}, Kv = new WeakMap(), Jv = new WeakMap(), $u = new WeakMap(), Bc = new WeakMap(), Vu = new WeakSet(), Ap = function(t) {
  vt(c(this, Yr), t, !0);
}, Qv = new WeakSet(), YS = function(t) {
  tt(c(this, Yr), t, 10), c(this, Yr)["sn.tagCh.doWait"];
}, tg = new WeakSet(), qS = function(t) {
  tt(
    c(this, Yr),
    t,
    this.cfg.oCfg.init.tagch_msecwait === void 0 ? 10 : this.cfg.oCfg.init.tagch_msecwait
  ), c(this, Yr)["sn.tagCh.doWait_Kidoku"];
}, Fc = new WeakSet(), Zy = function(t) {
  tt(
    c(this, Yr),
    t,
    this.cfg.oCfg.init.auto_msecpagewait === void 0 ? 3500 : this.cfg.oCfg.init.auto_msecpagewait
  );
}, Gc = new WeakSet(), Ky = function(t) {
  tt(c(this, Yr), t, 500);
}, eg = new WeakSet(), ZS = function(t) {
  return vt(c(this, ci), t, !0);
}, rg = new WeakSet(), KS = function(t) {
  vt(c(this, Me), t, !0);
}, Xu = new WeakSet(), Lp = function(t) {
  vt(c(this, Me), t, !1);
}, // reload 再生成 Main に受け渡すため static
E(kp, Va, {});
var Zt = Object.freeze({
  Linear: Object.freeze({
    None: function(i) {
      return i;
    },
    In: function(i) {
      return this.None(i);
    },
    Out: function(i) {
      return this.None(i);
    },
    InOut: function(i) {
      return this.None(i);
    }
  }),
  Quadratic: Object.freeze({
    In: function(i) {
      return i * i;
    },
    Out: function(i) {
      return i * (2 - i);
    },
    InOut: function(i) {
      return (i *= 2) < 1 ? 0.5 * i * i : -0.5 * (--i * (i - 2) - 1);
    }
  }),
  Cubic: Object.freeze({
    In: function(i) {
      return i * i * i;
    },
    Out: function(i) {
      return --i * i * i + 1;
    },
    InOut: function(i) {
      return (i *= 2) < 1 ? 0.5 * i * i * i : 0.5 * ((i -= 2) * i * i + 2);
    }
  }),
  Quartic: Object.freeze({
    In: function(i) {
      return i * i * i * i;
    },
    Out: function(i) {
      return 1 - --i * i * i * i;
    },
    InOut: function(i) {
      return (i *= 2) < 1 ? 0.5 * i * i * i * i : -0.5 * ((i -= 2) * i * i * i - 2);
    }
  }),
  Quintic: Object.freeze({
    In: function(i) {
      return i * i * i * i * i;
    },
    Out: function(i) {
      return --i * i * i * i * i + 1;
    },
    InOut: function(i) {
      return (i *= 2) < 1 ? 0.5 * i * i * i * i * i : 0.5 * ((i -= 2) * i * i * i * i + 2);
    }
  }),
  Sinusoidal: Object.freeze({
    In: function(i) {
      return 1 - Math.sin((1 - i) * Math.PI / 2);
    },
    Out: function(i) {
      return Math.sin(i * Math.PI / 2);
    },
    InOut: function(i) {
      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - i)));
    }
  }),
  Exponential: Object.freeze({
    In: function(i) {
      return i === 0 ? 0 : Math.pow(1024, i - 1);
    },
    Out: function(i) {
      return i === 1 ? 1 : 1 - Math.pow(2, -10 * i);
    },
    InOut: function(i) {
      return i === 0 ? 0 : i === 1 ? 1 : (i *= 2) < 1 ? 0.5 * Math.pow(1024, i - 1) : 0.5 * (-Math.pow(2, -10 * (i - 1)) + 2);
    }
  }),
  Circular: Object.freeze({
    In: function(i) {
      return 1 - Math.sqrt(1 - i * i);
    },
    Out: function(i) {
      return Math.sqrt(1 - --i * i);
    },
    InOut: function(i) {
      return (i *= 2) < 1 ? -0.5 * (Math.sqrt(1 - i * i) - 1) : 0.5 * (Math.sqrt(1 - (i -= 2) * i) + 1);
    }
  }),
  Elastic: Object.freeze({
    In: function(i) {
      return i === 0 ? 0 : i === 1 ? 1 : -Math.pow(2, 10 * (i - 1)) * Math.sin((i - 1.1) * 5 * Math.PI);
    },
    Out: function(i) {
      return i === 0 ? 0 : i === 1 ? 1 : Math.pow(2, -10 * i) * Math.sin((i - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(i) {
      return i === 0 ? 0 : i === 1 ? 1 : (i *= 2, i < 1 ? -0.5 * Math.pow(2, 10 * (i - 1)) * Math.sin((i - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (i - 1)) * Math.sin((i - 1.1) * 5 * Math.PI) + 1);
    }
  }),
  Back: Object.freeze({
    In: function(i) {
      var t = 1.70158;
      return i === 1 ? 1 : i * i * ((t + 1) * i - t);
    },
    Out: function(i) {
      var t = 1.70158;
      return i === 0 ? 0 : --i * i * ((t + 1) * i + t) + 1;
    },
    InOut: function(i) {
      var t = 2.5949095;
      return (i *= 2) < 1 ? 0.5 * (i * i * ((t + 1) * i - t)) : 0.5 * ((i -= 2) * i * ((t + 1) * i + t) + 2);
    }
  }),
  Bounce: Object.freeze({
    In: function(i) {
      return 1 - Zt.Bounce.Out(1 - i);
    },
    Out: function(i) {
      return i < 1 / 2.75 ? 7.5625 * i * i : i < 2 / 2.75 ? 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375;
    },
    InOut: function(i) {
      return i < 0.5 ? Zt.Bounce.In(i * 2) * 0.5 : Zt.Bounce.Out(i * 2 - 1) * 0.5 + 0.5;
    }
  }),
  generatePow: function(i) {
    return i === void 0 && (i = 4), i = i < Number.EPSILON ? Number.EPSILON : i, i = i > 1e4 ? 1e4 : i, {
      In: function(t) {
        return Math.pow(t, i);
      },
      Out: function(t) {
        return 1 - Math.pow(1 - t, i);
      },
      InOut: function(t) {
        return t < 0.5 ? Math.pow(t * 2, i) / 2 : (1 - Math.pow(2 - t * 2, i)) / 2 + 0.5;
      }
    };
  }
}), Ph = function() {
  return performance.now();
}, vA = (
  /** @class */
  function() {
    function i() {
      this._tweens = {}, this._tweensAddedDuringUpdate = {};
    }
    return i.prototype.getAll = function() {
      var t = this;
      return Object.keys(this._tweens).map(function(e) {
        return t._tweens[e];
      });
    }, i.prototype.removeAll = function() {
      this._tweens = {};
    }, i.prototype.add = function(t) {
      this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t;
    }, i.prototype.remove = function(t) {
      delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()];
    }, i.prototype.update = function(t, e) {
      t === void 0 && (t = Ph()), e === void 0 && (e = !1);
      var r = Object.keys(this._tweens);
      if (r.length === 0)
        return !1;
      for (; r.length > 0; ) {
        this._tweensAddedDuringUpdate = {};
        for (var n = 0; n < r.length; n++) {
          var s = this._tweens[r[n]], a = !e;
          s && s.update(t, a) === !1 && !e && delete this._tweens[r[n]];
        }
        r = Object.keys(this._tweensAddedDuringUpdate);
      }
      return !0;
    }, i;
  }()
), Ou = {
  Linear: function(i, t) {
    var e = i.length - 1, r = e * t, n = Math.floor(r), s = Ou.Utils.Linear;
    return t < 0 ? s(i[0], i[1], r) : t > 1 ? s(i[e], i[e - 1], e - r) : s(i[n], i[n + 1 > e ? e : n + 1], r - n);
  },
  Bezier: function(i, t) {
    for (var e = 0, r = i.length - 1, n = Math.pow, s = Ou.Utils.Bernstein, a = 0; a <= r; a++)
      e += n(1 - t, r - a) * n(t, a) * i[a] * s(r, a);
    return e;
  },
  CatmullRom: function(i, t) {
    var e = i.length - 1, r = e * t, n = Math.floor(r), s = Ou.Utils.CatmullRom;
    return i[0] === i[e] ? (t < 0 && (n = Math.floor(r = e * (1 + t))), s(i[(n - 1 + e) % e], i[n], i[(n + 1) % e], i[(n + 2) % e], r - n)) : t < 0 ? i[0] - (s(i[0], i[0], i[1], i[1], -r) - i[0]) : t > 1 ? i[e] - (s(i[e], i[e], i[e - 1], i[e - 1], r - e) - i[e]) : s(i[n ? n - 1 : 0], i[n], i[e < n + 1 ? e : n + 1], i[e < n + 2 ? e : n + 2], r - n);
  },
  Utils: {
    Linear: function(i, t, e) {
      return (t - i) * e + i;
    },
    Bernstein: function(i, t) {
      var e = Ou.Utils.Factorial;
      return e(i) / e(t) / e(i - t);
    },
    Factorial: function() {
      var i = [1];
      return function(t) {
        var e = 1;
        if (i[t])
          return i[t];
        for (var r = t; r > 1; r--)
          e *= r;
        return i[t] = e, e;
      };
    }(),
    CatmullRom: function(i, t, e, r, n) {
      var s = (e - i) * 0.5, a = (r - t) * 0.5, o = n * n, u = n * o;
      return (2 * t - 2 * e + s + a) * u + (-3 * t + 3 * e - 2 * s - a) * o + s * n + t;
    }
  }
}, gA = (
  /** @class */
  function() {
    function i() {
    }
    return i.nextId = function() {
      return i._nextId++;
    }, i._nextId = 0, i;
  }()
), Jy = new vA(), Tn = (
  /** @class */
  function() {
    function i(t, e) {
      e === void 0 && (e = Jy), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = !1, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = Zt.Linear.None, this._interpolationFunction = Ou.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = gA.nextId(), this._isChainStopped = !1, this._propertiesAreSetUp = !1, this._goToEnd = !1;
    }
    return i.prototype.getId = function() {
      return this._id;
    }, i.prototype.isPlaying = function() {
      return this._isPlaying;
    }, i.prototype.isPaused = function() {
      return this._isPaused;
    }, i.prototype.to = function(t, e) {
      if (e === void 0 && (e = 1e3), this._isPlaying)
        throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
      return this._valuesEnd = t, this._propertiesAreSetUp = !1, this._duration = e, this;
    }, i.prototype.duration = function(t) {
      return t === void 0 && (t = 1e3), this._duration = t, this;
    }, i.prototype.dynamic = function(t) {
      return t === void 0 && (t = !1), this._isDynamic = t, this;
    }, i.prototype.start = function(t, e) {
      if (t === void 0 && (t = Ph()), e === void 0 && (e = !1), this._isPlaying)
        return this;
      if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {
        this._reversed = !1;
        for (var r in this._valuesStartRepeat)
          this._swapEndStartRepeatValues(r), this._valuesStart[r] = this._valuesStartRepeat[r];
      }
      if (this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t, this._startTime += this._delayTime, !this._propertiesAreSetUp || e) {
        if (this._propertiesAreSetUp = !0, !this._isDynamic) {
          var n = {};
          for (var s in this._valuesEnd)
            n[s] = this._valuesEnd[s];
          this._valuesEnd = n;
        }
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, e);
      }
      return this;
    }, i.prototype.startFromCurrentValues = function(t) {
      return this.start(t, !0);
    }, i.prototype._setupProperties = function(t, e, r, n, s) {
      for (var a in r) {
        var o = t[a], u = Array.isArray(o), l = u ? "array" : typeof o, h = !u && Array.isArray(r[a]);
        if (!(l === "undefined" || l === "function")) {
          if (h) {
            var d = r[a];
            if (d.length === 0)
              continue;
            for (var f = [o], p = 0, v = d.length; p < v; p += 1) {
              var g = this._handleRelativeValue(o, d[p]);
              if (isNaN(g)) {
                h = !1, console.warn("Found invalid interpolation list. Skipping.");
                break;
              }
              f.push(g);
            }
            h && (r[a] = f);
          }
          if ((l === "object" || u) && o && !h) {
            e[a] = u ? [] : {};
            var m = o;
            for (var y in m)
              e[a][y] = m[y];
            n[a] = u ? [] : {};
            var d = r[a];
            if (!this._isDynamic) {
              var _ = {};
              for (var y in d)
                _[y] = d[y];
              r[a] = d = _;
            }
            this._setupProperties(m, e[a], d, n[a], s);
          } else
            (typeof e[a] > "u" || s) && (e[a] = o), u || (e[a] *= 1), h ? n[a] = r[a].slice().reverse() : n[a] = e[a] || 0;
        }
      }
    }, i.prototype.stop = function() {
      return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
    }, i.prototype.end = function() {
      return this._goToEnd = !0, this.update(1 / 0), this;
    }, i.prototype.pause = function(t) {
      return t === void 0 && (t = Ph()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this), this);
    }, i.prototype.resume = function(t) {
      return t === void 0 && (t = Ph()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);
    }, i.prototype.stopChainedTweens = function() {
      for (var t = 0, e = this._chainedTweens.length; t < e; t++)
        this._chainedTweens[t].stop();
      return this;
    }, i.prototype.group = function(t) {
      return t === void 0 && (t = Jy), this._group = t, this;
    }, i.prototype.delay = function(t) {
      return t === void 0 && (t = 0), this._delayTime = t, this;
    }, i.prototype.repeat = function(t) {
      return t === void 0 && (t = 0), this._initialRepeat = t, this._repeat = t, this;
    }, i.prototype.repeatDelay = function(t) {
      return this._repeatDelayTime = t, this;
    }, i.prototype.yoyo = function(t) {
      return t === void 0 && (t = !1), this._yoyo = t, this;
    }, i.prototype.easing = function(t) {
      return t === void 0 && (t = Zt.Linear.None), this._easingFunction = t, this;
    }, i.prototype.interpolation = function(t) {
      return t === void 0 && (t = Ou.Linear), this._interpolationFunction = t, this;
    }, i.prototype.chain = function() {
      for (var t = [], e = 0; e < arguments.length; e++)
        t[e] = arguments[e];
      return this._chainedTweens = t, this;
    }, i.prototype.onStart = function(t) {
      return this._onStartCallback = t, this;
    }, i.prototype.onEveryStart = function(t) {
      return this._onEveryStartCallback = t, this;
    }, i.prototype.onUpdate = function(t) {
      return this._onUpdateCallback = t, this;
    }, i.prototype.onRepeat = function(t) {
      return this._onRepeatCallback = t, this;
    }, i.prototype.onComplete = function(t) {
      return this._onCompleteCallback = t, this;
    }, i.prototype.onStop = function(t) {
      return this._onStopCallback = t, this;
    }, i.prototype.update = function(t, e) {
      if (t === void 0 && (t = Ph()), e === void 0 && (e = !0), this._isPaused)
        return !0;
      var r, n, s = this._startTime + this._duration;
      if (!this._goToEnd && !this._isPlaying) {
        if (t > s)
          return !1;
        e && this.start(t, !0);
      }
      if (this._goToEnd = !1, t < this._startTime)
        return !0;
      this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), this._onEveryStartCallbackFired === !1 && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0), n = (t - this._startTime) / this._duration, n = this._duration === 0 || n > 1 ? 1 : n;
      var a = this._easingFunction(n);
      if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, a), this._onUpdateCallback && this._onUpdateCallback(this._object, n), n === 1)
        if (this._repeat > 0) {
          isFinite(this._repeat) && this._repeat--;
          for (r in this._valuesStartRepeat)
            !this._yoyo && typeof this._valuesEnd[r] == "string" && (this._valuesStartRepeat[r] = // eslint-disable-next-line
            // @ts-ignore FIXME?
            this._valuesStartRepeat[r] + parseFloat(this._valuesEnd[r])), this._yoyo && this._swapEndStartRepeatValues(r), this._valuesStart[r] = this._valuesStartRepeat[r];
          return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0;
        } else {
          this._onCompleteCallback && this._onCompleteCallback(this._object);
          for (var o = 0, u = this._chainedTweens.length; o < u; o++)
            this._chainedTweens[o].start(this._startTime + this._duration, !1);
          return this._isPlaying = !1, !1;
        }
      return !0;
    }, i.prototype._updateProperties = function(t, e, r, n) {
      for (var s in r)
        if (e[s] !== void 0) {
          var a = e[s] || 0, o = r[s], u = Array.isArray(t[s]), l = Array.isArray(o), h = !u && l;
          h ? t[s] = this._interpolationFunction(o, n) : typeof o == "object" && o ? this._updateProperties(t[s], a, o, n) : (o = this._handleRelativeValue(a, o), typeof o == "number" && (t[s] = a + (o - a) * n));
        }
    }, i.prototype._handleRelativeValue = function(t, e) {
      return typeof e != "string" ? e : e.charAt(0) === "+" || e.charAt(0) === "-" ? t + parseFloat(e) : parseFloat(e);
    }, i.prototype._swapEndStartRepeatValues = function(t) {
      var e = this._valuesStartRepeat[t], r = this._valuesEnd[t];
      typeof r == "string" ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(r) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = e;
    }, i;
  }()
), kn = Jy;
kn.getAll.bind(kn);
var mA = kn.removeAll.bind(kn);
kn.add.bind(kn);
var yA = kn.remove.bind(kn), _A = kn.update.bind(kn), Uc;
const ig = class {
  static ease(t) {
    if (!t)
      return (e) => Zt.Linear.None(e);
    if (!(t in c(ig, Uc)))
      throw "異常なease指定です";
    return c(ig, Uc)[t];
  }
};
let ws = ig;
Uc = new WeakMap(), E(ws, Uc, {
  "Back.In": (t) => Zt.Back.In(t),
  "Back.InOut": (t) => Zt.Back.InOut(t),
  "Back.Out": (t) => Zt.Back.Out(t),
  "Bounce.In": (t) => Zt.Bounce.In(t),
  "Bounce.InOut": (t) => Zt.Bounce.InOut(t),
  "Bounce.Out": (t) => Zt.Bounce.Out(t),
  "Circular.In": (t) => Zt.Circular.In(t),
  "Circular.InOut": (t) => Zt.Circular.InOut(t),
  "Circular.Out": (t) => Zt.Circular.Out(t),
  "Cubic.In": (t) => Zt.Cubic.In(t),
  "Cubic.InOut": (t) => Zt.Cubic.InOut(t),
  "Cubic.Out": (t) => Zt.Cubic.Out(t),
  "Elastic.In": (t) => Zt.Elastic.In(t),
  "Elastic.InOut": (t) => Zt.Elastic.InOut(t),
  "Elastic.Out": (t) => Zt.Elastic.Out(t),
  "Exponential.In": (t) => Zt.Exponential.In(t),
  "Exponential.InOut": (t) => Zt.Exponential.InOut(t),
  "Exponential.Out": (t) => Zt.Exponential.Out(t),
  "Linear.None": (t) => Zt.Linear.None(t),
  "Quadratic.In": (t) => Zt.Quadratic.In(t),
  "Quadratic.InOut": (t) => Zt.Quadratic.InOut(t),
  "Quadratic.Out": (t) => Zt.Quadratic.Out(t),
  "Quartic.In": (t) => Zt.Quartic.In(t),
  "Quartic.InOut": (t) => Zt.Quartic.InOut(t),
  "Quartic.Out": (t) => Zt.Quartic.Out(t),
  "Quintic.In": (t) => Zt.Quintic.In(t),
  "Quintic.InOut": (t) => Zt.Quintic.InOut(t),
  "Quintic.Out": (t) => Zt.Quintic.Out(t),
  "Sinusoidal.In": (t) => Zt.Sinusoidal.In(t),
  "Sinusoidal.InOut": (t) => Zt.Sinusoidal.InOut(t),
  "Sinusoidal.Out": (t) => Zt.Sinusoidal.Out(t)
});
/*!
 * @pixi/sound - v4.3.3
 * https://github.com/pixijs/pixi-sound
 * Compiled Fri, 10 Mar 2023 17:19:30 UTC
 *
 * @pixi/sound is licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license
 */
var JS;
function Ae() {
  return JS;
}
var QS = function(i, t) {
  return (QS = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
  })(i, t);
};
function ei(i, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function e() {
    this.constructor = i;
  }
  QS(i, t), i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Qo = function() {
  return (Qo = Object.assign || function(i) {
    for (var t, e = 1, r = arguments.length; e < r; e++)
      for (var n in t = arguments[e])
        Object.prototype.hasOwnProperty.call(t, n) && (i[n] = t[n]);
    return i;
  }).apply(this, arguments);
}, nx = ["mp3", "ogg", "oga", "opus", "mpeg", "wav", "m4a", "aiff", "wma", "mid", "caf"], a0 = {};
function tT(i) {
  var t = Qo({ m4a: "audio/mp4", oga: "audio/ogg", opus: 'audio/ogg; codecs="opus"', caf: 'audio/x-caf; codecs="opus"' }, i || {}), e = document.createElement("audio"), r = {}, n = /^no$/;
  nx.forEach(function(s) {
    var a = e.canPlayType("audio/".concat(s)).replace(n, ""), o = t[s] ? e.canPlayType(t[s]).replace(n, "") : "";
    r[s] = !!a || !!o;
  }), Object.assign(a0, r);
}
tT();
var bA = /\.(\{([^\}]+)\})(\?.*)?$/;
function sx(i) {
  var t = bA, e = typeof i == "string" ? i : i.url;
  if (!t.test(e))
    return e;
  for (var r = t.exec(e), n = r[2].split(","), s = n[n.length - 1], a = 0, o = n.length; a < o; a++) {
    var u = n[a];
    if (a0[u]) {
      s = u;
      break;
    }
  }
  var l = e.replace(r[1], s);
  if (typeof i != "string") {
    var h = i;
    h.extension = s, h.url = l;
  }
  return l;
}
var ey = nx.filter(function(i) {
  return a0[i];
}), Qy = function() {
  function i() {
  }
  return i.add = function() {
    i.setLegacy(Ae().useLegacy);
  }, i.setLegacy = function(t) {
    t ? ey.forEach(function(e) {
      Ft.setExtensionXhrType(e, Ft.XHR_RESPONSE_TYPE.DEFAULT), Ft.setExtensionLoadType(e, Ft.LOAD_TYPE.AUDIO);
    }) : ey.forEach(function(e) {
      Ft.setExtensionXhrType(e, Ft.XHR_RESPONSE_TYPE.BUFFER), Ft.setExtensionLoadType(e, Ft.LOAD_TYPE.XHR);
    });
  }, i.pre = function(t, e) {
    sx(t), e();
  }, i.use = function(t, e) {
    t.data && ey.indexOf(t.extension) > -1 ? t.sound = Ae().add(t.name, { loaded: e, preload: !0, url: t.url, source: t.data }) : e();
  }, i.extension = "loader", i;
}(), xA = 0, wA = function(i) {
  function t(e) {
    var r = i.call(this) || this;
    return r.id = xA++, r.init(e), r;
  }
  return ei(t, i), t.prototype.set = function(e, r) {
    if (this[e] === void 0)
      throw new Error("Property with name ".concat(e, " does not exist."));
    switch (e) {
      case "speed":
        this.speed = r;
        break;
      case "volume":
        this.volume = r;
        break;
      case "paused":
        this.paused = r;
        break;
      case "loop":
        this.loop = r;
        break;
      case "muted":
        this.muted = r;
    }
    return this;
  }, Object.defineProperty(t.prototype, "progress", { get: function() {
    return this._source.currentTime / this._duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    this._paused = e, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), t.prototype._onPlay = function() {
    this._playing = !0;
  }, t.prototype._onPause = function() {
    this._playing = !1;
  }, t.prototype.init = function(e) {
    this._playing = !1, this._duration = e.source.duration;
    var r = this._source = e.source.cloneNode(!1);
    r.src = e.parent.url, r.onplay = this._onPlay.bind(this), r.onpause = this._onPause.bind(this), e.context.on("refresh", this.refresh, this), e.context.on("refreshPaused", this.refreshPaused, this), this._media = e;
  }, t.prototype._internalStop = function() {
    this._source && this._playing && (this._source.onended = null, this._source.pause());
  }, t.prototype.stop = function() {
    this._internalStop(), this._source && this.emit("stop");
  }, Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(e) {
    this._speed = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(e) {
    this._volume = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(e) {
    this._loop = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(e) {
    this._muted = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    var e = this._media.context, r = this._media.parent;
    this._source.loop = this._loop || r.loop;
    var n = e.volume * (e.muted ? 0 : 1), s = r.volume * (r.muted ? 0 : 1), a = this._volume * (this._muted ? 0 : 1);
    this._source.volume = a * n * s, this._source.playbackRate = this._speed * e.speed * r.speed;
  }, t.prototype.refreshPaused = function() {
    var e = this._media.context, r = this._media.parent, n = this._paused || r.paused || e.paused;
    n !== this._pausedReal && (this._pausedReal = n, n ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop })), this.emit("pause", n));
  }, t.prototype.play = function(e) {
    var r = this, n = e.start, s = e.end, a = e.speed, o = e.loop, u = e.volume, l = e.muted;
    this._speed = a, this._volume = u, this._loop = !!o, this._muted = l, this.refresh(), this.loop && s !== null && (this.loop = !1), this._start = n, this._end = s || this._duration, this._start = Math.max(0, this._start - t.PADDING), this._end = Math.min(this._end + t.PADDING, this._duration), this._source.onloadedmetadata = function() {
      r._source && (r._source.currentTime = n, r._source.onloadedmetadata = null, r.emit("progress", n, r._duration), Ge.shared.add(r._onUpdate, r));
    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit("start");
  }, t.prototype._onUpdate = function() {
    this.emit("progress", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();
  }, t.prototype._onComplete = function() {
    Ge.shared.remove(this._onUpdate, this), this._internalStop(), this.emit("progress", 1, this._duration), this.emit("end", this);
  }, t.prototype.destroy = function() {
    Ge.shared.remove(this._onUpdate, this), this.removeAllListeners();
    var e = this._source;
    e && (e.onended = null, e.onplay = null, e.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = !1, this._end = null, this._start = 0, this._duration = 0, this._playing = !1, this._pausedReal = !1, this._paused = !1, this._muted = !1, this._media && (this._media.context.off("refresh", this.refresh, this), this._media.context.off("refreshPaused", this.refreshPaused, this), this._media = null);
  }, t.prototype.toString = function() {
    return "[HTMLAudioInstance id=".concat(this.id, "]");
  }, t.PADDING = 0.1, t;
}(Pi), EA = function(i) {
  function t() {
    return i !== null && i.apply(this, arguments) || this;
  }
  return ei(t, i), t.prototype.init = function(e) {
    this.parent = e, this._source = e.options.source || new Audio(), e.url && (this._source.src = e.url);
  }, t.prototype.create = function() {
    return new wA(this);
  }, Object.defineProperty(t.prototype, "isPlayable", { get: function() {
    return !!this._source && this._source.readyState === 4;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "duration", { get: function() {
    return this._source.duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = "", this._source.load(), this._source = null);
  }, Object.defineProperty(t.prototype, "source", { get: function() {
    return this._source;
  }, enumerable: !1, configurable: !0 }), t.prototype.load = function(e) {
    var r = this._source, n = this.parent;
    if (r.readyState !== 4)
      if (n.url) {
        r.src = n.url;
        var s = function() {
          u(), n.isLoaded = !0;
          var h = n.autoPlayStart();
          e && e(null, n, h);
        }, a = function() {
          u(), e && e(new Error("Sound loading has been aborted"));
        }, o = function() {
          u();
          var h = "Failed to load audio element (code: ".concat(r.error.code, ")");
          e && e(new Error(h));
        }, u = function() {
          r.removeEventListener("canplaythrough", s), r.removeEventListener("load", s), r.removeEventListener("abort", a), r.removeEventListener("error", o);
        };
        r.addEventListener("canplaythrough", s, !1), r.addEventListener("load", s, !1), r.addEventListener("abort", a, !1), r.addEventListener("error", o, !1), r.load();
      } else
        e(new Error("sound.url or sound.source must be set"));
    else {
      n.isLoaded = !0;
      var l = n.autoPlayStart();
      e && setTimeout(function() {
        e(null, n, l);
      }, 0);
    }
  }, t;
}(Pi), SA = function() {
  function i(t, e) {
    this.parent = t, Object.assign(this, e), this.duration = this.end - this.start;
  }
  return i.prototype.play = function(t) {
    return this.parent.play({ complete: t, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop });
  }, i.prototype.destroy = function() {
    this.parent = null;
  }, i;
}(), hi = function() {
  function i() {
  }
  return i.setParamValue = function(t, e) {
    if (t.setValueAtTime) {
      var r = Ae().context;
      t.setValueAtTime(e, r.audioContext.currentTime);
    } else
      t.value = e;
    return e;
  }, i;
}(), TA = 0, CA = function(i) {
  function t(e) {
    var r = i.call(this) || this;
    return r.id = TA++, r._media = null, r._paused = !1, r._muted = !1, r._elapsed = 0, r.init(e), r;
  }
  return ei(t, i), t.prototype.set = function(e, r) {
    if (this[e] === void 0)
      throw new Error("Property with name ".concat(e, " does not exist."));
    switch (e) {
      case "speed":
        this.speed = r;
        break;
      case "volume":
        this.volume = r;
        break;
      case "muted":
        this.muted = r;
        break;
      case "loop":
        this.loop = r;
        break;
      case "paused":
        this.paused = r;
    }
    return this;
  }, t.prototype.stop = function() {
    this._source && (this._internalStop(), this.emit("stop"));
  }, Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(e) {
    this._speed = e, this.refresh(), this._update(!0);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(e) {
    this._volume = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(e) {
    this._muted = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(e) {
    this._loop = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(e) {
    var r;
    this._filters && ((r = this._filters) === null || r === void 0 || r.filter(function(n) {
      return n;
    }).forEach(function(n) {
      return n.disconnect();
    }), this._filters = null, this._source.connect(this._gain)), this._filters = e != null && e.length ? e.slice(0) : null, this.refresh();
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    if (this._source) {
      var e = this._media.context, r = this._media.parent;
      this._source.loop = this._loop || r.loop;
      var n = e.volume * (e.muted ? 0 : 1), s = r.volume * (r.muted ? 0 : 1), a = this._volume * (this._muted ? 0 : 1);
      hi.setParamValue(this._gain.gain, a * s * n), hi.setParamValue(this._source.playbackRate, this._speed * r.speed * e.speed), this.applyFilters();
    }
  }, t.prototype.applyFilters = function() {
    var e;
    if (!((e = this._filters) === null || e === void 0) && e.length) {
      this._source.disconnect();
      var r = this._source;
      this._filters.forEach(function(n) {
        r.connect(n.destination), r = n;
      }), r.connect(this._gain);
    }
  }, t.prototype.refreshPaused = function() {
    var e = this._media.context, r = this._media.parent, n = this._paused || r.paused || e.paused;
    n !== this._pausedReal && (this._pausedReal = n, n ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume })), this.emit("pause", n));
  }, t.prototype.play = function(e) {
    var r = e.start, n = e.end, s = e.speed, a = e.loop, o = e.volume, u = e.muted, l = e.filters;
    this._paused = !1;
    var h = this._media.nodes.cloneBufferSource(), d = h.source, f = h.gain;
    this._source = d, this._gain = f, this._speed = s, this._volume = o, this._loop = !!a, this._muted = u, this._filters = l, this.refresh();
    var p = this._source.buffer.duration;
    this._duration = p, this._end = n, this._lastUpdate = this._now(), this._elapsed = r, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = n, this._source.loopStart = r, this._source.start(0, r)) : n ? this._source.start(0, r, n - r) : this._source.start(0, r), this.emit("start"), this._update(!0), this.enableTicker(!0);
  }, t.prototype.enableTicker = function(e) {
    Ge.shared.remove(this._updateListener, this), e && Ge.shared.add(this._updateListener, this);
  }, Object.defineProperty(t.prototype, "progress", { get: function() {
    return this._progress;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    this._paused = e, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    var e;
    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off("refresh", this.refresh, this), this._media.context.events.off("refreshPaused", this.refreshPaused, this), this._media = null), (e = this._filters) === null || e === void 0 || e.forEach(function(r) {
      return r.disconnect();
    }), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = !1, this._elapsed = 0, this._duration = 0, this._paused = !1, this._muted = !1, this._pausedReal = !1;
  }, t.prototype.toString = function() {
    return "[WebAudioInstance id=".concat(this.id, "]");
  }, t.prototype._now = function() {
    return this._media.context.audioContext.currentTime;
  }, t.prototype._updateListener = function() {
    this._update();
  }, t.prototype._update = function(e) {
    if (e === void 0 && (e = !1), this._source) {
      var r = this._now(), n = r - this._lastUpdate;
      if (n > 0 || e) {
        var s = this._source.playbackRate.value;
        this._elapsed += n * s, this._lastUpdate = r;
        var a = this._duration, o = void 0;
        if (this._source.loopStart) {
          var u = this._source.loopEnd - this._source.loopStart;
          o = (this._source.loopStart + this._elapsed % u) / a;
        } else
          o = this._elapsed % a / a;
        this._progress = o, this.emit("progress", this._progress, a);
      }
    }
  }, t.prototype.init = function(e) {
    this._media = e, e.context.events.on("refresh", this.refresh, this), e.context.events.on("refreshPaused", this.refreshPaused, this);
  }, t.prototype._internalStop = function() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.stop(0), this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch {
      }
      this._source = null;
    }
  }, t.prototype._onComplete = function() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch {
      }
    }
    this._source = null, this._progress = 1, this.emit("progress", 1, this._duration), this.emit("end", this);
  }, t;
}(Pi), eT = function() {
  function i(t, e) {
    this._output = e, this._input = t;
  }
  return Object.defineProperty(i.prototype, "destination", { get: function() {
    return this._input;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(t) {
    var e = this;
    if (this._filters && (this._filters.forEach(function(n) {
      n && n.disconnect();
    }), this._filters = null, this._input.connect(this._output)), t && t.length) {
      this._filters = t.slice(0), this._input.disconnect();
      var r = null;
      t.forEach(function(n) {
        r === null ? e._input.connect(n.destination) : r.connect(n.destination), r = n;
      }), r.connect(this._output);
    }
  }, enumerable: !1, configurable: !0 }), i.prototype.destroy = function() {
    this.filters = null, this._input = null, this._output = null;
  }, i;
}(), MA = function(i) {
  function t(e) {
    var r = this, n = e.audioContext, s = n.createBufferSource(), a = n.createGain(), o = n.createAnalyser();
    return s.connect(o), o.connect(a), a.connect(e.destination), (r = i.call(this, o, a) || this).context = e, r.bufferSource = s, r.gain = a, r.analyser = o, r;
  }
  return ei(t, i), Object.defineProperty(t.prototype, "script", { get: function() {
    return this._script || (this._script = this.context.audioContext.createScriptProcessor(t.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    i.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;
  }, t.prototype.cloneBufferSource = function() {
    var e = this.bufferSource, r = this.context.audioContext.createBufferSource();
    r.buffer = e.buffer, hi.setParamValue(r.playbackRate, e.playbackRate.value), r.loop = e.loop;
    var n = this.context.audioContext.createGain();
    return r.connect(n), n.connect(this.destination), { source: r, gain: n };
  }, Object.defineProperty(t.prototype, "bufferSize", { get: function() {
    return this.script.bufferSize;
  }, enumerable: !1, configurable: !0 }), t.BUFFER_SIZE = 0, t;
}(eT), t_ = function() {
  function i() {
  }
  return i.prototype.init = function(t) {
    this.parent = t, this._nodes = new MA(this.context), this._source = this._nodes.bufferSource, this.source = t.options.source;
  }, i.prototype.destroy = function() {
    this.parent = null, this._nodes.destroy(), this._nodes = null;
    try {
      this._source.buffer = null;
    } catch {
    }
    this._source = null, this.source = null;
  }, i.prototype.create = function() {
    return new CA(this);
  }, Object.defineProperty(i.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, "isPlayable", { get: function() {
    return !!this._source && !!this._source.buffer;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, "filters", { get: function() {
    return this._nodes.filters;
  }, set: function(t) {
    this._nodes.filters = t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, "duration", { get: function() {
    return this._source.buffer.duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, "buffer", { get: function() {
    return this._source.buffer;
  }, set: function(t) {
    this._source.buffer = t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, "nodes", { get: function() {
    return this._nodes;
  }, enumerable: !1, configurable: !0 }), i.prototype.load = function(t) {
    this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t && t(new Error("sound.url or sound.source must be set"));
  }, i.prototype._loadUrl = function(t) {
    var e = this, r = new XMLHttpRequest(), n = this.parent.url;
    r.open("GET", n, !0), r.responseType = "arraybuffer", r.onload = function() {
      e.source = r.response, e._decode(r.response, t);
    }, r.send();
  }, i.prototype._decode = function(t, e) {
    var r = this, n = function(s, a) {
      if (s)
        e && e(s);
      else {
        r.parent.isLoaded = !0, r.buffer = a;
        var o = r.parent.autoPlayStart();
        e && e(null, r.parent, o);
      }
    };
    t instanceof AudioBuffer ? n(null, t) : this.parent.context.decode(t, n);
  }, i;
}(), Bu = function() {
  function i(t, e) {
    this.media = t, this.options = e, this._instances = [], this._sprites = {}, this.media.init(this);
    var r = e.complete;
    this._autoPlayOptions = r ? { complete: r } : null, this.isLoaded = !1, this.isPlaying = !1, this.autoPlay = e.autoPlay, this.singleInstance = e.singleInstance, this.preload = e.preload || this.autoPlay, this.url = e.url, this.speed = e.speed, this.volume = e.volume, this.loop = e.loop, e.sprites && this.addSprites(e.sprites), this.preload && this._preload(e.loaded);
  }
  return i.from = function(t) {
    var e = {};
    return typeof t == "string" ? e.url = t : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? e.source = t : e = t, (e = Qo({ autoPlay: !1, singleInstance: !1, url: null, source: null, preload: !1, volume: 1, speed: 1, complete: null, loaded: null, loop: !1 }, e)).url && (e.url = sx(e.url)), Object.freeze(e), new i(Ae().useLegacy ? new EA() : new t_(), e);
  }, Object.defineProperty(i.prototype, "context", { get: function() {
    return Ae().context;
  }, enumerable: !1, configurable: !0 }), i.prototype.pause = function() {
    return this.isPlaying = !1, this.paused = !0, this;
  }, i.prototype.resume = function() {
    return this.isPlaying = this._instances.length > 0, this.paused = !1, this;
  }, Object.defineProperty(i.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(t) {
    this._paused = t, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(t) {
    this._speed = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, "filters", { get: function() {
    return this.media.filters;
  }, set: function(t) {
    this.media.filters = t;
  }, enumerable: !1, configurable: !0 }), i.prototype.addSprites = function(t, e) {
    if (typeof t == "object") {
      var r = {};
      for (var n in t)
        r[n] = this.addSprites(n, t[n]);
      return r;
    }
    var s = new SA(this, e);
    return this._sprites[t] = s, s;
  }, i.prototype.destroy = function() {
    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;
  }, i.prototype.removeSprites = function(t) {
    if (t) {
      var e = this._sprites[t];
      e !== void 0 && (e.destroy(), delete this._sprites[t]);
    } else
      for (var r in this._sprites)
        this.removeSprites(r);
    return this;
  }, Object.defineProperty(i.prototype, "isPlayable", { get: function() {
    return this.isLoaded && this.media && this.media.isPlayable;
  }, enumerable: !1, configurable: !0 }), i.prototype.stop = function() {
    if (!this.isPlayable)
      return this.autoPlay = !1, this._autoPlayOptions = null, this;
    this.isPlaying = !1;
    for (var t = this._instances.length - 1; t >= 0; t--)
      this._instances[t].stop();
    return this;
  }, i.prototype.play = function(t, e) {
    var r, n = this;
    if (typeof t == "string" ? r = { sprite: a = t, loop: this.loop, complete: e } : typeof t == "function" ? (r = {}).complete = t : r = t, (r = Qo({ complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: !1, loop: !1 }, r || {})).sprite) {
      var s = r.sprite, a = this._sprites[s];
      r.start = a.start + (r.start || 0), r.end = a.end, r.speed = a.speed || 1, r.loop = a.loop || r.loop, delete r.sprite;
    }
    if (r.offset && (r.start = r.offset), !this.isLoaded)
      return new Promise(function(u, l) {
        n.autoPlay = !0, n._autoPlayOptions = r, n._preload(function(h, d, f) {
          h ? l(h) : (r.loaded && r.loaded(h, d, f), u(f));
        });
      });
    (this.singleInstance || r.singleInstance) && this._removeInstances();
    var o = this._createInstance();
    return this._instances.push(o), this.isPlaying = !0, o.once("end", function() {
      r.complete && r.complete(n), n._onComplete(o);
    }), o.once("stop", function() {
      n._onComplete(o);
    }), o.play(r), o;
  }, i.prototype.refresh = function() {
    for (var t = this._instances.length, e = 0; e < t; e++)
      this._instances[e].refresh();
  }, i.prototype.refreshPaused = function() {
    for (var t = this._instances.length, e = 0; e < t; e++)
      this._instances[e].refreshPaused();
  }, Object.defineProperty(i.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(t) {
    this._volume = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(t) {
    this._muted = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(t) {
    this._loop = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), i.prototype._preload = function(t) {
    this.media.load(t);
  }, Object.defineProperty(i.prototype, "instances", { get: function() {
    return this._instances;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, "sprites", { get: function() {
    return this._sprites;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, "duration", { get: function() {
    return this.media.duration;
  }, enumerable: !1, configurable: !0 }), i.prototype.autoPlayStart = function() {
    var t;
    return this.autoPlay && (t = this.play(this._autoPlayOptions)), t;
  }, i.prototype._removeInstances = function() {
    for (var t = this._instances.length - 1; t >= 0; t--)
      this._poolInstance(this._instances[t]);
    this._instances.length = 0;
  }, i.prototype._onComplete = function(t) {
    if (this._instances) {
      var e = this._instances.indexOf(t);
      e > -1 && this._instances.splice(e, 1), this.isPlaying = this._instances.length > 0;
    }
    this._poolInstance(t);
  }, i.prototype._createInstance = function() {
    if (i._pool.length > 0) {
      var t = i._pool.pop();
      return t.init(this.media), t;
    }
    return this.media.create();
  }, i.prototype._poolInstance = function(t) {
    t.destroy(), i._pool.indexOf(t) < 0 && i._pool.push(t);
  }, i._pool = [], i;
}(), PA = function(i) {
  function t() {
    var e = i !== null && i.apply(this, arguments) || this;
    return e.speed = 1, e.muted = !1, e.volume = 1, e.paused = !1, e;
  }
  return ei(t, i), t.prototype.refresh = function() {
    this.emit("refresh");
  }, t.prototype.refreshPaused = function() {
    this.emit("refreshPaused");
  }, Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "audioContext", { get: function() {
    return null;
  }, enumerable: !1, configurable: !0 }), t.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, t.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this.paused;
  }, t.prototype.destroy = function() {
    this.removeAllListeners();
  }, t;
}(Pi), aw = function(i) {
  function t() {
    var e = this, r = window, n = new t.AudioContext(), s = n.createDynamicsCompressor(), a = n.createAnalyser();
    return a.connect(s), s.connect(n.destination), (e = i.call(this, a, s) || this)._ctx = n, e._offlineCtx = new t.OfflineAudioContext(1, 2, r.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, n.sampleRate)) : 44100), e.compressor = s, e.analyser = a, e.events = new Pi(), e.volume = 1, e.speed = 1, e.muted = !1, e.paused = !1, e._locked = n.state === "suspended" && ("ontouchstart" in globalThis || "onclick" in globalThis), e._locked && (e._unlock(), e._unlock = e._unlock.bind(e), document.addEventListener("mousedown", e._unlock, !0), document.addEventListener("touchstart", e._unlock, !0), document.addEventListener("touchend", e._unlock, !0)), e.onFocus = e.onFocus.bind(e), e.onBlur = e.onBlur.bind(e), globalThis.addEventListener("focus", e.onFocus), globalThis.addEventListener("blur", e.onBlur), e;
  }
  return ei(t, i), t.prototype.onFocus = function() {
    var e = this._ctx.state;
    e !== "suspended" && e !== "interrupted" && this._locked || this._ctx.resume();
  }, t.prototype.onBlur = function() {
    this._locked || this._ctx.suspend();
  }, t.prototype._unlock = function() {
    this._locked && (this.playEmptySound(), this._ctx.state === "running" && (document.removeEventListener("mousedown", this._unlock, !0), document.removeEventListener("touchend", this._unlock, !0), document.removeEventListener("touchstart", this._unlock, !0), this._locked = !1));
  }, t.prototype.playEmptySound = function() {
    var e = this._ctx.createBufferSource();
    e.buffer = this._ctx.createBuffer(1, 1, 22050), e.connect(this._ctx.destination), e.start(0, 0, 0), e.context.state === "suspended" && e.context.resume();
  }, Object.defineProperty(t, "AudioContext", { get: function() {
    var e = window;
    return e.AudioContext || e.webkitAudioContext || null;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "OfflineAudioContext", { get: function() {
    var e = window;
    return e.OfflineAudioContext || e.webkitOfflineAudioContext || null;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    i.prototype.destroy.call(this);
    var e = this._ctx;
    e.close !== void 0 && e.close(), globalThis.removeEventListener("focus", this.onFocus), globalThis.removeEventListener("blur", this.onBlur), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;
  }, Object.defineProperty(t.prototype, "audioContext", { get: function() {
    return this._ctx;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "offlineContext", { get: function() {
    return this._offlineCtx;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    e && this._ctx.state === "running" ? this._ctx.suspend() : e || this._ctx.state !== "suspended" || this._ctx.resume(), this._paused = e;
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    this.events.emit("refresh");
  }, t.prototype.refreshPaused = function() {
    this.events.emit("refreshPaused");
  }, t.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, t.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this._paused;
  }, t.prototype.decode = function(e, r) {
    var n = function(a) {
      r(new Error((a == null ? void 0 : a.message) || "Unable to decode file"));
    }, s = this._offlineCtx.decodeAudioData(e, function(a) {
      r(null, a);
    }, n);
    s && s.catch(n);
  }, t;
}(eT), OA = function() {
  function i() {
    this.init();
  }
  return i.prototype.init = function() {
    return this.supported && (this._webAudioContext = new aw()), this._htmlAudioContext = new PA(), this._sounds = {}, this.useLegacy = !this.supported, this;
  }, Object.defineProperty(i.prototype, "context", { get: function() {
    return this._context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, "filtersAll", { get: function() {
    return this.useLegacy ? [] : this._context.filters;
  }, set: function(t) {
    this.useLegacy || (this._context.filters = t);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, "supported", { get: function() {
    return aw.AudioContext !== null;
  }, enumerable: !1, configurable: !0 }), i.prototype.add = function(t, e) {
    if (typeof t == "object") {
      var r = {};
      for (var n in t) {
        var s = this._getOptions(t[n], e);
        r[n] = this.add(n, s);
      }
      return r;
    }
    if (e instanceof Bu)
      return this._sounds[t] = e, e;
    var a = this._getOptions(e), o = Bu.from(a);
    return this._sounds[t] = o, o;
  }, i.prototype._getOptions = function(t, e) {
    var r;
    return r = typeof t == "string" ? { url: t } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? { source: t } : t, r = Qo(Qo({}, r), e || {});
  }, Object.defineProperty(i.prototype, "useLegacy", { get: function() {
    return this._useLegacy;
  }, set: function(t) {
    Qy.setLegacy(t), this._useLegacy = t, this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext;
  }, enumerable: !1, configurable: !0 }), i.prototype.remove = function(t) {
    return this.exists(t, !0), this._sounds[t].destroy(), delete this._sounds[t], this;
  }, Object.defineProperty(i.prototype, "volumeAll", { get: function() {
    return this._context.volume;
  }, set: function(t) {
    this._context.volume = t, this._context.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, "speedAll", { get: function() {
    return this._context.speed;
  }, set: function(t) {
    this._context.speed = t, this._context.refresh();
  }, enumerable: !1, configurable: !0 }), i.prototype.togglePauseAll = function() {
    return this._context.togglePause();
  }, i.prototype.pauseAll = function() {
    return this._context.paused = !0, this._context.refreshPaused(), this;
  }, i.prototype.resumeAll = function() {
    return this._context.paused = !1, this._context.refreshPaused(), this;
  }, i.prototype.toggleMuteAll = function() {
    return this._context.toggleMute();
  }, i.prototype.muteAll = function() {
    return this._context.muted = !0, this._context.refresh(), this;
  }, i.prototype.unmuteAll = function() {
    return this._context.muted = !1, this._context.refresh(), this;
  }, i.prototype.removeAll = function() {
    for (var t in this._sounds)
      this._sounds[t].destroy(), delete this._sounds[t];
    return this;
  }, i.prototype.stopAll = function() {
    for (var t in this._sounds)
      this._sounds[t].stop();
    return this;
  }, i.prototype.exists = function(t, e) {
    return !!this._sounds[t];
  }, i.prototype.find = function(t) {
    return this.exists(t, !0), this._sounds[t];
  }, i.prototype.play = function(t, e) {
    return this.find(t).play(e);
  }, i.prototype.stop = function(t) {
    return this.find(t).stop();
  }, i.prototype.pause = function(t) {
    return this.find(t).pause();
  }, i.prototype.resume = function(t) {
    return this.find(t).resume();
  }, i.prototype.volume = function(t, e) {
    var r = this.find(t);
    return e !== void 0 && (r.volume = e), r.volume;
  }, i.prototype.speed = function(t, e) {
    var r = this.find(t);
    return e !== void 0 && (r.speed = e), r.speed;
  }, i.prototype.duration = function(t) {
    return this.find(t).duration;
  }, i.prototype.close = function() {
    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;
  }, i;
}(), Is = function() {
  function i(t, e) {
    this.init(t, e);
  }
  return i.prototype.init = function(t, e) {
    this.destination = t, this.source = e || t;
  }, i.prototype.connect = function(t) {
    this.source.connect(t);
  }, i.prototype.disconnect = function() {
    this.source.disconnect();
  }, i.prototype.destroy = function() {
    this.disconnect(), this.destination = null, this.source = null;
  }, i;
}(), ap = { __proto__: null, Filter: Is, EqualizerFilter: function(i) {
  function t(e, r, n, s, a, o, u, l, h, d) {
    e === void 0 && (e = 0), r === void 0 && (r = 0), n === void 0 && (n = 0), s === void 0 && (s = 0), a === void 0 && (a = 0), o === void 0 && (o = 0), u === void 0 && (u = 0), l === void 0 && (l = 0), h === void 0 && (h = 0), d === void 0 && (d = 0);
    var f = this;
    if (!Ae().useLegacy) {
      var p = [{ f: t.F32, type: "lowshelf", gain: e }, { f: t.F64, type: "peaking", gain: r }, { f: t.F125, type: "peaking", gain: n }, { f: t.F250, type: "peaking", gain: s }, { f: t.F500, type: "peaking", gain: a }, { f: t.F1K, type: "peaking", gain: o }, { f: t.F2K, type: "peaking", gain: u }, { f: t.F4K, type: "peaking", gain: l }, { f: t.F8K, type: "peaking", gain: h }, { f: t.F16K, type: "highshelf", gain: d }].map(function(m) {
        var y = Ae().context.audioContext.createBiquadFilter();
        return y.type = m.type, hi.setParamValue(y.Q, 1), y.frequency.value = m.f, hi.setParamValue(y.gain, m.gain), y;
      });
      (f = i.call(this, p[0], p[p.length - 1]) || this).bands = p, f.bandsMap = {};
      for (var v = 0; v < f.bands.length; v++) {
        var g = f.bands[v];
        v > 0 && f.bands[v - 1].connect(g), f.bandsMap[g.frequency.value] = g;
      }
      return f;
    }
    f = i.call(this, null) || this;
  }
  return ei(t, i), t.prototype.setGain = function(e, r) {
    if (r === void 0 && (r = 0), !this.bandsMap[e])
      throw new Error("No band found for frequency ".concat(e));
    hi.setParamValue(this.bandsMap[e].gain, r);
  }, t.prototype.getGain = function(e) {
    if (!this.bandsMap[e])
      throw new Error("No band found for frequency ".concat(e));
    return this.bandsMap[e].gain.value;
  }, Object.defineProperty(t.prototype, "f32", { get: function() {
    return this.getGain(t.F32);
  }, set: function(e) {
    this.setGain(t.F32, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f64", { get: function() {
    return this.getGain(t.F64);
  }, set: function(e) {
    this.setGain(t.F64, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f125", { get: function() {
    return this.getGain(t.F125);
  }, set: function(e) {
    this.setGain(t.F125, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f250", { get: function() {
    return this.getGain(t.F250);
  }, set: function(e) {
    this.setGain(t.F250, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f500", { get: function() {
    return this.getGain(t.F500);
  }, set: function(e) {
    this.setGain(t.F500, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f1k", { get: function() {
    return this.getGain(t.F1K);
  }, set: function(e) {
    this.setGain(t.F1K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f2k", { get: function() {
    return this.getGain(t.F2K);
  }, set: function(e) {
    this.setGain(t.F2K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f4k", { get: function() {
    return this.getGain(t.F4K);
  }, set: function(e) {
    this.setGain(t.F4K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f8k", { get: function() {
    return this.getGain(t.F8K);
  }, set: function(e) {
    this.setGain(t.F8K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f16k", { get: function() {
    return this.getGain(t.F16K);
  }, set: function(e) {
    this.setGain(t.F16K, e);
  }, enumerable: !1, configurable: !0 }), t.prototype.reset = function() {
    this.bands.forEach(function(e) {
      hi.setParamValue(e.gain, 0);
    });
  }, t.prototype.destroy = function() {
    this.bands.forEach(function(e) {
      e.disconnect();
    }), this.bands = null, this.bandsMap = null;
  }, t.F32 = 32, t.F64 = 64, t.F125 = 125, t.F250 = 250, t.F500 = 500, t.F1K = 1e3, t.F2K = 2e3, t.F4K = 4e3, t.F8K = 8e3, t.F16K = 16e3, t;
}(Is), DistortionFilter: function(i) {
  function t(e) {
    e === void 0 && (e = 0);
    var r = this;
    if (!Ae().useLegacy) {
      var n = Ae().context.audioContext.createWaveShaper();
      return (r = i.call(this, n) || this)._distortion = n, r.amount = e, r;
    }
    r = i.call(this, null) || this;
  }
  return ei(t, i), Object.defineProperty(t.prototype, "amount", { get: function() {
    return this._amount;
  }, set: function(e) {
    this._amount = e;
    for (var r, n = 1e3 * e, s = 44100, a = new Float32Array(s), o = Math.PI / 180, u = 0; u < s; ++u)
      r = 2 * u / s - 1, a[u] = (3 + n) * r * 20 * o / (Math.PI + n * Math.abs(r));
    this._distortion.curve = a, this._distortion.oversample = "4x";
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this._distortion = null, i.prototype.destroy.call(this);
  }, t;
}(Is), StereoFilter: function(i) {
  function t(e) {
    e === void 0 && (e = 0);
    var r = this;
    if (!Ae().useLegacy) {
      var n, s, a, o = Ae().context.audioContext;
      return o.createStereoPanner ? a = n = o.createStereoPanner() : ((s = o.createPanner()).panningModel = "equalpower", a = s), (r = i.call(this, a) || this)._stereo = n, r._panner = s, r.pan = e, r;
    }
    r = i.call(this, null) || this;
  }
  return ei(t, i), Object.defineProperty(t.prototype, "pan", { get: function() {
    return this._pan;
  }, set: function(e) {
    this._pan = e, this._stereo ? hi.setParamValue(this._stereo.pan, e) : this._panner.setPosition(e, 0, 1 - Math.abs(e));
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    i.prototype.destroy.call(this), this._stereo = null, this._panner = null;
  }, t;
}(Is), ReverbFilter: function(i) {
  function t(e, r, n) {
    e === void 0 && (e = 3), r === void 0 && (r = 2), n === void 0 && (n = !1);
    var s = this;
    if (!Ae().useLegacy)
      return (s = i.call(this, null) || this)._seconds = s._clamp(e, 1, 50), s._decay = s._clamp(r, 0, 100), s._reverse = n, s._rebuild(), s;
    s = i.call(this, null) || this;
  }
  return ei(t, i), t.prototype._clamp = function(e, r, n) {
    return Math.min(n, Math.max(r, e));
  }, Object.defineProperty(t.prototype, "seconds", { get: function() {
    return this._seconds;
  }, set: function(e) {
    this._seconds = this._clamp(e, 1, 50), this._rebuild();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "decay", { get: function() {
    return this._decay;
  }, set: function(e) {
    this._decay = this._clamp(e, 0, 100), this._rebuild();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "reverse", { get: function() {
    return this._reverse;
  }, set: function(e) {
    this._reverse = e, this._rebuild();
  }, enumerable: !1, configurable: !0 }), t.prototype._rebuild = function() {
    for (var e, r = Ae().context.audioContext, n = r.sampleRate, s = n * this._seconds, a = r.createBuffer(2, s, n), o = a.getChannelData(0), u = a.getChannelData(1), l = 0; l < s; l++)
      e = this._reverse ? s - l : l, o[l] = (2 * Math.random() - 1) * Math.pow(1 - e / s, this._decay), u[l] = (2 * Math.random() - 1) * Math.pow(1 - e / s, this._decay);
    var h = Ae().context.audioContext.createConvolver();
    h.buffer = a, this.init(h);
  }, t;
}(Is), MonoFilter: function(i) {
  function t() {
    var e = this;
    if (!Ae().useLegacy) {
      var r = Ae().context.audioContext, n = r.createChannelSplitter(), s = r.createChannelMerger();
      return s.connect(n), (e = i.call(this, s, n) || this)._merger = s, e;
    }
    e = i.call(this, null) || this;
  }
  return ei(t, i), t.prototype.destroy = function() {
    this._merger.disconnect(), this._merger = null, i.prototype.destroy.call(this);
  }, t;
}(Is), StreamFilter: function(i) {
  function t() {
    var e = this;
    if (!Ae().useLegacy) {
      var r = Ae().context.audioContext, n = r.createMediaStreamDestination(), s = r.createMediaStreamSource(n.stream);
      return (e = i.call(this, n, s) || this)._stream = n.stream, e;
    }
    e = i.call(this, null) || this;
  }
  return ei(t, i), Object.defineProperty(t.prototype, "stream", { get: function() {
    return this._stream;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this._stream = null, i.prototype.destroy.call(this);
  }, t;
}(Is), TelephoneFilter: function(i) {
  function t() {
    if (!Ae().useLegacy) {
      var e = Ae().context.audioContext, r = e.createBiquadFilter(), n = e.createBiquadFilter(), s = e.createBiquadFilter(), a = e.createBiquadFilter();
      return r.type = "lowpass", hi.setParamValue(r.frequency, 2e3), n.type = "lowpass", hi.setParamValue(n.frequency, 2e3), s.type = "highpass", hi.setParamValue(s.frequency, 500), a.type = "highpass", hi.setParamValue(a.frequency, 500), r.connect(n), n.connect(s), s.connect(a), i.call(this, r, a) || this;
    }
    i.call(this, null);
  }
  return ei(t, i), t;
}(Is) }, ow = 0, IA = { __proto__: null, playOnce: function(i, t) {
  var e = "alias".concat(ow++);
  return Ae().add(e, { url: i, preload: !0, autoPlay: !0, loaded: function(r) {
    r && (Ae().remove(e), t && t(r));
  }, complete: function() {
    Ae().remove(e), t && t(null);
  } }), e;
}, get PLAY_ID() {
  return ow;
}, render: function(i, t) {
  var e = document.createElement("canvas");
  t = Qo({ width: 512, height: 128, fill: "black" }, t || {}), e.width = t.width, e.height = t.height;
  var r = Kt.from(e);
  if (!(i.media instanceof t_))
    return r;
  var n = i.media, s = e.getContext("2d");
  s.fillStyle = t.fill;
  for (var a = n.buffer.getChannelData(0), o = Math.ceil(a.length / t.width), u = t.height / 2, l = 0; l < t.width; l++) {
    for (var h = 1, d = -1, f = 0; f < o; f++) {
      var p = a[l * o + f];
      p < h && (h = p), p > d && (d = p);
    }
    s.fillRect(l, (1 + h) * u, 1, Math.max(1, (d - h) * u));
  }
  return r;
}, resolveUrl: sx, sineTone: function(i, t) {
  i === void 0 && (i = 200), t === void 0 && (t = 1);
  var e = Bu.from({ singleInstance: !0 });
  if (!(e.media instanceof t_))
    return e;
  for (var r = e.media, n = e.context.audioContext.createBuffer(1, 48e3 * t, 48e3), s = n.getChannelData(0), a = 0; a < s.length; a++) {
    var o = i * (a / n.sampleRate) * Math.PI;
    s[a] = 2 * Math.sin(o);
  }
  return r.buffer = n, e.isLoaded = !0, e;
}, validateFormats: tT, supported: a0, extensions: nx }, Vn = function(i) {
  return JS = i, i;
}(new OA());
"extensions" in G2 ? an.add(Qy) : ri.registerPlugin(Qy);
var Ie, hr, Gs, ng, rT, Wu, Fp, sg, iT, ag, nT, jc, e_, Xa, Oh, zc, r_, Yu, qu, Gp, Hc, i_, $c, Zu, Up, og, sT, ln, Ns, ug, aT, Vc, n_, Wa, Ih, lg, oT, Xc, s_, hg, uT, cg, lT, Ku, jp;
const tc = class {
  constructor(t, e, r, n, s) {
    // 音量設定（独自拡張）
    E(this, ng);
    E(this, Wu);
    // BGM/効果音のフェードアウト（loadから使うのでマクロ化禁止）
    E(this, sg);
    // 効果音のフェードアウト（loadから使うのでマクロ化禁止）
    E(this, ag);
    // BGMのフェード（loadから使うのでマクロ化禁止）
    E(this, jc);
    // 効果音のフェード
    E(this, Xa);
    // BGM の演奏
    E(this, zc);
    E(this, qu);
    E(this, Hc);
    // 全効果音再生の停止
    E(this, Zu);
    // BGM 演奏の停止（loadから使うのでマクロ化禁止）
    E(this, og);
    // 効果音再生の停止
    E(this, ln);
    // BGM フェードの終了待ち
    E(this, ug);
    // 効果音フェードの終了待ち
    E(this, Vc);
    // 音声フェードの停止
    E(this, Wa);
    // BGM 再生の終了待ち
    E(this, lg);
    // 効果音再生の終了待ち
    E(this, Xc);
    // 再生トラックの交換
    E(this, hg);
    E(this, cg);
    E(this, Ku);
    E(this, Ie, {});
    E(this, hr, {});
    E(this, Gs, void 0);
    E(this, $c, () => {
      Vn.volumeAll = Number(this.val.getVal("sys:sn.sound.global_volume", 1)), P(this, $c, () => {
      });
    });
    this.cfg = t, this.val = r, this.main = n, this.sys = s, e.volume = (a) => O(this, ng, rT).call(this, a), e.fadebgm = (a) => O(this, jc, e_).call(this, a), e.fadeoutbgm = (a) => O(this, sg, iT).call(this, a), e.fadeoutse = (a) => O(this, ag, nT).call(this, a), e.fadese = (a) => O(this, Xa, Oh).call(this, a), e.playbgm = (a) => O(this, zc, r_).call(this, a), e.playse = (a) => O(this, qu, Gp).call(this, a), e.stop_allse = () => O(this, Zu, Up).call(this), e.stopbgm = (a) => O(this, og, sT).call(this, a), e.stopse = (a) => O(this, ln, Ns).call(this, a), e.wb = (a) => O(this, ug, aT).call(this, a), e.wf = (a) => O(this, Vc, n_).call(this, a), e.stopfadese = (a) => O(this, Wa, Ih).call(this, a), e.wl = (a) => O(this, lg, oT).call(this, a), e.ws = (a) => O(this, Xc, s_).call(this, a), e.xchgbuf = (a) => O(this, hg, uT).call(this, a), this.val.setVal_Nochk("save", "const.sn.loopPlaying", "{}"), r.setVal_Nochk("tmp", "const.sn.sound.codecs", JSON.stringify(IA.supported));
  }
  setEvtMng(t) {
    P(this, Gs, t);
  }
  setNoticeChgVolume(t, e) {
    this.val.defValTrg("sys:sn.sound.global_volume", (r, n) => t(Vn.volumeAll = Number(n))), this.val.defValTrg("sys:sn.sound.movie_volume", (r, n) => e(Number(n))), this.val.setVal_Nochk("sys", "sn.sound.global_volume", this.val.getVal("sys:sn.sound.global_volume", 1)), this.val.setVal_Nochk("sys", "sn.sound.movie_volume", this.val.getVal("sys:sn.sound.movie_volume", 1));
  }
  clearCache() {
    Vn.removeAll();
  }
  // しおりの読込（BGM状態復元）
  playLoopFromSaveObj() {
    const t = String(this.val.getVal("save:const.sn.loopPlaying", "{}"));
    if (this.val.flush(), t === "{}") {
      O(this, Zu, Up).call(this);
      return;
    }
    P(this, hr, JSON.parse(t));
    const e = Object.keys(c(this, hr)).map((r) => () => {
      const n = "save:const.sn.sound." + r + ".", s = {
        fn: String(this.val.getVal(n + "fn")),
        buf: r,
        join: !1,
        loop: !0,
        volume: Number(this.val.getVal(n + "volume")),
        start_ms: Number(this.val.getVal(n + "start_ms")),
        end_ms: Number(this.val.getVal(n + "end_ms")),
        ret_ms: Number(this.val.getVal(n + "ret_ms"))
      };
      s.buf === "BGM" ? O(this, zc, r_).call(this, s) : O(this, qu, Gp).call(this, s);
    });
    O(this, Zu, Up).call(this);
    for (const r of e)
      r();
  }
};
let Bp = tc;
Ie = new WeakMap(), hr = new WeakMap(), Gs = new WeakMap(), ng = new WeakSet(), rT = function(t) {
  const { buf: e = "SE" } = t, r = "const.sn.sound." + e + ".volume", n = O(this, Wu, Fp).call(this, t, 1);
  return Number(this.val.getVal("sys:" + r)) === n ? !1 : (this.val.setVal_Nochk("sys", r, n), this.val.flush(), t.time = 0, t.volume = Number(this.val.getVal("save:" + r)), O(this, Xa, Oh).call(this, t));
}, Wu = new WeakSet(), Fp = function(t, e) {
  const r = tt(t, "volume", e);
  return r < 0 ? 0 : r > 1 ? 1 : r;
}, sg = new WeakSet(), iT = function(t) {
  return t.volume = 0, O(this, jc, e_).call(this, t);
}, ag = new WeakSet(), nT = function(t) {
  return t.volume = 0, O(this, Xa, Oh).call(this, t);
}, jc = new WeakSet(), e_ = function(t) {
  return t.buf = "BGM", O(this, Xa, Oh).call(this, t);
}, Xa = new WeakSet(), Oh = function(t) {
  O(this, Wa, Ih).call(this, t);
  const { buf: e = "SE" } = t, r = c(this, Ie)[e];
  if (!(r != null && r.playing()) || !r.snd)
    return !1;
  const n = "const.sn.sound." + e + ".", s = n + "volume", a = O(this, Wu, Fp).call(this, t, NaN);
  this.val.setVal_Nochk("save", s, a);
  const o = a * Number(this.val.getVal("sys:" + s, 1)), u = vt(t, "stop", a === 0);
  u && (O(this, Ku, jp).call(this, e), this.val.setVal_Nochk("save", n + "fn", "")), this.val.flush();
  const l = tt(t, "time", NaN), h = tt(t, "delay", 0);
  if (l === 0 && h === 0 || this.val.getVal("tmp:sn.skip.enabled") || c(this, Gs).isSkippingByKeyDown())
    return r.snd.volume = o, u && O(this, ln, Ns).call(this, t), !1;
  const d = tt(t, "repeat", 1);
  return r.updFade = (f) => r.snd.volume = f, r.twFade = new Tn({ v: r.snd.volume }).to({ v: o }, l).delay(h).easing(ws.ease(t.ease)).repeat(d === 0 ? 1 / 0 : d - 1).yoyo(vt(t, "yoyo", !1)).onUpdate(({ v: f }) => r.updFade(f)).onComplete(() => {
    const f = c(this, Ie)[r.now_buf];
    (f == null ? void 0 : f.twFade) !== void 0 && (f.updFade = () => {
    }, yA(f.twFade), delete f.twFade, u && (t.buf = r.now_buf, O(this, ln, Ns).call(this, t)), f.resumeFade && this.main.resume());
  }).start(), !1;
}, zc = new WeakSet(), r_ = function(t) {
  return t.buf = "BGM", t.canskip = !1, vt(t, "loop", !0), O(this, qu, Gp).call(this, t);
}, Yu = new WeakMap(), qu = new WeakSet(), Gp = function(t) {
  const { buf: e = "SE", fn: r } = t;
  if (O(this, ln, Ns).call(this, { buf: e }), !r)
    throw `[playse] fnは必須です buf:${e}`;
  if (vt(t, "canskip", !0) && c(this, Gs).isSkippingByKeyDown())
    return !1;
  const n = vt(t, "loop", !1);
  O(this, cg, lT).call(this, e, n);
  const s = "const.sn.sound." + e + ".";
  this.val.setVal_Nochk("save", s + "fn", r);
  const a = O(this, Wu, Fp).call(this, t, 1);
  this.val.setVal_Nochk("save", s + "volume", a);
  const o = a * Number(this.val.getVal("sys:" + s + "volume", 1)), u = tt(t, "start_ms", 0), l = tt(t, "end_ms", c(tc, Yu)), h = tt(t, "ret_ms", 0), d = tt(t, "pan", 0), f = tt(t, "speed", 1);
  if (u < 0)
    throw `[playse] start_ms:${u} が負の値です`;
  if (h < 0)
    throw `[playse] ret_ms:${h} が負の値です`;
  if (l > 0) {
    if (u >= l)
      throw `[playse] start_ms:${u} >= end_ms:${l} は異常値です`;
    if (h >= l)
      throw `[playse] ret_ms:${h} >= end_ms:${l} は異常値です`;
  }
  this.val.setVal_Nochk("save", s + "start_ms", u), this.val.setVal_Nochk("save", s + "end_ms", l), this.val.setVal_Nochk("save", s + "ret_ms", h), this.val.flush();
  const p = Vn.find(r), v = c(this, Ie)[e] = {
    now_buf: e,
    snd: p,
    loop: n,
    start_ms: u,
    end_ms: l,
    ret_ms: h,
    resume: !1,
    pan: d,
    playing: () => !0,
    // [ws]的にはここでtrueが欲しい
    updFade: () => {
    },
    onend: () => {
      const _ = v.now_buf, b = c(this, Ie)[_];
      if (!b)
        return;
      delete c(this, Ie)[_], b.playing = () => !1;
      const w = "const.sn.sound." + _ + ".";
      this.val.setVal_Nochk("tmp", w + "playing", !1), t.buf = _, O(this, Wa, Ih).call(this, t), b.resume && this.main.resume();
    }
  };
  this.val.setVal_Nochk("tmp", s + "playing", !0);
  const g = {
    loop: n,
    speed: f,
    volume: o,
    loaded: (_, b) => {
      if (_) {
        this.main.errScript(`Sound ロード失敗ですa fn:${r} ${_}`, !1);
        return;
      }
      if (!b)
        return;
      const w = c(this, Ie)[v.now_buf];
      w && (w.snd = b);
    }
  };
  let m = "";
  if (u > 0 || l < c(tc, Yu)) {
    m = `${r};${u};${l};${h}`;
    const _ = (g.sprites ?? (g.sprites = {}))[m] = {
      start: u / 1e3,
      end: l / 1e3
    };
    g.preload = !0;
    const b = g.loaded;
    g.loaded = (w, T) => {
      b(w, T);
      const x = T, S = x.duration;
      if (_.end < 0) {
        if (_.end += S, x.removeSprites(m), x.addSprites(m, _), _.start >= _.end)
          throw `[playse] start_ms:${u} >= end_ms:${l}(${_.end * 1e3}) は異常値です`;
        if (h >= _.end * 1e3)
          throw `[playse] ret_ms:${h} >= end_ms:${l}(${_.end * 1e3}) は異常値です`;
      }
      if (_.start >= S)
        throw `[playse] start_ms:${u} >= 音声ファイル再生時間:${S} は異常値です`;
      if (l !== c(tc, Yu) && _.end >= S)
        throw `[playse] end_ms:${l} >= 音声ファイル再生時間:${S} は異常値です`;
      x.play(m, g.complete);
    };
  } else
    g.autoPlay = !0;
  if (n ? h !== 0 && (g.loop = !1, g.complete = async (_) => {
    const b = _.duration, w = h / 1e3, T = l / 1e3;
    if (w >= b)
      throw `[playse] ret_ms:${h} >= 音声ファイル再生時間:${b} は異常値です`;
    await Vn.play(r, {
      // 一周目はループなし、なのでキャッシュされてる
      start: w,
      end: T < 0 ? T + b : T,
      // 負の値は末尾から
      speed: f,
      loop: !0,
      volume: o,
      //	sprite	: sp_nm2,	// err
      //-	muted?: boolean;
      filters: v.pan !== 0 ? [new ap.StereoFilter(v.pan)] : []
      //-	complete?: CompleteCallback;
      //-	loaded?: LoadedCallback;
      //-	singleInstance?: boolean;
    });
    const x = c(this, Ie)[v.now_buf];
    x && (x.snd = Vn.find(r));
  }) : g.complete = () => {
    var _;
    return (_ = c(this, Ie)[v.now_buf]) == null ? void 0 : _.onend();
  }, c(this, $c).call(this), p) {
    if (p.volume = o, m)
      O(this, Hc, i_).call(this, e, r, g);
    else if (p.isPlayable) {
      const _ = p.options.source;
      !(_ instanceof ArrayBuffer) || _.byteLength === 0 ? p.play(g) : v.snd = Bu.from({
        ...g,
        url: p.options.url,
        source: _
      }), p.filters = [new ap.StereoFilter(d)];
    }
    return !1;
  }
  const y = vt(t, "join", !0);
  if (y) {
    const _ = g.loaded;
    g.loaded = (b, w) => {
      _ == null || _(b, w), this.main.resume();
    };
  }
  return O(this, Hc, i_).call(this, e, r, g), y;
}, Hc = new WeakSet(), i_ = function(t, e, r) {
  const n = this.cfg.searchPath(e, vr.SOUND);
  if (n.slice(-4) !== ".bin") {
    r.url = n;
    const s = Bu.from(r);
    if (t) {
      const a = c(this, Ie)[t];
      if (!a)
        return;
      a.snd = s, a.pan !== 0 && (s.filters = [new ap.StereoFilter(a.pan)]);
    }
    r.loop || Vn.add(e, s);
    return;
  }
  new ri().add({ name: e, url: n, xhrType: Ft.XHR_RESPONSE_TYPE.BUFFER }).use((s, a) => {
    this.sys.dec(s.extension, s.data).then((o) => {
      s.data = o, a == null || a();
    }).catch((o) => this.main.errScript(`Sound ロード失敗ですc fn:${s.name} ${o}`, !1));
  }).load((s, a) => {
    var u;
    r.source = (u = a[e]) == null ? void 0 : u.data;
    const o = Bu.from(r);
    if (t) {
      const l = c(this, Ie)[t];
      if (!l)
        return;
      l.snd = o, l.pan !== 0 && (o.filters = [new ap.StereoFilter(l.pan)]);
    }
    r.loop || Vn.add(e, o);
  });
}, $c = new WeakMap(), Zu = new WeakSet(), Up = function() {
  for (const t of Object.keys(c(this, Ie)))
    O(this, ln, Ns).call(this, { buf: t });
  return P(this, Ie, {}), Vn.stopAll(), !1;
}, og = new WeakSet(), sT = function(t) {
  return t.buf = "BGM", O(this, ln, Ns).call(this, t);
}, ln = new WeakSet(), Ns = function(t) {
  var n;
  const { buf: e = "SE" } = t;
  O(this, Ku, jp).call(this, e);
  const r = c(this, Ie)[e];
  return r && ((n = r.snd) == null || n.stop(), r.onend()), !1;
}, ug = new WeakSet(), aT = function(t) {
  return t.buf = "BGM", O(this, Vc, n_).call(this, t);
}, Vc = new WeakSet(), n_ = function(t) {
  const { buf: e = "SE" } = t, r = c(this, Ie)[e];
  return !(r != null && r.twFade) || !r.playing() ? !1 : r.resumeFade = c(this, Gs).waitEvent(
    () => O(this, Wa, Ih).call(this, t),
    vt(t, "canskip", !0),
    vt(t, "global", !1)
  );
}, Wa = new WeakSet(), Ih = function(t) {
  var r, n;
  const { buf: e = "SE" } = t;
  return (n = (r = c(this, Ie)[e]) == null ? void 0 : r.twFade) == null || n.stop().end(), !1;
}, lg = new WeakSet(), oT = function(t) {
  return t.buf = "BGM", O(this, Xc, s_).call(this, t);
}, Xc = new WeakSet(), s_ = function(t) {
  const { buf: e = "SE" } = t, r = c(this, Ie)[e];
  return !(r != null && r.playing()) || r.loop ? !1 : r.resume = c(this, Gs).waitEvent(
    () => {
      t.buf = r.now_buf, O(this, ln, Ns).call(this, t);
      const n = c(this, Ie)[t.buf];
      !(n != null && n.playing()) || n.loop || n.onend();
    },
    vt(t, "canskip", !1),
    vt(t, "global", !1)
  );
}, hg = new WeakSet(), uT = function(t) {
  const { buf: e = "SE", buf2: r = "SE" } = t;
  if (e === r)
    return !1;
  const n = c(this, Ie)[e];
  n && (n.now_buf = r);
  const s = c(this, Ie)[r];
  s && (s.now_buf = e), [c(this, Ie)[e], c(this, Ie)[r]] = [s, n];
  const a = "const.sn.sound." + e + ".", o = Number(this.val.getVal("save:" + a + "volume")), u = Number(this.val.getVal("save:" + a + "fn")), l = String(this.val.getVal("tmp:" + a + "playing")) === "true", h = "const.sn.sound." + r + ".", d = Number(this.val.getVal("save:" + h + "volume")), f = Number(this.val.getVal("save:" + h + "fn")), p = String(this.val.getVal("tmp:" + h + "playing")) === "true";
  return this.val.setVal_Nochk("save", a + "volume", d), this.val.setVal_Nochk("save", h + "volume", o), this.val.setVal_Nochk("save", a + "fn", f), this.val.setVal_Nochk("save", h + "fn", u), this.val.setVal_Nochk("tmp", a + "playing", p), this.val.setVal_Nochk("tmp", h + "playing", l), e in c(this, hr) == r in c(this, hr) && (e in c(this, hr) ? (delete c(this, hr)[e], c(this, hr)[r] = 0) : (delete c(this, hr)[r], c(this, hr)[e] = 0), this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(c(this, hr)))), this.val.flush(), !1;
}, cg = new WeakSet(), lT = function(t, e) {
  if (!e) {
    O(this, Ku, jp).call(this, t);
    return;
  }
  c(this, hr)[t] = 0, this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(c(this, hr))), this.val.flush();
}, Ku = new WeakSet(), jp = function(t) {
  delete c(this, hr)[t], this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(c(this, hr))), this.val.flush();
}, // 効果音の再生
E(Bp, Yu, 999e3);
var ve;
const Jx = class {
  constructor(t, e, r, n, s, a, o, u) {
    E(this, ve, void 0);
    K(this, "lay", (t) => this.getPage(t).lay(t));
    K(this, "getPage", (t) => Jx.argChk_page(t, "fore") !== "back" ? c(this, ve).fore : c(this, ve).back);
    this.cls = e, this.hArg = s, this.sys = a, this.val = o, this.ret = u;
    const l = a.hFactoryCls[e];
    if (!l)
      throw `属性 class【${e}】が不正です`;
    const h = l(), d = l();
    h.layname = d.layname = t;
    const f = s[":id_tag"] = `layer:${t} cls:${e} page:`;
    h.spLay.name = h.name = f + "A", h.spLay.name = d.name = f + "B", r.addChild(h.spLay), n.addChild(d.spLay), vt(s, "visible", !0), vt(s, "visible", !0), u.isWait = h.lay(s) || d.lay(s), P(this, ve, { fore: h, back: d });
    const p = `const.sn.lay.${t}`;
    o.setVal_Nochk("tmp", p, !0), o.defTmp(p + ".fore.alpha", () => c(this, ve).fore.alpha), o.defTmp(p + ".back.alpha", () => c(this, ve).back.alpha), o.defTmp(p + ".fore.height", () => c(this, ve).fore.height), o.defTmp(p + ".back.height", () => c(this, ve).back.height), o.defTmp(p + ".fore.visible", () => c(this, ve).fore.spLay.visible), o.defTmp(p + ".back.visible", () => c(this, ve).back.spLay.visible), o.defTmp(p + ".fore.width", () => c(this, ve).fore.width), o.defTmp(p + ".back.width", () => c(this, ve).back.width), o.defTmp(p + ".fore.x", () => c(this, ve).fore.x), o.defTmp(p + ".back.x", () => c(this, ve).back.x), o.defTmp(p + ".fore.y", () => c(this, ve).fore.y), o.defTmp(p + ".back.y", () => c(this, ve).back.y);
  }
  destroy() {
    c(this, ve).fore.destroy(), c(this, ve).back.destroy();
  }
  static argChk_page(t, e) {
    const r = t.page ?? e;
    if (r === "fore" || r === "back")
      return t.page = r;
    throw Error("属性 page【" + r + "】が不正です");
  }
  get fore() {
    return c(this, ve).fore;
  }
  get back() {
    return c(this, ve).back;
  }
  transPage(t) {
    [c(this, ve).back, c(this, ve).fore] = [c(this, ve).fore, c(this, ve).back], c(this, ve).back.copy(c(this, ve).fore, t);
  }
};
let Wh = Jx;
ve = new WeakMap();
var fg, dg;
const Wn = class {
  constructor() {
    K(this, "layname", "");
    K(this, "name_", "");
    K(this, "spLay", new Ue(Ot.EMPTY));
  }
  set name(t) {
    this.name_ = t;
  }
  get name() {
    return this.name_;
  }
  // tsy用
  get alpha() {
    return this.spLay.alpha;
  }
  set alpha(t) {
    this.spLay.alpha = t;
  }
  get height() {
    return this.spLay.height;
  }
  get rotation() {
    return this.spLay.angle;
  }
  set rotation(t) {
    this.spLay.angle = t;
  }
  get scale_x() {
    return this.spLay.scale.x;
  }
  set scale_x(t) {
    this.spLay.scale.x = t;
  }
  get scale_y() {
    return this.spLay.scale.y;
  }
  set scale_y(t) {
    this.spLay.scale.y = t;
  }
  get width() {
    return this.spLay.width;
  }
  get x() {
    return this.spLay.x;
  }
  set x(t) {
    this.spLay.x = t;
  }
  get y() {
    return this.spLay.y;
  }
  set y(t) {
    this.spLay.y = t;
  }
  destroy() {
  }
  lay(t) {
    return "alpha" in t && (this.spLay.alpha = tt(t, "alpha", 1)), Wn.setBlendmode(this.spLay, t), ("pivot_x" in t || "pivot_y" in t) && this.spLay.pivot.set(
      tt(t, "pivot_x", this.spLay.pivot.x),
      tt(t, "pivot_y", this.spLay.pivot.y)
    ), "rotation" in t && (this.spLay.angle = tt(t, "rotation", 0)), ("scale_x" in t || "scale_y" in t) && this.spLay.scale.set(
      tt(t, "scale_x", this.spLay.scale.x),
      tt(t, "scale_y", this.spLay.scale.y)
    ), "visible" in t && (this.spLay.visible = vt(t, "visible", !0)), !1;
  }
  static setBlendmodeParentOnly(t, e) {
    const { blendmode: r } = e;
    if (!r)
      return;
    const n = Wn.getBlendmodeNum(r);
    t instanceof Ue && (t.blendMode = n);
  }
  static setBlendmode(t, e) {
    const { blendmode: r } = e;
    if (!r)
      return;
    const n = Wn.getBlendmodeNum(r);
    t instanceof Ue && (t.blendMode = n);
    for (const s of t.children)
      s instanceof Ue && (s.blendMode = n);
  }
  static getBlendmodeNum(t) {
    if (!t)
      return Et.NORMAL;
    const e = c(Wn, fg)[t];
    if (e !== void 0)
      return e;
    throw `${t} はサポートされない blendmode です`;
  }
  static getNum2Blendmode(t) {
    return c(Wn, dg)[t] ?? "normal";
  }
  // アニメ・動画があるか
  get containMovement() {
    return !1;
  }
  renderStart() {
  }
  renderEnd() {
  }
  clearLay(t) {
    this.spLay.alpha = 1, this.spLay.blendMode = Et.NORMAL, this.spLay.pivot.set(0, 0), this.spLay.angle = 0, this.spLay.scale.set(1, 1), vt(t, "filter", !1) && (this.spLay.filters = []);
  }
  copy(t, e) {
    const r = this.name_;
    this.playback(t.record(), e), this.name = r;
  }
  record() {
    return {
      name: this.name_,
      idx: this.spLay.parent.getChildIndex(this.spLay),
      alpha: this.spLay.alpha,
      blendMode: this.spLay.blendMode,
      rotation: this.spLay.angle,
      scale_x: this.spLay.scale.x,
      scale_y: this.spLay.scale.y,
      pivot_x: this.spLay.pivot.x,
      pivot_y: this.spLay.pivot.y,
      x: this.spLay.x,
      y: this.spLay.y,
      visible: this.spLay.visible
    };
  }
  playback(t, e) {
    this.name = t.name, this.clearLay({ filter: "true" }), this.spLay.alpha = t.alpha, this.spLay.blendMode = t.blendMode, this.spLay.angle = t.rotation, this.spLay.scale.set(t.scale_x, t.scale_y), this.spLay.pivot.set(t.pivot_x, t.pivot_y), this.spLay.position.set(t.x, t.y), this.spLay.visible = t.visible;
  }
  snapshot(t, e) {
    t.render(this.spLay, { clear: !1 }), e();
  }
  snapshot_end() {
  }
  makeDesignCast(t) {
  }
  makeDesignCastChildren(t) {
  }
  showDesignCast() {
  }
  showDesignCastChildren() {
  }
  cvsResize() {
  }
  cvsResizeChildren() {
  }
  dump() {
    return ` "idx":${this.spLay.parent.getChildIndex(this.spLay)}, "visible":"${this.spLay.visible}", "left":${this.spLay.x}, "top":${this.spLay.y}, "alpha":${this.spLay.alpha}, "rotation":${this.spLay.angle}, "name":"${this.name_}", "scale_x":${this.spLay.scale.x}, "scale_y":${this.spLay.scale.y}`;
  }
  static setXY(t, e, r, n = !1, s = !1) {
    if (e.pos) {
      Wn.setXYByPos(t, e.pos, r);
      return;
    }
    const a = t.getBounds(), o = r.scale.x < 0 ? -r.scale.x : r.scale.x, u = o === 1 ? a.width : a.width * o, l = r.scale.y < 0 ? -r.scale.y : r.scale.y, h = l === 1 ? a.height : a.height * l;
    let d = r.x;
    "left" in e ? (d = tt(e, "left", 0), d > -1 && d < 1 && (d *= Y.stageW)) : "center" in e ? (d = tt(e, "center", 0), d > -1 && d < 1 && (d *= Y.stageW), d = d - (s ? u / 3 : u) / 2) : "right" in e ? (d = tt(e, "right", 0), d > -1 && d < 1 && (d *= Y.stageW), d = d - (s ? u / 3 : u)) : "s_right" in e && (d = tt(e, "s_right", 0), d > -1 && d < 1 && (d *= Y.stageW), d = Y.stageW - d - (s ? u / 3 : u)), r.x = $t(r.scale.x < 0 ? d + (s ? u / 3 : u) : d);
    let f = r.y;
    "top" in e ? (f = tt(e, "top", 0), f > -1 && f < 1 && (f *= Y.stageH)) : "middle" in e ? (f = tt(e, "middle", 0), f > -1 && f < 1 && (f *= Y.stageH), f = f - h / 2) : "bottom" in e ? (f = tt(e, "bottom", 0), f > -1 && f < 1 && (f *= Y.stageH), f = f - h) : "s_bottom" in e && (f = tt(e, "s_bottom", 0), f > -1 && f < 1 && (f *= Y.stageH), f = Y.stageH - f - h), r.y = $t(r.scale.y < 0 ? f + h : f), n && !("left" in e) && !("center" in e) && !("right" in e) && !("s_right" in e) && !("top" in e) && !("middle" in e) && !("bottom" in e) && !("s_bottom" in e) && Wn.setXYByPos(t, "c", r);
  }
  static setXYByPos(t, e, r) {
    if (e === "stay")
      return;
    if (t === void 0)
      throw "setXYByPos base === undefined";
    if (r === void 0)
      throw "setXYByPos result === undefined";
    const n = t.getBounds(), s = r.scale.x < 0 ? -r.scale.x : r.scale.x, a = s === 1 ? n.width : n.width * s, o = r.scale.y < 0 ? -r.scale.y : r.scale.y, u = o === 1 ? n.height : n.height * o;
    let l = 0;
    !e || e === "c" ? l = Y.stageW * 0.5 : e === "r" ? l = Y.stageW - a * 0.5 : e === "l" ? l = a * 0.5 : l = $t(e), r.x = $t(l - a * 0.5), r.y = Y.stageH - u, r.scale.x < 0 && (r.x += a), r.scale.y < 0 && (r.y += u);
  }
  static setXYCenter(t) {
    const e = t.getBounds();
    t.x = (Y.stageW - e.width) * 0.5, t.y = (Y.stageH - e.height) * 0.5;
  }
};
let _r = Wn;
fg = new WeakMap(), dg = new WeakMap(), E(_r, fg, {
  normal: Et.NORMAL,
  add: Et.ADD,
  multiply: Et.MULTIPLY,
  screen: Et.SCREEN
  /*
  		'overlay'		: BLEND_MODES.OVERLAY,
  		'darken'		: BLEND_MODES.DARKEN,
  		'lighten'		: BLEND_MODES.LIGHTEN,
  		'color_dodge'	: BLEND_MODES.COLOR_DODGE,
  		'color_burn'	: BLEND_MODES.COLOR_BURN,
  		'hard_light'	: BLEND_MODES.HARD_LIGHT,
  		'soft_light'	: BLEND_MODES.SOFT_LIGHT,
  		'difference'	: BLEND_MODES.DIFFERENCE,
  		'exclusion'		: BLEND_MODES.EXCLUSION,
  		'hue'			: BLEND_MODES.HUE,
  		'saturation'	: BLEND_MODES.SATURATION,
  		'color'			: BLEND_MODES.COLOR,
  		'luminosity'	: BLEND_MODES.LUMINOSITY,
  
  		'normal_npm'	: BLEND_MODES.NORMAL_NPM,
  		'add_npm'		: BLEND_MODES.ADD_NPM,
  		'screen_npm'	: BLEND_MODES.SCREEN_NPM,
  		'none'			: BLEND_MODES.NONE,
  		'src_in'		: BLEND_MODES.SRC_IN,
  		'src_out'		: BLEND_MODES.SRC_OUT,
  		'src_atop'		: BLEND_MODES.SRC_ATOP,
  		'dst_over'		: BLEND_MODES.DST_OVER,
  		'dst_in'		: BLEND_MODES.DST_IN,
  		'dst_out'		: BLEND_MODES.DST_OUT,
  		'dst_atop'		: BLEND_MODES.DST_ATOP,
  		'subtract'		: BLEND_MODES.SUBTRACT,
  		'src_over'		: BLEND_MODES.SRC_OVER,
  		'erase'			: BLEND_MODES.ERASE,
  		'xor'			: BLEND_MODES.XOR,
  */
}), E(_r, dg, {
  0: "normal",
  1: "add",
  2: "multiply",
  3: "screen"
});
function RA(i) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  return t.map(function(r) {
    return r.split(" ").map(function(n) {
      return n ? "" + i + n : "";
    }).join(" ");
  }).join(" ");
}
function DA(i, t) {
  return t.replace(/([^}{]*){/gm, function(e, r) {
    return r.replace(/\.([^{,\s\d.]+)/g, "." + i + "$1") + "{";
  });
}
function Es(i, t) {
  return function(e) {
    e && (i[t] = e);
  };
}
function hT(i, t, e) {
  return function(r) {
    r && (i[t][e] = r);
  };
}
function uw(i, t) {
  return function(e) {
    var r = e.prototype;
    i.forEach(function(n) {
      t(r, n);
    });
  };
}
function kA(i, t) {
  return t === void 0 && (t = {}), function(e, r) {
    i.forEach(function(n) {
      var s = t[n] || n;
      s in e || (e[s] = function() {
        for (var a, o = [], u = 0; u < arguments.length; u++)
          o[u] = arguments[u];
        var l = (a = this[r])[n].apply(a, o);
        return l === this[r] ? this : l;
      });
    });
  };
}
var NA = "function", AA = "object", LA = "string", BA = "number", cT = "undefined", fT = typeof window !== cT, FA = [{
  open: "(",
  close: ")"
}, {
  open: '"',
  close: '"'
}, {
  open: "'",
  close: "'"
}, {
  open: '\\"',
  close: '\\"'
}, {
  open: "\\'",
  close: "\\'"
}], Je = 1e-7, op = {
  cm: function(i) {
    return i * 96 / 2.54;
  },
  mm: function(i) {
    return i * 96 / 254;
  },
  in: function(i) {
    return i * 96;
  },
  pt: function(i) {
    return i * 96 / 72;
  },
  pc: function(i) {
    return i * 96 / 6;
  },
  "%": function(i, t) {
    return i * t / 100;
  },
  vw: function(i, t) {
    return t === void 0 && (t = window.innerWidth), i / 100 * t;
  },
  vh: function(i, t) {
    return t === void 0 && (t = window.innerHeight), i / 100 * t;
  },
  vmax: function(i, t) {
    return t === void 0 && (t = Math.max(window.innerWidth, window.innerHeight)), i / 100 * t;
  },
  vmin: function(i, t) {
    return t === void 0 && (t = Math.min(window.innerWidth, window.innerHeight)), i / 100 * t;
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function GA() {
  for (var i = 0, t = 0, e = arguments.length; t < e; t++)
    i += arguments[t].length;
  for (var r = Array(i), n = 0, t = 0; t < e; t++)
    for (var s = arguments[t], a = 0, o = s.length; a < o; a++, n++)
      r[n] = s[a];
  return r;
}
function Ma(i, t, e, r) {
  return (i * r + t * e) / (e + r);
}
function o0(i) {
  return typeof i === cT;
}
function ha(i) {
  return i && typeof i === AA;
}
function tr(i) {
  return Array.isArray(i);
}
function $r(i) {
  return typeof i === LA;
}
function fc(i) {
  return typeof i === BA;
}
function ax(i) {
  return typeof i === NA;
}
function UA(i, t) {
  var e = i === "" || i == " ", r = t === "" || t == " ";
  return r && e || i === t;
}
function dT(i, t, e, r, n) {
  var s = ox(i, t, e);
  return s ? e : jA(i, t, e + 1, r, n);
}
function ox(i, t, e) {
  if (!i.ignore)
    return null;
  var r = t.slice(Math.max(e - 3, 0), e + 3).join("");
  return new RegExp(i.ignore).exec(r);
}
function jA(i, t, e, r, n) {
  for (var s = function(l) {
    var h = t[l].trim();
    if (h === i.close && !ox(i, t, l))
      return {
        value: l
      };
    var d = l, f = nn(n, function(p) {
      var v = p.open;
      return v === h;
    });
    if (f && (d = dT(f, t, l, r, n)), d === -1)
      return a = l, "break";
    l = d, a = l;
  }, a, o = e; o < r; ++o) {
    var u = s(o);
    if (o = a, typeof u == "object")
      return u.value;
    if (u === "break")
      break;
  }
  return -1;
}
function ux(i, t) {
  var e = $r(t) ? {
    separator: t
  } : t, r = e.separator, n = r === void 0 ? "," : r, s = e.isSeparateFirst, a = e.isSeparateOnlyOpenClose, o = e.isSeparateOpenClose, u = o === void 0 ? a : o, l = e.openCloseCharacters, h = l === void 0 ? FA : l, d = h.map(function(S) {
    var C = S.open, M = S.close;
    return C === M ? C : C + "|" + M;
  }).join("|"), f = "(\\s*" + n + "\\s*|" + d + "|\\s+)", p = new RegExp(f, "g"), v = i.split(p).filter(function(S) {
    return S && S !== "undefined";
  }), g = v.length, m = [], y = [];
  function _() {
    return y.length ? (m.push(y.join("")), y = [], !0) : !1;
  }
  for (var b = function(S) {
    var C = v[S].trim(), M = S, I = nn(h, function(A) {
      var G = A.open;
      return G === C;
    }), R = nn(h, function(A) {
      var G = A.close;
      return G === C;
    });
    if (I) {
      if (M = dT(I, v, S, g, h), M !== -1 && u)
        return _() && s || (m.push(v.slice(S, M + 1).join("")), S = M, s) ? (w = S, "break") : (w = S, "continue");
    } else if (R && !ox(R, v, S)) {
      var N = GA(h);
      return N.splice(h.indexOf(R), 1), {
        value: ux(i, {
          separator: n,
          isSeparateFirst: s,
          isSeparateOnlyOpenClose: a,
          isSeparateOpenClose: u,
          openCloseCharacters: N
        })
      };
    } else if (UA(C, n) && !a)
      return _(), s ? (w = S, "break") : (w = S, "continue");
    M === -1 && (M = g - 1), y.push(v.slice(S, M + 1).join("")), S = M, w = S;
  }, w, T = 0; T < g; ++T) {
    var x = b(T);
    if (T = w, typeof x == "object")
      return x.value;
    if (x === "break")
      break;
  }
  return y.length && m.push(y.join("")), m;
}
function ca(i) {
  return ux(i, "");
}
function Fa(i) {
  return ux(i, ",");
}
function pT(i) {
  var t = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(i);
  return !t || t.length < 4 ? {} : {
    prefix: t[1],
    value: t[2],
    suffix: t[3]
  };
}
function xd(i) {
  var t = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(i);
  if (!t)
    return {
      prefix: "",
      unit: "",
      value: NaN
    };
  var e = t[1], r = t[2], n = t[3];
  return {
    prefix: e,
    unit: n,
    value: parseFloat(r)
  };
}
function zA(i) {
  return i.replace(/[\s-_]+([^\s-_])/g, function(t, e) {
    return e.toUpperCase();
  });
}
function zp(i, t) {
  return t === void 0 && (t = "-"), i.replace(/([a-z])([A-Z])/g, function(e, r, n) {
    return "" + r + t + n.toLowerCase();
  });
}
function dc() {
  return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
}
function Ms(i, t, e) {
  e === void 0 && (e = -1);
  for (var r = i.length, n = 0; n < r; ++n)
    if (t(i[n], n, i))
      return n;
  return e;
}
function nn(i, t, e) {
  var r = Ms(i, t);
  return r > -1 ? i[r] : e;
}
var vT = /* @__PURE__ */ function() {
  var i = dc(), t = fT && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return t ? t.bind(window) : function(e) {
    var r = dc(), n = setTimeout(function() {
      e(r - i);
    }, 1e3 / 60);
    return n;
  };
}(), HA = /* @__PURE__ */ function() {
  var i = fT && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return i ? i.bind(window) : function(t) {
    clearTimeout(t);
  };
}();
function Ps(i) {
  return Object.keys(i);
}
function $A(i) {
  var t = Ps(i);
  return t.map(function(e) {
    return i[e];
  });
}
function Te(i, t) {
  var e = xd(i), r = e.value, n = e.unit;
  if (ha(t)) {
    var s = t[n];
    if (s) {
      if (ax(s))
        return s(r);
      if (op[n])
        return op[n](r, s);
    }
  } else if (n === "%")
    return r * t / 100;
  return op[n] ? op[n](r) : r;
}
function a_(i, t, e) {
  return Math.max(t, Math.min(i, e));
}
function lw(i, t, e, r) {
  return r === void 0 && (r = i[0] / i[1]), [[Gt(t[0], Je), Gt(t[0] / r, Je)], [Gt(t[1] * r, Je), Gt(t[1], Je)]].filter(function(n) {
    return n.every(function(s, a) {
      var o = t[a], u = Gt(o, Je);
      return e ? s <= o || s <= u : s >= o || s >= u;
    });
  })[0] || i;
}
function VA(i, t, e, r) {
  if (!r)
    return i.map(function(p, v) {
      return a_(p, t[v], e[v]);
    });
  var n = i[0], s = i[1], a = r === !0 ? n / s : r, o = lw(i, t, !1, a), u = o[0], l = o[1], h = lw(i, e, !0, a), d = h[0], f = h[1];
  return n < u || s < l ? (n = u, s = l) : (n > d || s > f) && (n = d, s = f), [n, s];
}
function XA(i) {
  for (var t = i.length, e = 0, r = t - 1; r >= 0; --r)
    e += i[r];
  return e;
}
function o_(i) {
  for (var t = i.length, e = 0, r = t - 1; r >= 0; --r)
    e += i[r];
  return t ? e / t : 0;
}
function $e(i, t) {
  var e = t[0] - i[0], r = t[1] - i[1], n = Math.atan2(r, e);
  return n >= 0 ? n : n + Math.PI * 2;
}
function WA(i) {
  return [0, 1].map(function(t) {
    return o_(i.map(function(e) {
      return e[t];
    }));
  });
}
function u_(i) {
  var t = WA(i), e = $e(t, i[0]), r = $e(t, i[1]);
  return e < r && r - e < Math.PI || e > r && r - e < -Math.PI ? 1 : -1;
}
function Zi(i, t) {
  return Math.sqrt(Math.pow((t ? t[0] : 0) - i[0], 2) + Math.pow((t ? t[1] : 0) - i[1], 2));
}
function Gt(i, t) {
  if (!t)
    return i;
  var e = 1 / t;
  return Math.round(i / t) / e;
}
function hw(i, t) {
  return i.forEach(function(e, r) {
    i[r] = Gt(i[r], t);
  }), i;
}
function YA(i) {
  return i.reduce(function(t, e) {
    return t.concat(e);
  }, []);
}
function gT(i, t) {
  i.indexOf(t) === -1 && i.push(t);
}
function sr(i, t) {
  return i.classList ? i.classList.contains(t) : !!i.className.match(new RegExp("(\\s|^)" + t + "(\\s|$)"));
}
function mT(i, t) {
  i.classList ? i.classList.add(t) : i.className += " " + t;
}
function yT(i, t) {
  if (i.classList)
    i.classList.remove(t);
  else {
    var e = new RegExp("(\\s|^)" + t + "(\\s|$)");
    i.className = i.className.replace(e, " ");
  }
}
function Dr(i, t, e, r) {
  i.addEventListener(t, e, r);
}
function gr(i, t, e, r) {
  i.removeEventListener(t, e, r);
}
var qA = /* @__PURE__ */ function() {
  function i() {
    this.keys = [], this.values = [];
  }
  var t = i.prototype;
  return t.get = function(e) {
    return this.values[this.keys.indexOf(e)];
  }, t.set = function(e, r) {
    var n = this.keys, s = this.values, a = n.indexOf(e), o = a === -1 ? n.length : a;
    n[o] = e, s[o] = r;
  }, i;
}(), ZA = /* @__PURE__ */ function() {
  function i() {
    this.object = {};
  }
  var t = i.prototype;
  return t.get = function(e) {
    return this.object[e];
  }, t.set = function(e, r) {
    this.object[e] = r;
  }, i;
}(), KA = typeof Map == "function", JA = /* @__PURE__ */ function() {
  function i() {
  }
  var t = i.prototype;
  return t.connect = function(e, r) {
    this.prev = e, this.next = r, e && (e.next = this), r && (r.prev = this);
  }, t.disconnect = function() {
    var e = this.prev, r = this.next;
    e && (e.next = r), r && (r.prev = e);
  }, t.getIndex = function() {
    for (var e = this, r = -1; e; )
      e = e.prev, ++r;
    return r;
  }, i;
}();
function QA(i, t) {
  var e = [], r = [];
  return i.forEach(function(n) {
    var s = n[0], a = n[1], o = new JA();
    e[s] = o, r[a] = o;
  }), e.forEach(function(n, s) {
    n.connect(e[s - 1]);
  }), i.filter(function(n, s) {
    return !t[s];
  }).map(function(n, s) {
    var a = n[0], o = n[1];
    if (a === o)
      return [0, 0];
    var u = e[a], l = r[o - 1], h = u.getIndex();
    u.disconnect(), l ? u.connect(l, l.next) : u.connect(void 0, e[0]);
    var d = u.getIndex();
    return [h, d];
  });
}
var tL = /* @__PURE__ */ function() {
  function i(e, r, n, s, a, o, u, l) {
    this.prevList = e, this.list = r, this.added = n, this.removed = s, this.changed = a, this.maintained = o, this.changedBeforeAdded = u, this.fixed = l;
  }
  var t = i.prototype;
  return Object.defineProperty(t, "ordered", {
    get: function() {
      return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t, "pureChanged", {
    get: function() {
      return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged;
    },
    enumerable: !0,
    configurable: !0
  }), t.caculateOrdered = function() {
    var e = QA(this.changedBeforeAdded, this.fixed), r = this.changed, n = [];
    this.cacheOrdered = e.filter(function(s, a) {
      var o = s[0], u = s[1], l = r[a], h = l[0], d = l[1];
      if (o !== u)
        return n.push([h, d]), !0;
    }), this.cachePureChanged = n;
  }, i;
}();
function wd(i, t, e) {
  var r = KA ? Map : e ? ZA : qA, n = e || function(_) {
    return _;
  }, s = [], a = [], o = [], u = i.map(n), l = t.map(n), h = new r(), d = new r(), f = [], p = [], v = {}, g = [], m = 0, y = 0;
  return u.forEach(function(_, b) {
    h.set(_, b);
  }), l.forEach(function(_, b) {
    d.set(_, b);
  }), u.forEach(function(_, b) {
    var w = d.get(_);
    typeof w > "u" ? (++y, a.push(b)) : v[w] = y;
  }), l.forEach(function(_, b) {
    var w = h.get(_);
    typeof w > "u" ? (s.push(b), ++m) : (o.push([w, b]), y = v[b] || 0, f.push([w - y, b - m]), p.push(b === w), w !== b && g.push([w, b]));
  }), a.reverse(), new tL(i, t, s, a, g, o, f, p);
}
var eL = /* @__PURE__ */ function() {
  function i(e, r) {
    e === void 0 && (e = []), this.findKeyCallback = r, this.list = [].slice.call(e);
  }
  var t = i.prototype;
  return t.update = function(e) {
    var r = [].slice.call(e), n = wd(this.list, r, this.findKeyCallback);
    return this.list = r, n;
  }, i;
}(), l_ = function(i, t) {
  return l_ = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
  }, l_(i, t);
};
function Ed(i, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  l_(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Pn = function() {
  return Pn = Object.assign || function(t) {
    for (var e, r = 1, n = arguments.length; r < n; r++) {
      e = arguments[r];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
    }
    return t;
  }, Pn.apply(this, arguments);
};
function _T(i, t) {
  var e = {};
  for (var r in i)
    Object.prototype.hasOwnProperty.call(i, r) && t.indexOf(r) < 0 && (e[r] = i[r]);
  if (i != null && typeof Object.getOwnPropertySymbols == "function")
    for (var n = 0, r = Object.getOwnPropertySymbols(i); n < r.length; n++)
      t.indexOf(r[n]) < 0 && Object.prototype.propertyIsEnumerable.call(i, r[n]) && (e[r[n]] = i[r[n]]);
  return e;
}
function cw(i, t, e) {
  if (e || arguments.length === 2)
    for (var r = 0, n = t.length, s; r < n; r++)
      (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return i.concat(s || Array.prototype.slice.call(t));
}
function fw(i) {
  var t = 0;
  return i.map(function(e) {
    return e == null ? "$compat".concat(++t) : "".concat(e);
  });
}
function bT(i) {
  var t = [];
  return i.forEach(function(e) {
    t = t.concat(tr(e) ? bT(e) : e);
  }), t;
}
function ry(i, t) {
  if (!t)
    return i;
  for (var e in t)
    o0(i[e]) && (i[e] = t[e]);
  return i;
}
function wv(i, t) {
  if (i === t)
    return !1;
  for (var e in i)
    if (!(e in t))
      return !0;
  for (var e in t)
    if (i[e] !== t[e])
      return !0;
  return !1;
}
function dw(i) {
  var t = i.className, e = _T(i, ["className"]);
  return t != null && (e.class = t), delete e.style, delete e.children, e;
}
function pw(i) {
  var t = {}, e = {};
  for (var r in i)
    r.indexOf("on") === 0 ? e[r] = i[r] : t[r] = i[r];
  return [t, e];
}
function lx(i) {
  if (!i)
    return null;
  var t = i.b;
  return t instanceof Node ? t : lx(i.c);
}
function xT(i) {
  var t = i.parentNode;
  t && t.removeChild(i);
}
function wT(i) {
  i.forEach(function(t) {
    t();
  });
}
function rL() {
  return this.constructor(this.props, this.context);
}
var hx = 0, ET = null, u0 = /* @__PURE__ */ function() {
  function i(e, r, n, s, a, o, u) {
    u === void 0 && (u = {}), this.t = e, this.d = r, this.k = n, this.i = s, this.c = a, this.ref = o, this.ps = u, this.typ = "prov", this._ps = [], this._cs = {}, this._hyd = null, this._sel = !1;
  }
  var t = i.prototype;
  return t.s = function() {
    return !0;
  }, t.u = function(e, r, n, s, a) {
    var o = this, u = o.d, l = $A(r).filter(function(v) {
      return v.$_req;
    }), h = bT(l.map(function(v) {
      return v.$_subs;
    })), d = nn(h, function(v) {
      return v.d === u;
    });
    if (o.b && !$r(n) && !a && !o.s(n.props, s) && !d) {
      var f = h.reduce(function(v, g) {
        var m = g.d;
        return v[0] ? v[0].d === m && v.push(g) : m > u && v.push(g), v;
      }, []);
      return f.forEach(function(v) {
        Sd(v, v._ps, [v.o], e, r, !0);
      }), !1;
    }
    o.o = n, o.ss(s);
    var p = o.ps;
    return $r(n) || (o.ps = n.props, o.ref = n.ref), cx(this), o.r(e, r, o.b ? p : {}, s), !0;
  }, t.md = function() {
    this.rr();
  }, t.ss = function() {
  }, t.ud = function() {
    this.rr();
  }, t.rr = function() {
    var e = this, r = e.ref, n = e.fr;
    r && r(n ? n.current : e.b);
  }, i;
}();
function ST() {
  return ET;
}
function iL() {
  return hx;
}
function nL(i) {
  hx = i;
}
function cx(i) {
  ET = i, hx = 0;
}
var fx = /* @__PURE__ */ function() {
  function i(e, r) {
    e === void 0 && (e = {}), this.props = e, this.context = r, this.state = {}, this.$_timer = 0, this.$_state = {}, this.$_subs = [], this.$_cs = {};
  }
  var t = i.prototype;
  return t.render = function() {
    return null;
  }, t.shouldComponentUpdate = function(e, r) {
    return this.props !== e || this.state !== r;
  }, t.setState = function(e, r, n) {
    var s = this;
    s.$_timer || (s.$_state = {}), clearTimeout(s.$_timer), s.$_timer = 0, s.$_state = Pn(Pn({}, s.$_state), e), n ? s.$_setState(r, n) : s.$_timer = window.setTimeout(function() {
      s.$_timer = 0, s.$_setState(r, n);
    });
  }, t.forceUpdate = function(e) {
    this.setState({}, e, !0);
  }, t.componentDidMount = function() {
  }, t.componentDidUpdate = function(e, r) {
  }, t.componentWillUnmount = function() {
  }, t.$_setState = function(e, r) {
    var n = [], s = this.$_p, a = Sd(s.c, [s], [s.o], n, s._cs, Pn(Pn({}, this.state), this.$_state), r);
    a && (e && n.push(e), wT(n), cx(null));
  }, i;
}(), TT = /* @__PURE__ */ function(i) {
  Ed(t, i);
  function t() {
    return i !== null && i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.shouldComponentUpdate = function(r, n) {
    return wv(this.props, r) || wv(this.state, n);
  }, t;
}(fx);
function CT(i) {
  var t = function(e) {
    t.current = e;
  };
  return t.current = i, t;
}
function sL(i) {
  return i._fr = !0, i;
}
function aL(i, t, e, r) {
  var n, s;
  return !((n = i == null ? void 0 : i.prototype) === null || n === void 0) && n.render ? s = new i(t, e) : (s = new fx(t, e), s.constructor = i, i._fr ? (r.fr = CT(), s.render = function() {
    return this.constructor(this.props, r.fr);
  }) : s.render = rL), s.$_p = r, s;
}
var oL = /* @__PURE__ */ function(i) {
  Ed(t, i);
  function t(r, n, s, a, o, u, l) {
    l === void 0 && (l = {});
    var h = i.call(this, r, n, s, a, o, u, ry(l, r.defaultProps)) || this;
    return h.typ = "comp", h._usefs = [], h._uefs = [], h._defs = [], h;
  }
  var e = t.prototype;
  return e.s = function(r, n) {
    var s = this.b;
    return s.shouldComponentUpdate(ry(r, this.t.defaultProps), n || s.state) !== !1;
  }, e.r = function(r, n, s) {
    var a, o, u = this, l = u.t;
    u.ps = ry(u.ps, u.t.defaultProps);
    var h = u.ps, d = !u.b, f = l.contextType, p = u.b, v = f == null ? void 0 : f.get(u);
    u._cs = n, d ? (p = aL(l, h, v, u), u.b = p) : (p.props = h, p.context = v);
    var g = p.state;
    u._usefs = [], u._uefs = [];
    var m = p.render();
    ((o = (a = m == null ? void 0 : m.props) === null || a === void 0 ? void 0 : a.children) === null || o === void 0 ? void 0 : o.length) === 0 && (m.props.children = u.ps.children);
    var y = Pn(Pn({}, n), p.$_cs);
    Sd(u, u._ps, m ? [m] : [], r, y), d ? u._uefs.push(function() {
      f == null || f.register(u), p.componentDidMount();
    }) : u._uefs.push(function() {
      p.componentDidUpdate(s, g);
    }), r.push(function() {
      u._usefs.forEach(function(_) {
        _();
      }), d ? u.md() : u.ud(), u._defs = u._uefs.map(function(_) {
        return _();
      });
    });
  }, e.ss = function(r) {
    var n = this.b;
    !n || !r || (n.state = r);
  }, e.un = function() {
    var r, n = this;
    n._ps.forEach(function(a) {
      a.un();
    });
    var s = n.t;
    (r = s.contextType) === null || r === void 0 || r.unregister(n), clearTimeout(n.b.$_timer), n._defs.forEach(function(a) {
      a && a();
    }), n.b.componentWillUnmount();
  }, t;
}(u0);
function uL(i, t, e) {
  var r = dx(dw(i), dw(t)), n = r.added, s = r.removed, a = r.changed;
  for (var o in n)
    e.setAttribute(o, n[o]);
  for (var u in a)
    e.setAttribute(u, a[u][1]);
  for (var l in s)
    e.removeAttribute(l);
}
function lL(i, t, e) {
  var r = dx(i, t), n = r.added, s = r.removed;
  for (var a in s)
    e.e(a, !0);
  for (var o in n)
    e.e(o);
}
function dx(i, t) {
  var e = Ps(i), r = Ps(t), n = wd(e, r, function(u) {
    return u;
  }), s = {}, a = {}, o = {};
  return n.added.forEach(function(u) {
    var l = r[u];
    s[l] = t[l];
  }), n.removed.forEach(function(u) {
    var l = e[u];
    a[l] = i[l];
  }), n.maintained.forEach(function(u) {
    var l = u[0], h = e[l], d = [i[h], t[h]];
    i[h] !== t[h] && (o[h] = d);
  }), {
    added: s,
    removed: a,
    changed: o
  };
}
function hL(i, t, e) {
  var r = e.style, n = dx(i, t), s = n.added, a = n.removed, o = n.changed;
  for (var u in s) {
    var l = zp(u, "-");
    r.setProperty(l, s[u]);
  }
  for (var u in o) {
    var h = zp(u, "-");
    r.setProperty(h, o[u][1]);
  }
  for (var u in a) {
    var d = zp(u, "-");
    r.removeProperty(d);
  }
}
function cL(i) {
  return i.replace(/^on/g, "").toLowerCase();
}
var fL = /* @__PURE__ */ function(i) {
  Ed(t, i);
  function t() {
    var r = i !== null && i.apply(this, arguments) || this;
    return r.typ = "elem", r._es = {}, r._svg = !1, r;
  }
  var e = t.prototype;
  return e.e = function(r, n) {
    var s = this, a = s._es, o = s.b, u = cL(r);
    n ? (gr(o, u, a[r]), delete a[r]) : (a[r] = function(l) {
      var h, d;
      (d = (h = s.ps)[r]) === null || d === void 0 || d.call(h, l);
    }, Dr(o, u, a[r]));
  }, e.s = function(r) {
    return wv(this.ps, r);
  }, e.r = function(r, n, s) {
    var a, o = this, u = !o.b, l = o.ps;
    if (u) {
      var h = !1;
      if (o._svg || o.t === "svg")
        h = !0;
      else {
        var d = lx(o.c);
        h = d && d.ownerSVGElement;
      }
      o._svg = h;
      var f = l.portalContainer;
      if (!f) {
        f = (a = o._hyd) === null || a === void 0 ? void 0 : a.splice(0, 1)[0];
        var p = o.t;
        f ? o._hyd = [].slice.call(f.children) : h ? f = document.createElementNS("http://www.w3.org/2000/svg", p) : f = document.createElement(p);
      }
      o.b = f;
    }
    Sd(o, o._ps, l.children, r, n);
    var v = o.b, g = pw(s), m = g[0], y = g[1], _ = pw(l), b = _[0], w = _[1];
    return uL(m, b, v), lL(y, w, o), hL(s.style || {}, l.style || {}, v), r.push(function() {
      u ? o.md() : o.ud();
    }), !0;
  }, e.un = function() {
    var r = this, n = r._es, s = r.b;
    for (var a in n)
      gr(s, a, n[a]);
    r._ps.forEach(function(o) {
      o.un();
    }), r._es = {}, !r.ps.portalContainer && !r._sel && xT(s);
  }, t;
}(u0);
function pc(i) {
  if (!i || i instanceof Node)
    return i;
  var t = i.$_p._ps;
  return t.length ? pc(t[0].b) : null;
}
function MT(i) {
  if (i) {
    if (i.b && i.b instanceof Node)
      return i;
    var t = i._ps;
    return t.length ? MT(t[0]) : null;
  }
}
function Ki(i, t) {
  for (var e = [], r = 2; r < arguments.length; r++)
    e[r - 2] = arguments[r];
  var n = t || {}, s = n.key, a = n.ref, o = _T(n, ["key", "ref"]);
  return {
    type: i,
    key: s,
    ref: a,
    props: Pn(Pn({}, o), {
      children: YA(e).filter(function(u) {
        return u != null && u !== !1;
      })
    })
  };
}
var PT = /* @__PURE__ */ function(i) {
  Ed(t, i);
  function t(r, n) {
    n === void 0 && (n = 0);
    var s = i.call(this, "container", n, "container", 0, null) || this;
    return s.typ = "container", s.b = r, s;
  }
  var e = t.prototype;
  return e.r = function() {
    return !0;
  }, e.un = function() {
  }, t;
}(u0), dL = /* @__PURE__ */ function(i) {
  Ed(t, i);
  function t() {
    var r = i !== null && i.apply(this, arguments) || this;
    return r.typ = "text", r;
  }
  var e = t.prototype;
  return e.r = function(r) {
    var n, s = this, a = !s.b;
    if (a) {
      var o = (n = s._hyd) === null || n === void 0 ? void 0 : n.splice(0, 1)[0];
      s.b = o || document.createTextNode(s.t.replace("text_", ""));
    }
    return r.push(function() {
      a ? s.md() : s.ud();
    }), !0;
  }, e.un = function() {
    xT(this.b);
  }, t;
}(u0);
function pL(i, t, e) {
  var r = e.map(function(u) {
    return $r(u) ? null : u.key;
  }), n = fw(t.map(function(u) {
    return u.k;
  })), s = fw(r), a = wd(n, s, function(u) {
    return u;
  });
  a.removed.forEach(function(u) {
    t.splice(u, 1)[0].un();
  }), a.ordered.forEach(function(u) {
    var l = u[0], h = u[1], d = t.splice(l, 1)[0];
    t.splice(h, 0, d);
    var f = pc(d.b), p = pc(t[h + 1] && t[h + 1].b);
    f && f.parentNode.insertBefore(f, p);
  }), a.added.forEach(function(u) {
    t.splice(u, 0, vw(e[u], r[u], u, i));
  });
  var o = a.maintained.filter(function(u) {
    u[0];
    var l = u[1], h = e[l], d = t[l], f = $r(h) ? "text_".concat(h) : h.type;
    return f !== d.t ? (d.un(), t.splice(l, 1, vw(h, r[l], l, i)), !0) : (d.i = l, !1);
  });
  return cw(cw([], a.added, !0), o.map(function(u) {
    u[0];
    var l = u[1];
    return l;
  }), !0);
}
function vL(i, t) {
  for (var e = i._ps, r = e.length, n = t.i + 1; n < r; ++n) {
    var s = pc(e[n].b);
    if (s)
      return s;
  }
  return null;
}
function vw(i, t, e, r) {
  var n = r.d + 1;
  if ($r(i) || fc(i))
    return new dL("text_".concat(i), n, t, e, r, null, {});
  var s = i.type, a = typeof s == "string" ? fL : oL;
  return new a(s, n, t, e, r, i.ref, i.props);
}
function Sd(i, t, e, r, n, s, a) {
  var o = pL(i, t, e), u = i._hyd, l = t.filter(function(d, f) {
    return d._hyd = u, d.u(r, n, e[f], s, a);
  });
  i.typ === "container" && i._sel && t.forEach(function(d) {
    var f = MT(d);
    f && (f._sel = !0);
  }), i._hyd = null;
  var h = lx(i);
  return h && o.reverse().forEach(function(d) {
    var f = t[d], p = pc(f.b);
    if (p && h !== p && !p.parentNode) {
      var v = vL(i, f);
      h.insertBefore(p, v);
    }
  }), l.length > 0;
}
function gL(i, t, e, r) {
  e === void 0 && (e = t.__CROACT__), r === void 0 && (r = {});
  var n = !!e;
  e || (e = new PT(t));
  var s = [];
  return Sd(e, e._ps, i ? [i] : [], s, r, void 0, void 0), wT(s), cx(null), n || (t.__CROACT__ = e), e;
}
function gw(i, t, e) {
  return !e && i && (e = new PT(t.parentElement), e._hyd = [t], e._sel = !0), gL(i, t, e), e;
}
function OT(i) {
  var t = ST(), e = t._hs || (t._hs = []), r = iL(), n = e[r];
  if (nL(r + 1), n) {
    if (!wv(n.deps, i.deps))
      return n.updated = !1, n;
    e[r] = i;
  } else
    e.push(i);
  return i.value = i.func(), i.updated = !0, i;
}
function mL(i, t) {
  var e = OT({
    func: i,
    deps: t
  });
  return e.value;
}
function yL(i) {
  return mL(function() {
    return CT(i);
  }, []);
}
function IT(i, t, e) {
  var r = ST(), n = OT({
    func: function() {
      return i;
    },
    deps: t
  }), s = e ? r._usefs : r._uefs;
  n.updated ? s.push(function() {
    return n.effect && n.effect(), n.effect = i(), n.effect;
  }) : s.push(function() {
    return n.effect;
  });
}
function _L(i, t, e) {
  IT(function() {
    i == null || i(t());
  }, e, !0);
}
function px(i, t) {
  for (var e = i.length, r = 0; r < e; ++r)
    if (t(i[r], r))
      return !0;
  return !1;
}
function RT(i, t) {
  for (var e = i.length, r = 0; r < e; ++r)
    if (t(i[r], r))
      return i[r];
  return null;
}
function DT(i) {
  var t = i;
  if (typeof t > "u") {
    if (typeof navigator > "u" || !navigator)
      return "";
    t = navigator.userAgent || "";
  }
  return t.toLowerCase();
}
function vx(i, t) {
  try {
    return new RegExp(i, "g").exec(t);
  } catch {
    return null;
  }
}
function bL() {
  if (typeof navigator > "u" || !navigator || !navigator.userAgentData)
    return !1;
  var i = navigator.userAgentData, t = i.brands || i.uaList;
  return !!(t && t.length);
}
function xL(i, t) {
  var e = vx("(" + i + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", t);
  return e ? e[3] : "";
}
function h_(i) {
  return i.replace(/_/g, ".");
}
function Rh(i, t) {
  var e = null, r = "-1";
  return px(i, function(n) {
    var s = vx("(" + n.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", t);
    return !s || n.brand ? !1 : (e = n, r = s[3] || "-1", n.versionAlias ? r = n.versionAlias : n.versionTest && (r = xL(n.versionTest.toLowerCase(), t) || r), r = h_(r), !0);
  }), {
    preset: e,
    version: r
  };
}
function Sh(i, t) {
  var e = {
    brand: "",
    version: "-1"
  };
  return px(i, function(r) {
    var n = kT(t, r);
    return n ? (e.brand = r.id, e.version = r.versionAlias || n.version, e.version !== "-1") : !1;
  }), e;
}
function kT(i, t) {
  return RT(i, function(e) {
    var r = e.brand;
    return vx("" + t.test, r.toLowerCase());
  });
}
var c_ = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}], NT = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: !0
}], f_ = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}], AT = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}], LT = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];
function BT(i) {
  return !!Rh(AT, i).preset;
}
function wL(i) {
  var t = DT(i), e = !!/mobi/g.exec(t), r = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: BT(t),
    chromium: !1,
    chromiumVersion: "-1",
    webkit: !1,
    webkitVersion: "-1"
  }, n = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  }, s = Rh(c_, t), a = s.preset, o = s.version, u = Rh(LT, t), l = u.preset, h = u.version, d = Rh(NT, t);
  if (r.chromium = !!d.preset, r.chromiumVersion = d.version, !r.chromium) {
    var f = Rh(f_, t);
    r.webkit = !!f.preset, r.webkitVersion = f.version;
  }
  return l && (n.name = l.id, n.version = h, n.majorVersion = parseInt(h, 10)), a && (r.name = a.id, r.version = o, r.webview && n.name === "ios" && r.name !== "safari" && (r.webview = !1)), r.majorVersion = parseInt(r.version, 10), {
    browser: r,
    os: n,
    isMobile: e,
    isHints: !1
  };
}
function EL(i) {
  var t = navigator.userAgentData, e = (t.uaList || t.brands).slice(), r = i && i.fullVersionList, n = t.mobile || !1, s = e[0], a = (i && i.platform || t.platform || navigator.platform).toLowerCase(), o = {
    name: s.brand,
    version: s.version,
    majorVersion: -1,
    webkit: !1,
    webkitVersion: "-1",
    chromium: !1,
    chromiumVersion: "-1",
    webview: !!Sh(AT, e).brand || BT(DT())
  }, u = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  o.webkit = !o.chromium && px(f_, function(v) {
    return kT(e, v);
  });
  var l = Sh(NT, e);
  if (o.chromium = !!l.brand, o.chromiumVersion = l.version, !o.chromium) {
    var h = Sh(f_, e);
    o.webkit = !!h.brand, o.webkitVersion = h.version;
  }
  var d = RT(LT, function(v) {
    return new RegExp("" + v.test, "g").exec(a);
  });
  if (u.name = d ? d.id : "", i && (u.version = i.platformVersion), r && r.length) {
    var f = Sh(c_, r);
    o.name = f.brand || o.name, o.version = f.version || o.version;
  } else {
    var p = Sh(c_, e);
    o.name = p.brand || o.name, o.version = p.brand && i ? i.uaFullVersion : p.version;
  }
  return o.webkit && (u.name = n ? "ios" : "mac"), u.name === "ios" && o.webview && (o.version = "-1"), u.version = h_(u.version), o.version = h_(o.version), u.majorVersion = parseInt(u.version, 10), o.majorVersion = parseInt(o.version, 10), {
    browser: o,
    os: u,
    isMobile: n,
    isHints: !0
  };
}
function SL(i) {
  return typeof i > "u" && bL() ? EL() : wL(i);
}
function TL(i, t, e, r, n, s) {
  for (var a = 0; a < n; ++a) {
    var o = e + a * n, u = r + a * n;
    i[o] += i[u] * s, t[o] += t[u] * s;
  }
}
function CL(i, t, e, r, n) {
  for (var s = 0; s < n; ++s) {
    var a = e + s * n, o = r + s * n, u = i[a], l = t[a];
    i[a] = i[o], i[o] = u, t[a] = t[o], t[o] = l;
  }
}
function ML(i, t, e, r, n) {
  for (var s = 0; s < r; ++s) {
    var a = e + s * r;
    i[a] /= n, t[a] /= n;
  }
}
function FT(i, t, e) {
  e === void 0 && (e = Math.sqrt(i.length));
  for (var r = i.slice(), n = 0; n < e; ++n)
    r[n * e + t - 1] = 0, r[(t - 1) * e + n] = 0;
  return r[(t - 1) * (e + 1)] = 1, r;
}
function Nn(i, t) {
  t === void 0 && (t = Math.sqrt(i.length));
  for (var e = i.slice(), r = Oe(t), n = 0; n < t; ++n) {
    var s = t * n + n;
    if (!Gt(e[s], Je)) {
      for (var a = n + 1; a < t; ++a)
        if (e[t * n + a]) {
          CL(e, r, n, a, t);
          break;
        }
    }
    if (!Gt(e[s], Je))
      return [];
    ML(e, r, n, t, e[s]);
    for (var a = 0; a < t; ++a) {
      var o = a, u = a + n * t, l = e[u];
      !Gt(l, Je) || n === a || TL(e, r, o, n, t, -l);
    }
  }
  return r;
}
function PL(i, t) {
  t === void 0 && (t = Math.sqrt(i.length));
  for (var e = [], r = 0; r < t; ++r)
    for (var n = 0; n < t; ++n)
      e[n * t + r] = i[t * r + n];
  return e;
}
function GT(i, t) {
  t === void 0 && (t = Math.sqrt(i.length));
  for (var e = [], r = i[t * t - 1], n = 0; n < t - 1; ++n)
    e[n] = i[t * (t - 1) + n] / r;
  return e[t - 1] = 0, e;
}
function OL(i, t) {
  for (var e = Oe(t), r = 0; r < t - 1; ++r)
    e[t * (t - 1) + r] = i[r] || 0;
  return e;
}
function tu(i, t) {
  for (var e = i.slice(), r = i.length; r < t - 1; ++r)
    e[r] = 0;
  return e[t - 1] = 1, e;
}
function An(i, t, e) {
  if (t === void 0 && (t = Math.sqrt(i.length)), t === e)
    return i;
  for (var r = Oe(e), n = Math.min(t, e), s = 0; s < n - 1; ++s) {
    for (var a = 0; a < n - 1; ++a)
      r[s * e + a] = i[s * t + a];
    r[(s + 1) * e - 1] = i[(s + 1) * t - 1], r[(e - 1) * e + s] = i[(t - 1) * t + s];
  }
  return r[e * e - 1] = i[t * t - 1], r;
}
function d_(i) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  var r = Oe(i);
  return t.forEach(function(n) {
    r = _e(r, n, i);
  }), r;
}
function _e(i, t, e) {
  e === void 0 && (e = Math.sqrt(i.length));
  var r = [], n = i.length / e, s = t.length / n;
  if (n) {
    if (!s)
      return i;
  } else
    return t;
  for (var a = 0; a < e; ++a)
    for (var o = 0; o < s; ++o) {
      r[o * e + a] = 0;
      for (var u = 0; u < n; ++u)
        r[o * e + a] += i[u * e + a] * t[o * n + u];
    }
  return r;
}
function Jt(i, t) {
  for (var e = Math.min(i.length, t.length), r = i.slice(), n = 0; n < e; ++n)
    r[n] = r[n] + t[n];
  return r;
}
function Mt(i, t) {
  for (var e = Math.min(i.length, t.length), r = i.slice(), n = 0; n < e; ++n)
    r[n] = r[n] - t[n];
  return r;
}
function IL(i, t) {
  return t === void 0 && (t = i.length === 6), t ? [i[0], i[1], 0, i[2], i[3], 0, i[4], i[5], 1] : i;
}
function UT(i, t) {
  return t === void 0 && (t = i.length === 9), t ? [i[0], i[1], i[3], i[4], i[6], i[7]] : i;
}
function br(i, t, e) {
  e === void 0 && (e = t.length);
  var r = _e(i, t, e), n = r[e - 1];
  return r.map(function(s) {
    return s / n;
  });
}
function RL(i, t) {
  return _e(i, [1, 0, 0, 0, 0, Math.cos(t), Math.sin(t), 0, 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1], 4);
}
function DL(i, t) {
  return _e(i, [Math.cos(t), 0, -Math.sin(t), 0, 0, 1, 0, 0, Math.sin(t), 0, Math.cos(t), 0, 0, 0, 0, 1], 4);
}
function kL(i, t) {
  return _e(i, Cd(t, 4));
}
function up(i, t) {
  var e = t[0], r = e === void 0 ? 1 : e, n = t[1], s = n === void 0 ? 1 : n, a = t[2], o = a === void 0 ? 1 : a;
  return _e(i, [r, 0, 0, 0, 0, s, 0, 0, 0, 0, o, 0, 0, 0, 0, 1], 4);
}
function Td(i, t) {
  return br(Cd(t, 3), tu(i, 3));
}
function iy(i, t) {
  var e = t[0], r = e === void 0 ? 0 : e, n = t[1], s = n === void 0 ? 0 : n, a = t[2], o = a === void 0 ? 0 : a;
  return _e(i, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, r, s, o, 1], 4);
}
function mw(i, t) {
  return _e(i, t, 4);
}
function Cd(i, t) {
  var e = Math.cos(i), r = Math.sin(i), n = Oe(t);
  return n[0] = e, n[1] = r, n[t] = -r, n[t + 1] = e, n;
}
function Oe(i) {
  for (var t = i * i, e = [], r = 0; r < t; ++r)
    e[r] = r % (i + 1) ? 0 : 1;
  return e;
}
function Ev(i, t) {
  for (var e = Oe(t), r = Math.min(i.length, t - 1), n = 0; n < r; ++n)
    e[(t + 1) * n] = i[n];
  return e;
}
function vc(i, t) {
  for (var e = Oe(t), r = Math.min(i.length, t - 1), n = 0; n < r; ++n)
    e[t * (t - 1) + n] = i[n];
  return e;
}
function gx(i, t, e, r, n, s, a, o) {
  var u = i[0], l = i[1], h = t[0], d = t[1], f = e[0], p = e[1], v = r[0], g = r[1], m = n[0], y = n[1], _ = s[0], b = s[1], w = a[0], T = a[1], x = o[0], S = o[1], C = [u, 0, h, 0, f, 0, v, 0, l, 0, d, 0, p, 0, g, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, u, 0, h, 0, f, 0, v, 0, l, 0, d, 0, p, 0, g, 0, 1, 0, 1, 0, 1, 0, 1, -m * u, -y * u, -_ * h, -b * h, -w * f, -T * f, -x * v, -S * v, -m * l, -y * l, -_ * d, -b * d, -w * p, -T * p, -x * g, -S * g], M = Nn(C, 8);
  if (!M.length)
    return [];
  var I = _e(M, [m, y, _, b, w, T, x, S], 8);
  return I[8] = 1, An(PL(I), 3, 4);
}
function NL() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function mx(i) {
  return _u(Ra(i));
}
function AL(i, t) {
  var e = br(i, [t[0], t[1] || 0, t[2] || 0, 1], 4), r = e[3] || 1;
  return [e[0] / r, e[1] / r, e[2] / r];
}
function _u(i) {
  var t = NL();
  return i.forEach(function(e) {
    var r = e.matrixFunction, n = e.functionValue;
    r && (t = r(t, n));
  }), t;
}
function Ra(i) {
  var t = tr(i) ? i : ca(i);
  return t.map(function(e) {
    var r = pT(e), n = r.prefix, s = r.value, a = null, o = n, u = "";
    if (n === "translate" || n === "translateX" || n === "translate3d") {
      var l = Fa(s).map(function(I) {
        return parseFloat(I);
      }), h = l[0], d = l[1], f = d === void 0 ? 0 : d, p = l[2], v = p === void 0 ? 0 : p;
      a = iy, u = [h, f, v];
    } else if (n === "translateY") {
      var f = parseFloat(s);
      a = iy, u = [0, f, 0];
    } else if (n === "translateZ") {
      var v = parseFloat(s);
      a = iy, u = [0, 0, v];
    } else if (n === "scale" || n === "scale3d") {
      var g = Fa(s).map(function(I) {
        return parseFloat(I);
      }), m = g[0], y = g[1], _ = y === void 0 ? m : y, b = g[2], w = b === void 0 ? 1 : b;
      a = up, u = [m, _, w];
    } else if (n === "scaleX") {
      var m = parseFloat(s);
      a = up, u = [m, 1, 1];
    } else if (n === "scaleY") {
      var _ = parseFloat(s);
      a = up, u = [1, _, 1];
    } else if (n === "scaleZ") {
      var w = parseFloat(s);
      a = up, u = [1, 1, w];
    } else if (n === "rotate" || n === "rotateZ" || n === "rotateX" || n === "rotateY") {
      var T = xd(s), x = T.unit, S = T.value, C = x === "rad" ? S : S * Math.PI / 180;
      n === "rotate" || n === "rotateZ" ? (o = "rotateZ", a = kL) : n === "rotateX" ? a = RL : n === "rotateY" && (a = DL), u = C;
    } else if (n === "matrix3d")
      a = mw, u = Fa(s).map(function(I) {
        return parseFloat(I);
      });
    else if (n === "matrix") {
      var M = Fa(s).map(function(I) {
        return parseFloat(I);
      });
      a = mw, u = [M[0], M[1], 0, 0, M[2], M[3], 0, 0, 0, 0, 1, 0, M[4], M[5], 0, 1];
    } else
      o = "";
    return {
      name: n,
      functionName: o,
      value: s,
      matrixFunction: a,
      functionValue: u
    };
  });
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var p_ = function(i, t) {
  return p_ = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, p_(i, t);
};
function LL(i, t) {
  p_(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var jT = typeof Map == "function" ? void 0 : function() {
  var i = 0;
  return function(t) {
    return t.__DIFF_KEY__ || (t.__DIFF_KEY__ = ++i);
  };
}(), BL = /* @__PURE__ */ function(i) {
  LL(t, i);
  function t(e) {
    return e === void 0 && (e = []), i.call(this, e, jT) || this;
  }
  return t;
}(eL);
function FL(i, t) {
  return wd(i, t, jT);
}
const zT = BL;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var v_ = function() {
  return v_ = Object.assign || function(t) {
    for (var e, r = 1, n = arguments.length; r < n; r++) {
      e = arguments[r];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
    }
    return t;
  }, v_.apply(this, arguments);
};
function GL() {
  for (var i = 0, t = 0, e = arguments.length; t < e; t++)
    i += arguments[t].length;
  for (var r = Array(i), n = 0, t = 0; t < e; t++)
    for (var s = arguments[t], a = 0, o = s.length; a < o; a++, n++)
      r[n] = s[a];
  return r;
}
var UL = /* @__PURE__ */ function() {
  function i() {
    this._events = {};
  }
  var t = i.prototype;
  return t.on = function(e, r) {
    if (ha(e))
      for (var n in e)
        this.on(n, e[n]);
    else
      this._addEvent(e, r, {});
    return this;
  }, t.off = function(e, r) {
    if (!e)
      this._events = {};
    else if (ha(e))
      for (var n in e)
        this.off(n);
    else if (!r)
      this._events[e] = [];
    else {
      var s = this._events[e];
      if (s) {
        var a = Ms(s, function(o) {
          return o.listener === r;
        });
        a > -1 && s.splice(a, 1);
      }
    }
    return this;
  }, t.once = function(e, r) {
    var n = this;
    return r && this._addEvent(e, r, {
      once: !0
    }), new Promise(function(s) {
      n._addEvent(e, s, {
        once: !0
      });
    });
  }, t.emit = function(e, r) {
    var n = this;
    r === void 0 && (r = {});
    var s = this._events[e];
    if (!e || !s)
      return !0;
    var a = !1;
    return r.eventType = e, r.stop = function() {
      a = !0;
    }, r.currentTarget = this, GL(s).forEach(function(o) {
      o.listener(r), o.once && n.off(e, o.listener);
    }), !a;
  }, t.trigger = function(e, r) {
    return r === void 0 && (r = {}), this.emit(e, r);
  }, t._addEvent = function(e, r, n) {
    var s = this._events;
    s[e] = s[e] || [];
    var a = s[e];
    a.push(v_({
      listener: r
    }, n));
  }, i;
}();
const l0 = UL;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var g_ = function(i, t) {
  return g_ = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, g_(i, t);
};
function jL(i, t) {
  g_(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Iu = function() {
  return Iu = Object.assign || function(t) {
    for (var e, r = 1, n = arguments.length; r < n; r++) {
      e = arguments[r];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
    }
    return t;
  }, Iu.apply(this, arguments);
};
function zL(i) {
  var t = i.container;
  return t === document.body ? [t.scrollLeft || document.documentElement.scrollLeft, t.scrollTop || document.documentElement.scrollTop] : [t.scrollLeft, t.scrollTop];
}
function yw(i, t) {
  return i.addEventListener("scroll", t), function() {
    i.removeEventListener("scroll", t);
  };
}
function lp(i) {
  if (i) {
    if ($r(i))
      return document.querySelector(i);
  } else
    return null;
  if (ax(i))
    return i();
  if (i instanceof Element)
    return i;
  if ("current" in i)
    return i.current;
  if ("value" in i)
    return i.value;
}
var HL = /* @__PURE__ */ function(i) {
  jL(t, i);
  function t() {
    var r = i !== null && i.apply(this, arguments) || this;
    return r._startRect = null, r._startPos = [], r._prevTime = 0, r._timer = 0, r._prevScrollPos = [0, 0], r._isWait = !1, r._flag = !1, r._currentOptions = null, r._lock = !1, r._unregister = null, r._onScroll = function() {
      var n = r._currentOptions;
      r._lock || !n || r.emit("scrollDrag", {
        next: function(s) {
          r.checkScroll({
            container: n.container,
            inputEvent: s
          });
        }
      });
    }, r;
  }
  var e = t.prototype;
  return e.dragStart = function(r, n) {
    var s = lp(n.container);
    if (!s) {
      this._flag = !1;
      return;
    }
    var a = 0, o = 0, u = 0, l = 0;
    if (s === document.body)
      u = window.innerWidth, l = window.innerHeight;
    else {
      var h = s.getBoundingClientRect();
      a = h.top, o = h.left, u = h.width, l = h.height;
    }
    this._flag = !0, this._startPos = [r.clientX, r.clientY], this._startRect = {
      top: a,
      left: o,
      width: u,
      height: l
    }, this._prevScrollPos = this._getScrollPosition([0, 0], n), this._currentOptions = n, this._registerScrollEvent(n);
  }, e.drag = function(r, n) {
    if (clearTimeout(this._timer), !!this._flag) {
      var s = r.clientX, a = r.clientY, o = n.threshold, u = o === void 0 ? 0 : o, l = this, h = l._startRect, d = l._startPos;
      this._currentOptions = n;
      var f = [0, 0];
      return h.top > a - u ? (d[1] > h.top || a < d[1]) && (f[1] = -1) : h.top + h.height < a + u && (d[1] < h.top + h.height || a > d[1]) && (f[1] = 1), h.left > s - u ? (d[0] > h.left || s < d[0]) && (f[0] = -1) : h.left + h.width < s + u && (d[0] < h.left + h.width || s > d[0]) && (f[0] = 1), !f[0] && !f[1] ? !1 : this._continueDrag(Iu(Iu({}, n), {
        direction: f,
        inputEvent: r,
        isDrag: !0
      }));
    }
  }, e.checkScroll = function(r) {
    var n = this;
    if (this._isWait)
      return !1;
    var s = r.prevScrollPos, a = s === void 0 ? this._prevScrollPos : s, o = r.direction, u = r.throttleTime, l = u === void 0 ? 0 : u, h = r.inputEvent, d = r.isDrag, f = this._getScrollPosition(o || [0, 0], r), p = f[0] - a[0], v = f[1] - a[1], g = o || [p ? Math.abs(p) / p : 0, v ? Math.abs(v) / v : 0];
    return this._prevScrollPos = f, this._lock = !1, !p && !v ? !1 : (this.emit("move", {
      offsetX: g[0] ? p : 0,
      offsetY: g[1] ? v : 0,
      inputEvent: h
    }), l && d && (clearTimeout(this._timer), this._timer = window.setTimeout(function() {
      n._continueDrag(r);
    }, l)), !0);
  }, e.dragEnd = function() {
    this._flag = !1, this._lock = !1, clearTimeout(this._timer), this._unregisterScrollEvent();
  }, e._getScrollPosition = function(r, n) {
    var s = n.container, a = n.getScrollPosition, o = a === void 0 ? zL : a;
    return o({
      container: lp(s),
      direction: r
    });
  }, e._continueDrag = function(r) {
    var n = this, s, a = r.container, o = r.direction, u = r.throttleTime, l = r.useScroll, h = r.isDrag, d = r.inputEvent;
    if (!(!this._flag || h && this._isWait)) {
      var f = dc(), p = Math.max(u + this._prevTime - f, 0);
      if (p > 0)
        return clearTimeout(this._timer), this._timer = window.setTimeout(function() {
          n._continueDrag(r);
        }, p), !1;
      this._prevTime = f;
      var v = this._getScrollPosition(o, r);
      this._prevScrollPos = v, h && (this._isWait = !0), l || (this._lock = !0);
      var g = {
        container: lp(a),
        direction: o,
        inputEvent: d
      };
      return (s = r.requestScroll) === null || s === void 0 || s.call(r, g), this.emit("scroll", g), this._isWait = !1, l || this.checkScroll(Iu(Iu({}, r), {
        prevScrollPos: v,
        direction: o,
        inputEvent: d
      }));
    }
  }, e._registerScrollEvent = function(r) {
    this._unregisterScrollEvent();
    var n = r.checkScrollEvent;
    if (n) {
      var s = n === !0 ? yw : n, a = lp(r.container);
      n === !0 && (a === document.body || a === document.documentElement) ? this._unregister = yw(window, this._onScroll) : this._unregister = s(a, this._onScroll);
    }
  }, e._unregisterScrollEvent = function() {
    var r;
    (r = this._unregister) === null || r === void 0 || r.call(this), this._unregister = null;
  }, t;
}(l0);
const $L = HL;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function VL() {
  for (var i = 0, t = 0, e = arguments.length; t < e; t++)
    i += arguments[t].length;
  for (var r = Array(i), n = 0, t = 0; t < e; t++)
    for (var s = arguments[t], a = 0, o = s.length; a < o; a++, n++)
      r[n] = s[a];
  return r;
}
function Fr(i) {
  return Gt(i, Je);
}
function XL(i, t) {
  return i.every(function(e, r) {
    return Fr(e - t[r]) === 0;
  });
}
function WL(i, t) {
  return !Fr(i[0] - t[0]) && !Fr(i[1] - t[1]);
}
function HT(i) {
  return i.length < 3 ? 0 : Math.abs(XA(i.map(function(t, e) {
    var r = i[e + 1] || i[0];
    return t[0] * r[1] - r[0] * t[1];
  }))) / 2;
}
function _w(i, t) {
  var e = t.width, r = t.height, n = t.left, s = t.top, a = eu(i), o = a.minX, u = a.minY, l = a.maxX, h = a.maxY, d = e / (l - o), f = r / (h - u);
  return i.map(function(p) {
    return [n + (p[0] - o) * d, s + (p[1] - u) * f];
  });
}
function eu(i) {
  var t = i.map(function(r) {
    return r[0];
  }), e = i.map(function(r) {
    return r[1];
  });
  return {
    minX: Math.min.apply(Math, t),
    minY: Math.min.apply(Math, e),
    maxX: Math.max.apply(Math, t),
    maxY: Math.max.apply(Math, e)
  };
}
function m_(i, t, e) {
  var r = i[0], n = i[1], s = eu(t), a = s.minX, o = s.maxX, u = [[a, n], [o, n]], l = Sv(u[0], u[1]), h = y_(t), d = [];
  if (h.forEach(function(v) {
    var g = Sv(v[0], v[1]), m = v[0];
    if (XL(l, g))
      d.push({
        pos: i,
        line: v,
        type: "line"
      });
    else {
      var y = $T(yx(l, g), [u, v]);
      y.forEach(function(_) {
        v.some(function(b) {
          return WL(b, _);
        }) ? d.push({
          pos: _,
          line: v,
          type: "point"
        }) : Fr(m[1] - n) !== 0 && d.push({
          pos: _,
          line: v,
          type: "intersection"
        });
      });
    }
  }), !e && nn(d, function(v) {
    return v[0] === r;
  }))
    return !0;
  var f = 0, p = {};
  return d.forEach(function(v) {
    var g = v.pos, m = v.type, y = v.line;
    if (!(g[0] > r))
      if (m === "intersection")
        ++f;
      else {
        if (m === "line")
          return;
        if (m === "point") {
          var _ = nn(y, function(T) {
            return T[1] !== n;
          }), b = p[g[0]], w = _[1] > n ? 1 : -1;
          b ? b !== w && ++f : p[g[0]] = w;
        }
      }
  }), f % 2 === 1;
}
function Sv(i, t) {
  var e = i[0], r = i[1], n = t[0], s = t[1], a = n - e, o = s - r;
  Math.abs(a) < Je && (a = 0), Math.abs(o) < Je && (o = 0);
  var u = 0, l = 0, h = 0;
  return a ? o ? (u = -o / a, l = 1, h = -u * e - r) : (l = 1, h = -r) : o && (u = -1, h = e), [u, l, h];
}
function yx(i, t) {
  var e = i[0], r = i[1], n = i[2], s = t[0], a = t[1], o = t[2], u = e === 0 && s === 0, l = r === 0 && a === 0, h = [];
  if (u && l)
    return [];
  if (u) {
    var d = -n / r, f = -o / a;
    return d !== f ? [] : [[-1 / 0, d], [1 / 0, d]];
  } else if (l) {
    var p = -n / e, v = -o / s;
    return p !== v ? [] : [[p, -1 / 0], [p, 1 / 0]];
  } else if (e === 0) {
    var g = -n / r, m = -(a * g + o) / s;
    h = [[m, g]];
  } else if (s === 0) {
    var g = -o / a, m = -(r * g + n) / e;
    h = [[m, g]];
  } else if (r === 0) {
    var m = -n / e, g = -(s * m + o) / a;
    h = [[m, g]];
  } else if (a === 0) {
    var m = -o / s, g = -(e * m + n) / r;
    h = [[m, g]];
  } else {
    var m = (r * o - a * n) / (a * e - r * s), g = -(e * m + n) / r;
    h = [[m, g]];
  }
  return h.map(function(y) {
    return [y[0], y[1]];
  });
}
function $T(i, t) {
  var e = t.map(function(d) {
    return [0, 1].map(function(f) {
      return [Math.min(d[0][f], d[1][f]), Math.max(d[0][f], d[1][f])];
    });
  }), r = [];
  if (i.length === 2) {
    var n = i[0], s = n[0], a = n[1];
    if (Fr(s - i[1][0])) {
      if (!Fr(a - i[1][1])) {
        var l = Math.max.apply(Math, e.map(function(d) {
          return d[0][0];
        })), h = Math.min.apply(Math, e.map(function(d) {
          return d[0][1];
        }));
        if (Fr(l - h) > 0)
          return [];
        r = [[l, a], [h, a]];
      }
    } else {
      var o = Math.max.apply(Math, e.map(function(d) {
        return d[1][0];
      })), u = Math.min.apply(Math, e.map(function(d) {
        return d[1][1];
      }));
      if (Fr(o - u) > 0)
        return [];
      r = [[s, o], [s, u]];
    }
  }
  return r.length || (r = i.filter(function(d) {
    var f = d[0], p = d[1];
    return e.every(function(v) {
      return 0 <= Fr(f - v[0][0]) && 0 <= Fr(v[0][1] - f) && 0 <= Fr(p - v[1][0]) && 0 <= Fr(v[1][1] - p);
    });
  })), r.map(function(d) {
    return [Fr(d[0]), Fr(d[1])];
  });
}
function y_(i) {
  return VL(i.slice(1), [i[0]]).map(function(t, e) {
    return [i[e], t];
  });
}
function YL(i, t) {
  var e = i.slice(), r = t.slice();
  u_(e) === -1 && e.reverse(), u_(r) === -1 && r.reverse();
  var n = y_(e), s = y_(r), a = n.map(function(h) {
    return Sv(h[0], h[1]);
  }), o = s.map(function(h) {
    return Sv(h[0], h[1]);
  }), u = [];
  a.forEach(function(h, d) {
    var f = n[d], p = [];
    o.forEach(function(v, g) {
      var m = yx(h, v), y = $T(m, [f, s[g]]);
      p.push.apply(p, y.map(function(_) {
        return {
          index1: d,
          index2: g,
          pos: _,
          type: "intersection"
        };
      }));
    }), p.sort(function(v, g) {
      return Zi(f[0], v.pos) - Zi(f[0], g.pos);
    }), u.push.apply(u, p), m_(f[1], r) && u.push({
      index1: d,
      index2: -1,
      pos: f[1],
      type: "inside"
    });
  }), s.forEach(function(h, d) {
    if (m_(h[1], e)) {
      var f = !1, p = Ms(u, function(v) {
        var g = v.index2;
        return g === d ? (f = !0, !1) : !!f;
      });
      p === -1 && (f = !1, p = Ms(u, function(v) {
        var g = v.index1, m = v.index2;
        return g === -1 && m + 1 === d ? (f = !0, !1) : !!f;
      })), p === -1 ? u.push({
        index1: -1,
        index2: d,
        pos: h[1],
        type: "inside"
      }) : u.splice(p, 0, {
        index1: -1,
        index2: d,
        pos: h[1],
        type: "inside"
      });
    }
  });
  var l = {};
  return u.filter(function(h) {
    var d = h.pos, f = d[0] + "x" + d[1];
    return l[f] ? !1 : (l[f] = !0, !0);
  });
}
function qL(i, t) {
  var e = YL(i, t);
  return e.map(function(r) {
    var n = r.pos;
    return n;
  });
}
function ZL(i, t) {
  var e = qL(i, t);
  return HT(e);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __ = function(i, t) {
  return __ = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      r.hasOwnProperty(n) && (e[n] = r[n]);
  }, __(i, t);
};
function KL(i, t) {
  __(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Xe = function() {
  return Xe = Object.assign || function(t) {
    for (var e, r = 1, n = arguments.length; r < n; r++) {
      e = arguments[r];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
    }
    return t;
  }, Xe.apply(this, arguments);
};
function JL(i, t) {
  var e = t[0] - i[0], r = t[1] - i[1], n = Math.atan2(r, e);
  return n >= 0 ? n : n + Math.PI * 2;
}
function ny(i) {
  return JL([
    i[0].clientX,
    i[0].clientY
  ], [
    i[1].clientX,
    i[1].clientY
  ]) / Math.PI * 180;
}
function QL(i) {
  return i.touches && i.touches.length >= 2;
}
function hp(i) {
  return i ? i.touches ? eB(i.touches) : [VT(i)] : [];
}
function tB(i) {
  return i && (i.type.indexOf("mouse") > -1 || "button" in i);
}
function bw(i, t, e) {
  var r = e.length, n = Yh(i, r), s = n.clientX, a = n.clientY, o = n.originalClientX, u = n.originalClientY, l = Yh(t, r), h = l.clientX, d = l.clientY, f = Yh(e, r), p = f.clientX, v = f.clientY, g = s - h, m = a - d, y = s - p, _ = a - v;
  return {
    clientX: o,
    clientY: u,
    deltaX: g,
    deltaY: m,
    distX: y,
    distY: _
  };
}
function sy(i) {
  return Math.sqrt(Math.pow(i[0].clientX - i[1].clientX, 2) + Math.pow(i[0].clientY - i[1].clientY, 2));
}
function eB(i) {
  for (var t = Math.min(i.length, 2), e = [], r = 0; r < t; ++r)
    e.push(VT(i[r]));
  return e;
}
function VT(i) {
  return {
    clientX: i.clientX,
    clientY: i.clientY
  };
}
function Yh(i, t) {
  t === void 0 && (t = i.length);
  for (var e = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  }, r = 0; r < t; ++r) {
    var n = i[r];
    e.originalClientX += "originalClientX" in n ? n.originalClientX : n.clientX, e.originalClientY += "originalClientY" in n ? n.originalClientY : n.clientY, e.clientX += n.clientX, e.clientY += n.clientY;
  }
  return t ? {
    clientX: e.clientX / t,
    clientY: e.clientY / t,
    originalClientX: e.originalClientX / t,
    originalClientY: e.originalClientY / t
  } : e;
}
var ay = /* @__PURE__ */ function() {
  function i(t) {
    this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = t, this.prevClients = t, this.length = t.length;
  }
  return i.prototype.getAngle = function(t) {
    return t === void 0 && (t = this.prevClients), ny(t);
  }, i.prototype.getRotation = function(t) {
    return t === void 0 && (t = this.prevClients), ny(t) - ny(this.startClients);
  }, i.prototype.getPosition = function(t, e) {
    t === void 0 && (t = this.prevClients);
    var r = bw(t || this.prevClients, this.prevClients, this.startClients), n = r.deltaX, s = r.deltaY;
    return this.movement += Math.sqrt(n * n + s * s), this.prevClients = t, r;
  }, i.prototype.getPositions = function(t) {
    t === void 0 && (t = this.prevClients);
    var e = this.prevClients;
    return this.startClients.map(function(r, n) {
      return bw([t[n]], [e[n]], [r]);
    });
  }, i.prototype.getMovement = function(t) {
    var e = this.movement;
    if (!t)
      return e;
    var r = Yh(t, this.length), n = Yh(this.prevClients, this.length), s = r.clientX - n.clientX, a = r.clientY - n.clientY;
    return Math.sqrt(s * s + a * a) + e;
  }, i.prototype.getDistance = function(t) {
    return t === void 0 && (t = this.prevClients), sy(t);
  }, i.prototype.getScale = function(t) {
    return t === void 0 && (t = this.prevClients), sy(t) / sy(this.startClients);
  }, i.prototype.move = function(t, e) {
    this.startClients.forEach(function(r) {
      r.clientX -= t, r.clientY -= e;
    }), this.prevClients.forEach(function(r) {
      r.clientX -= t, r.clientY -= e;
    });
  }, i;
}(), xw = ["textarea", "input"], rB = /* @__PURE__ */ function(i) {
  KL(t, i);
  function t(e, r) {
    r === void 0 && (r = {});
    var n = i.call(this) || this;
    n.options = {}, n.flag = !1, n.pinchFlag = !1, n.data = {}, n.isDrag = !1, n.isPinch = !1, n.isMouse = !1, n.isTouch = !1, n.clientStores = [], n.targets = [], n.prevTime = 0, n.doubleFlag = !1, n._dragFlag = !1, n._isTrusted = !1, n._isMouseEvent = !1, n._isSecondaryButton = !1, n._preventMouseEvent = !1, n._prevInputEvent = null, n.onDragStart = function(d, f) {
      if (f === void 0 && (f = !0), !(!n.flag && d.cancelable === !1)) {
        var p = n.options, v = p.container, g = p.pinchOutside, m = p.preventWheelClick, y = p.preventRightClick, _ = p.preventDefault, b = p.checkInput, w = p.dragFocusedInput, T = p.preventClickEventOnDragStart, x = p.preventClickEventOnDrag, S = p.preventClickEventByCondition, C = n.isTouch, M = !n.flag;
        if (n._isSecondaryButton = d.which === 3 || d.button === 2, m && (d.which === 2 || d.button === 1) || y && (d.which === 3 || d.button === 2))
          return n.stop(), !1;
        if (M) {
          var I = document.activeElement, R = d.target;
          if (R) {
            var N = R.tagName.toLowerCase(), A = xw.indexOf(N) > -1, G = R.isContentEditable;
            if (A || G) {
              if (b || !w && I === R || I && G && I.isContentEditable && I.contains(R))
                return !1;
            } else if ((_ || d.type === "touchstart") && I) {
              var B = I.tagName.toLowerCase();
              (I.isContentEditable || xw.indexOf(B) > -1) && I.blur();
            }
            (T || x || S) && Dr(window, "click", n._onClick, !0);
          }
          n.clientStores = [new ay(hp(d))], n.flag = !0, n.isDrag = !1, n._isTrusted = f, n._dragFlag = !0, n._prevInputEvent = d, n.data = {}, n.doubleFlag = dc() - n.prevTime < 200, n._isMouseEvent = tB(d), !n._isMouseEvent && n._preventMouseEvent && (n._preventMouseEvent = !1);
          var U = n._preventMouseEvent || n.emit("dragStart", Xe(Xe({ data: n.data, datas: n.data, inputEvent: d, isMouseEvent: n._isMouseEvent, isSecondaryButton: n._isSecondaryButton, isTrusted: f, isDouble: n.doubleFlag }, n.getCurrentStore().getPosition()), { preventDefault: function() {
            d.preventDefault();
          }, preventDrag: function() {
            n._dragFlag = !1;
          } }));
          U === !1 && n.stop(), n._isMouseEvent && n.flag && _ && d.preventDefault();
        }
        if (!n.flag)
          return !1;
        var $ = 0;
        if (M ? (n._attchDragEvent(), C && g && ($ = setTimeout(function() {
          Dr(v, "touchstart", n.onDragStart, {
            passive: !1
          });
        }))) : C && g && gr(v, "touchstart", n.onDragStart), n.flag && QL(d)) {
          if (clearTimeout($), M && d.touches.length !== d.changedTouches.length)
            return;
          n.pinchFlag || n.onPinchStart(d);
        }
      }
    }, n.onDrag = function(d, f) {
      if (n.flag) {
        var p = n.options.preventDefault;
        !n._isMouseEvent && p && d.preventDefault(), n._prevInputEvent = d;
        var v = hp(d), g = n.moveClients(v, d, !1);
        if (n._dragFlag) {
          if (n.pinchFlag || g.deltaX || g.deltaY) {
            var m = n._preventMouseEvent || n.emit("drag", Xe(Xe({}, g), { isScroll: !!f, inputEvent: d }));
            if (m === !1) {
              n.stop();
              return;
            }
          }
          n.pinchFlag && n.onPinch(d, v);
        }
        n.getCurrentStore().getPosition(v, !0);
      }
    }, n.onDragEnd = function(d) {
      if (n.flag) {
        var f = n.options, p = f.pinchOutside, v = f.container, g = f.preventClickEventOnDrag, m = f.preventClickEventOnDragStart, y = f.preventClickEventByCondition, _ = n.isDrag;
        (g || m || y) && requestAnimationFrame(function() {
          n._allowClickEvent();
        }), !y && !m && g && !_ && n._allowClickEvent(), n.isTouch && p && gr(v, "touchstart", n.onDragStart), n.pinchFlag && n.onPinchEnd(d);
        var b = d != null && d.touches ? hp(d) : [], w = b.length;
        w === 0 || !n.options.keepDragging ? n.flag = !1 : n._addStore(new ay(b));
        var T = n._getPosition(), x = dc(), S = !_ && n.doubleFlag;
        n._prevInputEvent = null, n.prevTime = _ || S ? 0 : x, n.flag || (n._dettachDragEvent(), n._preventMouseEvent || n.emit("dragEnd", Xe({ data: n.data, datas: n.data, isDouble: S, isDrag: _, isClick: !_, isMouseEvent: n._isMouseEvent, isSecondaryButton: n._isSecondaryButton, inputEvent: d, isTrusted: n._isTrusted }, T)), n.clientStores = [], n._isMouseEvent || (n._preventMouseEvent = !0, requestAnimationFrame(function() {
          requestAnimationFrame(function() {
            n._preventMouseEvent = !1;
          });
        })));
      }
    }, n.onBlur = function() {
      n.onDragEnd();
    }, n._allowClickEvent = function() {
      gr(window, "click", n._onClick, !0);
    }, n._onClick = function(d) {
      n._allowClickEvent(), n._preventMouseEvent = !1;
      var f = n.options.preventClickEventByCondition;
      f != null && f(d) || (d.stopPropagation(), d.preventDefault());
    }, n._onContextMenu = function(d) {
      var f = n.options;
      f.preventRightClick ? n.onDragEnd(d) : d.preventDefault();
    }, n._passCallback = function() {
    };
    var s = [].concat(e);
    n.options = Xe({ checkInput: !1, container: s.length > 1 ? window : s[0], preventRightClick: !0, preventWheelClick: !0, preventClickEventOnDragStart: !1, preventClickEventOnDrag: !1, preventClickEventByCondition: null, preventDefault: !0, checkWindowBlur: !1, keepDragging: !1, pinchThreshold: 0, events: ["touch", "mouse"] }, r);
    var a = n.options, o = a.container, u = a.events, l = a.checkWindowBlur;
    if (n.isTouch = u.indexOf("touch") > -1, n.isMouse = u.indexOf("mouse") > -1, n.targets = s, n.isMouse && (s.forEach(function(d) {
      Dr(d, "mousedown", n.onDragStart), Dr(d, "mousemove", n._passCallback);
    }), Dr(o, "contextmenu", n._onContextMenu)), l && Dr(window, "blur", n.onBlur), n.isTouch) {
      var h = {
        passive: !1
      };
      s.forEach(function(d) {
        Dr(d, "touchstart", n.onDragStart, h), Dr(d, "touchmove", n._passCallback, h);
      });
    }
    return n;
  }
  return t.prototype.stop = function() {
    this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._allowClickEvent(), this._dettachDragEvent();
  }, t.prototype.getMovement = function(e) {
    return this.getCurrentStore().getMovement(e) + this.clientStores.slice(1).reduce(function(r, n) {
      return r + n.movement;
    }, 0);
  }, t.prototype.isDragging = function() {
    return this.isDrag;
  }, t.prototype.isFlag = function() {
    return this.flag;
  }, t.prototype.isPinchFlag = function() {
    return this.pinchFlag;
  }, t.prototype.isDoubleFlag = function() {
    return this.doubleFlag;
  }, t.prototype.isPinching = function() {
    return this.isPinch;
  }, t.prototype.scrollBy = function(e, r, n, s) {
    s === void 0 && (s = !0), this.flag && (this.clientStores[0].move(e, r), s && this.onDrag(n, !0));
  }, t.prototype.move = function(e, r) {
    var n = e[0], s = e[1], a = this.getCurrentStore(), o = a.prevClients;
    return this.moveClients(o.map(function(u) {
      var l = u.clientX, h = u.clientY;
      return {
        clientX: l + n,
        clientY: h + s,
        originalClientX: l,
        originalClientY: h
      };
    }), r, !0);
  }, t.prototype.triggerDragStart = function(e) {
    this.onDragStart(e, !1);
  }, t.prototype.setEventData = function(e) {
    var r = this.data;
    for (var n in e)
      r[n] = e[n];
    return this;
  }, t.prototype.setEventDatas = function(e) {
    return this.setEventData(e);
  }, t.prototype.getCurrentEvent = function(e) {
    return e === void 0 && (e = this._prevInputEvent), Xe(Xe({ data: this.data, datas: this.data }, this._getPosition()), { movement: this.getMovement(), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, inputEvent: e });
  }, t.prototype.getEventData = function() {
    return this.data;
  }, t.prototype.getEventDatas = function() {
    return this.data;
  }, t.prototype.unset = function() {
    var e = this, r = this.targets, n = this.options.container;
    this.off(), gr(window, "blur", this.onBlur), this.isMouse && (r.forEach(function(s) {
      gr(s, "mousedown", e.onDragStart);
    }), gr(n, "contextmenu", this._onContextMenu)), this.isTouch && (r.forEach(function(s) {
      gr(s, "touchstart", e.onDragStart);
    }), gr(n, "touchstart", this.onDragStart)), this._prevInputEvent = null, this._allowClickEvent(), this._dettachDragEvent();
  }, t.prototype.onPinchStart = function(e) {
    var r = this, n = this.options.pinchThreshold;
    if (!(this.isDrag && this.getMovement() > n)) {
      var s = new ay(hp(e));
      this.pinchFlag = !0, this._addStore(s);
      var a = this.emit("pinchStart", Xe(Xe({ data: this.data, datas: this.data, angle: s.getAngle(), touches: this.getCurrentStore().getPositions() }, s.getPosition()), { inputEvent: e, isTrusted: this._isTrusted, preventDefault: function() {
        e.preventDefault();
      }, preventDrag: function() {
        r._dragFlag = !1;
      } }));
      a === !1 && (this.pinchFlag = !1);
    }
  }, t.prototype.onPinch = function(e, r) {
    if (!(!this.flag || !this.pinchFlag || r.length < 2)) {
      var n = this.getCurrentStore();
      this.isPinch = !0, this.emit("pinch", Xe(Xe({ data: this.data, datas: this.data, movement: this.getMovement(r), angle: n.getAngle(r), rotation: n.getRotation(r), touches: n.getPositions(r), scale: n.getScale(r), distance: n.getDistance(r) }, n.getPosition(r)), { inputEvent: e, isTrusted: this._isTrusted }));
    }
  }, t.prototype.onPinchEnd = function(e) {
    if (this.pinchFlag) {
      var r = this.isPinch;
      this.isPinch = !1, this.pinchFlag = !1;
      var n = this.getCurrentStore();
      this.emit("pinchEnd", Xe(Xe({ data: this.data, datas: this.data, isPinch: r, touches: n.getPositions() }, n.getPosition()), { inputEvent: e }));
    }
  }, t.prototype.getCurrentStore = function() {
    return this.clientStores[0];
  }, t.prototype.moveClients = function(e, r, n) {
    var s = this._getPosition(e, n), a = this.isDrag;
    (s.deltaX || s.deltaY) && (this.isDrag = !0);
    var o = !1;
    return !a && this.isDrag && (o = !0), Xe(Xe({ data: this.data, datas: this.data }, s), { movement: this.getMovement(e), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, isMouseEvent: this._isMouseEvent, isSecondaryButton: this._isSecondaryButton, inputEvent: r, isTrusted: this._isTrusted, isFirstDrag: o });
  }, t.prototype._addStore = function(e) {
    this.clientStores.splice(0, 0, e);
  }, t.prototype._getPosition = function(e, r) {
    var n = this.getCurrentStore(), s = n.getPosition(e, r), a = this.clientStores.slice(1).reduce(function(l, h) {
      var d = h.getPosition();
      return l.distX += d.distX, l.distY += d.distY, l;
    }, s), o = a.distX, u = a.distY;
    return Xe(Xe({}, s), { distX: o, distY: u });
  }, t.prototype._attchDragEvent = function() {
    var e = this.options.container, r = {
      passive: !1
    };
    this.isMouse && (Dr(e, "mousemove", this.onDrag), Dr(e, "mouseup", this.onDragEnd)), this.isTouch && (Dr(e, "touchmove", this.onDrag, r), Dr(e, "touchend", this.onDragEnd, r), Dr(e, "touchcancel", this.onDragEnd, r));
  }, t.prototype._dettachDragEvent = function() {
    var e = this.options.container;
    this.isMouse && (gr(e, "mousemove", this.onDrag), gr(e, "mouseup", this.onDragEnd)), this.isTouch && (gr(e, "touchstart", this.onDragStart), gr(e, "touchmove", this.onDrag), gr(e, "touchend", this.onDragEnd), gr(e, "touchcancel", this.onDragEnd));
  }, t;
}(l0);
function iB(i) {
  for (var t = 5381, e = i.length; e; )
    t = t * 33 ^ i.charCodeAt(--e);
  return t >>> 0;
}
var nB = iB;
function sB(i) {
  return nB(i).toString(36);
}
function aB(i) {
  if (i && i.getRootNode) {
    var t = i.getRootNode();
    if (t.nodeType === 11)
      return t;
  }
}
function oB(i, t, e) {
  return e.original ? t : t.replace(/([^};{\s}][^};{]*|^\s*){/mg, function(r, n) {
    var s = n.trim();
    return (s ? Fa(s) : [""]).map(function(a) {
      var o = a.trim();
      return o.indexOf("@") === 0 ? o : o.indexOf(":global") > -1 ? o.replace(/\:global/g, "") : o.indexOf(":host") > -1 ? "" + o.replace(/\:host/g, "." + i) : o ? "." + i + " " + o : "." + i;
    }).join(", ") + " {";
  });
}
function uB(i, t, e, r) {
  var n = document.createElement("style");
  return n.setAttribute("type", "text/css"), n.setAttribute("data-styled-id", i), e.nonce && n.setAttribute("nonce", e.nonce), n.innerHTML = oB(i, t, e), (r || document.head || document.body).appendChild(n), n;
}
function lB(i) {
  var t = "rCS" + sB(i), e = 0, r;
  return {
    className: t,
    inject: function(n, s) {
      s === void 0 && (s = {});
      var a = aB(n), o = e === 0, u;
      return (a || o) && (u = uB(t, i, s, a)), o && (r = u), a || ++e, {
        destroy: function() {
          a ? (a.removeChild(u), u = null) : (e > 0 && --e, e === 0 && r && (r.parentNode.removeChild(r), r = null));
        }
      };
    }
  };
}
var b_ = function() {
  return b_ = Object.assign || function(t) {
    for (var e, r = 1, n = arguments.length; r < n; r++) {
      e = arguments[r];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
    }
    return t;
  }, b_.apply(this, arguments);
};
function hB(i, t) {
  var e = {};
  for (var r in i)
    Object.prototype.hasOwnProperty.call(i, r) && t.indexOf(r) < 0 && (e[r] = i[r]);
  if (i != null && typeof Object.getOwnPropertySymbols == "function")
    for (var n = 0, r = Object.getOwnPropertySymbols(i); n < r.length; n++)
      t.indexOf(r[n]) < 0 && Object.prototype.propertyIsEnumerable.call(i, r[n]) && (e[r[n]] = i[r[n]]);
  return e;
}
function XT(i, t) {
  var e = lB(t), r = e.className;
  return sL(function(n, s) {
    var a = n.className, o = a === void 0 ? "" : a;
    n.cspNonce;
    var u = hB(n, ["className", "cspNonce"]), l = yL();
    return _L(s, function() {
      return l.current;
    }, []), IT(function() {
      var h = e.inject(l.current, {
        nonce: n.cspNonce
      });
      return function() {
        h.destroy();
      };
    }, []), Ki(i, b_({
      ref: l,
      "data-styled-id": r,
      className: "".concat(o, " ").concat(r)
    }, u));
  });
}
var x_ = function(i, t) {
  return x_ = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
  }, x_(i, t);
};
function Md(i, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  x_(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var F = function() {
  return F = Object.assign || function(t) {
    for (var e, r = 1, n = arguments.length; r < n; r++) {
      e = arguments[r];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
    }
    return t;
  }, F.apply(this, arguments);
};
function cB(i, t) {
  var e = {};
  for (var r in i)
    Object.prototype.hasOwnProperty.call(i, r) && t.indexOf(r) < 0 && (e[r] = i[r]);
  if (i != null && typeof Object.getOwnPropertySymbols == "function")
    for (var n = 0, r = Object.getOwnPropertySymbols(i); n < r.length; n++)
      t.indexOf(r[n]) < 0 && Object.prototype.propertyIsEnumerable.call(i, r[n]) && (e[r[n]] = i[r[n]]);
  return e;
}
function fB(i, t, e, r) {
  var n = arguments.length, s = n < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(i, t, e, r);
  else
    for (var o = i.length - 1; o >= 0; o--)
      (a = i[o]) && (s = (n < 3 ? a(s) : n > 3 ? a(t, e, s) : a(t, e)) || s);
  return n > 3 && s && Object.defineProperty(t, e, s), s;
}
function Tt(i, t, e) {
  if (e || arguments.length === 2)
    for (var r = 0, n = t.length, s; r < n; r++)
      (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return i.concat(s || Array.prototype.slice.call(t));
}
function Pd(i, t) {
  return F({
    events: [],
    props: [],
    name: i
  }, t);
}
var dB = ["n", "w", "s", "e"], _x = ["n", "w", "s", "e", "nw", "ne", "sw", "se"];
function pB(i, t) {
  return 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="'.concat(32 * i, 'px" height="').concat(32 * i, 'px" viewBox="0 0 32 32" ><path d="M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z" stroke-linejoin="round" stroke-width="1.2" fill="black" stroke="white" style="transform:rotate(').concat(t, 'deg);transform-origin: 16px 16px"></path></svg>');
}
function vB(i) {
  var t = pB(1, i), e = Math.round(i / 45) * 45 % 180, r = "ns-resize";
  return e === 135 ? r = "nwse-resize" : e === 45 ? r = "nesw-resize" : e === 90 && (r = "ew-resize"), "cursor:".concat(r, ";cursor: url('").concat(t, "') 16 16, ").concat(r, ";");
}
var ch = SL(), WT = ch.browser.webkit, YT = WT && function() {
  var i = typeof window > "u" ? {
    userAgent: ""
  } : window.navigator, t = /applewebkit\/([^\s]+)/g.exec(i.userAgent.toLowerCase());
  return t ? parseFloat(t[1]) < 605 : !1;
}(), qT = ch.browser.name, ZT = parseInt(ch.browser.version, 10), gB = qT === "chrome", mB = ch.browser.chromium, yB = parseInt(ch.browser.chromiumVersion, 10) || 0, _B = gB && ZT >= 109 || mB && yB >= 109, bB = qT === "firefox", xB = parseInt(ch.browser.webkitVersion, 10) >= 612 || ZT >= 15, bx = "moveable-", wB = _x.map(function(i) {
  var t = "", e = "", r = "center", n = "center";
  return i.indexOf("n") > -1 && (t = "top: -20px;", n = "bottom"), i.indexOf("s") > -1 && (t = "top: 0px;", n = "top"), i.indexOf("w") > -1 && (e = "left: -20px;", r = "right"), i.indexOf("e") > -1 && (e = "left: 0px;", r = "left"), '.around-control[data-direction*="'.concat(i, `"] {
        `).concat(e).concat(t, `
        transform-origin: `).concat(r, " ").concat(n, `;
    }`);
}).join(`
`), EB = `
{
position: absolute;
width: 1px;
height: 1px;
left: 0;
top: 0;
z-index: 3000;
--moveable-color: #4af;
--zoom: 1;
--zoompx: 1px;
will-change: transform;
outline: 1px solid transparent;
}
.control-box {
z-index: 0;
}
.line, .control {
position: absolute;
left: 0;
top: 0;
will-change: transform;
}
.control {
width: 14px;
height: 14px;
border-radius: 50%;
border: 2px solid #fff;
box-sizing: border-box;
background: #4af;
background: var(--moveable-color);
margin-top: -7px;
margin-left: -7px;
border: 2px solid #fff;
z-index: 10;
}
.around-control {
position: absolute;
will-change: transform;
width: calc(var(--moveable-control-padding, 20) * 1px);
height: calc(var(--moveable-control-padding, 20) * 1px);
left: -10px;
top: -10px;
box-sizing: border-box;
background: transparent;
z-index: 8;
cursor: alias;
transform-origin: center center;
}
`.concat(wB, `
.padding {
position: absolute;
top: 0px;
left: 0px;
width: 100px;
height: 100px;
transform-origin: 0 0;
}
.line {
width: 1px;
height: 1px;
background: #4af;
background: var(--moveable-color);
transform-origin: 0px 50%;
}
.line.edge {
z-index: 1;
background: transparent;
}
.line.dashed {
box-sizing: border-box;
background: transparent;
}
.line.dashed.horizontal {
border-top: 1px dashed #4af;
border-top-color: #4af;
border-top-color: var(--moveable-color);
}
.line.dashed.vertical {
border-left: 1px dashed #4af;
border-left-color: #4af;
border-left-color: var(--moveable-color);
}
.line.vertical {
transform: translateX(-50%);
}
.line.horizontal {
transform: translateY(-50%);
}
.line.vertical.bold {
width: 2px;
}
.line.horizontal.bold {
height: 2px;
}

.control.origin {
border-color: #f55;
background: #fff;
width: 12px;
height: 12px;
margin-top: -6px;
margin-left: -6px;
pointer-events: none;
}
`).concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function(i) {
  return `
.direction[data-rotation="`.concat(i, '"], :global .view-control-rotation').concat(i, ` {
`).concat(vB(i), `
}
`);
}).join(`
`), `

.line.direction:before {
content: "";
position: absolute;
width: 100%;
height: calc(var(--moveable-line-padding, 0) * 1px);
bottom: 0;
left: 0;
}
.group {
z-index: -1;
}
.area {
position: absolute;
}
.area-pieces {
position: absolute;
top: 0;
left: 0;
display: none;
}
.area.avoid, .area.pass {
pointer-events: none;
}
.area.avoid+.area-pieces {
display: block;
}
.area-piece {
position: absolute;
}

`).concat(YT ? `:global svg *:before {
content:"";
transform-origin: inherit;
}` : "", `
`), SB = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]], w_ = 1e-4, Rr = 1e-7, cp = 1e-9, E_ = Math.pow(10, 10), ww = -E_, TB = {
  n: [0, -1],
  e: [1, 0],
  s: [0, 1],
  w: [-1, 0],
  nw: [-1, -1],
  ne: [1, -1],
  sw: [-1, 1],
  se: [1, 1]
}, xx = {
  n: [0, 1],
  e: [1, 3],
  s: [3, 2],
  w: [2, 0],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
}, KT = {
  n: 0,
  s: 180,
  w: 270,
  e: 90,
  nw: 315,
  ne: 45,
  sw: 225,
  se: 135
}, JT = ["isMoveableElement", "updateRect", "updateTarget", "destroy", "dragStart", "isInside", "hitTest", "setState", "getRect", "request", "isDragging", "getManager", "forceUpdate", "waitToChangeTarget", "updateSelectors", "getTargets", "stopDrag"];
function Od(i, t, e, r, n, s) {
  var a, o;
  s === void 0 && (s = "draggable");
  var u = (o = (a = t.gestos[s]) === null || a === void 0 ? void 0 : a.move(e, i.inputEvent)) !== null && o !== void 0 ? o : {}, l = u.originalDatas || u.datas, h = l[s] || (l[s] = {});
  return F(F({}, n ? xC(t, u) : u), {
    isPinch: !!r,
    parentEvent: !0,
    datas: h,
    originalDatas: i.originalDatas
  });
}
var Ql = /* @__PURE__ */ function() {
  function i(e) {
    var r;
    e === void 0 && (e = "draggable"), this.ableName = e, this.prevX = 0, this.prevY = 0, this.startX = 0, this.startY = 0, this.isDrag = !1, this.isFlag = !1, this.datas = {
      draggable: {}
    }, this.datas = (r = {}, r[e] = {}, r);
  }
  var t = i.prototype;
  return t.dragStart = function(e, r) {
    this.isDrag = !1, this.isFlag = !1;
    var n = r.originalDatas;
    return this.datas = n, n[this.ableName] || (n[this.ableName] = {}), F(F({}, this.move(e, r.inputEvent)), {
      type: "dragstart"
    });
  }, t.drag = function(e, r) {
    return this.move([e[0] - this.prevX, e[1] - this.prevY], r);
  }, t.move = function(e, r) {
    var n, s, a = !1;
    if (!this.isFlag)
      this.prevX = e[0], this.prevY = e[1], this.startX = e[0], this.startY = e[1], n = e[0], s = e[1], this.isFlag = !0;
    else {
      var o = this.isDrag;
      n = this.prevX + e[0], s = this.prevY + e[1], (e[0] || e[1]) && (this.isDrag = !0), !o && this.isDrag && (a = !0);
    }
    return this.prevX = n, this.prevY = s, {
      type: "drag",
      clientX: n,
      clientY: s,
      inputEvent: r,
      isFirstDrag: a,
      isDrag: this.isDrag,
      distX: n - this.startX,
      distY: s - this.startY,
      deltaX: e[0],
      deltaY: e[1],
      datas: this.datas[this.ableName],
      originalDatas: this.datas,
      parentEvent: !0,
      parentGesto: this
    };
  }, i;
}();
function QT(i, t) {
  var e = t.clientX, r = t.clientY, n = t.datas, s = i.state, a = s.moveableClientRect, o = s.rootMatrix, u = s.is3d, l = s.pos1, h = a.left, d = a.top, f = u ? 4 : 3, p = Mt(rh(o, [e - h, r - d], f), l), v = p[0], g = p[1], m = Un({
    datas: n,
    distX: v,
    distY: g
  }), y = m[0], _ = m[1];
  return [y, _];
}
function au(i, t) {
  var e = t.datas, r = i.state, n = r.allMatrix, s = r.beforeMatrix, a = r.is3d, o = r.left, u = r.top, l = r.origin, h = r.offsetMatrix, d = r.targetMatrix, f = r.transformOrigin, p = a ? 4 : 3;
  e.is3d = a, e.matrix = n, e.targetMatrix = d, e.beforeMatrix = s, e.offsetMatrix = h, e.transformOrigin = f, e.inverseMatrix = Nn(n, p), e.inverseBeforeMatrix = Nn(s, p), e.absoluteOrigin = tu(Jt([o, u], l), p), e.startDragBeforeDist = br(e.inverseBeforeMatrix, e.absoluteOrigin, p), e.startDragDist = br(e.inverseMatrix, e.absoluteOrigin, p);
}
function CB(i) {
  return Fu(i.datas.beforeTransform, [50, 50], 100, 100).direction;
}
function h0(i, t) {
  var e = i.datas, r = i.originalDatas.beforeRenderable, n = e.transformIndex, s = r.nextTransforms, a = s.length, o = r.nextTransformAppendedIndexes, u = -1;
  n === -1 ? (t === "translate" ? u = 0 : t === "rotate" && (u = Ms(s, function(f) {
    return f.match(/scale\(/g);
  })), u === -1 && (u = s.length), e.transformIndex = u) : nn(o, function(f) {
    return f.index === n && f.functionName === t;
  }) ? u = n : u = n + o.filter(function(f) {
    return f.index < n;
  }).length;
  var l = eF(s, u), h = l.targetFunction, d = t === "rotate" ? "rotateZ" : t;
  e.beforeFunctionTexts = l.beforeFunctionTexts, e.afterFunctionTexts = l.afterFunctionTexts, e.beforeTransform = l.beforeFunctionMatrix, e.beforeTransform2 = l.beforeFunctionMatrix2, e.targetTansform = l.targetFunctionMatrix, e.afterTransform = l.afterFunctionMatrix, e.afterTransform2 = l.afterFunctionMatrix2, e.targetAllTransform = l.allFunctionMatrix, h.functionName === d ? (e.afterFunctionTexts.splice(0, 1), e.isAppendTransform = !1) : a > u && (e.isAppendTransform = !0, r.nextTransformAppendedIndexes = Tt(Tt([], o, !0), [{
    functionName: t,
    index: u,
    isAppend: !0
  }], !1));
}
function c0(i, t, e) {
  return "".concat(i.beforeFunctionTexts.join(" "), " ").concat(i.isAppendTransform ? e : t, " ").concat(i.afterFunctionTexts.join(" "));
}
function MB(i) {
  var t = i.datas, e = i.distX, r = i.distY, n = eC({
    datas: t,
    distX: e,
    distY: r
  }), s = n[0], a = n[1], o = tC(t, OL([s, a], 4));
  return br(o, tu([0, 0, 0], 4), 4);
}
function tC(i, t, e) {
  var r = i.beforeTransform, n = i.afterTransform, s = i.beforeTransform2, a = i.afterTransform2, o = i.targetAllTransform, u = e ? _e(o, t, 4) : _e(t, o, 4), l = _e(Nn(e ? s : r, 4), u, 4), h = _e(l, Nn(e ? a : n, 4), 4);
  return h;
}
function eC(i) {
  var t = i.datas, e = i.distX, r = i.distY, n = t.inverseBeforeMatrix, s = t.is3d, a = t.startDragBeforeDist, o = t.absoluteOrigin, u = s ? 4 : 3;
  return Mt(br(n, Jt(o, [e, r]), u), a);
}
function Un(i, t) {
  var e = i.datas, r = i.distX, n = i.distY, s = e.inverseBeforeMatrix, a = e.inverseMatrix, o = e.is3d, u = e.startDragBeforeDist, l = e.startDragDist, h = e.absoluteOrigin, d = o ? 4 : 3;
  return Mt(br(t ? s : a, Jt(h, [r, n]), d), t ? u : l);
}
function PB(i, t) {
  var e = i.datas, r = i.distX, n = i.distY, s = e.beforeMatrix, a = e.matrix, o = e.is3d, u = e.startDragBeforeDist, l = e.startDragDist, h = e.absoluteOrigin, d = o ? 4 : 3;
  return Mt(br(t ? s : a, Jt(t ? u : l, [r, n]), d), h);
}
function OB(i, t, e, r, n, s) {
  return r === void 0 && (r = t), n === void 0 && (n = e), s === void 0 && (s = [0, 0]), i ? i.map(function(a, o) {
    var u = xd(a), l = u.value, h = u.unit, d = o ? n : r, f = o ? e : t;
    if (a === "%" || isNaN(l)) {
      var p = d ? s[o] / d : 0;
      return f * p;
    } else if (h !== "%")
      return l;
    return f * l / 100;
  }) : s;
}
function rC(i) {
  var t = [];
  return i[1] >= 0 && (i[0] >= 0 && t.push(3), i[0] <= 0 && t.push(2)), i[1] <= 0 && (i[0] >= 0 && t.push(1), i[0] <= 0 && t.push(0)), t;
}
function IB(i, t) {
  return rC(t).map(function(e) {
    return i[e];
  });
}
function ze(i, t) {
  var e = (t[0] + 1) / 2, r = (t[1] + 1) / 2, n = [Ma(i[0][0], i[1][0], e, 1 - e), Ma(i[0][1], i[1][1], e, 1 - e)], s = [Ma(i[2][0], i[3][0], e, 1 - e), Ma(i[2][1], i[3][1], e, 1 - e)];
  return [Ma(n[0], s[0], r, 1 - r), Ma(n[1], s[1], r, 1 - r)];
}
function RB(i, t, e, r, n, s) {
  var a = fa(t, e, r, n), o = ze(a, s), u = i[0] - o[0], l = i[1] - o[1];
  return [u, l];
}
function Id(i, t, e, r) {
  return _e(i, qh(t, r, e), r);
}
function DB(i, t, e) {
  var r = i.transformOrigin, n = i.offsetMatrix, s = i.is3d, a = s ? 4 : 3, o;
  if ($r(e)) {
    var u = t.beforeTransform, l = t.afterTransform;
    o = An(_e(_e(u, mx([e]), 4), l, 4), 4, a);
  } else
    o = e;
  return Id(n, o, r, a);
}
function kB(i, t) {
  var e = i.transformOrigin, r = i.offsetMatrix, n = i.is3d, s = i.targetMatrix, a = i.targetAllTransform, o = n ? 4 : 3;
  return Id(r, _e(a || s, Ev(t, o), o), e, o);
}
function f0(i) {
  var t = fh(i);
  return {
    setTransform: function(e, r) {
      r === void 0 && (r = -1), t.startTransforms = tr(e) ? e : ca(e), S_(i, r);
    },
    setTransformIndex: function(e) {
      S_(i, e);
    }
  };
}
function d0(i, t) {
  var e = fh(i), r = e.startTransforms;
  S_(i, Ms(r, function(n) {
    return n.indexOf("".concat(t, "(")) === 0;
  }));
}
function S_(i, t) {
  var e = fh(i), r = i.datas;
  if (r.transformIndex = t, t !== -1) {
    var n = e.startTransforms[t];
    if (n) {
      var s = Ra([n]);
      r.startValue = s[0].functionValue;
    }
  }
}
function wx(i, t) {
  var e = fh(i);
  e.nextTransforms = ca(t);
}
function fh(i) {
  return i.originalDatas.beforeRenderable;
}
function iC(i) {
  var t = i.originalDatas.beforeRenderable;
  return t.nextTransforms;
}
function fp(i) {
  return iC(i).join(" ");
}
function dp(i) {
  return fh(i).nextStyle;
}
function nC(i, t, e, r, n) {
  wx(n, t);
  var s = Or.drag(i, Od(n, i.state, e, r, !1)), a = s ? s.transform : t;
  return F(F({
    transform: t,
    drag: s
  }, Ir({
    transform: a
  }, n)), {
    afterTransform: a
  });
}
function Ex(i, t, e, r) {
  var n = DB(i.state, r, t), s = oC(i, e, n);
  return s;
}
function sC(i, t, e, r, n) {
  var s = Ex(i, t, e, n), a = i.state, o = a.left, u = a.top, l = i.props.groupable, h = l ? o : 0, d = l ? u : 0, f = Mt(r, s);
  return Mt(f, [h, d]);
}
function NB(i, t, e, r, n) {
  var s = sC(i, "scale(".concat(t.join(", "), ")"), e, r, n);
  return s;
}
function aC(i, t, e) {
  return [-1 + i[0] / (t / 2), -1 + i[1] / (e / 2)];
}
function oC(i, t, e) {
  e === void 0 && (e = i.state.allMatrix);
  var r = i.state, n = r.width, s = r.height, a = r.is3d, o = a ? 4 : 3, u = [n / 2 * (1 + t[0]), s / 2 * (1 + t[1])];
  return nr(e, u, o);
}
function AB(i, t, e) {
  var r = e.fixedDirection, n = e.fixedPosition;
  return sC(i, "rotate(".concat(t, "deg)"), r, n, e);
}
function LB(i, t, e, r, n, s) {
  var a = i.props.groupable, o = i.state, u = o.transformOrigin, l = o.offsetMatrix, h = o.is3d, d = o.width, f = o.height, p = o.left, v = o.top, g = s.fixedDirection, m = s.nextTargetMatrix || o.targetMatrix, y = h ? 4 : 3, _ = OB(n, t, e, d, f, u), b = a ? p : 0, w = a ? v : 0, T = Id(l, m, _, y), x = RB(r, T, t, e, y, g);
  return Mt(x, [b, w]);
}
function BB(i, t) {
  return ze(Ti(i.state), t);
}
function FB(i, t) {
  var e = i.targetGesto, r = i.controlGesto, n;
  return e != null && e.isFlag() && (n = e.getEventData()[t]), !n && (r != null && r.isFlag()) && (n = r.getEventData()[t]), n || {};
}
function GB(i) {
  if (i && i.getRootNode) {
    var t = i.getRootNode();
    if (t.nodeType === 11)
      return t;
  }
}
function uC(i, t, e) {
  for (var r = i, n = [], s = document.documentElement || document.body, a = !e && i === t || i === s, o = a, u = !1, l = 3, h, d, f, p = !1, v = gc(t, t, !0).offsetParent, g = 1; r && !o; ) {
    o = a;
    var m = oi(r), y = m("position"), _ = m("scale"), b = hC(r), w = y === "fixed", T = IL(HB(b)), x = void 0, S = !1, C = !1, M = 0, I = 0, R = 0, N = 0, A = {
      hasTransform: !1,
      fixedContainer: null
    };
    w && (p = !0, A = YB(r), v = A.fixedContainer);
    var G = T.length;
    !u && G === 16 && (u = !0, l = 4, T_(n), f && (f = An(f, 3, 4))), u && G === 9 && (T = An(T, 3, 4));
    var B = WB(r, i), U = B.tagName, $ = B.hasOffset, Z = B.isSVG, H = B.origin, z = B.targetOrigin, X = B.offset, ct = X[0], it = X[1];
    U === "svg" && f && (n.push({
      type: "target",
      target: r,
      matrix: qB(r, l)
    }), n.push({
      type: "offset",
      target: r,
      matrix: Oe(l)
    }));
    var lt = parseFloat(m("zoom")) || 1;
    if (w)
      x = A.fixedContainer, S = !0;
    else {
      var et = gc(r, t, !1, !0, m), k = et.offsetZoom;
      if (x = et.offsetParent, S = et.isEnd, C = et.isStatic, g *= k, (et.isCustomElement || k !== 1) && C)
        ct -= x.offsetLeft, it -= x.offsetTop;
      else if (bB || _B) {
        var ft = et.parentSlotElement;
        if (ft) {
          for (var Q = x, St = 0, at = 0; Q && GB(Q); )
            St += Q.offsetLeft, at += Q.offsetTop, Q = Q.offsetParent;
          ct -= St, it -= at;
        }
      }
    }
    if (WT && !xB && $ && !Z && C && (y === "relative" || y === "static") && (ct -= x.offsetLeft, it -= x.offsetTop, a = a || S), w)
      $ && A.hasTransform && (R = x.clientLeft, N = x.clientTop);
    else if ($ && v !== x && (M = x.clientLeft, I = x.clientTop), $ && x === s) {
      var q = cC(r, !1);
      ct += q[0], it += q[1];
    }
    if (n.push({
      type: "target",
      target: r,
      matrix: qh(T, l, H)
    }), _ && _ !== "1" && _ !== "none") {
      var bt = _.split(" ").map(function(Ct) {
        return parseFloat(Ct);
      }), st = bt[0], W = bt[1], nt = W === void 0 ? st : W, dt = Ev([st, nt], l);
      n.push({
        type: "offset",
        target: r,
        matrix: Oe(l)
      }), n.push({
        type: "target",
        target: r,
        matrix: qh(dt, l, H)
      });
    }
    if ($) {
      var V = r === i, xt = V ? 0 : r.scrollLeft, Dt = V ? 0 : r.scrollTop;
      n.push({
        type: "offset",
        target: r,
        matrix: vc([ct - xt + M - R, it - Dt + I - N], l)
      });
    } else
      n.push({
        type: "offset",
        target: r,
        origin: H
      });
    if (lt !== 1 && n.push({
      type: "zoom",
      target: r,
      matrix: qh(Ev([lt, lt], l), l, [0, 0])
    }), f || (f = T), h || (h = H), d || (d = z), o || w)
      break;
    r = x, a = S, (!e || r === s) && (o = a);
  }
  return f || (f = Oe(l)), h || (h = [0, 0]), d || (d = [0, 0]), {
    zoom: g,
    offsetContainer: v,
    matrixes: n,
    targetMatrix: f,
    transformOrigin: h,
    targetOrigin: d,
    is3d: u,
    hasFixed: p
  };
}
var Da = null, ka = null, Ru = null;
function th(i) {
  i ? (window.Map && (Da = /* @__PURE__ */ new Map(), ka = /* @__PURE__ */ new Map()), Ru = []) : (Da = null, Ru = null, ka = null);
}
function UB(i) {
  var t = ka == null ? void 0 : ka.get(i);
  if (t)
    return t;
  var e = Zh(i, !0);
  return ka && ka.set(i, e), e;
}
function jB(i, t) {
  if (Ru) {
    var e = nn(Ru, function(n) {
      return n[0][0] == i && n[0][1] == t;
    });
    if (e)
      return e[1];
  }
  var r = uC(i, t, !0);
  return Ru && Ru.push([[i, t], r]), r;
}
function oi(i) {
  var t = Da == null ? void 0 : Da.get(i);
  if (!t) {
    var e = window.getComputedStyle(i);
    if (!Da)
      return function(s) {
        return e[s];
      };
    t = {
      style: e,
      cached: {}
    }, Da.set(i, t);
  }
  var r = t.cached, n = t.style;
  return function(s) {
    return s in r || (r[s] = n[s]), r[s];
  };
}
function zB(i, t) {
  return [i[0] * t[0], i[1] * t[1]];
}
function Pt() {
  for (var i = [], t = 0; t < arguments.length; t++)
    i[t] = arguments[t];
  return RA.apply(void 0, Tt([bx], i, !1));
}
function lC(i) {
  i();
}
function HB(i) {
  return !i || i === "none" ? [1, 0, 0, 1, 0, 0] : ha(i) ? i : mx(i);
}
function qh(i, t, e) {
  return d_(t, vc(e, t), i, vc(e.map(function(r) {
    return -r;
  }), t));
}
function $B(i, t, e) {
  if (t === "%") {
    var r = Sx(i.ownerSVGElement);
    return r[e ? "width" : "height"] / 100;
  }
  return 1;
}
function VB(i) {
  var t = XB(Mx(i, ":before"));
  return t.map(function(e, r) {
    var n = xd(e), s = n.value, a = n.unit;
    return s * $B(i, a, r === 0);
  });
}
function Tv(i) {
  return i ? i.split(" ") : ["0", "0"];
}
function XB(i) {
  return Tv(i.transformOrigin);
}
function hC(i) {
  var t = oi(i), e = t("transform");
  if (e && e !== "none")
    return e;
  if ("transform" in i) {
    var r = i.transform, n = r.baseVal;
    if (!n)
      return "";
    var s = n.length;
    if (!s)
      return "";
    for (var a = [], o = function(l) {
      var h = n[l].matrix;
      a.push("matrix(".concat(["a", "b", "c", "d", "e", "f"].map(function(d) {
        return h[d];
      }).join(", "), ")"));
    }, u = 0; u < s; ++u)
      o(u);
    return a.join(" ");
  }
  return "";
}
function gc(i, t, e, r, n) {
  var s, a, o = i && i.ownerDocument ? i.ownerDocument : document, u = o.documentElement || o.body, l = !1, h, d;
  if (!i || e)
    h = i;
  else {
    var f = (s = i == null ? void 0 : i.assignedSlot) === null || s === void 0 ? void 0 : s.parentElement, p = i.parentElement;
    f ? (l = !0, d = p, h = f) : h = p;
  }
  for (var v = !1, g = i === t || h === t, m = "relative", y = 1, _ = parseFloat(n == null ? void 0 : n("zoom")) || 1, b = n == null ? void 0 : n("position"); h && h !== u; ) {
    t === h && (g = !0);
    var w = oi(h), T = h.tagName.toLowerCase(), x = hC(h), S = w("willChange"), C = parseFloat(w("zoom")) || 1;
    if (m = w("position"), r && C !== 1) {
      y = C;
      break;
    }
    if (
      // offsetParent is the parentElement if the target's zoom is not 1 and not absolute.
      !e && r && _ !== 1 && b && b !== "absolute" || T === "svg" || m !== "static" || x && x !== "none" || S === "transform"
    )
      break;
    var M = (a = i == null ? void 0 : i.assignedSlot) === null || a === void 0 ? void 0 : a.parentNode, I = h.parentNode;
    M && (l = !0, d = I);
    var R = I;
    if (R && R.nodeType === 11) {
      h = R.host, v = !0, m = oi(h)("position");
      break;
    }
    h = R, m = "relative";
  }
  return {
    offsetZoom: y,
    hasSlot: l,
    parentSlotElement: d,
    isCustomElement: v,
    isStatic: m === "static",
    isEnd: g || !h || h === u,
    offsetParent: h || u
  };
}
function WB(i, t) {
  var e, r = i.tagName.toLowerCase(), n = i.offsetLeft, s = i.offsetTop, a = oi(i), o = o0(n), u = !o, l, h;
  return !u && r !== "svg" ? (l = YT ? VB(i) : Tv(a("transformOrigin")).map(function(d) {
    return parseFloat(d);
  }), h = l.slice(), u = !0, e = ZB(i, l, i === t && t.tagName.toLowerCase() === "g"), n = e[0], s = e[1], l[0] = e[2], l[1] = e[3]) : (l = Tv(a("transformOrigin")).map(function(d) {
    return parseFloat(d);
  }), h = l.slice()), {
    tagName: r,
    isSVG: o,
    hasOffset: u,
    offset: [n || 0, s || 0],
    origin: l,
    targetOrigin: h
  };
}
function cC(i, t) {
  var e = oi(i), r = oi(document.body), n = r("position");
  if (!t && (!n || n === "static"))
    return [0, 0];
  var s = parseInt(r("marginLeft"), 10), a = parseInt(r("marginTop"), 10);
  return e("position") === "absolute" && ((e("top") !== "auto" || e("bottom") !== "auto") && (a = 0), (e("left") !== "auto" || e("right") !== "auto") && (s = 0)), [s, a];
}
function T_(i) {
  i.forEach(function(t) {
    var e = t.matrix;
    e && (t.matrix = An(e, 3, 4));
  });
}
function YB(i) {
  for (var t = i.parentElement, e = !1; t; ) {
    var r = Mx(t).transform;
    if (r && r !== "none") {
      e = !0;
      break;
    }
    if (t === document.body)
      break;
    t = t.parentElement;
  }
  return {
    fixedContainer: t || document.body,
    hasTransform: e
  };
}
function p0(i, t) {
  return t === void 0 && (t = i.length > 9), "".concat(t ? "matrix3d" : "matrix", "(").concat(UT(i, !t).join(","), ")");
}
function Sx(i) {
  var t = i.clientWidth, e = i.clientHeight;
  if (!i)
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      clientWidth: t,
      clientHeight: e
    };
  var r = i.viewBox, n = r && r.baseVal || {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  return {
    x: n.x,
    y: n.y,
    width: n.width || t,
    height: n.height || e,
    clientWidth: t,
    clientHeight: e
  };
}
function qB(i, t) {
  var e = Sx(i), r = e.width, n = e.height, s = e.clientWidth, a = e.clientHeight, o = s / r, u = a / n, l = i.preserveAspectRatio.baseVal, h = l.align, d = l.meetOrSlice, f = [0, 0], p = [o, u], v = [0, 0];
  if (h !== 1) {
    var g = (h - 2) % 3, m = Math.floor((h - 2) / 3);
    f[0] = r * g / 2, f[1] = n * m / 2;
    var y = d === 2 ? Math.max(u, o) : Math.min(o, u);
    p[0] = y, p[1] = y, v[0] = (s - r) / 2 * g, v[1] = (a - n) / 2 * m;
  }
  var _ = Ev(p, t);
  return _[t * (t - 1)] = v[0], _[t * (t - 1) + 1] = v[1], qh(_, t, f);
}
function ZB(i, t, e) {
  if (!i.getBBox || !e && i.tagName.toLowerCase() === "g")
    return [0, 0, 0, 0];
  var r = i.getBBox(), n = Sx(i.ownerSVGElement), s = r.x - n.x, a = r.y - n.y;
  return [s, a, t[0] - s, t[1] - a];
}
function nr(i, t, e) {
  return br(i, tu(t, e), e);
}
function fa(i, t, e, r) {
  return [[0, 0], [t, 0], [0, e], [t, e]].map(function(n) {
    return nr(i, n, r);
  });
}
function Si(i) {
  var t = i.map(function(l) {
    return l[0];
  }), e = i.map(function(l) {
    return l[1];
  }), r = Math.min.apply(Math, t), n = Math.min.apply(Math, e), s = Math.max.apply(Math, t), a = Math.max.apply(Math, e), o = s - r, u = a - n;
  return {
    left: r,
    top: n,
    right: s,
    bottom: a,
    width: o,
    height: u
  };
}
function Ew(i, t, e, r) {
  var n = fa(i, t, e, r);
  return Si(n);
}
function KB(i, t, e, r, n) {
  var s, a = i.target, o = i.origin, u = t.matrix, l = dC(a), h = l.offsetWidth, d = l.offsetHeight, f = e.getBoundingClientRect(), p = [0, 0];
  e === document.body && (p = cC(a, !0));
  for (var v = a.getBoundingClientRect(), g = v.left - f.left + e.scrollLeft - (e.clientLeft || 0) + p[0], m = v.top - f.top + e.scrollTop - (e.clientTop || 0) + p[1], y = v.width, _ = v.height, b = d_(r, n, u), w = Ew(b, h, d, r), T = w.left, x = w.top, S = w.width, C = w.height, M = nr(b, o, r), I = Mt(M, [T, x]), R = [g + I[0] * y / S, m + I[1] * _ / C], N = [0, 0], A = 0; ++A < 10; ) {
    var G = Nn(n, r);
    s = Mt(nr(G, R, r), nr(G, M, r)), N[0] = s[0], N[1] = s[1];
    var B = d_(r, n, vc(N, r), u), U = Ew(B, h, d, r), $ = U.left, Z = U.top, H = $ - g, z = Z - m;
    if (Math.abs(H) < 2 && Math.abs(z) < 2)
      break;
    R[0] -= H, R[1] -= z;
  }
  return N.map(function(X) {
    return Math.round(X);
  });
}
function JB(i, t, e) {
  var r = i.length === 16, n = r ? 4 : 3, s = t.map(function(u) {
    return nr(i, u, n);
  }), a = e.left, o = e.top;
  return s.map(function(u) {
    return [u[0] + a, u[1] + o];
  });
}
function Fu(i, t, e, r) {
  var n = i.length === 16, s = n ? 4 : 3, a = fa(i, e, r, s), o = a[0], u = o[0], l = o[1], h = a[1], d = h[0], f = h[1], p = a[2], v = p[0], g = p[1], m = a[3], y = m[0], _ = m[1], b = nr(i, t, s), w = b[0], T = b[1], x = Math.min(u, d, v, y), S = Math.min(l, f, g, _), C = Math.max(u, d, v, y), M = Math.max(l, f, g, _);
  u = u - x || 0, d = d - x || 0, v = v - x || 0, y = y - x || 0, l = l - S || 0, f = f - S || 0, g = g - S || 0, _ = _ - S || 0, w = w - x || 0, T = T - S || 0;
  var I = u_(fa(i, 100, 100, s));
  return {
    left: x,
    top: S,
    right: C,
    bottom: M,
    origin: [w, T],
    pos1: [u, l],
    pos2: [d, f],
    pos3: [v, g],
    pos4: [y, _],
    direction: I
  };
}
function Ln(i) {
  return Math.sqrt(i[0] * i[0] + i[1] * i[1]);
}
function fC(i, t) {
  return Ln([t[0] - i[0], t[1] - i[1]]);
}
function Dh(i, t, e, r) {
  e === void 0 && (e = 1), r === void 0 && (r = $e(i, t));
  var n = fC(i, t);
  return {
    transform: "translateY(-50%) translate(".concat(i[0], "px, ").concat(i[1], "px) rotate(").concat(r, "rad) scaleY(").concat(e, ")"),
    width: "".concat(n, "px")
  };
}
function Tx(i, t) {
  for (var e = [], r = 2; r < arguments.length; r++)
    e[r - 2] = arguments[r];
  var n = e.length, s = e.reduce(function(o, u) {
    return o + u[0];
  }, 0) / n, a = e.reduce(function(o, u) {
    return o + u[1];
  }, 0) / n;
  return {
    transform: "translateZ(0px) translate(".concat(s, "px, ").concat(a, "px) rotate(").concat(i, "rad) scale(").concat(t, ")")
  };
}
function ru(i, t) {
  var e = i[t];
  return ha(e) ? F(F({}, i), e) : i;
}
function dC(i) {
  var t = i && !o0(i.offsetWidth), e = 0, r = 0, n = 0, s = 0, a = 0, o = 0, u = 0, l = 0, h = 0, d = 0, f = 0, p = 0, v = 1 / 0, g = 1 / 0, m = 1 / 0, y = 1 / 0, _ = 0, b = 0, w = !1;
  if (i)
    if (!t && i.tagName.toLowerCase() !== "svg") {
      var T = i.getBBox();
      w = !0, e = T.width, r = T.height, a = e, o = r, u = e, l = r, n = e, s = r;
    } else {
      var x = oi(i), S = i.style, C = x("boxSizing") === "border-box", M = parseFloat(x("borderLeftWidth")) || 0, I = parseFloat(x("borderRightWidth")) || 0, R = parseFloat(x("borderTopWidth")) || 0, N = parseFloat(x("borderBottomWidth")) || 0, A = parseFloat(x("paddingLeft")) || 0, G = parseFloat(x("paddingRight")) || 0, B = parseFloat(x("paddingTop")) || 0, U = parseFloat(x("paddingBottom")) || 0, $ = A + G, Z = B + U, H = M + I, z = R + N, X = $ + H, ct = Z + z, it = x("position"), lt = 0, et = 0;
      if ("clientLeft" in i) {
        var k = null;
        if (it === "absolute") {
          var ft = gc(i, document.body);
          k = ft.offsetParent;
        } else
          k = i.parentElement;
        if (k) {
          var Q = oi(k);
          lt = parseFloat(Q("width")), et = parseFloat(Q("height"));
        }
      }
      h = Math.max($, Te(x("minWidth"), lt) || 0), d = Math.max(Z, Te(x("minHeight"), et) || 0), v = Te(x("maxWidth"), lt), g = Te(x("maxHeight"), et), isNaN(v) && (v = 1 / 0), isNaN(g) && (g = 1 / 0), _ = Te(S.width, 0) || 0, b = Te(S.height, 0) || 0, a = parseFloat(x("width")) || 0, o = parseFloat(x("height")) || 0, u = Math.abs(a - _) < 1 ? a_(h, _ || a, v) : a, l = Math.abs(o - b) < 1 ? a_(d, b || o, g) : o, e = u, r = l, n = u, s = l, C ? (m = v, y = g, f = h, p = d, u = e - X, l = r - ct) : (m = v + X, y = g + ct, f = h + X, p = d + ct, e = u + X, r = l + ct), n = u + $, s = l + Z;
    }
  return {
    svg: w,
    offsetWidth: e,
    offsetHeight: r,
    clientWidth: n,
    clientHeight: s,
    contentWidth: u,
    contentHeight: l,
    inlineCSSWidth: _,
    inlineCSSHeight: b,
    cssWidth: a,
    cssHeight: o,
    minWidth: h,
    minHeight: d,
    maxWidth: v,
    maxHeight: g,
    minOffsetWidth: f,
    minOffsetHeight: p,
    maxOffsetWidth: m,
    maxOffsetHeight: y
  };
}
function pC(i, t) {
  return $e(t > 0 ? i[0] : i[1], t > 0 ? i[1] : i[0]);
}
function pp() {
  return {
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    right: 0,
    bottom: 0,
    clientLeft: 0,
    clientTop: 0,
    clientWidth: 0,
    clientHeight: 0,
    scrollWidth: 0,
    scrollHeight: 0
  };
}
function vC(i, t) {
  var e = i === document.body || i === document.documentElement, r = {
    clientLeft: i.clientLeft,
    clientTop: i.clientTop,
    clientWidth: i.clientWidth,
    clientHeight: i.clientHeight,
    scrollWidth: i.scrollWidth,
    scrollHeight: i.scrollHeight,
    overflow: !1
  };
  return e && (r.clientHeight = Math.max(t.height, r.clientHeight), r.scrollHeight = Math.max(t.height, r.scrollHeight)), r.overflow = oi(i)("overflow") !== "visible", F(F({}, t), r);
}
function oy(i, t, e, r) {
  var n = i.left, s = i.right, a = i.top, o = i.bottom, u = t.top, l = t.left, h = {
    left: l + n,
    top: u + a,
    right: l + s,
    bottom: u + o,
    width: s - n,
    height: o - a
  };
  return e && r ? vC(e, h) : h;
}
function Zh(i, t) {
  var e = 0, r = 0, n = 0, s = 0;
  if (i) {
    var a = i.getBoundingClientRect();
    e = a.left, r = a.top, n = a.width, s = a.height;
  }
  var o = {
    left: e,
    top: r,
    width: n,
    height: s,
    right: e + n,
    bottom: r + s
  };
  return i && t ? vC(i, o) : o;
}
function gC(i, t, e, r) {
  var n;
  if (i)
    n = i;
  else if (t)
    n = [0, 0];
  else {
    var s = e.target;
    n = mC(s, r);
  }
  return n;
}
function mC(i, t) {
  if (i) {
    var e = i.getAttribute("data-rotation") || "", r = i.getAttribute("data-direction");
    if (t.deg = e, !!r) {
      var n = [0, 0];
      return r.indexOf("w") > -1 && (n[0] = -1), r.indexOf("e") > -1 && (n[0] = 1), r.indexOf("n") > -1 && (n[1] = -1), r.indexOf("s") > -1 && (n[1] = 1), n;
    }
  }
}
function Cx(i, t) {
  return [Jt(t, i[0]), Jt(t, i[1]), Jt(t, i[2]), Jt(t, i[3])];
}
function Ti(i) {
  var t = i.left, e = i.top, r = i.pos1, n = i.pos2, s = i.pos3, a = i.pos4;
  return Cx([r, n, s, a], [t, e]);
}
function Du(i, t) {
  var e;
  (e = i[t]) === null || e === void 0 || e.unset(), i[t] = null;
}
function Ir(i, t) {
  if (t) {
    var e = fh(t);
    e.nextStyle = F(F({}, e.nextStyle), i);
  }
  return {
    style: i,
    cssText: Ps(i).map(function(r) {
      return "".concat(zp(r, "-"), ": ").concat(i[r], ";");
    }).join("")
  };
}
function yC(i, t, e) {
  var r = t.afterTransform || t.transform;
  return F(F({}, Ir(F(F(F({}, i.style), t.style), {
    transform: r
  }), e)), {
    afterTransform: r,
    transform: i.transform
  });
}
function Ut(i, t, e, r) {
  var n = t.datas;
  n.datas || (n.datas = {});
  var s = F(F({}, e), {
    target: i.state.target,
    clientX: t.clientX,
    clientY: t.clientY,
    inputEvent: t.inputEvent,
    currentTarget: i,
    moveable: i,
    datas: n.datas,
    isFirstDrag: !!t.isFirstDrag,
    isTrusted: t.isTrusted !== !1,
    stopAble: function() {
      n.isEventStart = !1;
    },
    stopDrag: function() {
      var a;
      (a = t.stop) === null || a === void 0 || a.call(t);
    }
  });
  return n.isStartEvent ? r || (n.lastEvent = s) : n.isStartEvent = !0, s;
}
function ui(i, t, e) {
  var r = t.datas, n = "isDrag" in e ? e.isDrag : t.isDrag;
  return r.datas || (r.datas = {}), F(F({
    isDrag: n
  }, e), {
    moveable: i,
    target: i.state.target,
    clientX: t.clientX,
    clientY: t.clientY,
    inputEvent: t.inputEvent,
    currentTarget: i,
    lastEvent: r.lastEvent,
    isDouble: t.isDouble,
    datas: r.datas,
    isFirstDrag: !!t.isFirstDrag
  });
}
function v0(i, t, e) {
  i._emitter.on(t, e);
}
function mt(i, t, e, r) {
  return i.triggerEvent(t, e, r);
}
function Mx(i, t) {
  return window.getComputedStyle(i, t);
}
function vp(i, t, e) {
  var r = {}, n = {};
  return i.filter(function(s) {
    var a = s.name;
    if (r[a] || !t.some(function(o) {
      return s[o];
    }))
      return !1;
    if (!e && s.ableGroup) {
      if (n[s.ableGroup])
        return !1;
      n[s.ableGroup] = !0;
    }
    return r[a] = !0, !0;
  });
}
function C_(i, t) {
  return i === t || i == null && t == null;
}
function QB() {
  for (var i = [], t = 0; t < arguments.length; t++)
    i[t] = arguments[t];
  for (var e = i.length - 1, r = 0; r < e; ++r) {
    var n = i[r];
    if (!o0(n))
      return n;
  }
  return i[e];
}
function _C(i, t) {
  var e = [], r = [];
  return i.forEach(function(n, s) {
    var a = t(n, s, i), o = r.indexOf(a), u = e[o] || [];
    o === -1 && (r.push(a), e.push(u)), u.push(n);
  }), e;
}
function tF(i, t) {
  var e = [], r = {};
  return i.forEach(function(n, s) {
    var a = t(n, s, i), o = r[a];
    o || (o = [], r[a] = o, e.push(o)), o.push(n);
  }), e;
}
function bC(i) {
  return i.reduce(function(t, e) {
    return t.concat(e);
  }, []);
}
function eh() {
  for (var i = [], t = 0; t < arguments.length; t++)
    i[t] = arguments[t];
  return i.sort(function(e, r) {
    return Math.abs(r) - Math.abs(e);
  }), i[0];
}
function rh(i, t, e) {
  return br(Nn(i, e), tu(t, e), e);
}
function xC(i, t) {
  var e, r = i.is3d, n = i.rootMatrix, s = r ? 4 : 3;
  return e = rh(n, [t.distX, t.distY], s), t.distX = e[0], t.distY = e[1], t;
}
function gp(i, t, e, r, n) {
  return Mt(nr(i, Jt(e, t), n), r);
}
function Vi(i, t, e) {
  return e ? "".concat(i / t * 100, "%") : "".concat(i, "px");
}
function Cv(i) {
  return Math.abs(i) <= Rr ? 0 : i;
}
function Px(i) {
  return function(t) {
    if (!t.isDragging(i))
      return "";
    var e = FB(t, i), r = e.deg;
    return r ? Pt("view-control-rotation".concat(r)) : "";
  };
}
function Ox(i, t) {
  return t === void 0 && (t = [i]), function(e, r) {
    if (r.isRequest)
      return t.some(function(s) {
        return r.requestAble === s;
      }) ? r.parentDirection : !1;
    var n = r.inputEvent.target;
    return sr(n, Pt("direction")) && (!i || sr(n, Pt(i)));
  };
}
function eF(i, t) {
  var e = i.slice(0, t < 0 ? void 0 : t), r = i.slice(0, t < 0 ? void 0 : t + 1), n = i[t] || "", s = t < 0 ? [] : i.slice(t), a = t < 0 ? [] : i.slice(t + 1), o = Ra(e), u = Ra(r), l = Ra([n]), h = Ra(s), d = Ra(a), f = _u(o), p = _u(u), v = _u(h), g = _u(d), m = _e(f, v, 4);
  return {
    transforms: i,
    beforeFunctionMatrix: f,
    beforeFunctionMatrix2: p,
    targetFunctionMatrix: _u(l),
    afterFunctionMatrix: v,
    afterFunctionMatrix2: g,
    allFunctionMatrix: m,
    beforeFunctions: o,
    beforeFunctions2: u,
    targetFunction: l[0],
    afterFunctions: h,
    afterFunctions2: d,
    beforeFunctionTexts: e,
    beforeFunctionTexts2: r,
    targetFunctionText: n,
    afterFunctionTexts: s,
    afterFunctionTexts2: a
  };
}
function rF(i) {
  return !i || !ha(i) || i instanceof Element ? !1 : tr(i) || "length" in i;
}
function iu(i, t) {
  return i ? i instanceof Element ? i : $r(i) ? t ? document.querySelector(i) : i : ax(i) ? i() : "current" in i ? i.current : i : null;
}
function Ix(i, t) {
  if (!i)
    return [];
  var e = rF(i) ? [].slice.call(i) : [i];
  return e.reduce(function(r, n) {
    return $r(n) && t ? Tt(Tt([], r, !0), [].slice.call(document.querySelectorAll(n)), !0) : (tr(n) ? r.push(Ix(n, t)) : r.push(iu(n, t)), r);
  }, []);
}
function iF(i, t, e) {
  var r = $e(i, t) / Math.PI * 180;
  return r = e >= 0 ? r : 180 - r, r = r >= 0 ? r : 360 + r, r;
}
function Sw(i, t) {
  var e = i.rootMatrix, r = i.is3d, n = r ? 4 : 3, s = Nn(e, n);
  return r || (s = An(s, 3, 4)), s[12] = 0, s[13] = 0, s[14] = 0, AL(s, t);
}
function wC(i, t, e, r, n) {
  var s = i[0], a = i[1], o = 0, u = 0;
  if (n && s && a) {
    var l = $e([0, 0], t), h = $e([0, 0], r), d = Ln(t), f = Math.cos(l - h) * d;
    if (!r[0])
      u = f, o = u * e;
    else if (!r[1])
      o = f, u = o / e;
    else {
      var p = r[0] * s, v = r[1] * a, g = Math.atan2(p + t[0], v + t[1]), m = Math.atan2(p, v);
      g < 0 && (g += Math.PI * 2), m < 0 && (m += Math.PI * 2);
      var y = 0;
      Math.abs(g - m) < Math.PI / 2 || Math.abs(g - m) > Math.PI / 2 * 3 || (m += Math.PI), y = g - m, y > Math.PI * 2 ? y -= Math.PI * 2 : y > Math.PI ? y = 2 * Math.PI - y : y < -Math.PI && (y = -2 * Math.PI - y);
      var _ = Ln([p + t[0], v + t[1]]) * Math.cos(y);
      o = _ * Math.sin(m) - p, u = _ * Math.cos(m) - v, r[0] < 0 && (o *= -1), r[1] < 0 && (u *= -1);
    }
  } else
    o = r[0] * t[0], u = r[1] * t[1];
  return [o, u];
}
function EC(i, t, e, r) {
  var n, s = e.ratio, a = e.startOffsetWidth, o = e.startOffsetHeight, u = 0, l = 0, h = r.distX, d = r.distY, f = r.pinchScale, p = r.parentDistance, v = r.parentDist, g = r.parentScale, m = e.fixedDirection, y = [0, 1].map(function(S) {
    return Math.abs(i[S] - m[S]);
  }), _ = [0, 1].map(function(S) {
    var C = y[S];
    return C !== 0 && (C = 2 / C), C;
  });
  if (v)
    u = v[0], l = v[1], t && (u ? l || (l = u / s) : u = l * s);
  else if (fc(f))
    u = (f - 1) * a, l = (f - 1) * o;
  else if (g)
    u = (g[0] - 1) * a, l = (g[1] - 1) * o;
  else if (p) {
    var b = a * y[0], w = o * y[1], T = Ln([b, w]);
    u = p / T * b * _[0], l = p / T * w * _[1];
  } else {
    var x = Un({
      datas: e,
      distX: h,
      distY: d
    });
    x = _.map(function(S, C) {
      return x[C] * S;
    }), n = wC([a, o], x, s, i, t), u = n[0], l = n[1];
  }
  return {
    // direction,
    // sizeDirection,
    distWidth: u,
    distHeight: l
  };
}
function M_(i, t) {
  if (t) {
    if (i === "left")
      return {
        x: "0%",
        y: "50%"
      };
    if (i === "top")
      return {
        x: "50%",
        y: "50%"
      };
    if (i === "center")
      return {
        x: "50%",
        y: "50%"
      };
    if (i === "right")
      return {
        x: "100%",
        y: "50%"
      };
    if (i === "bottom")
      return {
        x: "50%",
        y: "100%"
      };
    var e = i.split(" "), r = e[0], n = e[1], s = M_(r || ""), a = M_(n || ""), o = F(F({}, s), a), u = {
      x: "50%",
      y: "50%"
    };
    return o.x && (u.x = o.x), o.y && (u.y = o.y), o.value && (o.x && !o.y && (u.y = o.value), !o.x && o.y && (u.x = o.value)), u;
  }
  return i === "left" ? {
    x: "0%"
  } : i === "right" ? {
    x: "100%"
  } : i === "top" ? {
    y: "0%"
  } : i === "bottom" ? {
    y: "100%"
  } : i ? i === "center" ? {
    value: "50%"
  } : {
    value: i
  } : {};
}
function nF(i, t, e) {
  var r = M_(i, !0), n = r.x, s = r.y;
  return [Te(n, t) || 0, Te(s, e) || 0];
}
function sF(i, t, e) {
  var r = i.map(function(s) {
    return Mt(s, t);
  }), n = r.map(function(s) {
    return Td(s, e);
  });
  return {
    prev: r,
    next: n,
    result: n.map(function(s) {
      return Jt(s, t);
    })
  };
}
function SC(i, t) {
  return i.length === t.length && i.every(function(e, r) {
    var n = t[r], s = tr(e), a = tr(n);
    return s && a ? SC(e, n) : !s && !a ? e === n : !1;
  });
}
function Tw(i, t, e, r) {
  var n = i[t];
  return t in i && (n === e || r(n) === r(e)) ? n : (i[t] = e, e);
}
var aF = Pd("pinchable", {
  props: ["pinchable"],
  events: ["pinchStart", "pinch", "pinchEnd", "pinchGroupStart", "pinchGroup", "pinchGroupEnd"],
  dragStart: function() {
    return !0;
  },
  pinchStart: function(i, t) {
    var e = t.datas, r = t.targets, n = t.angle, s = t.originalDatas, a = i.props, o = a.pinchable, u = a.ables;
    if (!o)
      return !1;
    var l = "onPinch".concat(r ? "Group" : "", "Start"), h = "drag".concat(r ? "Group" : "", "ControlStart"), d = (o === !0 ? i.controlAbles : u.filter(function(g) {
      return o.indexOf(g.name) > -1;
    })).filter(function(g) {
      return g.canPinch && g[h];
    }), f = Ut(i, t, {});
    r && (f.targets = r);
    var p = mt(i, l, f);
    e.isPinch = p !== !1, e.ables = d;
    var v = e.isPinch;
    return v ? (d.forEach(function(g) {
      if (s[g.name] = s[g.name] || {}, !!g[h]) {
        var m = F(F({}, t), {
          datas: s[g.name],
          parentRotate: n,
          isPinch: !0
        });
        g[h](i, m);
      }
    }), i.state.snapRenderInfo = {
      request: t.isRequest,
      direction: [0, 0]
    }, v) : !1;
  },
  pinch: function(i, t) {
    var e = t.datas, r = t.scale, n = t.distance, s = t.originalDatas, a = t.inputEvent, o = t.targets, u = t.angle;
    if (e.isPinch) {
      var l = n * (1 - 1 / r), h = Ut(i, t, {});
      o && (h.targets = o);
      var d = "onPinch".concat(o ? "Group" : "");
      mt(i, d, h);
      var f = e.ables, p = "drag".concat(o ? "Group" : "", "Control");
      return f.forEach(function(v) {
        v[p] && v[p](i, F(F({}, t), {
          datas: s[v.name],
          inputEvent: a,
          resolveMatrix: !0,
          pinchScale: r,
          parentDistance: l,
          parentRotate: u,
          isPinch: !0
        }));
      }), h;
    }
  },
  pinchEnd: function(i, t) {
    var e = t.datas, r = t.isPinch, n = t.inputEvent, s = t.targets, a = t.originalDatas;
    if (e.isPinch) {
      var o = "onPinch".concat(s ? "Group" : "", "End"), u = ui(i, t, {
        isDrag: r
      });
      s && (u.targets = s), mt(i, o, u);
      var l = e.ables, h = "drag".concat(s ? "Group" : "", "ControlEnd");
      return l.forEach(function(d) {
        d[h] && d[h](i, F(F({}, t), {
          isDrag: r,
          datas: a[d.name],
          inputEvent: n,
          isPinch: !0
        }));
      }), r;
    }
  },
  pinchGroupStart: function(i, t) {
    return this.pinchStart(i, F(F({}, t), {
      targets: i.props.targets
    }));
  },
  pinchGroup: function(i, t) {
    return this.pinch(i, F(F({}, t), {
      targets: i.props.targets
    }));
  },
  pinchGroupEnd: function(i, t) {
    return this.pinchEnd(i, F(F({}, t), {
      targets: i.props.targets
    }));
  }
});
function Ji(i, t, e) {
  var r = e.originalDatas;
  r.groupable = r.groupable || {};
  var n = r.groupable;
  n.childDatas = n.childDatas || [];
  var s = n.childDatas;
  return i.moveables.map(function(a, o) {
    return s[o] = s[o] || {}, s[o][t] = s[o][t] || {}, F(F({}, e), {
      datas: s[o][t],
      originalDatas: s[o]
    });
  });
}
function uy(i, t, e, r, n, s, a) {
  var o = !!e.match(/Start$/g), u = !!e.match(/End$/g), l = n.isPinch, h = n.datas, d = Ji(i, t.name, n), f = i.moveables, p = d.map(function(v, g) {
    var m = f[g], y = m.state, _ = y.gestos, b = v;
    if (o)
      b = new Ql(a).dragStart(r, v);
    else {
      if (_[a] || (_[a] = h.childGestos[g]), !_[a])
        return;
      b = Od(v, y, r, l, s, a);
    }
    var w = t[e](m, F(F({}, b), {
      parentFlag: !0
    }));
    return u && (_[a] = null), w;
  });
  return o && (h.childGestos = f.map(function(v) {
    return v.state.gestos[a];
  })), p;
}
function Ss(i, t, e, r, n, s) {
  n === void 0 && (n = function(h, d) {
    return d;
  });
  var a = !!e.match(/End$/g), o = Ji(i, t.name, r), u = i.moveables, l = o.map(function(h, d) {
    var f = u[d], p = h;
    p = n(f, h);
    var v = t[e](f, F(F({}, p), {
      parentFlag: !0
    }));
    return v && s && s(f, h, v, d), a && (f.state.gestos = {}), v;
  });
  return l;
}
function Mv(i, t, e, r) {
  var n = e.fixedDirection, s = e.fixedPosition, a = r.datas.startPositions || Ti(t.state), o = ze(a, n), u = br(Cd(-i.rotation / 180 * Math.PI, 3), [o[0] - s[0], o[1] - s[1], 1], 3), l = u[0], h = u[1];
  return r.datas.originalX = l, r.datas.originalY = h, r;
}
var oF = ["left", "right", "center"], uF = ["top", "bottom", "middle"], da = {
  start: "left",
  end: "right",
  center: "center"
}, pa = {
  start: "top",
  end: "bottom",
  center: "middle"
};
function dh(i, t) {
  var e = i.props, r = e.snappable, n = e.bounds, s = e.innerBounds, a = e.verticalGuidelines, o = e.horizontalGuidelines, u = e.snapGridWidth, l = e.snapGridHeight, h = i.state, d = h.guidelines, f = h.enableSnap;
  return !r || !f || t && r !== !0 && r.indexOf(t) < 0 ? !1 : !!(u || l || n || s || d && d.length || a && a.length || o && o.length);
}
function Rx(i) {
  return i === !1 ? {} : i === !0 || !i ? {
    left: !0,
    right: !0,
    top: !0,
    bottom: !0
  } : i;
}
function lF(i, t) {
  var e = Rx(i), r = {};
  for (var n in e)
    n in t && e[n] && (r[n] = t[n]);
  return r;
}
function Dx(i, t) {
  var e = lF(i, t), r = uF.filter(function(s) {
    return s in e;
  }), n = oF.filter(function(s) {
    return s in e;
  });
  return {
    horizontal: r.map(function(s) {
      return e[s];
    }),
    vertical: n.map(function(s) {
      return e[s];
    })
  };
}
function hF(i, t, e) {
  var r = nr(i, [t.clientLeft, t.clientTop], e);
  return [t.left + r[0], t.top + r[1]];
}
function cF(i) {
  var t = i[0], e = i[1], r = e[0] - t[0], n = e[1] - t[1];
  Math.abs(r) < Je && (r = 0), Math.abs(n) < Je && (n = 0);
  var s = 0, a = 0, o = 0;
  return r ? n ? (s = -n / r, a = 1, o = s * t[0] - t[1]) : (a = 1, o = -t[1]) : (s = -1, o = t[0]), [s, a, o].map(function(u) {
    return Gt(u, Je);
  });
}
function g0(i, t, e, r) {
  var n = i.props, s = QB(r, n.snapThreshold, 5);
  return TC(i.state.guidelines, t, e, s);
}
function TC(i, t, e, r) {
  return {
    vertical: Mw(i, "vertical", t, r),
    horizontal: Mw(i, "horizontal", e, r)
  };
}
function fF(i, t, e) {
  var r = e[0], n = e[1], s = t[0], a = t[1], o = Mt(e, t), u = o[0], l = o[1], h = l > 0, d = u > 0;
  u = Cv(u), l = Cv(l);
  var f = {
    isSnap: !1,
    offset: 0,
    pos: 0
  }, p = {
    isSnap: !1,
    offset: 0,
    pos: 0
  };
  if (u === 0 && l === 0)
    return {
      vertical: f,
      horizontal: p
    };
  var v = g0(i, u ? [r] : [], l ? [n] : []), g = v.vertical, m = v.horizontal;
  g.posInfos.filter(function(G) {
    var B = G.pos;
    return d ? B >= s : B <= s;
  }), m.posInfos.filter(function(G) {
    var B = G.pos;
    return h ? B >= a : B <= a;
  }), g.isSnap = g.posInfos.length > 0, m.isSnap = m.posInfos.length > 0;
  var y = P_(g), _ = y.isSnap, b = y.guideline, w = P_(m), T = w.isSnap, x = w.guideline, S = T ? x.pos[1] : 0, C = _ ? b.pos[0] : 0;
  if (u === 0)
    T && (p.isSnap = !0, p.pos = x.pos[1], p.offset = n - p.pos);
  else if (l === 0)
    _ && (f.isSnap = !0, f.pos = C, f.offset = r - C);
  else {
    var M = l / u, I = e[1] - M * r, R = 0, N = 0, A = !1;
    _ ? (N = C, R = M * N + I, A = !0) : T && (R = S, N = (R - I) / M, A = !0), A && (f.isSnap = !0, f.pos = N, f.offset = r - N, p.isSnap = !0, p.pos = R, p.offset = n - R);
  }
  return {
    vertical: f,
    horizontal: p
  };
}
function Cw(i, t, e) {
  var r = Dx(i.props.snapDirections, t);
  return g0(i, r.vertical, r.horizontal, e);
}
function P_(i) {
  var t = i.isSnap;
  if (!t)
    return {
      isSnap: !1,
      offset: 0,
      dist: -1,
      pos: 0,
      guideline: null
    };
  var e = i.posInfos[0], r = e.guidelineInfos[0], n = r.offset, s = r.dist, a = r.guideline;
  return {
    isSnap: t,
    offset: n,
    dist: s,
    pos: e.pos,
    guideline: a
  };
}
function Mw(i, t, e, r) {
  if (!i || !i.length)
    return {
      isSnap: !1,
      index: -1,
      posInfos: []
    };
  var n = t === "vertical", s = n ? 0 : 1, a = e.map(function(u, l) {
    var h = i.map(function(d) {
      var f = d.pos, p = u - f[s];
      return {
        offset: p,
        dist: Math.abs(p),
        guideline: d
      };
    }).filter(function(d) {
      var f = d.guideline, p = d.dist, v = f.type;
      return !(v !== t || p > r);
    }).sort(function(d, f) {
      return d.dist - f.dist;
    });
    return {
      pos: u,
      index: l,
      guidelineInfos: h
    };
  }).filter(function(u) {
    return u.guidelineInfos.length > 0;
  }).sort(function(u, l) {
    return u.guidelineInfos[0].dist - l.guidelineInfos[0].dist;
  }), o = a.length > 0;
  return {
    isSnap: o,
    index: o ? a[0].index : -1,
    posInfos: a
  };
}
function dF(i, t, e, r) {
  r === void 0 && (r = 1);
  var n = [];
  if (e[0] && e[1])
    n = [e, [-e[0], e[1]], [e[0], -e[1]]].map(function(o) {
      return ze(t, o);
    });
  else if (!e[0] && !e[1])
    for (var s = [t[0], t[1], t[3], t[2], t[0]], a = 0; a < 4; ++a)
      n.push(s[a]), n.push([(s[a][0] + s[a + 1][0]) / 2, (s[a][1] + s[a + 1][1]) / 2]);
  else
    i.props.keepRatio ? n = [[-1, -1], [-1, 1], [1, -1], [1, 1], e].map(function(o) {
      return ze(t, o);
    }) : (n = IB(t, e), n.length > 1 && n.push([(n[0][0] + n[1][0]) / 2, (n[0][1] + n[1][1]) / 2]));
  return g0(i, n.map(function(o) {
    return o[0];
  }), n.map(function(o) {
    return o[1];
  }), r);
}
function CC(i, t) {
  var e = Math.abs(i.offset), r = Math.abs(t.offset);
  return i.isBound && t.isBound ? r - e : i.isBound ? -1 : t.isBound ? 1 : i.isSnap && t.isSnap ? r - e : i.isSnap ? -1 : t.isSnap || e < Rr ? 1 : r < Rr ? -1 : e - r;
}
function Pv(i, t) {
  return i.slice().sort(function(e, r) {
    var n = e.sign[t], s = r.sign[t], a = e.offset[t], o = r.offset[t];
    if (n) {
      if (!s)
        return -1;
    } else
      return 1;
    return CC({
      isBound: e.isBound,
      isSnap: e.isSnap,
      offset: a
    }, {
      isBound: r.isBound,
      isSnap: r.isSnap,
      offset: o
    });
  })[0];
}
function pF(i, t, e) {
  var r = [];
  if (e)
    Math.abs(t[0]) !== 1 || Math.abs(t[1]) !== 1 ? r.push([t, [-1, -1]], [t, [-1, 1]], [t, [1, -1]], [t, [1, 1]]) : r.push([t, [i[0], -i[1]]], [t, [-i[0], i[1]]]), r.push([t, i]);
  else if (i[0] && i[1] || !i[0] && !i[1]) {
    var n = i[0] ? i : [1, 1];
    [1, -1].forEach(function(a) {
      [1, -1].forEach(function(o) {
        var u = [a * n[0], o * n[1]];
        t[0] === u[0] && t[1] === u[1] || r.push([t, u]);
      });
    });
  } else if (i[0]) {
    var s = Math.abs(t[0]) === 1 ? [1] : [1, -1];
    s.forEach(function(a) {
      r.push([[t[0], -1], [a * i[0], -1]], [[t[0], 0], [a * i[0], 0]], [[t[0], 1], [a * i[0], 1]]);
    });
  } else if (i[1]) {
    var s = Math.abs(t[1]) === 1 ? [1] : [1, -1];
    s.forEach(function(o) {
      r.push([[-1, t[1]], [-1, o * i[1]]], [[0, t[1]], [0, o * i[1]]], [[1, t[1]], [1, o * i[1]]]);
    });
  }
  return r;
}
function MC(i, t) {
  var e = o_([t[0][0], t[1][0]]), r = o_([t[0][1], t[1][1]]);
  return {
    vertical: e <= i[0],
    horizontal: r <= i[1]
  };
}
function kx(i, t) {
  var e = t[0], r = t[1], n = r[0] - e[0], s = r[1] - e[1];
  Math.abs(n) < Rr && (n = 0), Math.abs(s) < Rr && (s = 0);
  var a, o;
  if (!n)
    a = e[0], o = i[0];
  else if (!s)
    a = e[1], o = i[1];
  else {
    var u = s / n;
    a = u * (i[0] - e[0]) + e[1], o = i[1];
  }
  return a - o;
}
function PC(i, t, e, r) {
  return r === void 0 && (r = Rr), i.every(function(n) {
    var s = kx(n, t), a = s <= 0;
    return a === e || Math.abs(s) <= r;
  });
}
function Pw(i, t, e, r, n) {
  return n === void 0 && (n = 0), r && t - n <= i || !r && i <= e + n ? {
    isBound: !0,
    offset: r ? t - i : e - i
  } : {
    isBound: !1,
    offset: 0
  };
}
function vF(i, t) {
  var e = t.line, r = t.centerSign, n = t.verticalSign, s = t.horizontalSign, a = t.lineConstants, o = i.props.innerBounds;
  if (!o)
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  var u = o.left, l = o.top, h = o.width, d = o.height, f = [[u, l], [u, l + d]], p = [[u, l], [u + h, l]], v = [[u + h, l], [u + h, l + d]], g = [[u, l + d], [u + h, l + d]];
  if (PC([[u, l], [u + h, l], [u, l + d], [u + h, l + d]], e, r))
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  var m = oa(e, a, p, n), y = oa(e, a, g, n), _ = oa(e, a, f, s), b = oa(e, a, v, s), w = m.isBound && y.isBound, T = m.isBound || y.isBound, x = _.isBound && b.isBound, S = _.isBound || b.isBound, C = eh(m.offset, y.offset), M = eh(_.offset, b.offset), I = [0, 0], R = !1, N = !1;
  return Math.abs(M) < Math.abs(C) ? (I = [C, 0], R = T, N = w) : (I = [0, M], R = S, N = x), {
    isAllBound: N,
    isVerticalBound: T,
    isHorizontalBound: S,
    isBound: R,
    offset: I
  };
}
function oa(i, t, e, r, n, s) {
  var a = t[0], o = t[1], u = i[0], l = e[0], h = e[1], d = Cv(h[1] - l[1]), f = Cv(h[0] - l[0]), p = o, v = a, g = -a / o;
  if (f) {
    if (!d) {
      if (s && !p)
        return {
          isBound: !1,
          offset: 0
        };
      if (v) {
        var b = (l[1] - u[1]) / g + u[0];
        return Pw(b, l[0], h[0], r, n);
      } else {
        var y = l[1] - u[1], _ = Math.abs(y) <= (n || 0);
        return {
          isBound: _,
          offset: _ ? y : 0
        };
      }
    }
  } else {
    if (s && !v)
      return {
        isBound: !1,
        offset: 0
      };
    if (p) {
      var m = g * (l[0] - u[0]) + u[1];
      return Pw(m, l[1], h[1], r, n);
    } else {
      var y = l[0] - u[0], _ = Math.abs(y) <= (n || 0);
      return {
        isBound: _,
        offset: _ ? y : 0
      };
    }
  }
  return {
    isBound: !1,
    offset: 0
  };
}
function OC(i, t, e) {
  return t.map(function(r) {
    var n = vF(i, r), s = n.isBound, a = n.offset, o = n.isVerticalBound, u = n.isHorizontalBound, l = r.multiple, h = Un({
      datas: e,
      distX: a[0],
      distY: a[1]
    }).map(function(d, f) {
      return d * (l[f] ? 2 / l[f] : 0);
    });
    return {
      sign: l,
      isBound: s,
      isVerticalBound: o,
      isHorizontalBound: u,
      isSnap: !1,
      offset: h
    };
  });
}
function gF(i, t, e) {
  var r, n = Nx(i, t, [0, 0], !1).map(function(f) {
    return F(F({}, f), {
      multiple: f.multiple.map(function(p) {
        return Math.abs(p) * 2;
      })
    });
  }), s = OC(i, n, e), a = Pv(s, 0), o = Pv(s, 1), u = 0, l = 0, h = a.isVerticalBound || o.isVerticalBound, d = a.isHorizontalBound || o.isHorizontalBound;
  return (h || d) && (r = PB({
    datas: e,
    distX: -a.offset[0],
    distY: -o.offset[1]
  }), u = r[0], l = r[1]), {
    vertical: {
      isBound: h,
      offset: u
    },
    horizontal: {
      isBound: d,
      offset: l
    }
  };
}
function mF(i, t) {
  var e = [], r = i[0], n = i[1];
  return r && n ? e.push([[0, n * 2], i, [-r, n]], [[r * 2, 0], i, [r, -n]]) : r ? (e.push([[r * 2, 0], [r, 1], [r, -1]]), t && e.push([[0, -1], [r, -1], [-r, -1]], [[0, 1], [r, 1], [-r, 1]])) : n ? (e.push([[0, n * 2], [1, n], [-1, n]]), t && e.push([[-1, 0], [-1, n], [-1, -n]], [[1, 0], [1, n], [1, -n]])) : e.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]), e;
}
function Nx(i, t, e, r) {
  var n = i.state, s = n.allMatrix, a = n.is3d, o = fa(s, 100, 100, a ? 4 : 3), u = ze(o, [0, 0]);
  return mF(e, r).map(function(l) {
    var h = l[0], d = l[1], f = l[2], p = [ze(o, d), ze(o, f)], v = cF(p), g = MC(u, p), m = g.vertical, y = g.horizontal, _ = kx(u, p) <= 0;
    return {
      multiple: h,
      centerSign: _,
      verticalSign: m,
      horizontalSign: y,
      lineConstants: v,
      line: [ze(t, d), ze(t, f)]
    };
  });
}
function Ow(i, t, e, r) {
  var n = r ? i.map(function(s) {
    return Td(s, r);
  }) : i;
  return [[n[0], n[1]], [n[1], n[3]], [n[3], n[2]], [n[2], n[0]]].some(function(s) {
    var a = kx(e, s) <= 0;
    return !PC(t, s, a);
  });
}
function yF(i) {
  var t = i[0], e = i[1], r = e[0] - t[0], n = e[1] - t[1];
  if (!r)
    return Math.abs(t[0]);
  if (!n)
    return Math.abs(t[1]);
  var s = n / r;
  return Math.abs((-s * t[0] + t[1]) / Math.sqrt(Math.pow(s, 2) + 1));
}
function _F(i) {
  var t = i[0], e = i[1], r = e[0] - t[0], n = e[1] - t[1];
  if (!r)
    return [t[0], 0];
  if (!n)
    return [0, t[1]];
  var s = n / r, a = -s * t[0] + t[1];
  return [-a / (s + 1 / s), a / (s * s + 1)];
}
function bF(i, t, e, r, n) {
  var s = i.props.innerBounds, a = n * Math.PI / 180;
  if (!s)
    return [];
  var o = s.left, u = s.top, l = s.width, h = s.height, d = o - r[0], f = o + l - r[0], p = u - r[1], v = u + h - r[1], g = [[d, p], [f, p], [d, v], [f, v]], m = ze(e, [0, 0]);
  if (!Ow(e, g, m, 0))
    return [];
  var y = [], _ = g.map(function(b) {
    return [Ln(b), $e([0, 0], b)];
  });
  return [[e[0], e[1]], [e[1], e[3]], [e[3], e[2]], [e[2], e[0]]].forEach(function(b) {
    var w = $e([0, 0], _F(b)), T = yF(b);
    y.push.apply(y, _.filter(function(x) {
      var S = x[0];
      return S && T <= S;
    }).map(function(x) {
      var S = x[0], C = x[1], M = Math.acos(S ? T / S : 0), I = C + M, R = C - M;
      return [a + I - w, a + R - w];
    }).reduce(function(x, S) {
      return x.push.apply(x, S), x;
    }, []).filter(function(x) {
      return !Ow(t, g, m, x);
    }).map(function(x) {
      return Gt(x * 180 / Math.PI, Rr);
    }));
  }), y;
}
function xF(i) {
  var t = i.props.innerBounds;
  if (!t)
    return {
      vertical: [],
      horizontal: []
    };
  var e = i.getRect(), r = e.pos1, n = e.pos2, s = e.pos3, a = e.pos4, o = [r, n, s, a], u = ze(o, [0, 0]), l = t.left, h = t.top, d = t.width, f = t.height, p = [[l, h], [l, h + f]], v = [[l, h], [l + d, h]], g = [[l + d, h], [l + d, h + f]], m = [[l, h + f], [l + d, h + f]], y = Nx(i, o, [0, 0], !1), _ = [], b = [], w = {
    top: !1,
    bottom: !1,
    left: !1,
    right: !1
  };
  return y.forEach(function(T) {
    var x = T.line, S = T.lineConstants, C = MC(u, x), M = C.horizontal, I = C.vertical, R = oa(x, S, v, I, 1, !0), N = oa(x, S, m, I, 1, !0), A = oa(x, S, p, M, 1, !0), G = oa(x, S, g, M, 1, !0);
    R.isBound && !w.top && (_.push(h), w.top = !0), N.isBound && !w.bottom && (_.push(h + f), w.bottom = !0), A.isBound && !w.left && (b.push(l), w.left = !0), G.isBound && !w.right && (b.push(l + d), w.right = !0);
  }), {
    horizontal: _,
    vertical: b
  };
}
function Ax(i, t, e) {
  var r = i || {}, n = r.position, s = n === void 0 ? "client" : n, a = r.left, o = a === void 0 ? -1 / 0 : a, u = r.top, l = u === void 0 ? -1 / 0 : u, h = r.right, d = h === void 0 ? 1 / 0 : h, f = r.bottom, p = f === void 0 ? 1 / 0 : f, v = {
    position: s,
    left: o,
    top: l,
    right: d,
    bottom: p
  };
  return {
    vertical: Iw(v, t, !0),
    horizontal: Iw(v, e, !1)
  };
}
function m0(i, t) {
  var e = i.state, r = e.containerClientRect, n = r.clientHeight, s = r.clientWidth, a = r.clientLeft, o = r.clientTop, u = e.snapOffset, l = u.left, h = u.top, d = u.right, f = u.bottom, p = t || i.props.bounds || {}, v = p.position || "client", g = v === "css", m = p.left, y = m === void 0 ? -1 / 0 : m, _ = p.top, b = _ === void 0 ? -1 / 0 : _, w = p.right, T = w === void 0 ? g ? -1 / 0 : 1 / 0 : w, x = p.bottom, S = x === void 0 ? g ? -1 / 0 : 1 / 0 : x;
  return g && (T = s + d - l - T, S = n + f - h - S), {
    left: y + l - a,
    right: T + l - a,
    top: b + h - o,
    bottom: S + h - o
  };
}
function wF(i, t, e) {
  var r = m0(i), n = r.left, s = r.top, a = r.right, o = r.bottom, u = e[0], l = e[1], h = Mt(e, t), d = h[0], f = h[1];
  Math.abs(d) < Rr && (d = 0), Math.abs(f) < Rr && (f = 0);
  var p = f > 0, v = d > 0, g = {
    isBound: !1,
    offset: 0,
    pos: 0
  }, m = {
    isBound: !1,
    offset: 0,
    pos: 0
  };
  if (d === 0 && f === 0)
    return {
      vertical: g,
      horizontal: m
    };
  if (d === 0)
    p ? o < l && (m.pos = o, m.offset = l - o) : s > l && (m.pos = s, m.offset = l - s);
  else if (f === 0)
    v ? a < u && (g.pos = a, g.offset = u - a) : n > u && (g.pos = n, g.offset = u - n);
  else {
    var y = f / d, _ = e[1] - y * u, b = 0, w = 0, T = !1;
    v && a <= u ? (b = y * a + _, w = a, T = !0) : !v && u <= n && (b = y * n + _, w = n, T = !0), T && (b < s || b > o) && (T = !1), T || (p && o <= l ? (b = o, w = (b - _) / y, T = !0) : !p && l <= s && (b = s, w = (b - _) / y, T = !0)), T && (g.isBound = !0, g.pos = w, g.offset = u - w, m.isBound = !0, m.pos = b, m.offset = l - b);
  }
  return {
    vertical: g,
    horizontal: m
  };
}
function Iw(i, t, e) {
  var r = i[e ? "left" : "top"], n = i[e ? "right" : "bottom"], s = Math.min.apply(Math, t), a = Math.max.apply(Math, t), o = [];
  return r + 1 > s && o.push({
    isBound: !0,
    offset: s - r,
    pos: r
  }), n - 1 < a && o.push({
    isBound: !0,
    offset: a - n,
    pos: n
  }), o.length || o.push({
    isBound: !1,
    offset: 0,
    pos: 0
  }), o.sort(function(u, l) {
    return Math.abs(l.offset) - Math.abs(u.offset);
  });
}
function Rw(i, t, e) {
  var r = e ? i.map(function(n) {
    return Td(n, e);
  }) : i;
  return r.some(function(n) {
    return n[0] < t.left && Math.abs(n[0] - t.left) > 0.1 || n[0] > t.right && Math.abs(n[0] - t.right) > 0.1 || n[1] < t.top && Math.abs(n[1] - t.top) > 0.1 || n[1] > t.bottom && Math.abs(n[1] - t.bottom) > 0.1;
  });
}
function EF(i, t, e) {
  var r = Ln(i), n = Math.sqrt(r * r - t * t) || 0;
  return [n, -n].sort(function(s, a) {
    return Math.abs(s - i[e ? 0 : 1]) - Math.abs(a - i[e ? 0 : 1]);
  }).map(function(s) {
    return $e([0, 0], e ? [s, t] : [t, s]);
  });
}
function SF(i, t, e, r, n) {
  if (!i.props.bounds)
    return [];
  var s = n * Math.PI / 180, a = m0(i), o = a.left, u = a.top, l = a.right, h = a.bottom, d = o - r[0], f = l - r[0], p = u - r[1], v = h - r[1], g = {
    left: d,
    top: p,
    right: f,
    bottom: v
  };
  if (!Rw(e, g, 0))
    return [];
  var m = [];
  return [[d, 0], [f, 0], [p, 1], [v, 1]].forEach(function(y) {
    var _ = y[0], b = y[1];
    e.forEach(function(w) {
      var T = $e([0, 0], w);
      m.push.apply(m, EF(w, _, b).map(function(x) {
        return s + x - T;
      }).filter(function(x) {
        return !Rw(t, g, x);
      }).map(function(x) {
        return Gt(x * 180 / Math.PI, Rr);
      }));
    });
  }), m;
}
function TF(i, t) {
  var e, r = i.direction, n = i.classNames, s = i.size, a = i.pos, o = i.zoom, u = i.key, l = r === "horizontal", h = l ? "Y" : "X";
  return t.createElement("div", {
    key: u,
    className: n.join(" "),
    style: (e = {}, e[l ? "width" : "height"] = "".concat(s), e.transform = "translate(".concat(a[0], ", ").concat(a[1], ") translate").concat(h, "(-50%) scale").concat(h, "(").concat(o, ")"), e)
  });
}
function Lx(i, t) {
  return TF(F(F({}, i), {
    classNames: Tt([Pt("line", "guideline", i.direction)], i.classNames, !0).filter(function(e) {
      return e;
    }),
    size: i.size || "".concat(i.sizeValue, "px"),
    pos: i.pos || i.posValue.map(function(e) {
      return "".concat(Gt(e, 0.1), "px");
    })
  }), t);
}
function Dw(i, t, e, r, n, s, a, o) {
  var u = i.props.zoom;
  return e.map(function(l, h) {
    var d = l.type, f = l.pos, p = [0, 0];
    return p[a] = r, p[a ? 0 : 1] = -n + f, Lx({
      key: "".concat(t, "TargetGuideline").concat(h),
      classNames: [Pt("target", "bold", d)],
      posValue: p,
      sizeValue: s,
      zoom: u,
      direction: t
    }, o);
  });
}
function kw(i, t, e, r, n, s) {
  var a = i.props, o = a.zoom, u = a.isDisplayInnerSnapDigit, l = t === "horizontal" ? da : pa, h = n[l.start], d = n[l.end];
  return e.filter(function(f) {
    var p = f.hide, v = f.elementRect;
    if (p)
      return !1;
    if (u && v) {
      var g = v.rect;
      if (g[l.start] <= h && d <= g[l.end])
        return !1;
    }
    return !0;
  }).map(function(f, p) {
    var v = f.pos, g = f.size, m = f.element, y = f.className, _ = [-r[0] + v[0], -r[1] + v[1]];
    return Lx({
      key: "".concat(t, "-default-guideline-").concat(p),
      classNames: m ? [Pt("bold"), y] : [Pt("normal"), y],
      direction: t,
      posValue: _,
      sizeValue: g,
      zoom: o
    }, s);
  });
}
function kh(i, t, e, r, n, s, a, o) {
  var u, l = i.props, h = l.snapDigit, d = h === void 0 ? 0 : h, f = l.isDisplaySnapDigit, p = f === void 0 ? !0 : f, v = l.snapDistFormat, g = v === void 0 ? function(T, x) {
    return T;
  } : v, m = l.zoom, y = t === "horizontal" ? "X" : "Y", _ = t === "vertical" ? "height" : "width", b = Math.abs(n), w = p ? parseFloat(b.toFixed(d)) : 0;
  return o.createElement("div", {
    key: "".concat(t, "-").concat(e, "-guideline-").concat(r),
    className: Pt("guideline-group", t),
    style: (u = {
      left: "".concat(s[0], "px"),
      top: "".concat(s[1], "px")
    }, u[_] = "".concat(b, "px"), u)
  }, Lx({
    direction: t,
    classNames: [Pt(e), a],
    size: "100%",
    posValue: [0, 0],
    sizeValue: b,
    zoom: m
  }, o), o.createElement("div", {
    className: Pt("size-value", "gap"),
    style: {
      transform: "translate".concat(y, "(-50%) scale(").concat(m, ")")
    }
  }, w > 0 ? g(w, t) : ""));
}
function CF(i, t, e, r) {
  var n = i === "vertical" ? 0 : 1, s = i === "vertical" ? 1 : 0, a = n ? da : pa, o = e[a.start], u = e[a.end];
  return _C(t, function(l) {
    return l.pos[n];
  }).map(function(l) {
    var h = [], d = [], f = [];
    return l.forEach(function(p) {
      var v, g, m = p.element, y = p.elementRect.rect;
      if (y[a.end] < o)
        h.push(p);
      else if (u < y[a.start])
        d.push(p);
      else if (y[a.start] <= o && u <= y[a.end] && r) {
        var _ = p.pos, b = {
          element: m,
          rect: F(F({}, y), (v = {}, v[a.end] = y[a.start], v))
        }, w = {
          element: m,
          rect: F(F({}, y), (g = {}, g[a.start] = y[a.end], g))
        }, T = [0, 0], x = [0, 0];
        T[n] = _[n], T[s] = _[s], x[n] = _[n], x[s] = _[s] + p.size, h.push({
          type: i,
          pos: T,
          size: 0,
          elementRect: b
        }), d.push({
          type: i,
          pos: x,
          size: 0,
          elementRect: w
        });
      }
    }), h.sort(function(p, v) {
      return v.pos[s] - p.pos[s];
    }), d.sort(function(p, v) {
      return p.pos[s] - v.pos[s];
    }), {
      total: l,
      start: h,
      end: d,
      inner: f
    };
  });
}
function MF(i, t, e, r, n) {
  var s = i.props.isDisplayInnerSnapDigit, a = [];
  return ["vertical", "horizontal"].forEach(function(o) {
    var u = t.filter(function(m) {
      return m.type === o;
    }), l = o === "vertical" ? 1 : 0, h = l ? 0 : 1, d = CF(o, u, r, s), f = l ? pa : da, p = l ? da : pa, v = r[f.start], g = r[f.end];
    d.forEach(function(m) {
      var y = m.total, _ = m.start, b = m.end, w = m.inner, T = e[h] + y[0].pos[h] - r[p.start], x = r;
      _.forEach(function(S) {
        var C = S.elementRect.rect, M = x[f.start] - C[f.end];
        if (M > 0) {
          var I = [0, 0];
          I[l] = e[l] + x[f.start] - v - M, I[h] = T, a.push(kh(i, o, "dashed", a.length, M, I, S.className, n));
        }
        x = C;
      }), x = r, b.forEach(function(S) {
        var C = S.elementRect.rect, M = C[f.start] - x[f.end];
        if (M > 0) {
          var I = [0, 0];
          I[l] = e[l] + x[f.end] - v, I[h] = T, a.push(kh(i, o, "dashed", a.length, M, I, S.className, n));
        }
        x = C;
      }), w.forEach(function(S) {
        var C = S.elementRect.rect, M = v - C[f.start], I = C[f.end] - g, R = [0, 0], N = [0, 0];
        R[l] = e[l] - M, R[h] = T, N[l] = e[l] + g - v, N[h] = T, a.push(kh(i, o, "dashed", a.length, M, R, S.className, n)), a.push(kh(i, o, "dashed", a.length, I, N, S.className, n));
      });
    });
  }), a;
}
function PF(i, t, e, r, n) {
  var s = [];
  return ["horizontal", "vertical"].forEach(function(a) {
    var o = t.filter(function(m) {
      return m.type === a;
    }).slice(0, 1), u = a === "vertical" ? 0 : 1, l = u ? 0 : 1, h = u ? pa : da, d = u ? da : pa, f = r[h.start], p = r[h.end], v = r[d.start], g = r[d.end];
    o.forEach(function(m) {
      var y = m.gap, _ = m.gapRects, b = Math.max.apply(Math, Tt([v], _.map(function(x) {
        var S = x.rect;
        return S[d.start];
      }), !1)), w = Math.min.apply(Math, Tt([g], _.map(function(x) {
        var S = x.rect;
        return S[d.end];
      }), !1)), T = (b + w) / 2;
      b === w || T === (v + g) / 2 || _.forEach(function(x) {
        var S = x.rect, C = x.className, M = [e[0], e[1]];
        if (S[h.end] < f)
          M[u] += S[h.end] - f;
        else if (p < S[h.start])
          M[u] += S[h.start] - f - y;
        else
          return;
        M[l] += T - v, s.push(kh(i, u ? "vertical" : "horizontal", "gap", s.length, y, M, C, n));
      });
    });
  }), s;
}
function OF(i, t, e, r) {
  var n = t[0] - i[0], s = t[1] - i[1];
  if (Math.abs(n) < Je && (n = 0), Math.abs(s) < Je && (s = 0), !n)
    return r ? [0, 0] : [0, e];
  if (!s)
    return r ? [e, 0] : [0, 0];
  var a = s / n, o = i[1] - a * i[0];
  if (r) {
    var u = a * (t[0] + e) + o;
    return [e, u - t[1]];
  } else {
    var l = (t[1] + e - o) / a;
    return [l - t[0], e];
  }
}
function O_(i, t, e, r, n) {
  var s = OF(i, t, e, r);
  if (!s)
    return {
      isOutside: !1,
      offset: [0, 0]
    };
  var a = Zi(i, t), o = Zi(s, i), u = Zi(s, t), l = o > a || u > a, h = Un({
    datas: n,
    distX: s[0],
    distY: s[1]
  }), d = h[0], f = h[1];
  return {
    offset: [d, f],
    isOutside: l
  };
}
function Ov(i, t) {
  return i.isBound ? i.offset : t.isSnap ? P_(t).offset : 0;
}
function IF(i, t, e, r, n) {
  var s = t[0], a = t[1], o = e[0], u = e[1], l = r[0], h = r[1], d = n[0], f = n[1], p = -d, v = -f;
  if (i && s && a) {
    p = 0, v = 0;
    var g = [];
    if (o && u ? g.push([0, f], [d, 0]) : o ? g.push([d, 0]) : u ? g.push([0, f]) : l && h ? g.push([0, f], [d, 0]) : l ? g.push([d, 0]) : h && g.push([0, f]), g.length) {
      g.sort(function(b, w) {
        return Ln(Mt([s, a], b)) - Ln(Mt([s, a], w));
      });
      var m = g[0];
      if (m[0] && Math.abs(s) > Je)
        p = -m[0], v = a * Math.abs(s + p) / Math.abs(s) - a;
      else if (m[1] && Math.abs(a) > Je) {
        var y = a;
        v = -m[1], p = s * Math.abs(a + v) / Math.abs(y) - s;
      }
      if (i && u && o)
        if (Math.abs(p) > Je && Math.abs(p) < Math.abs(d)) {
          var _ = Math.abs(d) / Math.abs(p);
          p *= _, v *= _;
        } else if (Math.abs(v) > Je && Math.abs(v) < Math.abs(f)) {
          var _ = Math.abs(f) / Math.abs(v);
          p *= _, v *= _;
        } else
          p = eh(-d, p), v = eh(-f, v);
    }
  } else
    p = s || o ? -d : 0, v = a || u ? -f : 0;
  return [p, v];
}
function RF(i, t, e, r, n, s) {
  if (!dh(i, "draggable"))
    return [{
      isSnap: !1,
      isBound: !1,
      offset: 0
    }, {
      isSnap: !1,
      isBound: !1,
      offset: 0
    }];
  var a = Cx(s.absolutePoses, [t, e]), o = Si(a), u = o.left, l = o.right, h = o.top, d = o.bottom, f = {
    horizontal: a.map(function(G) {
      return G[1];
    }),
    vertical: a.map(function(G) {
      return G[0];
    })
  }, p = Rx(i.props.snapDirections), v = Dx(p, {
    left: u,
    right: l,
    top: h,
    bottom: d,
    center: (u + l) / 2,
    middle: (h + d) / 2
  }), g = y0(i, n, v, f), m = g.vertical, y = g.horizontal, _ = gF(i, a, s), b = _.vertical, w = _.horizontal, T = m.isSnap, x = y.isSnap, S = m.isBound || b.isBound, C = y.isBound || w.isBound, M = eh(m.offset, b.offset), I = eh(y.offset, w.offset), R = IF(r, [t, e], [S, C], [T, x], [M, I]), N = R[0], A = R[1];
  return [{
    isBound: S,
    isSnap: T,
    offset: N
  }, {
    isBound: C,
    isSnap: x,
    offset: A
  }];
}
function y0(i, t, e, r) {
  r === void 0 && (r = e);
  var n = Ax(m0(i), r.vertical, r.horizontal), s = n.horizontal, a = n.vertical, o = t ? {
    horizontal: {
      isSnap: !1,
      index: -1
    },
    vertical: {
      isSnap: !1,
      index: -1
    }
  } : g0(i, e.vertical, e.horizontal), u = o.horizontal, l = o.vertical, h = Ov(s[0], u), d = Ov(a[0], l), f = Math.abs(h), p = Math.abs(d);
  return {
    horizontal: {
      isBound: s[0].isBound,
      isSnap: u.isSnap,
      snapIndex: u.index,
      offset: h,
      dist: f,
      bounds: s,
      snap: u
    },
    vertical: {
      isBound: a[0].isBound,
      isSnap: l.isSnap,
      snapIndex: l.index,
      offset: d,
      dist: p,
      bounds: a,
      snap: l
    }
  };
}
function Nw(i, t, e, r, n) {
  var s = Ax(t, e, r), a = s.horizontal, o = s.vertical, u = TC(i, e, r, n), l = u.horizontal, h = u.vertical, d = Ov(a[0], l), f = Ov(o[0], h), p = Math.abs(d), v = Math.abs(f);
  return {
    horizontal: {
      isBound: a[0].isBound,
      isSnap: l.isSnap,
      snapIndex: l.index,
      offset: d,
      dist: p,
      bounds: a,
      snap: l
    },
    vertical: {
      isBound: o[0].isBound,
      isSnap: h.isSnap,
      snapIndex: h.index,
      offset: f,
      dist: v,
      bounds: o,
      snap: h
    }
  };
}
function DF(i, t, e, r) {
  var n = $e(i, t) / Math.PI * 180, s = e.vertical, a = s.isBound, o = s.isSnap, u = s.dist, l = e.horizontal, h = l.isBound, d = l.isSnap, f = l.dist, p = n % 180, v = p < 3 || p > 177, g = p > 87 && p < 93;
  return f < u && (a || o && !g && (!r || !v)) ? "vertical" : h || d && !v && (!r || !g) ? "horizontal" : "";
}
function kF(i, t, e, r, n, s) {
  return e.map(function(a) {
    var o = a[0], u = a[1], l = ze(t, o), h = ze(t, u), d = r ? NF(i, l, h, n) : y0(i, n, {
      vertical: [h[0]],
      horizontal: [h[1]]
    }), f = d.horizontal, p = f.offset, v = f.isBound, g = f.isSnap, m = d.vertical, y = m.offset, _ = m.isBound, b = m.isSnap, w = Mt(u, o);
    if (!y && !p)
      return {
        isBound: _ || v,
        isSnap: b || g,
        sign: w,
        offset: [0, 0]
      };
    var T = DF(l, h, d, r);
    if (!T)
      return {
        sign: w,
        isBound: !1,
        isSnap: !1,
        offset: [0, 0]
      };
    var x = T === "vertical", S = [0, 0];
    return !r && Math.abs(u[0]) === 1 && Math.abs(u[1]) === 1 && o[0] !== u[0] && o[1] !== u[1] ? S = Un({
      datas: s,
      distX: -y,
      distY: -p
    }) : S = O_(l, h, -(x ? y : p), x, s).offset, S = S.map(function(C, M) {
      return C * (w[M] ? 2 / w[M] : 0);
    }), {
      sign: w,
      isBound: x ? _ : v,
      isSnap: x ? b : g,
      offset: S
    };
  });
}
function Aw(i, t) {
  return i.isBound ? i.offset : t.isSnap ? t.offset : 0;
}
function NF(i, t, e, r) {
  var n = wF(i, t, e), s = n.horizontal, a = n.vertical, o = r ? {
    horizontal: {
      isSnap: !1
    },
    vertical: {
      isSnap: !1
    }
  } : fF(i, t, e), u = o.horizontal, l = o.vertical, h = Aw(s, u), d = Aw(a, l), f = Math.abs(h), p = Math.abs(d);
  return {
    horizontal: {
      isBound: s.isBound,
      isSnap: u.isSnap,
      offset: h,
      dist: f
    },
    vertical: {
      isBound: a.isBound,
      isSnap: l.isSnap,
      offset: d,
      dist: p
    }
  };
}
function AF(i, t, e, r, n) {
  var s = [-e[0], -e[1]], a = i.state, o = a.width, u = a.height, l = i.props.bounds, h = 1 / 0, d = 1 / 0;
  if (l) {
    var f = [[e[0], -e[1]], [-e[0], e[1]]], p = l.left, v = p === void 0 ? -1 / 0 : p, g = l.top, m = g === void 0 ? -1 / 0 : g, y = l.right, _ = y === void 0 ? 1 / 0 : y, b = l.bottom, w = b === void 0 ? 1 / 0 : b;
    f.forEach(function(T) {
      var x = T[0] !== s[0], S = T[1] !== s[1], C = ze(t, T), M = $e(r, C) * 360 / Math.PI;
      if (S) {
        var I = C.slice();
        (Math.abs(M - 360) < 2 || Math.abs(M - 180) < 2) && (I[1] = r[1]);
        var R = O_(r, I, (r[1] < C[1] ? w : m) - C[1], !1, n), N = R.offset, A = N[1], G = R.isOutside;
        isNaN(A) || (d = u + (G ? 1 : -1) * Math.abs(A));
      }
      if (x) {
        var I = C.slice();
        (Math.abs(M - 90) < 2 || Math.abs(M - 270) < 2) && (I[0] = r[0]);
        var B = O_(r, I, (r[0] < C[0] ? _ : v) - C[0], !0, n), U = B.offset[0], $ = B.isOutside;
        isNaN(U) || (h = o + ($ ? 1 : -1) * Math.abs(U));
      }
    });
  }
  return {
    maxWidth: h,
    maxHeight: d
  };
}
function I_(i) {
  var t = i.state, e = t.containerClientRect, r = t.hasFixed, n = e.overflow, s = e.scrollHeight, a = e.scrollWidth, o = e.clientHeight, u = e.clientWidth, l = e.clientLeft, h = e.clientTop, d = i.props, f = d.snapGap, p = f === void 0 ? !0 : f, v = d.verticalGuidelines, g = d.horizontalGuidelines, m = d.snapThreshold, y = m === void 0 ? 5 : m, _ = d.snapGridWidth, b = _ === void 0 ? 0 : _, w = d.snapGridHeight, T = w === void 0 ? 0 : w, x = d.maxSnapElementGuidelineDistance, S = x === void 0 ? 1 / 0 : x, C = Si(Ti(i.state)), M = C.top, I = C.left, R = C.bottom, N = C.right, A = {
    top: M,
    left: I,
    bottom: R,
    right: N,
    center: (I + N) / 2,
    middle: (M + R) / 2
  }, G = FF(i), B = Tt([], G, !0);
  p && B.push.apply(B, LF(i, A, y)), B.push.apply(B, BF(b, T, n ? a : u, n ? s : o, l, h));
  var U = F({}, t.snapOffset || {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  });
  if (r) {
    var $ = e.left, Z = e.top;
    U.left += $, U.top += Z, U.right += $, U.bottom += Z;
  }
  return B.push.apply(B, RC(g || !1, v || !1, n ? a : u, n ? s : o, l, h, U)), B = B.filter(function(H) {
    var z = H.element, X = H.elementRect, ct = H.type;
    if (!z || !X)
      return !0;
    var it = X.rect;
    return IC(A, it, ct, S);
  }), B;
}
function LF(i, t, e) {
  var r = i.props, n = r.maxSnapElementGuidelineDistance, s = n === void 0 ? 1 / 0 : n, a = r.maxSnapElementGapDistance, o = a === void 0 ? 1 / 0 : a, u = i.state.elementRects, l = [];
  return [["vertical", da, pa], ["horizontal", pa, da]].forEach(function(h) {
    var d = h[0], f = h[1], p = h[2], v = t[f.start], g = t[f.end], m = t[f.center], y = t[p.start], _ = t[p.end];
    function b(x) {
      var S = x.rect;
      return S[f.end] < v + e ? v - S[f.end] : g - e < S[f.start] ? S[f.start] - g : -1;
    }
    var w = u.filter(function(x) {
      var S = x.rect;
      return S[p.start] > _ || S[p.end] < y ? !1 : b(x) > 0;
    }).sort(function(x, S) {
      return b(x) - b(S);
    }), T = [];
    w.forEach(function(x) {
      w.forEach(function(S) {
        if (x !== S) {
          var C = x.rect, M = S.rect, I = C[p.start], R = C[p.end], N = M[p.start], A = M[p.end];
          I > A || N > R || T.push([x, S]);
        }
      });
    }), T.forEach(function(x) {
      var S = x[0], C = x[1], M = S.rect, I = C.rect, R = M[f.start], N = M[f.end], A = I[f.start], G = I[f.end], B = 0, U = 0, $ = !1, Z = !1, H = !1;
      if (N <= v && g <= A) {
        if (Z = !0, B = (A - N - (g - v)) / 2, U = N + B + (g - v) / 2, Math.abs(U - m) > e)
          return;
      } else if (N < A && G < v + e) {
        if ($ = !0, B = A - N, U = G + B, Math.abs(U - v) > e)
          return;
      } else if (N < A && g - e < R) {
        if (H = !0, B = A - N, U = R - B, Math.abs(U - g) > e)
          return;
      } else
        return;
      B && IC(t, I, d, s) && (B > o || l.push({
        type: d,
        pos: d === "vertical" ? [U, 0] : [0, U],
        element: C.element,
        size: 0,
        className: C.className,
        isStart: $,
        isCenter: Z,
        isEnd: H,
        gap: B,
        hide: !0,
        gapRects: [S, C]
      }));
    });
  }), l;
}
function BF(i, t, e, r, n, s) {
  n === void 0 && (n = 0), s === void 0 && (s = 0);
  var a = [];
  if (t)
    for (var o = 0; o <= r; o += t)
      a.push({
        type: "horizontal",
        pos: [0, Gt(o - s, 0.1)],
        size: e,
        hide: !0
      });
  if (i)
    for (var o = 0; o <= e; o += i)
      a.push({
        type: "vertical",
        pos: [Gt(o - n, 0.1), 0],
        size: r,
        hide: !0
      });
  return a;
}
function IC(i, t, e, r) {
  return e === "horizontal" ? Math.abs(i.right - t.left) <= r || Math.abs(i.left - t.right) <= r || i.left <= t.right && t.left <= i.right : e === "vertical" ? Math.abs(i.bottom - t.top) <= r || Math.abs(i.top - t.bottom) <= r || i.top <= t.bottom && t.top <= i.bottom : !0;
}
function FF(i) {
  var t = i.state, e = i.props.elementGuidelines, r = e === void 0 ? [] : e;
  if (!r.length)
    return t.elementRects = [], [];
  var n = (t.elementRects || []).filter(function(f) {
    return !f.refresh;
  }), s = r.map(function(f) {
    return ha(f) && "element" in f ? F(F({}, f), {
      element: iu(f.element, !0)
    }) : {
      element: iu(f, !0)
    };
  }).filter(function(f) {
    return f.element;
  }), a = FL(n.map(function(f) {
    return f.element;
  }), s.map(function(f) {
    return f.element;
  })), o = a.maintained, u = a.added, l = [];
  o.forEach(function(f) {
    var p = f[0], v = f[1];
    l[v] = n[p];
  }), GF(i, u.map(function(f) {
    return s[f];
  })).map(function(f, p) {
    l[u[p]] = f;
  }), t.elementRects = l;
  var h = Rx(i.props.elementSnapDirections), d = [];
  return l.forEach(function(f) {
    var p = f.element, v = f.top, g = v === void 0 ? h.top : v, m = f.left, y = m === void 0 ? h.left : m, _ = f.right, b = _ === void 0 ? h.right : _, w = f.bottom, T = w === void 0 ? h.bottom : w, x = f.center, S = x === void 0 ? h.center : x, C = f.middle, M = C === void 0 ? h.middle : C, I = f.className, R = f.rect, N = Dx({
      top: g,
      right: b,
      left: y,
      bottom: T,
      center: S,
      middle: M
    }, R), A = N.horizontal, G = N.vertical, B = R.top, U = R.left, $ = R.right - U, Z = R.bottom - B, H = [$, Z];
    G.forEach(function(z) {
      d.push({
        type: "vertical",
        element: p,
        pos: [Gt(z, 0.1), B],
        size: Z,
        sizes: H,
        className: I,
        elementRect: f
      });
    }), A.forEach(function(z) {
      d.push({
        type: "horizontal",
        element: p,
        pos: [U, Gt(z, 0.1)],
        size: $,
        sizes: H,
        className: I,
        elementRect: f
      });
    });
  }), d;
}
function Lw(i, t) {
  return i ? i.map(function(e) {
    var r = ha(e) ? e : {
      pos: e
    }, n = r.pos;
    return fc(n) ? r : F(F({}, r), {
      pos: Te(n, t)
    });
  }) : [];
}
function RC(i, t, e, r, n, s, a) {
  n === void 0 && (n = 0), s === void 0 && (s = 0), a === void 0 && (a = {
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  });
  var o = [], u = a.left, l = a.top, h = a.bottom, d = a.right, f = e + d - u, p = r + h - l;
  return Lw(i, p).forEach(function(v) {
    o.push({
      type: "horizontal",
      pos: [u, Gt(v.pos - s + l, 0.1)],
      size: f,
      className: v.className
    });
  }), Lw(t, f).forEach(function(v) {
    o.push({
      type: "vertical",
      pos: [Gt(v.pos - n + u, 0.1), l],
      size: p,
      className: v.className
    });
  }), o;
}
function GF(i, t) {
  if (!t.length)
    return [];
  var e = i.state, r = e.containerClientRect, n = e.rootMatrix, s = e.is3d, a = e.offsetDelta, o = s ? 4 : 3, u = hF(n, r, o), l = u[0], h = u[1];
  return t.map(function(d) {
    var f = d.element.getBoundingClientRect(), p = f.left - l - a[0], v = f.top - h - a[1], g = v + f.height, m = p + f.width, y = rh(n, [p, v], o), _ = y[0], b = y[1], w = rh(n, [m, g], o), T = w[0], x = w[1];
    return F(F({}, d), {
      rect: {
        left: _,
        right: T,
        top: b,
        bottom: x,
        center: (_ + T) / 2,
        middle: (b + x) / 2
      }
    });
  });
}
function mp(i) {
  var t = i.state, e = t.container, r = i.props.snapContainer || e;
  if (t.snapContainer === r && t.guidelines && t.guidelines.length)
    return !1;
  var n = t.containerClientRect, s = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  };
  if (e !== r) {
    var a = iu(r, !0);
    if (a) {
      var o = Zh(a), u = Sw(t, [o.left - n.left, o.top - n.top]), l = Sw(t, [o.right - n.right, o.bottom - n.bottom]);
      s.left = Gt(u[0], 1e-5), s.top = Gt(u[1], 1e-5), s.right = Gt(l[0], 1e-5), s.bottom = Gt(l[1], 1e-5);
    }
  }
  return t.snapContainer = r, t.snapOffset = s, t.guidelines = I_(i), t.enableSnap = !0, !0;
}
function DC(i, t, e, r, n, s) {
  var a = fa(i, t, e, s ? 4 : 3), o = ze(a, r);
  return Cx(a, Mt(n, o));
}
function UF(i, t, e, r, n, s) {
  var a = s.fixedDirection, o = pF(e, a, r), u = Nx(i, t, e, r), l = Tt(Tt([], kF(i, t, o, r, n, s), !0), OC(i, u, s), !0), h = Pv(l, 0), d = Pv(l, 1);
  return {
    width: {
      isBound: h.isBound,
      offset: h.offset[0]
    },
    height: {
      isBound: d.isBound,
      offset: d.offset[1]
    }
  };
}
function jF(i, t, e, r, n, s, a, o, u) {
  var l = ze(t, a), h = y0(i, o, {
    vertical: [l[0]],
    horizontal: [l[1]]
  }), d = h.horizontal.offset, f = h.vertical.offset;
  if (Gt(f, w_) || Gt(d, w_)) {
    var p = Un({
      datas: u,
      distX: -f,
      distY: -d
    }), v = p[0], g = p[1], m = Math.min(n || 1 / 0, e + a[0] * v), y = Math.min(s || 1 / 0, r + a[1] * g);
    return [m - e, y - r];
  }
  return [0, 0];
}
function kC(i, t, e, r, n, s, a, o) {
  for (var u = Ti(i.state), l = i.props.keepRatio, h = 0, d = 0, f = 0; f < 2; ++f) {
    var p = t(h, d), v = UF(i, p, n, l, a, o), g = v.width, m = v.height, y = g.isBound, _ = m.isBound, b = g.offset, w = m.offset;
    if (f === 1 && (y || (b = 0), _ || (w = 0)), f === 0 && a && !y && !_)
      return [0, 0];
    if (l) {
      var T = Math.abs(b) * (e ? 1 / e : 1), x = Math.abs(w) * (r ? 1 / r : 1), S = y && _ ? T < x : _ || !y && T < x;
      S ? b = e * w / r : w = r * b / e;
    }
    h += b, d += w;
  }
  if (n[0] && n[1]) {
    var C = AF(i, u, n, s, o), M = C.maxWidth, I = C.maxHeight, R = jF(i, t(h, d).map(function(G) {
      return G.map(function(B) {
        return Gt(B, w_);
      });
    }), e + h, r + d, M, I, n, a, o), b = R[0], w = R[1];
    h += b, d += w;
  }
  return [h, d];
}
function zF(i, t, e) {
  if (!dh(i, "rotatable"))
    return {
      isSnap: !1,
      rotation: e
    };
  var r = t.pos1, n = t.pos2, s = t.pos3, a = t.pos4, o = t.origin, u = e * Math.PI / 180, l = [r, n, s, a].map(function(p) {
    return Mt(p, o);
  }), h = l.map(function(p) {
    return Td(p, u);
  }), d = Tt(Tt([], SF(i, l, h, o, e), !0), bF(i, l, h, o, e), !0);
  d.sort(function(p, v) {
    return Math.abs(p - e) - Math.abs(v - e);
  });
  var f = d.length > 0;
  return {
    isSnap: f,
    rotation: f ? d[0] : e
  };
}
function HF(i, t, e, r, n, s, a) {
  if (!dh(i, "resizable"))
    return [0, 0];
  var o = a.fixedDirection, u = a.nextAllMatrix, l = i.state, h = l.allMatrix, d = l.is3d;
  return kC(i, function(f, p) {
    return DC(u || h, t + f, e + p, o, n, d);
  }, t, e, r, n, s, a);
}
function $F(i, t, e, r, n) {
  if (!dh(i, "scalable"))
    return [0, 0];
  var s = n.startOffsetWidth, a = n.startOffsetHeight, o = n.fixedPosition, u = n.fixedDirection, l = n.is3d, h = kC(i, function(d, f) {
    return DC(kB(n, Jt(t, [d / s, f / a])), s, a, u, o, l);
  }, s, a, e, o, r, n);
  return [h[0] / s, h[1] / a];
}
function VF(i, t) {
  t.absolutePoses = Ti(i.state);
}
function Bw(i) {
  var t = [];
  return i.forEach(function(e) {
    e.guidelineInfos.forEach(function(r) {
      var n = r.guideline;
      t.indexOf(n) > -1 || t.push(n);
    });
  }), t;
}
function Fw(i, t, e, r, n, s) {
  var a = Ax(m0(i, s), t, e), o = a.vertical, u = a.horizontal;
  o.forEach(function(f) {
    f.isBound && r.push({
      type: "bounds",
      pos: f.pos
    });
  }), u.forEach(function(f) {
    f.isBound && n.push({
      type: "bounds",
      pos: f.pos
    });
  });
  var l = xF(i), h = l.vertical, d = l.horizontal;
  h.forEach(function(f) {
    Ms(r, function(p) {
      var v = p.type, g = p.pos;
      return v === "bounds" && g === f;
    }) >= 0 || r.push({
      type: "bounds",
      pos: f
    });
  }), d.forEach(function(f) {
    Ms(n, function(p) {
      var v = p.type, g = p.pos;
      return v === "bounds" && g === f;
    }) >= 0 || n.push({
      type: "bounds",
      pos: f
    });
  });
}
var XF = Ox("", ["resizable", "scalable"]), WF = {
  name: "snappable",
  dragRelation: "strong",
  props: ["snappable", "snapContainer", "snapDirections", "elementSnapDirections", "snapGap", "snapGridWidth", "snapGridHeight", "isDisplaySnapDigit", "isDisplayInnerSnapDigit", "snapDigit", "snapThreshold", "snapRenderThreshold", "horizontalGuidelines", "verticalGuidelines", "elementGuidelines", "bounds", "innerBounds", "snapDistFormat", "maxSnapElementGuidelineDistance", "maxSnapElementGapDistance"],
  events: ["snap"],
  css: [`:host {
--bounds-color: #d66;
}
.guideline {
pointer-events: none;
z-index: 2;
}
.guideline.bounds {
background: #d66;
background: var(--bounds-color);
}
.guideline-group {
position: absolute;
top: 0;
left: 0;
}
.guideline-group .size-value {
position: absolute;
color: #f55;
font-size: 12px;
font-size: calc(12px * var(--zoom));
font-weight: bold;
}
.guideline-group.horizontal .size-value {
transform-origin: 50% 100%;
transform: translateX(-50%);
left: 50%;
bottom: 5px;
bottom: calc(2px + 3px * var(--zoom));
}
.guideline-group.vertical .size-value {
transform-origin: 0% 50%;
top: 50%;
transform: translateY(-50%);
left: 5px;
left: calc(2px + 3px * var(--zoom));
}
.guideline.gap {
background: #f55;
}
.size-value.gap {
color: #f55;
}
`],
  render: function(i, t) {
    var e = i.state, r = e.top, n = e.left, s = e.pos1, a = e.pos2, o = e.pos3, u = e.pos4, l = e.snapRenderInfo, h = i.props.snapRenderThreshold, d = h === void 0 ? 1 : h;
    if (!l || !l.render || !dh(i, ""))
      return [];
    e.guidelines = I_(i);
    var f = Math.min(s[0], a[0], o[0], u[0]), p = Math.min(s[1], a[1], o[1], u[1]), v = l.externalPoses || [], g = Ti(i.state), m = [], y = [], _ = [], b = [], w = [], T = Si(g), x = T.width, S = T.height, C = T.top, M = T.left, I = T.bottom, R = T.right, N = {
      left: M,
      right: R,
      top: C,
      bottom: I,
      center: (M + R) / 2,
      middle: (C + I) / 2
    }, A = v.length > 0, G = A ? Si(v) : {};
    if (!l.request) {
      if (l.direction && w.push(dF(i, g, l.direction, d)), l.snap) {
        var B = Si(g);
        l.center && (B.middle = (B.top + B.bottom) / 2, B.center = (B.left + B.right) / 2), w.push(Cw(i, B, d));
      }
      A && (l.center && (G.middle = (G.top + G.bottom) / 2, G.center = (G.left + G.right) / 2), w.push(Cw(i, G, d))), w.forEach(function(H) {
        var z = H.vertical.posInfos, X = H.horizontal.posInfos;
        m.push.apply(m, z.filter(function(ct) {
          var it = ct.guidelineInfos;
          return it.some(function(lt) {
            var et = lt.guideline;
            return !et.hide;
          });
        }).map(function(ct) {
          return {
            type: "snap",
            pos: ct.pos
          };
        })), y.push.apply(y, X.filter(function(ct) {
          var it = ct.guidelineInfos;
          return it.some(function(lt) {
            var et = lt.guideline;
            return !et.hide;
          });
        }).map(function(ct) {
          return {
            type: "snap",
            pos: ct.pos
          };
        })), _.push.apply(_, Bw(z)), b.push.apply(b, Bw(X));
      });
    }
    Fw(i, [M, R], [C, I], m, y), A && Fw(i, [G.left, G.right], [G.top, G.bottom], m, y, l.externalBounds);
    var U = Tt(Tt([], _, !0), b, !0), $ = U.filter(function(H) {
      return H.element && !H.gapRects;
    }), Z = U.filter(function(H) {
      return H.gapRects;
    }).sort(function(H, z) {
      return H.gap - z.gap;
    });
    return mt(i, "onSnap", {
      guidelines: U.filter(function(H) {
        var z = H.element;
        return !z;
      }),
      elements: $,
      gaps: Z
    }, !0), Tt(Tt(Tt(Tt(Tt(Tt([], MF(i, $, [f, p], N, t), !0), PF(i, Z, [f, p], N, t), !0), kw(i, "horizontal", b, [n, r], N, t), !0), kw(i, "vertical", _, [n, r], N, t), !0), Dw(i, "horizontal", y, f, r, x, 0, t), !0), Dw(i, "vertical", m, p, n, S, 1, t), !0);
  },
  dragStart: function(i, t) {
    i.state.snapRenderInfo = {
      request: t.isRequest,
      snap: !0,
      center: !0
    }, mp(i);
  },
  drag: function(i) {
    var t = i.state;
    mp(i) || (t.guidelines = I_(i)), t.snapRenderInfo && (t.snapRenderInfo.render = !0);
  },
  pinchStart: function(i) {
    this.unset(i);
  },
  dragEnd: function(i) {
    this.unset(i);
  },
  dragControlCondition: function(i, t) {
    if (XF(i, t) || D_(i, t))
      return !0;
    if (!t.isRequest && t.inputEvent)
      return sr(t.inputEvent.target, Pt("snap-control"));
  },
  dragControlStart: function(i) {
    i.state.snapRenderInfo = null, mp(i);
  },
  dragControl: function(i) {
    this.drag(i);
  },
  dragControlEnd: function(i) {
    this.unset(i);
  },
  dragGroupStart: function(i, t) {
    this.dragStart(i, t);
  },
  dragGroup: function(i) {
    this.drag(i);
  },
  dragGroupEnd: function(i) {
    this.unset(i);
  },
  dragGroupControlStart: function(i) {
    i.state.snapRenderInfo = null, mp(i);
  },
  dragGroupControl: function(i) {
    this.drag(i);
  },
  dragGroupControlEnd: function(i) {
    this.unset(i);
  },
  unset: function(i) {
    var t = i.state;
    t.enableSnap = !1, t.guidelines = [], t.snapRenderInfo = null, t.elementRects = [];
  }
};
function NC(i, t, e, r) {
  var n = i.getState(), s = n.renderPoses, a = n.rotation, o = n.direction, u = ru(i.props, t).zoom, l = o > 0 ? 1 : -1, h = a / Math.PI * 180, d = {}, f = i.renderState;
  f.renderDirectionMap || (f.renderDirectionMap = {});
  var p = f.renderDirectionMap;
  return e.forEach(function(v) {
    var g = v.dir;
    d[g] = !0;
  }), e.map(function(v) {
    var g = v.data, m = v.classNames, y = v.dir, _ = xx[y];
    if (!_ || !d[y])
      return null;
    p[y] = !0;
    var b = (Gt(h, 15) + l * KT[y] + 720) % 180, w = {};
    return Ps(g).forEach(function(T) {
      w["data-".concat(T)] = g[T];
    }), r.createElement("div", F({
      className: Pt.apply(void 0, Tt(["control", "direction", y, t], m, !1)),
      "data-rotation": b,
      "data-direction": y
    }, w, {
      key: "direction-".concat(y),
      style: Tx.apply(void 0, Tt([a, u], _.map(function(T) {
        return s[T];
      }), !1))
    }));
  });
}
function AC(i, t, e, r) {
  var n = ru(i.props, e), s = n.renderDirections, a = s === void 0 ? t : s, o = n.displayAroundControls;
  if (!a)
    return [];
  var u = a === !0 ? _x : a;
  return Tt(Tt([], o ? GC(i, r, e, u) : [], !0), NC(i, e, u.map(function(l) {
    return {
      data: {},
      classNames: [],
      dir: l
    };
  }), r), !0);
}
function mc(i, t, e, r, n, s) {
  for (var a = [], o = 6; o < arguments.length; o++)
    a[o - 6] = arguments[o];
  var u = $e(e, r), l = t ? Gt(u / Math.PI * 180, 15) % 180 : -1;
  return i.createElement("div", {
    key: "line-".concat(s),
    className: Pt.apply(void 0, Tt(["line", "direction", t ? "edge" : "", t], a, !1)),
    "data-rotation": l,
    "data-line-key": s,
    "data-direction": t,
    style: Dh(e, r, n, u)
  });
}
function LC(i, t, e, r, n) {
  var s = e === !0 ? dB : e;
  return s.map(function(a, o) {
    var u = xx[a], l = u[0], h = u[1];
    if (h != null)
      return mc(i, a, r[l], r[h], n, "".concat(t, "Edge").concat(o), t);
  }).filter(Boolean);
}
function BC(i) {
  return function(t, e) {
    var r = ru(t.props, i).edge;
    return r && (r === !0 || r.length) ? Tt(Tt([], LC(e, i, r, t.getState().renderPoses, t.props.zoom), !0), YF(t, i, e), !0) : FC(t, i, e);
  };
}
function FC(i, t, e) {
  return AC(i, _x, t, e);
}
function YF(i, t, e) {
  return AC(i, ["nw", "ne", "sw", "se"], t, e);
}
function GC(i, t, e, r) {
  var n = i.renderState;
  n.renderDirectionMap || (n.renderDirectionMap = {});
  var s = i.getState(), a = s.renderPoses, o = s.rotation, u = s.direction, l = n.renderDirectionMap, h = i.props.zoom, d = u > 0 ? 1 : -1, f = o / Math.PI * 180;
  return (r || Ps(l)).map(function(p) {
    var v = xx[p];
    if (!v)
      return null;
    var g = (Gt(f, 15) + d * KT[p] + 720) % 180, m = ["around-control"];
    return e && m.push("direction", e), t.createElement("div", {
      className: Pt.apply(void 0, m),
      "data-rotation": g,
      "data-direction": p,
      key: "direction-around-".concat(p),
      style: Tx.apply(void 0, Tt([o, h], v.map(function(y) {
        return a[y];
      }), !1))
    });
  });
}
var Or = {
  name: "draggable",
  props: ["draggable", "throttleDrag", "throttleDragRotate", "startDragRotate", "edgeDraggable"],
  events: ["dragStart", "drag", "dragEnd", "dragGroupStart", "dragGroup", "dragGroupEnd"],
  requestStyle: function() {
    return ["left", "top", "right", "bottom"];
  },
  requestChildStyle: function() {
    return ["left", "top", "right", "bottom"];
  },
  render: function(i, t) {
    var e = i.props, r = e.throttleDragRotate, n = e.zoom, s = i.getState(), a = s.dragInfo, o = s.beforeOrigin;
    if (!r || !a)
      return [];
    var u = a.dist;
    if (!u[0] && !u[1])
      return [];
    var l = Ln(u), h = $e(u, [0, 0]);
    return [t.createElement("div", {
      className: Pt("line", "horizontal", "dragline", "dashed"),
      key: "dragRotateGuideline",
      style: {
        width: "".concat(l, "px"),
        transform: "translate(".concat(o[0], "px, ").concat(o[1], "px) rotate(").concat(h, "rad) scaleY(").concat(n, ")")
      }
    })];
  },
  dragStart: function(i, t) {
    var e = t.datas, r = t.parentEvent, n = t.parentGesto, s = i.state, a = s.gestos, o = s.style;
    if (a.draggable)
      return !1;
    a.draggable = n || i.targetGesto, e.datas = {}, e.left = parseFloat(o.left || "") || 0, e.top = parseFloat(o.top || "") || 0, e.bottom = parseFloat(o.bottom || "") || 0, e.right = parseFloat(o.right || "") || 0, e.startValue = [0, 0], au(i, t), d0(t, "translate"), VF(i, e), e.prevDist = [0, 0], e.prevBeforeDist = [0, 0], e.isDrag = !1, e.deltaOffset = [0, 0];
    var u = Ut(i, t, F({
      set: function(h) {
        e.startValue = h;
      }
    }, f0(t))), l = r || mt(i, "onDragStart", u);
    return l !== !1 ? (e.isDrag = !0, i.state.dragInfo = {
      startRect: i.getRect(),
      dist: [0, 0]
    }) : (a.draggable = null, e.isPinch = !1), e.isDrag ? u : !1;
  },
  drag: function(i, t) {
    if (t) {
      h0(t, "translate");
      var e = t.datas, r = t.parentEvent, n = t.parentFlag, s = t.isPinch, a = t.isRequest, o = t.deltaOffset, u = t.distX, l = t.distY, h = e.isDrag, d = e.prevDist, f = e.prevBeforeDist, p = e.startValue;
      if (h) {
        o && (u += o[0], l += o[1]);
        var v = i.props, g = v.parentMoveable, m = r ? 0 : v.throttleDrag || 0, y = r ? 0 : v.throttleDragRotate || 0, _ = 0, b = !1, w = !1, T = !1, x = !1;
        if (!r && y > 0 && (u || l)) {
          var S = v.startDragRotate || 0, C = Gt(S + $e([0, 0], [u, l]) * 180 / Math.PI, y) - S, M = l * Math.abs(Math.cos((C - 90) / 180 * Math.PI)), I = u * Math.abs(Math.cos(C / 180 * Math.PI)), R = Ln([I, M]);
          _ = C * Math.PI / 180, u = R * Math.cos(_), l = R * Math.sin(_);
        }
        if (!s && !r && !n) {
          var N = RF(i, u, l, y, a || o, e), A = N[0], G = N[1];
          b = A.isSnap, w = A.isBound, T = G.isSnap, x = G.isBound;
          var B = A.offset, U = G.offset;
          u += B, l += U;
        }
        var $ = Jt(eC({
          datas: e,
          distX: u,
          distY: l
        }), p), Z = Jt(MB({
          datas: e,
          distX: u,
          distY: l
        }), p);
        hw(Z, Rr), hw($, Rr), y || (!b && !w && (Z[0] = Gt(Z[0], m), $[0] = Gt($[0], m)), !T && !x && (Z[1] = Gt(Z[1], m), $[1] = Gt($[1], m)));
        var H = Mt($, p), z = Mt(Z, p), X = Mt(z, d), ct = Mt(H, f);
        e.prevDist = z, e.prevBeforeDist = H, e.passDelta = X, e.passDist = z;
        var it = e.left + H[0], lt = e.top + H[1], et = e.right - H[0], k = e.bottom - H[1], ft = c0(e, "translate(".concat(Z[0], "px, ").concat(Z[1], "px)"), "translate(".concat(z[0], "px, ").concat(z[1], "px)"));
        if (wx(t, ft), i.state.dragInfo.dist = r ? [0, 0] : z, !(!r && !g && X.every(function(bt) {
          return !bt;
        }) && ct.some(function(bt) {
          return !bt;
        }))) {
          var Q = i.state, St = Q.width, at = Q.height, q = Ut(i, t, F({
            transform: ft,
            dist: z,
            delta: X,
            translate: Z,
            beforeDist: H,
            beforeDelta: ct,
            beforeTranslate: $,
            left: it,
            top: lt,
            right: et,
            bottom: k,
            width: St,
            height: at,
            isPinch: s
          }, Ir({
            transform: ft
          }, t)));
          return !r && mt(i, "onDrag", q), q;
        }
      }
    }
  },
  dragAfter: function(i, t) {
    var e = t.datas, r = e.deltaOffset;
    return r[0] || r[1] ? (e.deltaOffset = [0, 0], this.drag(i, F(F({}, t), {
      deltaOffset: r
    }))) : !1;
  },
  dragEnd: function(i, t) {
    var e = t.parentEvent, r = t.datas;
    if (i.state.dragInfo = null, !!r.isDrag) {
      r.isDrag = !1;
      var n = ui(i, t, {});
      return !e && mt(i, "onDragEnd", n), n;
    }
  },
  dragGroupStart: function(i, t) {
    var e = t.datas, r = t.clientX, n = t.clientY, s = this.dragStart(i, t);
    if (!s)
      return !1;
    var a = uy(i, this, "dragStart", [r || 0, n || 0], t, !1, "draggable"), o = F(F({}, s), {
      targets: i.props.targets,
      events: a
    }), u = mt(i, "onDragGroupStart", o);
    return e.isDrag = u !== !1, e.isDrag ? s : !1;
  },
  dragGroup: function(i, t) {
    var e = t.datas;
    if (e.isDrag) {
      var r = this.drag(i, t), n = t.datas.passDelta, s = uy(i, this, "drag", n, t, !1, "draggable");
      if (r) {
        var a = F({
          targets: i.props.targets,
          events: s
        }, r);
        return mt(i, "onDragGroup", a), a;
      }
    }
  },
  dragGroupEnd: function(i, t) {
    var e = t.isDrag, r = t.datas;
    if (r.isDrag) {
      this.dragEnd(i, t);
      var n = uy(i, this, "dragEnd", [0, 0], t, !1, "draggable");
      return mt(i, "onDragGroupEnd", ui(i, t, {
        targets: i.props.targets,
        events: n
      })), e;
    }
  },
  /**
   * @method Moveable.Draggable#request
   * @param {object} [e] - the draggable's request parameter
   * @param {number} [e.x] - x position
   * @param {number} [e.y] - y position
   * @param {number} [e.deltaX] - X number to move
   * @param {number} [e.deltaY] - Y number to move
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * // Use Relative Value
   * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
   * // Use Absolute Value
   * moveable.request("draggable", { x: 200, y: 100 }, true);
   *
   * // requestStart
   * const requester = moveable.request("draggable");
   *
   * // request
   * // Use Relative Value
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * // Use Absolute Value
   * moveable.request("draggable", { x: 200, y: 100 });
   * moveable.request("draggable", { x: 220, y: 100 });
   * moveable.request("draggable", { x: 240, y: 100 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function(i) {
    var t = {}, e = i.getRect(), r = 0, n = 0;
    return {
      isControl: !1,
      requestStart: function() {
        return {
          datas: t
        };
      },
      request: function(s) {
        return "x" in s ? r = s.x - e.left : "deltaX" in s && (r += s.deltaX), "y" in s ? n = s.y - e.top : "deltaY" in s && (n += s.deltaY), {
          datas: t,
          distX: r,
          distY: n
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  },
  unset: function(i) {
    i.state.gestos.draggable = null, i.state.dragInfo = null;
  }
}, Gw = Ox("resizable"), R_ = {
  name: "resizable",
  ableGroup: "size",
  canPinch: !0,
  props: ["resizable", "throttleResize", "renderDirections", "displayAroundControls", "keepRatio", "resizeFormat", "keepRatioFinally", "edge", "checkResizableError"],
  events: ["resizeStart", "beforeResize", "resize", "resizeEnd", "resizeGroupStart", "beforeResizeGroup", "resizeGroup", "resizeGroupEnd"],
  render: BC("resizable"),
  dragControlCondition: Gw,
  viewClassName: Px("resizable"),
  dragControlStart: function(i, t) {
    var e, r = t.inputEvent, n = t.isPinch, s = t.isGroup, a = t.parentDirection, o = t.parentGesto, u = t.datas, l = t.parentFixedDirection, h = t.parentEvent, d = gC(a, n, r, u), f = i.state, p = f.target, v = f.width, g = f.height, m = f.gestos;
    if (!d || !p || m.resizable)
      return !1;
    m.resizable = o || i.controlGesto, !n && au(i, t), u.datas = {}, u.direction = d, u.startOffsetWidth = v, u.startOffsetHeight = g, u.prevWidth = 0, u.prevHeight = 0, u.minSize = [0, 0], u.startWidth = f.inlineCSSWidth || f.cssWidth, u.startHeight = f.inlineCSSHeight || f.cssHeight, u.maxSize = [1 / 0, 1 / 0], s || (u.minSize = [f.minOffsetWidth, f.minOffsetHeight], u.maxSize = [f.maxOffsetWidth, f.maxOffsetHeight]);
    var y = i.props.transformOrigin || "% %";
    u.transformOrigin = y && $r(y) ? y.split(" ") : y, u.startOffsetMatrix = f.offsetMatrix, u.startTransformOrigin = f.transformOrigin, u.isWidth = (e = t == null ? void 0 : t.parentIsWidth) !== null && e !== void 0 ? e : !d[0] && !d[1] || d[0] || !d[1];
    function _(M) {
      u.ratio = M && isFinite(M) ? M : 0;
    }
    u.startPositions = Ti(i.state);
    function b(M) {
      u.fixedDirection = M, u.fixedPosition = ze(u.startPositions, M);
    }
    function w(M) {
      var I = i.state, R = I.width, N = I.height;
      u.fixedPosition = M, u.fixedDirection = aC(M, R, N);
    }
    function T(M) {
      u.minSize = [Te("".concat(M[0]), 0) || 0, Te("".concat(M[1]), 0) || 0];
    }
    function x(M) {
      var I = [M[0] || 1 / 0, M[1] || 1 / 0];
      (!fc(I[0]) || isFinite(I[0])) && (I[0] = Te("".concat(I[0]), 0) || 1 / 0), (!fc(I[1]) || isFinite(I[1])) && (I[1] = Te("".concat(I[1]), 0) || 1 / 0), u.maxSize = I;
    }
    _(v / g), b(l || [-d[0], -d[1]]), u.setFixedDirection = b, u.setFixedPosition = w, u.setMin = T, u.setMax = x;
    var S = Ut(i, t, {
      direction: d,
      startRatio: u.ratio,
      set: function(M) {
        var I = M[0], R = M[1];
        u.startWidth = I, u.startHeight = R;
      },
      setMin: T,
      setMax: x,
      setRatio: _,
      setFixedDirection: b,
      setFixedPosition: w,
      setOrigin: function(M) {
        u.transformOrigin = M;
      },
      dragStart: Or.dragStart(i, new Ql().dragStart([0, 0], t))
    }), C = h || mt(i, "onResizeStart", S);
    return u.startFixedDirection = u.fixedDirection, u.startFixedPosition = u.fixedPosition, C !== !1 && (u.isResize = !0, i.state.snapRenderInfo = {
      request: t.isRequest,
      direction: d
    }), u.isResize ? S : !1;
  },
  dragControl: function(i, t) {
    var e, r = t.datas, n = t.parentFlag, s = t.isPinch, a = t.parentKeepRatio, o = t.dragClient, u = t.parentDist, l = t.isRequest, h = t.isGroup, d = t.parentEvent, f = t.resolveMatrix, p = r.isResize, v = r.transformOrigin, g = r.startWidth, m = r.startHeight, y = r.prevWidth, _ = r.prevHeight, b = r.minSize, w = r.maxSize, T = r.ratio, x = r.startOffsetWidth, S = r.startOffsetHeight, C = r.isWidth;
    if (!p)
      return;
    if (f) {
      var M = i.state.is3d, I = r.startOffsetMatrix, R = r.startTransformOrigin, N = M ? 4 : 3, A = mx(iC(t)), G = Math.sqrt(A.length);
      N !== G && (A = An(A, G, N));
      var B = Id(I, A, R, N), U = fa(B, x, S, N);
      r.startPositions = U, r.nextTargetMatrix = A, r.nextAllMatrix = B;
    }
    var $ = ru(i.props, "resizable"), Z = $.resizeFormat, H = $.throttleResize, z = H === void 0 ? n ? 0 : 1 : H, X = $.parentMoveable, ct = $.keepRatioFinally, it = r.direction, lt = it, et = 0, k = 0;
    !it[0] && !it[1] && (lt = [1, 1]);
    var ft = T && (a ?? $.keepRatio) || !1;
    function Q() {
      var ee = r.fixedDirection, pe = EC(lt, ft, r, t);
      et = pe.distWidth, k = pe.distHeight;
      var le = lt[0] - ee[0] || ft ? Math.max(x + et, Rr) : x, ae = lt[1] - ee[1] || ft ? Math.max(S + k, Rr) : S;
      return ft && x && S && (C ? ae = le / T : le = ae * T), [le, ae];
    }
    var St = Q(), at = St[0], q = St[1];
    d || (r.setFixedDirection(r.fixedDirection), mt(i, "onBeforeResize", Ut(i, t, {
      startFixedDirection: r.startFixedDirection,
      startFixedPosition: r.startFixedPosition,
      setFixedDirection: function(ee) {
        var pe;
        return r.setFixedDirection(ee), pe = Q(), at = pe[0], q = pe[1], [at, q];
      },
      setFixedPosition: function(ee) {
        var pe;
        return r.setFixedPosition(ee), pe = Q(), at = pe[0], q = pe[1], [at, q];
      },
      boundingWidth: at,
      boundingHeight: q,
      setSize: function(ee) {
        at = ee[0], q = ee[1];
      }
    }, !0)));
    var bt = o;
    o || (!n && s ? bt = BB(i, [0, 0]) : bt = r.fixedPosition);
    var st = [0, 0];
    s || (st = HF(i, at, q, it, bt, l, r)), u && (!u[0] && (st[0] = 0), !u[1] && (st[1] = 0));
    function W() {
      var ee;
      Z && (ee = Z([at, q]), at = ee[0], q = ee[1]), at = Gt(at, z), q = Gt(q, z);
    }
    if (ft) {
      lt[0] && lt[1] && st[0] && st[1] && (Math.abs(st[0]) > Math.abs(st[1]) ? st[1] = 0 : st[0] = 0);
      var nt = !st[0] && !st[1];
      nt && W(), lt[0] && !lt[1] || st[0] && !st[1] || nt && C ? (at += st[0], q = at / T) : (!lt[0] && lt[1] || !st[0] && st[1] || nt && !C) && (q += st[1], at = q * T);
    } else
      at += st[0], q += st[1], at = Math.max(0, at), q = Math.max(0, q);
    e = VA([at, q], b, w, ft ? T : !1), at = e[0], q = e[1], W(), ft && (h || ct) && (C ? q = at / T : at = q * T), et = at - x, k = q - S;
    var dt = [et - y, k - _];
    r.prevWidth = et, r.prevHeight = k;
    var V = LB(i, at, q, bt, v, r);
    if (!(!X && dt.every(function(ee) {
      return !ee;
    }) && V.every(function(ee) {
      return !ee;
    }))) {
      var xt = Or.drag(i, Od(t, i.state, V, !!s, !1, "draggable")), Dt = xt.transform, Ct = g + et, be = m + k, je = Ut(i, t, F({
        width: Ct,
        height: be,
        offsetWidth: Math.round(at),
        offsetHeight: Math.round(q),
        startRatio: T,
        boundingWidth: at,
        boundingHeight: q,
        direction: it,
        dist: [et, k],
        delta: dt,
        isPinch: !!s,
        drag: xt
      }, yC({
        style: {
          width: "".concat(Ct, "px"),
          height: "".concat(be, "px")
        },
        transform: Dt
      }, xt, t)));
      return !d && mt(i, "onResize", je), je;
    }
  },
  dragControlAfter: function(i, t) {
    var e = t.datas, r = e.isResize, n = e.startOffsetWidth, s = e.startOffsetHeight, a = e.prevWidth, o = e.prevHeight;
    if (!(!r || i.props.checkResizableError === !1)) {
      var u = i.state, l = u.width, h = u.height, d = l - (n + a), f = h - (s + o), p = Math.abs(d) > 3, v = Math.abs(f) > 3;
      if (p && (e.startWidth += d, e.startOffsetWidth += d, e.prevWidth += d), v && (e.startHeight += f, e.startOffsetHeight += f, e.prevHeight += f), p || v)
        return this.dragControl(i, t);
    }
  },
  dragControlEnd: function(i, t) {
    var e = t.datas, r = t.parentEvent;
    if (e.isResize) {
      e.isResize = !1;
      var n = ui(i, t, {});
      return !r && mt(i, "onResizeEnd", n), n;
    }
  },
  dragGroupControlCondition: Gw,
  dragGroupControlStart: function(i, t) {
    var e = t.datas, r = this.dragControlStart(i, F(F({}, t), {
      isGroup: !0
    }));
    if (!r)
      return !1;
    var n = Ji(i, "resizable", t), s = e.startOffsetWidth, a = e.startOffsetHeight;
    function o() {
      var p = e.minSize;
      n.forEach(function(v) {
        var g = v.datas, m = g.minSize, y = g.startOffsetWidth, _ = g.startOffsetHeight, b = s * (y ? m[0] / y : 0), w = a * (_ ? m[1] / _ : 0);
        p[0] = Math.max(p[0], b), p[1] = Math.max(p[1], w);
      });
    }
    function u() {
      var p = e.maxSize;
      n.forEach(function(v) {
        var g = v.datas, m = g.maxSize, y = g.startOffsetWidth, _ = g.startOffsetHeight, b = s * (y ? m[0] / y : 0), w = a * (_ ? m[1] / _ : 0);
        p[0] = Math.min(p[0], b), p[1] = Math.min(p[1], w);
      });
    }
    var l = Ss(i, this, "dragControlStart", t, function(p, v) {
      return Mv(i, p, e, v);
    });
    o(), u();
    var h = function(p) {
      r.setFixedDirection(p), l.forEach(function(v, g) {
        v.setFixedDirection(p), Mv(i, v.moveable, e, n[g]);
      });
    };
    e.setFixedDirection = h;
    var d = F(F({}, r), {
      targets: i.props.targets,
      events: l.map(function(p) {
        return F(F({}, p), {
          setMin: function(v) {
            p.setMin(v), o();
          },
          setMax: function(v) {
            p.setMax(v), u();
          }
        });
      }),
      setFixedDirection: h,
      setMin: function(p) {
        r.setMin(p), o();
      },
      setMax: function(p) {
        r.setMax(p), u();
      }
    }), f = mt(i, "onResizeGroupStart", d);
    return e.isResize = f !== !1, e.isResize ? r : !1;
  },
  dragGroupControl: function(i, t) {
    var e = t.datas;
    if (e.isResize) {
      var r = ru(i.props, "resizable");
      v0(i, "onBeforeResize", function(p) {
        mt(i, "onBeforeResizeGroup", Ut(i, t, F(F({}, p), {
          targets: r.targets
        }), !0));
      });
      var n = this.dragControl(i, F(F({}, t), {
        isGroup: !0
      }));
      if (n) {
        var s = n.boundingWidth, a = n.boundingHeight, o = n.dist, u = r.keepRatio, l = [s / (s - o[0]), a / (a - o[1])], h = e.fixedPosition, d = Ss(i, this, "dragControl", t, function(p, v) {
          var g = br(Cd(i.rotation / 180 * Math.PI, 3), [v.datas.originalX * l[0], v.datas.originalY * l[1], 1], 3), m = g[0], y = g[1];
          return F(F({}, v), {
            parentDist: null,
            parentScale: l,
            dragClient: Jt(h, [m, y]),
            parentKeepRatio: u
          });
        }), f = F({
          targets: r.targets,
          events: d
        }, n);
        return mt(i, "onResizeGroup", f), f;
      }
    }
  },
  dragGroupControlEnd: function(i, t) {
    var e = t.isDrag, r = t.datas;
    if (r.isResize) {
      this.dragControlEnd(i, t);
      var n = Ss(i, this, "dragControlEnd", t), s = ui(i, t, {
        targets: i.props.targets,
        events: n
      });
      return mt(i, "onResizeGroupEnd", s), e;
    }
  },
  /**
   * @method Moveable.Resizable#request
   * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * // Use Relative Value
   * moveable.request("resizable", { deltaWidth: 10, deltaHeight: 10 }, true);
   *
   * // Use Absolute Value
   * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 }, true);
   *
   * // requestStart
   * const requester = moveable.request("resizable");
   *
   * // request
   * // Use Relative Value
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   *
   * // Use Absolute Value
   * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 });
   * moveable.request("resizable", { offsetWidth: 110, offsetHeight: 100 });
   * moveable.request("resizable", { offsetWidth: 120, offsetHeight: 100 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function(i) {
    var t = {}, e = 0, r = 0, n = i.getRect();
    return {
      isControl: !0,
      requestStart: function(s) {
        var a;
        return {
          datas: t,
          parentDirection: s.direction || [1, 1],
          parentIsWidth: (a = s == null ? void 0 : s.horizontal) !== null && a !== void 0 ? a : !0
        };
      },
      request: function(s) {
        return "offsetWidth" in s ? e = s.offsetWidth - n.offsetWidth : "deltaWidth" in s && (e += s.deltaWidth), "offsetHeight" in s ? r = s.offsetHeight - n.offsetHeight : "deltaHeight" in s && (r += s.deltaHeight), {
          datas: t,
          parentDist: [e, r],
          parentKeepRatio: s.keepRatio
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  },
  unset: function(i) {
    i.state.gestos.resizable = null;
  }
};
function ly(i, t, e, r, n) {
  var s = i.props.groupable, a = i.state, o = a.is3d ? 4 : 3, u = t.origin, l = nr(
    i.state.rootMatrix,
    // TO-DO #710
    Mt([u[0], u[1]], s ? [0, 0] : [a.left, a.top]),
    o
  ), h = Jt([n.left, n.top], l);
  t.startAbsoluteOrigin = h, t.prevDeg = $e(h, [e, r]) / Math.PI * 180, t.defaultDeg = t.prevDeg, t.prevSnapDeg = 0, t.loop = 0, t.startDist = Zi(h, [e, r]);
}
function Hp(i, t, e) {
  var r = e.defaultDeg, n = e.prevDeg, s = n % 360, a = Math.floor(n / 360);
  s < 0 && (s += 360), s > i && s > 270 && i < 90 ? ++a : s < i && s < 90 && i > 270 && --a;
  var o = t * (a * 360 + i - r);
  return e.prevDeg = r + o, o;
}
function hy(i, t, e, r) {
  return Hp($e(r.startAbsoluteOrigin, [i, t]) / Math.PI * 180, e, r);
}
function cy(i, t, e, r, n, s) {
  var a = i.props.throttleRotate, o = a === void 0 ? 0 : a, u = e.prevSnapDeg, l = 0, h = !1;
  if (s) {
    var d = zF(i, t, r);
    h = d.isSnap, l = n + d.rotation;
  }
  h || (l = Gt(n + r, o));
  var f = l - n;
  return e.prevSnapDeg = f, [f - u, f, l];
}
function UC(i, t, e) {
  var r = t[0], n = t[1], s = t[2], a = t[3];
  if (i === "none")
    return [];
  if (tr(i))
    return i.map(function(g) {
      return UC(g, [r, n, s, a], e)[0];
    });
  var o = (i || "top").split("-"), u = o[0], l = o[1], h = [r, n];
  u === "left" ? h = [s, r] : u === "right" ? h = [n, a] : u === "bottom" && (h = [a, s]);
  var d = [(h[0][0] + h[1][0]) / 2, (h[0][1] + h[1][1]) / 2], f = pC(h, e);
  if (l) {
    var p = l === "top" || l === "left", v = u === "bottom" || u === "left";
    d = h[p && !v || !p && v ? 0 : 1];
  }
  return [[d, f]];
}
function D_(i, t) {
  if (t.isRequest)
    return t.requestAble === "rotatable";
  var e = t.inputEvent.target;
  if (sr(e, Pt("rotation-control")) || i.props.rotateAroundControls && sr(e, Pt("around-control")) || sr(e, Pt("control")) && sr(e, Pt("rotatable")))
    return !0;
  var r = i.props.rotationTarget;
  return r ? Ix(r, !0).some(function(n) {
    return n ? e === n || e.contains(n) : !1;
  }) : !1;
}
var qF = `.rotation {
position: absolute;
height: 40px;
width: 1px;
transform-origin: 50% 100%;
height: calc(40px * var(--zoom));
top: auto;
left: 0;
bottom: 100%;
will-change: transform;
}
.rotation .rotation-line {
display: block;
width: 100%;
height: 100%;
transform-origin: 50% 50%;
}
.rotation .rotation-control {
border-color: #4af;
border-color: var(--moveable-color);
background:#fff;
cursor: alias;
}
:global .view-rotation-dragging, .rotatable.direction.control {
cursor: alias;
}
.rotatable.direction.control.move {
cursor: move;
}
`, ZF = {
  name: "rotatable",
  canPinch: !0,
  props: ["rotatable", "rotationPosition", "throttleRotate", "renderDirections", "rotationTarget", "rotateAroundControls", "edge", "resolveAblesWithRotatable", "displayAroundControls"],
  events: ["rotateStart", "beforeRotate", "rotate", "rotateEnd", "rotateGroupStart", "beforeRotateGroup", "rotateGroup", "rotateGroupEnd"],
  css: [qF],
  viewClassName: function(i) {
    return i.isDragging("rotatable") ? Pt("view-rotation-dragging") : "";
  },
  render: function(i, t) {
    var e = ru(i.props, "rotatable"), r = e.rotatable, n = e.rotationPosition, s = e.zoom, a = e.renderDirections, o = e.rotateAroundControls, u = e.resolveAblesWithRotatable, l = i.getState(), h = l.renderPoses, d = l.direction;
    if (!r)
      return null;
    var f = UC(n, h, d), p = [];
    if (f.forEach(function(y, _) {
      var b = y[0], w = y[1];
      p.push(t.createElement("div", {
        key: "rotation".concat(_),
        className: Pt("rotation"),
        style: {
          // tslint:disable-next-line: max-line-length
          transform: "translate(-50%) translate(".concat(b[0], "px, ").concat(b[1], "px) rotate(").concat(w, "rad)")
        }
      }, t.createElement("div", {
        className: Pt("line rotation-line"),
        style: {
          transform: "scaleX(".concat(s, ")")
        }
      }), t.createElement("div", {
        className: Pt("control rotation-control"),
        style: {
          transform: "translate(0.5px) scale(".concat(s, ")")
        }
      })));
    }), a) {
      var v = Ps(u || {}), g = {};
      v.forEach(function(y) {
        u[y].forEach(function(_) {
          g[_] = y;
        });
      });
      var m = [];
      tr(a) && (m = a.map(function(y) {
        var _ = g[y];
        return {
          data: _ ? {
            resolve: _
          } : {},
          classNames: _ ? ["move"] : [],
          dir: y
        };
      })), p.push.apply(p, NC(i, "rotatable", m, t));
    }
    return o && p.push.apply(p, GC(i, t)), p;
  },
  dragControlCondition: D_,
  dragControlStart: function(i, t) {
    var e, r, n = t.datas, s = t.clientX, a = t.clientY, o = t.parentRotate, u = t.parentFlag, l = t.isPinch, h = t.isRequest, d = i.state, f = d.target, p = d.left, v = d.top, g = d.direction, m = d.beforeDirection, y = d.targetTransform, _ = d.moveableClientRect, b = d.offsetMatrix, w = d.targetMatrix, T = d.allMatrix, x = d.width, S = d.height;
    if (!h && !f)
      return !1;
    var C = i.getRect();
    n.rect = C, n.transform = y, n.left = p, n.top = v;
    var M = function(et) {
      var k = i.state, ft = k.allMatrix, Q = k.is3d, St = k.width, at = k.height, q = aC(et, St, at);
      n.fixedDirection = q, n.fixedPosition = nr(ft, et, Q ? 4 : 3), X && X.setFixedPosition(et);
    }, I = function(et) {
      n.fixedDirection = et, n.fixedPosition = oC(i, et), X && X.setFixedDirection(et);
    }, R = s, N = a;
    if (h || l || u) {
      var A = o || 0;
      n.beforeInfo = {
        origin: C.beforeOrigin,
        prevDeg: A,
        defaultDeg: A,
        prevSnapDeg: 0,
        startDist: 0
      }, n.afterInfo = F(F({}, n.beforeInfo), {
        origin: C.origin
      }), n.absoluteInfo = F(F({}, n.beforeInfo), {
        origin: C.origin,
        startValue: A
      });
    } else {
      var G = (r = t.inputEvent) === null || r === void 0 ? void 0 : r.target;
      if (G) {
        var B = G.getAttribute("data-direction") || "", U = TB[B];
        if (U) {
          n.isControl = !0, n.isAroundControl = sr(G, Pt("around-control")), n.controlDirection = U;
          var $ = G.getAttribute("data-resolve");
          $ && (n.resolveAble = $);
          var Z = JB(d.rootMatrix, d.renderPoses, _);
          e = ze(Z, U), R = e[0], N = e[1];
        }
      }
      n.beforeInfo = {
        origin: C.beforeOrigin
      }, n.afterInfo = {
        origin: C.origin
      }, n.absoluteInfo = {
        origin: C.origin,
        startValue: C.rotation
      };
      var H = M;
      M = function(et) {
        var k = d.is3d ? 4 : 3, ft = Jt(GT(w, k), et), Q = ft[0], St = ft[1], at = br(b, tu([Q, St], k)), q = br(T, tu([et[0], et[1]], k));
        H(et);
        var bt = d.posDelta;
        n.beforeInfo.origin = Mt(at, bt), n.afterInfo.origin = Mt(q, bt), n.absoluteInfo.origin = Mt(q, bt), ly(i, n.beforeInfo, R, N, _), ly(i, n.afterInfo, R, N, _), ly(i, n.absoluteInfo, R, N, _);
      }, I = function(et) {
        var k = ze([[0, 0], [x, 0], [0, S], [x, S]], et);
        M(k);
      };
    }
    n.startClientX = R, n.startClientY = N, n.direction = g, n.beforeDirection = m, n.startValue = 0, n.datas = {}, d0(t, "rotate");
    var z = !1, X = !1;
    if (n.isControl && n.resolveAble) {
      var ct = n.resolveAble;
      ct === "resizable" && (X = R_.dragControlStart(i, F(F({}, new Ql("resizable").dragStart([0, 0], t)), {
        parentPosition: n.controlPosition,
        parentFixedPosition: n.fixedPosition
      })));
    }
    X || (z = Or.dragStart(i, new Ql().dragStart([0, 0], t))), M(d.transformOrigin);
    var it = Ut(i, t, F(F({
      set: function(et) {
        n.startValue = et * Math.PI / 180;
      },
      setFixedDirection: I,
      setFixedPosition: M
    }, f0(t)), {
      dragStart: z,
      resizeStart: X
    })), lt = mt(i, "onRotateStart", it);
    return n.isRotate = lt !== !1, d.snapRenderInfo = {
      request: t.isRequest
    }, n.isRotate ? it : !1;
  },
  dragControl: function(i, t) {
    var e, r, n, s = t.datas, a = t.clientDistX, o = t.clientDistY, u = t.parentRotate, l = t.parentFlag, h = t.isPinch, d = t.groupDelta, f = t.resolveMatrix, p = s.beforeDirection, v = s.beforeInfo, g = s.afterInfo, m = s.absoluteInfo, y = s.isRotate, _ = s.startValue, b = s.rect, w = s.startClientX, T = s.startClientY;
    if (y) {
      h0(t, "rotate");
      var x = CB(t), S = p * x, C = i.props.parentMoveable, M = 0, I, R, N = 0, A, G, B = 0, U, $, Z = 180 / Math.PI * _, H = m.startValue, z = !1, X = w + a, ct = T + o;
      if (!l && "parentDist" in t) {
        var it = t.parentDist;
        I = it, A = it, U = it;
      } else
        h || l ? (I = Hp(u, p, v), A = Hp(u, S, g), U = Hp(u, S, m)) : (I = hy(X, ct, p, v), A = hy(X, ct, S, g), U = hy(X, ct, S, m), z = !0);
      if (R = Z + I, G = Z + A, $ = H + U, mt(i, "onBeforeRotate", Ut(i, t, {
        beforeRotation: R,
        rotation: G,
        absoluteRotation: $,
        setRotation: function(st) {
          A = st - Z, I = A, U = A;
        }
      }, !0)), e = cy(i, b, v, I, Z, z), M = e[0], I = e[1], R = e[2], r = cy(i, b, g, A, Z, z), N = r[0], A = r[1], G = r[2], n = cy(i, b, m, U, H, z), B = n[0], U = n[1], $ = n[2], !(!B && !N && !M && !C && !f)) {
        var lt = c0(s, "rotate(".concat(G, "deg)"), "rotate(".concat(A, "deg)"));
        f && (s.fixedPosition = Ex(i, s.targetAllTransform, [0, 0], s));
        var et = AB(i, A, s), k = Mt(Jt(d || [0, 0], et), s.prevInverseDist || [0, 0]);
        s.prevInverseDist = et, s.requestValue = null;
        var ft = nC(i, lt, k, h, t), Q = ft, St = Zi([X, ct], m.startAbsoluteOrigin) - m.startDist, at = void 0;
        if (s.resolveAble === "resizable") {
          var q = R_.dragControl(i, F(F({}, Od(t, i.state, [t.deltaX, t.deltaY], !!h, !1, "resizable")), {
            resolveMatrix: !0,
            parentDistance: St
          }));
          q && (at = q, Q = yC(Q, q, t));
        }
        var bt = Ut(i, t, F(F({
          delta: N,
          dist: A,
          rotate: G,
          rotation: G,
          beforeDist: I,
          beforeDelta: M,
          beforeRotate: R,
          beforeRotation: R,
          absoluteDist: U,
          absoluteDelta: B,
          absoluteRotate: $,
          absoluteRotation: $,
          isPinch: !!h,
          resize: at
        }, ft), Q));
        return mt(i, "onRotate", bt), bt;
      }
    }
  },
  dragControlEnd: function(i, t) {
    var e = t.datas;
    if (e.isRotate) {
      e.isRotate = !1;
      var r = ui(i, t, {});
      return mt(i, "onRotateEnd", r), r;
    }
  },
  dragGroupControlCondition: D_,
  dragGroupControlStart: function(i, t) {
    var e = t.datas, r = i.state, n = r.left, s = r.top, a = r.beforeOrigin, o = this.dragControlStart(i, t);
    if (!o)
      return !1;
    o.set(e.beforeDirection * i.rotation);
    var u = Ss(i, this, "dragControlStart", t, function(d, f) {
      var p = d.state, v = p.left, g = p.top, m = p.beforeOrigin, y = Jt(Mt([v, g], [n, s]), Mt(m, a));
      return f.datas.startGroupClient = y, f.datas.groupClient = y, F(F({}, f), {
        parentRotate: 0
      });
    }), l = F(F({}, o), {
      targets: i.props.targets,
      events: u
    }), h = mt(i, "onRotateGroupStart", l);
    return e.isRotate = h !== !1, e.isRotate ? o : !1;
  },
  dragGroupControl: function(i, t) {
    var e = t.datas;
    if (e.isRotate) {
      v0(i, "onBeforeRotate", function(l) {
        mt(i, "onBeforeRotateGroup", Ut(i, t, F(F({}, l), {
          targets: i.props.targets
        }), !0));
      });
      var r = this.dragControl(i, t);
      if (r) {
        var n = e.beforeDirection, s = r.beforeDist, a = s / 180 * Math.PI, o = Ss(i, this, "dragControl", t, function(l, h) {
          var d = h.datas.startGroupClient, f = h.datas.groupClient, p = f[0], v = f[1], g = Td(d, a * n), m = g[0], y = g[1], _ = [m - p, y - v];
          return h.datas.groupClient = [m, y], F(F({}, h), {
            parentRotate: s,
            groupDelta: _
          });
        });
        i.rotation = n * r.beforeRotation;
        var u = F({
          targets: i.props.targets,
          events: o,
          set: function(l) {
            i.rotation = l;
          },
          setGroupRotation: function(l) {
            i.rotation = l;
          }
        }, r);
        return mt(i, "onRotateGroup", u), u;
      }
    }
  },
  dragGroupControlEnd: function(i, t) {
    var e = t.isDrag, r = t.datas;
    if (r.isRotate) {
      this.dragControlEnd(i, t);
      var n = Ss(i, this, "dragControlEnd", t), s = ui(i, t, {
        targets: i.props.targets,
        events: n
      });
      return mt(i, "onRotateGroupEnd", s), e;
    }
  },
  /**
   * @method Moveable.Rotatable#request
   * @param {object} [e] - the Resizable's request parameter
   * @param {number} [e.deltaRotate=0] -  delta number of rotation
   * @param {number} [e.rotate=0] - absolute number of moveable's rotation
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("rotatable", { deltaRotate: 10 }, true);
   *
   * * moveable.request("rotatable", { rotate: 10 }, true);
   *
   * // requestStart
   * const requester = moveable.request("rotatable");
   *
   * // request
   * requester.request({ deltaRotate: 10 });
   * requester.request({ deltaRotate: 10 });
   * requester.request({ deltaRotate: 10 });
   *
   * requester.request({ rotate: 10 });
   * requester.request({ rotate: 20 });
   * requester.request({ rotate: 30 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function(i) {
    var t = {}, e = 0, r = i.getRotation();
    return {
      isControl: !0,
      requestStart: function() {
        return {
          datas: t
        };
      },
      request: function(n) {
        return "deltaRotate" in n ? e += n.deltaRotate : "rotate" in n && (e = n.rotate - r), {
          datas: t,
          parentDist: e
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  }
}, Uw = Ox("scalable"), KF = {
  name: "scalable",
  ableGroup: "size",
  canPinch: !0,
  props: ["scalable", "throttleScale", "renderDirections", "keepRatio", "edge", "displayAroundControls"],
  events: ["scaleStart", "beforeScale", "scale", "scaleEnd", "scaleGroupStart", "beforeScaleGroup", "scaleGroup", "scaleGroupEnd"],
  render: BC("scalable"),
  dragControlCondition: Uw,
  viewClassName: Px("scalable"),
  dragControlStart: function(i, t) {
    var e = t.datas, r = t.isPinch, n = t.inputEvent, s = t.parentDirection, a = gC(s, r, n, e), o = i.state, u = o.width, l = o.height, h = o.targetTransform, d = o.target, f = o.pos1, p = o.pos2, v = o.pos4;
    if (!a || !d)
      return !1;
    r || au(i, t), e.datas = {}, e.transform = h, e.prevDist = [1, 1], e.direction = a, e.startOffsetWidth = u, e.startOffsetHeight = l, e.startValue = [1, 1];
    var g = Zi(f, p), m = Zi(p, v), y = !a[0] && !a[1] || a[0] || !a[1];
    e.scaleWidth = g, e.scaleHeight = m, e.scaleXRatio = g / u, e.scaleYRatio = m / l, d0(t, "scale"), e.isWidth = y;
    function _(x) {
      e.ratio = x && isFinite(x) ? x : 0;
    }
    e.startPositions = Ti(i.state);
    function b(x) {
      e.fixedDirection = x, e.fixedPosition = ze(e.startPositions, x);
    }
    e.setFixedDirection = b, _(Zi(f, p) / Zi(p, v)), b([-a[0], -a[1]]);
    var w = Ut(i, t, F(F({
      direction: a,
      set: function(x) {
        e.startValue = x;
      },
      setRatio: _,
      setFixedDirection: b
    }, f0(t)), {
      dragStart: Or.dragStart(i, new Ql().dragStart([0, 0], t))
    })), T = mt(i, "onScaleStart", w);
    return e.startFixedDirection = e.fixedDirection, T !== !1 && (e.isScale = !0, i.state.snapRenderInfo = {
      request: t.isRequest,
      direction: a
    }), e.isScale ? w : !1;
  },
  dragControl: function(i, t) {
    h0(t, "scale");
    var e = t.datas, r = t.parentKeepRatio, n = t.parentFlag, s = t.isPinch, a = t.dragClient, o = t.isRequest, u = t.resolveMatrix, l = e.prevDist, h = e.direction, d = e.startOffsetWidth, f = e.startOffsetHeight, p = e.isScale, v = e.startValue, g = e.isWidth, m = e.ratio;
    if (!p)
      return !1;
    var y = i.props, _ = y.throttleScale, b = y.parentMoveable, w = h;
    !h[0] && !h[1] && (w = [1, 1]);
    var T = m && (r ?? y.keepRatio) || !1, x = i.state;
    function S() {
      var it = EC(w, T, e, t), lt = it.distWidth, et = it.distHeight, k = d ? (d + lt) / d : 1, ft = f ? (f + et) / f : 1;
      return k = w[0] || T ? k * v[0] : v[0], ft = w[1] || T ? ft * v[1] : v[1], k === 0 && (k = (l[0] > 0 ? 1 : -1) * cp), ft === 0 && (ft = (l[1] > 0 ? 1 : -1) * cp), [k, ft];
    }
    var C = S();
    if (!s && i.props.groupable) {
      var M = x.snapRenderInfo || {}, I = M.direction;
      tr(I) && (I[0] || I[1]) && (x.snapRenderInfo = {
        direction: h,
        request: t.isRequest
      });
    }
    mt(i, "onBeforeScale", Ut(i, t, {
      scale: C,
      setFixedDirection: function(it) {
        return e.setFixedDirection(it), C = S(), C;
      },
      startFixedDirection: e.startFixedDirection,
      setScale: function(it) {
        C = it;
      }
    }, !0));
    var R = [C[0] / v[0], C[1] / v[1]], N = a, A = [0, 0], G = !a && !n && s;
    if (G || u ? N = Ex(i, e.targetAllTransform, [0, 0], e) : a || (N = e.fixedPosition), s || (A = $F(i, R, h, o, e)), T) {
      w[0] && w[1] && A[0] && A[1] && (Math.abs(A[0] * d) > Math.abs(A[1] * f) ? A[1] = 0 : A[0] = 0);
      var B = !A[0] && !A[1];
      if (B && (g ? R[0] = Gt(R[0] * v[0], _) / v[0] : R[1] = Gt(R[1] * v[1], _) / v[1]), w[0] && !w[1] || A[0] && !A[1] || B && g) {
        R[0] += A[0];
        var U = d * R[0] * v[0] / m;
        R[1] = U / f / v[1];
      } else if (!w[0] && w[1] || !A[0] && A[1] || B && !g) {
        R[1] += A[1];
        var $ = f * R[1] * v[1] * m;
        R[0] = $ / d / v[0];
      }
    } else
      R[0] += A[0], R[1] += A[1], A[0] || (R[0] = Gt(R[0] * v[0], _) / v[0]), A[1] || (R[1] = Gt(R[1] * v[1], _) / v[1]);
    R[0] === 0 && (R[0] = (l[0] > 0 ? 1 : -1) * cp), R[1] === 0 && (R[1] = (l[1] > 0 ? 1 : -1) * cp);
    var Z = [R[0] / l[0], R[1] / l[1]];
    C = zB(R, v);
    var H = NB(i, R, e.fixedDirection, N, e), z = G ? H : Mt(H, e.prevInverseDist || [0, 0]);
    if (e.prevDist = R, e.prevInverseDist = H, C[0] === l[0] && C[1] === l[1] && z.every(function(it) {
      return !it;
    }) && !b && !G)
      return !1;
    var X = c0(e, "scale(".concat(C.join(", "), ")"), "scale(".concat(R.join(", "), ")")), ct = Ut(i, t, F({
      offsetWidth: d,
      offsetHeight: f,
      direction: h,
      scale: C,
      dist: R,
      delta: Z,
      isPinch: !!s
    }, nC(i, X, z, s, t)));
    return mt(i, "onScale", ct), ct;
  },
  dragControlEnd: function(i, t) {
    var e = t.datas;
    if (!e.isScale)
      return !1;
    e.isScale = !1;
    var r = ui(i, t, {});
    return mt(i, "onScaleEnd", r), r;
  },
  dragGroupControlCondition: Uw,
  dragGroupControlStart: function(i, t) {
    var e = t.datas, r = this.dragControlStart(i, t);
    if (!r)
      return !1;
    var n = Ji(i, "resizable", t);
    e.moveableScale = i.scale;
    var s = Ss(i, this, "dragControlStart", t, function(l, h) {
      return Mv(i, l, e, h);
    }), a = function(l) {
      r.setFixedDirection(l), s.forEach(function(h, d) {
        h.setFixedDirection(l), Mv(i, h.moveable, e, n[d]);
      });
    };
    e.setFixedDirection = a;
    var o = F(F({}, r), {
      targets: i.props.targets,
      events: s,
      setFixedDirection: a
    }), u = mt(i, "onScaleGroupStart", o);
    return e.isScale = u !== !1, e.isScale ? o : !1;
  },
  dragGroupControl: function(i, t) {
    var e = t.datas;
    if (e.isScale) {
      v0(i, "onBeforeScale", function(d) {
        mt(i, "onBeforeScaleGroup", Ut(i, t, F(F({}, d), {
          targets: i.props.targets
        }), !0));
      });
      var r = this.dragControl(i, t);
      if (r) {
        var n = e.moveableScale;
        i.scale = [r.scale[0] * n[0], r.scale[1] * n[1]];
        var s = i.props.keepRatio, a = r.dist, o = r.scale, u = e.fixedPosition, l = Ss(i, this, "dragControl", t, function(d, f) {
          var p = br(Cd(i.rotation / 180 * Math.PI, 3), [f.datas.originalX * a[0], f.datas.originalY * a[1], 1], 3), v = p[0], g = p[1];
          return F(F({}, f), {
            parentDist: null,
            parentScale: o,
            parentKeepRatio: s,
            dragClient: Jt(u, [v, g])
          });
        }), h = F({
          targets: i.props.targets,
          events: l
        }, r);
        return mt(i, "onScaleGroup", h), h;
      }
    }
  },
  dragGroupControlEnd: function(i, t) {
    var e = t.isDrag, r = t.datas;
    if (r.isScale) {
      this.dragControlEnd(i, t);
      var n = Ss(i, this, "dragControlEnd", t), s = ui(i, t, {
        targets: i.props.targets,
        events: n
      });
      return mt(i, "onScaleGroupEnd", s), e;
    }
  },
  /**
   * @method Moveable.Scalable#request
   * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("scalable", { deltaWidth: 10, deltaHeight: 10 }, true);
   *
   * // requestStart
   * const requester = moveable.request("scalable");
   *
   * // request
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function() {
    var i = {}, t = 0, e = 0;
    return {
      isControl: !0,
      requestStart: function(r) {
        return {
          datas: i,
          parentDirection: r.direction || [1, 1]
        };
      },
      request: function(r) {
        return t += r.deltaWidth, e += r.deltaHeight, {
          datas: i,
          parentDist: [t, e],
          parentKeepRatio: r.keepRatio
        };
      },
      requestEnd: function() {
        return {
          datas: i,
          isDrag: !0
        };
      }
    };
  }
};
function Rs(i, t) {
  return i.map(function(e, r) {
    return Ma(e, t[r], 1, 2);
  });
}
function jw(i, t, e) {
  var r = $e(i, t), n = $e(i, e), s = n - r;
  return s >= 0 ? s : s + 2 * Math.PI;
}
function JF(i, t) {
  var e = jw(i[0], i[1], i[2]), r = jw(t[0], t[1], t[2]), n = Math.PI;
  return !(e >= n && r <= n || e <= n && r >= n);
}
var QF = {
  name: "warpable",
  ableGroup: "size",
  props: ["warpable", "renderDirections", "edge", "displayAroundControls"],
  events: ["warpStart", "warp", "warpEnd"],
  viewClassName: Px("warpable"),
  render: function(i, t) {
    var e = i.props, r = e.resizable, n = e.scalable, s = e.warpable, a = e.zoom;
    if (r || n || !s)
      return [];
    var o = i.state, u = o.pos1, l = o.pos2, h = o.pos3, d = o.pos4, f = Rs(u, l), p = Rs(l, u), v = Rs(u, h), g = Rs(h, u), m = Rs(h, d), y = Rs(d, h), _ = Rs(l, d), b = Rs(d, l);
    return Tt([t.createElement("div", {
      className: Pt("line"),
      key: "middeLine1",
      style: Dh(f, m, a)
    }), t.createElement("div", {
      className: Pt("line"),
      key: "middeLine2",
      style: Dh(p, y, a)
    }), t.createElement("div", {
      className: Pt("line"),
      key: "middeLine3",
      style: Dh(v, _, a)
    }), t.createElement("div", {
      className: Pt("line"),
      key: "middeLine4",
      style: Dh(g, b, a)
    })], FC(i, "warpable", t), !0);
  },
  dragControlCondition: function(i, t) {
    if (t.isRequest)
      return !1;
    var e = t.inputEvent.target;
    return sr(e, Pt("direction")) && sr(e, Pt("warpable"));
  },
  dragControlStart: function(i, t) {
    var e = t.datas, r = t.inputEvent, n = i.props.target, s = r.target, a = mC(s, e);
    if (!a || !n)
      return !1;
    var o = i.state, u = o.transformOrigin, l = o.is3d, h = o.targetTransform, d = o.targetMatrix, f = o.width, p = o.height, v = o.left, g = o.top;
    e.datas = {}, e.targetTransform = h, e.warpTargetMatrix = l ? d : An(d, 3, 4), e.targetInverseMatrix = FT(Nn(e.warpTargetMatrix, 4), 3, 4), e.direction = a, e.left = v, e.top = g, e.poses = [[0, 0], [f, 0], [0, p], [f, p]].map(function(_) {
      return Mt(_, u);
    }), e.nextPoses = e.poses.map(function(_) {
      var b = _[0], w = _[1];
      return br(e.warpTargetMatrix, [b, w, 0, 1], 4);
    }), e.startValue = Oe(4), e.prevMatrix = Oe(4), e.absolutePoses = Ti(o), e.posIndexes = rC(a), au(i, t), d0(t, "matrix3d"), o.snapRenderInfo = {
      request: t.isRequest,
      direction: a
    };
    var m = Ut(i, t, F({
      set: function(_) {
        e.startValue = _;
      }
    }, f0(t))), y = mt(i, "onWarpStart", m);
    return y !== !1 && (e.isWarp = !0), e.isWarp;
  },
  dragControl: function(i, t) {
    var e = t.datas, r = t.isRequest, n = t.distX, s = t.distY, a = e.targetInverseMatrix, o = e.prevMatrix, u = e.isWarp, l = e.startValue, h = e.poses, d = e.posIndexes, f = e.absolutePoses;
    if (!u)
      return !1;
    if (h0(t, "matrix3d"), dh(i, "warpable")) {
      var p = d.map(function(M) {
        return f[M];
      });
      p.length > 1 && p.push([(p[0][0] + p[1][0]) / 2, (p[0][1] + p[1][1]) / 2]);
      var v = y0(i, r, {
        horizontal: p.map(function(M) {
          return M[1] + s;
        }),
        vertical: p.map(function(M) {
          return M[0] + n;
        })
      }), g = v.horizontal, m = v.vertical;
      s -= g.offset, n -= m.offset;
    }
    var y = Un({
      datas: e,
      distX: n,
      distY: s
    }, !0), _ = e.nextPoses.slice();
    if (d.forEach(function(M) {
      _[M] = Jt(_[M], y);
    }), !SB.every(function(M) {
      return JF(M.map(function(I) {
        return h[I];
      }), M.map(function(I) {
        return _[I];
      }));
    }))
      return !1;
    var b = gx(h[0], h[2], h[1], h[3], _[0], _[2], _[1], _[3]);
    if (!b.length)
      return !1;
    var w = _e(a, b, 4), T = tC(e, w, !0), x = _e(Nn(o, 4), T, 4);
    e.prevMatrix = T;
    var S = _e(l, T, 4), C = c0(e, "matrix3d(".concat(S.join(", "), ")"), "matrix3d(".concat(T.join(", "), ")"));
    return wx(t, C), mt(i, "onWarp", Ut(i, t, F({
      delta: x,
      matrix: S,
      dist: T,
      multiply: _e,
      transform: C
    }, Ir({
      transform: C
    }, t)))), !0;
  },
  dragControlEnd: function(i, t) {
    var e = t.datas, r = t.isDrag;
    return e.isWarp ? (e.isWarp = !1, mt(i, "onWarpEnd", ui(i, t, {})), r) : !1;
  }
}, t3 = /* @__PURE__ */ Pt("area-pieces"), yp = /* @__PURE__ */ Pt("area-piece"), jC = /* @__PURE__ */ Pt("avoid"), e3 = Pt("view-dragging");
function fy(i) {
  var t = i.areaElement;
  if (t) {
    var e = i.state, r = e.width, n = e.height;
    yT(t, jC), t.style.cssText += "left: 0px; top: 0px; width: ".concat(r, "px; height: ").concat(n, "px");
  }
}
function zw(i) {
  return i.createElement("div", {
    key: "area_pieces",
    className: t3
  }, i.createElement("div", {
    className: yp
  }), i.createElement("div", {
    className: yp
  }), i.createElement("div", {
    className: yp
  }), i.createElement("div", {
    className: yp
  }));
}
var zC = {
  name: "dragArea",
  props: ["dragArea", "passDragArea"],
  events: ["click", "clickGroup"],
  render: function(i, t) {
    var e = i.props, r = e.target, n = e.dragArea, s = e.groupable, a = e.passDragArea, o = i.getState(), u = o.width, l = o.height, h = o.renderPoses, d = a ? Pt("area", "pass") : Pt("area");
    if (s)
      return [t.createElement("div", {
        key: "area",
        ref: Es(i, "areaElement"),
        className: d
      }), zw(t)];
    if (!r || !n)
      return [];
    var f = gx([0, 0], [u, 0], [0, l], [u, l], h[0], h[1], h[2], h[3]), p = f.length ? p0(f, !0) : "none";
    return [t.createElement("div", {
      key: "area",
      ref: Es(i, "areaElement"),
      className: d,
      style: {
        top: "0px",
        left: "0px",
        width: "".concat(u, "px"),
        height: "".concat(l, "px"),
        transformOrigin: "0 0",
        transform: p
      }
    }), zw(t)];
  },
  dragStart: function(i, t) {
    var e = t.datas, r = t.clientX, n = t.clientY, s = t.inputEvent;
    if (!s)
      return !1;
    e.isDragArea = !1;
    var a = i.areaElement, o = i.state, u = o.moveableClientRect, l = o.renderPoses, h = o.rootMatrix, d = o.is3d, f = u.left, p = u.top, v = Si(l), g = v.left, m = v.top, y = v.width, _ = v.height, b = d ? 4 : 3, w = rh(h, [r - f, n - p], b), T = w[0], x = w[1];
    T -= g, x -= m;
    var S = [{
      left: g,
      top: m,
      width: y,
      height: x - 10
    }, {
      left: g,
      top: m,
      width: T - 10,
      height: _
    }, {
      left: g,
      top: m + x + 10,
      width: y,
      height: _ - x - 10
    }, {
      left: g + T + 10,
      top: m,
      width: y - T - 10,
      height: _
    }], C = [].slice.call(a.nextElementSibling.children);
    S.forEach(function(M, I) {
      C[I].style.cssText = "left: ".concat(M.left, "px;top: ").concat(M.top, "px; width: ").concat(M.width, "px; height: ").concat(M.height, "px;");
    }), mT(a, jC), o.disableNativeEvent = !0;
  },
  drag: function(i, t) {
    var e = t.datas, r = t.inputEvent;
    if (this.enableNativeEvent(i), !r)
      return !1;
    e.isDragArea || (e.isDragArea = !0, fy(i));
  },
  dragEnd: function(i, t) {
    this.enableNativeEvent(i);
    var e = t.inputEvent, r = t.datas;
    if (!e)
      return !1;
    r.isDragArea || fy(i);
  },
  dragGroupStart: function(i, t) {
    return this.dragStart(i, t);
  },
  dragGroup: function(i, t) {
    return this.drag(i, t);
  },
  dragGroupEnd: function(i, t) {
    return this.dragEnd(i, t);
  },
  unset: function(i) {
    fy(i), i.state.disableNativeEvent = !1;
  },
  enableNativeEvent: function(i) {
    var t = i.state;
    t.disableNativeEvent && vT(function() {
      t.disableNativeEvent = !1;
    });
  }
}, r3 = Pd("origin", {
  render: function(i, t) {
    var e = i.props.zoom, r = i.getState(), n = r.beforeOrigin, s = r.rotation;
    return [t.createElement("div", {
      className: Pt("control", "origin"),
      style: Tx(s, e, n),
      key: "beforeOrigin"
    })];
  }
});
function i3(i) {
  var t = i.scrollContainer;
  return [t.scrollLeft, t.scrollTop];
}
var n3 = {
  name: "scrollable",
  canPinch: !0,
  props: ["scrollable", "scrollContainer", "scrollThreshold", "scrollThrottleTime", "getScrollPosition", "scrollOptions"],
  events: ["scroll", "scrollGroup"],
  dragRelation: "strong",
  dragStart: function(i, t) {
    var e = i.props, r = e.scrollContainer, n = r === void 0 ? i.getContainer() : r, s = e.scrollOptions, a = new $L(), o = iu(n, !0);
    t.datas.dragScroll = a, i.state.dragScroll = a;
    var u = t.isControl ? "controlGesto" : "targetGesto", l = t.targets;
    a.on("scroll", function(h) {
      var d = h.container, f = h.direction, p = Ut(i, t, {
        scrollContainer: d,
        direction: f
      }), v = l ? "onScrollGroup" : "onScroll";
      l && (p.targets = l), mt(i, v, p);
    }).on("move", function(h) {
      var d = h.offsetX, f = h.offsetY, p = h.inputEvent;
      i[u].scrollBy(d, f, p.inputEvent, !0);
    }).on("scrollDrag", function(h) {
      var d = h.next;
      d(i[u].getCurrentEvent());
    }), a.dragStart(t, F({
      container: o
    }, s));
  },
  checkScroll: function(i, t) {
    var e = t.datas.dragScroll;
    if (e) {
      var r = i.props, n = r.scrollContainer, s = n === void 0 ? i.getContainer() : n, a = r.scrollThreshold, o = a === void 0 ? 0 : a, u = r.scrollThrottleTime, l = u === void 0 ? 0 : u, h = r.getScrollPosition, d = h === void 0 ? i3 : h, f = r.scrollOptions;
      return e.drag(t, F({
        container: s,
        threshold: o,
        throttleTime: l,
        getScrollPosition: function(p) {
          return d({
            scrollContainer: p.container,
            direction: p.direction
          });
        }
      }, f)), !0;
    }
  },
  drag: function(i, t) {
    return this.checkScroll(i, t);
  },
  dragEnd: function(i, t) {
    t.datas.dragScroll.dragEnd(), t.datas.dragScroll = null;
  },
  dragControlStart: function(i, t) {
    return this.dragStart(i, F(F({}, t), {
      isControl: !0
    }));
  },
  dragControl: function(i, t) {
    return this.drag(i, t);
  },
  dragControlEnd: function(i, t) {
    return this.dragEnd(i, t);
  },
  dragGroupStart: function(i, t) {
    return this.dragStart(i, F(F({}, t), {
      targets: i.props.targets
    }));
  },
  dragGroup: function(i, t) {
    return this.drag(i, F(F({}, t), {
      targets: i.props.targets
    }));
  },
  dragGroupEnd: function(i, t) {
    return this.dragEnd(i, F(F({}, t), {
      targets: i.props.targets
    }));
  },
  dragGroupControlStart: function(i, t) {
    return this.dragStart(i, F(F({}, t), {
      targets: i.props.targets,
      isControl: !0
    }));
  },
  dragGroupControl: function(i, t) {
    return this.drag(i, F(F({}, t), {
      targets: i.props.targets
    }));
  },
  dragGroupControEnd: function(i, t) {
    return this.dragEnd(i, F(F({}, t), {
      targets: i.props.targets
    }));
  },
  unset: function(i) {
    var t, e = i.state;
    (t = e.dragScroll) === null || t === void 0 || t.dragEnd(), e.dragScroll = null;
  }
}, HC = {
  name: "",
  props: ["target", "dragTarget", "container", "warpSelf", "rootContainer", "useResizeObserver", "useMutationObserver", "zoom", "transformOrigin", "edge", "ables", "className", "pinchThreshold", "pinchOutside", "triggerAblesSimultaneously", "checkInput", "cspNonce", "translateZ", "hideDefaultLines", "props", "flushSync", "stopPropagation", "preventClickEventOnDrag", "preventClickDefault", "viewContainer", "persistData", "useAccuratePosition", "firstRenderState", "linePadding", "displayAroundControls", "controlPadding", "preventDefault", "requestStyles"],
  events: ["changeTargets"]
}, s3 = Pd("padding", {
  render: function(i, t) {
    var e = i.props;
    if (e.dragArea)
      return [];
    var r = e.padding || {}, n = r.left, s = n === void 0 ? 0 : n, a = r.top, o = a === void 0 ? 0 : a, u = r.right, l = u === void 0 ? 0 : u, h = r.bottom, d = h === void 0 ? 0 : h, f = i.getState(), p = f.renderPoses, v = f.pos1, g = f.pos2, m = f.pos3, y = f.pos4, _ = [v, g, m, y], b = [];
    return s > 0 && b.push([0, 2]), o > 0 && b.push([0, 1]), l > 0 && b.push([1, 3]), d > 0 && b.push([2, 3]), b.map(function(w, T) {
      var x = w[0], S = w[1], C = _[x], M = _[S], I = p[x], R = p[S], N = gx([0, 0], [100, 0], [0, 100], [100, 100], C, M, I, R);
      if (N.length)
        return t.createElement("div", {
          key: "padding".concat(T),
          className: Pt("padding"),
          style: {
            transform: p0(N, !0)
          }
        });
    });
  }
}), Hw = ["nw", "ne", "se", "sw"];
function _p(i, t) {
  var e = i[0] + i[1], r = e > t ? t / e : 1;
  return i[0] *= r, i[1] = t - i[1] * r, i;
}
var a3 = [1, 2, 5, 6], o3 = [0, 3, 4, 7], Na = [1, -1, -1, 1], Aa = [1, 1, -1, -1];
function Bx(i, t, e, r, n, s, a, o) {
  n === void 0 && (n = 0), s === void 0 && (s = 0), a === void 0 && (a = e), o === void 0 && (o = r);
  var u = [], l = !1, h = i.filter(function(f) {
    return !f.virtual;
  }), d = h.map(function(f) {
    var p = f.horizontal, v = f.vertical, g = f.pos;
    if (v && !l && (l = !0, u.push("/")), l) {
      var m = Math.max(0, v === 1 ? g[1] - s : o - g[1]);
      return u.push(Vi(m, r, t)), m;
    } else {
      var m = Math.max(0, p === 1 ? g[0] - n : a - g[0]);
      return u.push(Vi(m, e, t)), m;
    }
  });
  return {
    radiusPoses: h,
    styles: u,
    raws: d
  };
}
function $C(i) {
  for (var t = [0, 0], e = [0, 0], r = i.length, n = 0; n < r; ++n) {
    var s = i[n];
    s.sub && (s.horizontal && (t[1] === 0 && (t[0] = n), t[1] = n - t[0] + 1, e[0] = n + 1), s.vertical && (e[1] === 0 && (e[0] = n), e[1] = n - e[0] + 1));
  }
  return {
    horizontalRange: t,
    verticalRange: e
  };
}
function VC(i, t, e, r, n, s, a) {
  var o, u, l, h;
  s === void 0 && (s = [0, 0]), a === void 0 && (a = !1);
  var d = i.indexOf("/"), f = (d > -1 ? i.slice(0, d) : i).length, p = i.slice(0, f), v = i.slice(f + 1), g = p.length, m = v.length, y = m > 0, _ = p[0], b = _ === void 0 ? "0px" : _, w = p[1], T = w === void 0 ? b : w, x = p[2], S = x === void 0 ? b : x, C = p[3], M = C === void 0 ? T : C, I = v[0], R = I === void 0 ? b : I, N = v[1], A = N === void 0 ? y ? R : T : N, G = v[2], B = G === void 0 ? y ? R : S : G, U = v[3], $ = U === void 0 ? y ? A : M : U, Z = [b, T, S, M].map(function(lt) {
    return Te(lt, t);
  }), H = [R, A, B, $].map(function(lt) {
    return Te(lt, e);
  }), z = Z.slice(), X = H.slice();
  o = _p([z[0], z[1]], t), z[0] = o[0], z[1] = o[1], u = _p([z[3], z[2]], t), z[3] = u[0], z[2] = u[1], l = _p([X[0], X[3]], e), X[0] = l[0], X[3] = l[1], h = _p([X[1], X[2]], e), X[1] = h[0], X[2] = h[1];
  var ct = a ? z : z.slice(0, Math.max(s[0], g)), it = a ? X : X.slice(0, Math.max(s[1], m));
  return Tt(Tt([], ct.map(function(lt, et) {
    var k = Hw[et];
    return {
      virtual: et >= g,
      horizontal: Na[et],
      vertical: 0,
      pos: [r + lt, n + (Aa[et] === -1 ? e : 0)],
      sub: !0,
      raw: Z[et],
      direction: k
    };
  }), !0), it.map(function(lt, et) {
    var k = Hw[et];
    return {
      virtual: et >= m,
      horizontal: 0,
      vertical: Aa[et],
      pos: [r + (Na[et] === -1 ? t : 0), n + lt],
      sub: !0,
      raw: H[et],
      direction: k
    };
  }), !0);
}
function u3(i, t, e, r, n) {
  n === void 0 && (n = t.length);
  var s = $C(i.slice(r)), a = s.horizontalRange, o = s.verticalRange, u = e - r, l = 0;
  if (u === 0)
    l = n;
  else if (u > 0 && u < a[1])
    l = a[1] - u;
  else if (u >= o[0])
    l = o[0] + o[1] - u;
  else
    return;
  i.splice(e, l), t.splice(e, l);
}
function l3(i, t, e, r, n, s, a, o, u, l, h) {
  l === void 0 && (l = 0), h === void 0 && (h = 0);
  var d = $C(i.slice(e)), f = d.horizontalRange, p = d.verticalRange;
  if (r > -1)
    for (var v = Na[r] === 1 ? s - l : o - s, g = f[1]; g <= r; ++g) {
      var m = Aa[g] === 1 ? h : u, y = 0;
      if (r === g ? y = s : g === 0 ? y = l + v : Na[g] === -1 && (y = o - (t[e][0] - l)), i.splice(e + g, 0, {
        horizontal: Na[g],
        vertical: 0,
        pos: [y, m]
      }), t.splice(e + g, 0, [y, m]), g === 0)
        break;
    }
  else if (n > -1) {
    var _ = Aa[n] === 1 ? a - h : u - a;
    if (f[1] === 0 && p[1] === 0) {
      var b = [l + _, h];
      i.push({
        horizontal: Na[0],
        vertical: 0,
        pos: b
      }), t.push(b);
    }
    for (var w = p[0], g = p[1]; g <= n; ++g) {
      var y = Na[g] === 1 ? l : o, m = 0;
      if (n === g ? m = a : g === 0 ? m = h + _ : Aa[g] === 1 ? m = t[e + w][1] : Aa[g] === -1 && (m = u - (t[e + w][1] - h)), i.push({
        horizontal: 0,
        vertical: Aa[g],
        pos: [y, m]
      }), t.push([y, m]), g === 0)
        break;
    }
  }
}
function h3(i, t) {
  t === void 0 && (t = i.map(function(n) {
    return n.raw;
  }));
  var e = i.map(function(n, s) {
    return n.horizontal ? t[s] : null;
  }).filter(function(n) {
    return n != null;
  }), r = i.map(function(n, s) {
    return n.vertical ? t[s] : null;
  }).filter(function(n) {
    return n != null;
  });
  return {
    horizontals: e,
    verticals: r
  };
}
var c3 = [[0, -1, "n"], [1, 0, "e"]], f3 = [[-1, -1, "nw"], [0, -1, "n"], [1, -1, "ne"], [1, 0, "e"], [1, 1, "se"], [0, 1, "s"], [-1, 1, "sw"], [-1, 0, "w"]];
function Fx(i, t, e) {
  var r = i.props.clipRelative, n = i.state, s = n.width, a = n.height, o = t, u = o.type, l = o.poses, h = u === "rect", d = u === "circle";
  if (u === "polygon")
    return e.map(function(x) {
      return "".concat(Vi(x[0], s, r), " ").concat(Vi(x[1], a, r));
    });
  if (h || u === "inset") {
    var f = e[1][1], p = e[3][0], v = e[7][0], g = e[5][1];
    if (h)
      return [f, p, g, v].map(function(x) {
        return "".concat(x, "px");
      });
    var m = [f, s - p, a - g, v].map(function(x, S) {
      return Vi(x, S % 2 ? s : a, r);
    });
    if (e.length > 8) {
      var y = Mt(e[4], e[0]), _ = y[0], b = y[1];
      m.push.apply(m, Tt(["round"], Bx(l.slice(8).map(function(x, S) {
        return F(F({}, x), {
          pos: e[S]
        });
      }), r, _, b, v, f, p, g).styles, !1));
    }
    return m;
  } else if (d || u === "ellipse") {
    var w = e[0], T = Vi(Math.abs(e[1][1] - w[1]), d ? Math.sqrt((s * s + a * a) / 2) : a, r), m = d ? [T] : [Vi(Math.abs(e[2][0] - w[0]), s, r), T];
    return m.push("at", Vi(w[0], s, r), Vi(w[1], a, r)), m;
  }
}
function Iv(i, t, e, r) {
  var n = [r, (r + t) / 2, t], s = [i, (i + e) / 2, e];
  return f3.map(function(a) {
    var o = a[0], u = a[1], l = a[2], h = n[o + 1], d = s[u + 1];
    return {
      vertical: Math.abs(u),
      horizontal: Math.abs(o),
      direction: l,
      pos: [h, d]
    };
  });
}
function XC(i) {
  var t = [1 / 0, -1 / 0], e = [1 / 0, -1 / 0];
  return i.forEach(function(r) {
    var n = r.pos;
    t[0] = Math.min(t[0], n[0]), t[1] = Math.max(t[1], n[0]), e[0] = Math.min(e[0], n[1]), e[1] = Math.max(e[1], n[1]);
  }), [Math.abs(t[1] - t[0]), Math.abs(e[1] - e[0])];
}
function $w(i, t, e, r, n) {
  var s, a, o, u, l, h, d;
  if (i) {
    var f = n;
    if (!f) {
      var p = oi(i), v = p("clipPath");
      f = v !== "none" ? v : p("clip");
    }
    if (!((!f || f === "none" || f === "auto") && (f = r, !f))) {
      var g = pT(f), m = g.prefix, y = m === void 0 ? f : m, _ = g.value, b = _ === void 0 ? "" : _, w = y === "circle", T = " ";
      if (y === "polygon") {
        var x = Fa(b || "0% 0%, 100% 0%, 100% 100%, 0% 100%");
        T = ",";
        var S = x.map(function(xt) {
          var Dt = xt.split(" "), Ct = Dt[0], be = Dt[1];
          return {
            vertical: 1,
            horizontal: 1,
            pos: [Te(Ct, t), Te(be, e)]
          };
        }), C = eu(S.map(function(xt) {
          return xt.pos;
        }));
        return {
          type: y,
          clipText: f,
          poses: S,
          splitter: T,
          left: C.minX,
          right: C.maxX,
          top: C.minY,
          bottom: C.maxY
        };
      } else if (w || y === "ellipse") {
        var M = "", I = "", R = 0, N = 0, x = ca(b);
        if (w) {
          var A = "";
          s = x[0], A = s === void 0 ? "50%" : s, a = x[2], M = a === void 0 ? "50%" : a, o = x[3], I = o === void 0 ? "50%" : o, R = Te(A, Math.sqrt((t * t + e * e) / 2)), N = R;
        } else {
          var G = "", B = "";
          u = x[0], G = u === void 0 ? "50%" : u, l = x[1], B = l === void 0 ? "50%" : l, h = x[3], M = h === void 0 ? "50%" : h, d = x[4], I = d === void 0 ? "50%" : d, R = Te(G, t), N = Te(B, e);
        }
        var U = [Te(M, t), Te(I, e)], S = Tt([{
          vertical: 1,
          horizontal: 1,
          pos: U,
          direction: "nesw"
        }], c3.slice(0, w ? 1 : 2).map(function(Ct) {
          return {
            vertical: Math.abs(Ct[1]),
            horizontal: Ct[0],
            direction: Ct[2],
            sub: !0,
            pos: [U[0] + Ct[0] * R, U[1] + Ct[1] * N]
          };
        }), !0);
        return {
          type: y,
          clipText: f,
          radiusX: R,
          radiusY: N,
          left: U[0] - R,
          top: U[1] - N,
          right: U[0] + R,
          bottom: U[1] + N,
          poses: S,
          splitter: T
        };
      } else if (y === "inset") {
        var x = ca(b || "0 0 0 0"), $ = x.indexOf("round"), Z = ($ > -1 ? x.slice(0, $) : x).length, H = x.slice(Z + 1), z = x.slice(0, Z), X = z[0], ct = z[1], it = ct === void 0 ? X : ct, lt = z[2], et = lt === void 0 ? X : lt, k = z[3], ft = k === void 0 ? it : k, Q = [X, et].map(function(Ct) {
          return Te(Ct, e);
        }), St = Q[0], at = Q[1], q = [ft, it].map(function(Ct) {
          return Te(Ct, t);
        }), bt = q[0], st = q[1], W = t - st, nt = e - at, dt = VC(H, W - bt, nt - St, bt, St), S = Tt(Tt([], Iv(St, W, nt, bt), !0), dt, !0);
        return {
          type: "inset",
          clipText: f,
          poses: S,
          top: St,
          left: bt,
          right: W,
          bottom: nt,
          radius: H,
          splitter: T
        };
      } else if (y === "rect") {
        var x = Fa(b || "0px, ".concat(t, "px, ").concat(e, "px, 0px"));
        T = ",";
        var V = x.map(function(pe) {
          var le = xd(pe).value;
          return le;
        }), St = V[0], st = V[1], at = V[2], bt = V[3], S = Iv(St, st, at, bt);
        return {
          type: "rect",
          clipText: f,
          poses: S,
          top: St,
          right: st,
          bottom: at,
          left: bt,
          values: x,
          splitter: T
        };
      }
    }
  }
}
function d3(i, t, e, r, n) {
  var s = i[t], a = s.direction, o = s.sub, u = i.map(function() {
    return [0, 0];
  }), l = a ? a.split("") : [];
  if (r && t < 8) {
    var h = l.filter(function(A) {
      return A === "w" || A === "e";
    }), d = l.filter(function(A) {
      return A === "n" || A === "s";
    }), f = h[0], p = d[0];
    u[t] = e;
    var v = XC(i), g = v[0], m = v[1], y = g && m ? g / m : 0;
    if (y && n) {
      var _ = (t + 4) % 8, b = i[_].pos, w = [0, 0];
      a.indexOf("w") > -1 ? w[0] = -1 : a.indexOf("e") > -1 && (w[0] = 1), a.indexOf("n") > -1 ? w[1] = -1 : a.indexOf("s") > -1 && (w[1] = 1);
      var T = wC([g, m], e, y, w, !0), x = g + T[0], S = m + T[1], C = b[1], M = b[1], I = b[0], R = b[0];
      w[0] === -1 ? I = R - x : w[0] === 1 ? R = I + x : (I = I - x / 2, R = R + x / 2), w[1] === -1 ? C = M - S : (w[1] === 1 || (C = M - S / 2), M = C + S);
      var N = Iv(C, R, M, I);
      i.forEach(function(A, G) {
        u[G][0] = N[G].pos[0] - A.pos[0], u[G][1] = N[G].pos[1] - A.pos[1];
      });
    } else
      i.forEach(function(A, G) {
        var B = A.direction;
        B && (B.indexOf(f) > -1 && (u[G][0] = e[0]), B.indexOf(p) > -1 && (u[G][1] = e[1]));
      }), f && (u[1][0] = e[0] / 2, u[5][0] = e[0] / 2), p && (u[3][1] = e[1] / 2, u[7][1] = e[1] / 2);
  } else
    a && !o ? l.forEach(function(A) {
      var G = A === "n" || A === "s";
      i.forEach(function(B, U) {
        var $ = B.direction, Z = B.horizontal, H = B.vertical;
        !$ || $.indexOf(A) === -1 || (u[U] = [G || !Z ? 0 : e[0], !G || !H ? 0 : e[1]]);
      });
    }) : u[t] = e;
  return u;
}
function p3(i, t) {
  var e = QT(i, t), r = e[0], n = e[1], s = t.datas, a = s.clipPath, o = s.clipIndex, u = a, l = u.type, h = u.poses, d = u.splitter, f = h.map(function(_) {
    return _.pos;
  });
  if (l === "polygon")
    f.splice(o, 0, [r, n]);
  else if (l === "inset") {
    var p = a3.indexOf(o), v = o3.indexOf(o), g = h.length;
    if (l3(h, f, 8, p, v, r, n, f[4][0], f[4][1], f[0][0], f[0][1]), g === h.length)
      return;
  } else
    return;
  var m = Fx(i, a, f), y = "".concat(l, "(").concat(m.join(d), ")");
  mt(i, "onClip", Ut(i, t, F({
    clipEventType: "added",
    clipType: l,
    poses: f,
    clipStyles: m,
    clipStyle: y,
    distX: 0,
    distY: 0
  }, Ir({
    clipPath: y
  }, t))));
}
function v3(i, t) {
  var e = t.datas, r = e.clipPath, n = e.clipIndex, s = r, a = s.type, o = s.poses, u = s.splitter, l = o.map(function(p) {
    return p.pos;
  }), h = l.length;
  if (a === "polygon")
    o.splice(n, 1), l.splice(n, 1);
  else if (a === "inset") {
    if (n < 8 || (u3(o, l, n, 8, h), h === o.length))
      return;
  } else
    return;
  var d = Fx(i, r, l), f = "".concat(a, "(").concat(d.join(u), ")");
  mt(i, "onClip", Ut(i, t, F({
    clipEventType: "removed",
    clipType: a,
    poses: l,
    clipStyles: d,
    clipStyle: f,
    distX: 0,
    distY: 0
  }, Ir({
    clipPath: f
  }, t))));
}
var g3 = {
  name: "clippable",
  props: ["clippable", "defaultClipPath", "customClipPath", "keepRatio", "clipRelative", "clipArea", "dragWithClip", "clipTargetBounds", "clipVerticalGuidelines", "clipHorizontalGuidelines", "clipSnapThreshold"],
  events: ["clipStart", "clip", "clipEnd"],
  css: [`.control.clip-control {
background: #6d6;
cursor: pointer;
}
.control.clip-control.clip-radius {
background: #d66;
}
.line.clip-line {
background: #6e6;
cursor: move;
z-index: 1;
}
.clip-area {
position: absolute;
top: 0;
left: 0;
}
.clip-ellipse {
position: absolute;
cursor: move;
border: 1px solid #6d6;
border: var(--zoompx) solid #6d6;
border-radius: 50%;
transform-origin: 0px 0px;
}`, `:host {
--bounds-color: #d66;
}`, `.guideline {
pointer-events: none;
z-index: 2;
}`, `.line.guideline.bounds {
background: #d66;
background: var(--bounds-color);
}`],
  render: function(i, t) {
    var e = i.props, r = e.customClipPath, n = e.defaultClipPath, s = e.clipArea, a = e.zoom, o = e.groupable, u = i.getState(), l = u.target, h = u.width, d = u.height, f = u.allMatrix, p = u.is3d, v = u.left, g = u.top, m = u.pos1, y = u.pos2, _ = u.pos3, b = u.pos4, w = u.clipPathState, T = u.snapBoundInfos, x = u.rotation;
    if (!l || o)
      return [];
    var S = $w(l, h, d, n || "inset", w || r);
    if (!S)
      return [];
    var C = p ? 4 : 3, M = S.type, I = S.poses, R = I.map(function(nt) {
      var dt = nr(f, nt.pos, C);
      return [dt[0] - v, dt[1] - g];
    }), N = [], A = [], G = M === "rect", B = M === "inset", U = M === "polygon";
    if (G || B || U) {
      var $ = B ? R.slice(0, 8) : R;
      A = $.map(function(nt, dt) {
        var V = dt === 0 ? $[$.length - 1] : $[dt - 1], xt = $e(V, nt), Dt = fC(V, nt);
        return t.createElement("div", {
          key: "clipLine".concat(dt),
          className: Pt("line", "clip-line", "snap-control"),
          "data-clip-index": dt,
          style: {
            width: "".concat(Dt, "px"),
            transform: "translate(".concat(V[0], "px, ").concat(V[1], "px) rotate(").concat(xt, "rad) scaleY(").concat(a, ")")
          }
        });
      });
    }
    if (N = R.map(function(nt, dt) {
      return t.createElement("div", {
        key: "clipControl".concat(dt),
        className: Pt("control", "clip-control", "snap-control"),
        "data-clip-index": dt,
        style: {
          transform: "translate(".concat(nt[0], "px, ").concat(nt[1], "px) rotate(").concat(x, "rad) scale(").concat(a, ")")
        }
      });
    }), B && N.push.apply(N, R.slice(8).map(function(nt, dt) {
      return t.createElement("div", {
        key: "clipRadiusControl".concat(dt),
        className: Pt("control", "clip-control", "clip-radius", "snap-control"),
        "data-clip-index": 8 + dt,
        style: {
          transform: "translate(".concat(nt[0], "px, ").concat(nt[1], "px) rotate(").concat(x, "rad) scale(").concat(a, ")")
        }
      });
    })), M === "circle" || M === "ellipse") {
      var Z = S.left, H = S.top, z = S.radiusX, X = S.radiusY, ct = Mt(nr(f, [Z, H], C), nr(f, [0, 0], C)), it = ct[0], lt = ct[1], et = "none";
      if (!s) {
        for (var k = Math.max(10, z / 5, X / 5), ft = [], Q = 0; Q <= k; ++Q) {
          var St = Math.PI * 2 / k * Q;
          ft.push([z + (z - a) * Math.cos(St), X + (X - a) * Math.sin(St)]);
        }
        ft.push([z, -2]), ft.push([-2, -2]), ft.push([-2, X * 2 + 2]), ft.push([z * 2 + 2, X * 2 + 2]), ft.push([z * 2 + 2, -2]), ft.push([z, -2]), et = "polygon(".concat(ft.map(function(nt) {
          return "".concat(nt[0], "px ").concat(nt[1], "px");
        }).join(", "), ")");
      }
      N.push(t.createElement("div", {
        key: "clipEllipse",
        className: Pt("clip-ellipse", "snap-control"),
        style: {
          width: "".concat(z * 2, "px"),
          height: "".concat(X * 2, "px"),
          clipPath: et,
          transform: "translate(".concat(-v + it, "px, ").concat(-g + lt, "px) ").concat(p0(f))
        }
      }));
    }
    if (s) {
      var at = Si(Tt([m, y, _, b], R, !0)), q = at.width, bt = at.height, st = at.left, W = at.top;
      if (U || G || B) {
        var ft = B ? R.slice(0, 8) : R;
        N.push(t.createElement("div", {
          key: "clipArea",
          className: Pt("clip-area", "snap-control"),
          style: {
            width: "".concat(q, "px"),
            height: "".concat(bt, "px"),
            transform: "translate(".concat(st, "px, ").concat(W, "px)"),
            clipPath: "polygon(".concat(ft.map(function(dt) {
              return "".concat(dt[0] - st, "px ").concat(dt[1] - W, "px");
            }).join(", "), ")")
          }
        }));
      }
    }
    return T && ["vertical", "horizontal"].forEach(function(nt) {
      var dt = T[nt], V = nt === "horizontal";
      dt.isSnap && A.push.apply(A, dt.snap.posInfos.map(function(xt, Dt) {
        var Ct = xt.pos, be = Mt(nr(f, V ? [0, Ct] : [Ct, 0], C), [v, g]), je = Mt(nr(f, V ? [h, Ct] : [Ct, d], C), [v, g]);
        return mc(t, "", be, je, a, "clip".concat(nt, "snap").concat(Dt), "guideline");
      })), dt.isBound && A.push.apply(A, dt.bounds.map(function(xt, Dt) {
        var Ct = xt.pos, be = Mt(nr(f, V ? [0, Ct] : [Ct, 0], C), [v, g]), je = Mt(nr(f, V ? [h, Ct] : [Ct, d], C), [v, g]);
        return mc(t, "", be, je, a, "clip".concat(nt, "bounds").concat(Dt), "guideline", "bounds", "bold");
      }));
    }), Tt(Tt([], N, !0), A, !0);
  },
  dragControlCondition: function(i, t) {
    return t.inputEvent && (t.inputEvent.target.getAttribute("class") || "").indexOf("clip") > -1;
  },
  dragStart: function(i, t) {
    var e = i.props, r = e.dragWithClip, n = r === void 0 ? !0 : r;
    return n ? !1 : this.dragControlStart(i, t);
  },
  drag: function(i, t) {
    return this.dragControl(i, F(F({}, t), {
      isDragTarget: !0
    }));
  },
  dragEnd: function(i, t) {
    return this.dragControlEnd(i, t);
  },
  dragControlStart: function(i, t) {
    var e = i.state, r = i.props, n = r.defaultClipPath, s = r.customClipPath, a = e.target, o = e.width, u = e.height, l = t.inputEvent ? t.inputEvent.target : null, h = l && l.getAttribute("class") || "", d = t.datas, f = $w(a, o, u, n || "inset", s);
    if (!f)
      return !1;
    var p = f.clipText, v = f.type, g = f.poses, m = mt(i, "onClipStart", Ut(i, t, {
      clipType: v,
      clipStyle: p,
      poses: g.map(function(y) {
        return y.pos;
      })
    }));
    return m === !1 ? (d.isClipStart = !1, !1) : (d.isControl = h && h.indexOf("clip-control") > -1, d.isLine = h.indexOf("clip-line") > -1, d.isArea = h.indexOf("clip-area") > -1 || h.indexOf("clip-ellipse") > -1, d.clipIndex = l ? parseInt(l.getAttribute("data-clip-index"), 10) : -1, d.clipPath = f, d.isClipStart = !0, e.clipPathState = p, au(i, t), !0);
  },
  dragControl: function(i, t) {
    var e, r, n = t.datas, s = t.originalDatas, a = t.isDragTarget;
    if (!n.isClipStart)
      return !1;
    var o = n, u = o.isControl, l = o.isLine, h = o.isArea, d = o.clipIndex, f = o.clipPath;
    if (!f)
      return !1;
    var p = ru(i.props, "clippable"), v = p.keepRatio, g = 0, m = 0, y = s.draggable, _ = Un(t);
    a && y ? (e = y.prevBeforeDist, g = e[0], m = e[1]) : (g = _[0], m = _[1]);
    var b = [g, m], w = i.state, T = w.width, x = w.height, S = !h && !u && !l, C = f.type, M = f.poses, I = f.splitter, R = M.map(function(L) {
      return L.pos;
    });
    S && (g = -g, m = -m);
    var N = !u || M[d].direction === "nesw", A = C === "inset" || C === "rect", G = M.map(function() {
      return [0, 0];
    });
    if (u && !N) {
      var B = M[d], U = B.horizontal, $ = B.vertical, Z = [g * Math.abs(U), m * Math.abs($)];
      G = d3(M, d, Z, A, v);
    } else
      N && (G = R.map(function() {
        return [g, m];
      }));
    var H = R.map(function(L, j) {
      return Jt(L, G[j]);
    }), z = Tt([], H, !0);
    w.snapBoundInfos = null;
    var X = f.type === "circle", ct = f.type === "ellipse";
    if (X || ct) {
      var it = Si(H), lt = Math.abs(it.bottom - it.top), et = Math.abs(ct ? it.right - it.left : lt), k = H[0][1] + lt, ft = H[0][0] - et, Q = H[0][0] + et;
      X && (z.push([Q, it.bottom]), G.push([1, 0])), z.push([it.left, k]), G.push([0, 1]), z.push([ft, it.bottom]), G.push([1, 0]);
    }
    var St = RC((p.clipHorizontalGuidelines || []).map(function(L) {
      return Te("".concat(L), x);
    }), (p.clipVerticalGuidelines || []).map(function(L) {
      return Te("".concat(L), T);
    }), T, x), at = [], q = [];
    if (X || ct)
      at = [z[4][0], z[2][0]], q = [z[1][1], z[3][1]];
    else if (A) {
      var bt = [z[0], z[2], z[4], z[6]], st = [G[0], G[2], G[4], G[6]];
      at = bt.filter(function(L, j) {
        return st[j][0];
      }).map(function(L) {
        return L[0];
      }), q = bt.filter(function(L, j) {
        return st[j][1];
      }).map(function(L) {
        return L[1];
      });
    } else
      at = z.filter(function(L, j) {
        return G[j][0];
      }).map(function(L) {
        return L[0];
      }), q = z.filter(function(L, j) {
        return G[j][1];
      }).map(function(L) {
        return L[1];
      });
    var W = [0, 0], nt = Nw(St, p.clipTargetBounds && {
      left: 0,
      top: 0,
      right: T,
      bottom: x
    }, at, q, 5), dt = nt.horizontal, V = nt.vertical, xt = dt.offset, Dt = V.offset;
    if (dt.isBound && (W[1] += xt), V.isBound && (W[0] += Dt), (ct || X) && G[0][0] === 0 && G[0][1] === 0) {
      var it = Si(H), Ct = it.bottom - it.top, be = ct ? it.right - it.left : Ct, je = V.isBound ? Math.abs(Dt) : V.snapIndex === 0 ? -Dt : Dt, ee = dt.isBound ? Math.abs(xt) : dt.snapIndex === 0 ? -xt : xt;
      be -= je, Ct -= ee, X && (Ct = CC(V, dt) > 0 ? Ct : be, be = Ct);
      var pe = z[0];
      z[1][1] = pe[1] - Ct, z[2][0] = pe[0] + be, z[3][1] = pe[1] + Ct, z[4][0] = pe[0] - be;
    } else if (A && v && u) {
      var le = XC(M), ae = le[0], ne = le[1], Ht = ae && ne ? ae / ne : 0, xr = M[d], ou = xr.direction || "", vh = z[1][1], k = z[5][1], ft = z[7][0], Q = z[3][0];
      xt <= Dt ? xt = Dt / Ht : Dt = xt * Ht, ou.indexOf("w") > -1 ? ft -= Dt : ou.indexOf("e") > -1 ? Q -= Dt : (ft += Dt / 2, Q -= Dt / 2), ou.indexOf("n") > -1 ? vh -= xt : ou.indexOf("s") > -1 ? k -= xt : (vh += xt / 2, k -= xt / 2);
      var w0 = Iv(vh, Q, k, ft);
      z.forEach(function(rt, ot) {
        var ut;
        ut = w0[ot].pos, rt[0] = ut[0], rt[1] = ut[1];
      });
    } else
      z.forEach(function(L, j) {
        var J = G[j];
        J[0] && (L[0] -= Dt), J[1] && (L[1] -= xt);
      });
    var gh = Fx(i, f, H), uu = "".concat(C, "(").concat(gh.join(I), ")");
    if (w.clipPathState = uu, X || ct)
      at = [z[4][0], z[2][0]], q = [z[1][1], z[3][1]];
    else if (A) {
      var bt = [z[0], z[2], z[4], z[6]];
      at = bt.map(function(j) {
        return j[0];
      }), q = bt.map(function(j) {
        return j[1];
      });
    } else
      at = z.map(function(L) {
        return L[0];
      }), q = z.map(function(L) {
        return L[1];
      });
    if (w.snapBoundInfos = Nw(St, p.clipTargetBounds && {
      left: 0,
      top: 0,
      right: T,
      bottom: x
    }, at, q, 1), y) {
      var kd = w.is3d, Nd = w.allMatrix, E0 = kd ? 4 : 3, D = W;
      a && (D = [b[0] + W[0] - _[0], b[1] + W[1] - _[1]]), y.deltaOffset = _e(Nd, [D[0], D[1], 0, 0], E0);
    }
    return mt(i, "onClip", Ut(i, t, F({
      clipEventType: "changed",
      clipType: C,
      poses: H,
      clipStyle: uu,
      clipStyles: gh,
      distX: g,
      distY: m
    }, Ir((r = {}, r[C === "rect" ? "clip" : "clipPath"] = uu, r), t)))), !0;
  },
  dragControlEnd: function(i, t) {
    this.unset(i);
    var e = t.isDrag, r = t.datas, n = t.isDouble, s = r.isLine, a = r.isClipStart, o = r.isControl;
    return a ? (mt(i, "onClipEnd", ui(i, t, {})), n && (o ? v3(i, t) : s && p3(i, t)), n || e) : !1;
  },
  unset: function(i) {
    i.state.clipPathState = "", i.state.snapBoundInfos = null;
  }
}, m3 = {
  name: "originDraggable",
  props: ["originDraggable", "originRelative"],
  events: ["dragOriginStart", "dragOrigin", "dragOriginEnd"],
  css: [`:host[data-able-origindraggable] .control.origin {
pointer-events: auto;
}`],
  dragControlCondition: function(i, t) {
    return t.isRequest ? t.requestAble === "originDraggable" : sr(t.inputEvent.target, Pt("origin"));
  },
  dragControlStart: function(i, t) {
    var e = t.datas;
    au(i, t);
    var r = Ut(i, t, {
      dragStart: Or.dragStart(i, new Ql().dragStart([0, 0], t))
    }), n = mt(i, "onDragOriginStart", r);
    return e.startOrigin = i.state.transformOrigin, e.startTargetOrigin = i.state.targetOrigin, e.prevOrigin = [0, 0], e.isDragOrigin = !0, n === !1 ? (e.isDragOrigin = !1, !1) : r;
  },
  dragControl: function(i, t) {
    var e = t.datas, r = t.isPinch, n = t.isRequest;
    if (!e.isDragOrigin)
      return !1;
    var s = Un(t), a = s[0], o = s[1], u = i.state, l = u.width, h = u.height, d = u.offsetMatrix, f = u.targetMatrix, p = u.is3d, v = i.props.originRelative, g = v === void 0 ? !0 : v, m = p ? 4 : 3, y = [a, o];
    if (n) {
      var _ = t.distOrigin;
      (_[0] || _[1]) && (y = _);
    }
    var b = Jt(e.startOrigin, y), w = Jt(e.startTargetOrigin, y), T = Mt(y, e.prevOrigin), x = Id(d, f, b, m), S = i.getRect(), C = Si(fa(x, l, h, m)), M = [S.left - C.left, S.top - C.top];
    e.prevOrigin = y;
    var I = [Vi(w[0], l, g), Vi(w[1], h, g)].join(" "), R = Or.drag(i, Od(t, i.state, M, !!r, !1)), N = Ut(i, t, F(F({
      width: l,
      height: h,
      origin: b,
      dist: y,
      delta: T,
      transformOrigin: I,
      drag: R
    }, Ir({
      transformOrigin: I,
      transform: R.transform
    }, t)), {
      afterTransform: R.transform
    }));
    return mt(i, "onDragOrigin", N), N;
  },
  dragControlEnd: function(i, t) {
    var e = t.datas;
    return e.isDragOrigin ? (mt(i, "onDragOriginEnd", ui(i, t, {})), !0) : !1;
  },
  dragGroupControlCondition: function(i, t) {
    return this.dragControlCondition(i, t);
  },
  dragGroupControlStart: function(i, t) {
    var e = this.dragControlStart(i, t);
    return !!e;
  },
  dragGroupControl: function(i, t) {
    var e = this.dragControl(i, t);
    return e ? (i.transformOrigin = e.transformOrigin, !0) : !1;
  },
  /**
  * @method Moveable.OriginDraggable#request
  * @param {object} e - the OriginDraggable's request parameter
  * @param {number} [e.x] - x position
  * @param {number} [e.y] - y position
  * @param {number} [e.deltaX] - x number to move
  * @param {number} [e.deltaY] - y number to move
  * @param {array} [e.deltaOrigin] - left, top number to move transform-origin
  * @param {array} [e.origin] - transform-origin position
  * @param {number} [e.isInstant] - Whether to execute the request instantly
  * @return {Moveable.Requester} Moveable Requester
  * @example
   * // Instantly Request (requestStart - request - requestEnd)
  * // Use Relative Value
  * moveable.request("originDraggable", { deltaX: 10, deltaY: 10 }, true);
  * // Use Absolute Value
  * moveable.request("originDraggable", { x: 200, y: 100 }, true);
  * // Use Transform Value
  * moveable.request("originDraggable", { deltaOrigin: [10, 0] }, true);
  * moveable.request("originDraggable", { origin: [100, 0] }, true);
  * // requestStart
  * const requester = moveable.request("originDraggable");
  *
  * // request
  * // Use Relative Value
  * requester.request({ deltaX: 10, deltaY: 10 });
  * requester.request({ deltaX: 10, deltaY: 10 });
  * requester.request({ deltaX: 10, deltaY: 10 });
  * // Use Absolute Value
  * moveable.request("originDraggable", { x: 200, y: 100 });
  * moveable.request("originDraggable", { x: 220, y: 100 });
  * moveable.request("originDraggable", { x: 240, y: 100 });
  *
  * // requestEnd
  * requester.requestEnd();
  */
  request: function(i) {
    var t = {}, e = i.getRect(), r = 0, n = 0, s = e.transformOrigin, a = [0, 0];
    return {
      isControl: !0,
      requestStart: function() {
        return {
          datas: t
        };
      },
      request: function(o) {
        return "deltaOrigin" in o ? (a[0] += o.deltaOrigin[0], a[1] += o.deltaOrigin[1]) : "origin" in o ? (a[0] = o.origin[0] - s[0], a[1] = o.origin[1] - s[1]) : ("x" in o ? r = o.x - e.left : "deltaX" in o && (r += o.deltaX), "y" in o ? n = o.y - e.top : "deltaY" in o && (n += o.deltaY)), {
          datas: t,
          distX: r,
          distY: n,
          distOrigin: a
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  }
};
function y3(i, t, e, r) {
  var n = i.filter(function(u) {
    var l = u.virtual, h = u.horizontal;
    return h && !l;
  }).length, s = i.filter(function(u) {
    var l = u.virtual, h = u.vertical;
    return h && !l;
  }).length, a = -1;
  if (t === 0 && (n === 0 ? a = 0 : n === 1 && (a = 1)), t === 2 && (n <= 2 ? a = 2 : n <= 3 && (a = 3)), t === 3 && (s === 0 ? a = 4 : s < 4 && (a = 7)), t === 1 && (s <= 1 ? a = 5 : s <= 2 && (a = 6)), !(a === -1 || !i[a].virtual)) {
    var o = i[a];
    _3(i, a), a < 4 ? o.pos[0] = e : o.pos[1] = r;
  }
}
function _3(i, t) {
  t < 4 ? i.slice(0, t + 1).forEach(function(e) {
    e.virtual = !1;
  }) : (i[0].virtual && (i[0].virtual = !1), i.slice(4, t + 1).forEach(function(e) {
    e.virtual = !1;
  }));
}
function b3(i, t) {
  t < 4 ? i.slice(t, 4).forEach(function(e) {
    e.virtual = !0;
  }) : i.slice(t).forEach(function(e) {
    e.virtual = !0;
  });
}
function Vw(i, t, e, r, n) {
  r === void 0 && (r = [0, 0]);
  var s = [];
  return !i || i === "0px" ? s = [] : s = ca(i), VC(s, t, e, 0, 0, r, n);
}
function Xw(i, t, e, r, n) {
  var s = i.state, a = s.width, o = s.height, u = Bx(n, i.props.roundRelative, a, o), l = u.raws, h = u.styles, d = u.radiusPoses, f = h3(d, l), p = f.horizontals, v = f.verticals, g = h.join(" ");
  s.borderRadiusState = g;
  var m = Ut(i, t, F({
    horizontals: p,
    verticals: v,
    borderRadius: g,
    width: a,
    height: o,
    delta: r,
    dist: e
  }, Ir({
    borderRadius: g
  }, t)));
  return mt(i, "onRound", m), m;
}
function Ww(i) {
  var t, e, r = i.getState().style, n = r.borderRadius || "";
  if (!n && i.props.groupable) {
    var s = i.moveables[0], a = i.getTargets()[0];
    a && ((s == null ? void 0 : s.props.target) === a ? (n = (e = (t = i.moveables[0]) === null || t === void 0 ? void 0 : t.state.style.borderRadius) !== null && e !== void 0 ? e : "", r.borderRadius = n) : (n = Mx(a).borderRadius, r.borderRadius = n));
  }
  return n;
}
var x3 = {
  name: "roundable",
  props: ["roundable", "roundRelative", "minRoundControls", "maxRoundControls", "roundClickable", "roundPadding", "isDisplayShadowRoundControls"],
  events: ["roundStart", "round", "roundEnd", "roundGroupStart", "roundGroup", "roundGroupEnd"],
  css: [`.control.border-radius {
background: #d66;
cursor: pointer;
z-index: 3;
}`, `.control.border-radius.vertical {
background: #d6d;
z-index: 2;
}`, `.control.border-radius.virtual {
opacity: 0.5;
z-index: 1;
}`, `:host.round-line-clickable .line.direction {
cursor: pointer;
}`],
  className: function(i) {
    var t = i.props.roundClickable;
    return t === !0 || t === "line" ? Pt("round-line-clickable") : "";
  },
  requestStyle: function() {
    return ["borderRadius"];
  },
  requestChildStyle: function() {
    return ["borderRadius"];
  },
  render: function(i, t) {
    var e = i.getState(), r = e.target, n = e.width, s = e.height, a = e.allMatrix, o = e.is3d, u = e.left, l = e.top, h = e.borderRadiusState, d = i.props, f = d.minRoundControls, p = f === void 0 ? [0, 0] : f, v = d.maxRoundControls, g = v === void 0 ? [4, 4] : v, m = d.zoom, y = d.roundPadding, _ = y === void 0 ? 0 : y, b = d.isDisplayShadowRoundControls, w = d.groupable;
    if (!r)
      return null;
    var T = h || Ww(i), x = o ? 4 : 3, S = Vw(T, n, s, p, !0);
    if (!S)
      return null;
    var C = 0, M = 0, I = w ? [0, 0] : [u, l];
    return S.map(function(R, N) {
      var A = R.horizontal, G = R.vertical, B = R.direction || "", U = Tt([], R.pos, !0);
      M += Math.abs(A), C += Math.abs(G), A && B.indexOf("n") > -1 && (U[1] -= _), G && B.indexOf("w") > -1 && (U[0] -= _), A && B.indexOf("s") > -1 && (U[1] += _), G && B.indexOf("e") > -1 && (U[0] += _);
      var $ = Mt(nr(a, U, x), I), Z = R.vertical ? C <= g[1] && (b || !R.virtual) : M <= g[0] && (b || !R.virtual);
      return t.createElement("div", {
        key: "borderRadiusControl".concat(N),
        className: Pt("control", "border-radius", R.vertical ? "vertical" : "", R.virtual ? "virtual" : ""),
        "data-radius-index": N,
        style: {
          display: Z ? "block" : "none",
          transform: "translate(".concat($[0], "px, ").concat($[1], "px) scale(").concat(m, ")")
        }
      });
    });
  },
  dragControlCondition: function(i, t) {
    if (!t.inputEvent || t.isRequest)
      return !1;
    var e = t.inputEvent.target.getAttribute("class") || "";
    return e.indexOf("border-radius") > -1 || e.indexOf("moveable-line") > -1 && e.indexOf("moveable-direction") > -1;
  },
  dragGroupControlCondition: function(i, t) {
    return this.dragControlCondition(i, t);
  },
  dragControlStart: function(i, t) {
    var e = t.inputEvent, r = t.datas, n = e.target, s = n.getAttribute("class") || "", a = s.indexOf("border-radius") > -1, o = s.indexOf("moveable-line") > -1 && s.indexOf("moveable-direction") > -1, u = a ? parseInt(n.getAttribute("data-radius-index"), 10) : -1, l = -1;
    if (o) {
      var h = n.getAttribute("data-line-key") || "";
      h && (l = parseInt(h.replace(/render-line-/g, ""), 10), isNaN(l) && (l = -1));
    }
    if (!a && !o)
      return !1;
    var d = Ut(i, t, {}), f = mt(i, "onRoundStart", d);
    if (f === !1)
      return !1;
    r.lineIndex = l, r.controlIndex = u, r.isControl = a, r.isLine = o, au(i, t);
    var p = i.props, v = p.roundRelative, g = p.minRoundControls, m = g === void 0 ? [0, 0] : g, y = i.state, _ = y.width, b = y.height;
    r.isRound = !0, r.prevDist = [0, 0];
    var w = Ww(i), T = Vw(w || "", _, b, m, !0) || [];
    return r.controlPoses = T, y.borderRadiusState = Bx(T, v, _, b).styles.join(" "), d;
  },
  dragControl: function(i, t) {
    var e = t.datas, r = e.controlPoses;
    if (!e.isRound || !e.isControl || !r.length)
      return !1;
    var n = e.controlIndex, s = Un(t), a = s[0], o = s[1], u = [a, o], l = Mt(u, e.prevDist), h = i.props.maxRoundControls, d = h === void 0 ? [4, 4] : h, f = i.state, p = f.width, v = f.height, g = r[n], m = g.vertical, y = g.horizontal, _ = r.map(function(w) {
      var T = w.horizontal, x = w.vertical, S = [T * y * u[0], x * m * u[1]];
      if (T) {
        if (d[0] === 1)
          return S;
        if (d[0] < 4 && T !== y)
          return S;
      } else {
        if (d[1] === 0)
          return S[1] = x * y * u[0] / p * v, S;
        if (m) {
          if (d[1] === 1)
            return S;
          if (d[1] < 4 && x !== m)
            return S;
        }
      }
      return [0, 0];
    });
    _[n] = u;
    var b = r.map(function(w, T) {
      return F(F({}, w), {
        pos: Jt(w.pos, _[T])
      });
    });
    return n < 4 ? b.slice(0, n + 1).forEach(function(w) {
      w.virtual = !1;
    }) : b.slice(4, n + 1).forEach(function(w) {
      w.virtual = !1;
    }), e.prevDist = [a, o], Xw(i, t, u, l, b);
  },
  dragControlEnd: function(i, t) {
    var e = i.state;
    e.borderRadiusState = "";
    var r = t.datas, n = t.isDouble;
    if (!r.isRound)
      return !1;
    var s = r.isControl, a = r.controlIndex, o = r.isLine, u = r.lineIndex, l = r.controlPoses, h = l.filter(function(y) {
      var _ = y.virtual;
      return _;
    }).length, d = i.props.roundClickable, f = d === void 0 ? !0 : d;
    if (n && f) {
      if (s && (f === !0 || f === "control"))
        b3(l, a);
      else if (o && (f === !0 || f === "line")) {
        var p = QT(i, t), v = p[0], g = p[1];
        y3(l, u, v, g);
      }
      h !== l.filter(function(y) {
        var _ = y.virtual;
        return _;
      }).length && Xw(i, t, [0, 0], [0, 0], l);
    }
    var m = ui(i, t, {});
    return mt(i, "onRoundEnd", m), e.borderRadiusState = "", m;
  },
  dragGroupControlStart: function(i, t) {
    var e = this.dragControlStart(i, t);
    if (!e)
      return !1;
    var r = i.moveables, n = i.props.targets, s = Ji(i, "roundable", t), a = F({
      targets: i.props.targets,
      events: s.map(function(o, u) {
        return F(F({}, o), {
          target: n[u],
          moveable: r[u],
          currentTarget: r[u]
        });
      })
    }, e);
    return mt(i, "onRoundGroupStart", a), e;
  },
  dragGroupControl: function(i, t) {
    var e = this.dragControl(i, t);
    if (!e)
      return !1;
    var r = i.moveables, n = i.props.targets, s = Ji(i, "roundable", t), a = F({
      targets: i.props.targets,
      events: s.map(function(o, u) {
        return F(F(F({}, o), {
          target: n[u],
          moveable: r[u],
          currentTarget: r[u]
        }), Ir({
          borderRadius: e.borderRadius
        }, o));
      })
    }, e);
    return mt(i, "onRoundGroup", a), a;
  },
  dragGroupControlEnd: function(i, t) {
    var e = i.moveables, r = i.props.targets, n = Ji(i, "roundable", t);
    v0(i, "onRound", function(o) {
      var u = F({
        targets: i.props.targets,
        events: n.map(function(l, h) {
          return F(F(F({}, l), {
            target: r[h],
            moveable: e[h],
            currentTarget: e[h]
          }), Ir({
            borderRadius: o.borderRadius
          }, l));
        })
      }, o);
      mt(i, "onRoundGroup", u);
    });
    var s = this.dragControlEnd(i, t);
    if (!s)
      return !1;
    var a = F({
      targets: i.props.targets,
      events: n.map(function(o, u) {
        var l;
        return F(F({}, o), {
          target: r[u],
          moveable: e[u],
          currentTarget: e[u],
          lastEvent: (l = o.datas) === null || l === void 0 ? void 0 : l.lastEvent
        });
      })
    }, s);
    return mt(i, "onRoundGroupEnd", a), a;
  },
  unset: function(i) {
    i.state.borderRadiusState = "";
  }
};
function w3(i, t) {
  var e = t ? 4 : 3, r = Oe(e), n = "matrix".concat(t ? "3d" : "", "(").concat(r.join(","), ")");
  return i === n || i === "matrix(1,0,0,1,0,0)";
}
var WC = {
  isPinch: !0,
  name: "beforeRenderable",
  props: [],
  events: ["beforeRenderStart", "beforeRender", "beforeRenderEnd", "beforeRenderGroupStart", "beforeRenderGroup", "beforeRenderGroupEnd"],
  dragRelation: "weak",
  setTransform: function(i, t) {
    var e = i.state, r = e.is3d, n = e.target, s = e.targetMatrix, a = n == null ? void 0 : n.style.transform, o = r ? "matrix3d(".concat(s.join(","), ")") : "matrix(".concat(UT(s, !0), ")"), u = !a || a === "none" ? o : a;
    t.datas.startTransforms = w3(u, r) ? [] : ca(u);
  },
  resetStyle: function(i) {
    var t = i.datas;
    t.nextStyle = {}, t.nextTransforms = i.datas.startTransforms, t.nextTransformAppendedIndexes = [];
  },
  fillDragStartParams: function(i, t) {
    return Ut(i, t, {
      setTransform: function(e) {
        t.datas.startTransforms = tr(e) ? e : ca(e);
      },
      isPinch: !!t.isPinch
    });
  },
  fillDragParams: function(i, t) {
    return Ut(i, t, {
      isPinch: !!t.isPinch
    });
  },
  dragStart: function(i, t) {
    this.setTransform(i, t), this.resetStyle(t), mt(i, "onBeforeRenderStart", this.fillDragStartParams(i, t));
  },
  drag: function(i, t) {
    this.resetStyle(t), mt(i, "onBeforeRender", Ut(i, t, {
      isPinch: !!t.isPinch
    }));
  },
  dragEnd: function(i, t) {
    mt(i, "onBeforeRenderEnd", Ut(i, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag
    }));
  },
  dragGroupStart: function(i, t) {
    var e = this;
    this.dragStart(i, t);
    var r = Ji(i, "beforeRenderable", t), n = i.moveables, s = r.map(function(a, o) {
      var u = n[o];
      return e.setTransform(u, a), e.resetStyle(a), e.fillDragStartParams(u, a);
    });
    mt(i, "onBeforeRenderGroupStart", Ut(i, t, {
      isPinch: !!t.isPinch,
      targets: i.props.targets,
      setTransform: function() {
      },
      events: s
    }));
  },
  dragGroup: function(i, t) {
    var e = this;
    this.drag(i, t);
    var r = Ji(i, "beforeRenderable", t), n = i.moveables, s = r.map(function(a, o) {
      var u = n[o];
      return e.resetStyle(a), e.fillDragParams(u, a);
    });
    mt(i, "onBeforeRenderGroup", Ut(i, t, {
      isPinch: !!t.isPinch,
      targets: i.props.targets,
      events: s
    }));
  },
  dragGroupEnd: function(i, t) {
    this.dragEnd(i, t), mt(i, "onBeforeRenderGroupEnd", Ut(i, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      targets: i.props.targets
    }));
  },
  dragControlStart: function(i, t) {
    return this.dragStart(i, t);
  },
  dragControl: function(i, t) {
    return this.drag(i, t);
  },
  dragControlEnd: function(i, t) {
    return this.dragEnd(i, t);
  },
  dragGroupControlStart: function(i, t) {
    return this.dragGroupStart(i, t);
  },
  dragGroupControl: function(i, t) {
    return this.dragGroup(i, t);
  },
  dragGroupControlEnd: function(i, t) {
    return this.dragGroupEnd(i, t);
  }
}, YC = {
  name: "renderable",
  props: [],
  events: ["renderStart", "render", "renderEnd", "renderGroupStart", "renderGroup", "renderGroupEnd"],
  dragRelation: "weak",
  dragStart: function(i, t) {
    mt(i, "onRenderStart", Ut(i, t, {
      isPinch: !!t.isPinch
    }));
  },
  drag: function(i, t) {
    mt(i, "onRender", this.fillDragParams(i, t));
  },
  dragAfter: function(i, t) {
    return this.drag(i, t);
  },
  dragEnd: function(i, t) {
    mt(i, "onRenderEnd", this.fillDragEndParams(i, t));
  },
  dragGroupStart: function(i, t) {
    mt(i, "onRenderGroupStart", Ut(i, t, {
      isPinch: !!t.isPinch,
      targets: i.props.targets
    }));
  },
  dragGroup: function(i, t) {
    var e = this, r = Ji(i, "beforeRenderable", t), n = i.moveables, s = r.map(function(a, o) {
      var u = n[o];
      return e.fillDragParams(u, a);
    });
    mt(i, "onRenderGroup", Ut(i, t, F(F({
      isPinch: !!t.isPinch,
      targets: i.props.targets,
      transform: fp(t)
    }, Ir(dp(t))), {
      events: s
    })));
  },
  dragGroupEnd: function(i, t) {
    var e = this, r = Ji(i, "beforeRenderable", t), n = i.moveables, s = r.map(function(a, o) {
      var u = n[o];
      return e.fillDragEndParams(u, a);
    });
    mt(i, "onRenderGroupEnd", Ut(i, t, F({
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      targets: i.props.targets,
      events: s,
      transform: fp(t)
    }, Ir(dp(t)))));
  },
  dragControlStart: function(i, t) {
    return this.dragStart(i, t);
  },
  dragControl: function(i, t) {
    return this.drag(i, t);
  },
  dragControlAfter: function(i, t) {
    return this.dragAfter(i, t);
  },
  dragControlEnd: function(i, t) {
    return this.dragEnd(i, t);
  },
  dragGroupControlStart: function(i, t) {
    return this.dragGroupStart(i, t);
  },
  dragGroupControl: function(i, t) {
    return this.dragGroup(i, t);
  },
  dragGroupControlEnd: function(i, t) {
    return this.dragGroupEnd(i, t);
  },
  fillDragParams: function(i, t) {
    return Ut(i, t, F({
      isPinch: !!t.isPinch,
      transform: fp(t)
    }, Ir(dp(t))));
  },
  fillDragEndParams: function(i, t) {
    return Ut(i, t, F({
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      transform: fp(t)
    }, Ir(dp(t))));
  }
};
function Kh(i, t, e, r, n, s, a) {
  s.clientDistX = s.distX, s.clientDistY = s.distY;
  var o = n === "Start", u = n === "End", l = n === "After", h = i.state.target, d = s.isRequest;
  if (!h || o && r.indexOf("Control") > -1 && !d && i.areaElement === s.inputEvent.target)
    return !1;
  var f = Tt([], i[t], !0);
  if (d) {
    var p = s.requestAble;
    f.some(function(M) {
      return M.name === p;
    }) || f.push.apply(f, i.props.ables.filter(function(M) {
      return M.name === p;
    }));
  }
  if (!f.length || f.every(function(M) {
    return M.dragRelation;
  }))
    return !1;
  var v = s.inputEvent, g;
  u && v && (g = document.elementFromPoint(s.clientX, s.clientY) || v.target);
  var m = !1, y = function() {
    var M;
    m = !0, (M = s.stop) === null || M === void 0 || M.call(s);
  }, _ = o && (!i.targetGesto || !i.controlGesto || !i.targetGesto.isFlag() || !i.controlGesto.isFlag());
  _ && i.updateRect(n, !0, !1);
  var b = s.datas, w = function(M, I, R) {
    if (!(I in M))
      return !1;
    var N = M.name, A = b[N] || (b[N] = {});
    if (o && (A.isEventStart = !R || !M[R] || M[R](i, s)), !A.isEventStart)
      return !1;
    var G = M[I](i, F(F({}, s), {
      stop: y,
      datas: A,
      originalDatas: b,
      inputTarget: g
    }));
    return i._emitter.off(), o && G === !1 && (A.isEventStart = !1), G;
  };
  _ && f.forEach(function(M) {
    M.unset && M.unset(i);
  }), w(WC, "drag".concat(r).concat(n));
  var T = 0, x = 0;
  e.forEach(function(M) {
    if (m)
      return !1;
    var I = "".concat(M).concat(r).concat(n), R = "".concat(M).concat(r, "Condition");
    n === "" && !d && xC(i.state, s);
    var N = f.filter(function(B) {
      return B[I];
    });
    N = N.filter(function(B, U) {
      return B.name && N.indexOf(B) === U;
    });
    var A = N.filter(function(B) {
      return w(B, I, R);
    }), G = A.length;
    m && ++T, G && ++x, !m && o && N.length && !G && (T += N.filter(function(B) {
      var U = B.name, $ = b[U];
      return $.isEventStart ? B.dragRelation !== "strong" : !1;
    }).length ? 1 : 0);
  }), (!l || x) && w(YC, "drag".concat(r).concat(n));
  var S = T === e.length;
  if ((u || m || S) && (i.state.gestos = {}, i.moveables && i.moveables.forEach(function(M) {
    M.state.gestos = {};
  }), f.forEach(function(M) {
    M.unset && M.unset(i);
  })), o && !S && !d && x && i.props.preventDefault && (s == null || s.preventDefault()), i.isUnmounted || S)
    return !1;
  if (!o && x && !a || u) {
    var C = i.props.flushSync || lC;
    C(function() {
      i.updateRect(u ? n : "", !0, !1), i.forceUpdate();
    });
  }
  return !o && !u && !l && x && !a && Kh(i, t, e, r, n + "After", s), !0;
}
function k_(i) {
  return function(t) {
    var e = i.props.dragTarget, r = t.inputEvent.target, n = i.areaElement;
    return e && (r === e || e.contains(r)) || r === n || !i.isMoveableElement(r) && !i.controlBox.contains(r) || sr(r, "moveable-area") || sr(r, "moveable-padding") || sr(r, "moveable-edgeDraggable");
  };
}
function qC(i, t, e) {
  var r = i.controlBox, n = [], s = i.props.dragTarget;
  return n.push(r), (!i.props.dragArea || s) && n.push(t), Gx(i, n, "targetAbles", e, {
    dragStart: k_(i),
    pinchStart: k_(i)
  });
}
function Gx(i, t, e, r, n) {
  n === void 0 && (n = {});
  var s = e === "targetAbles", a = i.props, o = a.pinchOutside, u = a.pinchThreshold, l = a.preventClickEventOnDrag, h = a.preventClickDefault, d = a.checkInput, f = a.preventDefault, p = f === void 0 ? !0 : f, v = {
    preventDefault: p,
    preventRightClick: !0,
    preventWheelClick: !0,
    container: window,
    pinchThreshold: u,
    pinchOutside: o,
    preventClickEventOnDrag: s ? l : !1,
    preventClickEventOnDragStart: s ? h : !1,
    preventClickEventByCondition: s ? null : function(y) {
      return i.controlBox.contains(y.target);
    },
    checkInput: s ? d : !1
  }, g = new rB(t, v), m = r === "Control";
  return ["drag", "pinch"].forEach(function(y) {
    ["Start", "", "End"].forEach(function(_) {
      g.on("".concat(y).concat(_), function(b) {
        var w, T = b.eventType, x = y === "drag" && b.isPinch;
        if (n[T] && !n[T](b)) {
          b.stop();
          return;
        }
        if (!x) {
          var S = y === "drag" ? [y] : ["drag", y], C = Kh(i, e, S, r, _, b);
          C ? (i.props.stopPropagation || _ === "Start" && m) && ((w = b == null ? void 0 : b.inputEvent) === null || w === void 0 || w.stopPropagation()) : b.stop();
        }
      });
    });
  }), g;
}
var E3 = /* @__PURE__ */ function() {
  function i(e, r, n) {
    var s = this;
    this.target = e, this.moveable = r, this.eventName = n, this.ables = [], this._onEvent = function(a) {
      var o = s.eventName, u = s.moveable;
      u.state.disableNativeEvent || s.ables.forEach(function(l) {
        l[o](u, {
          inputEvent: a
        });
      });
    }, e.addEventListener(n.toLowerCase(), this._onEvent);
  }
  var t = i.prototype;
  return t.setAbles = function(e) {
    this.ables = e;
  }, t.destroy = function() {
    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent), this.target = null, this.moveable = null;
  }, i;
}();
function S3(i, t, e, r) {
  var n;
  e === void 0 && (e = t);
  var s = uC(i, t), a = s.matrixes, o = s.is3d, u = s.targetMatrix, l = s.transformOrigin, h = s.targetOrigin, d = s.offsetContainer, f = s.hasFixed, p = s.zoom, v = jB(d, e), g = v.matrixes, m = v.is3d, y = v.offsetContainer, _ = v.zoom, b = r || m || o, w = b ? 4 : 3, T = i.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in i, x = u, S = Oe(w), C = Oe(w), M = Oe(w), I = Oe(w), R = a.length, N = Tt([], g, !0).reverse();
  a.reverse(), !o && b && (x = An(x, 3, 4), T_(a)), !m && b && T_(N), N.forEach(function(H) {
    C = _e(C, H.matrix, w);
  });
  var A = e || document.body, G = ((n = N[0]) === null || n === void 0 ? void 0 : n.target) || gc(A, A, !0).offsetParent, B = N.slice(1).reduce(function(H, z) {
    return _e(H, z.matrix, w);
  }, Oe(w));
  a.forEach(function(H, z) {
    if (R - 2 === z && (M = S.slice()), R - 1 === z && (I = S.slice()), !H.matrix) {
      var X = a[z + 1], ct = KB(H, X, G, w, _e(B, S, w));
      H.matrix = vc(ct, w);
    }
    S = _e(S, H.matrix, w);
  });
  var U = !T && o;
  x || (x = Oe(U ? 4 : 3));
  var $ = p0(T && x.length === 16 ? An(x, 4, 3) : x, U), Z = C;
  return C = FT(C, w, w), {
    hasZoom: p !== 1 || _ !== 1,
    hasFixed: f,
    rootMatrix: C,
    originalRootMatrix: Z,
    beforeMatrix: M,
    offsetMatrix: I,
    allMatrix: S,
    targetMatrix: x,
    targetTransform: $,
    transformOrigin: l,
    targetOrigin: h,
    is3d: b,
    offsetContainer: d,
    offsetRootContainer: y
  };
}
function T3(i, t, e, r) {
  e === void 0 && (e = t);
  var n = 0, s = 0, a = 0, o = {}, u = dC(i);
  if (i && (n = u.offsetWidth, s = u.offsetHeight), i) {
    var l = S3(i, t, e, r), h = Fu(l.allMatrix, l.transformOrigin, n, s);
    o = F(F({}, l), h);
    var d = Fu(l.allMatrix, [50, 50], 100, 100);
    a = pC([d.pos1, d.pos2], d.direction);
  }
  var f = r ? 4 : 3;
  return F(F(F({
    hasZoom: !1,
    width: n,
    height: s,
    rotation: a
  }, u), {
    originalRootMatrix: Oe(f),
    rootMatrix: Oe(f),
    beforeMatrix: Oe(f),
    offsetMatrix: Oe(f),
    allMatrix: Oe(f),
    targetMatrix: Oe(f),
    targetTransform: "",
    transformOrigin: [0, 0],
    targetOrigin: [0, 0],
    is3d: !!r,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    origin: [0, 0],
    pos1: [0, 0],
    pos2: [0, 0],
    pos3: [0, 0],
    pos4: [0, 0],
    direction: 1,
    hasFixed: !1,
    offsetContainer: null,
    offsetRootContainer: null
  }), o);
}
function N_(i, t, e, r, n, s) {
  s === void 0 && (s = []);
  var a = 1, o = [0, 0], u = pp(), l = pp(), h = pp(), d = pp(), f = [0, 0], p = {}, v = T3(t, e, n, !0);
  if (t) {
    var g = oi(t);
    s.forEach(function(N) {
      p[N] = g(N);
    });
    var m = v.is3d ? 4 : 3, y = Fu(v.offsetMatrix, Jt(v.transformOrigin, GT(v.targetMatrix, m)), v.width, v.height);
    a = y.direction, o = Jt(y.origin, [y.left - v.left, y.top - v.top]), d = Zh(v.offsetRootContainer);
    var _ = gc(r, r, !0).offsetParent || v.offsetRootContainer;
    if (v.hasZoom) {
      var b = Fu(_e(v.originalRootMatrix, v.allMatrix), v.transformOrigin, v.width, v.height), w = Fu(v.originalRootMatrix, Tv(oi(_)("transformOrigin")).map(function(N) {
        return parseFloat(N);
      }), _.offsetWidth, _.offsetHeight);
      if (u = oy(b, d), h = oy(w, d, _, !0), i) {
        var T = b.left, x = b.top;
        l = oy({
          left: T,
          top: x,
          bottom: x,
          right: x
        }, d);
      }
    } else {
      u = Zh(t), h = UB(_), i && (l = Zh(i));
      var S = h.left, C = h.top, M = h.clientLeft, I = h.clientTop, R = [u.left - S, u.top - C];
      f = Mt(rh(v.rootMatrix, R, 4), [M + v.left, I + v.top]);
    }
  }
  return F({
    targetClientRect: u,
    containerClientRect: h,
    moveableClientRect: l,
    rootContainerClientRect: d,
    beforeDirection: a,
    beforeOrigin: o,
    originalBeforeOrigin: o,
    target: t,
    style: p,
    offsetDelta: f
  }, v);
}
function Yw(i) {
  var t = i.pos1, e = i.pos2, r = i.pos3, n = i.pos4;
  if (!t || !e || !r || !n)
    return null;
  var s = eu([t, e, r, n]), a = [s.minX, s.minY], o = Mt(i.origin, a);
  return t = Mt(t, a), e = Mt(e, a), r = Mt(r, a), n = Mt(n, a), F(F({}, i), {
    left: i.left,
    top: i.top,
    posDelta: a,
    pos1: t,
    pos2: e,
    pos3: r,
    pos4: n,
    origin: o,
    beforeOrigin: o,
    // originalBeforeOrigin: origin,
    isPersisted: !0
  });
}
var ih = /* @__PURE__ */ function(i) {
  Md(t, i);
  function t() {
    var r = i !== null && i.apply(this, arguments) || this;
    return r.state = F({
      container: null,
      gestos: {},
      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],
      disableNativeEvent: !1,
      posDelta: [0, 0]
    }, N_(null)), r.renderState = {}, r.enabledAbles = [], r.targetAbles = [], r.controlAbles = [], r.rotation = 0, r.scale = [1, 1], r.isMoveableMounted = !1, r.isUnmounted = !1, r.events = {
      mouseEnter: null,
      mouseLeave: null
    }, r._emitter = new l0(), r._prevTarget = null, r._prevDragArea = !1, r._isPropTargetChanged = !1, r._hasFirstTarget = !1, r._reiszeObserver = null, r._observerId = 0, r._mutationObserver = null, r._rootContainer = null, r._viewContainer = null, r._viewClassNames = [], r._store = {}, r.checkUpdateRect = function() {
      if (!r.isDragging()) {
        var n = r.props.parentMoveable;
        if (n) {
          n.checkUpdateRect();
          return;
        }
        HA(r._observerId), r._observerId = vT(function() {
          r.isDragging() || r.updateRect();
        });
      }
    }, r._onPreventClick = function(n) {
      n.stopPropagation(), n.preventDefault();
    }, r;
  }
  var e = t.prototype;
  return e.render = function() {
    var r = this.props, n = this.getState(), s = r.parentPosition, a = r.className, o = r.target, u = r.zoom, l = r.cspNonce, h = r.translateZ, d = r.cssStyled, f = r.groupable, p = r.linePadding, v = r.controlPadding;
    this._checkUpdateRootContainer(), this.checkUpdate(), this.updateRenderPoses();
    var g = s || [0, 0], m = g[0], y = g[1], _ = n.left, b = n.top, w = n.target, T = n.direction, x = n.hasFixed, S = n.offsetDelta, C = r.targets, M = this.isDragging(), I = {};
    this.getEnabledAbles().forEach(function(U) {
      I["data-able-".concat(U.name.toLowerCase())] = !0;
    });
    var R = this._getAbleClassName(), N = C && C.length && (w || f) || o || !this._hasFirstTarget && this.state.isPersisted, A = this.controlBox || this.props.firstRenderState || this.props.persistData, G = [_ - m, b - y];
    !f && r.useAccuratePosition && (G[0] += S[0], G[1] += S[1]);
    var B = {
      position: x ? "fixed" : "absolute",
      display: N ? "block" : "none",
      visibility: A ? "visible" : "hidden",
      transform: "translate3d(".concat(G[0], "px, ").concat(G[1], "px, ").concat(h, ")"),
      "--zoom": u,
      "--zoompx": "".concat(u, "px")
    };
    return p && (B["--moveable-line-padding"] = p), v && (B["--moveable-control-padding"] = v), Ki(d, F({
      cspNonce: l,
      ref: Es(this, "controlBox"),
      className: "".concat(Pt("control-box", T === -1 ? "reverse" : "", M ? "dragging" : ""), " ").concat(R, " ").concat(a)
    }, I, {
      onClick: this._onPreventClick,
      style: B
    }), this.renderAbles(), this._renderLines());
  }, e.componentDidMount = function() {
    this.isMoveableMounted = !0, this.isUnmounted = !1;
    var r = this.props, n = r.parentMoveable, s = r.container, a = r.wrapperMoveable;
    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(this.props), !s && !n && !a && !this.state.isPersisted && (this.updateRect("", !1, !1), this.forceUpdate());
  }, e.componentDidUpdate = function(r) {
    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateNativeEvents(), this._updateEvents(), this._updateTargets(), this.updateCheckInput(), this._updateObserver(r);
  }, e.componentWillUnmount = function() {
    var r, n;
    this.isMoveableMounted = !1, this.isUnmounted = !0, this._emitter.off(), (r = this._reiszeObserver) === null || r === void 0 || r.disconnect(), (n = this._mutationObserver) === null || n === void 0 || n.disconnect();
    var s = this._viewContainer;
    s && this._changeAbleViewClassNames([]), Du(this, "targetGesto"), Du(this, "controlGesto");
    var a = this.events;
    for (var o in a) {
      var u = a[o];
      u && u.destroy();
    }
  }, e.getTargets = function() {
    var r = this.props.target;
    return r ? [r] : [];
  }, e.getAble = function(r) {
    var n = this.props.ables || [];
    return nn(n, function(s) {
      return s.name === r;
    });
  }, e.getContainer = function() {
    var r = this.props, n = r.parentMoveable, s = r.wrapperMoveable, a = r.container;
    return a || s && s.getContainer() || n && n.getContainer() || this.controlBox.parentElement;
  }, e.isMoveableElement = function(r) {
    var n;
    return r && (((n = r.getAttribute) === null || n === void 0 ? void 0 : n.call(r, "class")) || "").indexOf(bx) > -1;
  }, e.dragStart = function(r) {
    var n = this.targetGesto, s = this.controlGesto;
    return n && k_(this)({
      inputEvent: r
    }) ? n.isFlag() || n.triggerDragStart(r) : s && this.isMoveableElement(r.target) && (s.isFlag() || s.triggerDragStart(r)), this;
  }, e.hitTest = function(r) {
    var n = this.state, s = n.target, a = n.pos1, o = n.pos2, u = n.pos3, l = n.pos4, h = n.targetClientRect;
    if (!s)
      return 0;
    var d;
    if (r instanceof Element) {
      var f = r.getBoundingClientRect();
      d = {
        left: f.left,
        top: f.top,
        width: f.width,
        height: f.height
      };
    } else
      d = F({
        width: 0,
        height: 0
      }, r);
    var p = d.left, v = d.top, g = d.width, m = d.height, y = _w([a, o, l, u], h), _ = ZL(y, [[p, v], [p + g, v], [p + g, v + m], [p, v + m]]), b = HT(y);
    return !_ || !b ? 0 : Math.min(100, _ / b * 100);
  }, e.isInside = function(r, n) {
    var s = this.state, a = s.target, o = s.pos1, u = s.pos2, l = s.pos3, h = s.pos4, d = s.targetClientRect;
    return a ? m_([r, n], _w([o, u, h, l], d)) : !1;
  }, e.updateRect = function(r, n, s) {
    s === void 0 && (s = !0);
    var a = this.props, o = !a.parentPosition && !a.wrapperMoveable;
    o && th(!0);
    var u = a.parentMoveable, l = this.state, h = l.target || a.target, d = this.getContainer(), f = u ? u._rootContainer : this._rootContainer, p = N_(this.controlBox, h, d, d, f || d, this._getRequestStyles());
    if (!h && this._hasFirstTarget && a.persistData) {
      var v = Yw(a.persistData);
      for (var g in v)
        p[g] = v[g];
    }
    o && th(), this.updateState(p, u ? !1 : s);
  }, e.isDragging = function(r) {
    var n, s, a = this.targetGesto, o = this.controlGesto;
    if (a != null && a.isFlag()) {
      if (!r)
        return !0;
      var u = a.getEventData();
      return !!(!((n = u[r]) === null || n === void 0) && n.isEventStart);
    }
    if (o != null && o.isFlag()) {
      if (!r)
        return !0;
      var u = o.getEventData();
      return !!(!((s = u[r]) === null || s === void 0) && s.isEventStart);
    }
    return !1;
  }, e.updateTarget = function(r) {
    this.updateRect(r, !0);
  }, e.getRect = function() {
    var r = this.state, n = Ti(this.state), s = n[0], a = n[1], o = n[2], u = n[3], l = Si(n), h = r.width, d = r.height, f = l.width, p = l.height, v = l.left, g = l.top, m = [r.left, r.top], y = Jt(m, r.origin), _ = Jt(m, r.beforeOrigin), b = r.transformOrigin;
    return {
      width: f,
      height: p,
      left: v,
      top: g,
      pos1: s,
      pos2: a,
      pos3: o,
      pos4: u,
      offsetWidth: h,
      offsetHeight: d,
      beforeOrigin: _,
      origin: y,
      transformOrigin: b,
      rotation: this.getRotation()
    };
  }, e.getManager = function() {
    return this;
  }, e.stopDrag = function(r) {
    var n, s;
    (!r || r === "target") && ((n = this.targetGesto) === null || n === void 0 || n.stop()), (!r || r === "control") && ((s = this.controlGesto) === null || s === void 0 || s.stop());
  }, e.getRotation = function() {
    var r = this.state, n = r.pos1, s = r.pos2, a = r.direction;
    return iF(n, s, a);
  }, e.request = function(r, n, s) {
    n === void 0 && (n = {});
    var a = this.props, o = a.ables, u = a.groupable, l = o.filter(function(m) {
      return m.name === r;
    })[0];
    if (this.isDragging() || !l || !l.request)
      return {
        request: function() {
          return this;
        },
        requestEnd: function() {
          return this;
        }
      };
    var h = this, d = l.request(this), f = s || n.isInstant, p = d.isControl ? "controlAbles" : "targetAbles", v = "".concat(u ? "Group" : "").concat(d.isControl ? "Control" : ""), g = {
      request: function(m) {
        return Kh(h, p, ["drag"], v, "", F(F({}, d.request(m)), {
          requestAble: r,
          isRequest: !0
        }), f), this;
      },
      requestEnd: function() {
        return Kh(h, p, ["drag"], v, "End", F(F({}, d.requestEnd()), {
          requestAble: r,
          isRequest: !0
        }), f), this;
      }
    };
    return Kh(h, p, ["drag"], v, "Start", F(F({}, d.requestStart(n)), {
      requestAble: r,
      isRequest: !0
    }), f), f ? g.request(n).requestEnd() : g;
  }, e.destroy = function() {
    this.componentWillUnmount();
  }, e.updateRenderPoses = function() {
    var r = this.getState(), n = this.props, s = r.originalBeforeOrigin, a = r.transformOrigin, o = r.allMatrix, u = r.is3d, l = r.pos1, h = r.pos2, d = r.pos3, f = r.pos4, p = r.left, v = r.top, g = r.isPersisted, m = n.padding || {}, y = m.left, _ = y === void 0 ? 0 : y, b = m.top, w = b === void 0 ? 0 : b, T = m.bottom, x = T === void 0 ? 0 : T, S = m.right, C = S === void 0 ? 0 : S, M = u ? 4 : 3, I = [];
    g ? I = a : this.controlBox && n.groupable ? I = s : I = Jt(s, [p, v]), r.renderPoses = [Jt(l, gp(o, [-_, -w], a, I, M)), Jt(h, gp(o, [C, -w], a, I, M)), Jt(d, gp(o, [-_, x], a, I, M)), Jt(f, gp(o, [C, x], a, I, M))];
  }, e.checkUpdate = function() {
    this._isPropTargetChanged = !1;
    var r = this.props, n = r.target, s = r.container, a = r.parentMoveable, o = this.state, u = o.target, l = o.container;
    if (!(!u && !n)) {
      this.updateAbles();
      var h = !C_(u, n), d = h || !C_(l, s);
      if (d) {
        var f = s || this.controlBox;
        f && this.unsetAbles(), this.updateState({
          target: n,
          container: s
        }), !a && f && this.updateRect("End", !1, !1), this._isPropTargetChanged = h;
      }
    }
  }, e.waitToChangeTarget = function() {
    return new Promise(function() {
    });
  }, e.triggerEvent = function(r, n) {
    this._emitter.trigger(r, n);
    var s = this.props[r];
    return s && s(n);
  }, e.useCSS = function(r, n) {
    var s = this.props.customStyledMap, a = r + n;
    return s[a] || (s[a] = XT(r, n)), s[a];
  }, e.getState = function() {
    var r, n = this.props;
    (n.target || !((r = n.targets) === null || r === void 0) && r.length) && (this._hasFirstTarget = !0);
    var s = this.controlBox, a = n.persistData, o = n.firstRenderState;
    if (o && !s)
      return o;
    if (!this._hasFirstTarget && a) {
      var u = Yw(a);
      if (u)
        return this.updateState(u, !1), this.state;
    }
    return this.state.isPersisted = !1, this.state;
  }, e.updateSelectors = function() {
  }, e.unsetAbles = function() {
    var r = this;
    this.targetAbles.forEach(function(n) {
      n.unset && n.unset(r);
    });
  }, e.updateAbles = function(r, n) {
    r === void 0 && (r = this.props.ables), n === void 0 && (n = "");
    var s = this.props, a = s.triggerAblesSimultaneously, o = this.getEnabledAbles(r), u = "drag".concat(n, "Start"), l = "pinch".concat(n, "Start"), h = "drag".concat(n, "ControlStart"), d = vp(o, [u, l], a), f = vp(o, [h], a);
    this.enabledAbles = o, this.targetAbles = d, this.controlAbles = f;
  }, e.updateState = function(r, n) {
    if (n) {
      if (this.isUnmounted)
        return;
      this.setState(r);
    } else {
      var s = this.state;
      for (var a in r)
        s[a] = r[a];
    }
  }, e.getEnabledAbles = function(r) {
    r === void 0 && (r = this.props.ables);
    var n = this.props;
    return r.filter(function(s) {
      return s && (s.always && n[s.name] !== !1 || n[s.name]);
    });
  }, e.renderAbles = function() {
    var r = this, n = this.props, s = n.triggerAblesSimultaneously, a = {
      createElement: Ki
    };
    return this.renderState = {}, tF(bC(vp(this.getEnabledAbles(), ["render"], s).map(function(o) {
      var u = o.render;
      return u(r, a) || [];
    })).filter(function(o) {
      return o;
    }), function(o) {
      var u = o.key;
      return u;
    }).map(function(o) {
      return o[0];
    });
  }, e.updateCheckInput = function() {
    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);
  }, e._getRequestStyles = function() {
    var r = this.getEnabledAbles().reduce(function(n, s) {
      var a, o, u = (o = (a = s.requestStyle) === null || a === void 0 ? void 0 : a.call(s)) !== null && o !== void 0 ? o : [];
      return Tt(Tt([], n, !0), u, !0);
    }, Tt([], this.props.requestStyles || [], !0));
    return r;
  }, e._updateObserver = function(r) {
    this._updateResizeObserver(r), this._updateMutationObserver(r);
  }, e._updateEvents = function() {
    var r = this.controlBox, n = this.targetAbles.length, s = this.controlAbles.length, a = this.props, o = a.dragTarget || a.target, u = !n && this.targetGesto || this._isTargetChanged(!0);
    u && (Du(this, "targetGesto"), this.updateState({
      gesto: null
    })), s || Du(this, "controlGesto"), o && n && !this.targetGesto && (this.targetGesto = qC(this, o, "")), !this.controlGesto && s && (this.controlGesto = Gx(this, r, "controlAbles", "Control"));
  }, e._updateTargets = function() {
    var r = this.props;
    this._prevTarget = r.dragTarget || r.target, this._prevDragArea = r.dragArea;
  }, e._renderLines = function() {
    var r = this.props, n = r, s = n.zoom, a = n.hideDefaultLines, o = n.hideChildMoveableDefaultLines, u = n.parentMoveable;
    if (a || u && o)
      return [];
    var l = this.getState().renderPoses, h = {
      createElement: Ki
    };
    return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(d, f) {
      var p = d[0], v = d[1];
      return mc(h, "", l[p], l[v], s, "render-line-".concat(f));
    });
  }, e._isTargetChanged = function(r) {
    var n = this.props, s = n.dragTarget || n.target, a = this._prevTarget, o = this._prevDragArea, u = n.dragArea, l = !u && a !== s, h = (r || u) && o !== u;
    return l || h;
  }, e._updateNativeEvents = function() {
    var r = this, n = this.props, s = n.dragArea ? this.areaElement : this.state.target, a = this.events, o = Ps(a);
    if (this._isTargetChanged())
      for (var u in a) {
        var l = a[u];
        l && l.destroy(), a[u] = null;
      }
    if (s) {
      var h = this.enabledAbles;
      o.forEach(function(d) {
        var f = vp(h, [d]), p = f.length > 0, v = a[d];
        if (!p) {
          v && (v.destroy(), a[d] = null);
          return;
        }
        v || (v = new E3(s, r, d), a[d] = v), v.setAbles(f);
      });
    }
  }, e._checkUpdateRootContainer = function() {
    var r = this.props.rootContainer;
    !this._rootContainer && r && (this._rootContainer = iu(r, !0));
  }, e._checkUpdateViewContainer = function() {
    var r = this.props.viewContainer;
    !this._viewContainer && r && (this._viewContainer = iu(r, !0));
    var n = this._viewContainer;
    n && this._changeAbleViewClassNames(Tt(Tt([], this._getAbleViewClassNames(), !0), [this.isDragging() ? e3 : ""], !1));
  }, e._changeAbleViewClassNames = function(r) {
    var n = this._viewContainer, s = _C(r.filter(Boolean), function(h) {
      return h;
    }).map(function(h) {
      var d = h[0];
      return d;
    }), a = this._viewClassNames, o = wd(a, s), u = o.removed, l = o.added;
    u.forEach(function(h) {
      yT(n, a[h]);
    }), l.forEach(function(h) {
      mT(n, s[h]);
    }), this._viewClassNames = s;
  }, e._getAbleViewClassNames = function() {
    var r = this;
    return (this.getEnabledAbles().map(function(n) {
      var s;
      return ((s = n.viewClassName) === null || s === void 0 ? void 0 : s.call(n, r)) || "";
    }).join(" ") + " ".concat(this._getAbleClassName("-view"))).split(/\s+/g);
  }, e._getAbleClassName = function(r) {
    var n = this;
    r === void 0 && (r = "");
    var s = this.getEnabledAbles(), a = this.targetGesto, o = this.controlGesto, u = a != null && a.isFlag() ? a.getEventData() : {}, l = o != null && o.isFlag() ? o.getEventData() : {};
    return s.map(function(h) {
      var d, f, p, v = h.name, g = ((d = h.className) === null || d === void 0 ? void 0 : d.call(h, n)) || "";
      return (!((f = u[v]) === null || f === void 0) && f.isEventStart || !((p = l[v]) === null || p === void 0) && p.isEventStart) && (g += " ".concat(Pt("".concat(v).concat(r, "-dragging")))), g.trim();
    }).filter(Boolean).join(" ");
  }, e._updateResizeObserver = function(r) {
    var n, s = this.props, a = s.target;
    if (!window.ResizeObserver || !a || !s.useResizeObserver) {
      (n = this._reiszeObserver) === null || n === void 0 || n.disconnect();
      return;
    }
    if (!(r.target === a && this._reiszeObserver)) {
      var o = new ResizeObserver(this.checkUpdateRect);
      o.observe(a, {
        box: "border-box"
      }), this._reiszeObserver = o;
    }
  }, e._updateMutationObserver = function(r) {
    var n = this, s, a = this.props, o = a.target;
    if (!window.MutationObserver || !o || !a.useMutationObserver) {
      (s = this._mutationObserver) === null || s === void 0 || s.disconnect();
      return;
    }
    if (!(r.target === o && this._mutationObserver)) {
      var u = new MutationObserver(function(l) {
        for (var h = 0, d = l; h < d.length; h++) {
          var f = d[h];
          f.type === "attributes" && f.attributeName === "style" && n.checkUpdateRect();
        }
      });
      u.observe(o, {
        attributes: !0
      }), this._mutationObserver = u;
    }
  }, t.defaultProps = {
    target: null,
    dragTarget: null,
    container: null,
    rootContainer: null,
    origin: !0,
    parentMoveable: null,
    wrapperMoveable: null,
    isWrapperMounted: !1,
    parentPosition: null,
    warpSelf: !1,
    useResizeObserver: !1,
    useMutationObserver: !1,
    preventDefault: !0,
    linePadding: 0,
    controlPadding: 0,
    ables: [],
    pinchThreshold: 20,
    dragArea: !1,
    passDragArea: !1,
    transformOrigin: "",
    className: "",
    zoom: 1,
    triggerAblesSimultaneously: !1,
    padding: {},
    pinchOutside: !0,
    checkInput: !1,
    groupable: !1,
    hideDefaultLines: !1,
    cspNonce: "",
    translateZ: 0,
    cssStyled: null,
    customStyledMap: {},
    props: {},
    stopPropagation: !1,
    preventClickDefault: !1,
    preventClickEventOnDrag: !0,
    flushSync: lC,
    firstRenderState: null,
    persistData: null,
    viewContainer: null,
    requestStyles: [],
    useAccuratePosition: !1
  }, t;
}(TT), Ux = {
  name: "groupable",
  props: ["defaultGroupRotate", "defaultGroupOrigin", "groupable", "groupableProps", "targetGroups", "hideChildMoveableDefaultLines"],
  events: [],
  render: function(i, t) {
    var e, r = i.props, n = r.targets || [], s = i.getState(), a = s.left, o = s.top, u = s.isPersisted, l = r.zoom || 1, h = i.renderGroupRects, d = ((e = r.persistData) === null || e === void 0 ? void 0 : e.children) || [];
    u ? n = d.map(function() {
      return null;
    }) : d = [];
    var f = i._store, p = Tw(f, "parentPosition", [a, o], function(g) {
      return g.join(",");
    }), v = Tw(f, "requestStyles", i.getRequestChildStyles(), function(g) {
      return g.join(",");
    });
    return i.moveables = i.moveables.slice(0, n.length), Tt(Tt([], n.map(function(g, m) {
      return t.createElement(ih, {
        key: "moveable" + m,
        ref: hT(i, "moveables", m),
        target: g,
        origin: !1,
        requestStyles: v,
        cssStyled: r.cssStyled,
        customStyledMap: r.customStyledMap,
        useResizeObserver: r.useResizeObserver,
        hideChildMoveableDefaultLines: r.hideChildMoveableDefaultLines,
        parentMoveable: i,
        parentPosition: [a, o],
        persistData: d[m],
        zoom: l
      });
    }), !0), bC(h.map(function(g, m) {
      var y = g.pos1, _ = g.pos2, b = g.pos3, w = g.pos4, T = [y, _, b, w];
      return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(x, S) {
        var C = x[0], M = x[1];
        return mc(t, "", Mt(T[C], p), Mt(T[M], p), l, "group-rect-".concat(m, "-").concat(S));
      });
    })), !0);
  }
}, C3 = Pd("clickable", {
  props: ["clickable"],
  events: ["click", "clickGroup"],
  always: !0,
  dragRelation: "weak",
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  dragStart: function() {
  },
  dragControlStart: function() {
  },
  dragGroupStart: function(i, t) {
    t.datas.inputTarget = t.inputEvent && t.inputEvent.target;
  },
  dragEnd: function(i, t) {
    var e = i.props.target, r = t.inputEvent, n = t.inputTarget, s = i.isMoveableElement(n), a = !s && i.controlBox.contains(n);
    if (!(!r || !n || t.isDrag || i.isMoveableElement(n) || a)) {
      var o = e.contains(n);
      mt(i, "onClick", Ut(i, t, {
        isDouble: t.isDouble,
        inputTarget: n,
        isTarget: e === n,
        moveableTarget: i.props.target,
        containsTarget: o
      }));
    }
  },
  dragGroupEnd: function(i, t) {
    var e = t.inputEvent, r = t.inputTarget;
    if (!(!e || !r || t.isDrag || i.isMoveableElement(r) || t.datas.inputTarget === r)) {
      var n = i.props.targets, s = n.indexOf(r), a = s > -1, o = !1;
      s === -1 && (s = Ms(n, function(u) {
        return u.contains(r);
      }), o = s > -1), mt(i, "onClickGroup", Ut(i, t, {
        isDouble: t.isDouble,
        targets: n,
        inputTarget: r,
        targetIndex: s,
        isTarget: a,
        containsTarget: o,
        moveableTarget: n[s]
      }));
    }
  },
  dragControlEnd: function(i, t) {
    this.dragEnd(i, t);
  },
  dragGroupControlEnd: function(i, t) {
    this.dragEnd(i, t);
  }
});
function mu(i) {
  var t = i.originalDatas.draggable;
  return t || (i.originalDatas.draggable = {}, t = i.originalDatas.draggable), F(F({}, i), {
    datas: t
  });
}
var M3 = Pd("edgeDraggable", {
  css: [`.edge.edgeDraggable.line {
cursor: move;
}`],
  render: function(i, t) {
    var e = i.props, r = e.edgeDraggable;
    return r ? LC(t, "edgeDraggable", r, i.getState().renderPoses, e.zoom) : [];
  },
  dragCondition: function(i, t) {
    var e, r = i.props, n = (e = t.inputEvent) === null || e === void 0 ? void 0 : e.target;
    return !r.edgeDraggable || !n ? !1 : !r.draggable && sr(n, Pt("direction")) && sr(n, Pt("edge")) && sr(n, Pt("edgeDraggable"));
  },
  dragStart: function(i, t) {
    return Or.dragStart(i, mu(t));
  },
  drag: function(i, t) {
    return Or.drag(i, mu(t));
  },
  dragEnd: function(i, t) {
    return Or.dragEnd(i, mu(t));
  },
  dragGroupCondition: function(i, t) {
    var e, r = i.props, n = (e = t.inputEvent) === null || e === void 0 ? void 0 : e.target;
    return !r.edgeDraggable || !n ? !1 : !r.draggable && sr(n, Pt("direction")) && sr(n, Pt("line"));
  },
  dragGroupStart: function(i, t) {
    return Or.dragGroupStart(i, mu(t));
  },
  dragGroup: function(i, t) {
    return Or.dragGroup(i, mu(t));
  },
  dragGroupEnd: function(i, t) {
    return Or.dragGroupEnd(i, mu(t));
  },
  unset: function(i) {
    return Or.unset(i);
  }
}), ZC = {
  name: "individualGroupable",
  props: ["individualGroupable", "individualGroupableProps"],
  events: []
}, jx = [WC, HC, WF, aF, Or, M3, R_, KF, QF, ZF, n3, s3, r3, m3, g3, x3, Ux, ZC, C3, zC, YC], P3 = /* @__PURE__ */ jx.reduce(function(i, t) {
  return (t.events || []).forEach(function(e) {
    gT(i, e);
  }), i;
}, []), O3 = /* @__PURE__ */ jx.reduce(function(i, t) {
  return (t.props || []).forEach(function(e) {
    gT(i, e);
  }), i;
}, []);
function qw(i, t) {
  var e = i[0], r = i[1], n = i[2];
  return (e * t[0] + r * t[1] + n) / Math.sqrt(e * e + r * r);
}
function bp(i, t) {
  var e = i[0], r = i[1];
  return -e * t[0] - r * t[1];
}
function Zw(i, t) {
  return Math.max.apply(Math, i.map(function(e) {
    var r = e[0], n = e[1], s = e[2], a = e[3];
    return Math.max(r[t], n[t], s[t], a[t]);
  }));
}
function Kw(i, t) {
  return Math.min.apply(Math, i.map(function(e) {
    var r = e[0], n = e[1], s = e[2], a = e[3];
    return Math.min(r[t], n[t], s[t], a[t]);
  }));
}
function I3(i, t) {
  var e, r = [0, 0], n = [0, 0], s = [0, 0], a = [0, 0], o = 0, u = 0;
  if (!i.length)
    return {
      pos1: r,
      pos2: n,
      pos3: s,
      pos4: a,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: o,
      height: u,
      rotation: t
    };
  var l = Gt(t, Rr);
  if (l % 90) {
    var h = l / 180 * Math.PI, d = Math.tan(h), f = -1 / d, p = [E_, ww], v = [[0, 0], [0, 0]], g = [E_, ww], m = [[0, 0], [0, 0]];
    i.forEach(function(H) {
      H.forEach(function(z) {
        var X = qw([-d, 1, 0], z), ct = qw([-f, 1, 0], z);
        p[0] > X && (v[0] = z, p[0] = X), p[1] < X && (v[1] = z, p[1] = X), g[0] > ct && (m[0] = z, g[0] = ct), g[1] < ct && (m[1] = z, g[1] = ct);
      });
    });
    var y = v[0], _ = v[1], b = m[0], w = m[1], T = [-d, 1, bp([-d, 1], y)], x = [-d, 1, bp([-d, 1], _)], S = [-f, 1, bp([-f, 1], b)], C = [-f, 1, bp([-f, 1], w)];
    e = [[T, S], [T, C], [x, S], [x, C]].map(function(H) {
      var z = H[0], X = H[1];
      return yx(z, X)[0];
    }), r = e[0], n = e[1], s = e[2], a = e[3], o = g[1] - g[0], u = p[1] - p[0];
  } else {
    var M = Kw(i, 0), I = Kw(i, 1), R = Zw(i, 0), N = Zw(i, 1);
    if (r = [M, I], n = [R, I], s = [M, N], a = [R, N], o = R - M, u = N - I, l % 180) {
      var A = [s, r, a, n];
      r = A[0], n = A[1], s = A[2], a = A[3], o = N - I, u = R - M;
    }
  }
  if (l % 360 > 180) {
    var A = [a, s, n, r];
    r = A[0], n = A[1], s = A[2], a = A[3];
  }
  var G = eu([r, n, s, a]), B = G.minX, U = G.minY, $ = G.maxX, Z = G.maxY;
  return {
    pos1: r,
    pos2: n,
    pos3: s,
    pos4: a,
    width: o,
    height: u,
    minX: B,
    minY: U,
    maxX: $,
    maxY: Z,
    rotation: t
  };
}
function KC(i, t) {
  var e = t.map(function(r) {
    if (tr(r)) {
      var n = KC(i, r), s = n.length;
      return s > 1 ? n : s === 1 ? n[0] : null;
    } else {
      var a = nn(i, function(o) {
        var u = o.manager;
        return u.props.target === r;
      });
      return a ? (a.finded = !0, a.manager) : null;
    }
  }).filter(Boolean);
  return e.length === 1 && tr(e[0]) ? e[0] : e;
}
var R3 = /* @__PURE__ */ function(i) {
  Md(t, i);
  function t() {
    var r = i !== null && i.apply(this, arguments) || this;
    return r.differ = new zT(), r.moveables = [], r.transformOrigin = "50% 50%", r.renderGroupRects = [], r._targetGroups = [], r._hasFirstTargets = !1, r;
  }
  var e = t.prototype;
  return e.componentDidMount = function() {
    i.prototype.componentDidMount.call(this);
  }, e.checkUpdate = function() {
    this._isPropTargetChanged = !1, this.updateAbles();
  }, e.getTargets = function() {
    return this.props.targets;
  }, e.updateRect = function(r, n, s) {
    var a;
    s === void 0 && (s = !0);
    var o = this.state;
    if (!this.controlBox || o.isPersisted)
      return;
    th(!0), this.moveables.forEach(function(Q) {
      Q.updateRect(r, !1, !1);
    });
    var u = this.props, l = this.moveables, h = o.target || u.target, d = l.map(function(Q) {
      return {
        finded: !1,
        manager: Q
      };
    }), f = this.props.targetGroups || [], p = KC(d, f);
    p.push.apply(p, d.filter(function(Q) {
      var St = Q.finded;
      return !St;
    }).map(function(Q) {
      var St = Q.manager;
      return St;
    }));
    var v = [], g = !n || r !== "" && u.updateGroup, m = u.defaultGroupRotate || 0;
    if (!this._hasFirstTargets) {
      var y = (a = this.props.persistData) === null || a === void 0 ? void 0 : a.rotation;
      y != null && (m = y);
    }
    function _(Q, St, at) {
      var q = Q.map(function(xt) {
        if (tr(xt)) {
          var Dt = _(xt, St), Ct = [Dt.pos1, Dt.pos2, Dt.pos3, Dt.pos4];
          return v.push(Dt), {
            poses: Ct,
            rotation: Dt.rotation
          };
        } else
          return {
            poses: Ti(xt.state),
            rotation: xt.getRotation()
          };
      }), bt = q.map(function(xt) {
        var Dt = xt.rotation;
        return Dt;
      }), st = 0, W = bt[0], nt = bt.every(function(xt) {
        return Math.abs(W - xt) < 0.1;
      });
      g ? st = nt ? W : m : st = !at && nt ? W : St;
      var dt = q.map(function(xt) {
        var Dt = xt.poses;
        return Dt;
      }), V = I3(dt, st);
      return V;
    }
    var b = _(p, this.rotation, !0);
    g && (this.rotation = b.rotation, this.transformOrigin = u.defaultGroupOrigin || "50% 50%", this.scale = [1, 1]), this._targetGroups = f, this.renderGroupRects = v;
    var w = this.transformOrigin, T = this.rotation, x = this.scale, S = b.width, C = b.height, M = b.minX, I = b.minY, R = sF([[0, 0], [S, 0], [0, C], [S, C]], nF(w, S, C), this.rotation / 180 * Math.PI), N = eu(R.result), A = N.minX, G = N.minY, B = " rotate(".concat(T, "deg)") + " scale(".concat(x[0] >= 0 ? 1 : -1, ", ").concat(x[1] >= 0 ? 1 : -1, ")"), U = "translate(".concat(-A, "px, ").concat(-G, "px)").concat(B);
    this.controlBox.style.transform = "translate3d(".concat(M, "px, ").concat(I, "px, ").concat(this.props.translateZ || 0, ")"), h.style.cssText += "left:0px;top:0px;" + "transform-origin:".concat(w, ";") + "width:".concat(S, "px;height:").concat(C, "px;") + "transform: ".concat(U), o.width = S, o.height = C;
    var $ = this.getContainer(), Z = N_(this.controlBox, h, this.controlBox, this.getContainer(), this._rootContainer || $, []), H = [Z.left, Z.top], z = Ti(Z), X = z[0], ct = z[1], it = z[2], lt = z[3], et = eu([X, ct, it, lt]), k = [et.minX, et.minY], ft = x[0] * x[1] > 0 ? 1 : -1;
    Z.pos1 = Mt(X, k), Z.pos2 = Mt(ct, k), Z.pos3 = Mt(it, k), Z.pos4 = Mt(lt, k), Z.left = M - Z.left + k[0], Z.top = I - Z.top + k[1], Z.origin = Mt(Jt(H, Z.origin), k), Z.beforeOrigin = Mt(Jt(H, Z.beforeOrigin), k), Z.originalBeforeOrigin = Jt(H, Z.originalBeforeOrigin), Z.transformOrigin = Mt(Jt(H, Z.transformOrigin), k), h.style.transform = "translate(".concat(-A - k[0], "px, ").concat(-G - k[1], "px)") + B, th(), this.updateState(F(F({}, Z), {
      posDelta: k,
      direction: ft,
      beforeDirection: ft
    }), s);
  }, e.getRect = function() {
    return F(F({}, i.prototype.getRect.call(this)), {
      children: this.moveables.map(function(r) {
        return r.getRect();
      })
    });
  }, e.triggerEvent = function(r, n, s) {
    if (s || r.indexOf("Group") > -1)
      return i.prototype.triggerEvent.call(this, r, n);
    this._emitter.trigger(r, n);
  }, e.getRequestChildStyles = function() {
    var r = this.getEnabledAbles().reduce(function(n, s) {
      var a, o, u = (o = (a = s.requestChildStyle) === null || a === void 0 ? void 0 : a.call(s)) !== null && o !== void 0 ? o : [];
      return Tt(Tt([], n, !0), u, !0);
    }, []);
    return r;
  }, e.updateAbles = function() {
    i.prototype.updateAbles.call(this, Tt(Tt([], this.props.ables, !0), [Ux], !1), "Group");
  }, e._updateTargets = function() {
    i.prototype._updateTargets.call(this), this._prevTarget = this.props.dragTarget || this.areaElement;
  }, e._updateEvents = function() {
    var r = this.state, n = this.props, s = this._prevTarget, a = n.dragTarget || this.areaElement;
    s !== a && (Du(this, "targetGesto"), Du(this, "controlGesto"), r.target = null), r.target || (r.target = this.areaElement, this.controlBox.style.display = "block"), r.target && (this.targetGesto || (this.targetGesto = qC(this, a, "Group")), this.controlGesto || (this.controlGesto = Gx(this, this.controlBox, "controlAbles", "GroupControl")));
    var o = !C_(r.container, n.container);
    o && (r.container = n.container);
    var u = n.targets, l = this.differ.update(u), h = l.added, d = l.changed, f = l.removed, p = h.length || f.length;
    (o || p || this.transformOrigin !== (n.defaultGroupOrigin || "50% 50%") || d.length || u.length && !SC(this._targetGroups, n.targetGroups || [])) && (this.updateRect(), this._hasFirstTargets = !0), this._isPropTargetChanged = !!p;
  }, e._updateObserver = function() {
  }, t.defaultProps = F(F({}, ih.defaultProps), {
    transformOrigin: ["50%", "50%"],
    groupable: !0,
    dragArea: !0,
    keepRatio: !0,
    targets: [],
    defaultGroupRotate: 0,
    defaultGroupOrigin: "50% 50%"
  }), t;
}(ih), D3 = /* @__PURE__ */ function(i) {
  Md(t, i);
  function t() {
    var r = i !== null && i.apply(this, arguments) || this;
    return r.moveables = [], r;
  }
  var e = t.prototype;
  return e.render = function() {
    var r = this, n, s = this.props, a = s.cspNonce, o = s.cssStyled, u = s.persistData, l = s.targets || [], h = l.length, d = this.isUnmounted || !h, f = (n = u == null ? void 0 : u.children) !== null && n !== void 0 ? n : [];
    return d && !h && f.length ? l = f.map(function() {
      return null;
    }) : d || (f = []), Ki(o, {
      cspNonce: a,
      ref: Es(this, "controlBox"),
      className: Pt("control-box")
    }, l.map(function(p, v) {
      var g, m, y = (m = (g = s.individualGroupableProps) === null || g === void 0 ? void 0 : g.call(s, p, v)) !== null && m !== void 0 ? m : {};
      return Ki(ih, F({
        key: "moveable" + v,
        ref: hT(r, "moveables", v)
      }, s, y, {
        target: p,
        wrapperMoveable: r,
        isWrapperMounted: r.isMoveableMounted,
        persistData: f[v]
      }));
    }));
  }, e.componentDidUpdate = function() {
  }, e.getTargets = function() {
    return this.props.targets;
  }, e.updateRect = function(r, n, s) {
    s === void 0 && (s = !0), th(!0), this.moveables.forEach(function(a) {
      a.updateRect(r, n, s);
    }), th();
  }, e.getRect = function() {
    return F(F({}, i.prototype.getRect.call(this)), {
      children: this.moveables.map(function(r) {
        return r.getRect();
      })
    });
  }, e.request = function() {
    return {
      request: function() {
        return this;
      },
      requestEnd: function() {
        return this;
      }
    };
  }, e.dragStart = function() {
    return this;
  }, e.hitTest = function() {
    return 0;
  }, e.isInside = function() {
    return !1;
  }, e.isDragging = function() {
    return !1;
  }, e.updateRenderPoses = function() {
  }, e.checkUpdate = function() {
  }, e.triggerEvent = function() {
  }, e.updateAbles = function() {
  }, e._updateEvents = function() {
  }, e._updateObserver = function() {
  }, t;
}(ih);
function JC(i, t) {
  var e = [];
  return i.forEach(function(r) {
    if (r) {
      if ($r(r)) {
        t[r] && e.push.apply(e, t[r]);
        return;
      }
      tr(r) ? e.push.apply(e, JC(r, t)) : e.push(r);
    }
  }), e;
}
function QC(i, t) {
  var e = [];
  return i.forEach(function(r) {
    if (r) {
      if ($r(r)) {
        t[r] && e.push.apply(e, t[r]);
        return;
      }
      tr(r) ? e.push(QC(r, t)) : e.push(r);
    }
  }), e;
}
function tM(i, t) {
  return i.length !== t.length || i.some(function(e, r) {
    var n = t[r];
    return !e && !n ? !1 : e != n ? tr(e) && tr(n) ? tM(e, n) : !0 : !1;
  });
}
var k3 = /* @__PURE__ */ function(i) {
  Md(t, i);
  function t() {
    var r = i !== null && i.apply(this, arguments) || this;
    return r.refTargets = [], r.selectorMap = {}, r._differ = new zT(), r._elementTargets = [], r._onChangeTargets = null, r;
  }
  var e = t.prototype;
  return t.makeStyled = function() {
    var r = {}, n = this.getTotalAbles();
    n.forEach(function(a) {
      var o = a.css;
      o && o.forEach(function(u) {
        r[u] = !0;
      });
    });
    var s = Ps(r).join(`
`);
    this.defaultStyled = XT("div", DA(bx, EB + s));
  }, t.getTotalAbles = function() {
    return Tt([HC, Ux, ZC, zC], this.defaultAbles, !0);
  }, e.render = function() {
    var r, n = this.constructor;
    n.defaultStyled || n.makeStyled();
    var s = this.props, a = s.ables, o = s.props, u = cB(s, ["ables", "props"]), l = this._updateRefs(!0), h = JC(l, this.selectorMap), d = h.length > 1, f = n.getTotalAbles(), p = Tt(Tt([], f, !0), a || [], !0), v = F(F(F({}, u), o || {}), {
      ables: p,
      cssStyled: n.defaultStyled,
      customStyledMap: n.customStyledMap
    });
    this._elementTargets = h;
    var g = null, m = this.moveable, y = u.persistData;
    if (y != null && y.children && (d = !0), u.individualGroupable)
      return Ki(D3, F({
        key: "individual-group",
        ref: Es(this, "moveable")
      }, v, {
        target: null,
        targets: h
      }));
    if (d) {
      var _ = QC(l, this.selectorMap);
      if (m && !m.props.groupable && !m.props.individualGroupable) {
        var b = m.props.target;
        b && h.indexOf(b) > -1 && (g = F({}, m.state));
      }
      return Ki(R3, F({
        key: "group",
        ref: Es(this, "moveable")
      }, v, (r = u.groupableProps) !== null && r !== void 0 ? r : {}, {
        target: null,
        targets: h,
        targetGroups: _,
        firstRenderState: g
      }));
    } else {
      var w = h[0];
      if (m && (m.props.groupable || m.props.individualGroupable)) {
        var T = m.moveables || [], x = nn(T, function(S) {
          return S.props.target === w;
        });
        x && (g = F({}, x.state));
      }
      return Ki(ih, F({
        key: "single",
        ref: Es(this, "moveable")
      }, v, {
        target: w,
        firstRenderState: g
      }));
    }
  }, e.componentDidMount = function() {
    this._checkChangeTargets(), this._updateRefs();
  }, e.componentDidUpdate = function() {
    this._checkChangeTargets();
  }, e.componentWillUnmount = function() {
    this.selectorMap = {}, this.refTargets = [];
  }, e.getTargets = function() {
    var r, n;
    return (n = (r = this.moveable) === null || r === void 0 ? void 0 : r.getTargets()) !== null && n !== void 0 ? n : [];
  }, e.updateSelectors = function() {
    this.selectorMap = {}, this._updateRefs();
  }, e.waitToChangeTarget = function() {
    var r = this, n;
    return this._onChangeTargets = function() {
      r._onChangeTargets = null, n();
    }, new Promise(function(s) {
      n = s;
    });
  }, e.waitToChangeTargets = function() {
    return this.waitToChangeTarget();
  }, e.getManager = function() {
    return this.moveable;
  }, e._updateRefs = function(r) {
    var n = this.refTargets, s = Ix(this.props.target || this.props.targets), a = typeof document < "u", o = tM(n, s), u = this.selectorMap, l = {};
    return this.refTargets.forEach(function h(d) {
      if ($r(d)) {
        var f = u[d];
        f ? l[d] = u[d] : a && (o = !0, l[d] = [].slice.call(document.querySelectorAll(d)));
      } else
        tr(d) && d.forEach(h);
    }), this.refTargets = s, this.selectorMap = l, !r && o && this.forceUpdate(), s;
  }, e._checkChangeTargets = function() {
    var r, n, s, a = this._differ.update(this._elementTargets), o = a.added, u = a.removed, l = o.length || u.length;
    l && ((n = (r = this.props).onChangeTargets) === null || n === void 0 || n.call(r, {
      moveable: this.moveable,
      targets: this._elementTargets
    }), (s = this._onChangeTargets) === null || s === void 0 || s.call(this)), this._updateRefs();
  }, t.defaultAbles = [], t.customStyledMap = {}, t.defaultStyled = null, fB([kA(JT)], t.prototype, "moveable", void 0), t;
}(TT), N3 = /* @__PURE__ */ function(i) {
  Md(t, i);
  function t() {
    return i !== null && i.apply(this, arguments) || this;
  }
  return t.defaultAbles = jx, t;
}(k3), A3 = N3, A_ = function(i, t) {
  return A_ = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var n in r)
      Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
  }, A_(i, t);
};
function zx(i, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  A_(i, t);
  function e() {
    this.constructor = i;
  }
  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var yc = function() {
  return yc = Object.assign || function(t) {
    for (var e, r = 1, n = arguments.length; r < n; r++) {
      e = arguments[r];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
    }
    return t;
  }, yc.apply(this, arguments);
};
function L3(i, t, e, r) {
  var n = arguments.length, s = n < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(i, t, e, r);
  else
    for (var o = i.length - 1; o >= 0; o--)
      (a = i[o]) && (s = (n < 3 ? a(s) : n > 3 ? a(t, e, s) : a(t, e)) || s);
  return n > 3 && s && Object.defineProperty(t, e, s), s;
}
var B3 = /* @__PURE__ */ function(i) {
  zx(t, i);
  function t(r) {
    var n = i.call(this, r) || this;
    return n.state = {}, n.state = n.props, n;
  }
  var e = t.prototype;
  return e.render = function() {
    return Ki(A3, yc({
      ref: Es(this, "moveable")
    }, this.state));
  }, t;
}(fx), F3 = O3, G3 = JT, U3 = P3, j3 = /* @__PURE__ */ function(i) {
  zx(t, i);
  function t(r, n) {
    n === void 0 && (n = {});
    var s = i.call(this) || this;
    s.containerProvider = null, s.selfElement = null, s._warp = !1;
    var a = yc({}, n), o = {};
    U3.forEach(function(h) {
      o[zA("on ".concat(h))] = function(d) {
        return s.trigger(h, d);
      };
    });
    var u;
    n.warpSelf ? (delete n.warpSelf, s._warp = !0, u = r) : (u = document.createElement("div"), r.appendChild(u)), s.containerProvider = gw(Ki(B3, yc({
      ref: Es(s, "innerMoveable")
    }, a, o)), u);
    var l = a.target;
    return tr(l) && l.length > 1 && s.updateRect(), s;
  }
  var e = t.prototype;
  return e.setState = function(r, n) {
    this.innerMoveable.setState(r, n);
  }, e.forceUpdate = function(r) {
    this.innerMoveable.forceUpdate(r);
  }, e.dragStart = function(r) {
    var n = this.innerMoveable;
    n.$_timer && this.forceUpdate(), this.getMoveable().dragStart(r);
  }, e.destroy = function() {
    var r, n = this.selfElement;
    gw(null, n, this.containerProvider), this._warp || (r = n == null ? void 0 : n.parentElement) === null || r === void 0 || r.removeChild(n), this.containerProvider = null, this.off(), this.selfElement = null, this.innerMoveable = null;
  }, e.getMoveable = function() {
    return this.innerMoveable.moveable;
  }, t = L3([uw(G3, function(r, n) {
    r[n] || (r[n] = function() {
      for (var s = [], a = 0; a < arguments.length; a++)
        s[a] = arguments[a];
      var o = this.getMoveable();
      if (!(!o || !o[n]))
        return o[n].apply(o, s);
    });
  }), uw(F3, function(r, n) {
    Object.defineProperty(r, n, {
      get: function() {
        return this.getMoveable().props[n];
      },
      set: function(s) {
        var a;
        this.setState((a = {}, a[n] = s, a));
      },
      enumerable: !0,
      configurable: !0
    });
  })], t), t;
}(l0), z3 = /* @__PURE__ */ function(i) {
  zx(t, i);
  function t() {
    return i !== null && i.apply(this, arguments) || this;
  }
  return t;
}(j3), hn, Ju, Qu, tl, el, Wc, Ya, qa, Yc, L_;
const pt = class {
  constructor(t, e = !1) {
    // divでmovを更新
    E(this, Yc);
    K(this, "hArg", {});
    K(this, "id_tag", "");
    K(this, "hDesignArg", {
      rotation: 0,
      pivot_x: 0,
      pivot_y: 0,
      left: 0,
      center: 0,
      right: 0,
      s_right: 0,
      top: 0,
      middle: 0,
      bottom: 0,
      s_bottom: 0,
      width: 0,
      height: 0
    });
    K(this, "child");
    K(this, "parent");
    K(this, "fncLay", () => {
    });
    K(this, "mov");
    K(this, "div");
    K(this, "lx", 0);
    // これ以後の this変数スケールは SKYNovel スクリプト値
    K(this, "ly", 0);
    K(this, "rect", Nt.EMPTY);
    // cvsResizeBaseやhint座標など計算用
    K(this, "pivot", new xe(0, 0));
    K(this, "scale", new xe(1, 1));
    K(this, "rotation", 0);
    K(this, "oldFn", () => "");
    K(this, "rotatable", !0);
    this.bg_col = t, this.isLay = e;
  }
  static init(t, e, r, n, s, a, o) {
    pt.sys = e, P(pt, Ju, r), pt.prpPrs = n, P(pt, Qu, s), P(pt, tl, a), pt.hPages = o, Ur.cvs.insertAdjacentHTML("beforebegin", `<div id="${c(pt, el)}" style="width: ${Y.stageW * e.cvsScale}px; height: ${Y.stageH * e.cvsScale}px; background: rgba(0,0,0,0); position: absolute; touch-action: none; user-select: none; display: none;"></div>`), P(pt, hn, document.getElementById(c(pt, el))), pt.divHint.classList.add("sn_design_hint"), t.view.parentElement.appendChild(pt.divHint), Au(`
.sn_design_cast {
	position: absolute; touch-action: none; user-select: none;
	opacity: 0.6; border-radius: 8px;
}

.sn_design_cast.drag_border {
	line-height: 1.8;
	border: dashed 5px #333;
}

.sn_design_hint {
	position: absolute;
	left: 0;
	top: 0;
	padding: 5px;
	border-radius: 5px;
	background: #333;
	z-index: 10;
	color: #fff;
	font-weight: bold;
	font-size: 12px;
	display: none;
}
`);
  }
  static setHint(t, e, r, n) {
    pt.divHint.innerHTML = t;
    const s = window.getComputedStyle(pt.divHint), a = parseFloat(s.width), o = parseFloat(s.height);
    pt.divHint.style.cssText = `display: block; left: ${Math.max(10, n.lx + e - a)}px;
		top: ${Math.max(10, n.ly + r - o - 10)}px;`;
  }
  static cvsResizeDesign() {
    const t = c(pt, hn).style;
    t.width = `${Y.stageW * pt.sys.cvsScale}px`, t.height = `${Y.stageH * pt.sys.cvsScale}px`;
  }
  destroy() {
    var t;
    this.div = void 0, (t = this.mov) == null || t.destroy(), this.mov = void 0;
  }
  gethArg() {
    return this.hArg;
  }
  sethArg(t) {
    if (!this.includeDesignArg(t))
      return;
    this.id_tag || (this.id_tag = t[":id_tag"] ?? ""), this.hArg = t;
    const e = t[":id_dc"] ?? this.id_tag;
    c(pt, Ya)[e] = this;
  }
  includeDesignArg(t) {
    return Object.keys(t).some((e) => e in this.hDesignArg);
  }
  getRect() {
    return Nt.EMPTY;
  }
  cnvPosArg(t, e) {
    return {};
  }
  cnvSizeArg(t, e) {
    return {};
  }
  setPos(t, e) {
  }
  setSize(t, e) {
  }
  setOther(t) {
  }
  adopt(t) {
    this.child = t, t.parent = this;
  }
  static enterMode() {
    pt.leaveMode(), c(pt, hn).style.display = "inline", P(pt, Wc, 0), P(pt, Ya, {});
  }
  static allHide() {
    c(pt, qa).forEach((t) => t.visible = !1);
  }
  set visible(t) {
    !this.div || !this.mov || (this.div.style.display = t ? "inline" : "none", this.mov.updateTarget());
  }
  static leaveMode() {
    c(pt, hn).textContent = "", c(pt, hn).style.display = "none", c(pt, qa).forEach((t) => t.destroy()), P(pt, qa, []);
  }
  cvsResize() {
    var t;
    O(this, Yc, L_).call(this), (t = this.mov) == null || t.updateTarget();
  }
  onDragStart() {
  }
  make() {
    const t = this.hArg[":id_dc"] ?? this.id_tag;
    c(pt, Ya)[t] = this;
    const e = this.div = document.createElement("div");
    e.id = c(pt, el) + "_" + ++Ve(pt, Wc)._, e.classList.add("sn_design_cast"), e.dataset.id_dc = t, e.style.backgroundColor = `${this.bg_col}`, e.style.display = "none", this.rect = this.getRect(), O(this, Yc, L_).call(this), (this.parent ? document.querySelector(
      `[data-id_dc="${this.parent.id_tag}"]`
      // 親なので
    ) ?? c(pt, hn) : c(pt, hn)).appendChild(e);
    const r = {
      // movがdivを操作する際の雑用。スケールはHTML DOM
      aPos: [0, 0],
      roDeg: 0,
      trOrg: "",
      origin: [0, 0]
    }, n = () => {
      r.aPos = [NaN, NaN], r.roDeg = this.rotation;
      const u = this.pivot.x * pt.sys.cvsScale, l = this.pivot.y * pt.sys.cvsScale;
      r.trOrg = `${u}px ${l}px`, r.origin = [u, l];
    }, s = (u) => {
      pt.sys.send2Dbg("_changeCast", {
        ...u,
        ":id_tag": this.id_tag
      }), pt.divHint.style.display = "none";
    }, a = () => {
      const [u, l] = r.aPos;
      if (isNaN(u)) {
        pt.divHint.style.display = "none";
        return;
      }
      const h = $t(this.rect.x += u / pt.sys.cvsScale + this.pivot.x), d = $t(this.rect.y += l / pt.sys.cvsScale + this.pivot.y);
      this.setPos(h, d);
      const f = ii(this.rect.width), p = ii(this.rect.height);
      this.setSize(f, p), s({
        ...this.cnvPosArg(h, d),
        ...this.cnvSizeArg(f, p)
      });
    };
    let o;
    this.mov = new z3(document.body, {
      target: e,
      draggable: !0,
      resizable: !0,
      //	scalable	: true,
      rotatable: this.rotatable,
      originDraggable: this.rotatable,
      snappable: !0
    }).on("dragStart", (u) => {
      var h;
      n(), this.onDragStart();
      const l = (h = this.child) == null ? void 0 : h.mov;
      l && (o = l.target, l.isInside(u.clientX, u.clientY) && (l.target = void 0));
    }).on("drag", (u) => {
      r.aPos = u.beforeTranslate, this.procDragHint(u, u.left, u.top);
    }).on("dragEnd", () => {
      var u, l;
      a(), (u = this.child) != null && u.mov && (this.child.mov.target = o), (l = this.parent) != null && l.mov && (this.parent.mov.target = this.parent.div);
    }).on("resizeStart", n).on("resize", (u) => {
      e.style.width = `${u.width}px`, e.style.height = `${u.height}px`, r.aPos = u.drag.beforeTranslate, this.rect.width = u.width / pt.sys.cvsScale, this.rect.height = u.height / pt.sys.cvsScale, this.procResizeHint(u, u.drag.left, u.drag.top);
    }).on("resizeEnd", a).on("rotateStart", (u) => {
      n(), u.set(r.roDeg);
    }).on("rotate", (u) => {
      r.roDeg = u.beforeRotate, pt.setHint($t(r.roDeg) + "度", u.drag.left, u.drag.top, this);
    }).on("rotateEnd", () => {
      this.rotation = r.roDeg, this.setOther({}), s({ rotation: $t(r.roDeg) });
    }).on("dragOriginStart", () => n).on("dragOrigin", (u) => {
      r.trOrg = u.transformOrigin, r.origin = u.origin;
    }).on("dragOriginEnd", () => {
      const [u, l] = r.origin;
      r.trOrg = `${u}px ${l}px`;
      const h = this.pivot.x = u / pt.sys.cvsScale, d = this.pivot.y = l / pt.sys.cvsScale;
      this.setOther({});
      const f = $t(this.rect.x + h), p = $t(this.rect.y + d);
      this.setPos(f, p), s({
        ...this.cnvPosArg(f, p),
        pivot_x: $t(h),
        pivot_y: $t(d)
      });
    }).on("render", () => {
      const { aPos: u, roDeg: l, trOrg: h } = r;
      e.style.transformOrigin = h, e.style.transform = `translate(${u[0]}px, ${u[1]}px) rotate(${l}deg)`;
    }), c(pt, qa).push(this), e.addEventListener("dragenter", () => e.classList.add("drag_border")), e.addEventListener("dragover", (u) => {
      u.stopPropagation(), u.preventDefault(), u.dataTransfer && (u.dataTransfer.dropEffect = "copy");
    }), e.addEventListener("dragleave", () => e.classList.remove("drag_border")), e.addEventListener("drop", (u) => {
      u.stopPropagation(), u.preventDefault(), e.classList.remove("drag_border");
      const l = u.dataTransfer;
      if (!l || l.files.length === 0)
        return;
      const h = l.files[0], d = {
        ":id_tag": this.id_tag,
        fn: Vh(h.name),
        ext: ov(h.name),
        url: "",
        buf: new ArrayBuffer(0),
        old_fn: this.oldFn(),
        old_url: c(pt, tl).searchPath(this.oldFn(), vr.SP_GSM)
      };
      h.arrayBuffer().then((f) => {
        d.buf = f;
        try {
          d.url = c(pt, Ju).cnvPath4Dbg(
            c(pt, tl).searchPath(h.name, vr.SP_GSM)
          );
        } catch {
        }
        pt.sys.send2Dbg("_dropFile", d);
      }).catch((f) => console.error("drop2dc %o", f));
    }), e.addEventListener("dblclick", (u) => {
      u.preventDefault(), pt.sys.send2Dbg("_focusScript", this.hArg);
    });
  }
  procDragHint(t, e, r) {
    const [n, s] = t.beforeTranslate;
    pt.setHint(
      `(${$t(this.rect.x + n / pt.sys.cvsScale)}, ${$t(this.rect.y + s / pt.sys.cvsScale)})`,
      e,
      r,
      this
    );
  }
  procResizeHint(t, e, r) {
    pt.setHint(
      `(${$t(t.drag.left)}, ${$t(t.drag.top)})<br/>${$t(this.rect.width)} x ${$t(this.rect.height)}`,
      e,
      r,
      this
    );
  }
  static replaceToken(t) {
    var h, d, f, p, v, g, m, y;
    const r = t[":id_tag"], n = c(pt, Ya)[r];
    if (!document.querySelector(`div[data-id_dc='${r}']`) || !n)
      return;
    const a = t[":token"];
    c(pt, Ju).replace(t[":idx_tkn"], a);
    const [o, u] = Op(a);
    n.child && (n.child.hArg[":token"] = n.hArg[":token"]), c(pt, Qu).parse(u);
    const l = c(pt, Qu).hPrm;
    if ("pivot_x" in l || "pivot_y" in l) {
      const _ = Number(pt.prpPrs.getValAmpersand(l.pivot_x.val)), b = Number(pt.prpPrs.getValAmpersand(l.pivot_y.val));
      (isNaN(_) || isNaN(b)) && zt.myTrace(`pivot_xかpivot_yが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${a}`, "F"), n.pivot.set(_, b);
    }
    if ("left" in l || "top" in l || "x" in l || "y" in l) {
      const _ = $t(pt.prpPrs.getValAmpersand(((h = l.left) == null ? void 0 : h.val) ?? ((d = l.x) == null ? void 0 : d.val) ?? "0")), b = $t(pt.prpPrs.getValAmpersand(((f = l.top) == null ? void 0 : f.val) ?? ((p = l.y) == null ? void 0 : p.val) ?? "0"));
      (isNaN(_) || isNaN(b)) && zt.myTrace(`widthかheightが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${a}`, "F"), n.rect.x = _ - n.pivot.x, n.rect.y = b - n.pivot.y, n.setPos(_, b);
    }
    if ("width" in l || "height" in l) {
      const _ = $t(pt.prpPrs.getValAmpersand(((v = l.width) == null ? void 0 : v.val) ?? "0")), b = $t(pt.prpPrs.getValAmpersand(((g = l.height) == null ? void 0 : g.val) ?? "0"));
      (isNaN(_) || isNaN(b)) && zt.myTrace(`widthかheightが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${a}`, "F"), n.rect.width = _, n.rect.height = b, n.setSize(_, b);
    }
    if ("scale_x" in l || "scale_y" in l) {
      const _ = Number(pt.prpPrs.getValAmpersand(((m = l.scale_x) == null ? void 0 : m.val) ?? "0")), b = Number(pt.prpPrs.getValAmpersand(((y = l.scale_y) == null ? void 0 : y.val) ?? "0"));
      (isNaN(_) || isNaN(b)) && zt.myTrace(`scale_xかscale_yが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${a}`, "F"), n.scale.set(_, b);
    }
    if ("rotation" in l) {
      const _ = Number(pt.prpPrs.getValAmpersand(l.rotation.val));
      isNaN(_) && zt.myTrace(`rotationが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${a}`, "F"), n.rotation = _;
    }
    n.setOther(l), n.cvsResize();
  }
};
let Vt = pt;
hn = new WeakMap(), Ju = new WeakMap(), Qu = new WeakMap(), tl = new WeakMap(), el = new WeakMap(), Wc = new WeakMap(), Ya = new WeakMap(), qa = new WeakMap(), Yc = new WeakSet(), L_ = function() {
  this.fncLay(), this.div && Object.assign(this.div.style, {
    left: `${this.lx + this.rect.x * pt.sys.cvsScale}px`,
    top: `${this.ly + this.rect.y * pt.sys.cvsScale}px`,
    width: `${this.rect.width * pt.sys.cvsScale}px`,
    height: `${this.rect.height * pt.sys.cvsScale}px`,
    transformOrigin: `${this.pivot.x * pt.sys.cvsScale}px ${this.pivot.y * pt.sys.cvsScale}px`,
    transform: `scale(${this.scale.x}, ${this.scale.y}) rotate(${this.rotation}deg)`
  });
}, E(Vt, hn, void 0), K(Vt, "sys"), E(Vt, Ju, void 0), K(Vt, "prpPrs"), E(Vt, Qu, void 0), E(Vt, tl, void 0), K(Vt, "hPages"), K(Vt, "divHint", document.createElement("div")), E(Vt, el, "DesignMode"), E(Vt, Wc, 0), E(Vt, Ya, {}), E(Vt, qa, []);
var Us;
class H3 extends Vt {
  constructor(e, r) {
    super("#29e", !0);
    E(this, Us, void 0);
    K(this, "oldFn", () => this.hArg.fn ?? "");
    this.spLay = e, this.gl = r;
  }
  setSp(e) {
    P(this, Us, e);
  }
  getRect() {
    var e, r;
    return new Nt(this.spLay.x, this.spLay.y, ((e = c(this, Us)) == null ? void 0 : e.width) ?? 0, ((r = c(this, Us)) == null ? void 0 : r.height) ?? 0);
  }
  cnvPosArg(e, r) {
    return { left: e, top: r };
  }
  cnvSizeArg(e, r) {
    return { width: e, height: r };
  }
  setPos(e, r) {
    this.spLay.x = e, this.spLay.y = r;
  }
  setSize(e, r) {
    c(this, Us).width = e, c(this, Us).height = r;
  }
  setOther(e) {
    if ("fn" in e) {
      const r = Vt.prpPrs.getValAmpersand(e.fn.val);
      this.gl.lay({ fn: r });
    }
    this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;
  }
}
Us = new WeakMap();
class $3 extends Vt {
  constructor(e, r) {
    super("#29e", !0);
    K(this, "hDesignArg", {
      rotation: 0,
      pivot_x: 0,
      pivot_y: 0,
      left: 0,
      center: 0,
      right: 0,
      s_right: 0,
      top: 0,
      middle: 0,
      bottom: 0,
      s_bottom: 0,
      width: 0,
      height: 0,
      pl: 0,
      pr: 0,
      pt: 0,
      pb: 0
    });
    this.spLay = e, this.ts = r;
  }
  getRect() {
    const e = this.ts.infTL;
    return new Nt(this.spLay.x, this.spLay.y, e.$width, e.$height);
  }
  cnvPosArg(e, r) {
    return { left: e, top: r };
  }
  cnvSizeArg(e, r) {
    return { width: e, height: r };
  }
  setPos(e, r) {
    this.spLay.position.set(e, r), this.ts.lay(this.cnvPosArg(e, r));
  }
  setSize(e, r) {
    this.ts.lay(this.cnvSizeArg(e, r));
  }
  setOther(e) {
    var r;
    (r = this.child) == null || r.setOther(e), this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;
  }
}
var qc, B_;
class V3 extends Vt {
  constructor(e) {
    super("#9e2");
    E(this, qc);
    K(this, "rotatable", !1);
    this.ts = e;
  }
  getRect() {
    const e = this.ts.infTL;
    return new Nt(
      e.pad_left,
      e.pad_top,
      e.$width - e.pad_left - e.pad_right,
      e.$height - e.pad_top - e.pad_bottom
    );
  }
  cnvPosArg(e, r) {
    return { pl: e, pt: r };
  }
  cnvSizeArg(e, r) {
    const n = this.ts.infTL;
    return {
      pr: n.$width - n.pad_left - e,
      pb: n.$height - n.pad_top - r
    };
  }
  setPos(e, r) {
    this.ts.lay(this.cnvPosArg(e, r));
  }
  setSize(e, r) {
    this.ts.lay({ ...this.cnvSizeArg(e, r), ":redraw": !0 });
  }
  setOther(e) {
    var n, s, a, o;
    const r = this.ts.infTL;
    if (("pl" in e || "pt" in e) && (this.setPos(
      this.rect.x = parseFloat(Vt.prpPrs.getValAmpersand(
        ((n = e.pl) == null ? void 0 : n.val) ?? `${r.pad_left}`
      )),
      this.rect.y = parseFloat(Vt.prpPrs.getValAmpersand(
        ((s = e.pt) == null ? void 0 : s.val) ?? `${r.pad_top}`
      ))
    ), this.cvsResize()), "pr" in e || "pb" in e) {
      this.ts.lay({
        pr: parseFloat(Vt.prpPrs.getValAmpersand(
          ((a = e.pr) == null ? void 0 : a.val) ?? `${r.pad_right}`
        )),
        pb: parseFloat(Vt.prpPrs.getValAmpersand(
          ((o = e.pb) == null ? void 0 : o.val) ?? `${r.pad_bottom}`
        ))
      });
      const u = this.getRect();
      this.setSize(
        this.rect.width = u.width,
        this.rect.height = u.height
      ), this.cvsResize();
    }
  }
  procDragHint(e, r, n) {
    const [s, a] = e.beforeTranslate;
    O(this, qc, B_).call(this, r, n, s, a);
  }
  procResizeHint(e, r, n) {
    const [s, a] = e.drag.beforeTranslate;
    O(this, qc, B_).call(this, r, n, s, a);
  }
}
qc = new WeakSet(), B_ = function(e, r, n, s) {
  const a = this.rect.x, o = this.rect.y, u = this.rect.width, l = this.rect.height, h = this.ts.infTL, d = $t(a + n / Vt.sys.cvsScale), f = $t(o + s / Vt.sys.cvsScale), p = $t(h.$width - d - u), v = $t(h.$height - f - l), g = (m) => "&nbsp;".repeat(m);
  Vt.setHint(
    g(5 + 5 + 1) + `上幅=${f}<br/>
			左幅=${d + g(1 + 3 + 5 + 1)}右幅=${p}<br/>` + g(5) + `内側 ${$t(u)} x ${$t(l)}<br/>` + g(5 + 5) + `下幅=${v}`,
    e,
    r,
    this
  );
};
class eM extends Vt {
  constructor(t, e) {
    super("#e92"), this.btn = t, this.hArg = e, this.pivot.x = tt(e, "pivot_x", this.pivot.x), this.pivot.y = tt(e, "pivot_y", this.pivot.y), this.scale.x = tt(e, "scale_x", this.scale.x), this.scale.y = tt(e, "scale_y", this.scale.y), this.rotation = tt(e, "rotation", this.rotation), this.sethArg(e);
  }
  sethArg(t) {
    super.sethArg(t);
    const e = this.hArg.layer ?? "";
    this.fncLay = !this.parent && !this.child && e ? () => {
      const r = Vt.hPages[e].fore;
      this.lx = r.x * Vt.sys.cvsScale, this.ly = r.y * Vt.sys.cvsScale;
    } : () => {
    };
  }
  cnvPosArg(t, e) {
    return { left: t, top: e };
  }
  cnvSizeArg(t, e) {
    return { width: t, height: e };
  }
  setPos(t, e) {
    this.btn.x = t, this.btn.y = e;
  }
  setOther(t) {
    this.btn.pivot.copyFrom(this.pivot), this.btn.scale.copyFrom(this.scale), this.btn.angle = this.rotation;
  }
  onDragStart() {
  }
}
class X3 extends eM {
  constructor(e, r, n) {
    super(e, r);
    K(this, "oldFn", () => this.hArg.b_pic ?? "");
    this.txt = n, vt(r, "design", !0) || (this.setPos = () => {
    }, this.setSize = () => {
    });
  }
  getRect() {
    return new Nt(this.btn.x, this.btn.y, this.txt.width, this.txt.height);
  }
  setSize(e, r) {
    this.txt.width = e, this.txt.height = r;
  }
  setOther(e) {
    if (super.setOther(e), "b_pic" in e) {
      const r = Vt.prpPrs.getValAmpersand(e.b_pic.val ?? "");
      this.btn.update_b_pic(r, this.txt);
    }
  }
}
var Zn;
class W3 extends eM {
  constructor(e, r) {
    super(e, r);
    E(this, Zn, void 0);
    K(this, "oldFn", () => this.hArg.pic ?? "");
  }
  setSp(e) {
    P(this, Zn, e);
  }
  getRect() {
    return new Nt(this.btn.x, this.btn.y, c(this, Zn).width, c(this, Zn).height);
  }
  setSize(e, r) {
    c(this, Zn).width = e, c(this, Zn).height = r;
  }
  setOther(e) {
    if (super.setOther(e), "pic" in e) {
      const r = Vt.prpPrs.getValAmpersand(e.pic.val);
      this.btn.update_pic(r, c(this, Zn));
    }
  }
}
Zn = new WeakMap();
var pg, js, Kn, Za, Ka, cn, rl, Ja, Zc, il, fn, Jn, Qn, zs, Kc, Jc, Qc, vg, rM, gg, iM, tf, F_, mg, nM, nl, $p, sl, Ni, al, yg, Qa, ef;
const _t = class extends _r {
  constructor() {
    super();
    E(this, fn, new H3(this.spLay, this));
    E(this, Jn, "");
    E(this, Qn, "");
    E(this, zs, "");
    K(this, "lay", (e) => this.laySub(e, (r) => {
      r && c(_t, Kn).resume();
    }));
    E(this, Kc, 0);
    E(this, Jc, 0);
    E(this, sl, void 0);
    E(this, Ni, void 0);
    E(this, al, () => {
    });
    K(this, "record", () => ({
      ...super.record(),
      sBkFn: c(this, Qn),
      sBkFace: c(this, zs),
      idc_hArg: c(this, fn).gethArg()
    }));
    //showDesignCastChildren() {}
    K(this, "dump", () => super.dump() + `, "pic":"${c(this, Jn)}"`);
    Y.isDbg && (this.setSp = (e) => c(this, fn).setSp(e), this.cvsResize = () => {
      super.cvsResize(), c(this, fn).cvsResize();
    });
  }
  static init(e, r, n, s, a, o) {
    P(_t, Kn, e), P(_t, Za, r), P(_t, Ka, n), P(_t, cn, s), P(_t, rl, o);
    const u = () => {
      const l = c(_t, Ja) * c(_t, Zc);
      for (const h of Object.values(_t.hFn2VElm))
        h.volume = l;
    };
    a.setNoticeChgVolume(
      (l) => {
        P(_t, Ja, l), u();
      },
      (l) => {
        P(_t, Zc, l), u();
      }
    ), c(_t, cn).crypto && P(_t, Qc, O(_t, gg, iM));
  }
  static setEvtMng(e) {
    P(_t, il, e);
  }
  static destroy() {
    c(_t, pg).clear(), P(_t, js, {}), _t.hFn2ResAniSpr = {}, _t.hFn2VElm = {};
  }
  setSp(e) {
  }
  laySub(e, r) {
    var u;
    O(u = _t, nl, $p).call(u, c(this, Qn));
    const { fn: n, face: s = "" } = e;
    if (c(this, fn).sethArg(e), !n)
      return super.lay(e), this.spLay.children.length > 0 && this.setPos(e), P(this, Qn, ""), P(this, Jn, P(this, zs, s)), r(!1), !1;
    const a = "fn" in e, o = "face" in e;
    return this.clearLay({ filter: "true" }), a && P(this, Qn, n), o && P(this, zs, s), super.lay(e), e.dx = 0, e.dy = 0, _t.csv2Sprites(
      P(this, Jn, n + (s ? "," + s : "")),
      this.spLay,
      (l) => {
        ("width" in e || "height" in e) && (l.width = tt(e, "width", 0), l.height = tt(e, "height", 0)), P(this, Kc, l.width), P(this, Jc, l.height), _r.setXY(l, e, this.spLay, !0), this.setSp(l);
      },
      (l) => {
        _r.setBlendmodeParentOnly(this.spLay, e), r(l);
      }
    );
  }
  get width() {
    return c(this, Kc);
  }
  get height() {
    return c(this, Jc);
  }
  //	static #ldrHFn: {[name: string]: 1} = {};
  static csv2Sprites(e, r, n, s = () => {
  }) {
    let a = !1;
    if (e.slice(0, 5) === "data:") {
      const h = () => {
        const d = Ue.from(e);
        r == null || r.addChild(d), n(d), s(a);
      };
      return e in Gr ? h() : (a = !0, new ri().add(e, e).load(h)), a;
    }
    const o = [], u = new ri();
    e.split(",").forEach((h, d) => {
      if (!h)
        throw "face属性に空要素が含まれます";
      const { dx: f, dy: p, blendmode: v, fn: g } = c(_t, js)[h] || {
        fn: h,
        dx: 0,
        dy: 0,
        blendmode: Et.NORMAL
      }, m = d === 0 ? n : (b) => {
        b.x = f, b.y = p, b.blendMode = v;
      };
      if (o.push({ fn: g, fnc: m }), g in _t.hFn2ResAniSpr || g in Gr || g in ri.shared.resources)
        return;
      a = !0;
      const y = c(_t, Za).searchPath(g, vr.SP_GSM), _ = c(this, cn).crypto ? { xhrType: y.slice(-5) === ".json" ? Ft.XHR_RESPONSE_TYPE.TEXT : Ft.XHR_RESPONSE_TYPE.BUFFER } : {};
      u.add({ ..._, name: g, url: y });
    });
    const l = (h) => {
      var d;
      for (const { fn: f, fnc: p } of o) {
        const v = O(d = _t, mg, nM).call(d, f, h);
        v.name = f, r == null || r.addChild(v), p(v);
      }
      s(a);
    };
    return a ? u.use((h, d) => {
      c(this, cn).dec(h.extension, h.data).then((f) => {
        var p;
        return c(p = _t, Qc).call(p, f, h, () => d == null ? void 0 : d());
      }).catch((f) => c(this, Kn).errScript(`Graphic ロード失敗です fn:${h.name} ${f}`, !1));
    }).load((h, d) => l(d)) : l({}), a;
  }
  static wv(e) {
    var a;
    const { fn: r } = e;
    if (!r)
      throw "fnは必須です";
    const n = _t.hFn2VElm[r];
    if (!n || n.loop)
      return !1;
    if (c(this, rl).getVal("tmp:sn.skip.enabled") || c(this, il).isSkippingByKeyDown() || n.ended)
      return O(a = _t, nl, $p).call(a, r), !1;
    const s = () => {
      var o;
      O(o = _t, nl, $p).call(o, r), c(this, Kn).resume();
    };
    return n.addEventListener("ended", s, { once: !0, passive: !0 }), c(_t, il).waitEvent(
      () => {
        n.removeEventListener("ended", s), s();
      },
      vt(e, "canskip", !0),
      vt(e, "global", !1)
    );
  }
  renderStart() {
    P(this, sl, Ei.create({
      width: Y.stageW,
      height: Y.stageH
    })), P(this, Ni, new Ue(c(this, sl))), c(this, Ni).visible = !1, this.spLay.addChildAt(c(this, Ni), 0), c(this, Ni).position.set(-this.spLay.x, -this.spLay.y);
    let e = () => {
      const r = this.spLay.alpha;
      this.spLay.alpha = 1;
      for (const n of this.spLay.children)
        n.visible = !0;
      c(this, Ni).visible = !1, c(_t, Ka).renderer.render(this.spLay, { renderTexture: c(this, sl) }), this.spLay.alpha = r;
      for (const n of this.spLay.children)
        n.visible = !1;
    };
    if (!this.containMovement) {
      let r = e;
      e = () => {
        e = () => {
        }, r();
      };
    }
    P(this, al, () => {
      e(), c(this, Ni).visible = !0;
    }), c(_t, Ka).ticker.add(c(this, al));
  }
  renderEnd() {
    c(_t, Ka).ticker.remove(c(this, al)), this.spLay.removeChild(c(this, Ni));
    for (const e of this.spLay.children)
      e.visible = !0;
    c(this, Ni).destroy(!0);
  }
  // https://regex101.com/r/ZUnoFq/1
  static loadPic2Img(e, r, n) {
    const s = e.replace(c(_t, yg), ""), a = e === s ? "" : e.slice(s.length), o = c(this, ef)[e];
    if (o) {
      r.src = o;
      return;
    }
    const u = c(this, Qa)[e];
    if (u) {
      u.push(r);
      return;
    }
    c(this, Qa)[e] = [r];
    const l = c(_t, Za).searchPath(s, vr.SP_GSM), h = new ri().add({ name: e, url: l, xhrType: Ft.XHR_RESPONSE_TYPE.BUFFER });
    c(_t, cn).crypto && ov(l) === "bin" && h.use((d, f) => {
      c(_t, cn).dec(d.extension, d.data).then((p) => {
        if (d.extension !== "bin") {
          f == null || f();
          return;
        }
        d.data = p, p instanceof HTMLImageElement && (d.type = Ft.TYPE.IMAGE), f == null || f();
      }).catch((p) => c(_t, Kn).errScript(`GrpLayer loadPic ロード失敗です fn:${d.name} ${p}`, !1));
    }), h.load((d, f) => {
      for (const [p, { data: { src: v } }] of Object.entries(f)) {
        const g = c(this, ef)[p] = v + (v.slice(0, 5) === "blob:" ? "" : a);
        for (const m of c(this, Qa)[p])
          m.src = g, n && (m.onload = () => n(m));
        delete c(this, Qa)[p];
      }
    });
  }
  setPos(e) {
    _r.setXY(
      this.spLay.children.length === 0 ? this.spLay : this.spLay.children[0],
      e,
      this.spLay,
      !0
    );
  }
  static add_face(e) {
    const { name: r } = e;
    if (!r)
      throw "nameは必須です";
    if (r in c(_t, js))
      throw "一つのname（" + r + "）に対して同じ画像を複数割り当てられません";
    const { fn: n = r } = e;
    return c(_t, js)[r] = {
      fn: n,
      dx: tt(e, "dx", 0),
      dy: tt(e, "dy", 0),
      blendmode: _r.getBlendmodeNum(e.blendmode || "")
    }, !1;
  }
  static clearFace2Name() {
    P(_t, js, {});
  }
  // アニメ・動画を含むか
  get containMovement() {
    if (c(this, Jn) === "")
      return !1;
    const e = this.spLay.children;
    return c(this, Jn).split(",").some(
      (r, n) => e[n] instanceof nw || _t.hFn2VElm[r]
    );
  }
  clearLay(e) {
    super.clearLay(e);
    for (const r of this.spLay.removeChildren())
      r.destroy();
    P(this, Qn, ""), P(this, zs, ""), P(this, Jn, "");
  }
  playback(e, r) {
    if (super.playback(e, r), e.sBkFn === "" && e.sBkFace === "") {
      P(this, Qn, e.sBkFn), P(this, zs, e.sBkFace), c(this, fn).sethArg(e.idc_hArg);
      return;
    }
    r.push(new Promise((n) => this.laySub(
      { fn: e.sBkFn, face: e.sBkFace, left: e.x, top: e.y, alpha: e.alpha, blendmode: _r.getNum2Blendmode(e.blendMode), rotation: e.rotation, scale_x: e.scale_x, scale_y: e.scale_y },
      (s) => {
        this.spLay.position.set(e.x, e.y), n();
      }
      // Layer.setXY()の後に再度移動
    )));
  }
  makeDesignCast(e) {
    this.spLay.visible && e(c(this, fn));
  }
  //makeDesignCastChildren(_gdc: IMakeDesignCast) {}
  cvsResize() {
    super.cvsResize();
  }
  showDesignCast() {
    c(this, fn).visible = !0;
  }
};
let Wt = _t;
pg = new WeakMap(), js = new WeakMap(), Kn = new WeakMap(), Za = new WeakMap(), Ka = new WeakMap(), cn = new WeakMap(), rl = new WeakMap(), Ja = new WeakMap(), Zc = new WeakMap(), il = new WeakMap(), fn = new WeakMap(), Jn = new WeakMap(), Qn = new WeakMap(), zs = new WeakMap(), Kc = new WeakMap(), Jc = new WeakMap(), Qc = new WeakMap(), vg = new WeakSet(), rM = function(e) {
  const r = /([^\d]+)\d+\.(\w+)/.exec(e[0]);
  if (!r)
    return [];
  const n = r[1].length, s = -r[2].length - 1;
  return e.sort(
    (a, o) => $t(a.slice(n, s)) > $t(o.slice(n, s)) ? 1 : -1
  );
}, gg = new WeakSet(), iM = function(e, r, n) {
  var l;
  if (r.data = e, r.extension === "bin" && (e instanceof HTMLImageElement ? (r.texture = Ot.fromLoader(e, r.url, r.name), r.type = Ft.TYPE.IMAGE) : e instanceof HTMLVideoElement && (e.volume = c(_t, Ja), _t.hFn2VElm[r.name] = O(l = _t, tf, F_).call(l, e), r.type = Ft.TYPE.VIDEO)), r.extension !== "json") {
    n();
    return;
  }
  if (typeof e != "string") {
    n();
    return;
  }
  const { meta: s, frames: a } = r.data = JSON.parse(e);
  if (r.type = Ft.TYPE.JSON, !(s != null && s.image)) {
    n();
    return;
  }
  const o = Vh(s.image), u = c(_t, Za).searchPath(o, vr.SP_GSM);
  new ri().use((h, d) => {
    c(this, cn).dec(h.extension, h.data).then((f) => {
      h.data = f, f instanceof HTMLImageElement && (h.type = Ft.TYPE.IMAGE, URL.revokeObjectURL(f.src)), d == null || d();
    }).catch((f) => c(this, Kn).errScript(`Graphic ロード失敗です dec2res4Cripto fn:${h.name} ${f}`, !1));
  }).add({ name: o, url: u, xhrType: Ft.XHR_RESPONSE_TYPE.BUFFER }).load((h, d) => {
    for (const { data: f } of Object.values(h.resources)) {
      const { baseTexture: p } = Ot.from(f), v = Object.values(a);
      _t.hFn2ResAniSpr[r.name] = {
        aTex: v.map(({ frame: { x: g, y: m, w: y, h: _ } }) => new Ot(
          p,
          new Nt(g, m, y, _)
        )),
        meta: s
      };
    }
    n();
  });
}, tf = new WeakSet(), F_ = function(e) {
  return c(_t, rl).getVal("const.sn.needClick2Play") && (zt.trace_beforeNew(`[lay系] ${zt.strPos()}未クリック状態で動画を自動再生します。音声はミュートされます`, "W"), e.muted = !0), e.setAttribute("playsinline", ""), e;
}, mg = new WeakSet(), nM = function(e, r) {
  const n = _t.hFn2ResAniSpr[e];
  if (n) {
    const s = new nw(n.aTex);
    return s.animationSpeed = n.meta.animationSpeed ?? 1, s.play(), s;
  }
  return e in Gr ? Ue.from(e) : e in _t.hFn2VElm ? Ue.from(_t.hFn2VElm[e]) : e in r ? new Ue(r[e].texture) : new Ue();
}, nl = new WeakSet(), $p = function(e) {
  const r = _t.hFn2VElm[e];
  r && (delete _t.hFn2VElm[e], r.pause(), r.currentTime = r.duration);
}, sl = new WeakMap(), Ni = new WeakMap(), al = new WeakMap(), yg = new WeakMap(), Qa = new WeakMap(), ef = new WeakMap(), E(Wt, vg), E(Wt, gg), E(Wt, tf), E(Wt, mg), E(Wt, nl), E(Wt, pg, new Jl()), E(Wt, js, {}), E(Wt, Kn, void 0), E(Wt, Za, void 0), E(Wt, Ka, void 0), E(Wt, cn, void 0), E(Wt, rl, void 0), E(Wt, Ja, 1), E(Wt, Zc, 1), E(Wt, il, void 0), K(Wt, "hFn2ResAniSpr", {}), E(Wt, Qc, (e, r, n) => {
  var s, a;
  switch (r.type) {
    case Ft.TYPE.JSON:
      const o = r.spritesheet._frameKeys;
      O(s = _t, vg, rM).call(s, o), _t.hFn2ResAniSpr[r.name] = {
        aTex: o.map((l) => Ot.from(l)),
        meta: r.data.meta
      };
      break;
    case Ft.TYPE.VIDEO:
      const u = r.data;
      u.volume = c(_t, Ja), _t.hFn2VElm[r.name] = O(a = _t, tf, F_).call(a, u);
  }
  n();
}), K(Wt, "hFn2VElm", {}), E(Wt, yg, /\?([^?]+)$/), E(Wt, Qa, {}), E(Wt, ef, {});
var ol, rf, to, Xt, dn, ts, _g, qr, Hs, wt, di, Sr, Tr, ul, Vp, Ai, es, nf, ll, bg, sM, eo, hl, $s, ro, io, no, cl, sf, Vs, af, G_, rs, of, is, pn, fl, uf, U_, Xs, so, lf, j_, kr;
const At = class extends ye {
  constructor(e, r, n) {
    super();
    E(this, ul);
    E(this, bg);
    E(this, af);
    // 「g」などで下が欠ける問題対策
    E(this, uf);
    E(this, lf);
    E(this, Xt, document.createElement("span"));
    // サンプリング元
    E(this, dn, new ye());
    // サンプリング先
    E(this, ts, new si());
    E(this, qr, new $3(this.spLay, this));
    E(this, Hs, new V3(this));
    E(this, wt, {
      fontsize: 24,
      $width: 0,
      // レイヤサイズであり、背景色（画像）サイズ
      $height: 0,
      pad_left: 0,
      // paddingLeft（レイヤサイズの内側のスペーサー）
      pad_right: 0,
      // paddingRight
      pad_top: 0,
      // paddingTop
      pad_bottom: 0
      // paddingBottom
    });
    E(this, di, !1);
    E(this, Sr, 0);
    E(this, Tr, 0);
    E(this, Ai, 0);
    E(this, es, !1);
    E(this, nf, 0);
    E(this, ll, 0);
    E(this, eo, void 0);
    // 文字にかけるフィルター
    E(this, hl, []);
    E(this, $s, []);
    E(this, ro, 0);
    E(this, Vs, () => !1);
    E(this, fl, 0);
    E(this, Xs, "Quadratic.Out");
    E(this, so, "Quadratic.Out");
    E(this, kr, void 0);
    this.spLay = e, this.canFocus = r, this.sys = n, c(this, Xt).classList.add("sn_tx"), c(this, Xt).style.position = "absolute", c(At, rf).view.parentElement.appendChild(c(this, Xt)), this.addChild(c(this, dn)), this.addChild(c(this, ts)), c(this, ts).name = "grpDbgMasume", c(this, qr).adopt(c(this, Hs));
  }
  static init(e, r) {
    P(At, ol, e), P(At, rf, r), P(At, io, /[、。，．）］｝〉」』】〕”〟ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ！？!?‼⁉・ーゝゞヽヾ々]/), P(At, no, /[［（｛〈「『【〔“〝]/), P(At, cl, /[─‥…]/);
  }
  static setEvtMng(e) {
    P(At, to, e);
  }
  static destroy() {
    P(At, rs, /* @__PURE__ */ Object.create(null)), P(At, is, /* @__PURE__ */ Object.create(null)), P(At, pn, new ye());
  }
  lay(e) {
    const r = c(this, Xt).style;
    if ("style" in e)
      if (e.style) {
        const n = document.createElement("span");
        n.style.cssText = e.style;
        const s = n.style.length;
        for (let a = 0; a < s; ++a) {
          const o = n.style[a];
          if (o in c(At, _g)) {
            zt.myTrace(`${o}は指定できません`, "W");
            continue;
          }
          r[o] = n.style[o];
        }
        !n.style.opacity && "alpha" in e && (r.opacity = String(this.spLay.alpha));
      } else
        c(this, Xt).style.cssText = "";
    else
      "alpha" in e && (r.opacity = String(this.spLay.alpha));
    if ("width" in e && (r.width = (e.width ?? "0") + "px"), "height" in e && (r.height = (e.height ?? "0") + "px"), "pl" in e && (r.paddingLeft = (e.pl ?? "0") + "px"), "pr" in e && (r.paddingRight = (e.pr ?? "0") + "px"), "pt" in e && (r.paddingTop = (e.pt ?? "0") + "px"), "pb" in e && (r.paddingBottom = (e.pb ?? "0") + "px"), "kinsoku_sol" in e && P(At, io, new RegExp(`[${e.kinsoku_sol}]`)), "kinsoku_eol" in e && P(At, no, new RegExp(`[${e.kinsoku_eol}]`)), "kinsoku_dns" in e && P(At, cl, new RegExp(`[${e.kinsoku_dns}]`)), O(this, ul, Vp).call(this), c(this, qr).sethArg(e), P(this, Ai, this.spLay.position.x), r.transformOrigin = `${this.spLay.pivot.x}px ${this.spLay.pivot.y}px`, this.cvsResize(), r.display = this.spLay.visible ? "inline" : "none", r.textShadow = e.filter ?? r.textShadow ?? "", P(this, di, vt(e, "break_fixed", c(this, di))), P(this, Sr, tt(e, "break_fixed_left", c(this, Sr))), P(this, Tr, tt(e, "break_fixed_top", c(this, Tr))), ":redraw" in e && c(this, ro) > 0) {
      const n = [
        c(this, Xt).innerHTML.replaceAll(/(animation-delay: )\d+ms/g, "$10ms"),
        `<span class='sn_ch' data-add='{"ch_in_style":"default"}'>　</span>`
      ];
      O(this, lf, j_).call(this), this.goTxt(n, !0);
    }
  }
  cvsResize() {
    const e = c(this, Xt).style, r = this.sys.cvsScale;
    e.left = `${this.sys.ofsLeft4elm + c(this, Ai) * r}px`, e.top = `${this.sys.ofsTop4elm + this.spLay.position.y * r}px`, e.transform = `rotate(${this.spLay.angle}deg) scale(${this.spLay.scale.x * r}, ${this.spLay.scale.y * r})`, c(this, qr).cvsResize(), c(this, Hs).cvsResize();
  }
  get tategaki() {
    return c(this, es);
  }
  get infTL() {
    return c(this, wt);
  }
  get getWidth() {
    return c(this, wt).$width;
  }
  get getHeight() {
    return c(this, wt).$height;
  }
  setSize(e, r) {
    c(this, wt).$width = e, c(this, wt).$height = r, c(this, Xt).style.width = c(this, wt).$width + "px", c(this, Xt).style.height = c(this, wt).$height + "px";
  }
  goTxt(e, r) {
    var b, w, T;
    c(At, pn).visible = !1;
    let n = c(this, $s).length, s = "";
    if (n === 0) {
      if (c(At, ol).oCfg.debug.masume && (Y.debugLog && console.log(`🍌 masume ${this.name} v:${this.visible} l:${this.x} t:${this.y} a:${this.alpha} pl:${c(this, wt).pad_left} pr:${c(this, wt).pad_right} pt:${c(this, wt).pad_top} pb:${c(this, wt).pad_bottom} w:${c(this, wt).$width} h:${c(this, wt).$height}`), c(this, ts).clear().beginFill(3407616, 0.2).lineStyle(1, 3407616, 1).drawRect(-c(this, wt).pad_left, -c(this, wt).pad_top, c(this, wt).$width, c(this, wt).$height).endFill().beginFill(13311, 0.2).lineStyle(2, 13311, 1).drawRect(
        0,
        0,
        c(this, wt).$width - c(this, wt).pad_left - c(this, wt).pad_right,
        c(this, wt).$height - c(this, wt).pad_top - c(this, wt).pad_bottom
      ).endFill()), c(this, Xt).innerHTML = [...e].join("").replaceAll(/[\n\t]/g, "") + c(At, sf), !c(this, di)) {
        const x = globalThis.getComputedStyle(c(this, Xt)), S = parseFloat(x.fontSize);
        c(this, es) ? (P(this, Sr, (c(this, wt).$width - c(this, wt).pad_left - c(this, wt).pad_right - S * 1.5) * this.sys.cvsScale), P(this, Tr, 0)) : (P(this, Sr, 0), P(this, Tr, S / 2 * this.sys.cvsScale));
      }
    } else
      s = c(this, Xt).innerHTML, c(this, Xt).querySelectorAll(":scope > br").forEach((x) => c(this, Xt).removeChild(x)), c(this, Xt).insertAdjacentHTML(
        "beforeend",
        e.slice(c(this, ro)).join("").replaceAll(/[\n\t]/g, "") + c(At, sf)
        // 末尾改行削除挙動対策
      ), --n, (b = c(this, Xt).querySelector(".sn_ch_last")) == null || b.remove();
    P(this, ro, e.length);
    const a = this.sys.cvsScale, o = c(this, Xt).getBoundingClientRect(), u = o.left + c(this, wt).pad_left, l = o.top + c(this, wt).pad_top;
    let h;
    if (a === 1)
      h = (x, S) => new Nt(
        x.left - u,
        x.top - l,
        x.width,
        x.height + ("gjqy".includes(S) ? c(this, fl) : 0)
      );
    else {
      const x = this.sys.ofsPadLeft_Dom2PIXI + o.left * (1 - a), S = this.sys.ofsPadTop_Dom2PIXI + o.top * (1 - a);
      h = (C, M) => new Nt(
        (C.left - x) / a - u,
        (C.top - S) / a - l,
        C.width / a,
        (C.height + ("gjqy".includes(M) ? c(this, fl) : 0)) / a
      );
    }
    let d = 0, f = 2, p = !1;
    do {
      const x = P(this, $s, O(this, uf, U_).call(this, c(this, Xt), h));
      if (d = x.length, !p && (d < 2 || n === d)) {
        n > 0 && n === d && (c(this, Xt).innerHTML = s.replaceAll('class="sn_ch"', 'class="sn_ch sn_ch_in_default"'));
        break;
      }
      p = !0;
      let S = -1 / 0;
      for (; f < d; ++f) {
        const C = x[f];
        if (C.elm.tagName === "RT")
          continue;
        const M = this.tategaki ? C.rect.y : C.rect.x;
        if (S <= M || ((T = (w = C.elm.previousElementSibling) == null ? void 0 : w.children[0]) == null ? void 0 : T.tagName) === "BR") {
          S = M, c(this, di) || (P(this, Sr, C.rect.x), P(this, Tr, C.rect.y));
          continue;
        }
        let I = f - 1;
        for (; x[I].elm.tagName === "RT"; )
          --I;
        const R = x[I], N = R.ch;
        if (!c(this, di)) {
          P(this, Sr, R.rect.x), P(this, Tr, R.rect.y);
          const U = globalThis.getComputedStyle(R.elm), $ = parseFloat(U.fontSize);
          c(this, es) ? P(this, Tr, c(this, Tr) + $) : P(this, Sr, c(this, Sr) + $);
        }
        S = -1 / 0;
        const A = f;
        if (c(At, cl).test(N) && N === C.ch)
          f = I;
        else {
          if (c(At, no).test(N))
            f = I;
          else if (c(At, io).test(C.ch))
            for (f = I + 1; f > 0 && c(At, io).test(x[--f].ch); )
              ;
          else {
            ++f;
            continue;
          }
          for (f = I + 1; f > 0 && c(At, no).test(x[--f].ch); )
            ;
        }
        const G = x[f].elm.parentElement, B = document.createElement("br");
        if (G.classList.contains("sn_tx"))
          G.insertBefore(B, x[f].elm);
        else {
          const U = G.parentElement;
          U.classList.contains("sn_ch") ? U.parentElement.insertBefore(B, U) : U.insertBefore(B, G);
        }
        f += 2, f < A && (f = A), d = -1;
        break;
      }
    } while (d < 0);
    const v = Y.debugLog ? (x, S) => console.log(`🍌 masume ch:${x.ch} x:${S.x} y:${S.y} w:${S.width} h:${S.height}`) : () => {
    }, g = c(At, ol).oCfg.debug.masume ? (x, S) => {
      v(x, S), c(this, ts).beginFill(6737151, 0.5).lineStyle(2, 16724736, 1).drawRect(S.x, S.y, S.width, S.height).endFill();
    } : () => {
    }, m = ws.ease(c(this, Xs));
    for (let x = n; x < d; ++x) {
      const S = c(this, $s)[x], C = S.rect, M = JSON.parse(S.elm.dataset.arg ?? '{"delay": 0}'), I = JSON.parse(S.elm.dataset.add ?? "{}"), R = c(At, rs)[I.ch_in_style];
      if (g(S, C), S.elm.dataset.cmd === "grp") {
        const N = new ye();
        c(this, dn).addChild(N), Wt.csv2Sprites(M.pic, N, (A) => {
          O(this, af, G_).call(this, N, M, I, C, m, R ?? {}), N.parent || N.removeChild(A);
        });
      }
      if (S.elm.dataset.lnk) {
        const N = S.elm.parentElement.closest("[data-arg]"), A = JSON.parse(N.dataset.arg ?? "{}");
        A.key = `lnk=[${x}] ` + this.name;
        const G = new Ue();
        O(this, af, G_).call(this, G, A, I, C, m, R ?? {});
        const B = A.style ?? "", U = B + (A.style_hover ?? ""), $ = B + (A.style_clicked ?? ""), Z = A.r_style ?? "", H = Z + (A.r_style_hover ?? ""), z = Z + (A.r_style_clicked ?? ""), X = N.querySelectorAll("rt");
        X.forEach((et) => et.dataset.st_r_bk = et.style.cssText);
        const ct = N.style.cssText, it = (et, k) => {
          N.style.cssText = ct + et, X.forEach((ft) => ft.style.cssText = ft.dataset.st_r_bk + k);
        };
        vt(A, "enabled", !0) ? c(At, to).button(
          A,
          G,
          () => it(B, Z),
          () => this.canFocus() ? (it(U, H), !0) : !1,
          () => it($, z)
        ) : it(
          B + (A.style_disable ?? "color: gray;"),
          Z + (A.r_style_disable ?? "color: gray;")
        ), c(this, dn).addChild(G);
      }
    }
    const y = c(this, Xt).querySelectorAll("span.sn_ch");
    P(this, Vs, () => (P(this, Vs, () => !1), y.forEach((x) => x.className = x.className.replaceAll(/ go_ch_in_[^\s"]+/g, "")), c(At, pn).position.set(
      c(this, Sr),
      c(this, Tr)
    ), c(At, pn).visible = !0, c(At, to).noticeCompTxt(), !0)), y.forEach((x) => x.className = x.className.replaceAll(/sn_ch_in_([^\s"]+)/g, "go_ch_in_$1")), n > 0 && ++n;
    let _;
    for (let x = d - 2; x >= 0; --x) {
      const S = c(this, $s)[x];
      if (S.elm.tagName === "SPAN") {
        _ = S.elm;
        break;
      }
    }
    if (!_ || r || n === d) {
      c(this, Vs).call(this);
      return;
    }
    _.addEventListener("animationend", c(this, Vs), { once: !0, passive: !0 });
  }
  skipChIn() {
    let e = c(this, Vs).call(this);
    for (const r of c(this, hl))
      r.tw && (r.tw.stop().end(), e = !0);
    return P(this, hl, []), e;
  }
  static initChStyle() {
    P(At, rs, /* @__PURE__ */ Object.create(null)), P(At, is, /* @__PURE__ */ Object.create(null));
  }
  static getChInStyle(e) {
    return c(At, rs)[e];
  }
  static ch_in_style(e) {
    const { name: r } = e;
    if (!r)
      throw "nameは必須です";
    if (c(At, of).test(r))
      throw `name【${r}】に使えない文字が含まれます`;
    if (r in c(At, rs))
      throw `name【${r}】はすでにあります`;
    const n = String(e.x ?? "=0"), s = String(e.y ?? "=0");
    return c(At, rs)[r] = {
      wait: tt(e, "wait", 500),
      // アニメ・FI時間
      alpha: tt(e, "alpha", 0),
      x: n,
      // 初期x値
      y: s,
      // [tsy]と同様に絶対・相対指定可能
      // {x:500}			X位置を500に
      // {x:'=500'}		現在のX位置に+500加算した位置
      // {x:'=-500'}		現在のX位置に-500加算した位置
      // {x:'250,500'}	+250から＋500までの間でランダムな値をX位置に
      // {x:'=250,500'}	+250から＋500までの間でランダムな値を現在のX位置に加算
      nx: parseFloat(n.at(0) === "=" ? n.slice(1) : n),
      ny: parseFloat(s.at(0) === "=" ? s.slice(1) : s),
      scale_x: tt(e, "scale_x", 1),
      scale_y: tt(e, "scale_y", 1),
      rotate: tt(e, "rotate", 0),
      join: vt(e, "join", !0),
      // 文字を順番に出すか（true）同時か（false）
      ease: e.ease ?? "ease-out"
    };
  }
  static getChOutStyle(e) {
    return c(At, is)[e];
  }
  static ch_out_style(e) {
    const { name: r } = e;
    if (!r)
      throw "nameは必須です";
    if (c(At, of).test(r))
      throw `name【${r}】に使えない文字が含まれます`;
    if (r in c(At, is))
      throw `name【${r}】はすでにあります`;
    const n = String(e.x ?? "=0"), s = String(e.y ?? "=0");
    return c(At, is)[r] = {
      wait: tt(e, "wait", 500),
      // アニメ・FI時間
      alpha: tt(e, "alpha", 0),
      x: n,
      // 初期x値
      y: s,
      // [tsy]と同様に絶対・相対指定可能
      // {x:500}			X位置を500に
      // {x:'=500'}		現在のX位置に+500加算した位置
      // {x:'=-500'}		現在のX位置に-500加算した位置
      // {x:'250,500'}	+250から＋500までの間でランダムな値をX位置に
      // {x:'=250,500'}	+250から＋500までの間でランダムな値を現在のX位置に加算
      nx: parseFloat(n.at(0) === "=" ? n.slice(1) : n),
      ny: parseFloat(s.at(0) === "=" ? s.slice(1) : s),
      scale_x: tt(e, "scale_x", 1),
      scale_y: tt(e, "scale_y", 1),
      rotate: tt(e, "rotate", 0),
      join: vt(e, "join", !1),
      // 文字を順番に出すか（true）同時か（false）
      ease: e.ease ?? "ease-out"
    };
  }
  dispBreak(e) {
    const r = c(At, pn);
    r.visible = !1, this.addChild(r), Wt.csv2Sprites(e, r, (n) => {
      r.parent || r.removeChild(n);
    });
  }
  static delBreak() {
    const e = c(At, pn);
    e.parent && (e.parent.removeChild(e), e.removeChildren()), P(At, pn, new ye());
  }
  reNew() {
    var r;
    O(this, lf, j_).call(this);
    const e = new At(this.spLay, () => this.canFocus(), this.sys);
    return P(e, wt, c(this, wt)), c(e, Xt).style.cssText = c(this, Xt).style.cssText, P(e, Ai, c(this, Ai)), e.name = this.name, O(r = e, ul, Vp).call(r), c(e, qr).sethArg(c(this, qr).gethArg()), P(e, eo, c(this, eo)), P(e, Xs, c(this, Xs)), P(e, so, c(this, so)), P(e, di, c(this, di)), P(e, Sr, c(this, Sr)), P(e, Tr, c(this, Tr)), this.destroy(), e;
  }
  record() {
    return {
      infTL: c(this, wt),
      cssText: c(this, Xt).style.cssText,
      left: c(this, Ai),
      idc_hArg: c(this, qr).gethArg(),
      ch_filter: c(this, eo),
      fi_easing: c(this, Xs),
      fo_easing: c(this, so),
      break_fixed: c(this, di),
      break_fixed_left: c(this, Sr),
      break_fixed_top: c(this, Tr)
    };
  }
  playback(e) {
    P(this, wt, e.infTL), this.position.set(c(this, wt).pad_left, c(this, wt).pad_top), c(this, Xt).style.cssText = e.cssText, P(this, Ai, e.left), O(this, ul, Vp).call(this), c(this, qr).sethArg(e.idc_hArg), P(this, eo, e.ch_filter), P(this, Xs, e.fi_easing), P(this, so, e.fo_easing), P(this, di, e.break_fixed ?? !1), P(this, Sr, e.break_fixed_left ?? 0), P(this, Tr, e.break_fixed_top ?? 0);
  }
  snapshot(e, r) {
    O(this, bg, sM).call(this, (n) => {
      P(this, kr, new Ue(n)), c(this, es) && (c(this, kr).x += Y.stageW - (c(this, Ai) + c(this, wt).$width)), c(this, kr).y -= c(this, ll), c(this, kr).texture.frame = new Nt(
        0,
        0,
        Math.min(c(this, kr).width, c(this, wt).$width - c(this, Ai)),
        Math.min(c(this, kr).height, c(this, wt).$height)
      ), c(this, dn).addChild(c(this, kr)), e.render(c(this, kr), { clear: !1 }), r();
    }, !1);
  }
  snapshot_end() {
    c(this, kr) && (c(this, dn).removeChild(c(this, kr)), P(this, kr, void 0));
  }
  makeDesignCast(e) {
    e(c(this, qr));
    const r = c(this, qr).gethArg();
    c(this, Hs).sethArg({ ...r, ":id_dc": r[":id_tag"] + "_pad" }), e(c(this, Hs));
  }
  showDesignCast() {
    c(this, qr).visible = !0, c(this, Hs).visible = !0;
  }
  dump() {
    const e = [], r = c(this, Xt).style, n = r.length;
    for (let s = 0; s < n; ++s) {
      const a = r[s];
      e.push(`"${a}":"${r[a].replaceAll(/(["\\])/g, "\\$1")}"`);
    }
    return `"txt":"${c(this, Xt).textContent.replaceAll(/(["\\])/g, "\\$1")}", "style":{${e.join(",")}}`;
  }
  destroy() {
    At.delBreak(), c(this, Xt).parentElement.removeChild(c(this, Xt)), this.removeChild(c(this, dn)), this.removeChild(c(this, ts)), super.destroy();
  }
};
let De = At;
ol = new WeakMap(), rf = new WeakMap(), to = new WeakMap(), Xt = new WeakMap(), dn = new WeakMap(), ts = new WeakMap(), _g = new WeakMap(), qr = new WeakMap(), Hs = new WeakMap(), wt = new WeakMap(), di = new WeakMap(), Sr = new WeakMap(), Tr = new WeakMap(), ul = new WeakSet(), Vp = function() {
  const e = c(this, Xt).style, r = parseFloat(e.fontSize || "0");
  c(this, wt).fontsize = r, c(this, wt).pad_left = parseFloat(e.paddingLeft || "0"), c(this, wt).pad_right = parseFloat(e.paddingRight || "0"), c(this, wt).pad_top = parseFloat(e.paddingTop || "0"), c(this, wt).pad_bottom = parseFloat(e.paddingBottom || "0"), c(this, wt).$width = parseFloat(e.width || "0"), c(this, wt).$height = parseFloat(e.height || "0"), this.position.set(c(this, wt).pad_left, c(this, wt).pad_top), P(this, es, e.writingMode === "vertical-rl"), P(this, nf, 0), P(this, ll, 0);
  const n = e.lineHeight ?? "0";
  P(this, fl, c(this, es) ? 0 : (n.slice(-2) === "px" ? parseFloat(n) : r * parseFloat(n) - r) / 2);
}, Ai = new WeakMap(), es = new WeakMap(), nf = new WeakMap(), ll = new WeakMap(), bg = new WeakSet(), sM = function(e, r = !0) {
  const n = {
    escape: (m) => m.replaceAll(/([.*+?^${}()|\[\]\/\\])/g, "\\$1"),
    mimeType: (m) => {
      const y = l(m).toLowerCase();
      return s()[y] || "";
    },
    dataAsUrl: p,
    isDataUrl: h,
    resolveUrl: d,
    getAndEncode: f,
    asArray: (m) => {
      const y = [], _ = m.length;
      for (let b = 0; b < _; ++b)
        y.push(m[b]);
      return y;
    }
  };
  function s() {
    const m = "application/font-woff", y = "image/jpeg";
    return {
      woff: m,
      woff2: m,
      ttf: "application/font-truetype",
      eot: "application/vnd.ms-fontobject",
      png: "image/png",
      jpg: y,
      jpeg: y,
      gif: "image/gif",
      tiff: "image/tiff",
      svg: "image/svg+xml"
    };
  }
  const a = v(), o = g();
  function u(m) {
    return o.resolveAll().then((y) => {
      const _ = document.createElement("style");
      return m.appendChild(_), _.appendChild(document.createTextNode(y)), m;
    });
  }
  function l(m) {
    const y = /\.([^\.\/]*?)$/g.exec(m);
    return (y == null ? void 0 : y[1]) ?? "";
  }
  function h(m) {
    return m.search(/^(data:)/) !== -1;
  }
  function d(m, y) {
    const _ = document.implementation.createHTMLDocument(), b = _.createElement("base");
    _.head.appendChild(b);
    const w = _.createElement("a");
    return _.body.appendChild(w), b.href = y, w.href = m, w.href;
  }
  function f(m) {
    let y = 3e4;
    return new Promise(function(_) {
      const b = new XMLHttpRequest();
      b.onreadystatechange = w, b.ontimeout = T, b.responseType = "blob", b.timeout = y, b.open("GET", m, !0), b.send();
      function w() {
        if (b.readyState !== 4)
          return;
        if (b.status !== 200) {
          x("cannot fetch resource: " + m + ", status: " + b.status);
          return;
        }
        const S = new FileReader();
        S.onloadend = function() {
          const C = S.result.toString().split(/,/)[1];
          _(C);
        }, S.readAsDataURL(b.response);
      }
      function T() {
        x("timeout of " + y + "ms occured while fetching resource: " + m);
      }
      function x(S) {
        console.error(S), _("");
      }
    });
  }
  function p(m, y) {
    return "data:" + y + ";base64," + m;
  }
  function v() {
    const m = /url\(['"]?([^'"]+?)['"]?\)/g;
    return {
      inlineAll: w,
      shouldProcess: y
    };
    function y(T) {
      return T.search(m) !== -1;
    }
    function _(T) {
      const x = [];
      let S;
      for (; S = m.exec(T); )
        x.push(S[1]);
      return x.filter(function(C) {
        return !n.isDataUrl(C);
      });
    }
    function b(T, x, S, C) {
      return Promise.resolve(x).then((I) => S ? n.resolveUrl(I, S) : I).then(C || n.getAndEncode).then((I) => n.dataAsUrl(I, n.mimeType(x))).then((I) => T.replace(M(x), "$1" + I + "$3"));
      function M(I) {
        return new RegExp(`(url\\(['"]?)(` + n.escape(I) + `)(['"]?\\))`, "g");
      }
    }
    function w(T, x, S) {
      if (C())
        return Promise.resolve(T);
      return Promise.resolve(T).then(_).then((M) => {
        let I = Promise.resolve(T);
        for (const R of M)
          I = I.then((N) => b(N, R, x, S));
        return I;
      });
      function C() {
        return !y(T);
      }
    }
  }
  function g() {
    return {
      resolveAll: m,
      impl: { readAll: y }
    };
    function m() {
      return y().then((_) => Promise.allSettled(
        _.map((b) => b.resolve())
      )).then((_) => _.join(`
`));
    }
    function y() {
      return Promise.resolve(n.asArray(document.styleSheets)).then(b).then(_).then((T) => T.map(w));
      function _(T) {
        return T.filter((x) => x.type === CSSRule.FONT_FACE_RULE).filter((x) => a.shouldProcess(x.style.getPropertyValue("src")));
      }
      function b(T) {
        const x = [];
        for (const S of T)
          try {
            if (S.href)
              continue;
            n.asArray(S.cssRules || []).forEach(x.push.bind(x));
          } catch (C) {
            console.error("Error while reading CSS rules from " + S.href, C.toString());
          }
        return x;
      }
      function w(T) {
        return {
          resolve: function() {
            const S = (T.parentStyleSheet || {}).href;
            return a.inlineAll(T.cssText, S);
          },
          src: function() {
            return T.style.getPropertyValue("src");
          }
        };
      }
    }
  }
  Promise.resolve(c(this, Xt)).then((m) => {
    const y = m.cloneNode(!0);
    return y.style.padding = "0px", y.style.paddingRight = c(this, nf) + "px", y.style.paddingTop = c(this, ll) + "px", y.style.left = "0px", y.style.top = "0px", y.style.width = c(this, wt).$width - c(this, wt).pad_left - c(this, wt).pad_right + "px", y.style.height = c(this, wt).$height - c(this, wt).pad_top - c(this, wt).pad_bottom + "px", c(this, Xt).hidden = r, y;
  }).then(u).then((m) => {
    m.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
    const y = new Image();
    return y.src = `data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="${c(this, wt).$width}px" height="${c(this, wt).$height}px"><foreignObject x="0" y="0" width="100%" height="100%">${new XMLSerializer().serializeToString(m).replaceAll("#", "%23").replaceAll(`
`, "%0A")}</foreignObject></svg>`, new Promise((_) => y.onload = () => _(y));
  }).then((m) => new Promise((y) => setTimeout(() => y(m), 100))).then((m) => {
    const y = document.createElement("canvas");
    y.width = c(this, wt).$width, y.height = c(this, wt).$height, y.getContext("2d").drawImage(m, 0, 0), y.toBlob((_) => {
      if (!_)
        return;
      const b = URL.createObjectURL(_);
      Ot.from(b).once("update", (w) => {
        e(w), URL.revokeObjectURL(b);
      });
    });
  }).catch((m) => zt.myTrace(`goTxt() = ${m}`));
}, eo = new WeakMap(), hl = new WeakMap(), $s = new WeakMap(), ro = new WeakMap(), io = new WeakMap(), no = new WeakMap(), cl = new WeakMap(), sf = new WeakMap(), Vs = new WeakMap(), af = new WeakSet(), G_ = function(e, r, n, s, a, o) {
  e.alpha = 0, r.x && (s.x = r.x.at(0) === "=" ? s.x + parseInt(r.x.slice(1)) : parseInt(r.x)), r.y && (s.y = r.y.at(0) === "=" ? s.y + parseInt(r.y.slice(1)) : parseInt(r.y)), r.width && (s.width = parseInt(r.width)), r.height && (s.height = parseInt(r.height)), r.wait && (o.wait = parseInt(r.wait)), e.width = s.width, e.height = s.height, o.x ? e.position.set(
    o.x.at(0) === "=" ? s.x + e.width * o.nx : o.nx,
    o.y.at(0) === "=" ? s.y + e.height * o.ny : o.ny
  ) : e.position.set(s.x, s.y);
  const u = {
    sp: e,
    tw: new Tn(e).to({ alpha: 1, x: s.x, y: s.y, width: s.width, height: s.height, angle: 0 }, o.wait ?? 0).easing(a).delay((n.wait ?? 0) + (r.delay ?? 0)).onComplete(() => {
      u.tw = void 0;
    }).start()
  };
  c(this, hl).push(u);
}, rs = new WeakMap(), of = new WeakMap(), is = new WeakMap(), pn = new WeakMap(), fl = new WeakMap(), uf = new WeakSet(), U_ = function(e, r) {
  const n = [];
  if (e.nodeType !== e.TEXT_NODE)
    return Array.from(e.childNodes).map((u) => O(this, uf, U_).call(this, u, r)).flat();
  const s = e.ownerDocument.createRange();
  s.selectNodeContents(e);
  let a = 0;
  const o = s.endOffset;
  for (; a < o; ) {
    s.setStart(e, a), s.setEnd(e, ++a);
    const u = s.toString();
    n.push({
      ch: u,
      rect: r(s.getBoundingClientRect(), u),
      elm: s.startContainer.parentElement
    });
  }
  return s.detach(), n;
}, Xs = new WeakMap(), so = new WeakMap(), lf = new WeakSet(), j_ = function() {
  var a;
  c(this, ts).clear(), P(this, $s, []), P(this, ro, 0), this.skipChIn();
  const e = c(this, Xt).cloneNode(!0);
  e.textContent = "";
  const r = c(this, Xt);
  r.parentElement.insertBefore(e, r);
  let n = 0;
  r.querySelectorAll("span.sn_ch").forEach((o) => {
    var h, d, f;
    const u = JSON.parse(
      (o == null ? void 0 : o.dataset.add) ?? // 通常文字
      ((h = o == null ? void 0 : o.children[0]) == null ? void 0 : h.getAttribute("data-add")) ?? // ルビ
      ((f = (d = o == null ? void 0 : o.children[0]) == null ? void 0 : d.children[0]) == null ? void 0 : f.getAttribute("data-add")) ?? "{}"
      // 縦中横
    );
    if (!u.ch_out_style)
      return;
    const l = c(At, is)[u.ch_out_style];
    if (l) {
      if (l.wait === 0) {
        o.style.display = "none";
        return;
      }
      n += l.wait, l.join || (o.style.animationDelay = "0ms"), o.classList.add(`go_ch_out_${u.ch_out_style}`);
    }
  });
  const s = () => {
    r.parentElement.removeChild(r);
    for (const o of c(this, dn).removeChildren())
      o instanceof ye && c(At, to).unButton(o), o.destroy();
  };
  n === 0 ? (c(this, Xt).textContent = "", s()) : (a = r.lastElementChild) == null || a.addEventListener("animationend", s, { once: !0, passive: !0 }), P(this, Xt, e);
}, kr = new WeakMap(), E(De, ol, void 0), E(De, rf, void 0), E(De, to, void 0), E(De, _g, {
  "background-color": 0,
  "border-bottom-width": 0,
  "border-left-width": 0,
  "border-right-width": 0,
  "border-top-width": 0,
  "margin-bottom": 0,
  "margin-left": 0,
  "margin-right": 0,
  "margin-top": 0
}), E(De, io, void 0), E(De, no, void 0), E(De, cl, void 0), E(De, sf, "<span class='sn_ch sn_ch_last'>　</span>"), E(De, rs, /* @__PURE__ */ Object.create(null)), E(De, of, /[\s\.,]/), E(De, is, /* @__PURE__ */ Object.create(null)), E(De, pn, new ye());
var ao, vn, hf;
const As = class {
  constructor() {
    E(this, vn, () => {
    });
  }
  static setting(t) {
    t.sesame && P(As, ao, t.sesame);
  }
  static getSesame() {
    return c(As, ao);
  }
  static destroy() {
    P(As, ao, "ヽ");
  }
  init(t) {
    P(this, vn, t);
  }
  static setEscape(t) {
    P(As, hf, new RegExp(
      `${t ? `(?<ce>\\${t}\\S)|` : ""}｜(?<str>[^《\\n]+)《(?<ruby>[^》\\n]+)》|(?:(?<kan>[⺀-⿟々〇〻㐀-鿿豈-﫿]+[ぁ-ヿ]*|[^　｜《》\\n])《(?<kan_ruby>[^》\\n]+)》)|(?<txt>[\uD800-\uDBFF][\uDC00-\uDFFF]|[^｜《》]+?|.)`,
      "gs"
    ));
  }
  putTxt(t) {
    for (const { groups: e } of t.matchAll(c(As, hf))) {
      const { ruby: r, kan_ruby: n, kan: s, ce: a, txt: o = "", str: u } = e;
      if (r) {
        this.putTxtRb(decodeURIComponent(u), r);
        continue;
      }
      if (n) {
        this.putTxtRb(s, n);
        continue;
      }
      if (a) {
        c(this, vn).call(this, a.slice(1), "");
        continue;
      }
      for (const l of Array.from(o))
        c(this, vn).call(this, l, "");
    }
  }
  putTxtRb(t, e) {
    if (/^\w+｜{"/.test(e)) {
      c(this, vn).call(this, t, e);
      return;
    }
    const r = Array.from(t), n = r.length;
    if (/^\*.?$/.test(e)) {
      const u = "center｜" + (e === "*" ? c(As, ao) : e.charAt(1));
      for (let l = 0; l < n; ++l)
        c(this, vn).call(this, r[l], u);
      return;
    }
    if (n === 1 || e.indexOf(" ") === -1) {
      c(this, vn).call(this, t, decodeURIComponent(e));
      return;
    }
    const s = e.split(" "), a = s.length, o = a > n ? a : n;
    for (let u = 0; u < o; ++u)
      c(this, vn).call(this, u < n ? r[u] : "", u < a ? decodeURIComponent(s[u]) : "");
  }
};
let ua = As;
ao = new WeakMap(), vn = new WeakMap(), hf = new WeakMap(), E(ua, ao, "ヽ"), /*
		★Unicodeで「漢字」の正規表現 – ものかの http://tama-san.com/kanji-regex/
		2E80..2FDF CJK部首補助＋康熙部首
		3005 々（漢字の踊り字）
		3007 〇（漢数字のゼロ）
		303B 〻（漢字の踊り字）
		3400..4DBF CJK統合漢字拡張A
		4E00..9FFF CJK統合漢字
		F900..FAFF CJK互換漢字
		20000..2FFFF CJK統合漢字拡張B〜F＋CJK互換漢字追加＋念のためU+2FFFFまで

		[\x{2E80}-\x{2FDF}々〇〻\x{3400}-\x{4DBF}\x{4E00}-\x{9FFF}\x{F900}-\x{FAFF}\x{20000}-\x{2FFFF}]
		[\u2E80-\u2FDF々〇〻\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\u20000-\u2FFFF]
		[⺀-⿟々〇〻㐀-䶿一-鿿豈-﫿\u20000-\u2FFFF]		// 含まれない文字がある
		[⺀-⿟々〇〻㐀-鿿豈-﫿\u20000-\u2FFFF]			// ヽ--30FD が変に引っかかる。多分\u2000-\u2FFF解釈
		\\u{20000}-\\u{2FFFF}	// 五桁だとエラー

		【2022/10/03】ruby正規表現のUnicode プロパティ(とPOSIX文字クラス) - Qiita https://qiita.com/Takayuki_Nakano/items/8d38beaddb84b488d683
			> このHiraganaプロパティ、長音記号は含まれていません。
			> \p{Han}…簡体字や繁体字、韓国語の漢字…ベトナム語の漢字にもマッチ
		
		・Unicode文字一覧表 - instant tools https://tools.m-bsys.com/ex/unicode_table.php
*/
E(ua, hf, void 0);
var cf, ff, Li, ns, dl, pl, df, z_, vl, gl, pf, H_;
const La = class extends ye {
  constructor(e, r, n, s) {
    var v;
    super();
    E(this, df);
    E(this, pf);
    K(this, "getBtnBounds", () => c(this, Li));
    // 文字ボタンは背景画像を含まない位置指定なので、その当たり判定用
    E(this, Li, new Nt());
    E(this, ns, void 0);
    E(this, dl, void 0);
    E(this, pl, void 0);
    K(this, "normal", () => {
    });
    E(this, vl, () => !1);
    E(this, gl, () => {
    });
    this.hArg = e, this.evtMng = r, this.resolve = n, this.canFocus = s, Y.isDbg && (this.makeDesignCast = (g) => g(c(this, ns)), this.cvsResize = () => c(this, ns).cvsResize());
    let a = {
      x: this.x = ii(e.left ?? 0),
      y: this.y = ii(e.top ?? 0),
      rotation: this.angle = tt(e, "rotation", this.angle),
      // flash : rotation is in degrees.
      // pixijs: rotation is in radians, angle is in degrees.
      pivot_x: this.pivot.x = tt(e, "pivot_x", this.pivot.x),
      pivot_y: this.pivot.y = tt(e, "pivot_y", this.pivot.y),
      scale_x: this.scale.x = tt(e, "scale_x", this.scale.x),
      scale_y: this.scale.y = tt(e, "scale_y", this.scale.y),
      width: 0,
      height: 0
    };
    this.getBtnBounds = () => (c(this, Li).x = a.x, c(this, Li).y = a.y, c(this, Li));
    const o = a.enabled = vt(e, "enabled", !0);
    if (o && r.button(this.hArg, this, () => this.normal(), () => c(this, vl).call(this), () => c(this, gl).call(this)), e.pic) {
      a.type = "pic", P(this, ns, new W3(this, e)), Wt.csv2Sprites(
        e.pic,
        this,
        (g) => {
          O(this, pf, H_).call(this, g, a), c(this, Li).width = g.width * a.scale_x, c(this, Li).height = g.height * a.scale_y;
        },
        (g) => n
      );
      return;
    }
    if (!e.text)
      throw "textまたはpic属性は必須です";
    const u = tt(e, "height", 30), l = new Jo({
      align: "center",
      dropShadow: !0,
      dropShadowAlpha: 0.7,
      dropShadowColor: "white",
      dropShadowBlur: 7,
      dropShadowDistance: 0,
      fill: o ? "black" : "gray",
      fontFamily: La.fontFamily,
      fontSize: u,
      padding: 5
    });
    if (e.style)
      try {
        const g = JSON.parse(e.style);
        for (const [m, y] of Object.entries(g))
          l[m] = y;
      } catch (g) {
        throw new Error(Tp(e, "style", g.message));
      }
    const h = new ex(e.text ?? "", l);
    h.alpha = tt(e, "alpha", h.alpha), h.width = tt(e, "width", 100), h.height = e.height = u, this.setText = (g) => h.text = g, a.type = "text", a = { ...a, ...l }, a.alpha = h.alpha, a.text = h.text, a.width = h.width, a.height = h.height, P(this, ns, new X3(this, e, h));
    let d = !1;
    if (a.width = this.width, a.height = this.height, e.b_pic && (a.b_pic = e.b_pic, d = Wt.csv2Sprites(
      e.b_pic,
      this,
      (g) => {
        O(this, df, z_).call(this, g, h), a.width = this.width, a.height = this.height;
      },
      (g) => {
        _r.setBlendmode(this, e), g && n();
      }
    )), h.name = JSON.stringify(a), this.addChild(h), c(this, Li).width = h.width, c(this, Li).height = h.height, e.b_pic || _r.setBlendmode(this, e), c(v = La, cf).call(v, this, h), !o) {
      d || n();
      return;
    }
    const f = l.clone();
    if (e.style_hover)
      try {
        const g = JSON.parse(e.style_hover);
        for (const [m, y] of Object.entries(g))
          f[m] = y;
      } catch (g) {
        throw new Error(Tp(e, "style_hover", g.message));
      }
    else
      f.fill = "white";
    const p = f.clone();
    if (e.style_clicked)
      try {
        const g = JSON.parse(e.style_clicked);
        for (const [m, y] of Object.entries(g))
          p[m] = y;
      } catch (g) {
        throw new Error(Tp(e, "style_clicked", g.message));
      }
    else
      p.dropShadow = !1;
    this.normal = () => h.style = l, P(this, vl, () => s() ? (h.style = f, !0) : !1), P(this, gl, () => h.style = p), d || n();
  }
  static init(e) {
    e.oCfg.debug.masume && (P(La, cf, (r, n) => r.addChild(
      new si().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(n.x, n.y, n.width, n.height).endFill()
    )), P(La, ff, (r, n, s, a) => r.addChild(
      new si().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(n.x, n.y, s, a).endFill()
    )));
  }
  setText(e) {
  }
  destroy(e) {
    this.evtMng.unButton(this), super.destroy();
  }
  makeDesignCast(e) {
  }
  showDesignCast() {
    c(this, ns).visible = !0;
  }
  cvsResize() {
  }
  update_b_pic(e, r) {
    const n = JSON.parse(r.name ?? "{}");
    c(this, dl) && this.removeChild(c(this, dl)), this.hArg.b_pic = n.b_pic = e, r.name = JSON.stringify(n), e && Wt.csv2Sprites(
      e,
      this,
      (s) => O(this, df, z_).call(this, s, r),
      () => _r.setBlendmode(this, this.hArg)
    );
  }
  update_pic(e, r) {
    const n = JSON.parse(r.name ?? "{}");
    c(this, pl) && this.removeChild(c(this, pl)), this.hArg.pic = n.pic = e, r.name = JSON.stringify(n), e && Wt.csv2Sprites(
      e,
      this,
      (s) => O(this, pf, H_).call(this, s, n),
      () => _r.setBlendmode(this, this.hArg)
    );
  }
};
let Yi = La;
cf = new WeakMap(), ff = new WeakMap(), Li = new WeakMap(), ns = new WeakMap(), dl = new WeakMap(), pl = new WeakMap(), df = new WeakSet(), z_ = function(e, r) {
  P(this, dl, e), this.setChildIndex(e, 0), e.alpha = r.alpha, e.setTransform(
    r.x,
    r.y,
    1,
    1,
    r.rotation,
    0,
    0,
    (e.width - r.width) / 2,
    (e.height - r.height) / 2
  ), e.name = r.name;
}, vl = new WeakMap(), gl = new WeakMap(), pf = new WeakSet(), H_ = function(e, r) {
  var d;
  P(this, pl, e), r.alpha = e.alpha = tt(this.hArg, "alpha", e.alpha), c(this, ns).setSp(e);
  const n = e.width / 3, s = e.height, a = e.texture.baseTexture, o = new Ot(a, new Nt(0, 0, n, s)), u = new Ot(a, new Nt(n, 0, n, s)), l = new Ot(a, new Nt(n * 2, 0, n, s)), h = () => e.texture = o;
  h(), this.normal = h, P(this, vl, () => this.canFocus() ? (e.texture = l, !0) : !1), P(this, gl, () => e.texture = u), "width" in this.hArg ? (r.width = ii(this.hArg.width), this.scale.x *= r.width / n) : r.width = n, "height" in this.hArg ? (r.height = ii(this.hArg.height), this.scale.y *= r.height / s) : r.height = s, e.name = JSON.stringify(r), c(d = La, ff).call(d, this, e, n, s);
}, K(Yi, "fontFamily", "'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif"), E(Yi, cf, (e, r) => {
}), E(Yi, ff, (e, r, n, s) => {
});
var ml, Bi, vf, yl, gf, $_, mf, V_, yf, oo, _f, ss, uo, xg, aM, as, pi, Fi, ce, gn, re, bf, mn, wg, Nr, lo, Nh, ho, _l, co, Ah, bl, xf, X_, wf, W_, fo, po, xl, Ef, wl, Ws, Ar, Eg, oM, Zr, Sf, El, Xp, os, Pa, yn, Gi, vi, gi, Tf, Y_, Sl, Wp, Cf, q_, vo;
const Bt = class extends _r {
  constructor() {
    super();
    E(this, lo);
    E(this, co);
    E(this, xf);
    E(this, wf);
    E(this, Eg);
    E(this, El);
    E(this, os);
    E(this, Tf);
    E(this, Sl);
    E(this, Cf);
    // バック
    E(this, as, 0);
    E(this, pi, 0);
    E(this, Fi, !1);
    E(this, ce, void 0);
    E(this, gn, "");
    // 背景画像無し（＝単色塗り）
    // 文字表示
    E(this, re, new De(this.spLay, () => this.canFocus(), c(Bt, _f)));
    E(this, bf, new ua());
    E(this, mn, document.createElement("span"));
    E(this, Nr, new ye());
    E(this, ho, "");
    E(this, _l, !0);
    E(this, bl, "");
    E(this, fo, "");
    E(this, po, (e) => "");
    E(this, xl, "");
    E(this, Ef, new RegExp("[　]"));
    K(this, "isCur", !1);
    E(this, Ws, () => "");
    E(this, Ar, "");
    E(this, Zr, !1);
    E(this, Sf, (e, r) => {
      var l, h, d;
      c(Bt, ml).oCfg.debug.putCh && console.log(`🖊 文字表示 text:\`${e}\` ruby:\`${r}\` name:\`${this.name_}\``);
      const n = r.split("｜");
      let s = "";
      const [a, ...o] = n, u = o.join("｜");
      switch (n.length) {
        case 1:
          if (P(this, Zr, !0), e === `
`) {
            c(this, Gi) ? (P(this, Gi, !1), s = "<ruby>　<rt>　</rt></ruby><br/>") : s = "<br/>";
            break;
          }
          c(this, Gi) && (P(this, Gi, !1), r === "" && (r = "　")), s = O(this, El, Xp).call(this, e, r, c(this, Ar));
          break;
        default:
          switch (a) {
            case "start":
            case "left":
            case "center":
            case "right":
            case "justify":
            case "121":
            case "even":
            case "1ruby":
              P(this, Gi, !1), P(this, Zr, !0), s = O(this, El, Xp).call(this, e, u, a);
              break;
            case "gotxt":
              O(this, Sl, Wp).call(this), c(this, Zr) ? (this.isCur && c(Bt, yl).recText(
                c(this, vi).join("").replace(/^<ruby>　<rt>　<\/rt><\/ruby>(<br\/>)+/, "").replaceAll(/style='(anim\S+ \S+?;\s*)+/g, "style='").replaceAll(/( style=''| data-(add|arg|cmd)='.+?'|\n+|\t+)/g, "").replaceAll(/class='sn_ch .+?'/g, "class='sn_ch'").replaceAll("display: none;", "").replaceAll("class='offrec'", "style='display: none;'")
                // 囲んだ領域は履歴で非表示
              ), c(this, re).goTxt(c(this, vi), c(this, yn) === 0), P(this, Zr, !1), P(this, yn, 0)) : this.isCur && c(Bt, oo).noticeCompTxt();
              return;
            case "add":
              {
                const f = JSON.parse(u), { style: p = "", wait: v = null } = f, { cl: g, sty: m } = O(this, os, Pa).call(this, !0, v);
                c(this, vi).push(`<span${g} style='${m} display: inline; ${p}'>`), delete f.style, O(this, Tf, Y_).call(this, f);
              }
              return;
            case "add_close":
              c(this, vi).push("</span>"), O(this, Sl, Wp).call(this);
              return;
            case "grp":
              P(this, Zr, !0);
              {
                const f = JSON.parse(u);
                if (f.id ?? (f.id = c(this, vi).length), f.id === "break") {
                  c(this, re).dispBreak(f.pic);
                  return;
                }
                P(this, Gi, !1), f.delay = c(this, yn), f.r ?? (f.r = ""), f.style ?? (f.style = ""), f.r_style ?? (f.r_style = "");
                const { cl: p, sty: v, lnk: g } = O(this, os, Pa).call(this, !0, f.wait);
                s = `<span${p} style='${v} ${f.style}'><ruby><span data-cmd='grp' data-arg='${JSON.stringify(f)}'${g} style='${v} display: inline;'>　</span><rt${g}${this.mkStyle_r_align(
                  "　",
                  f.r,
                  c(this, Ar),
                  c(this, mn).style.cssText + (((l = c(this, gi).at(-1)) == null ? void 0 : l.o.r_style) ?? "") + f.r_style
                )}>${f.r}</rt></ruby></span>`;
              }
              break;
            case "tcy":
              P(this, Gi, !1), P(this, Zr, !0);
              {
                c(Bt, Bi).doRecLog() && P(this, vo, c(this, vo) + (e + (r ? `《${r}》` : "")));
                const { t: f, r: p = "", wait: v = null, style: g = "", r_style: m = "" } = JSON.parse(u), y = Y.isSafari ? p.replaceAll(/[A-Za-z0-9]/g, (T) => String.fromCharCode(T.charCodeAt(0) + 65248)) : p, { cl: _, sty: b, lnk: w } = O(this, os, Pa).call(this, !0, v);
                s = `<span${_} style='${b}${c(this, po).call(this, f)} ${g}'><ruby><span${w} style='${b} display: inline;
text-combine-upright: all;
-webkit-text-combine: horizontal;'>${f}</span><rt${w}${this.mkStyle_r_align(
                  f,
                  y,
                  c(this, Ar),
                  c(this, mn).style.cssText + (((h = c(this, gi).at(-1)) == null ? void 0 : h.o.r_style) ?? "") + m
                )}>${y}</rt></ruby></span>`;
              }
              break;
            case "del":
              De.delBreak();
              return;
            case "span":
              P(this, Zr, !0), O(this, Cf, q_).call(this, JSON.parse(u));
              return;
            case "link":
              P(this, Zr, !0);
              {
                const f = JSON.parse(u);
                f[":link"] = " data-lnk='@'";
                const { cl: p, sty: v, curpos: g } = O(this, os, Pa).call(this, !1, f.wait);
                c(this, vi).push(`<span${p} style='${v} display: inline; ${f.style ?? ""}' ${g} data-arg='${u}'>`), delete f.style, O(this, Cf, q_).call(this, f);
              }
              return;
            case "endlink":
              P(this, Zr, !0), c(this, vi).push("</span>"), O(this, Sl, Wp).call(this);
              return;
            default:
              P(this, Zr, !0), s = O(this, El, Xp).call(this, e, r, c(this, Ar));
          }
          break;
      }
      c(this, vi).push(c(d = Bt, wl).call(d, s));
    });
    E(this, yn, 0);
    E(this, Gi, !0);
    E(this, vi, []);
    E(this, gi, []);
    K(this, "click", () => !this.spLay.interactiveChildren || !this.spLay.visible ? !1 : c(this, re).skipChIn());
    E(this, vo, "");
    K(this, "addButton", (e) => new Promise((r) => {
      e.key = `btn=[${c(this, Nr).children.length}] ` + this.name_, e[":id_tag"] = e.key.slice(0, -7), vt(e, "hint_tate", c(this, re).tategaki);
      const n = new Yi(e, c(Bt, oo), () => r(), () => this.canFocus());
      n.name = JSON.stringify(e).replaceAll('"', "'"), c(this, Nr).addChild(n);
    }));
    K(this, "record", () => ({
      ...super.record(),
      enabled: this.enabled,
      r_cssText: c(this, mn).style.cssText,
      r_align: c(this, Ar),
      // バック
      b_do: c(this, ce) === void 0 ? void 0 : c(this, ce) instanceof Ue ? "Sprite" : "Graphics",
      b_pic: c(this, gn),
      b_color: c(this, as),
      b_alpha: c(this, pi),
      b_alpha_isfixed: c(this, Fi),
      ffs: c(this, fo),
      txs: c(this, re).record(),
      strNoFFS: c(this, xl),
      btns: c(this, Nr).children.map((e) => e.name)
    }));
    this.spLay.addChild(c(this, re)), c(this, bf).init(c(this, Sf)), this.spLay.addChild(c(this, Nr)), c(this, Nr).name = "cntBtn";
    const e = 16;
    this.lay({ style: `width: ${Y.stageW}px; height: ${Y.stageH}px; font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif; color: white; font-size: 24px; line-height: 1.5; padding: ${e}px;`, in_style: "default", out_style: "default", back_clear: "true" });
  }
  static init(e, r, n, s, a, o) {
    var u, l;
    P(Bt, ml, e), De.init(e, o), P(Bt, Bi, n), P(Bt, yl, s), P(Bt, vf, a), n.setDoRecProc(Bt.chgDoRec), r.autowc = (h) => {
      var d;
      return O(d = Bt, xg, aM).call(d, h);
    }, r.autowc({ enabled: !1, text: "", time: 0 }), r.ch_in_style = (h) => {
      var d;
      return O(d = Bt, gf, $_).call(d, h);
    }, r.ch_out_style = (h) => {
      var d;
      return O(d = Bt, mf, V_).call(d, h);
    }, De.initChStyle(), tO(), Au(
      e.matchPath(".+", vr.FONT).flatMap((h) => Object.values(h).map((d) => `
@font-face {
	font-family: '${d}';
	src: url('${c(this, ml).searchPath(d, vr.FONT)}');
}
`)).join("") + `
.sn_tx {
	pointer-events: none;
	user-select: none;
	-webkit-touch-callout: none;
	box-sizing: border-box;
}
.sn_ch {
	position: relative;
	display: inline-block;
}
`
      // 「sn_ch」と「sn_ch_in_〜」の中身が重複しているが、これは必須
    ), O(u = Bt, gf, $_).call(u, {
      name: "default",
      wait: 500,
      alpha: 0,
      x: "=0.3",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: !0,
      ease: "ease-out"
    }), O(l = Bt, mf, V_).call(l, {
      name: "default",
      wait: 0,
      alpha: 0,
      x: "=0",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: !1,
      ease: "ease-out"
    });
  }
  static setEvtMng(e, r, n) {
    P(Bt, yf, e), P(Bt, oo, r), P(Bt, _f, n), De.setEvtMng(r);
  }
  destroy() {
    c(this, ce) && (this.spLay.removeChild(c(this, ce)).destroy(), P(this, ce, void 0)), this.clearText(), c(this, re).destroy();
  }
  static destroy() {
    P(Bt, ss, !1), P(Bt, uo, {}), P(Bt, wl, (e) => e);
  }
  set name(e) {
    this.name_ = e, c(this, re).name = e;
  }
  get name() {
    return this.name_;
  }
  // getは継承しないらしい
  cvsResize() {
    c(this, re).cvsResize();
  }
  cvsResizeChildren() {
    for (const e of c(this, Nr).children)
      e.cvsResize();
  }
  lay(e) {
    if (super.lay(e), _r.setXY(this.spLay, e, this.spLay), e[":id_tag"] = this.name_.slice(0, -7), ua.setting(e), O(this, wf, W_).call(this, e), c(this, re).lay(e), "r_align" in e && P(this, Ar, e.r_align ?? ""), P(this, Ws, Y.isSafari ? c(this, re).tategaki ? (r, n) => `text-align: start; height: ${n}em; padding-top: ${r}; padding-bottom: ${r};` : (r, n) => `text-align: start; width: ${n}em; padding-left: ${r}; padding-right: ${r};` : c(this, re).tategaki ? (r) => `text-align: justify; text-align-last: justify; padding-top: ${r}; padding-bottom: ${r};` : (r) => `text-align: justify; text-align-last: justify; padding-left: ${r}; padding-right: ${r};`), Y.isFirefox && (this.mkStyle_r_align = O(this, Eg, oM)), "r_style" in e)
      if (e.r_style) {
        const r = document.createElement("span");
        r.style.cssText = e.r_style;
        const n = r.style.length, s = c(this, mn).style;
        for (let a = 0; a < n; ++a) {
          const o = r.style[a];
          if (o in c(Bt, wg)) {
            zt.myTrace(`${o}は指定できません`, "W");
            continue;
          }
          s[o] = r.style[o];
        }
      } else
        c(this, mn).style.cssText = "";
    if ("alpha" in e)
      for (const r of c(this, Nr).children)
        r.alpha = this.spLay.alpha;
    return O(this, lo, Nh).call(this, e), O(this, co, Ah).call(this, e), O(this, xf, X_).call(this, e, (r) => {
      r && c(Bt, yf).resume();
    });
  }
  get width() {
    return c(this, re).getWidth;
  }
  get height() {
    return c(this, re).getHeight;
  }
  chgBackAlpha(e) {
    const r = c(this, Fi) ? c(this, pi) : e * c(this, pi);
    c(this, ce) instanceof si && (c(this, ce) && (this.spLay.removeChild(c(this, ce)), c(this, ce).destroy()), this.spLay.addChildAt(
      P(this, ce, new si()).beginFill(c(this, as)).lineStyle(void 0).drawRect(0, 0, c(this, re).getWidth, c(this, re).getHeight).endFill(),
      0
    ), c(this, ce).name = "back(color)"), c(this, ce) && (c(this, ce).visible = r > 0, c(this, ce).alpha = r);
  }
  // Safariが全体に「font-feature-settings」した後、特定文字の「font-feature-settings: initial;」を受け付けてくれないのでわざわざ一つずつ指定
  static chgDoRec(e) {
    P(Bt, wl, e ? (r) => r : (r) => `<span class='offrec'>${r}</span>`);
  }
  mkStyle_r_align(e, r, n, s = "") {
    if (!n)
      return ` style='${s}'`;
    const a = e.length * 2;
    if (a - r.length < 0)
      return ` style='text-align: ${n}; ${s}'`;
    let o = "";
    switch (n) {
      case "justify":
        o = c(this, Ws).call(this, "0", a);
        break;
      case "121":
        o = c(this, Ws).call(this, `calc(${(a - r.length) / (r.length * 2)}em)`, a);
        break;
      case "even":
        o = c(this, Ws).call(this, `calc(${(a - r.length) / (r.length + 1)}em)`, a);
        break;
      case "1ruby":
        o = c(this, Ws).call(this, "1em", a);
        break;
      default:
        o = `text-align: ${n};`;
    }
    return ` style='${o} ${s}'`;
  }
  tagCh(e) {
    c(this, bf).putTxt(e);
  }
  clearText() {
    this.spLay.addChild(P(this, re, c(this, re).reNew())), P(this, yn, 0), P(this, Gi, !0), P(this, vi, []), P(this, vo, ""), c(Bt, yl).recPagebreak();
  }
  get pageText() {
    return c(this, vo).replace("《　》", "");
  }
  get enabled() {
    return this.spLay.interactiveChildren;
  }
  set enabled(e) {
    this.spLay.interactiveChildren = e;
  }
  canFocus() {
    var e;
    return (this.spLay.interactiveChildren ?? !1) && this.spLay.visible && c(e = Bt, vf).call(e, this);
  }
  clearLay(e) {
    super.clearLay(e), this.clearText();
    for (const r of c(this, Nr).removeChildren())
      r.destroy();
  }
  playback(e, r) {
    super.playback(e, r), this.enabled = e.enabled, c(this, mn).style.cssText = e.r_cssText, P(this, Ar, e.r_align), this.cvsResize(), O(this, wf, W_).call(this, e), c(this, re).playback(e.txs), P(this, pi, e.b_alpha), P(this, Fi, e.b_alpha_isfixed), r.push(new Promise((s) => {
      const a = e.b_do ? e.b_do === "Sprite" ? { b_pic: e.b_pic } : { b_color: e.b_color } : { b_pic: "" };
      a.b_alpha = e.b_alpha, a.b_alpha_isfixed = e.b_alpha_isfixed, O(this, xf, X_).call(this, a, (o) => {
        o && s();
      }) || s();
    }));
    const n = e.btns;
    r = r.concat(n.map((s) => this.addButton(JSON.parse(s.replaceAll("'", '"')))));
  }
  snapshot(e, r) {
    e.render(this.spLay, { clear: !1 }), c(this, re).snapshot(e, r);
  }
  snapshot_end() {
    c(this, re).snapshot_end();
  }
  makeDesignCast(e) {
    this.spLay.visible && c(this, re).makeDesignCast(e);
  }
  makeDesignCastChildren(e) {
    if (this.spLay.visible)
      for (const r of c(this, Nr).children)
        r.makeDesignCast(e);
  }
  showDesignCast() {
    c(this, re).showDesignCast();
  }
  showDesignCastChildren() {
    for (const e of c(this, Nr).children)
      e.showDesignCast();
  }
  dump() {
    return c(this, Sf).call(this, "", "gotxt｜"), super.dump() + `, "enabled":"${this.enabled}", ${c(this, re).dump()}, "b_pic":"${c(this, gn)}", "b_color":"${c(this, as)}", "b_alpha":${c(this, pi)}, "b_alpha_isfixed":"${c(this, Fi)}", "width":${c(this, re).getWidth}, "height":${c(this, re).getHeight}, "pixi_obj":[${this.spLay.children.map((e) => `{"class":"${e instanceof Ue ? "Sprite" : e instanceof si ? "Graphics" : e instanceof ye ? "Container" : "?"}", "name":"${e.name}", "alpha":${e.alpha}, "x":${e.x}, "y":${e.y}, "visible":"${e.visible}"}`).join(",")}], "button":[${c(this, Nr).children.map((e) => e.children[0].name ?? "{}").join(",")}]`;
  }
};
let Se = Bt;
ml = new WeakMap(), Bi = new WeakMap(), vf = new WeakMap(), yl = new WeakMap(), gf = new WeakSet(), $_ = function(e) {
  const r = De.ch_in_style(e), n = r.x.at(0) === "=" ? `${r.nx * 100}%` : `${r.nx}px`, s = r.y.at(0) === "=" ? `${r.ny * 100}%` : `${r.ny}px`, { name: a } = e;
  return Au(`
.sn_ch_in_${a} {
	position: relative;
	display: inline-block;
}
.go_ch_in_${a} {
	opacity: ${r.alpha};
	position: relative;
	display: inline-block;
	animation: sn_ch_in_${a} ${r.wait}ms ${r.ease} 0s both;
}
@keyframes sn_ch_in_${a} {
	from {transform: rotate(${r.rotate}deg) scale(${r.scale_x}, ${r.scale_y}) translate(${n}, ${s});}
	to {opacity: 1; transform: none;}
}
`), !1;
}, mf = new WeakSet(), V_ = function(e) {
  const r = De.ch_out_style(e), n = r.x.at(0) === "=" ? `${r.nx * 100}%` : `${r.nx}px`, s = r.y.at(0) === "=" ? `${r.ny * 100}%` : `${r.ny}px`, { name: a } = e;
  return Au(`
.go_ch_out_${a} {
	position: relative;
	display: inline-block;
	animation: go_ch_out_${a} ${r.wait}ms ${r.ease} 0s both;
}
@keyframes go_ch_out_${a} {
	to {
		opacity: ${r.alpha};
		transform: rotate(${r.rotate}deg) scale(${r.scale_x}, ${r.scale_y}) translate(${n}, ${s});
	}
`), !1;
}, yf = new WeakMap(), oo = new WeakMap(), _f = new WeakMap(), ss = new WeakMap(), uo = new WeakMap(), xg = new WeakSet(), aM = function(e) {
  P(Bt, ss, vt(e, "enabled", c(Bt, ss))), c(Bt, Bi).setVal_Nochk("save", "const.sn.autowc.enabled", c(Bt, ss));
  const { text: r } = e;
  if ("text" in e != "time" in e)
    throw "[autowc] textとtimeは同時指定必須です";
  if (c(Bt, Bi).setVal_Nochk("save", "const.sn.autowc.text", r), !r)
    return c(Bt, Bi).setVal_Nochk("save", "const.sn.autowc.time", ""), !1;
  const n = r.length;
  if (c(Bt, ss) && n === 0)
    throw '[autowc] enabled === false かつ text === "" は許されません';
  const s = String(e.time).split(",");
  if (s.length !== n)
    throw "[autowc] text文字数とtimeに記述された待ち時間（コンマ区切り）は同数にして下さい";
  return P(Bt, uo, {}), s.forEach((a, o) => c(Bt, uo)[r[o]] = ii(a)), c(Bt, Bi).setVal_Nochk("save", "const.sn.autowc.time", e.time), !1;
}, as = new WeakMap(), pi = new WeakMap(), Fi = new WeakMap(), ce = new WeakMap(), gn = new WeakMap(), re = new WeakMap(), bf = new WeakMap(), mn = new WeakMap(), wg = new WeakMap(), Nr = new WeakMap(), lo = new WeakSet(), Nh = function(e) {
  const { in_style: r } = e;
  if (!r)
    return;
  const n = De.getChInStyle(r);
  if (!n)
    throw `存在しないin_style【${r}】です`;
  P(this, ho, r), P(this, _l, n.join);
}, ho = new WeakMap(), _l = new WeakMap(), co = new WeakSet(), Ah = function(e) {
  const { out_style: r } = e;
  if (!r)
    return;
  if (!De.getChOutStyle(r))
    throw `存在しないout_style【${r}】です`;
  P(this, bl, r);
}, bl = new WeakMap(), xf = new WeakSet(), X_ = function(e, r) {
  if ("back_clear" in e)
    return vt(e, "back_clear", !1) && (P(this, as, 0), P(this, pi, 0), P(this, Fi, !1), P(this, gn, "")), r(!1), !1;
  P(this, pi, tt(e, "b_alpha", c(this, pi))), P(this, Fi, vt(e, "b_alpha_isfixed", c(this, Fi)));
  const n = (c(this, Fi) ? 1 : Number(c(Bt, Bi).getVal("sys:TextLayer.Back.Alpha"))) * c(this, pi);
  if (e.b_pic) {
    if (c(this, gn) !== e.b_pic)
      return P(this, gn, e.b_pic), c(this, ce) && (this.spLay.removeChild(c(this, ce)), c(this, ce).destroy()), Wt.csv2Sprites(c(this, gn), this.spLay, (s) => {
        P(this, ce, s), s.name = "back(pic)", s.visible = n > 0, s.alpha = n, c(this, re).setSize(s.width, s.height), this.spLay.setChildIndex(s, 0), r(!0);
      });
  } else
    "b_color" in e && (P(this, as, SE(e, "b_color", 0)), c(this, ce) && (this.spLay.removeChild(c(this, ce)), c(this, ce).destroy()), P(this, gn, ""), this.spLay.addChildAt(
      P(this, ce, new si()).beginFill(c(this, as)).lineStyle(void 0).drawRect(0, 0, c(this, re).getWidth, c(this, re).getHeight).endFill(),
      0
    ), c(this, ce).name = "back(color)");
  return c(this, ce) && (c(this, ce).visible = n > 0, c(this, ce).alpha = n), r(!1), !1;
}, wf = new WeakSet(), W_ = function(e) {
  "noffs" in e && (P(this, xl, e.noffs ?? ""), P(this, Ef, new RegExp(`[　${c(this, xl)}]`))), "ffs" in e && (c(this, fo) ?? P(this, fo, ""), P(this, po, c(this, fo) === "" ? () => "" : (r) => c(this, Ef).test(r) ? "" : ` font-feature-settings: ${c(this, fo)};`));
}, fo = new WeakMap(), po = new WeakMap(), xl = new WeakMap(), Ef = new WeakMap(), wl = new WeakMap(), Ws = new WeakMap(), Ar = new WeakMap(), Eg = new WeakSet(), oM = function(e, r, n, s = "") {
  if (!n)
    return ` style='${s}'`;
  const a = e.length * 2;
  if (a - r.length < 0)
    return ` style='text-align: ${n}; ${s}'`;
  let o = "";
  switch (n) {
    case "left":
      o = "ruby-align: start;";
      break;
    case "center":
      o = "ruby-align: center;";
      break;
    case "right":
      o = "ruby-align: start;";
      break;
    case "justify":
      o = "ruby-align: space-between;";
      break;
    case "121":
      o = "ruby-align: space-around;";
      break;
    case "even":
      const u = (a - r.length) / (r.length + 1);
      o = "ruby-align: space-between; " + (c(this, re).tategaki ? `padding-top: ${u}em; padding-bottom: ${u}em;` : `padding-left: ${u}em; padding-right: ${u}em;`);
      break;
    case "1ruby":
      o = "ruby-align: space-between; " + (c(this, re).tategaki ? "padding-top: 1em; padding-bottom: 1em;" : "padding-left: 1em; padding-right: 1em;");
      break;
    default:
      o = `text-align: ${n};`;
  }
  return ` style='${o} ${s}'`;
}, Zr = new WeakMap(), Sf = new WeakMap(), El = new WeakSet(), Xp = function(e, r, n) {
  var l;
  const s = e === " " ? "&nbsp;" : e;
  c(Bt, Bi).doRecLog() && P(this, vo, c(this, vo) + (s + (r ? `《${r}》` : "")));
  const { cl: a, sty: o, lnk: u } = O(this, os, Pa).call(this, !0, null, e);
  return r ? `<span${a} style='${o} ${c(this, po).call(this, e)}'><ruby>${// 文字個別に出現させるため以下にも ${cl} が必要
  Array.from(e).map((h, d) => `<span${a}${u} style='${d > 0 ? O(this, os, Pa).call(this, !0, null, e).sty : o} display: inline;'>${h === " " ? "&nbsp;" : h}</span>`).join("")}<rt${u}${this.mkStyle_r_align(
    e,
    r,
    n,
    c(this, mn).style.cssText + (((l = c(this, gi).at(-1)) == null ? void 0 : l.o.r_style) ?? "")
  )}>${r}</rt></ruby></span>` : `<span${a} style='${o} ${c(this, po).call(this, e)}'${u}>${s}</span>`;
}, os = new WeakSet(), Pa = function(e, r, n = `
`) {
  var o, u, l;
  const s = c(this, _l) ? r ?? ((o = c(this, gi).at(0)) == null ? void 0 : o.o.wait) ?? (c(Bt, ss) ? c(Bt, uo)[n.at(0) ?? ""] ?? 0 : Ga.msecChWait) : 0;
  c(Bt, oo).isSkippingByKeyDown() ? P(this, yn, 0) : e && c(this, _l) && P(this, yn, c(this, yn) + Number(s));
  const a = `data-add='{"ch_in_style":"${c(this, ho)}", "ch_out_style":"${c(this, bl)}"}'`;
  return {
    cl: ` class='sn_ch${s > 0 ? ` sn_ch_in_${c(this, ho)}` : ""}'`,
    // TxtStage.goTxt()はこれ単位で文字出現させる
    sty: `animation-delay: ${c(this, yn)}ms;${((u = c(this, gi).at(-1)) == null ? void 0 : u.o.style) ?? ""}`,
    // TxtStage.goTxt()はこれ単位で文字出現させる
    lnk: (((l = c(this, gi).at(0)) == null ? void 0 : l.o[":link"]) ?? "") + " " + a,
    curpos: a
  };
}, yn = new WeakMap(), Gi = new WeakMap(), vi = new WeakMap(), gi = new WeakMap(), Tf = new WeakSet(), Y_ = function(e) {
  c(this, gi).push({
    o: e,
    r_align: c(this, Ar),
    ch_in_style: c(this, ho),
    ch_out_style: c(this, bl)
  }), "r_align" in e && P(this, Ar, e.r_align), O(this, lo, Nh).call(this, e), O(this, co, Ah).call(this, e);
}, Sl = new WeakSet(), Wp = function() {
  const e = c(this, gi).pop();
  e && (P(this, Ar, e.r_align), O(this, lo, Nh).call(this, { in_style: e.ch_in_style }), O(this, co, Ah).call(this, { out_style: e.ch_out_style }));
}, Cf = new WeakSet(), q_ = function(e) {
  const r = c(this, gi).at(-1);
  if (!r) {
    O(this, Tf, Y_).call(this, e);
    return;
  }
  r.o = { ...r.o, ...e }, !e.style && !e.r_style && (r.o.style = "", r.o.r_style = ""), "r_align" in e && P(this, Ar, e.r_align), O(this, lo, Nh).call(this, e), O(this, co, Ah).call(this, e);
}, vo = new WeakMap(), // 文字出現演出
E(Se, gf), // 文字消去演出
E(Se, mf), E(Se, xg), E(Se, ml, void 0), E(Se, Bi, void 0), E(Se, vf, void 0), E(Se, yl, void 0), E(Se, yf, void 0), E(Se, oo, void 0), E(Se, _f, void 0), // 文字ごとのウェイト
E(Se, ss, !1), E(Se, uo, {}), // cssチェック・保存用
E(Se, wg, {
  "text-align": 0,
  "text-align-last": 0,
  height: 0,
  width: 0,
  "padding-left": 0,
  "padding-right": 0,
  "padding-top": 0,
  "padding-bottom": 0
}), E(Se, wl, (e) => e);
var Tl, go, Sg, uM, Cl, Ml, Yp, Tg, lM, Cg, hM, Mf, Mg, cM, Pg, fM;
class Y3 {
  constructor(t, e, r, n, s, a, o) {
    //	HTMLフレーム
    // フレーム追加
    E(this, Sg);
    E(this, Ml);
    // フレーム変数を取得
    E(this, Tg);
    // フレーム変数に設定
    E(this, Cg);
    E(this, Mg);
    // フレームをトゥイーン開始
    E(this, Pg);
    E(this, Tl, void 0);
    E(this, go, /* @__PURE__ */ Object.create(null));
    E(this, Cl, {});
    // フレームに設定
    E(this, Mf, 1);
    this.cfg = t, this.appPixi = r, this.val = n, this.main = s, this.sys = a, this.hTwInf = o, e.add_frame = (u) => O(this, Sg, uM).call(this, u), e.let_frame = (u) => O(this, Tg, lM).call(this, u), e.set_frame = (u) => O(this, Cg, hM).call(this, u), e.frame = (u) => O(this, Mg, cM).call(this, u), e.tsy_frame = (u) => O(this, Pg, fM).call(this, u);
  }
  setEvtMng(t) {
    P(this, Tl, t);
  }
  destroy() {
    for (const t of Object.values(c(this, go)))
      t.parentElement.removeChild(t);
    P(this, go, /* @__PURE__ */ Object.create(null));
  }
  getFrmDisabled(t) {
    return c(this, Cl)[t];
  }
  cvsResize() {
    for (const [t, e] of Object.entries(c(this, go))) {
      const r = "const.sn.frm." + t, n = Number(this.val.getVal(r + ".x")), s = Number(this.val.getVal(r + ".y")), a = Number(this.val.getVal(r + ".width")), o = Number(this.val.getVal(r + ".height"));
      e.style.left = `${this.sys.ofsLeft4elm + n * this.sys.cvsScale}px`, e.style.top = `${this.sys.ofsTop4elm + s * this.sys.cvsScale}px`, e.width = String(a * this.sys.cvsScale), e.height = String(o * this.sys.cvsScale);
    }
  }
}
Tl = new WeakMap(), go = new WeakMap(), Sg = new WeakSet(), uM = function(t) {
  const { id: e, src: r, alpha: n = 1, scale_x: s = 1, scale_y: a = 1, rotate: o = 0 } = t;
  if (!e)
    throw "idは必須です";
  if (!r)
    throw "srcは必須です";
  const u = "const.sn.frm." + e;
  if (this.val.getVal(`tmp:${u}`))
    throw `frame【${e}】はすでにあります`;
  const l = vt(t, "visible", !0), h = t.b_color ? ` background-color: ${t.b_color};` : "", d = O(this, Ml, Yp).call(this, t);
  Ur.cvs.insertAdjacentHTML("beforebegin", `<iframe id="${e}" sandbox="allow-scripts allow-same-origin" style="opacity: ${n}; position: absolute; left:${this.sys.ofsLeft4elm + d.x * this.sys.cvsScale}px; top: ${this.sys.ofsTop4elm + d.y * this.sys.cvsScale}px; z-index: 1; ${h} border: 0px; overflow: hidden; display: ${l ? "inline" : "none"}; transform: scale(${s}, ${a}) rotate(${o}deg);" width="${d.width * this.sys.cvsScale}" height="${d.height * this.sys.cvsScale}"></iframe>`);
  const f = this.cfg.searchPath(r, vr.HTML), p = new ri().add({ name: r, url: f, xhrType: Ft.XHR_RESPONSE_TYPE.TEXT });
  return this.sys.crypto && p.use((v, g) => {
    try {
      v.data = this.sys.decStr(v.extension, v.data);
    } catch (m) {
      this.main.errScript(`[add_frame]Html ロード失敗です src:${v.name} ${m}`, !1);
    }
    g == null || g();
  }), p.load((v, g) => {
    var y;
    const m = document.getElementById(e);
    c(this, go)[e] = m, c(this, Cl)[e] = !1, m.srcdoc = String((y = g[r]) == null ? void 0 : y.data).replace("sn_repRes();", "").replaceAll(
      /\s(?:src|href)=(["'])(\S+)\1/g,
      (_, b, w) => w.slice(0, 3) === "../" ? this.sys.cur + w.slice(4) : _.replace(b, b + f.slice(0, f.lastIndexOf("/") + 1))
    ), m.onload = () => {
      var b;
      this.val.setVal_Nochk("tmp", u, !0), this.val.setVal_Nochk("tmp", u + ".alpha", n), this.val.setVal_Nochk("tmp", u + ".x", d.x), this.val.setVal_Nochk("tmp", u + ".y", d.y), this.val.setVal_Nochk("tmp", u + ".scale_x", s), this.val.setVal_Nochk("tmp", u + ".scale_y", a), this.val.setVal_Nochk("tmp", u + ".rotate", o), this.val.setVal_Nochk("tmp", u + ".width", d.width), this.val.setVal_Nochk("tmp", u + ".height", d.height), this.val.setVal_Nochk("tmp", u + ".visible", l);
      const _ = m.contentWindow;
      c(this, Tl).resvFlameEvent(_), (b = _.sn_repRes) == null || b.call(_, (w) => Wt.loadPic2Img(w.dataset.src ?? "", w)), this.main.resume();
    };
  }), !0;
}, Cl = new WeakMap(), Ml = new WeakSet(), Yp = function(t) {
  const e = { ...t }, r = this.sys.resolution;
  return new DOMRect(
    tt(e, "x", 0) * r,
    tt(e, "y", 0) * r,
    tt(e, "width", Y.stageW) * r,
    tt(e, "height", Y.stageH) * r
  );
}, Tg = new WeakSet(), lM = function(t) {
  const { id: e, var_name: r } = t;
  if (!e)
    throw "idは必須です";
  const n = document.getElementById(e);
  if (!n)
    throw `id【${e}】はフレームではありません`;
  const s = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${s}`))
    throw `frame【${e}】が読み込まれていません`;
  if (!r)
    throw "var_nameは必須です";
  const a = n.contentWindow;
  if (!a.hasOwnProperty(r))
    throw `frame【${e}】に変数/関数【${r}】がありません。変数は var付きにして下さい`;
  const o = a[r];
  return this.val.setVal_Nochk(
    "tmp",
    s + "." + r,
    vt(t, "function", !1) ? o() : o
  ), !1;
}, Cg = new WeakSet(), hM = function(t) {
  const { id: e, var_name: r, text: n } = t;
  if (!e)
    throw "idは必須です";
  const s = document.getElementById(e);
  if (!s)
    throw `id【${e}】はフレームではありません`;
  const a = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${a}`))
    throw `frame【${e}】が読み込まれていません`;
  if (!r)
    throw "var_nameは必須です";
  if (!n)
    throw "textは必須です";
  this.val.setVal_Nochk("tmp", a + "." + r, n);
  const o = s.contentWindow;
  return o[r] = n, !1;
}, Mf = new WeakMap(), Mg = new WeakSet(), cM = function(t) {
  const { id: e } = t;
  if (!e)
    throw "idは必須です";
  const r = document.getElementById(e);
  if (!r)
    throw `id【${e}】はフレームではありません`;
  const n = "const.sn.frm." + e;
  if (!this.val.getVal("tmp:" + n))
    throw `frame【${e}】が読み込まれていません`;
  const s = r.style;
  if (vt(t, "float", !1) ? s.zIndex = `${++Ve(this, Mf)._}` : "index" in t ? s.zIndex = `${tt(t, "index", 0)}` : t.dive && (s.zIndex = `-${++Ve(this, Mf)._}`), "alpha" in t) {
    const o = s.opacity = String(t.alpha);
    this.val.setVal_Nochk("tmp", n + ".alpha", o);
  }
  const a = O(this, Ml, Yp).call(this, t);
  if (("x" in t || "y" in t) && (s.left = `${this.sys.ofsLeft4elm + a.x * this.sys.cvsScale}px`, s.top = `${this.sys.ofsTop4elm + a.y * this.sys.cvsScale}px`, this.val.setVal_Nochk("tmp", n + ".x", a.x), this.val.setVal_Nochk("tmp", n + ".y", a.y)), "scale_x" in t || "scale_y" in t || "rotate" in t) {
    const o = tt(t, "scale_x", 1), u = tt(t, "scale_y", 1), l = tt(t, "rotate", 0);
    s.transform = `scale(${o}, ${u}) rotate(${l}deg)`, this.val.setVal_Nochk("tmp", n + ".scale_x", o), this.val.setVal_Nochk("tmp", n + ".scale_y", u), this.val.setVal_Nochk("tmp", n + ".rotate", l);
  }
  if ("width" in t && (r.width = String(a.width * this.sys.cvsScale), this.val.setVal_Nochk("tmp", n + ".width", a.width)), "height" in t && (r.height = String(a.height * this.sys.cvsScale), this.val.setVal_Nochk("tmp", n + ".height", a.height)), "visible" in t) {
    const o = vt(t, "visible", !0);
    s.display = o ? "inline" : "none", this.val.setVal_Nochk("tmp", n + ".visible", o);
  }
  if ("b_color" in t && (s.backgroundColor = t.b_color), "disabled" in t) {
    const o = c(this, Cl)[e] = vt(t, "disabled", !0);
    r.contentDocument.body.querySelectorAll("input,select").forEach((l) => l.disabled = o);
  }
  return !1;
}, Pg = new WeakSet(), fM = function(t) {
  const { id: e, alpha: r, x: n, y: s, scale_x: a, scale_y: o, rotate: u, width: l, height: h, ease: d, path: f, chain: p } = t;
  if (!e)
    throw "idは必須です";
  const v = document.getElementById(e);
  if (!v)
    throw `id【${e}】はフレームではありません`;
  const g = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${g}`, 0))
    throw `frame【${e}】が読み込まれていません`;
  const m = {};
  r && (m.a = v.style.opacity), (n || s || a || o || u) && (m.x = Number(this.val.getVal(`tmp:${g}.x`)), m.y = Number(this.val.getVal(`tmp:${g}.y`)), m.sx = Number(this.val.getVal(`tmp:${g}.scale_x`)), m.sy = Number(this.val.getVal(`tmp:${g}.scale_y`)), m.r = Number(this.val.getVal(`tmp:${g}.rotate`))), l && (m.w = this.val.getVal(`tmp:${g}.width`)), h && (m.h = this.val.getVal(`tmp:${g}.height`));
  const y = av(t, m), _ = {};
  let b = () => {
  };
  r && (_.a = tt(y, "alpha", 0), b = () => {
    v.style.opacity = m.a, this.val.setVal_Nochk("tmp", "alpha", m.a);
  });
  let w = () => {
  };
  const T = O(this, Ml, Yp).call(this, y);
  (n || s || a || o || u) && (_.x = T.x, _.y = T.y, _.sx = tt(y, "scale_x", 1), _.sy = tt(y, "scale_y", 1), _.r = tt(y, "rotate", 0), w = () => {
    v.style.left = this.sys.ofsLeft4elm + m.x * this.sys.cvsScale + "px", v.style.top = this.sys.ofsTop4elm + m.y * this.sys.cvsScale + "px", v.style.transform = `scale(${m.sx}, ${m.sy}) rotate(${m.r}deg)`, this.val.setVal_Nochk("tmp", g + ".x", m.x), this.val.setVal_Nochk("tmp", g + ".y", m.y), this.val.setVal_Nochk("tmp", g + ".scale_x", m.sx), this.val.setVal_Nochk("tmp", g + ".scale_y", m.sy), this.val.setVal_Nochk("tmp", g + ".rotate", m.r);
  });
  let x = () => {
  };
  l && (_.w = T.width, x = () => {
    v.width = m.w * this.sys.cvsScale + "px", this.val.setVal_Nochk("tmp", g + ".width", m.w);
  });
  let S = () => {
  };
  h && (_.h = T.height, S = () => {
    v.height = m.h * this.sys.cvsScale + "px", this.val.setVal_Nochk("tmp", g + ".height", m.h);
  }), this.appPixi.stage.interactive = !1;
  const C = `frm
${e}`, M = () => {
    var H, z;
    this.appPixi.stage.interactive = !0;
    const Z = this.hTwInf[C];
    Z && (delete this.hTwInf[C], (H = Z.tw) == null || H.stop(), Z.resume && this.main.resume(), (z = Z.onEnd) == null || z.call(Z));
  }, I = tt(t, "time", NaN) * (this.val.getVal("tmp:sn.skip.enabled") || c(this, Tl).isSkippingByKeyDown() ? 0 : 1), R = ws.ease(d), N = tt(t, "repeat", 1), A = N === 0 ? 1 / 0 : N - 1, G = vt(t, "yoyo", !1), B = tt(t, "delay", 0), U = new Tn(m).to(_, I).easing(R).repeat(A).yoyo(G).delay(B).onUpdate(() => {
    b(), w(), x(), S();
  });
  let $ = U;
  if (f) {
    Y.debugLog && console.group(`🍝 [tsy_frame] path=${f}= start(${m.x},${m.y},${m.alpha})`);
    for (const { groups: Z } of f.matchAll(Ga.REG_TSY_PATH)) {
      const { x: H, x2: z, y: X, y2: ct, o: it, o2: lt, json: et } = Z;
      let k = {};
      if (et)
        try {
          k = JSON.parse(et);
        } catch (St) {
          console.error(`🍝 json=${et} ` + St);
          continue;
        }
      else
        (H ?? z) && (k.x = H ?? z), (X ?? ct) && (k.y = X ?? ct), (it ?? lt) && (k.alpha = it ?? lt);
      const ft = av(k, m);
      Y.debugLog && console.info(`🍝 {x:${H} y:${X} o:${it}} => hTo:${JSON.stringify(ft)}`);
      const Q = new Tn(m).to(ft, I).easing(R).repeat(A).yoyo(G);
      $.chain(Q), $ = Q;
    }
    Y.debugLog && console.groupEnd();
  }
  if ($.onComplete(M), p) {
    const Z = this.hTwInf[p ?? ""];
    if (!Z || !Z.tw)
      throw `${p}は存在しない・または終了したトゥイーンです`;
    delete Z.onEnd, Z.tw.chain(U);
  } else
    U.start();
  return this.hTwInf[C] = { tw: $, resume: !1 }, !1;
};
var mi, Qt, Ee, Ys, mo, Pl, Pf, Of, If, Ol, Rf, Z_, qs, Ui, Og, dM, Lr, Ig, pM, Rg, vM, Dg, gM, Yt, _n, bn, Df, kg, mM, Il, qp, Ng, yM, Ag, kf, Lg, yo, _o, us, Ye, bo, Bg, _M, qe, Cr, Xr, Fg, bM, Gg, xM, Ug, wM, xo, Lh, jg, EM, Kr, zg, SM, Hg, TM, $g, CM, Vg, MM, Xg, PM, Zs, wo, Bh, Jr, Wg, OM, Nf, Yg, IM, xn, Eo, Ks, bu, ji, wn, qg, RM, Zg, DM, Kg, kM, Jg, NM, Qg, AM, tm, LM, em, BM, Af, K_, rm, FM, im, GM, nm, UM, sm, jM, am, zM, om, HM, um, $M;
const Ls = class {
  constructor(t, e, r, n, s, a, o, u, l, h) {
    E(this, Rf);
    // 既存の全文字レイヤの実際のバック不透明度、を再計算
    E(this, Og);
    //	//	システム
    // スナップショット
    E(this, Ig);
    // プラグインの読み込み
    E(this, Rg);
    //	//	レイヤ共通
    // レイヤを追加する
    E(this, Dg);
    E(this, kg);
    E(this, Il);
    // レイヤ設定の消去
    E(this, Ng);
    // ページ裏表を交換
    E(this, Bg);
    E(this, Cr);
    E(this, Fg);
    E(this, Gg);
    // トランス終了待ち
    E(this, Ug);
    // レイヤのトランジションの停止
    E(this, xo);
    // 画面を揺らす
    E(this, jg);
    E(this, zg);
    // トゥイーン終了待ち
    E(this, Hg);
    // トゥイーン中断
    E(this, $g);
    // 一時停止
    E(this, Vg);
    // 一時停止再開
    E(this, Xg);
    // 文字を追加する
    E(this, wo);
    E(this, Wg);
    E(this, Yg);
    E(this, Ks);
    E(this, qg);
    // ハイパーリンクの終了
    E(this, Zg);
    // ページ両面の文字消去
    E(this, Kg);
    // インライン画像表示
    E(this, Jg);
    // ハイパーリンク
    E(this, Qg);
    // 改行
    E(this, tm);
    // 履歴改行
    E(this, em);
    // 履歴書き込み
    E(this, Af);
    // 履歴リセット
    E(this, rm);
    // 文字列と複数ルビの追加
    E(this, im);
    // インラインスタイル設定
    E(this, nm);
    // tcy縦中横を表示する
    E(this, sm);
    // レイヤのダンプ
    E(this, am);
    // イベント有無の切替
    E(this, om);
    // ボタンを表示
    E(this, um);
    E(this, mi, void 0);
    E(this, Qt, new ye());
    E(this, Ee, new ye());
    E(this, Ys, void 0);
    E(this, mo, void 0);
    E(this, Pl, new Jl());
    E(this, Pf, () => _A());
    E(this, Of, {
      attach: (t) => (Vt.leaveMode(), !1),
      continue: (t) => (Vt.leaveMode(), !1),
      disconnect: (t) => (Vt.leaveMode(), !1),
      _enterDesign: (t) => {
        Vt.enterMode();
        for (const e of c(this, _n)) {
          const r = c(this, Yt)[e].fore;
          r.makeDesignCastChildren((n) => n.make()), r.makeDesignCast((n) => n.make());
        }
        return O(this, Rf, Z_).call(this, c(this, bn)), !1;
      },
      _replaceToken: (t, e) => (Vt.replaceToken(e), !1),
      _selectNode: (t, e) => (O(this, Rf, Z_).call(this, e.node), !1)
    });
    E(this, If, "");
    E(this, Ol, "");
    K(this, "getFrmDisabled", (t) => c(this, Ys).getFrmDisabled(t));
    E(this, qs, void 0);
    E(this, Ui, void 0);
    E(this, Lr, (t, e = this.currentTxtlayForeNeedErr, r = !0) => e.tagCh("｜　《" + t + "》"));
    K(this, "goTxt", () => {
    });
    K(this, "breakLine", () => {
    });
    K(this, "breakPage", () => {
    });
    E(this, Yt, {});
    // しおりLoad時再読込
    E(this, _n, []);
    // 最適化用
    E(this, bn, "");
    E(this, Df, "");
    E(this, Ag, `
precision mediump float;

varying vec2 vTextureCoord;
uniform sampler2D uSampler;

uniform sampler2D rule;
uniform float vague;
uniform float tick;

uniform vec4 inputPixel;
uniform highp vec4 outputFrame;
vec2 getUV(vec2 coord) {
	return coord * inputPixel.xy / outputFrame.zw;
}

void main(void) {
	vec4 fg = texture2D(uSampler, vTextureCoord);
	vec4 ru = texture2D(rule, getUV(vTextureCoord));

	float v = ru.r - tick;
	if (abs(v) < vague) {
		float f_a = fg.a *(0.5 +v /vague *0.5);

		gl_FragColor.rgb = fg.rgb *f_a;
		gl_FragColor.a = f_a;
	}
	else {
		gl_FragColor = (v >= 0.0)? fg : vec4(0);
	}
}`);
    E(this, kf, {
      rule: Ot.EMPTY,
      vague: 0,
      tick: 0
    });
    E(this, Lg, new rn(void 0, c(this, Ag), c(this, kf)));
    E(this, yo, Ei.create({
      width: Y.stageW,
      height: Y.stageH
    }));
    E(this, _o, new Ue(c(this, yo)));
    E(this, us, Ei.create({
      width: Y.stageW,
      height: Y.stageH
    }));
    E(this, Ye, new Ue(c(this, us)));
    E(this, bo, []);
    E(this, qe, { tw: void 0, resume: !1 });
    // トゥイーン開始
    E(this, Kr, {});
    E(this, Jr, (t) => {
      throw c(this, Eo).call(this), 0;
    });
    // 操作対象のメッセージレイヤの指定
    E(this, Nf, (t) => {
      throw c(this, Eo).call(this), 0;
    });
    E(this, xn, void 0);
    // カレントテキストレイヤ
    E(this, Eo, () => {
      throw "文字レイヤーがありません。文字表示や操作する前に、[add_lay layer=（レイヤ名） class=txt]で文字レイヤを追加して下さい";
    });
    E(this, ji, "");
    E(this, wn, []);
    this.cfg = t, this.hTag = e, this.appPixi = r, this.val = n, this.main = s, this.scrItr = a, this.sys = o, this.sndMng = u, this.alzTagArg = l, this.prpPrs = h;
    const d = () => {
      if (o.cvsResize(), this.cvsResizeDesign(), c(this, Ol))
        for (const g of c(this, _n))
          c(this, Yt)[g].fore.cvsResizeChildren();
      else
        for (const g of c(this, _n))
          c(this, Yt)[g].fore.cvsResize();
      c(this, Ys).cvsResize(), c(this, Ui).cvsResize();
    };
    if (Y.isMobile)
      c(this, Pl).add(globalThis, "orientationchange", d, { passive: !0 });
    else {
      let g;
      c(this, Pl).add(globalThis, "resize", () => {
        g || (g = setTimeout(() => {
          g = void 0, d();
        }, 1e3 / 60 * 10));
      }, { passive: !0 });
    }
    o.cvsResize(), Se.init(t, e, n, this, (g) => c(this, Yt)[g.layname].fore === g, r), Wt.init(s, t, r, o, u, n), Yi.init(t), P(this, Ys, new Y3(t, e, r, n, s, o, c(this, Kr))), o.hFactoryCls.grp = () => new Wt(), o.hFactoryCls.txt = () => new Se(), e.loadplugin = (g) => O(this, Rg, vM).call(this, g), e.snapshot = (g) => O(this, Ig, pM).call(this, g), e.add_lay = (g) => O(this, Dg, gM).call(this, g), e.clear_lay = (g) => O(this, Ng, yM).call(this, g), e.finish_trans = () => O(this, xo, Lh).call(this), e.lay = (g) => O(this, kg, mM).call(this, g), e.trans = (g) => O(this, Bg, _M).call(this, g), e.wt = (g) => O(this, Ug, wM).call(this, g), e.quake = (g) => O(this, jg, EM).call(this, g), e.stop_quake = (g) => e.finish_trans(g), e.wq = (g) => e.wt(g), e.pause_tsy = (g) => O(this, Vg, MM).call(this, g), e.resume_tsy = (g) => O(this, Xg, PM).call(this, g), e.stop_tsy = (g) => O(this, $g, CM).call(this, g), e.tsy = (g) => O(this, zg, SM).call(this, g), e.wait_tsy = (g) => O(this, Hg, TM).call(this, g), e.ch = (g) => O(this, wo, Bh).call(this, g), e.clear_text = (g) => O(this, qg, RM).call(this, g), e.current = (g) => c(this, Nf).call(this, g), e.endlink = (g) => O(this, Zg, DM).call(this, g), e.er = (g) => O(this, Kg, kM).call(this, g), e.graph = (g) => O(this, Jg, NM).call(this, g), e.link = (g) => O(this, Qg, AM).call(this, g), e.r = (g) => O(this, tm, LM).call(this, g), e.rec_ch = (g) => O(this, Af, K_).call(this, g), e.rec_r = (g) => O(this, em, BM).call(this, g), e.reset_rec = (g) => O(this, rm, FM).call(this, g), e.ruby2 = (g) => O(this, im, GM).call(this, g), e.span = (g) => O(this, nm, UM).call(this, g), e.tcy = (g) => O(this, sm, jM).call(this, g), e.add_face = (g) => Wt.add_face(g), e.wv = (g) => Wt.wv(g), e.dump_lay = (g) => O(this, am, zM).call(this, g), e.enable_event = (g) => O(this, om, HM).call(this, g), e.button = (g) => O(this, um, $M).call(this, g), t.existsBreakline && (this.breakLine = () => c(this, Lr).call(this, 'grp｜{"id":"break","pic":"breakline"}')), t.existsBreakpage && (this.breakPage = () => c(this, Lr).call(this, 'grp｜{"id":"break","pic":"breakpage"}')), P(this, mo, xb(String(t.oCfg.init.bg_color)));
    const f = new si();
    f.beginFill(c(this, mo), 1).lineStyle(0, c(this, mo)).drawRect(0, 0, Y.stageW, Y.stageH).endFill(), c(this, Qt).addChild(f.clone()), c(this, Ee).addChild(f), c(this, Ee).visible = !1, c(this, Qt).name = "page:A", c(this, Ee).name = "page:B", P(this, mi, r.stage), c(this, mi).addChild(c(this, Ee)), c(this, mi).addChild(c(this, Qt)), c(this, mi).addChild(c(this, _o)), c(this, mi).addChild(c(this, Ye)), c(this, mi).name = "stage", r.ticker.add(c(this, Pf));
    const p = (g, m) => {
      O(this, Og, dM).call(this, Number(m));
    };
    p("", n.getVal("sys:TextLayer.Back.Alpha", 1)), n.defValTrg("sys:TextLayer.Back.Alpha", p);
    const v = (g, m) => Yi.fontFamily = m;
    v("", n.getVal("tmp:sn.button.fontFamily", Yi.fontFamily)), n.defValTrg("tmp:sn.button.fontFamily", v), n.defTmp("const.sn.log.json", () => JSON.stringify(
      c(this, ji) ? [...c(this, wn), { text: c(this, ji).replaceAll("</span><span class='sn_ch'>", "") }] : c(this, wn)
    )), n.defTmp("const.sn.last_page_text", () => {
      var g;
      return ((g = this.currentTxtlayFore) == null ? void 0 : g.pageText) ?? "";
    }), Y.isDbg && (Vt.init(r, o, a, h, l, t, c(this, Yt)), this.cvsResizeDesign = () => Vt.cvsResizeDesign(), o.addHook((g, m) => {
      var y, _;
      (_ = (y = c(this, Of))[g]) != null && _.call(y, g, m) && delete c(this, Of)[g];
    }));
  }
  cvsResizeDesign() {
  }
  cover(t, e = 0) {
    c(this, qs) && (c(this, mi).removeChild(c(this, qs)), c(this, qs).destroy(), P(this, qs, void 0)), t && c(this, mi).addChild(
      P(this, qs, new si()).beginFill(e).lineStyle(0, e).drawRect(0, 0, Y.stageW, Y.stageH).endFill()
    );
  }
  setEvtMng(t) {
    P(this, Ui, t), c(this, Ys).setEvtMng(t), Wt.setEvtMng(t);
  }
  before_destroy() {
    for (const t of Object.values(c(this, Yt)))
      t.destroy();
  }
  destroy() {
    c(this, Pl).clear(), Wt.destroy(), ua.destroy(), De.destroy(), Se.destroy(), c(this, Ys).destroy(), this.stopAllTw(), this.appPixi.ticker.remove(c(this, Pf)), P(Ls, Zs, 10);
  }
  // トゥイーン全停止
  stopAllTw() {
    P(this, Kr, {}), mA();
  }
  clearBreak() {
    this.currentTxtlayFore && (this.clearBreak = () => c(this, Lr).call(this, "del｜break"), this.clearBreak());
  }
  clickTxtLay() {
    return this.currentTxtlayFore ? O(this, Cr, Xr).call(this).some((t) => {
      const e = c(this, Yt)[t].fore;
      return e instanceof Se && e.click();
    }) : !1;
  }
  static get msecChWait() {
    return c(Ls, Zs);
  }
  static set msecChWait(t) {
    P(Ls, Zs, t);
  }
  setNormalChWait() {
    P(Ls, Zs, this.scrItr.normalWait);
  }
  get currentTxtlayForeNeedErr() {
    return c(this, Eo).call(this), this.currentTxtlayFore;
  }
  get currentTxtlayFore() {
    return c(this, xn) ? c(this, xn).fore : null;
  }
  recText(t) {
    P(this, ji, t), this.val.setVal_Nochk(
      "save",
      "const.sn.sLog",
      String(this.val.getVal("const.sn.log.json"))
      // これを起動したい
    );
  }
  recPagebreak() {
    if (!c(this, ji))
      return;
    const t = c(this, ji).replaceAll("</span><span class='sn_ch'>", "");
    c(this, wn).push({ text: t }) > this.cfg.oCfg.log.max_len && P(this, wn, c(this, wn).slice(-this.cfg.oCfg.log.max_len)), P(this, ji, "");
  }
  record() {
    const t = {};
    for (const e of c(this, _n)) {
      const r = c(this, Yt)[e];
      t[e] = {
        cls: r.cls,
        fore: r.fore.record(),
        back: r.back.record()
      };
    }
    return t;
  }
  playback(t, e) {
    var a;
    P(this, wn, JSON.parse(String(this.val.getVal("save:const.sn.sLog")))), P(this, ji, "");
    const r = [], n = [];
    for (const [o, { fore: u, fore: { idx: l }, back: h, cls: d }] of Object.entries(t)) {
      n.push({ layer: o, idx: l });
      const f = (a = c(this, Yt))[o] ?? (a[o] = new Wh(o, d, c(this, Qt), c(this, Ee), {}, this.sys, this.val, { isWait: !1 }));
      f.fore.playback(u, r), f.back.playback(h, r);
    }
    const s = c(this, Qt).children.length;
    Promise.allSettled(r).then(() => {
      for (const { layer: o, idx: u } of n.sort(({ idx: l }, { idx: h }) => l === h ? 0 : l < h ? -1 : 1)) {
        const { fore: l, back: h } = c(this, Yt)[o];
        if (!l)
          return;
        const d = s > u ? u : s - 1;
        c(this, Qt).setChildIndex(l.spLay, d), c(this, Ee).setChildIndex(h.spLay, d);
      }
      e();
    }).catch((o) => console.error("fn:LayerMng.ts playback e:%o", o));
  }
};
let Ga = Ls;
mi = new WeakMap(), Qt = new WeakMap(), Ee = new WeakMap(), Ys = new WeakMap(), mo = new WeakMap(), Pl = new WeakMap(), Pf = new WeakMap(), Of = new WeakMap(), If = new WeakMap(), Ol = new WeakMap(), Rf = new WeakSet(), Z_ = function(t) {
  [Ve(this, If)._, this.Ol = ""] = t.split("/");
  const e = c(this, Yt)[c(this, If)];
  e && (Vt.allHide(), c(this, Ol) ? e.fore.showDesignCastChildren() : e.fore.showDesignCast());
}, qs = new WeakMap(), Ui = new WeakMap(), Og = new WeakSet(), dM = function(t) {
  for (const e of O(this, Cr, Xr).call(this)) {
    const r = c(this, Yt)[e];
    r.fore instanceof Se && (r.fore.chgBackAlpha(t), r.back.chgBackAlpha(t));
  }
}, Lr = new WeakMap(), Ig = new WeakSet(), pM = function(t) {
  const e = t.fn ? t.fn.slice(0, 10) === "userdata:/" ? t.fn : `downloads:/${t.fn + ec("-", "_", "", "_")}.png` : `downloads:/snapshot${ec("-", "_", "", "_")}.png`, r = this.cfg.searchPath(e);
  if (!("layer" in t) && this.sys.canCapturePage(r, () => this.main.resume()))
    return !0;
  const n = ov(r), s = SE(t, "b_color", c(this, mo)), a = qb({
    width: tt(t, "width", Y.stageW),
    height: tt(t, "height", Y.stageH),
    backgroundAlpha: s > 16777216 && n === "png" ? 0 : 1,
    antialias: vt(t, "smoothing", !1),
    preserveDrawingBuffer: !0,
    backgroundColor: s & 16777215,
    autoDensity: !0
  }), o = [], u = t.page !== "back" ? "fore" : "back";
  if (c(this, qe).tw)
    o.push(new Promise((l) => {
      c(this, Ee).visible = !0;
      for (const h of c(this, bo))
        a.render(h, { clear: !1 });
      c(this, Ee).visible = !1, c(this, _o).visible = !0, c(this, Qt).filters = c(this, Ye).filters, c(this, Qt).visible = !0, a.render(c(this, Qt), { clear: !1 }), c(this, Qt).visible = !1, c(this, Qt).filters = [], l();
    }));
  else
    for (const l of O(this, Cr, Xr).call(this, t.layer))
      o.push(
        new Promise((h) => c(this, Yt)[l][u].snapshot(a, () => h()))
      );
  return Promise.allSettled(o).then(async () => {
    const l = Ei.create({ width: a.width, height: a.height });
    if (a.render(c(this, mi), { renderTexture: l }), await this.sys.savePic(
      r,
      a.plugins.extract.base64(Ue.from(l))
    ), !c(this, qe).tw)
      for (const h of O(this, Cr, Xr).call(this, t.layer))
        c(this, Yt)[h][u].snapshot_end();
    a.destroy(!0), this.main.resume();
  }), !0;
}, Rg = new WeakSet(), vM = function(t) {
  const { fn: e } = t;
  if (!e)
    throw "fnは必須です";
  const r = vt(t, "join", !0);
  switch (ov(e)) {
    case "css":
      (async () => {
        const n = await fetch(e);
        if (!n.ok)
          throw new Error("Network response was not ok.");
        Au(await n.text()), r && this.main.resume();
      })();
      break;
    default:
      throw "サポートされない拡張子です";
  }
  return r;
}, Dg = new WeakSet(), gM = function(t) {
  const { layer: e, class: r } = t;
  if (!e)
    throw "layerは必須です";
  if (e.includes(","))
    throw "layer名に「,」は使えません";
  if (e in c(this, Yt))
    throw `layer【${e}】はすでにあります`;
  if (!r)
    throw "clsは必須です";
  const n = { isWait: !1 };
  switch (c(this, Yt)[e] = new Wh(e, r, c(this, Qt), c(this, Ee), t, this.sys, this.val, n), c(this, _n).push(e), r) {
    case "txt":
      c(this, bn) || (P(this, Eo, () => {
      }), P(this, Jr, O(this, Wg, OM)), P(this, Nf, O(this, Yg, IM)), this.hTag.current({ layer: e }), this.goTxt = () => {
        this.val.getVal("sn.skip.enabled") ? P(Ls, Zs, 0) : this.setNormalChWait();
        for (const s of O(this, Cr, Xr).call(this)) {
          const a = c(this, Yt)[s].fore;
          a instanceof Se && c(this, Lr).call(this, "gotxt｜", a, !1);
        }
      }), this.val.setVal_Nochk(
        "save",
        "const.sn.layer." + (e ?? c(this, bn)) + ".enabled",
        !0
      );
      break;
    case "grp":
      if (c(this, Df))
        break;
      P(this, Df, e);
      break;
  }
  return this.scrItr.recodeDesign(t), n.isWait;
}, Yt = new WeakMap(), _n = new WeakMap(), bn = new WeakMap(), Df = new WeakMap(), kg = new WeakSet(), mM = function(t) {
  const e = O(this, Ks, bu).call(this, t), r = c(this, Yt)[e], n = r.back.spLay, s = r.fore.spLay;
  if (vt(t, "float", !1))
    c(this, Ee).setChildIndex(n, c(this, Ee).children.length - 1), c(this, Qt).setChildIndex(s, c(this, Qt).children.length - 1), O(this, Il, qp).call(this);
  else if (t.index)
    tt(t, "index", 0) && (c(this, Ee).setChildIndex(n, t.index), c(this, Qt).setChildIndex(s, t.index), O(this, Il, qp).call(this));
  else if (t.dive) {
    const { dive: a } = t;
    let o = 0;
    if (e === a)
      throw "[lay] 属性 layerとdiveが同じ【" + a + "】です";
    const u = c(this, Yt)[a];
    if (!u)
      throw "[lay] 属性 dive【" + a + "】が不正です。レイヤーがありません";
    const l = u.back, h = u.fore, d = c(this, Ee).getChildIndex(l.spLay), f = c(this, Qt).getChildIndex(h.spLay);
    o = d < f ? d : f, o > c(this, Ee).getChildIndex(n) && --o, c(this, Qt).setChildIndex(s, o), c(this, Ee).setChildIndex(n, o), O(this, Il, qp).call(this);
  }
  return t[":id_tag"] = r.fore.name.slice(0, -7), this.scrItr.recodeDesign(t), r.lay(t);
}, Il = new WeakSet(), qp = function() {
  P(this, _n, O(this, Gg, xM).call(this));
}, Ng = new WeakSet(), yM = function(t) {
  return O(this, Fg, bM).call(this, t, (e) => {
    const r = c(this, Yt)[O(this, Ks, bu).call(this, { layer: e })];
    t.page === "both" ? (r.fore.clearLay(t), r.back.clearLay(t)) : r.getPage(t).clearLay(t);
  }), !1;
}, Ag = new WeakMap(), kf = new WeakMap(), Lg = new WeakMap(), yo = new WeakMap(), _o = new WeakMap(), us = new WeakMap(), Ye = new WeakMap(), bo = new WeakMap(), Bg = new WeakSet(), _M = function(t) {
  O(this, xo, Lh).call(this), c(this, Ui).hideHint();
  const { layer: e } = t;
  P(this, bo, []);
  const r = {}, n = [];
  for (const m of O(this, Cr, Xr).call(this, e))
    r[m] = !0, n.push(c(this, Yt)[m].fore);
  const s = [];
  for (const m of O(this, Cr, Xr).call(this)) {
    const y = c(this, Yt)[m][r[m] ? "back" : "fore"];
    c(this, bo).push(y.spLay), s.push(y);
  }
  c(this, yo).resize(Y.stageW, Y.stageH), this.appPixi.renderer.render(c(this, Ee), { renderTexture: c(this, yo) });
  let a = () => {
    c(this, Ee).visible = !0;
    for (const m of c(this, bo))
      this.appPixi.renderer.render(m, { renderTexture: c(this, yo), clear: !1 });
    c(this, Ee).visible = !1;
  };
  if (!s.some((m) => m.containMovement)) {
    let m = a;
    a = () => {
      a = () => {
      }, m();
    };
  }
  c(this, us).resize(Y.stageW, Y.stageH), this.appPixi.renderer.render(c(this, Qt), { renderTexture: c(this, us) });
  let o = () => {
    c(this, Qt).visible = !0, this.appPixi.renderer.render(c(this, Qt), { renderTexture: c(this, us) }), c(this, Qt).visible = !1;
  };
  if (!n.some((m) => m.containMovement)) {
    let m = o;
    o = () => {
      o = () => {
      }, m();
    };
  }
  const u = () => {
    a(), c(this, _o).visible = !0, o(), c(this, Ye).visible = !0;
  };
  c(this, Ye).alpha = 1;
  const l = () => {
    var y;
    this.appPixi.ticker && this.appPixi.ticker.remove(u), [Ve(this, Qt)._, Ve(this, Ee)._] = [c(this, Ee), c(this, Qt)];
    const m = [];
    for (const [_, b] of Object.entries(c(this, Yt))) {
      if (r[_]) {
        b.transPage(m);
        continue;
      }
      const { fore: { spLay: w }, back: { spLay: T } } = b, x = c(this, Qt).getChildIndex(T);
      c(this, Qt).removeChild(T), c(this, Ee).removeChild(w), c(this, Qt).addChildAt(w, x), c(this, Ee).addChildAt(T, x);
    }
    Promise.allSettled(m), c(this, Qt).visible = !0, c(this, Ee).visible = !1, c(this, _o).visible = !1, c(this, Ye).visible = !1, (y = c(this, qe).tw) == null || y.stop(), c(this, qe).resume && this.main.resume(), P(this, qe, { tw: void 0, resume: !1 });
  };
  P(this, qe, { tw: void 0, resume: !1 });
  const h = tt(t, "time", 0);
  if (h === 0 || c(this, Ui).isSkippingByKeyDown())
    return l(), !1;
  const { ease: d, glsl: f, rule: p } = t, v = ws.ease(d);
  if (!f && !p)
    return c(this, Ye).filters = [], c(this, qe).tw = new Tn(c(this, Ye)).to({ alpha: 0 }, h).delay(tt(t, "delay", 0)).easing(v).onComplete(l).start(), this.appPixi.ticker.add(u), !1;
  const g = f ? new rn(void 0, f, c(this, kf)) : c(this, Lg);
  if (g.uniforms.vague = tt(t, "vague", 0.04), g.uniforms.tick = 0, c(this, qe).tw = new Tn(g.uniforms).to({ tick: 1 }, h).delay(tt(t, "delay", 0)).easing(v).onComplete(l), c(this, Ye).filters = [g], f)
    return c(this, qe).tw.start(), this.appPixi.ticker.add(u), !1;
  if (!p)
    throw "ruleが指定されていません";
  return Wt.csv2Sprites(p, void 0, (m) => {
    var y;
    g.uniforms.rule = m.texture, m.destroy(), (y = c(this, qe).tw) == null || y.start(), this.appPixi.ticker.add(u);
  }), !1;
}, qe = new WeakMap(), Cr = new WeakSet(), Xr = function(t = "") {
  return t ? t.split(",") : c(this, _n);
}, Fg = new WeakSet(), bM = function(t, e) {
  const r = O(this, Cr, Xr).call(this, t.layer);
  for (const n of r) {
    if (!n)
      continue;
    const s = c(this, Yt)[n];
    if (!s)
      throw "存在しないlayer【" + n + "】です";
    e(n, s);
  }
  return r;
}, Gg = new WeakSet(), xM = function(t = "") {
  return O(this, Cr, Xr).call(this, t).sort((e, r) => {
    const n = c(this, Qt).getChildIndex(c(this, Yt)[e].fore.spLay), s = c(this, Qt).getChildIndex(c(this, Yt)[r].fore.spLay);
    return n < s ? -1 : n > s ? 1 : 0;
  });
}, Ug = new WeakSet(), wM = function(t) {
  return c(this, qe).tw ? (c(this, qe).resume = !0, c(this, Ui).waitLimitedEvent(t, () => O(this, xo, Lh).call(this))) : !1;
}, xo = new WeakSet(), Lh = function() {
  var t;
  return (t = c(this, qe).tw) == null || t.end(), !1;
}, jg = new WeakSet(), EM = function(t) {
  O(this, xo, Lh).call(this);
  const e = tt(t, "time", NaN);
  if (e === 0 || this.val.getVal("tmp:sn.skip.enabled") || c(this, Ui).isSkippingByKeyDown())
    return !1;
  const { layer: r, ease: n } = t, s = [];
  for (const p of O(this, Cr, Xr).call(this, r))
    s.push(c(this, Yt)[p].fore.spLay);
  c(this, us).resize(Y.stageW, Y.stageH);
  const a = () => {
    c(this, Qt).visible = !0;
    for (const p of s)
      this.appPixi.renderer.render(
        p,
        { renderTexture: c(this, us), clear: !1 }
      );
    c(this, Qt).visible = !1;
  };
  c(this, Ye).visible = !0, c(this, Ye).alpha = 1;
  const o = ii(tt(t, "hmax", 10)), u = ii(tt(t, "vmax", 10)), l = o === 0 ? () => {
  } : () => c(this, Ye).x = Math.round(Math.random() * o * 2) - o, h = u === 0 ? () => {
  } : () => c(this, Ye).y = Math.round(Math.random() * u * 2) - u;
  c(this, Ye).filters = [];
  const d = tt(t, "repeat", 1), f = new Tn(c(this, Ye)).to({ x: 0, y: 0 }, e).delay(tt(t, "delay", 0)).easing(ws.ease(n)).onUpdate(() => {
    l(), h();
  }).repeat(d === 0 ? 1 / 0 : d - 1).yoyo(vt(t, "yoyo", !1)).onComplete(() => {
    var p, v;
    (p = this.appPixi.ticker) == null || p.remove(a), c(this, Qt).visible = !0, c(this, Ye).visible = !1, c(this, Ye).x = 0, c(this, Ye).y = 0, (v = c(this, qe).tw) == null || v.stop(), c(this, qe).resume && this.main.resume(), P(this, qe, { tw: void 0, resume: !1 });
  }).start();
  return P(this, qe, { tw: f, resume: !1 }), this.appPixi.ticker.add(a), !1;
}, Kr = new WeakMap(), zg = new WeakSet(), SM = function(t) {
  const { layer: e, render: r, path: n, name: s, ease: a, chain: o } = t;
  if (!e)
    throw "layerは必須です";
  const u = O(this, Ks, bu).call(this, t);
  let l = c(this, Yt)[u].fore, h = () => {
  };
  const d = c(this, Ui).isSkippingByKeyDown();
  !d && r && (l.renderStart(), h = () => l.renderEnd());
  const f = s ?? e, p = () => {
    var I, R;
    const M = c(this, Kr)[f];
    M && (h(), delete c(this, Kr)[f], (I = M.tw) == null || I.stop(), M.resume && this.main.resume(), (R = M.onEnd) == null || R.call(M));
  }, v = av(t, l), g = tt(t, "time", NaN) * (this.val.getVal("tmp:sn.skip.enabled") || d ? 0 : 1), m = ws.ease(a), y = tt(t, "repeat", 1), _ = y === 0 ? 1 / 0 : y - 1, b = vt(t, "yoyo", !1), w = tt(t, "delay", 0), T = new Tn(l).to(v, g).easing(m).repeat(_).yoyo(b).delay(w);
  let x = T;
  if (n) {
    Y.debugLog && console.group(`🍝 [tsy] path=${n}= start(${l.x},${l.y},${l.alpha})`);
    for (const { groups: M } of n.matchAll(Ls.REG_TSY_PATH)) {
      const { x: I, x2: R, y: N, y2: A, o: G, o2: B, json: U } = M;
      let $ = {};
      if (U)
        try {
          $ = JSON.parse(U);
        } catch (z) {
          console.error(`🍝 json=${U} ` + z);
          continue;
        }
      else
        (I ?? R) && ($.x = I ?? R), (N ?? A) && ($.y = N ?? A), (G ?? B) && ($.alpha = G ?? B);
      const Z = av($, l);
      Y.debugLog && console.info(`🍝 ${U ?? `{x:${I} y:${N} o:${G}}`} => hTo:${JSON.stringify(Z)}`);
      const H = new Tn(l).to(Z, g).easing(m).repeat(_).yoyo(b);
      x.chain(H), x = H;
    }
    Y.debugLog && console.groupEnd();
  }
  if (x.onComplete(p), o) {
    const M = c(this, Kr)[o ?? ""];
    if (!(M != null && M.tw))
      throw `${o}は存在しない・または終了したトゥイーンです`;
    delete M.onEnd, M.tw.chain(T);
  } else
    T.start();
  const S = vt(t, "arrive", !1), C = vt(t, "backlay", !1);
  return c(this, Kr)[f] = { tw: x, resume: !1, onEnd: () => {
    if (S && Object.assign(l, v), C) {
      const M = c(this, Yt)[u].back.spLay;
      for (const I of Object.keys(wE))
        M[I] = l[I];
    }
  } }, !1;
}, Hg = new WeakSet(), TM = function(t) {
  const { layer: e = "", id: r, name: n } = t, s = r ? `frm
${r}` : n ?? e;
  if (!s)
    throw "トゥイーンが指定されていません";
  const a = c(this, Kr)[s];
  return a != null && a.tw ? a.resume = c(this, Ui).waitEvent(
    () => {
      var o;
      return (o = a.tw) == null ? void 0 : o.end();
    },
    // stop()とend()は別
    vt(t, "canskip", !0),
    vt(t, "global", !1)
  ) : !1;
}, $g = new WeakSet(), CM = function(t) {
  var a, o;
  const { layer: e = "", id: r, name: n } = t, s = r ? `frm
${r}` : n ?? e;
  if (!s)
    throw "トゥイーンが指定されていません";
  return (o = (a = c(this, Kr)[s]) == null ? void 0 : a.tw) == null || o.end(), !1;
}, Vg = new WeakSet(), MM = function(t) {
  var a, o;
  const { layer: e = "", id: r, name: n } = t, s = r ? `frm
${r}` : n ?? e;
  if (!s)
    throw "トゥイーンが指定されていません";
  return (o = (a = c(this, Kr)[s]) == null ? void 0 : a.tw) == null || o.pause(), !1;
}, Xg = new WeakSet(), PM = function(t) {
  var a, o;
  const { layer: e = "", id: r, name: n } = t, s = r ? `frm
${r}` : n ?? e;
  if (!s)
    throw "トゥイーンが指定されていません";
  return (o = (a = c(this, Kr)[s]) == null ? void 0 : a.tw) == null || o.resume(), !1;
}, Zs = new WeakMap(), wo = new WeakSet(), Bh = function(t) {
  const { text: e } = t;
  if (!e)
    throw "textは必須です";
  const r = c(this, Jr).call(this, t);
  delete t.text, this.val.getVal("tmp:sn.skip.enabled") ? t.wait = 0 : "wait" in t && tt(t, "wait", NaN);
  const n = encodeURIComponent(JSON.stringify(t));
  c(this, Lr).call(this, "add｜" + n, r);
  const s = vt(t, "record", !0), a = this.val.doRecLog();
  return s || this.val.setVal_Nochk("save", "sn.doRecLog", s), r.tagCh(e.replaceAll("[r]", `
`)), this.val.setVal_Nochk("save", "sn.doRecLog", a), c(this, Lr).call(this, "add_close｜", r), !1;
}, Jr = new WeakMap(), Wg = new WeakSet(), OM = function(t) {
  const e = O(this, Ks, bu).call(this, t, c(this, bn)), n = c(this, Yt)[e].getPage(t);
  if (!(n instanceof Se))
    throw e + "はTxtLayerではありません";
  return n;
}, Nf = new WeakMap(), Yg = new WeakSet(), IM = function(t) {
  const { layer: e } = t;
  if (!e)
    throw "[current] layerは必須です";
  if (P(this, xn, c(this, Yt)[e]), !(c(this, xn).getPage(t) instanceof Se))
    throw `${e}はTxtLayerではありません`;
  this.recPagebreak(), P(this, bn, e), this.val.setVal_Nochk("save", "const.sn.mesLayer", e);
  for (const r of O(this, Cr, Xr).call(this)) {
    const n = c(this, Yt)[r];
    n.fore instanceof Se && (n.fore.isCur = n.back.isCur = r === e);
  }
  return !1;
}, xn = new WeakMap(), Eo = new WeakMap(), Ks = new WeakSet(), bu = function(t, e = "") {
  const r = t.layer ?? e;
  if (r.includes(","))
    throw "layer名に「,」は使えません";
  if (!(r in c(this, Yt)))
    throw "属性 layer【" + r + "】が不正です。レイヤーがありません";
  return t.layer = r;
}, ji = new WeakMap(), wn = new WeakMap(), qg = new WeakSet(), RM = function(t) {
  const e = c(this, Jr).call(this, t);
  return t.layer === c(this, bn) && t.page === "fore" && this.recPagebreak(), e.clearText(), !1;
}, Zg = new WeakSet(), DM = function(t) {
  return c(this, Lr).call(this, "endlink｜", c(this, Jr).call(this, t)), !1;
}, Kg = new WeakSet(), kM = function(t) {
  return vt(t, "rec_page_break", !0) && this.recPagebreak(), c(this, xn) && (c(this, xn).fore.clearLay(t), c(this, xn).back.clearLay(t)), !1;
}, Jg = new WeakSet(), NM = function(t) {
  if (!t.pic)
    throw "[graph] picは必須です";
  const e = encodeURIComponent(JSON.stringify(t));
  return c(this, Lr).call(this, "grp｜" + e, c(this, Jr).call(this, t)), !1;
}, Qg = new WeakSet(), AM = function(t) {
  t.style ?? (t.style = "background-color: rgba(255,0,0,0.5);"), t.style_hover ?? (t.style_hover = "background-color: rgba(255,0,0,0.9);"), t.style_clicked ?? (t.style_clicked = t.style);
  const e = encodeURIComponent(JSON.stringify(t));
  return c(this, Lr).call(this, "link｜" + e, c(this, Jr).call(this, t)), !1;
}, tm = new WeakSet(), LM = function(t) {
  return t.text = `
`, O(this, wo, Bh).call(this, t);
}, em = new WeakSet(), BM = function(t) {
  return O(this, Af, K_).call(this, { ...t, text: "[r]" });
}, Af = new WeakSet(), K_ = function(t) {
  return t.text ? (t.record = !0, t.style ?? (t.style = ""), t.style += "display: none;", t.wait = 0, O(this, wo, Bh).call(this, t)) : !1;
}, rm = new WeakSet(), FM = function(t) {
  return P(this, wn, []), P(this, ji, t.text ?? ""), this.val.setVal_Nochk(
    "save",
    "const.sn.sLog",
    t.text ? `[{text:"${t.text}"}]` : "[]"
  ), !1;
}, im = new WeakSet(), GM = function(t) {
  const { t: e, r } = t;
  if (!e)
    throw "[ruby2] tは必須です";
  if (!r)
    throw "[ruby2] rは必須です";
  return t.text = "｜" + encodeURIComponent(e) + "《" + encodeURIComponent(r) + "》", delete t.t, delete t.r, O(this, wo, Bh).call(this, t);
}, nm = new WeakSet(), UM = function(t) {
  const e = encodeURIComponent(JSON.stringify(t));
  return c(this, Lr).call(this, "span｜" + e, c(this, Jr).call(this, t)), !1;
}, sm = new WeakSet(), jM = function(t) {
  if (!t.t)
    throw "[tcy] tは必須です";
  const e = encodeURIComponent(JSON.stringify(t));
  return c(this, Lr).call(this, "tcy｜" + e, c(this, Jr).call(this, t)), !1;
}, am = new WeakSet(), zM = function(t) {
  console.group("🥟 [dump_lay]");
  for (const e of O(this, Cr, Xr).call(this, t.layer)) {
    const r = c(this, Yt)[e];
    try {
      console.info(
        `%c${r.fore.name.slice(0, -7)} %o`,
        `color:#${Y.isDarkMode ? "49F" : "05A"};`,
        JSON.parse(`{"back":{${r.back.dump()}}, "fore":{${r.fore.dump()}}}`)
      );
    } catch (n) {
      console.error("dump_lay err:%o", n), console.error(`   back:${r.back.dump()}`), console.error(`   fore:${r.fore.dump()}`);
    }
  }
  return console.groupEnd(), !1;
}, om = new WeakSet(), HM = function(t) {
  const e = O(this, Ks, bu).call(this, t, c(this, bn)), r = vt(t, "enabled", !0);
  return c(this, Jr).call(this, t).enabled = r, this.val.setVal_Nochk("save", "const.sn.layer." + e + ".enabled", r), !1;
}, um = new WeakSet(), $M = function(t) {
  return Wh.argChk_page(t, "back"), t.clicksebuf ?? (t.clicksebuf = "SYS"), t.entersebuf ?? (t.entersebuf = "SYS"), t.leavesebuf ?? (t.leavesebuf = "SYS"), t.fn || (t.fn = this.scrItr.scriptFn), c(this, Jr).call(this, t).addButton(t), this.scrItr.recodeDesign(t), !1;
}, // 11 match 301 step (0.1ms) PCRE2 https://regex101.com/r/reinpq/1
// List ${x}${x2}/${y}${y2}/${o}${o2}=${json}\n
/*
\(\s*
(?:	(?<x>[-=\d\.]+)	|	(['"])	(?<x2>.*?)	\2	)?
(?:
	\s*,\s*
	(?:	(?<y>[-=\d\.]+)	|	(['"])	(?<y2>.*?)	\5	)?
	(?:
		\s*,\s*
		(?:	(?<o>[-=\d\.]+)	|	(['"])	(?<o2>.*?)	\8	)

	)?
)?
|
(?<json>\{[^{}]*})
*/
K(Ga, "REG_TSY_PATH", /\(\s*(?:(?<x>[-=\d\.]+)|(['"])(?<x2>.*?)\2)?(?:\s*,\s*(?:(?<y>[-=\d\.]+)|(['"])(?<y2>.*?)\5)?(?:\s*,\s*(?:(?<o>[-=\d\.]+)|(['"])(?<o2>.*?)\8))?)?|(?<json>\{[^{}]*})/g), //	// 文字・文字レイヤ
E(Ga, Zs, 10);
var Pe, ge, Rl, lm, VM, Lf, So, Fh;
class q3 {
  constructor() {
    E(this, lm);
    E(this, So);
    E(this, Pe, []);
    E(this, ge, -1);
    E(this, Rl, new Jl());
    E(this, Lf, Y.debugLog ? (t) => console.log(`👾 <FocusMng idx:${t} btn:%o`, c(this, Pe)[t].btn) : () => {
    });
  }
  destroy() {
    P(this, Pe, []), P(this, ge, -1), c(this, Rl).clear();
  }
  add(t, e, r) {
    if (c(this, Pe).findIndex((o) => o.btn === t) >= 0)
      return;
    if (t instanceof ye) {
      t.on("pointerdown", () => {
        for (let o = c(this, Pe).length - 1; o >= 0; --o)
          if (c(this, Pe)[o].btn === t) {
            P(this, ge, o);
            return;
          }
        P(this, ge, -1);
      }), c(this, Pe).push({ btn: t, on: e, off: r });
      return;
    }
    c(this, Rl).add(t, "focus", () => {
      for (let o = c(this, Pe).length - 1; o >= 0; --o)
        if (c(this, Pe)[o].btn === t) {
          P(this, ge, o);
          return;
        }
      P(this, ge, -1);
    });
    let n = (o) => {
    }, s = t.localName === "button" || t.localName === "a" ? (o) => !o.isTrusted && o.key === "Enter" : (o) => o.key === "Enter";
    const a = t;
    switch (a.type ?? "") {
      case "checkbox":
        n = () => a.checked = !a.checked;
        break;
      case "":
        t.querySelectorAll("input[type]").length > 0 && (n = (o) => O(this, lm, VM).call(this, t, o.key), s = () => !1);
        break;
      case "range":
        n = (o) => {
          o.isTrusted || (o.key === "ArrowUp" ? a.stepUp() : a.stepDown());
        };
        break;
      case "text":
      case "textarea":
        n = (o) => {
          if (o.isTrusted)
            return;
          let u = (a.selectionStart ?? 0) + (o.key === "ArrowUp" ? -1 : 1);
          u < 0 && (u = 0), a.setSelectionRange(u, u);
        };
        break;
    }
    c(this, Rl).add(t, "keydown", (o) => {
      if (!(o.key !== "ArrowUp" && o.key !== "ArrowDown" && o.key !== "Enter")) {
        if (o.stopPropagation(), o.stopImmediatePropagation(), s(o)) {
          t.dispatchEvent(new MouseEvent("click"));
          return;
        }
        n(o);
      }
    }, { passive: !0 }), t.hasAttribute("tabindex") || (t.tabIndex = 0), c(this, Pe).push({ btn: t, on: e, off: r });
  }
  remove(t) {
    const e = c(this, Pe).findIndex((r) => r.btn === t);
    e < 0 || (c(this, Pe).splice(e, 1), c(this, Pe).length === 0 ? P(this, ge, -1) : e <= c(this, ge) && --Ve(this, ge)._);
  }
  isFocus(t) {
    return c(this, ge) < 0 ? !1 : c(this, Pe)[c(this, ge)].btn === t;
  }
  prev() {
    O(this, So, Fh).call(this);
    const t = c(this, Pe).length;
    if (t !== 0) {
      --Ve(this, ge)._ < 0 && P(this, ge, t - 1);
      for (let e = t; e >= 1; --e) {
        const r = (c(this, ge) + e) % t;
        if (c(this, Pe)[r].on()) {
          P(this, ge, r), c(this, Lf).call(this, r);
          return;
        }
      }
      P(this, ge, -1);
    }
  }
  next() {
    O(this, So, Fh).call(this);
    const t = c(this, Pe).length;
    if (t !== 0) {
      ++Ve(this, ge)._ >= t && P(this, ge, 0);
      for (let e = 0; e < t; ++e) {
        const r = (c(this, ge) + e) % t;
        if (c(this, Pe)[r].on()) {
          P(this, ge, r), c(this, Lf).call(this, r);
          return;
        }
      }
      P(this, ge, -1);
    }
  }
  getFocus() {
    if (c(this, ge) < 0)
      return null;
    O(this, So, Fh).call(this), c(this, ge) >= c(this, Pe).length && P(this, ge, 0);
    const t = c(this, Pe)[c(this, ge)];
    return t.on() ? t.btn : null;
  }
  blur() {
    O(this, So, Fh).call(this), P(this, ge, -1), globalThis.focus();
  }
}
Pe = new WeakMap(), ge = new WeakMap(), Rl = new WeakMap(), lm = new WeakSet(), VM = function(t, e) {
  const r = t.querySelectorAll("input[type]"), n = r.length;
  for (let s = 0; s < n; ++s)
    if (r[s].checked) {
      r[(s + n + (e === "ArrowUp" ? -1 : 1)) % n].checked = !0;
      break;
    }
}, Lf = new WeakMap(), So = new WeakSet(), Fh = function() {
  for (let t = c(this, Pe).length - 1; t >= 0; --t) {
    const e = c(this, Pe)[t];
    !(e.btn instanceof ye) || e.btn.parent ? e.off() : c(this, Pe).splice(t, 1);
  }
};
var zr = "top", Ci = "bottom", Mi = "right", Hr = "left", _0 = "auto", Rd = [zr, Ci, Mi, Hr], nh = "start", _c = "end", Z3 = "clippingParents", XM = "viewport", Th = "popper", K3 = "reference", Jw = /* @__PURE__ */ Rd.reduce(function(i, t) {
  return i.concat([t + "-" + nh, t + "-" + _c]);
}, []), WM = /* @__PURE__ */ [].concat(Rd, [_0]).reduce(function(i, t) {
  return i.concat([t, t + "-" + nh, t + "-" + _c]);
}, []), J3 = "beforeRead", Q3 = "read", tG = "afterRead", eG = "beforeMain", rG = "main", iG = "afterMain", nG = "beforeWrite", sG = "write", aG = "afterWrite", J_ = [J3, Q3, tG, eG, rG, iG, nG, sG, aG];
function Bn(i) {
  return i ? (i.nodeName || "").toLowerCase() : null;
}
function li(i) {
  if (i == null)
    return window;
  if (i.toString() !== "[object Window]") {
    var t = i.ownerDocument;
    return t && t.defaultView || window;
  }
  return i;
}
function nu(i) {
  var t = li(i).Element;
  return i instanceof t || i instanceof Element;
}
function ai(i) {
  var t = li(i).HTMLElement;
  return i instanceof t || i instanceof HTMLElement;
}
function Hx(i) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = li(i).ShadowRoot;
  return i instanceof t || i instanceof ShadowRoot;
}
function oG(i) {
  var t = i.state;
  Object.keys(t.elements).forEach(function(e) {
    var r = t.styles[e] || {}, n = t.attributes[e] || {}, s = t.elements[e];
    !ai(s) || !Bn(s) || (Object.assign(s.style, r), Object.keys(n).forEach(function(a) {
      var o = n[a];
      o === !1 ? s.removeAttribute(a) : s.setAttribute(a, o === !0 ? "" : o);
    }));
  });
}
function uG(i) {
  var t = i.state, e = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
    Object.keys(t.elements).forEach(function(r) {
      var n = t.elements[r], s = t.attributes[r] || {}, a = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : e[r]), o = a.reduce(function(u, l) {
        return u[l] = "", u;
      }, {});
      !ai(n) || !Bn(n) || (Object.assign(n.style, o), Object.keys(s).forEach(function(u) {
        n.removeAttribute(u);
      }));
    });
  };
}
const lG = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: oG,
  effect: uG,
  requires: ["computeStyles"]
};
function Qi(i) {
  return i.split("-")[0];
}
var Yo = Math.max, Rv = Math.min, sh = Math.round;
function Q_() {
  var i = navigator.userAgentData;
  return i != null && i.brands && Array.isArray(i.brands) ? i.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function YM() {
  return !/^((?!chrome|android).)*safari/i.test(Q_());
}
function ah(i, t, e) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  var r = i.getBoundingClientRect(), n = 1, s = 1;
  t && ai(i) && (n = i.offsetWidth > 0 && sh(r.width) / i.offsetWidth || 1, s = i.offsetHeight > 0 && sh(r.height) / i.offsetHeight || 1);
  var a = nu(i) ? li(i) : window, o = a.visualViewport, u = !YM() && e, l = (r.left + (u && o ? o.offsetLeft : 0)) / n, h = (r.top + (u && o ? o.offsetTop : 0)) / s, d = r.width / n, f = r.height / s;
  return {
    width: d,
    height: f,
    top: h,
    right: l + d,
    bottom: h + f,
    left: l,
    x: l,
    y: h
  };
}
function $x(i) {
  var t = ah(i), e = i.offsetWidth, r = i.offsetHeight;
  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
    x: i.offsetLeft,
    y: i.offsetTop,
    width: e,
    height: r
  };
}
function qM(i, t) {
  var e = t.getRootNode && t.getRootNode();
  if (i.contains(t))
    return !0;
  if (e && Hx(e)) {
    var r = t;
    do {
      if (r && i.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function sn(i) {
  return li(i).getComputedStyle(i);
}
function hG(i) {
  return ["table", "td", "th"].indexOf(Bn(i)) >= 0;
}
function ga(i) {
  return ((nu(i) ? i.ownerDocument : (
    // $FlowFixMe[prop-missing]
    i.document
  )) || window.document).documentElement;
}
function b0(i) {
  return Bn(i) === "html" ? i : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    i.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    i.parentNode || // DOM Element detected
    (Hx(i) ? i.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    ga(i)
  );
}
function Qw(i) {
  return !ai(i) || // https://github.com/popperjs/popper-core/issues/837
  sn(i).position === "fixed" ? null : i.offsetParent;
}
function cG(i) {
  var t = /firefox/i.test(Q_()), e = /Trident/i.test(Q_());
  if (e && ai(i)) {
    var r = sn(i);
    if (r.position === "fixed")
      return null;
  }
  var n = b0(i);
  for (Hx(n) && (n = n.host); ai(n) && ["html", "body"].indexOf(Bn(n)) < 0; ) {
    var s = sn(n);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || t && s.willChange === "filter" || t && s.filter && s.filter !== "none")
      return n;
    n = n.parentNode;
  }
  return null;
}
function Dd(i) {
  for (var t = li(i), e = Qw(i); e && hG(e) && sn(e).position === "static"; )
    e = Qw(e);
  return e && (Bn(e) === "html" || Bn(e) === "body" && sn(e).position === "static") ? t : e || cG(i) || t;
}
function Vx(i) {
  return ["top", "bottom"].indexOf(i) >= 0 ? "x" : "y";
}
function Jh(i, t, e) {
  return Yo(i, Rv(t, e));
}
function fG(i, t, e) {
  var r = Jh(i, t, e);
  return r > e ? e : r;
}
function ZM() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function KM(i) {
  return Object.assign({}, ZM(), i);
}
function JM(i, t) {
  return t.reduce(function(e, r) {
    return e[r] = i, e;
  }, {});
}
var dG = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, KM(typeof t != "number" ? t : JM(t, Rd));
};
function pG(i) {
  var t, e = i.state, r = i.name, n = i.options, s = e.elements.arrow, a = e.modifiersData.popperOffsets, o = Qi(e.placement), u = Vx(o), l = [Hr, Mi].indexOf(o) >= 0, h = l ? "height" : "width";
  if (!(!s || !a)) {
    var d = dG(n.padding, e), f = $x(s), p = u === "y" ? zr : Hr, v = u === "y" ? Ci : Mi, g = e.rects.reference[h] + e.rects.reference[u] - a[u] - e.rects.popper[h], m = a[u] - e.rects.reference[u], y = Dd(s), _ = y ? u === "y" ? y.clientHeight || 0 : y.clientWidth || 0 : 0, b = g / 2 - m / 2, w = d[p], T = _ - f[h] - d[v], x = _ / 2 - f[h] / 2 + b, S = Jh(w, x, T), C = u;
    e.modifiersData[r] = (t = {}, t[C] = S, t.centerOffset = S - x, t);
  }
}
function vG(i) {
  var t = i.state, e = i.options, r = e.element, n = r === void 0 ? "[data-popper-arrow]" : r;
  if (n != null && !(typeof n == "string" && (n = t.elements.popper.querySelector(n), !n))) {
    if (process.env.NODE_ENV !== "production" && (ai(n) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !qM(t.elements.popper, n)) {
      process.env.NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    t.elements.arrow = n;
  }
}
const gG = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: pG,
  effect: vG,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function oh(i) {
  return i.split("-")[1];
}
var mG = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function yG(i, t) {
  var e = i.x, r = i.y, n = t.devicePixelRatio || 1;
  return {
    x: sh(e * n) / n || 0,
    y: sh(r * n) / n || 0
  };
}
function tE(i) {
  var t, e = i.popper, r = i.popperRect, n = i.placement, s = i.variation, a = i.offsets, o = i.position, u = i.gpuAcceleration, l = i.adaptive, h = i.roundOffsets, d = i.isFixed, f = a.x, p = f === void 0 ? 0 : f, v = a.y, g = v === void 0 ? 0 : v, m = typeof h == "function" ? h({
    x: p,
    y: g
  }) : {
    x: p,
    y: g
  };
  p = m.x, g = m.y;
  var y = a.hasOwnProperty("x"), _ = a.hasOwnProperty("y"), b = Hr, w = zr, T = window;
  if (l) {
    var x = Dd(e), S = "clientHeight", C = "clientWidth";
    if (x === li(e) && (x = ga(e), sn(x).position !== "static" && o === "absolute" && (S = "scrollHeight", C = "scrollWidth")), x = x, n === zr || (n === Hr || n === Mi) && s === _c) {
      w = Ci;
      var M = d && x === T && T.visualViewport ? T.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        x[S]
      );
      g -= M - r.height, g *= u ? 1 : -1;
    }
    if (n === Hr || (n === zr || n === Ci) && s === _c) {
      b = Mi;
      var I = d && x === T && T.visualViewport ? T.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        x[C]
      );
      p -= I - r.width, p *= u ? 1 : -1;
    }
  }
  var R = Object.assign({
    position: o
  }, l && mG), N = h === !0 ? yG({
    x: p,
    y: g
  }, li(e)) : {
    x: p,
    y: g
  };
  if (p = N.x, g = N.y, u) {
    var A;
    return Object.assign({}, R, (A = {}, A[w] = _ ? "0" : "", A[b] = y ? "0" : "", A.transform = (T.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + g + "px)" : "translate3d(" + p + "px, " + g + "px, 0)", A));
  }
  return Object.assign({}, R, (t = {}, t[w] = _ ? g + "px" : "", t[b] = y ? p + "px" : "", t.transform = "", t));
}
function _G(i) {
  var t = i.state, e = i.options, r = e.gpuAcceleration, n = r === void 0 ? !0 : r, s = e.adaptive, a = s === void 0 ? !0 : s, o = e.roundOffsets, u = o === void 0 ? !0 : o;
  if (process.env.NODE_ENV !== "production") {
    var l = sn(t.elements.popper).transitionProperty || "";
    a && ["transform", "top", "right", "bottom", "left"].some(function(d) {
      return l.indexOf(d) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var h = {
    placement: Qi(t.placement),
    variation: oh(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: n,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, tE(Object.assign({}, h, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: a,
    roundOffsets: u
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, tE(Object.assign({}, h, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: u
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const bG = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: _G,
  data: {}
};
var xp = {
  passive: !0
};
function xG(i) {
  var t = i.state, e = i.instance, r = i.options, n = r.scroll, s = n === void 0 ? !0 : n, a = r.resize, o = a === void 0 ? !0 : a, u = li(t.elements.popper), l = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return s && l.forEach(function(h) {
    h.addEventListener("scroll", e.update, xp);
  }), o && u.addEventListener("resize", e.update, xp), function() {
    s && l.forEach(function(h) {
      h.removeEventListener("scroll", e.update, xp);
    }), o && u.removeEventListener("resize", e.update, xp);
  };
}
const wG = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: xG,
  data: {}
};
var EG = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Zp(i) {
  return i.replace(/left|right|bottom|top/g, function(t) {
    return EG[t];
  });
}
var SG = {
  start: "end",
  end: "start"
};
function eE(i) {
  return i.replace(/start|end/g, function(t) {
    return SG[t];
  });
}
function Xx(i) {
  var t = li(i), e = t.pageXOffset, r = t.pageYOffset;
  return {
    scrollLeft: e,
    scrollTop: r
  };
}
function Wx(i) {
  return ah(ga(i)).left + Xx(i).scrollLeft;
}
function TG(i, t) {
  var e = li(i), r = ga(i), n = e.visualViewport, s = r.clientWidth, a = r.clientHeight, o = 0, u = 0;
  if (n) {
    s = n.width, a = n.height;
    var l = YM();
    (l || !l && t === "fixed") && (o = n.offsetLeft, u = n.offsetTop);
  }
  return {
    width: s,
    height: a,
    x: o + Wx(i),
    y: u
  };
}
function CG(i) {
  var t, e = ga(i), r = Xx(i), n = (t = i.ownerDocument) == null ? void 0 : t.body, s = Yo(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), a = Yo(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), o = -r.scrollLeft + Wx(i), u = -r.scrollTop;
  return sn(n || e).direction === "rtl" && (o += Yo(e.clientWidth, n ? n.clientWidth : 0) - s), {
    width: s,
    height: a,
    x: o,
    y: u
  };
}
function Yx(i) {
  var t = sn(i), e = t.overflow, r = t.overflowX, n = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + n + r);
}
function QM(i) {
  return ["html", "body", "#document"].indexOf(Bn(i)) >= 0 ? i.ownerDocument.body : ai(i) && Yx(i) ? i : QM(b0(i));
}
function Qh(i, t) {
  var e;
  t === void 0 && (t = []);
  var r = QM(i), n = r === ((e = i.ownerDocument) == null ? void 0 : e.body), s = li(r), a = n ? [s].concat(s.visualViewport || [], Yx(r) ? r : []) : r, o = t.concat(a);
  return n ? o : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    o.concat(Qh(b0(a)))
  );
}
function tb(i) {
  return Object.assign({}, i, {
    left: i.x,
    top: i.y,
    right: i.x + i.width,
    bottom: i.y + i.height
  });
}
function MG(i, t) {
  var e = ah(i, !1, t === "fixed");
  return e.top = e.top + i.clientTop, e.left = e.left + i.clientLeft, e.bottom = e.top + i.clientHeight, e.right = e.left + i.clientWidth, e.width = i.clientWidth, e.height = i.clientHeight, e.x = e.left, e.y = e.top, e;
}
function rE(i, t, e) {
  return t === XM ? tb(TG(i, e)) : nu(t) ? MG(t, e) : tb(CG(ga(i)));
}
function PG(i) {
  var t = Qh(b0(i)), e = ["absolute", "fixed"].indexOf(sn(i).position) >= 0, r = e && ai(i) ? Dd(i) : i;
  return nu(r) ? t.filter(function(n) {
    return nu(n) && qM(n, r) && Bn(n) !== "body";
  }) : [];
}
function OG(i, t, e, r) {
  var n = t === "clippingParents" ? PG(i) : [].concat(t), s = [].concat(n, [e]), a = s[0], o = s.reduce(function(u, l) {
    var h = rE(i, l, r);
    return u.top = Yo(h.top, u.top), u.right = Rv(h.right, u.right), u.bottom = Rv(h.bottom, u.bottom), u.left = Yo(h.left, u.left), u;
  }, rE(i, a, r));
  return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;
}
function tP(i) {
  var t = i.reference, e = i.element, r = i.placement, n = r ? Qi(r) : null, s = r ? oh(r) : null, a = t.x + t.width / 2 - e.width / 2, o = t.y + t.height / 2 - e.height / 2, u;
  switch (n) {
    case zr:
      u = {
        x: a,
        y: t.y - e.height
      };
      break;
    case Ci:
      u = {
        x: a,
        y: t.y + t.height
      };
      break;
    case Mi:
      u = {
        x: t.x + t.width,
        y: o
      };
      break;
    case Hr:
      u = {
        x: t.x - e.width,
        y: o
      };
      break;
    default:
      u = {
        x: t.x,
        y: t.y
      };
  }
  var l = n ? Vx(n) : null;
  if (l != null) {
    var h = l === "y" ? "height" : "width";
    switch (s) {
      case nh:
        u[l] = u[l] - (t[h] / 2 - e[h] / 2);
        break;
      case _c:
        u[l] = u[l] + (t[h] / 2 - e[h] / 2);
        break;
    }
  }
  return u;
}
function bc(i, t) {
  t === void 0 && (t = {});
  var e = t, r = e.placement, n = r === void 0 ? i.placement : r, s = e.strategy, a = s === void 0 ? i.strategy : s, o = e.boundary, u = o === void 0 ? Z3 : o, l = e.rootBoundary, h = l === void 0 ? XM : l, d = e.elementContext, f = d === void 0 ? Th : d, p = e.altBoundary, v = p === void 0 ? !1 : p, g = e.padding, m = g === void 0 ? 0 : g, y = KM(typeof m != "number" ? m : JM(m, Rd)), _ = f === Th ? K3 : Th, b = i.rects.popper, w = i.elements[v ? _ : f], T = OG(nu(w) ? w : w.contextElement || ga(i.elements.popper), u, h, a), x = ah(i.elements.reference), S = tP({
    reference: x,
    element: b,
    strategy: "absolute",
    placement: n
  }), C = tb(Object.assign({}, b, S)), M = f === Th ? C : x, I = {
    top: T.top - M.top + y.top,
    bottom: M.bottom - T.bottom + y.bottom,
    left: T.left - M.left + y.left,
    right: M.right - T.right + y.right
  }, R = i.modifiersData.offset;
  if (f === Th && R) {
    var N = R[n];
    Object.keys(I).forEach(function(A) {
      var G = [Mi, Ci].indexOf(A) >= 0 ? 1 : -1, B = [zr, Ci].indexOf(A) >= 0 ? "y" : "x";
      I[A] += N[B] * G;
    });
  }
  return I;
}
function IG(i, t) {
  t === void 0 && (t = {});
  var e = t, r = e.placement, n = e.boundary, s = e.rootBoundary, a = e.padding, o = e.flipVariations, u = e.allowedAutoPlacements, l = u === void 0 ? WM : u, h = oh(r), d = h ? o ? Jw : Jw.filter(function(v) {
    return oh(v) === h;
  }) : Rd, f = d.filter(function(v) {
    return l.indexOf(v) >= 0;
  });
  f.length === 0 && (f = d, process.env.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var p = f.reduce(function(v, g) {
    return v[g] = bc(i, {
      placement: g,
      boundary: n,
      rootBoundary: s,
      padding: a
    })[Qi(g)], v;
  }, {});
  return Object.keys(p).sort(function(v, g) {
    return p[v] - p[g];
  });
}
function RG(i) {
  if (Qi(i) === _0)
    return [];
  var t = Zp(i);
  return [eE(i), t, eE(t)];
}
function DG(i) {
  var t = i.state, e = i.options, r = i.name;
  if (!t.modifiersData[r]._skip) {
    for (var n = e.mainAxis, s = n === void 0 ? !0 : n, a = e.altAxis, o = a === void 0 ? !0 : a, u = e.fallbackPlacements, l = e.padding, h = e.boundary, d = e.rootBoundary, f = e.altBoundary, p = e.flipVariations, v = p === void 0 ? !0 : p, g = e.allowedAutoPlacements, m = t.options.placement, y = Qi(m), _ = y === m, b = u || (_ || !v ? [Zp(m)] : RG(m)), w = [m].concat(b).reduce(function(lt, et) {
      return lt.concat(Qi(et) === _0 ? IG(t, {
        placement: et,
        boundary: h,
        rootBoundary: d,
        padding: l,
        flipVariations: v,
        allowedAutoPlacements: g
      }) : et);
    }, []), T = t.rects.reference, x = t.rects.popper, S = /* @__PURE__ */ new Map(), C = !0, M = w[0], I = 0; I < w.length; I++) {
      var R = w[I], N = Qi(R), A = oh(R) === nh, G = [zr, Ci].indexOf(N) >= 0, B = G ? "width" : "height", U = bc(t, {
        placement: R,
        boundary: h,
        rootBoundary: d,
        altBoundary: f,
        padding: l
      }), $ = G ? A ? Mi : Hr : A ? Ci : zr;
      T[B] > x[B] && ($ = Zp($));
      var Z = Zp($), H = [];
      if (s && H.push(U[N] <= 0), o && H.push(U[$] <= 0, U[Z] <= 0), H.every(function(lt) {
        return lt;
      })) {
        M = R, C = !1;
        break;
      }
      S.set(R, H);
    }
    if (C)
      for (var z = v ? 3 : 1, X = function(et) {
        var k = w.find(function(ft) {
          var Q = S.get(ft);
          if (Q)
            return Q.slice(0, et).every(function(St) {
              return St;
            });
        });
        if (k)
          return M = k, "break";
      }, ct = z; ct > 0; ct--) {
        var it = X(ct);
        if (it === "break")
          break;
      }
    t.placement !== M && (t.modifiersData[r]._skip = !0, t.placement = M, t.reset = !0);
  }
}
const kG = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: DG,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function iE(i, t, e) {
  return e === void 0 && (e = {
    x: 0,
    y: 0
  }), {
    top: i.top - t.height - e.y,
    right: i.right - t.width + e.x,
    bottom: i.bottom - t.height + e.y,
    left: i.left - t.width - e.x
  };
}
function nE(i) {
  return [zr, Mi, Ci, Hr].some(function(t) {
    return i[t] >= 0;
  });
}
function NG(i) {
  var t = i.state, e = i.name, r = t.rects.reference, n = t.rects.popper, s = t.modifiersData.preventOverflow, a = bc(t, {
    elementContext: "reference"
  }), o = bc(t, {
    altBoundary: !0
  }), u = iE(a, r), l = iE(o, n, s), h = nE(u), d = nE(l);
  t.modifiersData[e] = {
    referenceClippingOffsets: u,
    popperEscapeOffsets: l,
    isReferenceHidden: h,
    hasPopperEscaped: d
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": h,
    "data-popper-escaped": d
  });
}
const AG = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: NG
};
function LG(i, t, e) {
  var r = Qi(i), n = [Hr, zr].indexOf(r) >= 0 ? -1 : 1, s = typeof e == "function" ? e(Object.assign({}, t, {
    placement: i
  })) : e, a = s[0], o = s[1];
  return a = a || 0, o = (o || 0) * n, [Hr, Mi].indexOf(r) >= 0 ? {
    x: o,
    y: a
  } : {
    x: a,
    y: o
  };
}
function BG(i) {
  var t = i.state, e = i.options, r = i.name, n = e.offset, s = n === void 0 ? [0, 0] : n, a = WM.reduce(function(h, d) {
    return h[d] = LG(d, t.rects, s), h;
  }, {}), o = a[t.placement], u = o.x, l = o.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += u, t.modifiersData.popperOffsets.y += l), t.modifiersData[r] = a;
}
const FG = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: BG
};
function GG(i) {
  var t = i.state, e = i.name;
  t.modifiersData[e] = tP({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const UG = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: GG,
  data: {}
};
function jG(i) {
  return i === "x" ? "y" : "x";
}
function zG(i) {
  var t = i.state, e = i.options, r = i.name, n = e.mainAxis, s = n === void 0 ? !0 : n, a = e.altAxis, o = a === void 0 ? !1 : a, u = e.boundary, l = e.rootBoundary, h = e.altBoundary, d = e.padding, f = e.tether, p = f === void 0 ? !0 : f, v = e.tetherOffset, g = v === void 0 ? 0 : v, m = bc(t, {
    boundary: u,
    rootBoundary: l,
    padding: d,
    altBoundary: h
  }), y = Qi(t.placement), _ = oh(t.placement), b = !_, w = Vx(y), T = jG(w), x = t.modifiersData.popperOffsets, S = t.rects.reference, C = t.rects.popper, M = typeof g == "function" ? g(Object.assign({}, t.rects, {
    placement: t.placement
  })) : g, I = typeof M == "number" ? {
    mainAxis: M,
    altAxis: M
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, M), R = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, N = {
    x: 0,
    y: 0
  };
  if (x) {
    if (s) {
      var A, G = w === "y" ? zr : Hr, B = w === "y" ? Ci : Mi, U = w === "y" ? "height" : "width", $ = x[w], Z = $ + m[G], H = $ - m[B], z = p ? -C[U] / 2 : 0, X = _ === nh ? S[U] : C[U], ct = _ === nh ? -C[U] : -S[U], it = t.elements.arrow, lt = p && it ? $x(it) : {
        width: 0,
        height: 0
      }, et = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : ZM(), k = et[G], ft = et[B], Q = Jh(0, S[U], lt[U]), St = b ? S[U] / 2 - z - Q - k - I.mainAxis : X - Q - k - I.mainAxis, at = b ? -S[U] / 2 + z + Q + ft + I.mainAxis : ct + Q + ft + I.mainAxis, q = t.elements.arrow && Dd(t.elements.arrow), bt = q ? w === "y" ? q.clientTop || 0 : q.clientLeft || 0 : 0, st = (A = R == null ? void 0 : R[w]) != null ? A : 0, W = $ + St - st - bt, nt = $ + at - st, dt = Jh(p ? Rv(Z, W) : Z, $, p ? Yo(H, nt) : H);
      x[w] = dt, N[w] = dt - $;
    }
    if (o) {
      var V, xt = w === "x" ? zr : Hr, Dt = w === "x" ? Ci : Mi, Ct = x[T], be = T === "y" ? "height" : "width", je = Ct + m[xt], ee = Ct - m[Dt], pe = [zr, Hr].indexOf(y) !== -1, le = (V = R == null ? void 0 : R[T]) != null ? V : 0, ae = pe ? je : Ct - S[be] - C[be] - le + I.altAxis, ne = pe ? Ct + S[be] + C[be] - le - I.altAxis : ee, Ht = p && pe ? fG(ae, Ct, ne) : Jh(p ? ae : je, Ct, p ? ne : ee);
      x[T] = Ht, N[T] = Ht - Ct;
    }
    t.modifiersData[r] = N;
  }
}
const HG = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: zG,
  requiresIfExists: ["offset"]
};
function $G(i) {
  return {
    scrollLeft: i.scrollLeft,
    scrollTop: i.scrollTop
  };
}
function VG(i) {
  return i === li(i) || !ai(i) ? Xx(i) : $G(i);
}
function XG(i) {
  var t = i.getBoundingClientRect(), e = sh(t.width) / i.offsetWidth || 1, r = sh(t.height) / i.offsetHeight || 1;
  return e !== 1 || r !== 1;
}
function WG(i, t, e) {
  e === void 0 && (e = !1);
  var r = ai(t), n = ai(t) && XG(t), s = ga(t), a = ah(i, n, e), o = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = {
    x: 0,
    y: 0
  };
  return (r || !r && !e) && ((Bn(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  Yx(s)) && (o = VG(t)), ai(t) ? (u = ah(t, !0), u.x += t.clientLeft, u.y += t.clientTop) : s && (u.x = Wx(s))), {
    x: a.left + o.scrollLeft - u.x,
    y: a.top + o.scrollTop - u.y,
    width: a.width,
    height: a.height
  };
}
function YG(i) {
  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), r = [];
  i.forEach(function(s) {
    t.set(s.name, s);
  });
  function n(s) {
    e.add(s.name);
    var a = [].concat(s.requires || [], s.requiresIfExists || []);
    a.forEach(function(o) {
      if (!e.has(o)) {
        var u = t.get(o);
        u && n(u);
      }
    }), r.push(s);
  }
  return i.forEach(function(s) {
    e.has(s.name) || n(s);
  }), r;
}
function qG(i) {
  var t = YG(i);
  return J_.reduce(function(e, r) {
    return e.concat(t.filter(function(n) {
      return n.phase === r;
    }));
  }, []);
}
function ZG(i) {
  var t;
  return function() {
    return t || (t = new Promise(function(e) {
      Promise.resolve().then(function() {
        t = void 0, e(i());
      });
    })), t;
  };
}
function Ds(i) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    e[r - 1] = arguments[r];
  return [].concat(e).reduce(function(n, s) {
    return n.replace(/%s/, s);
  }, i);
}
var wa = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', KG = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', sE = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function JG(i) {
  i.forEach(function(t) {
    [].concat(Object.keys(t), sE).filter(function(e, r, n) {
      return n.indexOf(e) === r;
    }).forEach(function(e) {
      switch (e) {
        case "name":
          typeof t.name != "string" && console.error(Ds(wa, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"'));
          break;
        case "enabled":
          typeof t.enabled != "boolean" && console.error(Ds(wa, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"'));
          break;
        case "phase":
          J_.indexOf(t.phase) < 0 && console.error(Ds(wa, t.name, '"phase"', "either " + J_.join(", "), '"' + String(t.phase) + '"'));
          break;
        case "fn":
          typeof t.fn != "function" && console.error(Ds(wa, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "effect":
          t.effect != null && typeof t.effect != "function" && console.error(Ds(wa, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "requires":
          t.requires != null && !Array.isArray(t.requires) && console.error(Ds(wa, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(t.requiresIfExists) || console.error(Ds(wa, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + sE.map(function(r) {
            return '"' + r + '"';
          }).join(", ") + '; but "' + e + '" was provided.');
      }
      t.requires && t.requires.forEach(function(r) {
        i.find(function(n) {
          return n.name === r;
        }) == null && console.error(Ds(KG, String(t.name), r, r));
      });
    });
  });
}
function QG(i, t) {
  var e = /* @__PURE__ */ new Set();
  return i.filter(function(r) {
    var n = t(r);
    if (!e.has(n))
      return e.add(n), !0;
  });
}
function t4(i) {
  var t = i.reduce(function(e, r) {
    var n = e[r.name];
    return e[r.name] = n ? Object.assign({}, n, r, {
      options: Object.assign({}, n.options, r.options),
      data: Object.assign({}, n.data, r.data)
    }) : r, e;
  }, {});
  return Object.keys(t).map(function(e) {
    return t[e];
  });
}
var aE = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", e4 = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", oE = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function uE() {
  for (var i = arguments.length, t = new Array(i), e = 0; e < i; e++)
    t[e] = arguments[e];
  return !t.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function r4(i) {
  i === void 0 && (i = {});
  var t = i, e = t.defaultModifiers, r = e === void 0 ? [] : e, n = t.defaultOptions, s = n === void 0 ? oE : n;
  return function(o, u, l) {
    l === void 0 && (l = s);
    var h = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, oE, s),
      modifiersData: {},
      elements: {
        reference: o,
        popper: u
      },
      attributes: {},
      styles: {}
    }, d = [], f = !1, p = {
      state: h,
      setOptions: function(y) {
        var _ = typeof y == "function" ? y(h.options) : y;
        g(), h.options = Object.assign({}, s, h.options, _), h.scrollParents = {
          reference: nu(o) ? Qh(o) : o.contextElement ? Qh(o.contextElement) : [],
          popper: Qh(u)
        };
        var b = qG(t4([].concat(r, h.options.modifiers)));
        if (h.orderedModifiers = b.filter(function(R) {
          return R.enabled;
        }), process.env.NODE_ENV !== "production") {
          var w = QG([].concat(b, h.options.modifiers), function(R) {
            var N = R.name;
            return N;
          });
          if (JG(w), Qi(h.options.placement) === _0) {
            var T = h.orderedModifiers.find(function(R) {
              var N = R.name;
              return N === "flip";
            });
            T || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var x = sn(u), S = x.marginTop, C = x.marginRight, M = x.marginBottom, I = x.marginLeft;
          [S, C, M, I].some(function(R) {
            return parseFloat(R);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return v(), p.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var y = h.elements, _ = y.reference, b = y.popper;
          if (!uE(_, b)) {
            process.env.NODE_ENV !== "production" && console.error(aE);
            return;
          }
          h.rects = {
            reference: WG(_, Dd(b), h.options.strategy === "fixed"),
            popper: $x(b)
          }, h.reset = !1, h.placement = h.options.placement, h.orderedModifiers.forEach(function(R) {
            return h.modifiersData[R.name] = Object.assign({}, R.data);
          });
          for (var w = 0, T = 0; T < h.orderedModifiers.length; T++) {
            if (process.env.NODE_ENV !== "production" && (w += 1, w > 100)) {
              console.error(e4);
              break;
            }
            if (h.reset === !0) {
              h.reset = !1, T = -1;
              continue;
            }
            var x = h.orderedModifiers[T], S = x.fn, C = x.options, M = C === void 0 ? {} : C, I = x.name;
            typeof S == "function" && (h = S({
              state: h,
              options: M,
              name: I,
              instance: p
            }) || h);
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: ZG(function() {
        return new Promise(function(m) {
          p.forceUpdate(), m(h);
        });
      }),
      destroy: function() {
        g(), f = !0;
      }
    };
    if (!uE(o, u))
      return process.env.NODE_ENV !== "production" && console.error(aE), p;
    p.setOptions(l).then(function(m) {
      !f && l.onFirstUpdate && l.onFirstUpdate(m);
    });
    function v() {
      h.orderedModifiers.forEach(function(m) {
        var y = m.name, _ = m.options, b = _ === void 0 ? {} : _, w = m.effect;
        if (typeof w == "function") {
          var T = w({
            state: h,
            name: y,
            instance: p,
            options: b
          }), x = function() {
          };
          d.push(T || x);
        }
      });
    }
    function g() {
      d.forEach(function(m) {
        return m();
      }), d = [];
    }
    return p;
  };
}
var i4 = [wG, UG, bG, lG, FG, kG, HG, gG, AG], n4 = /* @__PURE__ */ r4({
  defaultModifiers: i4
});
const { GamepadListener: s4 } = require("gamepad.js");
var Mr, Js, or, Bf, Ff, eb, Gf, rb, Uf, ib, Dl, kl, jf, nb, Re, yi, ls, hs, zf, Qs, xu, Hf, $f, mr, Nl, Al, Vf, hm, eP, Xf, To, cm, rP, Wf, sb, fm, iP, Yf, ab, Co, Gh, Mo, dm, nP, pm, sP, _i, vm, aP, gm, oP, Ll, Kp, cs, Po, Oo, mm, uP, Pr;
class a4 {
  constructor(t, e, r, n, s, a, o, u, l) {
    E(this, Ff);
    E(this, Gf);
    E(this, Uf);
    E(this, jf);
    E(this, Qs);
    E(this, hm);
    // イベントを全消去
    E(this, cm);
    E(this, Wf);
    // イベントを予約
    E(this, fm);
    E(this, Yf);
    E(this, Co);
    // 行末クリック待ち
    E(this, dm);
    // 改ページクリック待ち
    E(this, pm);
    E(this, vm);
    // フォーカス移動
    E(this, gm);
    // ウェイトを入れる
    E(this, Ll);
    // クリックを待つ
    E(this, mm);
    E(this, Mr, new Jl());
    E(this, Js, new s4({
      analog: !1,
      deadZone: 0.3
    }));
    E(this, or, new q3());
    E(this, Bf, (t) => {
    });
    E(this, Dl, !1);
    E(this, kl, !1);
    E(this, Re, {});
    E(this, yi, {});
    E(this, ls, !1);
    E(this, hs, !1);
    // 予約イベントの発生待ち中か
    E(this, zf, (t) => c(this, Re)[t] ?? c(this, yi)[t]);
    E(this, Hf, () => {
      P(this, Hf, () => {
      }), this.scrItr.firstWait();
    });
    E(this, $f, {
      getBoundingClientRect: (t = 0, e = 0) => DOMRect.fromRect({ x: t, y: e, width: 0, height: 0 })
    });
    E(this, mr, void 0);
    E(this, Nl, void 0);
    E(this, Al, void 0);
    E(this, Vf, {
      placement: "bottom",
      fallbackPlacements: ["top", "bottom"]
    });
    E(this, Xf, (t, e) => {
    });
    E(this, To, new Jl());
    E(this, Mo, () => this.layMng.goTxt());
    // スキップ中断予約
    E(this, _i, () => !1);
    E(this, cs, () => {
    });
    E(this, Po, new Pi());
    E(this, Oo, "sn:notice_comp_txt");
    // 0:no push  1:one push  2:push repeating
    E(this, Pr, {
      Alt: 0,
      Meta: 0,
      // COMMANDキー
      Control: 0,
      ArrowDown: 0,
      End: 0,
      Enter: 0,
      Escape: 0,
      " ": 0,
      GoBack: 0
      // AndroidのBackキーだと思う
    });
    var g, m;
    if (this.cfg = t, this.hTag = e, this.appPixi = r, this.main = n, this.layMng = s, this.val = a, this.sndMng = o, this.scrItr = u, this.sys = l, e.clear_event = (y) => O(this, cm, rP).call(this, y), e.event = (y) => O(this, fm, iP).call(this, y), e.l = (y) => O(this, dm, nP).call(this, y), e.p = (y) => O(this, pm, sP).call(this, y), e.s = () => (u.recodePage(), O(this, Qs, xu).call(this, () => {
    }, !1, !0)), e.set_cancel_skip = () => O(this, vm, aP).call(this), e.set_focus = (y) => O(this, gm, oP).call(this, y), e.wait = (y) => O(this, Ll, Kp).call(this, y), e.waitclick = () => O(this, mm, uP).call(this), o.setEvtMng(this), u.setOtherObj(this, s), Se.setEvtMng(n, this, l), s.setEvtMng(this), l.setFire((y, _) => this.fire(y, _)), Y.isDbg) {
      const y = {
        pause: () => {
          if (P(this, ls, !0), !c(this, hs))
            return;
          const _ = {};
          u.recodeDesign(_), l.callHook("_enterDesign", _), l.send2Dbg("_enterDesign", _);
        },
        stopOnBreakpoint: () => P(this, ls, !0),
        stopOnDataBreakpoint: () => P(this, ls, !0),
        continue: () => P(this, ls, !1),
        disconnect: () => P(this, ls, !1)
      };
      y.attach = y.stopOnEntry = y.stopOnStep = y.stopOnStepIn = y.stopOnStepOut = y.stopOnBackstep = y.pause, l.addHook((_) => {
        var b;
        return (b = y[_]) == null ? void 0 : b.call(y);
      });
    }
    Au(`
.sn_hint {
	background-color: #3c3225;
	color: white;
	padding: 4px 8px;
	border-radius: 4px;
	font-size: 1.2em;
	z-index: 10000;
	pointer-events: none;
	user-select: none;
}

.sn_hint_ar,
.sn_hint_ar::before {
	position: absolute;
	width: 8px;
	height: 8px;
	background: inherit;
}
.sn_hint_ar {
	visibility: hidden;
}
.sn_hint_ar::before {
	visibility: visible;
	content: '';
	transform: rotate(45deg);
}

.sn_hint[data-popper-placement^='top']		> .sn_hint_ar {bottom: -4px;}
.sn_hint[data-popper-placement^='bottom']	> .sn_hint_ar {top: -4px;}
.sn_hint[data-popper-placement^='left']		> .sn_hint_ar {right: -4px;}
.sn_hint[data-popper-placement^='right']	> .sn_hint_ar {left: -4px;}
`);
    for (const y of Array.from(document.getElementsByClassName("sn_hint")))
      (g = y.parentElement) == null || g.removeChild(y);
    (m = Ur.cvs.parentElement) == null || m.insertAdjacentHTML("beforeend", `
<div class="sn_hint" role="tooltip">
	<span>Dummy</span>
	<div class="sn_hint_ar" data-popper-arrow></div>
</div>`), P(this, mr, document.querySelector(".sn_hint")), P(this, Nl, c(this, mr).querySelector("span")), P(this, Al, n4(c(this, $f), c(this, mr))), c(this, mr).hidden = !0, r.stage.interactive = !0, Y.isMobile ? r.stage.on("pointerdown", (y) => this.fire("click", y)) : c(this, Mr).add(r.stage, "pointerdown", (y) => {
      switch (y.data.button) {
        case 0:
          this.fire("click", y);
          break;
        case 1:
          this.fire("middleclick", y);
          break;
      }
    }), c(this, Mr).add(window, "keydown", (y) => O(this, Ff, eb).call(this, y)), c(this, Mr).add(Ur.cvs, "contextmenu", (y) => O(this, Gf, rb).call(this, y));
    const h = () => a.setVal_Nochk("tmp", "const.sn.navigator.language", navigator.language);
    c(this, Mr).add(window, "languagechange", (y) => {
      h(), this.fire("sn:chgNavLang", y), UE();
    }), h();
    const d = (y) => {
      Y.isDarkMode = y.matches, a.setVal_Nochk("tmp", "const.sn.isDarkMode", Y.isDarkMode);
    }, f = globalThis.matchMedia("(prefers-color-scheme: dark)");
    d(f), c(this, Mr).add(f, "change", (y) => {
      d(y), this.fire("sn:chgDarkMode", y);
    }), "WheelEvent" in window && (c(this, Mr).add(Ur.cvs, "wheel", (y) => O(this, Uf, ib).call(this, y), { passive: !0 }), P(this, Bf, (y) => c(this, Mr).add(y, "wheel", (_) => O(this, Uf, ib).call(this, _), { passive: !0 })), P(this, Xf, (y, _) => y.add(Ur.cvs, "wheel", (b) => {
      b.isComposing || b.deltaY <= 0 || (b.stopPropagation(), _());
    }))), Y.debugLog && (c(this, Js).on("gamepad:connected", (y) => console.log(`👺<'gamepad:connected' index:${y.detail.index} id:${y.detail.gamepad.id}`)), c(this, Js).on("gamepad:disconnected", (y) => console.log(`👺<'gamepad:disconnected' index:${y.detail.index} id:${y.detail.gamepad.id}`)));
    const p = [
      "",
      "ArrowUp",
      "",
      // '7', '8', '9',
      "ArrowLeft",
      "",
      "ArrowRight",
      // '4', '5', '6',
      "",
      "ArrowDown",
      ""
      // '1', '2', '3',
    ], v = [0, 0];
    c(this, Js).on("gamepad:axis", (y) => {
      if (!document.hasFocus() || y.detail.stick !== 0)
        return;
      v[y.detail.axis] = y.detail.value;
      const _ = (v[1] + 1) * 3 + (v[0] + 1), b = p[_];
      if (!b)
        return;
      const w = c(this, or).getFocus();
      (!w || w instanceof ye ? globalThis : w).dispatchEvent(new KeyboardEvent("keydown", { key: b, bubbles: !0 })), !(!w || w instanceof ye) && w.getAttribute("type") === "range" && w.dispatchEvent(new InputEvent("input", { bubbles: !0 }));
    }), c(this, Js).on("gamepad:button", (y) => {
      if (document.hasFocus())
        if (y.detail.button % 2 === 0) {
          const _ = c(this, or).getFocus();
          (!_ || _ instanceof ye ? globalThis : _).dispatchEvent(new KeyboardEvent("keydown", { key: "Enter", bubbles: !0 }));
        } else
          Ur.cvs.dispatchEvent(new Event("contextmenu"));
    }), c(this, Js).start(), c(this, Mr).add(window, "keyup", (y) => {
      y.isComposing || y.key in c(this, Pr) && (c(this, Pr)[y.key] = 0);
    }), a.defTmp("const.sn.key.alternate", () => c(this, Pr).Alt > 0), a.defTmp("const.sn.key.command", () => c(this, Pr).Meta > 0), a.defTmp("const.sn.key.control", () => c(this, Pr).Control > 0), a.defTmp("const.sn.key.end", () => c(this, Pr).End > 0), a.defTmp("const.sn.key.escape", () => c(this, Pr).Escape > 0), a.defTmp("const.sn.key.back", () => c(this, Pr).GoBack > 0);
  }
  resvFlameEvent(t) {
    c(this, Mr).add(t, "keydown", (e) => O(this, Ff, eb).call(this, e)), c(this, Mr).add(t, "contextmenu", (e) => O(this, Gf, rb).call(this, e)), c(this, Bf).call(this, t);
  }
  destroy() {
    c(this, or).destroy(), c(this, Mr).clear();
  }
  fire(t, e) {
    var s;
    if (c(this, _i).call(this) || !c(this, hs) || c(this, ls))
      return;
    const r = t.toLowerCase();
    if (Y.debugLog && console.log(`👺 fire<(key:\`${r}\` type:${e.type} e:%o)`, { ...e }), r === "enter") {
      const a = c(this, or).getFocus();
      if (a instanceof ye) {
        a.emit("pointerdown", new Event("pointerdown"));
        return;
      }
    }
    const n = c(this, zf).call(this, r);
    if (!n) {
      r.slice(0, 5) === "swipe" && globalThis.scrollBy(
        -e.deltaX,
        -e.deltaY
      );
      return;
    }
    r.slice(-5) !== "wheel" && ((s = e.preventDefault) == null || s.call(e)), e.stopPropagation(), !(r.slice(0, 4) !== "dom=" && this.layMng.clickTxtLay()) && (P(this, hs, !1), n(e));
  }
  popLocalEvts() {
    const t = c(this, Re);
    return P(this, Re, {}), t;
  }
  pushLocalEvts(t) {
    P(this, Re, t);
  }
  waitEvent(t, e = !0, r = !1) {
    if (e && r)
      throw "canskipとglobalを同時にtrue指定できません";
    if (this.val.getVal("tmp:sn.skip.enabled")) {
      if (this.val.getVal("tmp:sn.skip.all") || this.scrItr.isNextKidoku)
        return t(), !1;
      c(this, _i).call(this);
    }
    return O(this, Qs, xu).call(this, t, e, r);
  }
  unButton(t) {
    c(this, or).remove(t);
  }
  button(t, e, r, n, s) {
    var d;
    !t.fn && !t.label && this.main.errScript("fnまたはlabelは必須です"), e.interactive = e.buttonMode = !0;
    const a = ((d = t.key) == null ? void 0 : d.toLowerCase()) ?? " ";
    t.fn || (t.fn = this.scrItr.scriptFn);
    const o = vt(t, "global", !1);
    o ? c(this, yi)[a] = () => this.main.resumeByJumpOrCall(t) : c(this, Re)[a] = () => this.main.resumeByJumpOrCall(t), e.on("pointerdown", (f) => this.fire(a, f));
    const u = t.hint ? () => O(this, hm, eP).call(this, t, e) : () => {
    }, l = () => {
      r(), c(this, mr).hidden = !0;
    }, h = () => (u(), n());
    if (e.on("pointerover", h), e.on("pointerout", () => {
      c(this, or).isFocus(e) ? h() : l();
    }), e.on("pointerdown", () => {
      c(this, mr).hidden = !0;
      const f = c(this, or).getFocus();
      s(), f instanceof Yi && f.normal();
    }), e.on(
      "pointerup",
      Y.isMobile ? l : () => {
        c(this, or).isFocus(e) ? h() : l();
      }
    ), c(this, or).add(e, h, l), t.clickse && (this.cfg.searchPath(t.clickse, vr.SOUND), e.on("pointerdown", () => {
      const f = { fn: t.clickse, join: !1 };
      t.clicksebuf && (f.buf = t.clicksebuf), this.hTag.playse(f);
    })), t.enterse && (this.cfg.searchPath(t.enterse, vr.SOUND), e.on("pointerover", () => {
      const f = { fn: t.enterse, join: !1 };
      t.entersebuf && (f.buf = t.entersebuf), this.hTag.playse(f);
    })), t.leavese && (this.cfg.searchPath(t.leavese, vr.SOUND), e.on("pointerout", () => {
      const f = { fn: t.leavese, join: !1 };
      t.leavesebuf && (f.buf = t.leavesebuf), this.hTag.playse(f);
    })), t.onenter) {
      const f = a + t.onenter.toLowerCase(), p = { fn: t.fn, label: t.onenter, call: !0, key: f };
      o ? c(this, yi)[f] = () => this.main.resumeByJumpOrCall(p) : c(this, Re)[f] = () => this.main.resumeByJumpOrCall(p), e.on("pointerover", (v) => this.fire(f, v));
    }
    if (t.onleave) {
      const f = a + t.onleave.toLowerCase(), p = { fn: t.fn, label: t.onleave, call: !0, key: f };
      o ? c(this, yi)[f] = () => this.main.resumeByJumpOrCall(p) : c(this, Re)[f] = () => this.main.resumeByJumpOrCall(p), e.on("pointerout", (v) => this.fire(f, v));
    }
  }
  hideHint() {
    c(this, mr).hidden = !0;
  }
  cvsResize() {
    c(this, mr).hidden = !0;
  }
  // 予約イベントの発生待ちしない waitEvent()
  waitLimitedEvent(t, e) {
    c(this, Mo).call(this), this.val.saveKidoku();
    const r = () => {
      c(this, To).clear(), e();
    };
    if (this.val.getVal("tmp:sn.skip.enabled"))
      if (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
      !this.scrItr.isNextKidoku)
        c(this, _i).call(this);
      else
        return r(), !1;
    return vt(t, "canskip", !0) && (c(this, To).add(window, "pointerdown", (n) => {
      n.stopPropagation(), r();
    }), c(this, To).add(window, "keydown", (n) => {
      n.isComposing || (n.stopPropagation(), r());
    }), c(this, Xf).call(this, c(this, To), r)), !0;
  }
  noticeCompTxt() {
    c(this, Po).emit(c(this, Oo));
  }
  // キー押下によるスキップ中か
  isSkippingByKeyDown() {
    return this.scrItr.skip4page ? !0 : Object.keys(c(this, Pr)).some((t) => c(this, Pr)[t] === 2);
  }
}
Mr = new WeakMap(), Js = new WeakMap(), or = new WeakMap(), Bf = new WeakMap(), Ff = new WeakSet(), eb = function(t) {
  if (t.isComposing)
    return;
  t.key in c(this, Pr) && (c(this, Pr)[t.key] = t.repeat ? 2 : 1);
  const e = (t.altKey ? t.key === "Alt" ? "" : "alt+" : "") + (t.ctrlKey ? t.key === "Control" ? "" : "ctrl+" : "") + (t.shiftKey ? t.key === "Shift" ? "" : "shift+" : "") + t.key;
  this.fire(e, t);
}, Gf = new WeakSet(), rb = function(t) {
  const e = (t.altKey ? t.key === "Alt" ? "" : "alt+" : "") + (t.ctrlKey ? t.key === "Control" ? "" : "ctrl+" : "") + (t.shiftKey ? t.key === "Shift" ? "" : "shift+" : "") + "rightclick";
  this.fire(e, t), t.preventDefault();
}, Uf = new WeakSet(), ib = function(t) {
  if (t.isComposing)
    return;
  if (c(this, Dl)) {
    P(this, kl, !0);
    return;
  }
  P(this, Dl, !0), O(this, jf, nb).call(this);
  const e = (t.altKey ? "alt+" : "") + (t.ctrlKey ? "ctrl+" : "") + (t.shiftKey ? "shift+" : "") + (t.deltaY > 0 ? "downwheel" : "upwheel");
  this.fire(e, t);
}, Dl = new WeakMap(), kl = new WeakMap(), jf = new WeakSet(), nb = function() {
  setTimeout(() => {
    if (c(this, kl)) {
      P(this, kl, !1), O(this, jf, nb).call(this);
      return;
    }
    P(this, Dl, !1);
  }, 250);
}, Re = new WeakMap(), yi = new WeakMap(), ls = new WeakMap(), hs = new WeakMap(), zf = new WeakMap(), Qs = new WeakSet(), xu = function(t, e = !0, r = !0) {
  if (c(this, Mo).call(this), this.val.saveKidoku(), e ? c(this, Re).click = //this.hTag.event({key:'enter', breakout: fnc});
  //hTag.event({key:'down', breakout: fnc});
  //	hTag.event()は内部で使わず、こうする
  c(this, Re).enter = c(this, Re).arrowdown = // hTag.event({key:'downwheel', breakout: fnc});
  //	hTag.event()は内部で使わず、こうする
  c(this, Re)["wheel.y>0"] = t : (delete c(this, Re).click, delete c(this, Re).enter, delete c(this, Re).arrowdown, delete c(this, Re)["wheel.y>0"]), P(this, zf, r ? (n) => c(this, Re)[n] ?? c(this, yi)[n] : (n) => c(this, Re)[n]), P(this, hs, !0), c(this, Hf).call(this), Y.debugLog) {
    const n = /* @__PURE__ */ Object.create(null);
    n.local = Object.keys(c(this, Re)), n.global = Object.keys(c(this, yi)), console.log("🎍 wait event... %o", n);
  }
  return !0;
}, Hf = new WeakMap(), $f = new WeakMap(), mr = new WeakMap(), Nl = new WeakMap(), Al = new WeakMap(), Vf = new WeakMap(), hm = new WeakSet(), eP = function(t, e) {
  const r = e instanceof Yi ? e.getBtnBounds() : e.getBounds();
  if (!(t[":タグ名"] === "link")) {
    const s = e.parent.parent;
    r.x += s.x, r.y += s.y;
  }
  if (!t.hint) {
    c(this, mr).hidden = !0;
    return;
  }
  c(this, mr).style.cssText = `position:${c(this, mr).style.position}; transform:${c(this, mr).style.transform};` + (t.hint_style ?? ""), c(this, Nl).style.cssText = "", c(this, Nl).textContent = t.hint ?? "";
  try {
    const s = t.hint_opt ? { ...c(this, Vf), ...JSON.parse(t.hint_opt) } : c(this, Vf);
    c(this, Al).setOptions(s);
  } catch (s) {
    console.error(Tp(t, "hint_opt", s.message));
  }
  c(this, $f).getBoundingClientRect = () => DOMRect.fromRect({
    x: this.sys.ofsLeft4elm + r.x * this.sys.cvsScale,
    y: this.sys.ofsTop4elm + r.y * this.sys.cvsScale,
    width: r.width,
    height: r.height
  }), c(this, Al).update(), c(this, mr).hidden = !1;
}, Xf = new WeakMap(), To = new WeakMap(), cm = new WeakSet(), rP = function(t) {
  const e = vt(t, "global", !1), r = e ? c(this, yi) : c(this, Re);
  for (const [n, s] of Object.entries(r))
    O(this, Wf, sb).call(this, n, s);
  return e ? P(this, yi, {}) : P(this, Re, {}), P(this, hs, !1), !1;
}, Wf = new WeakSet(), sb = function(t, e) {
  t.slice(0, 4) === "dom=" && O(this, Co, Gh).call(this, t).el.forEach((r) => r.removeEventListener("click", e));
}, fm = new WeakSet(), iP = function(t) {
  const e = t.key;
  if (!e)
    throw "keyは必須です";
  const r = e.toLowerCase(), n = vt(t, "call", !1), s = vt(t, "global", !1) ? c(this, yi) : c(this, Re);
  if (vt(t, "del", !1)) {
    if (t.fn || t.label || n)
      throw "fn/label/callとdelは同時指定できません";
    return O(this, Wf, sb).call(this, e, s[r]), delete s[r], !1;
  }
  if (t.fn ?? (t.fn = this.scrItr.scriptFn), e.slice(0, 4) === "dom=") {
    const a = O(this, Co, Gh).call(this, e);
    if (a.el.length === 0) {
      if (vt(t, "need_err", !0))
        throw `HTML内にセレクタ（${a.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;
      return !1;
    }
    let o = ["click", "keydown"];
    switch (a.el[0].type ?? "") {
      case "checkbox":
        o = ["input"];
        break;
      case "range":
        o = ["input"];
        break;
      case "text":
      case "textarea":
        o = ["input", "change"];
        break;
    }
    o.forEach((l, h) => a.el.forEach((d) => {
      c(this, Mr).add(d, l, (f) => {
        if (!c(this, hs) || this.layMng.getFrmDisabled(a.id) || l === "keydown" && f.key !== "Enter")
          return;
        const p = d.dataset;
        for (const [v, g] of Object.entries(p))
          this.val.setVal_Nochk("tmp", `sn.event.domdata.${v}`, g);
        this.fire(e, f);
      }), h === 0 && c(this, or).add(
        d,
        () => O(this, Yf, ab).call(this, d) ? (d.focus(), !0) : !1,
        () => {
        }
      );
    }));
  }
  return s[r] = () => this.main.resumeByJumpOrCall(t), !1;
}, Yf = new WeakSet(), ab = function(t) {
  if (t.offsetParent === null)
    return !1;
  let e = t;
  do {
    if (getComputedStyle(e).display === "none" || e.dataset.focus === "false" || e != null && e.disabled)
      return !1;
    e = e.parentElement;
  } while (e !== null);
  return !0;
}, Co = new WeakSet(), Gh = function(t) {
  const e = t.indexOf(":");
  let r = "";
  if (e >= 0) {
    const n = t.slice(4, e), s = `const.sn.frm.${n}`;
    if (!this.val.getVal(`tmp:${s}`, 0))
      throw `HTML【${n}】が読み込まれていません`;
    const o = document.getElementById(n).contentWindow;
    return r = t.slice(e + 1), { el: o.document.querySelectorAll(r), id: n, sel: r };
  }
  return r = t.slice(4), { el: document.querySelectorAll(r), id: "", sel: r };
}, Mo = new WeakMap(), dm = new WeakSet(), nP = function(t) {
  if (this.scrItr.skip4page)
    return !1;
  if (!this.val.getVal("tmp:sn.tagL.enabled"))
    return c(this, Mo).call(this), !1;
  if (this.val.getVal("tmp:sn.skip.enabled")) {
    if (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
    !this.scrItr.isNextKidoku)
      c(this, _i).call(this);
    else if ("ps".includes(this.val.getVal("sys:sn.skip.mode")))
      return !1;
  }
  return this.val.getVal("tmp:sn.auto.enabled") ? O(this, Ll, Kp).call(this, {
    time: Number(this.scrItr.isKidoku ? this.val.getVal("sys:sn.auto.msecLineWait_Kidoku") : this.val.getVal("sys:sn.auto.msecLineWait"))
  }) : (vt(t, "visible", !0) && this.layMng.breakLine(), O(this, Qs, xu).call(this, () => this.main.resume()));
}, pm = new WeakSet(), sP = function(t) {
  if (this.scrItr.recodePage(), this.val.getVal("tmp:sn.skip.enabled")) {
    if (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
    !this.scrItr.isNextKidoku)
      c(this, _i).call(this);
    else if (this.val.getVal("sys:sn.skip.mode") == "s")
      return c(this, Mo).call(this), !1;
  }
  if (this.val.getVal("tmp:sn.auto.enabled"))
    return O(this, Ll, Kp).call(this, {
      time: Number(this.scrItr.isKidoku ? this.val.getVal("sys:sn.auto.msecPageWait_Kidoku") : this.val.getVal("sys:sn.auto.msecPageWait"))
    });
  vt(t, "visible", !0) && this.layMng.breakPage();
  const e = () => {
    this.sndMng.clearCache(), this.main.resume();
  };
  return O(this, Qs, xu).call(this, vt(t, "er", !1) && this.layMng.currentTxtlayFore ? () => {
    this.hTag.er(t), e();
  } : e);
}, _i = new WeakMap(), vm = new WeakSet(), aP = function() {
  return P(this, _i, () => (P(this, _i, () => !1), this.val.setVal_Nochk("tmp", "sn.tagL.enabled", !0), this.val.setVal_Nochk("tmp", "sn.skip.enabled", !1), this.val.setVal_Nochk("tmp", "sn.auto.enabled", !1), this.layMng.setNormalChWait(), c(this, cs).call(this), !0)), !1;
}, gm = new WeakSet(), oP = function(t) {
  const { add: e, del: r, to: n } = t;
  if ((e == null ? void 0 : e.slice(0, 4)) === "dom=") {
    const s = O(this, Co, Gh).call(this, e);
    if (s.el.length === 0 && vt(t, "need_err", !0))
      throw `HTML内にセレクタ（${s.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;
    return s.el.forEach((a) => c(this, or).add(
      a,
      () => O(this, Yf, ab).call(this, a) ? (a.focus(), !0) : !1,
      () => {
      }
    )), !1;
  }
  if ((r == null ? void 0 : r.slice(0, 4)) === "dom=") {
    const s = O(this, Co, Gh).call(this, r);
    if (s.el.length === 0 && vt(t, "need_err", !0))
      throw `HTML内にセレクタ（${s.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;
    return s.el.forEach((a) => c(this, or).remove(a)), !1;
  }
  if (!n)
    throw "[set_focus] add か to は必須です";
  switch (n) {
    case "null":
      c(this, or).blur();
      break;
    case "next":
      c(this, or).next();
      break;
    case "prev":
      c(this, or).prev();
      break;
  }
  return !1;
}, Ll = new WeakSet(), Kp = function(t) {
  const e = tt(t, "time", NaN);
  return this.scrItr.skip4page ? !1 : this.val.getVal("tmp:sn.skip.enabled") ? (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
  !this.scrItr.isNextKidoku && c(this, _i).call(this), !1) : (c(this, Po).once(c(this, Oo), () => {
    c(this, Po).off(c(this, Oo));
    const r = new Tn({}).to({}, e).onComplete(() => {
      P(this, cs, () => {
      }), r.stop(), this.main.resume();
    }).start();
    P(this, cs, () => r.end());
  }), P(this, cs, () => {
    P(this, cs, () => {
    }), c(this, Po).off(c(this, Oo));
  }), this.waitEvent(
    () => c(this, cs).call(this),
    vt(t, "canskip", !0),
    // スキップ中は利かない
    vt(t, "global", !1)
  ));
}, cs = new WeakMap(), Po = new WeakMap(), Oo = new WeakMap(), mm = new WeakSet(), uP = function() {
  return this.scrItr.skip4page ? !1 : ((this.val.getVal("tmp:sn.skip.enabled") || this.val.getVal("tmp:sn.auto.enabled")) && c(this, _i).call(this), O(this, Qs, xu).call(this, () => this.main.resume()));
}, Pr = new WeakMap();
class lE {
  constructor(t = "", e = 0, r = { ":hEvt1Time": {}, ":hMp": {} }) {
    K(this, "toString", () => `[fn:${this.fn}, idx:${this.idx}, csArg:${this.csArg}]`);
    this.fn = t, this.idx = e, this.csArg = r;
  }
}
var qt, ie, yt, me, fe, fs, qf, ob, Io, ta, ym, ea, Zf, ub, Kf, lb, Jf, ra, Eu, Ro, Uh, Do, ds, Ne, _m, lP, ko, jh, bm, hP, Qf, Bl, Qr, xm, cP, wm, fP, ps, Oa, Em, dP, No, Ao, td, ed, rd, ti, Sm, pP, Tm, vP, Cm, gP, id, hb, Mm, mP, Pm, yP, Om, _P, nd, cb, sd, Lo, zh, Bo, vs, Ia, ad, fb, od, ud, db, Im, Rm, ld, Dm, bP, cr, km, xP, hd, pb, Nm, Am, Lm, wP, Bm, EP, gs, cd, vb, Fm, SP, Gm, TP, Um, jm, CP, fd, Fl, zm, MP, Gl, Jp, Ul, Hm, PP, zi, $m, OP, jl, Qp, Vm, IP, Hi, fr;
const Wr = class {
  constructor(t, e, r, n, s, a, o, u, l) {
    E(this, qf);
    E(this, Zf);
    E(this, Kf);
    E(this, ra);
    E(this, Ro);
    E(this, _m);
    E(this, ko);
    E(this, bm);
    //	//	変数操作
    // インラインテキスト代入
    E(this, xm);
    //	// デバッグ・その他
    // スタックのダンプ
    E(this, wm);
    E(this, ps);
    // 外部へスクリプトを表示
    E(this, Em);
    // FIFOバッファ（push/unshift）
    E(this, Sm);
    E(this, Tm);
    //	// ラベル・ジャンプ
    // サブルーチンコール
    E(this, Cm);
    E(this, id);
    // シナリオジャンプ
    E(this, Mm);
    // ページ移動
    E(this, Pm);
    // コールスタック破棄
    E(this, Om);
    // サブルーチンから戻る
    E(this, nd);
    E(this, Lo);
    E(this, vs);
    // 初期化前に終了した場合向け
    E(this, ad);
    E(this, ud);
    E(this, Dm);
    //{} シナリオキャッシュ
    E(this, km);
    E(this, hd);
    E(this, Lm);
    E(this, Bm);
    E(this, cd);
    //	// マクロ
    // 括弧マクロの定義
    E(this, Fm);
    // 一文字マクロの定義
    E(this, Gm);
    E(this, jm);
    // https://regex101.com/r/Lk9ASK/1
    //	// しおり
    // しおりの読込
    E(this, zm);
    E(this, Gl);
    // スクリプト再読込
    E(this, Hm);
    E(this, $m);
    E(this, jl);
    // しおりの保存
    E(this, Vm);
    E(this, qt, { aToken: [""], len: 1, aLNum: [1] });
    E(this, ie, "");
    E(this, yt, 0);
    E(this, me, 0);
    K(this, "addLineNum", (t) => P(this, me, c(this, me) + t));
    E(this, fe, []);
    // FILOバッファ（push/pop）
    E(this, fs, new dA());
    K(this, "firstWait", () => {
    });
    E(this, Io, {
      //auth: // constructorで
      //launch:	// ここでは冒頭停止に間に合わないのでanalyzeInit()で
      disconnect: () => {
        P(Wr, Do, {}), P(Wr, ds, {}), this.isBreak = () => !1, c(this, Io).continue({}), P(this, Ne, 0);
      },
      restart: () => this.isBreak = () => !1,
      // ブレークポイント登録
      add_break: (t) => O(this, qf, ob).call(this, t.fn, t.o),
      data_break: (t) => {
        c(this, Ne) === 0 && (P(this, Ne, 1), this.main.setLoop(!1, `変数 ${t.dataId}【${t.old_v}】→【${t.new_v}】データブレーク`), this.sys.callHook("stopOnDataBreakpoint", {}), this.sys.send2Dbg("stopOnDataBreakpoint", {}));
      },
      set_func_break: (t) => {
        P(Wr, ds, {});
        for (const e of t.a)
          c(Wr, ds)[e.name] = 1;
        this.sys.send2Dbg(t.ri, {});
      },
      // 情報問い合わせ系
      stack: (t) => this.sys.send2Dbg(t.ri, { a: O(this, bm, hP).call(this) }),
      eval: (t) => {
        this.sys.send2Dbg(t.ri, { v: this.prpPrs.parse(t.txt) });
      },
      // デバッガからの操作系
      continue: () => {
        O(this, Ro, Uh).call(this) || (P(this, yt, c(this, yt) - c(this, ra, Eu)), P(this, Ne, 3), this.main.setLoop(!0), this.main.resume());
      },
      stepover: (t) => O(this, Zf, ub).call(this, t),
      stepin: () => {
        if (O(this, Ro, Uh).call(this))
          return;
        const t = c(this, qt).aToken[c(this, yt) - c(this, ra, Eu)];
        this.sys.callHook(`stopOnStep${c(this, Fl).test(t) ? "In" : ""}`, {}), P(this, yt, c(this, yt) - c(this, ra, Eu)), P(this, Ne, c(this, Ne) === 1 ? 4 : 5), this.main.setLoop(!0), this.main.resume();
      },
      stepout: (t) => {
        O(this, Ro, Uh).call(this) || (c(this, fe).length > 0 ? O(this, Kf, lb).call(this, !0) : O(this, Zf, ub).call(this, t));
      },
      pause: () => {
        P(this, Ne, 4), this.main.setLoop(!1, "一時停止"), this.sys.send2Dbg("stopOnStep", {});
      },
      stopOnEntry: () => {
        P(this, Ne, 4), this.main.setLoop(!1, "一時停止"), this.sys.send2Dbg("stopOnEntry", {});
      }
    });
    E(this, ta, (t) => this.cfg.searchPath(t, vr.SCRIPT));
    // https://regex101.com/r/Km54EK/1 141 steps (~0ms)
    E(this, ea, (t) => (this.sys.pathBaseCnvSnPath4Dbg + c(this, ta).call(this, t)).replace(c(Wr, ym), `$1/prj/$2/${c(this, ie)}$3`));
    K(this, "cnvPath4Dbg", (t) => this.sys.pathBaseCnvSnPath4Dbg + t.replace("/crypto_prj/", "/prj/"));
    E(this, Jf, 0);
    E(this, Ne, 0);
    // https://raw.githubusercontent.com/famibee/SKYNovel-vscode-extension/master/src/doc/BreakStateSMD.pu
    K(this, "isBreak", (t) => !1);
    // result = true : waitする  resume()で再開
    E(this, Qf, (t) => {
    });
    E(this, Bl, void 0);
    E(this, Qr, void 0);
    E(this, No, () => {
    });
    E(this, Ao, () => {
    });
    E(this, td, "");
    E(this, ed, {});
    K(this, "noticeBreak", (t) => {
    });
    E(this, rd, 5);
    //	// 条件分岐
    E(this, ti, [-1]);
    E(this, sd, "");
    E(this, Bo, "");
    // シナリオ解析処理ループ・冒頭処理
    K(this, "nextToken", () => "");
    E(this, od, (t) => {
    });
    E(this, Im, /(\*{2,})([^\|]*)/);
    E(this, Rm, /\[macro\s/);
    E(this, ld, /\[endmacro[\s\]]/);
    E(this, cr, /* @__PURE__ */ Object.create(null));
    E(this, Nm, /^\[(call|loadplugin)\s/);
    E(this, Am, /\bfn\s*=\s*[^\s\]]+/);
    E(this, gs, !1);
    // マクロ定義の開始
    E(this, Um, new RegExp(`["'#;\\]　]+`));
    E(this, fd, "call");
    E(this, Fl, /\[(call)\b/);
    E(this, Ul, !1);
    // セーブポイント指定
    E(this, zi, {
      hSave: {},
      hPages: {},
      aIfStk: [-1]
    });
    E(this, Hi, []);
    E(this, fr, -1);
    this.cfg = t, this.hTag = e, this.main = r, this.val = n, this.alzTagArg = s, this.runAnalyze = a, this.prpPrs = o, this.sndMng = u, this.sys = l, e.let_ml = (d) => O(this, xm, cP).call(this, d), e.endlet_ml = () => !1, e.dump_stack = () => O(this, wm, fP).call(this), e.dump_script = (d) => O(this, Em, dP).call(this, d), e.else = // その他ifブロック開始
    e.elsif = // 別条件のifブロック開始
    e.endif = () => O(this, Sm, pP).call(this), e.if = (d) => O(this, Tm, vP).call(this, d), e.call = (d) => O(this, Cm, gP).call(this, d), e.jump = (d) => O(this, Mm, mP).call(this, d), e.page = (d) => O(this, Pm, yP).call(this, d), e.pop_stack = (d) => O(this, Om, _P).call(this, d), e.return = (d) => O(this, nd, cb).call(this, d), e.bracket2macro = (d) => O(this, Fm, SP).call(this, d), e.char2macro = (d) => O(this, Gm, TP).call(this, d), e.endmacro = (d) => O(this, nd, cb).call(this, d), e.macro = (d) => O(this, jm, CP).call(this, d), e.load = (d) => O(this, zm, MP).call(this, d), e.reload_script = (d) => O(this, Hm, PP).call(this, d), e.record_place = () => O(this, $m, OP).call(this), e.save = (d) => O(this, Vm, IP).call(this, d), t.oCfg.debug.token && P(this, od, (d) => console.log(`🌱 トークン fn:${c(this, ie)} idx:${c(this, yt)} ln:${c(this, me)} token【${d}】`)), n.defTmp("const.sn.vctCallStk.length", () => c(this, fe).length);
    const h = t.oCfg.init.escape;
    if (c(this, fs).setEscape(h), ua.setEscape(h), Y.isDbg) {
      l.addHook((f, p) => {
        var v, g;
        return (g = (v = c(this, Io))[f]) == null ? void 0 : g.call(v, p);
      }), this.isBreak = O(this, _m, lP);
      const d = this.analyzeInit;
      this.analyzeInit = () => {
        this.analyzeInit = () => {
        }, this.sys.send2Dbg("hi", {});
      }, c(this, Io).auth = (f) => {
        const p = f.hBreakpoint.hFn2hLineBP;
        for (const [v, g] of Object.entries(p))
          O(this, qf, ob).call(this, v, g);
        P(Wr, ds, {});
        for (const v of f.hBreakpoint.aFunc)
          c(Wr, ds)[v.name] = 1;
        if (f.stopOnEntry) {
          for (; ; ) {
            let v = this.nextToken();
            if (!v)
              break;
            const g = v.charCodeAt(0);
            if (g === 91 || g === 38 || g === 42 && v.length === 1)
              break;
            g === 10 && P(this, me, c(this, me) + v.length);
          }
          this.sys.callHook("stopOnEntry", {}), this.analyzeInit = d, this.analyzeInit();
        } else
          this.firstWait = () => {
            this.sys.callHook("stopOnEntry", {});
          }, this.analyzeInit = d, this.analyzeInit();
      };
    } else
      this.recodeDesign = () => {
      };
    t.oCfg.debug.tag && P(this, Qf, (d) => console.log(`🌲 タグ解析 fn:${c(this, ie)} idx:${c(this, yt)} ln:${c(this, me)} [${d} %o]`, this.alzTagArg.hPrm));
  }
  get scriptFn() {
    return c(this, ie);
  }
  subIdxToken() {
    --Ve(this, yt)._;
  }
  get lineNum() {
    return c(this, me);
  }
  destroy() {
    this.isBreak = () => !1;
  }
  タグ解析(t) {
    const [e, r] = Op(t), n = this.hTag[e];
    if (!n)
      throw `未定義のタグ【${e}】です`;
    this.alzTagArg.parse(r), c(this, Qf).call(this, e);
    const s = this.alzTagArg.hPrm;
    if (s.cond) {
      const u = s.cond.val;
      if (!u || u.at(0) === "&")
        throw "属性condは「&」が不要です";
      const l = this.prpPrs.parse(u), h = String(l);
      if (h === "null" || h === "undefined" || !l)
        return !1;
    }
    let a = {};
    const o = c(this, fe).length;
    if (this.alzTagArg.isKomeParam) {
      if (o === 0)
        throw "属性「*」はマクロのみ有効です";
      a = { ...c(this, fe)[c(this, fe).length - 1].csArg };
    }
    a[":タグ名"] = e;
    for (const [u, { val: l, def: h }] of Object.entries(s)) {
      let d = l;
      if ((d == null ? void 0 : d.at(0)) === "%") {
        if (o === 0)
          throw "属性「%」はマクロ定義内でのみ使用できます（そのマクロの引数を示す簡略文法であるため）";
        const f = c(this, fe)[c(this, fe).length - 1].csArg[d.slice(1)];
        if (f) {
          a[u] = f;
          continue;
        }
        if (h === void 0 || h === "null")
          continue;
        d = h;
      }
      if (d = this.prpPrs.getValAmpersand(d ?? ""), d !== "undefined") {
        a[u] = d;
        continue;
      }
      h !== void 0 && (d = this.prpPrs.getValAmpersand(h), d !== "undefined" && (a[u] = d));
    }
    return n(a);
  }
  setOtherObj(t, e) {
    P(this, Bl, t), P(this, Qr, e);
  }
  dumpErrForeLine() {
    if (c(this, yt) === 0) {
      console.group(`🥟 Error line (from 0 rows before) fn:${c(this, ie)}`), console.groupEnd();
      return;
    }
    let t = "";
    for (let a = c(this, yt) - 1; a >= 0 && (t = c(this, qt).aToken[a] + t, !((t.match(/\n/g) ?? []).length >= c(this, rd))); --a)
      ;
    const e = t.split(`
`).slice(-c(this, rd)), r = e.length;
    console.group(`🥟 Error line (from ${r} rows before) fn:${c(this, ie)}`);
    const n = String(c(this, me)).length, s = O(this, ps, Oa).call(this, c(this, qt), c(this, yt));
    for (let a = 0; a < r; ++a) {
      const o = c(this, me) - r + a + 1, u = `${String(o).padStart(n, " ")}: %c`, l = e[a], h = l.length > 75 ? l.slice(0, 75) + "…" : l;
      a === r - 1 ? console.info(
        u + h.slice(0, s.col_s) + "%c" + h.slice(s.col_s),
        "color: black; background-color: skyblue;",
        "color: black; background-color: pink;"
      ) : console.info(u + h, "color: black; background-color: skyblue;");
    }
    console.groupEnd();
  }
  analyzeInit() {
    const t = O(this, Dm, bP).call(this, c(this, qt), !!this.val.getVal("mp:const.sn.macro.name"), c(this, me), c(this, Bo), c(this, yt));
    P(this, yt, t.idx), P(this, me, t.ln), this.runAnalyze();
  }
  get isKidoku() {
    return c(this, gs);
  }
  get isNextKidoku() {
    let t = c(this, ie), e = c(this, yt), r = c(this, qt).len;
    if (c(this, fe).length > 0) {
      const s = c(this, fe)[0];
      t = s.fn, e = s.idx;
      const a = c(this, cr)[t];
      a && (r = a.len);
    }
    const n = this.val.getAreaKidoku(t);
    return !n || e === r ? !1 : n.search(e);
  }
  get normalWait() {
    return c(this, gs) ? this.val.getVal("sys:sn.tagCh.doWait_Kidoku") ? ii(this.val.getVal("sys:sn.tagCh.msecWait_Kidoku")) : 0 : this.val.getVal("sys:sn.tagCh.doWait") ? ii(this.val.getVal("sys:sn.tagCh.msecWait")) : 0;
  }
  get skip4page() {
    return c(this, Ul);
  }
  recodePage() {
    if (P(this, Ul, !1), !this.val.getVal("save:sn.doRecLog"))
      return;
    const { fn: t, idx: e } = O(this, jl, Qp).call(this), r = e - 1, n = r + ":" + t, s = c(this, Hi).findIndex((o) => o.key === n);
    if (s > -1) {
      P(this, fr, s);
      return;
    }
    const a = {
      key: n,
      fn: t,
      idx: r,
      retFn: t,
      retIdx: 0,
      retMark: { ...c(this, zi) }
    };
    if (c(this, fr) >= 0) {
      const o = c(this, Hi)[c(this, fr)];
      a.retFn = o.fn, a.retIdx = o.idx + 1;
    }
    ++Ve(this, fr)._ === c(this, Hi).length ? c(this, Hi).push(a) : c(this, Hi)[c(this, fr)] = a;
  }
  recodeDesign(t) {
    let e = "", r = 0;
    const n = c(this, fe).length;
    if (t.design_unit && n > 0) {
      const o = c(this, fe)[0];
      e = o.fn, r = o.idx;
    } else
      e = c(this, ie), r = c(this, yt);
    t[":path"] = c(this, ea).call(this, e);
    const s = O(this, ps, Oa).call(this, c(this, cr)[e], r);
    t[":ln"] = s.ln, t[":col_s"] = s.col_s, t[":col_e"] = s.col_e;
    const a = r - 1;
    t[":idx_tkn"] = a, t[":token"] = c(this, cr)[e].aToken[a], this.sys.send2Dbg("_recodeDesign", t);
  }
  replace(t, e) {
    c(this, qt).aToken[t] = e;
  }
};
let wu = Wr;
qt = new WeakMap(), ie = new WeakMap(), yt = new WeakMap(), me = new WeakMap(), fe = new WeakMap(), fs = new WeakMap(), qf = new WeakSet(), ob = function(t, e) {
  c(Wr, Do)[c(this, ea).call(this, t)] = e;
}, Io = new WeakMap(), ta = new WeakMap(), ym = new WeakMap(), ea = new WeakMap(), Zf = new WeakSet(), ub = function(t) {
  if (O(this, Ro, Uh).call(this))
    return;
  const e = c(this, qt).aToken[c(this, yt) - c(this, ra, Eu)];
  c(this, Fl).test(e) ? O(this, Kf, lb).call(this, !1) : (this.sys.callHook("stopOnStep", {}), c(this, Io).stepin(t));
}, Kf = new WeakSet(), lb = function(t) {
  this.sys.callHook(`stopOnStep${t ? "Out" : ""}`, {}), P(this, Jf, c(this, fe).length - (t ? 1 : 0)), P(this, yt, c(this, yt) - c(this, ra, Eu)), P(this, Ne, t ? 7 : 6), this.main.setLoop(!0), this.main.resume();
}, Jf = new WeakMap(), ra = new WeakSet(), Eu = function() {
  return c(this, Ne) === 2 || c(this, Ne) === 4 ? 1 : 0;
}, Ro = new WeakSet(), Uh = function() {
  return c(this, yt) < c(this, qt).len ? !1 : (this.sys.callHook("stopOnEntry", {}), this.main.setLoop(!1, "スクリプト終端です"), !0);
}, Do = new WeakMap(), ds = new WeakMap(), Ne = new WeakMap(), _m = new WeakSet(), lP = function(t) {
  switch (c(this, Ne)) {
    case 6:
      O(this, ko, jh).call(this), P(this, Ne, 7);
      break;
    case 7:
      if (c(this, fe).length !== c(this, Jf))
        break;
      return P(this, Ne, 4), this.main.setLoop(!1, "ステップ実行"), this.sys.send2Dbg("stopOnStep", {}), !0;
    case 5:
      O(this, ko, jh).call(this), P(this, Ne, 4);
      break;
    case 4:
      return O(this, ko, jh).call(this), this.main.setLoop(!1, "ステップ実行"), this.sys.send2Dbg("stopOnStep", {}), !0;
    case 3:
      O(this, ko, jh).call(this), P(this, Ne, 0);
      break;
    default:
      if (Ip(t) in c(Wr, ds))
        return P(this, Ne, 2), this.main.setLoop(!1, `関数 ${t} ブレーク`), this.sys.callHook("stopOnBreakpoint", {}), this.sys.send2Dbg("stopOnBreakpoint", {}), !0;
      {
        const e = c(Wr, Do)[c(this, ea).call(this, c(this, ie))];
        if (!e)
          break;
        const r = e[c(this, me)];
        if (!r)
          break;
        if (r.condition) {
          if (!this.prpPrs.parse(r.condition))
            break;
        } else if ("hitCondition" in r && --r.hitCondition > 0)
          break;
        const n = c(this, Ne) === 0;
        P(this, Ne, 2), this.main.setLoop(!1, n ? (r.condition ? "条件" : "ヒットカウント") + "ブレーク" : "ステップ実行");
        const s = n ? "stopOnBreakpoint" : "stopOnStep";
        this.sys.callHook(s, {}), this.sys.send2Dbg(s, {});
      }
      return !0;
  }
  return !1;
}, ko = new WeakSet(), jh = function() {
  var e;
  const t = (e = c(Wr, Do)[Vh(c(this, ie))]) == null ? void 0 : e[c(this, me)];
  t != null && t.hitCondition && --t.hitCondition;
}, bm = new WeakSet(), hP = function() {
  const t = c(this, Ne) === 3 ? 1 : 0, e = c(this, qt).aToken[c(this, yt) - 1 + t], r = c(this, ea).call(this, c(this, ie)), n = Ip(e), s = n ? `[${n}]` : e, a = this.val.getVal("mp:const.sn.macro") ?? "{}";
  if (c(this, yt) === 0)
    return [{ fn: r, ln: 1, col: 1, nm: s, ma: a }];
  const o = O(this, ps, Oa).call(this, c(this, qt), c(this, yt)), u = [{ fn: r, ln: o.ln, col: o.col_s + 1, nm: s, ma: a }], l = c(this, fe).length;
  if (l === 0)
    return u;
  for (let h = l - 1; h >= 0; --h) {
    const d = c(this, fe)[h], f = c(this, cr)[d.fn], p = f.aToken[d.idx - 1], v = O(this, ps, Oa).call(this, f, d.idx), g = Ip(p);
    u.push({
      fn: c(this, ea).call(this, d.fn),
      ln: v.ln,
      col: v.col_s + 1,
      nm: g ? `[${g}]` : p,
      ma: d.csArg[":hMp"]["const.sn.macro"] ?? "{}"
    });
  }
  return u;
}, Qf = new WeakMap(), Bl = new WeakMap(), Qr = new WeakMap(), xm = new WeakSet(), cP = function(t) {
  const { name: e } = t;
  if (!e)
    throw "nameは必須です";
  let r = "";
  const n = c(this, qt).len;
  for (; c(this, yt) < n && (r = c(this, qt).aToken[c(this, yt)], r === ""); ++Ve(this, yt)._)
    ;
  return t.text = r, t.cast = "str", this.hTag.let(t), P(this, yt, c(this, yt) + 2), P(this, me, c(this, me) + (r.match(/\n/g) ?? []).length), !1;
}, wm = new WeakSet(), fP = function() {
  if (c(this, yt) === 0)
    return console.group(`🥟 [dump_stack] スクリプト現在地 fn:${c(this, ie)} line:1 col:0`), console.groupEnd(), !1;
  const t = O(this, ps, Oa).call(this, c(this, qt), c(this, yt)), e = `スクリプト現在地 fn:${c(this, ie)} line:${t.ln} col:${t.col_s + 1}`;
  console.group(`🥟 [dump_stack] ${e}`);
  const r = c(this, fe).length;
  if (r > 0) {
    console.info(e);
    for (let n = r - 1; n >= 0; --n) {
      const s = c(this, fe)[n], a = s.csArg[":hMp"], o = a ? a[":タグ名"] : void 0, u = s.csArg[":タグ名"] ?? "", l = O(this, ps, Oa).call(this, c(this, cr)[s.fn], s.idx);
      console.info(
        `${r - n}つ前のコール元 fn:${s.fn} line:${l.ln} col:${l.col_s + 1}` + (o ? "（[" + o + "]マクロ内）" : " ") + `で [${u} ...]をコール`
      );
    }
  }
  return console.groupEnd(), !1;
}, ps = new WeakSet(), Oa = function(t, e) {
  const r = { ln: 1, col_s: 0, col_e: 0 };
  if (!t)
    return r;
  let n = e - 1;
  const s = r.ln = t.aLNum[n];
  for (; t.aLNum[n] === s; ) {
    if (t.aToken[n].at(0) !== `
`) {
      const a = t.aToken[n].length;
      r.col_e > 0 && (r.col_s += a), r.col_e += a;
    }
    if (--n < 0)
      break;
  }
  return r;
}, Em = new WeakSet(), dP = function(t) {
  const { set_fnc: e, break_fnc: r } = t;
  if (!e)
    throw "set_fncは必須です";
  if (P(this, No, globalThis[e]), !c(this, No)) {
    if (vt(t, "need_err", !0))
      throw `HTML内に関数${e}が見つかりません`;
    return P(this, No, () => {
    }), !1;
  }
  if (this.noticeBreak = (n) => {
    c(this, td) !== c(this, ie) && (P(this, td, c(this, ie)), c(this, No).call(this, c(this, ed)[c(this, ie)] = c(this, ed)[c(this, ie)] ?? c(this, qt).aToken.join(""))), c(this, Ao).call(this, c(this, me), n);
  }, this.noticeBreak(!0), !r)
    return !1;
  if (P(this, Ao, globalThis[r]), !c(this, Ao)) {
    if (vt(t, "need_err", !0))
      throw `HTML内に関数${r}が見つかりません`;
    P(this, Ao, () => {
    });
  }
  return !1;
}, No = new WeakMap(), Ao = new WeakMap(), td = new WeakMap(), ed = new WeakMap(), rd = new WeakMap(), ti = new WeakMap(), Sm = new WeakSet(), pP = function() {
  if (c(this, ti)[0] === -1)
    throw "ifブロック内ではありません";
  return P(this, yt, c(this, ti)[0]), c(this, ti).shift(), !1;
}, Tm = new WeakSet(), vP = function(t) {
  const { exp: e } = t;
  if (!e)
    throw "expは必須です";
  if (e.at(0) === "&")
    throw "属性expは「&」が不要です";
  let r = 0, n = this.prpPrs.parse(e) ? c(this, yt) : -1;
  const s = c(this, qt).aLNum[c(this, yt)];
  let a = c(this, me) - (s || 0);
  const o = c(this, qt).len;
  for (; c(this, yt) < o; ++Ve(this, yt)._) {
    const u = c(this, qt).aLNum[c(this, yt)];
    c(this, qt).aLNum[c(this, yt)] = (u || 0) + a;
    const l = c(this, qt).aToken[c(this, yt)];
    if (!l)
      continue;
    const h = l.charCodeAt(0);
    if (h === 10) {
      P(this, me, c(this, me) + l.length);
      continue;
    }
    if (h !== 91)
      continue;
    const [d, f] = Op(l);
    if (!(d in this.hTag))
      throw `未定義のタグ[${d}]です`;
    switch (this.alzTagArg.parse(f), d) {
      case "if":
        ++r;
        break;
      case "elsif":
        if (r > 0 || n > -1)
          break;
        const p = this.alzTagArg.hPrm.exp.val;
        if (p.at(0) === "&")
          throw "属性expは「&」が不要です";
        this.prpPrs.parse(p) && (n = c(this, yt) + 1);
        break;
      case "else":
        if (r > 0)
          break;
        n === -1 && (n = c(this, yt) + 1);
        break;
      case "endif":
        if (r > 0) {
          --r;
          break;
        }
        return n === -1 ? (++Ve(this, yt)._, c(this, qt).aLNum[c(this, yt)] += a) : (c(this, ti).unshift(c(this, yt) + 1), P(this, yt, n), P(this, me, c(this, qt).aLNum[c(this, yt)])), !1;
    }
  }
  throw "[endif]がないままスクリプト終端です";
}, Cm = new WeakSet(), gP = function(t) {
  vt(t, "count", !1) || O(this, cd, vb).call(this);
  const { fn: e } = t;
  return e && c(this, ta).call(this, e), O(this, id, hb).call(this, { ":hEvt1Time": c(this, Bl).popLocalEvts(), ":hMp": this.val.cloneMp() }), vt(t, "clear_local_event", !1) && this.hTag.clear_event({}), O(this, vs, Ia).call(this, e, t.label), !0;
}, id = new WeakSet(), hb = function(t) {
  c(this, qt).aLNum[c(this, yt)] = c(this, me), c(this, sd) || (t[":resvToken"] = "", O(this, Lo, zh).call(this)), c(this, fe).push(new lE(c(this, ie), c(this, yt), t)), c(this, ti).unshift(-1);
}, Mm = new WeakSet(), mP = function(t) {
  return vt(t, "count", !0) || O(this, cd, vb).call(this), c(this, ti)[0] = -1, O(this, vs, Ia).call(this, t.fn, t.label), !0;
}, Pm = new WeakSet(), yP = function(t) {
  if (c(this, fr) === -1)
    return !1;
  if (vt(t, "clear", !1))
    return P(this, Hi, []), P(this, fr, -1), !1;
  const { to: e } = t;
  if (!e)
    throw "clearかtoは必須です";
  const r = c(this, fr);
  switch (e) {
    case "prev":
      c(this, fr) > 0 && --Ve(this, fr)._;
      break;
    case "next":
      const o = c(this, Hi).length;
      c(this, fr) < o - 1 && ++Ve(this, fr)._;
      break;
    default:
      throw `属性to「${e}」は異常です`;
  }
  if (r === c(this, fr))
    return !1;
  const n = c(this, Hi)[c(this, fr)], { fn: s, idx: a } = O(this, jl, Qp).call(this);
  return n.key === a + ":" + s ? !1 : O(this, Gl, Jp).call(this, { fn: n.retFn, index: n.retIdx }, n.retMark);
}, Om = new WeakSet(), _P = function(t) {
  if (vt(t, "clear", !1))
    P(this, fe, []);
  else if (!c(this, fe).pop())
    throw "[pop_stack] スタックが空です";
  return O(this, Lo, zh).call(this), P(this, ti, [-1]), this.val.setMp({}), !1;
}, nd = new WeakSet(), cb = function(t) {
  const e = c(this, fe).pop();
  if (!e)
    throw "[return] スタックが空です";
  const r = e.csArg;
  c(this, ti).shift();
  const n = r[":hMp"];
  n && this.val.setMp(n);
  const s = r[":resvToken"];
  s ? this.nextToken = () => (O(this, Lo, zh).call(this), s) : O(this, Lo, zh).call(this), r[":hEvt1Time"] && c(this, Bl).pushLocalEvts(r[":hEvt1Time"]);
  const { fn: a, label: o } = t;
  return a || o ? (O(this, vs, Ia).call(this, a, o), !0) : e.fn in c(this, cr) ? (O(this, hd, pb).call(this, e), !1) : (O(this, vs, Ia).call(this, e.fn, "", e.idx), !0);
}, sd = new WeakMap(), Lo = new WeakSet(), zh = function() {
  P(this, sd, ""), this.nextToken = O(this, ad, fb);
}, Bo = new WeakMap(), vs = new WeakSet(), Ia = function(t = "", e = "", r = 0) {
  if (!t && !e && this.main.errScript("[jump系] fnまたはlabelは必須です"), e ? (e.at(0) !== "*" && this.main.errScript("[jump系] labelは*で始まります"), P(this, Bo, e), c(this, Bo).slice(0, 2) !== "**" && P(this, yt, r)) : (P(this, Bo, ""), P(this, yt, r)), !t) {
    this.analyzeInit();
    return;
  }
  if (t.includes("@"))
    throw "[jump系] fn には文字「@」は禁止です";
  const n = c(this, ta).call(this, t);
  if (t === c(this, ie)) {
    this.analyzeInit();
    return;
  }
  P(this, ie, t);
  const s = c(this, cr)[t];
  if (s) {
    P(this, qt, s), this.analyzeInit();
    return;
  }
  const a = new ri();
  let o = "";
  try {
    o = c(this, ta).call(this, t + "@"), a.add({ name: t + ":base", url: n }), a.add({ name: t, url: o });
  } catch {
    a.add({ name: t, url: n });
  }
  a.use((u, l) => {
    try {
      u.data = this.sys.decStr(u.extension, u.data);
    } catch (h) {
      this.main.errScript(`[jump系]snロード失敗です fn:${u.name} ${h}`, !1);
    }
    l == null || l();
  }).load((u, l) => {
    if (o) {
      const h = l[t + ":base"].data, d = l[t].data, f = h.split(`
`), p = d.split(`
`), v = f.length, g = p.length;
      for (let m = 0; m < g && m < v; ++m)
        p[m] || (p[m] = f[m]);
      l[t].data = p.join(`
`), delete l[t + ":base"];
    }
    this.nextToken = O(this, ad, fb), P(this, me, 1), O(this, km, xP).call(this, l[t].data), this.hTag.record_place({}), this.main.resume(() => this.analyzeInit());
  }), this.main.stop();
}, ad = new WeakSet(), fb = function() {
  var e, r;
  if (O(this, ud, db).call(this))
    return "";
  O(this, Bm, EP).call(this), (e = c(this, qt).aLNum)[r = c(this, yt)] || (e[r] = c(this, me));
  const t = c(this, qt).aToken[c(this, yt)];
  return c(this, od).call(this, t), ++Ve(this, yt)._, t;
}, od = new WeakMap(), ud = new WeakSet(), db = function() {
  return c(this, yt) < c(this, qt).len ? !1 : (this.main.errScript("スクリプト終端です"), !0);
}, Im = new WeakMap(), Rm = new WeakMap(), ld = new WeakMap(), Dm = new WeakSet(), bP = function(t, e, r, n, s) {
  var h, d;
  const a = t.aToken.length;
  if (!n) {
    if (O(this, ud, db).call(this))
      return { idx: s, ln: r };
    if (t.aLNum[s])
      r = t.aLNum[s];
    else {
      r = 1;
      for (let f = 0; f < s; ++f) {
        (h = t.aLNum)[f] || (h[f] = r);
        const p = t.aToken[f];
        p.charCodeAt(0) === 10 ? r += p.length : r += (p.match(/\n/g) ?? []).length;
      }
      t.aLNum[s] = r;
    }
    return { idx: s, ln: r };
  }
  t.aLNum[0] = 1;
  const o = n.match(c(this, Im));
  if (o) {
    n = o[1];
    let f = s;
    switch (o[2]) {
      case "before":
        for (; t.aToken[--f] !== n; )
          f === 0 && zt.myTrace("[jump系 無名ラベルbefore] " + r + "行目以前で" + (e ? "マクロ内に" : "") + "ラベル【" + n + "】がありません", "ET"), e && t.aToken[f].search(c(this, Rm)) > -1 && zt.myTrace("[jump系 無名ラベルbefore] マクロ内にラベル【" + n + "】がありません", "ET");
        return { idx: f + 1, ln: t.aLNum[f] };
      case "after":
        for (; t.aToken[++f] !== n; )
          f === a && zt.myTrace("[jump系 無名ラベルafter] " + r + "行目以後でマクロ内にラベル【" + n + "】がありません", "ET"), t.aToken[f].search(c(this, ld)) > -1 && zt.myTrace("[jump系 無名ラベルafter] " + r + "行目以後でマクロ内にラベル【" + n + "】がありません", "ET");
        return { idx: f + 1, ln: t.aLNum[f] };
      default:
        zt.myTrace("[jump系] 無名ラベル指定【label=" + n + "】が間違っています", "ET");
    }
  }
  r = 1;
  const u = new RegExp(
    "^" + n.replaceAll("*", "\\*") + "(?=\\s|;|\\[|\\||$)"
  );
  let l = !1;
  for (let f = 0; f < a; ++f) {
    (d = t.aLNum)[f] || (d[f] = r);
    const p = t.aToken[f];
    if (l) {
      c(this, fs).testTagEndLetml(p) ? l = !1 : r += (p.match(/\n/g) ?? []).length;
      continue;
    }
    const v = p.charCodeAt(0);
    if (v === 10) {
      r += p.length;
      continue;
    }
    if (v === 42) {
      if (p.search(u) > -1)
        return { idx: f + 1, ln: r };
      continue;
    }
    v === 91 && (r += (p.match(/\n/g) ?? []).length, c(this, fs).testTagLetml(p) && (l = !0));
  }
  throw l ? "[let_ml]の終端・[endlet_ml]がありません" : (zt.myTrace(`[jump系] ラベル【${n}】がありません`, "ET"), "Dummy");
}, cr = new WeakMap(), km = new WeakSet(), xP = function(t) {
  let e = "";
  try {
    e = "ScriptIterator.resolveScript";
    const r = c(this, fs).resolveScript(t);
    e = "ScriptIterator.replaceScript_Wildcard", O(this, Lm, wP).call(this, r), c(this, cr)[c(this, ie)] = P(this, qt, r);
  } catch (r) {
    r instanceof Error ? e += `例外 mes=${r.message}(${r.name})` : e = r, this.main.errScript(e, !1);
  }
  this.val.loadScrWork(c(this, ie));
}, hd = new WeakSet(), pb = function(t) {
  P(this, ie, t.fn), P(this, yt, t.idx);
  const e = c(this, cr)[c(this, ie)];
  e && P(this, qt, e), P(this, me, c(this, qt).aLNum[t.idx]);
}, Nm = new WeakMap(), Am = new WeakMap(), Lm = new WeakSet(), wP = function(t) {
  for (let e = t.len - 1; e >= 0; --e) {
    const r = t.aToken[e];
    if (!c(this, Nm).test(r))
      continue;
    const [n, s] = Op(r);
    this.alzTagArg.parse(s);
    const a = this.alzTagArg.hPrm.fn;
    if (!a)
      continue;
    const { val: o } = a;
    if (!o || o.at(-1) !== "*")
      continue;
    t.aToken.splice(e, 1, "	", "; " + r), t.aLNum.splice(e, 1, NaN, NaN);
    const u = n === "loadplugin" ? vr.CSS : vr.SN, l = this.cfg.matchPath("^" + o.slice(0, -1) + ".*", u);
    for (const h of l) {
      const d = r.replace(
        c(this, Am),
        "fn=" + decodeURIComponent(Vh(h[u]))
      );
      t.aToken.splice(e, 0, d), t.aLNum.splice(e, 0, NaN);
    }
  }
  t.len = t.aToken.length;
}, Bm = new WeakSet(), EP = function() {
  const t = this.val.getAreaKidoku(c(this, ie));
  if (!t)
    throw `recordKidoku fn:'${c(this, ie)}' (areas === null)`;
  if (c(this, fe).length > 0) {
    t.record(c(this, yt));
    return;
  }
  P(this, gs, t.search(c(this, yt))), this.val.setVal_Nochk("tmp", "const.sn.isKidoku", c(this, gs)), !c(this, gs) && t.record(c(this, yt));
}, gs = new WeakMap(), cd = new WeakSet(), vb = function() {
  var t;
  (t = this.val.getAreaKidoku(c(this, ie))) == null || t.erase(c(this, yt)), P(this, gs, !1);
}, Fm = new WeakSet(), SP = function(t) {
  return c(this, fs).bracket2macro(t, this.hTag, c(this, qt), c(this, yt)), !1;
}, Gm = new WeakSet(), TP = function(t) {
  return c(this, fs).char2macro(t, this.hTag, c(this, qt), c(this, yt)), !1;
}, Um = new WeakMap(), jm = new WeakSet(), CP = function(t) {
  var s, a;
  const { name: e } = t;
  if (!e)
    throw "nameは必須です";
  if (e in this.hTag)
    throw `[${e}]はタグかすでに定義済みのマクロです`;
  if (c(this, Um).test(e))
    throw `[${e}]はマクロ名として異常です`;
  const r = c(this, me), n = new lE(c(this, ie), c(this, yt));
  for (P(this, fd, c(this, fd) + ("|" + e)), P(this, Fl, new RegExp(`\\[(${c(this, fd)})\\b`)), this.hTag[e] = (o) => (o.design_unit = t.design_unit, O(this, id, hb).call(this, { ...o, ":hMp": this.val.cloneMp() }), this.val.setMp(o), this.val.setVal_Nochk("mp", "const.sn.macro", JSON.stringify(t)), this.val.setVal_Nochk("mp", "const.sn.me_call_scriptFn", c(this, ie)), P(this, me, r), O(this, hd, pb).call(this, n), !1); c(this, yt) < c(this, qt).len; ++Ve(this, yt)._) {
    (s = c(this, qt).aLNum)[a = c(this, yt)] || (s[a] = c(this, me));
    const o = c(this, qt).aToken[c(this, yt)];
    if (o.search(c(this, ld)) > -1)
      return ++Ve(this, yt)._, !1;
    const u = o.charCodeAt(0);
    u === 10 ? P(this, me, c(this, me) + o.length) : u === 91 && P(this, me, c(this, me) + (o.match(/\n/g) ?? []).length);
  }
  throw `マクロ[${e}]定義の終端・[endmacro]がありません`;
}, fd = new WeakMap(), Fl = new WeakMap(), zm = new WeakSet(), MP = function(t) {
  if (!("place" in t))
    throw "placeは必須です";
  const e = Number(t.place);
  if ("fn" in t != "label" in t)
    throw "fnとlabelはセットで指定して下さい";
  const r = this.val.getMark(e);
  if (!r)
    throw `place【${e}】は存在しません`;
  return O(this, Gl, Jp).call(this, t, r);
}, Gl = new WeakSet(), Jp = function(t, e, r = !0) {
  this.hTag.clear_event({}), this.val.mark2save(e), this.val.setMp({}), c(this, Qr).recPagebreak(), r && this.sndMng.playLoopFromSaveObj(), vt(t, "do_rec", !0) && P(this, zi, {
    hSave: this.val.cloneSave(),
    hPages: { ...e.hPages },
    aIfStk: [...e.aIfStk]
  });
  const n = {
    enabled: this.val.getVal("save:const.sn.autowc.enabled"),
    text: this.val.getVal("save:const.sn.autowc.text"),
    time: Number(this.val.getVal("save:const.sn.autowc.time"))
  };
  this.hTag.autowc(n);
  const s = String(this.val.getVal("save:const.sn.scriptFn")), a = Number(this.val.getVal("save:const.sn.scriptIdx"));
  return P(this, ti, [...c(this, zi).aIfStk]), P(this, fe, []), c(this, Qr).cover(!0), c(this, Qr).stopAllTw(), "index" in t ? (c(this, Qr).playback(c(this, zi).hPages, () => {
    c(this, Qr).cover(!1), P(this, Ul, !0), O(this, vs, Ia).call(this, t.fn ?? s, "", t.index ?? a);
  }), !0) : (delete c(this, cr)[s], c(this, Qr).playback(
    c(this, zi).hPages,
    "label" in t ? () => {
      c(this, Qr).cover(!1), P(this, ie, s), P(this, yt, a), this.hTag.call({ fn: t.fn, label: t.label });
    } : () => {
      c(this, Qr).cover(!1), O(this, vs, Ia).call(this, s, "", a);
    }
  ), !0);
}, Ul = new WeakMap(), Hm = new WeakSet(), PP = function(t) {
  const e = this.val.getMark(0);
  delete c(this, cr)[Vh(e.hSave["const.sn.scriptFn"])];
  const r = {};
  for (const n in c(this, cr))
    try {
      c(this, ta).call(this, n + "@");
    } catch {
      r[n] = c(this, cr)[n];
    }
  return P(this, cr, r), t.do_rec = !1, O(this, Gl, Jp).call(this, t, e, !1);
}, zi = new WeakMap(), $m = new WeakSet(), OP = function() {
  if (this.main.isDestroyed())
    return !1;
  const { fn: t, idx: e } = O(this, jl, Qp).call(this);
  return this.val.setVal_Nochk("save", "const.sn.scriptFn", t), this.val.setVal_Nochk("save", "const.sn.scriptIdx", e), P(this, zi, {
    hSave: this.val.cloneSave(),
    hPages: c(this, Qr).record(),
    aIfStk: c(this, ti).slice(c(this, fe).length)
  }), !1;
}, jl = new WeakSet(), Qp = function() {
  if (c(this, fe).length === 0)
    return {
      fn: c(this, ie),
      idx: c(this, yt)
    };
  const e = c(this, fe)[0];
  return {
    fn: e.fn,
    idx: e.idx
  };
}, Vm = new WeakSet(), IP = function(t) {
  if (!("place" in t))
    throw "placeは必須です";
  const e = Number(t.place);
  delete t[":タグ名"], delete t.place, t.text = (t.text ?? "").replace(/^(<br\/>)+/, ""), c(this, zi).json = t, this.val.setMark(e, c(this, zi));
  const r = Number(this.val.getVal("sys:const.sn.save.place"));
  return e === r && this.val.setVal_Nochk("sys", "const.sn.save.place", r + 1), !1;
}, Hi = new WeakMap(), fr = new WeakMap(), E(wu, ym, /(.+)\/crypto_prj\/([^\/]+)\/[^\.]+(\.\w+)/), // reload 再生成 Main に受け渡すため static
E(wu, Do, {}), E(wu, ds, {});
var Br, bi, yr, xi, ms, Fo, dr, dd, ys, zl, Go, pd, vd, Hl, Xm, RP, gd, md, $l, Vl, tv, Uo, jo;
const Nu = class {
  constructor(t) {
    E(this, Xm);
    E(this, Vl);
    E(this, Br, void 0);
    E(this, bi, void 0);
    E(this, yr, /* @__PURE__ */ Object.create(null));
    // タグ処理辞書
    E(this, xi, void 0);
    E(this, ms, void 0);
    E(this, Fo, void 0);
    E(this, dr, void 0);
    E(this, dd, void 0);
    E(this, ys, void 0);
    E(this, zl, void 0);
    E(this, Go, () => {
    });
    E(this, pd, new pA());
    E(this, vd, !1);
    E(this, Hl, "skynovel");
    E(this, gd, () => c(this, Go).call(this));
    // メイン処理（シナリオ解析）
    E(this, md, (t = O(this, Vl, tv)) => {
      c(this, Uo) || (c(this, ys).clearBreak(), P(this, Go, t), this.resume = (e = O(this, Vl, tv)) => {
        P(this, Go, e);
      }, c(this, dr).noticeBreak(!1));
    });
    K(this, "resume", c(this, md));
    K(this, "stop", () => {
      P(this, Go, () => {
      }), this.resume = c(this, md), c(this, dr).noticeBreak(!0);
    });
    E(this, $l, !0);
    E(this, Uo, !1);
    K(this, "isDestroyed", () => c(this, Uo));
    E(this, jo, void 0);
    this.sys = t, jO(), ix.generate(t).then((e) => P(this, Br, e)).then(() => O(this, Xm, RP).call(this)).catch((e) => console.error("load err fn:prj.json e:%o", e));
  }
  // thisの扱いによりメソッド代入はダメ
  errScript(t, e = !0) {
    if (this.stop(), zt.myTrace(t), Y.debugLog && console.log("🍜 SKYNovel err!"), e)
      throw t;
  }
  resumeByJumpOrCall(t) {
    if (t.url) {
      globalThis.open(t.url);
      return;
    }
    c(this, xi).setVal_Nochk("tmp", "sn.eventArg", t.arg ?? ""), c(this, xi).setVal_Nochk("tmp", "sn.eventLabel", t.label ?? ""), vt(t, "call", !1) ? (c(this, dr).subIdxToken(), this.resume(() => c(this, yr).call(t))) : (c(this, yr).clear_event({}), this.resume(() => c(this, yr).jump(t)));
  }
  setLoop(t, e = "") {
    P(this, $l, t) ? this.resume() : this.stop(), this.sys.setTitleInfo(e ? ` -- ${e}中` : "");
  }
  fire(t, e) {
    c(this, zl).fire(t, e);
  }
  async destroy(t = 0) {
    c(this, Uo) || (P(this, Uo, !0), c(this, vd) && (this.stop(), P(this, $l, !1), c(this, ys).before_destroy(), t > 0 && await new Promise((e) => setTimeout(e, t)), P(this, yr, {}), c(this, zl).destroy(), c(this, dr).destroy(), c(this, ys).destroy(), c(this, dd).destroy(), c(this, bi).ticker.remove(c(this, gd)), c(this, jo) && c(this, bi) && Nu.cvs.parentNode.appendChild(c(this, jo)), UE(), c(this, bi).destroy(!0), this.sys.destroy()));
  }
};
let Ur = Nu;
Br = new WeakMap(), bi = new WeakMap(), yr = new WeakMap(), xi = new WeakMap(), ms = new WeakMap(), Fo = new WeakMap(), dr = new WeakMap(), dd = new WeakMap(), ys = new WeakMap(), zl = new WeakMap(), Go = new WeakMap(), pd = new WeakMap(), vd = new WeakMap(), Hl = new WeakMap(), Xm = new WeakSet(), RP = async function() {
  var n;
  const t = (n = document.createElement("canvas")) == null ? void 0 : n.getContext("2d");
  if (!t)
    throw "argChk_Color err";
  Y.cc4ColorName = t;
  const e = {
    width: c(this, Br).oCfg.window.width,
    height: c(this, Br).oCfg.window.height,
    backgroundColor: xb(String(c(this, Br).oCfg.init.bg_color)),
    // このString()は後方互換性のため必須
    //	resolution		: sys.resolution,
    resolution: globalThis.devicePixelRatio ?? 1
    // 理想
  }, r = document.getElementById(c(this, Hl));
  r && (P(this, jo, r.cloneNode(!0)), c(this, jo).id = c(this, Hl), e.view = r), P(this, bi, new IS(e)), Nu.cvs = c(this, bi).view, r || (document.body.appendChild(Nu.cvs), Nu.cvs.id = c(this, Hl)), P(this, xi, new kp(c(this, Br), c(this, yr))), P(this, ms, new Ba(c(this, xi), c(this, Br).oCfg.init.escape ?? "\\")), await Promise.allSettled(this.sys.init(c(this, yr), c(this, bi), c(this, xi), this)), c(this, yr).title({ text: c(this, Br).oCfg.book.title || "SKYNovel" }), P(this, Fo, new Bp(c(this, Br), c(this, yr), c(this, xi), this, this.sys)), P(this, dr, new wu(c(this, Br), c(this, yr), this, c(this, xi), c(this, pd), () => O(this, Vl, tv).call(this), c(this, ms), c(this, Fo), this.sys)), P(this, dd, new zt(this.sys, c(this, yr), c(this, dr))), P(this, ys, new Ga(c(this, Br), c(this, yr), c(this, bi), c(this, xi), this, c(this, dr), this.sys, c(this, Fo), c(this, pd), c(this, ms))), P(this, zl, new a4(c(this, Br), c(this, yr), c(this, bi), this, c(this, ys), c(this, xi), c(this, Fo), c(this, dr), this.sys)), c(this, bi).ticker.add(c(this, gd)), this.resumeByJumpOrCall({ fn: "main" }), P(this, vd, !0);
}, gd = new WeakMap(), md = new WeakMap(), $l = new WeakMap(), Vl = new WeakSet(), tv = function() {
  for (; c(this, $l); ) {
    let t = c(this, dr).nextToken();
    if (!t)
      break;
    const e = t.charCodeAt(0);
    if (e !== 9) {
      if (e === 10) {
        c(this, dr).addLineNum(t.length);
        continue;
      }
      if (e === 91) {
        if (c(this, dr).isBreak(t))
          return;
        try {
          const r = (t.match(/\n/g) ?? []).length;
          if (r > 0 && c(this, dr).addLineNum(r), c(this, dr).タグ解析(t)) {
            this.stop();
            break;
          }
          continue;
        } catch (r) {
          r instanceof Error ? this.errScript(`[${Ip(t)}]タグ解析中例外 mes=${r.message}(${r.name})`, !1) : this.errScript(String(r), !1);
          return;
        }
      }
      if (e === 38)
        try {
          if (t.at(-1) !== "&") {
            if (c(this, dr).isBreak(t))
              return;
            const r = fA(t.slice(1));
            r.name = c(this, ms).getValAmpersand(r.name), r.text = String(c(this, ms).parse(r.text)), c(this, yr).let(r);
            continue;
          }
          if (t.charAt(1) === "&")
            throw new Error("「&表示&」書式では「&」指定が不要です");
          t = String(c(this, ms).parse(t.slice(1, -1)));
        } catch (r) {
          this.errScript(
            r instanceof Error ? `& 変数操作・表示 mes=${r.message}(${r.name})` : r,
            !1
          );
          return;
        }
      else {
        if (e === 59)
          continue;
        if (e === 42 && t.length > 1)
          continue;
      }
      try {
        c(this, ys).currentTxtlayForeNeedErr.tagCh(t);
      } catch (r) {
        this.errScript(
          r instanceof Error ? `文字表示 mes=${r.message}(${r.name})` : r,
          !1
        );
        return;
      }
    }
  }
}, Uo = new WeakMap(), jo = new WeakMap(), K(Ur, "cvs");
const Fn = /* @__PURE__ */ Object.create(null);
Fn.open = "0";
Fn.close = "1";
Fn.ping = "2";
Fn.pong = "3";
Fn.message = "4";
Fn.upgrade = "5";
Fn.noop = "6";
const ev = /* @__PURE__ */ Object.create(null);
Object.keys(Fn).forEach((i) => {
  ev[Fn[i]] = i;
});
const o4 = { type: "error", data: "parser error" }, u4 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", l4 = typeof ArrayBuffer == "function", h4 = (i) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(i) : i && i.buffer instanceof ArrayBuffer, DP = ({ type: i, data: t }, e, r) => u4 && t instanceof Blob ? e ? r(t) : hE(t, r) : l4 && (t instanceof ArrayBuffer || h4(t)) ? e ? r(t) : hE(new Blob([t]), r) : r(Fn[i] + (t || "")), hE = (i, t) => {
  const e = new FileReader();
  return e.onload = function() {
    const r = e.result.split(",")[1];
    t("b" + (r || ""));
  }, e.readAsDataURL(i);
}, cE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Hh = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let i = 0; i < cE.length; i++)
  Hh[cE.charCodeAt(i)] = i;
const c4 = (i) => {
  let t = i.length * 0.75, e = i.length, r, n = 0, s, a, o, u;
  i[i.length - 1] === "=" && (t--, i[i.length - 2] === "=" && t--);
  const l = new ArrayBuffer(t), h = new Uint8Array(l);
  for (r = 0; r < e; r += 4)
    s = Hh[i.charCodeAt(r)], a = Hh[i.charCodeAt(r + 1)], o = Hh[i.charCodeAt(r + 2)], u = Hh[i.charCodeAt(r + 3)], h[n++] = s << 2 | a >> 4, h[n++] = (a & 15) << 4 | o >> 2, h[n++] = (o & 3) << 6 | u & 63;
  return l;
}, f4 = typeof ArrayBuffer == "function", kP = (i, t) => {
  if (typeof i != "string")
    return {
      type: "message",
      data: NP(i, t)
    };
  const e = i.charAt(0);
  return e === "b" ? {
    type: "message",
    data: d4(i.substring(1), t)
  } : ev[e] ? i.length > 1 ? {
    type: ev[e],
    data: i.substring(1)
  } : {
    type: ev[e]
  } : o4;
}, d4 = (i, t) => {
  if (f4) {
    const e = c4(i);
    return NP(e, t);
  } else
    return { base64: !0, data: i };
}, NP = (i, t) => {
  switch (t) {
    case "blob":
      return i instanceof ArrayBuffer ? new Blob([i]) : i;
    case "arraybuffer":
    default:
      return i;
  }
}, AP = String.fromCharCode(30), p4 = (i, t) => {
  const e = i.length, r = new Array(e);
  let n = 0;
  i.forEach((s, a) => {
    DP(s, !1, (o) => {
      r[a] = o, ++n === e && t(r.join(AP));
    });
  });
}, v4 = (i, t) => {
  const e = i.split(AP), r = [];
  for (let n = 0; n < e.length; n++) {
    const s = kP(e[n], t);
    if (r.push(s), s.type === "error")
      break;
  }
  return r;
}, LP = 4;
function Qe(i) {
  if (i)
    return g4(i);
}
function g4(i) {
  for (var t in Qe.prototype)
    i[t] = Qe.prototype[t];
  return i;
}
Qe.prototype.on = Qe.prototype.addEventListener = function(i, t) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + i] = this._callbacks["$" + i] || []).push(t), this;
};
Qe.prototype.once = function(i, t) {
  function e() {
    this.off(i, e), t.apply(this, arguments);
  }
  return e.fn = t, this.on(i, e), this;
};
Qe.prototype.off = Qe.prototype.removeListener = Qe.prototype.removeAllListeners = Qe.prototype.removeEventListener = function(i, t) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var e = this._callbacks["$" + i];
  if (!e)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + i], this;
  for (var r, n = 0; n < e.length; n++)
    if (r = e[n], r === t || r.fn === t) {
      e.splice(n, 1);
      break;
    }
  return e.length === 0 && delete this._callbacks["$" + i], this;
};
Qe.prototype.emit = function(i) {
  this._callbacks = this._callbacks || {};
  for (var t = new Array(arguments.length - 1), e = this._callbacks["$" + i], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  if (e) {
    e = e.slice(0);
    for (var r = 0, n = e.length; r < n; ++r)
      e[r].apply(this, t);
  }
  return this;
};
Qe.prototype.emitReserved = Qe.prototype.emit;
Qe.prototype.listeners = function(i) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + i] || [];
};
Qe.prototype.hasListeners = function(i) {
  return !!this.listeners(i).length;
};
const wi = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
function BP(i, ...t) {
  return t.reduce((e, r) => (i.hasOwnProperty(r) && (e[r] = i[r]), e), {});
}
const m4 = wi.setTimeout, y4 = wi.clearTimeout;
function x0(i, t) {
  t.useNativeTimers ? (i.setTimeoutFn = m4.bind(wi), i.clearTimeoutFn = y4.bind(wi)) : (i.setTimeoutFn = wi.setTimeout.bind(wi), i.clearTimeoutFn = wi.clearTimeout.bind(wi));
}
const _4 = 1.33;
function b4(i) {
  return typeof i == "string" ? x4(i) : Math.ceil((i.byteLength || i.size) * _4);
}
function x4(i) {
  let t = 0, e = 0;
  for (let r = 0, n = i.length; r < n; r++)
    t = i.charCodeAt(r), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (r++, e += 4);
  return e;
}
class w4 extends Error {
  constructor(t, e, r) {
    super(t), this.description = e, this.context = r, this.type = "TransportError";
  }
}
class FP extends Qe {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(t) {
    super(), this.writable = !1, x0(this, t), this.opts = t, this.query = t.query, this.socket = t.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(t, e, r) {
    return super.emitReserved("error", new w4(t, e, r)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(t) {
    this.readyState === "open" && this.write(t);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(t) {
    const e = kP(t, this.socket.binaryType);
    this.onPacket(e);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(t) {
    super.emitReserved("packet", t);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(t) {
    this.readyState = "closed", super.emitReserved("close", t);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(t) {
  }
}
const GP = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), gb = 64, E4 = {};
let fE = 0, wp = 0, dE;
function pE(i) {
  let t = "";
  do
    t = GP[i % gb] + t, i = Math.floor(i / gb);
  while (i > 0);
  return t;
}
function UP() {
  const i = pE(+/* @__PURE__ */ new Date());
  return i !== dE ? (fE = 0, dE = i) : i + "." + pE(fE++);
}
for (; wp < gb; wp++)
  E4[GP[wp]] = wp;
function jP(i) {
  let t = "";
  for (let e in i)
    i.hasOwnProperty(e) && (t.length && (t += "&"), t += encodeURIComponent(e) + "=" + encodeURIComponent(i[e]));
  return t;
}
function S4(i) {
  let t = {}, e = i.split("&");
  for (let r = 0, n = e.length; r < n; r++) {
    let s = e[r].split("=");
    t[decodeURIComponent(s[0])] = decodeURIComponent(s[1]);
  }
  return t;
}
let zP = !1;
try {
  zP = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const T4 = zP;
function HP(i) {
  const t = i.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!t || T4))
      return new XMLHttpRequest();
  } catch {
  }
  if (!t)
    try {
      return new wi[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
function C4() {
}
const M4 = function() {
  return new HP({
    xdomain: !1
  }).responseType != null;
}();
class P4 extends FP {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(t) {
    if (super(t), this.polling = !1, typeof location < "u") {
      const r = location.protocol === "https:";
      let n = location.port;
      n || (n = r ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || n !== t.port, this.xs = t.secure !== r;
    }
    const e = t && t.forceBase64;
    this.supportsBinary = M4 && !e;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(t) {
    this.readyState = "pausing";
    const e = () => {
      this.readyState = "paused", t();
    };
    if (this.polling || !this.writable) {
      let r = 0;
      this.polling && (r++, this.once("pollComplete", function() {
        --r || e();
      })), this.writable || (r++, this.once("drain", function() {
        --r || e();
      }));
    } else
      e();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  poll() {
    this.polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(t) {
    const e = (r) => {
      if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(r);
    };
    v4(t, this.socket.binaryType).forEach(e), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const t = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? t() : this.once("open", t);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(t) {
    this.writable = !1, p4(t, (e) => {
      this.doWrite(e, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    let t = this.query || {};
    const e = this.opts.secure ? "https" : "http";
    let r = "";
    this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = UP()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.opts.port && (e === "https" && Number(this.opts.port) !== 443 || e === "http" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port);
    const n = jP(t), s = this.opts.hostname.indexOf(":") !== -1;
    return e + "://" + (s ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (n.length ? "?" + n : "");
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @private
   */
  request(t = {}) {
    return Object.assign(t, { xd: this.xd, xs: this.xs }, this.opts), new Rn(this.uri(), t);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(t, e) {
    const r = this.request({
      method: "POST",
      data: t
    });
    r.on("success", e), r.on("error", (n, s) => {
      this.onError("xhr post error", n, s);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const t = this.request();
    t.on("data", this.onData.bind(this)), t.on("error", (e, r) => {
      this.onError("xhr poll error", e, r);
    }), this.pollXhr = t;
  }
}
class Rn extends Qe {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(t, e) {
    super(), x0(this, e), this.opts = e, this.method = e.method || "GET", this.uri = t, this.async = e.async !== !1, this.data = e.data !== void 0 ? e.data : null, this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  create() {
    const t = BP(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    t.xdomain = !!this.opts.xd, t.xscheme = !!this.opts.xs;
    const e = this.xhr = new HP(t);
    try {
      e.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0);
          for (let r in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(r) && e.setRequestHeader(r, this.opts.extraHeaders[r]);
        }
      } catch {
      }
      if (this.method === "POST")
        try {
          e.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        e.setRequestHeader("Accept", "*/*");
      } catch {
      }
      "withCredentials" in e && (e.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (e.timeout = this.opts.requestTimeout), e.onreadystatechange = () => {
        e.readyState === 4 && (e.status === 200 || e.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
          this.onError(typeof e.status == "number" ? e.status : 0);
        }, 0));
      }, e.send(this.data);
    } catch (r) {
      this.setTimeoutFn(() => {
        this.onError(r);
      }, 0);
      return;
    }
    typeof document < "u" && (this.index = Rn.requestsCount++, Rn.requests[this.index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  onError(t) {
    this.emitReserved("error", t, this.xhr), this.cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  cleanup(t) {
    if (!(typeof this.xhr > "u" || this.xhr === null)) {
      if (this.xhr.onreadystatechange = C4, t)
        try {
          this.xhr.abort();
        } catch {
        }
      typeof document < "u" && delete Rn.requests[this.index], this.xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  onLoad() {
    const t = this.xhr.responseText;
    t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this.cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this.cleanup();
  }
}
Rn.requestsCount = 0;
Rn.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", vE);
  else if (typeof addEventListener == "function") {
    const i = "onpagehide" in wi ? "pagehide" : "unload";
    addEventListener(i, vE, !1);
  }
}
function vE() {
  for (let i in Rn.requests)
    Rn.requests.hasOwnProperty(i) && Rn.requests[i].abort();
}
const $P = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0))(), Ep = wi.WebSocket || wi.MozWebSocket, gE = !0, O4 = "arraybuffer", mE = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class I4 extends FP {
  /**
   * WebSocket transport constructor.
   *
   * @param {Object} opts - connection options
   * @protected
   */
  constructor(t) {
    super(t), this.supportsBinary = !t.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check())
      return;
    const t = this.uri(), e = this.opts.protocols, r = mE ? {} : BP(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
    try {
      this.ws = gE && !mE ? e ? new Ep(t, e) : new Ep(t) : new Ep(t, e, r);
    } catch (n) {
      return this.emitReserved("error", n);
    }
    this.ws.binaryType = this.socket.binaryType || O4, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const r = t[e], n = e === t.length - 1;
      DP(r, this.supportsBinary, (s) => {
        const a = {};
        try {
          gE && this.ws.send(s);
        } catch {
        }
        n && $P(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    let t = this.query || {};
    const e = this.opts.secure ? "wss" : "ws";
    let r = "";
    this.opts.port && (e === "wss" && Number(this.opts.port) !== 443 || e === "ws" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port), this.opts.timestampRequests && (t[this.opts.timestampParam] = UP()), this.supportsBinary || (t.b64 = 1);
    const n = jP(t), s = this.opts.hostname.indexOf(":") !== -1;
    return e + "://" + (s ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (n.length ? "?" + n : "");
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @private
   */
  check() {
    return !!Ep;
  }
}
const R4 = {
  websocket: I4,
  polling: P4
}, D4 = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, k4 = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function mb(i) {
  const t = i, e = i.indexOf("["), r = i.indexOf("]");
  e != -1 && r != -1 && (i = i.substring(0, e) + i.substring(e, r).replace(/:/g, ";") + i.substring(r, i.length));
  let n = D4.exec(i || ""), s = {}, a = 14;
  for (; a--; )
    s[k4[a]] = n[a] || "";
  return e != -1 && r != -1 && (s.source = t, s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ":"), s.authority = s.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), s.ipv6uri = !0), s.pathNames = N4(s, s.path), s.queryKey = A4(s, s.query), s;
}
function N4(i, t) {
  const e = /\/{2,9}/g, r = t.replace(e, "/").split("/");
  return (t.slice(0, 1) == "/" || t.length === 0) && r.splice(0, 1), t.slice(-1) == "/" && r.splice(r.length - 1, 1), r;
}
function A4(i, t) {
  const e = {};
  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, n, s) {
    n && (e[n] = s);
  }), e;
}
let VP = class Su extends Qe {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(t, e = {}) {
    super(), this.writeBuffer = [], t && typeof t == "object" && (e = t, t = null), t ? (t = mb(t), e.hostname = t.host, e.secure = t.protocol === "https" || t.protocol === "wss", e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = mb(e.host).host), x0(this, e), this.secure = e.secure != null ? e.secure : typeof location < "u" && location.protocol === "https:", e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.hostname = e.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = e.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = e.transports || ["polling", "websocket"], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !0
    }, e), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = S4(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this.offlineEventListener = () => {
      this.onClose("transport close", {
        description: "network connection lost"
      });
    }, addEventListener("offline", this.offlineEventListener, !1))), this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(t) {
    const e = Object.assign({}, this.opts.query);
    e.EIO = LP, e.transport = t, this.id && (e.sid = this.id);
    const r = Object.assign({}, this.opts.transportOptions[t], this.opts, {
      query: e,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    });
    return new R4[t](r);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  open() {
    let t;
    if (this.opts.rememberUpgrade && Su.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
      t = "websocket";
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else
      t = this.transports[0];
    this.readyState = "opening";
    try {
      t = this.createTransport(t);
    } catch {
      this.transports.shift(), this.open();
      return;
    }
    t.open(), this.setTransport(t);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(t) {
    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (e) => this.onClose("transport close", e));
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  probe(t) {
    let e = this.createTransport(t), r = !1;
    Su.priorWebsocketSuccess = !1;
    const n = () => {
      r || (e.send([{ type: "ping", data: "probe" }]), e.once("packet", (d) => {
        if (!r)
          if (d.type === "pong" && d.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", e), !e)
              return;
            Su.priorWebsocketSuccess = e.name === "websocket", this.transport.pause(() => {
              r || this.readyState !== "closed" && (h(), this.setTransport(e), e.send([{ type: "upgrade" }]), this.emitReserved("upgrade", e), e = null, this.upgrading = !1, this.flush());
            });
          } else {
            const f = new Error("probe error");
            f.transport = e.name, this.emitReserved("upgradeError", f);
          }
      }));
    };
    function s() {
      r || (r = !0, h(), e.close(), e = null);
    }
    const a = (d) => {
      const f = new Error("probe error: " + d);
      f.transport = e.name, s(), this.emitReserved("upgradeError", f);
    };
    function o() {
      a("transport closed");
    }
    function u() {
      a("socket closed");
    }
    function l(d) {
      e && d.name !== e.name && s();
    }
    const h = () => {
      e.removeListener("open", n), e.removeListener("error", a), e.removeListener("close", o), this.off("close", u), this.off("upgrading", l);
    };
    e.once("open", n), e.once("error", a), e.once("close", o), this.once("close", u), this.once("upgrading", l), e.open();
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    if (this.readyState = "open", Su.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade) {
      let t = 0;
      const e = this.upgrades.length;
      for (; t < e; t++)
        this.probe(this.upgrades[t]);
    }
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  onPacket(t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;
        case "ping":
          this.resetPingTimeout(), this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
          break;
        case "error":
          const e = new Error("server error");
          e.code = t.data, this.onError(e);
          break;
        case "message":
          this.emitReserved("data", t.data), this.emitReserved("message", t.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(t) {
    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const t = this.getWritablePackets();
      this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  getWritablePackets() {
    if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let e = 1;
    for (let r = 0; r < this.writeBuffer.length; r++) {
      const n = this.writeBuffer[r].data;
      if (n && (e += b4(n)), r > 0 && e > this.maxPayload)
        return this.writeBuffer.slice(0, r);
      e += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} callback function.
   * @return {Socket} for chaining.
   */
  write(t, e, r) {
    return this.sendPacket("message", t, e, r), this;
  }
  send(t, e, r) {
    return this.sendPacket("message", t, e, r), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  sendPacket(t, e, r, n) {
    if (typeof e == "function" && (n = e, e = void 0), typeof r == "function" && (n = r, r = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    r = r || {}, r.compress = r.compress !== !1;
    const s = {
      type: t,
      data: e,
      options: r
    };
    this.emitReserved("packetCreate", s), this.writeBuffer.push(s), n && this.once("flush", n), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const t = () => {
      this.onClose("forced close"), this.transport.close();
    }, e = () => {
      this.off("upgrade", e), this.off("upgradeError", e), t();
    }, r = () => {
      this.once("upgrade", e), this.once("upgradeError", e);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? r() : t();
    }) : this.upgrading ? r() : t()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  onError(t) {
    Su.priorWebsocketSuccess = !1, this.emitReserved("error", t), this.onClose("transport error", t);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  onClose(t, e) {
    (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", t, e), this.writeBuffer = [], this.prevBufferLen = 0);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  filterUpgrades(t) {
    const e = [];
    let r = 0;
    const n = t.length;
    for (; r < n; r++)
      ~this.transports.indexOf(t[r]) && e.push(t[r]);
    return e;
  }
};
VP.protocol = LP;
function L4(i, t = "", e) {
  let r = i;
  e = e || typeof location < "u" && location, i == null && (i = e.protocol + "//" + e.host), typeof i == "string" && (i.charAt(0) === "/" && (i.charAt(1) === "/" ? i = e.protocol + i : i = e.host + i), /^(https?|wss?):\/\//.test(i) || (typeof e < "u" ? i = e.protocol + "//" + i : i = "https://" + i), r = mb(i)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/";
  const s = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
  return r.id = r.protocol + "://" + s + ":" + r.port + t, r.href = r.protocol + "://" + s + (e && e.port === r.port ? "" : ":" + r.port), r;
}
const B4 = typeof ArrayBuffer == "function", F4 = (i) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(i) : i.buffer instanceof ArrayBuffer, XP = Object.prototype.toString, G4 = typeof Blob == "function" || typeof Blob < "u" && XP.call(Blob) === "[object BlobConstructor]", U4 = typeof File == "function" || typeof File < "u" && XP.call(File) === "[object FileConstructor]";
function qx(i) {
  return B4 && (i instanceof ArrayBuffer || F4(i)) || G4 && i instanceof Blob || U4 && i instanceof File;
}
function rv(i, t) {
  if (!i || typeof i != "object")
    return !1;
  if (Array.isArray(i)) {
    for (let e = 0, r = i.length; e < r; e++)
      if (rv(i[e]))
        return !0;
    return !1;
  }
  if (qx(i))
    return !0;
  if (i.toJSON && typeof i.toJSON == "function" && arguments.length === 1)
    return rv(i.toJSON(), !0);
  for (const e in i)
    if (Object.prototype.hasOwnProperty.call(i, e) && rv(i[e]))
      return !0;
  return !1;
}
function j4(i) {
  const t = [], e = i.data, r = i;
  return r.data = yb(e, t), r.attachments = t.length, { packet: r, buffers: t };
}
function yb(i, t) {
  if (!i)
    return i;
  if (qx(i)) {
    const e = { _placeholder: !0, num: t.length };
    return t.push(i), e;
  } else if (Array.isArray(i)) {
    const e = new Array(i.length);
    for (let r = 0; r < i.length; r++)
      e[r] = yb(i[r], t);
    return e;
  } else if (typeof i == "object" && !(i instanceof Date)) {
    const e = {};
    for (const r in i)
      Object.prototype.hasOwnProperty.call(i, r) && (e[r] = yb(i[r], t));
    return e;
  }
  return i;
}
function z4(i, t) {
  return i.data = _b(i.data, t), delete i.attachments, i;
}
function _b(i, t) {
  if (!i)
    return i;
  if (i && i._placeholder === !0) {
    if (typeof i.num == "number" && i.num >= 0 && i.num < t.length)
      return t[i.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(i))
    for (let e = 0; e < i.length; e++)
      i[e] = _b(i[e], t);
  else if (typeof i == "object")
    for (const e in i)
      Object.prototype.hasOwnProperty.call(i, e) && (i[e] = _b(i[e], t));
  return i;
}
const H4 = 5;
var te;
(function(i) {
  i[i.CONNECT = 0] = "CONNECT", i[i.DISCONNECT = 1] = "DISCONNECT", i[i.EVENT = 2] = "EVENT", i[i.ACK = 3] = "ACK", i[i.CONNECT_ERROR = 4] = "CONNECT_ERROR", i[i.BINARY_EVENT = 5] = "BINARY_EVENT", i[i.BINARY_ACK = 6] = "BINARY_ACK";
})(te || (te = {}));
class $4 {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(t) {
    this.replacer = t;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(t) {
    return (t.type === te.EVENT || t.type === te.ACK) && rv(t) ? this.encodeAsBinary({
      type: t.type === te.EVENT ? te.BINARY_EVENT : te.BINARY_ACK,
      nsp: t.nsp,
      data: t.data,
      id: t.id
    }) : [this.encodeAsString(t)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(t) {
    let e = "" + t.type;
    return (t.type === te.BINARY_EVENT || t.type === te.BINARY_ACK) && (e += t.attachments + "-"), t.nsp && t.nsp !== "/" && (e += t.nsp + ","), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(t) {
    const e = j4(t), r = this.encodeAsString(e.packet), n = e.buffers;
    return n.unshift(r), n;
  }
}
class Zx extends Qe {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(t) {
    super(), this.reviver = t;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(t) {
    let e;
    if (typeof t == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      e = this.decodeString(t);
      const r = e.type === te.BINARY_EVENT;
      r || e.type === te.BINARY_ACK ? (e.type = r ? te.EVENT : te.ACK, this.reconstructor = new V4(e), e.attachments === 0 && super.emitReserved("decoded", e)) : super.emitReserved("decoded", e);
    } else if (qx(t) || t.base64)
      if (this.reconstructor)
        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved("decoded", e));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + t);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(t) {
    let e = 0;
    const r = {
      type: Number(t.charAt(0))
    };
    if (te[r.type] === void 0)
      throw new Error("unknown packet type " + r.type);
    if (r.type === te.BINARY_EVENT || r.type === te.BINARY_ACK) {
      const s = e + 1;
      for (; t.charAt(++e) !== "-" && e != t.length; )
        ;
      const a = t.substring(s, e);
      if (a != Number(a) || t.charAt(e) !== "-")
        throw new Error("Illegal attachments");
      r.attachments = Number(a);
    }
    if (t.charAt(e + 1) === "/") {
      const s = e + 1;
      for (; ++e && !(t.charAt(e) === "," || e === t.length); )
        ;
      r.nsp = t.substring(s, e);
    } else
      r.nsp = "/";
    const n = t.charAt(e + 1);
    if (n !== "" && Number(n) == n) {
      const s = e + 1;
      for (; ++e; ) {
        const a = t.charAt(e);
        if (a == null || Number(a) != a) {
          --e;
          break;
        }
        if (e === t.length)
          break;
      }
      r.id = Number(t.substring(s, e + 1));
    }
    if (t.charAt(++e)) {
      const s = this.tryParse(t.substr(e));
      if (Zx.isPayloadValid(r.type, s))
        r.data = s;
      else
        throw new Error("invalid payload");
    }
    return r;
  }
  tryParse(t) {
    try {
      return JSON.parse(t, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(t, e) {
    switch (t) {
      case te.CONNECT:
        return typeof e == "object";
      case te.DISCONNECT:
        return e === void 0;
      case te.CONNECT_ERROR:
        return typeof e == "string" || typeof e == "object";
      case te.EVENT:
      case te.BINARY_EVENT:
        return Array.isArray(e) && e.length > 0;
      case te.ACK:
      case te.BINARY_ACK:
        return Array.isArray(e);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class V4 {
  constructor(t) {
    this.packet = t, this.buffers = [], this.reconPack = t;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(t) {
    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
      const e = z4(this.reconPack, this.buffers);
      return this.finishedReconstruction(), e;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const X4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder: Zx,
  Encoder: $4,
  get PacketType() {
    return te;
  },
  protocol: H4
}, Symbol.toStringTag, { value: "Module" }));
function Xi(i, t, e) {
  return i.on(t, e), function() {
    i.off(t, e);
  };
}
const W4 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class WP extends Qe {
  /**
   * `Socket` constructor.
   */
  constructor(t, e, r) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const t = this.io;
    this.subs = [
      Xi(t, "open", this.onopen.bind(this)),
      Xi(t, "packet", this.onpacket.bind(this)),
      Xi(t, "error", this.onerror.bind(this)),
      Xi(t, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...t) {
    return t.unshift("message"), this.emit.apply(this, t), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(t, ...e) {
    if (W4.hasOwnProperty(t))
      throw new Error('"' + t.toString() + '" is a reserved event name');
    if (e.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(e), this;
    const r = {
      type: te.EVENT,
      data: e
    };
    if (r.options = {}, r.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == "function") {
      const a = this.ids++, o = e.pop();
      this._registerAckCallback(a, o), r.id = a;
    }
    const n = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    return this.flags.volatile && (!n || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(t, e) {
    var r;
    const n = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout;
    if (n === void 0) {
      this.acks[t] = e;
      return;
    }
    const s = this.io.setTimeoutFn(() => {
      delete this.acks[t];
      for (let a = 0; a < this.sendBuffer.length; a++)
        this.sendBuffer[a].id === t && this.sendBuffer.splice(a, 1);
      e.call(this, new Error("operation has timed out"));
    }, n);
    this.acks[t] = (...a) => {
      this.io.clearTimeoutFn(s), e.apply(this, [null, ...a]);
    };
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(t, ...e) {
    const r = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((n, s) => {
      e.push((a, o) => r ? a ? s(a) : n(o) : n(a)), this.emit(t, ...e);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(t) {
    let e;
    typeof t[t.length - 1] == "function" && (e = t.pop());
    const r = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: t,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    t.push((n, ...s) => r !== this._queue[0] ? void 0 : (n !== null ? r.tryCount > this._opts.retries && (this._queue.shift(), e && e(n)) : (this._queue.shift(), e && e(null, ...s)), r.pending = !1, this._drainQueue())), this._queue.push(r), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(t = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const e = this._queue[0];
    e.pending && !t || (e.pending = !0, e.tryCount++, this.flags = e.flags, this.emit.apply(this, e.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(t) {
    t.nsp = this.nsp, this.io._packet(t);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((t) => {
      this._sendConnectPacket(t);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(t) {
    this.packet({
      type: te.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(t) {
    this.connected || this.emitReserved("connect_error", t);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(t, e) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", t, e);
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case te.CONNECT:
          t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case te.EVENT:
        case te.BINARY_EVENT:
          this.onevent(t);
          break;
        case te.ACK:
        case te.BINARY_ACK:
          this.onack(t);
          break;
        case te.DISCONNECT:
          this.ondisconnect();
          break;
        case te.CONNECT_ERROR:
          this.destroy();
          const r = new Error(t.data.message);
          r.data = t.data.data, this.emitReserved("connect_error", r);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(t) {
    const e = t.data || [];
    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const e = this._anyListeners.slice();
      for (const r of e)
        r.apply(this, t);
    }
    super.emit.apply(this, t), this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(t) {
    const e = this;
    let r = !1;
    return function(...n) {
      r || (r = !0, e.packet({
        type: te.ACK,
        id: t,
        data: n
      }));
    };
  }
  /**
   * Called upon a server acknowlegement.
   *
   * @param packet
   * @private
   */
  onack(t) {
    const e = this.acks[t.id];
    typeof e == "function" && (e.apply(this, t.data), delete this.acks[t.id]);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(t, e) {
    this.id = t, this.recovered = e && this._pid === e, this._pid = e, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {
      this.notifyOutgoingListeners(t), this.packet(t);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: te.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(t) {
    return this.flags.compress = t, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(t) {
    return this.flags.timeout = t, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(t) {
    if (!this._anyListeners)
      return this;
    if (t) {
      const e = this._anyListeners;
      for (let r = 0; r < e.length; r++)
        if (t === e[r])
          return e.splice(r, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners)
      return this;
    if (t) {
      const e = this._anyOutgoingListeners;
      for (let r = 0; r < e.length; r++)
        if (t === e[r])
          return e.splice(r, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const e = this._anyOutgoingListeners.slice();
      for (const r of e)
        r.apply(this, t.data);
    }
  }
}
function ph(i) {
  i = i || {}, this.ms = i.min || 100, this.max = i.max || 1e4, this.factor = i.factor || 2, this.jitter = i.jitter > 0 && i.jitter <= 1 ? i.jitter : 0, this.attempts = 0;
}
ph.prototype.duration = function() {
  var i = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t = Math.random(), e = Math.floor(t * this.jitter * i);
    i = Math.floor(t * 10) & 1 ? i + e : i - e;
  }
  return Math.min(i, this.max) | 0;
};
ph.prototype.reset = function() {
  this.attempts = 0;
};
ph.prototype.setMin = function(i) {
  this.ms = i;
};
ph.prototype.setMax = function(i) {
  this.max = i;
};
ph.prototype.setJitter = function(i) {
  this.jitter = i;
};
class bb extends Qe {
  constructor(t, e) {
    var r;
    super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (e = t, t = void 0), e = e || {}, e.path = e.path || "/socket.io", this.opts = e, x0(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((r = e.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new ph({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = "closed", this.uri = t;
    const n = e.parser || X4;
    this.encoder = new n.Encoder(), this.decoder = new n.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(t) {
    return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);
  }
  reconnectionDelay(t) {
    var e;
    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);
  }
  randomizationFactor(t) {
    var e;
    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);
  }
  reconnectionDelayMax(t) {
    var e;
    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);
  }
  timeout(t) {
    return arguments.length ? (this._timeout = t, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(t) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new VP(this.uri, this.opts);
    const e = this.engine, r = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const n = Xi(e, "open", function() {
      r.onopen(), t && t();
    }), s = Xi(e, "error", (a) => {
      r.cleanup(), r._readyState = "closed", this.emitReserved("error", a), t ? t(a) : r.maybeReconnectOnOpen();
    });
    if (this._timeout !== !1) {
      const a = this._timeout;
      a === 0 && n();
      const o = this.setTimeoutFn(() => {
        n(), e.close(), e.emit("error", new Error("timeout"));
      }, a);
      this.opts.autoUnref && o.unref(), this.subs.push(function() {
        clearTimeout(o);
      });
    }
    return this.subs.push(n), this.subs.push(s), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(t) {
    return this.open(t);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const t = this.engine;
    this.subs.push(Xi(t, "ping", this.onping.bind(this)), Xi(t, "data", this.ondata.bind(this)), Xi(t, "error", this.onerror.bind(this)), Xi(t, "close", this.onclose.bind(this)), Xi(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(t) {
    try {
      this.decoder.add(t);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(t) {
    $P(() => {
      this.emitReserved("packet", t);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(t) {
    this.emitReserved("error", t);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(t, e) {
    let r = this.nsps[t];
    return r ? this._autoConnect && !r.active && r.connect() : (r = new WP(this, t, e), this.nsps[t] = r), r;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(t) {
    const e = Object.keys(this.nsps);
    for (const r of e)
      if (this.nsps[r].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(t) {
    const e = this.encoder.encode(t);
    for (let r = 0; r < e.length; r++)
      this.engine.write(e[r], t.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(t, e) {
    this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, e), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const t = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const e = this.backoff.duration();
      this._reconnecting = !0;
      const r = this.setTimeoutFn(() => {
        t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open((n) => {
          n ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", n)) : t.onreconnect();
        }));
      }, e);
      this.opts.autoUnref && r.unref(), this.subs.push(function() {
        clearTimeout(r);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const t = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t);
  }
}
const Ch = {};
function iv(i, t) {
  typeof i == "object" && (t = i, i = void 0), t = t || {};
  const e = L4(i, t.path || "/socket.io"), r = e.source, n = e.id, s = e.path, a = Ch[n] && s in Ch[n].nsps, o = t.forceNew || t["force new connection"] || t.multiplex === !1 || a;
  let u;
  return o ? u = new bb(r, t) : (Ch[n] || (Ch[n] = new bb(r, t)), u = Ch[n]), e.query && !t.query && (t.query = e.queryKey), u.socket(e.path, t);
}
Object.assign(iv, {
  Manager: bb,
  Socket: WP,
  io: iv,
  connect: iv
});
var $i, En, Sn, zo, Ho, ia, na, sa, Wm, Ym, yd, Xl, qm, Wl, $o, Zm, Vo, Yl;
const Km = class {
  constructor(t = {}, e) {
    K(this, "hFactoryCls", {});
    K(this, "elc", new Jl());
    K(this, "fetch", (t) => fetch(t));
    K(this, "resolution", 1);
    K(this, "cfg");
    K(this, "data", { sys: {}, mark: {}, kidoku: {} });
    K(this, "val");
    K(this, "appPixi");
    E(this, $i, 0);
    E(this, En, 0);
    E(this, Sn, 1);
    E(this, zo, 0);
    E(this, Ho, 0);
    E(this, ia, 0);
    E(this, na, 0);
    K(this, "isFullScr", !1);
    K(this, "extPort", 3776);
    E(this, sa, void 0);
    E(this, Wm, {
      auth: (t) => {
        if (t.t !== this.cfg.oCfg.debuger_token) {
          this.end();
          return;
        }
        this.toast("接続");
      },
      continue: () => this.toast("再生"),
      disconnect: () => this.toast("切断"),
      restart: (t) => {
        this.send2Dbg((t == null ? void 0 : t.ri) ?? "", {}), this.end(), this.run();
      },
      pause: () => this.toast("一時停止"),
      stopOnEntry: () => this.toast("一時停止"),
      stopOnDataBreakpoint: () => this.toast("注意"),
      stopOnBreakpoint: () => this.toast("注意"),
      stopOnStep: () => this.toast("一歩進む"),
      stopOnStepIn: () => this.toast("ステップイン"),
      stopOnStepOut: () => this.toast("ステップアウト"),
      stopOnBackstep: () => this.toast("一歩戻る"),
      _addPath: (t) => this.cfg.addPath(t.fn, t.o)
    });
    K(this, "pathBaseCnvSnPath4Dbg", "");
    K(this, "fire");
    E(this, yd, []);
    K(this, "callHook", (t, e) => {
    });
    K(this, "send2Dbg", (t, e) => {
      var r;
      (r = c(this, sa)) == null || r.emit("data", t, e);
    });
    K(this, "copyBMFolder", (t, e) => {
    });
    K(this, "eraseBMFolder", (t) => {
    });
    K(this, "close", () => !1);
    K(this, "_export", () => !1);
    K(this, "_import", () => !1);
    K(this, "navigate_to", () => !1);
    K(this, "title", (t) => {
      const { text: e } = t;
      if (!e)
        throw "[title] textは必須です";
      return P(this, Xl, e), this.titleSub(c(this, Xl) + c(this, Wl)), !1;
    });
    E(this, Xl, "");
    E(this, qm, (t) => {
      if (!t.key)
        return this.tglFlscr_sub(), !1;
      const e = t.key.toLowerCase();
      return this.elc.add(document, "keydown", (r) => {
        (r.altKey ? r.key === "Alt" ? "" : "alt+" : "") + (r.ctrlKey ? r.key === "Control" ? "" : "ctrl+" : "") + (r.shiftKey ? r.key === "Shift" ? "" : "shift+" : "") + r.key.toLowerCase() === e && (r.stopPropagation(), this.tglFlscr_sub());
      }, { passive: !0 }), !1;
    });
    K(this, "update_check", () => !1);
    K(this, "window", () => !1);
    E(this, Wl, "");
    E(this, $o, (t, e) => ({ ret: e.toString(), ext_num: 0 }));
    E(this, Zm, {
      1: { ext: "jpeg", fnc: (t) => c(this, Vo).call(this, t), mime: "image/jpeg" },
      2: { ext: "png", fnc: (t) => c(this, Vo).call(this, t), mime: "image/png" },
      3: { ext: "svg", fnc: (t) => c(this, Vo).call(this, t), mime: "image/svg+xml" },
      4: { ext: "webp", fnc: (t) => c(this, Vo).call(this, t), mime: "image/webp" },
      10: { ext: "mp3", fnc: (t) => t.arrayBuffer(), mime: "audio/mpeg" },
      11: { ext: "m4a", fnc: (t) => t.arrayBuffer(), mime: "audio/aac" },
      12: { ext: "ogg", fnc: (t) => t.arrayBuffer(), mime: "audio/ogg" },
      13: { ext: "aac", fnc: (t) => t.arrayBuffer(), mime: "audio/aac" },
      14: { ext: "flac", fnc: (t) => t.arrayBuffer(), mime: "audio/flac" },
      15: { ext: "wav", fnc: (t) => t.arrayBuffer(), mime: "audio/wav" },
      20: { ext: "mp4", fnc: (t) => c(this, Yl).call(this, t), mime: "video/mp4" },
      21: { ext: "webm", fnc: (t) => c(this, Yl).call(this, t), mime: "video/webm" },
      22: { ext: "ogv", fnc: (t) => c(this, Yl).call(this, t), mime: "video/ogv" }
    });
    E(this, Vo, (t) => new Promise((e, r) => {
      const n = new Image();
      n.onload = () => e(n), n.onerror = (s) => r(s), n.src = URL.createObjectURL(t);
    }));
    E(this, Yl, (t) => new Promise((e, r) => {
      const n = document.createElement("video");
      this.elc.add(n, "error", () => {
        var s;
        return r(((s = n == null ? void 0 : n.error) == null ? void 0 : s.message) ?? "");
      }), this.elc.add(n, "canplay", () => e(n)), n.src = URL.createObjectURL(t);
    }));
    K(this, "enc", (t) => t);
    K(this, "stk", () => "");
    K(this, "hash", (t) => "");
    K(this, "isApp", !1);
    K(this, "$path_downloads", "");
    K(this, "$path_userdata", "");
    this.hPlg = t, this.arg = e;
  }
  async loaded(t, e) {
    const r = t.snsys_pre;
    return delete t.snsys_pre, r == null ? void 0 : r.init({
      addTag: () => {
      },
      addLayCls: () => {
      },
      searchPath: () => "",
      getVal: () => ({}),
      resume: () => {
      },
      render: () => {
      },
      setDec: (n) => P(this, $o, n),
      setEnc: (n) => this.enc = n,
      getStK: (n) => this.stk = n,
      getHash: (n) => this.hash = n
    });
  }
  get cur() {
    return this.arg.cur;
  }
  get crypto() {
    return this.arg.crypto;
  }
  destroy() {
    this.elc.clear();
  }
  async loadPath(t, e) {
    this.cfg = e;
  }
  initVal(t, e, r) {
  }
  flush() {
  }
  async run() {
  }
  init(t, e, r, n) {
    this.val = r, this.appPixi = e;
    let s = "";
    try {
      this.val.setSys(this), s = "sys", s += Number(this.val.getVal("sys:TextLayer.Back.Alpha", 1)), s = "kidoku", this.val.saveKidoku();
    } catch (a) {
      console.error(`セーブデータ（${s}）が壊れています。一度クリアする必要があります %o`, a);
    }
    return t.close = (a) => this.close(a), t.export = (a) => this._export(a), t.import = (a) => this._import(a), t.navigate_to = (a) => this.navigate_to(a), t.title = (a) => this.title(a), t.toggle_full_screen = (a) => c(this, qm).call(this, a), t.update_check = (a) => this.update_check(a), t.window = (a) => this.window(a), r.setVal_Nochk("tmp", "const.sn.isApp", () => this.isApp), r.setVal_Nochk("tmp", "const.sn.isDbg", () => Y.isDbg), r.setVal_Nochk("tmp", "const.sn.isPackaged", () => Y.isPackaged), this.val.defTmp("const.sn.displayState", () => this.isFullScr), r.setVal_Nochk("sys", Km.VALNM_CFG_NS, this.cfg.oCfg.save_ns), r.flush(), Y.isDbg && this.attach_debug(n), this.hFactoryCls = {}, Object.values(this.hPlg).map((a) => a.init({
      addTag: (o, u) => {
        if (t[o])
          throw `すでに定義済みのタグ[${o}]です`;
        t[o] = u;
      },
      addLayCls: (o, u) => {
        if (this.hFactoryCls[o])
          throw `すでに定義済みのレイヤcls【${o}】です`;
        this.hFactoryCls[o] = u;
      },
      searchPath: (o, u = "") => this.cfg.searchPath(o, u),
      getVal: r.getVal,
      resume: () => n.resume(),
      render: (o, u, l = !1) => this.appPixi.renderer.render(o, { renderTexture: u, clear: l }),
      setDec: (o) => P(this, $o, o),
      setEnc: (o) => this.enc = o,
      getStK: (o) => this.stk = o,
      getHash: (o) => this.hash = o
    }));
  }
  get cvsWidth() {
    return c(this, $i);
  }
  get cvsHeight() {
    return c(this, En);
  }
  get cvsScale() {
    return c(this, Sn);
  }
  get ofsLeft4elm() {
    return c(this, zo);
  }
  get ofsTop4elm() {
    return c(this, Ho);
  }
  get ofsPadLeft_Dom2PIXI() {
    return c(this, ia);
  }
  get ofsPadTop_Dom2PIXI() {
    return c(this, na);
  }
  cvsResize() {
    var u;
    let t = globalThis.innerWidth, e = globalThis.innerHeight;
    const r = Ur.cvs, n = r.parentElement !== document.body;
    if (n) {
      const l = globalThis.getComputedStyle(r);
      t = parseFloat(l.width), e = parseFloat(l.height);
    }
    if (Y.isMobile) {
      const h = (((u = screen.orientation) == null ? void 0 : u.angle) ?? 0) % 180 === 0;
      (h && t > e || !h && t < e) && ([t, e] = [e, t]);
    }
    const s = r.getBoundingClientRect();
    if (vt(Y.hDip, "expanding", !0) || n || Y.stageW > t || Y.stageH > e)
      if (Y.stageW / Y.stageH <= t / e ? (P(this, En, e), P(this, $i, Y.stageW / Y.stageH * e)) : (P(this, $i, t), P(this, En, Y.stageH / Y.stageW * t)), P(this, Sn, c(this, $i) / Y.stageW), n)
        P(this, ia, 0), P(this, na, 0);
      else {
        const l = 1 - c(this, Sn);
        Y.isMobile ? (P(this, ia, (t - c(this, $i)) / 2 * l), P(this, na, (e - c(this, En)) / 2 * l)) : (P(this, ia, s.left * l), P(this, na, s.top * l));
      }
    else
      P(this, $i, Y.stageW), P(this, En, Y.stageH), P(this, Sn, 1), P(this, ia, 0), P(this, na, 0);
    const a = r.parentElement.style;
    n || (a.position = "relative", a.width = `${c(this, $i)}px`, a.height = `${c(this, En)}px`);
    const o = r.style;
    o.width = a.width, o.height = a.height, n ? (P(this, zo, s.left), P(this, Ho, s.top)) : (P(this, zo, 0), P(this, Ho, 0)), this.isFullScr && (P(this, zo, c(this, zo) + (t - c(this, $i)) / 2), P(this, Ho, c(this, Ho) + (e - c(this, En)) / 2));
  }
  // デバッガ接続
  attach_debug(t) {
    this.attach_debug = () => {
    };
    const e = document.createElement("style");
    e.innerHTML = `/* SKYNovel Dbg */
.sn_BounceInOut { animation: sn_kfBounceInOut linear 1.5s; }
@keyframes sn_kfBounceInOut{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
10%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
20%	{				transform: scaleX(0.95) scaleY(0.95);}
30%	{				transform: scaleX(1.00) scaleY(1.00);}
70%	{opacity: 1;}
100%{opacity: 0;}
}
.sn_BounceIn { animation: sn_kfBounceIn linear 0.3s; }
@keyframes sn_kfBounceIn{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
50%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
100%{				transform: scaleX(0.95) scaleY(0.95);}
}
.sn_HopIn { animation: sn_kfHopIn linear 0.8s; }
@keyframes sn_kfHopIn{
0%	{transform:	translate(0px,   0px);}
15% {transform:	translate(0px, -25px);}
30% {transform:	translate(0px,   0px);}
45% {transform:	translate(0px, -15px);}
60% {transform:	translate(0px,   0px);}
75% {transform:	translate(0px,  -5px);}
100%{transform:	translate(0px,   0px);}
}`, document.getElementsByTagName("head")[0].appendChild(e), this.addHook((r, n) => {
      var s, a;
      return (a = (s = c(this, Wm))[r]) == null ? void 0 : a.call(s, n);
    }), P(this, sa, iv(`http://localhost:${this.extPort}`)), c(this, sa).on("data", (r, n) => {
      this.callHook(r, n);
    }).on("disconnect", () => t.setLoop(!0)), this.callHook = (r, n) => {
      for (const s of c(this, yd))
        s(r, n);
    };
  }
  end() {
    var t;
    (t = c(this, sa)) == null || t.disconnect(), P(this, sa, void 0);
  }
  toast(t) {
    const e = document.body;
    e.querySelectorAll(".sn_BounceIn, .sn_HopIn").forEach((a) => e.removeChild(a));
    const r = document.createElement("img"), n = c(Km, Ym)[t];
    r.src = `data:image/svg+xml;base64,${n.dat}`;
    const s = Math.min(Y.stageW, Y.stageH) / 4 * c(this, Sn);
    r.width = r.height = s, r.style.cssText = `position: absolute;
left: ${(Y.stageW - s) / 2 * c(this, Sn) + s * (n.dx ?? 0)}px;
top: ${(Y.stageH - s) / 2 * c(this, Sn) + s * (n.dy ?? 0)}px;`, r.classList.add("sn_toast", n.ease ?? "sn_BounceInOut"), n.ease || r.addEventListener("animationend", () => e.removeChild(r), { once: !0, passive: !0 }), e.insertBefore(r, Ur.cvs);
  }
  setFire(t) {
    this.fire = t;
  }
  addHook(t) {
    c(this, yd).push(t);
  }
  titleSub(t) {
  }
  tglFlscr_sub() {
  }
  setTitleInfo(t) {
    P(this, Wl, t), this.titleSub(c(this, Xl) + c(this, Wl));
  }
  decStr(t, e) {
    return c(this, $o).call(this, t, e).ret;
  }
  async dec(t, e) {
    const { ret: r, ext_num: n } = c(this, $o).call(this, t, e), s = c(this, Zm)[n];
    return s != null && s.fnc ? await s.fnc(new Blob([r], { type: s.mime })) : r;
  }
  get path_downloads() {
    return this.$path_downloads;
  }
  get path_userdata() {
    return this.$path_userdata;
  }
  canCapturePage(t, e) {
    return !1;
  }
  async savePic(t, e) {
  }
  async appendFile(t, e, r) {
  }
  async ensureFileSync(t) {
  }
};
let $h = Km;
$i = new WeakMap(), En = new WeakMap(), Sn = new WeakMap(), zo = new WeakMap(), Ho = new WeakMap(), ia = new WeakMap(), na = new WeakMap(), sa = new WeakMap(), Wm = new WeakMap(), Ym = new WeakMap(), yd = new WeakMap(), Xl = new WeakMap(), qm = new WeakMap(), Wl = new WeakMap(), $o = new WeakMap(), Zm = new WeakMap(), Vo = new WeakMap(), Yl = new WeakMap(), K($h, "VALNM_CFG_NS", "const.sn.cfg.ns"), E($h, Ym, {
  // Thanks ICOOON MONO https://icooon-mono.com/ 、 https://vectr.com/ で 640x640化、ImageOptim経由、Base64エンコーダー https://lab.syncer.jp/Tool/Base64-encode/ 
  接続: { dx: -1, dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMCAyOTJ2NTUuODhoMTI3LjEzYzEyLjM3IDQ2IDU0LjEyIDc5Ljg3IDEwNCA3OS44N2g3Ny44N3YtMjE1LjYyYy00Ni43MyAwLTcyLjY4IDAtNzcuODggMC00OS43NCAwLTkxLjYyIDMzLjg3LTEwMy45OSA3OS44Ny0xNi45NSAwLTU5LjMzIDAtMTI3LjEzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im01MTIuODggMjkyYy0xMi4zOC00Ni01NC4xMy03OS44Ny0xMDQtNzkuODctNS4yMSAwLTMxLjIxIDAtNzggMHYyMTUuNzRoNzcuODdjNDkuODggMCA5MS43NS0zMy44NyAxMDQtNzkuODdoMTI3LjI1di01NmMtNzYuMjcgMC0xMTguNjUgMC0xMjcuMTIgMHoiLz48L2RlZnM+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9IiMzYWFiZDIiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYiIvPjx1c2UgZmlsbD0iIzNhYWJkMiIgeGxpbms6aHJlZj0iI2MiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNjIi8+PC9zdmc+" },
  切断: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMTkxLjUzIDIyMS4yNGMtNDUuNjggMC04NC4wMSAzMS4wNC05NS4zIDczLjE2LTYuNDEgMC0zOC40OSAwLTk2LjIzIDB2NTEuMjFoOTYuMjNjMTEuMyA0Mi4xMSA0OS42MyA3My4xNiA5NS4zIDczLjE2aDcxLjMzdi00OC4yNGg1My43OHYtMTAxLjA1aC01My43OHYtNDguMjRjLTQyLjggMC02Ni41NyAwLTcxLjMzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im00NDguNDcgMjIxLjIzYy00Ljc2IDAtMjguNTMgMC03MS4zMyAwdjE5Ny41M2g3MS4zM2M0NS42OCAwIDgzLjk5LTMxLjA0IDk1LjI5LTczLjE1aDk2LjI0di01MS4yMWgtOTYuMjRjLTMzLjA4LTQ4Ljc4LTY0Ljg0LTczLjE3LTk1LjI5LTczLjE3eiIvPjwvZGVmcz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0iI2RmNTY1NiIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSIjZGY1NjU2IiB4bGluazpocmVmPSIjYyIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2MiLz48L3N2Zz4=" },
  再生: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yNTguODMgMTExLjA1Yy0xLjI5Ljc5LTIuOTMuODMtNC4yNi4wNC0xLjI5LS43NC0yLjExLTIuMTItMi4xMS0zLjY3IDAtNy4xNiAwLTQyLjk3IDAtMTA3LjQzczAtMTAwLjI3IDAtMTA3LjQzYzAtMS41My44Mi0yLjkzIDIuMTEtMy42OCAxLjMzLS43NiAyLjk3LS43MiA0LjI2LjA0IDE4IDEwLjc1IDE2MiA5Ni43MSAxODAgMTA3LjQ2IDEuMjkuNzMgMi4wNSAyLjE0IDIuMDUgMy42MSAwIDEuNDktLjc2IDIuODgtMi4wNSAzLjYzLTM2IDIxLjQ5LTE2MiA5Ni42OS0xODAgMTA3LjQzeiIvPjwvZGVmcz48cGF0aCBkPSJtMTU0LjU3IDE3MC4xOWgzNDYuMTV2MzA3LjY5aC0zNDYuMTV6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
  一時停止: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yMDAgMTAwdi0yMDBoODB2MjAwem0xNjAgMHYtMjAwaDgwdjIwMHoiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxODAuNDFoMzUyLjR2MjgyLjY5aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
  注意: { ease: "sn_HopIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMzQzLjM0IDI5LjJjLTEwLjM3LTE3Ljk3LTM2LjMxLTE3Ljk3LTQ2LjY5IDAtMjkuMyA1MC43NS0yNjMuNyA0NTYuNzQtMjkzIDUwNy40OS0xMC4zNyAxNy45NyAyLjU5IDQwLjQ0IDIzLjM0IDQwLjQ0aDU4Ni4wMWMyMC43NSAwIDMzLjcyLTIyLjQ2IDIzLjM1LTQwLjQ0LTU4LjYtMTAxLjUtMjYzLjctNDU2Ljc0LTI5My4wMS01MDcuNDl6bS0yMy4zNCA0ODIuODNjLTE0LjUyIDAtMjYuMjktMi43MS0yNi4yOS02LjA2IDAtNC4yMSAwLTM3Ljg2IDAtNDIuMDcgMC0zLjM1IDExLjc3LTYuMDcgMjYuMjktNi4wN3MyNi4yOSAyLjcyIDI2LjI5IDYuMDd2NDIuMDdjLTcuODQgNC4wNC0xNi42MSA2LjA2LTI2LjI5IDYuMDZ6bTIxLjk5LTEwMy44NGMwIDUuNDMtOS44NSA5LjgzLTIxLjk5IDkuODMtMTIuMTUgMC0yMS45OS00LjQtMjEuOTktOS44MyAwLS4xMy4wNy0uMjUuMDgtLjM4LTEuMzctMTcuNTYtMTIuMy0xNTguMDYtMTMuNjctMTc1LjYyIDAtNS40MyAxNS45My05Ljg0IDM1LjU4LTkuODRzMzUuNTggNC40MSAzNS41OCA5Ljg0Yy0uOTEgMTEuNy01LjQ3IDcwLjI1LTEzLjY3IDE3NS42Mi4wNi4xNi4wOC4yOS4wOC4zOHoiLz48L2RlZnM+PHBhdGggZD0ibTI0MS4yOSAxOTEuNDRoMTQ1LjQ5djM1MS42NmgtMTQ1LjQ5eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iI2QyYmYzYSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
  一歩進む: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0zNzYuOTMgOTEuOTdjMC01My41MSAwLTgzLjI0IDAtODkuMTktLjE1LjE0LS4yNS4zNC0uNDQuNDUtMTYuMTEgOS42Mi0xNDQuOTUgODYuNTQtMTYxLjA2IDk2LjE1LTEuMTUuNjktMi42Mi43My0zLjgxLjAyLTEuMTUtLjY0LTEuODktMS44OS0xLjg5LTMuMjggMC02LjQxIDAtMzguNDQgMC05Ni4xMSAwLTU3LjY5IDAtODkuNzQgMC05Ni4xNSAwLTEuMzUuNzQtMi42MiAxLjg5LTMuMjkgMS4xOS0uNjggMi42Ni0uNjQgMy44MS4wNCAxNi4xMSA5LjYyIDE0NC45NSA4Ni41NCAxNjEuMDYgOTYuMTYuMTkuMS4yOS4zMS40NC40NSAwLTYuMTMgMC0zNi43NyAwLTkxLjkyaDUzLjMydjE4Ni42N3oiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxNTQuMmgzNTIuNHYzMDguOWgtMzUyLjR6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
  一歩戻る: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem00MzAuMjcgOTYuMTRjMCAxLjM1LS43NCAyLjYyLTEuODkgMy4yOC0xLjE5LjY5LTIuNjYuNjUtMy44MS0uMDMtMTYuMTEtOS42Mi0xNDQuOTUtODYuNTQtMTYxLjA1LTk2LjE2LS4yLS4xLS4yOS0uMzEtLjQ1LS40NXY5MS45MmgtNTMuMzJ2LTE4Ni42N2g1My4zMnY4OS4xOWMuMTYtLjE0LjI1LS4zNC40NS0uNDUgMTYuMS05LjYyIDE0NC45NC04Ni41NCAxNjEuMDUtOTYuMTYgMS4xNS0uNjggMi42Mi0uNzIgMy44MS0uMDEgMS4xNS42NCAxLjg5IDEuODkgMS44OSAzLjI4djk2LjExeiIvPjwvZGVmcz48cGF0aCBkPSJtMTQ3LjQ5IDE1NC4yaDM1Mi40djMwOC45aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
  ステップイン: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMTkuOTljMCAxNzYuNzQgMTQzLjI3IDMyMC4wMSAzMjAuMDEgMzIwLjAxIDE3Ni43MiAwIDMxOS45OS0xNDMuMjcgMzE5Ljk5LTMyMC4wMSAwLTE3Ni43Mi0xNDMuMjctMzE5Ljk5LTMxOS45OS0zMTkuOTktMTc2Ljc0IDAtMzIwLjAxIDE0My4yNy0zMjAuMDEgMzE5Ljk5em0xNTMuMDUtMjkuNzIgNTUuMTItNTUuMTMgMTExLjg0IDExMS44MiAxMTEuODItMTExLjgyIDU1LjEyIDU1LjEyLTE2Ni45NCAxNjYuOTd6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
  ステップアウト: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjAuMDFjMCAxNzYuNzIgMTQzLjI3IDMxOS45OSAzMTkuOTkgMzE5Ljk5IDE3Ni43NCAwIDMyMC4wMS0xNDMuMjcgMzIwLjAxLTMxOS45OSAwLTE3Ni43NC0xNDMuMjctMzIwLjAxLTMyMC4wMS0zMjAuMDEtMTc2LjcyIDAtMzE5Ljk5IDE0My4yNy0zMTkuOTkgMzIwLjAxem0zMTkuOTktMjYuOTgtMTExLjgyIDExMS44My01NS4xMi01NS4xMyAxNjYuOTQtMTY2Ljk2IDE2Ni45NiAxNjYuOTYtNTUuMTIgNTUuMTN6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" }
});
window.Buffer = bE;
class Y4 extends $h {
  constructor() {
    super(...arguments);
    K(this, "isApp", !0);
  }
  async loadPath(e, r) {
    await super.loadPath(e, r);
    const n = this.arg.cur + "path.json", s = await this.readFileSync(n), a = JSON.parse(this.decStr(n, s));
    for (const [o, u] of Object.entries(a)) {
      const l = e[o] = u;
      for (const [h, d] of Object.entries(l))
        h !== ":cnt" && (l[h] = this.arg.cur + d);
    }
  }
  init(e, r, n, s) {
    const a = super.init(e, r, n, s);
    return document.body.style.backgroundColor = "#000", a;
  }
  async savePic(e, r) {
    const n = r.slice(r.indexOf(",", 20) + 1);
    try {
      this.ensureFileSync(e), await this.writeFileSync(e, bE.from(n, "base64")), Y.debugLog && console.log(`画像ファイル ${e} を保存しました`);
    } catch (s) {
      throw s;
    }
  }
  async readFileSync(e) {
    return "";
  }
  async writeFileSync(e, r, n) {
  }
}
const oe = window.to_app;
var ir, _d, ql, Zl, nv;
class J4 extends Y4 {
  constructor(e = {}, r = { cur: "prj/", crypto: !1, dip: "" }) {
    super(e, r);
    E(this, Zl);
    E(this, ir, {
      getAppPath: "",
      isPackaged: !1,
      downloads: "",
      userData: "",
      getVersion: "",
      env: {},
      platform: "",
      arch: ""
    });
    K(this, "readFileSync", oe.readFileSync);
    K(this, "writeFileSync", oe.writeFileSync);
    K(this, "appendFile", oe.appendFile);
    K(this, "ensureFileSync", oe.ensureFileSync);
    K(this, "$path_userdata", "");
    K(this, "$path_downloads", "");
    E(this, _d, () => oe.Store({
      cwd: this.$path_userdata + "storage",
      name: this.arg.crypto ? "data_" : "data",
      encryptionKey: this.arg.crypto ? this.stk() : void 0
    }));
    E(this, ql, void 0);
    K(this, "copyBMFolder", async (e, r) => {
      const n = `${this.$path_userdata}storage/${e}/`, s = `${this.$path_userdata}storage/${r}/`;
      await oe.existsSync(n) && oe.copySync(n, s);
    });
    K(this, "eraseBMFolder", async (e) => {
      await oe.removeSync(`${this.$path_userdata}storage/${e}/`);
    });
    // アプリの終了
    K(this, "close", () => (oe.win_close(), !1));
    // プレイデータをエクスポート
    K(this, "_export", () => (oe.zip(
      this.$path_userdata + "storage/",
      this.$path_downloads + (this.crypto ? "" : "no_crypto_") + this.cfg.getNs() + ec("-", "_", "") + ".spd"
    ), Y.debugLog && console.log("プレイデータをエクスポートしました"), this.fire("sn:exported", new Event("click")), !1));
    // プレイデータをインポート
    K(this, "_import", () => {
      const e = this.flush;
      return new Promise((r, n) => {
        const s = document.createElement("input");
        s.type = "file", s.accept = ".spd, text/plain", s.onchange = () => {
          s.files ? r(s.files[0].path) : n();
        }, s.click();
      }).then(async (r) => {
        this.flush = () => {
        }, oe.unzip(r, this.$path_userdata + "storage/"), await c(this, _d).call(this);
        const n = await oe.Store_get();
        this.data.sys = n.sys, this.data.mark = n.mark, this.data.kidoku = n.kidoku, this.flush = e, this.flush(), this.val.updateData(n), Y.debugLog && console.log("プレイデータをインポートしました"), this.fire("sn:imported", new Event("click"));
      }), !1;
    });
    // ＵＲＬを開く
    K(this, "navigate_to", (e) => {
      const { url: r } = e;
      if (!r)
        throw "[navigate_to] urlは必須です";
      return oe.navigate_to(r), !1;
    });
    // 全画面状態切替
    K(this, "tglFlscr_sub", async () => oe.setSimpleFullScreen(
      this.isFullScr = !await oe.isSimpleFullScreen()
    ));
    // 更新チェック
    K(this, "update_check", (e) => {
      const { url: r } = e;
      if (!r)
        throw "[update_check] urlは必須です";
      if (r.at(-1) !== "/")
        throw "[update_check] urlの最後は/です";
      return Y.debugLog && zt.myTrace(`[update_check] url=${r}`, "D"), (async () => {
        let n = {}, s = "", a = "";
        const o = await this.fetch(r + "_index.json");
        if (o.ok)
          Y.debugLog && zt.myTrace("[update_check] _index.jsonを取得しました", "D"), n = await o.json(), a = n.version;
        else {
          const d = await this.fetch(r + `latest${Y.isMac ? "-mac" : ""}.yml`);
          if (!d.ok) {
            Y.debugLog && zt.myTrace("[update_check] [update_check] .ymlが見つかりません");
            return;
          }
          Y.debugLog && zt.myTrace("[update_check] .ymlを取得しました", "D"), s = await d.text();
          const f = /version: (.+)/.exec(s);
          if (!f)
            throw "[update_check] .yml に version が見つかりません";
          [, a] = f;
        }
        const u = c(this, ir).getVersion;
        if (Y.debugLog && zt.myTrace(`[update_check] 現在ver=${u} 新規ver=${a}`, "D"), a === u) {
          Y.debugLog && zt.myTrace("[update_check] バージョン更新なし", "I");
          return;
        }
        const l = {
          title: "アプリ更新",
          icon: c(this, ir).getAppPath + "/app/icon.png",
          buttons: ["OK", "Cancel"],
          defaultId: 0,
          cancelId: 1,
          message: `アプリ【${this.cfg.oCfg.book.title}】に更新があります。
ダウンロードしますか？`,
          detail: `現在 NOW ver ${u}
新規 NEW ver ${a}`
        }, { response: h } = await oe.showMessageBox(l);
        if (!(h > 0)) {
          if (Y.debugLog && zt.myTrace("[update_check] アプリダウンロード開始", "D"), o.ok) {
            const d = c(this, ir).platform + "_" + c(this, ir).arch, { cn: f, path: p } = n[d];
            if (f)
              await O(this, Zl, nv).call(this, r, d + "-" + f, p);
            else {
              let v = "";
              const g = new RegExp("^" + c(this, ir).platform + "_"), m = Object.entries(n).flatMap(([_, { path: b, cn: w }]) => g.test(_) ? (v += `
- ` + b, () => O(this, Zl, nv).call(this, r, _ + "-" + w, b)) : []);
              l.message = `CPU = ${c(this, ir).arch}
に対応するファイルが見つかりません。同じOSのファイルをすべてダウンロードしますか？`, l.detail = m.length + " 個ファイルがあります" + v;
              const { response: y } = await oe.showMessageBox(l);
              if (y > 0)
                return;
              await Promise.allSettled(m);
            }
          } else {
            const d = /path: (.+)/.exec(s);
            if (!d)
              throw "[update_check] path が見つかりません";
            const [, f] = d;
            Y.debugLog && zt.myTrace(`[update_check] path=${f}`, "D");
            const p = /sha512: (.+)/.exec(s);
            if (!p)
              throw "[update_check] sha512 が見つかりません";
            const [, v] = p;
            Y.debugLog && zt.myTrace(`[update_check] sha=${v}=`, "D");
            const [, g, m] = /(.+)(\.\w+)/.exec(f) ?? ["", "", ""];
            await O(this, Zl, nv).call(this, r, g + "-" + c(this, ir).arch + m, f);
          }
          Y.debugLog && zt.myTrace("アプリファイルを保存しました", "D"), l.buttons.pop(), l.message = `アプリ【${this.cfg.oCfg.book.title}】の更新パッケージを
ダウンロードしました`, oe.showMessageBox(l);
        }
      })(), !1;
    });
    // アプリウインドウ設定
    K(this, "window", (e) => {
      const r = tt(e, "x", Number(this.val.getVal("sys:const.sn.nativeWindow.x", 0))), n = tt(e, "y", Number(this.val.getVal("sys:const.sn.nativeWindow.y", 0)));
      return oe.window(vt(e, "centering", !1), r, n, Y.stageW, Y.stageH), this.val.setVal_Nochk("sys", "const.sn.nativeWindow.x", r), this.val.setVal_Nochk("sys", "const.sn.nativeWindow.y", n), this.flush(), !1;
    });
    globalThis.addEventListener("DOMContentLoaded", async () => this.loaded(e, r), { once: !0, passive: !0 });
  }
  async loaded(e, r) {
    await super.loaded(e, r), P(this, ir, await oe.getInfo()), Y.isPackaged = c(this, ir).isPackaged, this.arg = r = { ...r, cur: c(this, ir).getAppPath.replaceAll("\\", "/") + (Y.isPackaged ? "/doc/" : "/") + r.cur }, this.$path_downloads = c(this, ir).downloads.replaceAll("\\", "/") + "/", Y.isDbg = !!c(this, ir).env.SKYNOVEL_DBG && !Y.isPackaged, Y.isDbg && (this.extPort = ii(c(this, ir).env.SKYNOVEL_PORT ?? "3776")), this.run();
  }
  initVal(e, r, n) {
    r["const.sn.isDebugger"] = !1, r["const.sn.screenResolutionX"] = screen.width, r["const.sn.screenResolutionY"] = screen.height, this.$path_userdata = Y.isDbg ? c(this, ir).getAppPath.slice(0, -3) + ".vscode/" : c(this, ir).userData.replaceAll("\\", "/") + "/", this.flush = () => oe.flush(this.data), c(this, _d).call(this).then(async () => {
      const s = r["const.sn.isFirstBoot"] = await oe.Store_isEmpty();
      if (s)
        this.data.sys = e.sys, this.data.mark = e.mark, this.data.kidoku = e.kidoku, this.flush();
      else {
        const u = await oe.Store_get();
        this.data.sys = u.sys, this.data.mark = u.mark, this.data.kidoku = u.kidoku;
      }
      const a = this.data.sys["const.sn.nativeWindow.x"] ?? 0, o = this.data.sys["const.sn.nativeWindow.y"] ?? 0;
      oe.window(s, a, o, Y.stageW, Y.stageH), oe.on("save_win_pos", (u, l, h) => {
        this.val.setVal_Nochk("sys", "const.sn.nativeWindow.x", l), this.val.setVal_Nochk("sys", "const.sn.nativeWindow.y", h), this.flush();
      }), n(this.data);
    });
  }
  async run() {
    c(this, ql) && (c(this, ql).destroy(10), await new Promise((r) => setTimeout(r, 10))), P(this, ql, new Ur(this));
  }
  init(e, r, n, s) {
    const a = super.init(e, r, n, s), o = new Event("click");
    return oe.on("fire", (u, l) => s.fire(l, o)), this.cfg.oCfg.debug.devtool ? oe.openDevTools() : oe.win_ev_devtools_opened(() => {
      console.error("DevToolは禁止されています。許可する場合は【プロジェクト設定】の【devtool】をONに。"), s.destroy();
    }), a;
  }
  cvsResize() {
    super.cvsResize();
    const e = Ur.cvs, r = e.parentElement.style, n = e.style;
    this.isFullScr ? (r.position = "", r.width = "", r.height = "", n.position = "fixed", n.left = `${this.ofsLeft4elm}px`, n.top = `${this.ofsTop4elm}px`) : (r.position = "relative", r.width = `${this.cvsWidth}px`, r.height = `${this.cvsHeight}px`, n.position = "relative", n.left = "", n.top = "");
  }
  // タイトル指定
  titleSub(e) {
    oe.win_setTitle(e);
  }
  canCapturePage(e, r) {
    return oe.capturePage(e).then(() => r()), !0;
  }
}
ir = new WeakMap(), _d = new WeakMap(), ql = new WeakMap(), Zl = new WeakSet(), nv = async function(e, r, n) {
  Y.debugLog && zt.myTrace(`[update_check] アプリファイルDL試行... url=${e + r}`, "D");
  const s = await this.fetch(e + r);
  if (!s.ok) {
    Y.debugLog && zt.myTrace(`[update_check] アプリファイルが見つかりません url=${e + n}`);
    return;
  }
  const a = c(this, ir).downloads + "/" + n;
  Y.debugLog && zt.myTrace(`[update_check] pathDL=${a}`, "D");
  const o = await s.arrayBuffer();
  await this.writeFileSync(a, new DataView(o));
};
export {
  Y as CmnLib,
  _r as Layer,
  J4 as SysApp,
  vt as argChk_Boolean,
  tt as argChk_Num
};
//# sourceMappingURL=app.js.map
