var fE = Object.defineProperty;
var dE = (r, t, e) => t in r ? fE(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;
var D = (r, t, e) => (dE(r, typeof t != "symbol" ? t + "" : t, e), e), Uv = (r, t, e) => {
  if (!t.has(r))
    throw TypeError("Cannot " + e);
};
var h = (r, t, e) => (Uv(r, t, "read from private field"), e ? e.call(r) : t.get(r)), _ = (r, t, e) => {
  if (t.has(r))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(r) : t.set(r, e);
}, g = (r, t, e, i) => (Uv(r, t, "write to private field"), i ? i.call(r, e) : t.set(r, e), e), Te = (r, t, e, i) => ({
  set _(n) {
    g(r, t, n, e);
  },
  get _() {
    return h(r, t, i);
  }
}), x = (r, t, e) => (Uv(r, t, "access private method"), e);
import { parse as pE, format as vE, resolve as yE } from "url";
import { Buffer as T0 } from "buffer";
var uf = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ov(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var $f = { exports: {} };
/*!
 * Platform.js v1.3.6
 * Copyright 2014-2020 Benjamin Tan
 * Copyright 2011-2013 John-David Dalton
 * Available under MIT license
 */
$f.exports;
(function(r, t) {
  (function() {
    var e = {
      function: !0,
      object: !0
    }, i = e[typeof window] && window || this, n = t, s = r && !r.nodeType && r, o = n && s && typeof uf == "object" && uf;
    o && (o.global === o || o.window === o || o.self === o) && (i = o);
    var a = Math.pow(2, 53) - 1, l = /\bOpera/, u = Object.prototype, c = u.hasOwnProperty, d = u.toString;
    function f(P) {
      return P = String(P), P.charAt(0).toUpperCase() + P.slice(1);
    }
    function v(P, R, N) {
      var F = {
        "10.0": "10",
        "6.4": "10 Technical Preview",
        "6.3": "8.1",
        "6.2": "8",
        "6.1": "Server 2008 R2 / 7",
        "6.0": "Server 2008 / Vista",
        "5.2": "Server 2003 / XP 64-bit",
        "5.1": "XP",
        "5.01": "2000 SP1",
        "5.0": "2000",
        "4.0": "NT",
        "4.90": "ME"
      };
      return R && N && /^Win/i.test(P) && !/^Windows Phone /i.test(P) && (F = F[/[\d.]+$/.exec(P)]) && (P = "Windows " + F), P = String(P), R && N && (P = P.replace(RegExp(R, "i"), N)), P = p(
        P.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]
      ), P;
    }
    function m(P, R) {
      var N = -1, F = P ? P.length : 0;
      if (typeof F == "number" && F > -1 && F <= a)
        for (; ++N < F; )
          R(P[N], N, P);
      else
        y(P, R);
    }
    function p(P) {
      return P = I(P), /^(?:webOS|i(?:OS|P))/.test(P) ? P : f(P);
    }
    function y(P, R) {
      for (var N in P)
        c.call(P, N) && R(P[N], N, P);
    }
    function b(P) {
      return P == null ? f(P) : d.call(P).slice(8, -1);
    }
    function w(P, R) {
      var N = P != null ? typeof P[R] : "number";
      return !/^(?:boolean|number|string|undefined)$/.test(N) && (N == "object" ? !!P[R] : !0);
    }
    function E(P) {
      return String(P).replace(/([ -])(?!$)/g, "$1?");
    }
    function O(P, R) {
      var N = null;
      return m(P, function(F, $) {
        N = R(N, F, $, P);
      }), N;
    }
    function I(P) {
      return String(P).replace(/^ +| +$/g, "");
    }
    function S(P) {
      var R = i, N = P && typeof P == "object" && b(P) != "String";
      N && (R = P, P = null);
      var F = R.navigator || {}, $ = F.userAgent || "";
      P || (P = $);
      var q = N ? !!F.likeChrome : /\bChrome\b/.test(P) && !/internal|\n/i.test(d.toString()), ht = "Object", V = N ? ht : "ScriptBridgingProxyObject", H = N ? ht : "Environment", Q = N && R.java ? "JavaPackage" : b(R.java), mt = N ? ht : "RuntimeObject", et = /\bJava/.test(Q) && R.java, Tt = et && b(R.environment) == H, it = et ? "a" : "α", we = et ? "b" : "β", Bt = R.document || {}, Dt = R.operamini || R.opera, Ut = l.test(Ut = N && Dt ? Dt["[[Class]]"] : b(Dt)) ? Ut : Dt = null, k, zt = P, lt = [], me = null, jt = P == $, Z = jt && Dt && typeof Dt.version == "function" && Dt.version(), be, ft = Re([
        { label: "EdgeHTML", pattern: "Edge" },
        "Trident",
        { label: "WebKit", pattern: "AppleWebKit" },
        "iCab",
        "Presto",
        "NetFront",
        "Tasman",
        "KHTML",
        "Gecko"
      ]), B = ke([
        "Adobe AIR",
        "Arora",
        "Avant Browser",
        "Breach",
        "Camino",
        "Electron",
        "Epiphany",
        "Fennec",
        "Flock",
        "Galeon",
        "GreenBrowser",
        "iCab",
        "Iceweasel",
        "K-Meleon",
        "Konqueror",
        "Lunascape",
        "Maxthon",
        { label: "Microsoft Edge", pattern: "(?:Edge|Edg|EdgA|EdgiOS)" },
        "Midori",
        "Nook Browser",
        "PaleMoon",
        "PhantomJS",
        "Raven",
        "Rekonq",
        "RockMelt",
        { label: "Samsung Internet", pattern: "SamsungBrowser" },
        "SeaMonkey",
        { label: "Silk", pattern: "(?:Cloud9|Silk-Accelerated)" },
        "Sleipnir",
        "SlimBrowser",
        { label: "SRWare Iron", pattern: "Iron" },
        "Sunrise",
        "Swiftfox",
        "Vivaldi",
        "Waterfox",
        "WebPositive",
        { label: "Yandex Browser", pattern: "YaBrowser" },
        { label: "UC Browser", pattern: "UCBrowser" },
        "Opera Mini",
        { label: "Opera Mini", pattern: "OPiOS" },
        "Opera",
        { label: "Opera", pattern: "OPR" },
        "Chromium",
        "Chrome",
        { label: "Chrome", pattern: "(?:HeadlessChrome)" },
        { label: "Chrome Mobile", pattern: "(?:CriOS|CrMo)" },
        { label: "Firefox", pattern: "(?:Firefox|Minefield)" },
        { label: "Firefox for iOS", pattern: "FxiOS" },
        { label: "IE", pattern: "IEMobile" },
        { label: "IE", pattern: "MSIE" },
        "Safari"
      ]), at = Ni([
        { label: "BlackBerry", pattern: "BB10" },
        "BlackBerry",
        { label: "Galaxy S", pattern: "GT-I9000" },
        { label: "Galaxy S2", pattern: "GT-I9100" },
        { label: "Galaxy S3", pattern: "GT-I9300" },
        { label: "Galaxy S4", pattern: "GT-I9500" },
        { label: "Galaxy S5", pattern: "SM-G900" },
        { label: "Galaxy S6", pattern: "SM-G920" },
        { label: "Galaxy S6 Edge", pattern: "SM-G925" },
        { label: "Galaxy S7", pattern: "SM-G930" },
        { label: "Galaxy S7 Edge", pattern: "SM-G935" },
        "Google TV",
        "Lumia",
        "iPad",
        "iPod",
        "iPhone",
        "Kindle",
        { label: "Kindle Fire", pattern: "(?:Cloud9|Silk-Accelerated)" },
        "Nexus",
        "Nook",
        "PlayBook",
        "PlayStation Vita",
        "PlayStation",
        "TouchPad",
        "Transformer",
        { label: "Wii U", pattern: "WiiU" },
        "Wii",
        "Xbox One",
        { label: "Xbox 360", pattern: "Xbox" },
        "Xoom"
      ]), Et = pi({
        Apple: { iPad: 1, iPhone: 1, iPod: 1 },
        Alcatel: {},
        Archos: {},
        Amazon: { Kindle: 1, "Kindle Fire": 1 },
        Asus: { Transformer: 1 },
        "Barnes & Noble": { Nook: 1 },
        BlackBerry: { PlayBook: 1 },
        Google: { "Google TV": 1, Nexus: 1 },
        HP: { TouchPad: 1 },
        HTC: {},
        Huawei: {},
        Lenovo: {},
        LG: {},
        Microsoft: { Xbox: 1, "Xbox One": 1 },
        Motorola: { Xoom: 1 },
        Nintendo: { "Wii U": 1, Wii: 1 },
        Nokia: { Lumia: 1 },
        Oppo: {},
        Samsung: { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 },
        Sony: { PlayStation: 1, "PlayStation Vita": 1 },
        Xiaomi: { Mi: 1, Redmi: 1 }
      }), U = ki([
        "Windows Phone",
        "KaiOS",
        "Android",
        "CentOS",
        { label: "Chrome OS", pattern: "CrOS" },
        "Debian",
        { label: "DragonFly BSD", pattern: "DragonFly" },
        "Fedora",
        "FreeBSD",
        "Gentoo",
        "Haiku",
        "Kubuntu",
        "Linux Mint",
        "OpenBSD",
        "Red Hat",
        "SuSE",
        "Ubuntu",
        "Xubuntu",
        "Cygwin",
        "Symbian OS",
        "hpwOS",
        "webOS ",
        "webOS",
        "Tablet OS",
        "Tizen",
        "Linux",
        "Mac OS X",
        "Macintosh",
        "Mac",
        "Windows 98;",
        "Windows "
      ]);
      function Re(ce) {
        return O(ce, function(Vt, Rt) {
          return Vt || RegExp("\\b" + (Rt.pattern || E(Rt)) + "\\b", "i").exec(P) && (Rt.label || Rt);
        });
      }
      function pi(ce) {
        return O(ce, function(Vt, Rt, vi) {
          return Vt || (Rt[at] || Rt[/^[a-z]+(?: +[a-z]+\b)*/i.exec(at)] || RegExp("\\b" + E(vi) + "(?:\\b|\\w*\\d)", "i").exec(P)) && vi;
        });
      }
      function ke(ce) {
        return O(ce, function(Vt, Rt) {
          return Vt || RegExp("\\b" + (Rt.pattern || E(Rt)) + "\\b", "i").exec(P) && (Rt.label || Rt);
        });
      }
      function ki(ce) {
        return O(ce, function(Vt, Rt) {
          var vi = Rt.pattern || E(Rt);
          return !Vt && (Vt = RegExp("\\b" + vi + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(P)) && (Vt = v(Vt, vi, Rt.label || Rt)), Vt;
        });
      }
      function Ni(ce) {
        return O(ce, function(Vt, Rt) {
          var vi = Rt.pattern || E(Rt);
          return !Vt && (Vt = RegExp("\\b" + vi + " *\\d+[.\\w_]*", "i").exec(P) || RegExp("\\b" + vi + " *\\w+-[\\w]*", "i").exec(P) || RegExp("\\b" + vi + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(P)) && ((Vt = String(Rt.label && !RegExp(vi, "i").test(Rt.label) ? Rt.label : Vt).split("/"))[1] && !/[\d.]+/.test(Vt[0]) && (Vt[0] += " " + Vt[1]), Rt = Rt.label || Rt, Vt = p(Vt[0].replace(RegExp(vi, "i"), Rt).replace(RegExp("; *(?:" + Rt + "[_-])?", "i"), " ").replace(RegExp("(" + Rt + ")[-_.]?(\\w)", "i"), "$1 $2"))), Vt;
        });
      }
      function ri(ce) {
        return O(ce, function(Vt, Rt) {
          return Vt || (RegExp(Rt + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(P) || 0)[1] || null;
        });
      }
      function Sr() {
        return this.description || "";
      }
      if (ft && (ft = [ft]), /\bAndroid\b/.test(U) && !at && (k = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(P)) && (at = I(k[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null), Et && !at ? at = Ni([Et]) : Et && at && (at = at.replace(RegExp("^(" + E(Et) + ")[-_.\\s]", "i"), Et + " ").replace(RegExp("^(" + E(Et) + ")[-_.]?(\\w)", "i"), Et + " $2")), (k = /\bGoogle TV\b/.exec(at)) && (at = k[0]), /\bSimulator\b/i.test(P) && (at = (at ? at + " " : "") + "Simulator"), B == "Opera Mini" && /\bOPiOS\b/.test(P) && lt.push("running in Turbo/Uncompressed mode"), B == "IE" && /\blike iPhone OS\b/.test(P) ? (k = S(P.replace(/like iPhone OS/, "")), Et = k.manufacturer, at = k.product) : /^iP/.test(at) ? (B || (B = "Safari"), U = "iOS" + ((k = / OS ([\d_]+)/i.exec(P)) ? " " + k[1].replace(/_/g, ".") : "")) : B == "Konqueror" && /^Linux\b/i.test(U) ? U = "Kubuntu" : Et && Et != "Google" && (/Chrome/.test(B) && !/\bMobile Safari\b/i.test(P) || /\bVita\b/.test(at)) || /\bAndroid\b/.test(U) && /^Chrome/.test(B) && /\bVersion\//i.test(P) ? (B = "Android Browser", U = /\bAndroid\b/.test(U) ? U : "Android") : B == "Silk" ? (/\bMobi/i.test(P) || (U = "Android", lt.unshift("desktop mode")), /Accelerated *= *true/i.test(P) && lt.unshift("accelerated")) : B == "UC Browser" && /\bUCWEB\b/.test(P) ? lt.push("speed mode") : B == "PaleMoon" && (k = /\bFirefox\/([\d.]+)\b/.exec(P)) ? lt.push("identifying as Firefox " + k[1]) : B == "Firefox" && (k = /\b(Mobile|Tablet|TV)\b/i.exec(P)) ? (U || (U = "Firefox OS"), at || (at = k[1])) : !B || (k = !/\bMinefield\b/i.test(P) && /\b(?:Firefox|Safari)\b/.exec(B)) ? (B && !at && /[\/,]|^[^(]+?\)/.test(P.slice(P.indexOf(k + "/") + 8)) && (B = null), (k = at || Et || U) && (at || Et || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(U)) && (B = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(U) ? U : k) + " Browser")) : B == "Electron" && (k = (/\bChrome\/([\d.]+)\b/.exec(P) || 0)[1]) && lt.push("Chromium " + k), Z || (Z = ri([
        "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
        "Version",
        E(B),
        "(?:Firefox|Minefield|NetFront)"
      ])), (k = ft == "iCab" && parseFloat(Z) > 3 && "WebKit" || /\bOpera\b/.test(B) && (/\bOPR\b/.test(P) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(P) && !/^(?:Trident|EdgeHTML)$/.test(ft) && "WebKit" || !ft && /\bMSIE\b/i.test(P) && (U == "Mac OS" ? "Tasman" : "Trident") || ft == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(B) && "NetFront") && (ft = [k]), B == "IE" && (k = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(P) || 0)[1]) ? (B += " Mobile", U = "Windows Phone " + (/\+$/.test(k) ? k : k + ".x"), lt.unshift("desktop mode")) : /\bWPDesktop\b/i.test(P) ? (B = "IE Mobile", U = "Windows Phone 8.x", lt.unshift("desktop mode"), Z || (Z = (/\brv:([\d.]+)/.exec(P) || 0)[1])) : B != "IE" && ft == "Trident" && (k = /\brv:([\d.]+)/.exec(P)) && (B && lt.push("identifying as " + B + (Z ? " " + Z : "")), B = "IE", Z = k[1]), jt) {
        if (w(R, "global"))
          if (et && (k = et.lang.System, zt = k.getProperty("os.arch"), U = U || k.getProperty("os.name") + " " + k.getProperty("os.version")), Tt) {
            try {
              Z = R.require("ringo/engine").version.join("."), B = "RingoJS";
            } catch {
              (k = R.system) && k.global.system == R.system && (B = "Narwhal", U || (U = k[0].os || null));
            }
            B || (B = "Rhino");
          } else
            typeof R.process == "object" && !R.process.browser && (k = R.process) && (typeof k.versions == "object" && (typeof k.versions.electron == "string" ? (lt.push("Node " + k.versions.node), B = "Electron", Z = k.versions.electron) : typeof k.versions.nw == "string" && (lt.push("Chromium " + Z, "Node " + k.versions.node), B = "NW.js", Z = k.versions.nw)), B || (B = "Node.js", zt = k.arch, U = k.platform, Z = /[\d.]+/.exec(k.version), Z = Z ? Z[0] : null));
        else
          b(k = R.runtime) == V ? (B = "Adobe AIR", U = k.flash.system.Capabilities.os) : b(k = R.phantom) == mt ? (B = "PhantomJS", Z = (k = k.version || null) && k.major + "." + k.minor + "." + k.patch) : typeof Bt.documentMode == "number" && (k = /\bTrident\/(\d+)/i.exec(P)) ? (Z = [Z, Bt.documentMode], (k = +k[1] + 4) != Z[1] && (lt.push("IE " + Z[1] + " mode"), ft && (ft[1] = ""), Z[1] = k), Z = B == "IE" ? String(Z[1].toFixed(1)) : Z[0]) : typeof Bt.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(B) && (lt.push("masking as " + B + " " + Z), B = "IE", Z = "11.0", ft = ["Trident"], U = "Windows");
        U = U && p(U);
      }
      if (Z && (k = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(Z) || /(?:alpha|beta)(?: ?\d)?/i.exec(P + ";" + (jt && F.appMinorVersion)) || /\bMinefield\b/i.test(P) && "a") && (me = /b/i.test(k) ? "beta" : "alpha", Z = Z.replace(RegExp(k + "\\+?$"), "") + (me == "beta" ? we : it) + (/\d+\+?/.exec(k) || "")), B == "Fennec" || B == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(U))
        B = "Firefox Mobile";
      else if (B == "Maxthon" && Z)
        Z = Z.replace(/\.[\d.]+/, ".x");
      else if (/\bXbox\b/i.test(at))
        at == "Xbox 360" && (U = null), at == "Xbox 360" && /\bIEMobile\b/.test(P) && lt.unshift("mobile mode");
      else if ((/^(?:Chrome|IE|Opera)$/.test(B) || B && !at && !/Browser|Mobi/.test(B)) && (U == "Windows CE" || /Mobi/i.test(P)))
        B += " Mobile";
      else if (B == "IE" && jt)
        try {
          R.external === null && lt.unshift("platform preview");
        } catch {
          lt.unshift("embedded");
        }
      else
        (/\bBlackBerry\b/.test(at) || /\bBB10\b/.test(P)) && (k = (RegExp(at.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(P) || 0)[1] || Z) ? (k = [k, /BB10/.test(P)], U = (k[1] ? (at = null, Et = "BlackBerry") : "Device Software") + " " + k[0], Z = null) : this != y && at != "Wii" && (jt && Dt || /Opera/.test(B) && /\b(?:MSIE|Firefox)\b/i.test(P) || B == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(U) || B == "IE" && (U && !/^Win/.test(U) && Z > 5.5 || /\bWindows XP\b/.test(U) && Z > 8 || Z == 8 && !/\bTrident\b/.test(P))) && !l.test(k = S.call(y, P.replace(l, "") + ";")) && k.name && (k = "ing as " + k.name + ((k = k.version) ? " " + k : ""), l.test(B) ? (/\bIE\b/.test(k) && U == "Mac OS" && (U = null), k = "identify" + k) : (k = "mask" + k, Ut ? B = p(Ut.replace(/([a-z])([A-Z])/g, "$1 $2")) : B = "Opera", /\bIE\b/.test(k) && (U = null), jt || (Z = null)), ft = ["Presto"], lt.push(k));
      (k = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(P) || 0)[1]) && (k = [parseFloat(k.replace(/\.(\d)$/, ".0$1")), k], B == "Safari" && k[1].slice(-1) == "+" ? (B = "WebKit Nightly", me = "alpha", Z = k[1].slice(0, -1)) : (Z == k[1] || Z == (k[2] = (/\bSafari\/([\d.]+\+?)/i.exec(P) || 0)[1])) && (Z = null), k[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(P) || 0)[1], k[0] == 537.36 && k[2] == 537.36 && parseFloat(k[1]) >= 28 && ft == "WebKit" && (ft = ["Blink"]), !jt || !q && !k[1] ? (ft && (ft[1] = "like Safari"), k = (k = k[0], k < 400 ? 1 : k < 500 ? 2 : k < 526 ? 3 : k < 533 ? 4 : k < 534 ? "4+" : k < 535 ? 5 : k < 537 ? 6 : k < 538 ? 7 : k < 601 ? 8 : k < 602 ? 9 : k < 604 ? 10 : k < 606 ? 11 : k < 608 ? 12 : "12")) : (ft && (ft[1] = "like Chrome"), k = k[1] || (k = k[0], k < 530 ? 1 : k < 532 ? 2 : k < 532.05 ? 3 : k < 533 ? 4 : k < 534.03 ? 5 : k < 534.07 ? 6 : k < 534.1 ? 7 : k < 534.13 ? 8 : k < 534.16 ? 9 : k < 534.24 ? 10 : k < 534.3 ? 11 : k < 535.01 ? 12 : k < 535.02 ? "13+" : k < 535.07 ? 15 : k < 535.11 ? 16 : k < 535.19 ? 17 : k < 536.05 ? 18 : k < 536.1 ? 19 : k < 537.01 ? 20 : k < 537.11 ? "21+" : k < 537.13 ? 23 : k < 537.18 ? 24 : k < 537.24 ? 25 : k < 537.36 ? 26 : ft != "Blink" ? "27" : "28")), ft && (ft[1] += " " + (k += typeof k == "number" ? ".x" : /[.+]/.test(k) ? "" : "+")), B == "Safari" && (!Z || parseInt(Z) > 45) ? Z = k : B == "Chrome" && /\bHeadlessChrome/i.test(P) && lt.unshift("headless")), B == "Opera" && (k = /\bzbov|zvav$/.exec(U)) ? (B += " ", lt.unshift("desktop mode"), k == "zvav" ? (B += "Mini", Z = null) : B += "Mobile", U = U.replace(RegExp(" *" + k + "$"), "")) : B == "Safari" && /\bChrome\b/.exec(ft && ft[1]) ? (lt.unshift("desktop mode"), B = "Chrome Mobile", Z = null, /\bOS X\b/.test(U) ? (Et = "Apple", U = "iOS 4.3+") : U = null) : /\bSRWare Iron\b/.test(B) && !Z && (Z = ri("Chrome")), Z && Z.indexOf(k = /[\d.]+$/.exec(U)) == 0 && P.indexOf("/" + k + "-") > -1 && (U = I(U.replace(k, ""))), U && U.indexOf(B) != -1 && !RegExp(B + " OS").test(U) && (U = U.replace(RegExp(" *" + E(B) + " *"), "")), ft && !/\b(?:Avant|Nook)\b/.test(B) && (/Browser|Lunascape|Maxthon/.test(B) || B != "Safari" && /^iOS/.test(U) && /\bSafari\b/.test(ft[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(B) && ft[1]) && (k = ft[ft.length - 1]) && lt.push(k), lt.length && (lt = ["(" + lt.join("; ") + ")"]), Et && at && at.indexOf(Et) < 0 && lt.push("on " + Et), at && lt.push((/^on /.test(lt[lt.length - 1]) ? "" : "on ") + at), U && (k = / ([\d.+]+)$/.exec(U), be = k && U.charAt(U.length - k[0].length - 1) == "/", U = {
        architecture: 32,
        family: k && !be ? U.replace(k[0], "") : U,
        version: k ? k[1] : null,
        toString: function() {
          var ce = this.version;
          return this.family + (ce && !be ? " " + ce : "") + (this.architecture == 64 ? " 64-bit" : "");
        }
      }), (k = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(zt)) && !/\bi686\b/i.test(zt) ? (U && (U.architecture = 64, U.family = U.family.replace(RegExp(" *" + k), "")), B && (/\bWOW64\b/i.test(P) || jt && /\w(?:86|32)$/.test(F.cpuClass || F.platform) && !/\bWin64; x64\b/i.test(P)) && lt.unshift("32-bit")) : U && /^OS X/.test(U.family) && B == "Chrome" && parseFloat(Z) >= 39 && (U.architecture = 64), P || (P = null);
      var Ee = {};
      return Ee.description = P, Ee.layout = ft && ft[0], Ee.manufacturer = Et, Ee.name = B, Ee.prerelease = me, Ee.product = at, Ee.ua = P, Ee.version = B && Z, Ee.os = U || {
        /**
         * The CPU architecture the OS is built for.
         *
         * @memberOf platform.os
         * @type number|null
         */
        architecture: null,
        /**
         * The family of the OS.
         *
         * Common values include:
         * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
         * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
         * "SuSE", "Android", "iOS" and "Windows Phone"
         *
         * @memberOf platform.os
         * @type string|null
         */
        family: null,
        /**
         * The version of the OS.
         *
         * @memberOf platform.os
         * @type string|null
         */
        version: null,
        /**
         * Returns the OS string.
         *
         * @memberOf platform.os
         * @returns {string} The OS string.
         */
        toString: function() {
          return "null";
        }
      }, Ee.parse = S, Ee.toString = Sr, Ee.version && lt.unshift(Z), Ee.name && lt.unshift(B), U && B && !(U == String(U).split(" ")[0] && (U == B.split(" ")[0] || at)) && lt.push(at ? "(" + U + ")" : "on " + U), lt.length && (Ee.description = lt.join(" ")), Ee;
    }
    var C = S();
    n && s ? y(C, function(P, R) {
      n[R] = P;
    }) : i.platform = C;
  }).call(uf);
})($f, $f.exports);
var tl = $f.exports;
const S0 = /* @__PURE__ */ Ov(tl);
function Ue(r) {
  return parseInt(String(r), 10);
}
function mr(r) {
  const t = parseInt(String(r), 10);
  return t < 0 ? -t : t;
}
"toInt" in String.prototype || (String.prototype.toInt = function() {
  return Ue(this);
});
"toUint" in String.prototype || (String.prototype.toUint = function() {
  const r = Ue(this);
  return r < 0 ? -r : r;
});
function xl(r = "/", t = " ", e = ":", i = "") {
  const n = /* @__PURE__ */ new Date();
  return n.getFullYear() + r + String(100 + n.getMonth() + 1).slice(1, 3) + r + String(100 + n.getDate()).slice(1, 3) + t + String(100 + n.getHours()).slice(1, 3) + e + String(100 + n.getMinutes()).slice(1, 3) + (i === "" ? "" : i + String(n.getMilliseconds()));
}
const P0 = {
  alpha: 0,
  height: 0,
  rotation: 0,
  scale_x: 0,
  scale_y: 0,
  pivot_x: 0,
  pivot_y: 0,
  width: 0,
  x: 0,
  y: 0
};
function zf(r, t) {
  const e = {};
  for (const i of Object.keys(P0)) {
    if (!(i in r))
      continue;
    const n = String(r[i]), s = (n.at(0) === "=" ? n.slice(1) : n).split(","), o = e[i] = parseFloat(s[0]);
    s.length > 1 && (e[i] += Math.round(Math.random() * (parseFloat(s[1]) - o + 1))), n.at(0) === "=" && (e[i] += parseFloat(t[i]));
  }
  return e;
}
const O0 = "/* SKYNovel */";
function mE() {
  const r = document.getElementsByTagName("head")[0], t = r.children.length;
  for (let e = t - 1; e >= 0; --e) {
    const i = r.children[e];
    i instanceof HTMLStyleElement && i.innerText.slice(0, 14) === O0 && r.removeChild(i);
  }
}
function ba(r) {
  const t = document.createElement("style");
  t.innerHTML = O0 + r, document.getElementsByTagName("head")[0].appendChild(t);
}
function j(r, t, e) {
  const i = r[t];
  if (!(t in r)) {
    if (isNaN(e))
      throw `[${r[":タグ名"]}]属性 ${t} は必須です`;
    return r[t] = e, e;
  }
  const n = String(i).slice(0, 2) === "0x" ? parseInt(i) : parseFloat(i);
  if (isNaN(n))
    throw `[${r[":タグ名"]}]属性 ${t} の値【${i}】が数値ではありません`;
  return r[t] = n;
}
function K(r, t, e) {
  if (!(t in r))
    return r[t] = e;
  const i = r[t];
  if (i === null)
    return !1;
  const n = String(i);
  return r[t] = n === "false" ? !1 : !!n;
}
function Ym(r) {
  if (r.at(0) === "#")
    return parseInt(r.slice(1), 16);
  const t = Number(r);
  if (!isNaN(t))
    return t;
  if (r === "black")
    return 0;
  L.cc4ColorName.fillStyle = r;
  const e = L.cc4ColorName.fillStyle;
  if (e === "#000000")
    throw `色名前 ${r} が異常です`;
  return parseInt(e.slice(1), 16);
}
function I0(r, t, e) {
  const i = r[t];
  return i ? r[t] = Ym(String(i)) : r[t] = e;
}
const _E = /JSON at position (\d+)$/;
function cf(r, t = "", e = "") {
  const i = (e.match(_E) ?? ["", ""])[1];
  return `[${r[":タグ名"]}] ${t} 属性の解析エラー : ${e}
${r[t]}${i ? `
${"^".padStart(Number(i))}` : ""}`;
}
const gE = /^[^\/\.]+$|[^\/]+(?=\.)/;
function vl(r) {
  return (r.match(gE) ?? [""])[0];
}
const bE = /\.([^\.]+)$/;
function Vf(r) {
  return (r.match(bE) ?? ["", ""])[1];
}
var w0, E0;
class L {
}
D(L, "stageW", 0), D(L, "stageH", 0), D(L, "debugLog", !1), D(L, "isSafari", tl.name === "Safari"), D(L, "isFirefox", tl.name === "Firefox"), D(L, "isMac", new RegExp("OS X").test(((w0 = tl.os) == null ? void 0 : w0.family) ?? "")), D(L, "isMobile", !new RegExp("(Windows|OS X)").test(((E0 = tl.os) == null ? void 0 : E0.family) ?? "")), D(L, "hDip", {}), D(L, "isDbg", !1), D(L, "isPackaged", !1), D(L, "isDarkMode", !1), D(L, "cc4ColorName");
function xE(r) {
  var t = this.constructor;
  return this.then(
    function(e) {
      return t.resolve(r()).then(function() {
        return e;
      });
    },
    function(e) {
      return t.resolve(r()).then(function() {
        return t.reject(e);
      });
    }
  );
}
function wE(r) {
  var t = this;
  return new t(function(e, i) {
    if (!(r && typeof r.length < "u"))
      return i(
        new TypeError(
          typeof r + " " + r + " is not iterable(cannot read property Symbol(Symbol.iterator))"
        )
      );
    var n = Array.prototype.slice.call(r);
    if (n.length === 0)
      return e([]);
    var s = n.length;
    function o(l, u) {
      if (u && (typeof u == "object" || typeof u == "function")) {
        var c = u.then;
        if (typeof c == "function") {
          c.call(
            u,
            function(d) {
              o(l, d);
            },
            function(d) {
              n[l] = { status: "rejected", reason: d }, --s === 0 && e(n);
            }
          );
          return;
        }
      }
      n[l] = { status: "fulfilled", value: u }, --s === 0 && e(n);
    }
    for (var a = 0; a < n.length; a++)
      o(a, n[a]);
  });
}
function C0(r, t) {
  this.name = "AggregateError", this.errors = r, this.message = t || "";
}
C0.prototype = Error.prototype;
function EE(r) {
  var t = this;
  return new t(function(e, i) {
    if (!(r && typeof r.length < "u"))
      return i(new TypeError("Promise.any accepts an array"));
    var n = Array.prototype.slice.call(r);
    if (n.length === 0)
      return i();
    for (var s = [], o = 0; o < n.length; o++)
      try {
        t.resolve(n[o]).then(e).catch(function(a) {
          s.push(a), s.length === n.length && i(
            new C0(
              s,
              "All promises were rejected"
            )
          );
        });
      } catch (a) {
        i(a);
      }
  });
}
var TE = setTimeout;
function M0(r) {
  return !!(r && typeof r.length < "u");
}
function SE() {
}
function PE(r, t) {
  return function() {
    r.apply(t, arguments);
  };
}
function ye(r) {
  if (!(this instanceof ye))
    throw new TypeError("Promises must be constructed via new");
  if (typeof r != "function")
    throw new TypeError("not a function");
  this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], k0(r, this);
}
function R0(r, t) {
  for (; r._state === 3; )
    r = r._value;
  if (r._state === 0) {
    r._deferreds.push(t);
    return;
  }
  r._handled = !0, ye._immediateFn(function() {
    var e = r._state === 1 ? t.onFulfilled : t.onRejected;
    if (e === null) {
      (r._state === 1 ? my : wl)(t.promise, r._value);
      return;
    }
    var i;
    try {
      i = e(r._value);
    } catch (n) {
      wl(t.promise, n);
      return;
    }
    my(t.promise, i);
  });
}
function my(r, t) {
  try {
    if (t === r)
      throw new TypeError("A promise cannot be resolved with itself.");
    if (t && (typeof t == "object" || typeof t == "function")) {
      var e = t.then;
      if (t instanceof ye) {
        r._state = 3, r._value = t, _y(r);
        return;
      } else if (typeof e == "function") {
        k0(PE(e, t), r);
        return;
      }
    }
    r._state = 1, r._value = t, _y(r);
  } catch (i) {
    wl(r, i);
  }
}
function wl(r, t) {
  r._state = 2, r._value = t, _y(r);
}
function _y(r) {
  r._state === 2 && r._deferreds.length === 0 && ye._immediateFn(function() {
    r._handled || ye._unhandledRejectionFn(r._value);
  });
  for (var t = 0, e = r._deferreds.length; t < e; t++)
    R0(r, r._deferreds[t]);
  r._deferreds = null;
}
function OE(r, t, e) {
  this.onFulfilled = typeof r == "function" ? r : null, this.onRejected = typeof t == "function" ? t : null, this.promise = e;
}
function k0(r, t) {
  var e = !1;
  try {
    r(
      function(i) {
        e || (e = !0, my(t, i));
      },
      function(i) {
        e || (e = !0, wl(t, i));
      }
    );
  } catch (i) {
    if (e)
      return;
    e = !0, wl(t, i);
  }
}
ye.prototype.catch = function(r) {
  return this.then(null, r);
};
ye.prototype.then = function(r, t) {
  var e = new this.constructor(SE);
  return R0(this, new OE(r, t, e)), e;
};
ye.prototype.finally = xE;
ye.all = function(r) {
  return new ye(function(t, e) {
    if (!M0(r))
      return e(new TypeError("Promise.all accepts an array"));
    var i = Array.prototype.slice.call(r);
    if (i.length === 0)
      return t([]);
    var n = i.length;
    function s(a, l) {
      try {
        if (l && (typeof l == "object" || typeof l == "function")) {
          var u = l.then;
          if (typeof u == "function") {
            u.call(
              l,
              function(c) {
                s(a, c);
              },
              e
            );
            return;
          }
        }
        i[a] = l, --n === 0 && t(i);
      } catch (c) {
        e(c);
      }
    }
    for (var o = 0; o < i.length; o++)
      s(o, i[o]);
  });
};
ye.any = EE;
ye.allSettled = wE;
ye.resolve = function(r) {
  return r && typeof r == "object" && r.constructor === ye ? r : new ye(function(t) {
    t(r);
  });
};
ye.reject = function(r) {
  return new ye(function(t, e) {
    e(r);
  });
};
ye.race = function(r) {
  return new ye(function(t, e) {
    if (!M0(r))
      return e(new TypeError("Promise.race accepts an array"));
    for (var i = 0, n = r.length; i < n; i++)
      ye.resolve(r[i]).then(t, e);
  });
};
ye._immediateFn = // @ts-ignore
typeof setImmediate == "function" && function(r) {
  setImmediate(r);
} || function(r) {
  TE(r, 0);
};
ye._unhandledRejectionFn = function(t) {
  typeof console < "u" && console && console.warn("Possible Unhandled Promise Rejection:", t);
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var W_ = Object.getOwnPropertySymbols, IE = Object.prototype.hasOwnProperty, CE = Object.prototype.propertyIsEnumerable;
function ME(r) {
  if (r == null)
    throw new TypeError("Object.assign cannot be called with null or undefined");
  return Object(r);
}
function RE() {
  try {
    if (!Object.assign)
      return !1;
    var r = new String("abc");
    if (r[5] = "de", Object.getOwnPropertyNames(r)[0] === "5")
      return !1;
    for (var t = {}, e = 0; e < 10; e++)
      t["_" + String.fromCharCode(e)] = e;
    var i = Object.getOwnPropertyNames(t).map(function(s) {
      return t[s];
    });
    if (i.join("") !== "0123456789")
      return !1;
    var n = {};
    return "abcdefghijklmnopqrst".split("").forEach(function(s) {
      n[s] = s;
    }), Object.keys(Object.assign({}, n)).join("") === "abcdefghijklmnopqrst";
  } catch {
    return !1;
  }
}
var kE = RE() ? Object.assign : function(r, t) {
  for (var e, i = ME(r), n, s = 1; s < arguments.length; s++) {
    e = Object(arguments[s]);
    for (var o in e)
      IE.call(e, o) && (i[o] = e[o]);
    if (W_) {
      n = W_(e);
      for (var a = 0; a < n.length; a++)
        CE.call(e, n[a]) && (i[n[a]] = e[n[a]]);
    }
  }
  return i;
};
const NE = /* @__PURE__ */ Ov(kE);
/*!
 * @pixi/polyfill - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/polyfill is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
typeof globalThis > "u" && (typeof self < "u" ? self.globalThis = self : typeof global < "u" && (global.globalThis = global));
globalThis.Promise || (globalThis.Promise = ye);
Object.assign || (Object.assign = NE);
var AE = 16;
Date.now && Date.prototype.getTime || (Date.now = function() {
  return (/* @__PURE__ */ new Date()).getTime();
});
if (!(globalThis.performance && globalThis.performance.now)) {
  var LE = Date.now();
  globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {
    return Date.now() - LE;
  };
}
var Gv = Date.now(), Y_ = ["ms", "moz", "webkit", "o"];
for (var jv = 0; jv < Y_.length && !globalThis.requestAnimationFrame; ++jv) {
  var Hv = Y_[jv];
  globalThis.requestAnimationFrame = globalThis[Hv + "RequestAnimationFrame"], globalThis.cancelAnimationFrame = globalThis[Hv + "CancelAnimationFrame"] || globalThis[Hv + "CancelRequestAnimationFrame"];
}
globalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(r) {
  if (typeof r != "function")
    throw new TypeError(r + "is not a function");
  var t = Date.now(), e = AE + Gv - t;
  return e < 0 && (e = 0), Gv = t, globalThis.self.setTimeout(function() {
    Gv = Date.now(), r(performance.now());
  }, e);
});
globalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(r) {
  return clearTimeout(r);
});
Math.sign || (Math.sign = function(t) {
  return t = Number(t), t === 0 || isNaN(t) ? t : t > 0 ? 1 : -1;
});
Number.isInteger || (Number.isInteger = function(t) {
  return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
});
globalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array);
globalThis.Float32Array || (globalThis.Float32Array = Array);
globalThis.Uint32Array || (globalThis.Uint32Array = Array);
globalThis.Uint16Array || (globalThis.Uint16Array = Array);
globalThis.Uint8Array || (globalThis.Uint8Array = Array);
globalThis.Int32Array || (globalThis.Int32Array = Array);
/*!
 * @pixi/constants - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Bn;
(function(r) {
  r[r.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", r[r.WEBGL = 1] = "WEBGL", r[r.WEBGL2 = 2] = "WEBGL2";
})(Bn || (Bn = {}));
var El;
(function(r) {
  r[r.UNKNOWN = 0] = "UNKNOWN", r[r.WEBGL = 1] = "WEBGL", r[r.CANVAS = 2] = "CANVAS";
})(El || (El = {}));
var Xf;
(function(r) {
  r[r.COLOR = 16384] = "COLOR", r[r.DEPTH = 256] = "DEPTH", r[r.STENCIL = 1024] = "STENCIL";
})(Xf || (Xf = {}));
var ot;
(function(r) {
  r[r.NORMAL = 0] = "NORMAL", r[r.ADD = 1] = "ADD", r[r.MULTIPLY = 2] = "MULTIPLY", r[r.SCREEN = 3] = "SCREEN", r[r.OVERLAY = 4] = "OVERLAY", r[r.DARKEN = 5] = "DARKEN", r[r.LIGHTEN = 6] = "LIGHTEN", r[r.COLOR_DODGE = 7] = "COLOR_DODGE", r[r.COLOR_BURN = 8] = "COLOR_BURN", r[r.HARD_LIGHT = 9] = "HARD_LIGHT", r[r.SOFT_LIGHT = 10] = "SOFT_LIGHT", r[r.DIFFERENCE = 11] = "DIFFERENCE", r[r.EXCLUSION = 12] = "EXCLUSION", r[r.HUE = 13] = "HUE", r[r.SATURATION = 14] = "SATURATION", r[r.COLOR = 15] = "COLOR", r[r.LUMINOSITY = 16] = "LUMINOSITY", r[r.NORMAL_NPM = 17] = "NORMAL_NPM", r[r.ADD_NPM = 18] = "ADD_NPM", r[r.SCREEN_NPM = 19] = "SCREEN_NPM", r[r.NONE = 20] = "NONE", r[r.SRC_OVER = 0] = "SRC_OVER", r[r.SRC_IN = 21] = "SRC_IN", r[r.SRC_OUT = 22] = "SRC_OUT", r[r.SRC_ATOP = 23] = "SRC_ATOP", r[r.DST_OVER = 24] = "DST_OVER", r[r.DST_IN = 25] = "DST_IN", r[r.DST_OUT = 26] = "DST_OUT", r[r.DST_ATOP = 27] = "DST_ATOP", r[r.ERASE = 26] = "ERASE", r[r.SUBTRACT = 28] = "SUBTRACT", r[r.XOR = 29] = "XOR";
})(ot || (ot = {}));
var _r;
(function(r) {
  r[r.POINTS = 0] = "POINTS", r[r.LINES = 1] = "LINES", r[r.LINE_LOOP = 2] = "LINE_LOOP", r[r.LINE_STRIP = 3] = "LINE_STRIP", r[r.TRIANGLES = 4] = "TRIANGLES", r[r.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", r[r.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(_r || (_r = {}));
var W;
(function(r) {
  r[r.RGBA = 6408] = "RGBA", r[r.RGB = 6407] = "RGB", r[r.RG = 33319] = "RG", r[r.RED = 6403] = "RED", r[r.RGBA_INTEGER = 36249] = "RGBA_INTEGER", r[r.RGB_INTEGER = 36248] = "RGB_INTEGER", r[r.RG_INTEGER = 33320] = "RG_INTEGER", r[r.RED_INTEGER = 36244] = "RED_INTEGER", r[r.ALPHA = 6406] = "ALPHA", r[r.LUMINANCE = 6409] = "LUMINANCE", r[r.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", r[r.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", r[r.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(W || (W = {}));
var zo;
(function(r) {
  r[r.TEXTURE_2D = 3553] = "TEXTURE_2D", r[r.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", r[r.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", r[r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", r[r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", r[r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", r[r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(zo || (zo = {}));
var ct;
(function(r) {
  r[r.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", r[r.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", r[r.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", r[r.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", r[r.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", r[r.UNSIGNED_INT = 5125] = "UNSIGNED_INT", r[r.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", r[r.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", r[r.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", r[r.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", r[r.BYTE = 5120] = "BYTE", r[r.SHORT = 5122] = "SHORT", r[r.INT = 5124] = "INT", r[r.FLOAT = 5126] = "FLOAT", r[r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", r[r.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(ct || (ct = {}));
var Wf;
(function(r) {
  r[r.FLOAT = 0] = "FLOAT", r[r.INT = 1] = "INT", r[r.UINT = 2] = "UINT";
})(Wf || (Wf = {}));
var Vr;
(function(r) {
  r[r.NEAREST = 0] = "NEAREST", r[r.LINEAR = 1] = "LINEAR";
})(Vr || (Vr = {}));
var Wr;
(function(r) {
  r[r.CLAMP = 33071] = "CLAMP", r[r.REPEAT = 10497] = "REPEAT", r[r.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(Wr || (Wr = {}));
var br;
(function(r) {
  r[r.OFF = 0] = "OFF", r[r.POW2 = 1] = "POW2", r[r.ON = 2] = "ON", r[r.ON_MANUAL = 3] = "ON_MANUAL";
})(br || (br = {}));
var xr;
(function(r) {
  r[r.NPM = 0] = "NPM", r[r.UNPACK = 1] = "UNPACK", r[r.PMA = 2] = "PMA", r[r.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", r[r.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", r[r.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", r[r.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(xr || (xr = {}));
var vr;
(function(r) {
  r[r.NO = 0] = "NO", r[r.YES = 1] = "YES", r[r.AUTO = 2] = "AUTO", r[r.BLEND = 0] = "BLEND", r[r.CLEAR = 1] = "CLEAR", r[r.BLIT = 2] = "BLIT";
})(vr || (vr = {}));
var Yf;
(function(r) {
  r[r.AUTO = 0] = "AUTO", r[r.MANUAL = 1] = "MANUAL";
})(Yf || (Yf = {}));
var Ii;
(function(r) {
  r.LOW = "lowp", r.MEDIUM = "mediump", r.HIGH = "highp";
})(Ii || (Ii = {}));
var Ie;
(function(r) {
  r[r.NONE = 0] = "NONE", r[r.SCISSOR = 1] = "SCISSOR", r[r.STENCIL = 2] = "STENCIL", r[r.SPRITE = 3] = "SPRITE", r[r.COLOR = 4] = "COLOR";
})(Ie || (Ie = {}));
var q_;
(function(r) {
  r[r.RED = 1] = "RED", r[r.GREEN = 2] = "GREEN", r[r.BLUE = 4] = "BLUE", r[r.ALPHA = 8] = "ALPHA";
})(q_ || (q_ = {}));
var ue;
(function(r) {
  r[r.NONE = 0] = "NONE", r[r.LOW = 2] = "LOW", r[r.MEDIUM = 4] = "MEDIUM", r[r.HIGH = 8] = "HIGH";
})(ue || (ue = {}));
var Yr;
(function(r) {
  r[r.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", r[r.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", r[r.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(Yr || (Yr = {}));
/*!
 * @pixi/settings - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var DE = {
  /**
   * Creates a canvas element of the given size.
   * This canvas is created using the browser's native canvas element.
   * @param width - width of the canvas
   * @param height - height of the canvas
   */
  createCanvas: function(r, t) {
    var e = document.createElement("canvas");
    return e.width = r, e.height = t, e;
  },
  getWebGLRenderingContext: function() {
    return WebGLRenderingContext;
  },
  getNavigator: function() {
    return navigator;
  },
  getBaseUrl: function() {
    var r;
    return (r = document.baseURI) !== null && r !== void 0 ? r : window.location.href;
  },
  fetch: function(r, t) {
    return fetch(r, t);
  }
}, $v = /iPhone/i, Z_ = /iPod/i, K_ = /iPad/i, J_ = /\biOS-universal(?:.+)Mac\b/i, zv = /\bAndroid(?:.+)Mobile\b/i, Q_ = /Android/i, sa = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, Ac = /Silk/i, nn = /Windows Phone/i, tg = /\bWindows(?:.+)ARM\b/i, eg = /BlackBerry/i, ig = /BB10/i, rg = /Opera Mini/i, ng = /\b(CriOS|Chrome)(?:.+)Mobile/i, sg = /Mobile(?:.+)Firefox\b/i, og = function(r) {
  return typeof r < "u" && r.platform === "MacIntel" && typeof r.maxTouchPoints == "number" && r.maxTouchPoints > 1 && typeof MSStream > "u";
};
function FE(r) {
  return function(t) {
    return t.test(r);
  };
}
function BE(r) {
  var t = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  !r && typeof navigator < "u" ? t = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    maxTouchPoints: navigator.maxTouchPoints || 0
  } : typeof r == "string" ? t.userAgent = r : r && r.userAgent && (t = {
    userAgent: r.userAgent,
    platform: r.platform,
    maxTouchPoints: r.maxTouchPoints || 0
  });
  var e = t.userAgent, i = e.split("[FBAN");
  typeof i[1] < "u" && (e = i[0]), i = e.split("Twitter"), typeof i[1] < "u" && (e = i[0]);
  var n = FE(e), s = {
    apple: {
      phone: n($v) && !n(nn),
      ipod: n(Z_),
      tablet: !n($v) && (n(K_) || og(t)) && !n(nn),
      universal: n(J_),
      device: (n($v) || n(Z_) || n(K_) || n(J_) || og(t)) && !n(nn)
    },
    amazon: {
      phone: n(sa),
      tablet: !n(sa) && n(Ac),
      device: n(sa) || n(Ac)
    },
    android: {
      phone: !n(nn) && n(sa) || !n(nn) && n(zv),
      tablet: !n(nn) && !n(sa) && !n(zv) && (n(Ac) || n(Q_)),
      device: !n(nn) && (n(sa) || n(Ac) || n(zv) || n(Q_)) || n(/\bokhttp\b/i)
    },
    windows: {
      phone: n(nn),
      tablet: n(tg),
      device: n(nn) || n(tg)
    },
    other: {
      blackberry: n(eg),
      blackberry10: n(ig),
      opera: n(rg),
      firefox: n(sg),
      chrome: n(ng),
      device: n(eg) || n(ig) || n(rg) || n(sg) || n(ng)
    },
    any: !1,
    phone: !1,
    tablet: !1
  };
  return s.any = s.apple.device || s.android.device || s.windows.device || s.other.device, s.phone = s.apple.phone || s.android.phone || s.windows.phone, s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet, s;
}
var Xr = BE(globalThis.navigator);
function UE() {
  return !Xr.apple.device;
}
function GE(r) {
  var t = !0;
  if (Xr.tablet || Xr.phone) {
    if (Xr.apple.device) {
      var e = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (e) {
        var i = parseInt(e[1], 10);
        i < 11 && (t = !1);
      }
    }
    if (Xr.android.device) {
      var e = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (e) {
        var i = parseInt(e[1], 10);
        i < 7 && (t = !1);
      }
    }
  }
  return t ? r : 4;
}
var J = {
  /**
   * This adapter is used to call methods that are platform dependent.
   * For example `document.createElement` only runs on the web but fails in node environments.
   * This allows us to support more platforms by abstracting away specific implementations per platform.
   *
   * By default the adapter is set to work in the browser. However you can create your own
   * by implementing the `IAdapter` interface. See `IAdapter` for more information.
   * @name ADAPTER
   * @memberof PIXI.settings
   * @type {PIXI.IAdapter}
   * @default PIXI.BrowserAdapter
   */
  ADAPTER: DE,
  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  MIPMAP_TEXTURES: br.POW2,
  /**
   * Default anisotropic filtering level of textures.
   * Usually from 0 to 16
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @default 0
   */
  ANISOTROPIC_LEVEL: 0,
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Default filter resolution.
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,
  /**
   * Default filter samples.
   * @static
   * @name FILTER_MULTISAMPLE
   * @memberof PIXI.settings
   * @type {PIXI.MSAA_QUALITY}
   * @default PIXI.MSAA_QUALITY.NONE
   */
  FILTER_MULTISAMPLE: ue.NONE,
  /**
   * The maximum textures that this device supports.
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @type {number}
   * @default 32
   */
  SPRITE_MAX_TEXTURES: GE(32),
  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,
  /**
   * The default render options if none are supplied to {@link PIXI.Renderer}
   * or {@link PIXI.CanvasRenderer}.
   * @static
   * @name RENDER_OPTIONS
   * @memberof PIXI.settings
   * @type {object}
   * @property {HTMLCanvasElement} [view=null] -
   * @property {boolean} [antialias=false] -
   * @property {boolean} [autoDensity=false] -
   * @property {boolean} [useContextAlpha=true]  -
   * @property {number} [backgroundColor=0x000000] -
   * @property {number} [backgroundAlpha=1] -
   * @property {boolean} [clearBeforeRender=true] -
   * @property {boolean} [preserveDrawingBuffer=false] -
   * @property {number} [width=800] -
   * @property {number} [height=600] -
   * @property {boolean} [legacy=false] -
   */
  RENDER_OPTIONS: {
    view: null,
    antialias: !1,
    autoDensity: !1,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: !0,
    clearBeforeRender: !0,
    preserveDrawingBuffer: !1,
    width: 800,
    height: 600,
    legacy: !1
  },
  /**
   * Default Garbage Collection mode.
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: Yf.AUTO,
  /**
   * Default Garbage Collection max idle.
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,
  /**
   * Default Garbage Collection maximum check count.
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,
  /**
   * Default wrap modes that are supported by pixi.
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: Wr.CLAMP,
  /**
   * Default scale mode for textures.
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: Vr.LINEAR,
  /**
   * Default specify float precision in vertex shader.
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.HIGH
   */
  PRECISION_VERTEX: Ii.HIGH,
  /**
   * Default specify float precision in fragment shader.
   * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION_FRAGMENT: Xr.apple.device ? Ii.HIGH : Ii.MEDIUM,
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: UE(),
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: !1,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: !1
}, N0 = { exports: {} };
(function(r) {
  var t = Object.prototype.hasOwnProperty, e = "~";
  function i() {
  }
  Object.create && (i.prototype = /* @__PURE__ */ Object.create(null), new i().__proto__ || (e = !1));
  function n(l, u, c) {
    this.fn = l, this.context = u, this.once = c || !1;
  }
  function s(l, u, c, d, f) {
    if (typeof c != "function")
      throw new TypeError("The listener must be a function");
    var v = new n(c, d || l, f), m = e ? e + u : u;
    return l._events[m] ? l._events[m].fn ? l._events[m] = [l._events[m], v] : l._events[m].push(v) : (l._events[m] = v, l._eventsCount++), l;
  }
  function o(l, u) {
    --l._eventsCount === 0 ? l._events = new i() : delete l._events[u];
  }
  function a() {
    this._events = new i(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var u = [], c, d;
    if (this._eventsCount === 0)
      return u;
    for (d in c = this._events)
      t.call(c, d) && u.push(e ? d.slice(1) : d);
    return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(c)) : u;
  }, a.prototype.listeners = function(u) {
    var c = e ? e + u : u, d = this._events[c];
    if (!d)
      return [];
    if (d.fn)
      return [d.fn];
    for (var f = 0, v = d.length, m = new Array(v); f < v; f++)
      m[f] = d[f].fn;
    return m;
  }, a.prototype.listenerCount = function(u) {
    var c = e ? e + u : u, d = this._events[c];
    return d ? d.fn ? 1 : d.length : 0;
  }, a.prototype.emit = function(u, c, d, f, v, m) {
    var p = e ? e + u : u;
    if (!this._events[p])
      return !1;
    var y = this._events[p], b = arguments.length, w, E;
    if (y.fn) {
      switch (y.once && this.removeListener(u, y.fn, void 0, !0), b) {
        case 1:
          return y.fn.call(y.context), !0;
        case 2:
          return y.fn.call(y.context, c), !0;
        case 3:
          return y.fn.call(y.context, c, d), !0;
        case 4:
          return y.fn.call(y.context, c, d, f), !0;
        case 5:
          return y.fn.call(y.context, c, d, f, v), !0;
        case 6:
          return y.fn.call(y.context, c, d, f, v, m), !0;
      }
      for (E = 1, w = new Array(b - 1); E < b; E++)
        w[E - 1] = arguments[E];
      y.fn.apply(y.context, w);
    } else {
      var O = y.length, I;
      for (E = 0; E < O; E++)
        switch (y[E].once && this.removeListener(u, y[E].fn, void 0, !0), b) {
          case 1:
            y[E].fn.call(y[E].context);
            break;
          case 2:
            y[E].fn.call(y[E].context, c);
            break;
          case 3:
            y[E].fn.call(y[E].context, c, d);
            break;
          case 4:
            y[E].fn.call(y[E].context, c, d, f);
            break;
          default:
            if (!w)
              for (I = 1, w = new Array(b - 1); I < b; I++)
                w[I - 1] = arguments[I];
            y[E].fn.apply(y[E].context, w);
        }
    }
    return !0;
  }, a.prototype.on = function(u, c, d) {
    return s(this, u, c, d, !1);
  }, a.prototype.once = function(u, c, d) {
    return s(this, u, c, d, !0);
  }, a.prototype.removeListener = function(u, c, d, f) {
    var v = e ? e + u : u;
    if (!this._events[v])
      return this;
    if (!c)
      return o(this, v), this;
    var m = this._events[v];
    if (m.fn)
      m.fn === c && (!f || m.once) && (!d || m.context === d) && o(this, v);
    else {
      for (var p = 0, y = [], b = m.length; p < b; p++)
        (m[p].fn !== c || f && !m[p].once || d && m[p].context !== d) && y.push(m[p]);
      y.length ? this._events[v] = y.length === 1 ? y[0] : y : o(this, v);
    }
    return this;
  }, a.prototype.removeAllListeners = function(u) {
    var c;
    return u ? (c = e ? e + u : u, this._events[c] && o(this, c)) : (this._events = new i(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = e, a.EventEmitter = a, r.exports = a;
})(N0);
var jE = N0.exports;
const Zi = /* @__PURE__ */ Ov(jE);
var qm = { exports: {} };
qm.exports = Iv;
qm.exports.default = Iv;
function Iv(r, t, e) {
  e = e || 2;
  var i = t && t.length, n = i ? t[0] * e : r.length, s = A0(r, 0, n, e, !0), o = [];
  if (!s || s.next === s.prev)
    return o;
  var a, l, u, c, d, f, v;
  if (i && (s = XE(r, t, s, e)), r.length > 80 * e) {
    a = u = r[0], l = c = r[1];
    for (var m = e; m < n; m += e)
      d = r[m], f = r[m + 1], d < a && (a = d), f < l && (l = f), d > u && (u = d), f > c && (c = f);
    v = Math.max(u - a, c - l), v = v !== 0 ? 32767 / v : 0;
  }
  return Tl(s, o, e, a, l, v, 0), o;
}
function A0(r, t, e, i, n) {
  var s, o;
  if (n === xy(r, t, e, i) > 0)
    for (s = t; s < e; s += i)
      o = ag(s, r[s], r[s + 1], o);
  else
    for (s = e - i; s >= t; s -= i)
      o = ag(s, r[s], r[s + 1], o);
  return o && Cv(o, o.next) && (Pl(o), o = o.next), o;
}
function Wo(r, t) {
  if (!r)
    return r;
  t || (t = r);
  var e = r, i;
  do
    if (i = !1, !e.steiner && (Cv(e, e.next) || ve(e.prev, e, e.next) === 0)) {
      if (Pl(e), e = t = e.prev, e === e.next)
        break;
      i = !0;
    } else
      e = e.next;
  while (i || e !== t);
  return t;
}
function Tl(r, t, e, i, n, s, o) {
  if (r) {
    !o && s && KE(r, i, n, s);
    for (var a = r, l, u; r.prev !== r.next; ) {
      if (l = r.prev, u = r.next, s ? $E(r, i, n, s) : HE(r)) {
        t.push(l.i / e | 0), t.push(r.i / e | 0), t.push(u.i / e | 0), Pl(r), r = u.next, a = u.next;
        continue;
      }
      if (r = u, r === a) {
        o ? o === 1 ? (r = zE(Wo(r), t, e), Tl(r, t, e, i, n, s, 2)) : o === 2 && VE(r, t, e, i, n, s) : Tl(Wo(r), t, e, i, n, s, 1);
        break;
      }
    }
  }
}
function HE(r) {
  var t = r.prev, e = r, i = r.next;
  if (ve(t, e, i) >= 0)
    return !1;
  for (var n = t.x, s = e.x, o = i.x, a = t.y, l = e.y, u = i.y, c = n < s ? n < o ? n : o : s < o ? s : o, d = a < l ? a < u ? a : u : l < u ? l : u, f = n > s ? n > o ? n : o : s > o ? s : o, v = a > l ? a > u ? a : u : l > u ? l : u, m = i.next; m !== t; ) {
    if (m.x >= c && m.x <= f && m.y >= d && m.y <= v && da(n, a, s, l, o, u, m.x, m.y) && ve(m.prev, m, m.next) >= 0)
      return !1;
    m = m.next;
  }
  return !0;
}
function $E(r, t, e, i) {
  var n = r.prev, s = r, o = r.next;
  if (ve(n, s, o) >= 0)
    return !1;
  for (var a = n.x, l = s.x, u = o.x, c = n.y, d = s.y, f = o.y, v = a < l ? a < u ? a : u : l < u ? l : u, m = c < d ? c < f ? c : f : d < f ? d : f, p = a > l ? a > u ? a : u : l > u ? l : u, y = c > d ? c > f ? c : f : d > f ? d : f, b = gy(v, m, t, e, i), w = gy(p, y, t, e, i), E = r.prevZ, O = r.nextZ; E && E.z >= b && O && O.z <= w; ) {
    if (E.x >= v && E.x <= p && E.y >= m && E.y <= y && E !== n && E !== o && da(a, c, l, d, u, f, E.x, E.y) && ve(E.prev, E, E.next) >= 0 || (E = E.prevZ, O.x >= v && O.x <= p && O.y >= m && O.y <= y && O !== n && O !== o && da(a, c, l, d, u, f, O.x, O.y) && ve(O.prev, O, O.next) >= 0))
      return !1;
    O = O.nextZ;
  }
  for (; E && E.z >= b; ) {
    if (E.x >= v && E.x <= p && E.y >= m && E.y <= y && E !== n && E !== o && da(a, c, l, d, u, f, E.x, E.y) && ve(E.prev, E, E.next) >= 0)
      return !1;
    E = E.prevZ;
  }
  for (; O && O.z <= w; ) {
    if (O.x >= v && O.x <= p && O.y >= m && O.y <= y && O !== n && O !== o && da(a, c, l, d, u, f, O.x, O.y) && ve(O.prev, O, O.next) >= 0)
      return !1;
    O = O.nextZ;
  }
  return !0;
}
function zE(r, t, e) {
  var i = r;
  do {
    var n = i.prev, s = i.next.next;
    !Cv(n, s) && L0(n, i, i.next, s) && Sl(n, s) && Sl(s, n) && (t.push(n.i / e | 0), t.push(i.i / e | 0), t.push(s.i / e | 0), Pl(i), Pl(i.next), i = r = s), i = i.next;
  } while (i !== r);
  return Wo(i);
}
function VE(r, t, e, i, n, s) {
  var o = r;
  do {
    for (var a = o.next.next; a !== o.prev; ) {
      if (o.i !== a.i && tT(o, a)) {
        var l = D0(o, a);
        o = Wo(o, o.next), l = Wo(l, l.next), Tl(o, t, e, i, n, s, 0), Tl(l, t, e, i, n, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== r);
}
function XE(r, t, e, i) {
  var n = [], s, o, a, l, u;
  for (s = 0, o = t.length; s < o; s++)
    a = t[s] * i, l = s < o - 1 ? t[s + 1] * i : r.length, u = A0(r, a, l, i, !1), u === u.next && (u.steiner = !0), n.push(QE(u));
  for (n.sort(WE), s = 0; s < n.length; s++)
    e = YE(n[s], e);
  return e;
}
function WE(r, t) {
  return r.x - t.x;
}
function YE(r, t) {
  var e = qE(r, t);
  if (!e)
    return t;
  var i = D0(e, r);
  return Wo(i, i.next), Wo(e, e.next);
}
function qE(r, t) {
  var e = t, i = r.x, n = r.y, s = -1 / 0, o;
  do {
    if (n <= e.y && n >= e.next.y && e.next.y !== e.y) {
      var a = e.x + (n - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (a <= i && a > s && (s = a, o = e.x < e.next.x ? e : e.next, a === i))
        return o;
    }
    e = e.next;
  } while (e !== t);
  if (!o)
    return null;
  var l = o, u = o.x, c = o.y, d = 1 / 0, f;
  e = o;
  do
    i >= e.x && e.x >= u && i !== e.x && da(n < c ? i : s, n, u, c, n < c ? s : i, n, e.x, e.y) && (f = Math.abs(n - e.y) / (i - e.x), Sl(e, r) && (f < d || f === d && (e.x > o.x || e.x === o.x && ZE(o, e))) && (o = e, d = f)), e = e.next;
  while (e !== l);
  return o;
}
function ZE(r, t) {
  return ve(r.prev, r, t.prev) < 0 && ve(t.next, r, r.next) < 0;
}
function KE(r, t, e, i) {
  var n = r;
  do
    n.z === 0 && (n.z = gy(n.x, n.y, t, e, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== r);
  n.prevZ.nextZ = null, n.prevZ = null, JE(n);
}
function JE(r) {
  var t, e, i, n, s, o, a, l, u = 1;
  do {
    for (e = r, r = null, s = null, o = 0; e; ) {
      for (o++, i = e, a = 0, t = 0; t < u && (a++, i = i.nextZ, !!i); t++)
        ;
      for (l = u; a > 0 || l > 0 && i; )
        a !== 0 && (l === 0 || !i || e.z <= i.z) ? (n = e, e = e.nextZ, a--) : (n = i, i = i.nextZ, l--), s ? s.nextZ = n : r = n, n.prevZ = s, s = n;
      e = i;
    }
    s.nextZ = null, u *= 2;
  } while (o > 1);
  return r;
}
function gy(r, t, e, i, n) {
  return r = (r - e) * n | 0, t = (t - i) * n | 0, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, r | t << 1;
}
function QE(r) {
  var t = r, e = r;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== r);
  return e;
}
function da(r, t, e, i, n, s, o, a) {
  return (n - o) * (t - a) >= (r - o) * (s - a) && (r - o) * (i - a) >= (e - o) * (t - a) && (e - o) * (s - a) >= (n - o) * (i - a);
}
function tT(r, t) {
  return r.next.i !== t.i && r.prev.i !== t.i && !eT(r, t) && // dones't intersect other edges
  (Sl(r, t) && Sl(t, r) && iT(r, t) && // locally visible
  (ve(r.prev, r, t.prev) || ve(r, t.prev, t)) || // does not create opposite-facing sectors
  Cv(r, t) && ve(r.prev, r, r.next) > 0 && ve(t.prev, t, t.next) > 0);
}
function ve(r, t, e) {
  return (t.y - r.y) * (e.x - t.x) - (t.x - r.x) * (e.y - t.y);
}
function Cv(r, t) {
  return r.x === t.x && r.y === t.y;
}
function L0(r, t, e, i) {
  var n = Dc(ve(r, t, e)), s = Dc(ve(r, t, i)), o = Dc(ve(e, i, r)), a = Dc(ve(e, i, t));
  return !!(n !== s && o !== a || n === 0 && Lc(r, e, t) || s === 0 && Lc(r, i, t) || o === 0 && Lc(e, r, i) || a === 0 && Lc(e, t, i));
}
function Lc(r, t, e) {
  return t.x <= Math.max(r.x, e.x) && t.x >= Math.min(r.x, e.x) && t.y <= Math.max(r.y, e.y) && t.y >= Math.min(r.y, e.y);
}
function Dc(r) {
  return r > 0 ? 1 : r < 0 ? -1 : 0;
}
function eT(r, t) {
  var e = r;
  do {
    if (e.i !== r.i && e.next.i !== r.i && e.i !== t.i && e.next.i !== t.i && L0(e, e.next, r, t))
      return !0;
    e = e.next;
  } while (e !== r);
  return !1;
}
function Sl(r, t) {
  return ve(r.prev, r, r.next) < 0 ? ve(r, t, r.next) >= 0 && ve(r, r.prev, t) >= 0 : ve(r, t, r.prev) < 0 || ve(r, r.next, t) < 0;
}
function iT(r, t) {
  var e = r, i = !1, n = (r.x + t.x) / 2, s = (r.y + t.y) / 2;
  do
    e.y > s != e.next.y > s && e.next.y !== e.y && n < (e.next.x - e.x) * (s - e.y) / (e.next.y - e.y) + e.x && (i = !i), e = e.next;
  while (e !== r);
  return i;
}
function D0(r, t) {
  var e = new by(r.i, r.x, r.y), i = new by(t.i, t.x, t.y), n = r.next, s = t.prev;
  return r.next = t, t.prev = r, e.next = n, n.prev = e, i.next = e, e.prev = i, s.next = i, i.prev = s, i;
}
function ag(r, t, e, i) {
  var n = new by(r, t, e);
  return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n;
}
function Pl(r) {
  r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
}
function by(r, t, e) {
  this.i = r, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
Iv.deviation = function(r, t, e, i) {
  var n = t && t.length, s = n ? t[0] * e : r.length, o = Math.abs(xy(r, 0, s, e));
  if (n)
    for (var a = 0, l = t.length; a < l; a++) {
      var u = t[a] * e, c = a < l - 1 ? t[a + 1] * e : r.length;
      o -= Math.abs(xy(r, u, c, e));
    }
  var d = 0;
  for (a = 0; a < i.length; a += 3) {
    var f = i[a] * e, v = i[a + 1] * e, m = i[a + 2] * e;
    d += Math.abs(
      (r[f] - r[m]) * (r[v + 1] - r[f + 1]) - (r[f] - r[v]) * (r[m + 1] - r[f + 1])
    );
  }
  return o === 0 && d === 0 ? 0 : Math.abs((d - o) / o);
};
function xy(r, t, e, i) {
  for (var n = 0, s = t, o = e - i; s < e; s += i)
    n += (r[o] - r[s]) * (r[s + 1] + r[o + 1]), o = s;
  return n;
}
Iv.flatten = function(r) {
  for (var t = r[0][0].length, e = { vertices: [], holes: [], dimensions: t }, i = 0, n = 0; n < r.length; n++) {
    for (var s = 0; s < r[n].length; s++)
      for (var o = 0; o < t; o++)
        e.vertices.push(r[n][s][o]);
    n > 0 && (i += r[n - 1].length, e.holes.push(i));
  }
  return e;
};
var rT = qm.exports;
const F0 = /* @__PURE__ */ Ov(rT);
/*!
 * @pixi/utils - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var pa = {
  parse: pE,
  format: vE,
  resolve: yE
};
J.RETINA_PREFIX = /@([0-9\.]+)x/;
J.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var wy = !1, hg = "6.5.9";
function nT() {
  wy = !0;
}
function sT(r) {
  var t;
  if (!wy) {
    if (J.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      var e = [
        `
 %c %c %c PixiJS ` + hg + " - ✰ " + r + ` ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ 

`,
        "background: #ff66a5; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff66a5; background: #030307; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "background: #ffc3dc; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;"
      ];
      (t = globalThis.console).log.apply(t, e);
    } else
      globalThis.console && globalThis.console.log("PixiJS " + hg + " - " + r + " - http://www.pixijs.com/");
    wy = !0;
  }
}
var Vv;
function oT() {
  return typeof Vv > "u" && (Vv = function() {
    var t = {
      stencil: !0,
      failIfMajorPerformanceCaveat: J.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
    };
    try {
      if (!J.ADAPTER.getWebGLRenderingContext())
        return !1;
      var e = J.ADAPTER.createCanvas(), i = e.getContext("webgl", t) || e.getContext("experimental-webgl", t), n = !!(i && i.getContextAttributes().stencil);
      if (i) {
        var s = i.getExtension("WEBGL_lose_context");
        s && s.loseContext();
      }
      return i = null, n;
    } catch {
      return !1;
    }
  }()), Vv;
}
var aT = "#f0f8ff", hT = "#faebd7", lT = "#00ffff", uT = "#7fffd4", cT = "#f0ffff", fT = "#f5f5dc", dT = "#ffe4c4", pT = "#000000", vT = "#ffebcd", yT = "#0000ff", mT = "#8a2be2", _T = "#a52a2a", gT = "#deb887", bT = "#5f9ea0", xT = "#7fff00", wT = "#d2691e", ET = "#ff7f50", TT = "#6495ed", ST = "#fff8dc", PT = "#dc143c", OT = "#00ffff", IT = "#00008b", CT = "#008b8b", MT = "#b8860b", RT = "#a9a9a9", kT = "#006400", NT = "#a9a9a9", AT = "#bdb76b", LT = "#8b008b", DT = "#556b2f", FT = "#ff8c00", BT = "#9932cc", UT = "#8b0000", GT = "#e9967a", jT = "#8fbc8f", HT = "#483d8b", $T = "#2f4f4f", zT = "#2f4f4f", VT = "#00ced1", XT = "#9400d3", WT = "#ff1493", YT = "#00bfff", qT = "#696969", ZT = "#696969", KT = "#1e90ff", JT = "#b22222", QT = "#fffaf0", t1 = "#228b22", e1 = "#ff00ff", i1 = "#dcdcdc", r1 = "#f8f8ff", n1 = "#daa520", s1 = "#ffd700", o1 = "#808080", a1 = "#008000", h1 = "#adff2f", l1 = "#808080", u1 = "#f0fff0", c1 = "#ff69b4", f1 = "#cd5c5c", d1 = "#4b0082", p1 = "#fffff0", v1 = "#f0e68c", y1 = "#fff0f5", m1 = "#e6e6fa", _1 = "#7cfc00", g1 = "#fffacd", b1 = "#add8e6", x1 = "#f08080", w1 = "#e0ffff", E1 = "#fafad2", T1 = "#d3d3d3", S1 = "#90ee90", P1 = "#d3d3d3", O1 = "#ffb6c1", I1 = "#ffa07a", C1 = "#20b2aa", M1 = "#87cefa", R1 = "#778899", k1 = "#778899", N1 = "#b0c4de", A1 = "#ffffe0", L1 = "#00ff00", D1 = "#32cd32", F1 = "#faf0e6", B1 = "#ff00ff", U1 = "#800000", G1 = "#66cdaa", j1 = "#0000cd", H1 = "#ba55d3", $1 = "#9370db", z1 = "#3cb371", V1 = "#7b68ee", X1 = "#00fa9a", W1 = "#48d1cc", Y1 = "#c71585", q1 = "#191970", Z1 = "#f5fffa", K1 = "#ffe4e1", J1 = "#ffe4b5", Q1 = "#ffdead", tS = "#000080", eS = "#fdf5e6", iS = "#808000", rS = "#6b8e23", nS = "#ffa500", sS = "#ff4500", oS = "#da70d6", aS = "#eee8aa", hS = "#98fb98", lS = "#afeeee", uS = "#db7093", cS = "#ffefd5", fS = "#ffdab9", dS = "#cd853f", pS = "#ffc0cb", vS = "#dda0dd", yS = "#b0e0e6", mS = "#800080", _S = "#663399", gS = "#ff0000", bS = "#bc8f8f", xS = "#4169e1", wS = "#8b4513", ES = "#fa8072", TS = "#f4a460", SS = "#2e8b57", PS = "#fff5ee", OS = "#a0522d", IS = "#c0c0c0", CS = "#87ceeb", MS = "#6a5acd", RS = "#708090", kS = "#708090", NS = "#fffafa", AS = "#00ff7f", LS = "#4682b4", DS = "#d2b48c", FS = "#008080", BS = "#d8bfd8", US = "#ff6347", GS = "#40e0d0", jS = "#ee82ee", HS = "#f5deb3", $S = "#ffffff", zS = "#f5f5f5", VS = "#ffff00", XS = "#9acd32", WS = {
  aliceblue: aT,
  antiquewhite: hT,
  aqua: lT,
  aquamarine: uT,
  azure: cT,
  beige: fT,
  bisque: dT,
  black: pT,
  blanchedalmond: vT,
  blue: yT,
  blueviolet: mT,
  brown: _T,
  burlywood: gT,
  cadetblue: bT,
  chartreuse: xT,
  chocolate: wT,
  coral: ET,
  cornflowerblue: TT,
  cornsilk: ST,
  crimson: PT,
  cyan: OT,
  darkblue: IT,
  darkcyan: CT,
  darkgoldenrod: MT,
  darkgray: RT,
  darkgreen: kT,
  darkgrey: NT,
  darkkhaki: AT,
  darkmagenta: LT,
  darkolivegreen: DT,
  darkorange: FT,
  darkorchid: BT,
  darkred: UT,
  darksalmon: GT,
  darkseagreen: jT,
  darkslateblue: HT,
  darkslategray: $T,
  darkslategrey: zT,
  darkturquoise: VT,
  darkviolet: XT,
  deeppink: WT,
  deepskyblue: YT,
  dimgray: qT,
  dimgrey: ZT,
  dodgerblue: KT,
  firebrick: JT,
  floralwhite: QT,
  forestgreen: t1,
  fuchsia: e1,
  gainsboro: i1,
  ghostwhite: r1,
  goldenrod: n1,
  gold: s1,
  gray: o1,
  green: a1,
  greenyellow: h1,
  grey: l1,
  honeydew: u1,
  hotpink: c1,
  indianred: f1,
  indigo: d1,
  ivory: p1,
  khaki: v1,
  lavenderblush: y1,
  lavender: m1,
  lawngreen: _1,
  lemonchiffon: g1,
  lightblue: b1,
  lightcoral: x1,
  lightcyan: w1,
  lightgoldenrodyellow: E1,
  lightgray: T1,
  lightgreen: S1,
  lightgrey: P1,
  lightpink: O1,
  lightsalmon: I1,
  lightseagreen: C1,
  lightskyblue: M1,
  lightslategray: R1,
  lightslategrey: k1,
  lightsteelblue: N1,
  lightyellow: A1,
  lime: L1,
  limegreen: D1,
  linen: F1,
  magenta: B1,
  maroon: U1,
  mediumaquamarine: G1,
  mediumblue: j1,
  mediumorchid: H1,
  mediumpurple: $1,
  mediumseagreen: z1,
  mediumslateblue: V1,
  mediumspringgreen: X1,
  mediumturquoise: W1,
  mediumvioletred: Y1,
  midnightblue: q1,
  mintcream: Z1,
  mistyrose: K1,
  moccasin: J1,
  navajowhite: Q1,
  navy: tS,
  oldlace: eS,
  olive: iS,
  olivedrab: rS,
  orange: nS,
  orangered: sS,
  orchid: oS,
  palegoldenrod: aS,
  palegreen: hS,
  paleturquoise: lS,
  palevioletred: uS,
  papayawhip: cS,
  peachpuff: fS,
  peru: dS,
  pink: pS,
  plum: vS,
  powderblue: yS,
  purple: mS,
  rebeccapurple: _S,
  red: gS,
  rosybrown: bS,
  royalblue: xS,
  saddlebrown: wS,
  salmon: ES,
  sandybrown: TS,
  seagreen: SS,
  seashell: PS,
  sienna: OS,
  silver: IS,
  skyblue: CS,
  slateblue: MS,
  slategray: RS,
  slategrey: kS,
  snow: NS,
  springgreen: AS,
  steelblue: LS,
  tan: DS,
  teal: FS,
  thistle: BS,
  tomato: US,
  turquoise: GS,
  violet: jS,
  wheat: HS,
  white: $S,
  whitesmoke: zS,
  yellow: VS,
  yellowgreen: XS
};
function Lh(r, t) {
  return t === void 0 && (t = []), t[0] = (r >> 16 & 255) / 255, t[1] = (r >> 8 & 255) / 255, t[2] = (r & 255) / 255, t;
}
function B0(r) {
  var t = r.toString(16);
  return t = "000000".substring(0, 6 - t.length) + t, "#" + t;
}
function U0(r) {
  return typeof r == "string" && (r = WS[r.toLowerCase()] || r, r[0] === "#" && (r = r.slice(1))), parseInt(r, 16);
}
function YS() {
  for (var r = [], t = [], e = 0; e < 32; e++)
    r[e] = e, t[e] = e;
  r[ot.NORMAL_NPM] = ot.NORMAL, r[ot.ADD_NPM] = ot.ADD, r[ot.SCREEN_NPM] = ot.SCREEN, t[ot.NORMAL] = ot.NORMAL_NPM, t[ot.ADD] = ot.ADD_NPM, t[ot.SCREEN] = ot.SCREEN_NPM;
  var i = [];
  return i.push(t), i.push(r), i;
}
var G0 = YS();
function j0(r, t) {
  return G0[t ? 1 : 0][r];
}
function qS(r, t, e, i) {
  return e = e || new Float32Array(4), i || i === void 0 ? (e[0] = r[0] * t, e[1] = r[1] * t, e[2] = r[2] * t) : (e[0] = r[0], e[1] = r[1], e[2] = r[2]), e[3] = t, e;
}
function Zm(r, t) {
  if (t === 1)
    return (t * 255 << 24) + r;
  if (t === 0)
    return 0;
  var e = r >> 16 & 255, i = r >> 8 & 255, n = r & 255;
  return e = e * t + 0.5 | 0, i = i * t + 0.5 | 0, n = n * t + 0.5 | 0, (t * 255 << 24) + (e << 16) + (i << 8) + n;
}
function H0(r, t, e, i) {
  return e = e || new Float32Array(4), e[0] = (r >> 16 & 255) / 255, e[1] = (r >> 8 & 255) / 255, e[2] = (r & 255) / 255, (i || i === void 0) && (e[0] *= t, e[1] *= t, e[2] *= t), e[3] = t, e;
}
function ZS(r, t) {
  t === void 0 && (t = null);
  var e = r * 6;
  if (t = t || new Uint16Array(e), t.length !== e)
    throw new Error("Out buffer length is incorrect, got " + t.length + " and expected " + e);
  for (var i = 0, n = 0; i < e; i += 6, n += 4)
    t[i + 0] = n + 0, t[i + 1] = n + 1, t[i + 2] = n + 2, t[i + 3] = n + 0, t[i + 4] = n + 2, t[i + 5] = n + 3;
  return t;
}
function $0(r) {
  if (r.BYTES_PER_ELEMENT === 4)
    return r instanceof Float32Array ? "Float32Array" : r instanceof Uint32Array ? "Uint32Array" : "Int32Array";
  if (r.BYTES_PER_ELEMENT === 2) {
    if (r instanceof Uint16Array)
      return "Uint16Array";
  } else if (r.BYTES_PER_ELEMENT === 1 && r instanceof Uint8Array)
    return "Uint8Array";
  return null;
}
function qf(r) {
  return r += r === 0 ? 1 : 0, --r, r |= r >>> 1, r |= r >>> 2, r |= r >>> 4, r |= r >>> 8, r |= r >>> 16, r + 1;
}
function lg(r) {
  return !(r & r - 1) && !!r;
}
function ug(r) {
  var t = (r > 65535 ? 1 : 0) << 4;
  r >>>= t;
  var e = (r > 255 ? 1 : 0) << 3;
  return r >>>= e, t |= e, e = (r > 15 ? 1 : 0) << 2, r >>>= e, t |= e, e = (r > 3 ? 1 : 0) << 1, r >>>= e, t |= e, t | r >> 1;
}
function xa(r, t, e) {
  var i = r.length, n;
  if (!(t >= i || e === 0)) {
    e = t + e > i ? i - t : e;
    var s = i - e;
    for (n = t; n < s; ++n)
      r[n] = r[n + e];
    r.length = s;
  }
}
function va(r) {
  return r === 0 ? 0 : r < 0 ? -1 : 1;
}
var KS = 0;
function Yo() {
  return ++KS;
}
var cg = {};
function ci(r, t, e) {
  if (e === void 0 && (e = 3), !cg[t]) {
    var i = new Error().stack;
    typeof i > "u" ? console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + r) : (i = i.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", t + `
Deprecated since v` + r), console.warn(i), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + r), console.warn(i))), cg[t] = !0;
  }
}
var fg = {}, li = /* @__PURE__ */ Object.create(null), an = /* @__PURE__ */ Object.create(null);
function z0() {
  var r;
  for (r in li)
    delete li[r];
  for (r in an)
    delete an[r];
}
var dg = (
  /** @class */
  function() {
    function r(t, e, i) {
      this.canvas = J.ADAPTER.createCanvas(), this.context = this.canvas.getContext("2d"), this.resolution = i || J.RESOLUTION, this.resize(t, e);
    }
    return r.prototype.clear = function() {
      this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }, r.prototype.resize = function(t, e) {
      this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);
    }, r.prototype.destroy = function() {
      this.context = null, this.canvas = null;
    }, Object.defineProperty(r.prototype, "width", {
      /**
       * The width of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.width;
      },
      set: function(t) {
        this.canvas.width = Math.round(t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "height", {
      /**
       * The height of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.height;
      },
      set: function(t) {
        this.canvas.height = Math.round(t);
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
);
function JS(r) {
  var t = r.width, e = r.height, i = r.getContext("2d", {
    willReadFrequently: !0
  }), n = i.getImageData(0, 0, t, e), s = n.data, o = s.length, a = {
    top: null,
    left: null,
    right: null,
    bottom: null
  }, l = null, u, c, d;
  for (u = 0; u < o; u += 4)
    s[u + 3] !== 0 && (c = u / 4 % t, d = ~~(u / 4 / t), a.top === null && (a.top = d), (a.left === null || c < a.left) && (a.left = c), (a.right === null || a.right < c) && (a.right = c + 1), (a.bottom === null || a.bottom < d) && (a.bottom = d));
  return a.top !== null && (t = a.right - a.left, e = a.bottom - a.top + 1, l = i.getImageData(a.left, a.top, t, e)), {
    height: e,
    width: t,
    data: l
  };
}
var Fc;
function QS(r, t) {
  if (t === void 0 && (t = globalThis.location), r.indexOf("data:") === 0)
    return "";
  t = t || globalThis.location, Fc || (Fc = document.createElement("a")), Fc.href = r;
  var e = pa.parse(Fc.href), i = !e.port && t.port === "" || e.port === t.port;
  return e.hostname !== t.hostname || !i || e.protocol !== t.protocol ? "anonymous" : "";
}
function Zf(r, t) {
  var e = J.RETINA_PREFIX.exec(r);
  return e ? parseFloat(e[1]) : t !== void 0 ? t : 1;
}
/*!
 * @pixi/math - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Kf = Math.PI * 2, tP = 180 / Math.PI, eP = Math.PI / 180, Be;
(function(r) {
  r[r.POLY = 0] = "POLY", r[r.RECT = 1] = "RECT", r[r.CIRC = 2] = "CIRC", r[r.ELIP = 3] = "ELIP", r[r.RREC = 4] = "RREC";
})(Be || (Be = {}));
var te = (
  /** @class */
  function() {
    function r(t, e) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e;
    }
    return r.prototype.clone = function() {
      return new r(this.x, this.y);
    }, r.prototype.copyFrom = function(t) {
      return this.set(t.x, t.y), this;
    }, r.prototype.copyTo = function(t) {
      return t.set(this.x, this.y), t;
    }, r.prototype.equals = function(t) {
      return t.x === this.x && t.y === this.y;
    }, r.prototype.set = function(t, e) {
      return t === void 0 && (t = 0), e === void 0 && (e = t), this.x = t, this.y = e, this;
    }, r.prototype.toString = function() {
      return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
    }, r;
  }()
), Bc = [new te(), new te(), new te(), new te()], pt = (
  /** @class */
  function() {
    function r(t, e, i, n) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), i === void 0 && (i = 0), n === void 0 && (n = 0), this.x = Number(t), this.y = Number(e), this.width = Number(i), this.height = Number(n), this.type = Be.RECT;
    }
    return Object.defineProperty(r.prototype, "left", {
      /** Returns the left edge of the rectangle. */
      get: function() {
        return this.x;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "right", {
      /** Returns the right edge of the rectangle. */
      get: function() {
        return this.x + this.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "top", {
      /** Returns the top edge of the rectangle. */
      get: function() {
        return this.y;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "bottom", {
      /** Returns the bottom edge of the rectangle. */
      get: function() {
        return this.y + this.height;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "EMPTY", {
      /** A constant empty rectangle. */
      get: function() {
        return new r(0, 0, 0, 0);
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.clone = function() {
      return new r(this.x, this.y, this.width, this.height);
    }, r.prototype.copyFrom = function(t) {
      return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
    }, r.prototype.copyTo = function(t) {
      return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
    }, r.prototype.contains = function(t, e) {
      return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
    }, r.prototype.intersects = function(t, e) {
      if (!e) {
        var i = this.x < t.x ? t.x : this.x, n = this.right > t.right ? t.right : this.right;
        if (n <= i)
          return !1;
        var s = this.y < t.y ? t.y : this.y, o = this.bottom > t.bottom ? t.bottom : this.bottom;
        return o > s;
      }
      var a = this.left, l = this.right, u = this.top, c = this.bottom;
      if (l <= a || c <= u)
        return !1;
      var d = Bc[0].set(t.left, t.top), f = Bc[1].set(t.left, t.bottom), v = Bc[2].set(t.right, t.top), m = Bc[3].set(t.right, t.bottom);
      if (v.x <= d.x || f.y <= d.y)
        return !1;
      var p = Math.sign(e.a * e.d - e.b * e.c);
      if (p === 0 || (e.apply(d, d), e.apply(f, f), e.apply(v, v), e.apply(m, m), Math.max(d.x, f.x, v.x, m.x) <= a || Math.min(d.x, f.x, v.x, m.x) >= l || Math.max(d.y, f.y, v.y, m.y) <= u || Math.min(d.y, f.y, v.y, m.y) >= c))
        return !1;
      var y = p * (f.y - d.y), b = p * (d.x - f.x), w = y * a + b * u, E = y * l + b * u, O = y * a + b * c, I = y * l + b * c;
      if (Math.max(w, E, O, I) <= y * d.x + b * d.y || Math.min(w, E, O, I) >= y * m.x + b * m.y)
        return !1;
      var S = p * (d.y - v.y), C = p * (v.x - d.x), P = S * a + C * u, R = S * l + C * u, N = S * a + C * c, F = S * l + C * c;
      return !(Math.max(P, R, N, F) <= S * d.x + C * d.y || Math.min(P, R, N, F) >= S * m.x + C * m.y);
    }, r.prototype.pad = function(t, e) {
      return t === void 0 && (t = 0), e === void 0 && (e = t), this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
    }, r.prototype.fit = function(t) {
      var e = Math.max(this.x, t.x), i = Math.min(this.x + this.width, t.x + t.width), n = Math.max(this.y, t.y), s = Math.min(this.y + this.height, t.y + t.height);
      return this.x = e, this.width = Math.max(i - e, 0), this.y = n, this.height = Math.max(s - n, 0), this;
    }, r.prototype.ceil = function(t, e) {
      t === void 0 && (t = 1), e === void 0 && (e = 1e-3);
      var i = Math.ceil((this.x + this.width - e) * t) / t, n = Math.ceil((this.y + this.height - e) * t) / t;
      return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = i - this.x, this.height = n - this.y, this;
    }, r.prototype.enlarge = function(t) {
      var e = Math.min(this.x, t.x), i = Math.max(this.x + this.width, t.x + t.width), n = Math.min(this.y, t.y), s = Math.max(this.y + this.height, t.y + t.height);
      return this.x = e, this.width = i - e, this.y = n, this.height = s - n, this;
    }, r.prototype.toString = function() {
      return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    }, r;
  }()
), iP = (
  /** @class */
  function() {
    function r(t, e, i) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), i === void 0 && (i = 0), this.x = t, this.y = e, this.radius = i, this.type = Be.CIRC;
    }
    return r.prototype.clone = function() {
      return new r(this.x, this.y, this.radius);
    }, r.prototype.contains = function(t, e) {
      if (this.radius <= 0)
        return !1;
      var i = this.radius * this.radius, n = this.x - t, s = this.y - e;
      return n *= n, s *= s, n + s <= i;
    }, r.prototype.getBounds = function() {
      return new pt(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }, r.prototype.toString = function() {
      return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
    }, r;
  }()
), rP = (
  /** @class */
  function() {
    function r(t, e, i, n) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), i === void 0 && (i = 0), n === void 0 && (n = 0), this.x = t, this.y = e, this.width = i, this.height = n, this.type = Be.ELIP;
    }
    return r.prototype.clone = function() {
      return new r(this.x, this.y, this.width, this.height);
    }, r.prototype.contains = function(t, e) {
      if (this.width <= 0 || this.height <= 0)
        return !1;
      var i = (t - this.x) / this.width, n = (e - this.y) / this.height;
      return i *= i, n *= n, i + n <= 1;
    }, r.prototype.getBounds = function() {
      return new pt(this.x - this.width, this.y - this.height, this.width, this.height);
    }, r.prototype.toString = function() {
      return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    }, r;
  }()
), ff = (
  /** @class */
  function() {
    function r() {
      for (var t = arguments, e = [], i = 0; i < arguments.length; i++)
        e[i] = t[i];
      var n = Array.isArray(e[0]) ? e[0] : e;
      if (typeof n[0] != "number") {
        for (var s = [], o = 0, a = n.length; o < a; o++)
          s.push(n[o].x, n[o].y);
        n = s;
      }
      this.points = n, this.type = Be.POLY, this.closeStroke = !0;
    }
    return r.prototype.clone = function() {
      var t = this.points.slice(), e = new r(t);
      return e.closeStroke = this.closeStroke, e;
    }, r.prototype.contains = function(t, e) {
      for (var i = !1, n = this.points.length / 2, s = 0, o = n - 1; s < n; o = s++) {
        var a = this.points[s * 2], l = this.points[s * 2 + 1], u = this.points[o * 2], c = this.points[o * 2 + 1], d = l > e != c > e && t < (u - a) * ((e - l) / (c - l)) + a;
        d && (i = !i);
      }
      return i;
    }, r.prototype.toString = function() {
      return "[@pixi/math:Polygon" + ("closeStroke=" + this.closeStroke) + ("points=" + this.points.reduce(function(t, e) {
        return t + ", " + e;
      }, "") + "]");
    }, r;
  }()
), nP = (
  /** @class */
  function() {
    function r(t, e, i, n, s) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), i === void 0 && (i = 0), n === void 0 && (n = 0), s === void 0 && (s = 20), this.x = t, this.y = e, this.width = i, this.height = n, this.radius = s, this.type = Be.RREC;
    }
    return r.prototype.clone = function() {
      return new r(this.x, this.y, this.width, this.height, this.radius);
    }, r.prototype.contains = function(t, e) {
      if (this.width <= 0 || this.height <= 0)
        return !1;
      if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
        var i = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (e >= this.y + i && e <= this.y + this.height - i || t >= this.x + i && t <= this.x + this.width - i)
          return !0;
        var n = t - (this.x + i), s = e - (this.y + i), o = i * i;
        if (n * n + s * s <= o || (n = t - (this.x + this.width - i), n * n + s * s <= o) || (s = e - (this.y + this.height - i), n * n + s * s <= o) || (n = t - (this.x + i), n * n + s * s <= o))
          return !0;
      }
      return !1;
    }, r.prototype.toString = function() {
      return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + ("width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]");
    }, r;
  }()
), ya = (
  /** @class */
  function() {
    function r(t, e, i, n) {
      i === void 0 && (i = 0), n === void 0 && (n = 0), this._x = i, this._y = n, this.cb = t, this.scope = e;
    }
    return r.prototype.clone = function(t, e) {
      return t === void 0 && (t = this.cb), e === void 0 && (e = this.scope), new r(t, e, this._x, this._y);
    }, r.prototype.set = function(t, e) {
      return t === void 0 && (t = 0), e === void 0 && (e = t), (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this.cb.call(this.scope)), this;
    }, r.prototype.copyFrom = function(t) {
      return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this;
    }, r.prototype.copyTo = function(t) {
      return t.set(this._x, this._y), t;
    }, r.prototype.equals = function(t) {
      return t.x === this._x && t.y === this._y;
    }, r.prototype.toString = function() {
      return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
    }, Object.defineProperty(r.prototype, "x", {
      /** Position of the observable point on the x axis. */
      get: function() {
        return this._x;
      },
      set: function(t) {
        this._x !== t && (this._x = t, this.cb.call(this.scope));
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "y", {
      /** Position of the observable point on the y axis. */
      get: function() {
        return this._y;
      },
      set: function(t) {
        this._y !== t && (this._y = t, this.cb.call(this.scope));
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
), De = (
  /** @class */
  function() {
    function r(t, e, i, n, s, o) {
      t === void 0 && (t = 1), e === void 0 && (e = 0), i === void 0 && (i = 0), n === void 0 && (n = 1), s === void 0 && (s = 0), o === void 0 && (o = 0), this.array = null, this.a = t, this.b = e, this.c = i, this.d = n, this.tx = s, this.ty = o;
    }
    return r.prototype.fromArray = function(t) {
      this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
    }, r.prototype.set = function(t, e, i, n, s, o) {
      return this.a = t, this.b = e, this.c = i, this.d = n, this.tx = s, this.ty = o, this;
    }, r.prototype.toArray = function(t, e) {
      this.array || (this.array = new Float32Array(9));
      var i = e || this.array;
      return t ? (i[0] = this.a, i[1] = this.b, i[2] = 0, i[3] = this.c, i[4] = this.d, i[5] = 0, i[6] = this.tx, i[7] = this.ty, i[8] = 1) : (i[0] = this.a, i[1] = this.c, i[2] = this.tx, i[3] = this.b, i[4] = this.d, i[5] = this.ty, i[6] = 0, i[7] = 0, i[8] = 1), i;
    }, r.prototype.apply = function(t, e) {
      e = e || new te();
      var i = t.x, n = t.y;
      return e.x = this.a * i + this.c * n + this.tx, e.y = this.b * i + this.d * n + this.ty, e;
    }, r.prototype.applyInverse = function(t, e) {
      e = e || new te();
      var i = 1 / (this.a * this.d + this.c * -this.b), n = t.x, s = t.y;
      return e.x = this.d * i * n + -this.c * i * s + (this.ty * this.c - this.tx * this.d) * i, e.y = this.a * i * s + -this.b * i * n + (-this.ty * this.a + this.tx * this.b) * i, e;
    }, r.prototype.translate = function(t, e) {
      return this.tx += t, this.ty += e, this;
    }, r.prototype.scale = function(t, e) {
      return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
    }, r.prototype.rotate = function(t) {
      var e = Math.cos(t), i = Math.sin(t), n = this.a, s = this.c, o = this.tx;
      return this.a = n * e - this.b * i, this.b = n * i + this.b * e, this.c = s * e - this.d * i, this.d = s * i + this.d * e, this.tx = o * e - this.ty * i, this.ty = o * i + this.ty * e, this;
    }, r.prototype.append = function(t) {
      var e = this.a, i = this.b, n = this.c, s = this.d;
      return this.a = t.a * e + t.b * n, this.b = t.a * i + t.b * s, this.c = t.c * e + t.d * n, this.d = t.c * i + t.d * s, this.tx = t.tx * e + t.ty * n + this.tx, this.ty = t.tx * i + t.ty * s + this.ty, this;
    }, r.prototype.setTransform = function(t, e, i, n, s, o, a, l, u) {
      return this.a = Math.cos(a + u) * s, this.b = Math.sin(a + u) * s, this.c = -Math.sin(a - l) * o, this.d = Math.cos(a - l) * o, this.tx = t - (i * this.a + n * this.c), this.ty = e - (i * this.b + n * this.d), this;
    }, r.prototype.prepend = function(t) {
      var e = this.tx;
      if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
        var i = this.a, n = this.c;
        this.a = i * t.a + this.b * t.c, this.b = i * t.b + this.b * t.d, this.c = n * t.a + this.d * t.c, this.d = n * t.b + this.d * t.d;
      }
      return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
    }, r.prototype.decompose = function(t) {
      var e = this.a, i = this.b, n = this.c, s = this.d, o = t.pivot, a = -Math.atan2(-n, s), l = Math.atan2(i, e), u = Math.abs(a + l);
      return u < 1e-5 || Math.abs(Kf - u) < 1e-5 ? (t.rotation = l, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = a, t.skew.y = l), t.scale.x = Math.sqrt(e * e + i * i), t.scale.y = Math.sqrt(n * n + s * s), t.position.x = this.tx + (o.x * e + o.y * n), t.position.y = this.ty + (o.x * i + o.y * s), t;
    }, r.prototype.invert = function() {
      var t = this.a, e = this.b, i = this.c, n = this.d, s = this.tx, o = t * n - e * i;
      return this.a = n / o, this.b = -e / o, this.c = -i / o, this.d = t / o, this.tx = (i * this.ty - n * s) / o, this.ty = -(t * this.ty - e * s) / o, this;
    }, r.prototype.identity = function() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }, r.prototype.clone = function() {
      var t = new r();
      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
    }, r.prototype.copyTo = function(t) {
      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
    }, r.prototype.copyFrom = function(t) {
      return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
    }, r.prototype.toString = function() {
      return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
    }, Object.defineProperty(r, "IDENTITY", {
      /**
       * A default (identity) matrix
       * @readonly
       */
      get: function() {
        return new r();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "TEMP_MATRIX", {
      /**
       * A temp matrix
       * @readonly
       */
      get: function() {
        return new r();
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
), Ps = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], Os = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], Is = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], Cs = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], Ey = [], V0 = [], Uc = Math.sign;
function sP() {
  for (var r = 0; r < 16; r++) {
    var t = [];
    Ey.push(t);
    for (var e = 0; e < 16; e++)
      for (var i = Uc(Ps[r] * Ps[e] + Is[r] * Os[e]), n = Uc(Os[r] * Ps[e] + Cs[r] * Os[e]), s = Uc(Ps[r] * Is[e] + Is[r] * Cs[e]), o = Uc(Os[r] * Is[e] + Cs[r] * Cs[e]), a = 0; a < 16; a++)
        if (Ps[a] === i && Os[a] === n && Is[a] === s && Cs[a] === o) {
          t.push(a);
          break;
        }
  }
  for (var r = 0; r < 16; r++) {
    var l = new De();
    l.set(Ps[r], Os[r], Is[r], Cs[r], 0, 0), V0.push(l);
  }
}
sP();
var pe = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: function(r) {
    return Ps[r];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: function(r) {
    return Os[r];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: function(r) {
    return Is[r];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: function(r) {
    return Cs[r];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: function(r) {
    return r & 8 ? r & 15 : -r & 7;
  },
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {PIXI.GD8Symmetry} Composed operation
   */
  add: function(r, t) {
    return Ey[r][t];
  },
  /**
   * Reverse of `add`.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @returns {PIXI.GD8Symmetry} Result
   */
  sub: function(r, t) {
    return Ey[r][pe.inv(t)];
  },
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @memberof PIXI.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: function(r) {
    return r ^ 4;
  },
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: function(r) {
    return (r & 3) === 2;
  },
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @memberof PIXI.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: function(r, t) {
    return Math.abs(r) * 2 <= Math.abs(t) ? t >= 0 ? pe.S : pe.N : Math.abs(t) * 2 <= Math.abs(r) ? r > 0 ? pe.E : pe.W : t > 0 ? r > 0 ? pe.SE : pe.SW : r > 0 ? pe.NE : pe.NW;
  },
  /**
   * Helps sprite to compensate texture packer rotation.
   * @memberof PIXI.groupD8
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: function(r, t, e, i) {
    e === void 0 && (e = 0), i === void 0 && (i = 0);
    var n = V0[pe.inv(t)];
    n.tx = e, n.ty = i, r.append(n);
  }
}, X0 = (
  /** @class */
  function() {
    function r() {
      this.worldTransform = new De(), this.localTransform = new De(), this.position = new ya(this.onChange, this, 0, 0), this.scale = new ya(this.onChange, this, 1, 1), this.pivot = new ya(this.onChange, this, 0, 0), this.skew = new ya(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
    }
    return r.prototype.onChange = function() {
      this._localID++;
    }, r.prototype.updateSkew = function() {
      this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
    }, r.prototype.toString = function() {
      return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
    }, r.prototype.updateLocalTransform = function() {
      var t = this.localTransform;
      this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1);
    }, r.prototype.updateTransform = function(t) {
      var e = this.localTransform;
      if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {
        var i = t.worldTransform, n = this.worldTransform;
        n.a = e.a * i.a + e.b * i.c, n.b = e.a * i.b + e.b * i.d, n.c = e.c * i.a + e.d * i.c, n.d = e.c * i.b + e.d * i.d, n.tx = e.tx * i.a + e.ty * i.c + i.tx, n.ty = e.tx * i.b + e.ty * i.d + i.ty, this._parentID = t._worldID, this._worldID++;
      }
    }, r.prototype.setFromMatrix = function(t) {
      t.decompose(this), this._localID++;
    }, Object.defineProperty(r.prototype, "rotation", {
      /** The rotation of the object in radians. */
      get: function() {
        return this._rotation;
      },
      set: function(t) {
        this._rotation !== t && (this._rotation = t, this.updateSkew());
      },
      enumerable: !1,
      configurable: !0
    }), r.IDENTITY = new r(), r;
  }()
);
/*!
 * @pixi/display - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
J.SORTABLE_CHILDREN = !1;
var Jf = (
  /** @class */
  function() {
    function r() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
    }
    return r.prototype.isEmpty = function() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }, r.prototype.clear = function() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
    }, r.prototype.getRectangle = function(t) {
      return this.minX > this.maxX || this.minY > this.maxY ? pt.EMPTY : (t = t || new pt(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t);
    }, r.prototype.addPoint = function(t) {
      this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y);
    }, r.prototype.addPointMatrix = function(t, e) {
      var i = t.a, n = t.b, s = t.c, o = t.d, a = t.tx, l = t.ty, u = i * e.x + s * e.y + a, c = n * e.x + o * e.y + l;
      this.minX = Math.min(this.minX, u), this.maxX = Math.max(this.maxX, u), this.minY = Math.min(this.minY, c), this.maxY = Math.max(this.maxY, c);
    }, r.prototype.addQuad = function(t) {
      var e = this.minX, i = this.minY, n = this.maxX, s = this.maxY, o = t[0], a = t[1];
      e = o < e ? o : e, i = a < i ? a : i, n = o > n ? o : n, s = a > s ? a : s, o = t[2], a = t[3], e = o < e ? o : e, i = a < i ? a : i, n = o > n ? o : n, s = a > s ? a : s, o = t[4], a = t[5], e = o < e ? o : e, i = a < i ? a : i, n = o > n ? o : n, s = a > s ? a : s, o = t[6], a = t[7], e = o < e ? o : e, i = a < i ? a : i, n = o > n ? o : n, s = a > s ? a : s, this.minX = e, this.minY = i, this.maxX = n, this.maxY = s;
    }, r.prototype.addFrame = function(t, e, i, n, s) {
      this.addFrameMatrix(t.worldTransform, e, i, n, s);
    }, r.prototype.addFrameMatrix = function(t, e, i, n, s) {
      var o = t.a, a = t.b, l = t.c, u = t.d, c = t.tx, d = t.ty, f = this.minX, v = this.minY, m = this.maxX, p = this.maxY, y = o * e + l * i + c, b = a * e + u * i + d;
      f = y < f ? y : f, v = b < v ? b : v, m = y > m ? y : m, p = b > p ? b : p, y = o * n + l * i + c, b = a * n + u * i + d, f = y < f ? y : f, v = b < v ? b : v, m = y > m ? y : m, p = b > p ? b : p, y = o * e + l * s + c, b = a * e + u * s + d, f = y < f ? y : f, v = b < v ? b : v, m = y > m ? y : m, p = b > p ? b : p, y = o * n + l * s + c, b = a * n + u * s + d, f = y < f ? y : f, v = b < v ? b : v, m = y > m ? y : m, p = b > p ? b : p, this.minX = f, this.minY = v, this.maxX = m, this.maxY = p;
    }, r.prototype.addVertexData = function(t, e, i) {
      for (var n = this.minX, s = this.minY, o = this.maxX, a = this.maxY, l = e; l < i; l += 2) {
        var u = t[l], c = t[l + 1];
        n = u < n ? u : n, s = c < s ? c : s, o = u > o ? u : o, a = c > a ? c : a;
      }
      this.minX = n, this.minY = s, this.maxX = o, this.maxY = a;
    }, r.prototype.addVertices = function(t, e, i, n) {
      this.addVerticesMatrix(t.worldTransform, e, i, n);
    }, r.prototype.addVerticesMatrix = function(t, e, i, n, s, o) {
      s === void 0 && (s = 0), o === void 0 && (o = s);
      for (var a = t.a, l = t.b, u = t.c, c = t.d, d = t.tx, f = t.ty, v = this.minX, m = this.minY, p = this.maxX, y = this.maxY, b = i; b < n; b += 2) {
        var w = e[b], E = e[b + 1], O = a * w + u * E + d, I = c * E + l * w + f;
        v = Math.min(v, O - s), p = Math.max(p, O + s), m = Math.min(m, I - o), y = Math.max(y, I + o);
      }
      this.minX = v, this.minY = m, this.maxX = p, this.maxY = y;
    }, r.prototype.addBounds = function(t) {
      var e = this.minX, i = this.minY, n = this.maxX, s = this.maxY;
      this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < i ? t.minY : i, this.maxX = t.maxX > n ? t.maxX : n, this.maxY = t.maxY > s ? t.maxY : s;
    }, r.prototype.addBoundsMask = function(t, e) {
      var i = t.minX > e.minX ? t.minX : e.minX, n = t.minY > e.minY ? t.minY : e.minY, s = t.maxX < e.maxX ? t.maxX : e.maxX, o = t.maxY < e.maxY ? t.maxY : e.maxY;
      if (i <= s && n <= o) {
        var a = this.minX, l = this.minY, u = this.maxX, c = this.maxY;
        this.minX = i < a ? i : a, this.minY = n < l ? n : l, this.maxX = s > u ? s : u, this.maxY = o > c ? o : c;
      }
    }, r.prototype.addBoundsMatrix = function(t, e) {
      this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);
    }, r.prototype.addBoundsArea = function(t, e) {
      var i = t.minX > e.x ? t.minX : e.x, n = t.minY > e.y ? t.minY : e.y, s = t.maxX < e.x + e.width ? t.maxX : e.x + e.width, o = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
      if (i <= s && n <= o) {
        var a = this.minX, l = this.minY, u = this.maxX, c = this.maxY;
        this.minX = i < a ? i : a, this.minY = n < l ? n : l, this.maxX = s > u ? s : u, this.maxY = o > c ? o : c;
      }
    }, r.prototype.pad = function(t, e) {
      t === void 0 && (t = 0), e === void 0 && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e);
    }, r.prototype.addFramePad = function(t, e, i, n, s, o) {
      t -= s, e -= o, i += s, n += o, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > i ? this.maxX : i, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > n ? this.maxY : n;
    }, r;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ty = function(r, t) {
  return Ty = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Ty(r, t);
};
function Km(r, t) {
  Ty(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var xe = (
  /** @class */
  function(r) {
    Km(t, r);
    function t() {
      var e = r.call(this) || this;
      return e.tempDisplayObjectParent = null, e.transform = new X0(), e.alpha = 1, e.visible = !0, e.renderable = !0, e.cullable = !1, e.cullArea = null, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new Jf(), e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._maskRefCount = 0, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e;
    }
    return t.mixin = function(e) {
      for (var i = Object.keys(e), n = 0; n < i.length; ++n) {
        var s = i[n];
        Object.defineProperty(t.prototype, s, Object.getOwnPropertyDescriptor(e, s));
      }
    }, Object.defineProperty(t.prototype, "destroyed", {
      /**
       * Fired when this DisplayObject is added to a Container.
       * @instance
       * @event added
       * @param {PIXI.Container} container - The container added to.
       */
      /**
       * Fired when this DisplayObject is removed from a Container.
       * @instance
       * @event removed
       * @param {PIXI.Container} container - The container removed from.
       */
      /**
       * Fired when this DisplayObject is destroyed. This event is emitted once
       * destroy is finished.
       * @instance
       * @event destroyed
       */
      /** Readonly flag for destroyed display objects. */
      get: function() {
        return this._destroyed;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype._recursivePostUpdateTransform = function() {
      this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }, t.prototype.updateTransform = function() {
      this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
    }, t.prototype.getBounds = function(e, i) {
      return e || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), i || (this._boundsRect || (this._boundsRect = new pt()), i = this._boundsRect), this._bounds.getRectangle(i);
    }, t.prototype.getLocalBounds = function(e) {
      e || (this._localBoundsRect || (this._localBoundsRect = new pt()), e = this._localBoundsRect), this._localBounds || (this._localBounds = new Jf());
      var i = this.transform, n = this.parent;
      this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
      var s = this._bounds, o = this._boundsID;
      this._bounds = this._localBounds;
      var a = this.getBounds(!1, e);
      return this.parent = n, this.transform = i, this._bounds = s, this._bounds.updateID += this._boundsID - o, a;
    }, t.prototype.toGlobal = function(e, i, n) {
      return n === void 0 && (n = !1), n || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(e, i);
    }, t.prototype.toLocal = function(e, i, n, s) {
      return i && (e = i.toGlobal(e, n, s)), s || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(e, n);
    }, t.prototype.setParent = function(e) {
      if (!e || !e.addChild)
        throw new Error("setParent: Argument must be a Container");
      return e.addChild(this), e;
    }, t.prototype.setTransform = function(e, i, n, s, o, a, l, u, c) {
      return e === void 0 && (e = 0), i === void 0 && (i = 0), n === void 0 && (n = 1), s === void 0 && (s = 1), o === void 0 && (o = 0), a === void 0 && (a = 0), l === void 0 && (l = 0), u === void 0 && (u = 0), c === void 0 && (c = 0), this.position.x = e, this.position.y = i, this.scale.x = n || 1, this.scale.y = s || 1, this.rotation = o, this.skew.x = a, this.skew.y = l, this.pivot.x = u, this.pivot.y = c, this;
    }, t.prototype.destroy = function(e) {
      this.parent && this.parent.removeChild(this), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners();
    }, Object.defineProperty(t.prototype, "_tempDisplayObjectParent", {
      /**
       * @protected
       * @member {PIXI.Container}
       */
      get: function() {
        return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new W0()), this.tempDisplayObjectParent;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.enableTempParent = function() {
      var e = this.parent;
      return this.parent = this._tempDisplayObjectParent, e;
    }, t.prototype.disableTempParent = function(e) {
      this.parent = e;
    }, Object.defineProperty(t.prototype, "x", {
      /**
       * The position of the displayObject on the x axis relative to the local coordinates of the parent.
       * An alias to position.x
       */
      get: function() {
        return this.position.x;
      },
      set: function(e) {
        this.transform.position.x = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "y", {
      /**
       * The position of the displayObject on the y axis relative to the local coordinates of the parent.
       * An alias to position.y
       */
      get: function() {
        return this.position.y;
      },
      set: function(e) {
        this.transform.position.y = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "worldTransform", {
      /**
       * Current transform of the object based on world (parent) factors.
       * @readonly
       */
      get: function() {
        return this.transform.worldTransform;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "localTransform", {
      /**
       * Current transform of the object based on local factors: position, scale, other stuff.
       * @readonly
       */
      get: function() {
        return this.transform.localTransform;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "position", {
      /**
       * The coordinate of the object relative to the local coordinates of the parent.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.position;
      },
      set: function(e) {
        this.transform.position.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "scale", {
      /**
       * The scale factors of this object along the local coordinate axes.
       *
       * The default scale is (1, 1).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.scale;
      },
      set: function(e) {
        this.transform.scale.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "pivot", {
      /**
       * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
       * is the projection of `pivot` in the parent's local space.
       *
       * By default, the pivot is the origin (0, 0).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.pivot;
      },
      set: function(e) {
        this.transform.pivot.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "skew", {
      /**
       * The skew factor for the object in radians.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.skew;
      },
      set: function(e) {
        this.transform.skew.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "rotation", {
      /**
       * The rotation of the object in radians.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation;
      },
      set: function(e) {
        this.transform.rotation = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "angle", {
      /**
       * The angle of the object in degrees.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation * tP;
      },
      set: function(e) {
        this.transform.rotation = e * eP;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "zIndex", {
      /**
       * The zIndex of the displayObject.
       *
       * If a container has the sortableChildren property set to true, children will be automatically
       * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
       * and thus rendered on top of other display objects within the same container.
       * @see PIXI.Container#sortableChildren
       */
      get: function() {
        return this._zIndex;
      },
      set: function(e) {
        this._zIndex = e, this.parent && (this.parent.sortDirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "worldVisible", {
      /**
       * Indicates if the object is globally visible.
       * @readonly
       */
      get: function() {
        var e = this;
        do {
          if (!e.visible)
            return !1;
          e = e.parent;
        } while (e);
        return !0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "mask", {
      /**
       * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
       * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
       * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
       * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
       * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
       * To remove a mask, set this property to `null`.
       *
       * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
       * @example
       * const graphics = new PIXI.Graphics();
       * graphics.beginFill(0xFF3300);
       * graphics.drawRect(50, 250, 100, 100);
       * graphics.endFill();
       *
       * const sprite = new PIXI.Sprite(texture);
       * sprite.mask = graphics;
       * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
       */
      get: function() {
        return this._mask;
      },
      set: function(e) {
        if (this._mask !== e) {
          if (this._mask) {
            var i = this._mask.isMaskData ? this._mask.maskObject : this._mask;
            i && (i._maskRefCount--, i._maskRefCount === 0 && (i.renderable = !0, i.isMask = !1));
          }
          if (this._mask = e, this._mask) {
            var i = this._mask.isMaskData ? this._mask.maskObject : this._mask;
            i && (i._maskRefCount === 0 && (i.renderable = !1, i.isMask = !0), i._maskRefCount++);
          }
        }
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zi)
), W0 = (
  /** @class */
  function(r) {
    Km(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.sortDirty = null, e;
    }
    return t;
  }(xe)
);
xe.prototype.displayObjectUpdateTransform = xe.prototype.updateTransform;
function oP(r, t) {
  return r.zIndex === t.zIndex ? r._lastSortedIndex - t._lastSortedIndex : r.zIndex - t.zIndex;
}
var Qt = (
  /** @class */
  function(r) {
    Km(t, r);
    function t() {
      var e = r.call(this) || this;
      return e.children = [], e.sortableChildren = J.SORTABLE_CHILDREN, e.sortDirty = !1, e;
    }
    return t.prototype.onChildrenChange = function(e) {
    }, t.prototype.addChild = function() {
      for (var e = arguments, i = [], n = 0; n < arguments.length; n++)
        i[n] = e[n];
      if (i.length > 1)
        for (var s = 0; s < i.length; s++)
          this.addChild(i[s]);
      else {
        var o = i[0];
        o.parent && o.parent.removeChild(o), o.parent = this, this.sortDirty = !0, o.transform._parentID = -1, this.children.push(o), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", o, this, this.children.length - 1), o.emit("added", this);
      }
      return i[0];
    }, t.prototype.addChildAt = function(e, i) {
      if (i < 0 || i > this.children.length)
        throw new Error(e + "addChildAt: The index " + i + " supplied is out of bounds " + this.children.length);
      return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(i, 0, e), this._boundsID++, this.onChildrenChange(i), e.emit("added", this), this.emit("childAdded", e, this, i), e;
    }, t.prototype.swapChildren = function(e, i) {
      if (e !== i) {
        var n = this.getChildIndex(e), s = this.getChildIndex(i);
        this.children[n] = i, this.children[s] = e, this.onChildrenChange(n < s ? n : s);
      }
    }, t.prototype.getChildIndex = function(e) {
      var i = this.children.indexOf(e);
      if (i === -1)
        throw new Error("The supplied DisplayObject must be a child of the caller");
      return i;
    }, t.prototype.setChildIndex = function(e, i) {
      if (i < 0 || i >= this.children.length)
        throw new Error("The index " + i + " supplied is out of bounds " + this.children.length);
      var n = this.getChildIndex(e);
      xa(this.children, n, 1), this.children.splice(i, 0, e), this.onChildrenChange(i);
    }, t.prototype.getChildAt = function(e) {
      if (e < 0 || e >= this.children.length)
        throw new Error("getChildAt: Index (" + e + ") does not exist.");
      return this.children[e];
    }, t.prototype.removeChild = function() {
      for (var e = arguments, i = [], n = 0; n < arguments.length; n++)
        i[n] = e[n];
      if (i.length > 1)
        for (var s = 0; s < i.length; s++)
          this.removeChild(i[s]);
      else {
        var o = i[0], a = this.children.indexOf(o);
        if (a === -1)
          return null;
        o.parent = null, o.transform._parentID = -1, xa(this.children, a, 1), this._boundsID++, this.onChildrenChange(a), o.emit("removed", this), this.emit("childRemoved", o, this, a);
      }
      return i[0];
    }, t.prototype.removeChildAt = function(e) {
      var i = this.getChildAt(e);
      return i.parent = null, i.transform._parentID = -1, xa(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), i.emit("removed", this), this.emit("childRemoved", i, this, e), i;
    }, t.prototype.removeChildren = function(e, i) {
      e === void 0 && (e = 0), i === void 0 && (i = this.children.length);
      var n = e, s = i, o = s - n, a;
      if (o > 0 && o <= s) {
        a = this.children.splice(n, o);
        for (var l = 0; l < a.length; ++l)
          a[l].parent = null, a[l].transform && (a[l].transform._parentID = -1);
        this._boundsID++, this.onChildrenChange(e);
        for (var l = 0; l < a.length; ++l)
          a[l].emit("removed", this), this.emit("childRemoved", a[l], this, l);
        return a;
      } else if (o === 0 && this.children.length === 0)
        return [];
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    }, t.prototype.sortChildren = function() {
      for (var e = !1, i = 0, n = this.children.length; i < n; ++i) {
        var s = this.children[i];
        s._lastSortedIndex = i, !e && s.zIndex !== 0 && (e = !0);
      }
      e && this.children.length > 1 && this.children.sort(oP), this.sortDirty = !1;
    }, t.prototype.updateTransform = function() {
      this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (var e = 0, i = this.children.length; e < i; ++e) {
        var n = this.children[e];
        n.visible && n.updateTransform();
      }
    }, t.prototype.calculateBounds = function() {
      this._bounds.clear(), this._calculateBounds();
      for (var e = 0; e < this.children.length; e++) {
        var i = this.children[e];
        if (!(!i.visible || !i.renderable))
          if (i.calculateBounds(), i._mask) {
            var n = i._mask.isMaskData ? i._mask.maskObject : i._mask;
            n ? (n.calculateBounds(), this._bounds.addBoundsMask(i._bounds, n._bounds)) : this._bounds.addBounds(i._bounds);
          } else
            i.filterArea ? this._bounds.addBoundsArea(i._bounds, i.filterArea) : this._bounds.addBounds(i._bounds);
      }
      this._bounds.updateID = this._boundsID;
    }, t.prototype.getLocalBounds = function(e, i) {
      i === void 0 && (i = !1);
      var n = r.prototype.getLocalBounds.call(this, e);
      if (!i)
        for (var s = 0, o = this.children.length; s < o; ++s) {
          var a = this.children[s];
          a.visible && a.updateTransform();
        }
      return n;
    }, t.prototype._calculateBounds = function() {
    }, t.prototype._renderWithCulling = function(e) {
      var i = e.renderTexture.sourceFrame;
      if (i.width > 0 && i.height > 0) {
        var n, s;
        if (this.cullArea ? (n = this.cullArea, s = this.worldTransform) : this._render !== t.prototype._render && (n = this.getBounds(!0)), n && i.intersects(n, s))
          this._render(e);
        else if (this.cullArea)
          return;
        for (var o = 0, a = this.children.length; o < a; ++o) {
          var l = this.children[o], u = l.cullable;
          l.cullable = u || !this.cullArea, l.render(e), l.cullable = u;
        }
      }
    }, t.prototype.render = function(e) {
      if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
        if (this._mask || this.filters && this.filters.length)
          this.renderAdvanced(e);
        else if (this.cullable)
          this._renderWithCulling(e);
        else {
          this._render(e);
          for (var i = 0, n = this.children.length; i < n; ++i)
            this.children[i].render(e);
        }
    }, t.prototype.renderAdvanced = function(e) {
      var i = this.filters, n = this._mask;
      if (i) {
        this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
        for (var s = 0; s < i.length; s++)
          i[s].enabled && this._enabledFilters.push(i[s]);
      }
      var o = i && this._enabledFilters && this._enabledFilters.length || n && (!n.isMaskData || n.enabled && (n.autoDetect || n.type !== Ie.NONE));
      if (o && e.batch.flush(), i && this._enabledFilters && this._enabledFilters.length && e.filter.push(this, this._enabledFilters), n && e.mask.push(this, this._mask), this.cullable)
        this._renderWithCulling(e);
      else {
        this._render(e);
        for (var s = 0, a = this.children.length; s < a; ++s)
          this.children[s].render(e);
      }
      o && e.batch.flush(), n && e.mask.pop(this), i && this._enabledFilters && this._enabledFilters.length && e.filter.pop();
    }, t.prototype._render = function(e) {
    }, t.prototype.destroy = function(e) {
      r.prototype.destroy.call(this), this.sortDirty = !1;
      var i = typeof e == "boolean" ? e : e && e.children, n = this.removeChildren(0, this.children.length);
      if (i)
        for (var s = 0; s < n.length; ++s)
          n[s].destroy(e);
    }, Object.defineProperty(t.prototype, "width", {
      /** The width of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.x * this.getLocalBounds().width;
      },
      set: function(e) {
        var i = this.getLocalBounds().width;
        i !== 0 ? this.scale.x = e / i : this.scale.x = 1, this._width = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.y * this.getLocalBounds().height;
      },
      set: function(e) {
        var i = this.getLocalBounds().height;
        i !== 0 ? this.scale.y = e / i : this.scale.y = 1, this._height = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(xe)
);
Qt.prototype.containerUpdateTransform = Qt.prototype.updateTransform;
/*!
 * @pixi/extensions - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/extensions is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var yl = function() {
  return yl = Object.assign || function(t) {
    for (var e = arguments, i, n = 1, s = arguments.length; n < s; n++) {
      i = e[n];
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (t[o] = i[o]);
    }
    return t;
  }, yl.apply(this, arguments);
}, qt;
(function(r) {
  r.Application = "application", r.RendererPlugin = "renderer-webgl-plugin", r.CanvasRendererPlugin = "renderer-canvas-plugin", r.Loader = "loader", r.LoadParser = "load-parser", r.ResolveParser = "resolve-parser", r.CacheParser = "cache-parser", r.DetectionParser = "detection-parser";
})(qt || (qt = {}));
var pg = function(r) {
  if (typeof r == "function" || typeof r == "object" && r.extension) {
    if (!r.extension)
      throw new Error("Extension class must have an extension object");
    var t = typeof r.extension != "object" ? { type: r.extension } : r.extension;
    r = yl(yl({}, t), { ref: r });
  }
  if (typeof r == "object")
    r = yl({}, r);
  else
    throw new Error("Invalid extension type");
  return typeof r.type == "string" && (r.type = [r.type]), r;
}, Tr = {
  /** @ignore */
  _addHandlers: null,
  /** @ignore */
  _removeHandlers: null,
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {PIXI.extensions} For chaining.
   */
  remove: function() {
    for (var r = arguments, t = this, e = [], i = 0; i < arguments.length; i++)
      e[i] = r[i];
    return e.map(pg).forEach(function(n) {
      n.type.forEach(function(s) {
        var o, a;
        return (a = (o = t._removeHandlers)[s]) === null || a === void 0 ? void 0 : a.call(o, n);
      });
    }), this;
  },
  /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {PIXI.extensions} For chaining.
   */
  add: function() {
    for (var r = arguments, t = this, e = [], i = 0; i < arguments.length; i++)
      e[i] = r[i];
    return e.map(pg).forEach(function(n) {
      n.type.forEach(function(s) {
        var o = t._addHandlers, a = t._queue;
        o[s] ? o[s](n) : (a[s] = a[s] || [], a[s].push(n));
      });
    }), this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.
   * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.
   * @returns {PIXI.extensions} For chaining.
   */
  handle: function(r, t, e) {
    var i = this._addHandlers = this._addHandlers || {}, n = this._removeHandlers = this._removeHandlers || {};
    if (i[r] || n[r])
      throw new Error("Extension type " + r + " already has a handler");
    i[r] = t, n[r] = e;
    var s = this._queue;
    return s[r] && (s[r].forEach(function(o) {
      return t(o);
    }), delete s[r]), this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByMap: function(r, t) {
    return this.handle(r, function(e) {
      t[e.name] = e.ref;
    }, function(e) {
      delete t[e.name];
    });
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByList: function(r, t) {
    return this.handle(r, function(e) {
      var i, n;
      t.includes(e.ref) || (t.push(e.ref), r === qt.Loader && ((n = (i = e.ref).add) === null || n === void 0 || n.call(i)));
    }, function(e) {
      var i = t.indexOf(e.ref);
      i !== -1 && t.splice(i, 1);
    });
  }
};
/*!
 * @pixi/runner - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Ve = (
  /** @class */
  function() {
    function r(t) {
      this.items = [], this._name = t, this._aliasCount = 0;
    }
    return r.prototype.emit = function(t, e, i, n, s, o, a, l) {
      if (arguments.length > 8)
        throw new Error("max arguments reached");
      var u = this, c = u.name, d = u.items;
      this._aliasCount++;
      for (var f = 0, v = d.length; f < v; f++)
        d[f][c](t, e, i, n, s, o, a, l);
      return d === this.items && this._aliasCount--, this;
    }, r.prototype.ensureNonAliasedItems = function() {
      this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
    }, r.prototype.add = function(t) {
      return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this;
    }, r.prototype.remove = function(t) {
      var e = this.items.indexOf(t);
      return e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this;
    }, r.prototype.contains = function(t) {
      return this.items.indexOf(t) !== -1;
    }, r.prototype.removeAll = function() {
      return this.ensureNonAliasedItems(), this.items.length = 0, this;
    }, r.prototype.destroy = function() {
      this.removeAll(), this.items = null, this._name = null;
    }, Object.defineProperty(r.prototype, "empty", {
      /**
       * `true` if there are no this Runner contains no listeners
       * @readonly
       */
      get: function() {
        return this.items.length === 0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "name", {
      /**
       * The name of the runner.
       * @readonly
       */
      get: function() {
        return this._name;
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
);
Object.defineProperties(Ve.prototype, {
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method dispatch
   * @see PIXI.Runner#emit
   */
  dispatch: { value: Ve.prototype.emit },
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method run
   * @see PIXI.Runner#emit
   */
  run: { value: Ve.prototype.emit }
});
/*!
 * @pixi/ticker - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/ticker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
J.TARGET_FPMS = 0.06;
var Un;
(function(r) {
  r[r.INTERACTION = 50] = "INTERACTION", r[r.HIGH = 25] = "HIGH", r[r.NORMAL = 0] = "NORMAL", r[r.LOW = -25] = "LOW", r[r.UTILITY = -50] = "UTILITY";
})(Un || (Un = {}));
var Xv = (
  /** @class */
  function() {
    function r(t, e, i, n) {
      e === void 0 && (e = null), i === void 0 && (i = 0), n === void 0 && (n = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = i, this.once = n;
    }
    return r.prototype.match = function(t, e) {
      return e === void 0 && (e = null), this.fn === t && this.context === e;
    }, r.prototype.emit = function(t) {
      this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
      var e = this.next;
      return this.once && this.destroy(!0), this._destroyed && (this.next = null), e;
    }, r.prototype.connect = function(t) {
      this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
    }, r.prototype.destroy = function(t) {
      t === void 0 && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
      var e = this.next;
      return this.next = t ? null : e, this.previous = null, e;
    }, r;
  }()
), _e = (
  /** @class */
  function() {
    function r() {
      var t = this;
      this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new Xv(null, null, 1 / 0), this.deltaMS = 1 / J.TARGET_FPMS, this.elapsedMS = 1 / J.TARGET_FPMS, this._tick = function(e) {
        t._requestId = null, t.started && (t.update(e), t.started && t._requestId === null && t._head.next && (t._requestId = requestAnimationFrame(t._tick)));
      };
    }
    return r.prototype._requestIfNeeded = function() {
      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
    }, r.prototype._cancelIfNeeded = function() {
      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }, r.prototype._startIfPossible = function() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }, r.prototype.add = function(t, e, i) {
      return i === void 0 && (i = Un.NORMAL), this._addListener(new Xv(t, e, i));
    }, r.prototype.addOnce = function(t, e, i) {
      return i === void 0 && (i = Un.NORMAL), this._addListener(new Xv(t, e, i, !0));
    }, r.prototype._addListener = function(t) {
      var e = this._head.next, i = this._head;
      if (!e)
        t.connect(i);
      else {
        for (; e; ) {
          if (t.priority > e.priority) {
            t.connect(i);
            break;
          }
          i = e, e = e.next;
        }
        t.previous || t.connect(i);
      }
      return this._startIfPossible(), this;
    }, r.prototype.remove = function(t, e) {
      for (var i = this._head.next; i; )
        i.match(t, e) ? i = i.destroy() : i = i.next;
      return this._head.next || this._cancelIfNeeded(), this;
    }, Object.defineProperty(r.prototype, "count", {
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       * @readonly
       * @member {number}
       */
      get: function() {
        if (!this._head)
          return 0;
        for (var t = 0, e = this._head; e = e.next; )
          t++;
        return t;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.start = function() {
      this.started || (this.started = !0, this._requestIfNeeded());
    }, r.prototype.stop = function() {
      this.started && (this.started = !1, this._cancelIfNeeded());
    }, r.prototype.destroy = function() {
      if (!this._protected) {
        this.stop();
        for (var t = this._head.next; t; )
          t = t.destroy(!0);
        this._head.destroy(), this._head = null;
      }
    }, r.prototype.update = function(t) {
      t === void 0 && (t = performance.now());
      var e;
      if (t > this.lastTime) {
        if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
          var i = t - this._lastFrame | 0;
          if (i < this._minElapsedMS)
            return;
          this._lastFrame = t - i % this._minElapsedMS;
        }
        this.deltaMS = e, this.deltaTime = this.deltaMS * J.TARGET_FPMS;
        for (var n = this._head, s = n.next; s; )
          s = s.emit(this.deltaTime);
        n.next || this._cancelIfNeeded();
      } else
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = t;
    }, Object.defineProperty(r.prototype, "FPS", {
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link PIXI.Ticker#speed}, which is specific
       * to scaling {@link PIXI.Ticker#deltaTime}.
       * @member {number}
       * @readonly
       */
      get: function() {
        return 1e3 / this.elapsedMS;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "minFPS", {
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This value is used to cap {@link PIXI.Ticker#deltaTime},
       * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
       * @member {number}
       * @default 10
       */
      get: function() {
        return 1e3 / this._maxElapsedMS;
      },
      set: function(t) {
        var e = Math.min(this.maxFPS, t), i = Math.min(Math.max(0, e) / 1e3, J.TARGET_FPMS);
        this._maxElapsedMS = 1 / i;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "maxFPS", {
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This will effect the measured value of {@link PIXI.Ticker#FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @member {number}
       * @default 0
       */
      get: function() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
      },
      set: function(t) {
        if (t === 0)
          this._minElapsedMS = 0;
        else {
          var e = Math.max(this.minFPS, t);
          this._minElapsedMS = 1 / (e / 1e3);
        }
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "shared", {
      /**
       * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
       * {@link PIXI.VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * let ticker = PIXI.Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the PIXI.Ticker.shared instance.
       * ticker.autoStart = false;
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * // You may use the shared ticker to render...
       * let renderer = PIXI.autoDetectRenderer();
       * let stage = new PIXI.Container();
       * document.body.appendChild(renderer.view);
       * ticker.add(function (time) {
       *     renderer.render(stage);
       * });
       * @example
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * function animate(time) {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * }
       * animate(performance.now());
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!r._shared) {
          var t = r._shared = new r();
          t.autoStart = !0, t._protected = !0;
        }
        return r._shared;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "system", {
      /**
       * The system ticker instance used by {@link PIXI.InteractionManager} and by
       * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
       * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!r._system) {
          var t = r._system = new r();
          t.autoStart = !0, t._protected = !0;
        }
        return r._system;
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
), aP = (
  /** @class */
  function() {
    function r() {
    }
    return r.init = function(t) {
      var e = this;
      t = Object.assign({
        autoStart: !0,
        sharedTicker: !1
      }, t), Object.defineProperty(this, "ticker", {
        set: function(i) {
          this._ticker && this._ticker.remove(this.render, this), this._ticker = i, i && i.add(this.render, this, Un.LOW);
        },
        get: function() {
          return this._ticker;
        }
      }), this.stop = function() {
        e._ticker.stop();
      }, this.start = function() {
        e._ticker.start();
      }, this._ticker = null, this.ticker = t.sharedTicker ? _e.shared : new _e(), t.autoStart && this.start();
    }, r.destroy = function() {
      if (this._ticker) {
        var t = this._ticker;
        this.ticker = null, t.destroy();
      }
    }, r.extension = qt.Application, r;
  }()
);
/*!
 * @pixi/core - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
J.PREFER_ENV = Xr.any ? Bn.WEBGL : Bn.WEBGL2;
J.STRICT_TEXTURE_CACHE = !1;
var Ol = [];
function Mv(r, t) {
  if (!r)
    return null;
  var e = "";
  if (typeof r == "string") {
    var i = /\.(\w{3,4})(?:$|\?|#)/i.exec(r);
    i && (e = i[1].toLowerCase());
  }
  for (var n = Ol.length - 1; n >= 0; --n) {
    var s = Ol[n];
    if (s.test && s.test(r, e))
      return new s(r, t);
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Sy = function(r, t) {
  return Sy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Sy(r, t);
};
function se(r, t) {
  Sy(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Py = function() {
  return Py = Object.assign || function(t) {
    for (var e = arguments, i, n = 1, s = arguments.length; n < s; n++) {
      i = e[n];
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (t[o] = i[o]);
    }
    return t;
  }, Py.apply(this, arguments);
};
function hP(r, t) {
  var e = {};
  for (var i in r)
    Object.prototype.hasOwnProperty.call(r, i) && t.indexOf(i) < 0 && (e[i] = r[i]);
  if (r != null && typeof Object.getOwnPropertySymbols == "function")
    for (var n = 0, i = Object.getOwnPropertySymbols(r); n < i.length; n++)
      t.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(r, i[n]) && (e[i[n]] = r[i[n]]);
  return e;
}
var qo = (
  /** @class */
  function() {
    function r(t, e) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new Ve("setRealSize"), this.onUpdate = new Ve("update"), this.onError = new Ve("onError");
    }
    return r.prototype.bind = function(t) {
      this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height);
    }, r.prototype.unbind = function(t) {
      this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t);
    }, r.prototype.resize = function(t, e) {
      (t !== this._width || e !== this._height) && (this._width = t, this._height = e, this.onResize.emit(t, e));
    }, Object.defineProperty(r.prototype, "valid", {
      /**
       * Has been validated
       * @readonly
       */
      get: function() {
        return !!this._width && !!this._height;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.update = function() {
      this.destroyed || this.onUpdate.emit();
    }, r.prototype.load = function() {
      return Promise.resolve(this);
    }, Object.defineProperty(r.prototype, "width", {
      /**
       * The width of the resource.
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "height", {
      /**
       * The height of the resource.
       * @readonly
       */
      get: function() {
        return this._height;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.style = function(t, e, i) {
      return !1;
    }, r.prototype.dispose = function() {
    }, r.prototype.destroy = function() {
      this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
    }, r.test = function(t, e) {
      return !1;
    }, r;
  }()
), Qo = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e, i) {
      var n = this, s = i || {}, o = s.width, a = s.height;
      if (!o || !a)
        throw new Error("BufferResource width or height invalid");
      return n = r.call(this, o, a) || this, n.data = e, n;
    }
    return t.prototype.upload = function(e, i, n) {
      var s = e.gl;
      s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.alphaMode === xr.UNPACK);
      var o = i.realWidth, a = i.realHeight;
      return n.width === o && n.height === a ? s.texSubImage2D(i.target, 0, 0, 0, o, a, i.format, n.type, this.data) : (n.width = o, n.height = a, s.texImage2D(i.target, 0, n.internalFormat, o, a, 0, i.format, n.type, this.data)), !0;
    }, t.prototype.dispose = function() {
      this.data = null;
    }, t.test = function(e) {
      return e instanceof Float32Array || e instanceof Uint8Array || e instanceof Uint32Array;
    }, t;
  }(qo)
), lP = {
  scaleMode: Vr.NEAREST,
  format: W.RGBA,
  alphaMode: xr.NPM
}, Mt = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e, i) {
      e === void 0 && (e = null), i === void 0 && (i = null);
      var n = r.call(this) || this;
      i = i || {};
      var s = i.alphaMode, o = i.mipmap, a = i.anisotropicLevel, l = i.scaleMode, u = i.width, c = i.height, d = i.wrapMode, f = i.format, v = i.type, m = i.target, p = i.resolution, y = i.resourceOptions;
      return e && !(e instanceof qo) && (e = Mv(e, y), e.internal = !0), n.resolution = p || J.RESOLUTION, n.width = Math.round((u || 0) * n.resolution) / n.resolution, n.height = Math.round((c || 0) * n.resolution) / n.resolution, n._mipmap = o !== void 0 ? o : J.MIPMAP_TEXTURES, n.anisotropicLevel = a !== void 0 ? a : J.ANISOTROPIC_LEVEL, n._wrapMode = d || J.WRAP_MODE, n._scaleMode = l !== void 0 ? l : J.SCALE_MODE, n.format = f || W.RGBA, n.type = v || ct.UNSIGNED_BYTE, n.target = m || zo.TEXTURE_2D, n.alphaMode = s !== void 0 ? s : xr.UNPACK, n.uid = Yo(), n.touched = 0, n.isPowerOfTwo = !1, n._refreshPOT(), n._glTextures = {}, n.dirtyId = 0, n.dirtyStyleId = 0, n.cacheId = null, n.valid = u > 0 && c > 0, n.textureCacheIds = [], n.destroyed = !1, n.resource = null, n._batchEnabled = 0, n._batchLocation = 0, n.parentTextureArray = null, n.setResource(e), n;
    }
    return Object.defineProperty(t.prototype, "realWidth", {
      /**
       * Pixel width of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.width * this.resolution);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "realHeight", {
      /**
       * Pixel height of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.height * this.resolution);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "mipmap", {
      /**
       * Mipmap mode of the texture, affects downscaled images
       * @default PIXI.settings.MIPMAP_TEXTURES
       */
      get: function() {
        return this._mipmap;
      },
      set: function(e) {
        this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "scaleMode", {
      /**
       * The scale mode to apply when scaling this texture
       * @default PIXI.settings.SCALE_MODE
       */
      get: function() {
        return this._scaleMode;
      },
      set: function(e) {
        this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "wrapMode", {
      /**
       * How the texture wraps
       * @default PIXI.settings.WRAP_MODE
       */
      get: function() {
        return this._wrapMode;
      },
      set: function(e) {
        this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++);
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.setStyle = function(e, i) {
      var n;
      return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e, n = !0), i !== void 0 && i !== this.mipmap && (this.mipmap = i, n = !0), n && this.dirtyStyleId++, this;
    }, t.prototype.setSize = function(e, i, n) {
      return n = n || this.resolution, this.setRealSize(e * n, i * n, n);
    }, t.prototype.setRealSize = function(e, i, n) {
      return this.resolution = n || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(i) / this.resolution, this._refreshPOT(), this.update(), this;
    }, t.prototype._refreshPOT = function() {
      this.isPowerOfTwo = lg(this.realWidth) && lg(this.realHeight);
    }, t.prototype.setResolution = function(e) {
      var i = this.resolution;
      return i === e ? this : (this.resolution = e, this.valid && (this.width = Math.round(this.width * i) / e, this.height = Math.round(this.height * i) / e, this.emit("update", this)), this._refreshPOT(), this);
    }, t.prototype.setResource = function(e) {
      if (this.resource === e)
        return this;
      if (this.resource)
        throw new Error("Resource can be set only once");
      return e.bind(this), this.resource = e, this;
    }, t.prototype.update = function() {
      this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this));
    }, t.prototype.onError = function(e) {
      this.emit("error", this, e);
    }, t.prototype.destroy = function() {
      this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete an[this.cacheId], delete li[this.cacheId], this.cacheId = null), this.dispose(), t.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0;
    }, t.prototype.dispose = function() {
      this.emit("dispose", this);
    }, t.prototype.castToBaseTexture = function() {
      return this;
    }, t.from = function(e, i, n) {
      n === void 0 && (n = J.STRICT_TEXTURE_CACHE);
      var s = typeof e == "string", o = null;
      if (s)
        o = e;
      else {
        if (!e._pixiId) {
          var a = i && i.pixiIdPrefix || "pixiid";
          e._pixiId = a + "_" + Yo();
        }
        o = e._pixiId;
      }
      var l = an[o];
      if (s && n && !l)
        throw new Error('The cacheId "' + o + '" does not exist in BaseTextureCache.');
      return l || (l = new t(e, i), l.cacheId = o, t.addToCache(l, o)), l;
    }, t.fromBuffer = function(e, i, n, s) {
      e = e || new Float32Array(i * n * 4);
      var o = new Qo(e, { width: i, height: n }), a = e instanceof Float32Array ? ct.FLOAT : ct.UNSIGNED_BYTE;
      return new t(o, Object.assign({}, lP, s || { width: i, height: n, type: a }));
    }, t.addToCache = function(e, i) {
      i && (e.textureCacheIds.indexOf(i) === -1 && e.textureCacheIds.push(i), an[i] && console.warn("BaseTexture added to the cache with an id [" + i + "] that already had an entry"), an[i] = e);
    }, t.removeFromCache = function(e) {
      if (typeof e == "string") {
        var i = an[e];
        if (i) {
          var n = i.textureCacheIds.indexOf(e);
          return n > -1 && i.textureCacheIds.splice(n, 1), delete an[e], i;
        }
      } else if (e && e.textureCacheIds) {
        for (var s = 0; s < e.textureCacheIds.length; ++s)
          delete an[e.textureCacheIds[s]];
        return e.textureCacheIds.length = 0, e;
      }
      return null;
    }, t._globalBatch = 0, t;
  }(Zi)
), Rv = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e, i) {
      var n = this, s = i || {}, o = s.width, a = s.height;
      n = r.call(this, o, a) || this, n.items = [], n.itemDirtyIds = [];
      for (var l = 0; l < e; l++) {
        var u = new Mt();
        n.items.push(u), n.itemDirtyIds.push(-2);
      }
      return n.length = e, n._load = null, n.baseTexture = null, n;
    }
    return t.prototype.initFromArray = function(e, i) {
      for (var n = 0; n < this.length; n++)
        e[n] && (e[n].castToBaseTexture ? this.addBaseTextureAt(e[n].castToBaseTexture(), n) : e[n] instanceof qo ? this.addResourceAt(e[n], n) : this.addResourceAt(Mv(e[n], i), n));
    }, t.prototype.dispose = function() {
      for (var e = 0, i = this.length; e < i; e++)
        this.items[e].destroy();
      this.items = null, this.itemDirtyIds = null, this._load = null;
    }, t.prototype.addResourceAt = function(e, i) {
      if (!this.items[i])
        throw new Error("Index " + i + " is out of bounds");
      return e.valid && !this.valid && this.resize(e.width, e.height), this.items[i].setResource(e), this;
    }, t.prototype.bind = function(e) {
      if (this.baseTexture !== null)
        throw new Error("Only one base texture per TextureArray is allowed");
      r.prototype.bind.call(this, e);
      for (var i = 0; i < this.length; i++)
        this.items[i].parentTextureArray = e, this.items[i].on("update", e.update, e);
    }, t.prototype.unbind = function(e) {
      r.prototype.unbind.call(this, e);
      for (var i = 0; i < this.length; i++)
        this.items[i].parentTextureArray = null, this.items[i].off("update", e.update, e);
    }, t.prototype.load = function() {
      var e = this;
      if (this._load)
        return this._load;
      var i = this.items.map(function(s) {
        return s.resource;
      }).filter(function(s) {
        return s;
      }), n = i.map(function(s) {
        return s.load();
      });
      return this._load = Promise.all(n).then(function() {
        var s = e.items[0], o = s.realWidth, a = s.realHeight;
        return e.resize(o, a), Promise.resolve(e);
      }), this._load;
    }, t;
  }(qo)
), Jm = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e, i) {
      var n = this, s = i || {}, o = s.width, a = s.height, l, u;
      return Array.isArray(e) ? (l = e, u = e.length) : u = e, n = r.call(this, u, { width: o, height: a }) || this, l && n.initFromArray(l, i), n;
    }
    return t.prototype.addBaseTextureAt = function(e, i) {
      if (e.resource)
        this.addResourceAt(e.resource, i);
      else
        throw new Error("ArrayResource does not support RenderTexture");
      return this;
    }, t.prototype.bind = function(e) {
      r.prototype.bind.call(this, e), e.target = zo.TEXTURE_2D_ARRAY;
    }, t.prototype.upload = function(e, i, n) {
      var s = this, o = s.length, a = s.itemDirtyIds, l = s.items, u = e.gl;
      n.dirtyId < 0 && u.texImage3D(u.TEXTURE_2D_ARRAY, 0, n.internalFormat, this._width, this._height, o, 0, i.format, n.type, null);
      for (var c = 0; c < o; c++) {
        var d = l[c];
        a[c] < d.dirtyId && (a[c] = d.dirtyId, d.valid && u.texSubImage3D(
          u.TEXTURE_2D_ARRAY,
          0,
          0,
          // xoffset
          0,
          // yoffset
          c,
          // zoffset
          d.resource.width,
          d.resource.height,
          1,
          i.format,
          n.type,
          d.resource.source
        ));
      }
      return !0;
    }, t;
  }(Rv)
), Zr = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e) {
      var i = this, n = e, s = n.naturalWidth || n.videoWidth || n.width, o = n.naturalHeight || n.videoHeight || n.height;
      return i = r.call(this, s, o) || this, i.source = e, i.noSubImage = !1, i;
    }
    return t.crossOrigin = function(e, i, n) {
      n === void 0 && i.indexOf("data:") !== 0 ? e.crossOrigin = QS(i) : n !== !1 && (e.crossOrigin = typeof n == "string" ? n : "anonymous");
    }, t.prototype.upload = function(e, i, n, s) {
      var o = e.gl, a = i.realWidth, l = i.realHeight;
      if (s = s || this.source, s instanceof HTMLImageElement) {
        if (!s.complete || s.naturalWidth === 0)
          return !1;
      } else if (s instanceof HTMLVideoElement && s.readyState <= 1)
        return !1;
      return o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.alphaMode === xr.UNPACK), !this.noSubImage && i.target === o.TEXTURE_2D && n.width === a && n.height === l ? o.texSubImage2D(o.TEXTURE_2D, 0, 0, 0, i.format, n.type, s) : (n.width = a, n.height = l, o.texImage2D(i.target, 0, n.internalFormat, i.format, n.type, s)), !0;
    }, t.prototype.update = function() {
      if (!this.destroyed) {
        var e = this.source, i = e.naturalWidth || e.videoWidth || e.width, n = e.naturalHeight || e.videoHeight || e.height;
        this.resize(i, n), r.prototype.update.call(this);
      }
    }, t.prototype.dispose = function() {
      this.source = null;
    }, t;
  }(qo)
), Qm = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e) {
      return r.call(this, e) || this;
    }
    return t.test = function(e) {
      var i = globalThis.OffscreenCanvas;
      return i && e instanceof i ? !0 : globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement;
    }, t;
  }(Zr)
), t_ = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e, i) {
      var n = this, s = i || {}, o = s.width, a = s.height, l = s.autoLoad, u = s.linkBaseTexture;
      if (e && e.length !== t.SIDES)
        throw new Error("Invalid length. Got " + e.length + ", expected 6");
      n = r.call(this, 6, { width: o, height: a }) || this;
      for (var c = 0; c < t.SIDES; c++)
        n.items[c].target = zo.TEXTURE_CUBE_MAP_POSITIVE_X + c;
      return n.linkBaseTexture = u !== !1, e && n.initFromArray(e, i), l !== !1 && n.load(), n;
    }
    return t.prototype.bind = function(e) {
      r.prototype.bind.call(this, e), e.target = zo.TEXTURE_CUBE_MAP;
    }, t.prototype.addBaseTextureAt = function(e, i, n) {
      if (!this.items[i])
        throw new Error("Index " + i + " is out of bounds");
      if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)
        if (e.resource)
          this.addResourceAt(e.resource, i);
        else
          throw new Error("CubeResource does not support copying of renderTexture.");
      else
        e.target = zo.TEXTURE_CUBE_MAP_POSITIVE_X + i, e.parentTextureArray = this.baseTexture, this.items[i] = e;
      return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[i] = e, this;
    }, t.prototype.upload = function(e, i, n) {
      for (var s = this.itemDirtyIds, o = 0; o < t.SIDES; o++) {
        var a = this.items[o];
        (s[o] < a.dirtyId || n.dirtyId < i.dirtyId) && (a.valid && a.resource ? (a.resource.upload(e, a, n), s[o] = a.dirtyId) : s[o] < -1 && (e.gl.texImage2D(a.target, 0, n.internalFormat, i.realWidth, i.realHeight, 0, i.format, n.type, null), s[o] = -1));
      }
      return !0;
    }, t.test = function(e) {
      return Array.isArray(e) && e.length === t.SIDES;
    }, t.SIDES = 6, t;
  }(Rv)
), kv = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e, i) {
      var n = this;
      if (i = i || {}, !(e instanceof HTMLImageElement)) {
        var s = new Image();
        Zr.crossOrigin(s, e, i.crossorigin), s.src = e, e = s;
      }
      return n = r.call(this, e) || this, !e.complete && n._width && n._height && (n._width = 0, n._height = 0), n.url = e.src, n._process = null, n.preserveBitmap = !1, n.createBitmap = (i.createBitmap !== void 0 ? i.createBitmap : J.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, n.alphaMode = typeof i.alphaMode == "number" ? i.alphaMode : null, n.bitmap = null, n._load = null, i.autoLoad !== !1 && n.load(), n;
    }
    return t.prototype.load = function(e) {
      var i = this;
      return this._load ? this._load : (e !== void 0 && (this.createBitmap = e), this._load = new Promise(function(n, s) {
        var o = i.source;
        i.url = o.src;
        var a = function() {
          i.destroyed || (o.onload = null, o.onerror = null, i.resize(o.width, o.height), i._load = null, i.createBitmap ? n(i.process()) : n(i));
        };
        o.complete && o.src ? a() : (o.onload = a, o.onerror = function(l) {
          s(l), i.onError.emit(l);
        });
      }), this._load);
    }, t.prototype.process = function() {
      var e = this, i = this.source;
      if (this._process !== null)
        return this._process;
      if (this.bitmap !== null || !globalThis.createImageBitmap)
        return Promise.resolve(this);
      var n = globalThis.createImageBitmap, s = !i.crossOrigin || i.crossOrigin === "anonymous";
      return this._process = fetch(i.src, {
        mode: s ? "cors" : "no-cors"
      }).then(function(o) {
        return o.blob();
      }).then(function(o) {
        return n(o, 0, 0, i.width, i.height, {
          premultiplyAlpha: e.alphaMode === null || e.alphaMode === xr.UNPACK ? "premultiply" : "none"
        });
      }).then(function(o) {
        return e.destroyed ? Promise.reject() : (e.bitmap = o, e.update(), e._process = null, Promise.resolve(e));
      }), this._process;
    }, t.prototype.upload = function(e, i, n) {
      if (typeof this.alphaMode == "number" && (i.alphaMode = this.alphaMode), !this.createBitmap)
        return r.prototype.upload.call(this, e, i, n);
      if (!this.bitmap && (this.process(), !this.bitmap))
        return !1;
      if (r.prototype.upload.call(this, e, i, n, this.bitmap), !this.preserveBitmap) {
        var s = !0, o = i._glTextures;
        for (var a in o) {
          var l = o[a];
          if (l !== n && l.dirtyId !== i.dirtyId) {
            s = !1;
            break;
          }
        }
        s && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
      }
      return !0;
    }, t.prototype.dispose = function() {
      this.source.onload = null, this.source.onerror = null, r.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
    }, t.test = function(e) {
      return typeof e == "string" || e instanceof HTMLImageElement;
    }, t;
  }(Zr)
), e_ = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e, i) {
      var n = this;
      return i = i || {}, n = r.call(this, J.ADAPTER.createCanvas()) || this, n._width = 0, n._height = 0, n.svg = e, n.scale = i.scale || 1, n._overrideWidth = i.width, n._overrideHeight = i.height, n._resolve = null, n._crossorigin = i.crossorigin, n._load = null, i.autoLoad !== !1 && n.load(), n;
    }
    return t.prototype.load = function() {
      var e = this;
      return this._load ? this._load : (this._load = new Promise(function(i) {
        if (e._resolve = function() {
          e.resize(e.source.width, e.source.height), i(e);
        }, t.SVG_XML.test(e.svg.trim())) {
          if (!btoa)
            throw new Error("Your browser doesn't support base64 conversions.");
          e.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(e.svg)));
        }
        e._loadSvg();
      }), this._load);
    }, t.prototype._loadSvg = function() {
      var e = this, i = new Image();
      Zr.crossOrigin(i, this.svg, this._crossorigin), i.src = this.svg, i.onerror = function(n) {
        e._resolve && (i.onerror = null, e.onError.emit(n));
      }, i.onload = function() {
        if (e._resolve) {
          var n = i.width, s = i.height;
          if (!n || !s)
            throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
          var o = n * e.scale, a = s * e.scale;
          (e._overrideWidth || e._overrideHeight) && (o = e._overrideWidth || e._overrideHeight / s * n, a = e._overrideHeight || e._overrideWidth / n * s), o = Math.round(o), a = Math.round(a);
          var l = e.source;
          l.width = o, l.height = a, l._pixiId = "canvas_" + Yo(), l.getContext("2d").drawImage(i, 0, 0, n, s, 0, 0, o, a), e._resolve(), e._resolve = null;
        }
      };
    }, t.getSize = function(e) {
      var i = t.SVG_SIZE.exec(e), n = {};
      return i && (n[i[1]] = Math.round(parseFloat(i[3])), n[i[5]] = Math.round(parseFloat(i[7]))), n;
    }, t.prototype.dispose = function() {
      r.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;
    }, t.test = function(e, i) {
      return i === "svg" || typeof e == "string" && e.startsWith("data:image/svg+xml") || typeof e == "string" && t.SVG_XML.test(e);
    }, t.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, t.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, t;
  }(Zr)
), i_ = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e, i) {
      var n = this;
      if (i = i || {}, !(e instanceof HTMLVideoElement)) {
        var s = document.createElement("video");
        s.setAttribute("preload", "auto"), s.setAttribute("webkit-playsinline", ""), s.setAttribute("playsinline", ""), typeof e == "string" && (e = [e]);
        var o = e[0].src || e[0];
        Zr.crossOrigin(s, o, i.crossorigin);
        for (var a = 0; a < e.length; ++a) {
          var l = document.createElement("source"), u = e[a], c = u.src, d = u.mime;
          c = c || e[a];
          var f = c.split("?").shift().toLowerCase(), v = f.slice(f.lastIndexOf(".") + 1);
          d = d || t.MIME_TYPES[v] || "video/" + v, l.src = c, l.type = d, s.appendChild(l);
        }
        e = s;
      }
      return n = r.call(this, e) || this, n.noSubImage = !0, n._autoUpdate = !0, n._isConnectedToTicker = !1, n._updateFPS = i.updateFPS || 0, n._msToNextUpdate = 0, n.autoPlay = i.autoPlay !== !1, n._load = null, n._resolve = null, n._onCanPlay = n._onCanPlay.bind(n), n._onError = n._onError.bind(n), i.autoLoad !== !1 && n.load(), n;
    }
    return t.prototype.update = function(e) {
      if (!this.destroyed) {
        var i = _e.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - i), (!this._updateFPS || this._msToNextUpdate <= 0) && (r.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
      }
    }, t.prototype.load = function() {
      var e = this;
      if (this._load)
        return this._load;
      var i = this.source;
      return (i.readyState === i.HAVE_ENOUGH_DATA || i.readyState === i.HAVE_FUTURE_DATA) && i.width && i.height && (i.complete = !0), i.addEventListener("play", this._onPlayStart.bind(this)), i.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (i.addEventListener("canplay", this._onCanPlay), i.addEventListener("canplaythrough", this._onCanPlay), i.addEventListener("error", this._onError, !0)), this._load = new Promise(function(n) {
        e.valid ? n(e) : (e._resolve = n, i.load());
      }), this._load;
    }, t.prototype._onError = function(e) {
      this.source.removeEventListener("error", this._onError, !0), this.onError.emit(e);
    }, t.prototype._isSourcePlaying = function() {
      var e = this.source;
      return !e.paused && !e.ended && this._isSourceReady();
    }, t.prototype._isSourceReady = function() {
      var e = this.source;
      return e.readyState > 2;
    }, t.prototype._onPlayStart = function() {
      this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (_e.shared.add(this.update, this), this._isConnectedToTicker = !0);
    }, t.prototype._onPlayStop = function() {
      this._isConnectedToTicker && (_e.shared.remove(this.update, this), this._isConnectedToTicker = !1);
    }, t.prototype._onCanPlay = function() {
      var e = this.source;
      e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlay);
      var i = this.valid;
      this.resize(e.videoWidth, e.videoHeight), !i && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play();
    }, t.prototype.dispose = function() {
      this._isConnectedToTicker && (_e.shared.remove(this.update, this), this._isConnectedToTicker = !1);
      var e = this.source;
      e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), r.prototype.dispose.call(this);
    }, Object.defineProperty(t.prototype, "autoUpdate", {
      /** Should the base texture automatically update itself, set to true by default. */
      get: function() {
        return this._autoUpdate;
      },
      set: function(e) {
        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (_e.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (_e.shared.add(this.update, this), this._isConnectedToTicker = !0));
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "updateFPS", {
      /**
       * How many times a second to update the texture from the video. Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       */
      get: function() {
        return this._updateFPS;
      },
      set: function(e) {
        e !== this._updateFPS && (this._updateFPS = e);
      },
      enumerable: !1,
      configurable: !0
    }), t.test = function(e, i) {
      return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || t.TYPES.indexOf(i) > -1;
    }, t.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], t.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    }, t;
  }(Zr)
), r_ = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e) {
      return r.call(this, e) || this;
    }
    return t.test = function(e) {
      return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && e instanceof ImageBitmap;
    }, t;
  }(Zr)
);
Ol.push(kv, r_, Qm, i_, e_, Qo, t_, Jm);
var Y0 = {
  __proto__: null,
  Resource: qo,
  BaseImageResource: Zr,
  INSTALLED: Ol,
  autoDetectResource: Mv,
  AbstractMultiResource: Rv,
  ArrayResource: Jm,
  BufferResource: Qo,
  CanvasResource: Qm,
  CubeResource: t_,
  ImageResource: kv,
  SVGResource: e_,
  VideoResource: i_,
  ImageBitmapResource: r_
}, uP = (
  /** @class */
  function(r) {
    se(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.upload = function(e, i, n) {
      var s = e.gl;
      s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.alphaMode === xr.UNPACK);
      var o = i.realWidth, a = i.realHeight;
      return n.width === o && n.height === a ? s.texSubImage2D(i.target, 0, 0, 0, o, a, i.format, n.type, this.data) : (n.width = o, n.height = a, s.texImage2D(i.target, 0, n.internalFormat, o, a, 0, i.format, n.type, this.data)), !0;
    }, t;
  }(Qo)
), Qf = (
  /** @class */
  function() {
    function r(t, e) {
      this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Ve("disposeFramebuffer"), this.multisample = ue.NONE;
    }
    return Object.defineProperty(r.prototype, "colorTexture", {
      /**
       * Reference to the colorTexture.
       * @readonly
       */
      get: function() {
        return this.colorTextures[0];
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.addColorTexture = function(t, e) {
      return t === void 0 && (t = 0), this.colorTextures[t] = e || new Mt(null, {
        scaleMode: Vr.NEAREST,
        resolution: 1,
        mipmap: br.OFF,
        width: this.width,
        height: this.height
      }), this.dirtyId++, this.dirtyFormat++, this;
    }, r.prototype.addDepthTexture = function(t) {
      return this.depthTexture = t || new Mt(new uP(null, { width: this.width, height: this.height }), {
        scaleMode: Vr.NEAREST,
        resolution: 1,
        width: this.width,
        height: this.height,
        mipmap: br.OFF,
        format: W.DEPTH_COMPONENT,
        type: ct.UNSIGNED_SHORT
      }), this.dirtyId++, this.dirtyFormat++, this;
    }, r.prototype.enableDepth = function() {
      return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;
    }, r.prototype.enableStencil = function() {
      return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;
    }, r.prototype.resize = function(t, e) {
      if (t = Math.round(t), e = Math.round(e), !(t === this.width && e === this.height)) {
        this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;
        for (var i = 0; i < this.colorTextures.length; i++) {
          var n = this.colorTextures[i], s = n.resolution;
          n.setSize(t / s, e / s);
        }
        if (this.depthTexture) {
          var s = this.depthTexture.resolution;
          this.depthTexture.setSize(t / s, e / s);
        }
      }
    }, r.prototype.dispose = function() {
      this.disposeRunner.emit(this, !1);
    }, r.prototype.destroyDepthTexture = function() {
      this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
    }, r;
  }()
), n_ = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e) {
      e === void 0 && (e = {});
      var i = this;
      if (typeof e == "number") {
        var n = arguments[0], s = arguments[1], o = arguments[2], a = arguments[3];
        e = { width: n, height: s, scaleMode: o, resolution: a };
      }
      return e.width = e.width || 100, e.height = e.height || 100, e.multisample = e.multisample !== void 0 ? e.multisample : ue.NONE, i = r.call(this, null, e) || this, i.mipmap = br.OFF, i.valid = !0, i.clearColor = [0, 0, 0, 0], i.framebuffer = new Qf(i.realWidth, i.realHeight).addColorTexture(0, i), i.framebuffer.multisample = e.multisample, i.maskStack = [], i.filterStack = [{}], i;
    }
    return t.prototype.resize = function(e, i) {
      this.framebuffer.resize(e * this.resolution, i * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
    }, t.prototype.dispose = function() {
      this.framebuffer.dispose(), r.prototype.dispose.call(this);
    }, t.prototype.destroy = function() {
      r.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
    }, t;
  }(Mt)
), s_ = (
  /** @class */
  function() {
    function r() {
      this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
    }
    return r.prototype.set = function(t, e, i) {
      var n = e.width, s = e.height;
      if (i) {
        var o = t.width / 2 / n, a = t.height / 2 / s, l = t.x / n + o, u = t.y / s + a;
        i = pe.add(i, pe.NW), this.x0 = l + o * pe.uX(i), this.y0 = u + a * pe.uY(i), i = pe.add(i, 2), this.x1 = l + o * pe.uX(i), this.y1 = u + a * pe.uY(i), i = pe.add(i, 2), this.x2 = l + o * pe.uX(i), this.y2 = u + a * pe.uY(i), i = pe.add(i, 2), this.x3 = l + o * pe.uX(i), this.y3 = u + a * pe.uY(i);
      } else
        this.x0 = t.x / n, this.y0 = t.y / s, this.x1 = (t.x + t.width) / n, this.y1 = t.y / s, this.x2 = (t.x + t.width) / n, this.y2 = (t.y + t.height) / s, this.x3 = t.x / n, this.y3 = (t.y + t.height) / s;
      this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
    }, r.prototype.toString = function() {
      return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
    }, r;
  }()
), vg = new s_();
function Gc(r) {
  r.destroy = function() {
  }, r.on = function() {
  }, r.once = function() {
  }, r.emit = function() {
  };
}
var ut = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e, i, n, s, o, a) {
      var l = r.call(this) || this;
      if (l.noFrame = !1, i || (l.noFrame = !0, i = new pt(0, 0, 1, 1)), e instanceof t && (e = e.baseTexture), l.baseTexture = e, l._frame = i, l.trim = s, l.valid = !1, l._uvs = vg, l.uvMatrix = null, l.orig = n || i, l._rotate = Number(o || 0), o === !0)
        l._rotate = 2;
      else if (l._rotate % 2 !== 0)
        throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
      return l.defaultAnchor = a ? new te(a.x, a.y) : new te(0, 0), l._updateID = 0, l.textureCacheIds = [], e.valid ? l.noFrame ? e.valid && l.onBaseTextureUpdated(e) : l.frame = i : e.once("loaded", l.onBaseTextureUpdated, l), l.noFrame && e.on("update", l.onBaseTextureUpdated, l), l;
    }
    return t.prototype.update = function() {
      this.baseTexture.resource && this.baseTexture.resource.update();
    }, t.prototype.onBaseTextureUpdated = function(e) {
      if (this.noFrame) {
        if (!this.baseTexture.valid)
          return;
        this._frame.width = e.width, this._frame.height = e.height, this.valid = !0, this.updateUvs();
      } else
        this.frame = this._frame;
      this.emit("update", this);
    }, t.prototype.destroy = function(e) {
      if (this.baseTexture) {
        if (e) {
          var i = this.baseTexture.resource;
          i && i.url && li[i.url] && t.removeFromCache(i.url), this.baseTexture.destroy();
        }
        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
      }
      this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, t.removeFromCache(this), this.textureCacheIds = null;
    }, t.prototype.clone = function() {
      var e = this._frame.clone(), i = this._frame === this.orig ? e : this.orig.clone(), n = new t(this.baseTexture, !this.noFrame && e, i, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
      return this.noFrame && (n._frame = e), n;
    }, t.prototype.updateUvs = function() {
      this._uvs === vg && (this._uvs = new s_()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
    }, t.from = function(e, i, n) {
      i === void 0 && (i = {}), n === void 0 && (n = J.STRICT_TEXTURE_CACHE);
      var s = typeof e == "string", o = null;
      if (s)
        o = e;
      else if (e instanceof Mt) {
        if (!e.cacheId) {
          var a = i && i.pixiIdPrefix || "pixiid";
          e.cacheId = a + "-" + Yo(), Mt.addToCache(e, e.cacheId);
        }
        o = e.cacheId;
      } else {
        if (!e._pixiId) {
          var a = i && i.pixiIdPrefix || "pixiid";
          e._pixiId = a + "_" + Yo();
        }
        o = e._pixiId;
      }
      var l = li[o];
      if (s && n && !l)
        throw new Error('The cacheId "' + o + '" does not exist in TextureCache.');
      return !l && !(e instanceof Mt) ? (i.resolution || (i.resolution = Zf(e)), l = new t(new Mt(e, i)), l.baseTexture.cacheId = o, Mt.addToCache(l.baseTexture, o), t.addToCache(l, o)) : !l && e instanceof Mt && (l = new t(e), t.addToCache(l, o)), l;
    }, t.fromURL = function(e, i) {
      var n = Object.assign({ autoLoad: !1 }, i == null ? void 0 : i.resourceOptions), s = t.from(e, Object.assign({ resourceOptions: n }, i), !1), o = s.baseTexture.resource;
      return s.baseTexture.valid ? Promise.resolve(s) : o.load().then(function() {
        return Promise.resolve(s);
      });
    }, t.fromBuffer = function(e, i, n, s) {
      return new t(Mt.fromBuffer(e, i, n, s));
    }, t.fromLoader = function(e, i, n, s) {
      var o = new Mt(e, Object.assign({
        scaleMode: J.SCALE_MODE,
        resolution: Zf(i)
      }, s)), a = o.resource;
      a instanceof kv && (a.url = i);
      var l = new t(o);
      return n || (n = i), Mt.addToCache(l.baseTexture, n), t.addToCache(l, n), n !== i && (Mt.addToCache(l.baseTexture, i), t.addToCache(l, i)), l.baseTexture.valid ? Promise.resolve(l) : new Promise(function(u) {
        l.baseTexture.once("loaded", function() {
          return u(l);
        });
      });
    }, t.addToCache = function(e, i) {
      i && (e.textureCacheIds.indexOf(i) === -1 && e.textureCacheIds.push(i), li[i] && console.warn("Texture added to the cache with an id [" + i + "] that already had an entry"), li[i] = e);
    }, t.removeFromCache = function(e) {
      if (typeof e == "string") {
        var i = li[e];
        if (i) {
          var n = i.textureCacheIds.indexOf(e);
          return n > -1 && i.textureCacheIds.splice(n, 1), delete li[e], i;
        }
      } else if (e && e.textureCacheIds) {
        for (var s = 0; s < e.textureCacheIds.length; ++s)
          li[e.textureCacheIds[s]] === e && delete li[e.textureCacheIds[s]];
        return e.textureCacheIds.length = 0, e;
      }
      return null;
    }, Object.defineProperty(t.prototype, "resolution", {
      /**
       * Returns resolution of baseTexture
       * @readonly
       */
      get: function() {
        return this.baseTexture.resolution;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "frame", {
      /**
       * The frame specifies the region of the base texture that this texture uses.
       * Please call `updateUvs()` after you change coordinates of `frame` manually.
       */
      get: function() {
        return this._frame;
      },
      set: function(e) {
        this._frame = e, this.noFrame = !1;
        var i = e.x, n = e.y, s = e.width, o = e.height, a = i + s > this.baseTexture.width, l = n + o > this.baseTexture.height;
        if (a || l) {
          var u = a && l ? "and" : "or", c = "X: " + i + " + " + s + " = " + (i + s) + " > " + this.baseTexture.width, d = "Y: " + n + " + " + o + " = " + (n + o) + " > " + this.baseTexture.height;
          throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (c + " " + u + " " + d));
        }
        this.valid = s && o && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = e), this.valid && this.updateUvs();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "rotate", {
      /**
       * Indicates whether the texture is rotated inside the atlas
       * set to 2 to compensate for texture packer rotation
       * set to 6 to compensate for spine packer rotation
       * can be used to rotate or mirror sprites
       * See {@link PIXI.groupD8} for explanation
       */
      get: function() {
        return this._rotate;
      },
      set: function(e) {
        this._rotate = e, this.valid && this.updateUvs();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "width", {
      /** The width of the Texture in pixels. */
      get: function() {
        return this.orig.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the Texture in pixels. */
      get: function() {
        return this.orig.height;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.castToBaseTexture = function() {
      return this.baseTexture;
    }, Object.defineProperty(t, "EMPTY", {
      /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */
      get: function() {
        return t._EMPTY || (t._EMPTY = new t(new Mt()), Gc(t._EMPTY), Gc(t._EMPTY.baseTexture)), t._EMPTY;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "WHITE", {
      /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */
      get: function() {
        if (!t._WHITE) {
          var e = J.ADAPTER.createCanvas(16, 16), i = e.getContext("2d");
          e.width = 16, e.height = 16, i.fillStyle = "white", i.fillRect(0, 0, 16, 16), t._WHITE = new t(Mt.from(e)), Gc(t._WHITE), Gc(t._WHITE.baseTexture);
        }
        return t._WHITE;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zi)
), Wi = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e, i) {
      var n = r.call(this, e, i) || this;
      return n.valid = !0, n.filterFrame = null, n.filterPoolKey = null, n.updateUvs(), n;
    }
    return Object.defineProperty(t.prototype, "framebuffer", {
      /**
       * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
       * @readonly
       */
      get: function() {
        return this.baseTexture.framebuffer;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "multisample", {
      /**
       * Shortcut to `this.framebuffer.multisample`.
       * @default PIXI.MSAA_QUALITY.NONE
       */
      get: function() {
        return this.framebuffer.multisample;
      },
      set: function(e) {
        this.framebuffer.multisample = e;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.resize = function(e, i, n) {
      n === void 0 && (n = !0);
      var s = this.baseTexture.resolution, o = Math.round(e * s) / s, a = Math.round(i * s) / s;
      this.valid = o > 0 && a > 0, this._frame.width = this.orig.width = o, this._frame.height = this.orig.height = a, n && this.baseTexture.resize(o, a), this.updateUvs();
    }, t.prototype.setResolution = function(e) {
      var i = this.baseTexture;
      i.resolution !== e && (i.setResolution(e), this.resize(i.width, i.height, !1));
    }, t.create = function(e) {
      for (var i = arguments, n = [], s = 1; s < arguments.length; s++)
        n[s - 1] = i[s];
      return typeof e == "number" && (ci("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), e = {
        width: e,
        height: n[0],
        scaleMode: n[1],
        resolution: n[2]
      }), new t(new n_(e));
    }, t;
  }(ut)
), q0 = (
  /** @class */
  function() {
    function r(t) {
      this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;
    }
    return r.prototype.createTexture = function(t, e, i) {
      i === void 0 && (i = ue.NONE);
      var n = new n_(Object.assign({
        width: t,
        height: e,
        resolution: 1,
        multisample: i
      }, this.textureOptions));
      return new Wi(n);
    }, r.prototype.getOptimalTexture = function(t, e, i, n) {
      i === void 0 && (i = 1), n === void 0 && (n = ue.NONE);
      var s;
      t = Math.ceil(t * i - 1e-6), e = Math.ceil(e * i - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || e !== this._pixelsHeight ? (t = qf(t), e = qf(e), s = ((t & 65535) << 16 | e & 65535) >>> 0, n > 1 && (s += n * 4294967296)) : s = n > 1 ? -n : -1, this.texturePool[s] || (this.texturePool[s] = []);
      var o = this.texturePool[s].pop();
      return o || (o = this.createTexture(t, e, n)), o.filterPoolKey = s, o.setResolution(i), o;
    }, r.prototype.getFilterTexture = function(t, e, i) {
      var n = this.getOptimalTexture(t.width, t.height, e || t.resolution, i || ue.NONE);
      return n.filterFrame = t.filterFrame, n;
    }, r.prototype.returnTexture = function(t) {
      var e = t.filterPoolKey;
      t.filterFrame = null, this.texturePool[e].push(t);
    }, r.prototype.returnFilterTexture = function(t) {
      this.returnTexture(t);
    }, r.prototype.clear = function(t) {
      if (t = t !== !1, t)
        for (var e in this.texturePool) {
          var i = this.texturePool[e];
          if (i)
            for (var n = 0; n < i.length; n++)
              i[n].destroy(!0);
        }
      this.texturePool = {};
    }, r.prototype.setScreenSize = function(t) {
      if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {
        this.enableFullScreen = t.width > 0 && t.height > 0;
        for (var e in this.texturePool)
          if (Number(e) < 0) {
            var i = this.texturePool[e];
            if (i)
              for (var n = 0; n < i.length; n++)
                i[n].destroy(!0);
            this.texturePool[e] = [];
          }
        this._pixelsWidth = t.width, this._pixelsHeight = t.height;
      }
    }, r.SCREEN_KEY = -1, r;
  }()
), Oy = (
  /** @class */
  function() {
    function r(t, e, i, n, s, o, a) {
      e === void 0 && (e = 0), i === void 0 && (i = !1), n === void 0 && (n = ct.FLOAT), this.buffer = t, this.size = e, this.normalized = i, this.type = n, this.stride = s, this.start = o, this.instance = a;
    }
    return r.prototype.destroy = function() {
      this.buffer = null;
    }, r.from = function(t, e, i, n, s) {
      return new r(t, e, i, n, s);
    }, r;
  }()
), cP = 0, Ce = (
  /** @class */
  function() {
    function r(t, e, i) {
      e === void 0 && (e = !0), i === void 0 && (i = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = i, this.static = e, this.id = cP++, this.disposeRunner = new Ve("disposeBuffer");
    }
    return r.prototype.update = function(t) {
      t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++;
    }, r.prototype.dispose = function() {
      this.disposeRunner.emit(this, !1);
    }, r.prototype.destroy = function() {
      this.dispose(), this.data = null;
    }, Object.defineProperty(r.prototype, "index", {
      get: function() {
        return this.type === Yr.ELEMENT_ARRAY_BUFFER;
      },
      /**
       * Flags whether this is an index buffer.
       *
       * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make
       * the buffer of type `ARRAY_BUFFER`.
       *
       * For backwards compatibility.
       */
      set: function(t) {
        this.type = t ? Yr.ELEMENT_ARRAY_BUFFER : Yr.ARRAY_BUFFER;
      },
      enumerable: !1,
      configurable: !0
    }), r.from = function(t) {
      return t instanceof Array && (t = new Float32Array(t)), new r(t);
    }, r;
  }()
), fP = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function dP(r, t) {
  for (var e = 0, i = 0, n = {}, s = 0; s < r.length; s++)
    i += t[s], e += r[s].length;
  for (var o = new ArrayBuffer(e * 4), a = null, l = 0, s = 0; s < r.length; s++) {
    var u = t[s], c = r[s], d = $0(c);
    n[d] || (n[d] = new fP[d](o)), a = n[d];
    for (var f = 0; f < c.length; f++) {
      var v = (f / u | 0) * i + l, m = f % u;
      a[v + m] = c[f];
    }
    l += u;
  }
  return new Float32Array(o);
}
var yg = { 5126: 4, 5123: 2, 5121: 1 }, pP = 0, vP = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
}, jh = (
  /** @class */
  function() {
    function r(t, e) {
      t === void 0 && (t = []), e === void 0 && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = pP++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new Ve("disposeGeometry"), this.refCount = 0;
    }
    return r.prototype.addAttribute = function(t, e, i, n, s, o, a, l) {
      if (i === void 0 && (i = 0), n === void 0 && (n = !1), l === void 0 && (l = !1), !e)
        throw new Error("You must pass a buffer when creating an attribute");
      e instanceof Ce || (e instanceof Array && (e = new Float32Array(e)), e = new Ce(e));
      var u = t.split("|");
      if (u.length > 1) {
        for (var c = 0; c < u.length; c++)
          this.addAttribute(u[c], e, i, n, s);
        return this;
      }
      var d = this.buffers.indexOf(e);
      return d === -1 && (this.buffers.push(e), d = this.buffers.length - 1), this.attributes[t] = new Oy(d, i, n, s, o, a, l), this.instanced = this.instanced || l, this;
    }, r.prototype.getAttribute = function(t) {
      return this.attributes[t];
    }, r.prototype.getBuffer = function(t) {
      return this.buffers[this.getAttribute(t).buffer];
    }, r.prototype.addIndex = function(t) {
      return t instanceof Ce || (t instanceof Array && (t = new Uint16Array(t)), t = new Ce(t)), t.type = Yr.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.indexOf(t) === -1 && this.buffers.push(t), this;
    }, r.prototype.getIndex = function() {
      return this.indexBuffer;
    }, r.prototype.interleave = function() {
      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
        return this;
      var t = [], e = [], i = new Ce(), n;
      for (n in this.attributes) {
        var s = this.attributes[n], o = this.buffers[s.buffer];
        t.push(o.data), e.push(s.size * yg[s.type] / 4), s.buffer = 0;
      }
      for (i.data = dP(t, e), n = 0; n < this.buffers.length; n++)
        this.buffers[n] !== this.indexBuffer && this.buffers[n].destroy();
      return this.buffers = [i], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
    }, r.prototype.getSize = function() {
      for (var t in this.attributes) {
        var e = this.attributes[t], i = this.buffers[e.buffer];
        return i.data.length / (e.stride / 4 || e.size);
      }
      return 0;
    }, r.prototype.dispose = function() {
      this.disposeRunner.emit(this, !1);
    }, r.prototype.destroy = function() {
      this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
    }, r.prototype.clone = function() {
      for (var t = new r(), e = 0; e < this.buffers.length; e++)
        t.buffers[e] = new Ce(this.buffers[e].data.slice(0));
      for (var e in this.attributes) {
        var i = this.attributes[e];
        t.attributes[e] = new Oy(i.buffer, i.size, i.normalized, i.type, i.stride, i.start, i.instance);
      }
      return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = Yr.ELEMENT_ARRAY_BUFFER), t;
    }, r.merge = function(t) {
      for (var e = new r(), i = [], n = [], s = [], o, a = 0; a < t.length; a++) {
        o = t[a];
        for (var l = 0; l < o.buffers.length; l++)
          n[l] = n[l] || 0, n[l] += o.buffers[l].data.length, s[l] = 0;
      }
      for (var a = 0; a < o.buffers.length; a++)
        i[a] = new vP[$0(o.buffers[a].data)](n[a]), e.buffers[a] = new Ce(i[a]);
      for (var a = 0; a < t.length; a++) {
        o = t[a];
        for (var l = 0; l < o.buffers.length; l++)
          i[l].set(o.buffers[l].data, s[l]), s[l] += o.buffers[l].data.length;
      }
      if (e.attributes = o.attributes, o.indexBuffer) {
        e.indexBuffer = e.buffers[o.buffers.indexOf(o.indexBuffer)], e.indexBuffer.type = Yr.ELEMENT_ARRAY_BUFFER;
        for (var u = 0, c = 0, d = 0, f = 0, a = 0; a < o.buffers.length; a++)
          if (o.buffers[a] !== o.indexBuffer) {
            f = a;
            break;
          }
        for (var a in o.attributes) {
          var v = o.attributes[a];
          (v.buffer | 0) === f && (c += v.size * yg[v.type] / 4);
        }
        for (var a = 0; a < t.length; a++) {
          for (var m = t[a].indexBuffer.data, l = 0; l < m.length; l++)
            e.indexBuffer.data[l + d] += u;
          u += t[a].buffers[f].data.length / c, d += m.length;
        }
      }
      return e;
    }, r;
  }()
), Z0 = (
  /** @class */
  function(r) {
    se(t, r);
    function t() {
      var e = r.call(this) || this;
      return e.addAttribute("aVertexPosition", new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ])).addIndex([0, 1, 3, 2]), e;
    }
    return t;
  }(jh)
), o_ = (
  /** @class */
  function(r) {
    se(t, r);
    function t() {
      var e = r.call(this) || this;
      return e.vertices = new Float32Array([
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1
      ]), e.uvs = new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]), e.vertexBuffer = new Ce(e.vertices), e.uvBuffer = new Ce(e.uvs), e.addAttribute("aVertexPosition", e.vertexBuffer).addAttribute("aTextureCoord", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e;
    }
    return t.prototype.map = function(e, i) {
      var n = 0, s = 0;
      return this.uvs[0] = n, this.uvs[1] = s, this.uvs[2] = n + i.width / e.width, this.uvs[3] = s, this.uvs[4] = n + i.width / e.width, this.uvs[5] = s + i.height / e.height, this.uvs[6] = n, this.uvs[7] = s + i.height / e.height, n = i.x, s = i.y, this.vertices[0] = n, this.vertices[1] = s, this.vertices[2] = n + i.width, this.vertices[3] = s, this.vertices[4] = n + i.width, this.vertices[5] = s + i.height, this.vertices[6] = n, this.vertices[7] = s + i.height, this.invalidate(), this;
    }, t.prototype.invalidate = function() {
      return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
    }, t;
  }(jh)
), yP = 0, ms = (
  /** @class */
  function() {
    function r(t, e, i) {
      this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = yP++, this.static = !!e, this.ubo = !!i, t instanceof Ce ? (this.buffer = t, this.buffer.type = Yr.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Ce(new Float32Array(1)), this.buffer.type = Yr.UNIFORM_BUFFER, this.autoManage = !0));
    }
    return r.prototype.update = function() {
      this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
    }, r.prototype.add = function(t, e, i) {
      if (!this.ubo)
        this.uniforms[t] = new r(e, i);
      else
        throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }, r.from = function(t, e, i) {
      return new r(t, e, i);
    }, r.uboFrom = function(t, e) {
      return new r(t, e ?? !0, !0);
    }, r;
  }()
), K0 = (
  /** @class */
  function() {
    function r() {
      this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = ue.NONE, this.sourceFrame = new pt(), this.destinationFrame = new pt(), this.bindingSourceFrame = new pt(), this.bindingDestinationFrame = new pt(), this.filters = [], this.transform = null;
    }
    return r.prototype.clear = function() {
      this.target = null, this.filters = null, this.renderTexture = null;
    }, r;
  }()
), jc = [new te(), new te(), new te(), new te()], Wv = new De(), a_ = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new q0(), this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new Z0(), this.quadUv = new o_(), this.tempRect = new pt(), this.activeState = {}, this.globalUniforms = new ms({
        outputFrame: new pt(),
        inputSize: new Float32Array(4),
        inputPixel: new Float32Array(4),
        inputClamp: new Float32Array(4),
        resolution: 1,
        // legacy variables
        filterArea: new Float32Array(4),
        filterClamp: new Float32Array(4)
      }, !0), this.forceClear = !1, this.useMaxPadding = !1;
    }
    return r.prototype.push = function(t, e) {
      for (var i, n, s = this.renderer, o = this.defaultFilterStack, a = this.statePool.pop() || new K0(), l = this.renderer.renderTexture, u = e[0].resolution, c = e[0].multisample, d = e[0].padding, f = e[0].autoFit, v = (i = e[0].legacy) !== null && i !== void 0 ? i : !0, m = 1; m < e.length; m++) {
        var p = e[m];
        u = Math.min(u, p.resolution), c = Math.min(c, p.multisample), d = this.useMaxPadding ? Math.max(d, p.padding) : d + p.padding, f = f && p.autoFit, v = v || ((n = p.legacy) !== null && n !== void 0 ? n : !0);
      }
      o.length === 1 && (this.defaultFilterStack[0].renderTexture = l.current), o.push(a), a.resolution = u, a.multisample = c, a.legacy = v, a.target = t, a.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), a.sourceFrame.pad(d);
      var y = this.tempRect.copyFrom(l.sourceFrame);
      s.projection.transform && this.transformAABB(Wv.copyFrom(s.projection.transform).invert(), y), f ? (a.sourceFrame.fit(y), (a.sourceFrame.width <= 0 || a.sourceFrame.height <= 0) && (a.sourceFrame.width = 0, a.sourceFrame.height = 0)) : a.sourceFrame.intersects(y) || (a.sourceFrame.width = 0, a.sourceFrame.height = 0), this.roundFrame(a.sourceFrame, l.current ? l.current.resolution : s.resolution, l.sourceFrame, l.destinationFrame, s.projection.transform), a.renderTexture = this.getOptimalFilterTexture(a.sourceFrame.width, a.sourceFrame.height, u, c), a.filters = e, a.destinationFrame.width = a.renderTexture.width, a.destinationFrame.height = a.renderTexture.height;
      var b = this.tempRect;
      b.x = 0, b.y = 0, b.width = a.sourceFrame.width, b.height = a.sourceFrame.height, a.renderTexture.filterFrame = a.sourceFrame, a.bindingSourceFrame.copyFrom(l.sourceFrame), a.bindingDestinationFrame.copyFrom(l.destinationFrame), a.transform = s.projection.transform, s.projection.transform = null, l.bind(a.renderTexture, a.sourceFrame, b), s.framebuffer.clear(0, 0, 0, 0);
    }, r.prototype.pop = function() {
      var t = this.defaultFilterStack, e = t.pop(), i = e.filters;
      this.activeState = e;
      var n = this.globalUniforms.uniforms;
      n.outputFrame = e.sourceFrame, n.resolution = e.resolution;
      var s = n.inputSize, o = n.inputPixel, a = n.inputClamp;
      if (s[0] = e.destinationFrame.width, s[1] = e.destinationFrame.height, s[2] = 1 / s[0], s[3] = 1 / s[1], o[0] = Math.round(s[0] * e.resolution), o[1] = Math.round(s[1] * e.resolution), o[2] = 1 / o[0], o[3] = 1 / o[1], a[0] = 0.5 * o[2], a[1] = 0.5 * o[3], a[2] = e.sourceFrame.width * s[2] - 0.5 * o[2], a[3] = e.sourceFrame.height * s[3] - 0.5 * o[3], e.legacy) {
        var l = n.filterArea;
        l[0] = e.destinationFrame.width, l[1] = e.destinationFrame.height, l[2] = e.sourceFrame.x, l[3] = e.sourceFrame.y, n.filterClamp = n.inputClamp;
      }
      this.globalUniforms.update();
      var u = t[t.length - 1];
      if (this.renderer.framebuffer.blit(), i.length === 1)
        i[0].apply(this, e.renderTexture, u.renderTexture, vr.BLEND, e), this.returnFilterTexture(e.renderTexture);
      else {
        var c = e.renderTexture, d = this.getOptimalFilterTexture(c.width, c.height, e.resolution);
        d.filterFrame = c.filterFrame;
        var f = 0;
        for (f = 0; f < i.length - 1; ++f) {
          f === 1 && e.multisample > 1 && (d = this.getOptimalFilterTexture(c.width, c.height, e.resolution), d.filterFrame = c.filterFrame), i[f].apply(this, c, d, vr.CLEAR, e);
          var v = c;
          c = d, d = v;
        }
        i[f].apply(this, c, u.renderTexture, vr.BLEND, e), f > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture(c), this.returnFilterTexture(d);
      }
      e.clear(), this.statePool.push(e);
    }, r.prototype.bindAndClear = function(t, e) {
      e === void 0 && (e = vr.CLEAR);
      var i = this.renderer, n = i.renderTexture, s = i.state;
      if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) {
        var o = this.tempRect;
        o.x = 0, o.y = 0, o.width = t.filterFrame.width, o.height = t.filterFrame.height, n.bind(t, t.filterFrame, o);
      } else
        t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? n.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
      var a = s.stateId & 1 || this.forceClear;
      (e === vr.CLEAR || e === vr.BLIT && a) && this.renderer.framebuffer.clear(0, 0, 0, 0);
    }, r.prototype.applyFilter = function(t, e, i, n) {
      var s = this.renderer;
      s.state.set(t.state), this.bindAndClear(i, n), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, s.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), s.geometry.bind(this.quadUv), s.geometry.draw(_r.TRIANGLES)) : (s.geometry.bind(this.quad), s.geometry.draw(_r.TRIANGLE_STRIP));
    }, r.prototype.calculateSpriteMatrix = function(t, e) {
      var i = this.activeState, n = i.sourceFrame, s = i.destinationFrame, o = e._texture.orig, a = t.set(s.width, 0, 0, s.height, n.x, n.y), l = e.worldTransform.copyTo(De.TEMP_MATRIX);
      return l.invert(), a.prepend(l), a.scale(1 / o.width, 1 / o.height), a.translate(e.anchor.x, e.anchor.y), a;
    }, r.prototype.destroy = function() {
      this.renderer = null, this.texturePool.clear(!1);
    }, r.prototype.getOptimalFilterTexture = function(t, e, i, n) {
      return i === void 0 && (i = 1), n === void 0 && (n = ue.NONE), this.texturePool.getOptimalTexture(t, e, i, n);
    }, r.prototype.getFilterTexture = function(t, e, i) {
      if (typeof t == "number") {
        var n = t;
        t = e, e = n;
      }
      t = t || this.activeState.renderTexture;
      var s = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, i || ue.NONE);
      return s.filterFrame = t.filterFrame, s;
    }, r.prototype.returnFilterTexture = function(t) {
      this.texturePool.returnTexture(t);
    }, r.prototype.emptyPool = function() {
      this.texturePool.clear(!0);
    }, r.prototype.resize = function() {
      this.texturePool.setScreenSize(this.renderer.view);
    }, r.prototype.transformAABB = function(t, e) {
      var i = jc[0], n = jc[1], s = jc[2], o = jc[3];
      i.set(e.left, e.top), n.set(e.left, e.bottom), s.set(e.right, e.top), o.set(e.right, e.bottom), t.apply(i, i), t.apply(n, n), t.apply(s, s), t.apply(o, o);
      var a = Math.min(i.x, n.x, s.x, o.x), l = Math.min(i.y, n.y, s.y, o.y), u = Math.max(i.x, n.x, s.x, o.x), c = Math.max(i.y, n.y, s.y, o.y);
      e.x = a, e.y = l, e.width = u - a, e.height = c - l;
    }, r.prototype.roundFrame = function(t, e, i, n, s) {
      if (!(t.width <= 0 || t.height <= 0 || i.width <= 0 || i.height <= 0)) {
        if (s) {
          var o = s.a, a = s.b, l = s.c, u = s.d;
          if ((Math.abs(a) > 1e-4 || Math.abs(l) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(u) > 1e-4))
            return;
        }
        s = s ? Wv.copyFrom(s) : Wv.identity(), s.translate(-i.x, -i.y).scale(n.width / i.width, n.height / i.height).translate(n.x, n.y), this.transformAABB(s, t), t.ceil(e), this.transformAABB(s.invert(), t);
      }
    }, r;
  }()
), Rc = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t;
    }
    return r.prototype.flush = function() {
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r.prototype.start = function() {
    }, r.prototype.stop = function() {
      this.flush();
    }, r.prototype.render = function(t) {
    }, r;
  }()
), h_ = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.emptyRenderer = new Rc(t), this.currentRenderer = this.emptyRenderer;
    }
    return r.prototype.setObjectRenderer = function(t) {
      this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start());
    }, r.prototype.flush = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, r.prototype.reset = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, r.prototype.copyBoundTextures = function(t, e) {
      for (var i = this.renderer.texture.boundTextures, n = e - 1; n >= 0; --n)
        t[n] = i[n] || null, t[n] && (t[n]._batchLocation = n);
    }, r.prototype.boundArray = function(t, e, i, n) {
      for (var s = t.elements, o = t.ids, a = t.count, l = 0, u = 0; u < a; u++) {
        var c = s[u], d = c._batchLocation;
        if (d >= 0 && d < n && e[d] === c) {
          o[u] = d;
          continue;
        }
        for (; l < n; ) {
          var f = e[l];
          if (f && f._batchEnabled === i && f._batchLocation === l) {
            l++;
            continue;
          }
          o[u] = l, c._batchLocation = l, e[l] = c;
          break;
        }
      }
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), mg = 0, l_ = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {
        uint32Indices: !1
      }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener("webglcontextlost", this.handleContextLost, !1), t.view.addEventListener("webglcontextrestored", this.handleContextRestored, !1);
    }
    return Object.defineProperty(r.prototype, "isLost", {
      /**
       * `true` if the context is lost
       * @readonly
       */
      get: function() {
        return !this.gl || this.gl.isContextLost();
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.contextChange = function(t) {
      this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = mg++;
    }, r.prototype.initFromContext = function(t) {
      this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = mg++, this.renderer.runners.contextChange.emit(t);
    }, r.prototype.initFromOptions = function(t) {
      var e = this.createContext(this.renderer.view, t);
      this.initFromContext(e);
    }, r.prototype.createContext = function(t, e) {
      var i;
      if (J.PREFER_ENV >= Bn.WEBGL2 && (i = t.getContext("webgl2", e)), i)
        this.webGLVersion = 2;
      else if (this.webGLVersion = 1, i = t.getContext("webgl", e) || t.getContext("experimental-webgl", e), !i)
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      return this.gl = i, this.getExtensions(), this.gl;
    }, r.prototype.getExtensions = function() {
      var t = this.gl, e = {
        loseContext: t.getExtension("WEBGL_lose_context"),
        anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
        floatTextureLinear: t.getExtension("OES_texture_float_linear"),
        s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: t.getExtension("WEBGL_compressed_texture_etc"),
        etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: t.getExtension("WEBGL_compressed_texture_atc"),
        astc: t.getExtension("WEBGL_compressed_texture_astc")
      };
      this.webGLVersion === 1 ? Object.assign(this.extensions, e, {
        drawBuffers: t.getExtension("WEBGL_draw_buffers"),
        depthTexture: t.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: t.getExtension("OES_element_index_uint"),
        // Floats and half-floats
        floatTexture: t.getExtension("OES_texture_float"),
        floatTextureLinear: t.getExtension("OES_texture_float_linear"),
        textureHalfFloat: t.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
      }) : this.webGLVersion === 2 && Object.assign(this.extensions, e, {
        // Floats and half-floats
        colorBufferFloat: t.getExtension("EXT_color_buffer_float")
      });
    }, r.prototype.handleContextLost = function(t) {
      var e = this;
      t.preventDefault(), setTimeout(function() {
        e.gl.isContextLost() && e.extensions.loseContext && e.extensions.loseContext.restoreContext();
      }, 0);
    }, r.prototype.handleContextRestored = function() {
      this.renderer.runners.contextChange.emit(this.gl);
    }, r.prototype.destroy = function() {
      var t = this.renderer.view;
      this.renderer = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
    }, r.prototype.postrender = function() {
      this.renderer.renderingToScreen && this.gl.flush();
    }, r.prototype.validateContext = function(t) {
      var e = t.getContextAttributes(), i = "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext;
      i && (this.webGLVersion = 2), e && !e.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      var n = i || !!t.getExtension("OES_element_index_uint");
      this.supports.uint32Indices = n, n || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }, r;
  }()
), J0 = (
  /** @class */
  function() {
    function r(t) {
      this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = ue.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
    }
    return r;
  }()
), mP = new pt(), u_ = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new Qf(10, 10), this.msaaSamples = null;
    }
    return r.prototype.contextChange = function() {
      this.disposeAll(!0);
      var t = this.gl = this.renderer.gl;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new pt(), this.hasMRT = !0, this.writeDepthTexture = !0, this.renderer.context.webGLVersion === 1) {
        var e = this.renderer.context.extensions.drawBuffers, i = this.renderer.context.extensions.depthTexture;
        J.PREFER_ENV === Bn.WEBGL_LEGACY && (e = null, i = null), e ? t.drawBuffers = function(n) {
          return e.drawBuffersWEBGL(n);
        } : (this.hasMRT = !1, t.drawBuffers = function() {
        }), i || (this.writeDepthTexture = !1);
      } else
        this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES);
    }, r.prototype.bind = function(t, e, i) {
      i === void 0 && (i = 0);
      var n = this.gl;
      if (t) {
        var s = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
        this.current !== t && (this.current = t, n.bindFramebuffer(n.FRAMEBUFFER, s.framebuffer)), s.mipLevel !== i && (t.dirtyId++, t.dirtyFormat++, s.mipLevel = i), s.dirtyId !== t.dirtyId && (s.dirtyId = t.dirtyId, s.dirtyFormat !== t.dirtyFormat ? (s.dirtyFormat = t.dirtyFormat, s.dirtySize = t.dirtySize, this.updateFramebuffer(t, i)) : s.dirtySize !== t.dirtySize && (s.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));
        for (var o = 0; o < t.colorTextures.length; o++) {
          var a = t.colorTextures[o];
          this.renderer.texture.unbind(a.parentTextureArray || a);
        }
        if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {
          var l = e.width >> i, u = e.height >> i, c = l / e.width;
          this.setViewport(e.x * c, e.y * c, l, u);
        } else {
          var l = t.width >> i, u = t.height >> i;
          this.setViewport(0, 0, l, u);
        }
      } else
        this.current && (this.current = null, n.bindFramebuffer(n.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
    }, r.prototype.setViewport = function(t, e, i, n) {
      var s = this.viewport;
      t = Math.round(t), e = Math.round(e), i = Math.round(i), n = Math.round(n), (s.width !== i || s.height !== n || s.x !== t || s.y !== e) && (s.x = t, s.y = e, s.width = i, s.height = n, this.gl.viewport(t, e, i, n));
    }, Object.defineProperty(r.prototype, "size", {
      /**
       * Get the size of the current width and height. Returns object with `width` and `height` values.
       * @readonly
       */
      get: function() {
        return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.clear = function(t, e, i, n, s) {
      s === void 0 && (s = Xf.COLOR | Xf.DEPTH);
      var o = this.gl;
      o.clearColor(t, e, i, n), o.clear(s);
    }, r.prototype.initFramebuffer = function(t) {
      var e = this.gl, i = new J0(e.createFramebuffer());
      return i.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = i, this.managedFramebuffers.push(t), t.disposeRunner.add(this), i;
    }, r.prototype.resizeFramebuffer = function(t) {
      var e = this.gl, i = t.glFramebuffers[this.CONTEXT_UID];
      i.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, i.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, i.multisample, e.RGBA8, t.width, t.height)), i.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, i.stencil), i.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, i.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));
      var n = t.colorTextures, s = n.length;
      e.drawBuffers || (s = Math.min(s, 1));
      for (var o = 0; o < s; o++) {
        var a = n[o], l = a.parentTextureArray || a;
        this.renderer.texture.bind(l, 0);
      }
      t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0);
    }, r.prototype.updateFramebuffer = function(t, e) {
      var i = this.gl, n = t.glFramebuffers[this.CONTEXT_UID], s = t.colorTextures, o = s.length;
      i.drawBuffers || (o = Math.min(o, 1)), n.multisample > 1 && this.canMultisampleFramebuffer(t) ? (n.msaaBuffer = n.msaaBuffer || i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, n.msaaBuffer), i.renderbufferStorageMultisample(i.RENDERBUFFER, n.multisample, i.RGBA8, t.width, t.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, n.msaaBuffer)) : n.msaaBuffer && (i.deleteRenderbuffer(n.msaaBuffer), n.msaaBuffer = null, n.blitFramebuffer && (n.blitFramebuffer.dispose(), n.blitFramebuffer = null));
      for (var a = [], l = 0; l < o; l++) {
        var u = s[l], c = u.parentTextureArray || u;
        this.renderer.texture.bind(c, 0), !(l === 0 && n.msaaBuffer) && (i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + l, u.target, c._glTextures[this.CONTEXT_UID].texture, e), a.push(i.COLOR_ATTACHMENT0 + l));
      }
      if (a.length > 1 && i.drawBuffers(a), t.depthTexture) {
        var d = this.writeDepthTexture;
        if (d) {
          var f = t.depthTexture;
          this.renderer.texture.bind(f, 0), i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, f._glTextures[this.CONTEXT_UID].texture, e);
        }
      }
      (t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (n.stencil = n.stencil || i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, n.stencil), n.msaaBuffer ? i.renderbufferStorageMultisample(i.RENDERBUFFER, n.multisample, i.DEPTH24_STENCIL8, t.width, t.height) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t.width, t.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, n.stencil)) : n.stencil && (i.deleteRenderbuffer(n.stencil), n.stencil = null);
    }, r.prototype.canMultisampleFramebuffer = function(t) {
      return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture;
    }, r.prototype.detectSamples = function(t) {
      var e = this.msaaSamples, i = ue.NONE;
      if (t <= 1 || e === null)
        return i;
      for (var n = 0; n < e.length; n++)
        if (e[n] <= t) {
          i = e[n];
          break;
        }
      return i === 1 && (i = ue.NONE), i;
    }, r.prototype.blit = function(t, e, i) {
      var n = this, s = n.current, o = n.renderer, a = n.gl, l = n.CONTEXT_UID;
      if (o.context.webGLVersion === 2 && s) {
        var u = s.glFramebuffers[l];
        if (u) {
          if (!t) {
            if (!u.msaaBuffer)
              return;
            var c = s.colorTextures[0];
            if (!c)
              return;
            u.blitFramebuffer || (u.blitFramebuffer = new Qf(s.width, s.height), u.blitFramebuffer.addColorTexture(0, c)), t = u.blitFramebuffer, t.colorTextures[0] !== c && (t.colorTextures[0] = c, t.dirtyId++, t.dirtyFormat++), (t.width !== s.width || t.height !== s.height) && (t.width = s.width, t.height = s.height, t.dirtyId++, t.dirtySize++);
          }
          e || (e = mP, e.width = s.width, e.height = s.height), i || (i = e);
          var d = e.width === i.width && e.height === i.height;
          this.bind(t), a.bindFramebuffer(a.READ_FRAMEBUFFER, u.framebuffer), a.blitFramebuffer(e.left, e.top, e.right, e.bottom, i.left, i.top, i.right, i.bottom, a.COLOR_BUFFER_BIT, d ? a.NEAREST : a.LINEAR);
        }
      }
    }, r.prototype.disposeFramebuffer = function(t, e) {
      var i = t.glFramebuffers[this.CONTEXT_UID], n = this.gl;
      if (i) {
        delete t.glFramebuffers[this.CONTEXT_UID];
        var s = this.managedFramebuffers.indexOf(t);
        s >= 0 && this.managedFramebuffers.splice(s, 1), t.disposeRunner.remove(this), e || (n.deleteFramebuffer(i.framebuffer), i.msaaBuffer && n.deleteRenderbuffer(i.msaaBuffer), i.stencil && n.deleteRenderbuffer(i.stencil)), i.blitFramebuffer && i.blitFramebuffer.dispose();
      }
    }, r.prototype.disposeAll = function(t) {
      var e = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (var i = 0; i < e.length; i++)
        this.disposeFramebuffer(e[i], t);
    }, r.prototype.forceStencil = function() {
      var t = this.current;
      if (t) {
        var e = t.glFramebuffers[this.CONTEXT_UID];
        if (!(!e || e.stencil)) {
          t.stencil = !0;
          var i = t.width, n = t.height, s = this.gl, o = s.createRenderbuffer();
          s.bindRenderbuffer(s.RENDERBUFFER, o), e.msaaBuffer ? s.renderbufferStorageMultisample(s.RENDERBUFFER, e.multisample, s.DEPTH24_STENCIL8, i, n) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, i, n), e.stencil = o, s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, o);
        }
      }
    }, r.prototype.reset = function() {
      this.current = this.unknownFramebuffer, this.viewport = new pt();
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), Yv = { 5126: 4, 5123: 2, 5121: 1 }, c_ = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};
    }
    return r.prototype.contextChange = function() {
      this.disposeAll(!0);
      var t = this.gl = this.renderer.gl, e = this.renderer.context;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e.webGLVersion !== 2) {
        var i = this.renderer.context.extensions.vertexArrayObject;
        J.PREFER_ENV === Bn.WEBGL_LEGACY && (i = null), i ? (t.createVertexArray = function() {
          return i.createVertexArrayOES();
        }, t.bindVertexArray = function(s) {
          return i.bindVertexArrayOES(s);
        }, t.deleteVertexArray = function(s) {
          return i.deleteVertexArrayOES(s);
        }) : (this.hasVao = !1, t.createVertexArray = function() {
          return null;
        }, t.bindVertexArray = function() {
          return null;
        }, t.deleteVertexArray = function() {
          return null;
        });
      }
      if (e.webGLVersion !== 2) {
        var n = t.getExtension("ANGLE_instanced_arrays");
        n ? (t.vertexAttribDivisor = function(s, o) {
          return n.vertexAttribDivisorANGLE(s, o);
        }, t.drawElementsInstanced = function(s, o, a, l, u) {
          return n.drawElementsInstancedANGLE(s, o, a, l, u);
        }, t.drawArraysInstanced = function(s, o, a, l) {
          return n.drawArraysInstancedANGLE(s, o, a, l);
        }) : this.hasInstance = !1;
      }
      this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex;
    }, r.prototype.bind = function(t, e) {
      e = e || this.renderer.shader.shader;
      var i = this.gl, n = t.glVertexArrayObjects[this.CONTEXT_UID], s = !1;
      n || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = n = {}, s = !0);
      var o = n[e.program.id] || this.initGeometryVao(t, e, s);
      this._activeGeometry = t, this._activeVao !== o && (this._activeVao = o, this.hasVao ? i.bindVertexArray(o) : this.activateVao(t, e.program)), this.updateBuffers();
    }, r.prototype.reset = function() {
      this.unbind();
    }, r.prototype.updateBuffers = function() {
      for (var t = this._activeGeometry, e = this.renderer.buffer, i = 0; i < t.buffers.length; i++) {
        var n = t.buffers[i];
        e.update(n);
      }
    }, r.prototype.checkCompatibility = function(t, e) {
      var i = t.attributes, n = e.attributeData;
      for (var s in n)
        if (!i[s])
          throw new Error('shader and geometry incompatible, geometry missing the "' + s + '" attribute');
    }, r.prototype.getSignature = function(t, e) {
      var i = t.attributes, n = e.attributeData, s = ["g", t.id];
      for (var o in i)
        n[o] && s.push(o, n[o].location);
      return s.join("-");
    }, r.prototype.initGeometryVao = function(t, e, i) {
      i === void 0 && (i = !0);
      var n = this.gl, s = this.CONTEXT_UID, o = this.renderer.buffer, a = e.program;
      a.glPrograms[s] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, a);
      var l = this.getSignature(t, a), u = t.glVertexArrayObjects[this.CONTEXT_UID], c = u[l];
      if (c)
        return u[a.id] = c, c;
      var d = t.buffers, f = t.attributes, v = {}, m = {};
      for (var p in d)
        v[p] = 0, m[p] = 0;
      for (var p in f)
        !f[p].size && a.attributeData[p] ? f[p].size = a.attributeData[p].size : f[p].size || console.warn("PIXI Geometry attribute '" + p + "' size cannot be determined (likely the bound shader does not have the attribute)"), v[f[p].buffer] += f[p].size * Yv[f[p].type];
      for (var p in f) {
        var y = f[p], b = y.size;
        y.stride === void 0 && (v[y.buffer] === b * Yv[y.type] ? y.stride = 0 : y.stride = v[y.buffer]), y.start === void 0 && (y.start = m[y.buffer], m[y.buffer] += b * Yv[y.type]);
      }
      c = n.createVertexArray(), n.bindVertexArray(c);
      for (var w = 0; w < d.length; w++) {
        var E = d[w];
        o.bind(E), i && E._glBuffers[s].refCount++;
      }
      return this.activateVao(t, a), this._activeVao = c, u[a.id] = c, u[l] = c, c;
    }, r.prototype.disposeGeometry = function(t, e) {
      var i;
      if (this.managedGeometries[t.id]) {
        delete this.managedGeometries[t.id];
        var n = t.glVertexArrayObjects[this.CONTEXT_UID], s = this.gl, o = t.buffers, a = (i = this.renderer) === null || i === void 0 ? void 0 : i.buffer;
        if (t.disposeRunner.remove(this), !!n) {
          if (a)
            for (var l = 0; l < o.length; l++) {
              var u = o[l]._glBuffers[this.CONTEXT_UID];
              u && (u.refCount--, u.refCount === 0 && !e && a.dispose(o[l], e));
            }
          if (!e) {
            for (var c in n)
              if (c[0] === "g") {
                var d = n[c];
                this._activeVao === d && this.unbind(), s.deleteVertexArray(d);
              }
          }
          delete t.glVertexArrayObjects[this.CONTEXT_UID];
        }
      }
    }, r.prototype.disposeAll = function(t) {
      for (var e = Object.keys(this.managedGeometries), i = 0; i < e.length; i++)
        this.disposeGeometry(this.managedGeometries[e[i]], t);
    }, r.prototype.activateVao = function(t, e) {
      var i = this.gl, n = this.CONTEXT_UID, s = this.renderer.buffer, o = t.buffers, a = t.attributes;
      t.indexBuffer && s.bind(t.indexBuffer);
      var l = null;
      for (var u in a) {
        var c = a[u], d = o[c.buffer], f = d._glBuffers[n];
        if (e.attributeData[u]) {
          l !== f && (s.bind(d), l = f);
          var v = e.attributeData[u].location;
          if (i.enableVertexAttribArray(v), i.vertexAttribPointer(v, c.size, c.type || i.FLOAT, c.normalized, c.stride, c.start), c.instance)
            if (this.hasInstance)
              i.vertexAttribDivisor(v, 1);
            else
              throw new Error("geometry error, GPU Instancing is not supported on this device");
        }
      }
    }, r.prototype.draw = function(t, e, i, n) {
      var s = this.gl, o = this._activeGeometry;
      if (o.indexBuffer) {
        var a = o.indexBuffer.data.BYTES_PER_ELEMENT, l = a === 2 ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
        a === 2 || a === 4 && this.canUseUInt32ElementIndex ? o.instanced ? s.drawElementsInstanced(t, e || o.indexBuffer.data.length, l, (i || 0) * a, n || 1) : s.drawElements(t, e || o.indexBuffer.data.length, l, (i || 0) * a) : console.warn("unsupported index buffer type: uint32");
      } else
        o.instanced ? s.drawArraysInstanced(t, i, e || o.getSize(), n || 1) : s.drawArrays(t, i, e || o.getSize());
      return this;
    }, r.prototype.unbind = function() {
      this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), Q0 = (
  /** @class */
  function() {
    function r(t) {
      t === void 0 && (t = null), this.type = Ie.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = J.FILTER_MULTISAMPLE, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;
    }
    return Object.defineProperty(r.prototype, "filter", {
      /**
       * The sprite mask filter.
       * If set to `null`, the default sprite mask filter is used.
       * @default null
       */
      get: function() {
        return this._filters ? this._filters[0] : null;
      },
      set: function(t) {
        t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.reset = function() {
      this.pooled && (this.maskObject = null, this.type = Ie.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;
    }, r.prototype.copyCountersOrReset = function(t) {
      t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
    }, r;
  }()
);
function _g(r, t, e) {
  var i = r.createShader(t);
  return r.shaderSource(i, e), r.compileShader(i), i;
}
function gg(r, t) {
  var e = r.getShaderSource(t).split(`
`).map(function(u, c) {
    return c + ": " + u;
  }), i = r.getShaderInfoLog(t), n = i.split(`
`), s = {}, o = n.map(function(u) {
    return parseFloat(u.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
  }).filter(function(u) {
    return u && !s[u] ? (s[u] = !0, !0) : !1;
  }), a = [""];
  o.forEach(function(u) {
    e[u - 1] = "%c" + e[u - 1] + "%c", a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  var l = e.join(`
`);
  a[0] = l, console.error(i), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, a), console.groupEnd();
}
function _P(r, t, e, i) {
  r.getProgramParameter(t, r.LINK_STATUS) || (r.getShaderParameter(e, r.COMPILE_STATUS) || gg(r, e), r.getShaderParameter(i, r.COMPILE_STATUS) || gg(r, i), console.error("PixiJS Error: Could not initialize shader."), r.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", r.getProgramInfoLog(t)));
}
function qv(r) {
  for (var t = new Array(r), e = 0; e < t.length; e++)
    t[e] = !1;
  return t;
}
function tb(r, t) {
  switch (r) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * t);
    case "vec3":
      return new Float32Array(3 * t);
    case "vec4":
      return new Float32Array(4 * t);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * t);
    case "ivec3":
      return new Int32Array(3 * t);
    case "ivec4":
      return new Int32Array(4 * t);
    case "uvec2":
      return new Uint32Array(2 * t);
    case "uvec3":
      return new Uint32Array(3 * t);
    case "uvec4":
      return new Uint32Array(4 * t);
    case "bool":
      return !1;
    case "bvec2":
      return qv(2 * t);
    case "bvec3":
      return qv(3 * t);
    case "bvec4":
      return qv(4 * t);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var eb = {}, Vh = eb;
function ib() {
  if (Vh === eb || Vh && Vh.isContextLost()) {
    var r = J.ADAPTER.createCanvas(), t = void 0;
    J.PREFER_ENV >= Bn.WEBGL2 && (t = r.getContext("webgl2", {})), t || (t = r.getContext("webgl", {}) || r.getContext("experimental-webgl", {}), t ? t.getExtension("WEBGL_draw_buffers") : t = null), Vh = t;
  }
  return Vh;
}
var Hc;
function gP() {
  if (!Hc) {
    Hc = Ii.MEDIUM;
    var r = ib();
    if (r && r.getShaderPrecisionFormat) {
      var t = r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT);
      Hc = t.precision ? Ii.HIGH : Ii.MEDIUM;
    }
  }
  return Hc;
}
function bg(r, t, e) {
  if (r.substring(0, 9) !== "precision") {
    var i = t;
    return t === Ii.HIGH && e !== Ii.HIGH && (i = Ii.MEDIUM), "precision " + i + ` float;
` + r;
  } else if (e !== Ii.HIGH && r.substring(0, 15) === "precision highp")
    return r.replace("precision highp", "precision mediump");
  return r;
}
var bP = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function rb(r) {
  return bP[r];
}
var $c = null, xg = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function nb(r, t) {
  if (!$c) {
    var e = Object.keys(xg);
    $c = {};
    for (var i = 0; i < e.length; ++i) {
      var n = e[i];
      $c[r[n]] = xg[n];
    }
  }
  return $c[t];
}
var Vo = [
  // a float cache layer
  {
    test: function(r) {
      return r.type === "float" && r.size === 1 && !r.isArray;
    },
    code: function(r) {
      return `
            if(uv["` + r + '"] !== ud["' + r + `"].value)
            {
                ud["` + r + '"].value = uv["' + r + `"]
                gl.uniform1f(ud["` + r + '"].location, uv["' + r + `"])
            }
            `;
    }
  },
  // handling samplers
  {
    test: function(r, t) {
      return (r.type === "sampler2D" || r.type === "samplerCube" || r.type === "sampler2DArray") && r.size === 1 && !r.isArray && (t == null || t.castToBaseTexture !== void 0);
    },
    code: function(r) {
      return `t = syncData.textureCount++;

            renderer.texture.bind(uv["` + r + `"], t);

            if(ud["` + r + `"].value !== t)
            {
                ud["` + r + `"].value = t;
                gl.uniform1i(ud["` + r + `"].location, t);
; // eslint-disable-line max-len
            }`;
    }
  },
  // uploading pixi matrix object to mat3
  {
    test: function(r, t) {
      return r.type === "mat3" && r.size === 1 && !r.isArray && t.a !== void 0;
    },
    code: function(r) {
      return `
            gl.uniformMatrix3fv(ud["` + r + '"].location, false, uv["' + r + `"].toArray(true));
            `;
    },
    codeUbo: function(r) {
      return `
                var ` + r + "_matrix = uv." + r + `.toArray(true);

                data[offset] = ` + r + `_matrix[0];
                data[offset+1] = ` + r + `_matrix[1];
                data[offset+2] = ` + r + `_matrix[2];
        
                data[offset + 4] = ` + r + `_matrix[3];
                data[offset + 5] = ` + r + `_matrix[4];
                data[offset + 6] = ` + r + `_matrix[5];
        
                data[offset + 8] = ` + r + `_matrix[6];
                data[offset + 9] = ` + r + `_matrix[7];
                data[offset + 10] = ` + r + `_matrix[8];
            `;
    }
  },
  // uploading a pixi point as a vec2 with caching layer
  {
    test: function(r, t) {
      return r.type === "vec2" && r.size === 1 && !r.isArray && t.x !== void 0;
    },
    code: function(r) {
      return `
                cv = ud["` + r + `"].value;
                v = uv["` + r + `"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["` + r + `"].location, v.x, v.y);
                }`;
    },
    codeUbo: function(r) {
      return `
                v = uv.` + r + `;

                data[offset] = v.x;
                data[offset+1] = v.y;
            `;
    }
  },
  // caching layer for a vec2
  {
    test: function(r) {
      return r.type === "vec2" && r.size === 1 && !r.isArray;
    },
    code: function(r) {
      return `
                cv = ud["` + r + `"].value;
                v = uv["` + r + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["` + r + `"].location, v[0], v[1]);
                }
            `;
    }
  },
  // upload a pixi rectangle as a vec4 with caching layer
  {
    test: function(r, t) {
      return r.type === "vec4" && r.size === 1 && !r.isArray && t.width !== void 0;
    },
    code: function(r) {
      return `
                cv = ud["` + r + `"].value;
                v = uv["` + r + `"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["` + r + `"].location, v.x, v.y, v.width, v.height)
                }`;
    },
    codeUbo: function(r) {
      return `
                    v = uv.` + r + `;

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `;
    }
  },
  // a caching layer for vec4 uploading
  {
    test: function(r) {
      return r.type === "vec4" && r.size === 1 && !r.isArray;
    },
    code: function(r) {
      return `
                cv = ud["` + r + `"].value;
                v = uv["` + r + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["` + r + `"].location, v[0], v[1], v[2], v[3])
                }`;
    }
  }
], xP = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
}, wP = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function EP(r, t) {
  var e, i = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (var n in r.uniforms) {
    var s = t[n];
    if (!s) {
      !((e = r.uniforms[n]) === null || e === void 0) && e.group && (r.uniforms[n].ubo ? i.push(`
                        renderer.shader.syncUniformBufferGroup(uv.` + n + ", '" + n + `');
                    `) : i.push(`
                        renderer.shader.syncUniformGroup(uv.` + n + `, syncData);
                    `));
      continue;
    }
    for (var o = r.uniforms[n], a = !1, l = 0; l < Vo.length; l++)
      if (Vo[l].test(s, o)) {
        i.push(Vo[l].code(n, o)), a = !0;
        break;
      }
    if (!a) {
      var u = s.size === 1 && !s.isArray ? xP : wP, c = u[s.type].replace("location", 'ud["' + n + '"].location');
      i.push(`
            cu = ud["` + n + `"];
            cv = cu.value;
            v = uv["` + n + `"];
            ` + c + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", i.join(`
`));
}
var TP = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function SP(r) {
  for (var t = "", e = 0; e < r; ++e)
    e > 0 && (t += `
else `), e < r - 1 && (t += "if(test == " + e + ".0){}");
  return t;
}
function sb(r, t) {
  if (r === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  for (var e = t.createShader(t.FRAGMENT_SHADER); ; ) {
    var i = TP.replace(/%forloop%/gi, SP(r));
    if (t.shaderSource(e, i), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))
      r = r / 2 | 0;
    else
      break;
  }
  return r;
}
var Xh;
function PP() {
  if (typeof Xh == "boolean")
    return Xh;
  try {
    var r = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    Xh = r({ a: "b" }, "a", "b") === !0;
  } catch {
    Xh = !1;
  }
  return Xh;
}
var OP = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`, IP = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`, CP = 0, zc = {}, Hh = (
  /** @class */
  function() {
    function r(t, e, i) {
      i === void 0 && (i = "pixi-shader"), this.id = CP++, this.vertexSrc = t || r.defaultVertexSrc, this.fragmentSrc = e || r.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== "#version" && (i = i.replace(/\s+/g, "-"), zc[i] ? (zc[i]++, i += "-" + zc[i]) : zc[i] = 1, this.vertexSrc = "#define SHADER_NAME " + i + `
` + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + i + `
` + this.fragmentSrc, this.vertexSrc = bg(this.vertexSrc, J.PRECISION_VERTEX, Ii.HIGH), this.fragmentSrc = bg(this.fragmentSrc, J.PRECISION_FRAGMENT, gP())), this.glPrograms = {}, this.syncUniforms = null;
    }
    return Object.defineProperty(r, "defaultVertexSrc", {
      /**
       * The default vertex shader source.
       * @constant
       */
      get: function() {
        return IP;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "defaultFragmentSrc", {
      /**
       * The default fragment shader source.
       * @constant
       */
      get: function() {
        return OP;
      },
      enumerable: !1,
      configurable: !0
    }), r.from = function(t, e, i) {
      var n = t + e, s = fg[n];
      return s || (fg[n] = s = new r(t, e, i)), s;
    }, r;
  }()
), Dn = (
  /** @class */
  function() {
    function r(t, e) {
      this.uniformBindCount = 0, this.program = t, e ? e instanceof ms ? this.uniformGroup = e : this.uniformGroup = new ms(e) : this.uniformGroup = new ms({}), this.disposeRunner = new Ve("disposeShader");
    }
    return r.prototype.checkUniformExists = function(t, e) {
      if (e.uniforms[t])
        return !0;
      for (var i in e.uniforms) {
        var n = e.uniforms[i];
        if (n.group && this.checkUniformExists(t, n))
          return !0;
      }
      return !1;
    }, r.prototype.destroy = function() {
      this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();
    }, Object.defineProperty(r.prototype, "uniforms", {
      /**
       * Shader uniform values, shortcut for `uniformGroup.uniforms`.
       * @readonly
       */
      get: function() {
        return this.uniformGroup.uniforms;
      },
      enumerable: !1,
      configurable: !0
    }), r.from = function(t, e, i) {
      var n = Hh.from(t, e);
      return new r(n, i);
    }, r;
  }()
), Zv = 0, Kv = 1, Jv = 2, Qv = 3, ty = 4, ey = 5, _s = (
  /** @class */
  function() {
    function r() {
      this.data = 0, this.blendMode = ot.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;
    }
    return Object.defineProperty(r.prototype, "blend", {
      /**
       * Activates blending of the computed fragment color values.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << Zv);
      },
      set: function(t) {
        !!(this.data & 1 << Zv) !== t && (this.data ^= 1 << Zv);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "offsets", {
      /**
       * Activates adding an offset to depth values of polygon's fragments
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << Kv);
      },
      set: function(t) {
        !!(this.data & 1 << Kv) !== t && (this.data ^= 1 << Kv);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "culling", {
      /**
       * Activates culling of polygons.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << Jv);
      },
      set: function(t) {
        !!(this.data & 1 << Jv) !== t && (this.data ^= 1 << Jv);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "depthTest", {
      /**
       * Activates depth comparisons and updates to the depth buffer.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << Qv);
      },
      set: function(t) {
        !!(this.data & 1 << Qv) !== t && (this.data ^= 1 << Qv);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "depthMask", {
      /**
       * Enables or disables writing to the depth buffer.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << ey);
      },
      set: function(t) {
        !!(this.data & 1 << ey) !== t && (this.data ^= 1 << ey);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "clockwiseFrontFace", {
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << ty);
      },
      set: function(t) {
        !!(this.data & 1 << ty) !== t && (this.data ^= 1 << ty);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "blendMode", {
      /**
       * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this._blendMode;
      },
      set: function(t) {
        this.blend = t !== ot.NONE, this._blendMode = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "polygonOffset", {
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       * @default 0
       */
      get: function() {
        return this._polygonOffset;
      },
      set: function(t) {
        this.offsets = !!t, this._polygonOffset = t;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.toString = function() {
      return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
    }, r.for2d = function() {
      var t = new r();
      return t.depthTest = !1, t.blend = !0, t;
    }, r;
  }()
), MP = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`, RP = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, wr = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e, i, n) {
      var s = this, o = Hh.from(e || t.defaultVertexSrc, i || t.defaultFragmentSrc);
      return s = r.call(this, o, n) || this, s.padding = 0, s.resolution = J.FILTER_RESOLUTION, s.multisample = J.FILTER_MULTISAMPLE, s.enabled = !0, s.autoFit = !0, s.state = new _s(), s;
    }
    return t.prototype.apply = function(e, i, n, s, o) {
      e.applyFilter(this, i, n, s);
    }, Object.defineProperty(t.prototype, "blendMode", {
      /**
       * Sets the blend mode of the filter.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this.state.blendMode;
      },
      set: function(e) {
        this.state.blendMode = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "resolution", {
      /**
       * The resolution of the filter. Setting this to be lower will lower the quality but
       * increase the performance of the filter.
       */
      get: function() {
        return this._resolution;
      },
      set: function(e) {
        this._resolution = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @constant
       */
      get: function() {
        return RP;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "defaultFragmentSrc", {
      /**
       * The default fragment shader source
       * @constant
       */
      get: function() {
        return MP;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Dn)
), kP = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`, NP = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`, wg = new De(), Nv = (
  /** @class */
  function() {
    function r(t, e) {
      this._texture = t, this.mapCoord = new De(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof e > "u" ? 0.5 : e, this.isSimple = !1;
    }
    return Object.defineProperty(r.prototype, "texture", {
      /** Texture property. */
      get: function() {
        return this._texture;
      },
      set: function(t) {
        this._texture = t, this._textureID = -1;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.multiplyUvs = function(t, e) {
      e === void 0 && (e = t);
      for (var i = this.mapCoord, n = 0; n < t.length; n += 2) {
        var s = t[n], o = t[n + 1];
        e[n] = s * i.a + o * i.c + i.tx, e[n + 1] = s * i.b + o * i.d + i.ty;
      }
      return e;
    }, r.prototype.update = function(t) {
      var e = this._texture;
      if (!e || !e.valid || !t && this._textureID === e._updateID)
        return !1;
      this._textureID = e._updateID, this._updateID++;
      var i = e._uvs;
      this.mapCoord.set(i.x1 - i.x0, i.y1 - i.y0, i.x3 - i.x0, i.y3 - i.y0, i.x0, i.y0);
      var n = e.orig, s = e.trim;
      s && (wg.set(n.width / s.width, 0, 0, n.height / s.height, -s.x / s.width, -s.y / s.height), this.mapCoord.append(wg));
      var o = e.baseTexture, a = this.uClampFrame, l = this.clampMargin / o.resolution, u = this.clampOffset;
      return a[0] = (e._frame.x + l + u) / o.width, a[1] = (e._frame.y + l + u) / o.height, a[2] = (e._frame.x + e._frame.width - l + u) / o.width, a[3] = (e._frame.y + e._frame.height - l + u) / o.height, this.uClampOffset[0] = u / o.realWidth, this.uClampOffset[1] = u / o.realHeight, this.isSimple = e._frame.width === o.width && e._frame.height === o.height && e.rotate === 0, !0;
    }, r;
  }()
), ob = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e, i, n) {
      var s = this, o = null;
      return typeof e != "string" && i === void 0 && n === void 0 && (o = e, e = void 0, i = void 0, n = void 0), s = r.call(this, e || kP, i || NP, n) || this, s.maskSprite = o, s.maskMatrix = new De(), s;
    }
    return Object.defineProperty(t.prototype, "maskSprite", {
      /**
       * Sprite mask
       * @type {PIXI.DisplayObject}
       */
      get: function() {
        return this._maskSprite;
      },
      set: function(e) {
        this._maskSprite = e, this._maskSprite && (this._maskSprite.renderable = !1);
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.apply = function(e, i, n, s) {
      var o = this._maskSprite, a = o._texture;
      a.valid && (a.uvMatrix || (a.uvMatrix = new Nv(a, 0)), a.uvMatrix.update(), this.uniforms.npmAlpha = a.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = a, this.uniforms.otherMatrix = e.calculateSpriteMatrix(this.maskMatrix, o).prepend(a.uvMatrix.mapCoord), this.uniforms.alpha = o.worldAlpha, this.uniforms.maskClamp = a.uvMatrix.uClampFrame, e.applyFilter(this, i, n, s));
    }, t;
  }(wr)
), f_ = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
    }
    return r.prototype.setMaskStack = function(t) {
      this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t);
    }, r.prototype.push = function(t, e) {
      var i = e;
      if (!i.isMaskData) {
        var n = this.maskDataPool.pop() || new Q0();
        n.pooled = !0, n.maskObject = e, i = n;
      }
      var s = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      if (i.copyCountersOrReset(s), i._colorMask = s ? s._colorMask : 15, i.autoDetect && this.detect(i), i._target = t, i.type !== Ie.SPRITE && this.maskStack.push(i), i.enabled)
        switch (i.type) {
          case Ie.SCISSOR:
            this.renderer.scissor.push(i);
            break;
          case Ie.STENCIL:
            this.renderer.stencil.push(i);
            break;
          case Ie.SPRITE:
            i.copyCountersOrReset(null), this.pushSpriteMask(i);
            break;
          case Ie.COLOR:
            this.pushColorMask(i);
            break;
        }
      i.type === Ie.SPRITE && this.maskStack.push(i);
    }, r.prototype.pop = function(t) {
      var e = this.maskStack.pop();
      if (!(!e || e._target !== t)) {
        if (e.enabled)
          switch (e.type) {
            case Ie.SCISSOR:
              this.renderer.scissor.pop(e);
              break;
            case Ie.STENCIL:
              this.renderer.stencil.pop(e.maskObject);
              break;
            case Ie.SPRITE:
              this.popSpriteMask(e);
              break;
            case Ie.COLOR:
              this.popColorMask(e);
              break;
          }
        if (e.reset(), e.pooled && this.maskDataPool.push(e), this.maskStack.length !== 0) {
          var i = this.maskStack[this.maskStack.length - 1];
          i.type === Ie.SPRITE && i._filters && (i._filters[0].maskSprite = i.maskObject);
        }
      }
    }, r.prototype.detect = function(t) {
      var e = t.maskObject;
      e ? e.isSprite ? t.type = Ie.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = Ie.SCISSOR : t.type = Ie.STENCIL : t.type = Ie.COLOR;
    }, r.prototype.pushSpriteMask = function(t) {
      var e, i, n = t.maskObject, s = t._target, o = t._filters;
      o || (o = this.alphaMaskPool[this.alphaMaskIndex], o || (o = this.alphaMaskPool[this.alphaMaskIndex] = [new ob()]));
      var a = this.renderer, l = a.renderTexture, u, c;
      if (l.current) {
        var d = l.current;
        u = t.resolution || d.resolution, c = (e = t.multisample) !== null && e !== void 0 ? e : d.multisample;
      } else
        u = t.resolution || a.resolution, c = (i = t.multisample) !== null && i !== void 0 ? i : a.multisample;
      o[0].resolution = u, o[0].multisample = c, o[0].maskSprite = n;
      var f = s.filterArea;
      s.filterArea = n.getBounds(!0), a.filter.push(s, o), s.filterArea = f, t._filters || this.alphaMaskIndex++;
    }, r.prototype.popSpriteMask = function(t) {
      this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
    }, r.prototype.pushColorMask = function(t) {
      var e = t._colorMask, i = t._colorMask = e & t.colorMask;
      i !== e && this.renderer.gl.colorMask((i & 1) !== 0, (i & 2) !== 0, (i & 4) !== 0, (i & 8) !== 0);
    }, r.prototype.popColorMask = function(t) {
      var e = t._colorMask, i = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
      i !== e && this.renderer.gl.colorMask((i & 1) !== 0, (i & 2) !== 0, (i & 4) !== 0, (i & 8) !== 0);
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), ab = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.maskStack = [], this.glConst = 0;
    }
    return r.prototype.getStackLength = function() {
      return this.maskStack.length;
    }, r.prototype.setMaskStack = function(t) {
      var e = this.renderer.gl, i = this.getStackLength();
      this.maskStack = t;
      var n = this.getStackLength();
      n !== i && (n === 0 ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()));
    }, r.prototype._useCurrent = function() {
    }, r.prototype.destroy = function() {
      this.renderer = null, this.maskStack = null;
    }, r;
  }()
), Eg = new De(), Tg = [], d_ = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e) {
      var i = r.call(this, e) || this;
      return i.glConst = J.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST, i;
    }
    return t.prototype.getStackLength = function() {
      var e = this.maskStack[this.maskStack.length - 1];
      return e ? e._scissorCounter : 0;
    }, t.prototype.calcScissorRect = function(e) {
      var i;
      if (!e._scissorRectLocal) {
        var n = e._scissorRect, s = e.maskObject, o = this.renderer, a = o.renderTexture, l = s.getBounds(!0, (i = Tg.pop()) !== null && i !== void 0 ? i : new pt());
        this.roundFrameToPixels(l, a.current ? a.current.resolution : o.resolution, a.sourceFrame, a.destinationFrame, o.projection.transform), n && l.fit(n), e._scissorRectLocal = l;
      }
    }, t.isMatrixRotated = function(e) {
      if (!e)
        return !1;
      var i = e.a, n = e.b, s = e.c, o = e.d;
      return (Math.abs(n) > 1e-4 || Math.abs(s) > 1e-4) && (Math.abs(i) > 1e-4 || Math.abs(o) > 1e-4);
    }, t.prototype.testScissor = function(e) {
      var i = e.maskObject;
      if (!i.isFastRect || !i.isFastRect() || t.isMatrixRotated(i.worldTransform) || t.isMatrixRotated(this.renderer.projection.transform))
        return !1;
      this.calcScissorRect(e);
      var n = e._scissorRectLocal;
      return n.width > 0 && n.height > 0;
    }, t.prototype.roundFrameToPixels = function(e, i, n, s, o) {
      t.isMatrixRotated(o) || (o = o ? Eg.copyFrom(o) : Eg.identity(), o.translate(-n.x, -n.y).scale(s.width / n.width, s.height / n.height).translate(s.x, s.y), this.renderer.filter.transformAABB(o, e), e.fit(s), e.x = Math.round(e.x * i), e.y = Math.round(e.y * i), e.width = Math.round(e.width * i), e.height = Math.round(e.height * i));
    }, t.prototype.push = function(e) {
      e._scissorRectLocal || this.calcScissorRect(e);
      var i = this.renderer.gl;
      e._scissorRect || i.enable(i.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent();
    }, t.prototype.pop = function(e) {
      var i = this.renderer.gl;
      e && Tg.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : i.disable(i.SCISSOR_TEST);
    }, t.prototype._useCurrent = function() {
      var e = this.maskStack[this.maskStack.length - 1]._scissorRect, i;
      this.renderer.renderTexture.current ? i = e.y : i = this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, i, e.width, e.height);
    }, t;
  }(ab)
), p_ = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e) {
      var i = r.call(this, e) || this;
      return i.glConst = J.ADAPTER.getWebGLRenderingContext().STENCIL_TEST, i;
    }
    return t.prototype.getStackLength = function() {
      var e = this.maskStack[this.maskStack.length - 1];
      return e ? e._stencilCounter : 0;
    }, t.prototype.push = function(e) {
      var i = e.maskObject, n = this.renderer.gl, s = e._stencilCounter;
      s === 0 && (this.renderer.framebuffer.forceStencil(), n.clearStencil(0), n.clear(n.STENCIL_BUFFER_BIT), n.enable(n.STENCIL_TEST)), e._stencilCounter++;
      var o = e._colorMask;
      o !== 0 && (e._colorMask = 0, n.colorMask(!1, !1, !1, !1)), n.stencilFunc(n.EQUAL, s, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.INCR), i.renderable = !0, i.render(this.renderer), this.renderer.batch.flush(), i.renderable = !1, o !== 0 && (e._colorMask = o, n.colorMask((o & 1) !== 0, (o & 2) !== 0, (o & 4) !== 0, (o & 8) !== 0)), this._useCurrent();
    }, t.prototype.pop = function(e) {
      var i = this.renderer.gl;
      if (this.getStackLength() === 0)
        i.disable(i.STENCIL_TEST);
      else {
        var n = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, s = n ? n._colorMask : 15;
        s !== 0 && (n._colorMask = 0, i.colorMask(!1, !1, !1, !1)), i.stencilOp(i.KEEP, i.KEEP, i.DECR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, s !== 0 && (n._colorMask = s, i.colorMask((s & 1) !== 0, (s & 2) !== 0, (s & 4) !== 0, (s & 8) !== 0)), this._useCurrent();
      }
    }, t.prototype._useCurrent = function() {
      var e = this.renderer.gl;
      e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP);
    }, t;
  }(ab)
), v_ = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new De(), this.transform = null;
    }
    return r.prototype.update = function(t, e, i, n) {
      this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, i, n), this.transform && this.projectionMatrix.append(this.transform);
      var s = this.renderer;
      s.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, s.globalUniforms.update(), s.shader.shader && s.shader.syncUniformGroup(s.shader.shader.uniforms.globals);
    }, r.prototype.calculateProjection = function(t, e, i, n) {
      var s = this.projectionMatrix, o = n ? -1 : 1;
      s.identity(), s.a = 1 / e.width * 2, s.d = o * (1 / e.height * 2), s.tx = -1 - e.x * s.a, s.ty = -o - e.y * s.d;
    }, r.prototype.setTransform = function(t) {
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), xs = new pt(), Wh = new pt(), y_ = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new pt(), this.destinationFrame = new pt(), this.viewportFrame = new pt();
    }
    return r.prototype.bind = function(t, e, i) {
      t === void 0 && (t = null);
      var n = this.renderer;
      this.current = t;
      var s, o, a;
      t ? (s = t.baseTexture, a = s.resolution, e || (xs.width = t.frame.width, xs.height = t.frame.height, e = xs), i || (Wh.x = t.frame.x, Wh.y = t.frame.y, Wh.width = e.width, Wh.height = e.height, i = Wh), o = s.framebuffer) : (a = n.resolution, e || (xs.width = n.screen.width, xs.height = n.screen.height, e = xs), i || (i = xs, i.width = e.width, i.height = e.height));
      var l = this.viewportFrame;
      l.x = i.x * a, l.y = i.y * a, l.width = i.width * a, l.height = i.height * a, t || (l.y = n.view.height - (l.y + l.height)), l.ceil(), this.renderer.framebuffer.bind(o, l), this.renderer.projection.update(i, e, a, !o), t ? this.renderer.mask.setMaskStack(s.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(i);
    }, r.prototype.clear = function(t, e) {
      this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.clearColor;
      var i = this.destinationFrame, n = this.current ? this.current.baseTexture : this.renderer.screen, s = i.width !== n.width || i.height !== n.height;
      if (s) {
        var o = this.viewportFrame, a = o.x, l = o.y, u = o.width, c = o.height;
        a = Math.round(a), l = Math.round(l), u = Math.round(u), c = Math.round(c), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(a, l, u, c);
      }
      this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), s && this.renderer.scissor.pop();
    }, r.prototype.resize = function() {
      this.bind(null);
    }, r.prototype.reset = function() {
      this.bind(null);
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
);
function AP(r, t, e, i, n) {
  e.buffer.update(n);
}
var LP = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}, hb = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function lb(r) {
  for (var t = r.map(function(l) {
    return {
      data: l,
      offset: 0,
      dataLen: 0,
      dirty: 0
    };
  }), e = 0, i = 0, n = 0, s = 0; s < t.length; s++) {
    var o = t[s];
    if (e = hb[o.data.type], o.data.size > 1 && (e = Math.max(e, 16) * o.data.size), o.dataLen = e, i % e !== 0 && i < 16) {
      var a = i % e % 16;
      i += a, n += a;
    }
    i + e > 16 ? (n = Math.ceil(n / 16) * 16, o.offset = n, n += e, i = e) : (o.offset = n, i += e, n += e);
  }
  return n = Math.ceil(n / 16) * 16, { uboElements: t, size: n };
}
function ub(r, t) {
  var e = [];
  for (var i in r)
    t[i] && e.push(t[i]);
  return e.sort(function(n, s) {
    return n.index - s.index;
  }), e;
}
function cb(r, t) {
  if (!r.autoManage)
    return { size: 0, syncFunc: AP };
  for (var e = ub(r.uniforms, t), i = lb(e), n = i.uboElements, s = i.size, o = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `], a = 0; a < n.length; a++) {
    for (var l = n[a], u = r.uniforms[l.data.name], c = l.data.name, d = !1, f = 0; f < Vo.length; f++) {
      var v = Vo[f];
      if (v.codeUbo && v.test(l.data, u)) {
        o.push("offset = " + l.offset / 4 + ";", Vo[f].codeUbo(l.data.name, u)), d = !0;
        break;
      }
    }
    if (!d)
      if (l.data.size > 1) {
        var m = rb(l.data.type), p = Math.max(hb[l.data.type] / 16, 1), y = m / p, b = (4 - y % 4) % 4;
        o.push(`
                cv = ud.` + c + `.value;
                v = uv.` + c + `;
                offset = ` + l.offset / 4 + `;

                t = 0;

                for(var i=0; i < ` + l.data.size * p + `; i++)
                {
                    for(var j = 0; j < ` + y + `; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ` + b + `;
                }

                `);
      } else {
        var w = LP[l.data.type];
        o.push(`
                cv = ud.` + c + `.value;
                v = uv.` + c + `;
                offset = ` + l.offset / 4 + `;
                ` + w + `;
                `);
      }
  }
  return o.push(`
       renderer.buffer.update(buffer);
    `), {
    size: s,
    // eslint-disable-next-line no-new-func
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", o.join(`
`))
  };
}
var DP = (
  /** @class */
  function() {
    function r() {
    }
    return r;
  }()
), fb = (
  /** @class */
  function() {
    function r(t, e) {
      this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
    }
    return r.prototype.destroy = function() {
      this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
    }, r;
  }()
);
function FP(r, t) {
  for (var e = {}, i = t.getProgramParameter(r, t.ACTIVE_ATTRIBUTES), n = 0; n < i; n++) {
    var s = t.getActiveAttrib(r, n);
    if (s.name.indexOf("gl_") !== 0) {
      var o = nb(t, s.type), a = {
        type: o,
        name: s.name,
        size: rb(o),
        location: t.getAttribLocation(r, s.name)
      };
      e[s.name] = a;
    }
  }
  return e;
}
function BP(r, t) {
  for (var e = {}, i = t.getProgramParameter(r, t.ACTIVE_UNIFORMS), n = 0; n < i; n++) {
    var s = t.getActiveUniform(r, n), o = s.name.replace(/\[.*?\]$/, ""), a = !!s.name.match(/\[.*?\]$/), l = nb(t, s.type);
    e[o] = {
      name: o,
      index: n,
      type: l,
      size: s.size,
      isArray: a,
      value: tb(l, s.size)
    };
  }
  return e;
}
function db(r, t) {
  var e = _g(r, r.VERTEX_SHADER, t.vertexSrc), i = _g(r, r.FRAGMENT_SHADER, t.fragmentSrc), n = r.createProgram();
  if (r.attachShader(n, e), r.attachShader(n, i), r.linkProgram(n), r.getProgramParameter(n, r.LINK_STATUS) || _P(r, n, e, i), t.attributeData = FP(n, r), t.uniformData = BP(n, r), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc)) {
    var s = Object.keys(t.attributeData);
    s.sort(function(c, d) {
      return c > d ? 1 : -1;
    });
    for (var o = 0; o < s.length; o++)
      t.attributeData[s[o]].location = o, r.bindAttribLocation(n, o, s[o]);
    r.linkProgram(n);
  }
  r.deleteShader(e), r.deleteShader(i);
  var a = {};
  for (var o in t.uniformData) {
    var l = t.uniformData[o];
    a[o] = {
      location: r.getUniformLocation(n, o),
      value: tb(l.type, l.size)
    };
  }
  var u = new fb(n, a);
  return u;
}
var UP = 0, Vc = { textureCount: 0, uboCount: 0 }, m_ = (
  /** @class */
  function() {
    function r(t) {
      this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = UP++;
    }
    return r.prototype.systemCheck = function() {
      if (!PP())
        throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }, r.prototype.contextChange = function(t) {
      this.gl = t, this.reset();
    }, r.prototype.bind = function(t, e) {
      t.disposeRunner.add(this), t.uniforms.globals = this.renderer.globalUniforms;
      var i = t.program, n = i.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
      return this.shader = t, this.program !== i && (this.program = i, this.gl.useProgram(n.program)), e || (Vc.textureCount = 0, Vc.uboCount = 0, this.syncUniformGroup(t.uniformGroup, Vc)), n;
    }, r.prototype.setUniforms = function(t) {
      var e = this.shader.program, i = e.glPrograms[this.renderer.CONTEXT_UID];
      e.syncUniforms(i.uniformData, t, this.renderer);
    }, r.prototype.syncUniformGroup = function(t, e) {
      var i = this.getGlProgram();
      (!t.static || t.dirtyId !== i.uniformDirtyGroups[t.id]) && (i.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, i, e));
    }, r.prototype.syncUniforms = function(t, e, i) {
      var n = t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t);
      n(e.uniformData, t.uniforms, this.renderer, i);
    }, r.prototype.createSyncGroups = function(t) {
      var e = this.getSignature(t, this.shader.program.uniformData, "u");
      return this.cache[e] || (this.cache[e] = EP(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id];
    }, r.prototype.syncUniformBufferGroup = function(t, e) {
      var i = this.getGlProgram();
      if (!t.static || t.dirtyId !== 0 || !i.uniformGroups[t.id]) {
        t.dirtyId = 0;
        var n = i.uniformGroups[t.id] || this.createSyncBufferGroup(t, i, e);
        t.buffer.update(), n(i.uniformData, t.uniforms, this.renderer, Vc, t.buffer);
      }
      this.renderer.buffer.bindBufferBase(t.buffer, i.uniformBufferBindings[e]);
    }, r.prototype.createSyncBufferGroup = function(t, e, i) {
      var n = this.renderer.gl;
      this.renderer.buffer.bind(t.buffer);
      var s = this.gl.getUniformBlockIndex(e.program, i);
      e.uniformBufferBindings[i] = this.shader.uniformBindCount, n.uniformBlockBinding(e.program, s, this.shader.uniformBindCount), this.shader.uniformBindCount++;
      var o = this.getSignature(t, this.shader.program.uniformData, "ubo"), a = this._uboCache[o];
      if (a || (a = this._uboCache[o] = cb(t, this.shader.program.uniformData)), t.autoManage) {
        var l = new Float32Array(a.size / 4);
        t.buffer.update(l);
      }
      return e.uniformGroups[t.id] = a.syncFunc, e.uniformGroups[t.id];
    }, r.prototype.getSignature = function(t, e, i) {
      var n = t.uniforms, s = [i + "-"];
      for (var o in n)
        s.push(o), e[o] && s.push(e[o].type);
      return s.join("-");
    }, r.prototype.getGlProgram = function() {
      return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
    }, r.prototype.generateProgram = function(t) {
      var e = this.gl, i = t.program, n = db(e, i);
      return i.glPrograms[this.renderer.CONTEXT_UID] = n, n;
    }, r.prototype.reset = function() {
      this.program = null, this.shader = null;
    }, r.prototype.disposeShader = function(t) {
      this.shader === t && (this.shader = null);
    }, r.prototype.destroy = function() {
      this.renderer = null, this.destroyed = !0;
    }, r;
  }()
);
function GP(r, t) {
  return t === void 0 && (t = []), t[ot.NORMAL] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.ADD] = [r.ONE, r.ONE], t[ot.MULTIPLY] = [r.DST_COLOR, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.SCREEN] = [r.ONE, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.OVERLAY] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.DARKEN] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.LIGHTEN] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.COLOR_DODGE] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.COLOR_BURN] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.HARD_LIGHT] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.SOFT_LIGHT] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.DIFFERENCE] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.EXCLUSION] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.HUE] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.SATURATION] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.COLOR] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.LUMINOSITY] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.NONE] = [0, 0], t[ot.NORMAL_NPM] = [r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.ADD_NPM] = [r.SRC_ALPHA, r.ONE, r.ONE, r.ONE], t[ot.SCREEN_NPM] = [r.SRC_ALPHA, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE_MINUS_SRC_ALPHA], t[ot.SRC_IN] = [r.DST_ALPHA, r.ZERO], t[ot.SRC_OUT] = [r.ONE_MINUS_DST_ALPHA, r.ZERO], t[ot.SRC_ATOP] = [r.DST_ALPHA, r.ONE_MINUS_SRC_ALPHA], t[ot.DST_OVER] = [r.ONE_MINUS_DST_ALPHA, r.ONE], t[ot.DST_IN] = [r.ZERO, r.SRC_ALPHA], t[ot.DST_OUT] = [r.ZERO, r.ONE_MINUS_SRC_ALPHA], t[ot.DST_ATOP] = [r.ONE_MINUS_DST_ALPHA, r.SRC_ALPHA], t[ot.XOR] = [r.ONE_MINUS_DST_ALPHA, r.ONE_MINUS_SRC_ALPHA], t[ot.SUBTRACT] = [r.ONE, r.ONE, r.ONE, r.ONE, r.FUNC_REVERSE_SUBTRACT, r.FUNC_ADD], t;
}
var jP = 0, HP = 1, $P = 2, zP = 3, VP = 4, XP = 5, __ = (
  /** @class */
  function() {
    function r() {
      this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = ot.NONE, this._blendEq = !1, this.map = [], this.map[jP] = this.setBlend, this.map[HP] = this.setOffset, this.map[$P] = this.setCullFace, this.map[zP] = this.setDepthTest, this.map[VP] = this.setFrontFace, this.map[XP] = this.setDepthMask, this.checks = [], this.defaultState = new _s(), this.defaultState.blend = !0;
    }
    return r.prototype.contextChange = function(t) {
      this.gl = t, this.blendModes = GP(t), this.set(this.defaultState), this.reset();
    }, r.prototype.set = function(t) {
      if (t = t || this.defaultState, this.stateId !== t.data) {
        for (var e = this.stateId ^ t.data, i = 0; e; )
          e & 1 && this.map[i].call(this, !!(t.data & 1 << i)), e = e >> 1, i++;
        this.stateId = t.data;
      }
      for (var i = 0; i < this.checks.length; i++)
        this.checks[i](this, t);
    }, r.prototype.forceState = function(t) {
      t = t || this.defaultState;
      for (var e = 0; e < this.map.length; e++)
        this.map[e].call(this, !!(t.data & 1 << e));
      for (var e = 0; e < this.checks.length; e++)
        this.checks[e](this, t);
      this.stateId = t.data;
    }, r.prototype.setBlend = function(t) {
      this.updateCheck(r.checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND);
    }, r.prototype.setOffset = function(t) {
      this.updateCheck(r.checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    }, r.prototype.setDepthTest = function(t) {
      this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST);
    }, r.prototype.setDepthMask = function(t) {
      this.gl.depthMask(t);
    }, r.prototype.setCullFace = function(t) {
      this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE);
    }, r.prototype.setFrontFace = function(t) {
      this.gl.frontFace(this.gl[t ? "CW" : "CCW"]);
    }, r.prototype.setBlendMode = function(t) {
      if (t !== this.blendMode) {
        this.blendMode = t;
        var e = this.blendModes[t], i = this.gl;
        e.length === 2 ? i.blendFunc(e[0], e[1]) : i.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, i.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD));
      }
    }, r.prototype.setPolygonOffset = function(t, e) {
      this.gl.polygonOffset(t, e);
    }, r.prototype.reset = function() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);
    }, r.prototype.updateCheck = function(t, e) {
      var i = this.checks.indexOf(t);
      e && i === -1 ? this.checks.push(t) : !e && i !== -1 && this.checks.splice(i, 1);
    }, r.checkBlendMode = function(t, e) {
      t.setBlendMode(e.blendMode);
    }, r.checkPolygonOffset = function(t, e) {
      t.setPolygonOffset(1, e.polygonOffset);
    }, r.prototype.destroy = function() {
      this.gl = null;
    }, r;
  }()
), g_ = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = J.GC_MAX_IDLE, this.checkCountMax = J.GC_MAX_CHECK_COUNT, this.mode = J.GC_MODE;
    }
    return r.prototype.postrender = function() {
      this.renderer.renderingToScreen && (this.count++, this.mode !== Yf.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
    }, r.prototype.run = function() {
      for (var t = this.renderer.texture, e = t.managedTextures, i = !1, n = 0; n < e.length; n++) {
        var s = e[n];
        !s.framebuffer && this.count - s.touched > this.maxIdle && (t.destroyTexture(s, !0), e[n] = null, i = !0);
      }
      if (i) {
        for (var o = 0, n = 0; n < e.length; n++)
          e[n] !== null && (e[o++] = e[n]);
        e.length = o;
      }
    }, r.prototype.unload = function(t) {
      var e = this.renderer.texture, i = t._texture;
      i && !i.framebuffer && e.destroyTexture(i);
      for (var n = t.children.length - 1; n >= 0; n--)
        this.unload(t.children[n]);
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
);
function WP(r) {
  var t, e, i, n, s, o, a, l, u, c, d, f, v, m, p, y, b, w, E, O, I, S, C;
  return "WebGL2RenderingContext" in globalThis && r instanceof globalThis.WebGL2RenderingContext ? C = (t = {}, t[ct.UNSIGNED_BYTE] = (e = {}, e[W.RGBA] = r.RGBA8, e[W.RGB] = r.RGB8, e[W.RG] = r.RG8, e[W.RED] = r.R8, e[W.RGBA_INTEGER] = r.RGBA8UI, e[W.RGB_INTEGER] = r.RGB8UI, e[W.RG_INTEGER] = r.RG8UI, e[W.RED_INTEGER] = r.R8UI, e[W.ALPHA] = r.ALPHA, e[W.LUMINANCE] = r.LUMINANCE, e[W.LUMINANCE_ALPHA] = r.LUMINANCE_ALPHA, e), t[ct.BYTE] = (i = {}, i[W.RGBA] = r.RGBA8_SNORM, i[W.RGB] = r.RGB8_SNORM, i[W.RG] = r.RG8_SNORM, i[W.RED] = r.R8_SNORM, i[W.RGBA_INTEGER] = r.RGBA8I, i[W.RGB_INTEGER] = r.RGB8I, i[W.RG_INTEGER] = r.RG8I, i[W.RED_INTEGER] = r.R8I, i), t[ct.UNSIGNED_SHORT] = (n = {}, n[W.RGBA_INTEGER] = r.RGBA16UI, n[W.RGB_INTEGER] = r.RGB16UI, n[W.RG_INTEGER] = r.RG16UI, n[W.RED_INTEGER] = r.R16UI, n[W.DEPTH_COMPONENT] = r.DEPTH_COMPONENT16, n), t[ct.SHORT] = (s = {}, s[W.RGBA_INTEGER] = r.RGBA16I, s[W.RGB_INTEGER] = r.RGB16I, s[W.RG_INTEGER] = r.RG16I, s[W.RED_INTEGER] = r.R16I, s), t[ct.UNSIGNED_INT] = (o = {}, o[W.RGBA_INTEGER] = r.RGBA32UI, o[W.RGB_INTEGER] = r.RGB32UI, o[W.RG_INTEGER] = r.RG32UI, o[W.RED_INTEGER] = r.R32UI, o[W.DEPTH_COMPONENT] = r.DEPTH_COMPONENT24, o), t[ct.INT] = (a = {}, a[W.RGBA_INTEGER] = r.RGBA32I, a[W.RGB_INTEGER] = r.RGB32I, a[W.RG_INTEGER] = r.RG32I, a[W.RED_INTEGER] = r.R32I, a), t[ct.FLOAT] = (l = {}, l[W.RGBA] = r.RGBA32F, l[W.RGB] = r.RGB32F, l[W.RG] = r.RG32F, l[W.RED] = r.R32F, l[W.DEPTH_COMPONENT] = r.DEPTH_COMPONENT32F, l), t[ct.HALF_FLOAT] = (u = {}, u[W.RGBA] = r.RGBA16F, u[W.RGB] = r.RGB16F, u[W.RG] = r.RG16F, u[W.RED] = r.R16F, u), t[ct.UNSIGNED_SHORT_5_6_5] = (c = {}, c[W.RGB] = r.RGB565, c), t[ct.UNSIGNED_SHORT_4_4_4_4] = (d = {}, d[W.RGBA] = r.RGBA4, d), t[ct.UNSIGNED_SHORT_5_5_5_1] = (f = {}, f[W.RGBA] = r.RGB5_A1, f), t[ct.UNSIGNED_INT_2_10_10_10_REV] = (v = {}, v[W.RGBA] = r.RGB10_A2, v[W.RGBA_INTEGER] = r.RGB10_A2UI, v), t[ct.UNSIGNED_INT_10F_11F_11F_REV] = (m = {}, m[W.RGB] = r.R11F_G11F_B10F, m), t[ct.UNSIGNED_INT_5_9_9_9_REV] = (p = {}, p[W.RGB] = r.RGB9_E5, p), t[ct.UNSIGNED_INT_24_8] = (y = {}, y[W.DEPTH_STENCIL] = r.DEPTH24_STENCIL8, y), t[ct.FLOAT_32_UNSIGNED_INT_24_8_REV] = (b = {}, b[W.DEPTH_STENCIL] = r.DEPTH32F_STENCIL8, b), t) : C = (w = {}, w[ct.UNSIGNED_BYTE] = (E = {}, E[W.RGBA] = r.RGBA, E[W.RGB] = r.RGB, E[W.ALPHA] = r.ALPHA, E[W.LUMINANCE] = r.LUMINANCE, E[W.LUMINANCE_ALPHA] = r.LUMINANCE_ALPHA, E), w[ct.UNSIGNED_SHORT_5_6_5] = (O = {}, O[W.RGB] = r.RGB, O), w[ct.UNSIGNED_SHORT_4_4_4_4] = (I = {}, I[W.RGBA] = r.RGBA, I), w[ct.UNSIGNED_SHORT_5_5_5_1] = (S = {}, S[W.RGBA] = r.RGBA, S), w), C;
}
var df = (
  /** @class */
  function() {
    function r(t) {
      this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = ct.UNSIGNED_BYTE, this.internalFormat = W.RGBA, this.samplerType = 0;
    }
    return r;
  }()
), b_ = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new Mt(), this.hasIntegerTextures = !1;
    }
    return r.prototype.contextChange = function() {
      var t = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = WP(t);
      var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = e;
      for (var i = 0; i < e; i++)
        this.boundTextures[i] = null;
      this.emptyTextures = {};
      var n = new df(t.createTexture());
      t.bindTexture(t.TEXTURE_2D, n.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = n, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new df(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
      for (var i = 0; i < 6; i++)
        t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
      t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
      for (var i = 0; i < this.boundTextures.length; i++)
        this.bind(null, i);
    }, r.prototype.bind = function(t, e) {
      e === void 0 && (e = 0);
      var i = this.gl;
      if (t = t == null ? void 0 : t.castToBaseTexture(), t && t.valid && !t.parentTextureArray) {
        t.touched = this.renderer.textureGC.count;
        var n = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
        this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, i.activeTexture(i.TEXTURE0 + e)), i.bindTexture(t.target, n.texture)), n.dirtyId !== t.dirtyId ? (this.currentLocation !== e && (this.currentLocation = e, i.activeTexture(i.TEXTURE0 + e)), this.updateTexture(t)) : n.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t), this.boundTextures[e] = t;
      } else
        this.currentLocation !== e && (this.currentLocation = e, i.activeTexture(i.TEXTURE0 + e)), i.bindTexture(i.TEXTURE_2D, this.emptyTextures[i.TEXTURE_2D].texture), this.boundTextures[e] = null;
    }, r.prototype.reset = function() {
      this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;
      for (var t = 0; t < this.boundTextures.length; t++)
        this.boundTextures[t] = this.unknownTexture;
    }, r.prototype.unbind = function(t) {
      var e = this, i = e.gl, n = e.boundTextures;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = !1;
        for (var s = 0; s < n.length; s++)
          n[s] === this.unknownTexture && this.bind(null, s);
      }
      for (var s = 0; s < n.length; s++)
        n[s] === t && (this.currentLocation !== s && (i.activeTexture(i.TEXTURE0 + s), this.currentLocation = s), i.bindTexture(t.target, this.emptyTextures[t.target].texture), n[s] = null);
    }, r.prototype.ensureSamplerType = function(t) {
      var e = this, i = e.boundTextures, n = e.hasIntegerTextures, s = e.CONTEXT_UID;
      if (n)
        for (var o = t - 1; o >= 0; --o) {
          var a = i[o];
          if (a) {
            var l = a._glTextures[s];
            l.samplerType !== Wf.FLOAT && this.renderer.texture.unbind(a);
          }
        }
    }, r.prototype.initTexture = function(t) {
      var e = new df(this.gl.createTexture());
      return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), e;
    }, r.prototype.initTextureType = function(t, e) {
      var i, n;
      e.internalFormat = (n = (i = this.internalFormats[t.type]) === null || i === void 0 ? void 0 : i[t.format]) !== null && n !== void 0 ? n : t.format, this.webGLVersion === 2 && t.type === ct.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type;
    }, r.prototype.updateTexture = function(t) {
      var e = t._glTextures[this.CONTEXT_UID];
      if (e) {
        var i = this.renderer;
        if (this.initTextureType(t, e), t.resource && t.resource.upload(i, t, e))
          e.samplerType !== Wf.FLOAT && (this.hasIntegerTextures = !0);
        else {
          var n = t.realWidth, s = t.realHeight, o = i.gl;
          (e.width !== n || e.height !== s || e.dirtyId < 0) && (e.width = n, e.height = s, o.texImage2D(t.target, 0, e.internalFormat, n, s, 0, t.format, e.type, null));
        }
        t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId;
      }
    }, r.prototype.destroyTexture = function(t, e) {
      var i = this.gl;
      if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), i.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {
        var n = this.managedTextures.indexOf(t);
        n !== -1 && xa(this.managedTextures, n, 1);
      }
    }, r.prototype.updateTextureStyle = function(t) {
      var e = t._glTextures[this.CONTEXT_UID];
      e && ((t.mipmap === br.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? e.mipmap = !1 : e.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? e.wrapMode = Wr.CLAMP : e.wrapMode = t.wrapMode, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId);
    }, r.prototype.setStyle = function(t, e) {
      var i = this.gl;
      if (e.mipmap && t.mipmap !== br.ON_MANUAL && i.generateMipmap(t.target), i.texParameteri(t.target, i.TEXTURE_WRAP_S, e.wrapMode), i.texParameteri(t.target, i.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {
        i.texParameteri(t.target, i.TEXTURE_MIN_FILTER, t.scaleMode === Vr.LINEAR ? i.LINEAR_MIPMAP_LINEAR : i.NEAREST_MIPMAP_NEAREST);
        var n = this.renderer.context.extensions.anisotropicFiltering;
        if (n && t.anisotropicLevel > 0 && t.scaleMode === Vr.LINEAR) {
          var s = Math.min(t.anisotropicLevel, i.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          i.texParameterf(t.target, n.TEXTURE_MAX_ANISOTROPY_EXT, s);
        }
      } else
        i.texParameteri(t.target, i.TEXTURE_MIN_FILTER, t.scaleMode === Vr.LINEAR ? i.LINEAR : i.NEAREST);
      i.texParameteri(t.target, i.TEXTURE_MAG_FILTER, t.scaleMode === Vr.LINEAR ? i.LINEAR : i.NEAREST);
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), pb = {
  __proto__: null,
  FilterSystem: a_,
  BatchSystem: h_,
  ContextSystem: l_,
  FramebufferSystem: u_,
  GeometrySystem: c_,
  MaskSystem: f_,
  ScissorSystem: d_,
  StencilSystem: p_,
  ProjectionSystem: v_,
  RenderTextureSystem: y_,
  ShaderSystem: m_,
  StateSystem: __,
  TextureGCSystem: g_,
  TextureSystem: b_
}, iy = new De(), vb = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e, i) {
      e === void 0 && (e = El.UNKNOWN);
      var n = r.call(this) || this;
      return i = Object.assign({}, J.RENDER_OPTIONS, i), n.options = i, n.type = e, n.screen = new pt(0, 0, i.width, i.height), n.view = i.view || J.ADAPTER.createCanvas(), n.resolution = i.resolution || J.RESOLUTION, n.useContextAlpha = i.useContextAlpha, n.autoDensity = !!i.autoDensity, n.preserveDrawingBuffer = i.preserveDrawingBuffer, n.clearBeforeRender = i.clearBeforeRender, n._backgroundColor = 0, n._backgroundColorRgba = [0, 0, 0, 1], n._backgroundColorString = "#000000", n.backgroundColor = i.backgroundColor || n._backgroundColor, n.backgroundAlpha = i.backgroundAlpha, i.transparent !== void 0 && (ci("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), n.useContextAlpha = i.transparent, n.backgroundAlpha = i.transparent ? 0 : 1), n._lastObjectRendered = null, n.plugins = {}, n;
    }
    return t.prototype.initPlugins = function(e) {
      for (var i in e)
        this.plugins[i] = new e[i](this);
    }, Object.defineProperty(t.prototype, "width", {
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal.
       * @member {number}
       * @readonly
       * @default 800
       */
      get: function() {
        return this.view.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /**
       * Same as view.height, actual number of pixels in the canvas by vertical.
       * @member {number}
       * @readonly
       * @default 600
       */
      get: function() {
        return this.view.height;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.resize = function(e, i) {
      this.view.width = Math.round(e * this.resolution), this.view.height = Math.round(i * this.resolution);
      var n = this.view.width / this.resolution, s = this.view.height / this.resolution;
      this.screen.width = n, this.screen.height = s, this.autoDensity && (this.view.style.width = n + "px", this.view.style.height = s + "px"), this.emit("resize", n, s);
    }, t.prototype.generateTexture = function(e, i, n, s) {
      i === void 0 && (i = {}), typeof i == "number" && (ci("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), i = { scaleMode: i, resolution: n, region: s });
      var o = i.region, a = hP(i, ["region"]);
      s = o || e.getLocalBounds(null, !0), s.width === 0 && (s.width = 1), s.height === 0 && (s.height = 1);
      var l = Wi.create(Py({ width: s.width, height: s.height }, a));
      return iy.tx = -s.x, iy.ty = -s.y, this.render(e, {
        renderTexture: l,
        clear: !1,
        transform: iy,
        skipUpdateTransform: !!e.parent
      }), l;
    }, t.prototype.destroy = function(e) {
      for (var i in this.plugins)
        this.plugins[i].destroy(), this.plugins[i] = null;
      e && this.view.parentNode && this.view.parentNode.removeChild(this.view);
      var n = this;
      n.plugins = null, n.type = El.UNKNOWN, n.view = null, n.screen = null, n._tempDisplayObjectParent = null, n.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;
    }, Object.defineProperty(t.prototype, "backgroundColor", {
      /**
       * The background color to fill if not transparent
       * @member {number}
       */
      get: function() {
        return this._backgroundColor;
      },
      set: function(e) {
        this._backgroundColor = e, this._backgroundColorString = B0(e), Lh(e, this._backgroundColorRgba);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "backgroundAlpha", {
      /**
       * The background color alpha. Setting this to 0 will make the canvas transparent.
       * @member {number}
       */
      get: function() {
        return this._backgroundColorRgba[3];
      },
      set: function(e) {
        this._backgroundColorRgba[3] = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zi)
), YP = (
  /** @class */
  function() {
    function r(t) {
      this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
    }
    return r;
  }()
), qP = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {};
    }
    return r.prototype.destroy = function() {
      this.renderer = null;
    }, r.prototype.contextChange = function() {
      this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    }, r.prototype.bind = function(t) {
      var e = this, i = e.gl, n = e.CONTEXT_UID, s = t._glBuffers[n] || this.createGLBuffer(t);
      i.bindBuffer(t.type, s.buffer);
    }, r.prototype.bindBufferBase = function(t, e) {
      var i = this, n = i.gl, s = i.CONTEXT_UID;
      if (this.boundBufferBases[e] !== t) {
        var o = t._glBuffers[s] || this.createGLBuffer(t);
        this.boundBufferBases[e] = t, n.bindBufferBase(n.UNIFORM_BUFFER, e, o.buffer);
      }
    }, r.prototype.bindBufferRange = function(t, e, i) {
      var n = this, s = n.gl, o = n.CONTEXT_UID;
      i = i || 0;
      var a = t._glBuffers[o] || this.createGLBuffer(t);
      s.bindBufferRange(s.UNIFORM_BUFFER, e || 0, a.buffer, i * 256, 256);
    }, r.prototype.update = function(t) {
      var e = this, i = e.gl, n = e.CONTEXT_UID, s = t._glBuffers[n];
      if (t._updateID !== s.updateID)
        if (s.updateID = t._updateID, i.bindBuffer(t.type, s.buffer), s.byteLength >= t.data.byteLength)
          i.bufferSubData(t.type, 0, t.data);
        else {
          var o = t.static ? i.STATIC_DRAW : i.DYNAMIC_DRAW;
          s.byteLength = t.data.byteLength, i.bufferData(t.type, t.data, o);
        }
    }, r.prototype.dispose = function(t, e) {
      if (this.managedBuffers[t.id]) {
        delete this.managedBuffers[t.id];
        var i = t._glBuffers[this.CONTEXT_UID], n = this.gl;
        t.disposeRunner.remove(this), i && (e || n.deleteBuffer(i.buffer), delete t._glBuffers[this.CONTEXT_UID]);
      }
    }, r.prototype.disposeAll = function(t) {
      for (var e = Object.keys(this.managedBuffers), i = 0; i < e.length; i++)
        this.dispose(this.managedBuffers[e[i]], t);
    }, r.prototype.createGLBuffer = function(t) {
      var e = this, i = e.CONTEXT_UID, n = e.gl;
      return t._glBuffers[i] = new YP(n.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[i];
    }, r;
  }()
), x_ = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e) {
      var i = r.call(this, El.WEBGL, e) || this;
      return e = i.options, i.gl = null, i.CONTEXT_UID = 0, i.runners = {
        destroy: new Ve("destroy"),
        contextChange: new Ve("contextChange"),
        reset: new Ve("reset"),
        update: new Ve("update"),
        postrender: new Ve("postrender"),
        prerender: new Ve("prerender"),
        resize: new Ve("resize")
      }, i.runners.contextChange.add(i), i.globalUniforms = new ms({
        projectionMatrix: new De()
      }, !0), i.addSystem(f_, "mask").addSystem(l_, "context").addSystem(__, "state").addSystem(m_, "shader").addSystem(b_, "texture").addSystem(qP, "buffer").addSystem(c_, "geometry").addSystem(u_, "framebuffer").addSystem(d_, "scissor").addSystem(p_, "stencil").addSystem(v_, "projection").addSystem(g_, "textureGC").addSystem(a_, "filter").addSystem(y_, "renderTexture").addSystem(h_, "batch"), i.initPlugins(t.__plugins), i.multisample = void 0, e.context ? i.context.initFromContext(e.context) : i.context.initFromOptions({
        alpha: !!i.useContextAlpha,
        antialias: e.antialias,
        premultipliedAlpha: i.useContextAlpha && i.useContextAlpha !== "notMultiplied",
        stencil: !0,
        preserveDrawingBuffer: e.preserveDrawingBuffer,
        powerPreference: i.options.powerPreference
      }), i.renderingToScreen = !0, sT(i.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1"), i.resize(i.options.width, i.options.height), i;
    }
    return t.create = function(e) {
      if (oT())
        return new t(e);
      throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
    }, t.prototype.contextChange = function() {
      var e = this.gl, i;
      if (this.context.webGLVersion === 1) {
        var n = e.getParameter(e.FRAMEBUFFER_BINDING);
        e.bindFramebuffer(e.FRAMEBUFFER, null), i = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, n);
      } else {
        var n = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);
        e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), i = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, n);
      }
      i >= ue.HIGH ? this.multisample = ue.HIGH : i >= ue.MEDIUM ? this.multisample = ue.MEDIUM : i >= ue.LOW ? this.multisample = ue.LOW : this.multisample = ue.NONE;
    }, t.prototype.addSystem = function(e, i) {
      var n = new e(this);
      if (this[i])
        throw new Error('Whoops! The name "' + i + '" is already in use');
      this[i] = n;
      for (var s in this.runners)
        this.runners[s].add(n);
      return this;
    }, t.prototype.render = function(e, i) {
      var n, s, o, a;
      if (i && (i instanceof Wi ? (ci("6.0.0", "Renderer#render arguments changed, use options instead."), n = i, s = arguments[2], o = arguments[3], a = arguments[4]) : (n = i.renderTexture, s = i.clear, o = i.transform, a = i.skipUpdateTransform)), this.renderingToScreen = !n, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = o, !this.context.isLost) {
        if (n || (this._lastObjectRendered = e), !a) {
          var l = e.enableTempParent();
          e.updateTransform(), e.disableTempParent(l);
        }
        this.renderTexture.bind(n), this.batch.currentRenderer.start(), (s !== void 0 ? s : this.clearBeforeRender) && this.renderTexture.clear(), e.render(this), this.batch.currentRenderer.flush(), n && n.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender");
      }
    }, t.prototype.generateTexture = function(e, i, n, s) {
      i === void 0 && (i = {});
      var o = r.prototype.generateTexture.call(this, e, i, n, s);
      return this.framebuffer.blit(), o;
    }, t.prototype.resize = function(e, i) {
      r.prototype.resize.call(this, e, i), this.runners.resize.emit(this.screen.height, this.screen.width);
    }, t.prototype.reset = function() {
      return this.runners.reset.emit(), this;
    }, t.prototype.clear = function() {
      this.renderTexture.bind(), this.renderTexture.clear();
    }, t.prototype.destroy = function(e) {
      this.runners.destroy.emit();
      for (var i in this.runners)
        this.runners[i].destroy();
      r.prototype.destroy.call(this, e), this.gl = null;
    }, Object.defineProperty(t.prototype, "extract", {
      /**
       * Please use `plugins.extract` instead.
       * @member {PIXI.Extract} extract
       * @deprecated since 6.0.0
       * @readonly
       */
      get: function() {
        return ci("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract;
      },
      enumerable: !1,
      configurable: !0
    }), t.registerPlugin = function(e, i) {
      ci("6.5.0", "Renderer.registerPlugin() has been deprecated, please use extensions.add() instead."), Tr.add({
        name: e,
        type: qt.RendererPlugin,
        ref: i
      });
    }, t.__plugins = {}, t;
  }(vb)
);
Tr.handleByMap(qt.RendererPlugin, x_.__plugins);
function w_(r) {
  return x_.create(r);
}
var ZP = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`, KP = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, yb = ZP, E_ = KP, JP = (
  /** @class */
  function() {
    function r(t) {
      ci("6.1.0", "System class is deprecated, implemement ISystem interface instead."), this.renderer = t;
    }
    return r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), td = (
  /** @class */
  function() {
    function r() {
      this.texArray = null, this.blend = 0, this.type = _r.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
    }
    return r;
  }()
), ed = (
  /** @class */
  function() {
    function r() {
      this.elements = [], this.ids = [], this.count = 0;
    }
    return r.prototype.clear = function() {
      for (var t = 0; t < this.count; t++)
        this.elements[t] = null;
      this.count = 0;
    }, r;
  }()
), id = (
  /** @class */
  function() {
    function r(t) {
      typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
    }
    return Object.defineProperty(r.prototype, "int8View", {
      /** View on the raw binary data as a `Int8Array`. */
      get: function() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "uint8View", {
      /** View on the raw binary data as a `Uint8Array`. */
      get: function() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "int16View", {
      /**  View on the raw binary data as a `Int16Array`. */
      get: function() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "uint16View", {
      /** View on the raw binary data as a `Uint16Array`. */
      get: function() {
        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "int32View", {
      /** View on the raw binary data as a `Int32Array`. */
      get: function() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.view = function(t) {
      return this[t + "View"];
    }, r.prototype.destroy = function() {
      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
    }, r.sizeOf = function(t) {
      switch (t) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(t + " isn't a valid view type");
      }
    }, r;
  }()
), mb = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e) {
      var i = r.call(this, e) || this;
      return i.shaderGenerator = null, i.geometryClass = null, i.vertexSize = null, i.state = _s.for2d(), i.size = J.SPRITE_BATCH_SIZE * 4, i._vertexCount = 0, i._indexCount = 0, i._bufferedElements = [], i._bufferedTextures = [], i._bufferSize = 0, i._shader = null, i._packedGeometries = [], i._packedGeometryPoolSize = 2, i._flushId = 0, i._aBuffers = {}, i._iBuffers = {}, i.MAX_TEXTURES = 1, i.renderer.on("prerender", i.onPrerender, i), e.runners.contextChange.add(i), i._dcIndex = 0, i._aIndex = 0, i._iIndex = 0, i._attributeBuffer = null, i._indexBuffer = null, i._tempBoundTextures = [], i;
    }
    return t.prototype.contextChange = function() {
      var e = this.renderer.gl;
      J.PREFER_ENV === Bn.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), J.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = sb(this.MAX_TEXTURES, e)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
      for (var i = 0; i < this._packedGeometryPoolSize; i++)
        this._packedGeometries[i] = new this.geometryClass();
      this.initFlushBuffers();
    }, t.prototype.initFlushBuffers = function() {
      for (var e = t._drawCallPool, i = t._textureArrayPool, n = this.size / 4, s = Math.floor(n / this.MAX_TEXTURES) + 1; e.length < n; )
        e.push(new td());
      for (; i.length < s; )
        i.push(new ed());
      for (var o = 0; o < this.MAX_TEXTURES; o++)
        this._tempBoundTextures[o] = null;
    }, t.prototype.onPrerender = function() {
      this._flushId = 0;
    }, t.prototype.render = function(e) {
      e._texture.valid && (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e);
    }, t.prototype.buildTexturesAndDrawCalls = function() {
      var e = this, i = e._bufferedTextures, n = e.MAX_TEXTURES, s = t._textureArrayPool, o = this.renderer.batch, a = this._tempBoundTextures, l = this.renderer.textureGC.count, u = ++Mt._globalBatch, c = 0, d = s[0], f = 0;
      o.copyBoundTextures(a, n);
      for (var v = 0; v < this._bufferSize; ++v) {
        var m = i[v];
        i[v] = null, m._batchEnabled !== u && (d.count >= n && (o.boundArray(d, a, u, n), this.buildDrawCalls(d, f, v), f = v, d = s[++c], ++u), m._batchEnabled = u, m.touched = l, d.elements[d.count++] = m);
      }
      d.count > 0 && (o.boundArray(d, a, u, n), this.buildDrawCalls(d, f, this._bufferSize), ++c, ++u);
      for (var v = 0; v < a.length; v++)
        a[v] = null;
      Mt._globalBatch = u;
    }, t.prototype.buildDrawCalls = function(e, i, n) {
      var s = this, o = s._bufferedElements, a = s._attributeBuffer, l = s._indexBuffer, u = s.vertexSize, c = t._drawCallPool, d = this._dcIndex, f = this._aIndex, v = this._iIndex, m = c[d];
      m.start = this._iIndex, m.texArray = e;
      for (var p = i; p < n; ++p) {
        var y = o[p], b = y._texture.baseTexture, w = G0[b.alphaMode ? 1 : 0][y.blendMode];
        o[p] = null, i < p && m.blend !== w && (m.size = v - m.start, i = p, m = c[++d], m.texArray = e, m.start = v), this.packInterleavedGeometry(y, a, l, f, v), f += y.vertexData.length / 2 * u, v += y.indices.length, m.blend = w;
      }
      i < n && (m.size = v - m.start, ++d), this._dcIndex = d, this._aIndex = f, this._iIndex = v;
    }, t.prototype.bindAndClearTexArray = function(e) {
      for (var i = this.renderer.texture, n = 0; n < e.count; n++)
        i.bind(e.elements[n], e.ids[n]), e.elements[n] = null;
      e.count = 0;
    }, t.prototype.updateGeometry = function() {
      var e = this, i = e._packedGeometries, n = e._attributeBuffer, s = e._indexBuffer;
      J.CAN_UPLOAD_SAME_BUFFER ? (i[this._flushId]._buffer.update(n.rawBinaryData), i[this._flushId]._indexBuffer.update(s), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, i[this._flushId] = new this.geometryClass()), i[this._flushId]._buffer.update(n.rawBinaryData), i[this._flushId]._indexBuffer.update(s), this.renderer.geometry.bind(i[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
    }, t.prototype.drawBatches = function() {
      for (var e = this._dcIndex, i = this.renderer, n = i.gl, s = i.state, o = t._drawCallPool, a = null, l = 0; l < e; l++) {
        var u = o[l], c = u.texArray, d = u.type, f = u.size, v = u.start, m = u.blend;
        a !== c && (a = c, this.bindAndClearTexArray(c)), this.state.blendMode = m, s.set(this.state), n.drawElements(d, f, n.UNSIGNED_SHORT, v * 2);
      }
    }, t.prototype.flush = function() {
      this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
    }, t.prototype.start = function() {
      this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), J.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }, t.prototype.stop = function() {
      this.flush();
    }, t.prototype.destroy = function() {
      for (var e = 0; e < this._packedGeometryPoolSize; e++)
        this._packedGeometries[e] && this._packedGeometries[e].destroy();
      this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), r.prototype.destroy.call(this);
    }, t.prototype.getAttributeBuffer = function(e) {
      var i = qf(Math.ceil(e / 8)), n = ug(i), s = i * 8;
      this._aBuffers.length <= n && (this._iBuffers.length = n + 1);
      var o = this._aBuffers[s];
      return o || (this._aBuffers[s] = o = new id(s * this.vertexSize * 4)), o;
    }, t.prototype.getIndexBuffer = function(e) {
      var i = qf(Math.ceil(e / 12)), n = ug(i), s = i * 12;
      this._iBuffers.length <= n && (this._iBuffers.length = n + 1);
      var o = this._iBuffers[n];
      return o || (this._iBuffers[n] = o = new Uint16Array(s)), o;
    }, t.prototype.packInterleavedGeometry = function(e, i, n, s, o) {
      for (var a = i.uint32View, l = i.float32View, u = s / this.vertexSize, c = e.uvs, d = e.indices, f = e.vertexData, v = e._texture.baseTexture._batchLocation, m = Math.min(e.worldAlpha, 1), p = m < 1 && e._texture.baseTexture.alphaMode ? Zm(e._tintRGB, m) : e._tintRGB + (m * 255 << 24), y = 0; y < f.length; y += 2)
        l[s++] = f[y], l[s++] = f[y + 1], l[s++] = c[y], l[s++] = c[y + 1], a[s++] = p, l[s++] = v;
      for (var y = 0; y < d.length; y++)
        n[o++] = u + d[y];
    }, t._drawCallPool = [], t._textureArrayPool = [], t;
  }(Rc)
), _b = (
  /** @class */
  function() {
    function r(t, e) {
      if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf("%count%") < 0)
        throw new Error('Fragment template must contain "%count%".');
      if (e.indexOf("%forloop%") < 0)
        throw new Error('Fragment template must contain "%forloop%".');
    }
    return r.prototype.generateShader = function(t) {
      if (!this.programCache[t]) {
        for (var e = new Int32Array(t), i = 0; i < t; i++)
          e[i] = i;
        this.defaultGroupCache[t] = ms.from({ uSamplers: e }, !0);
        var n = this.fragTemplate;
        n = n.replace(/%count%/gi, "" + t), n = n.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new Hh(this.vertexSrc, n);
      }
      var s = {
        tint: new Float32Array([1, 1, 1, 1]),
        translationMatrix: new De(),
        default: this.defaultGroupCache[t]
      };
      return new Dn(this.programCache[t], s);
    }, r.prototype.generateSampleSrc = function(t) {
      var e = "";
      e += `
`, e += `
`;
      for (var i = 0; i < t; i++)
        i > 0 && (e += `
else `), i < t - 1 && (e += "if(vTextureId < " + i + ".5)"), e += `
{`, e += `
	color = texture2D(uSamplers[` + i + "], vTextureCoord);", e += `
}`;
      return e += `
`, e += `
`, e;
    }, r;
  }()
), T_ = (
  /** @class */
  function(r) {
    se(t, r);
    function t(e) {
      e === void 0 && (e = !1);
      var i = r.call(this) || this;
      return i._buffer = new Ce(null, e, !1), i._indexBuffer = new Ce(null, e, !0), i.addAttribute("aVertexPosition", i._buffer, 2, !1, ct.FLOAT).addAttribute("aTextureCoord", i._buffer, 2, !1, ct.FLOAT).addAttribute("aColor", i._buffer, 4, !0, ct.UNSIGNED_BYTE).addAttribute("aTextureId", i._buffer, 1, !0, ct.FLOAT).addIndex(i._indexBuffer), i;
    }
    return t;
  }(jh)
), Sg = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`, Pg = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`, gb = (
  /** @class */
  function() {
    function r() {
    }
    return r.create = function(t) {
      var e = Object.assign({
        vertex: Sg,
        fragment: Pg,
        geometryClass: T_,
        vertexSize: 6
      }, t), i = e.vertex, n = e.fragment, s = e.vertexSize, o = e.geometryClass;
      return (
        /** @class */
        function(a) {
          se(l, a);
          function l(u) {
            var c = a.call(this, u) || this;
            return c.shaderGenerator = new _b(i, n), c.geometryClass = o, c.vertexSize = s, c;
          }
          return l;
        }(mb)
      );
    }, Object.defineProperty(r, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @readonly
       */
      get: function() {
        return Sg;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "defaultFragmentTemplate", {
      /**
       * The default fragment shader source
       * @readonly
       */
      get: function() {
        return Pg;
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
), S_ = gb.create();
Object.assign(S_, {
  extension: {
    name: "batch",
    type: qt.RendererPlugin
  }
});
var bb = {}, QP = function(r) {
  Object.defineProperty(bb, r, {
    get: function() {
      return ci("6.0.0", "PIXI.systems." + r + " has moved to PIXI." + r), Y0[r];
    }
  });
};
for (var P_ in Y0)
  QP(P_);
var xb = {}, tO = function(r) {
  Object.defineProperty(xb, r, {
    get: function() {
      return ci("6.0.0", "PIXI.resources." + r + " has moved to PIXI." + r), pb[r];
    }
  });
};
for (var P_ in pb)
  tO(P_);
var eO = "6.5.9";
const iO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbstractBatchRenderer: mb,
  AbstractMultiResource: Rv,
  AbstractRenderer: vb,
  ArrayResource: Jm,
  Attribute: Oy,
  BaseImageResource: Zr,
  BaseRenderTexture: n_,
  BaseTexture: Mt,
  BatchDrawCall: td,
  BatchGeometry: T_,
  BatchPluginFactory: gb,
  BatchRenderer: S_,
  BatchShaderGenerator: _b,
  BatchSystem: h_,
  BatchTextureArray: ed,
  Buffer: Ce,
  BufferResource: Qo,
  CanvasResource: Qm,
  ContextSystem: l_,
  CubeResource: t_,
  get ExtensionType() {
    return qt;
  },
  Filter: wr,
  FilterState: K0,
  FilterSystem: a_,
  Framebuffer: Qf,
  FramebufferSystem: u_,
  GLFramebuffer: J0,
  GLProgram: fb,
  GLTexture: df,
  Geometry: jh,
  GeometrySystem: c_,
  IGLUniformData: DP,
  INSTALLED: Ol,
  ImageBitmapResource: r_,
  ImageResource: kv,
  MaskData: Q0,
  MaskSystem: f_,
  ObjectRenderer: Rc,
  Program: Hh,
  ProjectionSystem: v_,
  Quad: Z0,
  QuadUv: o_,
  RenderTexture: Wi,
  RenderTexturePool: q0,
  RenderTextureSystem: y_,
  Renderer: x_,
  Resource: qo,
  SVGResource: e_,
  ScissorSystem: d_,
  Shader: Dn,
  ShaderSystem: m_,
  SpriteMaskFilter: ob,
  State: _s,
  StateSystem: __,
  StencilSystem: p_,
  System: JP,
  Texture: ut,
  TextureGCSystem: g_,
  TextureMatrix: Nv,
  TextureSystem: b_,
  TextureUvs: s_,
  UniformGroup: ms,
  VERSION: eO,
  VideoResource: i_,
  ViewableBuffer: id,
  autoDetectRenderer: w_,
  autoDetectResource: Mv,
  checkMaxIfStatementsInShader: sb,
  createUBOElements: lb,
  defaultFilterVertex: E_,
  defaultVertex: yb,
  extensions: Tr,
  generateProgram: db,
  generateUniformBufferSync: cb,
  getTestContext: ib,
  getUBOData: ub,
  resources: bb,
  systems: xb,
  uniformParsers: Vo
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * @pixi/accessibility - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/accessibility is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var rO = {
  /**
   *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
   *   shadow div with attributes set
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  accessible: !1,
  /**
   * Sets the title attribute of the shadow div
   * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
   * @member {?string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleTitle: null,
  /**
   * Sets the aria-label attribute of the shadow div
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleHint: null,
  /**
   * @member {number}
   * @memberof PIXI.DisplayObject#
   * @private
   * @todo Needs docs.
   */
  tabIndex: 0,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleActive: !1,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleDiv: null,
  /**
   * Specify the type of div the accessible layer is. Screen readers treat the element differently
   * depending on this type. Defaults to button.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'button'
   */
  accessibleType: "button",
  /**
   * Specify the pointer-events the accessible div will use
   * Defaults to auto.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'auto'
   */
  accessiblePointerEvents: "auto",
  /**
   * Setting to false will prevent any children inside this container to
   * be accessible. Defaults to true.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @default true
   */
  accessibleChildren: !0,
  renderId: -1
};
xe.mixin(rO);
var nO = 9, Xc = 100, sO = 0, oO = 0, Og = 2, Ig = 1, aO = -1e3, hO = -1e3, lO = 2, uO = (
  /** @class */
  function() {
    function r(t) {
      this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (Xr.tablet || Xr.phone) && this.createTouchHook();
      var e = document.createElement("div");
      e.style.width = Xc + "px", e.style.height = Xc + "px", e.style.position = "absolute", e.style.top = sO + "px", e.style.left = oO + "px", e.style.zIndex = Og.toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1);
    }
    return Object.defineProperty(r.prototype, "isActive", {
      /**
       * Value of `true` if accessibility is currently active and accessibility layers are showing.
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this._isActive;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "isMobileAccessibility", {
      /**
       * Value of `true` if accessibility is enabled for touch devices.
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this._isMobileAccessibility;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.createTouchHook = function() {
      var t = this, e = document.createElement("button");
      e.style.width = Ig + "px", e.style.height = Ig + "px", e.style.position = "absolute", e.style.top = aO + "px", e.style.left = hO + "px", e.style.zIndex = lO.toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessibility for this content", e.addEventListener("focus", function() {
        t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook();
      }), document.body.appendChild(e), this._hookDiv = e;
    }, r.prototype.destroyTouchHook = function() {
      this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
    }, r.prototype.activate = function() {
      var t;
      this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), (t = this.renderer.view.parentNode) === null || t === void 0 || t.appendChild(this.div));
    }, r.prototype.deactivate = function() {
      var t;
      !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), (t = this.div.parentNode) === null || t === void 0 || t.removeChild(this.div));
    }, r.prototype.updateAccessibleObjects = function(t) {
      if (!(!t.visible || !t.accessibleChildren)) {
        t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);
        var e = t.children;
        if (e)
          for (var i = 0; i < e.length; i++)
            this.updateAccessibleObjects(e[i]);
      }
    }, r.prototype.update = function() {
      var t = performance.now();
      if (!(Xr.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, !!this.renderer.renderingToScreen)) {
        this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);
        var e = this.renderer.view.getBoundingClientRect(), i = e.left, n = e.top, s = e.width, o = e.height, a = this.renderer, l = a.width, u = a.height, c = a.resolution, d = s / l * c, f = o / u * c, v = this.div;
        v.style.left = i + "px", v.style.top = n + "px", v.style.width = l + "px", v.style.height = u + "px";
        for (var m = 0; m < this.children.length; m++) {
          var p = this.children[m];
          if (p.renderId !== this.renderId)
            p._accessibleActive = !1, xa(this.children, m, 1), this.div.removeChild(p._accessibleDiv), this.pool.push(p._accessibleDiv), p._accessibleDiv = null, m--;
          else {
            v = p._accessibleDiv;
            var y = p.hitArea, b = p.worldTransform;
            p.hitArea ? (v.style.left = (b.tx + y.x * b.a) * d + "px", v.style.top = (b.ty + y.y * b.d) * f + "px", v.style.width = y.width * b.a * d + "px", v.style.height = y.height * b.d * f + "px") : (y = p.getBounds(), this.capHitArea(y), v.style.left = y.x * d + "px", v.style.top = y.y * f + "px", v.style.width = y.width * d + "px", v.style.height = y.height * f + "px", v.title !== p.accessibleTitle && p.accessibleTitle !== null && (v.title = p.accessibleTitle), v.getAttribute("aria-label") !== p.accessibleHint && p.accessibleHint !== null && v.setAttribute("aria-label", p.accessibleHint)), (p.accessibleTitle !== v.title || p.tabIndex !== v.tabIndex) && (v.title = p.accessibleTitle, v.tabIndex = p.tabIndex, this.debug && this.updateDebugHTML(v));
          }
        }
        this.renderId++;
      }
    }, r.prototype.updateDebugHTML = function(t) {
      t.innerHTML = "type: " + t.type + "</br> title : " + t.title + "</br> tabIndex: " + t.tabIndex;
    }, r.prototype.capHitArea = function(t) {
      t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
      var e = this.renderer, i = e.width, n = e.height;
      t.x + t.width > i && (t.width = i - t.x), t.y + t.height > n && (t.height = n - t.y);
    }, r.prototype.addChild = function(t) {
      var e = this.pool.pop();
      e || (e = document.createElement("button"), e.style.width = Xc + "px", e.style.height = Xc + "px", e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = Og.toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = "displayObject " + t.tabIndex), t.accessibleHint && t.accessibleHint !== null && e.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex;
    }, r.prototype._onClick = function(t) {
      var e = this.renderer.plugins.interaction, i = t.target.displayObject, n = e.eventData;
      e.dispatchEvent(i, "click", n), e.dispatchEvent(i, "pointertap", n), e.dispatchEvent(i, "tap", n);
    }, r.prototype._onFocus = function(t) {
      t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive");
      var e = this.renderer.plugins.interaction, i = t.target.displayObject, n = e.eventData;
      e.dispatchEvent(i, "mouseover", n);
    }, r.prototype._onFocusOut = function(t) {
      t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite");
      var e = this.renderer.plugins.interaction, i = t.target.displayObject, n = e.eventData;
      e.dispatchEvent(i, "mouseout", n);
    }, r.prototype._onKeyDown = function(t) {
      t.keyCode === nO && this.activate();
    }, r.prototype._onMouseMove = function(t) {
      t.movementX === 0 && t.movementY === 0 || this.deactivate();
    }, r.prototype.destroy = function() {
      this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;
    }, r.extension = {
      name: "accessibility",
      type: [
        qt.RendererPlugin,
        qt.CanvasRendererPlugin
      ]
    }, r;
  }()
);
/*!
 * @pixi/interaction - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Cg = (
  /** @class */
  function() {
    function r() {
      this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new te(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;
    }
    return Object.defineProperty(r.prototype, "pointerId", {
      /**
       * The unique identifier of the pointer. It will be the same as `identifier`.
       * @readonly
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
       */
      get: function() {
        return this.identifier;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.getLocalPosition = function(t, e, i) {
      return t.worldTransform.applyInverse(i || this.global, e);
    }, r.prototype.copyEvent = function(t) {
      "isPrimary" in t && t.isPrimary && (this.isPrimary = !0), this.button = "button" in t && t.button;
      var e = "buttons" in t && t.buttons;
      this.buttons = Number.isInteger(e) ? e : "which" in t && t.which, this.width = "width" in t && t.width, this.height = "height" in t && t.height, this.tiltX = "tiltX" in t && t.tiltX, this.tiltY = "tiltY" in t && t.tiltY, this.pointerType = "pointerType" in t && t.pointerType, this.pressure = "pressure" in t && t.pressure, this.rotationAngle = "rotationAngle" in t && t.rotationAngle, this.twist = "twist" in t && t.twist || 0, this.tangentialPressure = "tangentialPressure" in t && t.tangentialPressure || 0;
    }, r.prototype.reset = function() {
      this.isPrimary = !1;
    }, r;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Iy = function(r, t) {
  return Iy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Iy(r, t);
};
function cO(r, t) {
  Iy(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fO = (
  /** @class */
  function() {
    function r() {
      this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null;
    }
    return r.prototype.stopPropagation = function() {
      this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget;
    }, r.prototype.reset = function() {
      this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null;
    }, r;
  }()
), ry = (
  /** @class */
  function() {
    function r(t) {
      this._pointerId = t, this._flags = r.FLAGS.NONE;
    }
    return r.prototype._doSet = function(t, e) {
      e ? this._flags = this._flags | t : this._flags = this._flags & ~t;
    }, Object.defineProperty(r.prototype, "pointerId", {
      /**
       * Unique pointer id of the event
       * @readonly
       * @private
       * @member {number}
       */
      get: function() {
        return this._pointerId;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "flags", {
      /**
       * State of the tracking data, expressed as bit flags
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags;
      },
      set: function(t) {
        this._flags = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "none", {
      /**
       * Is the tracked event inactive (not over or down)?
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags === r.FLAGS.NONE;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "over", {
      /**
       * Is the tracked event over the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & r.FLAGS.OVER) !== 0;
      },
      set: function(t) {
        this._doSet(r.FLAGS.OVER, t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "rightDown", {
      /**
       * Did the right mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & r.FLAGS.RIGHT_DOWN) !== 0;
      },
      set: function(t) {
        this._doSet(r.FLAGS.RIGHT_DOWN, t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "leftDown", {
      /**
       * Did the left mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & r.FLAGS.LEFT_DOWN) !== 0;
      },
      set: function(t) {
        this._doSet(r.FLAGS.LEFT_DOWN, t);
      },
      enumerable: !1,
      configurable: !0
    }), r.FLAGS = Object.freeze({
      NONE: 0,
      OVER: 1 << 0,
      LEFT_DOWN: 1 << 1,
      RIGHT_DOWN: 1 << 2
    }), r;
  }()
), dO = (
  /** @class */
  function() {
    function r() {
      this._tempPoint = new te();
    }
    return r.prototype.recursiveFindHit = function(t, e, i, n, s) {
      var o;
      if (!e || !e.visible)
        return !1;
      var a = t.data.global;
      s = e.interactive || s;
      var l = !1, u = s, c = !0;
      if (e.hitArea)
        n && (e.worldTransform.applyInverse(a, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? l = !0 : (n = !1, c = !1)), u = !1;
      else if (e._mask && n) {
        var d = e._mask.isMaskData ? e._mask.maskObject : e._mask;
        d && !(!((o = d.containsPoint) === null || o === void 0) && o.call(d, a)) && (n = !1);
      }
      if (c && e.interactiveChildren && e.children)
        for (var f = e.children, v = f.length - 1; v >= 0; v--) {
          var m = f[v], p = this.recursiveFindHit(t, m, i, n, u);
          if (p) {
            if (!m.parent)
              continue;
            u = !1, p && (t.target && (n = !1), l = !0);
          }
        }
      return s && (n && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(a) && (l = !0), e.interactive && (l && !t.target && (t.target = e), i && i(t, e, !!l))), l;
    }, r.prototype.findHit = function(t, e, i, n) {
      this.recursiveFindHit(t, e, i, n, !1);
    }, r;
  }()
), pO = {
  interactive: !1,
  interactiveChildren: !0,
  hitArea: null,
  /**
   * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
   * Setting this changes the 'cursor' property to `'pointer'`.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.buttonMode = true;
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  get buttonMode() {
    return this.cursor === "pointer";
  },
  set buttonMode(r) {
    r ? this.cursor = "pointer" : this.cursor === "pointer" && (this.cursor = null);
  },
  /**
   * This defines what cursor mode is used when the mouse cursor
   * is hovered over the displayObject.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.cursor = 'wait';
   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  cursor: null,
  /**
   * Internal set of all active pointers, by identifier
   * @member {Map<number, InteractionTrackingData>}
   * @memberof PIXI.DisplayObject#
   * @private
   */
  get trackedPointers() {
    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;
  },
  /**
   * Map of all tracked pointers, by identifier. Use trackedPointers to access.
   * @private
   * @type {Map<number, InteractionTrackingData>}
   */
  _trackedPointers: void 0
};
xe.mixin(pO);
var Wc = 1, Yc = {
  target: null,
  data: {
    global: null
  }
}, vO = (
  /** @class */
  function(r) {
    cO(t, r);
    function t(e, i) {
      var n = r.call(this) || this;
      return i = i || {}, n.renderer = e, n.autoPreventDefault = i.autoPreventDefault !== void 0 ? i.autoPreventDefault : !0, n.interactionFrequency = i.interactionFrequency || 10, n.mouse = new Cg(), n.mouse.identifier = Wc, n.mouse.global.set(-999999), n.activeInteractionData = {}, n.activeInteractionData[Wc] = n.mouse, n.interactionDataPool = [], n.eventData = new fO(), n.interactionDOMElement = null, n.moveWhenInside = !1, n.eventsAdded = !1, n.tickerAdded = !1, n.mouseOverRenderer = !("PointerEvent" in globalThis), n.supportsTouchEvents = "ontouchstart" in globalThis, n.supportsPointerEvents = !!globalThis.PointerEvent, n.onPointerUp = n.onPointerUp.bind(n), n.processPointerUp = n.processPointerUp.bind(n), n.onPointerCancel = n.onPointerCancel.bind(n), n.processPointerCancel = n.processPointerCancel.bind(n), n.onPointerDown = n.onPointerDown.bind(n), n.processPointerDown = n.processPointerDown.bind(n), n.onPointerMove = n.onPointerMove.bind(n), n.processPointerMove = n.processPointerMove.bind(n), n.onPointerOut = n.onPointerOut.bind(n), n.processPointerOverOut = n.processPointerOverOut.bind(n), n.onPointerOver = n.onPointerOver.bind(n), n.cursorStyles = {
        default: "inherit",
        pointer: "pointer"
      }, n.currentCursorMode = null, n.cursor = null, n.resolution = 1, n.delayedEvents = [], n.search = new dO(), n._tempDisplayObject = new W0(), n._eventListenerOptions = { capture: !0, passive: !1 }, n._useSystemTicker = i.useSystemTicker !== void 0 ? i.useSystemTicker : !0, n.setTargetElement(n.renderer.view, n.renderer.resolution), n;
    }
    return Object.defineProperty(t.prototype, "useSystemTicker", {
      /**
       * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.
       * @default true
       */
      get: function() {
        return this._useSystemTicker;
      },
      set: function(e) {
        this._useSystemTicker = e, e ? this.addTickerListener() : this.removeTickerListener();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastObjectRendered", {
      /**
       * Last rendered object or temp object.
       * @readonly
       * @protected
       */
      get: function() {
        return this.renderer._lastObjectRendered || this._tempDisplayObject;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.hitTest = function(e, i) {
      return Yc.target = null, Yc.data.global = e, i || (i = this.lastObjectRendered), this.processInteractive(Yc, i, null, !0), Yc.target;
    }, t.prototype.setTargetElement = function(e, i) {
      i === void 0 && (i = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = e, this.resolution = i, this.addEvents(), this.addTickerListener();
    }, t.prototype.addTickerListener = function() {
      this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker || (_e.system.add(this.tickerUpdate, this, Un.INTERACTION), this.tickerAdded = !0);
    }, t.prototype.removeTickerListener = function() {
      this.tickerAdded && (_e.system.remove(this.tickerUpdate, this), this.tickerAdded = !1);
    }, t.prototype.addEvents = function() {
      if (!(this.eventsAdded || !this.interactionDOMElement)) {
        var e = this.interactionDOMElement.style;
        globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "none", e.msTouchAction = "none") : this.supportsPointerEvents && (e.touchAction = "none"), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0;
      }
    }, t.prototype.removeEvents = function() {
      if (!(!this.eventsAdded || !this.interactionDOMElement)) {
        var e = this.interactionDOMElement.style;
        globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "", e.msTouchAction = "") : this.supportsPointerEvents && (e.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1;
      }
    }, t.prototype.tickerUpdate = function(e) {
      this._deltaTime += e, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());
    }, t.prototype.update = function() {
      if (this.interactionDOMElement) {
        if (this._didMove) {
          this._didMove = !1;
          return;
        }
        this.cursor = null;
        for (var e in this.activeInteractionData)
          if (this.activeInteractionData.hasOwnProperty(e)) {
            var i = this.activeInteractionData[e];
            if (i.originalEvent && i.pointerType !== "touch") {
              var n = this.configureInteractionEventForDOMEvent(this.eventData, i.originalEvent, i);
              this.processInteractive(n, this.lastObjectRendered, this.processPointerOverOut, !0);
            }
          }
        this.setCursorMode(this.cursor);
      }
    }, t.prototype.setCursorMode = function(e) {
      e = e || "default";
      var i = !0;
      if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (i = !1), this.currentCursorMode !== e) {
        this.currentCursorMode = e;
        var n = this.cursorStyles[e];
        if (n)
          switch (typeof n) {
            case "string":
              i && (this.interactionDOMElement.style.cursor = n);
              break;
            case "function":
              n(e);
              break;
            case "object":
              i && Object.assign(this.interactionDOMElement.style, n);
              break;
          }
        else
          i && typeof e == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.interactionDOMElement.style.cursor = e);
      }
    }, t.prototype.dispatchEvent = function(e, i, n) {
      (!n.stopPropagationHint || e === n.stopsPropagatingAt) && (n.currentTarget = e, n.type = i, e.emit(i, n), e[i] && e[i](n));
    }, t.prototype.delayDispatchEvent = function(e, i, n) {
      this.delayedEvents.push({ displayObject: e, eventString: i, eventData: n });
    }, t.prototype.mapPositionToPoint = function(e, i, n) {
      var s;
      this.interactionDOMElement.parentElement ? s = this.interactionDOMElement.getBoundingClientRect() : s = {
        x: 0,
        y: 0,
        width: this.interactionDOMElement.width,
        height: this.interactionDOMElement.height,
        left: 0,
        top: 0
      };
      var o = 1 / this.resolution;
      e.x = (i - s.left) * (this.interactionDOMElement.width / s.width) * o, e.y = (n - s.top) * (this.interactionDOMElement.height / s.height) * o;
    }, t.prototype.processInteractive = function(e, i, n, s) {
      var o = this.search.findHit(e, i, n, s), a = this.delayedEvents;
      if (!a.length)
        return o;
      e.stopPropagationHint = !1;
      var l = a.length;
      this.delayedEvents = [];
      for (var u = 0; u < l; u++) {
        var c = a[u], d = c.displayObject, f = c.eventString, v = c.eventData;
        v.stopsPropagatingAt === d && (v.stopPropagationHint = !0), this.dispatchEvent(d, f, v);
      }
      return o;
    }, t.prototype.onPointerDown = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var i = this.normalizeToPointerData(e);
        if (this.autoPreventDefault && i[0].isNormalized) {
          var n = e.cancelable || !("cancelable" in e);
          n && e.preventDefault();
        }
        for (var s = i.length, o = 0; o < s; o++) {
          var a = i[o], l = this.getInteractionDataForPointerId(a), u = this.configureInteractionEventForDOMEvent(this.eventData, a, l);
          if (u.data.originalEvent = e, this.processInteractive(u, this.lastObjectRendered, this.processPointerDown, !0), this.emit("pointerdown", u), a.pointerType === "touch")
            this.emit("touchstart", u);
          else if (a.pointerType === "mouse" || a.pointerType === "pen") {
            var c = a.button === 2;
            this.emit(c ? "rightdown" : "mousedown", this.eventData);
          }
        }
      }
    }, t.prototype.processPointerDown = function(e, i, n) {
      var s = e.data, o = e.data.identifier;
      if (n) {
        if (i.trackedPointers[o] || (i.trackedPointers[o] = new ry(o)), this.dispatchEvent(i, "pointerdown", e), s.pointerType === "touch")
          this.dispatchEvent(i, "touchstart", e);
        else if (s.pointerType === "mouse" || s.pointerType === "pen") {
          var a = s.button === 2;
          a ? i.trackedPointers[o].rightDown = !0 : i.trackedPointers[o].leftDown = !0, this.dispatchEvent(i, a ? "rightdown" : "mousedown", e);
        }
      }
    }, t.prototype.onPointerComplete = function(e, i, n) {
      var s = this.normalizeToPointerData(e), o = s.length, a = e.target;
      e.composedPath && e.composedPath().length > 0 && (a = e.composedPath()[0]);
      for (var l = a !== this.interactionDOMElement ? "outside" : "", u = 0; u < o; u++) {
        var c = s[u], d = this.getInteractionDataForPointerId(c), f = this.configureInteractionEventForDOMEvent(this.eventData, c, d);
        if (f.data.originalEvent = e, this.processInteractive(f, this.lastObjectRendered, n, i || !l), this.emit(i ? "pointercancel" : "pointerup" + l, f), c.pointerType === "mouse" || c.pointerType === "pen") {
          var v = c.button === 2;
          this.emit(v ? "rightup" + l : "mouseup" + l, f);
        } else
          c.pointerType === "touch" && (this.emit(i ? "touchcancel" : "touchend" + l, f), this.releaseInteractionDataForPointerId(c.pointerId));
      }
    }, t.prototype.onPointerCancel = function(e) {
      this.supportsTouchEvents && e.pointerType === "touch" || this.onPointerComplete(e, !0, this.processPointerCancel);
    }, t.prototype.processPointerCancel = function(e, i) {
      var n = e.data, s = e.data.identifier;
      i.trackedPointers[s] !== void 0 && (delete i.trackedPointers[s], this.dispatchEvent(i, "pointercancel", e), n.pointerType === "touch" && this.dispatchEvent(i, "touchcancel", e));
    }, t.prototype.onPointerUp = function(e) {
      this.supportsTouchEvents && e.pointerType === "touch" || this.onPointerComplete(e, !1, this.processPointerUp);
    }, t.prototype.processPointerUp = function(e, i, n) {
      var s = e.data, o = e.data.identifier, a = i.trackedPointers[o], l = s.pointerType === "touch", u = s.pointerType === "mouse" || s.pointerType === "pen", c = !1;
      if (u) {
        var d = s.button === 2, f = ry.FLAGS, v = d ? f.RIGHT_DOWN : f.LEFT_DOWN, m = a !== void 0 && a.flags & v;
        n ? (this.dispatchEvent(i, d ? "rightup" : "mouseup", e), m && (this.dispatchEvent(i, d ? "rightclick" : "click", e), c = !0)) : m && this.dispatchEvent(i, d ? "rightupoutside" : "mouseupoutside", e), a && (d ? a.rightDown = !1 : a.leftDown = !1);
      }
      n ? (this.dispatchEvent(i, "pointerup", e), l && this.dispatchEvent(i, "touchend", e), a && ((!u || c) && this.dispatchEvent(i, "pointertap", e), l && (this.dispatchEvent(i, "tap", e), a.over = !1))) : a && (this.dispatchEvent(i, "pointerupoutside", e), l && this.dispatchEvent(i, "touchendoutside", e)), a && a.none && delete i.trackedPointers[o];
    }, t.prototype.onPointerMove = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var i = this.normalizeToPointerData(e);
        (i[0].pointerType === "mouse" || i[0].pointerType === "pen") && (this._didMove = !0, this.cursor = null);
        for (var n = i.length, s = 0; s < n; s++) {
          var o = i[s], a = this.getInteractionDataForPointerId(o), l = this.configureInteractionEventForDOMEvent(this.eventData, o, a);
          l.data.originalEvent = e, this.processInteractive(l, this.lastObjectRendered, this.processPointerMove, !0), this.emit("pointermove", l), o.pointerType === "touch" && this.emit("touchmove", l), (o.pointerType === "mouse" || o.pointerType === "pen") && this.emit("mousemove", l);
        }
        i[0].pointerType === "mouse" && this.setCursorMode(this.cursor);
      }
    }, t.prototype.processPointerMove = function(e, i, n) {
      var s = e.data, o = s.pointerType === "touch", a = s.pointerType === "mouse" || s.pointerType === "pen";
      a && this.processPointerOverOut(e, i, n), (!this.moveWhenInside || n) && (this.dispatchEvent(i, "pointermove", e), o && this.dispatchEvent(i, "touchmove", e), a && this.dispatchEvent(i, "mousemove", e));
    }, t.prototype.onPointerOut = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var i = this.normalizeToPointerData(e), n = i[0];
        n.pointerType === "mouse" && (this.mouseOverRenderer = !1, this.setCursorMode(null));
        var s = this.getInteractionDataForPointerId(n), o = this.configureInteractionEventForDOMEvent(this.eventData, n, s);
        o.data.originalEvent = n, this.processInteractive(o, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit("pointerout", o), n.pointerType === "mouse" || n.pointerType === "pen" ? this.emit("mouseout", o) : this.releaseInteractionDataForPointerId(s.identifier);
      }
    }, t.prototype.processPointerOverOut = function(e, i, n) {
      var s = e.data, o = e.data.identifier, a = s.pointerType === "mouse" || s.pointerType === "pen", l = i.trackedPointers[o];
      n && !l && (l = i.trackedPointers[o] = new ry(o)), l !== void 0 && (n && this.mouseOverRenderer ? (l.over || (l.over = !0, this.delayDispatchEvent(i, "pointerover", e), a && this.delayDispatchEvent(i, "mouseover", e)), a && this.cursor === null && (this.cursor = i.cursor)) : l.over && (l.over = !1, this.dispatchEvent(i, "pointerout", this.eventData), a && this.dispatchEvent(i, "mouseout", e), l.none && delete i.trackedPointers[o]));
    }, t.prototype.onPointerOver = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var i = this.normalizeToPointerData(e), n = i[0], s = this.getInteractionDataForPointerId(n), o = this.configureInteractionEventForDOMEvent(this.eventData, n, s);
        o.data.originalEvent = n, n.pointerType === "mouse" && (this.mouseOverRenderer = !0), this.emit("pointerover", o), (n.pointerType === "mouse" || n.pointerType === "pen") && this.emit("mouseover", o);
      }
    }, t.prototype.getInteractionDataForPointerId = function(e) {
      var i = e.pointerId, n;
      return i === Wc || e.pointerType === "mouse" ? n = this.mouse : this.activeInteractionData[i] ? n = this.activeInteractionData[i] : (n = this.interactionDataPool.pop() || new Cg(), n.identifier = i, this.activeInteractionData[i] = n), n.copyEvent(e), n;
    }, t.prototype.releaseInteractionDataForPointerId = function(e) {
      var i = this.activeInteractionData[e];
      i && (delete this.activeInteractionData[e], i.reset(), this.interactionDataPool.push(i));
    }, t.prototype.configureInteractionEventForDOMEvent = function(e, i, n) {
      return e.data = n, this.mapPositionToPoint(n.global, i.clientX, i.clientY), i.pointerType === "touch" && (i.globalX = n.global.x, i.globalY = n.global.y), n.originalEvent = i, e.reset(), e;
    }, t.prototype.normalizeToPointerData = function(e) {
      var i = [];
      if (this.supportsTouchEvents && e instanceof TouchEvent)
        for (var n = 0, s = e.changedTouches.length; n < s; n++) {
          var o = e.changedTouches[n];
          typeof o.button > "u" && (o.button = e.touches.length ? 1 : 0), typeof o.buttons > "u" && (o.buttons = e.touches.length ? 1 : 0), typeof o.isPrimary > "u" && (o.isPrimary = e.touches.length === 1 && e.type === "touchstart"), typeof o.width > "u" && (o.width = o.radiusX || 1), typeof o.height > "u" && (o.height = o.radiusY || 1), typeof o.tiltX > "u" && (o.tiltX = 0), typeof o.tiltY > "u" && (o.tiltY = 0), typeof o.pointerType > "u" && (o.pointerType = "touch"), typeof o.pointerId > "u" && (o.pointerId = o.identifier || 0), typeof o.pressure > "u" && (o.pressure = o.force || 0.5), typeof o.twist > "u" && (o.twist = 0), typeof o.tangentialPressure > "u" && (o.tangentialPressure = 0), typeof o.layerX > "u" && (o.layerX = o.offsetX = o.clientX), typeof o.layerY > "u" && (o.layerY = o.offsetY = o.clientY), o.isNormalized = !0, i.push(o);
        }
      else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {
        var a = e;
        typeof a.isPrimary > "u" && (a.isPrimary = !0), typeof a.width > "u" && (a.width = 1), typeof a.height > "u" && (a.height = 1), typeof a.tiltX > "u" && (a.tiltX = 0), typeof a.tiltY > "u" && (a.tiltY = 0), typeof a.pointerType > "u" && (a.pointerType = "mouse"), typeof a.pointerId > "u" && (a.pointerId = Wc), typeof a.pressure > "u" && (a.pressure = 0.5), typeof a.twist > "u" && (a.twist = 0), typeof a.tangentialPressure > "u" && (a.tangentialPressure = 0), a.isNormalized = !0, i.push(a);
      } else
        i.push(e);
      return i;
    }, t.prototype.destroy = function() {
      this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;
    }, t.extension = {
      name: "interaction",
      type: [
        qt.RendererPlugin,
        qt.CanvasRendererPlugin
      ]
    }, t;
  }(Zi)
);
/*!
 * @pixi/extract - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var yO = new pt(), mO = 4, _O = (
  /** @class */
  function() {
    function r(t) {
      this.renderer = t;
    }
    return r.prototype.image = function(t, e, i) {
      var n = new Image();
      return n.src = this.base64(t, e, i), n;
    }, r.prototype.base64 = function(t, e, i) {
      return this.canvas(t).toDataURL(e, i);
    }, r.prototype.canvas = function(t, e) {
      var i = this._rawPixels(t, e), n = i.pixels, s = i.width, o = i.height, a = i.flipY, l = new dg(s, o, 1), u = l.context.getImageData(0, 0, s, o);
      if (r.arrayPostDivide(n, u.data), l.context.putImageData(u, 0, 0), a) {
        var c = new dg(l.width, l.height, 1);
        c.context.scale(1, -1), c.context.drawImage(l.canvas, 0, -o), l.destroy(), l = c;
      }
      return l.canvas;
    }, r.prototype.pixels = function(t, e) {
      var i = this._rawPixels(t, e).pixels;
      return r.arrayPostDivide(i, i), i;
    }, r.prototype._rawPixels = function(t, e) {
      var i = this.renderer, n, s = !1, o, a = !1;
      if (t)
        if (t instanceof Wi)
          o = t;
        else {
          var l = i.context.webGLVersion >= 2 ? i.multisample : ue.NONE;
          if (o = this.renderer.generateTexture(t, { multisample: l }), l !== ue.NONE) {
            var u = Wi.create({
              width: o.width,
              height: o.height
            });
            i.framebuffer.bind(o.framebuffer), i.framebuffer.blit(u.framebuffer), i.framebuffer.bind(null), o.destroy(!0), o = u;
          }
          a = !0;
        }
      o ? (n = o.baseTexture.resolution, e = e ?? o.frame, s = !1, i.renderTexture.bind(o)) : (n = i.resolution, e || (e = yO, e.width = i.width, e.height = i.height), s = !0, i.renderTexture.bind(null));
      var c = Math.round(e.width * n), d = Math.round(e.height * n), f = new Uint8Array(mO * c * d), v = i.gl;
      return v.readPixels(Math.round(e.x * n), Math.round(e.y * n), c, d, v.RGBA, v.UNSIGNED_BYTE, f), a && o.destroy(!0), { pixels: f, width: c, height: d, flipY: s };
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r.arrayPostDivide = function(t, e) {
      for (var i = 0; i < t.length; i += 4) {
        var n = e[i + 3] = t[i + 3];
        n !== 0 ? (e[i] = Math.round(Math.min(t[i] * 255 / n, 255)), e[i + 1] = Math.round(Math.min(t[i + 1] * 255 / n, 255)), e[i + 2] = Math.round(Math.min(t[i + 2] * 255 / n, 255))) : (e[i] = t[i], e[i + 1] = t[i + 1], e[i + 2] = t[i + 2]);
      }
    }, r.extension = {
      name: "extract",
      type: qt.RendererPlugin
    }, r;
  }()
);
/*!
 * @pixi/loaders - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var qc = (
  /** @class */
  function() {
    function r(t, e, i) {
      e === void 0 && (e = !1), this._fn = t, this._once = e, this._thisArg = i, this._next = this._prev = this._owner = null;
    }
    return r.prototype.detach = function() {
      return this._owner === null ? !1 : (this._owner.detach(this), !0);
    }, r;
  }()
);
function Mg(r, t) {
  return r._head ? (r._tail._next = t, t._prev = r._tail, r._tail = t) : (r._head = t, r._tail = t), t._owner = r, t;
}
var An = (
  /** @class */
  function() {
    function r() {
      this._head = this._tail = void 0;
    }
    return r.prototype.handlers = function(t) {
      t === void 0 && (t = !1);
      var e = this._head;
      if (t)
        return !!e;
      for (var i = []; e; )
        i.push(e), e = e._next;
      return i;
    }, r.prototype.has = function(t) {
      if (!(t instanceof qc))
        throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
      return t._owner === this;
    }, r.prototype.dispatch = function() {
      for (var t = arguments, e = [], i = 0; i < arguments.length; i++)
        e[i] = t[i];
      var n = this._head;
      if (!n)
        return !1;
      for (; n; )
        n._once && this.detach(n), n._fn.apply(n._thisArg, e), n = n._next;
      return !0;
    }, r.prototype.add = function(t, e) {
      if (e === void 0 && (e = null), typeof t != "function")
        throw new Error("MiniSignal#add(): First arg must be a Function.");
      return Mg(this, new qc(t, !1, e));
    }, r.prototype.once = function(t, e) {
      if (e === void 0 && (e = null), typeof t != "function")
        throw new Error("MiniSignal#once(): First arg must be a Function.");
      return Mg(this, new qc(t, !0, e));
    }, r.prototype.detach = function(t) {
      if (!(t instanceof qc))
        throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
      return t._owner !== this ? this : (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, t._next === null && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null, this);
    }, r.prototype.detachAll = function() {
      var t = this._head;
      if (!t)
        return this;
      for (this._head = this._tail = null; t; )
        t._owner = null, t = t._next;
      return this;
    }, r;
  }()
);
function wb(r, t) {
  t = t || {};
  for (var e = {
    // eslint-disable-next-line max-len
    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
    q: {
      name: "queryKey",
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      // eslint-disable-next-line max-len
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      // eslint-disable-next-line max-len
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  }, i = e.parser[t.strictMode ? "strict" : "loose"].exec(r), n = {}, s = 14; s--; )
    n[e.key[s]] = i[s] || "";
  return n[e.q.name] = {}, n[e.key[12]].replace(e.q.parser, function(o, a, l) {
    a && (n[e.q.name][a] = l);
  }), n;
}
var ny, Zc = null, gO = 0, Rg = 200, bO = 204, xO = 1223, wO = 2;
function kg() {
}
function Ng(r, t, e) {
  t && t.indexOf(".") === 0 && (t = t.substring(1)), t && (r[t] = e);
}
function sy(r) {
  return r.toString().replace("object ", "");
}
var bt = (
  /** @class */
  function() {
    function r(t, e, i) {
      if (this._dequeue = kg, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof t != "string" || typeof e != "string")
        throw new Error("Both name and url are required for constructing a resource.");
      i = i || {}, this._flags = 0, this._setFlag(r.STATUS_FLAGS.DATA_URL, e.indexOf("data:") === 0), this.name = t, this.url = e, this.extension = this._getExtension(), this.data = null, this.crossOrigin = i.crossOrigin === !0 ? "anonymous" : i.crossOrigin, this.timeout = i.timeout || 0, this.loadType = i.loadType || this._determineLoadType(), this.xhrType = i.xhrType, this.metadata = i.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = r.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = kg, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new An(), this.onProgress = new An(), this.onComplete = new An(), this.onAfterMiddleware = new An();
    }
    return r.setExtensionLoadType = function(t, e) {
      Ng(r._loadTypeMap, t, e);
    }, r.setExtensionXhrType = function(t, e) {
      Ng(r._xhrTypeMap, t, e);
    }, Object.defineProperty(r.prototype, "isDataUrl", {
      /**
       * When the resource starts to load.
       * @memberof PIXI.LoaderResource
       * @callback OnStartSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       */
      /**
       * When the resource reports loading progress.
       * @memberof PIXI.LoaderResource
       * @callback OnProgressSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       * @param {number} percentage - The progress of the load in the range [0, 1].
       */
      /**
       * When the resource finishes loading.
       * @memberof PIXI.LoaderResource
       * @callback OnCompleteSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       */
      /**
       * @memberof PIXI.LoaderResource
       * @typedef {object} IMetadata
       * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
       *      element to use for loading, instead of creating one.
       * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
       *      is useful if you want to pass in a `loadElement` that you already added load sources to.
       * @property {string|string[]} [mimeType] - The mime type to use for the source element
       *      of a video/audio elment. If the urls are an array, you can pass this as an array as well
       *      where each index is the mime type to use for the corresponding url index.
       */
      /**
       * Stores whether or not this url is a data url.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(r.STATUS_FLAGS.DATA_URL);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "isComplete", {
      /**
       * Describes if this resource has finished loading. Is true when the resource has completely
       * loaded.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(r.STATUS_FLAGS.COMPLETE);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "isLoading", {
      /**
       * Describes if this resource is currently loading. Is true when the resource starts loading,
       * and is false again when complete.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(r.STATUS_FLAGS.LOADING);
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.complete = function() {
      this._clearEvents(), this._finish();
    }, r.prototype.abort = function(t) {
      if (!this.error) {
        if (this.error = new Error(t), this._clearEvents(), this.xhr)
          this.xhr.abort();
        else if (this.xdr)
          this.xdr.abort();
        else if (this.data)
          if (this.data.src)
            this.data.src = r.EMPTY_GIF;
          else
            for (; this.data.firstChild; )
              this.data.removeChild(this.data.firstChild);
        this._finish();
      }
    }, r.prototype.load = function(t) {
      var e = this;
      if (!this.isLoading) {
        if (this.isComplete) {
          t && setTimeout(function() {
            return t(e);
          }, 1);
          return;
        } else
          t && this.onComplete.once(t);
        switch (this._setFlag(r.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), (this.crossOrigin === !1 || typeof this.crossOrigin != "string") && (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
          case r.LOAD_TYPE.IMAGE:
            this.type = r.TYPE.IMAGE, this._loadElement("image");
            break;
          case r.LOAD_TYPE.AUDIO:
            this.type = r.TYPE.AUDIO, this._loadSourceElement("audio");
            break;
          case r.LOAD_TYPE.VIDEO:
            this.type = r.TYPE.VIDEO, this._loadSourceElement("video");
            break;
          case r.LOAD_TYPE.XHR:
          default:
            typeof ny > "u" && (ny = !!(globalThis.XDomainRequest && !("withCredentials" in new XMLHttpRequest()))), ny && this.crossOrigin ? this._loadXdr() : this._loadXhr();
            break;
        }
      }
    }, r.prototype._hasFlag = function(t) {
      return (this._flags & t) !== 0;
    }, r.prototype._setFlag = function(t, e) {
      this._flags = e ? this._flags | t : this._flags & ~t;
    }, r.prototype._clearEvents = function() {
      clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));
    }, r.prototype._finish = function() {
      if (this.isComplete)
        throw new Error("Complete called again for an already completed resource.");
      this._setFlag(r.STATUS_FLAGS.COMPLETE, !0), this._setFlag(r.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this);
    }, r.prototype._loadElement = function(t) {
      this.metadata.loadElement ? this.data = this.metadata.loadElement : t === "image" && typeof globalThis.Image < "u" ? this.data = new Image() : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
    }, r.prototype._loadSourceElement = function(t) {
      if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t === "audio" && typeof globalThis.Audio < "u" ? this.data = new Audio() : this.data = document.createElement(t), this.data === null) {
        this.abort("Unsupported element: " + t);
        return;
      }
      if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)
        if (navigator.isCocoonJS)
          this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
        else if (Array.isArray(this.url))
          for (var e = this.metadata.mimeType, i = 0; i < this.url.length; ++i)
            this.data.appendChild(this._createSource(t, this.url[i], Array.isArray(e) ? e[i] : e));
        else {
          var e = this.metadata.mimeType;
          this.data.appendChild(this._createSource(t, this.url, Array.isArray(e) ? e[0] : e));
        }
      this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
    }, r.prototype._loadXhr = function() {
      typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
      var t = this.xhr = new XMLHttpRequest();
      this.crossOrigin === "use-credentials" && (t.withCredentials = !0), t.open("GET", this.url, !0), t.timeout = this.timeout, this.xhrType === r.XHR_RESPONSE_TYPE.JSON || this.xhrType === r.XHR_RESPONSE_TYPE.DOCUMENT ? t.responseType = r.XHR_RESPONSE_TYPE.TEXT : t.responseType = this.xhrType, t.addEventListener("error", this._boundXhrOnError, !1), t.addEventListener("timeout", this._boundXhrOnTimeout, !1), t.addEventListener("abort", this._boundXhrOnAbort, !1), t.addEventListener("progress", this._boundOnProgress, !1), t.addEventListener("load", this._boundXhrOnLoad, !1), t.send();
    }, r.prototype._loadXdr = function() {
      typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
      var t = this.xhr = new globalThis.XDomainRequest();
      t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open("GET", this.url, !0), setTimeout(function() {
        return t.send();
      }, 1);
    }, r.prototype._createSource = function(t, e, i) {
      i || (i = t + "/" + this._getExtension(e));
      var n = document.createElement("source");
      return n.src = e, n.type = i, n;
    }, r.prototype._onError = function(t) {
      this.abort("Failed to load element using: " + t.target.nodeName);
    }, r.prototype._onProgress = function(t) {
      t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total);
    }, r.prototype._onTimeout = function() {
      this.abort("Load timed out.");
    }, r.prototype._xhrOnError = function() {
      var t = this.xhr;
      this.abort(sy(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"');
    }, r.prototype._xhrOnTimeout = function() {
      var t = this.xhr;
      this.abort(sy(t) + " Request timed out.");
    }, r.prototype._xhrOnAbort = function() {
      var t = this.xhr;
      this.abort(sy(t) + " Request was aborted by the user.");
    }, r.prototype._xhrOnLoad = function() {
      var t = this.xhr, e = "", i = typeof t.status > "u" ? Rg : t.status;
      (t.responseType === "" || t.responseType === "text" || typeof t.responseType > "u") && (e = t.responseText), i === gO && (e.length > 0 || t.responseType === r.XHR_RESPONSE_TYPE.BUFFER) ? i = Rg : i === xO && (i = bO);
      var n = i / 100 | 0;
      if (n === wO)
        if (this.xhrType === r.XHR_RESPONSE_TYPE.TEXT)
          this.data = e, this.type = r.TYPE.TEXT;
        else if (this.xhrType === r.XHR_RESPONSE_TYPE.JSON)
          try {
            this.data = JSON.parse(e), this.type = r.TYPE.JSON;
          } catch (a) {
            this.abort("Error trying to parse loaded json: " + a);
            return;
          }
        else if (this.xhrType === r.XHR_RESPONSE_TYPE.DOCUMENT)
          try {
            if (globalThis.DOMParser) {
              var s = new DOMParser();
              this.data = s.parseFromString(e, "text/xml");
            } else {
              var o = document.createElement("div");
              o.innerHTML = e, this.data = o;
            }
            this.type = r.TYPE.XML;
          } catch (a) {
            this.abort("Error trying to parse loaded xml: " + a);
            return;
          }
        else
          this.data = t.response || e;
      else {
        this.abort("[" + t.status + "] " + t.statusText + ": " + t.responseURL);
        return;
      }
      this.complete();
    }, r.prototype._determineCrossOrigin = function(t, e) {
      if (t.indexOf("data:") === 0)
        return "";
      if (globalThis.origin !== globalThis.location.origin)
        return "anonymous";
      e = e || globalThis.location, Zc || (Zc = document.createElement("a")), Zc.href = t;
      var i = wb(Zc.href, { strictMode: !0 }), n = !i.port && e.port === "" || i.port === e.port, s = i.protocol ? i.protocol + ":" : "";
      return i.host !== e.hostname || !n || s !== e.protocol ? "anonymous" : "";
    }, r.prototype._determineXhrType = function() {
      return r._xhrTypeMap[this.extension] || r.XHR_RESPONSE_TYPE.TEXT;
    }, r.prototype._determineLoadType = function() {
      return r._loadTypeMap[this.extension] || r.LOAD_TYPE.XHR;
    }, r.prototype._getExtension = function(t) {
      t === void 0 && (t = this.url);
      var e = "";
      if (this.isDataUrl) {
        var i = t.indexOf("/");
        e = t.substring(i + 1, t.indexOf(";", i));
      } else {
        var n = t.indexOf("?"), s = t.indexOf("#"), o = Math.min(n > -1 ? n : t.length, s > -1 ? s : t.length);
        t = t.substring(0, o), e = t.substring(t.lastIndexOf(".") + 1);
      }
      return e.toLowerCase();
    }, r.prototype._getMimeFromXhrType = function(t) {
      switch (t) {
        case r.XHR_RESPONSE_TYPE.BUFFER:
          return "application/octet-binary";
        case r.XHR_RESPONSE_TYPE.BLOB:
          return "application/blob";
        case r.XHR_RESPONSE_TYPE.DOCUMENT:
          return "application/xml";
        case r.XHR_RESPONSE_TYPE.JSON:
          return "application/json";
        case r.XHR_RESPONSE_TYPE.DEFAULT:
        case r.XHR_RESPONSE_TYPE.TEXT:
        default:
          return "text/plain";
      }
    }, r;
  }()
);
(function(r) {
  (function(t) {
    t[t.NONE = 0] = "NONE", t[t.DATA_URL = 1] = "DATA_URL", t[t.COMPLETE = 2] = "COMPLETE", t[t.LOADING = 4] = "LOADING";
  })(r.STATUS_FLAGS || (r.STATUS_FLAGS = {})), function(t) {
    t[t.UNKNOWN = 0] = "UNKNOWN", t[t.JSON = 1] = "JSON", t[t.XML = 2] = "XML", t[t.IMAGE = 3] = "IMAGE", t[t.AUDIO = 4] = "AUDIO", t[t.VIDEO = 5] = "VIDEO", t[t.TEXT = 6] = "TEXT";
  }(r.TYPE || (r.TYPE = {})), function(t) {
    t[t.XHR = 1] = "XHR", t[t.IMAGE = 2] = "IMAGE", t[t.AUDIO = 3] = "AUDIO", t[t.VIDEO = 4] = "VIDEO";
  }(r.LOAD_TYPE || (r.LOAD_TYPE = {})), function(t) {
    t.DEFAULT = "text", t.BUFFER = "arraybuffer", t.BLOB = "blob", t.DOCUMENT = "document", t.JSON = "json", t.TEXT = "text";
  }(r.XHR_RESPONSE_TYPE || (r.XHR_RESPONSE_TYPE = {})), r._loadTypeMap = {
    // images
    gif: r.LOAD_TYPE.IMAGE,
    png: r.LOAD_TYPE.IMAGE,
    bmp: r.LOAD_TYPE.IMAGE,
    jpg: r.LOAD_TYPE.IMAGE,
    jpeg: r.LOAD_TYPE.IMAGE,
    tif: r.LOAD_TYPE.IMAGE,
    tiff: r.LOAD_TYPE.IMAGE,
    webp: r.LOAD_TYPE.IMAGE,
    tga: r.LOAD_TYPE.IMAGE,
    avif: r.LOAD_TYPE.IMAGE,
    svg: r.LOAD_TYPE.IMAGE,
    "svg+xml": r.LOAD_TYPE.IMAGE,
    // audio
    mp3: r.LOAD_TYPE.AUDIO,
    ogg: r.LOAD_TYPE.AUDIO,
    wav: r.LOAD_TYPE.AUDIO,
    // videos
    mp4: r.LOAD_TYPE.VIDEO,
    webm: r.LOAD_TYPE.VIDEO
  }, r._xhrTypeMap = {
    // xml
    xhtml: r.XHR_RESPONSE_TYPE.DOCUMENT,
    html: r.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: r.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: r.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: r.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: r.XHR_RESPONSE_TYPE.DOCUMENT,
    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
    // this should probably be fine.
    tsx: r.XHR_RESPONSE_TYPE.DOCUMENT,
    // images
    gif: r.XHR_RESPONSE_TYPE.BLOB,
    png: r.XHR_RESPONSE_TYPE.BLOB,
    bmp: r.XHR_RESPONSE_TYPE.BLOB,
    jpg: r.XHR_RESPONSE_TYPE.BLOB,
    jpeg: r.XHR_RESPONSE_TYPE.BLOB,
    tif: r.XHR_RESPONSE_TYPE.BLOB,
    tiff: r.XHR_RESPONSE_TYPE.BLOB,
    webp: r.XHR_RESPONSE_TYPE.BLOB,
    tga: r.XHR_RESPONSE_TYPE.BLOB,
    avif: r.XHR_RESPONSE_TYPE.BLOB,
    // json
    json: r.XHR_RESPONSE_TYPE.JSON,
    // text
    text: r.XHR_RESPONSE_TYPE.TEXT,
    txt: r.XHR_RESPONSE_TYPE.TEXT,
    // fonts
    ttf: r.XHR_RESPONSE_TYPE.BUFFER,
    otf: r.XHR_RESPONSE_TYPE.BUFFER
  }, r.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
})(bt || (bt = {}));
function ws() {
}
function EO(r) {
  return function() {
    for (var e = arguments, i = [], n = 0; n < arguments.length; n++)
      i[n] = e[n];
    if (r === null)
      throw new Error("Callback was already called.");
    var s = r;
    r = null, s.apply(this, i);
  };
}
var TO = (
  /** @class */
  function() {
    function r(t, e) {
      this.data = t, this.callback = e;
    }
    return r;
  }()
), oy = (
  /** @class */
  function() {
    function r(t, e) {
      var i = this;
      if (e === void 0 && (e = 1), this.workers = 0, this.saturated = ws, this.unsaturated = ws, this.empty = ws, this.drain = ws, this.error = ws, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function(n, s, o) {
        if (o && typeof o != "function")
          throw new Error("task callback must be a function");
        if (i.started = !0, n == null && i.idle()) {
          setTimeout(function() {
            return i.drain();
          }, 1);
          return;
        }
        var a = new TO(n, typeof o == "function" ? o : ws);
        s ? i._tasks.unshift(a) : i._tasks.push(a), setTimeout(i.process, 1);
      }, this.process = function() {
        for (; !i.paused && i.workers < i.concurrency && i._tasks.length; ) {
          var n = i._tasks.shift();
          i._tasks.length === 0 && i.empty(), i.workers += 1, i.workers === i.concurrency && i.saturated(), i._worker(n.data, EO(i._next(n)));
        }
      }, this._worker = t, e === 0)
        throw new Error("Concurrency must not be zero");
      this.concurrency = e, this.buffer = e / 4;
    }
    return r.prototype._next = function(t) {
      var e = this;
      return function() {
        for (var i = arguments, n = [], s = 0; s < arguments.length; s++)
          n[s] = i[s];
        e.workers -= 1, t.callback.apply(t, n), n[0] != null && e.error(n[0], t.data), e.workers <= e.concurrency - e.buffer && e.unsaturated(), e.idle() && e.drain(), e.process();
      };
    }, r.prototype.push = function(t, e) {
      this._insert(t, !1, e);
    }, r.prototype.kill = function() {
      this.workers = 0, this.drain = ws, this.started = !1, this._tasks = [];
    }, r.prototype.unshift = function(t, e) {
      this._insert(t, !0, e);
    }, r.prototype.length = function() {
      return this._tasks.length;
    }, r.prototype.running = function() {
      return this.workers;
    }, r.prototype.idle = function() {
      return this._tasks.length + this.workers === 0;
    }, r.prototype.pause = function() {
      this.paused !== !0 && (this.paused = !0);
    }, r.prototype.resume = function() {
      if (this.paused !== !1) {
        this.paused = !1;
        for (var t = 1; t <= this.concurrency; t++)
          this.process();
      }
    }, r.eachSeries = function(t, e, i, n) {
      var s = 0, o = t.length;
      function a(l) {
        if (l || s === o) {
          i && i(l);
          return;
        }
        n ? setTimeout(function() {
          e(t[s++], a);
        }, 1) : e(t[s++], a);
      }
      a();
    }, r.queue = function(t, e) {
      return new r(t, e);
    }, r;
  }()
), ay = 100, SO = /(#[\w-]+)?$/, Oi = (
  /** @class */
  function() {
    function r(t, e) {
      var i = this;
      t === void 0 && (t = ""), e === void 0 && (e = 10), this.progress = 0, this.loading = !1, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(l, u) {
        return i._loadResource(l, u);
      }, this.resources = {}, this.baseUrl = t, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(l, u) {
        return i._loadResource(l, u);
      }, this._queue = oy.queue(this._boundLoadResource, e), this._queue.pause(), this.resources = {}, this.onProgress = new An(), this.onError = new An(), this.onLoad = new An(), this.onStart = new An(), this.onComplete = new An();
      for (var n = 0; n < r._plugins.length; ++n) {
        var s = r._plugins[n], o = s.pre, a = s.use;
        o && this.pre(o), a && this.use(a);
      }
      this._protected = !1;
    }
    return r.prototype._add = function(t, e, i, n) {
      if (this.loading && (!i || !i.parentResource))
        throw new Error("Cannot add resources while the loader is running.");
      if (this.resources[t])
        throw new Error('Resource named "' + t + '" already exists.');
      if (e = this._prepareUrl(e), this.resources[t] = new bt(t, e, i), typeof n == "function" && this.resources[t].onAfterMiddleware.once(n), this.loading) {
        for (var s = i.parentResource, o = [], a = 0; a < s.children.length; ++a)
          s.children[a].isComplete || o.push(s.children[a]);
        var l = s.progressChunk * (o.length + 1), u = l / (o.length + 2);
        s.children.push(this.resources[t]), s.progressChunk = u;
        for (var a = 0; a < o.length; ++a)
          o[a].progressChunk = u;
        this.resources[t].progressChunk = u;
      }
      return this._queue.push(this.resources[t]), this;
    }, r.prototype.pre = function(t) {
      return this._beforeMiddleware.push(t), this;
    }, r.prototype.use = function(t) {
      return this._afterMiddleware.push(t), this;
    }, r.prototype.reset = function() {
      this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause();
      for (var t in this.resources) {
        var e = this.resources[t];
        e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort("loader reset");
      }
      return this.resources = {}, this;
    }, r.prototype.load = function(t) {
      if (ci("6.5.0", "@pixi/loaders is being replaced with @pixi/assets in the next major release."), typeof t == "function" && this.onComplete.once(t), this.loading)
        return this;
      if (this._queue.idle())
        this._onStart(), this._onComplete();
      else {
        for (var e = this._queue._tasks.length, i = ay / e, n = 0; n < this._queue._tasks.length; ++n)
          this._queue._tasks[n].data.progressChunk = i;
        this._onStart(), this._queue.resume();
      }
      return this;
    }, Object.defineProperty(r.prototype, "concurrency", {
      /**
       * The number of resources to load concurrently.
       * @default 10
       */
      get: function() {
        return this._queue.concurrency;
      },
      set: function(t) {
        this._queue.concurrency = t;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype._prepareUrl = function(t) {
      var e = wb(t, { strictMode: !0 }), i;
      if (e.protocol || !e.path || t.indexOf("//") === 0 ? i = t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && t.charAt(0) !== "/" ? i = this.baseUrl + "/" + t : i = this.baseUrl + t, this.defaultQueryString) {
        var n = SO.exec(i)[0];
        i = i.slice(0, i.length - n.length), i.indexOf("?") !== -1 ? i += "&" + this.defaultQueryString : i += "?" + this.defaultQueryString, i += n;
      }
      return i;
    }, r.prototype._loadResource = function(t, e) {
      var i = this;
      t._dequeue = e, oy.eachSeries(this._beforeMiddleware, function(n, s) {
        n.call(i, t, function() {
          s(t.isComplete ? {} : null);
        });
      }, function() {
        t.isComplete ? i._onLoad(t) : (t._onLoadBinding = t.onComplete.once(i._onLoad, i), t.load());
      }, !0);
    }, r.prototype._onStart = function() {
      this.progress = 0, this.loading = !0, this.onStart.dispatch(this);
    }, r.prototype._onComplete = function() {
      this.progress = ay, this.loading = !1, this.onComplete.dispatch(this, this.resources);
    }, r.prototype._onLoad = function(t) {
      var e = this;
      t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), oy.eachSeries(this._afterMiddleware, function(i, n) {
        i.call(e, t, n);
      }, function() {
        t.onAfterMiddleware.dispatch(t), e.progress = Math.min(ay, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && e._resourcesParsing.length === 0 && e._onComplete();
      }, !0);
    }, r.prototype.destroy = function() {
      this._protected || this.reset();
    }, Object.defineProperty(r, "shared", {
      /** A premade instance of the loader that can be used to load resources. */
      get: function() {
        var t = r._shared;
        return t || (t = new r(), t._protected = !0, r._shared = t), t;
      },
      enumerable: !1,
      configurable: !0
    }), r.registerPlugin = function(t) {
      return ci("6.5.0", "Loader.registerPlugin() is deprecated, use extensions.add() instead."), Tr.add({
        type: qt.Loader,
        ref: t
      }), r;
    }, r._plugins = [], r;
  }()
);
Tr.handleByList(qt.Loader, Oi._plugins);
Oi.prototype.add = function(t, e, i, n) {
  if (Array.isArray(t)) {
    for (var s = 0; s < t.length; ++s)
      this.add(t[s]);
    return this;
  }
  if (typeof t == "object" && (i = t, n = e || i.callback || i.onComplete, e = i.url, t = i.name || i.key || i.url), typeof e != "string" && (n = i, i = e, e = t), typeof e != "string")
    throw new Error("No url passed to add resource to loader.");
  return typeof i == "function" && (n = i, i = null), this._add(t, e, i, n);
};
var PO = (
  /** @class */
  function() {
    function r() {
    }
    return r.init = function(t) {
      t = Object.assign({
        sharedLoader: !1
      }, t), this.loader = t.sharedLoader ? Oi.shared : new Oi();
    }, r.destroy = function() {
      this.loader && (this.loader.destroy(), this.loader = null);
    }, r.extension = qt.Application, r;
  }()
), OO = (
  /** @class */
  function() {
    function r() {
    }
    return r.add = function() {
      bt.setExtensionLoadType("svg", bt.LOAD_TYPE.XHR), bt.setExtensionXhrType("svg", bt.XHR_RESPONSE_TYPE.TEXT);
    }, r.use = function(t, e) {
      if (t.data && (t.type === bt.TYPE.IMAGE || t.extension === "svg")) {
        var i = t.data, n = t.url, s = t.name, o = t.metadata;
        ut.fromLoader(i, n, s, o).then(function(a) {
          t.texture = a, e();
        }).catch(e);
      } else
        e();
    }, r.extension = qt.Loader, r;
  }()
), IO = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function CO(r) {
  for (var t = "", e = 0; e < r.length; ) {
    for (var i = [0, 0, 0], n = [0, 0, 0, 0], s = 0; s < i.length; ++s)
      e < r.length ? i[s] = r.charCodeAt(e++) & 255 : i[s] = 0;
    n[0] = i[0] >> 2, n[1] = (i[0] & 3) << 4 | i[1] >> 4, n[2] = (i[1] & 15) << 2 | i[2] >> 6, n[3] = i[2] & 63;
    var o = e - (r.length - 1);
    switch (o) {
      case 2:
        n[3] = 64, n[2] = 64;
        break;
      case 1:
        n[3] = 64;
        break;
    }
    for (var s = 0; s < n.length; ++s)
      t += IO.charAt(n[s]);
  }
  return t;
}
function MO(r, t) {
  if (!r.data) {
    t();
    return;
  }
  if (r.xhr && r.xhrType === bt.XHR_RESPONSE_TYPE.BLOB) {
    if (!self.Blob || typeof r.data == "string") {
      var e = r.xhr.getResponseHeader("content-type");
      if (e && e.indexOf("image") === 0) {
        r.data = new Image(), r.data.src = "data:" + e + ";base64," + CO(r.xhr.responseText), r.type = bt.TYPE.IMAGE, r.data.onload = function() {
          r.data.onload = null, t();
        };
        return;
      }
    } else if (r.data.type.indexOf("image") === 0) {
      var i = globalThis.URL || globalThis.webkitURL, n = i.createObjectURL(r.data);
      r.blob = r.data, r.data = new Image(), r.data.src = n, r.type = bt.TYPE.IMAGE, r.data.onload = function() {
        i.revokeObjectURL(n), r.data.onload = null, t();
      };
      return;
    }
  }
  t();
}
var RO = (
  /** @class */
  function() {
    function r() {
    }
    return r.extension = qt.Loader, r.use = MO, r;
  }()
);
Tr.add(OO, RO);
/*!
 * @pixi/compressed-textures - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/compressed-textures is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Xt, xt;
(function(r) {
  r[r.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", r[r.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", r[r.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", r[r.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", r[r.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", r[r.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", r[r.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", r[r.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", r[r.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", r[r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", r[r.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", r[r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", r[r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", r[r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", r[r.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", r[r.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", r[r.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", r[r.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", r[r.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
})(xt || (xt = {}));
var rd = (Xt = {}, // WEBGL_compressed_texture_s3tc
Xt[xt.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, Xt[xt.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, Xt[xt.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, Xt[xt.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_s3tc
Xt[xt.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, Xt[xt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, Xt[xt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, Xt[xt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_etc
Xt[xt.COMPRESSED_R11_EAC] = 0.5, Xt[xt.COMPRESSED_SIGNED_R11_EAC] = 0.5, Xt[xt.COMPRESSED_RG11_EAC] = 1, Xt[xt.COMPRESSED_SIGNED_RG11_EAC] = 1, Xt[xt.COMPRESSED_RGB8_ETC2] = 0.5, Xt[xt.COMPRESSED_RGBA8_ETC2_EAC] = 1, Xt[xt.COMPRESSED_SRGB8_ETC2] = 0.5, Xt[xt.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, Xt[xt.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, Xt[xt.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, // WEBGL_compressed_texture_pvrtc
Xt[xt.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, Xt[xt.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, Xt[xt.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, Xt[xt.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, // WEBGL_compressed_texture_etc1
Xt[xt.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, // @see https://www.khronos.org/registry/OpenGL/extensions/AMD/AMD_compressed_ATC_texture.txt
// WEBGL_compressed_texture_atc
Xt[xt.COMPRESSED_RGB_ATC_WEBGL] = 0.5, Xt[xt.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, Xt[xt.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, // @see https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt
// WEBGL_compressed_texture_astc
/* eslint-disable-next-line camelcase */
Xt[xt.COMPRESSED_RGBA_ASTC_4x4_KHR] = 1, Xt);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Cy = function(r, t) {
  return Cy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Cy(r, t);
};
function Eb(r, t) {
  Cy(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function kO(r, t, e, i) {
  function n(s) {
    return s instanceof e ? s : new e(function(o) {
      o(s);
    });
  }
  return new (e || (e = Promise))(function(s, o) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      c.done ? s(c.value) : n(c.value).then(a, l);
    }
    u((i = i.apply(r, t || [])).next());
  });
}
function NO(r, t) {
  var e = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, i, n, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(c) {
      return l([u, c]);
    };
  }
  function l(u) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, n && (s = u[0] & 2 ? n.return : u[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) && !(s = s.call(n, u[1])).done)
          return s;
        switch (n = 0, s && (u = [u[0] & 2, s.value]), u[0]) {
          case 0:
          case 1:
            s = u;
            break;
          case 4:
            return e.label++, { value: u[1], done: !1 };
          case 5:
            e.label++, n = u[1], u = [0];
            continue;
          case 7:
            u = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (s = e.trys, !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              e = 0;
              continue;
            }
            if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
              e.label = u[1];
              break;
            }
            if (u[0] === 6 && e.label < s[1]) {
              e.label = s[1], s = u;
              break;
            }
            if (s && e.label < s[2]) {
              e.label = s[2], e.ops.push(u);
              break;
            }
            s[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        u = t.call(r, e);
      } catch (c) {
        u = [6, c], n = 0;
      } finally {
        i = s = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
var AO = (
  /** @class */
  function(r) {
    Eb(t, r);
    function t(e, i) {
      i === void 0 && (i = { width: 1, height: 1, autoLoad: !0 });
      var n = this, s, o;
      return typeof e == "string" ? (s = e, o = new Uint8Array()) : (s = null, o = e), n = r.call(this, o, i) || this, n.origin = s, n.buffer = o ? new id(o) : null, n.origin && i.autoLoad !== !1 && n.load(), o && o.length && (n.loaded = !0, n.onBlobLoaded(n.buffer.rawBinaryData)), n;
    }
    return t.prototype.onBlobLoaded = function(e) {
    }, t.prototype.load = function() {
      return kO(this, void 0, Promise, function() {
        var e, i, n;
        return NO(this, function(s) {
          switch (s.label) {
            case 0:
              return [4, fetch(this.origin)];
            case 1:
              return e = s.sent(), [4, e.blob()];
            case 2:
              return i = s.sent(), [4, i.arrayBuffer()];
            case 3:
              return n = s.sent(), this.data = new Uint32Array(n), this.buffer = new id(n), this.loaded = !0, this.onBlobLoaded(n), this.update(), [2, this];
          }
        });
      });
    }, t;
  }(Qo)
), My = (
  /** @class */
  function(r) {
    Eb(t, r);
    function t(e, i) {
      var n = r.call(this, e, i) || this;
      return n.format = i.format, n.levels = i.levels || 1, n._width = i.width, n._height = i.height, n._extension = t._formatToExtension(n.format), (i.levelBuffers || n.buffer) && (n._levelBuffers = i.levelBuffers || t._createLevelBuffers(
        e instanceof Uint8Array ? e : n.buffer.uint8View,
        n.format,
        n.levels,
        4,
        4,
        // PVRTC has 8x4 blocks in 2bpp mode
        n.width,
        n.height
      )), n;
    }
    return t.prototype.upload = function(e, i, n) {
      var s = e.gl, o = e.context.extensions[this._extension];
      if (!o)
        throw new Error(this._extension + " textures are not supported on the current machine");
      if (!this._levelBuffers)
        return !1;
      for (var a = 0, l = this.levels; a < l; a++) {
        var u = this._levelBuffers[a], c = u.levelID, d = u.levelWidth, f = u.levelHeight, v = u.levelBuffer;
        s.compressedTexImage2D(s.TEXTURE_2D, c, this.format, d, f, 0, v);
      }
      return !0;
    }, t.prototype.onBlobLoaded = function() {
      this._levelBuffers = t._createLevelBuffers(
        this.buffer.uint8View,
        this.format,
        this.levels,
        4,
        4,
        // PVRTC has 8x4 blocks in 2bpp mode
        this.width,
        this.height
      );
    }, t._formatToExtension = function(e) {
      if (e >= 33776 && e <= 33779)
        return "s3tc";
      if (e >= 37488 && e <= 37497)
        return "etc";
      if (e >= 35840 && e <= 35843)
        return "pvrtc";
      if (e >= 36196)
        return "etc1";
      if (e >= 35986 && e <= 34798)
        return "atc";
      throw new Error("Invalid (compressed) texture format given!");
    }, t._createLevelBuffers = function(e, i, n, s, o, a, l) {
      for (var u = new Array(n), c = e.byteOffset, d = a, f = l, v = d + s - 1 & ~(s - 1), m = f + o - 1 & ~(o - 1), p = v * m * rd[i], y = 0; y < n; y++)
        u[y] = {
          levelID: y,
          levelWidth: n > 1 ? d : v,
          levelHeight: n > 1 ? f : m,
          levelBuffer: new Uint8Array(e.buffer, c, p)
        }, c += p, d = d >> 1 || 1, f = f >> 1 || 1, v = d + s - 1 & ~(s - 1), m = f + o - 1 & ~(o - 1), p = v * m * rd[i];
      return u;
    }, t;
  }(AO)
), LO = (
  /** @class */
  function() {
    function r() {
    }
    return r.use = function(t, e) {
      var i = t.data, n = this;
      if (t.type === bt.TYPE.JSON && i && i.cacheID && i.textures) {
        for (var s = i.textures, o = void 0, a = void 0, l = 0, u = s.length; l < u; l++) {
          var c = s[l], d = c.src, f = c.format;
          if (f || (a = d), r.textureFormats[f]) {
            o = d;
            break;
          }
        }
        if (o = o || a, !o) {
          e(new Error("Cannot load compressed-textures in " + t.url + ", make sure you provide a fallback"));
          return;
        }
        if (o === t.url) {
          e(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
          return;
        }
        var v = {
          crossOrigin: t.crossOrigin,
          metadata: t.metadata.imageMetadata,
          parentResource: t
        }, m = pa.resolve(t.url.replace(n.baseUrl, ""), o), p = i.cacheID;
        n.add(p, m, v, function(y) {
          if (y.error) {
            e(y.error);
            return;
          }
          var b = y.texture, w = b === void 0 ? null : b, E = y.textures, O = E === void 0 ? {} : E;
          Object.assign(t, { texture: w, textures: O }), e();
        });
      } else
        e();
    }, Object.defineProperty(r, "textureExtensions", {
      /**  Map of available texture extensions. */
      get: function() {
        if (!r._textureExtensions) {
          var t = J.ADAPTER.createCanvas(), e = t.getContext("webgl");
          if (!e)
            return console.warn("WebGL not available for compressed textures. Silently failing."), {};
          var i = {
            s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: e.getExtension("WEBGL_compressed_texture_etc"),
            etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: e.getExtension("WEBGL_compressed_texture_atc"),
            astc: e.getExtension("WEBGL_compressed_texture_astc")
          };
          r._textureExtensions = i;
        }
        return r._textureExtensions;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "textureFormats", {
      /** Map of available texture formats. */
      get: function() {
        if (!r._textureFormats) {
          var t = r.textureExtensions;
          r._textureFormats = {};
          for (var e in t) {
            var i = t[e];
            i && Object.assign(r._textureFormats, Object.getPrototypeOf(i));
          }
        }
        return r._textureFormats;
      },
      enumerable: !1,
      configurable: !0
    }), r.extension = qt.Loader, r;
  }()
);
function Tb(r, t, e) {
  var i = {
    textures: {},
    texture: null
  };
  if (!t)
    return i;
  var n = t.map(function(s) {
    return new ut(new Mt(s, Object.assign({
      mipmap: br.OFF,
      alphaMode: xr.NO_PREMULTIPLIED_ALPHA
    }, e)));
  });
  return n.forEach(function(s, o) {
    var a = s.baseTexture, l = r + "-" + (o + 1);
    Mt.addToCache(a, l), ut.addToCache(s, l), o === 0 && (Mt.addToCache(a, r), ut.addToCache(s, r), i.texture = s), i.textures[l] = s;
  }), i;
}
var Yh, Ki, hy = 4, Kc = 124, DO = 32, Ag = 20, FO = 542327876, Jc = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
}, BO = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
}, Qc = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
}, Qi;
(function(r) {
  r[r.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", r[r.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", r[r.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", r[r.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", r[r.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", r[r.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", r[r.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", r[r.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", r[r.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", r[r.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", r[r.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", r[r.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", r[r.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", r[r.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", r[r.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", r[r.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", r[r.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", r[r.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", r[r.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", r[r.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", r[r.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", r[r.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", r[r.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", r[r.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", r[r.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", r[r.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", r[r.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", r[r.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", r[r.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", r[r.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", r[r.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", r[r.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", r[r.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", r[r.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", r[r.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", r[r.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", r[r.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", r[r.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", r[r.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", r[r.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", r[r.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", r[r.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", r[r.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", r[r.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", r[r.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", r[r.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", r[r.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", r[r.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", r[r.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", r[r.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", r[r.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", r[r.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", r[r.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", r[r.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", r[r.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", r[r.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", r[r.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", r[r.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", r[r.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", r[r.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", r[r.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", r[r.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", r[r.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", r[r.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", r[r.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", r[r.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", r[r.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", r[r.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", r[r.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", r[r.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", r[r.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", r[r.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", r[r.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", r[r.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", r[r.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", r[r.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", r[r.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", r[r.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", r[r.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", r[r.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", r[r.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", r[r.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", r[r.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", r[r.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", r[r.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", r[r.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", r[r.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", r[r.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", r[r.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", r[r.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", r[r.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", r[r.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", r[r.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", r[r.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", r[r.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", r[r.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", r[r.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", r[r.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", r[r.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", r[r.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", r[r.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV", r[r.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410", r[r.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416", r[r.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12", r[r.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010", r[r.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016", r[r.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE", r[r.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2", r[r.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210", r[r.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216", r[r.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11", r[r.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44", r[r.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44", r[r.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8", r[r.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8", r[r.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", r[r.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208", r[r.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208", r[r.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408", r[r.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", r[r.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", r[r.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT";
})(Qi || (Qi = {}));
var Ry;
(function(r) {
  r[r.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", r[r.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", r[r.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D";
})(Ry || (Ry = {}));
var UO = 1, GO = 2, jO = 4, HO = 64, $O = 512, zO = 131072, VO = 827611204, XO = 861165636, WO = 894720068, YO = 808540228, qO = 4, ZO = (Yh = {}, Yh[VO] = xt.COMPRESSED_RGBA_S3TC_DXT1_EXT, Yh[XO] = xt.COMPRESSED_RGBA_S3TC_DXT3_EXT, Yh[WO] = xt.COMPRESSED_RGBA_S3TC_DXT5_EXT, Yh), KO = (Ki = {}, // WEBGL_compressed_texture_s3tc
Ki[Qi.DXGI_FORMAT_BC1_TYPELESS] = xt.COMPRESSED_RGBA_S3TC_DXT1_EXT, Ki[Qi.DXGI_FORMAT_BC1_UNORM] = xt.COMPRESSED_RGBA_S3TC_DXT1_EXT, Ki[Qi.DXGI_FORMAT_BC2_TYPELESS] = xt.COMPRESSED_RGBA_S3TC_DXT3_EXT, Ki[Qi.DXGI_FORMAT_BC2_UNORM] = xt.COMPRESSED_RGBA_S3TC_DXT3_EXT, Ki[Qi.DXGI_FORMAT_BC3_TYPELESS] = xt.COMPRESSED_RGBA_S3TC_DXT5_EXT, Ki[Qi.DXGI_FORMAT_BC3_UNORM] = xt.COMPRESSED_RGBA_S3TC_DXT5_EXT, // WEBGL_compressed_texture_s3tc_srgb
Ki[Qi.DXGI_FORMAT_BC1_UNORM_SRGB] = xt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, Ki[Qi.DXGI_FORMAT_BC2_UNORM_SRGB] = xt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, Ki[Qi.DXGI_FORMAT_BC3_UNORM_SRGB] = xt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, Ki);
function JO(r) {
  var t = new Uint32Array(r), e = t[0];
  if (e !== FO)
    throw new Error("Invalid DDS file magic word");
  var i = new Uint32Array(r, 0, Kc / Uint32Array.BYTES_PER_ELEMENT), n = i[Jc.HEIGHT], s = i[Jc.WIDTH], o = i[Jc.MIPMAP_COUNT], a = new Uint32Array(r, Jc.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DO / Uint32Array.BYTES_PER_ELEMENT), l = a[UO];
  if (l & jO) {
    var u = a[BO.FOURCC];
    if (u !== YO) {
      var c = ZO[u], d = hy + Kc, f = new Uint8Array(r, d), v = new My(f, {
        format: c,
        width: s,
        height: n,
        levels: o
        // CompressedTextureResource will separate the levelBuffers for us!
      });
      return [v];
    }
    var m = hy + Kc, p = new Uint32Array(t.buffer, m, Ag / Uint32Array.BYTES_PER_ELEMENT), y = p[Qc.DXGI_FORMAT], b = p[Qc.RESOURCE_DIMENSION], w = p[Qc.MISC_FLAG], E = p[Qc.ARRAY_SIZE], O = KO[y];
    if (O === void 0)
      throw new Error("DDSParser cannot parse texture data with DXGI format " + y);
    if (w === qO)
      throw new Error("DDSParser does not support cubemap textures");
    if (b === Ry.DDS_DIMENSION_TEXTURE3D)
      throw new Error("DDSParser does not supported 3D texture data");
    var I = new Array(), S = hy + Kc + Ag;
    if (E === 1)
      I.push(new Uint8Array(r, S));
    else {
      for (var C = rd[O], P = 0, R = s, N = n, F = 0; F < o; F++) {
        var $ = Math.max(1, R + 3 & -4), q = Math.max(1, N + 3 & -4), ht = $ * q * C;
        P += ht, R = R >>> 1, N = N >>> 1;
      }
      for (var V = S, F = 0; F < E; F++)
        I.push(new Uint8Array(r, V, P)), V += P;
    }
    return I.map(function(H) {
      return new My(H, {
        format: O,
        width: s,
        height: n,
        levels: o
      });
    });
  }
  throw l & HO ? new Error("DDSParser does not support uncompressed texture data.") : l & $O ? new Error("DDSParser does not supported YUV uncompressed texture data.") : l & zO ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : l & GO ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
var Gn, sn, qh, Lg = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], QO = 67305985, Ji = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
}, ky = 64, Dg = (Gn = {}, Gn[ct.UNSIGNED_BYTE] = 1, Gn[ct.UNSIGNED_SHORT] = 2, Gn[ct.INT] = 4, Gn[ct.UNSIGNED_INT] = 4, Gn[ct.FLOAT] = 4, Gn[ct.HALF_FLOAT] = 8, Gn), tI = (sn = {}, sn[W.RGBA] = 4, sn[W.RGB] = 3, sn[W.RG] = 2, sn[W.RED] = 1, sn[W.LUMINANCE] = 1, sn[W.LUMINANCE_ALPHA] = 2, sn[W.ALPHA] = 1, sn), eI = (qh = {}, qh[ct.UNSIGNED_SHORT_4_4_4_4] = 2, qh[ct.UNSIGNED_SHORT_5_5_5_1] = 2, qh[ct.UNSIGNED_SHORT_5_6_5] = 2, qh);
function iI(r, t, e) {
  e === void 0 && (e = !1);
  var i = new DataView(t);
  if (!rI(r, i))
    return null;
  var n = i.getUint32(Ji.ENDIANNESS, !0) === QO, s = i.getUint32(Ji.GL_TYPE, n), o = i.getUint32(Ji.GL_FORMAT, n), a = i.getUint32(Ji.GL_INTERNAL_FORMAT, n), l = i.getUint32(Ji.PIXEL_WIDTH, n), u = i.getUint32(Ji.PIXEL_HEIGHT, n) || 1, c = i.getUint32(Ji.PIXEL_DEPTH, n) || 1, d = i.getUint32(Ji.NUMBER_OF_ARRAY_ELEMENTS, n) || 1, f = i.getUint32(Ji.NUMBER_OF_FACES, n), v = i.getUint32(Ji.NUMBER_OF_MIPMAP_LEVELS, n), m = i.getUint32(Ji.BYTES_OF_KEY_VALUE_DATA, n);
  if (u === 0 || c !== 1)
    throw new Error("Only 2D textures are supported");
  if (f !== 1)
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  if (d !== 1)
    throw new Error("WebGL does not support array textures");
  var p = 4, y = 4, b = l + 3 & -4, w = u + 3 & -4, E = new Array(d), O = l * u;
  s === 0 && (O = b * w);
  var I;
  if (s !== 0 ? Dg[s] ? I = Dg[s] * tI[o] : I = eI[s] : I = rd[a], I === void 0)
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  for (var S = e ? sI(i, m, n) : null, C = O * I, P = C, R = l, N = u, F = b, $ = w, q = ky + m, ht = 0; ht < v; ht++) {
    for (var V = i.getUint32(q, n), H = q + 4, Q = 0; Q < d; Q++) {
      var mt = E[Q];
      mt || (mt = E[Q] = new Array(v)), mt[ht] = {
        levelID: ht,
        // don't align mipWidth when texture not compressed! (glType not zero)
        levelWidth: v > 1 || s !== 0 ? R : F,
        levelHeight: v > 1 || s !== 0 ? N : $,
        levelBuffer: new Uint8Array(t, H, P)
      }, H += P;
    }
    q += V + 4, q = q % 4 !== 0 ? q + 4 - q % 4 : q, R = R >> 1 || 1, N = N >> 1 || 1, F = R + p - 1 & ~(p - 1), $ = N + y - 1 & ~(y - 1), P = F * $ * I;
  }
  return s !== 0 ? {
    uncompressed: E.map(function(et) {
      var Tt = et[0].levelBuffer, it = !1;
      return s === ct.FLOAT ? Tt = new Float32Array(et[0].levelBuffer.buffer, et[0].levelBuffer.byteOffset, et[0].levelBuffer.byteLength / 4) : s === ct.UNSIGNED_INT ? (it = !0, Tt = new Uint32Array(et[0].levelBuffer.buffer, et[0].levelBuffer.byteOffset, et[0].levelBuffer.byteLength / 4)) : s === ct.INT && (it = !0, Tt = new Int32Array(et[0].levelBuffer.buffer, et[0].levelBuffer.byteOffset, et[0].levelBuffer.byteLength / 4)), {
        resource: new Qo(Tt, {
          width: et[0].levelWidth,
          height: et[0].levelHeight
        }),
        type: s,
        format: it ? nI(o) : o
      };
    }),
    kvData: S
  } : {
    compressed: E.map(function(et) {
      return new My(null, {
        format: a,
        width: l,
        height: u,
        levels: v,
        levelBuffers: et
      });
    }),
    kvData: S
  };
}
function rI(r, t) {
  for (var e = 0; e < Lg.length; e++)
    if (t.getUint8(e) !== Lg[e])
      return console.error(r + " is not a valid *.ktx file!"), !1;
  return !0;
}
function nI(r) {
  switch (r) {
    case W.RGBA:
      return W.RGBA_INTEGER;
    case W.RGB:
      return W.RGB_INTEGER;
    case W.RG:
      return W.RG_INTEGER;
    case W.RED:
      return W.RED_INTEGER;
    default:
      return r;
  }
}
function sI(r, t, e) {
  for (var i = /* @__PURE__ */ new Map(), n = 0; n < t; ) {
    var s = r.getUint32(ky + n, e), o = ky + n + 4, a = 3 - (s + 3) % 4;
    if (s === 0 || s > t - n) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    for (var l = 0; l < s && r.getUint8(o + l) !== 0; l++)
      ;
    if (l === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    var u = new TextDecoder().decode(new Uint8Array(r.buffer, o, l)), c = new DataView(r.buffer, o + l + 1, s - l - 1);
    i.set(u, c), n += 4 + s + a;
  }
  return i;
}
bt.setExtensionXhrType("dds", bt.XHR_RESPONSE_TYPE.BUFFER);
var oI = (
  /** @class */
  function() {
    function r() {
    }
    return r.use = function(t, e) {
      if (t.extension === "dds" && t.data)
        try {
          Object.assign(t, Tb(t.name || t.url, JO(t.data), t.metadata));
        } catch (i) {
          e(i);
          return;
        }
      e();
    }, r.extension = qt.Loader, r;
  }()
);
bt.setExtensionXhrType("ktx", bt.XHR_RESPONSE_TYPE.BUFFER);
var aI = (
  /** @class */
  function() {
    function r() {
    }
    return r.use = function(t, e) {
      if (t.extension === "ktx" && t.data)
        try {
          var i = t.name || t.url, n = iI(i, t.data, this.loadKeyValueData), s = n.compressed, o = n.uncompressed, a = n.kvData;
          if (s) {
            var l = Tb(i, s, t.metadata);
            if (a && l.textures)
              for (var u in l.textures)
                l.textures[u].baseTexture.ktxKeyValueData = a;
            Object.assign(t, l);
          } else if (o) {
            var c = {};
            o.forEach(function(d, f) {
              var v = new ut(new Mt(d.resource, {
                mipmap: br.OFF,
                alphaMode: xr.NO_PREMULTIPLIED_ALPHA,
                type: d.type,
                format: d.format
              })), m = i + "-" + (f + 1);
              a && (v.baseTexture.ktxKeyValueData = a), Mt.addToCache(v.baseTexture, m), ut.addToCache(v, m), f === 0 && (c[i] = v, Mt.addToCache(v.baseTexture, i), ut.addToCache(v, i)), c[m] = v;
            }), Object.assign(t, { textures: c });
          }
        } catch (d) {
          e(d);
          return;
        }
      e();
    }, r.extension = qt.Loader, r.loadKeyValueData = !1, r;
  }()
);
/*!
 * @pixi/particle-container - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/particle-container is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ny = function(r, t) {
  return Ny = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Ny(r, t);
};
function Sb(r, t) {
  Ny(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
(function(r) {
  Sb(t, r);
  function t(e, i, n, s) {
    e === void 0 && (e = 1500), n === void 0 && (n = 16384), s === void 0 && (s = !1);
    var o = r.call(this) || this, a = 16384;
    return n > a && (n = a), o._properties = [!1, !0, !1, !1, !1], o._maxSize = e, o._batchSize = n, o._buffers = null, o._bufferUpdateIDs = [], o._updateID = 0, o.interactiveChildren = !1, o.blendMode = ot.NORMAL, o.autoResize = s, o.roundPixels = !0, o.baseTexture = null, o.setProperties(i), o._tint = 0, o.tintRgb = new Float32Array(4), o.tint = 16777215, o;
  }
  return t.prototype.setProperties = function(e) {
    e && (this._properties[0] = "vertices" in e || "scale" in e ? !!e.vertices || !!e.scale : this._properties[0], this._properties[1] = "position" in e ? !!e.position : this._properties[1], this._properties[2] = "rotation" in e ? !!e.rotation : this._properties[2], this._properties[3] = "uvs" in e ? !!e.uvs : this._properties[3], this._properties[4] = "tint" in e || "alpha" in e ? !!e.tint || !!e.alpha : this._properties[4]);
  }, t.prototype.updateTransform = function() {
    this.displayObjectUpdateTransform();
  }, Object.defineProperty(t.prototype, "tint", {
    /**
     * The tint applied to the container. This is a hex value.
     * A value of 0xFFFFFF will remove any tint effect.
     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
     * @default 0xFFFFFF
     */
    get: function() {
      return this._tint;
    },
    set: function(e) {
      this._tint = e, Lh(e, this.tintRgb);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.render = function(e) {
    var i = this;
    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", function() {
      return i.onChildrenChange(0);
    })), e.batch.setObjectRenderer(e.plugins.particle), e.plugins.particle.render(this));
  }, t.prototype.onChildrenChange = function(e) {
    for (var i = Math.floor(e / this._batchSize); this._bufferUpdateIDs.length < i; )
      this._bufferUpdateIDs.push(0);
    this._bufferUpdateIDs[i] = ++this._updateID;
  }, t.prototype.dispose = function() {
    if (this._buffers) {
      for (var e = 0; e < this._buffers.length; ++e)
        this._buffers[e].destroy();
      this._buffers = null;
    }
  }, t.prototype.destroy = function(e) {
    r.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;
  }, t;
})(Qt);
var Fg = (
  /** @class */
  function() {
    function r(t, e, i) {
      this.geometry = new jh(), this.indexBuffer = null, this.size = i, this.dynamicProperties = [], this.staticProperties = [];
      for (var n = 0; n < t.length; ++n) {
        var s = t[n];
        s = {
          attributeName: s.attributeName,
          size: s.size,
          uploadFunction: s.uploadFunction,
          type: s.type || ct.FLOAT,
          offset: s.offset
        }, e[n] ? this.dynamicProperties.push(s) : this.staticProperties.push(s);
      }
      this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();
    }
    return r.prototype.initBuffers = function() {
      var t = this.geometry, e = 0;
      this.indexBuffer = new Ce(ZS(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;
      for (var i = 0; i < this.dynamicProperties.length; ++i) {
        var n = this.dynamicProperties[i];
        n.offset = e, e += n.size, this.dynamicStride += n.size;
      }
      var s = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
      this.dynamicData = new Float32Array(s), this.dynamicDataUint32 = new Uint32Array(s), this.dynamicBuffer = new Ce(this.dynamicData, !1, !1);
      var o = 0;
      this.staticStride = 0;
      for (var i = 0; i < this.staticProperties.length; ++i) {
        var n = this.staticProperties[i];
        n.offset = o, o += n.size, this.staticStride += n.size;
      }
      var a = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
      this.staticData = new Float32Array(a), this.staticDataUint32 = new Uint32Array(a), this.staticBuffer = new Ce(this.staticData, !0, !1);
      for (var i = 0; i < this.dynamicProperties.length; ++i) {
        var n = this.dynamicProperties[i];
        t.addAttribute(n.attributeName, this.dynamicBuffer, 0, n.type === ct.UNSIGNED_BYTE, n.type, this.dynamicStride * 4, n.offset * 4);
      }
      for (var i = 0; i < this.staticProperties.length; ++i) {
        var n = this.staticProperties[i];
        t.addAttribute(n.attributeName, this.staticBuffer, 0, n.type === ct.UNSIGNED_BYTE, n.type, this.staticStride * 4, n.offset * 4);
      }
    }, r.prototype.uploadDynamic = function(t, e, i) {
      for (var n = 0; n < this.dynamicProperties.length; n++) {
        var s = this.dynamicProperties[n];
        s.uploadFunction(t, e, i, s.type === ct.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, s.offset);
      }
      this.dynamicBuffer._updateID++;
    }, r.prototype.uploadStatic = function(t, e, i) {
      for (var n = 0; n < this.staticProperties.length; n++) {
        var s = this.staticProperties[n];
        s.uploadFunction(t, e, i, s.type === ct.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, s.offset);
      }
      this.staticBuffer._updateID++;
    }, r.prototype.destroy = function() {
      this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();
    }, r;
  }()
), hI = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`, lI = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`, uI = (
  /** @class */
  function(r) {
    Sb(t, r);
    function t(e) {
      var i = r.call(this, e) || this;
      return i.shader = null, i.properties = null, i.tempMatrix = new De(), i.properties = [
        // verticesData
        {
          attributeName: "aVertexPosition",
          size: 2,
          uploadFunction: i.uploadVertices,
          offset: 0
        },
        // positionData
        {
          attributeName: "aPositionCoord",
          size: 2,
          uploadFunction: i.uploadPosition,
          offset: 0
        },
        // rotationData
        {
          attributeName: "aRotation",
          size: 1,
          uploadFunction: i.uploadRotation,
          offset: 0
        },
        // uvsData
        {
          attributeName: "aTextureCoord",
          size: 2,
          uploadFunction: i.uploadUvs,
          offset: 0
        },
        // tintData
        {
          attributeName: "aColor",
          size: 1,
          type: ct.UNSIGNED_BYTE,
          uploadFunction: i.uploadTint,
          offset: 0
        }
      ], i.shader = Dn.from(lI, hI, {}), i.state = _s.for2d(), i;
    }
    return t.prototype.render = function(e) {
      var i = e.children, n = e._maxSize, s = e._batchSize, o = this.renderer, a = i.length;
      if (a !== 0) {
        a > n && !e.autoResize && (a = n);
        var l = e._buffers;
        l || (l = e._buffers = this.generateBuffers(e));
        var u = i[0]._texture.baseTexture, c = u.alphaMode > 0;
        this.state.blendMode = j0(e.blendMode, c), o.state.set(this.state);
        var d = o.gl, f = e.worldTransform.copyTo(this.tempMatrix);
        f.prepend(o.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = f.toArray(!0), this.shader.uniforms.uColor = qS(e.tintRgb, e.worldAlpha, this.shader.uniforms.uColor, c), this.shader.uniforms.uSampler = u, this.renderer.shader.bind(this.shader);
        for (var v = !1, m = 0, p = 0; m < a; m += s, p += 1) {
          var y = a - m;
          y > s && (y = s), p >= l.length && l.push(this._generateOneMoreBuffer(e));
          var b = l[p];
          b.uploadDynamic(i, m, y);
          var w = e._bufferUpdateIDs[p] || 0;
          v = v || b._updateID < w, v && (b._updateID = e._updateID, b.uploadStatic(i, m, y)), o.geometry.bind(b.geometry), d.drawElements(d.TRIANGLES, y * 6, d.UNSIGNED_SHORT, 0);
        }
      }
    }, t.prototype.generateBuffers = function(e) {
      for (var i = [], n = e._maxSize, s = e._batchSize, o = e._properties, a = 0; a < n; a += s)
        i.push(new Fg(this.properties, o, s));
      return i;
    }, t.prototype._generateOneMoreBuffer = function(e) {
      var i = e._batchSize, n = e._properties;
      return new Fg(this.properties, n, i);
    }, t.prototype.uploadVertices = function(e, i, n, s, o, a) {
      for (var l = 0, u = 0, c = 0, d = 0, f = 0; f < n; ++f) {
        var v = e[i + f], m = v._texture, p = v.scale.x, y = v.scale.y, b = m.trim, w = m.orig;
        b ? (u = b.x - v.anchor.x * w.width, l = u + b.width, d = b.y - v.anchor.y * w.height, c = d + b.height) : (l = w.width * (1 - v.anchor.x), u = w.width * -v.anchor.x, c = w.height * (1 - v.anchor.y), d = w.height * -v.anchor.y), s[a] = u * p, s[a + 1] = d * y, s[a + o] = l * p, s[a + o + 1] = d * y, s[a + o * 2] = l * p, s[a + o * 2 + 1] = c * y, s[a + o * 3] = u * p, s[a + o * 3 + 1] = c * y, a += o * 4;
      }
    }, t.prototype.uploadPosition = function(e, i, n, s, o, a) {
      for (var l = 0; l < n; l++) {
        var u = e[i + l].position;
        s[a] = u.x, s[a + 1] = u.y, s[a + o] = u.x, s[a + o + 1] = u.y, s[a + o * 2] = u.x, s[a + o * 2 + 1] = u.y, s[a + o * 3] = u.x, s[a + o * 3 + 1] = u.y, a += o * 4;
      }
    }, t.prototype.uploadRotation = function(e, i, n, s, o, a) {
      for (var l = 0; l < n; l++) {
        var u = e[i + l].rotation;
        s[a] = u, s[a + o] = u, s[a + o * 2] = u, s[a + o * 3] = u, a += o * 4;
      }
    }, t.prototype.uploadUvs = function(e, i, n, s, o, a) {
      for (var l = 0; l < n; ++l) {
        var u = e[i + l]._texture._uvs;
        u ? (s[a] = u.x0, s[a + 1] = u.y0, s[a + o] = u.x1, s[a + o + 1] = u.y1, s[a + o * 2] = u.x2, s[a + o * 2 + 1] = u.y2, s[a + o * 3] = u.x3, s[a + o * 3 + 1] = u.y3, a += o * 4) : (s[a] = 0, s[a + 1] = 0, s[a + o] = 0, s[a + o + 1] = 0, s[a + o * 2] = 0, s[a + o * 2 + 1] = 0, s[a + o * 3] = 0, s[a + o * 3 + 1] = 0, a += o * 4);
      }
    }, t.prototype.uploadTint = function(e, i, n, s, o, a) {
      for (var l = 0; l < n; ++l) {
        var u = e[i + l], c = u._texture.baseTexture.alphaMode > 0, d = u.alpha, f = d < 1 && c ? Zm(u._tintRGB, d) : u._tintRGB + (d * 255 << 24);
        s[a] = f, s[a + o] = f, s[a + o * 2] = f, s[a + o * 3] = f, a += o * 4;
      }
    }, t.prototype.destroy = function() {
      r.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;
    }, t.extension = {
      name: "particle",
      type: qt.RendererPlugin
    }, t;
  }(Rc)
);
/*!
 * @pixi/graphics - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/graphics is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Ln;
(function(r) {
  r.MITER = "miter", r.BEVEL = "bevel", r.ROUND = "round";
})(Ln || (Ln = {}));
var vs;
(function(r) {
  r.BUTT = "butt", r.ROUND = "round", r.SQUARE = "square";
})(vs || (vs = {}));
var Il = {
  adaptive: !0,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount: function(r, t) {
    if (t === void 0 && (t = 20), !this.adaptive || !r || isNaN(r))
      return t;
    var e = Math.ceil(r / this.maxLength);
    return e < this.minSegments ? e = this.minSegments : e > this.maxSegments && (e = this.maxSegments), e;
  }
}, Pb = (
  /** @class */
  function() {
    function r() {
      this.color = 16777215, this.alpha = 1, this.texture = ut.WHITE, this.matrix = null, this.visible = !1, this.reset();
    }
    return r.prototype.clone = function() {
      var t = new r();
      return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t;
    }, r.prototype.reset = function() {
      this.color = 16777215, this.alpha = 1, this.texture = ut.WHITE, this.matrix = null, this.visible = !1;
    }, r.prototype.destroy = function() {
      this.texture = null, this.matrix = null;
    }, r;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ay = function(r, t) {
  return Ay = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Ay(r, t);
};
function O_(r, t) {
  Ay(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function Bg(r, t) {
  var e, i;
  t === void 0 && (t = !1);
  var n = r.length;
  if (!(n < 6)) {
    for (var s = 0, o = 0, a = r[n - 2], l = r[n - 1]; o < n; o += 2) {
      var u = r[o], c = r[o + 1];
      s += (u - a) * (c + l), a = u, l = c;
    }
    if (!t && s > 0 || t && s <= 0)
      for (var d = n / 2, o = d + d % 2; o < n; o += 2) {
        var f = n - o - 2, v = n - o - 1, m = o, p = o + 1;
        e = [r[m], r[f]], r[f] = e[0], r[m] = e[1], i = [r[p], r[v]], r[v] = i[0], r[p] = i[1];
      }
  }
}
var Ob = {
  build: function(r) {
    r.points = r.shape.points.slice();
  },
  triangulate: function(r, t) {
    var e = r.points, i = r.holes, n = t.points, s = t.indices;
    if (e.length >= 6) {
      Bg(e, !1);
      for (var o = [], a = 0; a < i.length; a++) {
        var l = i[a];
        Bg(l.points, !0), o.push(e.length / 2), e = e.concat(l.points);
      }
      var u = F0(e, o, 2);
      if (!u)
        return;
      for (var c = n.length / 2, a = 0; a < u.length; a += 3)
        s.push(u[a] + c), s.push(u[a + 1] + c), s.push(u[a + 2] + c);
      for (var a = 0; a < e.length; a++)
        n.push(e[a]);
    }
  }
}, nd = {
  build: function(r) {
    var t = r.points, e, i, n, s, o, a;
    if (r.type === Be.CIRC) {
      var l = r.shape;
      e = l.x, i = l.y, o = a = l.radius, n = s = 0;
    } else if (r.type === Be.ELIP) {
      var u = r.shape;
      e = u.x, i = u.y, o = u.width, a = u.height, n = s = 0;
    } else {
      var c = r.shape, d = c.width / 2, f = c.height / 2;
      e = c.x + d, i = c.y + f, o = a = Math.max(0, Math.min(c.radius, Math.min(d, f))), n = d - o, s = f - a;
    }
    if (!(o >= 0 && a >= 0 && n >= 0 && s >= 0)) {
      t.length = 0;
      return;
    }
    var v = Math.ceil(2.3 * Math.sqrt(o + a)), m = v * 8 + (n ? 4 : 0) + (s ? 4 : 0);
    if (t.length = m, m !== 0) {
      if (v === 0) {
        t.length = 8, t[0] = t[6] = e + n, t[1] = t[3] = i + s, t[2] = t[4] = e - n, t[5] = t[7] = i - s;
        return;
      }
      var p = 0, y = v * 4 + (n ? 2 : 0) + 2, b = y, w = m;
      {
        var E = n + o, O = s, I = e + E, S = e - E, C = i + O;
        if (t[p++] = I, t[p++] = C, t[--y] = C, t[--y] = S, s) {
          var P = i - O;
          t[b++] = S, t[b++] = P, t[--w] = P, t[--w] = I;
        }
      }
      for (var R = 1; R < v; R++) {
        var N = Math.PI / 2 * (R / v), E = n + Math.cos(N) * o, O = s + Math.sin(N) * a, I = e + E, S = e - E, C = i + O, P = i - O;
        t[p++] = I, t[p++] = C, t[--y] = C, t[--y] = S, t[b++] = S, t[b++] = P, t[--w] = P, t[--w] = I;
      }
      {
        var E = n, O = s + a, I = e + E, S = e - E, C = i + O, P = i - O;
        t[p++] = I, t[p++] = C, t[--w] = P, t[--w] = I, n && (t[p++] = S, t[p++] = C, t[--w] = P, t[--w] = S);
      }
    }
  },
  triangulate: function(r, t) {
    var e = r.points, i = t.points, n = t.indices;
    if (e.length !== 0) {
      var s = i.length / 2, o = s, a, l;
      if (r.type !== Be.RREC) {
        var u = r.shape;
        a = u.x, l = u.y;
      } else {
        var c = r.shape;
        a = c.x + c.width / 2, l = c.y + c.height / 2;
      }
      var d = r.matrix;
      i.push(r.matrix ? d.a * a + d.c * l + d.tx : a, r.matrix ? d.b * a + d.d * l + d.ty : l), s++, i.push(e[0], e[1]);
      for (var f = 2; f < e.length; f += 2)
        i.push(e[f], e[f + 1]), n.push(s++, o, s);
      n.push(o + 1, o, s);
    }
  }
}, cI = {
  build: function(r) {
    var t = r.shape, e = t.x, i = t.y, n = t.width, s = t.height, o = r.points;
    o.length = 0, o.push(e, i, e + n, i, e + n, i + s, e, i + s);
  },
  triangulate: function(r, t) {
    var e = r.points, i = t.points, n = i.length / 2;
    i.push(e[0], e[1], e[2], e[3], e[6], e[7], e[4], e[5]), t.indices.push(n, n + 1, n + 2, n + 1, n + 2, n + 3);
  }
};
function oa(r, t, e) {
  var i = t - r;
  return r + i * e;
}
function tf(r, t, e, i, n, s, o) {
  o === void 0 && (o = []);
  for (var a = 20, l = o, u = 0, c = 0, d = 0, f = 0, v = 0, m = 0, p = 0, y = 0; p <= a; ++p)
    y = p / a, u = oa(r, e, y), c = oa(t, i, y), d = oa(e, n, y), f = oa(i, s, y), v = oa(u, d, y), m = oa(c, f, y), !(p === 0 && l[l.length - 2] === v && l[l.length - 1] === m) && l.push(v, m);
  return l;
}
var fI = {
  build: function(r) {
    if (Ci.nextRoundedRectBehavior) {
      nd.build(r);
      return;
    }
    var t = r.shape, e = r.points, i = t.x, n = t.y, s = t.width, o = t.height, a = Math.max(0, Math.min(t.radius, Math.min(s, o) / 2));
    e.length = 0, a ? (tf(i, n + a, i, n, i + a, n, e), tf(i + s - a, n, i + s, n, i + s, n + a, e), tf(i + s, n + o - a, i + s, n + o, i + s - a, n + o, e), tf(i + a, n + o, i, n + o, i, n + o - a, e)) : e.push(i, n, i + s, n, i + s, n + o, i, n + o);
  },
  triangulate: function(r, t) {
    if (Ci.nextRoundedRectBehavior) {
      nd.triangulate(r, t);
      return;
    }
    for (var e = r.points, i = t.points, n = t.indices, s = i.length / 2, o = F0(e, null, 2), a = 0, l = o.length; a < l; a += 3)
      n.push(o[a] + s), n.push(o[a + 1] + s), n.push(o[a + 2] + s);
    for (var a = 0, l = e.length; a < l; a++)
      i.push(e[a], e[++a]);
  }
};
function Ug(r, t, e, i, n, s, o, a) {
  var l = r - e * n, u = t - i * n, c = r + e * s, d = t + i * s, f, v;
  o ? (f = i, v = -e) : (f = -i, v = e);
  var m = l + f, p = u + v, y = c + f, b = d + v;
  return a.push(m, p), a.push(y, b), 2;
}
function Es(r, t, e, i, n, s, o, a) {
  var l = e - r, u = i - t, c = Math.atan2(l, u), d = Math.atan2(n - r, s - t);
  a && c < d ? c += Math.PI * 2 : !a && c > d && (d += Math.PI * 2);
  var f = c, v = d - c, m = Math.abs(v), p = Math.sqrt(l * l + u * u), y = (15 * m * Math.sqrt(p) / Math.PI >> 0) + 1, b = v / y;
  if (f += b, a) {
    o.push(r, t), o.push(e, i);
    for (var w = 1, E = f; w < y; w++, E += b)
      o.push(r, t), o.push(r + Math.sin(E) * p, t + Math.cos(E) * p);
    o.push(r, t), o.push(n, s);
  } else {
    o.push(e, i), o.push(r, t);
    for (var w = 1, E = f; w < y; w++, E += b)
      o.push(r + Math.sin(E) * p, t + Math.cos(E) * p), o.push(r, t);
    o.push(n, s), o.push(r, t);
  }
  return y * 2;
}
function dI(r, t) {
  var e = r.shape, i = r.points || e.points.slice(), n = t.closePointEps;
  if (i.length !== 0) {
    var s = r.lineStyle, o = new te(i[0], i[1]), a = new te(i[i.length - 2], i[i.length - 1]), l = e.type !== Be.POLY || e.closeStroke, u = Math.abs(o.x - a.x) < n && Math.abs(o.y - a.y) < n;
    if (l) {
      i = i.slice(), u && (i.pop(), i.pop(), a.set(i[i.length - 2], i[i.length - 1]));
      var c = (o.x + a.x) * 0.5, d = (a.y + o.y) * 0.5;
      i.unshift(c, d), i.push(c, d);
    }
    var f = t.points, v = i.length / 2, m = i.length, p = f.length / 2, y = s.width / 2, b = y * y, w = s.miterLimit * s.miterLimit, E = i[0], O = i[1], I = i[2], S = i[3], C = 0, P = 0, R = -(O - S), N = E - I, F = 0, $ = 0, q = Math.sqrt(R * R + N * N);
    R /= q, N /= q, R *= y, N *= y;
    var ht = s.alignment, V = (1 - ht) * 2, H = ht * 2;
    l || (s.cap === vs.ROUND ? m += Es(E - R * (V - H) * 0.5, O - N * (V - H) * 0.5, E - R * V, O - N * V, E + R * H, O + N * H, f, !0) + 2 : s.cap === vs.SQUARE && (m += Ug(E, O, R, N, V, H, !0, f))), f.push(E - R * V, O - N * V), f.push(E + R * H, O + N * H);
    for (var Q = 1; Q < v - 1; ++Q) {
      E = i[(Q - 1) * 2], O = i[(Q - 1) * 2 + 1], I = i[Q * 2], S = i[Q * 2 + 1], C = i[(Q + 1) * 2], P = i[(Q + 1) * 2 + 1], R = -(O - S), N = E - I, q = Math.sqrt(R * R + N * N), R /= q, N /= q, R *= y, N *= y, F = -(S - P), $ = I - C, q = Math.sqrt(F * F + $ * $), F /= q, $ /= q, F *= y, $ *= y;
      var mt = I - E, et = O - S, Tt = I - C, it = P - S, we = mt * Tt + et * it, Bt = et * Tt - it * mt, Dt = Bt < 0;
      if (Math.abs(Bt) < 1e-3 * Math.abs(we)) {
        f.push(I - R * V, S - N * V), f.push(I + R * H, S + N * H), we >= 0 && (s.join === Ln.ROUND ? m += Es(I, S, I - R * V, S - N * V, I - F * V, S - $ * V, f, !1) + 4 : m += 2, f.push(I - F * H, S - $ * H), f.push(I + F * V, S + $ * V));
        continue;
      }
      var Ut = (-R + E) * (-N + S) - (-R + I) * (-N + O), k = (-F + C) * (-$ + S) - (-F + I) * (-$ + P), zt = (mt * k - Tt * Ut) / Bt, lt = (it * Ut - et * k) / Bt, me = (zt - I) * (zt - I) + (lt - S) * (lt - S), jt = I + (zt - I) * V, Z = S + (lt - S) * V, be = I - (zt - I) * H, ft = S - (lt - S) * H, B = Math.min(mt * mt + et * et, Tt * Tt + it * it), at = Dt ? V : H, Et = B + at * at * b, U = me <= Et;
      U ? s.join === Ln.BEVEL || me / b > w ? (Dt ? (f.push(jt, Z), f.push(I + R * H, S + N * H), f.push(jt, Z), f.push(I + F * H, S + $ * H)) : (f.push(I - R * V, S - N * V), f.push(be, ft), f.push(I - F * V, S - $ * V), f.push(be, ft)), m += 2) : s.join === Ln.ROUND ? Dt ? (f.push(jt, Z), f.push(I + R * H, S + N * H), m += Es(I, S, I + R * H, S + N * H, I + F * H, S + $ * H, f, !0) + 4, f.push(jt, Z), f.push(I + F * H, S + $ * H)) : (f.push(I - R * V, S - N * V), f.push(be, ft), m += Es(I, S, I - R * V, S - N * V, I - F * V, S - $ * V, f, !1) + 4, f.push(I - F * V, S - $ * V), f.push(be, ft)) : (f.push(jt, Z), f.push(be, ft)) : (f.push(I - R * V, S - N * V), f.push(I + R * H, S + N * H), s.join === Ln.ROUND ? Dt ? m += Es(I, S, I + R * H, S + N * H, I + F * H, S + $ * H, f, !0) + 2 : m += Es(I, S, I - R * V, S - N * V, I - F * V, S - $ * V, f, !1) + 2 : s.join === Ln.MITER && me / b <= w && (Dt ? (f.push(be, ft), f.push(be, ft)) : (f.push(jt, Z), f.push(jt, Z)), m += 2), f.push(I - F * V, S - $ * V), f.push(I + F * H, S + $ * H), m += 2);
    }
    E = i[(v - 2) * 2], O = i[(v - 2) * 2 + 1], I = i[(v - 1) * 2], S = i[(v - 1) * 2 + 1], R = -(O - S), N = E - I, q = Math.sqrt(R * R + N * N), R /= q, N /= q, R *= y, N *= y, f.push(I - R * V, S - N * V), f.push(I + R * H, S + N * H), l || (s.cap === vs.ROUND ? m += Es(I - R * (V - H) * 0.5, S - N * (V - H) * 0.5, I - R * V, S - N * V, I + R * H, S + N * H, f, !1) + 2 : s.cap === vs.SQUARE && (m += Ug(I, S, R, N, V, H, !1, f)));
    for (var Re = t.indices, pi = Il.epsilon * Il.epsilon, Q = p; Q < m + p - 2; ++Q)
      E = f[Q * 2], O = f[Q * 2 + 1], I = f[(Q + 1) * 2], S = f[(Q + 1) * 2 + 1], C = f[(Q + 2) * 2], P = f[(Q + 2) * 2 + 1], !(Math.abs(E * (S - P) + I * (P - O) + C * (O - S)) < pi) && Re.push(Q, Q + 1, Q + 2);
  }
}
function pI(r, t) {
  var e = 0, i = r.shape, n = r.points || i.points, s = i.type !== Be.POLY || i.closeStroke;
  if (n.length !== 0) {
    var o = t.points, a = t.indices, l = n.length / 2, u = o.length / 2, c = u;
    for (o.push(n[0], n[1]), e = 1; e < l; e++)
      o.push(n[e * 2], n[e * 2 + 1]), a.push(c, c + 1), c++;
    s && a.push(c, u);
  }
}
function Gg(r, t) {
  r.lineStyle.native ? pI(r, t) : dI(r, t);
}
var jg = (
  /** @class */
  function() {
    function r() {
    }
    return r.curveTo = function(t, e, i, n, s, o) {
      var a = o[o.length - 2], l = o[o.length - 1], u = l - e, c = a - t, d = n - e, f = i - t, v = Math.abs(u * f - c * d);
      if (v < 1e-8 || s === 0)
        return (o[o.length - 2] !== t || o[o.length - 1] !== e) && o.push(t, e), null;
      var m = u * u + c * c, p = d * d + f * f, y = u * d + c * f, b = s * Math.sqrt(m) / v, w = s * Math.sqrt(p) / v, E = b * y / m, O = w * y / p, I = b * f + w * c, S = b * d + w * u, C = c * (w + E), P = u * (w + E), R = f * (b + O), N = d * (b + O), F = Math.atan2(P - S, C - I), $ = Math.atan2(N - S, R - I);
      return {
        cx: I + t,
        cy: S + e,
        radius: s,
        startAngle: F,
        endAngle: $,
        anticlockwise: c * d > f * u
      };
    }, r.arc = function(t, e, i, n, s, o, a, l, u) {
      for (var c = a - o, d = Il._segmentsCount(Math.abs(c) * s, Math.ceil(Math.abs(c) / Kf) * 40), f = c / (d * 2), v = f * 2, m = Math.cos(f), p = Math.sin(f), y = d - 1, b = y % 1 / y, w = 0; w <= y; ++w) {
        var E = w + b * w, O = f + o + v * E, I = Math.cos(O), S = -Math.sin(O);
        u.push((m * I + p * S) * s + i, (m * -S + p * I) * s + n);
      }
    }, r;
  }()
), vI = (
  /** @class */
  function() {
    function r() {
    }
    return r.curveLength = function(t, e, i, n, s, o, a, l) {
      for (var u = 10, c = 0, d = 0, f = 0, v = 0, m = 0, p = 0, y = 0, b = 0, w = 0, E = 0, O = 0, I = t, S = e, C = 1; C <= u; ++C)
        d = C / u, f = d * d, v = f * d, m = 1 - d, p = m * m, y = p * m, b = y * t + 3 * p * d * i + 3 * m * f * s + v * a, w = y * e + 3 * p * d * n + 3 * m * f * o + v * l, E = I - b, O = S - w, I = b, S = w, c += Math.sqrt(E * E + O * O);
      return c;
    }, r.curveTo = function(t, e, i, n, s, o, a) {
      var l = a[a.length - 2], u = a[a.length - 1];
      a.length -= 2;
      var c = Il._segmentsCount(r.curveLength(l, u, t, e, i, n, s, o)), d = 0, f = 0, v = 0, m = 0, p = 0;
      a.push(l, u);
      for (var y = 1, b = 0; y <= c; ++y)
        b = y / c, d = 1 - b, f = d * d, v = f * d, m = b * b, p = m * b, a.push(v * l + 3 * f * b * t + 3 * d * m * i + p * s, v * u + 3 * f * b * e + 3 * d * m * n + p * o);
    }, r;
  }()
), yI = (
  /** @class */
  function() {
    function r() {
    }
    return r.curveLength = function(t, e, i, n, s, o) {
      var a = t - 2 * i + s, l = e - 2 * n + o, u = 2 * i - 2 * t, c = 2 * n - 2 * e, d = 4 * (a * a + l * l), f = 4 * (a * u + l * c), v = u * u + c * c, m = 2 * Math.sqrt(d + f + v), p = Math.sqrt(d), y = 2 * d * p, b = 2 * Math.sqrt(v), w = f / p;
      return (y * m + p * f * (m - b) + (4 * v * d - f * f) * Math.log((2 * p + w + m) / (w + b))) / (4 * y);
    }, r.curveTo = function(t, e, i, n, s) {
      for (var o = s[s.length - 2], a = s[s.length - 1], l = Il._segmentsCount(r.curveLength(o, a, t, e, i, n)), u = 0, c = 0, d = 1; d <= l; ++d) {
        var f = d / l;
        u = o + (t - o) * f, c = a + (e - a) * f, s.push(u + (t + (i - t) * f - u) * f, c + (e + (n - e) * f - c) * f);
      }
    }, r;
  }()
), mI = (
  /** @class */
  function() {
    function r() {
      this.reset();
    }
    return r.prototype.begin = function(t, e, i) {
      this.reset(), this.style = t, this.start = e, this.attribStart = i;
    }, r.prototype.end = function(t, e) {
      this.attribSize = e - this.attribStart, this.size = t - this.start;
    }, r.prototype.reset = function() {
      this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;
    }, r;
  }()
), Ts, ly = (Ts = {}, Ts[Be.POLY] = Ob, Ts[Be.CIRC] = nd, Ts[Be.ELIP] = nd, Ts[Be.RECT] = cI, Ts[Be.RREC] = fI, Ts), Hg = [], ef = [], $g = (
  /** @class */
  function() {
    function r(t, e, i, n) {
      e === void 0 && (e = null), i === void 0 && (i = null), n === void 0 && (n = null), this.points = [], this.holes = [], this.shape = t, this.lineStyle = i, this.fillStyle = e, this.matrix = n, this.type = t.type;
    }
    return r.prototype.clone = function() {
      return new r(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    }, r.prototype.destroy = function() {
      this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;
    }, r;
  }()
), aa = new te(), _I = (
  /** @class */
  function(r) {
    O_(t, r);
    function t() {
      var e = r.call(this) || this;
      return e.closePointEps = 1e-4, e.boundsPadding = 0, e.uvsFloat32 = null, e.indicesUint16 = null, e.batchable = !1, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.drawCalls = [], e.batchDirty = -1, e.batches = [], e.dirty = 0, e.cacheDirty = -1, e.clearDirty = 0, e.shapeIndex = 0, e._bounds = new Jf(), e.boundsDirty = -1, e;
    }
    return Object.defineProperty(t.prototype, "bounds", {
      /**
       * Get the current bounds of the graphic geometry.
       * @readonly
       */
      get: function() {
        return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.invalidate = function() {
      this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
      for (var e = 0; e < this.drawCalls.length; e++)
        this.drawCalls[e].texArray.clear(), ef.push(this.drawCalls[e]);
      this.drawCalls.length = 0;
      for (var e = 0; e < this.batches.length; e++) {
        var i = this.batches[e];
        i.reset(), Hg.push(i);
      }
      this.batches.length = 0;
    }, t.prototype.clear = function() {
      return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;
    }, t.prototype.drawShape = function(e, i, n, s) {
      i === void 0 && (i = null), n === void 0 && (n = null), s === void 0 && (s = null);
      var o = new $g(e, i, n, s);
      return this.graphicsData.push(o), this.dirty++, this;
    }, t.prototype.drawHole = function(e, i) {
      if (i === void 0 && (i = null), !this.graphicsData.length)
        return null;
      var n = new $g(e, null, null, i), s = this.graphicsData[this.graphicsData.length - 1];
      return n.lineStyle = s.lineStyle, s.holes.push(n), this.dirty++, this;
    }, t.prototype.destroy = function() {
      r.prototype.destroy.call(this);
      for (var e = 0; e < this.graphicsData.length; ++e)
        this.graphicsData[e].destroy();
      this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;
    }, t.prototype.containsPoint = function(e) {
      for (var i = this.graphicsData, n = 0; n < i.length; ++n) {
        var s = i[n];
        if (s.fillStyle.visible && s.shape && (s.matrix ? s.matrix.applyInverse(e, aa) : aa.copyFrom(e), s.shape.contains(aa.x, aa.y))) {
          var o = !1;
          if (s.holes)
            for (var a = 0; a < s.holes.length; a++) {
              var l = s.holes[a];
              if (l.shape.contains(aa.x, aa.y)) {
                o = !0;
                break;
              }
            }
          if (!o)
            return !0;
        }
      }
      return !1;
    }, t.prototype.updateBatches = function() {
      if (!this.graphicsData.length) {
        this.batchable = !0;
        return;
      }
      if (this.validateBatching()) {
        this.cacheDirty = this.dirty;
        var e = this.uvs, i = this.graphicsData, n = null, s = null;
        this.batches.length > 0 && (n = this.batches[this.batches.length - 1], s = n.style);
        for (var o = this.shapeIndex; o < i.length; o++) {
          this.shapeIndex++;
          var a = i[o], l = a.fillStyle, u = a.lineStyle, c = ly[a.type];
          c.build(a), a.matrix && this.transformPoints(a.points, a.matrix), (l.visible || u.visible) && this.processHoles(a.holes);
          for (var d = 0; d < 2; d++) {
            var f = d === 0 ? l : u;
            if (f.visible) {
              var v = f.texture.baseTexture, m = this.indices.length, p = this.points.length / 2;
              v.wrapMode = Wr.REPEAT, d === 0 ? this.processFill(a) : this.processLine(a);
              var y = this.points.length / 2 - p;
              y !== 0 && (n && !this._compareStyles(s, f) && (n.end(m, p), n = null), n || (n = Hg.pop() || new mI(), n.begin(f, m, p), this.batches.push(n), s = f), this.addUvs(this.points, e, f.texture, p, y, f.matrix));
            }
          }
        }
        var b = this.indices.length, w = this.points.length / 2;
        if (n && n.end(b, w), this.batches.length === 0) {
          this.batchable = !0;
          return;
        }
        var E = w > 65535;
        this.indicesUint16 && this.indices.length === this.indicesUint16.length && E === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = E ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();
      }
    }, t.prototype._compareStyles = function(e, i) {
      return !(!e || !i || e.texture.baseTexture !== i.texture.baseTexture || e.color + e.alpha !== i.color + i.alpha || !!e.native != !!i.native);
    }, t.prototype.validateBatching = function() {
      if (this.dirty === this.cacheDirty || !this.graphicsData.length)
        return !1;
      for (var e = 0, i = this.graphicsData.length; e < i; e++) {
        var n = this.graphicsData[e], s = n.fillStyle, o = n.lineStyle;
        if (s && !s.texture.baseTexture.valid || o && !o.texture.baseTexture.valid)
          return !1;
      }
      return !0;
    }, t.prototype.packBatches = function() {
      this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
      for (var e = this.batches, i = 0, n = e.length; i < n; i++)
        for (var s = e[i], o = 0; o < s.size; o++) {
          var a = s.start + o;
          this.indicesUint16[a] = this.indicesUint16[a] - s.attribStart;
        }
    }, t.prototype.isBatchable = function() {
      if (this.points.length > 65535 * 2)
        return !1;
      for (var e = this.batches, i = 0; i < e.length; i++)
        if (e[i].style.native)
          return !1;
      return this.points.length < t.BATCHABLE_SIZE * 2;
    }, t.prototype.buildDrawCalls = function() {
      for (var e = ++Mt._globalBatch, i = 0; i < this.drawCalls.length; i++)
        this.drawCalls[i].texArray.clear(), ef.push(this.drawCalls[i]);
      this.drawCalls.length = 0;
      var n = this.colors, s = this.textureIds, o = ef.pop();
      o || (o = new td(), o.texArray = new ed()), o.texArray.count = 0, o.start = 0, o.size = 0, o.type = _r.TRIANGLES;
      var a = 0, l = null, u = 0, c = !1, d = _r.TRIANGLES, f = 0;
      this.drawCalls.push(o);
      for (var i = 0; i < this.batches.length; i++) {
        var v = this.batches[i], m = 8, p = v.style, y = p.texture.baseTexture;
        c !== !!p.native && (c = !!p.native, d = c ? _r.LINES : _r.TRIANGLES, l = null, a = m, e++), l !== y && (l = y, y._batchEnabled !== e && (a === m && (e++, a = 0, o.size > 0 && (o = ef.pop(), o || (o = new td(), o.texArray = new ed()), this.drawCalls.push(o)), o.start = f, o.size = 0, o.texArray.count = 0, o.type = d), y.touched = 1, y._batchEnabled = e, y._batchLocation = a, y.wrapMode = Wr.REPEAT, o.texArray.elements[o.texArray.count++] = y, a++)), o.size += v.size, f += v.size, u = y._batchLocation, this.addColors(n, p.color, p.alpha, v.attribSize, v.attribStart), this.addTextureIds(s, u, v.attribSize, v.attribStart);
      }
      Mt._globalBatch = e, this.packAttributes();
    }, t.prototype.packAttributes = function() {
      for (var e = this.points, i = this.uvs, n = this.colors, s = this.textureIds, o = new ArrayBuffer(e.length * 3 * 4), a = new Float32Array(o), l = new Uint32Array(o), u = 0, c = 0; c < e.length / 2; c++)
        a[u++] = e[c * 2], a[u++] = e[c * 2 + 1], a[u++] = i[c * 2], a[u++] = i[c * 2 + 1], l[u++] = n[c], a[u++] = s[c];
      this._buffer.update(o), this._indexBuffer.update(this.indicesUint16);
    }, t.prototype.processFill = function(e) {
      if (e.holes.length)
        Ob.triangulate(e, this);
      else {
        var i = ly[e.type];
        i.triangulate(e, this);
      }
    }, t.prototype.processLine = function(e) {
      Gg(e, this);
      for (var i = 0; i < e.holes.length; i++)
        Gg(e.holes[i], this);
    }, t.prototype.processHoles = function(e) {
      for (var i = 0; i < e.length; i++) {
        var n = e[i], s = ly[n.type];
        s.build(n), n.matrix && this.transformPoints(n.points, n.matrix);
      }
    }, t.prototype.calculateBounds = function() {
      var e = this._bounds;
      e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding);
    }, t.prototype.transformPoints = function(e, i) {
      for (var n = 0; n < e.length / 2; n++) {
        var s = e[n * 2], o = e[n * 2 + 1];
        e[n * 2] = i.a * s + i.c * o + i.tx, e[n * 2 + 1] = i.b * s + i.d * o + i.ty;
      }
    }, t.prototype.addColors = function(e, i, n, s, o) {
      o === void 0 && (o = 0);
      var a = (i >> 16) + (i & 65280) + ((i & 255) << 16), l = Zm(a, n);
      e.length = Math.max(e.length, o + s);
      for (var u = 0; u < s; u++)
        e[o + u] = l;
    }, t.prototype.addTextureIds = function(e, i, n, s) {
      s === void 0 && (s = 0), e.length = Math.max(e.length, s + n);
      for (var o = 0; o < n; o++)
        e[s + o] = i;
    }, t.prototype.addUvs = function(e, i, n, s, o, a) {
      a === void 0 && (a = null);
      for (var l = 0, u = i.length, c = n.frame; l < o; ) {
        var d = e[(s + l) * 2], f = e[(s + l) * 2 + 1];
        if (a) {
          var v = a.a * d + a.c * f + a.tx;
          f = a.b * d + a.d * f + a.ty, d = v;
        }
        l++, i.push(d / c.width, f / c.height);
      }
      var m = n.baseTexture;
      (c.width < m.width || c.height < m.height) && this.adjustUvs(i, n, u, o);
    }, t.prototype.adjustUvs = function(e, i, n, s) {
      for (var o = i.baseTexture, a = 1e-6, l = n + s * 2, u = i.frame, c = u.width / o.width, d = u.height / o.height, f = u.x / u.width, v = u.y / u.height, m = Math.floor(e[n] + a), p = Math.floor(e[n + 1] + a), y = n + 2; y < l; y += 2)
        m = Math.min(m, Math.floor(e[y] + a)), p = Math.min(p, Math.floor(e[y + 1] + a));
      f -= m, v -= p;
      for (var y = n; y < l; y += 2)
        e[y] = (e[y] + f) * c, e[y + 1] = (e[y + 1] + v) * d;
    }, t.BATCHABLE_SIZE = 100, t;
  }(T_)
), gI = (
  /** @class */
  function(r) {
    O_(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.width = 0, e.alignment = 0.5, e.native = !1, e.cap = vs.BUTT, e.join = Ln.MITER, e.miterLimit = 10, e;
    }
    return t.prototype.clone = function() {
      var e = new t();
      return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e.width = this.width, e.alignment = this.alignment, e.native = this.native, e.cap = this.cap, e.join = this.join, e.miterLimit = this.miterLimit, e;
    }, t.prototype.reset = function() {
      r.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1;
    }, t;
  }(Pb)
), bI = new Float32Array(3), uy = {}, Ci = (
  /** @class */
  function(r) {
    O_(t, r);
    function t(e) {
      e === void 0 && (e = null);
      var i = r.call(this) || this;
      return i.shader = null, i.pluginName = "batch", i.currentPath = null, i.batches = [], i.batchTint = -1, i.batchDirty = -1, i.vertexData = null, i._fillStyle = new Pb(), i._lineStyle = new gI(), i._matrix = null, i._holeMode = !1, i.state = _s.for2d(), i._geometry = e || new _I(), i._geometry.refCount++, i._transformID = -1, i.tint = 16777215, i.blendMode = ot.NORMAL, i;
    }
    return Object.defineProperty(t.prototype, "geometry", {
      /**
       * Includes vertex positions, face indices, normals, colors, UVs, and
       * custom attributes within buffers, reducing the cost of passing all
       * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
       * @readonly
       */
      get: function() {
        return this._geometry;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.clone = function() {
      return this.finishPoly(), new t(this._geometry);
    }, Object.defineProperty(t.prototype, "blendMode", {
      get: function() {
        return this.state.blendMode;
      },
      /**
       * The blend mode to be applied to the graphic shape. Apply a value of
       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each
       * primitive in the GraphicsGeometry list is rendered sequentially, modes
       * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will
       * be applied per-primitive.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      set: function(e) {
        this.state.blendMode = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      /**
       * The tint applied to each graphic shape. This is a hex value. A value of
       * 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get: function() {
        return this._tint;
      },
      set: function(e) {
        this._tint = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "fill", {
      /**
       * The current fill style.
       * @readonly
       */
      get: function() {
        return this._fillStyle;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "line", {
      /**
       * The current line style.
       * @readonly
       */
      get: function() {
        return this._lineStyle;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.lineStyle = function(e, i, n, s, o) {
      return e === void 0 && (e = null), i === void 0 && (i = 0), n === void 0 && (n = 1), s === void 0 && (s = 0.5), o === void 0 && (o = !1), typeof e == "number" && (e = { width: e, color: i, alpha: n, alignment: s, native: o }), this.lineTextureStyle(e);
    }, t.prototype.lineTextureStyle = function(e) {
      e = Object.assign({
        width: 0,
        texture: ut.WHITE,
        color: e && e.texture ? 16777215 : 0,
        alpha: 1,
        matrix: null,
        alignment: 0.5,
        native: !1,
        cap: vs.BUTT,
        join: Ln.MITER,
        miterLimit: 10
      }, e), this.currentPath && this.startPoly();
      var i = e.width > 0 && e.alpha > 0;
      return i ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, { visible: i }, e)) : this._lineStyle.reset(), this;
    }, t.prototype.startPoly = function() {
      if (this.currentPath) {
        var e = this.currentPath.points, i = this.currentPath.points.length;
        i > 2 && (this.drawShape(this.currentPath), this.currentPath = new ff(), this.currentPath.closeStroke = !1, this.currentPath.points.push(e[i - 2], e[i - 1]));
      } else
        this.currentPath = new ff(), this.currentPath.closeStroke = !1;
    }, t.prototype.finishPoly = function() {
      this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);
    }, t.prototype.moveTo = function(e, i) {
      return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = i, this;
    }, t.prototype.lineTo = function(e, i) {
      this.currentPath || this.moveTo(0, 0);
      var n = this.currentPath.points, s = n[n.length - 2], o = n[n.length - 1];
      return (s !== e || o !== i) && n.push(e, i), this;
    }, t.prototype._initCurve = function(e, i) {
      e === void 0 && (e = 0), i === void 0 && (i = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, i]) : this.moveTo(e, i);
    }, t.prototype.quadraticCurveTo = function(e, i, n, s) {
      this._initCurve();
      var o = this.currentPath.points;
      return o.length === 0 && this.moveTo(0, 0), yI.curveTo(e, i, n, s, o), this;
    }, t.prototype.bezierCurveTo = function(e, i, n, s, o, a) {
      return this._initCurve(), vI.curveTo(e, i, n, s, o, a, this.currentPath.points), this;
    }, t.prototype.arcTo = function(e, i, n, s, o) {
      this._initCurve(e, i);
      var a = this.currentPath.points, l = jg.curveTo(e, i, n, s, o, a);
      if (l) {
        var u = l.cx, c = l.cy, d = l.radius, f = l.startAngle, v = l.endAngle, m = l.anticlockwise;
        this.arc(u, c, d, f, v, m);
      }
      return this;
    }, t.prototype.arc = function(e, i, n, s, o, a) {
      if (a === void 0 && (a = !1), s === o)
        return this;
      !a && o <= s ? o += Kf : a && s <= o && (s += Kf);
      var l = o - s;
      if (l === 0)
        return this;
      var u = e + Math.cos(s) * n, c = i + Math.sin(s) * n, d = this._geometry.closePointEps, f = this.currentPath ? this.currentPath.points : null;
      if (f) {
        var v = Math.abs(f[f.length - 2] - u), m = Math.abs(f[f.length - 1] - c);
        v < d && m < d || f.push(u, c);
      } else
        this.moveTo(u, c), f = this.currentPath.points;
      return jg.arc(u, c, e, i, n, s, o, a, f), this;
    }, t.prototype.beginFill = function(e, i) {
      return e === void 0 && (e = 0), i === void 0 && (i = 1), this.beginTextureFill({ texture: ut.WHITE, color: e, alpha: i });
    }, t.prototype.beginTextureFill = function(e) {
      e = Object.assign({
        texture: ut.WHITE,
        color: 16777215,
        alpha: 1,
        matrix: null
      }, e), this.currentPath && this.startPoly();
      var i = e.alpha > 0;
      return i ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, { visible: i }, e)) : this._fillStyle.reset(), this;
    }, t.prototype.endFill = function() {
      return this.finishPoly(), this._fillStyle.reset(), this;
    }, t.prototype.drawRect = function(e, i, n, s) {
      return this.drawShape(new pt(e, i, n, s));
    }, t.prototype.drawRoundedRect = function(e, i, n, s, o) {
      return this.drawShape(new nP(e, i, n, s, o));
    }, t.prototype.drawCircle = function(e, i, n) {
      return this.drawShape(new iP(e, i, n));
    }, t.prototype.drawEllipse = function(e, i, n, s) {
      return this.drawShape(new rP(e, i, n, s));
    }, t.prototype.drawPolygon = function() {
      for (var e = arguments, i = [], n = 0; n < arguments.length; n++)
        i[n] = e[n];
      var s, o = !0, a = i[0];
      a.points ? (o = a.closeStroke, s = a.points) : Array.isArray(i[0]) ? s = i[0] : s = i;
      var l = new ff(s);
      return l.closeStroke = o, this.drawShape(l), this;
    }, t.prototype.drawShape = function(e) {
      return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;
    }, t.prototype.clear = function() {
      return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;
    }, t.prototype.isFastRect = function() {
      var e = this._geometry.graphicsData;
      return e.length === 1 && e[0].shape.type === Be.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width);
    }, t.prototype._render = function(e) {
      this.finishPoly();
      var i = this._geometry;
      i.updateBatches(), i.batchable ? (this.batchDirty !== i.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e));
    }, t.prototype._populateBatches = function() {
      var e = this._geometry, i = this.blendMode, n = e.batches.length;
      this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = n, this.vertexData = new Float32Array(e.points);
      for (var s = 0; s < n; s++) {
        var o = e.batches[s], a = o.style.color, l = new Float32Array(this.vertexData.buffer, o.attribStart * 4 * 2, o.attribSize * 2), u = new Float32Array(e.uvsFloat32.buffer, o.attribStart * 4 * 2, o.attribSize * 2), c = new Uint16Array(e.indicesUint16.buffer, o.start * 2, o.size), d = {
          vertexData: l,
          blendMode: i,
          indices: c,
          uvs: u,
          _batchRGB: Lh(a),
          _tintRGB: a,
          _texture: o.style.texture,
          alpha: o.style.alpha,
          worldAlpha: 1
        };
        this.batches[s] = d;
      }
    }, t.prototype._renderBatched = function(e) {
      if (this.batches.length) {
        e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
        for (var i = 0, n = this.batches.length; i < n; i++) {
          var s = this.batches[i];
          s.worldAlpha = this.worldAlpha * s.alpha, e.plugins[this.pluginName].render(s);
        }
      }
    }, t.prototype._renderDirect = function(e) {
      var i = this._resolveDirectShader(e), n = this._geometry, s = this.tint, o = this.worldAlpha, a = i.uniforms, l = n.drawCalls;
      a.translationMatrix = this.transform.worldTransform, a.tint[0] = (s >> 16 & 255) / 255 * o, a.tint[1] = (s >> 8 & 255) / 255 * o, a.tint[2] = (s & 255) / 255 * o, a.tint[3] = o, e.shader.bind(i), e.geometry.bind(n, i), e.state.set(this.state);
      for (var u = 0, c = l.length; u < c; u++)
        this._renderDrawCallDirect(e, n.drawCalls[u]);
    }, t.prototype._renderDrawCallDirect = function(e, i) {
      for (var n = i.texArray, s = i.type, o = i.size, a = i.start, l = n.count, u = 0; u < l; u++)
        e.texture.bind(n.elements[u], u);
      e.geometry.draw(s, o, a);
    }, t.prototype._resolveDirectShader = function(e) {
      var i = this.shader, n = this.pluginName;
      if (!i) {
        if (!uy[n]) {
          for (var s = e.plugins[n].MAX_TEXTURES, o = new Int32Array(s), a = 0; a < s; a++)
            o[a] = a;
          var l = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new De(),
            default: ms.from({ uSamplers: o }, !0)
          }, u = e.plugins[n]._shader.program;
          uy[n] = new Dn(u, l);
        }
        i = uy[n];
      }
      return i;
    }, t.prototype._calculateBounds = function() {
      this.finishPoly();
      var e = this._geometry;
      if (e.graphicsData.length) {
        var i = e.bounds, n = i.minX, s = i.minY, o = i.maxX, a = i.maxY;
        this._bounds.addFrame(this.transform, n, s, o, a);
      }
    }, t.prototype.containsPoint = function(e) {
      return this.worldTransform.applyInverse(e, t._TEMP_POINT), this._geometry.containsPoint(t._TEMP_POINT);
    }, t.prototype.calculateTints = function() {
      if (this.batchTint !== this.tint) {
        this.batchTint = this.tint;
        for (var e = Lh(this.tint, bI), i = 0; i < this.batches.length; i++) {
          var n = this.batches[i], s = n._batchRGB, o = e[0] * s[0] * 255, a = e[1] * s[1] * 255, l = e[2] * s[2] * 255, u = (o << 16) + (a << 8) + (l | 0);
          n._tintRGB = (u >> 16) + (u & 65280) + ((u & 255) << 16);
        }
      }
    }, t.prototype.calculateVertices = function() {
      var e = this.transform._worldID;
      if (this._transformID !== e) {
        this._transformID = e;
        for (var i = this.transform.worldTransform, n = i.a, s = i.b, o = i.c, a = i.d, l = i.tx, u = i.ty, c = this._geometry.points, d = this.vertexData, f = 0, v = 0; v < c.length; v += 2) {
          var m = c[v], p = c[v + 1];
          d[f++] = n * m + o * p + l, d[f++] = a * p + s * m + u;
        }
      }
    }, t.prototype.closePath = function() {
      var e = this.currentPath;
      return e && (e.closeStroke = !0, this.finishPoly()), this;
    }, t.prototype.setMatrix = function(e) {
      return this._matrix = e, this;
    }, t.prototype.beginHole = function() {
      return this.finishPoly(), this._holeMode = !0, this;
    }, t.prototype.endHole = function() {
      return this.finishPoly(), this._holeMode = !1, this;
    }, t.prototype.destroy = function(e) {
      this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, r.prototype.destroy.call(this, e);
    }, t.nextRoundedRectBehavior = !1, t._TEMP_POINT = new te(), t;
  }(Qt)
);
/*!
 * @pixi/sprite - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/sprite is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ly = function(r, t) {
  return Ly = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Ly(r, t);
};
function xI(r, t) {
  Ly(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Zh = new te(), wI = new Uint16Array([0, 1, 2, 0, 2, 3]), ge = (
  /** @class */
  function(r) {
    xI(t, r);
    function t(e) {
      var i = r.call(this) || this;
      return i._anchor = new ya(i._onAnchorUpdate, i, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), i._texture = null, i._width = 0, i._height = 0, i._tint = null, i._tintRGB = null, i.tint = 16777215, i.blendMode = ot.NORMAL, i._cachedTint = 16777215, i.uvs = null, i.texture = e || ut.EMPTY, i.vertexData = new Float32Array(8), i.vertexTrimmedData = null, i._transformID = -1, i._textureID = -1, i._transformTrimmedID = -1, i._textureTrimmedID = -1, i.indices = wI, i.pluginName = "batch", i.isSprite = !0, i._roundPixels = J.ROUND_PIXELS, i;
    }
    return t.prototype._onTextureUpdate = function() {
      this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = va(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = va(this.scale.y) * this._height / this._texture.orig.height);
    }, t.prototype._onAnchorUpdate = function() {
      this._transformID = -1, this._transformTrimmedID = -1;
    }, t.prototype.calculateVertices = function() {
      var e = this._texture;
      if (!(this._transformID === this.transform._worldID && this._textureID === e._updateID)) {
        this._textureID !== e._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = e._updateID;
        var i = this.transform.worldTransform, n = i.a, s = i.b, o = i.c, a = i.d, l = i.tx, u = i.ty, c = this.vertexData, d = e.trim, f = e.orig, v = this._anchor, m = 0, p = 0, y = 0, b = 0;
        if (d ? (p = d.x - v._x * f.width, m = p + d.width, b = d.y - v._y * f.height, y = b + d.height) : (p = -v._x * f.width, m = p + f.width, b = -v._y * f.height, y = b + f.height), c[0] = n * p + o * b + l, c[1] = a * b + s * p + u, c[2] = n * m + o * b + l, c[3] = a * b + s * m + u, c[4] = n * m + o * y + l, c[5] = a * y + s * m + u, c[6] = n * p + o * y + l, c[7] = a * y + s * p + u, this._roundPixels)
          for (var w = J.RESOLUTION, E = 0; E < c.length; ++E)
            c[E] = Math.round((c[E] * w | 0) / w);
      }
    }, t.prototype.calculateTrimmedVertices = function() {
      if (!this.vertexTrimmedData)
        this.vertexTrimmedData = new Float32Array(8);
      else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
        return;
      this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
      var e = this._texture, i = this.vertexTrimmedData, n = e.orig, s = this._anchor, o = this.transform.worldTransform, a = o.a, l = o.b, u = o.c, c = o.d, d = o.tx, f = o.ty, v = -s._x * n.width, m = v + n.width, p = -s._y * n.height, y = p + n.height;
      i[0] = a * v + u * p + d, i[1] = c * p + l * v + f, i[2] = a * m + u * p + d, i[3] = c * p + l * m + f, i[4] = a * m + u * y + d, i[5] = c * y + l * m + f, i[6] = a * v + u * y + d, i[7] = c * y + l * v + f;
    }, t.prototype._render = function(e) {
      this.calculateVertices(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this);
    }, t.prototype._calculateBounds = function() {
      var e = this._texture.trim, i = this._texture.orig;
      !e || e.width === i.width && e.height === i.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
    }, t.prototype.getLocalBounds = function(e) {
      return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Jf()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new pt()), e = this._localBoundsRect), this._localBounds.getRectangle(e)) : r.prototype.getLocalBounds.call(this, e);
    }, t.prototype.containsPoint = function(e) {
      this.worldTransform.applyInverse(e, Zh);
      var i = this._texture.orig.width, n = this._texture.orig.height, s = -i * this.anchor.x, o = 0;
      return Zh.x >= s && Zh.x < s + i && (o = -n * this.anchor.y, Zh.y >= o && Zh.y < o + n);
    }, t.prototype.destroy = function(e) {
      r.prototype.destroy.call(this, e), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null;
      var i = typeof e == "boolean" ? e : e && e.texture;
      if (i) {
        var n = typeof e == "boolean" ? e : e && e.baseTexture;
        this._texture.destroy(!!n);
      }
      this._texture = null;
    }, t.from = function(e, i) {
      var n = e instanceof ut ? e : ut.from(e, i);
      return new t(n);
    }, Object.defineProperty(t.prototype, "roundPixels", {
      get: function() {
        return this._roundPixels;
      },
      /**
       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
       *
       * Advantages can include sharper image quality (like text) and faster rendering on canvas.
       * The main disadvantage is movement of objects may appear less smooth.
       *
       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.
       * @default false
       */
      set: function(e) {
        this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "width", {
      /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
      },
      set: function(e) {
        var i = va(this.scale.x) || 1;
        this.scale.x = i * e / this._texture.orig.width, this._width = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
      },
      set: function(e) {
        var i = va(this.scale.y) || 1;
        this.scale.y = i * e / this._texture.orig.height, this._height = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "anchor", {
      /**
       * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}
       * and passed to the constructor.
       *
       * The default is `(0,0)`, this means the sprite's origin is the top left.
       *
       * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
       *
       * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
       *
       * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
       * @example
       * const sprite = new PIXI.Sprite(texture);
       * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
       */
      get: function() {
        return this._anchor;
      },
      set: function(e) {
        this._anchor.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      /**
       * The tint applied to the sprite. This is a hex value.
       *
       * A value of 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get: function() {
        return this._tint;
      },
      set: function(e) {
        this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "texture", {
      /** The texture that the sprite is using. */
      get: function() {
        return this._texture;
      },
      set: function(e) {
        this._texture !== e && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = e || ut.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, e && (e.baseTexture.valid ? this._onTextureUpdate() : e.once("update", this._onTextureUpdate, this)));
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qt)
);
/*!
 * @pixi/text - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/text is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Dy = function(r, t) {
  return Dy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Dy(r, t);
};
function EI(r, t) {
  Dy(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Cl;
(function(r) {
  r[r.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", r[r.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL";
})(Cl || (Cl = {}));
var cy = {
  align: "left",
  breakWords: !1,
  dropShadow: !1,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: Cl.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: !1,
  whiteSpace: "pre",
  wordWrap: !1,
  wordWrapWidth: 100,
  leading: 0
}, TI = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
], Zo = (
  /** @class */
  function() {
    function r(t) {
      this.styleID = 0, this.reset(), dy(this, t, t);
    }
    return r.prototype.clone = function() {
      var t = {};
      return dy(t, this, cy), new r(t);
    }, r.prototype.reset = function() {
      dy(this, cy, cy);
    }, Object.defineProperty(r.prototype, "align", {
      /**
       * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
       *
       * @member {string}
       */
      get: function() {
        return this._align;
      },
      set: function(t) {
        this._align !== t && (this._align = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "breakWords", {
      /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
      get: function() {
        return this._breakWords;
      },
      set: function(t) {
        this._breakWords !== t && (this._breakWords = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadow", {
      /** Set a drop shadow for the text. */
      get: function() {
        return this._dropShadow;
      },
      set: function(t) {
        this._dropShadow !== t && (this._dropShadow = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadowAlpha", {
      /** Set alpha for the drop shadow. */
      get: function() {
        return this._dropShadowAlpha;
      },
      set: function(t) {
        this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadowAngle", {
      /** Set a angle of the drop shadow. */
      get: function() {
        return this._dropShadowAngle;
      },
      set: function(t) {
        this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadowBlur", {
      /** Set a shadow blur radius. */
      get: function() {
        return this._dropShadowBlur;
      },
      set: function(t) {
        this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadowColor", {
      /** A fill style to be used on the dropshadow e.g 'red', '#00FF00'. */
      get: function() {
        return this._dropShadowColor;
      },
      set: function(t) {
        var e = fy(t);
        this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadowDistance", {
      /** Set a distance of the drop shadow. */
      get: function() {
        return this._dropShadowDistance;
      },
      set: function(t) {
        this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fill", {
      /**
       * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
       *
       * Can be an array to create a gradient eg ['#000000','#FFFFFF']
       * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
       *
       * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
       */
      get: function() {
        return this._fill;
      },
      set: function(t) {
        var e = fy(t);
        this._fill !== e && (this._fill = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fillGradientType", {
      /**
       * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
       *
       * @see PIXI.TEXT_GRADIENT
       */
      get: function() {
        return this._fillGradientType;
      },
      set: function(t) {
        this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fillGradientStops", {
      /**
       * If fill is an array of colours to create a gradient, this array can set the stop points
       * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
       */
      get: function() {
        return this._fillGradientStops;
      },
      set: function(t) {
        SI(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fontFamily", {
      /** The font family. */
      get: function() {
        return this._fontFamily;
      },
      set: function(t) {
        this.fontFamily !== t && (this._fontFamily = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fontSize", {
      /**
       * The font size
       * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
       */
      get: function() {
        return this._fontSize;
      },
      set: function(t) {
        this._fontSize !== t && (this._fontSize = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fontStyle", {
      /**
       * The font style
       * ('normal', 'italic' or 'oblique')
       *
       * @member {string}
       */
      get: function() {
        return this._fontStyle;
      },
      set: function(t) {
        this._fontStyle !== t && (this._fontStyle = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fontVariant", {
      /**
       * The font variant
       * ('normal' or 'small-caps')
       *
       * @member {string}
       */
      get: function() {
        return this._fontVariant;
      },
      set: function(t) {
        this._fontVariant !== t && (this._fontVariant = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fontWeight", {
      /**
       * The font weight
       * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
       *
       * @member {string}
       */
      get: function() {
        return this._fontWeight;
      },
      set: function(t) {
        this._fontWeight !== t && (this._fontWeight = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "letterSpacing", {
      /** The amount of spacing between letters, default is 0. */
      get: function() {
        return this._letterSpacing;
      },
      set: function(t) {
        this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "lineHeight", {
      /** The line height, a number that represents the vertical space that a letter uses. */
      get: function() {
        return this._lineHeight;
      },
      set: function(t) {
        this._lineHeight !== t && (this._lineHeight = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "leading", {
      /** The space between lines. */
      get: function() {
        return this._leading;
      },
      set: function(t) {
        this._leading !== t && (this._leading = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "lineJoin", {
      /**
       * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
       * Default is 'miter' (creates a sharp corner).
       *
       * @member {string}
       */
      get: function() {
        return this._lineJoin;
      },
      set: function(t) {
        this._lineJoin !== t && (this._lineJoin = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "miterLimit", {
      /**
       * The miter limit to use when using the 'miter' lineJoin mode.
       *
       * This can reduce or increase the spikiness of rendered text.
       */
      get: function() {
        return this._miterLimit;
      },
      set: function(t) {
        this._miterLimit !== t && (this._miterLimit = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "padding", {
      /**
       * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
       * by adding padding to all sides of the text.
       */
      get: function() {
        return this._padding;
      },
      set: function(t) {
        this._padding !== t && (this._padding = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "stroke", {
      /**
       * A canvas fillstyle that will be used on the text stroke
       * e.g 'blue', '#FCFF00'
       */
      get: function() {
        return this._stroke;
      },
      set: function(t) {
        var e = fy(t);
        this._stroke !== e && (this._stroke = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "strokeThickness", {
      /**
       * A number that represents the thickness of the stroke.
       *
       * @default 0
       */
      get: function() {
        return this._strokeThickness;
      },
      set: function(t) {
        this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "textBaseline", {
      /**
       * The baseline of the text that is rendered.
       *
       * @member {string}
       */
      get: function() {
        return this._textBaseline;
      },
      set: function(t) {
        this._textBaseline !== t && (this._textBaseline = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "trim", {
      /** Trim transparent borders. */
      get: function() {
        return this._trim;
      },
      set: function(t) {
        this._trim !== t && (this._trim = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "whiteSpace", {
      /**
       * How newlines and spaces should be handled.
       * Default is 'pre' (preserve, preserve).
       *
       *  value       | New lines     |   Spaces
       *  ---         | ---           |   ---
       * 'normal'     | Collapse      |   Collapse
       * 'pre'        | Preserve      |   Preserve
       * 'pre-line'   | Preserve      |   Collapse
       *
       * @member {string}
       */
      get: function() {
        return this._whiteSpace;
      },
      set: function(t) {
        this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "wordWrap", {
      /** Indicates if word wrap should be used. */
      get: function() {
        return this._wordWrap;
      },
      set: function(t) {
        this._wordWrap !== t && (this._wordWrap = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "wordWrapWidth", {
      /** The width at which text will wrap, it needs wordWrap to be set to true. */
      get: function() {
        return this._wordWrapWidth;
      },
      set: function(t) {
        this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.toFontString = function() {
      var t = typeof this.fontSize == "number" ? this.fontSize + "px" : this.fontSize, e = this.fontFamily;
      Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
      for (var i = e.length - 1; i >= 0; i--) {
        var n = e[i].trim();
        !/([\"\'])[^\'\"]+\1/.test(n) && TI.indexOf(n) < 0 && (n = '"' + n + '"'), e[i] = n;
      }
      return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t + " " + e.join(",");
    }, r;
  }()
);
function zg(r) {
  return typeof r == "number" ? B0(r) : (typeof r == "string" && r.indexOf("0x") === 0 && (r = r.replace("0x", "#")), r);
}
function fy(r) {
  if (Array.isArray(r)) {
    for (var t = 0; t < r.length; ++t)
      r[t] = zg(r[t]);
    return r;
  } else
    return zg(r);
}
function SI(r, t) {
  if (!Array.isArray(r) || !Array.isArray(t) || r.length !== t.length)
    return !1;
  for (var e = 0; e < r.length; ++e)
    if (r[e] !== t[e])
      return !1;
  return !0;
}
function dy(r, t, e) {
  for (var i in e)
    Array.isArray(t[i]) ? r[i] = t[i].slice() : r[i] = t[i];
}
var rf = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: !0
}, tn = (
  /** @class */
  function() {
    function r(t, e, i, n, s, o, a, l, u) {
      this.text = t, this.style = e, this.width = i, this.height = n, this.lines = s, this.lineWidths = o, this.lineHeight = a, this.maxLineWidth = l, this.fontProperties = u;
    }
    return r.measureText = function(t, e, i, n) {
      n === void 0 && (n = r._canvas), i = i ?? e.wordWrap;
      var s = e.toFontString(), o = r.measureFont(s);
      o.fontSize === 0 && (o.fontSize = e.fontSize, o.ascent = e.fontSize);
      var a = n.getContext("2d", rf);
      a.font = s;
      for (var l = i ? r.wordWrap(t, e, n) : t, u = l.split(/(?:\r\n|\r|\n)/), c = new Array(u.length), d = 0, f = 0; f < u.length; f++) {
        var v = a.measureText(u[f]).width + (u[f].length - 1) * e.letterSpacing;
        c[f] = v, d = Math.max(d, v);
      }
      var m = d + e.strokeThickness;
      e.dropShadow && (m += e.dropShadowDistance);
      var p = e.lineHeight || o.fontSize + e.strokeThickness, y = Math.max(p, o.fontSize + e.strokeThickness) + (u.length - 1) * (p + e.leading);
      return e.dropShadow && (y += e.dropShadowDistance), new r(t, e, m, y, u, c, p + e.leading, d, o);
    }, r.wordWrap = function(t, e, i) {
      i === void 0 && (i = r._canvas);
      for (var n = i.getContext("2d", rf), s = 0, o = "", a = "", l = /* @__PURE__ */ Object.create(null), u = e.letterSpacing, c = e.whiteSpace, d = r.collapseSpaces(c), f = r.collapseNewlines(c), v = !d, m = e.wordWrapWidth + u, p = r.tokenize(t), y = 0; y < p.length; y++) {
        var b = p[y];
        if (r.isNewline(b)) {
          if (!f) {
            a += r.addLine(o), v = !d, o = "", s = 0;
            continue;
          }
          b = " ";
        }
        if (d) {
          var w = r.isBreakingSpace(b), E = r.isBreakingSpace(o[o.length - 1]);
          if (w && E)
            continue;
        }
        var O = r.getFromCache(b, u, l, n);
        if (O > m)
          if (o !== "" && (a += r.addLine(o), o = "", s = 0), r.canBreakWords(b, e.breakWords))
            for (var I = r.wordWrapSplit(b), S = 0; S < I.length; S++) {
              for (var C = I[S], P = 1; I[S + P]; ) {
                var R = I[S + P], N = C[C.length - 1];
                if (!r.canBreakChars(N, R, b, S, e.breakWords))
                  C += R;
                else
                  break;
                P++;
              }
              S += C.length - 1;
              var F = r.getFromCache(C, u, l, n);
              F + s > m && (a += r.addLine(o), v = !1, o = "", s = 0), o += C, s += F;
            }
          else {
            o.length > 0 && (a += r.addLine(o), o = "", s = 0);
            var $ = y === p.length - 1;
            a += r.addLine(b, !$), v = !1, o = "", s = 0;
          }
        else
          O + s > m && (v = !1, a += r.addLine(o), o = "", s = 0), (o.length > 0 || !r.isBreakingSpace(b) || v) && (o += b, s += O);
      }
      return a += r.addLine(o, !1), a;
    }, r.addLine = function(t, e) {
      return e === void 0 && (e = !0), t = r.trimRight(t), t = e ? t + `
` : t, t;
    }, r.getFromCache = function(t, e, i, n) {
      var s = i[t];
      if (typeof s != "number") {
        var o = t.length * e;
        s = n.measureText(t).width + o, i[t] = s;
      }
      return s;
    }, r.collapseSpaces = function(t) {
      return t === "normal" || t === "pre-line";
    }, r.collapseNewlines = function(t) {
      return t === "normal";
    }, r.trimRight = function(t) {
      if (typeof t != "string")
        return "";
      for (var e = t.length - 1; e >= 0; e--) {
        var i = t[e];
        if (!r.isBreakingSpace(i))
          break;
        t = t.slice(0, -1);
      }
      return t;
    }, r.isNewline = function(t) {
      return typeof t != "string" ? !1 : r._newlines.indexOf(t.charCodeAt(0)) >= 0;
    }, r.isBreakingSpace = function(t, e) {
      return typeof t != "string" ? !1 : r._breakingSpaces.indexOf(t.charCodeAt(0)) >= 0;
    }, r.tokenize = function(t) {
      var e = [], i = "";
      if (typeof t != "string")
        return e;
      for (var n = 0; n < t.length; n++) {
        var s = t[n], o = t[n + 1];
        if (r.isBreakingSpace(s, o) || r.isNewline(s)) {
          i !== "" && (e.push(i), i = ""), e.push(s);
          continue;
        }
        i += s;
      }
      return i !== "" && e.push(i), e;
    }, r.canBreakWords = function(t, e) {
      return e;
    }, r.canBreakChars = function(t, e, i, n, s) {
      return !0;
    }, r.wordWrapSplit = function(t) {
      return t.split("");
    }, r.measureFont = function(t) {
      if (r._fonts[t])
        return r._fonts[t];
      var e = {
        ascent: 0,
        descent: 0,
        fontSize: 0
      }, i = r._canvas, n = r._context;
      n.font = t;
      var s = r.METRICS_STRING + r.BASELINE_SYMBOL, o = Math.ceil(n.measureText(s).width), a = Math.ceil(n.measureText(r.BASELINE_SYMBOL).width), l = Math.ceil(r.HEIGHT_MULTIPLIER * a);
      a = a * r.BASELINE_MULTIPLIER | 0, i.width = o, i.height = l, n.fillStyle = "#f00", n.fillRect(0, 0, o, l), n.font = t, n.textBaseline = "alphabetic", n.fillStyle = "#000", n.fillText(s, 0, a);
      var u = n.getImageData(0, 0, o, l).data, c = u.length, d = o * 4, f = 0, v = 0, m = !1;
      for (f = 0; f < a; ++f) {
        for (var p = 0; p < d; p += 4)
          if (u[v + p] !== 255) {
            m = !0;
            break;
          }
        if (!m)
          v += d;
        else
          break;
      }
      for (e.ascent = a - f, v = c - d, m = !1, f = l; f > a; --f) {
        for (var p = 0; p < d; p += 4)
          if (u[v + p] !== 255) {
            m = !0;
            break;
          }
        if (!m)
          v -= d;
        else
          break;
      }
      return e.descent = f - a, e.fontSize = e.ascent + e.descent, r._fonts[t] = e, e;
    }, r.clearMetrics = function(t) {
      t === void 0 && (t = ""), t ? delete r._fonts[t] : r._fonts = {};
    }, Object.defineProperty(r, "_canvas", {
      /**
       * Cached canvas element for measuring text
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      get: function() {
        if (!r.__canvas) {
          var t = void 0;
          try {
            var e = new OffscreenCanvas(0, 0), i = e.getContext("2d", rf);
            if (i && i.measureText)
              return r.__canvas = e, e;
            t = J.ADAPTER.createCanvas();
          } catch {
            t = J.ADAPTER.createCanvas();
          }
          t.width = t.height = 10, r.__canvas = t;
        }
        return r.__canvas;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "_context", {
      /**
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      get: function() {
        return r.__context || (r.__context = r._canvas.getContext("2d", rf)), r.__context;
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
);
tn._fonts = {};
tn.METRICS_STRING = "|ÉqÅ";
tn.BASELINE_SYMBOL = "M";
tn.BASELINE_MULTIPLIER = 1.4;
tn.HEIGHT_MULTIPLIER = 2;
tn._newlines = [
  10,
  13
];
tn._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
var PI = {
  texture: !0,
  children: !1,
  baseTexture: !0
}, I_ = (
  /** @class */
  function(r) {
    EI(t, r);
    function t(e, i, n) {
      var s = this, o = !1;
      n || (n = J.ADAPTER.createCanvas(), o = !0), n.width = 3, n.height = 3;
      var a = ut.from(n);
      return a.orig = new pt(), a.trim = new pt(), s = r.call(this, a) || this, s._ownCanvas = o, s.canvas = n, s.context = n.getContext("2d", {
        // required for trimming to work without warnings
        willReadFrequently: !0
      }), s._resolution = J.RESOLUTION, s._autoResolution = !0, s._text = null, s._style = null, s._styleListener = null, s._font = "", s.text = e, s.style = i, s.localStyleID = -1, s;
    }
    return t.prototype.updateText = function(e) {
      var i = this._style;
      if (this.localStyleID !== i.styleID && (this.dirty = !0, this.localStyleID = i.styleID), !(!this.dirty && e)) {
        this._font = this._style.toFontString();
        var n = this.context, s = tn.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), o = s.width, a = s.height, l = s.lines, u = s.lineHeight, c = s.lineWidths, d = s.maxLineWidth, f = s.fontProperties;
        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, o) + i.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, a) + i.padding * 2) * this._resolution), n.scale(this._resolution, this._resolution), n.clearRect(0, 0, this.canvas.width, this.canvas.height), n.font = this._font, n.lineWidth = i.strokeThickness, n.textBaseline = i.textBaseline, n.lineJoin = i.lineJoin, n.miterLimit = i.miterLimit;
        for (var v, m, p = i.dropShadow ? 2 : 1, y = 0; y < p; ++y) {
          var b = i.dropShadow && y === 0, w = b ? Math.ceil(Math.max(1, a) + i.padding * 2) : 0, E = w * this._resolution;
          if (b) {
            n.fillStyle = "black", n.strokeStyle = "black";
            var O = i.dropShadowColor, I = Lh(typeof O == "number" ? O : U0(O)), S = i.dropShadowBlur * this._resolution, C = i.dropShadowDistance * this._resolution;
            n.shadowColor = "rgba(" + I[0] * 255 + "," + I[1] * 255 + "," + I[2] * 255 + "," + i.dropShadowAlpha + ")", n.shadowBlur = S, n.shadowOffsetX = Math.cos(i.dropShadowAngle) * C, n.shadowOffsetY = Math.sin(i.dropShadowAngle) * C + E;
          } else
            n.fillStyle = this._generateFillStyle(i, l, s), n.strokeStyle = i.stroke, n.shadowColor = "black", n.shadowBlur = 0, n.shadowOffsetX = 0, n.shadowOffsetY = 0;
          var P = (u - f.fontSize) / 2;
          (!t.nextLineHeightBehavior || u - f.fontSize < 0) && (P = 0);
          for (var R = 0; R < l.length; R++)
            v = i.strokeThickness / 2, m = i.strokeThickness / 2 + R * u + f.ascent + P, i.align === "right" ? v += d - c[R] : i.align === "center" && (v += (d - c[R]) / 2), i.stroke && i.strokeThickness && this.drawLetterSpacing(l[R], v + i.padding, m + i.padding - w, !0), i.fill && this.drawLetterSpacing(l[R], v + i.padding, m + i.padding - w);
        }
        this.updateTexture();
      }
    }, t.prototype.drawLetterSpacing = function(e, i, n, s) {
      s === void 0 && (s = !1);
      var o = this._style, a = o.letterSpacing, l = t.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
      if (a === 0 || l) {
        l && (this.context.letterSpacing = a, this.context.textLetterSpacing = a), s ? this.context.strokeText(e, i, n) : this.context.fillText(e, i, n);
        return;
      }
      for (var u = i, c = Array.from ? Array.from(e) : e.split(""), d = this.context.measureText(e).width, f = 0, v = 0; v < c.length; ++v) {
        var m = c[v];
        s ? this.context.strokeText(m, u, n) : this.context.fillText(m, u, n);
        for (var p = "", y = v + 1; y < c.length; ++y)
          p += c[y];
        f = this.context.measureText(p).width, u += d - f + a, d = f;
      }
    }, t.prototype.updateTexture = function() {
      var e = this.canvas;
      if (this._style.trim) {
        var i = JS(e);
        i.data && (e.width = i.width, e.height = i.height, this.context.putImageData(i.data, 0, 0));
      }
      var n = this._texture, s = this._style, o = s.trim ? 0 : s.padding, a = n.baseTexture;
      n.trim.width = n._frame.width = e.width / this._resolution, n.trim.height = n._frame.height = e.height / this._resolution, n.trim.x = -o, n.trim.y = -o, n.orig.width = n._frame.width - o * 2, n.orig.height = n._frame.height - o * 2, this._onTextureUpdate(), a.setRealSize(e.width, e.height, this._resolution), n.updateUvs(), this.dirty = !1;
    }, t.prototype._render = function(e) {
      this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), r.prototype._render.call(this, e);
    }, t.prototype.updateTransform = function() {
      this.updateText(!0), r.prototype.updateTransform.call(this);
    }, t.prototype.getBounds = function(e, i) {
      return this.updateText(!0), this._textureID === -1 && (e = !1), r.prototype.getBounds.call(this, e, i);
    }, t.prototype.getLocalBounds = function(e) {
      return this.updateText(!0), r.prototype.getLocalBounds.call(this, e);
    }, t.prototype._calculateBounds = function() {
      this.calculateVertices(), this._bounds.addQuad(this.vertexData);
    }, t.prototype._generateFillStyle = function(e, i, n) {
      var s = e.fill;
      if (Array.isArray(s)) {
        if (s.length === 1)
          return s[0];
      } else
        return s;
      var o, a = e.dropShadow ? e.dropShadowDistance : 0, l = e.padding || 0, u = this.canvas.width / this._resolution - a - l * 2, c = this.canvas.height / this._resolution - a - l * 2, d = s.slice(), f = e.fillGradientStops.slice();
      if (!f.length)
        for (var v = d.length + 1, m = 1; m < v; ++m)
          f.push(m / v);
      if (d.unshift(s[0]), f.unshift(0), d.push(s[s.length - 1]), f.push(1), e.fillGradientType === Cl.LINEAR_VERTICAL) {
        o = this.context.createLinearGradient(u / 2, l, u / 2, c + l);
        for (var p = n.fontProperties.fontSize + e.strokeThickness, m = 0; m < i.length; m++) {
          var y = n.lineHeight * (m - 1) + p, b = n.lineHeight * m, w = b;
          m > 0 && y > b && (w = (b + y) / 2);
          var E = b + p, O = n.lineHeight * (m + 1), I = E;
          m + 1 < i.length && O < E && (I = (E + O) / 2);
          for (var S = (I - w) / c, C = 0; C < d.length; C++) {
            var P = 0;
            typeof f[C] == "number" ? P = f[C] : P = C / d.length;
            var R = Math.min(1, Math.max(0, w / c + P * S));
            R = Number(R.toFixed(5)), o.addColorStop(R, d[C]);
          }
        }
      } else {
        o = this.context.createLinearGradient(l, c / 2, u + l, c / 2);
        for (var N = d.length + 1, F = 1, m = 0; m < d.length; m++) {
          var $ = void 0;
          typeof f[m] == "number" ? $ = f[m] : $ = F / N, o.addColorStop($, d[m]), F++;
        }
      }
      return o;
    }, t.prototype.destroy = function(e) {
      typeof e == "boolean" && (e = { children: e }), e = Object.assign({}, PI, e), r.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;
    }, Object.defineProperty(t.prototype, "width", {
      /** The width of the Text, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;
      },
      set: function(e) {
        this.updateText(!0);
        var i = va(this.scale.x) || 1;
        this.scale.x = i * e / this._texture.orig.width, this._width = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the Text, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;
      },
      set: function(e) {
        this.updateText(!0);
        var i = va(this.scale.y) || 1;
        this.scale.y = i * e / this._texture.orig.height, this._height = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "style", {
      /**
       * Set the style of the text.
       *
       * Set up an event listener to listen for changes on the style object and mark the text as dirty.
       */
      get: function() {
        return this._style;
      },
      set: function(e) {
        e = e || {}, e instanceof Zo ? this._style = e : this._style = new Zo(e), this.localStyleID = -1, this.dirty = !0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "text", {
      /** Set the copy for the text object. To split a line you can use '\n'. */
      get: function() {
        return this._text;
      },
      set: function(e) {
        e = String(e ?? ""), this._text !== e && (this._text = e, this.dirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "resolution", {
      /**
       * The resolution / device pixel ratio of the canvas.
       *
       * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
       * @default 1
       */
      get: function() {
        return this._resolution;
      },
      set: function(e) {
        this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), t.nextLineHeightBehavior = !1, t.experimentalLetterSpacing = !1, t;
  }(ge)
);
/*!
 * @pixi/prepare - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/prepare is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
J.UPLOADS_PER_FRAME = 4;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Fy = function(r, t) {
  return Fy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Fy(r, t);
};
function OI(r, t) {
  Fy(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var II = (
  /** @class */
  function() {
    function r(t) {
      this.maxItemsPerFrame = t, this.itemsLeft = 0;
    }
    return r.prototype.beginFrame = function() {
      this.itemsLeft = this.maxItemsPerFrame;
    }, r.prototype.allowedToUpload = function() {
      return this.itemsLeft-- > 0;
    }, r;
  }()
);
function CI(r, t) {
  var e = !1;
  if (r && r._textures && r._textures.length) {
    for (var i = 0; i < r._textures.length; i++)
      if (r._textures[i] instanceof ut) {
        var n = r._textures[i].baseTexture;
        t.indexOf(n) === -1 && (t.push(n), e = !0);
      }
  }
  return e;
}
function MI(r, t) {
  if (r.baseTexture instanceof Mt) {
    var e = r.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function RI(r, t) {
  if (r._texture && r._texture instanceof ut) {
    var e = r._texture.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function kI(r, t) {
  return t instanceof I_ ? (t.updateText(!0), !0) : !1;
}
function NI(r, t) {
  if (t instanceof Zo) {
    var e = t.toFontString();
    return tn.measureFont(e), !0;
  }
  return !1;
}
function AI(r, t) {
  if (r instanceof I_) {
    t.indexOf(r.style) === -1 && t.push(r.style), t.indexOf(r) === -1 && t.push(r);
    var e = r._texture.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function LI(r, t) {
  return r instanceof Zo ? (t.indexOf(r) === -1 && t.push(r), !0) : !1;
}
var DI = (
  /** @class */
  function() {
    function r(t) {
      var e = this;
      this.limiter = new II(J.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function() {
        e.queue && e.prepareItems();
      }, this.registerFindHook(AI), this.registerFindHook(LI), this.registerFindHook(CI), this.registerFindHook(MI), this.registerFindHook(RI), this.registerUploadHook(kI), this.registerUploadHook(NI);
    }
    return r.prototype.upload = function(t, e) {
      var i = this;
      return typeof t == "function" && (e = t, t = null), e && ci("6.5.0", "BasePrepare.upload callback is deprecated, use the return Promise instead."), new Promise(function(n) {
        t && i.add(t);
        var s = function() {
          e == null || e(), n();
        };
        i.queue.length ? (i.completes.push(s), i.ticking || (i.ticking = !0, _e.system.addOnce(i.tick, i, Un.UTILITY))) : s();
      });
    }, r.prototype.tick = function() {
      setTimeout(this.delayedTick, 0);
    }, r.prototype.prepareItems = function() {
      for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
        var t = this.queue[0], e = !1;
        if (t && !t._destroyed) {
          for (var i = 0, n = this.uploadHooks.length; i < n; i++)
            if (this.uploadHooks[i](this.uploadHookHelper, t)) {
              this.queue.shift(), e = !0;
              break;
            }
        }
        e || this.queue.shift();
      }
      if (this.queue.length)
        _e.system.addOnce(this.tick, this, Un.UTILITY);
      else {
        this.ticking = !1;
        var s = this.completes.slice(0);
        this.completes.length = 0;
        for (var i = 0, n = s.length; i < n; i++)
          s[i]();
      }
    }, r.prototype.registerFindHook = function(t) {
      return t && this.addHooks.push(t), this;
    }, r.prototype.registerUploadHook = function(t) {
      return t && this.uploadHooks.push(t), this;
    }, r.prototype.add = function(t) {
      for (var e = 0, i = this.addHooks.length; e < i && !this.addHooks[e](t, this.queue); e++)
        ;
      if (t instanceof Qt)
        for (var e = t.children.length - 1; e >= 0; e--)
          this.add(t.children[e]);
      return this;
    }, r.prototype.destroy = function() {
      this.ticking && _e.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;
    }, r;
  }()
);
function Ib(r, t) {
  return t instanceof Mt ? (t._glTextures[r.CONTEXT_UID] || r.texture.bind(t), !0) : !1;
}
function FI(r, t) {
  if (!(t instanceof Ci))
    return !1;
  var e = t.geometry;
  t.finishPoly(), e.updateBatches();
  for (var i = e.batches, n = 0; n < i.length; n++) {
    var s = i[n].style.texture;
    s && Ib(r, s.baseTexture);
  }
  return e.batchable || r.geometry.bind(e, t._resolveDirectShader(r)), !0;
}
function BI(r, t) {
  return r instanceof Ci ? (t.push(r), !0) : !1;
}
var UI = (
  /** @class */
  function(r) {
    OI(t, r);
    function t(e) {
      var i = r.call(this, e) || this;
      return i.uploadHookHelper = i.renderer, i.registerFindHook(BI), i.registerUploadHook(Ib), i.registerUploadHook(FI), i;
    }
    return t.extension = {
      name: "prepare",
      type: qt.RendererPlugin
    }, t;
  }(DI)
);
/*!
 * @pixi/spritesheet - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/spritesheet is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var GI = (
  /** @class */
  function() {
    function r(t, e, i) {
      i === void 0 && (i = null), this.linkedSheets = [], this._texture = t instanceof ut ? t : null, this.baseTexture = t instanceof Mt ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;
      var n = this.baseTexture.resource;
      this.resolution = this._updateResolution(i || (n ? n.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
    }
    return r.prototype._updateResolution = function(t) {
      t === void 0 && (t = null);
      var e = this.data.meta.scale, i = Zf(t, null);
      return i === null && (i = e !== void 0 ? parseFloat(e) : 1), i !== 1 && this.baseTexture.setResolution(i), i;
    }, r.prototype.parse = function(t) {
      var e = this;
      return t && ci("6.5.0", "Spritesheet.parse callback is deprecated, use the return Promise instead."), new Promise(function(i) {
        e._callback = function(n) {
          t == null || t(n), i(n);
        }, e._batchIndex = 0, e._frameKeys.length <= r.BATCH_SIZE ? (e._processFrames(0), e._processAnimations(), e._parseComplete()) : e._nextBatch();
      });
    }, r.prototype._processFrames = function(t) {
      for (var e = t, i = r.BATCH_SIZE; e - t < i && e < this._frameKeys.length; ) {
        var n = this._frameKeys[e], s = this._frames[n], o = s.frame;
        if (o) {
          var a = null, l = null, u = s.trimmed !== !1 && s.sourceSize ? s.sourceSize : s.frame, c = new pt(0, 0, Math.floor(u.w) / this.resolution, Math.floor(u.h) / this.resolution);
          s.rotated ? a = new pt(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.h) / this.resolution, Math.floor(o.w) / this.resolution) : a = new pt(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution), s.trimmed !== !1 && s.spriteSourceSize && (l = new pt(Math.floor(s.spriteSourceSize.x) / this.resolution, Math.floor(s.spriteSourceSize.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution)), this.textures[n] = new ut(this.baseTexture, a, c, l, s.rotated ? 2 : 0, s.anchor), ut.addToCache(this.textures[n], n);
        }
        e++;
      }
    }, r.prototype._processAnimations = function() {
      var t = this.data.animations || {};
      for (var e in t) {
        this.animations[e] = [];
        for (var i = 0; i < t[e].length; i++) {
          var n = t[e][i];
          this.animations[e].push(this.textures[n]);
        }
      }
    }, r.prototype._parseComplete = function() {
      var t = this._callback;
      this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
    }, r.prototype._nextBatch = function() {
      var t = this;
      this._processFrames(this._batchIndex * r.BATCH_SIZE), this._batchIndex++, setTimeout(function() {
        t._batchIndex * r.BATCH_SIZE < t._frameKeys.length ? t._nextBatch() : (t._processAnimations(), t._parseComplete());
      }, 0);
    }, r.prototype.destroy = function(t) {
      var e;
      t === void 0 && (t = !1);
      for (var i in this.textures)
        this.textures[i].destroy();
      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) === null || e === void 0 || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];
    }, r.BATCH_SIZE = 1e3, r;
  }()
), jI = (
  /** @class */
  function() {
    function r() {
    }
    return r.use = function(t, e) {
      var i, n, s = this, o = t.name + "_image";
      if (!t.data || t.type !== bt.TYPE.JSON || !t.data.frames || s.resources[o]) {
        e();
        return;
      }
      var a = (n = (i = t.data) === null || i === void 0 ? void 0 : i.meta) === null || n === void 0 ? void 0 : n.related_multi_packs;
      if (Array.isArray(a))
        for (var l = function(m) {
          if (typeof m != "string")
            return "continue";
          var p = m.replace(".json", ""), y = pa.resolve(t.url.replace(s.baseUrl, ""), m);
          if (s.resources[p] || Object.values(s.resources).some(function(w) {
            return pa.format(pa.parse(w.url)) === y;
          }))
            return "continue";
          var b = {
            crossOrigin: t.crossOrigin,
            loadType: bt.LOAD_TYPE.XHR,
            xhrType: bt.XHR_RESPONSE_TYPE.JSON,
            parentResource: t,
            metadata: t.metadata
          };
          s.add(p, y, b);
        }, u = 0, c = a; u < c.length; u++) {
          var d = c[u];
          l(d);
        }
      var f = {
        crossOrigin: t.crossOrigin,
        metadata: t.metadata.imageMetadata,
        parentResource: t
      }, v = r.getResourcePath(t, s.baseUrl);
      s.add(o, v, f, function(p) {
        if (p.error) {
          e(p.error);
          return;
        }
        var y = new GI(p.texture, t.data, t.url);
        y.parse().then(function() {
          t.spritesheet = y, t.textures = y.textures, e();
        });
      });
    }, r.getResourcePath = function(t, e) {
      return t.isDataUrl ? t.data.meta.image : pa.resolve(t.url.replace(e, ""), t.data.meta.image);
    }, r.extension = qt.Loader, r;
  }()
);
/*!
 * @pixi/sprite-tiling - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var By = function(r, t) {
  return By = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, By(r, t);
};
function Cb(r, t) {
  By(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Kh = new te();
(function(r) {
  Cb(t, r);
  function t(e, i, n) {
    i === void 0 && (i = 100), n === void 0 && (n = 100);
    var s = r.call(this, e) || this;
    return s.tileTransform = new X0(), s._width = i, s._height = n, s.uvMatrix = s.texture.uvMatrix || new Nv(e), s.pluginName = "tilingSprite", s.uvRespectAnchor = !1, s;
  }
  return Object.defineProperty(t.prototype, "clampMargin", {
    /**
     * Changes frame clamping in corresponding textureTransform, shortcut
     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
     * @default 0.5
     * @member {number}
     */
    get: function() {
      return this.uvMatrix.clampMargin;
    },
    set: function(e) {
      this.uvMatrix.clampMargin = e, this.uvMatrix.update(!0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tileScale", {
    /** The scaling of the image that is being tiled. */
    get: function() {
      return this.tileTransform.scale;
    },
    set: function(e) {
      this.tileTransform.scale.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tilePosition", {
    /** The offset of the image that is being tiled. */
    get: function() {
      return this.tileTransform.position;
    },
    set: function(e) {
      this.tileTransform.position.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._onTextureUpdate = function() {
    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;
  }, t.prototype._render = function(e) {
    var i = this._texture;
    !i || !i.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this));
  }, t.prototype._calculateBounds = function() {
    var e = this._width * -this._anchor._x, i = this._height * -this._anchor._y, n = this._width * (1 - this._anchor._x), s = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, e, i, n, s);
  }, t.prototype.getLocalBounds = function(e) {
    return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new pt()), e = this._localBoundsRect), this._bounds.getRectangle(e)) : r.prototype.getLocalBounds.call(this, e);
  }, t.prototype.containsPoint = function(e) {
    this.worldTransform.applyInverse(e, Kh);
    var i = this._width, n = this._height, s = -i * this.anchor._x;
    if (Kh.x >= s && Kh.x < s + i) {
      var o = -n * this.anchor._y;
      if (Kh.y >= o && Kh.y < o + n)
        return !0;
    }
    return !1;
  }, t.prototype.destroy = function(e) {
    r.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null;
  }, t.from = function(e, i) {
    var n = e instanceof ut ? e : ut.from(e, i);
    return new t(n, i.width, i.height);
  }, Object.defineProperty(t.prototype, "width", {
    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this._width;
    },
    set: function(e) {
      this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this._height;
    },
    set: function(e) {
      this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(ge);
var HI = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`, Vg = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, $I = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`, zI = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, VI = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`, nf = new De(), XI = (
  /** @class */
  function(r) {
    Cb(t, r);
    function t(e) {
      var i = r.call(this, e) || this;
      return e.runners.contextChange.add(i), i.quad = new o_(), i.state = _s.for2d(), i;
    }
    return t.prototype.contextChange = function() {
      var e = this.renderer, i = { globals: e.globalUniforms };
      this.simpleShader = Dn.from(Vg, HI, i), this.shader = e.context.webGLVersion > 1 ? Dn.from(zI, VI, i) : Dn.from(Vg, $I, i);
    }, t.prototype.render = function(e) {
      var i = this.renderer, n = this.quad, s = n.vertices;
      s[0] = s[6] = e._width * -e.anchor.x, s[1] = s[3] = e._height * -e.anchor.y, s[2] = s[4] = e._width * (1 - e.anchor.x), s[5] = s[7] = e._height * (1 - e.anchor.y);
      var o = e.uvRespectAnchor ? e.anchor.x : 0, a = e.uvRespectAnchor ? e.anchor.y : 0;
      s = n.uvs, s[0] = s[6] = -o, s[1] = s[3] = -a, s[2] = s[4] = 1 - o, s[5] = s[7] = 1 - a, n.invalidate();
      var l = e._texture, u = l.baseTexture, c = u.alphaMode > 0, d = e.tileTransform.localTransform, f = e.uvMatrix, v = u.isPowerOfTwo && l.frame.width === u.width && l.frame.height === u.height;
      v && (u._glTextures[i.CONTEXT_UID] ? v = u.wrapMode !== Wr.CLAMP : u.wrapMode === Wr.CLAMP && (u.wrapMode = Wr.REPEAT));
      var m = v ? this.simpleShader : this.shader, p = l.width, y = l.height, b = e._width, w = e._height;
      nf.set(d.a * p / b, d.b * p / w, d.c * y / b, d.d * y / w, d.tx / b, d.ty / w), nf.invert(), v ? nf.prepend(f.mapCoord) : (m.uniforms.uMapCoord = f.mapCoord.toArray(!0), m.uniforms.uClampFrame = f.uClampFrame, m.uniforms.uClampOffset = f.uClampOffset), m.uniforms.uTransform = nf.toArray(!0), m.uniforms.uColor = H0(e.tint, e.worldAlpha, m.uniforms.uColor, c), m.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0), m.uniforms.uSampler = l, i.shader.bind(m), i.geometry.bind(n), this.state.blendMode = j0(e.blendMode, c), i.state.set(this.state), i.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    }, t.extension = {
      name: "tilingSprite",
      type: qt.RendererPlugin
    }, t;
  }(Rc)
);
/*!
 * @pixi/mesh - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/mesh is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Uy = function(r, t) {
  return Uy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Uy(r, t);
};
function C_(r, t) {
  Uy(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var WI = (
  /** @class */
  function() {
    function r(t, e) {
      this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;
    }
    return r.prototype.update = function(t) {
      if (!(!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)) {
        this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
        var e = this.uvBuffer.data;
        (!this.data || this.data.length !== e.length) && (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++;
      }
    }, r;
  }()
), py = new te(), Xg = new ff(), Ml = (
  /** @class */
  function(r) {
    C_(t, r);
    function t(e, i, n, s) {
      s === void 0 && (s = _r.TRIANGLES);
      var o = r.call(this) || this;
      return o.geometry = e, o.shader = i, o.state = n || _s.for2d(), o.drawMode = s, o.start = 0, o.size = 0, o.uvs = null, o.indices = null, o.vertexData = new Float32Array(1), o.vertexDirty = -1, o._transformID = -1, o._roundPixels = J.ROUND_PIXELS, o.batchUvs = null, o;
    }
    return Object.defineProperty(t.prototype, "geometry", {
      /**
       * Includes vertex positions, face indices, normals, colors, UVs, and
       * custom attributes within buffers, reducing the cost of passing all
       * this data to the GPU. Can be shared between multiple Mesh objects.
       */
      get: function() {
        return this._geometry;
      },
      set: function(e) {
        this._geometry !== e && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "uvBuffer", {
      /**
       * To change mesh uv's, change its uvBuffer data and increment its _updateID.
       * @readonly
       */
      get: function() {
        return this.geometry.buffers[1];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "verticesBuffer", {
      /**
       * To change mesh vertices, change its uvBuffer data and increment its _updateID.
       * Incrementing _updateID is optional because most of Mesh objects do it anyway.
       * @readonly
       */
      get: function() {
        return this.geometry.buffers[0];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "material", {
      get: function() {
        return this.shader;
      },
      /** Alias for {@link PIXI.Mesh#shader}. */
      set: function(e) {
        this.shader = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "blendMode", {
      get: function() {
        return this.state.blendMode;
      },
      /**
       * The blend mode to be applied to the Mesh. Apply a value of
       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * @default PIXI.BLEND_MODES.NORMAL;
       */
      set: function(e) {
        this.state.blendMode = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "roundPixels", {
      get: function() {
        return this._roundPixels;
      },
      /**
       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
       * Advantages can include sharper image quality (like text) and faster rendering on canvas.
       * The main disadvantage is movement of objects may appear less smooth.
       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
       * @default false
       */
      set: function(e) {
        this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      /**
       * The multiply tint applied to the Mesh. This is a hex value. A value of
       * `0xFFFFFF` will remove any tint effect.
       *
       * Null for non-MeshMaterial shaders
       * @default 0xFFFFFF
       */
      get: function() {
        return "tint" in this.shader ? this.shader.tint : null;
      },
      set: function(e) {
        this.shader.tint = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "texture", {
      /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
      get: function() {
        return "texture" in this.shader ? this.shader.texture : null;
      },
      set: function(e) {
        this.shader.texture = e;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype._render = function(e) {
      var i = this.geometry.buffers[0].data, n = this.shader;
      n.batchable && this.drawMode === _r.TRIANGLES && i.length < t.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e);
    }, t.prototype._renderDefault = function(e) {
      var i = this.shader;
      i.alpha = this.worldAlpha, i.update && i.update(), e.batch.flush(), i.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(i), e.state.set(this.state), e.geometry.bind(this.geometry, i), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    }, t.prototype._renderToBatch = function(e) {
      var i = this.geometry, n = this.shader;
      n.uvMatrix && (n.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = i.indexBuffer.data, this._tintRGB = n._tintRGB, this._texture = n.texture;
      var s = this.material.pluginName;
      e.batch.setObjectRenderer(e.plugins[s]), e.plugins[s].render(this);
    }, t.prototype.calculateVertices = function() {
      var e = this.geometry, i = e.buffers[0], n = i.data, s = i._updateID;
      if (!(s === this.vertexDirty && this._transformID === this.transform._worldID)) {
        this._transformID = this.transform._worldID, this.vertexData.length !== n.length && (this.vertexData = new Float32Array(n.length));
        for (var o = this.transform.worldTransform, a = o.a, l = o.b, u = o.c, c = o.d, d = o.tx, f = o.ty, v = this.vertexData, m = 0; m < v.length / 2; m++) {
          var p = n[m * 2], y = n[m * 2 + 1];
          v[m * 2] = a * p + u * y + d, v[m * 2 + 1] = l * p + c * y + f;
        }
        if (this._roundPixels)
          for (var b = J.RESOLUTION, m = 0; m < v.length; ++m)
            v[m] = Math.round((v[m] * b | 0) / b);
        this.vertexDirty = s;
      }
    }, t.prototype.calculateUvs = function() {
      var e = this.geometry.buffers[1], i = this.shader;
      i.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new WI(e, i.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);
    }, t.prototype._calculateBounds = function() {
      this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    }, t.prototype.containsPoint = function(e) {
      if (!this.getBounds().contains(e.x, e.y))
        return !1;
      this.worldTransform.applyInverse(e, py);
      for (var i = this.geometry.getBuffer("aVertexPosition").data, n = Xg.points, s = this.geometry.getIndex().data, o = s.length, a = this.drawMode === 4 ? 3 : 1, l = 0; l + 2 < o; l += a) {
        var u = s[l] * 2, c = s[l + 1] * 2, d = s[l + 2] * 2;
        if (n[0] = i[u], n[1] = i[u + 1], n[2] = i[c], n[3] = i[c + 1], n[4] = i[d], n[5] = i[d + 1], Xg.contains(py.x, py.y))
          return !0;
      }
      return !1;
    }, t.prototype.destroy = function(e) {
      r.prototype.destroy.call(this, e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;
    }, t.BATCHABLE_SIZE = 100, t;
  }(Qt)
), YI = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`, qI = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`, Rl = (
  /** @class */
  function(r) {
    C_(t, r);
    function t(e, i) {
      var n = this, s = {
        uSampler: e,
        alpha: 1,
        uTextureMatrix: De.IDENTITY,
        uColor: new Float32Array([1, 1, 1, 1])
      };
      return i = Object.assign({
        tint: 16777215,
        alpha: 1,
        pluginName: "batch"
      }, i), i.uniforms && Object.assign(s, i.uniforms), n = r.call(this, i.program || Hh.from(qI, YI), s) || this, n._colorDirty = !1, n.uvMatrix = new Nv(e), n.batchable = i.program === void 0, n.pluginName = i.pluginName, n.tint = i.tint, n.alpha = i.alpha, n;
    }
    return Object.defineProperty(t.prototype, "texture", {
      /** Reference to the texture being rendered. */
      get: function() {
        return this.uniforms.uSampler;
      },
      set: function(e) {
        this.uniforms.uSampler !== e && (!this.uniforms.uSampler.baseTexture.alphaMode != !e.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = e, this.uvMatrix.texture = e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "alpha", {
      get: function() {
        return this._alpha;
      },
      /**
       * This gets automatically set by the object using this.
       * @default 1
       */
      set: function(e) {
        e !== this._alpha && (this._alpha = e, this._colorDirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      get: function() {
        return this._tint;
      },
      /**
       * Multiply tint for the material.
       * @default 0xFFFFFF
       */
      set: function(e) {
        e !== this._tint && (this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16), this._colorDirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.update = function() {
      if (this._colorDirty) {
        this._colorDirty = !1;
        var e = this.texture.baseTexture;
        H0(this._tint, this._alpha, this.uniforms.uColor, e.alphaMode);
      }
      this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
    }, t;
  }(Dn)
), Av = (
  /** @class */
  function(r) {
    C_(t, r);
    function t(e, i, n) {
      var s = r.call(this) || this, o = new Ce(e), a = new Ce(i, !0), l = new Ce(n, !0, !0);
      return s.addAttribute("aVertexPosition", o, 2, !1, ct.FLOAT).addAttribute("aTextureCoord", a, 2, !1, ct.FLOAT).addIndex(l), s._updateId = -1, s;
    }
    return Object.defineProperty(t.prototype, "vertexDirtyId", {
      /**
       * If the vertex position is updated.
       * @readonly
       * @private
       */
      get: function() {
        return this.buffers[0]._updateID;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(jh)
);
/*!
 * @pixi/text-bitmap - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/text-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Gy = function(r, t) {
  return Gy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Gy(r, t);
};
function ZI(r, t) {
  Gy(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var sd = (
  /** @class */
  function() {
    function r() {
      this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];
    }
    return r;
  }()
), KI = (
  /** @class */
  function() {
    function r() {
    }
    return r.test = function(t) {
      return typeof t == "string" && t.indexOf("info face=") === 0;
    }, r.parse = function(t) {
      var e = t.match(/^[a-z]+\s+.+$/gm), i = {
        info: [],
        common: [],
        page: [],
        char: [],
        chars: [],
        kerning: [],
        kernings: [],
        distanceField: []
      };
      for (var n in e) {
        var s = e[n].match(/^[a-z]+/gm)[0], o = e[n].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), a = {};
        for (var l in o) {
          var u = o[l].split("="), c = u[0], d = u[1].replace(/"/gm, ""), f = parseFloat(d), v = isNaN(f) ? d : f;
          a[c] = v;
        }
        i[s].push(a);
      }
      var m = new sd();
      return i.info.forEach(function(p) {
        return m.info.push({
          face: p.face,
          size: parseInt(p.size, 10)
        });
      }), i.common.forEach(function(p) {
        return m.common.push({
          lineHeight: parseInt(p.lineHeight, 10)
        });
      }), i.page.forEach(function(p) {
        return m.page.push({
          id: parseInt(p.id, 10),
          file: p.file
        });
      }), i.char.forEach(function(p) {
        return m.char.push({
          id: parseInt(p.id, 10),
          page: parseInt(p.page, 10),
          x: parseInt(p.x, 10),
          y: parseInt(p.y, 10),
          width: parseInt(p.width, 10),
          height: parseInt(p.height, 10),
          xoffset: parseInt(p.xoffset, 10),
          yoffset: parseInt(p.yoffset, 10),
          xadvance: parseInt(p.xadvance, 10)
        });
      }), i.kerning.forEach(function(p) {
        return m.kerning.push({
          first: parseInt(p.first, 10),
          second: parseInt(p.second, 10),
          amount: parseInt(p.amount, 10)
        });
      }), i.distanceField.forEach(function(p) {
        return m.distanceField.push({
          distanceRange: parseInt(p.distanceRange, 10),
          fieldType: p.fieldType
        });
      }), m;
    }, r;
  }()
), jy = (
  /** @class */
  function() {
    function r() {
    }
    return r.test = function(t) {
      return t instanceof XMLDocument && t.getElementsByTagName("page").length && t.getElementsByTagName("info")[0].getAttribute("face") !== null;
    }, r.parse = function(t) {
      for (var e = new sd(), i = t.getElementsByTagName("info"), n = t.getElementsByTagName("common"), s = t.getElementsByTagName("page"), o = t.getElementsByTagName("char"), a = t.getElementsByTagName("kerning"), l = t.getElementsByTagName("distanceField"), u = 0; u < i.length; u++)
        e.info.push({
          face: i[u].getAttribute("face"),
          size: parseInt(i[u].getAttribute("size"), 10)
        });
      for (var u = 0; u < n.length; u++)
        e.common.push({
          lineHeight: parseInt(n[u].getAttribute("lineHeight"), 10)
        });
      for (var u = 0; u < s.length; u++)
        e.page.push({
          id: parseInt(s[u].getAttribute("id"), 10) || 0,
          file: s[u].getAttribute("file")
        });
      for (var u = 0; u < o.length; u++) {
        var c = o[u];
        e.char.push({
          id: parseInt(c.getAttribute("id"), 10),
          page: parseInt(c.getAttribute("page"), 10) || 0,
          x: parseInt(c.getAttribute("x"), 10),
          y: parseInt(c.getAttribute("y"), 10),
          width: parseInt(c.getAttribute("width"), 10),
          height: parseInt(c.getAttribute("height"), 10),
          xoffset: parseInt(c.getAttribute("xoffset"), 10),
          yoffset: parseInt(c.getAttribute("yoffset"), 10),
          xadvance: parseInt(c.getAttribute("xadvance"), 10)
        });
      }
      for (var u = 0; u < a.length; u++)
        e.kerning.push({
          first: parseInt(a[u].getAttribute("first"), 10),
          second: parseInt(a[u].getAttribute("second"), 10),
          amount: parseInt(a[u].getAttribute("amount"), 10)
        });
      for (var u = 0; u < l.length; u++)
        e.distanceField.push({
          fieldType: l[u].getAttribute("fieldType"),
          distanceRange: parseInt(l[u].getAttribute("distanceRange"), 10)
        });
      return e;
    }, r;
  }()
), JI = (
  /** @class */
  function() {
    function r() {
    }
    return r.test = function(t) {
      if (typeof t == "string" && t.indexOf("<font>") > -1) {
        var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
        return jy.test(e);
      }
      return !1;
    }, r.parse = function(t) {
      var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
      return jy.parse(e);
    }, r;
  }()
), vy = [
  KI,
  jy,
  JI
];
function Mb(r) {
  for (var t = 0; t < vy.length; t++)
    if (vy[t].test(r))
      return vy[t];
  return null;
}
function QI(r, t, e, i, n, s) {
  var o = e.fill;
  if (Array.isArray(o)) {
    if (o.length === 1)
      return o[0];
  } else
    return o;
  var a, l = e.dropShadow ? e.dropShadowDistance : 0, u = e.padding || 0, c = r.width / i - l - u * 2, d = r.height / i - l - u * 2, f = o.slice(), v = e.fillGradientStops.slice();
  if (!v.length)
    for (var m = f.length + 1, p = 1; p < m; ++p)
      v.push(p / m);
  if (f.unshift(o[0]), v.unshift(0), f.push(o[o.length - 1]), v.push(1), e.fillGradientType === Cl.LINEAR_VERTICAL) {
    a = t.createLinearGradient(c / 2, u, c / 2, d + u);
    for (var y = 0, b = s.fontProperties.fontSize + e.strokeThickness, w = b / d, p = 0; p < n.length; p++)
      for (var E = s.lineHeight * p, O = 0; O < f.length; O++) {
        var I = 0;
        typeof v[O] == "number" ? I = v[O] : I = O / f.length;
        var S = E / d + I * w, C = Math.max(y, S);
        C = Math.min(C, 1), a.addColorStop(C, f[O]), y = C;
      }
  } else {
    a = t.createLinearGradient(u, d / 2, c + u, d / 2);
    for (var P = f.length + 1, R = 1, p = 0; p < f.length; p++) {
      var N = void 0;
      typeof v[p] == "number" ? N = v[p] : N = R / P, a.addColorStop(N, f[p]), R++;
    }
  }
  return a;
}
function tC(r, t, e, i, n, s, o) {
  var a = e.text, l = e.fontProperties;
  t.translate(i, n), t.scale(s, s);
  var u = o.strokeThickness / 2, c = -(o.strokeThickness / 2);
  if (t.font = o.toFontString(), t.lineWidth = o.strokeThickness, t.textBaseline = o.textBaseline, t.lineJoin = o.lineJoin, t.miterLimit = o.miterLimit, t.fillStyle = QI(r, t, o, s, [a], e), t.strokeStyle = o.stroke, o.dropShadow) {
    var d = o.dropShadowColor, f = Lh(typeof d == "number" ? d : U0(d)), v = o.dropShadowBlur * s, m = o.dropShadowDistance * s;
    t.shadowColor = "rgba(" + f[0] * 255 + "," + f[1] * 255 + "," + f[2] * 255 + "," + o.dropShadowAlpha + ")", t.shadowBlur = v, t.shadowOffsetX = Math.cos(o.dropShadowAngle) * m, t.shadowOffsetY = Math.sin(o.dropShadowAngle) * m;
  } else
    t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
  o.stroke && o.strokeThickness && t.strokeText(a, u, c + e.lineHeight - l.descent), o.fill && t.fillText(a, u, c + e.lineHeight - l.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = "rgba(0, 0, 0, 0)";
}
function Rb(r) {
  return Array.from ? Array.from(r) : r.split("");
}
function eC(r) {
  typeof r == "string" && (r = [r]);
  for (var t = [], e = 0, i = r.length; e < i; e++) {
    var n = r[e];
    if (Array.isArray(n)) {
      if (n.length !== 2)
        throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + n.length + ".");
      var s = n[0].charCodeAt(0), o = n[1].charCodeAt(0);
      if (o < s)
        throw new Error("[BitmapFont]: Invalid character range.");
      for (var a = s, l = o; a <= l; a++)
        t.push(String.fromCharCode(a));
    } else
      t.push.apply(t, Rb(n));
  }
  if (t.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return t;
}
function pf(r) {
  return r.codePointAt ? r.codePointAt(0) : r.charCodeAt(0);
}
var $n = (
  /** @class */
  function() {
    function r(t, e, i) {
      var n, s, o = t.info[0], a = t.common[0], l = t.page[0], u = t.distanceField[0], c = Zf(l.file), d = {};
      this._ownsTextures = i, this.font = o.face, this.size = o.size, this.lineHeight = a.lineHeight / c, this.chars = {}, this.pageTextures = d;
      for (var f = 0; f < t.page.length; f++) {
        var v = t.page[f], m = v.id, p = v.file;
        d[m] = e instanceof Array ? e[f] : e[p], u != null && u.fieldType && u.fieldType !== "none" && (d[m].baseTexture.alphaMode = xr.NO_PREMULTIPLIED_ALPHA, d[m].baseTexture.mipmap = br.OFF);
      }
      for (var f = 0; f < t.char.length; f++) {
        var y = t.char[f], m = y.id, b = y.page, w = t.char[f], E = w.x, O = w.y, I = w.width, S = w.height, C = w.xoffset, P = w.yoffset, R = w.xadvance;
        E /= c, O /= c, I /= c, S /= c, C /= c, P /= c, R /= c;
        var N = new pt(E + d[b].frame.x / c, O + d[b].frame.y / c, I, S);
        this.chars[m] = {
          xOffset: C,
          yOffset: P,
          xAdvance: R,
          kerning: {},
          texture: new ut(d[b].baseTexture, N),
          page: b
        };
      }
      for (var f = 0; f < t.kerning.length; f++) {
        var F = t.kerning[f], $ = F.first, q = F.second, ht = F.amount;
        $ /= c, q /= c, ht /= c, this.chars[q] && (this.chars[q].kerning[$] = ht);
      }
      this.distanceFieldRange = u == null ? void 0 : u.distanceRange, this.distanceFieldType = (s = (n = u == null ? void 0 : u.fieldType) === null || n === void 0 ? void 0 : n.toLowerCase()) !== null && s !== void 0 ? s : "none";
    }
    return r.prototype.destroy = function() {
      for (var t in this.chars)
        this.chars[t].texture.destroy(), this.chars[t].texture = null;
      for (var t in this.pageTextures)
        this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;
      this.chars = null, this.pageTextures = null;
    }, r.install = function(t, e, i) {
      var n;
      if (t instanceof sd)
        n = t;
      else {
        var s = Mb(t);
        if (!s)
          throw new Error("Unrecognized data format for font.");
        n = s.parse(t);
      }
      e instanceof ut && (e = [e]);
      var o = new r(n, e, i);
      return r.available[o.font] = o, o;
    }, r.uninstall = function(t) {
      var e = r.available[t];
      if (!e)
        throw new Error("No font found named '" + t + "'");
      e.destroy(), delete r.available[t];
    }, r.from = function(t, e, i) {
      if (!t)
        throw new Error("[BitmapFont] Property `name` is required.");
      var n = Object.assign({}, r.defaultOptions, i), s = n.chars, o = n.padding, a = n.resolution, l = n.textureWidth, u = n.textureHeight, c = eC(s), d = e instanceof Zo ? e : new Zo(e), f = l, v = new sd();
      v.info[0] = {
        face: d.fontFamily,
        size: d.fontSize
      }, v.common[0] = {
        lineHeight: d.fontSize
      };
      for (var m = 0, p = 0, y, b, w, E = 0, O = [], I = 0; I < c.length; I++) {
        y || (y = J.ADAPTER.createCanvas(), y.width = l, y.height = u, b = y.getContext("2d"), w = new Mt(y, { resolution: a }), O.push(new ut(w)), v.page.push({
          id: O.length - 1,
          file: ""
        }));
        var S = c[I], C = tn.measureText(S, d, !1, y), P = C.width, R = Math.ceil(C.height), N = Math.ceil((d.fontStyle === "italic" ? 2 : 1) * P);
        if (p >= u - R * a) {
          if (p === 0)
            throw new Error("[BitmapFont] textureHeight " + u + "px is too small " + ("(fontFamily: '" + d.fontFamily + "', fontSize: " + d.fontSize + "px, char: '" + S + "')"));
          --I, y = null, b = null, w = null, p = 0, m = 0, E = 0;
          continue;
        }
        if (E = Math.max(R + C.fontProperties.descent, E), N * a + m >= f) {
          if (m === 0)
            throw new Error("[BitmapFont] textureWidth " + l + "px is too small " + ("(fontFamily: '" + d.fontFamily + "', fontSize: " + d.fontSize + "px, char: '" + S + "')"));
          --I, p += E * a, p = Math.ceil(p), m = 0, E = 0;
          continue;
        }
        tC(y, b, C, m, p, a, d);
        var F = pf(C.text);
        v.char.push({
          id: F,
          page: O.length - 1,
          x: m / a,
          y: p / a,
          width: N,
          height: R,
          xoffset: 0,
          yoffset: 0,
          xadvance: Math.ceil(P - (d.dropShadow ? d.dropShadowDistance : 0) - (d.stroke ? d.strokeThickness : 0))
        }), m += (N + 2 * o) * a, m = Math.ceil(m);
      }
      for (var I = 0, $ = c.length; I < $; I++)
        for (var q = c[I], ht = 0; ht < $; ht++) {
          var V = c[ht], H = b.measureText(q).width, Q = b.measureText(V).width, mt = b.measureText(q + V).width, et = mt - (H + Q);
          et && v.kerning.push({
            first: pf(q),
            second: pf(V),
            amount: et
          });
        }
      var Tt = new r(v, O, !0);
      return r.available[t] !== void 0 && r.uninstall(t), r.available[t] = Tt, Tt;
    }, r.ALPHA = [["a", "z"], ["A", "Z"], " "], r.NUMERIC = [["0", "9"]], r.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], r.ASCII = [[" ", "~"]], r.defaultOptions = {
      resolution: 1,
      textureWidth: 512,
      textureHeight: 512,
      padding: 4,
      chars: r.ALPHANUMERIC
    }, r.available = {}, r;
  }()
), iC = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r
\r
}\r
`, rC = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`, Wg = [], Yg = [], qg = [];
(function(r) {
  ZI(t, r);
  function t(e, i) {
    i === void 0 && (i = {});
    var n = r.call(this) || this;
    n._tint = 16777215;
    var s = Object.assign({}, t.styleDefaults, i), o = s.align, a = s.tint, l = s.maxWidth, u = s.letterSpacing, c = s.fontName, d = s.fontSize;
    if (!$n.available[c])
      throw new Error('Missing BitmapFont "' + c + '"');
    return n._activePagesMeshData = [], n._textWidth = 0, n._textHeight = 0, n._align = o, n._tint = a, n._font = void 0, n._fontName = c, n._fontSize = d, n.text = e, n._maxWidth = l, n._maxLineHeight = 0, n._letterSpacing = u, n._anchor = new ya(function() {
      n.dirty = !0;
    }, n, 0, 0), n._roundPixels = J.ROUND_PIXELS, n.dirty = !0, n._resolution = J.RESOLUTION, n._autoResolution = !0, n._textureCache = {}, n;
  }
  return t.prototype.updateText = function() {
    for (var e, i = $n.available[this._fontName], n = this.fontSize, s = n / i.size, o = new te(), a = [], l = [], u = [], c = this._text.replace(/(?:\r\n|\r)/g, `
`) || " ", d = Rb(c), f = this._maxWidth * i.size / n, v = i.distanceFieldType === "none" ? Wg : Yg, m = null, p = 0, y = 0, b = 0, w = -1, E = 0, O = 0, I = 0, S = 0, C = 0; C < d.length; C++) {
      var P = d[C], R = pf(P);
      if (/(?:\s)/.test(P) && (w = C, E = p, S++), P === "\r" || P === `
`) {
        l.push(p), u.push(-1), y = Math.max(y, p), ++b, ++O, o.x = 0, o.y += i.lineHeight, m = null, S = 0;
        continue;
      }
      var N = i.chars[R];
      if (N) {
        m && N.kerning[m] && (o.x += N.kerning[m]);
        var F = qg.pop() || {
          texture: ut.EMPTY,
          line: 0,
          charCode: 0,
          prevSpaces: 0,
          position: new te()
        };
        F.texture = N.texture, F.line = b, F.charCode = R, F.position.x = o.x + N.xOffset + this._letterSpacing / 2, F.position.y = o.y + N.yOffset, F.prevSpaces = S, a.push(F), p = F.position.x + Math.max(N.xAdvance - N.xOffset, N.texture.orig.width), o.x += N.xAdvance + this._letterSpacing, I = Math.max(I, N.yOffset + N.texture.height), m = R, w !== -1 && f > 0 && o.x > f && (++O, xa(a, 1 + w - O, 1 + C - w), C = w, w = -1, l.push(E), u.push(a.length > 0 ? a[a.length - 1].prevSpaces : 0), y = Math.max(y, E), b++, o.x = 0, o.y += i.lineHeight, m = null, S = 0);
      }
    }
    var $ = d[d.length - 1];
    $ !== "\r" && $ !== `
` && (/(?:\s)/.test($) && (p = E), l.push(p), y = Math.max(y, p), u.push(-1));
    for (var q = [], C = 0; C <= b; C++) {
      var ht = 0;
      this._align === "right" ? ht = y - l[C] : this._align === "center" ? ht = (y - l[C]) / 2 : this._align === "justify" && (ht = u[C] < 0 ? 0 : (y - l[C]) / u[C]), q.push(ht);
    }
    var V = a.length, H = {}, Q = [], mt = this._activePagesMeshData;
    v.push.apply(v, mt);
    for (var C = 0; C < V; C++) {
      var et = a[C].texture, Tt = et.baseTexture.uid;
      if (!H[Tt]) {
        var it = v.pop();
        if (!it) {
          var we = new Av(), Bt = void 0, Dt = void 0;
          i.distanceFieldType === "none" ? (Bt = new Rl(ut.EMPTY), Dt = ot.NORMAL) : (Bt = new Rl(ut.EMPTY, { program: Hh.from(rC, iC), uniforms: { uFWidth: 0 } }), Dt = ot.NORMAL_NPM);
          var Ut = new Ml(we, Bt);
          Ut.blendMode = Dt, it = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh: Ut,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        it.index = 0, it.indexCount = 0, it.vertexCount = 0, it.uvsCount = 0, it.total = 0;
        var k = this._textureCache;
        k[Tt] = k[Tt] || new ut(et.baseTexture), it.mesh.texture = k[Tt], it.mesh.tint = this._tint, Q.push(it), H[Tt] = it;
      }
      H[Tt].total++;
    }
    for (var C = 0; C < mt.length; C++)
      Q.indexOf(mt[C]) === -1 && this.removeChild(mt[C].mesh);
    for (var C = 0; C < Q.length; C++)
      Q[C].mesh.parent !== this && this.addChild(Q[C].mesh);
    this._activePagesMeshData = Q;
    for (var C in H) {
      var it = H[C], zt = it.total;
      if (!(((e = it.indices) === null || e === void 0 ? void 0 : e.length) > 6 * zt) || it.vertices.length < Ml.BATCHABLE_SIZE * 2)
        it.vertices = new Float32Array(4 * 2 * zt), it.uvs = new Float32Array(4 * 2 * zt), it.indices = new Uint16Array(6 * zt);
      else
        for (var lt = it.total, me = it.vertices, jt = lt * 4 * 2; jt < me.length; jt++)
          me[jt] = 0;
      it.mesh.size = 6 * zt;
    }
    for (var C = 0; C < V; C++) {
      var P = a[C], Z = P.position.x + q[P.line] * (this._align === "justify" ? P.prevSpaces : 1);
      this._roundPixels && (Z = Math.round(Z));
      var be = Z * s, ft = P.position.y * s, et = P.texture, B = H[et.baseTexture.uid], at = et.frame, Et = et._uvs, U = B.index++;
      B.indices[U * 6 + 0] = 0 + U * 4, B.indices[U * 6 + 1] = 1 + U * 4, B.indices[U * 6 + 2] = 2 + U * 4, B.indices[U * 6 + 3] = 0 + U * 4, B.indices[U * 6 + 4] = 2 + U * 4, B.indices[U * 6 + 5] = 3 + U * 4, B.vertices[U * 8 + 0] = be, B.vertices[U * 8 + 1] = ft, B.vertices[U * 8 + 2] = be + at.width * s, B.vertices[U * 8 + 3] = ft, B.vertices[U * 8 + 4] = be + at.width * s, B.vertices[U * 8 + 5] = ft + at.height * s, B.vertices[U * 8 + 6] = be, B.vertices[U * 8 + 7] = ft + at.height * s, B.uvs[U * 8 + 0] = Et.x0, B.uvs[U * 8 + 1] = Et.y0, B.uvs[U * 8 + 2] = Et.x1, B.uvs[U * 8 + 3] = Et.y1, B.uvs[U * 8 + 4] = Et.x2, B.uvs[U * 8 + 5] = Et.y2, B.uvs[U * 8 + 6] = Et.x3, B.uvs[U * 8 + 7] = Et.y3;
    }
    this._textWidth = y * s, this._textHeight = (o.y + i.lineHeight) * s;
    for (var C in H) {
      var it = H[C];
      if (this.anchor.x !== 0 || this.anchor.y !== 0)
        for (var Re = 0, pi = this._textWidth * this.anchor.x, ke = this._textHeight * this.anchor.y, ki = 0; ki < it.total; ki++)
          it.vertices[Re++] -= pi, it.vertices[Re++] -= ke, it.vertices[Re++] -= pi, it.vertices[Re++] -= ke, it.vertices[Re++] -= pi, it.vertices[Re++] -= ke, it.vertices[Re++] -= pi, it.vertices[Re++] -= ke;
      this._maxLineHeight = I * s;
      var Ni = it.mesh.geometry.getBuffer("aVertexPosition"), ri = it.mesh.geometry.getBuffer("aTextureCoord"), Sr = it.mesh.geometry.getIndex();
      Ni.data = it.vertices, ri.data = it.uvs, Sr.data = it.indices, Ni.update(), ri.update(), Sr.update();
    }
    for (var C = 0; C < a.length; C++)
      qg.push(a[C]);
    this._font = i, this.dirty = !1;
  }, t.prototype.updateTransform = function() {
    this.validate(), this.containerUpdateTransform();
  }, t.prototype._render = function(e) {
    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);
    var i = $n.available[this._fontName], n = i.distanceFieldRange, s = i.distanceFieldType, o = i.size;
    if (s !== "none")
      for (var a = this.worldTransform, l = a.a, u = a.b, c = a.c, d = a.d, f = Math.sqrt(l * l + u * u), v = Math.sqrt(c * c + d * d), m = (Math.abs(f) + Math.abs(v)) / 2, p = this.fontSize / o, y = 0, b = this._activePagesMeshData; y < b.length; y++) {
        var w = b[y];
        w.mesh.shader.uniforms.uFWidth = m * n * p * this._resolution;
      }
    r.prototype._render.call(this, e);
  }, t.prototype.getLocalBounds = function() {
    return this.validate(), r.prototype.getLocalBounds.call(this);
  }, t.prototype.validate = function() {
    var e = $n.available[this._fontName];
    if (!e)
      throw new Error('Missing BitmapFont "' + this._fontName + '"');
    this._font !== e && (this.dirty = !0), this.dirty && this.updateText();
  }, Object.defineProperty(t.prototype, "tint", {
    /**
     * The tint of the BitmapText object.
     * @default 0xffffff
     */
    get: function() {
      return this._tint;
    },
    set: function(e) {
      if (this._tint !== e) {
        this._tint = e;
        for (var i = 0; i < this._activePagesMeshData.length; i++)
          this._activePagesMeshData[i].mesh.tint = e;
      }
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "align", {
    /**
     * The alignment of the BitmapText object.
     * @member {string}
     * @default 'left'
     */
    get: function() {
      return this._align;
    },
    set: function(e) {
      this._align !== e && (this._align = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fontName", {
    /** The name of the BitmapFont. */
    get: function() {
      return this._fontName;
    },
    set: function(e) {
      if (!$n.available[e])
        throw new Error('Missing BitmapFont "' + e + '"');
      this._fontName !== e && (this._fontName = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fontSize", {
    /** The size of the font to display. */
    get: function() {
      var e;
      return (e = this._fontSize) !== null && e !== void 0 ? e : $n.available[this._fontName].size;
    },
    set: function(e) {
      this._fontSize !== e && (this._fontSize = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "anchor", {
    /**
     * The anchor sets the origin point of the text.
     *
     * The default is `(0,0)`, this means the text's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
     */
    get: function() {
      return this._anchor;
    },
    set: function(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "text", {
    /** The text of the BitmapText object. */
    get: function() {
      return this._text;
    },
    set: function(e) {
      e = String(e ?? ""), this._text !== e && (this._text = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "maxWidth", {
    /**
     * The max width of this bitmap text in pixels. If the text provided is longer than the
     * value provided, line breaks will be automatically inserted in the last whitespace.
     * Disable by setting the value to 0.
     */
    get: function() {
      return this._maxWidth;
    },
    set: function(e) {
      this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "maxLineHeight", {
    /**
     * The max line height. This is useful when trying to use the total height of the Text,
     * i.e. when trying to vertically align.
     * @readonly
     */
    get: function() {
      return this.validate(), this._maxLineHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textWidth", {
    /**
     * The width of the overall text, different from fontSize,
     * which is defined in the style object.
     * @readonly
     */
    get: function() {
      return this.validate(), this._textWidth;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "letterSpacing", {
    /** Additional space between characters. */
    get: function() {
      return this._letterSpacing;
    },
    set: function(e) {
      this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "roundPixels", {
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     * @default PIXI.settings.ROUND_PIXELS
     */
    get: function() {
      return this._roundPixels;
    },
    set: function(e) {
      e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textHeight", {
    /**
     * The height of the overall text, different from fontSize,
     * which is defined in the style object.
     * @readonly
     */
    get: function() {
      return this.validate(), this._textHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "resolution", {
    /**
     * The resolution / device pixel ratio of the canvas.
     *
     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
     * @default 1
     */
    get: function() {
      return this._resolution;
    },
    set: function(e) {
      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.destroy = function(e) {
    var i = this._textureCache, n = $n.available[this._fontName], s = n.distanceFieldType === "none" ? Wg : Yg;
    s.push.apply(s, this._activePagesMeshData);
    for (var o = 0, a = this._activePagesMeshData; o < a.length; o++) {
      var l = a[o];
      this.removeChild(l.mesh);
    }
    this._activePagesMeshData = [], s.filter(function(d) {
      return i[d.mesh.texture.baseTexture.uid];
    }).forEach(function(d) {
      d.mesh.texture = ut.EMPTY;
    });
    for (var u in i) {
      var c = i[u];
      c.destroy(), delete i[u];
    }
    this._font = null, this._textureCache = null, r.prototype.destroy.call(this, e);
  }, t.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
  }, t;
})(Qt);
var nC = (
  /** @class */
  function() {
    function r() {
    }
    return r.add = function() {
      bt.setExtensionXhrType("fnt", bt.XHR_RESPONSE_TYPE.TEXT);
    }, r.use = function(t, e) {
      var i = Mb(t.data);
      if (!i) {
        e();
        return;
      }
      for (var n = r.getBaseUrl(this, t), s = i.parse(t.data), o = {}, a = function(p) {
        o[p.metadata.pageFile] = p.texture, Object.keys(o).length === s.page.length && (t.bitmapFont = $n.install(s, o, !0), e());
      }, l = 0; l < s.page.length; ++l) {
        var u = s.page[l].file, c = n + u, d = !1;
        for (var f in this.resources) {
          var v = this.resources[f];
          if (v.url === c) {
            v.metadata.pageFile = u, v.texture ? a(v) : v.onAfterMiddleware.add(a), d = !0;
            break;
          }
        }
        if (!d) {
          var m = {
            crossOrigin: t.crossOrigin,
            loadType: bt.LOAD_TYPE.IMAGE,
            metadata: Object.assign({ pageFile: u }, t.metadata.imageMetadata),
            parentResource: t
          };
          this.add(c, m, a);
        }
      }
    }, r.getBaseUrl = function(t, e) {
      var i = e.isDataUrl ? "" : r.dirname(e.url);
      return e.isDataUrl && (i === "." && (i = ""), t.baseUrl && i && t.baseUrl.charAt(t.baseUrl.length - 1) === "/" && (i += "/")), i = i.replace(t.baseUrl, ""), i && i.charAt(i.length - 1) !== "/" && (i += "/"), i;
    }, r.dirname = function(t) {
      var e = t.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
      return e === t ? "." : e === "" ? "/" : e;
    }, r.extension = qt.Loader, r;
  }()
);
/*!
 * @pixi/filter-alpha - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-alpha is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Hy = function(r, t) {
  return Hy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Hy(r, t);
};
function sC(r, t) {
  Hy(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var oC = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
(function(r) {
  sC(t, r);
  function t(e) {
    e === void 0 && (e = 1);
    var i = r.call(this, yb, oC, { uAlpha: 1 }) || this;
    return i.alpha = e, i;
  }
  return Object.defineProperty(t.prototype, "alpha", {
    /**
     * Coefficient for alpha multiplication
     * @default 1
     */
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(e) {
      this.uniforms.uAlpha = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(wr);
/*!
 * @pixi/filter-blur - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var $y = function(r, t) {
  return $y = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, $y(r, t);
};
function kb(r, t) {
  $y(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var aC = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function hC(r, t) {
  var e = Math.ceil(r / 2), i = aC, n = "", s;
  t ? s = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : s = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  for (var o = 0; o < r; o++) {
    var a = s.replace("%index%", o.toString());
    a = a.replace("%sampleIndex%", o - (e - 1) + ".0"), n += a, n += `
`;
  }
  return i = i.replace("%blur%", n), i = i.replace("%size%", r.toString()), i;
}
var lC = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
}, uC = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join(`
`);
function cC(r) {
  for (var t = lC[r], e = t.length, i = uC, n = "", s = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;", o, a = 0; a < r; a++) {
    var l = s.replace("%index%", a.toString());
    o = a, a >= e && (o = r - a - 1), l = l.replace("%value%", t[o].toString()), n += l, n += `
`;
  }
  return i = i.replace("%blur%", n), i = i.replace("%size%", r.toString()), i;
}
var Zg = (
  /** @class */
  function(r) {
    kb(t, r);
    function t(e, i, n, s, o) {
      i === void 0 && (i = 8), n === void 0 && (n = 4), s === void 0 && (s = J.FILTER_RESOLUTION), o === void 0 && (o = 5);
      var a = this, l = hC(o, e), u = cC(o);
      return a = r.call(
        this,
        // vertex shader
        l,
        // fragment shader
        u
      ) || this, a.horizontal = e, a.resolution = s, a._quality = 0, a.quality = n, a.blur = i, a;
    }
    return t.prototype.apply = function(e, i, n, s) {
      if (n ? this.horizontal ? this.uniforms.strength = 1 / n.width * (n.width / i.width) : this.uniforms.strength = 1 / n.height * (n.height / i.height) : this.horizontal ? this.uniforms.strength = 1 / e.renderer.width * (e.renderer.width / i.width) : this.uniforms.strength = 1 / e.renderer.height * (e.renderer.height / i.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)
        e.applyFilter(this, i, n, s);
      else {
        var o = e.getFilterTexture(), a = e.renderer, l = i, u = o;
        this.state.blend = !1, e.applyFilter(this, l, u, vr.CLEAR);
        for (var c = 1; c < this.passes - 1; c++) {
          e.bindAndClear(l, vr.BLIT), this.uniforms.uSampler = u;
          var d = u;
          u = l, l = d, a.shader.bind(this), a.geometry.draw(5);
        }
        this.state.blend = !0, e.applyFilter(this, u, n, s), e.returnFilterTexture(o);
      }
    }, Object.defineProperty(t.prototype, "blur", {
      /**
       * Sets the strength of both the blur.
       * @default 16
       */
      get: function() {
        return this.strength;
      },
      set: function(e) {
        this.padding = 1 + Math.abs(e) * 2, this.strength = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "quality", {
      /**
       * Sets the quality of the blur by modifying the number of passes. More passes means higher
       * quality bluring but the lower the performance.
       * @default 4
       */
      get: function() {
        return this._quality;
      },
      set: function(e) {
        this._quality = e, this.passes = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wr)
);
(function(r) {
  kb(t, r);
  function t(e, i, n, s) {
    e === void 0 && (e = 8), i === void 0 && (i = 4), n === void 0 && (n = J.FILTER_RESOLUTION), s === void 0 && (s = 5);
    var o = r.call(this) || this;
    return o.blurXFilter = new Zg(!0, e, i, n, s), o.blurYFilter = new Zg(!1, e, i, n, s), o.resolution = n, o.quality = i, o.blur = e, o.repeatEdgePixels = !1, o;
  }
  return t.prototype.apply = function(e, i, n, s) {
    var o = Math.abs(this.blurXFilter.strength), a = Math.abs(this.blurYFilter.strength);
    if (o && a) {
      var l = e.getFilterTexture();
      this.blurXFilter.apply(e, i, l, vr.CLEAR), this.blurYFilter.apply(e, l, n, s), e.returnFilterTexture(l);
    } else
      a ? this.blurYFilter.apply(e, i, n, s) : this.blurXFilter.apply(e, i, n, s);
  }, t.prototype.updatePadding = function() {
    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
  }, Object.defineProperty(t.prototype, "blur", {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     * @default 2
     */
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(e) {
      this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "quality", {
    /**
     * Sets the number of passes for blur. More passes means higher quality bluring.
     * @default 1
     */
    get: function() {
      return this.blurXFilter.quality;
    },
    set: function(e) {
      this.blurXFilter.quality = this.blurYFilter.quality = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blurX", {
    /**
     * Sets the strength of the blurX property
     * @default 2
     */
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(e) {
      this.blurXFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blurY", {
    /**
     * Sets the strength of the blurY property
     * @default 2
     */
    get: function() {
      return this.blurYFilter.blur;
    },
    set: function(e) {
      this.blurYFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blendMode", {
    /**
     * Sets the blendmode of the filter
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get: function() {
      return this.blurYFilter.blendMode;
    },
    set: function(e) {
      this.blurYFilter.blendMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "repeatEdgePixels", {
    /**
     * If set to true the edge of the target will be clamped
     * @default false
     */
    get: function() {
      return this._repeatEdgePixels;
    },
    set: function(e) {
      this._repeatEdgePixels = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(wr);
/*!
 * @pixi/filter-color-matrix - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-color-matrix is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var zy = function(r, t) {
  return zy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, zy(r, t);
};
function fC(r, t) {
  zy(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var dC = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`, Kg = (
  /** @class */
  function(r) {
    fC(t, r);
    function t() {
      var e = this, i = {
        m: new Float32Array([
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]),
        uAlpha: 1
      };
      return e = r.call(this, E_, dC, i) || this, e.alpha = 1, e;
    }
    return t.prototype._loadMatrix = function(e, i) {
      i === void 0 && (i = !1);
      var n = e;
      i && (this._multiply(n, this.uniforms.m, e), n = this._colorMatrix(n)), this.uniforms.m = n;
    }, t.prototype._multiply = function(e, i, n) {
      return e[0] = i[0] * n[0] + i[1] * n[5] + i[2] * n[10] + i[3] * n[15], e[1] = i[0] * n[1] + i[1] * n[6] + i[2] * n[11] + i[3] * n[16], e[2] = i[0] * n[2] + i[1] * n[7] + i[2] * n[12] + i[3] * n[17], e[3] = i[0] * n[3] + i[1] * n[8] + i[2] * n[13] + i[3] * n[18], e[4] = i[0] * n[4] + i[1] * n[9] + i[2] * n[14] + i[3] * n[19] + i[4], e[5] = i[5] * n[0] + i[6] * n[5] + i[7] * n[10] + i[8] * n[15], e[6] = i[5] * n[1] + i[6] * n[6] + i[7] * n[11] + i[8] * n[16], e[7] = i[5] * n[2] + i[6] * n[7] + i[7] * n[12] + i[8] * n[17], e[8] = i[5] * n[3] + i[6] * n[8] + i[7] * n[13] + i[8] * n[18], e[9] = i[5] * n[4] + i[6] * n[9] + i[7] * n[14] + i[8] * n[19] + i[9], e[10] = i[10] * n[0] + i[11] * n[5] + i[12] * n[10] + i[13] * n[15], e[11] = i[10] * n[1] + i[11] * n[6] + i[12] * n[11] + i[13] * n[16], e[12] = i[10] * n[2] + i[11] * n[7] + i[12] * n[12] + i[13] * n[17], e[13] = i[10] * n[3] + i[11] * n[8] + i[12] * n[13] + i[13] * n[18], e[14] = i[10] * n[4] + i[11] * n[9] + i[12] * n[14] + i[13] * n[19] + i[14], e[15] = i[15] * n[0] + i[16] * n[5] + i[17] * n[10] + i[18] * n[15], e[16] = i[15] * n[1] + i[16] * n[6] + i[17] * n[11] + i[18] * n[16], e[17] = i[15] * n[2] + i[16] * n[7] + i[17] * n[12] + i[18] * n[17], e[18] = i[15] * n[3] + i[16] * n[8] + i[17] * n[13] + i[18] * n[18], e[19] = i[15] * n[4] + i[16] * n[9] + i[17] * n[14] + i[18] * n[19] + i[19], e;
    }, t.prototype._colorMatrix = function(e) {
      var i = new Float32Array(e);
      return i[4] /= 255, i[9] /= 255, i[14] /= 255, i[19] /= 255, i;
    }, t.prototype.brightness = function(e, i) {
      var n = [
        e,
        0,
        0,
        0,
        0,
        0,
        e,
        0,
        0,
        0,
        0,
        0,
        e,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, i);
    }, t.prototype.tint = function(e, i) {
      var n = e >> 16 & 255, s = e >> 8 & 255, o = e & 255, a = [
        n / 255,
        0,
        0,
        0,
        0,
        0,
        s / 255,
        0,
        0,
        0,
        0,
        0,
        o / 255,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(a, i);
    }, t.prototype.greyscale = function(e, i) {
      var n = [
        e,
        e,
        e,
        0,
        0,
        e,
        e,
        e,
        0,
        0,
        e,
        e,
        e,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, i);
    }, t.prototype.blackAndWhite = function(e) {
      var i = [
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.hue = function(e, i) {
      e = (e || 0) / 180 * Math.PI;
      var n = Math.cos(e), s = Math.sin(e), o = Math.sqrt, a = 1 / 3, l = o(a), u = n + (1 - n) * a, c = a * (1 - n) - l * s, d = a * (1 - n) + l * s, f = a * (1 - n) + l * s, v = n + a * (1 - n), m = a * (1 - n) - l * s, p = a * (1 - n) - l * s, y = a * (1 - n) + l * s, b = n + a * (1 - n), w = [
        u,
        c,
        d,
        0,
        0,
        f,
        v,
        m,
        0,
        0,
        p,
        y,
        b,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(w, i);
    }, t.prototype.contrast = function(e, i) {
      var n = (e || 0) + 1, s = -0.5 * (n - 1), o = [
        n,
        0,
        0,
        0,
        s,
        0,
        n,
        0,
        0,
        s,
        0,
        0,
        n,
        0,
        s,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(o, i);
    }, t.prototype.saturate = function(e, i) {
      e === void 0 && (e = 0);
      var n = e * 2 / 3 + 1, s = (n - 1) * -0.5, o = [
        n,
        s,
        s,
        0,
        0,
        s,
        n,
        s,
        0,
        0,
        s,
        s,
        n,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(o, i);
    }, t.prototype.desaturate = function() {
      this.saturate(-1);
    }, t.prototype.negative = function(e) {
      var i = [
        -1,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        -1,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.sepia = function(e) {
      var i = [
        0.393,
        0.7689999,
        0.18899999,
        0,
        0,
        0.349,
        0.6859999,
        0.16799999,
        0,
        0,
        0.272,
        0.5339999,
        0.13099999,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.technicolor = function(e) {
      var i = [
        1.9125277891456083,
        -0.8545344976951645,
        -0.09155508482755585,
        0,
        11.793603434377337,
        -0.3087833385928097,
        1.7658908555458428,
        -0.10601743074722245,
        0,
        -70.35205161461398,
        -0.231103377548616,
        -0.7501899197440212,
        1.847597816108189,
        0,
        30.950940869491138,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.polaroid = function(e) {
      var i = [
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.toBGR = function(e) {
      var i = [
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.kodachrome = function(e) {
      var i = [
        1.1285582396593525,
        -0.3967382283601348,
        -0.03992559172921793,
        0,
        63.72958762196502,
        -0.16404339962244616,
        1.0835251566291304,
        -0.05498805115633132,
        0,
        24.732407896706203,
        -0.16786010706155763,
        -0.5603416277695248,
        1.6014850761964943,
        0,
        35.62982807460946,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.browni = function(e) {
      var i = [
        0.5997023498159715,
        0.34553243048391263,
        -0.2708298674538042,
        0,
        47.43192855600873,
        -0.037703249837783157,
        0.8609577587992641,
        0.15059552388459913,
        0,
        -36.96841498319127,
        0.24113635128153335,
        -0.07441037908422492,
        0.44972182064877153,
        0,
        -7.562075277591283,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.vintage = function(e) {
      var i = [
        0.6279345635605994,
        0.3202183420819367,
        -0.03965408211312453,
        0,
        9.651285835294123,
        0.02578397704808868,
        0.6441188644374771,
        0.03259127616149294,
        0,
        7.462829176470591,
        0.0466055556782719,
        -0.0851232987247891,
        0.5241648018700465,
        0,
        5.159190588235296,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.colorTone = function(e, i, n, s, o) {
      e = e || 0.2, i = i || 0.15, n = n || 16770432, s = s || 3375104;
      var a = (n >> 16 & 255) / 255, l = (n >> 8 & 255) / 255, u = (n & 255) / 255, c = (s >> 16 & 255) / 255, d = (s >> 8 & 255) / 255, f = (s & 255) / 255, v = [
        0.3,
        0.59,
        0.11,
        0,
        0,
        a,
        l,
        u,
        e,
        0,
        c,
        d,
        f,
        i,
        0,
        a - c,
        l - d,
        u - f,
        0,
        0
      ];
      this._loadMatrix(v, o);
    }, t.prototype.night = function(e, i) {
      e = e || 0.1;
      var n = [
        e * -2,
        -e,
        0,
        0,
        0,
        -e,
        0,
        e,
        0,
        0,
        0,
        e,
        e * 2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, i);
    }, t.prototype.predator = function(e, i) {
      var n = [
        // row 1
        11.224130630493164 * e,
        -4.794486999511719 * e,
        -2.8746118545532227 * e,
        0 * e,
        0.40342438220977783 * e,
        // row 2
        -3.6330697536468506 * e,
        9.193157196044922 * e,
        -2.951810836791992 * e,
        0 * e,
        -1.316135048866272 * e,
        // row 3
        -3.2184197902679443 * e,
        -4.2375030517578125 * e,
        7.476448059082031 * e,
        0 * e,
        0.8044459223747253 * e,
        // row 4
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, i);
    }, t.prototype.lsd = function(e) {
      var i = [
        2,
        -0.4,
        0.5,
        0,
        0,
        -0.5,
        2,
        -0.4,
        0,
        0,
        -0.4,
        -0.5,
        3,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, e);
    }, t.prototype.reset = function() {
      var e = [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(e, !1);
    }, Object.defineProperty(t.prototype, "matrix", {
      /**
       * The matrix of the color matrix filter
       * @member {number[]}
       * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
       */
      get: function() {
        return this.uniforms.m;
      },
      set: function(e) {
        this.uniforms.m = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "alpha", {
      /**
       * The opacity value to use when mixing the original and resultant colors.
       *
       * When the value is 0, the original color is used without modification.
       * When the value is 1, the result color is used.
       * When in the range (0, 1) the color is interpolated between the original and result by this amount.
       * @default 1
       */
      get: function() {
        return this.uniforms.uAlpha;
      },
      set: function(e) {
        this.uniforms.uAlpha = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wr)
);
Kg.prototype.grayscale = Kg.prototype.greyscale;
/*!
 * @pixi/filter-displacement - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-displacement is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Vy = function(r, t) {
  return Vy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Vy(r, t);
};
function pC(r, t) {
  Vy(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var vC = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`, yC = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
(function(r) {
  pC(t, r);
  function t(e, i) {
    var n = this, s = new De();
    return e.renderable = !1, n = r.call(this, yC, vC, {
      mapSampler: e._texture,
      filterMatrix: s,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    }) || this, n.maskSprite = e, n.maskMatrix = s, i == null && (i = 20), n.scale = new te(i, i), n;
  }
  return t.prototype.apply = function(e, i, n, s) {
    this.uniforms.filterMatrix = e.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
    var o = this.maskSprite.worldTransform, a = Math.sqrt(o.a * o.a + o.b * o.b), l = Math.sqrt(o.c * o.c + o.d * o.d);
    a !== 0 && l !== 0 && (this.uniforms.rotation[0] = o.a / a, this.uniforms.rotation[1] = o.b / a, this.uniforms.rotation[2] = o.c / l, this.uniforms.rotation[3] = o.d / l), e.applyFilter(this, i, n, s);
  }, Object.defineProperty(t.prototype, "map", {
    /** The texture used for the displacement map. Must be power of 2 sized texture. */
    get: function() {
      return this.uniforms.mapSampler;
    },
    set: function(e) {
      this.uniforms.mapSampler = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(wr);
/*!
 * @pixi/filter-fxaa - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-fxaa is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Xy = function(r, t) {
  return Xy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Xy(r, t);
};
function mC(r, t) {
  Xy(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var _C = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`, gC = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
(function(r) {
  mC(t, r);
  function t() {
    return r.call(this, _C, gC) || this;
  }
  return t;
})(wr);
/*!
 * @pixi/filter-noise - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-noise is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Wy = function(r, t) {
  return Wy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Wy(r, t);
};
function bC(r, t) {
  Wy(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var xC = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
(function(r) {
  bC(t, r);
  function t(e, i) {
    e === void 0 && (e = 0.5), i === void 0 && (i = Math.random());
    var n = r.call(this, E_, xC, {
      uNoise: 0,
      uSeed: 0
    }) || this;
    return n.noise = e, n.seed = i, n;
  }
  return Object.defineProperty(t.prototype, "noise", {
    /**
     * The amount of noise to apply, this value should be in the range (0, 1].
     * @default 0.5
     */
    get: function() {
      return this.uniforms.uNoise;
    },
    set: function(e) {
      this.uniforms.uNoise = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "seed", {
    /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */
    get: function() {
      return this.uniforms.uSeed;
    },
    set: function(e) {
      this.uniforms.uSeed = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(wr);
/*!
 * @pixi/mixin-cache-as-bitmap - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Nb = new De();
xe.prototype._cacheAsBitmap = !1;
xe.prototype._cacheData = null;
xe.prototype._cacheAsBitmapResolution = null;
xe.prototype._cacheAsBitmapMultisample = ue.NONE;
var wC = (
  /** @class */
  function() {
    function r() {
      this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;
    }
    return r;
  }()
);
Object.defineProperties(xe.prototype, {
  /**
   * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution
   * but can be overriden for performance. Lower values will reduce memory usage at the expense
   * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.
   * @member {number} cacheAsBitmapResolution
   * @memberof PIXI.DisplayObject#
   * @default null
   */
  cacheAsBitmapResolution: {
    get: function() {
      return this._cacheAsBitmapResolution;
    },
    set: function(r) {
      r !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = r, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  /**
   * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's
   * sample count is used.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.
   * @member {number} cacheAsBitmapMultisample
   * @memberof PIXI.DisplayObject#
   * @default PIXI.MSAA_QUALITY.NONE
   */
  cacheAsBitmapMultisample: {
    get: function() {
      return this._cacheAsBitmapMultisample;
    },
    set: function(r) {
      r !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = r, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  /**
   * Set this to true if you want this display object to be cached as a bitmap.
   * This basically takes a snap shot of the display object as it is at that moment. It can
   * provide a performance benefit for complex static displayObjects.
   * To remove simply set this property to `false`
   *
   * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
   * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  cacheAsBitmap: {
    get: function() {
      return this._cacheAsBitmap;
    },
    set: function(r) {
      if (this._cacheAsBitmap !== r) {
        this._cacheAsBitmap = r;
        var t;
        r ? (this._cacheData || (this._cacheData = new wC()), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea);
      }
    }
  }
});
xe.prototype._renderCached = function(t) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t));
};
xe.prototype._initCachedDisplayObject = function(t) {
  var e;
  if (!(this._cacheData && this._cacheData.sprite)) {
    var i = this.alpha;
    this.alpha = 1, t.batch.flush();
    var n = this.getLocalBounds(null, !0).clone();
    if (this.filters && this.filters.length) {
      var s = this.filters[0].padding;
      n.pad(s);
    }
    n.ceil(J.RESOLUTION);
    var o = t.renderTexture.current, a = t.renderTexture.sourceFrame.clone(), l = t.renderTexture.destinationFrame.clone(), u = t.projection.transform, c = Wi.create({
      width: n.width,
      height: n.height,
      resolution: this.cacheAsBitmapResolution || t.resolution,
      multisample: (e = this.cacheAsBitmapMultisample) !== null && e !== void 0 ? e : t.multisample
    }), d = "cacheAsBitmap_" + Yo();
    this._cacheData.textureCacheId = d, Mt.addToCache(c.baseTexture, d), ut.addToCache(c, d);
    var f = this.transform.localTransform.copyTo(Nb).invert().translate(-n.x, -n.y);
    this.render = this._cacheData.originalRender, t.render(this, { renderTexture: c, clear: !0, transform: f, skipUpdateTransform: !1 }), t.framebuffer.blit(), t.projection.transform = u, t.renderTexture.bind(o, a, l), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = i;
    var v = new ge(c);
    v.transform.worldTransform = this.transform.worldTransform, v.anchor.x = -(n.x / n.width), v.anchor.y = -(n.y / n.height), v.alpha = i, v._bounds = this._bounds, this._cacheData.sprite = v, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = v.containsPoint.bind(v);
  }
};
xe.prototype._renderCachedCanvas = function(t) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t));
};
xe.prototype._initCachedDisplayObjectCanvas = function(t) {
  if (!(this._cacheData && this._cacheData.sprite)) {
    var e = this.getLocalBounds(null, !0), i = this.alpha;
    this.alpha = 1;
    var n = t.context, s = t._projTransform;
    e.ceil(J.RESOLUTION);
    var o = Wi.create({ width: e.width, height: e.height }), a = "cacheAsBitmap_" + Yo();
    this._cacheData.textureCacheId = a, Mt.addToCache(o.baseTexture, a), ut.addToCache(o, a);
    var l = Nb;
    this.transform.localTransform.copyTo(l), l.invert(), l.tx -= e.x, l.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, { renderTexture: o, clear: !0, transform: l, skipUpdateTransform: !1 }), t.context = n, t._projTransform = s, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = i;
    var u = new ge(o);
    u.transform.worldTransform = this.transform.worldTransform, u.anchor.x = -(e.x / e.width), u.anchor.y = -(e.y / e.height), u.alpha = i, u._bounds = this._bounds, this._cacheData.sprite = u, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = u.containsPoint.bind(u);
  }
};
xe.prototype._calculateCachedBounds = function() {
  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;
};
xe.prototype._getCachedLocalBounds = function() {
  return this._cacheData.sprite.getLocalBounds(null);
};
xe.prototype._destroyCachedDisplayObject = function() {
  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, Mt.removeFromCache(this._cacheData.textureCacheId), ut.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;
};
xe.prototype._cacheAsBitmapDestroy = function(t) {
  this.cacheAsBitmap = !1, this.destroy(t);
};
/*!
 * @pixi/mixin-get-child-by-name - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
xe.prototype.name = null;
Qt.prototype.getChildByName = function(t, e) {
  for (var i = 0, n = this.children.length; i < n; i++)
    if (this.children[i].name === t)
      return this.children[i];
  if (e)
    for (var i = 0, n = this.children.length; i < n; i++) {
      var s = this.children[i];
      if (s.getChildByName) {
        var o = s.getChildByName(t, !0);
        if (o)
          return o;
      }
    }
  return null;
};
/*!
 * @pixi/mixin-get-global-position - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
xe.prototype.getGlobalPosition = function(t, e) {
  return t === void 0 && (t = new te()), e === void 0 && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t;
};
/*!
 * @pixi/app - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/app is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var EC = (
  /** @class */
  function() {
    function r() {
    }
    return r.init = function(t) {
      var e = this;
      Object.defineProperty(
        this,
        "resizeTo",
        /**
         * The HTML element or window to automatically resize the
         * renderer's view element to match width and height.
         * @member {Window|HTMLElement}
         * @name resizeTo
         * @memberof PIXI.Application#
         */
        {
          set: function(i) {
            globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = i, i && (globalThis.addEventListener("resize", this.queueResize), this.resize());
          },
          get: function() {
            return this._resizeTo;
          }
        }
      ), this.queueResize = function() {
        e._resizeTo && (e.cancelResize(), e._resizeId = requestAnimationFrame(function() {
          return e.resize();
        }));
      }, this.cancelResize = function() {
        e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null);
      }, this.resize = function() {
        if (e._resizeTo) {
          e.cancelResize();
          var i, n;
          if (e._resizeTo === globalThis.window)
            i = globalThis.innerWidth, n = globalThis.innerHeight;
          else {
            var s = e._resizeTo, o = s.clientWidth, a = s.clientHeight;
            i = o, n = a;
          }
          e.renderer.resize(i, n);
        }
      }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;
    }, r.destroy = function() {
      globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
    }, r.extension = qt.Application, r;
  }()
), Ab = (
  /** @class */
  function() {
    function r(t) {
      var e = this;
      this.stage = new Qt(), t = Object.assign({
        forceCanvas: !1
      }, t), this.renderer = w_(t), r._plugins.forEach(function(i) {
        i.init.call(e, t);
      });
    }
    return r.registerPlugin = function(t) {
      ci("6.5.0", "Application.registerPlugin() is deprecated, use extensions.add()"), Tr.add({
        type: qt.Application,
        ref: t
      });
    }, r.prototype.render = function() {
      this.renderer.render(this.stage);
    }, Object.defineProperty(r.prototype, "view", {
      /**
       * Reference to the renderer's canvas element.
       * @member {HTMLCanvasElement}
       * @readonly
       */
      get: function() {
        return this.renderer.view;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "screen", {
      /**
       * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
       * @member {PIXI.Rectangle}
       * @readonly
       */
      get: function() {
        return this.renderer.screen;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.destroy = function(t, e) {
      var i = this, n = r._plugins.slice(0);
      n.reverse(), n.forEach(function(s) {
        s.destroy.call(i);
      }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;
    }, r._plugins = [], r;
  }()
);
Tr.handleByList(qt.Application, Ab._plugins);
Tr.add(EC);
/*!
 * @pixi/mesh-extras - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/mesh-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Yy = function(r, t) {
  return Yy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, Yy(r, t);
};
function $h(r, t) {
  Yy(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var TC = (
  /** @class */
  function(r) {
    $h(t, r);
    function t(e, i, n, s) {
      e === void 0 && (e = 100), i === void 0 && (i = 100), n === void 0 && (n = 10), s === void 0 && (s = 10);
      var o = r.call(this) || this;
      return o.segWidth = n, o.segHeight = s, o.width = e, o.height = i, o.build(), o;
    }
    return t.prototype.build = function() {
      for (var e = this.segWidth * this.segHeight, i = [], n = [], s = [], o = this.segWidth - 1, a = this.segHeight - 1, l = this.width / o, u = this.height / a, c = 0; c < e; c++) {
        var d = c % this.segWidth, f = c / this.segWidth | 0;
        i.push(d * l, f * u), n.push(d / o, f / a);
      }
      for (var v = o * a, c = 0; c < v; c++) {
        var m = c % o, p = c / o | 0, y = p * this.segWidth + m, b = p * this.segWidth + m + 1, w = (p + 1) * this.segWidth + m, E = (p + 1) * this.segWidth + m + 1;
        s.push(y, b, w, b, E, w);
      }
      this.buffers[0].data = new Float32Array(i), this.buffers[1].data = new Float32Array(n), this.indexBuffer.data = new Uint16Array(s), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
    }, t;
  }(Av)
), SC = (
  /** @class */
  function(r) {
    $h(t, r);
    function t(e, i, n) {
      e === void 0 && (e = 200), n === void 0 && (n = 0);
      var s = r.call(this, new Float32Array(i.length * 4), new Float32Array(i.length * 4), new Uint16Array((i.length - 1) * 6)) || this;
      return s.points = i, s._width = e, s.textureScale = n, s.build(), s;
    }
    return Object.defineProperty(t.prototype, "width", {
      /**
       * The width (i.e., thickness) of the rope.
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.build = function() {
      var e = this.points;
      if (e) {
        var i = this.getBuffer("aVertexPosition"), n = this.getBuffer("aTextureCoord"), s = this.getIndex();
        if (!(e.length < 1)) {
          i.data.length / 4 !== e.length && (i.data = new Float32Array(e.length * 4), n.data = new Float32Array(e.length * 4), s.data = new Uint16Array((e.length - 1) * 6));
          var o = n.data, a = s.data;
          o[0] = 0, o[1] = 0, o[2] = 0, o[3] = 1;
          for (var l = 0, u = e[0], c = this._width * this.textureScale, d = e.length, f = 0; f < d; f++) {
            var v = f * 4;
            if (this.textureScale > 0) {
              var m = u.x - e[f].x, p = u.y - e[f].y, y = Math.sqrt(m * m + p * p);
              u = e[f], l += y / c;
            } else
              l = f / (d - 1);
            o[v] = l, o[v + 1] = 0, o[v + 2] = l, o[v + 3] = 1;
          }
          for (var b = 0, f = 0; f < d - 1; f++) {
            var v = f * 2;
            a[b++] = v, a[b++] = v + 1, a[b++] = v + 2, a[b++] = v + 2, a[b++] = v + 1, a[b++] = v + 3;
          }
          n.update(), s.update(), this.updateVertices();
        }
      }
    }, t.prototype.updateVertices = function() {
      var e = this.points;
      if (!(e.length < 1)) {
        for (var i = e[0], n, s = 0, o = 0, a = this.buffers[0].data, l = e.length, u = 0; u < l; u++) {
          var c = e[u], d = u * 4;
          u < e.length - 1 ? n = e[u + 1] : n = c, o = -(n.x - i.x), s = n.y - i.y;
          var f = Math.sqrt(s * s + o * o), v = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
          s /= f, o /= f, s *= v, o *= v, a[d] = c.x + s, a[d + 1] = c.y + o, a[d + 2] = c.x - s, a[d + 3] = c.y - o, i = c;
        }
        this.buffers[0].update();
      }
    }, t.prototype.update = function() {
      this.textureScale > 0 ? this.build() : this.updateVertices();
    }, t;
  }(Av)
);
(function(r) {
  $h(t, r);
  function t(e, i, n) {
    n === void 0 && (n = 0);
    var s = this, o = new SC(e.height, i, n), a = new Rl(e);
    return n > 0 && (e.baseTexture.wrapMode = Wr.REPEAT), s = r.call(this, o, a) || this, s.autoUpdate = !0, s;
  }
  return t.prototype._render = function(e) {
    var i = this.geometry;
    (this.autoUpdate || i._width !== this.shader.texture.height) && (i._width = this.shader.texture.height, i.update()), r.prototype._render.call(this, e);
  }, t;
})(Ml);
var PC = (
  /** @class */
  function(r) {
    $h(t, r);
    function t(e, i, n) {
      var s = this, o = new TC(e.width, e.height, i, n), a = new Rl(ut.WHITE);
      return s = r.call(this, o, a) || this, s.texture = e, s.autoResize = !0, s;
    }
    return t.prototype.textureUpdated = function() {
      this._textureID = this.shader.texture._updateID;
      var e = this.geometry, i = this.shader.texture, n = i.width, s = i.height;
      this.autoResize && (e.width !== n || e.height !== s) && (e.width = this.shader.texture.width, e.height = this.shader.texture.height, e.build());
    }, Object.defineProperty(t.prototype, "texture", {
      get: function() {
        return this.shader.texture;
      },
      set: function(e) {
        this.shader.texture !== e && (this.shader.texture = e, this._textureID = -1, e.baseTexture.valid ? this.textureUpdated() : e.once("update", this.textureUpdated, this));
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype._render = function(e) {
      this._textureID !== this.shader.texture._updateID && this.textureUpdated(), r.prototype._render.call(this, e);
    }, t.prototype.destroy = function(e) {
      this.shader.texture.off("update", this.textureUpdated, this), r.prototype.destroy.call(this, e);
    }, t;
  }(Ml)
);
(function(r) {
  $h(t, r);
  function t(e, i, n, s, o) {
    e === void 0 && (e = ut.EMPTY);
    var a = this, l = new Av(i, n, s);
    l.getBuffer("aVertexPosition").static = !1;
    var u = new Rl(e);
    return a = r.call(this, l, u, null, o) || this, a.autoUpdate = !0, a;
  }
  return Object.defineProperty(t.prototype, "vertices", {
    /**
     * Collection of vertices data.
     * @type {Float32Array}
     */
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(e) {
      this.geometry.getBuffer("aVertexPosition").data = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._render = function(e) {
    this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), r.prototype._render.call(this, e);
  }, t;
})(Ml);
var sf = 10;
(function(r) {
  $h(t, r);
  function t(e, i, n, s, o) {
    i === void 0 && (i = sf), n === void 0 && (n = sf), s === void 0 && (s = sf), o === void 0 && (o = sf);
    var a = r.call(this, ut.WHITE, 4, 4) || this;
    return a._origWidth = e.orig.width, a._origHeight = e.orig.height, a._width = a._origWidth, a._height = a._origHeight, a._leftWidth = i, a._rightWidth = s, a._topHeight = n, a._bottomHeight = o, a.texture = e, a;
  }
  return t.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID, this._refresh();
  }, Object.defineProperty(t.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(e) {
      this.geometry.getBuffer("aVertexPosition").data = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.updateHorizontalVertices = function() {
    var e = this.vertices, i = this._getMinScale();
    e[9] = e[11] = e[13] = e[15] = this._topHeight * i, e[17] = e[19] = e[21] = e[23] = this._height - this._bottomHeight * i, e[25] = e[27] = e[29] = e[31] = this._height;
  }, t.prototype.updateVerticalVertices = function() {
    var e = this.vertices, i = this._getMinScale();
    e[2] = e[10] = e[18] = e[26] = this._leftWidth * i, e[4] = e[12] = e[20] = e[28] = this._width - this._rightWidth * i, e[6] = e[14] = e[22] = e[30] = this._width;
  }, t.prototype._getMinScale = function() {
    var e = this._leftWidth + this._rightWidth, i = this._width > e ? 1 : this._width / e, n = this._topHeight + this._bottomHeight, s = this._height > n ? 1 : this._height / n, o = Math.min(i, s);
    return o;
  }, Object.defineProperty(t.prototype, "width", {
    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    get: function() {
      return this._width;
    },
    set: function(e) {
      this._width = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    get: function() {
      return this._height;
    },
    set: function(e) {
      this._height = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "leftWidth", {
    /** The width of the left column. */
    get: function() {
      return this._leftWidth;
    },
    set: function(e) {
      this._leftWidth = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "rightWidth", {
    /** The width of the right column. */
    get: function() {
      return this._rightWidth;
    },
    set: function(e) {
      this._rightWidth = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "topHeight", {
    /** The height of the top row. */
    get: function() {
      return this._topHeight;
    },
    set: function(e) {
      this._topHeight = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "bottomHeight", {
    /** The height of the bottom row. */
    get: function() {
      return this._bottomHeight;
    },
    set: function(e) {
      this._bottomHeight = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._refresh = function() {
    var e = this.texture, i = this.geometry.buffers[1].data;
    this._origWidth = e.orig.width, this._origHeight = e.orig.height;
    var n = 1 / this._origWidth, s = 1 / this._origHeight;
    i[0] = i[8] = i[16] = i[24] = 0, i[1] = i[3] = i[5] = i[7] = 0, i[6] = i[14] = i[22] = i[30] = 1, i[25] = i[27] = i[29] = i[31] = 1, i[2] = i[10] = i[18] = i[26] = n * this._leftWidth, i[4] = i[12] = i[20] = i[28] = 1 - n * this._rightWidth, i[9] = i[11] = i[13] = i[15] = s * this._topHeight, i[17] = i[19] = i[21] = i[23] = 1 - s * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();
  }, t;
})(PC);
/*!
 * @pixi/sprite-animated - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/sprite-animated is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var qy = function(r, t) {
  return qy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (e[n] = i[n]);
  }, qy(r, t);
};
function OC(r, t) {
  qy(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Jg = (
  /** @class */
  function(r) {
    OC(t, r);
    function t(e, i) {
      i === void 0 && (i = !0);
      var n = r.call(this, e[0] instanceof ut ? e[0] : e[0].texture) || this;
      return n._textures = null, n._durations = null, n._autoUpdate = i, n._isConnectedToTicker = !1, n.animationSpeed = 1, n.loop = !0, n.updateAnchor = !1, n.onComplete = null, n.onFrameChange = null, n.onLoop = null, n._currentTime = 0, n._playing = !1, n._previousFrame = null, n.textures = e, n;
    }
    return t.prototype.stop = function() {
      this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (_e.shared.remove(this.update, this), this._isConnectedToTicker = !1));
    }, t.prototype.play = function() {
      this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (_e.shared.add(this.update, this, Un.HIGH), this._isConnectedToTicker = !0));
    }, t.prototype.gotoAndStop = function(e) {
      this.stop();
      var i = this.currentFrame;
      this._currentTime = e, i !== this.currentFrame && this.updateTexture();
    }, t.prototype.gotoAndPlay = function(e) {
      var i = this.currentFrame;
      this._currentTime = e, i !== this.currentFrame && this.updateTexture(), this.play();
    }, t.prototype.update = function(e) {
      if (this._playing) {
        var i = this.animationSpeed * e, n = this.currentFrame;
        if (this._durations !== null) {
          var s = this._currentTime % 1 * this._durations[this.currentFrame];
          for (s += i / 60 * 1e3; s < 0; )
            this._currentTime--, s += this._durations[this.currentFrame];
          var o = Math.sign(this.animationSpeed * e);
          for (this._currentTime = Math.floor(this._currentTime); s >= this._durations[this.currentFrame]; )
            s -= this._durations[this.currentFrame] * o, this._currentTime += o;
          this._currentTime += s / this._durations[this.currentFrame];
        } else
          this._currentTime += i;
        this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : n !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < n ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > n && this.onLoop()), this.updateTexture());
      }
    }, t.prototype.updateTexture = function() {
      var e = this.currentFrame;
      this._previousFrame !== e && (this._previousFrame = e, this._texture = this._textures[e], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));
    }, t.prototype.destroy = function(e) {
      this.stop(), r.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;
    }, t.fromFrames = function(e) {
      for (var i = [], n = 0; n < e.length; ++n)
        i.push(ut.from(e[n]));
      return new t(i);
    }, t.fromImages = function(e) {
      for (var i = [], n = 0; n < e.length; ++n)
        i.push(ut.from(e[n]));
      return new t(i);
    }, Object.defineProperty(t.prototype, "totalFrames", {
      /**
       * The total number of frames in the AnimatedSprite. This is the same as number of textures
       * assigned to the AnimatedSprite.
       * @readonly
       * @default 0
       */
      get: function() {
        return this._textures.length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "textures", {
      /** The array of textures used for this AnimatedSprite. */
      get: function() {
        return this._textures;
      },
      set: function(e) {
        if (e[0] instanceof ut)
          this._textures = e, this._durations = null;
        else {
          this._textures = [], this._durations = [];
          for (var i = 0; i < e.length; i++)
            this._textures.push(e[i].texture), this._durations.push(e[i].time);
        }
        this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "currentFrame", {
      /**
       * The AnimatedSprites current frame index.
       * @readonly
       */
      get: function() {
        var e = Math.floor(this._currentTime) % this._textures.length;
        return e < 0 && (e += this._textures.length), e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "playing", {
      /**
       * Indicates if the AnimatedSprite is currently playing.
       * @readonly
       */
      get: function() {
        return this._playing;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "autoUpdate", {
      /** Whether to use PIXI.Ticker.shared to auto update animation time. */
      get: function() {
        return this._autoUpdate;
      },
      set: function(e) {
        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (_e.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (_e.shared.add(this.update, this), this._isConnectedToTicker = !0));
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ge)
);
/*!
 * pixi.js - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
Tr.add(
  // Install renderer plugins
  uO,
  _O,
  vO,
  uI,
  UI,
  S_,
  XI,
  // Install loader plugins
  nC,
  LO,
  oI,
  aI,
  jI,
  // Install application plugins
  aP,
  PO
);
var Wn;
class Dh {
  constructor() {
    // リソースリーク対策
    _(this, Wn, []);
  }
  add(t, e, i, n = {}) {
    if (t instanceof Mt) {
      switch (e) {
        case "loaded":
        case "update":
        case "error":
        case "dispose":
          t.on(e, i, n), h(this, Wn).push(() => t.off(e, i, n));
          break;
      }
      return;
    }
    if (t instanceof Zi) {
      t.on(e, i, n), h(this, Wn).push(() => t.off(e, i, n));
      return;
    }
    t.addEventListener(e, i, n), h(this, Wn).push(() => t.removeEventListener(e, i, { capture: n.capture ?? !1 }));
  }
  clear() {
    for (const t of h(this, Wn))
      t();
    g(this, Wn, []);
  }
}
Wn = new WeakMap();
var Xe = /* @__PURE__ */ ((r) => (r.DEFAULT = "", r.SP_GSM = "png|jpg|jpeg|json|svg|webp|mp4|webm", r.SCRIPT = "sn|ssn", r.FONT = "woff2|woff|otf|ttf", r.SOUND = "mp3|m4a|ogg|aac|flac|wav", r.HTML = "htm|html", r.CSS = "css", r.SN = "sn", r.PSD = "psd", r.TST_PNGPNG_ = "png|png_", r.TST_HH = "hh", r.TST_EEE = "eee", r.TST_GGG = "ggg", r.TST_PNGXML = "png|xml", r))(Xe || {}), Al, Ll, ad;
class IC {
  constructor(t) {
    D(this, "oCfg", {
      save_ns: "",
      // 扱うセーブデータを一意に識別するキーワード文字列
      window: {
        // アプリケーションウインドウサイズ
        width: 300,
        height: 300
      },
      book: {
        // プロジェクトの詳細情報です
        title: "",
        //作品タイトル
        creator: "",
        //著作者。同人ならペンネーム
        cre_url: "",
        //著作者URL。ツイッターやメール、サイトなど
        publisher: "",
        //出版社。同人ならサークル名
        pub_url: "",
        //出版社URL。無ければ省略します
        detail: "",
        // 内容紹介。端的に記入
        version: "1.0"
      },
      log: { max_len: 1024 },
      // プレイヤーが読んだ文章を読み返せる履歴の長さ
      init: {
        bg_color: "#000000",
        // 背景色
        tagch_msecwait: 10,
        // 通常文字表示待ち時間（未読／既読）
        auto_msecpagewait: 3500,
        // 自動文字表示、行クリック待ち時間（未読／既読）
        escape: ""
        // エスケープ文字
      },
      debug: {
        devtool: !1,
        token: !1,
        tag: !1,
        putCh: !1,
        debugLog: !1,
        baseTx: !1,
        masume: !1,
        // テキストレイヤ：ガイドマス目を表示するか
        variable: !1
      },
      code: {},
      // 暗号化しないフォルダ
      debuger_token: ""
      // デバッガとの接続トークン
    });
    D(this, "userFnTail", "");
    // 4tst public
    D(this, "hPathFn2Exts", {});
    _(this, Al, !1);
    _(this, Ll, !1);
    _(this, ad, /([^\/\s]+)\.([^\d]\w+)/);
    this.sys = t;
  }
  async load(t) {
    var e, i, n, s;
    if (this.oCfg.save_ns = (t == null ? void 0 : t.save_ns) ?? this.oCfg.save_ns, this.oCfg.window.width = Number(((e = t == null ? void 0 : t.window) == null ? void 0 : e.width) ?? this.oCfg.window.width), this.oCfg.window.height = Number(((i = t == null ? void 0 : t.window) == null ? void 0 : i.height) ?? this.oCfg.window.height), this.oCfg.book = { ...this.oCfg.book, ...t.book }, this.oCfg.log.max_len = ((s = (n = t.log) == null ? void 0 : n.max_len) == null ? void 0 : s.max_len) ?? this.oCfg.log.max_len, this.oCfg.init = { ...this.oCfg.init, ...t.init }, this.oCfg.debug = { ...this.oCfg.debug, ...t.debug }, this.oCfg.debuger_token = t.debuger_token, await this.sys.loadPath(this.hPathFn2Exts, this), g(this, Al, this.matchPath(
      "^breakline$",
      "png|jpg|jpeg|json|svg|webp|mp4|webm"
      /* SP_GSM */
    ).length > 0), g(this, Ll, this.matchPath(
      "^breakpage$",
      "png|jpg|jpeg|json|svg|webp|mp4|webm"
      /* SP_GSM */
    ).length > 0), !!this.sys.crypto)
      for (const o of Object.values(this.hPathFn2Exts))
        for (const [a, l] of Object.entries(o)) {
          if (a.slice(-10) !== ":RIPEMD160")
            continue;
          const u = l.slice(l.lastIndexOf("/") + 1), c = o[a.slice(0, -10)], f = await (await this.sys.fetch(c)).text(), v = this.sys.hash(f);
          if (u !== v)
            throw `ファイル改竄エラーです fn:${c}`;
        }
  }
  get existsBreakline() {
    return h(this, Al);
  }
  get existsBreakpage() {
    return h(this, Ll);
  }
  getNs() {
    return `skynovel.${this.oCfg.save_ns} - `;
  }
  // 4 match 498 step(~1ms)  https://regex101.com/r/tpVgmI/1
  searchPath(t, e = "") {
    if (!t)
      throw "[searchPath] fnが空です";
    if (t.slice(0, 7) === "http://")
      return t;
    const i = t.match(h(this, ad));
    let n = i ? i[1] : t;
    const s = i ? i[2] : "";
    if (this.userFnTail) {
      const l = n + "@@" + this.userFnTail;
      if (l in this.hPathFn2Exts) {
        if (e === "")
          n = l;
        else
          for (const u of Object.keys(this.hPathFn2Exts[l]))
            if (`|${e}|`.indexOf(`|${u}|`) !== -1) {
              n = l;
              break;
            }
      }
    }
    const o = this.hPathFn2Exts[n];
    if (!o)
      throw `サーチパスに存在しないファイル【${t}】です`;
    let a = "";
    if (!s) {
      const l = Ue(o[":cnt"]);
      if (e === "") {
        if (l > 1)
          throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;
        return t;
      }
      const u = `|${e}|`;
      if (l > 1) {
        let c = 0;
        for (const d of Object.keys(o))
          if (u.indexOf(`|${d}|`) !== -1 && ++c > 1)
            throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;
      }
      for (let c of Object.keys(o))
        if (u.indexOf(`|${c}|`) > -1)
          return o[c];
      throw `サーチ対象拡張子群【${e}】にマッチするファイルがサーチパスに存在しません。探索ファイル名=【${t}】`;
    }
    if (e !== "" && `|${e}|`.indexOf(`|${s}|`) === -1)
      throw `指定ファイルの拡張子【${s}】は、サーチ対象拡張子群【${e}】にマッチしません。探索ファイル名=【${t}】`;
    if (a = o[s], !a)
      throw `サーチパスに存在しない拡張子【${s}】です。探索ファイル名=【${t}】、サーチ対象拡張子群【${e}】`;
    return a;
  }
  matchPath(t, e = "") {
    const i = [], n = new RegExp(t), s = new RegExp(e);
    for (const [o, a] of Object.entries(this.hPathFn2Exts)) {
      if (o.search(n) === -1)
        continue;
      if (e === "") {
        i.push(a);
        continue;
      }
      const l = {};
      let u = !1;
      for (const c of Object.keys(a))
        c.search(s) !== -1 && (l[c] = o, u = !0);
      u && i.push(l);
    }
    return i;
  }
  addPath(t, e) {
    const i = {};
    for (const [n, s] of Object.entries(e))
      i[n] = (n.at(0) === ":" ? "" : this.sys.cur) + s;
    this.hPathFn2Exts[t] = i;
  }
}
Al = new WeakMap(), Ll = new WeakMap(), ad = new WeakMap();
class M_ extends IC {
  constructor(t) {
    super(t), this.sys = t;
  }
  static async generate(t) {
    const e = new M_(t), i = t.cur + "prj.json", n = await (await t.fetch(i)).text(), s = JSON.parse(t.decStr(i, n));
    return await e.load(s), e;
  }
  async load(t) {
    await super.load(t), L.stageW = this.oCfg.window.width, L.stageH = this.oCfg.window.height, L.debugLog = this.oCfg.debug.debugLog;
  }
  searchPath(t, e = Xe.DEFAULT) {
    return t.slice(0, 11) === "downloads:/" ? this.sys.path_downloads + t.slice(11) : t.slice(0, 10) === "userdata:/" ? this.sys.path_userdata + "storage/" + t.slice(10) : super.searchPath(t, e);
  }
}
const Lb = /(?<name>[^\s;\]]+)/;
function vf(r) {
  const t = Lb.exec(r.slice(1, -1)), e = t == null ? void 0 : t.groups;
  if (!e)
    throw `タグ記述【${r}】異常です(タグ解析)`;
  const i = e.name;
  return [i, r.slice(1 + i.length, -1)];
}
function yf(r) {
  const t = Lb.exec(r.slice(1)), e = t == null ? void 0 : t.groups;
  if (!e)
    throw `タグ記述【${r}】異常です(タグ解析)`;
  return e.name;
}
function CC(r) {
  const t = r.replaceAll("==", "＝").replaceAll("!=", "≠").split("="), e = t.length;
  if (e < 2 || e > 3)
    throw "「&計算」書式では「=」指定が一つか二つ必要です";
  if (t[1].at(0) === "&")
    throw "「&計算」書式では「&」指定が不要です";
  return {
    name: t[0].replaceAll("＝", "==").replaceAll("≠", "!="),
    text: t[1].replaceAll("＝", "==").replaceAll("≠", "!="),
    cast: e === 3 ? t[2].trim() : void 0
  };
}
var Fs, Bs, Dl, Fl, Bl, Ke, Ul, Ea, mf;
class MC {
  constructor() {
    _(this, Ea);
    _(this, Fs, void 0);
    _(this, Bs, void 0);
    _(this, Dl, new RegExp(""));
    _(this, Fl, "");
    _(this, Bl, "");
    _(this, Ke, void 0);
    _(this, Ul, void 0);
    this.setEscape("");
  }
  setEscape(t) {
    if (h(this, Ke) && t in h(this, Ke))
      throw "[エスケープ文字] char【" + t + "】が登録済みの括弧マクロまたは一文字マクロです";
    g(this, Fs, new RegExp(
      (t ? `\\${t}\\S|` : "") + // エスケープシーケンス
      `\\n+|\\t+|\\[let_ml\\s+[^\\]]+\\].+?(?=\\[endlet_ml[\\]\\s])|\\[(?:(?=([^"'#;\\]]+))\\1|(["'#]).*?\\2|;[^\\n]*)*?]|;[^\\n]*|&[^&\\n]+&|&&?[^&;\\n\\t]+|^\\*[^\\s\\[&;\\\\]+|[^\\n\\t\\[;${t ? `\\${t}` : ""}]+`,
      // 本文
      "gs"
    )), g(this, Bs, new RegExp(`[\\w\\s;[\\]*=&｜《》${t ? `\\${t}` : ""}]`)), g(this, Ul, new RegExp(`[\\n\\t;\\[*&${t ? `\\${t}` : ""}]`));
  }
  // 括弧マクロの定義
  bracket2macro(t, e, i, n) {
    const { name: s, text: o } = t;
    if (!s)
      throw "[bracket2macro] nameは必須です";
    if (!o)
      throw "[bracket2macro] textは必須です";
    const a = o.at(0);
    if (!a)
      throw "[bracket2macro] textは必須です";
    if (o.length !== 2)
      throw "[bracket2macro] textは括弧の前後を示す二文字を指定してください";
    if (!(s in e))
      throw `[bracket2macro] 未定義のタグ又はマクロ[${s}]です`;
    h(this, Ke) ?? g(this, Ke, {});
    const l = o.charAt(1);
    if (a in h(this, Ke))
      throw "[bracket2macro] text【" + a + "】が登録済みの括弧マクロまたは一文字マクロです";
    if (l in h(this, Ke))
      throw "[bracket2macro] text【" + l + "】が登録済みの括弧マクロまたは一文字マクロです";
    if (h(this, Bs).test(a))
      throw "[bracket2macro] text【" + a + "】は括弧マクロに使用できない文字です";
    if (h(this, Bs).test(l))
      throw "[bracket2macro] text【" + l + "】は括弧マクロに使用できない文字です";
    h(this, Ke)[l] = "0", h(this, Ke)[a] = `[${s} text=`, this.addC2M(`\\${a}[^\\${l}]*\\${l}`, `\\${a}\\${l}`), x(this, Ea, mf).call(this, i, n);
  }
  // 一文字マクロの定義
  char2macro(t, e, i, n) {
    const { char: s, name: o } = t;
    if (!s)
      throw "[char2macro] charは必須です";
    if (h(this, Ke) ?? g(this, Ke, {}), s in h(this, Ke))
      throw "[char2macro] char【" + s + "】が登録済みの括弧マクロまたは一文字マクロです";
    if (h(this, Bs).test(s))
      throw "[char2macro] char【" + s + "】は一文字マクロに使用できない文字です";
    if (!o)
      throw "[char2macro] nameは必須です";
    if (!(o in e))
      throw `[char2macro] 未定義のタグ又はマクロ[${o}]です`;
    h(this, Ke)[s] = `[${o}]`, this.addC2M(`\\${s}`, `\\${s}`), x(this, Ea, mf).call(this, i, n);
  }
  addC2M(t, e) {
    g(this, Fl, h(this, Fl) + `${t}|`), g(this, Bl, h(this, Bl) + `${e}`), g(this, Dl, new RegExp(
      `(${h(this, Fl)}[^${h(this, Bl)}]+)`,
      "g"
    ));
  }
  resolveScript(t) {
    var n;
    const e = ((n = t.replaceAll(/(\r\n|\r)/g, `
`).match(h(this, Fs))) == null ? void 0 : n.flatMap((s) => {
      if (!this.testTagLetml(s))
        return s;
      const o = /^([^\]]+?])(.*)$/s.exec(s);
      if (!o)
        return s;
      const [, a, l] = o;
      return [a, l];
    })) ?? [], i = { aToken: e, len: e.length, aLNum: [] };
    return x(this, Ea, mf).call(this, i), i;
  }
  testTagLetml(t) {
    return /^\[let_ml\s/.test(t);
  }
  testTagEndLetml(t) {
    return /^\[endlet_ml\s*]/.test(t);
  }
  analyzToken(t) {
    return h(this, Fs).lastIndex = 0, h(this, Fs).exec(t);
  }
  testNoTxt(t) {
    return h(this, Ul).test(t);
  }
  //4tst
}
Fs = new WeakMap(), Bs = new WeakMap(), Dl = new WeakMap(), Fl = new WeakMap(), Bl = new WeakMap(), Ke = new WeakMap(), Ul = new WeakMap(), Ea = new WeakSet(), mf = function(t, e = 0) {
  if (h(this, Ke)) {
    for (let i = t.len - 1; i >= e; --i) {
      const n = t.aToken[i];
      if (this.testNoTxt(n.at(0) ?? `
`))
        continue;
      const s = t.aLNum[i], o = n.match(h(this, Dl));
      if (!o)
        continue;
      let a = 1;
      for (let l = o.length - 1; l >= 0; --l) {
        let u = o[l];
        const c = h(this, Ke)[u.at(0) ?? " "];
        c && (u = c + (c.at(-1) === "]" ? "" : `'${u.slice(1, -1)}']`)), t.aToken.splice(i, a, u), t.aLNum.splice(i, a, s), a = 0;
      }
    }
    t.len = t.aToken.length;
  }
};
var Gl, Ta, _f, Us, Sa;
class RC {
  constructor() {
    _(this, Ta);
    // 87 match 2725 step(0.5ms) PCRE2 https://regex101.com/r/aeN57J/1
    /*
    ;[^\n]*
    |	(?<key>[^\s="'#|;]+)
    	(?: \s | ;[^\n]*\n)*
    	=
    	(?: \s | ;[^\n]*\n)*
    	(?:	(?<val> [^\s"'#|;]+)
    	|	(["'#]) (?<val2>.*?) \3 )
    	(?: \|
    		(?: (?<def> [^\s"'#;]+)
    	|	(["'#]) (?<def2>.*?) \6 ) )?
    |	(?<literal>[^\s;]+)
    	*/
    _(this, Gl, /;[^\n]*|(?<key>[^\s="'#|;]+)(?:\s|;[^\n]*\n)*=(?:\s|;[^\n]*\n)*(?:(?<val>[^\s"'#|;]+)|(["'#])(?<val2>.*?)\3)(?:\|(?:(?<def>[^\s"'#;]+)|(["'#])(?<def2>.*?)\6))?|(?<literal>[^\s;]+)/g);
    _(this, Us, {});
    _(this, Sa, !1);
  }
  // 【属性 = 値 | 省略値】の分析
  parse(t) {
    g(this, Us, {}), g(this, Sa, !1);
    for (const { groups: e } of t.matchAll(h(this, Gl))) {
      const { key: i, val: n, val2: s, def: o, def2: a, literal: l } = e;
      i ? h(this, Us)[i] = {
        val: n ?? s,
        def: o ?? a
      } : l && (l === "*" ? g(this, Sa, !0) : h(this, Us)[l] = { val: "1" });
    }
  }
  // 属性と値の位置をまとめて返す
  parseinDetail(t, e, i, n) {
    const s = {}, o = t.slice(1 + e, -1);
    for (const { groups: a, index: l, 0: u } of o.matchAll(h(this, Gl))) {
      if (l === void 0)
        continue;
      const { key: c, val: d, val2: f, literal: v } = a;
      if (v) {
        if (v.at(-1) === "=") {
          const w = v.length - 1, { ch: E } = x(this, Ta, _f).call(this, e, i, n, o, l + w);
          s[v.slice(0, -1)] = {
            k_ln: i,
            k_ch: E - w,
            v_ln: i,
            v_ch: E + 1,
            //	v_ch: ch +1+lenNm +literal.length +1,
            v_len: 0
          };
        }
        continue;
      }
      if (!c)
        continue;
      const { ln: m, ch: p } = x(this, Ta, _f).call(this, e, i, n, o, l), { ln: y, ch: b } = x(this, Ta, _f).call(this, e, i, n, o, l + u.lastIndexOf(d ?? f) - (d ? 0 : 1));
      s[c] = { k_ln: m, k_ch: p, v_ln: y, v_ch: b, v_len: d ? d.length : f.length + 2 };
    }
    return s;
  }
  get hPrm() {
    return h(this, Us);
  }
  get isKomeParam() {
    return h(this, Sa);
  }
}
Gl = new WeakMap(), Ta = new WeakSet(), _f = function(t, e, i, n, s) {
  const a = n.slice(0, s).split(`
`), l = a.length;
  return {
    ln: e + l - 1,
    ch: l < 2 ? i + 1 + t + s : a.at(-1).length
  };
}, Us = new WeakMap(), Sa = new WeakMap();
var Db = { exports: {} };
(function(r, t) {
  (function(e, i) {
    r.exports = i();
  })(typeof self < "u" ? self : uf, function() {
    return function(e) {
      var i = {};
      function n(s) {
        if (i[s])
          return i[s].exports;
        var o = i[s] = { i: s, l: !1, exports: {} };
        return e[s].call(o.exports, o, o.exports, n), o.l = !0, o.exports;
      }
      return n.m = e, n.c = i, n.d = function(s, o, a) {
        n.o(s, o) || Object.defineProperty(s, o, { configurable: !1, enumerable: !0, get: a });
      }, n.r = function(s) {
        Object.defineProperty(s, "__esModule", { value: !0 });
      }, n.n = function(s) {
        var o = s && s.__esModule ? function() {
          return s.default;
        } : function() {
          return s;
        };
        return n.d(o, "a", o), o;
      }, n.o = function(s, o) {
        return Object.prototype.hasOwnProperty.call(s, o);
      }, n.p = "", n(n.s = 0);
    }([function(e, i, n) {
      function s(T) {
        if (!(this instanceof s))
          return new s(T);
        this._ = T;
      }
      var o = s.prototype;
      function a(T, M) {
        for (var A = 0; A < T; A++)
          M(A);
      }
      function l(T, M, A) {
        return function(G, z) {
          a(z.length, function(X) {
            G(z[X], X, z);
          });
        }(function(G, z, X) {
          M = T(M, G, z, X);
        }, A), M;
      }
      function u(T, M) {
        return l(function(A, G, z, X) {
          return A.concat([T(G, z, X)]);
        }, [], M);
      }
      function c(T, M) {
        var A = { v: 0, buf: M };
        return a(T, function() {
          var G;
          A = { v: A.v << 1 | (G = A.buf, G[0] >> 7), buf: function(z) {
            var X = l(function(Y, _t, ee, Ze) {
              return Y.concat(ee === Ze.length - 1 ? Buffer.from([_t, 0]).readUInt16BE(0) : Ze.readUInt16BE(ee));
            }, [], z);
            return Buffer.from(u(function(Y) {
              return (Y << 1 & 65535) >> 8;
            }, X));
          }(A.buf) };
        }), A;
      }
      function d() {
        return typeof Buffer < "u";
      }
      function f() {
        if (!d())
          throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
      }
      function v(T) {
        f();
        var M = l(function(X, Y) {
          return X + Y;
        }, 0, T);
        if (M % 8 != 0)
          throw new Error("The bits [" + T.join(", ") + "] add up to " + M + " which is not an even number of bytes; the total should be divisible by 8");
        var A, G = M / 8, z = (A = function(X) {
          return X > 48;
        }, l(function(X, Y) {
          return X || (A(Y) ? Y : X);
        }, null, T));
        if (z)
          throw new Error(z + " bit range requested exceeds 48 bit (6 byte) Number max.");
        return new s(function(X, Y) {
          var _t = G + Y;
          return _t > X.length ? P(Y, G.toString() + " bytes") : C(_t, l(function(ee, Ze) {
            var Ge = c(Ze, ee.buf);
            return { coll: ee.coll.concat(Ge.v), buf: Ge.buf };
          }, { coll: [], buf: X.slice(Y, _t) }, T).coll);
        });
      }
      function m(T, M) {
        return new s(function(A, G) {
          return f(), G + M > A.length ? P(G, M + " bytes for " + T) : C(G + M, A.slice(G, G + M));
        });
      }
      function p(T, M) {
        if (typeof (A = M) != "number" || Math.floor(A) !== A || M < 0 || M > 6)
          throw new Error(T + " requires integer length in range [0, 6].");
        var A;
      }
      function y(T) {
        return p("uintBE", T), m("uintBE(" + T + ")", T).map(function(M) {
          return M.readUIntBE(0, T);
        });
      }
      function b(T) {
        return p("uintLE", T), m("uintLE(" + T + ")", T).map(function(M) {
          return M.readUIntLE(0, T);
        });
      }
      function w(T) {
        return p("intBE", T), m("intBE(" + T + ")", T).map(function(M) {
          return M.readIntBE(0, T);
        });
      }
      function E(T) {
        return p("intLE", T), m("intLE(" + T + ")", T).map(function(M) {
          return M.readIntLE(0, T);
        });
      }
      function O(T) {
        return T instanceof s;
      }
      function I(T) {
        return {}.toString.call(T) === "[object Array]";
      }
      function S(T) {
        return d() && Buffer.isBuffer(T);
      }
      function C(T, M) {
        return { status: !0, index: T, value: M, furthest: -1, expected: [] };
      }
      function P(T, M) {
        return I(M) || (M = [M]), { status: !1, index: -1, value: null, furthest: T, expected: M };
      }
      function R(T, M) {
        if (!M || T.furthest > M.furthest)
          return T;
        var A = T.furthest === M.furthest ? function(G, z) {
          if (function() {
            if (s._supportsSet !== void 0)
              return s._supportsSet;
            var rn = typeof Set < "u";
            return s._supportsSet = rn, rn;
          }() && Array.from) {
            for (var X = new Set(G), Y = 0; Y < z.length; Y++)
              X.add(z[Y]);
            var _t = Array.from(X);
            return _t.sort(), _t;
          }
          for (var ee = {}, Ze = 0; Ze < G.length; Ze++)
            ee[G[Ze]] = !0;
          for (var Ge = 0; Ge < z.length; Ge++)
            ee[z[Ge]] = !0;
          var en = [];
          for (var yi in ee)
            ({}).hasOwnProperty.call(ee, yi) && en.push(yi);
          return en.sort(), en;
        }(T.expected, M.expected) : M.expected;
        return { status: T.status, index: T.index, value: T.value, furthest: M.furthest, expected: A };
      }
      var N = {};
      function F(T, M) {
        if (S(T))
          return { offset: M, line: -1, column: -1 };
        T in N || (N[T] = {});
        for (var A = N[T], G = 0, z = 0, X = 0, Y = M; Y >= 0; ) {
          if (Y in A) {
            G = A[Y].line, X === 0 && (X = A[Y].lineStart);
            break;
          }
          (T.charAt(Y) === `
` || T.charAt(Y) === "\r" && T.charAt(Y + 1) !== `
`) && (z++, X === 0 && (X = Y + 1)), Y--;
        }
        var _t = G + z, ee = M - X;
        return A[M] = { line: _t, lineStart: X }, { offset: M, line: _t + 1, column: ee + 1 };
      }
      function $(T) {
        if (!O(T))
          throw new Error("not a parser: " + T);
      }
      function q(T, M) {
        return typeof T == "string" ? T.charAt(M) : T[M];
      }
      function ht(T) {
        if (typeof T != "number")
          throw new Error("not a number: " + T);
      }
      function V(T) {
        if (typeof T != "function")
          throw new Error("not a function: " + T);
      }
      function H(T) {
        if (typeof T != "string")
          throw new Error("not a string: " + T);
      }
      var Q = 2, mt = 3, et = 8, Tt = 5 * et, it = 4 * et, we = "  ";
      function Bt(T, M) {
        return new Array(M + 1).join(T);
      }
      function Dt(T, M, A) {
        var G = M - T.length;
        return G <= 0 ? T : Bt(A, G) + T;
      }
      function Ut(T, M, A, G) {
        return { from: T - M > 0 ? T - M : 0, to: T + A > G ? G : T + A };
      }
      function k(T, M) {
        var A, G, z, X, Y, _t = M.index, ee = _t.offset, Ze = 1;
        if (ee === T.length)
          return "Got the end of the input";
        if (S(T)) {
          var Ge = ee - ee % et, en = ee - Ge, yi = Ut(Ge, Tt, it + et, T.length), rn = u(function(Ne) {
            return u(function(ea) {
              return Dt(ea.toString(16), 2, "0");
            }, Ne);
          }, function(Ne, ea) {
            var ia = Ne.length, bs = [], ra = 0;
            if (ia <= ea)
              return [Ne.slice()];
            for (var na = 0; na < ia; na++)
              bs[ra] || bs.push([]), bs[ra].push(Ne[na]), (na + 1) % ea == 0 && ra++;
            return bs;
          }(T.slice(yi.from, yi.to).toJSON().data, et));
          X = function(Ne) {
            return Ne.from === 0 && Ne.to === 1 ? { from: Ne.from, to: Ne.to } : { from: Ne.from / et, to: Math.floor(Ne.to / et) };
          }(yi), G = Ge / et, A = 3 * en, en >= 4 && (A += 1), Ze = 2, z = u(function(Ne) {
            return Ne.length <= 4 ? Ne.join(" ") : Ne.slice(0, 4).join(" ") + "  " + Ne.slice(4).join(" ");
          }, rn), (Y = (8 * (X.to > 0 ? X.to - 1 : X.to)).toString(16).length) < 2 && (Y = 2);
        } else {
          var ta = T.split(/\r\n|[\n\r\u2028\u2029]/);
          A = _t.column - 1, G = _t.line - 1, X = Ut(G, Q, mt, ta.length), z = ta.slice(X.from, X.to), Y = X.to.toString().length;
        }
        var cE = G - X.from;
        return S(T) && (Y = (8 * (X.to > 0 ? X.to - 1 : X.to)).toString(16).length) < 2 && (Y = 2), l(function(Ne, ea, ia) {
          var bs, ra = ia === cE, na = ra ? "> " : we;
          return bs = S(T) ? Dt((8 * (X.from + ia)).toString(16), Y, "0") : Dt((X.from + ia + 1).toString(), Y, " "), [].concat(Ne, [na + bs + " | " + ea], ra ? [we + Bt(" ", Y) + " | " + Dt("", A, " ") + Bt("^", Ze)] : []);
        }, [], z).join(`
`);
      }
      function zt(T, M) {
        return [`
`, "-- PARSING FAILED " + Bt("-", 50), `

`, k(T, M), `

`, (A = M.expected, A.length === 1 ? `Expected:

` + A[0] : `Expected one of the following: 

` + A.join(", ")), `
`].join("");
        var A;
      }
      function lt(T) {
        return T.flags !== void 0 ? T.flags : [T.global ? "g" : "", T.ignoreCase ? "i" : "", T.multiline ? "m" : "", T.unicode ? "u" : "", T.sticky ? "y" : ""].join("");
      }
      function me() {
        for (var T = [].slice.call(arguments), M = T.length, A = 0; A < M; A += 1)
          $(T[A]);
        return s(function(G, z) {
          for (var X, Y = new Array(M), _t = 0; _t < M; _t += 1) {
            if (!(X = R(T[_t]._(G, z), X)).status)
              return X;
            Y[_t] = X.value, z = X.index;
          }
          return R(C(z, Y), X);
        });
      }
      function jt() {
        var T = [].slice.call(arguments);
        if (T.length === 0)
          throw new Error("seqMap needs at least one argument");
        var M = T.pop();
        return V(M), me.apply(null, T).map(function(A) {
          return M.apply(null, A);
        });
      }
      function Z() {
        var T = [].slice.call(arguments), M = T.length;
        if (M === 0)
          return U("zero alternates");
        for (var A = 0; A < M; A += 1)
          $(T[A]);
        return s(function(G, z) {
          for (var X, Y = 0; Y < T.length; Y += 1)
            if ((X = R(T[Y]._(G, z), X)).status)
              return X;
          return X;
        });
      }
      function be(T, M) {
        return ft(T, M).or(Et([]));
      }
      function ft(T, M) {
        return $(T), $(M), jt(T, M.then(T).many(), function(A, G) {
          return [A].concat(G);
        });
      }
      function B(T) {
        H(T);
        var M = "'" + T + "'";
        return s(function(A, G) {
          var z = G + T.length, X = A.slice(G, z);
          return X === T ? C(z, X) : P(G, M);
        });
      }
      function at(T, M) {
        (function(z) {
          if (!(z instanceof RegExp))
            throw new Error("not a regexp: " + z);
          for (var X = lt(z), Y = 0; Y < X.length; Y++) {
            var _t = X.charAt(Y);
            if (_t !== "i" && _t !== "m" && _t !== "u" && _t !== "s")
              throw new Error('unsupported regexp flag "' + _t + '": ' + z);
          }
        })(T), arguments.length >= 2 ? ht(M) : M = 0;
        var A = function(z) {
          return RegExp("^(?:" + z.source + ")", lt(z));
        }(T), G = "" + T;
        return s(function(z, X) {
          var Y = A.exec(z.slice(X));
          if (Y) {
            if (0 <= M && M <= Y.length) {
              var _t = Y[0], ee = Y[M];
              return C(X + _t.length, ee);
            }
            return P(X, "valid match group (0 to " + Y.length + ") in " + G);
          }
          return P(X, G);
        });
      }
      function Et(T) {
        return s(function(M, A) {
          return C(A, T);
        });
      }
      function U(T) {
        return s(function(M, A) {
          return P(A, T);
        });
      }
      function Re(T) {
        if (O(T))
          return s(function(M, A) {
            var G = T._(M, A);
            return G.index = A, G.value = "", G;
          });
        if (typeof T == "string")
          return Re(B(T));
        if (T instanceof RegExp)
          return Re(at(T));
        throw new Error("not a string, regexp, or parser: " + T);
      }
      function pi(T) {
        return $(T), s(function(M, A) {
          var G = T._(M, A), z = M.slice(A, G.index);
          return G.status ? P(A, 'not "' + z + '"') : C(A, null);
        });
      }
      function ke(T) {
        return V(T), s(function(M, A) {
          var G = q(M, A);
          return A < M.length && T(G) ? C(A + 1, G) : P(A, "a character/byte matching " + T);
        });
      }
      function ki(T, M) {
        arguments.length < 2 && (M = T, T = void 0);
        var A = s(function(G, z) {
          return A._ = M()._, A._(G, z);
        });
        return T ? A.desc(T) : A;
      }
      function Ni() {
        return U("fantasy-land/empty");
      }
      o.parse = function(T) {
        if (typeof T != "string" && !S(T))
          throw new Error(".parse must be called with a string or Buffer as its argument");
        var M, A = this.skip(ce)._(T, 0);
        return M = A.status ? { status: !0, value: A.value } : { status: !1, index: F(T, A.furthest), expected: A.expected }, delete N[T], M;
      }, o.tryParse = function(T) {
        var M = this.parse(T);
        if (M.status)
          return M.value;
        var A = zt(T, M), G = new Error(A);
        throw G.type = "ParsimmonError", G.result = M, G;
      }, o.assert = function(T, M) {
        return this.chain(function(A) {
          return T(A) ? Et(A) : U(M);
        });
      }, o.or = function(T) {
        return Z(this, T);
      }, o.trim = function(T) {
        return this.wrap(T, T);
      }, o.wrap = function(T, M) {
        return jt(T, this, M, function(A, G) {
          return G;
        });
      }, o.thru = function(T) {
        return T(this);
      }, o.then = function(T) {
        return $(T), me(this, T).map(function(M) {
          return M[1];
        });
      }, o.many = function() {
        var T = this;
        return s(function(M, A) {
          for (var G = [], z = void 0; ; ) {
            if (!(z = R(T._(M, A), z)).status)
              return R(C(A, G), z);
            if (A === z.index)
              throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
            A = z.index, G.push(z.value);
          }
        });
      }, o.tieWith = function(T) {
        return H(T), this.map(function(M) {
          if (function(z) {
            if (!I(z))
              throw new Error("not an array: " + z);
          }(M), M.length) {
            H(M[0]);
            for (var A = M[0], G = 1; G < M.length; G++)
              H(M[G]), A += T + M[G];
            return A;
          }
          return "";
        });
      }, o.tie = function() {
        return this.tieWith("");
      }, o.times = function(T, M) {
        var A = this;
        return arguments.length < 2 && (M = T), ht(T), ht(M), s(function(G, z) {
          for (var X = [], Y = void 0, _t = void 0, ee = 0; ee < T; ee += 1) {
            if (_t = R(Y = A._(G, z), _t), !Y.status)
              return _t;
            z = Y.index, X.push(Y.value);
          }
          for (; ee < M && (_t = R(Y = A._(G, z), _t), Y.status); ee += 1)
            z = Y.index, X.push(Y.value);
          return R(C(z, X), _t);
        });
      }, o.result = function(T) {
        return this.map(function() {
          return T;
        });
      }, o.atMost = function(T) {
        return this.times(0, T);
      }, o.atLeast = function(T) {
        return jt(this.times(T), this.many(), function(M, A) {
          return M.concat(A);
        });
      }, o.map = function(T) {
        V(T);
        var M = this;
        return s(function(A, G) {
          var z = M._(A, G);
          return z.status ? R(C(z.index, T(z.value)), z) : z;
        });
      }, o.contramap = function(T) {
        V(T);
        var M = this;
        return s(function(A, G) {
          var z = M.parse(T(A.slice(G)));
          return z.status ? C(G + A.length, z.value) : z;
        });
      }, o.promap = function(T, M) {
        return V(T), V(M), this.contramap(T).map(M);
      }, o.skip = function(T) {
        return me(this, T).map(function(M) {
          return M[0];
        });
      }, o.mark = function() {
        return jt(ri, this, ri, function(T, M, A) {
          return { start: T, value: M, end: A };
        });
      }, o.node = function(T) {
        return jt(ri, this, ri, function(M, A, G) {
          return { name: T, value: A, start: M, end: G };
        });
      }, o.sepBy = function(T) {
        return be(this, T);
      }, o.sepBy1 = function(T) {
        return ft(this, T);
      }, o.lookahead = function(T) {
        return this.skip(Re(T));
      }, o.notFollowedBy = function(T) {
        return this.skip(pi(T));
      }, o.desc = function(T) {
        I(T) || (T = [T]);
        var M = this;
        return s(function(A, G) {
          var z = M._(A, G);
          return z.status || (z.expected = T), z;
        });
      }, o.fallback = function(T) {
        return this.or(Et(T));
      }, o.ap = function(T) {
        return jt(T, this, function(M, A) {
          return M(A);
        });
      }, o.chain = function(T) {
        var M = this;
        return s(function(A, G) {
          var z = M._(A, G);
          return z.status ? R(T(z.value)._(A, z.index), z) : z;
        });
      }, o.concat = o.or, o.empty = Ni, o.of = Et, o["fantasy-land/ap"] = o.ap, o["fantasy-land/chain"] = o.chain, o["fantasy-land/concat"] = o.concat, o["fantasy-land/empty"] = o.empty, o["fantasy-land/of"] = o.of, o["fantasy-land/map"] = o.map;
      var ri = s(function(T, M) {
        return C(M, F(T, M));
      }), Sr = s(function(T, M) {
        return M >= T.length ? P(M, "any character/byte") : C(M + 1, q(T, M));
      }), Ee = s(function(T, M) {
        return C(T.length, T.slice(M));
      }), ce = s(function(T, M) {
        return M < T.length ? P(M, "EOF") : C(M, null);
      }), Vt = at(/[0-9]/).desc("a digit"), Rt = at(/[0-9]*/).desc("optional digits"), vi = at(/[a-z]/i).desc("a letter"), aE = at(/[a-z]*/i).desc("optional letters"), hE = at(/\s*/).desc("optional whitespace"), lE = at(/\s+/).desc("whitespace"), $_ = B("\r"), z_ = B(`
`), V_ = B(`\r
`), X_ = Z(V_, z_, $_).desc("newline"), uE = Z(X_, ce);
      s.all = Ee, s.alt = Z, s.any = Sr, s.cr = $_, s.createLanguage = function(T) {
        var M = {};
        for (var A in T)
          ({}).hasOwnProperty.call(T, A) && function(G) {
            M[G] = ki(function() {
              return T[G](M);
            });
          }(A);
        return M;
      }, s.crlf = V_, s.custom = function(T) {
        return s(T(C, P));
      }, s.digit = Vt, s.digits = Rt, s.empty = Ni, s.end = uE, s.eof = ce, s.fail = U, s.formatError = zt, s.index = ri, s.isParser = O, s.lazy = ki, s.letter = vi, s.letters = aE, s.lf = z_, s.lookahead = Re, s.makeFailure = P, s.makeSuccess = C, s.newline = X_, s.noneOf = function(T) {
        return ke(function(M) {
          return T.indexOf(M) < 0;
        }).desc("none of '" + T + "'");
      }, s.notFollowedBy = pi, s.of = Et, s.oneOf = function(T) {
        for (var M = T.split(""), A = 0; A < M.length; A++)
          M[A] = "'" + M[A] + "'";
        return ke(function(G) {
          return T.indexOf(G) >= 0;
        }).desc(M);
      }, s.optWhitespace = hE, s.Parser = s, s.range = function(T, M) {
        return ke(function(A) {
          return T <= A && A <= M;
        }).desc(T + "-" + M);
      }, s.regex = at, s.regexp = at, s.sepBy = be, s.sepBy1 = ft, s.seq = me, s.seqMap = jt, s.seqObj = function() {
        for (var T, M = {}, A = 0, G = (T = arguments, Array.prototype.slice.call(T)), z = G.length, X = 0; X < z; X += 1) {
          var Y = G[X];
          if (!O(Y)) {
            if (I(Y) && Y.length === 2 && typeof Y[0] == "string" && O(Y[1])) {
              var _t = Y[0];
              if (Object.prototype.hasOwnProperty.call(M, _t))
                throw new Error("seqObj: duplicate key " + _t);
              M[_t] = !0, A++;
              continue;
            }
            throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
          }
        }
        if (A === 0)
          throw new Error("seqObj expects at least one named parser, found zero");
        return s(function(ee, Ze) {
          for (var Ge, en = {}, yi = 0; yi < z; yi += 1) {
            var rn, ta;
            if (I(G[yi]) ? (rn = G[yi][0], ta = G[yi][1]) : (rn = null, ta = G[yi]), !(Ge = R(ta._(ee, Ze), Ge)).status)
              return Ge;
            rn && (en[rn] = Ge.value), Ze = Ge.index;
          }
          return R(C(Ze, en), Ge);
        });
      }, s.string = B, s.succeed = Et, s.takeWhile = function(T) {
        return V(T), s(function(M, A) {
          for (var G = A; G < M.length && T(q(M, G)); )
            G++;
          return C(G, M.slice(A, G));
        });
      }, s.test = ke, s.whitespace = lE, s["fantasy-land/empty"] = Ni, s["fantasy-land/of"] = Et, s.Binary = { bitSeq: v, bitSeqObj: function(T) {
        f();
        var M = {}, A = 0, G = u(function(X) {
          if (I(X)) {
            var Y = X;
            if (Y.length !== 2)
              throw new Error("[" + Y.join(", ") + "] should be length 2, got length " + Y.length);
            if (H(Y[0]), ht(Y[1]), Object.prototype.hasOwnProperty.call(M, Y[0]))
              throw new Error("duplicate key in bitSeqObj: " + Y[0]);
            return M[Y[0]] = !0, A++, Y;
          }
          return ht(X), [null, X];
        }, T);
        if (A < 1)
          throw new Error("bitSeqObj expects at least one named pair, got [" + T.join(", ") + "]");
        var z = u(function(X) {
          return X[0];
        }, G);
        return v(u(function(X) {
          return X[1];
        }, G)).map(function(X) {
          return l(function(Y, _t) {
            return _t[0] !== null && (Y[_t[0]] = _t[1]), Y;
          }, {}, u(function(Y, _t) {
            return [Y, X[_t]];
          }, z));
        });
      }, byte: function(T) {
        if (f(), ht(T), T > 255)
          throw new Error("Value specified to byte constructor (" + T + "=0x" + T.toString(16) + ") is larger in value than a single byte.");
        var M = (T > 15 ? "0x" : "0x0") + T.toString(16);
        return s(function(A, G) {
          var z = q(A, G);
          return z === T ? C(G + 1, z) : P(G, M);
        });
      }, buffer: function(T) {
        return m("buffer", T).map(function(M) {
          return Buffer.from(M);
        });
      }, encodedString: function(T, M) {
        return m("string", M).map(function(A) {
          return A.toString(T);
        });
      }, uintBE: y, uint8BE: y(1), uint16BE: y(2), uint32BE: y(4), uintLE: b, uint8LE: b(1), uint16LE: b(2), uint32LE: b(4), intBE: w, int8BE: w(1), int16BE: w(2), int32BE: w(4), intLE: E, int8LE: E(1), int16LE: E(2), int32LE: E(4), floatBE: m("floatBE", 4).map(function(T) {
        return T.readFloatBE(0);
      }), floatLE: m("floatLE", 4).map(function(T) {
        return T.readFloatLE(0);
      }), doubleBE: m("doubleBE", 8).map(function(T) {
        return T.readDoubleBE(0);
      }), doubleLE: m("doubleLE", 8).map(function(T) {
        return T.readDoubleLE(0);
      }) }, e.exports = s;
    }]);
  });
})(Db);
var Gt = Db.exports, Gs, dt, vt, tr, ln, Ms, hd, jl, Zy, ld, ud, Fb;
const j_ = class {
  constructor(t, e = "\\") {
    _(this, dt);
    _(this, ln);
    _(this, jl);
    _(this, Gs, null);
    _(this, tr, {
      "!num!": (t) => t.shift(),
      "!str!": (t) => x(this, jl, Zy).call(this, t.shift()),
      "!bool!": (t) => t.shift(),
      PostfixInc: (t) => {
        throw Error("(PropParser)後置インクリメントは未サポートです");
      },
      PostfixDec: (t) => {
        throw Error("(PropParser)後置デクリメントは未サポートです");
      },
      PrefixInc: (t) => {
        throw Error("(PropParser)前置インクリメントは未サポートです");
      },
      PrefixDec: (t) => {
        throw Error("(PropParser)前置デクリメントは未サポートです");
      },
      // 論理 NOT
      "!": (t) => !h(this, tr).Boolean(t),
      // チルダ演算子（ビット反転）
      "~": (t) => ~Number(x(this, dt, vt).call(this, t.shift())),
      //		UnaryNegate:	a=> - Number(this.#calc(a.shift())),
      UnaryNegate: (t) => -h(this, tr).Number(t),
      //	Unaryplus:		a=> this.#hFnc['Number'](a),
      // 乗算、除算、剰余
      "**": (t) => Number(x(this, dt, vt).call(this, t.shift())) ** Number(x(this, dt, vt).call(this, t.shift())),
      "*": (t) => Number(x(this, dt, vt).call(this, t.shift())) * Number(x(this, dt, vt).call(this, t.shift())),
      "/": (t) => Number(x(this, dt, vt).call(this, t.shift())) / Number(x(this, dt, vt).call(this, t.shift())),
      "¥": (t) => Math.floor(h(this, tr)["/"](t)),
      "%": (t) => Number(x(this, dt, vt).call(this, t.shift())) % Number(x(this, dt, vt).call(this, t.shift())),
      // 加算、減算、文字列の連結
      "+": (t) => {
        const e = x(this, dt, vt).call(this, t.shift()), i = x(this, dt, vt).call(this, t.shift());
        return Object.prototype.toString.call(e) === "[object String]" || Object.prototype.toString.call(i) === "[object String]" ? String(e) + String(i) : Number(e) + Number(i);
      },
      "-": (t) => Number(x(this, dt, vt).call(this, t.shift())) - Number(x(this, dt, vt).call(this, t.shift())),
      // 関数
      int: (t) => Ue(x(this, ln, Ms).call(this, t.shift())),
      parseInt: (t) => Ue(h(this, tr).Number(t)),
      Number: (t) => {
        const e = x(this, dt, vt).call(this, t.shift());
        return Object.prototype.toString.call(e) === "[object String]" ? x(this, ln, Ms).call(this, h(this, Gs).parse(String(e)).value) : Number(e);
      },
      Boolean: (t) => {
        const e = t.shift();
        return e[0] === "!bool!" ? !!e[1] : !!x(this, dt, vt).call(this, e);
      },
      ceil: (t) => Math.ceil(x(this, ln, Ms).call(this, t.shift())),
      floor: (t) => Math.floor(x(this, ln, Ms).call(this, t.shift())),
      round: (t) => Math.round(x(this, ln, Ms).call(this, t.shift())),
      isNaN: (t) => Number.isNaN(x(this, ln, Ms).call(this, t.shift())),
      // ビットシフト
      "<<": (t) => Number(x(this, dt, vt).call(this, t.shift())) << Number(x(this, dt, vt).call(this, t.shift())),
      ">>": (t) => Number(x(this, dt, vt).call(this, t.shift())) >> Number(x(this, dt, vt).call(this, t.shift())),
      ">>>": (t) => Number(x(this, dt, vt).call(this, t.shift())) >>> Number(x(this, dt, vt).call(this, t.shift())),
      // 等値、非等値、厳密等価、厳密非等価
      "<": (t) => Number(x(this, dt, vt).call(this, t.shift())) < Number(x(this, dt, vt).call(this, t.shift())),
      "<=": (t) => Number(x(this, dt, vt).call(this, t.shift())) <= Number(x(this, dt, vt).call(this, t.shift())),
      ">": (t) => Number(x(this, dt, vt).call(this, t.shift())) > Number(x(this, dt, vt).call(this, t.shift())),
      ">=": (t) => Number(x(this, dt, vt).call(this, t.shift())) >= Number(x(this, dt, vt).call(this, t.shift())),
      // 小なり、以下、大なり、以上
      "==": (t) => {
        const e = x(this, dt, vt).call(this, t.shift()), i = x(this, dt, vt).call(this, t.shift());
        return e == null && i == null && (!e || !i) ? e == i : String(e) === String(i);
      },
      "!=": (t) => !h(this, tr)["=="](t),
      "===": (t) => {
        const e = x(this, dt, vt).call(this, t.shift()), i = x(this, dt, vt).call(this, t.shift());
        return Object.prototype.toString.call(e) != Object.prototype.toString.call(i) ? !1 : String(e) === String(i);
      },
      "!==": (t) => !h(this, tr)["==="](t),
      // ビット演算子
      "&": (t) => Number(x(this, dt, vt).call(this, t.shift())) & Number(x(this, dt, vt).call(this, t.shift())),
      "^": (t) => Number(x(this, dt, vt).call(this, t.shift())) ^ Number(x(this, dt, vt).call(this, t.shift())),
      "|": (t) => Number(x(this, dt, vt).call(this, t.shift())) | Number(x(this, dt, vt).call(this, t.shift())),
      // 論理 AND,OR
      "&&": (t) => String(x(this, dt, vt).call(this, t.shift())) === "true" && String(x(this, dt, vt).call(this, t.shift())) === "true",
      "||": (t) => String(x(this, dt, vt).call(this, t.shift())) === "true" || String(x(this, dt, vt).call(this, t.shift())) === "true",
      // 条件
      "?": (t) => {
        const e = h(this, tr).Boolean(t), i = t.shift();
        if (i[0] !== ":")
          throw Error("(PropParser)三項演算子の文法エラーです。: が見つかりません");
        return x(this, dt, vt).call(this, i[e ? 1 : 2]);
      },
      ":": () => {
        throw Error("(PropParser)三項演算子の文法エラーです。? が見つかりません");
      }
    });
    _(this, hd, /(\$((tmp|sys|save|mp):)?[^\s!--\/:-@[-^`{-~]+|\#\{[^\}]+})/g);
    D(this, "getValAmpersand", (t) => t.at(0) === "&" ? String(this.parse(t.slice(1))) : t);
    this.val = t;
    function i(w) {
      const E = [];
      for (const O of w)
        E.push(
          (typeof O == "string" ? Gt.string(O) : Gt.regex(O)).trim(Gt.optWhitespace)
        );
      return Gt.alt.apply(null, E);
    }
    function n(w) {
      let O = Object.keys(w).sort().map(
        (I) => (typeof w[I] == "string" ? Gt.string(w[I]) : Gt.regex(w[I])).trim(Gt.optWhitespace).result(I)
      );
      return Gt.alt.apply(null, O);
    }
    function s(w, E) {
      const O = Gt.lazy(() => Gt.seq(w, O).or(E));
      return O;
    }
    function o(w, E) {
      return Gt.seqMap(E, w.many(), (O, I) => I.reduce((S, C) => [C, S], O));
    }
    function a(w, E) {
      let O = Gt.lazy(
        () => E.chain(
          (I) => Gt.seq(
            w,
            Gt.of(I),
            O
          ).or(Gt.of(I))
        )
      );
      return O;
    }
    function l(w, E) {
      return Gt.seqMap(
        E,
        Gt.seq(w, E).many(),
        (O, I) => I.reduce((S, C) => [C[0], S, C[1]], O)
      );
    }
    const u = Gt.alt(
      Gt.alt(
        Gt.regex(/-?(0|[1-9][0-9]*)\.[0-9]+/),
        Gt.regex(/0x[0-9a-fA-F]+/)
      ).map(Number),
      Gt.alt(
        Gt.regex(/-?(0|[1-9][0-9]*)/)
      ).map((w) => Ue(w))
    ).map((w) => ["!num!", w]).desc("number"), c = Gt.string("null").map(() => ["!str!", null]), d = Gt.regex(/(true|false)/).map((w) => ["!bool!", w === "true"]).desc("boolean"), f = Gt.regex(new RegExp(`(?:"(?:\\${e}["'#\\n]|[^"])*"|'(?:\\${e}["'#\\n]|[^'])*'|\\#(?:\\${e}["'#\\n]|[^#])*\\#)`)).map((w) => ["!str!", w.slice(1, -1).replaceAll(e, "")]).desc("string"), v = /\[[^\]]+\]/g, m = Gt.regex(/-?(?:(?:tmp|sys|save|mp):)?[^\s!-\/:-@[-^`{-~]+(?:\.[^\s!-\/:-@[-^`{-~]+|\[[^\]]+\])*(?:@str)?/).map((w) => {
      const E = String(w).replaceAll(
        v,
        (I) => "." + this.parse(I.slice(1, -1))
      ), O = this.val.getVal(E);
      return O == null ? ["!str!", O] : typeof O == "boolean" ? ["!bool!", O] : Object.prototype.toString.call(O) === "[object String]" ? ["!str!", String(O)] : ["!num!", Number(O)];
    }).desc("string"), p = Gt.lazy(
      () => Gt.string("(").then(h(this, Gs)).skip(Gt.string(")")).or(u).or(c).or(d).or(f).or(m)
    ), b = [
      // 演算子の優先順位 - JavaScript | MDN https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Operator_precedence
      // 優先順位：18（メンバーへのアクセス、計算値によるメンバーへのアクセス）
      // a.b  a[b]
      { type: s, ops: i([/[A-Za-z_][A-Za-z0-9_]*(?=\()/]) },
      // 優先順位：16
      { type: o, ops: n({ PostfixInc: "++" }) },
      { type: o, ops: n({ PostfixDec: "--" }) },
      // 【未サポート】後置インクリメント・デクリメント
      // 優先順位：15
      { type: s, ops: i([/!(?!=)|~/]) },
      // 論理 NOT (!)、ビット単位 NOT (~)
      { type: s, ops: n({ PrefixInc: "++" }) },
      { type: s, ops: n({ PrefixDec: "--" }) },
      // 【未サポート】前置インクリメント・デクリメント
      //	{type: PREFIX, ops: opeH({Unaryplus: /\+(?!\+)/})},	// 単項プラス
      { type: s, ops: n({ UnaryNegate: /-(?!-)/ }) },
      // 単項マイナス
      // 優先順位：14以下（並びに注意）
      { type: a, ops: i(["**"]) },
      { type: l, ops: i(["*", "/", "¥", "%"]) },
      { type: l, ops: i(["+", "-"]) },
      { type: l, ops: i([/>>>|<<|>>/]) },
      { type: l, ops: i([/<=|<|>=|>/]) },
      { type: l, ops: i([/===|!==|==|!=/]) },
      { type: l, ops: i([/&(?!&)/]) },
      { type: l, ops: i(["^"]) },
      { type: l, ops: i([/\|(?!\|)/]) },
      { type: l, ops: i(["&&"]) },
      { type: l, ops: i(["||"]) },
      { type: a, ops: i([":"]) },
      { type: a, ops: i(["?"]) }
    ].reduce(
      (w, E) => E.type(E.ops, w),
      p
    );
    g(this, Gs, b.trim(Gt.optWhitespace));
  }
  parse(t) {
    const e = h(this, Gs).parse(t);
    if (!e.status)
      throw Error("(PropParser)文法エラー【" + t + "】");
    const i = e.value;
    return i[0] === "!str!" ? x(this, jl, Zy).call(this, i[1]) : x(this, dt, vt).call(this, i);
  }
  // 522 match 18413 step(~10ms) https://regex101.com/r/tmCKuE/1
  // →これは改良しようがない。いい意味で改善の余地なし
  static getValName(t) {
    var a;
    const e = h(this, ld).exec(t.trim()), i = e == null ? void 0 : e.groups;
    if (!i)
      return null;
    const { scope: n = "tmp", name: s, at: o = "" } = i;
    return {
      scope: n,
      name: x(a = j_, ud, Fb).call(a, s),
      at: o
    };
  }
};
let Ls = j_;
Gs = new WeakMap(), dt = new WeakSet(), vt = function(t) {
  const e = t.shift();
  if (e instanceof Array)
    return x(this, dt, vt).call(this, e);
  const i = h(this, tr)[e];
  return i ? i(t) : Object(null);
}, tr = new WeakMap(), ln = new WeakSet(), Ms = function(t) {
  const e = x(this, dt, vt).call(this, t);
  if (Object.prototype.toString.call(e) !== "[object Number]")
    throw Error("(PropParser)引数【" + e + "】が数値ではありません");
  return Number(e);
}, hd = new WeakMap(), jl = new WeakSet(), Zy = function(t) {
  return t == null ? t : String(t).replaceAll(
    h(this, hd),
    (e) => e.at(0) === "$" ? this.val.getVal(e.slice(1)) : this.parse(e.slice(2, -1))
  );
}, ld = new WeakMap(), ud = new WeakSet(), Fb = function(t) {
  let e = 0, i = 0;
  for (; ; ) {
    if (e = t.indexOf('["'), e < 0) {
      if (e = t.indexOf("['"), e < 0)
        break;
      i = t.indexOf("']", e + 2);
    } else
      i = t.indexOf('"]', e + 2);
    if (i < 0)
      break;
    t = t.slice(0, e) + "." + t.slice(e + 2, i) + t.slice(i + 2), e = i - 2;
  }
  return t;
}, _(Ls, ud), _(Ls, ld, /^((?<scope>\w+?):)?(?<name>[^\s :@]+)(?<at>\@str)?$/);
var er, js, Pa, ir, Hl, cd, Bb, fd, Ub, dd, Gb, pd, jb;
const $t = class {
  constructor(t, e, i) {
    _(this, cd);
    _(this, fd);
    // ログ出力
    _(this, Hl, !0);
    this.sys = t, g($t, er, i), g($t, js, e), g($t, Pa, e.title), $t.myTrace = x($t, dd, Gb), e.log = (n) => x(this, cd, Bb).call(this, n), e.trace = (n) => x(this, fd, Ub).call(this, n), g($t, ir, document.createElement("span")), h($t, ir).hidden = !0, h($t, ir).textContent = "", h($t, ir).style.cssText = `	z-index: ${Number.MAX_SAFE_INTEGER};
			position: absolute; left: 0; top: 0;
			color: black;
			background-color: rgba(255, 255, 255, 0.7);`, document.body.appendChild(h($t, ir));
  }
  destroy() {
    g($t, Pa, () => !1), document.body.removeChild(h($t, ir)), $t.myTrace = $t.trace_beforeNew;
  }
  // private禁止、galleryでエラーになる
  static trace_beforeNew(t, e = "E") {
    let i = `{${e}} ` + t, n = "";
    switch (e) {
      case "D":
        n = `color:#${L.isDarkMode ? "49F" : "05A"};`;
        break;
      case "W":
        n = "color:#FF8800;";
        break;
      case "F":
        n = "color:#BB0000;";
        break;
      case "ET":
        throw i;
      case "E":
        console.error("%c" + i, "color:#FF3300;");
        return;
      default:
        n = "color:black;", i = " " + i;
    }
    console.info("%c" + i, n);
  }
};
let wt = $t;
er = new WeakMap(), js = new WeakMap(), Pa = new WeakMap(), ir = new WeakMap(), Hl = new WeakMap(), cd = new WeakSet(), Bb = function(t) {
  let e = "";
  return h(this, Hl) && (g(this, Hl, !1), e = `== ${S0.description} ==
`), this.sys.appendFile(
    this.sys.path_downloads + "log.txt",
    `${e}--- ${xl("-", "_", "")} [fn:${h($t, er).scriptFn} line:${h($t, er).lineNum}] prj:${this.sys.cur}
${t.text || `(text is ${t.text})`}
`,
    (i) => {
      i && console.log(i);
    }
  ), !1;
}, fd = new WeakSet(), Ub = function(t) {
  return $t.myTrace(t.text || `(text is ${t.text})`, "I"), !1;
}, dd = new WeakSet(), Gb = function(t, e = "E") {
  var s, o;
  let i = `{${e}} ` + $t.strPos() + t;
  x(s = $t, pd, jb).call(s, i, e);
  let n = "";
  switch (e) {
    case "D":
      n = `color:#${L.isDarkMode ? "49F" : "05A"};`;
      break;
    case "W":
      n = "color:#F80;";
      break;
    case "F":
      n = "color:#B00;";
      break;
    case "ET":
    case "E":
      if (h(o = $t, Pa).call(o, { text: t }), h(this, js).dump_lay({}), h(this, js).dump_val({}), h($t, er).dumpErrForeLine(), h(this, js).dump_stack({}), e === "ET")
        throw i;
      console.error("%c" + i, "color:#F30;");
      return;
    default:
      n = "", i = " " + i;
  }
  console.info("%c" + i, n);
}, pd = new WeakSet(), jb = function(t, e) {
  let i = "";
  switch (e) {
    case "D":
      i = "color:#05A;";
      break;
    case "W":
      i = "color:#F80;";
      break;
    case "F":
      i = "color:#B00;";
      break;
    case "ET":
    case "E":
      i = "color:#F30;";
      break;
    default:
      i = "";
  }
  h($t, ir).innerHTML += `<span style='${i}'>${t}</span><br/>`, h($t, ir).hidden = !1;
}, _(wt, dd), _(wt, pd), _(wt, er, void 0), _(wt, js, void 0), _(wt, Pa, void 0), _(wt, ir, void 0), D(wt, "myTrace", $t.trace_beforeNew), D(wt, "strPos", () => h($t, er) && h($t, er).lineNum > 0 ? `(fn:${h($t, er).scriptFn} line:${h($t, er).lineNum}) ` : "");
class Qg {
  constructor() {
    D(this, "hAreas", /* @__PURE__ */ Object.create(null));
  }
  clear() {
    this.hAreas = {};
  }
  search(t) {
    return Object.entries(this.hAreas).some(([e, i]) => t >= parseInt(e) && t <= i);
  }
  record(t) {
    if (!this.search(t)) {
      for (const [e, i] of Object.entries(this.hAreas))
        if (i + 1 === t) {
          String(t + 1) in this.hAreas ? (this.hAreas[e] = this.hAreas[t + 1], delete this.hAreas[t + 1]) : this.hAreas[e] = t;
          return;
        }
      if (String(t + 1) in this.hAreas) {
        this.hAreas[t] = this.hAreas[t + 1], delete this.hAreas[t + 1];
        return;
      }
      this.hAreas[t] = t;
    }
  }
  erase(t) {
    if (this.search(t)) {
      if (String(t) in this.hAreas) {
        this.hAreas[t] > t && (this.hAreas[t + 1] = this.hAreas[t]), delete this.hAreas[t];
        return;
      }
      for (const [e, i] of Object.entries(this.hAreas))
        if (!(t < parseInt(e) || i < t)) {
          if (this.hAreas[e] === t) {
            this.hAreas[e] = t - 1;
            return;
          }
          this.hAreas[t + 1] = i, this.hAreas[e] = t - 1;
          return;
        }
    }
  }
  get count() {
    return Object.keys(this.hAreas).length;
  }
  // 4tst
  toString() {
    let t = ",";
    for (const e of Object.keys(this.hAreas).map((i) => parseInt(i)).sort((i, n) => i - n))
      t += e === this.hAreas[e] ? "," + e : "," + e + "~" + this.hAreas[e];
    return t.slice(1);
  }
}
var Ae, Li, ie, un, Se, gi, Or, $l, vd, zl, Ky, Vl, Xl, yd, Hb, md, $b, Di, Pr, _d, zb, gd, Vb, bd, Xb, xd, Wb, wd, Yb, Ed, qb, Td, Zb, Sd, Kb, Oa, bf, Wl, Jy, Yl, Hs, ql, Qy, Pd, Od, Ia, Zl, Ca, xf, Id, Jb, Cd, Qb, Kl, tm, Jl, em, Md, tx, Rd, ex, Ma, wf;
const _a = class {
  constructor(t, e) {
    _(this, zl);
    //	// しおり
    // しおりの複写
    _(this, yd);
    // しおりの消去
    _(this, md);
    //	//	変数操作
    // 変数代入・演算
    _(this, Di);
    // 絶対値
    _(this, _d);
    // 文字列から一字取りだし
    _(this, gd);
    // 文字列で検索
    _(this, bd);
    // 文字列の長さ
    _(this, xd);
    // 正規表現で置換
    _(this, wd);
    // 四捨五入
    _(this, Ed);
    // 正規表現で検索
    _(this, Td);
    // 文字列から抜きだし
    _(this, Sd);
    //	// デバッグ・その他
    // システム変数の全消去
    _(this, Oa);
    // ゲーム変数の全消去
    _(this, Wl);
    _(this, ql);
    _(this, Ca);
    _(this, Id);
    _(this, Cd);
    _(this, Kl);
    _(this, Jl);
    _(this, Md);
    _(this, Rd);
    _(this, Ma);
    _(this, Ae, { sys: {}, save: {}, tmp: {}, mp: {} });
    _(this, Li, h(this, Ae).save);
    _(this, ie, h(this, Ae).tmp);
    _(this, un, void 0);
    _(this, Se, { sys: {}, mark: {}, kidoku: {} });
    _(this, gi, void 0);
    _(this, Or, {});
    _(this, $l, void 0);
    _(this, vd, {
      auth: (t, e) => x(this, zl, Ky).call(this, e.hBreakpoint.aData),
      var: (t, e) => h(this, un).send2Dbg(e.ri, { v: h(this, Ae)[e.scope] ?? {} }),
      set_var: (t, e) => {
        try {
          h(this, Yl).call(this, e.nm, e.val), h(this, un).send2Dbg(e.ri, {});
        } catch {
        }
      },
      set_data_break: (t, e) => {
        x(this, zl, Ky).call(this, e.a), h(this, un).send2Dbg(e.ri, {});
      },
      disconnect: (t) => g(_a, Hs, {})
    });
    _(this, Vl, () => {
    });
    _(this, Xl, (t) => {
    });
    D(this, "getMark", (t) => h(this, Se).mark[t]);
    D(this, "getAreaKidoku", (t) => h(this, Or)[t]);
    _(this, Yl, (t, e, i = !0) => {
      if (!t)
        throw "[変数に値セット] nameは必須です";
      if (e == null)
        throw "[変数に値セット] textは必須です（空文字はOK）";
      const n = Ls.getValName(t);
      if (n === null)
        throw "[変数参照] name(" + t + ")が変数名として異常です";
      const s = h(this, Ae)[n.scope];
      if (!s)
        throw "[変数に値セット] scopeが異常【" + n.scope + "】です";
      const o = n.name;
      if (o.slice(0, 6) === "const." && o in s)
        throw "[変数に値セット] 変数【" + o + "】は書き換え不可です";
      this.setVal_Nochk(n.scope, o, e, i);
    });
    D(this, "getVal", (t, e) => {
      if (!t)
        throw "[変数参照] nameは必須です";
      const i = Ls.getValName(t);
      if (i === null)
        throw "[変数参照] name(" + t + ")が変数名として異常です";
      const n = h(this, Ae)[i.scope];
      if (!n)
        throw "[変数参照] scopeが異常【" + i.scope + "】です";
      const s = i.name;
      let o = n[s];
      if (!(s in n)) {
        o = e;
        let a = "";
        const l = s.split("."), u = l.length;
        for (let c = 0; c < u; ++c, a += ".") {
          if (a += l[c], !(a in n))
            continue;
          let d = JSON.parse(n[a]);
          if (Object.prototype.toString.call(d) !== "[object Object]") {
            if (c + 1 === u) {
              o = d;
              break;
            }
            continue;
          }
          let f = c;
          for (; ++f < u; ) {
            if (!(l[f] in d)) {
              o = e;
              break;
            }
            if (d = d[l[f]], Object.prototype.toString.call(d) !== "[object Object]" || f + 1 === u) {
              o = d;
              break;
            }
          }
          o instanceof Object && (o = JSON.stringify(o));
          break;
        }
      }
      return o instanceof Function && (o = o()), i.at === "@str" ? o : x(this, ql, Qy).call(this, o);
    });
    _(this, Pd, /^-?[\d\.]+$/);
    // 変数のダンプ
    _(this, Od, () => {
      const t = { tmp: {}, sys: {}, save: {}, mp: {} };
      for (let e in t) {
        const i = h(this, Ae)[e], n = t[e];
        for (let [s, o] of Object.entries(i))
          n[s] = Object.prototype.toString.call(o) === "[object Function]" ? o() : o;
      }
      return console.info("🥟 [dump_val]", t), !1;
    });
    _(this, Ia, !1);
    _(this, Zl, {
      // sys
      "sys:sn.tagCh.doWait": (t) => x(this, Ca, xf).call(this, t),
      "sys:sn.tagCh.doWait_Kidoku": (t) => x(this, Ca, xf).call(this, t),
      "sys:sn.tagCh.msecWait": (t) => x(this, Id, Jb).call(this, t),
      "sys:sn.tagCh.msecWait_Kidoku": (t) => x(this, Cd, Qb).call(this, t),
      "sys:sn.tagCh.canskip": (t) => x(this, Ca, xf).call(this, t),
      "sys:sn.auto.msecPageWait": (t) => x(this, Kl, tm).call(this, t),
      "sys:sn.auto.msecPageWait_Kidoku": (t) => x(this, Kl, tm).call(this, t),
      "sys:sn.auto.msecLineWait": (t) => x(this, Jl, em).call(this, t),
      "sys:sn.auto.msecLineWait_Kidoku": (t) => x(this, Jl, em).call(this, t),
      // save
      "save:sn.doRecLog": (t) => {
        h(this, Xl).call(this, g(this, Ia, x(this, Md, tx).call(this, t)));
      },
      "save:sn.userFnTail": (t, e) => {
        if (e.includes("@"))
          throw "この変数では文字「@」は禁止です";
        this.cfg.userFnTail = e;
      },
      // tmp
      "tmp:sn.tagL.enabled": (t) => x(this, Rd, ex).call(this, t),
      "tmp:sn.skip.all": (t) => x(this, Ma, wf).call(this, t),
      "tmp:sn.skip.enabled": (t) => x(this, Ma, wf).call(this, t),
      "tmp:sn.auto.enabled": (t) => x(this, Ma, wf).call(this, t),
      "tmp:flash.desktop.NativeApplication.nativeApplication.systemIdleMode": () => {
      }
    });
    if (this.cfg = t, e.let = (s) => x(this, Di, Pr).call(this, s), e.let_abs = (s) => x(this, _d, zb).call(this, s), e.let_char_at = (s) => x(this, gd, Vb).call(this, s), e.let_index_of = (s) => x(this, bd, Xb).call(this, s), e.let_length = (s) => x(this, xd, Wb).call(this, s), e.let_replace = (s) => x(this, wd, Yb).call(this, s), e.let_round = (s) => x(this, Ed, qb).call(this, s), e.let_search = (s) => x(this, Td, Zb).call(this, s), e.let_substr = (s) => x(this, Sd, Kb).call(this, s), e.clearsysvar = () => x(this, Oa, bf).call(this), e.clearvar = () => x(this, Wl, Jy).call(this), e.dump_val = () => h(this, Od).call(this), e.copybookmark = (s) => x(this, yd, Hb).call(this, s), e.erasebookmark = (s) => x(this, md, $b).call(this, s), h(this, Li)["sn.userFnTail"] = "", this.defTmp("const.sn.bookmark.json", () => {
      const s = [];
      for (const o of Object.keys(h(this, Se).mark).sort()) {
        const a = { ...h(this, Se).mark[o].json };
        a.place = o, s.push(a);
      }
      return JSON.stringify(s);
    }), h(this, ie)["const.sn.isFirstBoot"] = !0, h(this, ie)["sn.tagL.enabled"] = !0, h(this, ie)["sn.skip.all"] = !1, h(this, ie)["sn.skip.enabled"] = !1, h(this, ie)["sn.auto.enabled"] = !1, h(this, ie)["const.sn.last_page_text"] = "", h(this, ie)["const.sn.last_page_plain_text"] = "", h(this, ie)["const.sn.displayState"] = !1, h(this, ie)["const.Date.getTime"] = () => (/* @__PURE__ */ new Date()).getTime(), h(this, ie)["const.Date.getDateStr"] = () => xl(), h(this, ie)["const.sn.platform"] = JSON.stringify(S0), x(this, Oa, bf).call(this), x(this, Wl, Jy).call(this), h(this, ie)["const.sn.config.window.width"] = t.oCfg.window.width, h(this, ie)["const.sn.config.window.height"] = t.oCfg.window.height, h(this, ie)["const.sn.config.book.title"] = t.oCfg.book.title, h(this, ie)["const.sn.config.book.version"] = t.oCfg.book.version, h(this, ie)["const.sn.Math.PI"] = Math.PI, typeof window > "u")
      return;
    const i = window, n = i.AudioContext ?? i.webkitAudioContext;
    h(this, ie)["const.sn.needClick2Play"] = () => new n().state === "suspended";
  }
  setSys(t) {
    g(this, un, t), t.initVal(h(this, Se), h(this, ie), (e) => {
      this.updateData(e), sessionStorage.clear();
      const i = this.cfg.getNs();
      g(this, Vl, this.cfg.oCfg.debug.variable ? () => {
        const s = {};
        for (const [d, f] of Object.entries(h(this, gi)))
          s["sys:" + d] = f instanceof Function ? f() : f;
        sessionStorage[i + "sys"] = JSON.stringify(s);
        const o = {};
        for (const [d, f] of Object.entries(h(this, Li)))
          o["save:" + d] = f instanceof Function ? f() : f;
        sessionStorage[i + "save"] = JSON.stringify(o);
        const a = {};
        for (const [d, f] of Object.entries(h(this, ie)))
          a[d] = f instanceof Function ? f() : f;
        sessionStorage[i + "tmp"] = JSON.stringify(a);
        const l = {};
        for (const [d, f] of Object.entries(h(this, Ae).mp))
          l[d] = f instanceof Function ? f() : f;
        sessionStorage[i + "mp"] = JSON.stringify(l);
        const u = {};
        for (const [d, f] of Object.entries(h(this, Se).mark))
          u[d] = f instanceof Function ? f() : f;
        sessionStorage[i + "mark"] = JSON.stringify(u);
        const c = {};
        for (const [d, f] of Object.entries(h(this, Se).kidoku))
          c[d] = f instanceof Function ? f() : f;
        sessionStorage[i + "kidoku"] = JSON.stringify(c), t.flush();
      } : () => t.flush()), g(this, $l, (s, o) => t.callHook(s, o)), t.addHook((s, o) => {
        var a, l;
        return (l = (a = h(this, vd))[s]) == null ? void 0 : l.call(a, s, o);
      });
      const n = this.getVal("sys:sn.tagCh.msecWait", -1);
      (h(this, ie)["const.sn.isFirstBoot"] || n === -1) && x(this, Oa, bf).call(this);
    });
  }
  updateData(t) {
    g(this, Se, t), g(this, gi, h(this, Ae).sys = h(this, Se).sys), g(this, Or, {});
    for (const [e, i] of Object.entries(h(this, Se).kidoku)) {
      const n = new Qg();
      n.hAreas = { ...i }, h(this, Or)[e] = n;
    }
  }
  flush() {
    h(this, Vl).call(this);
  }
  // 先にこのメソッドへの参照を配ってしまうので、中身を入れ替える
  setDoRecProc(t) {
    g(this, Xl, t);
  }
  defTmp(t, e) {
    h(this, ie)[t] = e;
  }
  cloneMp() {
    return { ...h(this, Ae).mp };
  }
  setMp(t) {
    h(this, Ae).mp = t;
  }
  setMark(t, e) {
    h(this, Se).mark[t] = e, this.flush();
  }
  cloneSave() {
    return { ...h(this, Ae).save };
  }
  mark2save(t) {
    g(this, Li, h(this, Ae).save = { ...t.hSave }), g(this, Ia, h(this, Li)["sn.doRecLog"] ?? !1);
  }
  // 既読系
  loadScrWork(t) {
    t in h(this, Or) || (h(this, Or)[t] = new Qg());
  }
  saveKidoku() {
    for (const [t, { hAreas: e }] of Object.entries(h(this, Or)))
      h(this, Se).kidoku[t] = { ...e };
    this.flush();
  }
  setVal_Nochk(t, e, i, n = !1) {
    var a, l;
    const s = h(this, Ae)[t];
    n && (i = x(this, ql, Qy).call(this, i));
    const o = t + ":" + e;
    if (o in h(_a, Hs)) {
      const u = s[e], c = i;
      u != c && h(this, $l).call(this, "data_break", {
        dataId: o,
        old_v: u,
        new_v: c
      });
    }
    s[e] = i, (l = (a = h(this, Zl))[o]) == null || l.call(a, e, i);
  }
  doRecLog() {
    return h(this, Ia);
  }
  defValTrg(t, e) {
    h(this, Zl)[t] = e;
  }
};
let gf = _a;
Ae = new WeakMap(), Li = new WeakMap(), ie = new WeakMap(), un = new WeakMap(), Se = new WeakMap(), gi = new WeakMap(), Or = new WeakMap(), $l = new WeakMap(), vd = new WeakMap(), zl = new WeakSet(), Ky = function(t) {
  g(_a, Hs, {});
  for (const e of t)
    h(_a, Hs)[e.dataId] = 1;
}, Vl = new WeakMap(), Xl = new WeakMap(), yd = new WeakSet(), Hb = function(t) {
  if (!("from" in t))
    throw "fromは必須です";
  if (!("to" in t))
    throw "toは必須です";
  const e = Number(t.from), i = Number(t.to);
  if (e === i)
    return !1;
  if (!(e in h(this, Se).mark))
    throw `from:${e} のセーブデータは存在しません`;
  return this.setMark(i, { ...h(this, Se).mark[e] }), h(this, un).copyBMFolder(e, i), !1;
}, md = new WeakSet(), $b = function(t) {
  const { place: e } = t;
  if (!e)
    throw "placeは必須です";
  return delete h(this, Se).mark[e], this.flush(), h(this, un).eraseBMFolder(e), !1;
}, Di = new WeakSet(), Pr = function(t) {
  if (!t.name)
    throw "nameは必須です";
  let e = !0;
  if (t.cast)
    switch (t.cast) {
      case "num":
        j(t, "text", NaN);
        break;
      case "int":
        t.text = String(Ue(j(t, "text", NaN)));
        break;
      case "uint":
        t.text = String(mr(j(t, "text", NaN)));
        break;
      case "bool":
        K(t, "text", !1);
        break;
      case "str":
        e = !1;
        break;
      default:
        throw "cast【" + t.cast + "】は未定義です";
    }
  return h(this, Yl).call(this, t.name, t.text, e), !1;
}, _d = new WeakSet(), zb = function(t) {
  const e = j(t, "text", 0);
  return t.text = String(e < 0 ? -e : e), x(this, Di, Pr).call(this, t), !1;
}, gd = new WeakSet(), Vb = function(t) {
  return t.text = (t.text ?? "").charAt(j(t, "pos", 0)), x(this, Di, Pr).call(this, t), !1;
}, bd = new WeakSet(), Xb = function(t) {
  const { val: e } = t;
  if (!e)
    throw "valは必須です";
  const i = j(t, "start", 0);
  return t.text = String((t.text ?? "").indexOf(e, i)), x(this, Di, Pr).call(this, t), !1;
}, xd = new WeakSet(), Wb = function(t) {
  return t.text = String((t.text ?? "").length), x(this, Di, Pr).call(this, t), !1;
}, wd = new WeakSet(), Yb = function(t) {
  if (!t.reg)
    throw "regは必須です";
  const { flags: e } = t, i = e ? new RegExp(t.reg, e) : new RegExp(t.reg);
  return t.text = String(t.text ?? "").replace(i, String(t.val)), x(this, Di, Pr).call(this, t), !1;
}, Ed = new WeakSet(), qb = function(t) {
  const e = j(t, "text", 0);
  return t.text = String(Math.round(e)), x(this, Di, Pr).call(this, t), !1;
}, Td = new WeakSet(), Zb = function(t) {
  if (!t.reg)
    throw "regは必須です";
  const { flags: e } = t, i = e ? new RegExp(t.reg, e) : new RegExp(t.reg);
  return t.text = String((t.text ?? "").search(i)), x(this, Di, Pr).call(this, t), !1;
}, Sd = new WeakSet(), Kb = function(t) {
  const e = j(t, "pos", 0);
  return t.text = t.len !== "all" ? (t.text ?? "").slice(e, e + Ue(j(t, "len", 1))) : (t.text ?? "").slice(e), x(this, Di, Pr).call(this, t), !1;
}, Oa = new WeakSet(), bf = function() {
  const t = g(this, gi, h(this, Ae).sys = h(this, Se).sys = {});
  typeof process < "u" || (this.setVal_Nochk("sys", "const.sn.window.x", 0), this.setVal_Nochk("sys", "const.sn.window.y", 0)), this.setVal_Nochk("sys", "sn.tagCh.doWait", !0), this.setVal_Nochk("sys", "sn.tagCh.doWait_Kidoku", !0), this.setVal_Nochk("sys", "sn.tagCh.msecWait", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk("sys", "sn.tagCh.msecWait_Kidoku", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk("sys", "sn.tagCh.canskip", !0), this.setVal_Nochk("sys", "sn.skip.mode", "s"), this.setVal_Nochk("sys", "sn.auto.msecPageWait", j(t, "sn.auto.msecPageWait", this.cfg.oCfg.init.auto_msecpagewait ?? 3500)), this.setVal_Nochk("sys", "sn.auto.msecPageWait_Kidoku", j(t, "sn.auto.msecPageWait", this.cfg.oCfg.init.auto_msecpagewait ?? 3500)), this.setVal_Nochk("sys", "sn.auto.msecLineWait", 500), this.setVal_Nochk("sys", "sn.auto.msecLineWait_Kidoku", 500), this.setVal_Nochk("sys", "const.sn.sound.BGM.volume", 1), this.setVal_Nochk("sys", "const.sn.sound.SE.volume", 1), this.setVal_Nochk("sys", "const.sn.sound.SYS.volume", 1);
  for (const [i, n] of Object.entries(h(this, Se).kidoku))
    n.hAreas = {}, h(this, Or)[i].clear();
  return this.setVal_Nochk("sys", "TextLayer.Back.Alpha", 0.5), h(this, Ae).mark = h(this, Se).mark = {}, this.setVal_Nochk("sys", "const.sn.save.place", 1), this.flush(), !1;
}, Wl = new WeakSet(), Jy = function() {
  const t = h(this, Li)["const.sn.mesLayer"] ?? "", e = h(this, Li)["sn.doRecLog"] ?? !1, i = h(this, Li)["const.sn.sLog"] ?? "[]";
  return g(this, Li, h(this, Ae).save = {}), this.setVal_Nochk("save", "const.sn.mesLayer", t), this.setVal_Nochk("save", "sn.doRecLog", e), this.setVal_Nochk("save", "const.sn.sLog", i), !1;
}, Yl = new WeakMap(), Hs = new WeakMap(), ql = new WeakSet(), Qy = function(t) {
  const e = t;
  if (e === "true")
    return !0;
  if (e === "false")
    return !1;
  if (e === "null")
    return null;
  if (e !== "undefined")
    return h(this, Pd).test(e) ? parseFloat(e) : t;
}, Pd = new WeakMap(), Od = new WeakMap(), Ia = new WeakMap(), Zl = new WeakMap(), Ca = new WeakSet(), xf = function(t) {
  K(h(this, gi), t, !0);
}, Id = new WeakSet(), Jb = function(t) {
  j(h(this, gi), t, 10), h(this, gi)["sn.tagCh.doWait"];
}, Cd = new WeakSet(), Qb = function(t) {
  j(
    h(this, gi),
    t,
    this.cfg.oCfg.init.tagch_msecwait === void 0 ? 10 : this.cfg.oCfg.init.tagch_msecwait
  ), h(this, gi)["sn.tagCh.doWait_Kidoku"];
}, Kl = new WeakSet(), tm = function(t) {
  j(
    h(this, gi),
    t,
    this.cfg.oCfg.init.auto_msecpagewait === void 0 ? 3500 : this.cfg.oCfg.init.auto_msecpagewait
  );
}, Jl = new WeakSet(), em = function(t) {
  j(h(this, gi), t, 500);
}, Md = new WeakSet(), tx = function(t) {
  return K(h(this, Li), t, !0);
}, Rd = new WeakSet(), ex = function(t) {
  K(h(this, ie), t, !0);
}, Ma = new WeakSet(), wf = function(t) {
  K(h(this, ie), t, !1);
}, // reload 再生成 Main に受け渡すため static
_(gf, Hs, {});
var Ct = Object.freeze({
  Linear: Object.freeze({
    None: function(r) {
      return r;
    },
    In: function(r) {
      return this.None(r);
    },
    Out: function(r) {
      return this.None(r);
    },
    InOut: function(r) {
      return this.None(r);
    }
  }),
  Quadratic: Object.freeze({
    In: function(r) {
      return r * r;
    },
    Out: function(r) {
      return r * (2 - r);
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1);
    }
  }),
  Cubic: Object.freeze({
    In: function(r) {
      return r * r * r;
    },
    Out: function(r) {
      return --r * r * r + 1;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2);
    }
  }),
  Quartic: Object.freeze({
    In: function(r) {
      return r * r * r * r;
    },
    Out: function(r) {
      return 1 - --r * r * r * r;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r : -0.5 * ((r -= 2) * r * r * r - 2);
    }
  }),
  Quintic: Object.freeze({
    In: function(r) {
      return r * r * r * r * r;
    },
    Out: function(r) {
      return --r * r * r * r * r + 1;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r * r : 0.5 * ((r -= 2) * r * r * r * r + 2);
    }
  }),
  Sinusoidal: Object.freeze({
    In: function(r) {
      return 1 - Math.sin((1 - r) * Math.PI / 2);
    },
    Out: function(r) {
      return Math.sin(r * Math.PI / 2);
    },
    InOut: function(r) {
      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - r)));
    }
  }),
  Exponential: Object.freeze({
    In: function(r) {
      return r === 0 ? 0 : Math.pow(1024, r - 1);
    },
    Out: function(r) {
      return r === 1 ? 1 : 1 - Math.pow(2, -10 * r);
    },
    InOut: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2) < 1 ? 0.5 * Math.pow(1024, r - 1) : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2);
    }
  }),
  Circular: Object.freeze({
    In: function(r) {
      return 1 - Math.sqrt(1 - r * r);
    },
    Out: function(r) {
      return Math.sqrt(1 - --r * r);
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r * r) - 1) : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1);
    }
  }),
  Elastic: Object.freeze({
    In: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : -Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI);
    },
    Out: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : Math.pow(2, -10 * r) * Math.sin((r - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2, r < 1 ? -0.5 * Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) + 1);
    }
  }),
  Back: Object.freeze({
    In: function(r) {
      var t = 1.70158;
      return r === 1 ? 1 : r * r * ((t + 1) * r - t);
    },
    Out: function(r) {
      var t = 1.70158;
      return r === 0 ? 0 : --r * r * ((t + 1) * r + t) + 1;
    },
    InOut: function(r) {
      var t = 2.5949095;
      return (r *= 2) < 1 ? 0.5 * (r * r * ((t + 1) * r - t)) : 0.5 * ((r -= 2) * r * ((t + 1) * r + t) + 2);
    }
  }),
  Bounce: Object.freeze({
    In: function(r) {
      return 1 - Ct.Bounce.Out(1 - r);
    },
    Out: function(r) {
      return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;
    },
    InOut: function(r) {
      return r < 0.5 ? Ct.Bounce.In(r * 2) * 0.5 : Ct.Bounce.Out(r * 2 - 1) * 0.5 + 0.5;
    }
  }),
  generatePow: function(r) {
    return r === void 0 && (r = 4), r = r < Number.EPSILON ? Number.EPSILON : r, r = r > 1e4 ? 1e4 : r, {
      In: function(t) {
        return Math.pow(t, r);
      },
      Out: function(t) {
        return 1 - Math.pow(1 - t, r);
      },
      InOut: function(t) {
        return t < 0.5 ? Math.pow(t * 2, r) / 2 : (1 - Math.pow(2 - t * 2, r)) / 2 + 0.5;
      }
    };
  }
}), el = function() {
  return performance.now();
}, kC = (
  /** @class */
  function() {
    function r() {
      this._tweens = {}, this._tweensAddedDuringUpdate = {};
    }
    return r.prototype.getAll = function() {
      var t = this;
      return Object.keys(this._tweens).map(function(e) {
        return t._tweens[e];
      });
    }, r.prototype.removeAll = function() {
      this._tweens = {};
    }, r.prototype.add = function(t) {
      this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t;
    }, r.prototype.remove = function(t) {
      delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()];
    }, r.prototype.update = function(t, e) {
      t === void 0 && (t = el()), e === void 0 && (e = !1);
      var i = Object.keys(this._tweens);
      if (i.length === 0)
        return !1;
      for (; i.length > 0; ) {
        this._tweensAddedDuringUpdate = {};
        for (var n = 0; n < i.length; n++) {
          var s = this._tweens[i[n]], o = !e;
          s && s.update(t, o) === !1 && !e && delete this._tweens[i[n]];
        }
        i = Object.keys(this._tweensAddedDuringUpdate);
      }
      return !0;
    }, r;
  }()
), ma = {
  Linear: function(r, t) {
    var e = r.length - 1, i = e * t, n = Math.floor(i), s = ma.Utils.Linear;
    return t < 0 ? s(r[0], r[1], i) : t > 1 ? s(r[e], r[e - 1], e - i) : s(r[n], r[n + 1 > e ? e : n + 1], i - n);
  },
  Bezier: function(r, t) {
    for (var e = 0, i = r.length - 1, n = Math.pow, s = ma.Utils.Bernstein, o = 0; o <= i; o++)
      e += n(1 - t, i - o) * n(t, o) * r[o] * s(i, o);
    return e;
  },
  CatmullRom: function(r, t) {
    var e = r.length - 1, i = e * t, n = Math.floor(i), s = ma.Utils.CatmullRom;
    return r[0] === r[e] ? (t < 0 && (n = Math.floor(i = e * (1 + t))), s(r[(n - 1 + e) % e], r[n], r[(n + 1) % e], r[(n + 2) % e], i - n)) : t < 0 ? r[0] - (s(r[0], r[0], r[1], r[1], -i) - r[0]) : t > 1 ? r[e] - (s(r[e], r[e], r[e - 1], r[e - 1], i - e) - r[e]) : s(r[n ? n - 1 : 0], r[n], r[e < n + 1 ? e : n + 1], r[e < n + 2 ? e : n + 2], i - n);
  },
  Utils: {
    Linear: function(r, t, e) {
      return (t - r) * e + r;
    },
    Bernstein: function(r, t) {
      var e = ma.Utils.Factorial;
      return e(r) / e(t) / e(r - t);
    },
    Factorial: function() {
      var r = [1];
      return function(t) {
        var e = 1;
        if (r[t])
          return r[t];
        for (var i = t; i > 1; i--)
          e *= i;
        return r[t] = e, e;
      };
    }(),
    CatmullRom: function(r, t, e, i, n) {
      var s = (e - r) * 0.5, o = (i - t) * 0.5, a = n * n, l = n * a;
      return (2 * t - 2 * e + s + o) * l + (-3 * t + 3 * e - 2 * s - o) * a + s * n + t;
    }
  }
}, NC = (
  /** @class */
  function() {
    function r() {
    }
    return r.nextId = function() {
      return r._nextId++;
    }, r._nextId = 0, r;
  }()
), im = new kC(), zr = (
  /** @class */
  function() {
    function r(t, e) {
      e === void 0 && (e = im), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = !1, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = Ct.Linear.None, this._interpolationFunction = ma.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = NC.nextId(), this._isChainStopped = !1, this._propertiesAreSetUp = !1, this._goToEnd = !1;
    }
    return r.prototype.getId = function() {
      return this._id;
    }, r.prototype.isPlaying = function() {
      return this._isPlaying;
    }, r.prototype.isPaused = function() {
      return this._isPaused;
    }, r.prototype.to = function(t, e) {
      if (e === void 0 && (e = 1e3), this._isPlaying)
        throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
      return this._valuesEnd = t, this._propertiesAreSetUp = !1, this._duration = e, this;
    }, r.prototype.duration = function(t) {
      return t === void 0 && (t = 1e3), this._duration = t, this;
    }, r.prototype.dynamic = function(t) {
      return t === void 0 && (t = !1), this._isDynamic = t, this;
    }, r.prototype.start = function(t, e) {
      if (t === void 0 && (t = el()), e === void 0 && (e = !1), this._isPlaying)
        return this;
      if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {
        this._reversed = !1;
        for (var i in this._valuesStartRepeat)
          this._swapEndStartRepeatValues(i), this._valuesStart[i] = this._valuesStartRepeat[i];
      }
      if (this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t, this._startTime += this._delayTime, !this._propertiesAreSetUp || e) {
        if (this._propertiesAreSetUp = !0, !this._isDynamic) {
          var n = {};
          for (var s in this._valuesEnd)
            n[s] = this._valuesEnd[s];
          this._valuesEnd = n;
        }
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, e);
      }
      return this;
    }, r.prototype.startFromCurrentValues = function(t) {
      return this.start(t, !0);
    }, r.prototype._setupProperties = function(t, e, i, n, s) {
      for (var o in i) {
        var a = t[o], l = Array.isArray(a), u = l ? "array" : typeof a, c = !l && Array.isArray(i[o]);
        if (!(u === "undefined" || u === "function")) {
          if (c) {
            var d = i[o];
            if (d.length === 0)
              continue;
            for (var f = [a], v = 0, m = d.length; v < m; v += 1) {
              var p = this._handleRelativeValue(a, d[v]);
              if (isNaN(p)) {
                c = !1, console.warn("Found invalid interpolation list. Skipping.");
                break;
              }
              f.push(p);
            }
            c && (i[o] = f);
          }
          if ((u === "object" || l) && a && !c) {
            e[o] = l ? [] : {};
            var y = a;
            for (var b in y)
              e[o][b] = y[b];
            n[o] = l ? [] : {};
            var d = i[o];
            if (!this._isDynamic) {
              var w = {};
              for (var b in d)
                w[b] = d[b];
              i[o] = d = w;
            }
            this._setupProperties(y, e[o], d, n[o], s);
          } else
            (typeof e[o] > "u" || s) && (e[o] = a), l || (e[o] *= 1), c ? n[o] = i[o].slice().reverse() : n[o] = e[o] || 0;
        }
      }
    }, r.prototype.stop = function() {
      return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
    }, r.prototype.end = function() {
      return this._goToEnd = !0, this.update(1 / 0), this;
    }, r.prototype.pause = function(t) {
      return t === void 0 && (t = el()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this), this);
    }, r.prototype.resume = function(t) {
      return t === void 0 && (t = el()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);
    }, r.prototype.stopChainedTweens = function() {
      for (var t = 0, e = this._chainedTweens.length; t < e; t++)
        this._chainedTweens[t].stop();
      return this;
    }, r.prototype.group = function(t) {
      return t === void 0 && (t = im), this._group = t, this;
    }, r.prototype.delay = function(t) {
      return t === void 0 && (t = 0), this._delayTime = t, this;
    }, r.prototype.repeat = function(t) {
      return t === void 0 && (t = 0), this._initialRepeat = t, this._repeat = t, this;
    }, r.prototype.repeatDelay = function(t) {
      return this._repeatDelayTime = t, this;
    }, r.prototype.yoyo = function(t) {
      return t === void 0 && (t = !1), this._yoyo = t, this;
    }, r.prototype.easing = function(t) {
      return t === void 0 && (t = Ct.Linear.None), this._easingFunction = t, this;
    }, r.prototype.interpolation = function(t) {
      return t === void 0 && (t = ma.Linear), this._interpolationFunction = t, this;
    }, r.prototype.chain = function() {
      for (var t = [], e = 0; e < arguments.length; e++)
        t[e] = arguments[e];
      return this._chainedTweens = t, this;
    }, r.prototype.onStart = function(t) {
      return this._onStartCallback = t, this;
    }, r.prototype.onEveryStart = function(t) {
      return this._onEveryStartCallback = t, this;
    }, r.prototype.onUpdate = function(t) {
      return this._onUpdateCallback = t, this;
    }, r.prototype.onRepeat = function(t) {
      return this._onRepeatCallback = t, this;
    }, r.prototype.onComplete = function(t) {
      return this._onCompleteCallback = t, this;
    }, r.prototype.onStop = function(t) {
      return this._onStopCallback = t, this;
    }, r.prototype.update = function(t, e) {
      if (t === void 0 && (t = el()), e === void 0 && (e = !0), this._isPaused)
        return !0;
      var i, n, s = this._startTime + this._duration;
      if (!this._goToEnd && !this._isPlaying) {
        if (t > s)
          return !1;
        e && this.start(t, !0);
      }
      if (this._goToEnd = !1, t < this._startTime)
        return !0;
      this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), this._onEveryStartCallbackFired === !1 && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0), n = (t - this._startTime) / this._duration, n = this._duration === 0 || n > 1 ? 1 : n;
      var o = this._easingFunction(n);
      if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, o), this._onUpdateCallback && this._onUpdateCallback(this._object, n), n === 1)
        if (this._repeat > 0) {
          isFinite(this._repeat) && this._repeat--;
          for (i in this._valuesStartRepeat)
            !this._yoyo && typeof this._valuesEnd[i] == "string" && (this._valuesStartRepeat[i] = // eslint-disable-next-line
            // @ts-ignore FIXME?
            this._valuesStartRepeat[i] + parseFloat(this._valuesEnd[i])), this._yoyo && this._swapEndStartRepeatValues(i), this._valuesStart[i] = this._valuesStartRepeat[i];
          return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0;
        } else {
          this._onCompleteCallback && this._onCompleteCallback(this._object);
          for (var a = 0, l = this._chainedTweens.length; a < l; a++)
            this._chainedTweens[a].start(this._startTime + this._duration, !1);
          return this._isPlaying = !1, !1;
        }
      return !0;
    }, r.prototype._updateProperties = function(t, e, i, n) {
      for (var s in i)
        if (e[s] !== void 0) {
          var o = e[s] || 0, a = i[s], l = Array.isArray(t[s]), u = Array.isArray(a), c = !l && u;
          c ? t[s] = this._interpolationFunction(a, n) : typeof a == "object" && a ? this._updateProperties(t[s], o, a, n) : (a = this._handleRelativeValue(o, a), typeof a == "number" && (t[s] = o + (a - o) * n));
        }
    }, r.prototype._handleRelativeValue = function(t, e) {
      return typeof e != "string" ? e : e.charAt(0) === "+" || e.charAt(0) === "-" ? t + parseFloat(e) : parseFloat(e);
    }, r.prototype._swapEndStartRepeatValues = function(t) {
      var e = this._valuesStartRepeat[t], i = this._valuesEnd[t];
      typeof i == "string" ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(i) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = e;
    }, r;
  }()
), Kr = im;
Kr.getAll.bind(Kr);
var AC = Kr.removeAll.bind(Kr);
Kr.add.bind(Kr);
var LC = Kr.remove.bind(Kr), DC = Kr.update.bind(Kr), Ql;
const kd = class {
  static ease(t) {
    if (!t)
      return (e) => Ct.Linear.None(e);
    if (!(t in h(kd, Ql)))
      throw "異常なease指定です";
    return h(kd, Ql)[t];
  }
};
let Fn = kd;
Ql = new WeakMap(), _(Fn, Ql, {
  "Back.In": (t) => Ct.Back.In(t),
  "Back.InOut": (t) => Ct.Back.InOut(t),
  "Back.Out": (t) => Ct.Back.Out(t),
  "Bounce.In": (t) => Ct.Bounce.In(t),
  "Bounce.InOut": (t) => Ct.Bounce.InOut(t),
  "Bounce.Out": (t) => Ct.Bounce.Out(t),
  "Circular.In": (t) => Ct.Circular.In(t),
  "Circular.InOut": (t) => Ct.Circular.InOut(t),
  "Circular.Out": (t) => Ct.Circular.Out(t),
  "Cubic.In": (t) => Ct.Cubic.In(t),
  "Cubic.InOut": (t) => Ct.Cubic.InOut(t),
  "Cubic.Out": (t) => Ct.Cubic.Out(t),
  "Elastic.In": (t) => Ct.Elastic.In(t),
  "Elastic.InOut": (t) => Ct.Elastic.InOut(t),
  "Elastic.Out": (t) => Ct.Elastic.Out(t),
  "Exponential.In": (t) => Ct.Exponential.In(t),
  "Exponential.InOut": (t) => Ct.Exponential.InOut(t),
  "Exponential.Out": (t) => Ct.Exponential.Out(t),
  "Linear.None": (t) => Ct.Linear.None(t),
  "Quadratic.In": (t) => Ct.Quadratic.In(t),
  "Quadratic.InOut": (t) => Ct.Quadratic.InOut(t),
  "Quadratic.Out": (t) => Ct.Quadratic.Out(t),
  "Quartic.In": (t) => Ct.Quartic.In(t),
  "Quartic.InOut": (t) => Ct.Quartic.InOut(t),
  "Quartic.Out": (t) => Ct.Quartic.Out(t),
  "Quintic.In": (t) => Ct.Quintic.In(t),
  "Quintic.InOut": (t) => Ct.Quintic.InOut(t),
  "Quintic.Out": (t) => Ct.Quintic.Out(t),
  "Sinusoidal.In": (t) => Ct.Sinusoidal.In(t),
  "Sinusoidal.InOut": (t) => Ct.Sinusoidal.InOut(t),
  "Sinusoidal.Out": (t) => Ct.Sinusoidal.Out(t)
});
/*!
 * @pixi/sound - v4.3.3
 * https://github.com/pixijs/pixi-sound
 * Compiled Fri, 10 Mar 2023 17:19:30 UTC
 *
 * @pixi/sound is licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license
 */
var ix;
function de() {
  return ix;
}
var rx = function(r, t) {
  return (rx = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n]);
  })(r, t);
};
function Pi(r, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function e() {
    this.constructor = r;
  }
  rx(r, t), r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var Ko = function() {
  return (Ko = Object.assign || function(r) {
    for (var t, e = 1, i = arguments.length; e < i; e++)
      for (var n in t = arguments[e])
        Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
    return r;
  }).apply(this, arguments);
}, R_ = ["mp3", "ogg", "oga", "opus", "mpeg", "wav", "m4a", "aiff", "wma", "mid", "caf"], Lv = {};
function nx(r) {
  var t = Ko({ m4a: "audio/mp4", oga: "audio/ogg", opus: 'audio/ogg; codecs="opus"', caf: 'audio/x-caf; codecs="opus"' }, r || {}), e = document.createElement("audio"), i = {}, n = /^no$/;
  R_.forEach(function(s) {
    var o = e.canPlayType("audio/".concat(s)).replace(n, ""), a = t[s] ? e.canPlayType(t[s]).replace(n, "") : "";
    i[s] = !!o || !!a;
  }), Object.assign(Lv, i);
}
nx();
var FC = /\.(\{([^\}]+)\})(\?.*)?$/;
function k_(r) {
  var t = FC, e = typeof r == "string" ? r : r.url;
  if (!t.test(e))
    return e;
  for (var i = t.exec(e), n = i[2].split(","), s = n[n.length - 1], o = 0, a = n.length; o < a; o++) {
    var l = n[o];
    if (Lv[l]) {
      s = l;
      break;
    }
  }
  var u = e.replace(i[1], s);
  if (typeof r != "string") {
    var c = r;
    c.extension = s, c.url = u;
  }
  return u;
}
var yy = R_.filter(function(r) {
  return Lv[r];
}), rm = function() {
  function r() {
  }
  return r.add = function() {
    r.setLegacy(de().useLegacy);
  }, r.setLegacy = function(t) {
    t ? yy.forEach(function(e) {
      bt.setExtensionXhrType(e, bt.XHR_RESPONSE_TYPE.DEFAULT), bt.setExtensionLoadType(e, bt.LOAD_TYPE.AUDIO);
    }) : yy.forEach(function(e) {
      bt.setExtensionXhrType(e, bt.XHR_RESPONSE_TYPE.BUFFER), bt.setExtensionLoadType(e, bt.LOAD_TYPE.XHR);
    });
  }, r.pre = function(t, e) {
    k_(t), e();
  }, r.use = function(t, e) {
    t.data && yy.indexOf(t.extension) > -1 ? t.sound = de().add(t.name, { loaded: e, preload: !0, url: t.url, source: t.data }) : e();
  }, r.extension = "loader", r;
}(), BC = 0, UC = function(r) {
  function t(e) {
    var i = r.call(this) || this;
    return i.id = BC++, i.init(e), i;
  }
  return Pi(t, r), t.prototype.set = function(e, i) {
    if (this[e] === void 0)
      throw new Error("Property with name ".concat(e, " does not exist."));
    switch (e) {
      case "speed":
        this.speed = i;
        break;
      case "volume":
        this.volume = i;
        break;
      case "paused":
        this.paused = i;
        break;
      case "loop":
        this.loop = i;
        break;
      case "muted":
        this.muted = i;
    }
    return this;
  }, Object.defineProperty(t.prototype, "progress", { get: function() {
    return this._source.currentTime / this._duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    this._paused = e, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), t.prototype._onPlay = function() {
    this._playing = !0;
  }, t.prototype._onPause = function() {
    this._playing = !1;
  }, t.prototype.init = function(e) {
    this._playing = !1, this._duration = e.source.duration;
    var i = this._source = e.source.cloneNode(!1);
    i.src = e.parent.url, i.onplay = this._onPlay.bind(this), i.onpause = this._onPause.bind(this), e.context.on("refresh", this.refresh, this), e.context.on("refreshPaused", this.refreshPaused, this), this._media = e;
  }, t.prototype._internalStop = function() {
    this._source && this._playing && (this._source.onended = null, this._source.pause());
  }, t.prototype.stop = function() {
    this._internalStop(), this._source && this.emit("stop");
  }, Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(e) {
    this._speed = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(e) {
    this._volume = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(e) {
    this._loop = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(e) {
    this._muted = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    var e = this._media.context, i = this._media.parent;
    this._source.loop = this._loop || i.loop;
    var n = e.volume * (e.muted ? 0 : 1), s = i.volume * (i.muted ? 0 : 1), o = this._volume * (this._muted ? 0 : 1);
    this._source.volume = o * n * s, this._source.playbackRate = this._speed * e.speed * i.speed;
  }, t.prototype.refreshPaused = function() {
    var e = this._media.context, i = this._media.parent, n = this._paused || i.paused || e.paused;
    n !== this._pausedReal && (this._pausedReal = n, n ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop })), this.emit("pause", n));
  }, t.prototype.play = function(e) {
    var i = this, n = e.start, s = e.end, o = e.speed, a = e.loop, l = e.volume, u = e.muted;
    this._speed = o, this._volume = l, this._loop = !!a, this._muted = u, this.refresh(), this.loop && s !== null && (this.loop = !1), this._start = n, this._end = s || this._duration, this._start = Math.max(0, this._start - t.PADDING), this._end = Math.min(this._end + t.PADDING, this._duration), this._source.onloadedmetadata = function() {
      i._source && (i._source.currentTime = n, i._source.onloadedmetadata = null, i.emit("progress", n, i._duration), _e.shared.add(i._onUpdate, i));
    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit("start");
  }, t.prototype._onUpdate = function() {
    this.emit("progress", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();
  }, t.prototype._onComplete = function() {
    _e.shared.remove(this._onUpdate, this), this._internalStop(), this.emit("progress", 1, this._duration), this.emit("end", this);
  }, t.prototype.destroy = function() {
    _e.shared.remove(this._onUpdate, this), this.removeAllListeners();
    var e = this._source;
    e && (e.onended = null, e.onplay = null, e.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = !1, this._end = null, this._start = 0, this._duration = 0, this._playing = !1, this._pausedReal = !1, this._paused = !1, this._muted = !1, this._media && (this._media.context.off("refresh", this.refresh, this), this._media.context.off("refreshPaused", this.refreshPaused, this), this._media = null);
  }, t.prototype.toString = function() {
    return "[HTMLAudioInstance id=".concat(this.id, "]");
  }, t.PADDING = 0.1, t;
}(Zi), GC = function(r) {
  function t() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return Pi(t, r), t.prototype.init = function(e) {
    this.parent = e, this._source = e.options.source || new Audio(), e.url && (this._source.src = e.url);
  }, t.prototype.create = function() {
    return new UC(this);
  }, Object.defineProperty(t.prototype, "isPlayable", { get: function() {
    return !!this._source && this._source.readyState === 4;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "duration", { get: function() {
    return this._source.duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = "", this._source.load(), this._source = null);
  }, Object.defineProperty(t.prototype, "source", { get: function() {
    return this._source;
  }, enumerable: !1, configurable: !0 }), t.prototype.load = function(e) {
    var i = this._source, n = this.parent;
    if (i.readyState !== 4)
      if (n.url) {
        i.src = n.url;
        var s = function() {
          l(), n.isLoaded = !0;
          var c = n.autoPlayStart();
          e && e(null, n, c);
        }, o = function() {
          l(), e && e(new Error("Sound loading has been aborted"));
        }, a = function() {
          l();
          var c = "Failed to load audio element (code: ".concat(i.error.code, ")");
          e && e(new Error(c));
        }, l = function() {
          i.removeEventListener("canplaythrough", s), i.removeEventListener("load", s), i.removeEventListener("abort", o), i.removeEventListener("error", a);
        };
        i.addEventListener("canplaythrough", s, !1), i.addEventListener("load", s, !1), i.addEventListener("abort", o, !1), i.addEventListener("error", a, !1), i.load();
      } else
        e(new Error("sound.url or sound.source must be set"));
    else {
      n.isLoaded = !0;
      var u = n.autoPlayStart();
      e && setTimeout(function() {
        e(null, n, u);
      }, 0);
    }
  }, t;
}(Zi), jC = function() {
  function r(t, e) {
    this.parent = t, Object.assign(this, e), this.duration = this.end - this.start;
  }
  return r.prototype.play = function(t) {
    return this.parent.play({ complete: t, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop });
  }, r.prototype.destroy = function() {
    this.parent = null;
  }, r;
}(), Ai = function() {
  function r() {
  }
  return r.setParamValue = function(t, e) {
    if (t.setValueAtTime) {
      var i = de().context;
      t.setValueAtTime(e, i.audioContext.currentTime);
    } else
      t.value = e;
    return e;
  }, r;
}(), HC = 0, $C = function(r) {
  function t(e) {
    var i = r.call(this) || this;
    return i.id = HC++, i._media = null, i._paused = !1, i._muted = !1, i._elapsed = 0, i.init(e), i;
  }
  return Pi(t, r), t.prototype.set = function(e, i) {
    if (this[e] === void 0)
      throw new Error("Property with name ".concat(e, " does not exist."));
    switch (e) {
      case "speed":
        this.speed = i;
        break;
      case "volume":
        this.volume = i;
        break;
      case "muted":
        this.muted = i;
        break;
      case "loop":
        this.loop = i;
        break;
      case "paused":
        this.paused = i;
    }
    return this;
  }, t.prototype.stop = function() {
    this._source && (this._internalStop(), this.emit("stop"));
  }, Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(e) {
    this._speed = e, this.refresh(), this._update(!0);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(e) {
    this._volume = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(e) {
    this._muted = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(e) {
    this._loop = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(e) {
    var i;
    this._filters && ((i = this._filters) === null || i === void 0 || i.filter(function(n) {
      return n;
    }).forEach(function(n) {
      return n.disconnect();
    }), this._filters = null, this._source.connect(this._gain)), this._filters = e != null && e.length ? e.slice(0) : null, this.refresh();
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    if (this._source) {
      var e = this._media.context, i = this._media.parent;
      this._source.loop = this._loop || i.loop;
      var n = e.volume * (e.muted ? 0 : 1), s = i.volume * (i.muted ? 0 : 1), o = this._volume * (this._muted ? 0 : 1);
      Ai.setParamValue(this._gain.gain, o * s * n), Ai.setParamValue(this._source.playbackRate, this._speed * i.speed * e.speed), this.applyFilters();
    }
  }, t.prototype.applyFilters = function() {
    var e;
    if (!((e = this._filters) === null || e === void 0) && e.length) {
      this._source.disconnect();
      var i = this._source;
      this._filters.forEach(function(n) {
        i.connect(n.destination), i = n;
      }), i.connect(this._gain);
    }
  }, t.prototype.refreshPaused = function() {
    var e = this._media.context, i = this._media.parent, n = this._paused || i.paused || e.paused;
    n !== this._pausedReal && (this._pausedReal = n, n ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume })), this.emit("pause", n));
  }, t.prototype.play = function(e) {
    var i = e.start, n = e.end, s = e.speed, o = e.loop, a = e.volume, l = e.muted, u = e.filters;
    this._paused = !1;
    var c = this._media.nodes.cloneBufferSource(), d = c.source, f = c.gain;
    this._source = d, this._gain = f, this._speed = s, this._volume = a, this._loop = !!o, this._muted = l, this._filters = u, this.refresh();
    var v = this._source.buffer.duration;
    this._duration = v, this._end = n, this._lastUpdate = this._now(), this._elapsed = i, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = n, this._source.loopStart = i, this._source.start(0, i)) : n ? this._source.start(0, i, n - i) : this._source.start(0, i), this.emit("start"), this._update(!0), this.enableTicker(!0);
  }, t.prototype.enableTicker = function(e) {
    _e.shared.remove(this._updateListener, this), e && _e.shared.add(this._updateListener, this);
  }, Object.defineProperty(t.prototype, "progress", { get: function() {
    return this._progress;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    this._paused = e, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    var e;
    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off("refresh", this.refresh, this), this._media.context.events.off("refreshPaused", this.refreshPaused, this), this._media = null), (e = this._filters) === null || e === void 0 || e.forEach(function(i) {
      return i.disconnect();
    }), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = !1, this._elapsed = 0, this._duration = 0, this._paused = !1, this._muted = !1, this._pausedReal = !1;
  }, t.prototype.toString = function() {
    return "[WebAudioInstance id=".concat(this.id, "]");
  }, t.prototype._now = function() {
    return this._media.context.audioContext.currentTime;
  }, t.prototype._updateListener = function() {
    this._update();
  }, t.prototype._update = function(e) {
    if (e === void 0 && (e = !1), this._source) {
      var i = this._now(), n = i - this._lastUpdate;
      if (n > 0 || e) {
        var s = this._source.playbackRate.value;
        this._elapsed += n * s, this._lastUpdate = i;
        var o = this._duration, a = void 0;
        if (this._source.loopStart) {
          var l = this._source.loopEnd - this._source.loopStart;
          a = (this._source.loopStart + this._elapsed % l) / o;
        } else
          a = this._elapsed % o / o;
        this._progress = a, this.emit("progress", this._progress, o);
      }
    }
  }, t.prototype.init = function(e) {
    this._media = e, e.context.events.on("refresh", this.refresh, this), e.context.events.on("refreshPaused", this.refreshPaused, this);
  }, t.prototype._internalStop = function() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.stop(0), this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch {
      }
      this._source = null;
    }
  }, t.prototype._onComplete = function() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch {
      }
    }
    this._source = null, this._progress = 1, this.emit("progress", 1, this._duration), this.emit("end", this);
  }, t;
}(Zi), sx = function() {
  function r(t, e) {
    this._output = e, this._input = t;
  }
  return Object.defineProperty(r.prototype, "destination", { get: function() {
    return this._input;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(t) {
    var e = this;
    if (this._filters && (this._filters.forEach(function(n) {
      n && n.disconnect();
    }), this._filters = null, this._input.connect(this._output)), t && t.length) {
      this._filters = t.slice(0), this._input.disconnect();
      var i = null;
      t.forEach(function(n) {
        i === null ? e._input.connect(n.destination) : i.connect(n.destination), i = n;
      }), i.connect(this._output);
    }
  }, enumerable: !1, configurable: !0 }), r.prototype.destroy = function() {
    this.filters = null, this._input = null, this._output = null;
  }, r;
}(), zC = function(r) {
  function t(e) {
    var i = this, n = e.audioContext, s = n.createBufferSource(), o = n.createGain(), a = n.createAnalyser();
    return s.connect(a), a.connect(o), o.connect(e.destination), (i = r.call(this, a, o) || this).context = e, i.bufferSource = s, i.gain = o, i.analyser = a, i;
  }
  return Pi(t, r), Object.defineProperty(t.prototype, "script", { get: function() {
    return this._script || (this._script = this.context.audioContext.createScriptProcessor(t.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    r.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;
  }, t.prototype.cloneBufferSource = function() {
    var e = this.bufferSource, i = this.context.audioContext.createBufferSource();
    i.buffer = e.buffer, Ai.setParamValue(i.playbackRate, e.playbackRate.value), i.loop = e.loop;
    var n = this.context.audioContext.createGain();
    return i.connect(n), n.connect(this.destination), { source: i, gain: n };
  }, Object.defineProperty(t.prototype, "bufferSize", { get: function() {
    return this.script.bufferSize;
  }, enumerable: !1, configurable: !0 }), t.BUFFER_SIZE = 0, t;
}(sx), nm = function() {
  function r() {
  }
  return r.prototype.init = function(t) {
    this.parent = t, this._nodes = new zC(this.context), this._source = this._nodes.bufferSource, this.source = t.options.source;
  }, r.prototype.destroy = function() {
    this.parent = null, this._nodes.destroy(), this._nodes = null;
    try {
      this._source.buffer = null;
    } catch {
    }
    this._source = null, this.source = null;
  }, r.prototype.create = function() {
    return new $C(this);
  }, Object.defineProperty(r.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "isPlayable", { get: function() {
    return !!this._source && !!this._source.buffer;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "filters", { get: function() {
    return this._nodes.filters;
  }, set: function(t) {
    this._nodes.filters = t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "duration", { get: function() {
    return this._source.buffer.duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "buffer", { get: function() {
    return this._source.buffer;
  }, set: function(t) {
    this._source.buffer = t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "nodes", { get: function() {
    return this._nodes;
  }, enumerable: !1, configurable: !0 }), r.prototype.load = function(t) {
    this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t && t(new Error("sound.url or sound.source must be set"));
  }, r.prototype._loadUrl = function(t) {
    var e = this, i = new XMLHttpRequest(), n = this.parent.url;
    i.open("GET", n, !0), i.responseType = "arraybuffer", i.onload = function() {
      e.source = i.response, e._decode(i.response, t);
    }, i.send();
  }, r.prototype._decode = function(t, e) {
    var i = this, n = function(s, o) {
      if (s)
        e && e(s);
      else {
        i.parent.isLoaded = !0, i.buffer = o;
        var a = i.parent.autoPlayStart();
        e && e(null, i.parent, a);
      }
    };
    t instanceof AudioBuffer ? n(null, t) : this.parent.context.decode(t, n);
  }, r;
}(), wa = function() {
  function r(t, e) {
    this.media = t, this.options = e, this._instances = [], this._sprites = {}, this.media.init(this);
    var i = e.complete;
    this._autoPlayOptions = i ? { complete: i } : null, this.isLoaded = !1, this.isPlaying = !1, this.autoPlay = e.autoPlay, this.singleInstance = e.singleInstance, this.preload = e.preload || this.autoPlay, this.url = e.url, this.speed = e.speed, this.volume = e.volume, this.loop = e.loop, e.sprites && this.addSprites(e.sprites), this.preload && this._preload(e.loaded);
  }
  return r.from = function(t) {
    var e = {};
    return typeof t == "string" ? e.url = t : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? e.source = t : e = t, (e = Ko({ autoPlay: !1, singleInstance: !1, url: null, source: null, preload: !1, volume: 1, speed: 1, complete: null, loaded: null, loop: !1 }, e)).url && (e.url = k_(e.url)), Object.freeze(e), new r(de().useLegacy ? new GC() : new nm(), e);
  }, Object.defineProperty(r.prototype, "context", { get: function() {
    return de().context;
  }, enumerable: !1, configurable: !0 }), r.prototype.pause = function() {
    return this.isPlaying = !1, this.paused = !0, this;
  }, r.prototype.resume = function() {
    return this.isPlaying = this._instances.length > 0, this.paused = !1, this;
  }, Object.defineProperty(r.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(t) {
    this._paused = t, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(t) {
    this._speed = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "filters", { get: function() {
    return this.media.filters;
  }, set: function(t) {
    this.media.filters = t;
  }, enumerable: !1, configurable: !0 }), r.prototype.addSprites = function(t, e) {
    if (typeof t == "object") {
      var i = {};
      for (var n in t)
        i[n] = this.addSprites(n, t[n]);
      return i;
    }
    var s = new jC(this, e);
    return this._sprites[t] = s, s;
  }, r.prototype.destroy = function() {
    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;
  }, r.prototype.removeSprites = function(t) {
    if (t) {
      var e = this._sprites[t];
      e !== void 0 && (e.destroy(), delete this._sprites[t]);
    } else
      for (var i in this._sprites)
        this.removeSprites(i);
    return this;
  }, Object.defineProperty(r.prototype, "isPlayable", { get: function() {
    return this.isLoaded && this.media && this.media.isPlayable;
  }, enumerable: !1, configurable: !0 }), r.prototype.stop = function() {
    if (!this.isPlayable)
      return this.autoPlay = !1, this._autoPlayOptions = null, this;
    this.isPlaying = !1;
    for (var t = this._instances.length - 1; t >= 0; t--)
      this._instances[t].stop();
    return this;
  }, r.prototype.play = function(t, e) {
    var i, n = this;
    if (typeof t == "string" ? i = { sprite: o = t, loop: this.loop, complete: e } : typeof t == "function" ? (i = {}).complete = t : i = t, (i = Ko({ complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: !1, loop: !1 }, i || {})).sprite) {
      var s = i.sprite, o = this._sprites[s];
      i.start = o.start + (i.start || 0), i.end = o.end, i.speed = o.speed || 1, i.loop = o.loop || i.loop, delete i.sprite;
    }
    if (i.offset && (i.start = i.offset), !this.isLoaded)
      return new Promise(function(l, u) {
        n.autoPlay = !0, n._autoPlayOptions = i, n._preload(function(c, d, f) {
          c ? u(c) : (i.loaded && i.loaded(c, d, f), l(f));
        });
      });
    (this.singleInstance || i.singleInstance) && this._removeInstances();
    var a = this._createInstance();
    return this._instances.push(a), this.isPlaying = !0, a.once("end", function() {
      i.complete && i.complete(n), n._onComplete(a);
    }), a.once("stop", function() {
      n._onComplete(a);
    }), a.play(i), a;
  }, r.prototype.refresh = function() {
    for (var t = this._instances.length, e = 0; e < t; e++)
      this._instances[e].refresh();
  }, r.prototype.refreshPaused = function() {
    for (var t = this._instances.length, e = 0; e < t; e++)
      this._instances[e].refreshPaused();
  }, Object.defineProperty(r.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(t) {
    this._volume = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(t) {
    this._muted = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(t) {
    this._loop = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), r.prototype._preload = function(t) {
    this.media.load(t);
  }, Object.defineProperty(r.prototype, "instances", { get: function() {
    return this._instances;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "sprites", { get: function() {
    return this._sprites;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "duration", { get: function() {
    return this.media.duration;
  }, enumerable: !1, configurable: !0 }), r.prototype.autoPlayStart = function() {
    var t;
    return this.autoPlay && (t = this.play(this._autoPlayOptions)), t;
  }, r.prototype._removeInstances = function() {
    for (var t = this._instances.length - 1; t >= 0; t--)
      this._poolInstance(this._instances[t]);
    this._instances.length = 0;
  }, r.prototype._onComplete = function(t) {
    if (this._instances) {
      var e = this._instances.indexOf(t);
      e > -1 && this._instances.splice(e, 1), this.isPlaying = this._instances.length > 0;
    }
    this._poolInstance(t);
  }, r.prototype._createInstance = function() {
    if (r._pool.length > 0) {
      var t = r._pool.pop();
      return t.init(this.media), t;
    }
    return this.media.create();
  }, r.prototype._poolInstance = function(t) {
    t.destroy(), r._pool.indexOf(t) < 0 && r._pool.push(t);
  }, r._pool = [], r;
}(), VC = function(r) {
  function t() {
    var e = r !== null && r.apply(this, arguments) || this;
    return e.speed = 1, e.muted = !1, e.volume = 1, e.paused = !1, e;
  }
  return Pi(t, r), t.prototype.refresh = function() {
    this.emit("refresh");
  }, t.prototype.refreshPaused = function() {
    this.emit("refreshPaused");
  }, Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "audioContext", { get: function() {
    return null;
  }, enumerable: !1, configurable: !0 }), t.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, t.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this.paused;
  }, t.prototype.destroy = function() {
    this.removeAllListeners();
  }, t;
}(Zi), t0 = function(r) {
  function t() {
    var e = this, i = window, n = new t.AudioContext(), s = n.createDynamicsCompressor(), o = n.createAnalyser();
    return o.connect(s), s.connect(n.destination), (e = r.call(this, o, s) || this)._ctx = n, e._offlineCtx = new t.OfflineAudioContext(1, 2, i.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, n.sampleRate)) : 44100), e.compressor = s, e.analyser = o, e.events = new Zi(), e.volume = 1, e.speed = 1, e.muted = !1, e.paused = !1, e._locked = n.state === "suspended" && ("ontouchstart" in globalThis || "onclick" in globalThis), e._locked && (e._unlock(), e._unlock = e._unlock.bind(e), document.addEventListener("mousedown", e._unlock, !0), document.addEventListener("touchstart", e._unlock, !0), document.addEventListener("touchend", e._unlock, !0)), e.onFocus = e.onFocus.bind(e), e.onBlur = e.onBlur.bind(e), globalThis.addEventListener("focus", e.onFocus), globalThis.addEventListener("blur", e.onBlur), e;
  }
  return Pi(t, r), t.prototype.onFocus = function() {
    var e = this._ctx.state;
    e !== "suspended" && e !== "interrupted" && this._locked || this._ctx.resume();
  }, t.prototype.onBlur = function() {
    this._locked || this._ctx.suspend();
  }, t.prototype._unlock = function() {
    this._locked && (this.playEmptySound(), this._ctx.state === "running" && (document.removeEventListener("mousedown", this._unlock, !0), document.removeEventListener("touchend", this._unlock, !0), document.removeEventListener("touchstart", this._unlock, !0), this._locked = !1));
  }, t.prototype.playEmptySound = function() {
    var e = this._ctx.createBufferSource();
    e.buffer = this._ctx.createBuffer(1, 1, 22050), e.connect(this._ctx.destination), e.start(0, 0, 0), e.context.state === "suspended" && e.context.resume();
  }, Object.defineProperty(t, "AudioContext", { get: function() {
    var e = window;
    return e.AudioContext || e.webkitAudioContext || null;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "OfflineAudioContext", { get: function() {
    var e = window;
    return e.OfflineAudioContext || e.webkitOfflineAudioContext || null;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    r.prototype.destroy.call(this);
    var e = this._ctx;
    e.close !== void 0 && e.close(), globalThis.removeEventListener("focus", this.onFocus), globalThis.removeEventListener("blur", this.onBlur), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;
  }, Object.defineProperty(t.prototype, "audioContext", { get: function() {
    return this._ctx;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "offlineContext", { get: function() {
    return this._offlineCtx;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    e && this._ctx.state === "running" ? this._ctx.suspend() : e || this._ctx.state !== "suspended" || this._ctx.resume(), this._paused = e;
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    this.events.emit("refresh");
  }, t.prototype.refreshPaused = function() {
    this.events.emit("refreshPaused");
  }, t.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, t.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this._paused;
  }, t.prototype.decode = function(e, i) {
    var n = function(o) {
      i(new Error((o == null ? void 0 : o.message) || "Unable to decode file"));
    }, s = this._offlineCtx.decodeAudioData(e, function(o) {
      i(null, o);
    }, n);
    s && s.catch(n);
  }, t;
}(sx), XC = function() {
  function r() {
    this.init();
  }
  return r.prototype.init = function() {
    return this.supported && (this._webAudioContext = new t0()), this._htmlAudioContext = new VC(), this._sounds = {}, this.useLegacy = !this.supported, this;
  }, Object.defineProperty(r.prototype, "context", { get: function() {
    return this._context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "filtersAll", { get: function() {
    return this.useLegacy ? [] : this._context.filters;
  }, set: function(t) {
    this.useLegacy || (this._context.filters = t);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "supported", { get: function() {
    return t0.AudioContext !== null;
  }, enumerable: !1, configurable: !0 }), r.prototype.add = function(t, e) {
    if (typeof t == "object") {
      var i = {};
      for (var n in t) {
        var s = this._getOptions(t[n], e);
        i[n] = this.add(n, s);
      }
      return i;
    }
    if (e instanceof wa)
      return this._sounds[t] = e, e;
    var o = this._getOptions(e), a = wa.from(o);
    return this._sounds[t] = a, a;
  }, r.prototype._getOptions = function(t, e) {
    var i;
    return i = typeof t == "string" ? { url: t } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? { source: t } : t, i = Ko(Ko({}, i), e || {});
  }, Object.defineProperty(r.prototype, "useLegacy", { get: function() {
    return this._useLegacy;
  }, set: function(t) {
    rm.setLegacy(t), this._useLegacy = t, this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext;
  }, enumerable: !1, configurable: !0 }), r.prototype.remove = function(t) {
    return this.exists(t, !0), this._sounds[t].destroy(), delete this._sounds[t], this;
  }, Object.defineProperty(r.prototype, "volumeAll", { get: function() {
    return this._context.volume;
  }, set: function(t) {
    this._context.volume = t, this._context.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, "speedAll", { get: function() {
    return this._context.speed;
  }, set: function(t) {
    this._context.speed = t, this._context.refresh();
  }, enumerable: !1, configurable: !0 }), r.prototype.togglePauseAll = function() {
    return this._context.togglePause();
  }, r.prototype.pauseAll = function() {
    return this._context.paused = !0, this._context.refreshPaused(), this;
  }, r.prototype.resumeAll = function() {
    return this._context.paused = !1, this._context.refreshPaused(), this;
  }, r.prototype.toggleMuteAll = function() {
    return this._context.toggleMute();
  }, r.prototype.muteAll = function() {
    return this._context.muted = !0, this._context.refresh(), this;
  }, r.prototype.unmuteAll = function() {
    return this._context.muted = !1, this._context.refresh(), this;
  }, r.prototype.removeAll = function() {
    for (var t in this._sounds)
      this._sounds[t].destroy(), delete this._sounds[t];
    return this;
  }, r.prototype.stopAll = function() {
    for (var t in this._sounds)
      this._sounds[t].stop();
    return this;
  }, r.prototype.exists = function(t, e) {
    return !!this._sounds[t];
  }, r.prototype.find = function(t) {
    return this.exists(t, !0), this._sounds[t];
  }, r.prototype.play = function(t, e) {
    return this.find(t).play(e);
  }, r.prototype.stop = function(t) {
    return this.find(t).stop();
  }, r.prototype.pause = function(t) {
    return this.find(t).pause();
  }, r.prototype.resume = function(t) {
    return this.find(t).resume();
  }, r.prototype.volume = function(t, e) {
    var i = this.find(t);
    return e !== void 0 && (i.volume = e), i.volume;
  }, r.prototype.speed = function(t, e) {
    var i = this.find(t);
    return e !== void 0 && (i.speed = e), i.speed;
  }, r.prototype.duration = function(t) {
    return this.find(t).duration;
  }, r.prototype.close = function() {
    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;
  }, r;
}(), jn = function() {
  function r(t, e) {
    this.init(t, e);
  }
  return r.prototype.init = function(t, e) {
    this.destination = t, this.source = e || t;
  }, r.prototype.connect = function(t) {
    this.source.connect(t);
  }, r.prototype.disconnect = function() {
    this.source.disconnect();
  }, r.prototype.destroy = function() {
    this.disconnect(), this.destination = null, this.source = null;
  }, r;
}(), of = { __proto__: null, Filter: jn, EqualizerFilter: function(r) {
  function t(e, i, n, s, o, a, l, u, c, d) {
    e === void 0 && (e = 0), i === void 0 && (i = 0), n === void 0 && (n = 0), s === void 0 && (s = 0), o === void 0 && (o = 0), a === void 0 && (a = 0), l === void 0 && (l = 0), u === void 0 && (u = 0), c === void 0 && (c = 0), d === void 0 && (d = 0);
    var f = this;
    if (!de().useLegacy) {
      var v = [{ f: t.F32, type: "lowshelf", gain: e }, { f: t.F64, type: "peaking", gain: i }, { f: t.F125, type: "peaking", gain: n }, { f: t.F250, type: "peaking", gain: s }, { f: t.F500, type: "peaking", gain: o }, { f: t.F1K, type: "peaking", gain: a }, { f: t.F2K, type: "peaking", gain: l }, { f: t.F4K, type: "peaking", gain: u }, { f: t.F8K, type: "peaking", gain: c }, { f: t.F16K, type: "highshelf", gain: d }].map(function(y) {
        var b = de().context.audioContext.createBiquadFilter();
        return b.type = y.type, Ai.setParamValue(b.Q, 1), b.frequency.value = y.f, Ai.setParamValue(b.gain, y.gain), b;
      });
      (f = r.call(this, v[0], v[v.length - 1]) || this).bands = v, f.bandsMap = {};
      for (var m = 0; m < f.bands.length; m++) {
        var p = f.bands[m];
        m > 0 && f.bands[m - 1].connect(p), f.bandsMap[p.frequency.value] = p;
      }
      return f;
    }
    f = r.call(this, null) || this;
  }
  return Pi(t, r), t.prototype.setGain = function(e, i) {
    if (i === void 0 && (i = 0), !this.bandsMap[e])
      throw new Error("No band found for frequency ".concat(e));
    Ai.setParamValue(this.bandsMap[e].gain, i);
  }, t.prototype.getGain = function(e) {
    if (!this.bandsMap[e])
      throw new Error("No band found for frequency ".concat(e));
    return this.bandsMap[e].gain.value;
  }, Object.defineProperty(t.prototype, "f32", { get: function() {
    return this.getGain(t.F32);
  }, set: function(e) {
    this.setGain(t.F32, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f64", { get: function() {
    return this.getGain(t.F64);
  }, set: function(e) {
    this.setGain(t.F64, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f125", { get: function() {
    return this.getGain(t.F125);
  }, set: function(e) {
    this.setGain(t.F125, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f250", { get: function() {
    return this.getGain(t.F250);
  }, set: function(e) {
    this.setGain(t.F250, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f500", { get: function() {
    return this.getGain(t.F500);
  }, set: function(e) {
    this.setGain(t.F500, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f1k", { get: function() {
    return this.getGain(t.F1K);
  }, set: function(e) {
    this.setGain(t.F1K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f2k", { get: function() {
    return this.getGain(t.F2K);
  }, set: function(e) {
    this.setGain(t.F2K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f4k", { get: function() {
    return this.getGain(t.F4K);
  }, set: function(e) {
    this.setGain(t.F4K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f8k", { get: function() {
    return this.getGain(t.F8K);
  }, set: function(e) {
    this.setGain(t.F8K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f16k", { get: function() {
    return this.getGain(t.F16K);
  }, set: function(e) {
    this.setGain(t.F16K, e);
  }, enumerable: !1, configurable: !0 }), t.prototype.reset = function() {
    this.bands.forEach(function(e) {
      Ai.setParamValue(e.gain, 0);
    });
  }, t.prototype.destroy = function() {
    this.bands.forEach(function(e) {
      e.disconnect();
    }), this.bands = null, this.bandsMap = null;
  }, t.F32 = 32, t.F64 = 64, t.F125 = 125, t.F250 = 250, t.F500 = 500, t.F1K = 1e3, t.F2K = 2e3, t.F4K = 4e3, t.F8K = 8e3, t.F16K = 16e3, t;
}(jn), DistortionFilter: function(r) {
  function t(e) {
    e === void 0 && (e = 0);
    var i = this;
    if (!de().useLegacy) {
      var n = de().context.audioContext.createWaveShaper();
      return (i = r.call(this, n) || this)._distortion = n, i.amount = e, i;
    }
    i = r.call(this, null) || this;
  }
  return Pi(t, r), Object.defineProperty(t.prototype, "amount", { get: function() {
    return this._amount;
  }, set: function(e) {
    this._amount = e;
    for (var i, n = 1e3 * e, s = 44100, o = new Float32Array(s), a = Math.PI / 180, l = 0; l < s; ++l)
      i = 2 * l / s - 1, o[l] = (3 + n) * i * 20 * a / (Math.PI + n * Math.abs(i));
    this._distortion.curve = o, this._distortion.oversample = "4x";
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this._distortion = null, r.prototype.destroy.call(this);
  }, t;
}(jn), StereoFilter: function(r) {
  function t(e) {
    e === void 0 && (e = 0);
    var i = this;
    if (!de().useLegacy) {
      var n, s, o, a = de().context.audioContext;
      return a.createStereoPanner ? o = n = a.createStereoPanner() : ((s = a.createPanner()).panningModel = "equalpower", o = s), (i = r.call(this, o) || this)._stereo = n, i._panner = s, i.pan = e, i;
    }
    i = r.call(this, null) || this;
  }
  return Pi(t, r), Object.defineProperty(t.prototype, "pan", { get: function() {
    return this._pan;
  }, set: function(e) {
    this._pan = e, this._stereo ? Ai.setParamValue(this._stereo.pan, e) : this._panner.setPosition(e, 0, 1 - Math.abs(e));
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    r.prototype.destroy.call(this), this._stereo = null, this._panner = null;
  }, t;
}(jn), ReverbFilter: function(r) {
  function t(e, i, n) {
    e === void 0 && (e = 3), i === void 0 && (i = 2), n === void 0 && (n = !1);
    var s = this;
    if (!de().useLegacy)
      return (s = r.call(this, null) || this)._seconds = s._clamp(e, 1, 50), s._decay = s._clamp(i, 0, 100), s._reverse = n, s._rebuild(), s;
    s = r.call(this, null) || this;
  }
  return Pi(t, r), t.prototype._clamp = function(e, i, n) {
    return Math.min(n, Math.max(i, e));
  }, Object.defineProperty(t.prototype, "seconds", { get: function() {
    return this._seconds;
  }, set: function(e) {
    this._seconds = this._clamp(e, 1, 50), this._rebuild();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "decay", { get: function() {
    return this._decay;
  }, set: function(e) {
    this._decay = this._clamp(e, 0, 100), this._rebuild();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "reverse", { get: function() {
    return this._reverse;
  }, set: function(e) {
    this._reverse = e, this._rebuild();
  }, enumerable: !1, configurable: !0 }), t.prototype._rebuild = function() {
    for (var e, i = de().context.audioContext, n = i.sampleRate, s = n * this._seconds, o = i.createBuffer(2, s, n), a = o.getChannelData(0), l = o.getChannelData(1), u = 0; u < s; u++)
      e = this._reverse ? s - u : u, a[u] = (2 * Math.random() - 1) * Math.pow(1 - e / s, this._decay), l[u] = (2 * Math.random() - 1) * Math.pow(1 - e / s, this._decay);
    var c = de().context.audioContext.createConvolver();
    c.buffer = o, this.init(c);
  }, t;
}(jn), MonoFilter: function(r) {
  function t() {
    var e = this;
    if (!de().useLegacy) {
      var i = de().context.audioContext, n = i.createChannelSplitter(), s = i.createChannelMerger();
      return s.connect(n), (e = r.call(this, s, n) || this)._merger = s, e;
    }
    e = r.call(this, null) || this;
  }
  return Pi(t, r), t.prototype.destroy = function() {
    this._merger.disconnect(), this._merger = null, r.prototype.destroy.call(this);
  }, t;
}(jn), StreamFilter: function(r) {
  function t() {
    var e = this;
    if (!de().useLegacy) {
      var i = de().context.audioContext, n = i.createMediaStreamDestination(), s = i.createMediaStreamSource(n.stream);
      return (e = r.call(this, n, s) || this)._stream = n.stream, e;
    }
    e = r.call(this, null) || this;
  }
  return Pi(t, r), Object.defineProperty(t.prototype, "stream", { get: function() {
    return this._stream;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this._stream = null, r.prototype.destroy.call(this);
  }, t;
}(jn), TelephoneFilter: function(r) {
  function t() {
    if (!de().useLegacy) {
      var e = de().context.audioContext, i = e.createBiquadFilter(), n = e.createBiquadFilter(), s = e.createBiquadFilter(), o = e.createBiquadFilter();
      return i.type = "lowpass", Ai.setParamValue(i.frequency, 2e3), n.type = "lowpass", Ai.setParamValue(n.frequency, 2e3), s.type = "highpass", Ai.setParamValue(s.frequency, 500), o.type = "highpass", Ai.setParamValue(o.frequency, 500), i.connect(n), n.connect(s), s.connect(o), r.call(this, i, o) || this;
    }
    r.call(this, null);
  }
  return Pi(t, r), t;
}(jn) }, e0 = 0, WC = { __proto__: null, playOnce: function(r, t) {
  var e = "alias".concat(e0++);
  return de().add(e, { url: r, preload: !0, autoPlay: !0, loaded: function(i) {
    i && (de().remove(e), t && t(i));
  }, complete: function() {
    de().remove(e), t && t(null);
  } }), e;
}, get PLAY_ID() {
  return e0;
}, render: function(r, t) {
  var e = document.createElement("canvas");
  t = Ko({ width: 512, height: 128, fill: "black" }, t || {}), e.width = t.width, e.height = t.height;
  var i = Mt.from(e);
  if (!(r.media instanceof nm))
    return i;
  var n = r.media, s = e.getContext("2d");
  s.fillStyle = t.fill;
  for (var o = n.buffer.getChannelData(0), a = Math.ceil(o.length / t.width), l = t.height / 2, u = 0; u < t.width; u++) {
    for (var c = 1, d = -1, f = 0; f < a; f++) {
      var v = o[u * a + f];
      v < c && (c = v), v > d && (d = v);
    }
    s.fillRect(u, (1 + c) * l, 1, Math.max(1, (d - c) * l));
  }
  return i;
}, resolveUrl: k_, sineTone: function(r, t) {
  r === void 0 && (r = 200), t === void 0 && (t = 1);
  var e = wa.from({ singleInstance: !0 });
  if (!(e.media instanceof nm))
    return e;
  for (var i = e.media, n = e.context.audioContext.createBuffer(1, 48e3 * t, 48e3), s = n.getChannelData(0), o = 0; o < s.length; o++) {
    var a = r * (o / n.sampleRate) * Math.PI;
    s[o] = 2 * Math.sin(a);
  }
  return i.buffer = n, e.isLoaded = !0, e;
}, validateFormats: nx, supported: Lv, extensions: R_ }, on = function(r) {
  return ix = r, r;
}(new XC());
"extensions" in iO ? Tr.add(rm) : Oi.registerPlugin(rm);
var ae, je, Yn, Nd, ox, Ra, Tf, Ad, ax, Ld, hx, tu, sm, $s, il, eu, om, ka, Na, Sf, iu, am, ru, Aa, Pf, Dd, lx, Ir, zn, Fd, ux, nu, hm, zs, rl, Bd, cx, su, lm, Ud, fx, Gd, dx, La, Of;
const bl = class {
  constructor(t, e, i, n, s) {
    // 音量設定（独自拡張）
    _(this, Nd);
    _(this, Ra);
    // BGM/効果音のフェードアウト（loadから使うのでマクロ化禁止）
    _(this, Ad);
    // 効果音のフェードアウト（loadから使うのでマクロ化禁止）
    _(this, Ld);
    // BGMのフェード（loadから使うのでマクロ化禁止）
    _(this, tu);
    // 効果音のフェード
    _(this, $s);
    // BGM の演奏
    _(this, eu);
    _(this, Na);
    _(this, iu);
    // 全効果音再生の停止
    _(this, Aa);
    // BGM 演奏の停止（loadから使うのでマクロ化禁止）
    _(this, Dd);
    // 効果音再生の停止
    _(this, Ir);
    // BGM フェードの終了待ち
    _(this, Fd);
    // 効果音フェードの終了待ち
    _(this, nu);
    // 音声フェードの停止
    _(this, zs);
    // BGM 再生の終了待ち
    _(this, Bd);
    // 効果音再生の終了待ち
    _(this, su);
    // 再生トラックの交換
    _(this, Ud);
    _(this, Gd);
    _(this, La);
    _(this, ae, {});
    _(this, je, {});
    _(this, Yn, void 0);
    _(this, ru, () => {
      on.volumeAll = Number(this.val.getVal("sys:sn.sound.global_volume", 1)), g(this, ru, () => {
      });
    });
    this.cfg = t, this.val = i, this.main = n, this.sys = s, e.volume = (o) => x(this, Nd, ox).call(this, o), e.fadebgm = (o) => x(this, tu, sm).call(this, o), e.fadeoutbgm = (o) => x(this, Ad, ax).call(this, o), e.fadeoutse = (o) => x(this, Ld, hx).call(this, o), e.fadese = (o) => x(this, $s, il).call(this, o), e.playbgm = (o) => x(this, eu, om).call(this, o), e.playse = (o) => x(this, Na, Sf).call(this, o), e.stop_allse = () => x(this, Aa, Pf).call(this), e.stopbgm = (o) => x(this, Dd, lx).call(this, o), e.stopse = (o) => x(this, Ir, zn).call(this, o), e.wb = (o) => x(this, Fd, ux).call(this, o), e.wf = (o) => x(this, nu, hm).call(this, o), e.stopfadese = (o) => x(this, zs, rl).call(this, o), e.wl = (o) => x(this, Bd, cx).call(this, o), e.ws = (o) => x(this, su, lm).call(this, o), e.xchgbuf = (o) => x(this, Ud, fx).call(this, o), this.val.setVal_Nochk("save", "const.sn.loopPlaying", "{}"), i.setVal_Nochk("tmp", "const.sn.sound.codecs", JSON.stringify(WC.supported));
  }
  setEvtMng(t) {
    g(this, Yn, t);
  }
  setNoticeChgVolume(t, e) {
    this.val.defValTrg("sys:sn.sound.global_volume", (i, n) => t(on.volumeAll = Number(n))), this.val.defValTrg("sys:sn.sound.movie_volume", (i, n) => e(Number(n))), this.val.setVal_Nochk("sys", "sn.sound.global_volume", this.val.getVal("sys:sn.sound.global_volume", 1)), this.val.setVal_Nochk("sys", "sn.sound.movie_volume", this.val.getVal("sys:sn.sound.movie_volume", 1));
  }
  clearCache() {
    on.removeAll();
  }
  // しおりの読込（BGM状態復元）
  playLoopFromSaveObj() {
    const t = String(this.val.getVal("save:const.sn.loopPlaying", "{}"));
    if (this.val.flush(), t === "{}") {
      x(this, Aa, Pf).call(this);
      return;
    }
    g(this, je, JSON.parse(t));
    const e = Object.keys(h(this, je)).map((i) => () => {
      const n = "save:const.sn.sound." + i + ".", s = {
        fn: String(this.val.getVal(n + "fn")),
        buf: i,
        join: !1,
        loop: !0,
        volume: Number(this.val.getVal(n + "volume")),
        start_ms: Number(this.val.getVal(n + "start_ms")),
        end_ms: Number(this.val.getVal(n + "end_ms")),
        ret_ms: Number(this.val.getVal(n + "ret_ms"))
      };
      s.buf === "BGM" ? x(this, eu, om).call(this, s) : x(this, Na, Sf).call(this, s);
    });
    x(this, Aa, Pf).call(this);
    for (const i of e)
      i();
  }
};
let Ef = bl;
ae = new WeakMap(), je = new WeakMap(), Yn = new WeakMap(), Nd = new WeakSet(), ox = function(t) {
  const { buf: e = "SE" } = t, i = "const.sn.sound." + e + ".volume", n = x(this, Ra, Tf).call(this, t, 1);
  return Number(this.val.getVal("sys:" + i)) === n ? !1 : (this.val.setVal_Nochk("sys", i, n), this.val.flush(), t.time = 0, t.volume = Number(this.val.getVal("save:" + i)), x(this, $s, il).call(this, t));
}, Ra = new WeakSet(), Tf = function(t, e) {
  const i = j(t, "volume", e);
  return i < 0 ? 0 : i > 1 ? 1 : i;
}, Ad = new WeakSet(), ax = function(t) {
  return t.volume = 0, x(this, tu, sm).call(this, t);
}, Ld = new WeakSet(), hx = function(t) {
  return t.volume = 0, x(this, $s, il).call(this, t);
}, tu = new WeakSet(), sm = function(t) {
  return t.buf = "BGM", x(this, $s, il).call(this, t);
}, $s = new WeakSet(), il = function(t) {
  x(this, zs, rl).call(this, t);
  const { buf: e = "SE" } = t, i = h(this, ae)[e];
  if (!(i != null && i.playing()) || !i.snd)
    return !1;
  const n = "const.sn.sound." + e + ".", s = n + "volume", o = x(this, Ra, Tf).call(this, t, NaN);
  this.val.setVal_Nochk("save", s, o);
  const a = o * Number(this.val.getVal("sys:" + s, 1)), l = K(t, "stop", o === 0);
  l && (x(this, La, Of).call(this, e), this.val.setVal_Nochk("save", n + "fn", "")), this.val.flush();
  const u = j(t, "time", NaN), c = j(t, "delay", 0);
  if (u === 0 && c === 0 || this.val.getVal("tmp:sn.skip.enabled") || h(this, Yn).isSkippingByKeyDown())
    return i.snd.volume = a, l && x(this, Ir, zn).call(this, t), !1;
  const d = j(t, "repeat", 1);
  return i.updFade = (f) => i.snd.volume = f, i.twFade = new zr({ v: i.snd.volume }).to({ v: a }, u).delay(c).easing(Fn.ease(t.ease)).repeat(d === 0 ? 1 / 0 : d - 1).yoyo(K(t, "yoyo", !1)).onUpdate(({ v: f }) => i.updFade(f)).onComplete(() => {
    const f = h(this, ae)[i.now_buf];
    (f == null ? void 0 : f.twFade) !== void 0 && (f.updFade = () => {
    }, LC(f.twFade), delete f.twFade, l && (t.buf = i.now_buf, x(this, Ir, zn).call(this, t)), f.resumeFade && this.main.resume());
  }).start(), !1;
}, eu = new WeakSet(), om = function(t) {
  return t.buf = "BGM", t.canskip = !1, K(t, "loop", !0), x(this, Na, Sf).call(this, t);
}, ka = new WeakMap(), Na = new WeakSet(), Sf = function(t) {
  const { buf: e = "SE", fn: i } = t;
  if (x(this, Ir, zn).call(this, { buf: e }), !i)
    throw `[playse] fnは必須です buf:${e}`;
  if (K(t, "canskip", !0) && h(this, Yn).isSkippingByKeyDown())
    return !1;
  const n = K(t, "loop", !1);
  x(this, Gd, dx).call(this, e, n);
  const s = "const.sn.sound." + e + ".";
  this.val.setVal_Nochk("save", s + "fn", i);
  const o = x(this, Ra, Tf).call(this, t, 1);
  this.val.setVal_Nochk("save", s + "volume", o);
  const a = o * Number(this.val.getVal("sys:" + s + "volume", 1)), l = j(t, "start_ms", 0), u = j(t, "end_ms", h(bl, ka)), c = j(t, "ret_ms", 0), d = j(t, "pan", 0), f = j(t, "speed", 1);
  if (l < 0)
    throw `[playse] start_ms:${l} が負の値です`;
  if (c < 0)
    throw `[playse] ret_ms:${c} が負の値です`;
  if (u > 0) {
    if (l >= u)
      throw `[playse] start_ms:${l} >= end_ms:${u} は異常値です`;
    if (c >= u)
      throw `[playse] ret_ms:${c} >= end_ms:${u} は異常値です`;
  }
  this.val.setVal_Nochk("save", s + "start_ms", l), this.val.setVal_Nochk("save", s + "end_ms", u), this.val.setVal_Nochk("save", s + "ret_ms", c), this.val.flush();
  const v = on.find(i), m = h(this, ae)[e] = {
    now_buf: e,
    snd: v,
    loop: n,
    start_ms: l,
    end_ms: u,
    ret_ms: c,
    resume: !1,
    pan: d,
    playing: () => !0,
    // [ws]的にはここでtrueが欲しい
    updFade: () => {
    },
    onend: () => {
      const w = m.now_buf, E = h(this, ae)[w];
      if (!E)
        return;
      delete h(this, ae)[w], E.playing = () => !1;
      const O = "const.sn.sound." + w + ".";
      this.val.setVal_Nochk("tmp", O + "playing", !1), t.buf = w, x(this, zs, rl).call(this, t), E.resume && this.main.resume();
    }
  };
  this.val.setVal_Nochk("tmp", s + "playing", !0);
  const p = {
    loop: n,
    speed: f,
    volume: a,
    loaded: (w, E) => {
      if (w) {
        this.main.errScript(`Sound ロード失敗ですa fn:${i} ${w}`, !1);
        return;
      }
      if (!E)
        return;
      const O = h(this, ae)[m.now_buf];
      O && (O.snd = E);
    }
  };
  let y = "";
  if (l > 0 || u < h(bl, ka)) {
    y = `${i};${l};${u};${c}`;
    const w = (p.sprites ?? (p.sprites = {}))[y] = {
      start: l / 1e3,
      end: u / 1e3
    };
    p.preload = !0;
    const E = p.loaded;
    p.loaded = (O, I) => {
      E(O, I);
      const S = I, C = S.duration;
      if (w.end < 0) {
        if (w.end += C, S.removeSprites(y), S.addSprites(y, w), w.start >= w.end)
          throw `[playse] start_ms:${l} >= end_ms:${u}(${w.end * 1e3}) は異常値です`;
        if (c >= w.end * 1e3)
          throw `[playse] ret_ms:${c} >= end_ms:${u}(${w.end * 1e3}) は異常値です`;
      }
      if (w.start >= C)
        throw `[playse] start_ms:${l} >= 音声ファイル再生時間:${C} は異常値です`;
      if (u !== h(bl, ka) && w.end >= C)
        throw `[playse] end_ms:${u} >= 音声ファイル再生時間:${C} は異常値です`;
      S.play(y, p.complete);
    };
  } else
    p.autoPlay = !0;
  if (n ? c !== 0 && (p.loop = !1, p.complete = async (w) => {
    const E = w.duration, O = c / 1e3, I = u / 1e3;
    if (O >= E)
      throw `[playse] ret_ms:${c} >= 音声ファイル再生時間:${E} は異常値です`;
    await on.play(i, {
      // 一周目はループなし、なのでキャッシュされてる
      start: O,
      end: I < 0 ? I + E : I,
      // 負の値は末尾から
      speed: f,
      loop: !0,
      volume: a,
      //	sprite	: sp_nm2,	// err
      //-	muted?: boolean;
      filters: m.pan !== 0 ? [new of.StereoFilter(m.pan)] : []
      //-	complete?: CompleteCallback;
      //-	loaded?: LoadedCallback;
      //-	singleInstance?: boolean;
    });
    const S = h(this, ae)[m.now_buf];
    S && (S.snd = on.find(i));
  }) : p.complete = () => {
    var w;
    return (w = h(this, ae)[m.now_buf]) == null ? void 0 : w.onend();
  }, h(this, ru).call(this), v) {
    if (v.volume = a, y)
      x(this, iu, am).call(this, e, i, p);
    else if (v.isPlayable) {
      const w = v.options.source;
      !(w instanceof ArrayBuffer) || w.byteLength === 0 ? v.play(p) : m.snd = wa.from({
        ...p,
        url: v.options.url,
        source: w
      }), v.filters = [new of.StereoFilter(d)];
    }
    return !1;
  }
  const b = K(t, "join", !0);
  if (b) {
    const w = p.loaded;
    p.loaded = (E, O) => {
      w == null || w(E, O), this.main.resume();
    };
  }
  return x(this, iu, am).call(this, e, i, p), b;
}, iu = new WeakSet(), am = function(t, e, i) {
  const n = this.cfg.searchPath(e, Xe.SOUND);
  if (n.slice(-4) !== ".bin") {
    i.url = n;
    const s = wa.from(i);
    if (t) {
      const o = h(this, ae)[t];
      if (!o)
        return;
      o.snd = s, o.pan !== 0 && (s.filters = [new of.StereoFilter(o.pan)]);
    }
    i.loop || on.add(e, s);
    return;
  }
  new Oi().add({ name: e, url: n, xhrType: bt.XHR_RESPONSE_TYPE.BUFFER }).use((s, o) => {
    this.sys.dec(s.extension, s.data).then((a) => {
      s.data = a, o == null || o();
    }).catch((a) => this.main.errScript(`Sound ロード失敗ですc fn:${s.name} ${a}`, !1));
  }).load((s, o) => {
    var l;
    i.source = (l = o[e]) == null ? void 0 : l.data;
    const a = wa.from(i);
    if (t) {
      const u = h(this, ae)[t];
      if (!u)
        return;
      u.snd = a, u.pan !== 0 && (a.filters = [new of.StereoFilter(u.pan)]);
    }
    i.loop || on.add(e, a);
  });
}, ru = new WeakMap(), Aa = new WeakSet(), Pf = function() {
  for (const t of Object.keys(h(this, ae)))
    x(this, Ir, zn).call(this, { buf: t });
  return g(this, ae, {}), on.stopAll(), !1;
}, Dd = new WeakSet(), lx = function(t) {
  return t.buf = "BGM", x(this, Ir, zn).call(this, t);
}, Ir = new WeakSet(), zn = function(t) {
  var n;
  const { buf: e = "SE" } = t;
  x(this, La, Of).call(this, e);
  const i = h(this, ae)[e];
  return i && ((n = i.snd) == null || n.stop(), i.onend()), !1;
}, Fd = new WeakSet(), ux = function(t) {
  return t.buf = "BGM", x(this, nu, hm).call(this, t);
}, nu = new WeakSet(), hm = function(t) {
  const { buf: e = "SE" } = t, i = h(this, ae)[e];
  return !(i != null && i.twFade) || !i.playing() ? !1 : i.resumeFade = h(this, Yn).waitEvent(
    () => x(this, zs, rl).call(this, t),
    K(t, "canskip", !0),
    K(t, "global", !1)
  );
}, zs = new WeakSet(), rl = function(t) {
  var i, n;
  const { buf: e = "SE" } = t;
  return (n = (i = h(this, ae)[e]) == null ? void 0 : i.twFade) == null || n.stop().end(), !1;
}, Bd = new WeakSet(), cx = function(t) {
  return t.buf = "BGM", x(this, su, lm).call(this, t);
}, su = new WeakSet(), lm = function(t) {
  const { buf: e = "SE" } = t, i = h(this, ae)[e];
  return !(i != null && i.playing()) || i.loop ? !1 : i.resume = h(this, Yn).waitEvent(
    () => {
      t.buf = i.now_buf, x(this, Ir, zn).call(this, t);
      const n = h(this, ae)[t.buf];
      !(n != null && n.playing()) || n.loop || n.onend();
    },
    K(t, "canskip", !1),
    K(t, "global", !1)
  );
}, Ud = new WeakSet(), fx = function(t) {
  const { buf: e = "SE", buf2: i = "SE" } = t;
  if (e === i)
    return !1;
  const n = h(this, ae)[e];
  n && (n.now_buf = i);
  const s = h(this, ae)[i];
  s && (s.now_buf = e), [h(this, ae)[e], h(this, ae)[i]] = [s, n];
  const o = "const.sn.sound." + e + ".", a = Number(this.val.getVal("save:" + o + "volume")), l = Number(this.val.getVal("save:" + o + "fn")), u = String(this.val.getVal("tmp:" + o + "playing")) === "true", c = "const.sn.sound." + i + ".", d = Number(this.val.getVal("save:" + c + "volume")), f = Number(this.val.getVal("save:" + c + "fn")), v = String(this.val.getVal("tmp:" + c + "playing")) === "true";
  return this.val.setVal_Nochk("save", o + "volume", d), this.val.setVal_Nochk("save", c + "volume", a), this.val.setVal_Nochk("save", o + "fn", f), this.val.setVal_Nochk("save", c + "fn", l), this.val.setVal_Nochk("tmp", o + "playing", v), this.val.setVal_Nochk("tmp", c + "playing", u), e in h(this, je) == i in h(this, je) && (e in h(this, je) ? (delete h(this, je)[e], h(this, je)[i] = 0) : (delete h(this, je)[i], h(this, je)[e] = 0), this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(h(this, je)))), this.val.flush(), !1;
}, Gd = new WeakSet(), dx = function(t, e) {
  if (!e) {
    x(this, La, Of).call(this, t);
    return;
  }
  h(this, je)[t] = 0, this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(h(this, je))), this.val.flush();
}, La = new WeakSet(), Of = function(t) {
  delete h(this, je)[t], this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(h(this, je))), this.val.flush();
}, // 効果音の再生
_(Ef, ka, 999e3);
var Zt;
const H_ = class {
  constructor(t, e, i, n, s, o, a, l) {
    _(this, Zt, void 0);
    D(this, "lay", (t) => this.getPage(t).lay(t));
    D(this, "getPage", (t) => H_.argChk_page(t, "fore") !== "back" ? h(this, Zt).fore : h(this, Zt).back);
    this.cls = e, this.hArg = s, this.sys = o, this.val = a, this.ret = l;
    const u = o.hFactoryCls[e];
    if (!u)
      throw `属性 class【${e}】が不正です`;
    const c = u(), d = u();
    c.layname = d.layname = t;
    const f = s[":id_tag"] = `layer:${t} cls:${e} page:`;
    c.spLay.name = c.name = f + "A", c.spLay.name = d.name = f + "B", i.addChild(c.spLay), n.addChild(d.spLay), K(s, "visible", !0), K(s, "visible", !0), l.isWait = c.lay(s) || d.lay(s), g(this, Zt, { fore: c, back: d });
    const v = `const.sn.lay.${t}`;
    a.setVal_Nochk("tmp", v, !0), a.defTmp(v + ".fore.alpha", () => h(this, Zt).fore.alpha), a.defTmp(v + ".back.alpha", () => h(this, Zt).back.alpha), a.defTmp(v + ".fore.height", () => h(this, Zt).fore.height), a.defTmp(v + ".back.height", () => h(this, Zt).back.height), a.defTmp(v + ".fore.visible", () => h(this, Zt).fore.spLay.visible), a.defTmp(v + ".back.visible", () => h(this, Zt).back.spLay.visible), a.defTmp(v + ".fore.width", () => h(this, Zt).fore.width), a.defTmp(v + ".back.width", () => h(this, Zt).back.width), a.defTmp(v + ".fore.x", () => h(this, Zt).fore.x), a.defTmp(v + ".back.x", () => h(this, Zt).back.x), a.defTmp(v + ".fore.y", () => h(this, Zt).fore.y), a.defTmp(v + ".back.y", () => h(this, Zt).back.y);
  }
  destroy() {
    h(this, Zt).fore.destroy(), h(this, Zt).back.destroy();
  }
  static argChk_page(t, e) {
    const i = t.page ?? e;
    if (i === "fore" || i === "back")
      return t.page = i;
    throw Error("属性 page【" + i + "】が不正です");
  }
  get fore() {
    return h(this, Zt).fore;
  }
  get back() {
    return h(this, Zt).back;
  }
  transPage(t) {
    [h(this, Zt).back, h(this, Zt).fore] = [h(this, Zt).fore, h(this, Zt).back], h(this, Zt).back.copy(h(this, Zt).fore, t);
  }
};
let ml = H_;
Zt = new WeakMap();
var jd, Hd;
const hn = class {
  constructor() {
    D(this, "layname", "");
    D(this, "name_", "");
    D(this, "spLay", new ge(ut.EMPTY));
  }
  set name(t) {
    this.name_ = t;
  }
  get name() {
    return this.name_;
  }
  // tsy用
  get alpha() {
    return this.spLay.alpha;
  }
  set alpha(t) {
    this.spLay.alpha = t;
  }
  get height() {
    return this.spLay.height;
  }
  get rotation() {
    return this.spLay.angle;
  }
  set rotation(t) {
    this.spLay.angle = t;
  }
  get scale_x() {
    return this.spLay.scale.x;
  }
  set scale_x(t) {
    this.spLay.scale.x = t;
  }
  get scale_y() {
    return this.spLay.scale.y;
  }
  set scale_y(t) {
    this.spLay.scale.y = t;
  }
  get width() {
    return this.spLay.width;
  }
  get x() {
    return this.spLay.x;
  }
  set x(t) {
    this.procSetX(t), this.spLay.x = t;
  }
  procSetX(t) {
  }
  // set を override できないので
  get y() {
    return this.spLay.y;
  }
  set y(t) {
    this.procSetY(t), this.spLay.y = t;
  }
  procSetY(t) {
  }
  // set を override できないので
  destroy() {
  }
  lay(t) {
    return "alpha" in t && (this.spLay.alpha = j(t, "alpha", 1)), hn.setBlendmode(this.spLay, t), ("pivot_x" in t || "pivot_y" in t) && this.spLay.pivot.set(
      j(t, "pivot_x", this.spLay.pivot.x),
      j(t, "pivot_y", this.spLay.pivot.y)
    ), "rotation" in t && (this.spLay.angle = j(t, "rotation", 0)), ("scale_x" in t || "scale_y" in t) && this.spLay.scale.set(
      j(t, "scale_x", this.spLay.scale.x),
      j(t, "scale_y", this.spLay.scale.y)
    ), "visible" in t && (this.spLay.visible = K(t, "visible", !0)), !1;
  }
  static setBlendmodeParentOnly(t, e) {
    const { blendmode: i } = e;
    if (!i)
      return;
    const n = hn.getBlendmodeNum(i);
    t instanceof ge && (t.blendMode = n);
  }
  static setBlendmode(t, e) {
    const { blendmode: i } = e;
    if (!i)
      return;
    const n = hn.getBlendmodeNum(i);
    t instanceof ge && (t.blendMode = n);
    for (const s of t.children)
      s instanceof ge && (s.blendMode = n);
  }
  static getBlendmodeNum(t) {
    if (!t)
      return ot.NORMAL;
    const e = h(hn, jd)[t];
    if (e !== void 0)
      return e;
    throw `${t} はサポートされない blendmode です`;
  }
  static getNum2Blendmode(t) {
    return h(hn, Hd)[t] ?? "normal";
  }
  // アニメ・動画があるか
  get containMovement() {
    return !1;
  }
  renderStart() {
  }
  renderEnd() {
  }
  clearLay(t) {
    this.spLay.alpha = 1, this.spLay.blendMode = ot.NORMAL, this.spLay.pivot.set(0, 0), this.spLay.angle = 0, this.spLay.scale.set(1, 1), K(t, "filter", !1) && (this.spLay.filters = []);
  }
  copy(t, e) {
    const i = this.name_;
    this.playback(t.record(), e), this.name = i;
  }
  record() {
    return {
      name: this.name_,
      idx: this.spLay.parent.getChildIndex(this.spLay),
      alpha: this.spLay.alpha,
      blendMode: this.spLay.blendMode,
      rotation: this.spLay.angle,
      scale_x: this.spLay.scale.x,
      scale_y: this.spLay.scale.y,
      pivot_x: this.spLay.pivot.x,
      pivot_y: this.spLay.pivot.y,
      x: this.spLay.x,
      y: this.spLay.y,
      visible: this.spLay.visible
    };
  }
  playback(t, e) {
    this.name = t.name, this.clearLay({ filter: "true" }), this.spLay.alpha = t.alpha, this.spLay.blendMode = t.blendMode, this.spLay.angle = t.rotation, this.spLay.scale.set(t.scale_x, t.scale_y), this.spLay.pivot.set(t.pivot_x, t.pivot_y), this.spLay.position.set(t.x, t.y), this.spLay.visible = t.visible;
  }
  snapshot(t, e) {
    t.render(this.spLay, { clear: !1 }), e();
  }
  snapshot_end() {
  }
  makeDesignCast(t) {
  }
  makeDesignCastChildren(t) {
  }
  showDesignCast() {
  }
  showDesignCastChildren() {
  }
  cvsResize() {
  }
  cvsResizeChildren() {
  }
  dump() {
    return ` "idx":${this.spLay.parent.getChildIndex(this.spLay)}, "visible":"${this.spLay.visible}", "left":${this.spLay.x}, "top":${this.spLay.y}, "alpha":${this.spLay.alpha}, "rotation":${this.spLay.angle}, "name":"${this.name_}", "scale_x":${this.spLay.scale.x}, "scale_y":${this.spLay.scale.y}`;
  }
  static setXY(t, e, i, n = !1, s = !1) {
    if (e.pos) {
      hn.setXYByPos(t, e.pos, i);
      return;
    }
    const o = t.getBounds(), a = i.scale.x < 0 ? -i.scale.x : i.scale.x, l = a === 1 ? o.width : o.width * a, u = i.scale.y < 0 ? -i.scale.y : i.scale.y, c = u === 1 ? o.height : o.height * u;
    let d = i.x;
    "left" in e ? (d = j(e, "left", 0), d > -1 && d < 1 && (d *= L.stageW)) : "center" in e ? (d = j(e, "center", 0), d > -1 && d < 1 && (d *= L.stageW), d = d - (s ? l / 3 : l) / 2) : "right" in e ? (d = j(e, "right", 0), d > -1 && d < 1 && (d *= L.stageW), d = d - (s ? l / 3 : l)) : "s_right" in e && (d = j(e, "s_right", 0), d > -1 && d < 1 && (d *= L.stageW), d = L.stageW - d - (s ? l / 3 : l)), i.x = Ue(i.scale.x < 0 ? d + (s ? l / 3 : l) : d);
    let f = i.y;
    "top" in e ? (f = j(e, "top", 0), f > -1 && f < 1 && (f *= L.stageH)) : "middle" in e ? (f = j(e, "middle", 0), f > -1 && f < 1 && (f *= L.stageH), f = f - c / 2) : "bottom" in e ? (f = j(e, "bottom", 0), f > -1 && f < 1 && (f *= L.stageH), f = f - c) : "s_bottom" in e && (f = j(e, "s_bottom", 0), f > -1 && f < 1 && (f *= L.stageH), f = L.stageH - f - c), i.y = Ue(i.scale.y < 0 ? f + c : f), n && !("left" in e) && !("center" in e) && !("right" in e) && !("s_right" in e) && !("top" in e) && !("middle" in e) && !("bottom" in e) && !("s_bottom" in e) && hn.setXYByPos(t, "c", i);
  }
  static setXYByPos(t, e, i) {
    if (e === "stay")
      return;
    if (t === void 0)
      throw "setXYByPos base === undefined";
    if (i === void 0)
      throw "setXYByPos result === undefined";
    const n = t.getBounds(), s = i.scale.x < 0 ? -i.scale.x : i.scale.x, o = s === 1 ? n.width : n.width * s, a = i.scale.y < 0 ? -i.scale.y : i.scale.y, l = a === 1 ? n.height : n.height * a;
    let u = 0;
    !e || e === "c" ? u = L.stageW * 0.5 : e === "r" ? u = L.stageW - o * 0.5 : e === "l" ? u = o * 0.5 : u = Ue(e), i.x = Ue(u - o * 0.5), i.y = L.stageH - l, i.scale.x < 0 && (i.x += o), i.scale.y < 0 && (i.y += l);
  }
  static setXYCenter(t) {
    const e = t.getBounds();
    t.x = (L.stageW - e.width) * 0.5, t.y = (L.stageH - e.height) * 0.5;
  }
};
let qe = hn;
jd = new WeakMap(), Hd = new WeakMap(), _(qe, jd, {
  normal: ot.NORMAL,
  add: ot.ADD,
  multiply: ot.MULTIPLY,
  screen: ot.SCREEN
  /*
  		'overlay'		: BLEND_MODES.OVERLAY,
  		'darken'		: BLEND_MODES.DARKEN,
  		'lighten'		: BLEND_MODES.LIGHTEN,
  		'color_dodge'	: BLEND_MODES.COLOR_DODGE,
  		'color_burn'	: BLEND_MODES.COLOR_BURN,
  		'hard_light'	: BLEND_MODES.HARD_LIGHT,
  		'soft_light'	: BLEND_MODES.SOFT_LIGHT,
  		'difference'	: BLEND_MODES.DIFFERENCE,
  		'exclusion'		: BLEND_MODES.EXCLUSION,
  		'hue'			: BLEND_MODES.HUE,
  		'saturation'	: BLEND_MODES.SATURATION,
  		'color'			: BLEND_MODES.COLOR,
  		'luminosity'	: BLEND_MODES.LUMINOSITY,
  
  		'normal_npm'	: BLEND_MODES.NORMAL_NPM,
  		'add_npm'		: BLEND_MODES.ADD_NPM,
  		'screen_npm'	: BLEND_MODES.SCREEN_NPM,
  		'none'			: BLEND_MODES.NONE,
  		'src_in'		: BLEND_MODES.SRC_IN,
  		'src_out'		: BLEND_MODES.SRC_OUT,
  		'src_atop'		: BLEND_MODES.SRC_ATOP,
  		'dst_over'		: BLEND_MODES.DST_OVER,
  		'dst_in'		: BLEND_MODES.DST_IN,
  		'dst_out'		: BLEND_MODES.DST_OUT,
  		'dst_atop'		: BLEND_MODES.DST_ATOP,
  		'subtract'		: BLEND_MODES.SUBTRACT,
  		'src_over'		: BLEND_MODES.SRC_OVER,
  		'erase'			: BLEND_MODES.ERASE,
  		'xor'			: BLEND_MODES.XOR,
  */
}), _(qe, Hd, {
  0: "normal",
  1: "add",
  2: "multiply",
  3: "screen"
});
var Cr, Da, Fa, Ba, Ua, ou, Vs, Xs, au, um;
const nt = class {
  constructor(t, e = !1) {
    // divでmovを更新
    //	cvsResize() {this.#resizeDiv(); this.mov?.updateTarget();}	// divでmovを更新
    _(this, au);
    D(this, "hArg", {});
    D(this, "id_tag", "");
    D(this, "hDesignArg", {
      rotation: 0,
      pivot_x: 0,
      pivot_y: 0,
      left: 0,
      center: 0,
      right: 0,
      s_right: 0,
      top: 0,
      middle: 0,
      bottom: 0,
      s_bottom: 0,
      width: 0,
      height: 0
    });
    D(this, "child");
    D(this, "parent");
    D(this, "fncLay", () => {
    });
    //	protected	mov		: Moveable | undefined		= undefined;
    D(this, "div");
    D(this, "lx", 0);
    // これ以後の this変数スケールは SKYNovel スクリプト値
    D(this, "ly", 0);
    D(this, "rect", pt.EMPTY);
    // cvsResizeBaseやhint座標など計算用
    D(this, "pivot", new te(0, 0));
    D(this, "scale", new te(1, 1));
    D(this, "rotation", 0);
    D(this, "oldFn", () => "");
    D(this, "rotatable", !0);
    this.bg_col = t, this.isLay = e;
  }
  static init(t, e, i, n, s, o, a) {
    nt.sys = e, g(nt, Da, i), nt.prpPrs = n, g(nt, Fa, s), g(nt, Ba, o), nt.hPages = a, ui.cvs.insertAdjacentHTML("beforebegin", `<div id="${h(nt, Ua)}" style="width: ${L.stageW * e.cvsScale}px; height: ${L.stageH * e.cvsScale}px; background: rgba(0,0,0,0); position: absolute; touch-action: none; user-select: none; display: none;"></div>`), g(nt, Cr, document.getElementById(h(nt, Ua))), nt.divHint.classList.add("sn_design_hint"), t.view.parentElement.appendChild(nt.divHint), ba(`
.sn_design_cast {
	position: absolute; touch-action: none; user-select: none;
	opacity: 0.6; border-radius: 8px;
}

.sn_design_cast.drag_border {
	line-height: 1.8;
	border: dashed 5px #333;
}

.sn_design_hint {
	position: absolute;
	left: 0;
	top: 0;
	padding: 5px;
	border-radius: 5px;
	background: #333;
	z-index: 10;
	color: #fff;
	font-weight: bold;
	font-size: 12px;
	display: none;
}
`);
  }
  static setHint(t, e, i, n) {
    nt.divHint.innerHTML = t;
    const s = window.getComputedStyle(nt.divHint), o = parseFloat(s.width), a = parseFloat(s.height);
    nt.divHint.style.cssText = `display: block; left: ${Math.max(10, n.lx + e - o)}px;
		top: ${Math.max(10, n.ly + i - a - 10)}px;`;
  }
  static cvsResizeDesign() {
    const t = h(nt, Cr).style;
    t.width = `${L.stageW * nt.sys.cvsScale}px`, t.height = `${L.stageH * nt.sys.cvsScale}px`;
  }
  destroy() {
    this.div = void 0;
  }
  gethArg() {
    return this.hArg;
  }
  sethArg(t) {
    if (!this.includeDesignArg(t))
      return;
    this.id_tag || (this.id_tag = t[":id_tag"] ?? ""), this.hArg = t;
    const e = t[":id_dc"] ?? this.id_tag;
    h(nt, Vs)[e] = this;
  }
  includeDesignArg(t) {
    return Object.keys(t).some((e) => e in this.hDesignArg);
  }
  getRect() {
    return pt.EMPTY;
  }
  cnvPosArg(t, e) {
    return {};
  }
  cnvSizeArg(t, e) {
    return {};
  }
  setPos(t, e) {
  }
  setSize(t, e) {
  }
  setOther(t) {
  }
  adopt(t) {
    this.child = t, t.parent = this;
  }
  static enterMode() {
    nt.leaveMode(), h(nt, Cr).style.display = "inline", g(nt, ou, 0), g(nt, Vs, {});
  }
  static allHide() {
    h(nt, Xs).forEach((t) => t.visible = !1);
  }
  set visible(t) {
    this.div && (this.div.style.display = t ? "inline" : "none");
  }
  static leaveMode() {
    h(nt, Cr).textContent = "", h(nt, Cr).style.display = "none", h(nt, Xs).forEach((t) => t.destroy()), g(nt, Xs, []);
  }
  cvsResize() {
    x(this, au, um).call(this);
  }
  onDragStart() {
  }
  make() {
    const t = this.hArg[":id_dc"] ?? this.id_tag;
    h(nt, Vs)[t] = this;
    const e = this.div = document.createElement("div");
    e.id = h(nt, Ua) + "_" + ++Te(nt, ou)._, e.classList.add("sn_design_cast"), e.dataset.id_dc = t, e.style.backgroundColor = `${this.bg_col}`, e.style.display = "none", this.rect = this.getRect(), x(this, au, um).call(this), (this.parent ? document.querySelector(
      `[data-id_dc="${this.parent.id_tag}"]`
      // 親なので
    ) ?? h(nt, Cr) : h(nt, Cr)).appendChild(e), h(nt, Xs).push(this), e.addEventListener("dragenter", () => e.classList.add("drag_border")), e.addEventListener("dragover", (i) => {
      i.stopPropagation(), i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = "copy");
    }), e.addEventListener("dragleave", () => e.classList.remove("drag_border")), e.addEventListener("drop", (i) => {
      i.stopPropagation(), i.preventDefault(), e.classList.remove("drag_border");
      const n = i.dataTransfer;
      if (!n || n.files.length === 0)
        return;
      const s = n.files[0], o = {
        ":id_tag": this.id_tag,
        fn: vl(s.name),
        ext: Vf(s.name),
        url: "",
        buf: new ArrayBuffer(0),
        old_fn: this.oldFn(),
        old_url: h(nt, Ba).searchPath(this.oldFn(), Xe.SP_GSM)
      };
      s.arrayBuffer().then((a) => {
        o.buf = a;
        try {
          o.url = h(nt, Da).cnvPath4Dbg(
            h(nt, Ba).searchPath(s.name, Xe.SP_GSM)
          );
        } catch {
        }
        nt.sys.send2Dbg("_dropFile", o);
      }).catch((a) => console.error("drop2dc %o", a));
    }), e.addEventListener("dblclick", (i) => {
      i.preventDefault(), nt.sys.send2Dbg("_focusScript", this.hArg);
    });
  }
  /*
  	protected	procDragHint(e: OnDrag, left: number, top: number) {
  		const [dx, dy] = e.beforeTranslate;
  		DesignCast.setHint(
  			`(${int(this.rect.x +dx /DesignCast.sys.cvsScale)
  				}, ${int(this.rect.y +dy /DesignCast.sys.cvsScale)})`,
  			left, top, this);
  	}
  	protected	procResizeHint(e: OnResize, left: number, top: number) {
  		DesignCast.setHint(
  			`(${int(e.drag.left)}, ${int(e.drag.top)})<br/>${
  				int(this.rect.width)} x ${int(this.rect.height)}`,
  			left, top, this);
  	}
  */
  static replaceToken(t) {
    var c, d, f, v, m, p, y, b;
    const i = t[":id_tag"], n = h(nt, Vs)[i];
    if (!document.querySelector(`div[data-id_dc='${i}']`) || !n)
      return;
    const o = t[":token"];
    h(nt, Da).replace(t[":idx_tkn"], o);
    const [a, l] = vf(o);
    n.child && (n.child.hArg[":token"] = n.hArg[":token"]), h(nt, Fa).parse(l);
    const u = h(nt, Fa).hPrm;
    if ("pivot_x" in u || "pivot_y" in u) {
      const w = Number(nt.prpPrs.getValAmpersand(u.pivot_x.val)), E = Number(nt.prpPrs.getValAmpersand(u.pivot_y.val));
      (isNaN(w) || isNaN(E)) && wt.myTrace(`pivot_xかpivot_yが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${o}`, "F"), n.pivot.set(w, E);
    }
    if ("left" in u || "top" in u || "x" in u || "y" in u) {
      const w = Ue(nt.prpPrs.getValAmpersand(((c = u.left) == null ? void 0 : c.val) ?? ((d = u.x) == null ? void 0 : d.val) ?? "0")), E = Ue(nt.prpPrs.getValAmpersand(((f = u.top) == null ? void 0 : f.val) ?? ((v = u.y) == null ? void 0 : v.val) ?? "0"));
      (isNaN(w) || isNaN(E)) && wt.myTrace(`widthかheightが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${o}`, "F"), n.rect.x = w - n.pivot.x, n.rect.y = E - n.pivot.y, n.setPos(w, E);
    }
    if ("width" in u || "height" in u) {
      const w = Ue(nt.prpPrs.getValAmpersand(((m = u.width) == null ? void 0 : m.val) ?? "0")), E = Ue(nt.prpPrs.getValAmpersand(((p = u.height) == null ? void 0 : p.val) ?? "0"));
      (isNaN(w) || isNaN(E)) && wt.myTrace(`widthかheightが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${o}`, "F"), n.rect.width = w, n.rect.height = E, n.setSize(w, E);
    }
    if ("scale_x" in u || "scale_y" in u) {
      const w = Number(nt.prpPrs.getValAmpersand(((y = u.scale_x) == null ? void 0 : y.val) ?? "0")), E = Number(nt.prpPrs.getValAmpersand(((b = u.scale_y) == null ? void 0 : b.val) ?? "0"));
      (isNaN(w) || isNaN(E)) && wt.myTrace(`scale_xかscale_yが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${o}`, "F"), n.scale.set(w, E);
    }
    if ("rotation" in u) {
      const w = Number(nt.prpPrs.getValAmpersand(u.rotation.val));
      isNaN(w) && wt.myTrace(`rotationが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${o}`, "F"), n.rotation = w;
    }
    n.setOther(u), n.cvsResize();
  }
};
let Nt = nt;
Cr = new WeakMap(), Da = new WeakMap(), Fa = new WeakMap(), Ba = new WeakMap(), Ua = new WeakMap(), ou = new WeakMap(), Vs = new WeakMap(), Xs = new WeakMap(), au = new WeakSet(), um = function() {
  this.fncLay(), this.div && Object.assign(this.div.style, {
    left: `${this.lx + this.rect.x * nt.sys.cvsScale}px`,
    top: `${this.ly + this.rect.y * nt.sys.cvsScale}px`,
    width: `${this.rect.width * nt.sys.cvsScale}px`,
    height: `${this.rect.height * nt.sys.cvsScale}px`,
    transformOrigin: `${this.pivot.x * nt.sys.cvsScale}px ${this.pivot.y * nt.sys.cvsScale}px`,
    transform: `scale(${this.scale.x}, ${this.scale.y}) rotate(${this.rotation}deg)`
  });
}, _(Nt, Cr, void 0), D(Nt, "sys"), _(Nt, Da, void 0), D(Nt, "prpPrs"), _(Nt, Fa, void 0), _(Nt, Ba, void 0), D(Nt, "hPages"), D(Nt, "divHint", document.createElement("div")), _(Nt, Ua, "DesignMode"), _(Nt, ou, 0), _(Nt, Vs, {}), _(Nt, Xs, []);
var qn;
class YC extends Nt {
  constructor(e, i) {
    super("#29e", !0);
    _(this, qn, void 0);
    D(this, "oldFn", () => this.hArg.fn ?? "");
    this.spLay = e, this.gl = i;
  }
  setSp(e) {
    g(this, qn, e);
  }
  getRect() {
    var e, i;
    return new pt(this.spLay.x, this.spLay.y, ((e = h(this, qn)) == null ? void 0 : e.width) ?? 0, ((i = h(this, qn)) == null ? void 0 : i.height) ?? 0);
  }
  cnvPosArg(e, i) {
    return { left: e, top: i };
  }
  cnvSizeArg(e, i) {
    return { width: e, height: i };
  }
  setPos(e, i) {
    this.spLay.x = e, this.spLay.y = i;
  }
  setSize(e, i) {
    h(this, qn).width = e, h(this, qn).height = i;
  }
  setOther(e) {
    if ("fn" in e) {
      const i = Nt.prpPrs.getValAmpersand(e.fn.val);
      this.gl.lay({ fn: i });
    }
    this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;
  }
}
qn = new WeakMap();
class qC extends Nt {
  constructor(e, i) {
    super("#29e", !0);
    D(this, "hDesignArg", {
      rotation: 0,
      pivot_x: 0,
      pivot_y: 0,
      left: 0,
      center: 0,
      right: 0,
      s_right: 0,
      top: 0,
      middle: 0,
      bottom: 0,
      s_bottom: 0,
      width: 0,
      height: 0,
      pl: 0,
      pr: 0,
      pt: 0,
      pb: 0
    });
    this.spLay = e, this.ts = i;
  }
  getRect() {
    const e = this.ts.infTL;
    return new pt(this.spLay.x, this.spLay.y, e.$width, e.$height);
  }
  cnvPosArg(e, i) {
    return { left: e, top: i };
  }
  cnvSizeArg(e, i) {
    return { width: e, height: i };
  }
  setPos(e, i) {
    this.spLay.position.set(e, i), this.ts.lay(this.cnvPosArg(e, i));
  }
  setSize(e, i) {
    this.ts.lay(this.cnvSizeArg(e, i));
  }
  setOther(e) {
    var i;
    (i = this.child) == null || i.setOther(e), this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;
  }
}
class ZC extends Nt {
  constructor(e) {
    super("#9e2");
    D(this, "rotatable", !1);
    this.ts = e;
  }
  getRect() {
    const e = this.ts.infTL;
    return new pt(
      e.pad_left,
      e.pad_top,
      e.$width - e.pad_left - e.pad_right,
      e.$height - e.pad_top - e.pad_bottom
    );
  }
  cnvPosArg(e, i) {
    return { pl: e, pt: i };
  }
  cnvSizeArg(e, i) {
    const n = this.ts.infTL;
    return {
      pr: n.$width - n.pad_left - e,
      pb: n.$height - n.pad_top - i
    };
  }
  setPos(e, i) {
    this.ts.lay(this.cnvPosArg(e, i));
  }
  setSize(e, i) {
    this.ts.lay({ ...this.cnvSizeArg(e, i), ":redraw": !0 });
  }
  setOther(e) {
    var n, s, o, a;
    const i = this.ts.infTL;
    if (("pl" in e || "pt" in e) && (this.setPos(
      this.rect.x = parseFloat(Nt.prpPrs.getValAmpersand(
        ((n = e.pl) == null ? void 0 : n.val) ?? `${i.pad_left}`
      )),
      this.rect.y = parseFloat(Nt.prpPrs.getValAmpersand(
        ((s = e.pt) == null ? void 0 : s.val) ?? `${i.pad_top}`
      ))
    ), this.cvsResize()), "pr" in e || "pb" in e) {
      this.ts.lay({
        pr: parseFloat(Nt.prpPrs.getValAmpersand(
          ((o = e.pr) == null ? void 0 : o.val) ?? `${i.pad_right}`
        )),
        pb: parseFloat(Nt.prpPrs.getValAmpersand(
          ((a = e.pb) == null ? void 0 : a.val) ?? `${i.pad_bottom}`
        ))
      });
      const l = this.getRect();
      this.setSize(
        this.rect.width = l.width,
        this.rect.height = l.height
      ), this.cvsResize();
    }
  }
  /*
  	protected	override procDragHint(e: OnDrag, left: number, top: number) {
  		const [dx, dy] = e.beforeTranslate;
  		this.#procHint(left, top, dx, dy);
  	}
  	protected	override procResizeHint(e: OnResize, left: number, top: number) {
  		const [dx, dy] = e.drag.beforeTranslate;
  		this.#procHint(left, top, dx, dy);
  	}
  	#procHint(left: number, top: number, dx: number, dy: number) {
  		const x = this.rect.x, y = this.rect.y;
  		const w = this.rect.width, h = this.rect.height;
  		const it = this.ts.infTL;
  		const pl = int(x +dx /DesignCast.sys.cvsScale);
  		const pt = int(y +dy /DesignCast.sys.cvsScale);
  		const pr = int(it.$width -pl -w);
  		const pb = int(it.$height -pt -h);
  		const sp = (re: number)=> '&nbsp;'.repeat(re);
  		DesignCast.setHint(
  			sp(5+5 +1) +`上幅=${pt}<br/>
  			左幅=${pl + sp(1+ 3+5 +1)}右幅=${pr}<br/>`+
  			sp(5) +`内側 ${int(w)} x ${int(h)}<br/>`+
  			sp(5+5) +`下幅=${pb}`,
  			left, top, this);
  	}
  */
}
class px extends Nt {
  constructor(t, e) {
    super("#e92"), this.btn = t, this.hArg = e, this.pivot.x = j(e, "pivot_x", this.pivot.x), this.pivot.y = j(e, "pivot_y", this.pivot.y), this.scale.x = j(e, "scale_x", this.scale.x), this.scale.y = j(e, "scale_y", this.scale.y), this.rotation = j(e, "rotation", this.rotation), this.sethArg(e);
  }
  sethArg(t) {
    super.sethArg(t);
    const e = this.hArg.layer ?? "";
    this.fncLay = !this.parent && !this.child && e ? () => {
      const i = Nt.hPages[e].fore;
      this.lx = i.x * Nt.sys.cvsScale, this.ly = i.y * Nt.sys.cvsScale;
    } : () => {
    };
  }
  cnvPosArg(t, e) {
    return { left: t, top: e };
  }
  cnvSizeArg(t, e) {
    return { width: t, height: e };
  }
  setPos(t, e) {
    this.btn.x = t, this.btn.y = e;
  }
  setOther(t) {
    this.btn.pivot.copyFrom(this.pivot), this.btn.scale.copyFrom(this.scale), this.btn.angle = this.rotation;
  }
  onDragStart() {
  }
}
class KC extends px {
  constructor(e, i, n) {
    super(e, i);
    D(this, "oldFn", () => this.hArg.b_pic ?? "");
    this.txt = n, K(i, "design", !0) || (this.setPos = () => {
    }, this.setSize = () => {
    });
  }
  getRect() {
    return new pt(this.btn.x, this.btn.y, this.txt.width, this.txt.height);
  }
  setSize(e, i) {
    this.txt.width = e, this.txt.height = i;
  }
  setOther(e) {
    if (super.setOther(e), "b_pic" in e) {
      const i = Nt.prpPrs.getValAmpersand(e.b_pic.val ?? "");
      this.btn.update_b_pic(i, this.txt);
    }
  }
}
var cn;
class JC extends px {
  constructor(e, i) {
    super(e, i);
    _(this, cn, void 0);
    D(this, "oldFn", () => this.hArg.pic ?? "");
  }
  setSp(e) {
    g(this, cn, e);
  }
  getRect() {
    return new pt(this.btn.x, this.btn.y, h(this, cn).width, h(this, cn).height);
  }
  setSize(e, i) {
    h(this, cn).width = e, h(this, cn).height = i;
  }
  setOther(e) {
    if (super.setOther(e), "pic" in e) {
      const i = Nt.prpPrs.getValAmpersand(e.pic.val);
      this.btn.update_pic(i, h(this, cn));
    }
  }
}
cn = new WeakMap();
var $d, Zn, fn, Ws, Ys, Mr, Ga, qs, hu, ja, Rr, dn, pn, Kn, lu, uu, cu, zd, vx, Vd, yx, fu, cm, Xd, mx, Ha, If, $a, rr, za, Wd, Zs, du;
const rt = class extends qe {
  constructor() {
    super();
    _(this, Rr, new YC(this.spLay, this));
    _(this, dn, "");
    _(this, pn, "");
    _(this, Kn, "");
    D(this, "lay", (e) => this.laySub(e, (i) => {
      i && h(rt, fn).resume();
    }));
    _(this, lu, 0);
    _(this, uu, 0);
    _(this, $a, void 0);
    _(this, rr, void 0);
    _(this, za, () => {
    });
    D(this, "record", () => ({
      ...super.record(),
      sBkFn: h(this, pn),
      sBkFace: h(this, Kn),
      idc_hArg: h(this, Rr).gethArg()
    }));
    //showDesignCastChildren() {}
    D(this, "dump", () => super.dump() + `, "pic":"${h(this, dn)}"`);
    L.isDbg && (this.setSp = (e) => h(this, Rr).setSp(e), this.cvsResize = () => {
      super.cvsResize(), h(this, Rr).cvsResize();
    });
  }
  static init(e, i, n, s, o, a) {
    g(rt, fn, e), g(rt, Ws, i), g(rt, Ys, n), g(rt, Mr, s), g(rt, Ga, a);
    const l = () => {
      const u = h(rt, qs) * h(rt, hu);
      for (const c of Object.values(rt.hFn2VElm))
        c.volume = u;
    };
    o.setNoticeChgVolume(
      (u) => {
        g(rt, qs, u), l();
      },
      (u) => {
        g(rt, hu, u), l();
      }
    ), h(rt, Mr).crypto && g(rt, cu, x(rt, Vd, yx));
  }
  static setEvtMng(e) {
    g(rt, ja, e);
  }
  static destroy() {
    h(rt, $d).clear(), g(rt, Zn, {}), rt.hFn2ResAniSpr = {}, rt.hFn2VElm = {};
  }
  setSp(e) {
  }
  laySub(e, i) {
    var l;
    x(l = rt, Ha, If).call(l, h(this, pn));
    const { fn: n, face: s = "" } = e;
    if (h(this, Rr).sethArg(e), !n)
      return super.lay(e), this.spLay.children.length > 0 && this.setPos(e), g(this, pn, ""), g(this, dn, g(this, Kn, s)), i(!1), !1;
    const o = "fn" in e, a = "face" in e;
    return this.clearLay({ filter: "true" }), o && g(this, pn, n), a && g(this, Kn, s), super.lay(e), e.dx = 0, e.dy = 0, rt.csv2Sprites(
      g(this, dn, n + (s ? "," + s : "")),
      this.spLay,
      (u) => {
        ("width" in e || "height" in e) && (u.width = j(e, "width", 0), u.height = j(e, "height", 0)), g(this, lu, u.width), g(this, uu, u.height), qe.setXY(u, e, this.spLay, !0), this.setSp(u);
      },
      (u) => {
        qe.setBlendmodeParentOnly(this.spLay, e), i(u);
      }
    );
  }
  get width() {
    return h(this, lu);
  }
  get height() {
    return h(this, uu);
  }
  //	static #ldrHFn: {[name: string]: 1} = {};
  static csv2Sprites(e, i, n, s = () => {
  }) {
    let o = !1;
    if (e.slice(0, 5) === "data:") {
      const c = () => {
        const d = ge.from(e);
        i == null || i.addChild(d), n(d), s(o);
      };
      return e in li ? c() : (o = !0, new Oi().add(e, e).load(c)), o;
    }
    const a = [], l = new Oi();
    e.split(",").forEach((c, d) => {
      if (!c)
        throw "face属性に空要素が含まれます";
      const { dx: f, dy: v, blendmode: m, fn: p } = h(rt, Zn)[c] || {
        fn: c,
        dx: 0,
        dy: 0,
        blendmode: ot.NORMAL
      }, y = d === 0 ? n : (E) => {
        E.x = f, E.y = v, E.blendMode = m;
      };
      if (a.push({ fn: p, fnc: y }), p in rt.hFn2ResAniSpr || p in li || p in Oi.shared.resources)
        return;
      o = !0;
      const b = h(rt, Ws).searchPath(p, Xe.SP_GSM), w = h(this, Mr).crypto ? { xhrType: b.slice(-5) === ".json" ? bt.XHR_RESPONSE_TYPE.TEXT : bt.XHR_RESPONSE_TYPE.BUFFER } : {};
      l.add({ ...w, name: p, url: b });
    });
    const u = (c) => {
      var d;
      for (const { fn: f, fnc: v } of a) {
        const m = x(d = rt, Xd, mx).call(d, f, c);
        m.name = f, i == null || i.addChild(m), v(m);
      }
      s(o);
    };
    return o ? l.use((c, d) => {
      h(this, Mr).dec(c.extension, c.data).then((f) => {
        var v;
        return h(v = rt, cu).call(v, f, c, () => d == null ? void 0 : d());
      }).catch((f) => h(this, fn).errScript(`Graphic ロード失敗です fn:${c.name} ${f}`, !1));
    }).load((c, d) => u(d)) : u({}), o;
  }
  static wv(e) {
    var o;
    const { fn: i } = e;
    if (!i)
      throw "fnは必須です";
    const n = rt.hFn2VElm[i];
    if (!n || n.loop)
      return !1;
    if (h(this, Ga).getVal("tmp:sn.skip.enabled") || h(this, ja).isSkippingByKeyDown() || n.ended)
      return x(o = rt, Ha, If).call(o, i), !1;
    const s = () => {
      var a;
      x(a = rt, Ha, If).call(a, i), h(this, fn).resume();
    };
    return n.addEventListener("ended", s, { once: !0, passive: !0 }), h(rt, ja).waitEvent(
      () => {
        n.removeEventListener("ended", s), s();
      },
      K(e, "canskip", !0),
      K(e, "global", !1)
    );
  }
  renderStart() {
    g(this, $a, Wi.create({
      width: L.stageW,
      height: L.stageH
    })), g(this, rr, new ge(h(this, $a))), h(this, rr).visible = !1, this.spLay.addChildAt(h(this, rr), 0), h(this, rr).position.set(-this.spLay.x, -this.spLay.y);
    let e = () => {
      const i = this.spLay.alpha;
      this.spLay.alpha = 1;
      for (const n of this.spLay.children)
        n.visible = !0;
      h(this, rr).visible = !1, h(rt, Ys).renderer.render(this.spLay, { renderTexture: h(this, $a) }), this.spLay.alpha = i;
      for (const n of this.spLay.children)
        n.visible = !1;
    };
    if (!this.containMovement) {
      let i = e;
      e = () => {
        e = () => {
        }, i();
      };
    }
    g(this, za, () => {
      e(), h(this, rr).visible = !0;
    }), h(rt, Ys).ticker.add(h(this, za));
  }
  renderEnd() {
    h(rt, Ys).ticker.remove(h(this, za)), this.spLay.removeChild(h(this, rr));
    for (const e of this.spLay.children)
      e.visible = !0;
    h(this, rr).destroy(!0);
  }
  // https://regex101.com/r/ZUnoFq/1
  static loadPic2Img(e, i, n) {
    const s = e.replace(h(rt, Wd), ""), o = e === s ? "" : e.slice(s.length), a = h(this, du)[e];
    if (a) {
      i.src = a;
      return;
    }
    const l = h(this, Zs)[e];
    if (l) {
      l.push(i);
      return;
    }
    h(this, Zs)[e] = [i];
    const u = h(rt, Ws).searchPath(s, Xe.SP_GSM), c = new Oi().add({ name: e, url: u, xhrType: bt.XHR_RESPONSE_TYPE.BUFFER });
    h(rt, Mr).crypto && Vf(u) === "bin" && c.use((d, f) => {
      h(rt, Mr).dec(d.extension, d.data).then((v) => {
        if (d.extension !== "bin") {
          f == null || f();
          return;
        }
        d.data = v, v instanceof HTMLImageElement && (d.type = bt.TYPE.IMAGE), f == null || f();
      }).catch((v) => h(rt, fn).errScript(`GrpLayer loadPic ロード失敗です fn:${d.name} ${v}`, !1));
    }), c.load((d, f) => {
      for (const [v, { data: { src: m } }] of Object.entries(f)) {
        const p = h(this, du)[v] = m + (m.slice(0, 5) === "blob:" ? "" : o);
        for (const y of h(this, Zs)[v])
          y.src = p, n && (y.onload = () => n(y));
        delete h(this, Zs)[v];
      }
    });
  }
  setPos(e) {
    qe.setXY(
      this.spLay.children.length === 0 ? this.spLay : this.spLay.children[0],
      e,
      this.spLay,
      !0
    );
  }
  static add_face(e) {
    const { name: i } = e;
    if (!i)
      throw "nameは必須です";
    if (i in h(rt, Zn))
      throw "一つのname（" + i + "）に対して同じ画像を複数割り当てられません";
    const { fn: n = i } = e;
    return h(rt, Zn)[i] = {
      fn: n,
      dx: j(e, "dx", 0),
      dy: j(e, "dy", 0),
      blendmode: qe.getBlendmodeNum(e.blendmode || "")
    }, !1;
  }
  static clearFace2Name() {
    g(rt, Zn, {});
  }
  // アニメ・動画を含むか
  get containMovement() {
    if (h(this, dn) === "")
      return !1;
    const e = this.spLay.children;
    return h(this, dn).split(",").some(
      (i, n) => e[n] instanceof Jg || rt.hFn2VElm[i]
    );
  }
  clearLay(e) {
    super.clearLay(e);
    for (const i of this.spLay.removeChildren())
      i.destroy();
    g(this, pn, ""), g(this, Kn, ""), g(this, dn, "");
  }
  playback(e, i) {
    if (super.playback(e, i), e.sBkFn === "" && e.sBkFace === "") {
      g(this, pn, e.sBkFn), g(this, Kn, e.sBkFace), h(this, Rr).sethArg(e.idc_hArg);
      return;
    }
    i.push(new Promise((n) => this.laySub(
      { fn: e.sBkFn, face: e.sBkFace, left: e.x, top: e.y, alpha: e.alpha, blendmode: qe.getNum2Blendmode(e.blendMode), rotation: e.rotation, scale_x: e.scale_x, scale_y: e.scale_y },
      (s) => {
        this.spLay.position.set(e.x, e.y), n();
      }
      // Layer.setXY()の後に再度移動
    )));
  }
  makeDesignCast(e) {
    this.spLay.visible && e(h(this, Rr));
  }
  //makeDesignCastChildren(_gdc: IMakeDesignCast) {}
  cvsResize() {
    super.cvsResize();
  }
  showDesignCast() {
    h(this, Rr).visible = !0;
  }
};
let Pt = rt;
$d = new WeakMap(), Zn = new WeakMap(), fn = new WeakMap(), Ws = new WeakMap(), Ys = new WeakMap(), Mr = new WeakMap(), Ga = new WeakMap(), qs = new WeakMap(), hu = new WeakMap(), ja = new WeakMap(), Rr = new WeakMap(), dn = new WeakMap(), pn = new WeakMap(), Kn = new WeakMap(), lu = new WeakMap(), uu = new WeakMap(), cu = new WeakMap(), zd = new WeakSet(), vx = function(e) {
  const i = /([^\d]+)\d+\.(\w+)/.exec(e[0]);
  if (!i)
    return [];
  const n = i[1].length, s = -i[2].length - 1;
  return e.sort(
    (o, a) => Ue(o.slice(n, s)) > Ue(a.slice(n, s)) ? 1 : -1
  );
}, Vd = new WeakSet(), yx = function(e, i, n) {
  var u;
  if (i.data = e, i.extension === "bin" && (e instanceof HTMLImageElement ? (i.texture = ut.fromLoader(e, i.url, i.name), i.type = bt.TYPE.IMAGE) : e instanceof HTMLVideoElement && (e.volume = h(rt, qs), rt.hFn2VElm[i.name] = x(u = rt, fu, cm).call(u, e), i.type = bt.TYPE.VIDEO)), i.extension !== "json") {
    n();
    return;
  }
  if (typeof e != "string") {
    n();
    return;
  }
  const { meta: s, frames: o } = i.data = JSON.parse(e);
  if (i.type = bt.TYPE.JSON, !(s != null && s.image)) {
    n();
    return;
  }
  const a = vl(s.image), l = h(rt, Ws).searchPath(a, Xe.SP_GSM);
  new Oi().use((c, d) => {
    h(this, Mr).dec(c.extension, c.data).then((f) => {
      c.data = f, f instanceof HTMLImageElement && (c.type = bt.TYPE.IMAGE, URL.revokeObjectURL(f.src)), d == null || d();
    }).catch((f) => h(this, fn).errScript(`Graphic ロード失敗です dec2res4Cripto fn:${c.name} ${f}`, !1));
  }).add({ name: a, url: l, xhrType: bt.XHR_RESPONSE_TYPE.BUFFER }).load((c, d) => {
    for (const { data: f } of Object.values(c.resources)) {
      const { baseTexture: v } = ut.from(f), m = Object.values(o);
      rt.hFn2ResAniSpr[i.name] = {
        aTex: m.map(({ frame: { x: p, y, w: b, h: w } }) => new ut(
          v,
          new pt(p, y, b, w)
        )),
        meta: s
      };
    }
    n();
  });
}, fu = new WeakSet(), cm = function(e) {
  return h(rt, Ga).getVal("const.sn.needClick2Play") && (wt.trace_beforeNew(`[lay系] ${wt.strPos()}未クリック状態で動画を自動再生します。音声はミュートされます`, "W"), e.muted = !0), e.setAttribute("playsinline", ""), e;
}, Xd = new WeakSet(), mx = function(e, i) {
  const n = rt.hFn2ResAniSpr[e];
  if (n) {
    const s = new Jg(n.aTex);
    return s.animationSpeed = n.meta.animationSpeed ?? 1, s.play(), s;
  }
  return e in li ? ge.from(e) : e in rt.hFn2VElm ? ge.from(rt.hFn2VElm[e]) : e in i ? new ge(i[e].texture) : new ge();
}, Ha = new WeakSet(), If = function(e) {
  const i = rt.hFn2VElm[e];
  i && (delete rt.hFn2VElm[e], i.pause(), i.currentTime = i.duration);
}, $a = new WeakMap(), rr = new WeakMap(), za = new WeakMap(), Wd = new WeakMap(), Zs = new WeakMap(), du = new WeakMap(), _(Pt, zd), _(Pt, Vd), _(Pt, fu), _(Pt, Xd), _(Pt, Ha), _(Pt, $d, new Dh()), _(Pt, Zn, {}), _(Pt, fn, void 0), _(Pt, Ws, void 0), _(Pt, Ys, void 0), _(Pt, Mr, void 0), _(Pt, Ga, void 0), _(Pt, qs, 1), _(Pt, hu, 1), _(Pt, ja, void 0), D(Pt, "hFn2ResAniSpr", {}), _(Pt, cu, (e, i, n) => {
  var s, o;
  switch (i.type) {
    case bt.TYPE.JSON:
      const a = i.spritesheet._frameKeys;
      x(s = rt, zd, vx).call(s, a), rt.hFn2ResAniSpr[i.name] = {
        aTex: a.map((u) => ut.from(u)),
        meta: i.data.meta
      };
      break;
    case bt.TYPE.VIDEO:
      const l = i.data;
      l.volume = h(rt, qs), rt.hFn2VElm[i.name] = x(o = rt, fu, cm).call(o, l);
  }
  n();
}), D(Pt, "hFn2VElm", {}), _(Pt, Wd, /\?([^?]+)$/), _(Pt, Zs, {}), _(Pt, du, {});
var Va, pu, Ks, St, kr, vn, Yd, bi, Jn, st, Fi, Je, Qe, Xa, Cf, nr, yn, vu, Wa, qd, _x, Js, Ya, Qn, Qs, to, eo, qa, yu, ts, mu, fm, mn, _u, _n, Nr, Za, gu, dm, es, io, bu, pm, ni;
const yt = class extends Qt {
  constructor(e, i, n) {
    super();
    _(this, Xa);
    _(this, qd);
    _(this, mu);
    // 「g」などで下が欠ける問題対策
    _(this, gu);
    _(this, bu);
    _(this, St, document.createElement("span"));
    // サンプリング元
    _(this, kr, new Qt());
    // サンプリング先
    _(this, vn, new Ci());
    _(this, bi, new qC(this.spLay, this));
    _(this, Jn, new ZC(this));
    _(this, st, {
      fontsize: 24,
      $width: 0,
      // レイヤサイズであり、背景色（画像）サイズ
      $height: 0,
      pad_left: 0,
      // paddingLeft（レイヤサイズの内側のスペーサー）
      pad_right: 0,
      // paddingRight
      pad_top: 0,
      // paddingTop
      pad_bottom: 0
      // paddingBottom
    });
    _(this, Fi, !1);
    _(this, Je, 0);
    _(this, Qe, 0);
    _(this, nr, 0);
    _(this, yn, !1);
    _(this, vu, 0);
    _(this, Wa, 0);
    _(this, Js, void 0);
    // 文字にかけるフィルター
    _(this, Ya, []);
    _(this, Qn, []);
    _(this, Qs, 0);
    _(this, ts, () => !1);
    _(this, Za, 0);
    _(this, es, "Quadratic.Out");
    _(this, io, "Quadratic.Out");
    _(this, ni, void 0);
    this.spLay = e, this.canFocus = i, this.sys = n, h(this, St).classList.add("sn_tx"), h(this, St).style.position = "absolute", h(yt, pu).view.parentElement.appendChild(h(this, St)), this.addChild(h(this, kr)), this.addChild(h(this, vn)), h(this, vn).name = "grpDbgMasume", h(this, bi).adopt(h(this, Jn));
  }
  static init(e, i) {
    g(yt, Va, e), g(yt, pu, i), g(yt, to, /[、。，．）］｝〉」』】〕”〟ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ！？!?‼⁉・ーゝゞヽヾ々]/), g(yt, eo, /[［（｛〈「『【〔“〝]/), g(yt, qa, /[─‥…]/);
  }
  static setEvtMng(e) {
    g(yt, Ks, e);
  }
  static destroy() {
    g(yt, mn, /* @__PURE__ */ Object.create(null)), g(yt, _n, /* @__PURE__ */ Object.create(null)), g(yt, Nr, new Qt());
  }
  lay(e) {
    const i = h(this, St).style;
    if ("style" in e)
      if (e.style) {
        const n = document.createElement("span");
        n.style.cssText = e.style;
        const s = n.style.length;
        for (let o = 0; o < s; ++o) {
          const a = n.style[o];
          if (a in h(yt, Yd)) {
            wt.myTrace(`${a}は指定できません`, "W");
            continue;
          }
          i[a] = n.style[a];
        }
        !n.style.opacity && "alpha" in e && (i.opacity = String(this.spLay.alpha));
      } else
        h(this, St).style.cssText = "";
    else
      "alpha" in e && (i.opacity = String(this.spLay.alpha));
    if ("width" in e && (i.width = (e.width ?? "0") + "px"), "height" in e && (i.height = (e.height ?? "0") + "px"), "pl" in e && (i.paddingLeft = (e.pl ?? "0") + "px"), "pr" in e && (i.paddingRight = (e.pr ?? "0") + "px"), "pt" in e && (i.paddingTop = (e.pt ?? "0") + "px"), "pb" in e && (i.paddingBottom = (e.pb ?? "0") + "px"), "kinsoku_sol" in e && g(yt, to, new RegExp(`[${e.kinsoku_sol}]`)), "kinsoku_eol" in e && g(yt, eo, new RegExp(`[${e.kinsoku_eol}]`)), "kinsoku_dns" in e && g(yt, qa, new RegExp(`[${e.kinsoku_dns}]`)), x(this, Xa, Cf).call(this), h(this, bi).sethArg(e), g(this, nr, this.spLay.position.x), i.transformOrigin = `${this.spLay.pivot.x}px ${this.spLay.pivot.y}px`, this.cvsResize(), i.display = this.spLay.visible ? "inline" : "none", i.textShadow = e.filter ?? i.textShadow ?? "", g(this, Fi, K(e, "break_fixed", h(this, Fi))), g(this, Je, j(e, "break_fixed_left", h(this, Je))), g(this, Qe, j(e, "break_fixed_top", h(this, Qe))), ":redraw" in e && h(this, Qs) > 0) {
      const n = [
        h(this, St).innerHTML.replaceAll(/(animation-delay: )\d+ms/g, "$10ms"),
        `<span class='sn_ch' data-add='{"ch_in_style":"default"}'>　</span>`
      ];
      x(this, bu, pm).call(this), this.goTxt(n, !0);
    }
  }
  cvsResize() {
    const e = h(this, St).style, i = this.sys.cvsScale;
    e.left = `${this.sys.ofsLeft4elm + h(this, nr) * i}px`, e.top = `${this.sys.ofsTop4elm + this.spLay.position.y * i}px`, e.transform = `rotate(${this.spLay.angle}deg) scale(${this.spLay.scale.x * i}, ${this.spLay.scale.y * i})`, h(this, bi).cvsResize(), h(this, Jn).cvsResize();
  }
  get tategaki() {
    return h(this, yn);
  }
  get infTL() {
    return h(this, st);
  }
  get getWidth() {
    return h(this, st).$width;
  }
  get getHeight() {
    return h(this, st).$height;
  }
  setSize(e, i) {
    h(this, st).$width = e, h(this, st).$height = i, h(this, St).style.width = h(this, st).$width + "px", h(this, St).style.height = h(this, st).$height + "px";
  }
  goTxt(e, i) {
    var E, O, I;
    h(yt, Nr).visible = !1;
    let n = h(this, Qn).length, s = "";
    if (n === 0) {
      if (h(yt, Va).oCfg.debug.masume && (L.debugLog && console.log(`🍌 masume ${this.name} v:${this.visible} l:${this.x} t:${this.y} a:${this.alpha} pl:${h(this, st).pad_left} pr:${h(this, st).pad_right} pt:${h(this, st).pad_top} pb:${h(this, st).pad_bottom} w:${h(this, st).$width} h:${h(this, st).$height}`), h(this, vn).clear().beginFill(3407616, 0.2).lineStyle(1, 3407616, 1).drawRect(-h(this, st).pad_left, -h(this, st).pad_top, h(this, st).$width, h(this, st).$height).endFill().beginFill(13311, 0.2).lineStyle(2, 13311, 1).drawRect(
        0,
        0,
        h(this, st).$width - h(this, st).pad_left - h(this, st).pad_right,
        h(this, st).$height - h(this, st).pad_top - h(this, st).pad_bottom
      ).endFill()), h(this, St).innerHTML = [...e].join("").replaceAll(/[\n\t]/g, "") + h(yt, yu), !h(this, Fi)) {
        const S = globalThis.getComputedStyle(h(this, St)), C = parseFloat(S.fontSize);
        h(this, yn) ? (g(this, Je, (h(this, st).$width - h(this, st).pad_left - h(this, st).pad_right - C * 1.5) * this.sys.cvsScale), g(this, Qe, 0)) : (g(this, Je, 0), g(this, Qe, C / 2 * this.sys.cvsScale));
      }
    } else
      s = h(this, St).innerHTML, h(this, St).querySelectorAll(":scope > br").forEach((S) => h(this, St).removeChild(S)), h(this, St).insertAdjacentHTML(
        "beforeend",
        e.slice(h(this, Qs)).join("").replaceAll(/[\n\t]/g, "") + h(yt, yu)
        // 末尾改行削除挙動対策
      ), --n, (E = h(this, St).querySelector(".sn_ch_last")) == null || E.remove();
    g(this, Qs, e.length);
    const o = this.sys.cvsScale, a = h(this, St).getBoundingClientRect(), l = a.left + h(this, st).pad_left, u = a.top + h(this, st).pad_top;
    let c;
    if (o === 1)
      c = (S, C) => new pt(
        S.left - l,
        S.top - u,
        S.width,
        S.height + ("gjqy".includes(C) ? h(this, Za) : 0)
      );
    else {
      const S = this.sys.ofsPadLeft_Dom2PIXI + a.left * (1 - o), C = this.sys.ofsPadTop_Dom2PIXI + a.top * (1 - o);
      c = (P, R) => new pt(
        (P.left - S) / o - l,
        (P.top - C) / o - u,
        P.width / o,
        (P.height + ("gjqy".includes(R) ? h(this, Za) : 0)) / o
      );
    }
    let d = 0, f = 2, v = !1;
    do {
      const S = g(this, Qn, x(this, gu, dm).call(this, h(this, St), c));
      if (d = S.length, !v && (d < 2 || n === d)) {
        n > 0 && n === d && (h(this, St).innerHTML = s.replaceAll('class="sn_ch"', 'class="sn_ch sn_ch_in_default"'));
        break;
      }
      v = !0;
      let C = -1 / 0;
      for (; f < d; ++f) {
        const P = S[f];
        if (P.elm.tagName === "RT")
          continue;
        const R = this.tategaki ? P.rect.y : P.rect.x;
        if (C <= R || ((I = (O = P.elm.previousElementSibling) == null ? void 0 : O.children[0]) == null ? void 0 : I.tagName) === "BR") {
          C = R, h(this, Fi) || (g(this, Je, P.rect.x), g(this, Qe, P.rect.y));
          continue;
        }
        let N = f - 1;
        for (; S[N].elm.tagName === "RT"; )
          --N;
        const F = S[N], $ = F.ch;
        if (!h(this, Fi)) {
          g(this, Je, F.rect.x), g(this, Qe, F.rect.y);
          const H = globalThis.getComputedStyle(F.elm), Q = parseFloat(H.fontSize);
          h(this, yn) ? g(this, Qe, h(this, Qe) + Q) : g(this, Je, h(this, Je) + Q);
        }
        C = -1 / 0;
        const q = f;
        if (h(yt, qa).test($) && $ === P.ch)
          f = N;
        else {
          if (h(yt, eo).test($))
            f = N;
          else if (h(yt, to).test(P.ch))
            for (f = N + 1; f > 0 && h(yt, to).test(S[--f].ch); )
              ;
          else {
            ++f;
            continue;
          }
          for (f = N + 1; f > 0 && h(yt, eo).test(S[--f].ch); )
            ;
        }
        const ht = S[f].elm.parentElement, V = document.createElement("br");
        if (ht.classList.contains("sn_tx"))
          ht.insertBefore(V, S[f].elm);
        else {
          const H = ht.parentElement;
          H.classList.contains("sn_ch") ? H.parentElement.insertBefore(V, H) : H.insertBefore(V, ht);
        }
        f += 2, f < q && (f = q), d = -1;
        break;
      }
    } while (d < 0);
    const m = L.debugLog ? (S, C) => console.log(`🍌 masume ch:${S.ch} x:${C.x} y:${C.y} w:${C.width} h:${C.height}`) : () => {
    }, p = h(yt, Va).oCfg.debug.masume ? (S, C) => {
      m(S, C), h(this, vn).beginFill(6737151, 0.5).lineStyle(2, 16724736, 1).drawRect(C.x, C.y, C.width, C.height).endFill();
    } : () => {
    }, y = Fn.ease(h(this, es));
    for (let S = n; S < d; ++S) {
      const C = h(this, Qn)[S], P = C.rect, R = JSON.parse(C.elm.dataset.arg ?? '{"delay": 0}'), N = JSON.parse(C.elm.dataset.add ?? "{}"), F = h(yt, mn)[N.ch_in_style];
      if (p(C, P), C.elm.dataset.cmd === "grp") {
        const $ = new Qt();
        h(this, kr).addChild($), Pt.csv2Sprites(R.pic, $, (q) => {
          x(this, mu, fm).call(this, $, R, N, P, y, F ?? {}), $.parent || $.removeChild(q);
        });
      }
      if (C.elm.dataset.lnk) {
        const $ = C.elm.parentElement.closest("[data-arg]"), q = JSON.parse($.dataset.arg ?? "{}");
        q.key = `lnk=[${S}] ` + this.name;
        const ht = new ge();
        x(this, mu, fm).call(this, ht, q, N, P, y, F ?? {});
        const V = q.style ?? "", H = V + (q.style_hover ?? ""), Q = V + (q.style_clicked ?? ""), mt = q.r_style ?? "", et = mt + (q.r_style_hover ?? ""), Tt = mt + (q.r_style_clicked ?? ""), it = $.querySelectorAll("rt");
        it.forEach((Ut) => Ut.dataset.st_r_bk = Ut.style.cssText);
        const we = $.style.cssText, Bt = (Ut, k) => {
          $.style.cssText = we + Ut, it.forEach((zt) => zt.style.cssText = zt.dataset.st_r_bk + k);
        };
        K(q, "enabled", !0) ? h(yt, Ks).button(
          q,
          ht,
          () => Bt(V, mt),
          () => this.canFocus() ? (Bt(H, et), !0) : !1,
          () => Bt(Q, Tt)
        ) : Bt(
          V + (q.style_disable ?? "color: gray;"),
          mt + (q.r_style_disable ?? "color: gray;")
        ), h(this, kr).addChild(ht);
      }
    }
    const b = h(this, St).querySelectorAll("span.sn_ch");
    g(this, ts, () => (g(this, ts, () => !1), b.forEach((S) => S.className = S.className.replaceAll(/ go_ch_in_[^\s"]+/g, "")), h(yt, Nr).position.set(
      h(this, Je),
      h(this, Qe)
    ), h(yt, Nr).visible = !0, h(yt, Ks).noticeCompTxt(), !0)), b.forEach((S) => S.className = S.className.replaceAll(/sn_ch_in_([^\s"]+)/g, "go_ch_in_$1")), n > 0 && ++n;
    let w;
    for (let S = d - 2; S >= 0; --S) {
      const C = h(this, Qn)[S];
      if (C.elm.tagName === "SPAN") {
        w = C.elm;
        break;
      }
    }
    if (!w || i || n === d) {
      h(this, ts).call(this);
      return;
    }
    w.addEventListener("animationend", h(this, ts), { once: !0, passive: !0 });
  }
  skipChIn() {
    let e = h(this, ts).call(this);
    for (const i of h(this, Ya))
      i.tw && (i.tw.stop().end(), e = !0);
    return g(this, Ya, []), e;
  }
  static initChStyle() {
    g(yt, mn, /* @__PURE__ */ Object.create(null)), g(yt, _n, /* @__PURE__ */ Object.create(null));
  }
  static getChInStyle(e) {
    return h(yt, mn)[e];
  }
  static ch_in_style(e) {
    const { name: i } = e;
    if (!i)
      throw "nameは必須です";
    if (h(yt, _u).test(i))
      throw `name【${i}】に使えない文字が含まれます`;
    if (i in h(yt, mn))
      throw `name【${i}】はすでにあります`;
    const n = String(e.x ?? "=0"), s = String(e.y ?? "=0");
    return h(yt, mn)[i] = {
      wait: j(e, "wait", 500),
      // アニメ・FI時間
      alpha: j(e, "alpha", 0),
      x: n,
      // 初期x値
      y: s,
      // [tsy]と同様に絶対・相対指定可能
      // {x:500}			X位置を500に
      // {x:'=500'}		現在のX位置に+500加算した位置
      // {x:'=-500'}		現在のX位置に-500加算した位置
      // {x:'250,500'}	+250から＋500までの間でランダムな値をX位置に
      // {x:'=250,500'}	+250から＋500までの間でランダムな値を現在のX位置に加算
      nx: parseFloat(n.at(0) === "=" ? n.slice(1) : n),
      ny: parseFloat(s.at(0) === "=" ? s.slice(1) : s),
      scale_x: j(e, "scale_x", 1),
      scale_y: j(e, "scale_y", 1),
      rotate: j(e, "rotate", 0),
      join: K(e, "join", !0),
      // 文字を順番に出すか（true）同時か（false）
      ease: e.ease ?? "ease-out"
    };
  }
  static getChOutStyle(e) {
    return h(yt, _n)[e];
  }
  static ch_out_style(e) {
    const { name: i } = e;
    if (!i)
      throw "nameは必須です";
    if (h(yt, _u).test(i))
      throw `name【${i}】に使えない文字が含まれます`;
    if (i in h(yt, _n))
      throw `name【${i}】はすでにあります`;
    const n = String(e.x ?? "=0"), s = String(e.y ?? "=0");
    return h(yt, _n)[i] = {
      wait: j(e, "wait", 500),
      // アニメ・FI時間
      alpha: j(e, "alpha", 0),
      x: n,
      // 初期x値
      y: s,
      // [tsy]と同様に絶対・相対指定可能
      // {x:500}			X位置を500に
      // {x:'=500'}		現在のX位置に+500加算した位置
      // {x:'=-500'}		現在のX位置に-500加算した位置
      // {x:'250,500'}	+250から＋500までの間でランダムな値をX位置に
      // {x:'=250,500'}	+250から＋500までの間でランダムな値を現在のX位置に加算
      nx: parseFloat(n.at(0) === "=" ? n.slice(1) : n),
      ny: parseFloat(s.at(0) === "=" ? s.slice(1) : s),
      scale_x: j(e, "scale_x", 1),
      scale_y: j(e, "scale_y", 1),
      rotate: j(e, "rotate", 0),
      join: K(e, "join", !1),
      // 文字を順番に出すか（true）同時か（false）
      ease: e.ease ?? "ease-out"
    };
  }
  dispBreak(e) {
    const i = h(yt, Nr);
    i.visible = !1, this.addChild(i), Pt.csv2Sprites(e, i, (n) => {
      i.parent || i.removeChild(n);
    });
  }
  static delBreak() {
    const e = h(yt, Nr);
    e.parent && (e.parent.removeChild(e), e.removeChildren()), g(yt, Nr, new Qt());
  }
  reNew() {
    var i;
    x(this, bu, pm).call(this);
    const e = new yt(this.spLay, () => this.canFocus(), this.sys);
    return g(e, st, h(this, st)), h(e, St).style.cssText = h(this, St).style.cssText, g(e, nr, h(this, nr)), e.name = this.name, x(i = e, Xa, Cf).call(i), h(e, bi).sethArg(h(this, bi).gethArg()), g(e, Js, h(this, Js)), g(e, es, h(this, es)), g(e, io, h(this, io)), g(e, Fi, h(this, Fi)), g(e, Je, h(this, Je)), g(e, Qe, h(this, Qe)), this.destroy(), e;
  }
  record() {
    return {
      infTL: h(this, st),
      cssText: h(this, St).style.cssText,
      left: h(this, nr),
      idc_hArg: h(this, bi).gethArg(),
      ch_filter: h(this, Js),
      fi_easing: h(this, es),
      fo_easing: h(this, io),
      break_fixed: h(this, Fi),
      break_fixed_left: h(this, Je),
      break_fixed_top: h(this, Qe)
    };
  }
  playback(e) {
    g(this, st, e.infTL), this.position.set(h(this, st).pad_left, h(this, st).pad_top), h(this, St).style.cssText = e.cssText, g(this, nr, e.left), x(this, Xa, Cf).call(this), h(this, bi).sethArg(e.idc_hArg), g(this, Js, e.ch_filter), g(this, es, e.fi_easing), g(this, io, e.fo_easing), g(this, Fi, e.break_fixed ?? !1), g(this, Je, e.break_fixed_left ?? 0), g(this, Qe, e.break_fixed_top ?? 0);
  }
  snapshot(e, i) {
    x(this, qd, _x).call(this, (n) => {
      g(this, ni, new ge(n)), h(this, yn) && (h(this, ni).x += L.stageW - (h(this, nr) + h(this, st).$width)), h(this, ni).y -= h(this, Wa), h(this, ni).texture.frame = new pt(
        0,
        0,
        Math.min(h(this, ni).width, h(this, st).$width - h(this, nr)),
        Math.min(h(this, ni).height, h(this, st).$height)
      ), h(this, kr).addChild(h(this, ni)), e.render(h(this, ni), { clear: !1 }), i();
    }, !1);
  }
  snapshot_end() {
    h(this, ni) && (h(this, kr).removeChild(h(this, ni)), g(this, ni, void 0));
  }
  makeDesignCast(e) {
    e(h(this, bi));
    const i = h(this, bi).gethArg();
    h(this, Jn).sethArg({ ...i, ":id_dc": i[":id_tag"] + "_pad" }), e(h(this, Jn));
  }
  showDesignCast() {
    h(this, bi).visible = !0, h(this, Jn).visible = !0;
  }
  dump() {
    const e = [], i = h(this, St).style, n = i.length;
    for (let s = 0; s < n; ++s) {
      const o = i[s];
      e.push(`"${o}":"${i[o].replaceAll(/(["\\])/g, "\\$1")}"`);
    }
    return `"txt":"${h(this, St).textContent.replaceAll(/(["\\])/g, "\\$1")}", "style":{${e.join(",")}}`;
  }
  destroy() {
    yt.delBreak(), h(this, St).parentElement.removeChild(h(this, St)), this.removeChild(h(this, kr)), this.removeChild(h(this, vn)), super.destroy();
  }
};
let le = yt;
Va = new WeakMap(), pu = new WeakMap(), Ks = new WeakMap(), St = new WeakMap(), kr = new WeakMap(), vn = new WeakMap(), Yd = new WeakMap(), bi = new WeakMap(), Jn = new WeakMap(), st = new WeakMap(), Fi = new WeakMap(), Je = new WeakMap(), Qe = new WeakMap(), Xa = new WeakSet(), Cf = function() {
  const e = h(this, St).style, i = parseFloat(e.fontSize || "0");
  h(this, st).fontsize = i, h(this, st).pad_left = parseFloat(e.paddingLeft || "0"), h(this, st).pad_right = parseFloat(e.paddingRight || "0"), h(this, st).pad_top = parseFloat(e.paddingTop || "0"), h(this, st).pad_bottom = parseFloat(e.paddingBottom || "0"), h(this, st).$width = parseFloat(e.width || "0"), h(this, st).$height = parseFloat(e.height || "0"), this.position.set(h(this, st).pad_left, h(this, st).pad_top), g(this, yn, e.writingMode === "vertical-rl"), g(this, vu, 0), g(this, Wa, 0);
  const n = e.lineHeight ?? "0";
  g(this, Za, h(this, yn) ? 0 : (n.slice(-2) === "px" ? parseFloat(n) : i * parseFloat(n) - i) / 2);
}, nr = new WeakMap(), yn = new WeakMap(), vu = new WeakMap(), Wa = new WeakMap(), qd = new WeakSet(), _x = function(e, i = !0) {
  const n = {
    escape: (y) => y.replaceAll(/([.*+?^${}()|\[\]\/\\])/g, "\\$1"),
    mimeType: (y) => {
      const b = u(y).toLowerCase();
      return s()[b] || "";
    },
    dataAsUrl: v,
    isDataUrl: c,
    resolveUrl: d,
    getAndEncode: f,
    asArray: (y) => {
      const b = [], w = y.length;
      for (let E = 0; E < w; ++E)
        b.push(y[E]);
      return b;
    }
  };
  function s() {
    const y = "application/font-woff", b = "image/jpeg";
    return {
      woff: y,
      woff2: y,
      ttf: "application/font-truetype",
      eot: "application/vnd.ms-fontobject",
      png: "image/png",
      jpg: b,
      jpeg: b,
      gif: "image/gif",
      tiff: "image/tiff",
      svg: "image/svg+xml"
    };
  }
  const o = m(), a = p();
  function l(y) {
    return a.resolveAll().then((b) => {
      const w = document.createElement("style");
      return y.appendChild(w), w.appendChild(document.createTextNode(b)), y;
    });
  }
  function u(y) {
    const b = /\.([^\.\/]*?)$/g.exec(y);
    return (b == null ? void 0 : b[1]) ?? "";
  }
  function c(y) {
    return y.search(/^(data:)/) !== -1;
  }
  function d(y, b) {
    const w = document.implementation.createHTMLDocument(), E = w.createElement("base");
    w.head.appendChild(E);
    const O = w.createElement("a");
    return w.body.appendChild(O), E.href = b, O.href = y, O.href;
  }
  function f(y) {
    let b = 3e4;
    return new Promise(function(w) {
      const E = new XMLHttpRequest();
      E.onreadystatechange = O, E.ontimeout = I, E.responseType = "blob", E.timeout = b, E.open("GET", y, !0), E.send();
      function O() {
        if (E.readyState !== 4)
          return;
        if (E.status !== 200) {
          S("cannot fetch resource: " + y + ", status: " + E.status);
          return;
        }
        const C = new FileReader();
        C.onloadend = function() {
          const P = C.result.toString().split(/,/)[1];
          w(P);
        }, C.readAsDataURL(E.response);
      }
      function I() {
        S("timeout of " + b + "ms occured while fetching resource: " + y);
      }
      function S(C) {
        console.error(C), w("");
      }
    });
  }
  function v(y, b) {
    return "data:" + b + ";base64," + y;
  }
  function m() {
    const y = /url\(['"]?([^'"]+?)['"]?\)/g;
    return {
      inlineAll: O,
      shouldProcess: b
    };
    function b(I) {
      return I.search(y) !== -1;
    }
    function w(I) {
      const S = [];
      let C;
      for (; C = y.exec(I); )
        S.push(C[1]);
      return S.filter(function(P) {
        return !n.isDataUrl(P);
      });
    }
    function E(I, S, C, P) {
      return Promise.resolve(S).then((N) => C ? n.resolveUrl(N, C) : N).then(P || n.getAndEncode).then((N) => n.dataAsUrl(N, n.mimeType(S))).then((N) => I.replace(R(S), "$1" + N + "$3"));
      function R(N) {
        return new RegExp(`(url\\(['"]?)(` + n.escape(N) + `)(['"]?\\))`, "g");
      }
    }
    function O(I, S, C) {
      if (P())
        return Promise.resolve(I);
      return Promise.resolve(I).then(w).then((R) => {
        let N = Promise.resolve(I);
        for (const F of R)
          N = N.then(($) => E($, F, S, C));
        return N;
      });
      function P() {
        return !b(I);
      }
    }
  }
  function p() {
    return {
      resolveAll: y,
      impl: { readAll: b }
    };
    function y() {
      return b().then((w) => Promise.allSettled(
        w.map((E) => E.resolve())
      )).then((w) => w.join(`
`));
    }
    function b() {
      return Promise.resolve(n.asArray(document.styleSheets)).then(E).then(w).then((I) => I.map(O));
      function w(I) {
        return I.filter((S) => S.type === CSSRule.FONT_FACE_RULE).filter((S) => o.shouldProcess(S.style.getPropertyValue("src")));
      }
      function E(I) {
        const S = [];
        for (const C of I)
          try {
            if (C.href)
              continue;
            n.asArray(C.cssRules || []).forEach(S.push.bind(S));
          } catch (P) {
            console.error("Error while reading CSS rules from " + C.href, P.toString());
          }
        return S;
      }
      function O(I) {
        return {
          resolve: function() {
            const C = (I.parentStyleSheet || {}).href;
            return o.inlineAll(I.cssText, C);
          },
          src: function() {
            return I.style.getPropertyValue("src");
          }
        };
      }
    }
  }
  Promise.resolve(h(this, St)).then((y) => {
    const b = y.cloneNode(!0);
    return b.style.padding = "0px", b.style.paddingRight = h(this, vu) + "px", b.style.paddingTop = h(this, Wa) + "px", b.style.left = "0px", b.style.top = "0px", b.style.width = h(this, st).$width - h(this, st).pad_left - h(this, st).pad_right + "px", b.style.height = h(this, st).$height - h(this, st).pad_top - h(this, st).pad_bottom + "px", h(this, St).hidden = i, b;
  }).then(l).then((y) => {
    y.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
    const b = new Image();
    return b.src = `data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="${h(this, st).$width}px" height="${h(this, st).$height}px"><foreignObject x="0" y="0" width="100%" height="100%">${new XMLSerializer().serializeToString(y).replaceAll("#", "%23").replaceAll(`
`, "%0A")}</foreignObject></svg>`, new Promise((w) => b.onload = () => w(b));
  }).then((y) => new Promise((b) => setTimeout(() => b(y), 100))).then((y) => {
    const b = document.createElement("canvas");
    b.width = h(this, st).$width, b.height = h(this, st).$height, b.getContext("2d").drawImage(y, 0, 0), b.toBlob((w) => {
      if (!w)
        return;
      const E = URL.createObjectURL(w);
      ut.from(E).once("update", (O) => {
        e(O), URL.revokeObjectURL(E);
      });
    });
  }).catch((y) => wt.myTrace(`goTxt() = ${y}`));
}, Js = new WeakMap(), Ya = new WeakMap(), Qn = new WeakMap(), Qs = new WeakMap(), to = new WeakMap(), eo = new WeakMap(), qa = new WeakMap(), yu = new WeakMap(), ts = new WeakMap(), mu = new WeakSet(), fm = function(e, i, n, s, o, a) {
  e.alpha = 0, i.x && (s.x = i.x.at(0) === "=" ? s.x + parseInt(i.x.slice(1)) : parseInt(i.x)), i.y && (s.y = i.y.at(0) === "=" ? s.y + parseInt(i.y.slice(1)) : parseInt(i.y)), i.width && (s.width = parseInt(i.width)), i.height && (s.height = parseInt(i.height)), i.wait && (a.wait = parseInt(i.wait)), e.width = s.width, e.height = s.height, a.x ? e.position.set(
    a.x.at(0) === "=" ? s.x + e.width * a.nx : a.nx,
    a.y.at(0) === "=" ? s.y + e.height * a.ny : a.ny
  ) : e.position.set(s.x, s.y);
  const l = {
    sp: e,
    tw: new zr(e).to({ alpha: 1, x: s.x, y: s.y, width: s.width, height: s.height, angle: 0 }, a.wait ?? 0).easing(o).delay((n.wait ?? 0) + (i.delay ?? 0)).onComplete(() => {
      l.tw = void 0;
    }).start()
  };
  h(this, Ya).push(l);
}, mn = new WeakMap(), _u = new WeakMap(), _n = new WeakMap(), Nr = new WeakMap(), Za = new WeakMap(), gu = new WeakSet(), dm = function(e, i) {
  const n = [];
  if (e.nodeType !== e.TEXT_NODE)
    return Array.from(e.childNodes).map((l) => x(this, gu, dm).call(this, l, i)).flat();
  const s = e.ownerDocument.createRange();
  s.selectNodeContents(e);
  let o = 0;
  const a = s.endOffset;
  for (; o < a; ) {
    s.setStart(e, o), s.setEnd(e, ++o);
    const l = s.toString();
    n.push({
      ch: l,
      rect: i(s.getBoundingClientRect(), l),
      elm: s.startContainer.parentElement
    });
  }
  return s.detach(), n;
}, es = new WeakMap(), io = new WeakMap(), bu = new WeakSet(), pm = function() {
  var o;
  h(this, vn).clear(), g(this, Qn, []), g(this, Qs, 0), this.skipChIn();
  const e = h(this, St).cloneNode(!0);
  e.textContent = "";
  const i = h(this, St);
  i.parentElement.insertBefore(e, i);
  let n = 0;
  i.querySelectorAll("span.sn_ch").forEach((a) => {
    var c, d, f;
    const l = JSON.parse(
      (a == null ? void 0 : a.dataset.add) ?? // 通常文字
      ((c = a == null ? void 0 : a.children[0]) == null ? void 0 : c.getAttribute("data-add")) ?? // ルビ
      ((f = (d = a == null ? void 0 : a.children[0]) == null ? void 0 : d.children[0]) == null ? void 0 : f.getAttribute("data-add")) ?? "{}"
      // 縦中横
    );
    if (!l.ch_out_style)
      return;
    const u = h(yt, _n)[l.ch_out_style];
    if (u) {
      if (u.wait === 0) {
        a.style.display = "none";
        return;
      }
      n += u.wait, u.join || (a.style.animationDelay = "0ms"), a.classList.add(`go_ch_out_${l.ch_out_style}`);
    }
  });
  const s = () => {
    i.parentElement.removeChild(i);
    for (const a of h(this, kr).removeChildren())
      a instanceof Qt && h(yt, Ks).unButton(a), a.destroy();
  };
  n === 0 ? (h(this, St).textContent = "", s()) : (o = i.lastElementChild) == null || o.addEventListener("animationend", s, { once: !0, passive: !0 }), g(this, St, e);
}, ni = new WeakMap(), _(le, Va, void 0), _(le, pu, void 0), _(le, Ks, void 0), _(le, Yd, {
  "background-color": 0,
  "border-bottom-width": 0,
  "border-left-width": 0,
  "border-right-width": 0,
  "border-top-width": 0,
  "margin-bottom": 0,
  "margin-left": 0,
  "margin-right": 0,
  "margin-top": 0
}), _(le, to, void 0), _(le, eo, void 0), _(le, qa, void 0), _(le, yu, "<span class='sn_ch sn_ch_last'>　</span>"), _(le, mn, /* @__PURE__ */ Object.create(null)), _(le, _u, /[\s\.,]/), _(le, _n, /* @__PURE__ */ Object.create(null)), _(le, Nr, new Qt());
var ro, Ar, xu;
const Vn = class {
  constructor() {
    _(this, Ar, () => {
    });
  }
  static setting(t) {
    t.sesame && g(Vn, ro, t.sesame);
  }
  static getSesame() {
    return h(Vn, ro);
  }
  static destroy() {
    g(Vn, ro, "ヽ");
  }
  init(t) {
    g(this, Ar, t);
  }
  static setEscape(t) {
    g(Vn, xu, new RegExp(
      `${t ? `(?<ce>\\${t}\\S)|` : ""}｜(?<str>[^《\\n]+)《(?<ruby>[^》\\n]+)》|(?:(?<kan>[⺀-⿟々〇〻㐀-鿿豈-﫿]+[ぁ-ヿ]*|[^　｜《》\\n])《(?<kan_ruby>[^》\\n]+)》)|(?<txt>[\uD800-\uDBFF][\uDC00-\uDFFF]|[^｜《》]+?|.)`,
      "gs"
    ));
  }
  putTxt(t) {
    for (const { groups: e } of t.matchAll(h(Vn, xu))) {
      const { ruby: i, kan_ruby: n, kan: s, ce: o, txt: a = "", str: l } = e;
      if (i) {
        this.putTxtRb(decodeURIComponent(l), i);
        continue;
      }
      if (n) {
        this.putTxtRb(s, n);
        continue;
      }
      if (o) {
        h(this, Ar).call(this, o.slice(1), "");
        continue;
      }
      for (const u of Array.from(a))
        h(this, Ar).call(this, u, "");
    }
  }
  putTxtRb(t, e) {
    if (/^\w+｜{"/.test(e)) {
      h(this, Ar).call(this, t, e);
      return;
    }
    const i = Array.from(t), n = i.length;
    if (/^\*.?$/.test(e)) {
      const l = "center｜" + (e === "*" ? h(Vn, ro) : e.charAt(1));
      for (let u = 0; u < n; ++u)
        h(this, Ar).call(this, i[u], l);
      return;
    }
    if (n === 1 || e.indexOf(" ") === -1) {
      h(this, Ar).call(this, t, decodeURIComponent(e));
      return;
    }
    const s = e.split(" "), o = s.length, a = o > n ? o : n;
    for (let l = 0; l < a; ++l)
      h(this, Ar).call(this, l < n ? i[l] : "", l < o ? decodeURIComponent(s[l]) : "");
  }
};
let ys = Vn;
ro = new WeakMap(), Ar = new WeakMap(), xu = new WeakMap(), _(ys, ro, "ヽ"), /*
		★Unicodeで「漢字」の正規表現 – ものかの http://tama-san.com/kanji-regex/
		2E80..2FDF CJK部首補助＋康熙部首
		3005 々（漢字の踊り字）
		3007 〇（漢数字のゼロ）
		303B 〻（漢字の踊り字）
		3400..4DBF CJK統合漢字拡張A
		4E00..9FFF CJK統合漢字
		F900..FAFF CJK互換漢字
		20000..2FFFF CJK統合漢字拡張B〜F＋CJK互換漢字追加＋念のためU+2FFFFまで

		[\x{2E80}-\x{2FDF}々〇〻\x{3400}-\x{4DBF}\x{4E00}-\x{9FFF}\x{F900}-\x{FAFF}\x{20000}-\x{2FFFF}]
		[\u2E80-\u2FDF々〇〻\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\u20000-\u2FFFF]
		[⺀-⿟々〇〻㐀-䶿一-鿿豈-﫿\u20000-\u2FFFF]		// 含まれない文字がある
		[⺀-⿟々〇〻㐀-鿿豈-﫿\u20000-\u2FFFF]			// ヽ--30FD が変に引っかかる。多分\u2000-\u2FFF解釈
		\\u{20000}-\\u{2FFFF}	// 五桁だとエラー

		【2022/10/03】ruby正規表現のUnicode プロパティ(とPOSIX文字クラス) - Qiita https://qiita.com/Takayuki_Nakano/items/8d38beaddb84b488d683
			> このHiraganaプロパティ、長音記号は含まれていません。
			> \p{Han}…簡体字や繁体字、韓国語の漢字…ベトナム語の漢字にもマッチ
		
		・Unicode文字一覧表 - instant tools https://tools.m-bsys.com/ex/unicode_table.php
*/
_(ys, xu, void 0);
var wu, Eu, sr, gn, Ka, Ja, Tu, vm, Qa, th, Su, ym;
const As = class extends Qt {
  constructor(e, i, n, s) {
    var m;
    super();
    _(this, Tu);
    _(this, Su);
    D(this, "getBtnBounds", () => h(this, sr));
    // 文字ボタンは背景画像を含まない位置指定なので、その当たり判定用
    _(this, sr, new pt());
    _(this, gn, void 0);
    _(this, Ka, void 0);
    _(this, Ja, void 0);
    D(this, "normal", () => {
    });
    _(this, Qa, () => !1);
    _(this, th, () => {
    });
    this.hArg = e, this.evtMng = i, this.resolve = n, this.canFocus = s, L.isDbg && (this.makeDesignCast = (p) => p(h(this, gn)), this.cvsResize = () => h(this, gn).cvsResize());
    let o = {
      x: this.x = mr(e.left ?? 0),
      y: this.y = mr(e.top ?? 0),
      rotation: this.angle = j(e, "rotation", this.angle),
      // flash : rotation is in degrees.
      // pixijs: rotation is in radians, angle is in degrees.
      pivot_x: this.pivot.x = j(e, "pivot_x", this.pivot.x),
      pivot_y: this.pivot.y = j(e, "pivot_y", this.pivot.y),
      scale_x: this.scale.x = j(e, "scale_x", this.scale.x),
      scale_y: this.scale.y = j(e, "scale_y", this.scale.y),
      width: 0,
      height: 0
    };
    this.getBtnBounds = () => (h(this, sr).x = o.x, h(this, sr).y = o.y, h(this, sr));
    const a = o.enabled = K(e, "enabled", !0);
    if (a && i.button(this.hArg, this, () => this.normal(), () => h(this, Qa).call(this), () => h(this, th).call(this)), e.pic) {
      o.type = "pic", g(this, gn, new JC(this, e)), Pt.csv2Sprites(
        e.pic,
        this,
        (p) => {
          x(this, Su, ym).call(this, p, o), h(this, sr).width = p.width * o.scale_x, h(this, sr).height = p.height * o.scale_y;
        },
        (p) => n
      );
      return;
    }
    if (!e.text)
      throw "textまたはpic属性は必須です";
    const l = j(e, "height", 30), u = new Zo({
      align: "center",
      dropShadow: !0,
      dropShadowAlpha: 0.7,
      dropShadowColor: "white",
      dropShadowBlur: 7,
      dropShadowDistance: 0,
      fill: a ? "black" : "gray",
      fontFamily: As.fontFamily,
      fontSize: l,
      padding: 5
    });
    if (e.style)
      try {
        const p = JSON.parse(e.style);
        for (const [y, b] of Object.entries(p))
          u[y] = b;
      } catch (p) {
        throw new Error(cf(e, "style", p.message));
      }
    const c = new I_(e.text ?? "", u);
    c.alpha = j(e, "alpha", c.alpha), c.width = j(e, "width", 100), c.height = e.height = l, this.setText = (p) => c.text = p, o.type = "text", o = { ...o, ...u }, o.alpha = c.alpha, o.text = c.text, o.width = c.width, o.height = c.height, g(this, gn, new KC(this, e, c));
    let d = !1;
    if (o.width = this.width, o.height = this.height, e.b_pic && (o.b_pic = e.b_pic, d = Pt.csv2Sprites(
      e.b_pic,
      this,
      (p) => {
        x(this, Tu, vm).call(this, p, c), o.width = this.width, o.height = this.height;
      },
      (p) => {
        qe.setBlendmode(this, e), p && n();
      }
    )), c.name = JSON.stringify(o), this.addChild(c), h(this, sr).width = c.width, h(this, sr).height = c.height, e.b_pic || qe.setBlendmode(this, e), h(m = As, wu).call(m, this, c), !a) {
      d || n();
      return;
    }
    const f = u.clone();
    if (e.style_hover)
      try {
        const p = JSON.parse(e.style_hover);
        for (const [y, b] of Object.entries(p))
          f[y] = b;
      } catch (p) {
        throw new Error(cf(e, "style_hover", p.message));
      }
    else
      f.fill = "white";
    const v = f.clone();
    if (e.style_clicked)
      try {
        const p = JSON.parse(e.style_clicked);
        for (const [y, b] of Object.entries(p))
          v[y] = b;
      } catch (p) {
        throw new Error(cf(e, "style_clicked", p.message));
      }
    else
      v.dropShadow = !1;
    this.normal = () => c.style = u, g(this, Qa, () => s() ? (c.style = f, !0) : !1), g(this, th, () => c.style = v), d || n();
  }
  static init(e) {
    e.oCfg.debug.masume && (g(As, wu, (i, n) => i.addChild(
      new Ci().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(n.x, n.y, n.width, n.height).endFill()
    )), g(As, Eu, (i, n, s, o) => i.addChild(
      new Ci().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(n.x, n.y, s, o).endFill()
    )));
  }
  setText(e) {
  }
  destroy(e) {
    this.evtMng.unButton(this), super.destroy();
  }
  makeDesignCast(e) {
  }
  showDesignCast() {
    h(this, gn).visible = !0;
  }
  cvsResize() {
  }
  update_b_pic(e, i) {
    const n = JSON.parse(i.name ?? "{}");
    h(this, Ka) && this.removeChild(h(this, Ka)), this.hArg.b_pic = n.b_pic = e, i.name = JSON.stringify(n), e && Pt.csv2Sprites(
      e,
      this,
      (s) => x(this, Tu, vm).call(this, s, i),
      () => qe.setBlendmode(this, this.hArg)
    );
  }
  update_pic(e, i) {
    const n = JSON.parse(i.name ?? "{}");
    h(this, Ja) && this.removeChild(h(this, Ja)), this.hArg.pic = n.pic = e, i.name = JSON.stringify(n), e && Pt.csv2Sprites(
      e,
      this,
      (s) => x(this, Su, ym).call(this, s, n),
      () => qe.setBlendmode(this, this.hArg)
    );
  }
};
let yr = As;
wu = new WeakMap(), Eu = new WeakMap(), sr = new WeakMap(), gn = new WeakMap(), Ka = new WeakMap(), Ja = new WeakMap(), Tu = new WeakSet(), vm = function(e, i) {
  g(this, Ka, e), this.setChildIndex(e, 0), e.alpha = i.alpha, e.setTransform(
    i.x,
    i.y,
    1,
    1,
    i.rotation,
    0,
    0,
    (e.width - i.width) / 2,
    (e.height - i.height) / 2
  ), e.name = i.name;
}, Qa = new WeakMap(), th = new WeakMap(), Su = new WeakSet(), ym = function(e, i) {
  var d;
  g(this, Ja, e), i.alpha = e.alpha = j(this.hArg, "alpha", e.alpha), h(this, gn).setSp(e);
  const n = e.width / 3, s = e.height, o = e.texture.baseTexture, a = new ut(o, new pt(0, 0, n, s)), l = new ut(o, new pt(n, 0, n, s)), u = new ut(o, new pt(n * 2, 0, n, s)), c = () => e.texture = a;
  c(), this.normal = c, g(this, Qa, () => this.canFocus() ? (e.texture = u, !0) : !1), g(this, th, () => e.texture = l), "width" in this.hArg ? (i.width = mr(this.hArg.width), this.scale.x *= i.width / n) : i.width = n, "height" in this.hArg ? (i.height = mr(this.hArg.height), this.scale.y *= i.height / s) : i.height = s, e.name = JSON.stringify(i), h(d = As, Eu).call(d, this, e, n, s);
}, D(yr, "fontFamily", "'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif"), _(yr, wu, (e, i) => {
}), _(yr, Eu, (e, i, n, s) => {
});
var eh, or, Pu, ih, Ou, mm, Iu, _m, Cu, no, Mu, bn, so, Zd, gx, xn, Bi, ar, Wt, Lr, kt, Ru, Dr, Kd, si, oo, nl, ao, rh, ho, sl, nh, ku, gm, Nu, bm, lo, uo, sh, Au, oh, is, oi, Jd, bx, xi, Lu, ah, Mf, wn, Rs, Fr, hr, Ui, Gi, Du, xm, hh, Rf, Fu, wm, co, fo;
const gt = class extends qe {
  constructor() {
    super();
    _(this, oo);
    _(this, ho);
    _(this, ku);
    _(this, Nu);
    _(this, Jd);
    _(this, ah);
    _(this, wn);
    _(this, Du);
    _(this, hh);
    _(this, Fu);
    // バック
    _(this, xn, 0);
    _(this, Bi, 0);
    _(this, ar, !1);
    _(this, Wt, void 0);
    _(this, Lr, "");
    // 背景画像無し（＝単色塗り）
    // 文字表示
    _(this, kt, new le(this.spLay, () => this.canFocus(), h(gt, Mu)));
    _(this, Ru, new ys());
    _(this, Dr, document.createElement("span"));
    _(this, si, new Qt());
    _(this, ao, "");
    _(this, rh, !0);
    _(this, nh, "");
    _(this, lo, "");
    _(this, uo, (e) => "");
    _(this, sh, "");
    _(this, Au, new RegExp("[　]"));
    D(this, "isCur", !1);
    _(this, is, () => "");
    _(this, oi, "");
    _(this, xi, !1);
    _(this, Lu, (e, i) => {
      var u, c, d;
      h(gt, eh).oCfg.debug.putCh && console.log(`🖊 文字表示 text:\`${e}\` ruby:\`${i}\` name:\`${this.name_}\``);
      const n = i.split("｜");
      let s = "";
      const [o, ...a] = n, l = a.join("｜");
      switch (n.length) {
        case 1:
          if (g(this, xi, !0), e === `
`) {
            h(this, hr) ? (g(this, hr, !1), s = "<ruby>　<rt>　</rt></ruby><br/>") : s = "<br/>";
            break;
          }
          h(this, hr) && (g(this, hr, !1), i === "" && (i = "　")), s = x(this, ah, Mf).call(this, e, i, h(this, oi));
          break;
        default:
          switch (o) {
            case "start":
            case "left":
            case "center":
            case "right":
            case "justify":
            case "121":
            case "even":
            case "1ruby":
              g(this, hr, !1), g(this, xi, !0), s = x(this, ah, Mf).call(this, e, l, o);
              break;
            case "gotxt":
              x(this, hh, Rf).call(this), h(this, xi) ? (this.isCur && h(gt, ih).recText(
                h(this, Ui).join("").replace(/^<ruby>　<rt>　<\/rt><\/ruby>(<br\/>)+/, "").replaceAll(/style='(anim\S+ \S+?;\s*)+/g, "style='").replaceAll(/( style=''| data-(add|arg|cmd)='.+?'|\n+|\t+)/g, "").replaceAll(/class='sn_ch .+?'/g, "class='sn_ch'").replaceAll("display: none;", "").replaceAll("class='offrec'", "style='display: none;'")
                // 囲んだ領域は履歴で非表示
              ), h(this, kt).goTxt(h(this, Ui), h(this, Fr) === 0), g(this, xi, !1), g(this, Fr, 0)) : this.isCur && h(gt, no).noticeCompTxt();
              return;
            case "add":
              {
                const f = JSON.parse(l), { style: v = "", wait: m = null } = f, { cl: p, sty: y } = x(this, wn, Rs).call(this, !0, m);
                h(this, Ui).push(`<span${p} style='${y} display: inline; ${v}'>`), delete f.style, x(this, Du, xm).call(this, f);
              }
              return;
            case "add_close":
              h(this, Ui).push("</span>"), x(this, hh, Rf).call(this);
              return;
            case "grp":
              g(this, xi, !0);
              {
                const f = JSON.parse(l);
                if (f.id ?? (f.id = h(this, Ui).length), f.id === "break") {
                  h(this, kt).dispBreak(f.pic);
                  return;
                }
                g(this, hr, !1), f.delay = h(this, Fr), f.r ?? (f.r = ""), f.style ?? (f.style = ""), f.r_style ?? (f.r_style = "");
                const { cl: v, sty: m, lnk: p } = x(this, wn, Rs).call(this, !0, f.wait);
                s = `<span${v} style='${m} ${f.style}'><ruby><span data-cmd='grp' data-arg='${JSON.stringify(f)}'${p} style='${m} display: inline;'>　</span><rt${p}${this.mkStyle_r_align(
                  "　",
                  f.r,
                  h(this, oi),
                  h(this, Dr).style.cssText + (((u = h(this, Gi).at(-1)) == null ? void 0 : u.o.r_style) ?? "") + f.r_style
                )}>${f.r}</rt></ruby></span>`;
              }
              break;
            case "tcy":
              g(this, hr, !1), g(this, xi, !0);
              {
                const { t: f, r: v = "", wait: m = null, style: p = "", r_style: y = "" } = JSON.parse(l);
                h(gt, or).doRecLog() && (g(this, co, h(this, co) + (e + (i ? `《${i}》` : ""))), g(this, fo, h(this, fo) + f));
                const b = L.isSafari ? v.replaceAll(/[A-Za-z0-9]/g, (I) => String.fromCharCode(I.charCodeAt(0) + 65248)) : v, { cl: w, sty: E, lnk: O } = x(this, wn, Rs).call(this, !0, m);
                s = `<span${w} style='${E}${h(this, uo).call(this, f)} ${p}'><ruby><span${O} style='${E} display: inline;
text-combine-upright: all;
-webkit-text-combine: horizontal;'>${f}</span><rt${O}${this.mkStyle_r_align(
                  f,
                  b,
                  h(this, oi),
                  h(this, Dr).style.cssText + (((c = h(this, Gi).at(-1)) == null ? void 0 : c.o.r_style) ?? "") + y
                )}>${b}</rt></ruby></span>`;
              }
              break;
            case "del":
              le.delBreak();
              return;
            case "span":
              g(this, xi, !0), x(this, Fu, wm).call(this, JSON.parse(l));
              return;
            case "link":
              g(this, xi, !0);
              {
                const f = JSON.parse(l);
                f[":link"] = " data-lnk='@'";
                const { cl: v, sty: m, curpos: p } = x(this, wn, Rs).call(this, !1, f.wait);
                h(this, Ui).push(`<span${v} style='${m} display: inline; ${f.style ?? ""}' ${p} data-arg='${l}'>`), delete f.style, x(this, Fu, wm).call(this, f);
              }
              return;
            case "endlink":
              g(this, xi, !0), h(this, Ui).push("</span>"), x(this, hh, Rf).call(this);
              return;
            default:
              g(this, xi, !0), s = x(this, ah, Mf).call(this, e, i, h(this, oi));
          }
          break;
      }
      h(this, Ui).push(h(d = gt, oh).call(d, s));
    });
    _(this, Fr, 0);
    _(this, hr, !0);
    _(this, Ui, []);
    _(this, Gi, []);
    D(this, "click", () => !this.spLay.interactiveChildren || !this.spLay.visible ? !1 : h(this, kt).skipChIn());
    _(this, co, "");
    _(this, fo, "");
    D(this, "addButton", (e) => new Promise((i) => {
      e.key = `btn=[${h(this, si).children.length}] ` + this.name_, e[":id_tag"] = e.key.slice(0, -7), K(e, "hint_tate", h(this, kt).tategaki);
      const n = new yr(e, h(gt, no), () => i(), () => this.canFocus());
      n.name = JSON.stringify(e).replaceAll('"', "'"), h(this, si).addChild(n);
    }));
    D(this, "record", () => ({
      ...super.record(),
      enabled: this.enabled,
      r_cssText: h(this, Dr).style.cssText,
      r_align: h(this, oi),
      // バック
      b_do: h(this, Wt) === void 0 ? void 0 : h(this, Wt) instanceof ge ? "Sprite" : "Graphics",
      b_pic: h(this, Lr),
      b_color: h(this, xn),
      b_alpha: h(this, Bi),
      b_alpha_isfixed: h(this, ar),
      ffs: h(this, lo),
      txs: h(this, kt).record(),
      strNoFFS: h(this, sh),
      btns: h(this, si).children.map((e) => e.name)
    }));
    this.spLay.addChild(h(this, kt)), h(this, Ru).init(h(this, Lu)), this.spLay.addChild(h(this, si)), h(this, si).name = "cntBtn";
    const e = 16;
    this.lay({ style: `width: ${L.stageW}px; height: ${L.stageH}px; font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif; color: white; font-size: 24px; line-height: 1.5; padding: ${e}px;`, in_style: "default", out_style: "default", back_clear: "true" });
  }
  static init(e, i, n, s, o, a) {
    var l, u;
    g(gt, eh, e), le.init(e, a), g(gt, or, n), g(gt, ih, s), g(gt, Pu, o), n.setDoRecProc(gt.chgDoRec), i.autowc = (c) => {
      var d;
      return x(d = gt, Zd, gx).call(d, c);
    }, i.autowc({ enabled: !1, text: "", time: 0 }), i.ch_in_style = (c) => {
      var d;
      return x(d = gt, Ou, mm).call(d, c);
    }, i.ch_out_style = (c) => {
      var d;
      return x(d = gt, Iu, _m).call(d, c);
    }, le.initChStyle(), mE(), ba(
      e.matchPath(".+", Xe.FONT).flatMap((c) => Object.values(c).map((d) => `
@font-face {
	font-family: '${d}';
	src: url('${h(this, eh).searchPath(d, Xe.FONT)}');
}
`)).join("") + `
.sn_tx {
	pointer-events: none;
	user-select: none;
	-webkit-touch-callout: none;
	box-sizing: border-box;
}
.sn_ch {
	position: relative;
	display: inline-block;
}
`
      // 「sn_ch」と「sn_ch_in_〜」の中身が重複しているが、これは必須
    ), x(l = gt, Ou, mm).call(l, {
      name: "default",
      wait: 500,
      alpha: 0,
      x: "=0.3",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: !0,
      ease: "ease-out"
    }), x(u = gt, Iu, _m).call(u, {
      name: "default",
      wait: 0,
      alpha: 0,
      x: "=0",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: !1,
      ease: "ease-out"
    });
  }
  static setEvtMng(e, i, n) {
    g(gt, Cu, e), g(gt, no, i), g(gt, Mu, n), le.setEvtMng(i);
  }
  destroy() {
    h(this, Wt) && (this.spLay.removeChild(h(this, Wt)).destroy(), g(this, Wt, void 0)), this.clearText(), h(this, kt).destroy();
  }
  static destroy() {
    g(gt, bn, !1), g(gt, so, {}), g(gt, oh, (e) => e);
  }
  set name(e) {
    this.name_ = e, h(this, kt).name = e;
  }
  get name() {
    return this.name_;
  }
  // getは継承しないらしい
  cvsResize() {
    h(this, kt).cvsResize();
  }
  cvsResizeChildren() {
    for (const e of h(this, si).children)
      e.cvsResize();
  }
  procSetX(e) {
    h(this, kt).lay({ x: e });
  }
  procSetY(e) {
    h(this, kt).lay({ y: e });
  }
  lay(e) {
    if (super.lay(e), qe.setXY(this.spLay, e, this.spLay), e[":id_tag"] = this.name_.slice(0, -7), ys.setting(e), x(this, Nu, bm).call(this, e), h(this, kt).lay(e), "r_align" in e && g(this, oi, e.r_align ?? ""), g(this, is, L.isSafari ? h(this, kt).tategaki ? (i, n) => `text-align: start; height: ${n}em; padding-top: ${i}; padding-bottom: ${i};` : (i, n) => `text-align: start; width: ${n}em; padding-left: ${i}; padding-right: ${i};` : h(this, kt).tategaki ? (i) => `text-align: justify; text-align-last: justify; padding-top: ${i}; padding-bottom: ${i};` : (i) => `text-align: justify; text-align-last: justify; padding-left: ${i}; padding-right: ${i};`), L.isFirefox && (this.mkStyle_r_align = x(this, Jd, bx)), "r_style" in e)
      if (e.r_style) {
        const i = document.createElement("span");
        i.style.cssText = e.r_style;
        const n = i.style.length, s = h(this, Dr).style;
        for (let o = 0; o < n; ++o) {
          const a = i.style[o];
          if (a in h(gt, Kd)) {
            wt.myTrace(`${a}は指定できません`, "W");
            continue;
          }
          s[a] = i.style[a];
        }
      } else
        h(this, Dr).style.cssText = "";
    if ("alpha" in e)
      for (const i of h(this, si).children)
        i.alpha = this.spLay.alpha;
    return x(this, oo, nl).call(this, e), x(this, ho, sl).call(this, e), x(this, ku, gm).call(this, e, (i) => {
      i && h(gt, Cu).resume();
    });
  }
  get width() {
    return h(this, kt).getWidth;
  }
  get height() {
    return h(this, kt).getHeight;
  }
  chgBackAlpha(e) {
    const i = h(this, ar) ? h(this, Bi) : e * h(this, Bi);
    h(this, Wt) instanceof Ci && (h(this, Wt) && (this.spLay.removeChild(h(this, Wt)), h(this, Wt).destroy()), this.spLay.addChildAt(
      g(this, Wt, new Ci()).beginFill(h(this, xn)).lineStyle(void 0).drawRect(0, 0, h(this, kt).getWidth, h(this, kt).getHeight).endFill(),
      0
    ), h(this, Wt).name = "back(color)"), h(this, Wt) && (h(this, Wt).visible = i > 0, h(this, Wt).alpha = i);
  }
  // Safariが全体に「font-feature-settings」した後、特定文字の「font-feature-settings: initial;」を受け付けてくれないのでわざわざ一つずつ指定
  static chgDoRec(e) {
    g(gt, oh, e ? (i) => i : (i) => `<span class='offrec'>${i}</span>`);
  }
  mkStyle_r_align(e, i, n, s = "") {
    if (!n)
      return ` style='${s}'`;
    const o = e.length * 2;
    if (o - i.length < 0)
      return ` style='text-align: ${n}; ${s}'`;
    let a = "";
    switch (n) {
      case "justify":
        a = h(this, is).call(this, "0", o);
        break;
      case "121":
        a = h(this, is).call(this, `calc(${(o - i.length) / (i.length * 2)}em)`, o);
        break;
      case "even":
        a = h(this, is).call(this, `calc(${(o - i.length) / (i.length + 1)}em)`, o);
        break;
      case "1ruby":
        a = h(this, is).call(this, "1em", o);
        break;
      default:
        a = `text-align: ${n};`;
    }
    return ` style='${a} ${s}'`;
  }
  tagCh(e) {
    h(this, Ru).putTxt(e);
  }
  clearText() {
    this.spLay.addChild(g(this, kt, h(this, kt).reNew())), g(this, Fr, 0), g(this, hr, !0), g(this, Ui, []), g(this, co, ""), g(this, fo, ""), h(gt, ih).recPagebreak();
  }
  get pageText() {
    return h(this, co).replace("《　》", "");
  }
  get pagePlainText() {
    return h(this, fo);
  }
  get enabled() {
    return this.spLay.interactiveChildren;
  }
  set enabled(e) {
    this.spLay.interactiveChildren = e;
  }
  canFocus() {
    var e;
    return (this.spLay.interactiveChildren ?? !1) && this.spLay.visible && h(e = gt, Pu).call(e, this);
  }
  clearLay(e) {
    super.clearLay(e), this.clearText();
    for (const i of h(this, si).removeChildren())
      i.destroy();
  }
  playback(e, i) {
    super.playback(e, i), this.enabled = e.enabled, h(this, Dr).style.cssText = e.r_cssText, g(this, oi, e.r_align), this.cvsResize(), x(this, Nu, bm).call(this, e), h(this, kt).playback(e.txs), g(this, Bi, e.b_alpha), g(this, ar, e.b_alpha_isfixed), i.push(new Promise((s) => {
      const o = e.b_do ? e.b_do === "Sprite" ? { b_pic: e.b_pic } : { b_color: e.b_color } : { b_pic: "" };
      o.b_alpha = e.b_alpha, o.b_alpha_isfixed = e.b_alpha_isfixed, x(this, ku, gm).call(this, o, (a) => {
        a && s();
      }) || s();
    }));
    const n = e.btns;
    i = i.concat(n.map((s) => this.addButton(JSON.parse(s.replaceAll("'", '"')))));
  }
  snapshot(e, i) {
    e.render(this.spLay, { clear: !1 }), h(this, kt).snapshot(e, i);
  }
  snapshot_end() {
    h(this, kt).snapshot_end();
  }
  makeDesignCast(e) {
    this.spLay.visible && h(this, kt).makeDesignCast(e);
  }
  makeDesignCastChildren(e) {
    if (this.spLay.visible)
      for (const i of h(this, si).children)
        i.makeDesignCast(e);
  }
  showDesignCast() {
    h(this, kt).showDesignCast();
  }
  showDesignCastChildren() {
    for (const e of h(this, si).children)
      e.showDesignCast();
  }
  dump() {
    return h(this, Lu).call(this, "", "gotxt｜"), super.dump() + `, "enabled":"${this.enabled}", ${h(this, kt).dump()}, "b_pic":"${h(this, Lr)}", "b_color":"${h(this, xn)}", "b_alpha":${h(this, Bi)}, "b_alpha_isfixed":"${h(this, ar)}", "width":${h(this, kt).getWidth}, "height":${h(this, kt).getHeight}, "pixi_obj":[${this.spLay.children.map((e) => `{"class":"${e instanceof ge ? "Sprite" : e instanceof Ci ? "Graphics" : e instanceof Qt ? "Container" : "?"}", "name":"${e.name}", "alpha":${e.alpha}, "x":${e.x}, "y":${e.y}, "visible":"${e.visible}"}`).join(",")}], "button":[${h(this, si).children.map((e) => e.children[0].name ?? "{}").join(",")}]`;
  }
};
let ne = gt;
eh = new WeakMap(), or = new WeakMap(), Pu = new WeakMap(), ih = new WeakMap(), Ou = new WeakSet(), mm = function(e) {
  const i = le.ch_in_style(e), n = i.x.at(0) === "=" ? `${i.nx * 100}%` : `${i.nx}px`, s = i.y.at(0) === "=" ? `${i.ny * 100}%` : `${i.ny}px`, { name: o } = e;
  return ba(`
.sn_ch_in_${o} {
	position: relative;
	display: inline-block;
}
.go_ch_in_${o} {
	opacity: ${i.alpha};
	position: relative;
	display: inline-block;
	animation: sn_ch_in_${o} ${i.wait}ms ${i.ease} 0s both;
}
@keyframes sn_ch_in_${o} {
	from {transform: rotate(${i.rotate}deg) scale(${i.scale_x}, ${i.scale_y}) translate(${n}, ${s});}
	to {opacity: 1; transform: none;}
}
`), !1;
}, Iu = new WeakSet(), _m = function(e) {
  const i = le.ch_out_style(e), n = i.x.at(0) === "=" ? `${i.nx * 100}%` : `${i.nx}px`, s = i.y.at(0) === "=" ? `${i.ny * 100}%` : `${i.ny}px`, { name: o } = e;
  return ba(`
.go_ch_out_${o} {
	position: relative;
	display: inline-block;
	animation: go_ch_out_${o} ${i.wait}ms ${i.ease} 0s both;
}
@keyframes go_ch_out_${o} {
	to {
		opacity: ${i.alpha};
		transform: rotate(${i.rotate}deg) scale(${i.scale_x}, ${i.scale_y}) translate(${n}, ${s});
	}
`), !1;
}, Cu = new WeakMap(), no = new WeakMap(), Mu = new WeakMap(), bn = new WeakMap(), so = new WeakMap(), Zd = new WeakSet(), gx = function(e) {
  g(gt, bn, K(e, "enabled", h(gt, bn))), h(gt, or).setVal_Nochk("save", "const.sn.autowc.enabled", h(gt, bn));
  const { text: i } = e;
  if ("text" in e != "time" in e)
    throw "[autowc] textとtimeは同時指定必須です";
  if (h(gt, or).setVal_Nochk("save", "const.sn.autowc.text", i), !i)
    return h(gt, or).setVal_Nochk("save", "const.sn.autowc.time", ""), !1;
  const n = i.length;
  if (h(gt, bn) && n === 0)
    throw '[autowc] enabled === false かつ text === "" は許されません';
  const s = String(e.time).split(",");
  if (s.length !== n)
    throw "[autowc] text文字数とtimeに記述された待ち時間（コンマ区切り）は同数にして下さい";
  return g(gt, so, {}), s.forEach((o, a) => h(gt, so)[i[a]] = mr(o)), h(gt, or).setVal_Nochk("save", "const.sn.autowc.time", e.time), !1;
}, xn = new WeakMap(), Bi = new WeakMap(), ar = new WeakMap(), Wt = new WeakMap(), Lr = new WeakMap(), kt = new WeakMap(), Ru = new WeakMap(), Dr = new WeakMap(), Kd = new WeakMap(), si = new WeakMap(), oo = new WeakSet(), nl = function(e) {
  const { in_style: i } = e;
  if (!i)
    return;
  const n = le.getChInStyle(i);
  if (!n)
    throw `存在しないin_style【${i}】です`;
  g(this, ao, i), g(this, rh, n.join);
}, ao = new WeakMap(), rh = new WeakMap(), ho = new WeakSet(), sl = function(e) {
  const { out_style: i } = e;
  if (!i)
    return;
  if (!le.getChOutStyle(i))
    throw `存在しないout_style【${i}】です`;
  g(this, nh, i);
}, nh = new WeakMap(), ku = new WeakSet(), gm = function(e, i) {
  if ("back_clear" in e)
    return K(e, "back_clear", !1) && (g(this, xn, 0), g(this, Bi, 0), g(this, ar, !1), g(this, Lr, "")), i(!1), !1;
  g(this, Bi, j(e, "b_alpha", h(this, Bi))), g(this, ar, K(e, "b_alpha_isfixed", h(this, ar)));
  const n = (h(this, ar) ? 1 : Number(h(gt, or).getVal("sys:TextLayer.Back.Alpha"))) * h(this, Bi);
  if (e.b_pic) {
    if (h(this, Lr) !== e.b_pic)
      return g(this, Lr, e.b_pic), h(this, Wt) && (this.spLay.removeChild(h(this, Wt)), h(this, Wt).destroy()), Pt.csv2Sprites(h(this, Lr), this.spLay, (s) => {
        g(this, Wt, s), s.name = "back(pic)", s.visible = n > 0, s.alpha = n, h(this, kt).setSize(s.width, s.height), this.spLay.setChildIndex(s, 0), i(!0);
      });
  } else
    "b_color" in e && (g(this, xn, I0(e, "b_color", 0)), h(this, Wt) && (this.spLay.removeChild(h(this, Wt)), h(this, Wt).destroy()), g(this, Lr, ""), this.spLay.addChildAt(
      g(this, Wt, new Ci()).beginFill(h(this, xn)).lineStyle(void 0).drawRect(0, 0, h(this, kt).getWidth, h(this, kt).getHeight).endFill(),
      0
    ), h(this, Wt).name = "back(color)");
  return h(this, Wt) && (h(this, Wt).visible = n > 0, h(this, Wt).alpha = n), i(!1), !1;
}, Nu = new WeakSet(), bm = function(e) {
  "noffs" in e && (g(this, sh, e.noffs ?? ""), g(this, Au, new RegExp(`[　${h(this, sh)}]`))), "ffs" in e && (h(this, lo) ?? g(this, lo, ""), g(this, uo, h(this, lo) === "" ? () => "" : (i) => h(this, Au).test(i) ? "" : ` font-feature-settings: ${h(this, lo)};`));
}, lo = new WeakMap(), uo = new WeakMap(), sh = new WeakMap(), Au = new WeakMap(), oh = new WeakMap(), is = new WeakMap(), oi = new WeakMap(), Jd = new WeakSet(), bx = function(e, i, n, s = "") {
  if (!n)
    return ` style='${s}'`;
  const o = e.length * 2;
  if (o - i.length < 0)
    return ` style='text-align: ${n}; ${s}'`;
  let a = "";
  switch (n) {
    case "left":
      a = "ruby-align: start;";
      break;
    case "center":
      a = "ruby-align: center;";
      break;
    case "right":
      a = "ruby-align: start;";
      break;
    case "justify":
      a = "ruby-align: space-between;";
      break;
    case "121":
      a = "ruby-align: space-around;";
      break;
    case "even":
      const l = (o - i.length) / (i.length + 1);
      a = "ruby-align: space-between; " + (h(this, kt).tategaki ? `padding-top: ${l}em; padding-bottom: ${l}em;` : `padding-left: ${l}em; padding-right: ${l}em;`);
      break;
    case "1ruby":
      a = "ruby-align: space-between; " + (h(this, kt).tategaki ? "padding-top: 1em; padding-bottom: 1em;" : "padding-left: 1em; padding-right: 1em;");
      break;
    default:
      a = `text-align: ${n};`;
  }
  return ` style='${a} ${s}'`;
}, xi = new WeakMap(), Lu = new WeakMap(), ah = new WeakSet(), Mf = function(e, i, n) {
  var u;
  const s = e === " " ? "&nbsp;" : e;
  h(gt, or).doRecLog() && (g(this, co, h(this, co) + (s + (i ? `《${i}》` : ""))), e !== " " && g(this, fo, h(this, fo) + e));
  const { cl: o, sty: a, lnk: l } = x(this, wn, Rs).call(this, !0, null, e);
  return i ? `<span${o} style='${a} ${h(this, uo).call(this, e)}'><ruby>${// 文字個別に出現させるため以下にも ${cl} が必要
  Array.from(e).map((c, d) => `<span${o}${l} style='${d > 0 ? x(this, wn, Rs).call(this, !0, null, e).sty : a} display: inline;'>${c === " " ? "&nbsp;" : c}</span>`).join("")}<rt${l}${this.mkStyle_r_align(
    e,
    i,
    n,
    h(this, Dr).style.cssText + (((u = h(this, Gi).at(-1)) == null ? void 0 : u.o.r_style) ?? "")
  )}>${i}</rt></ruby></span>` : `<span${o} style='${a} ${h(this, uo).call(this, e)}'${l}>${s}</span>`;
}, wn = new WeakSet(), Rs = function(e, i, n = `
`) {
  var a, l, u;
  const s = h(this, rh) ? i ?? ((a = h(this, Gi).at(0)) == null ? void 0 : a.o.wait) ?? (h(gt, bn) ? h(gt, so)[n.at(0) ?? ""] ?? 0 : Ds.msecChWait) : 0;
  h(gt, no).isSkippingByKeyDown() ? g(this, Fr, 0) : e && h(this, rh) && g(this, Fr, h(this, Fr) + Number(s));
  const o = `data-add='{"ch_in_style":"${h(this, ao)}", "ch_out_style":"${h(this, nh)}"}'`;
  return {
    cl: ` class='sn_ch${s > 0 ? ` sn_ch_in_${h(this, ao)}` : ""}'`,
    // TxtStage.goTxt()はこれ単位で文字出現させる
    sty: `animation-delay: ${h(this, Fr)}ms;${((l = h(this, Gi).at(-1)) == null ? void 0 : l.o.style) ?? ""}`,
    // TxtStage.goTxt()はこれ単位で文字出現させる
    lnk: (((u = h(this, Gi).at(0)) == null ? void 0 : u.o[":link"]) ?? "") + " " + o,
    curpos: o
  };
}, Fr = new WeakMap(), hr = new WeakMap(), Ui = new WeakMap(), Gi = new WeakMap(), Du = new WeakSet(), xm = function(e) {
  h(this, Gi).push({
    o: e,
    r_align: h(this, oi),
    ch_in_style: h(this, ao),
    ch_out_style: h(this, nh)
  }), "r_align" in e && g(this, oi, e.r_align), x(this, oo, nl).call(this, e), x(this, ho, sl).call(this, e);
}, hh = new WeakSet(), Rf = function() {
  const e = h(this, Gi).pop();
  e && (g(this, oi, e.r_align), x(this, oo, nl).call(this, { in_style: e.ch_in_style }), x(this, ho, sl).call(this, { out_style: e.ch_out_style }));
}, Fu = new WeakSet(), wm = function(e) {
  const i = h(this, Gi).at(-1);
  if (!i) {
    x(this, Du, xm).call(this, e);
    return;
  }
  i.o = { ...i.o, ...e }, !e.style && !e.r_style && (i.o.style = "", i.o.r_style = ""), "r_align" in e && g(this, oi, e.r_align), x(this, oo, nl).call(this, e), x(this, ho, sl).call(this, e);
}, co = new WeakMap(), fo = new WeakMap(), // 文字出現演出
_(ne, Ou), // 文字消去演出
_(ne, Iu), _(ne, Zd), _(ne, eh, void 0), _(ne, or, void 0), _(ne, Pu, void 0), _(ne, ih, void 0), _(ne, Cu, void 0), _(ne, no, void 0), _(ne, Mu, void 0), // 文字ごとのウェイト
_(ne, bn, !1), _(ne, so, {}), // cssチェック・保存用
_(ne, Kd, {
  "text-align": 0,
  "text-align-last": 0,
  height: 0,
  width: 0,
  "padding-left": 0,
  "padding-right": 0,
  "padding-top": 0,
  "padding-bottom": 0
}), _(ne, oh, (e) => e);
var lh, po, Qd, xx, uh, ch, kf, tp, wx, ep, Ex, Bu, ip, Tx, rp, Sx;
class QC {
  constructor(t, e, i, n, s, o, a) {
    //	HTMLフレーム
    // フレーム追加
    _(this, Qd);
    _(this, ch);
    // フレーム変数を取得
    _(this, tp);
    // フレーム変数に設定
    _(this, ep);
    _(this, ip);
    // フレームをトゥイーン開始
    _(this, rp);
    _(this, lh, void 0);
    _(this, po, /* @__PURE__ */ Object.create(null));
    _(this, uh, {});
    // フレームに設定
    _(this, Bu, 1);
    this.cfg = t, this.appPixi = i, this.val = n, this.main = s, this.sys = o, this.hTwInf = a, e.add_frame = (l) => x(this, Qd, xx).call(this, l), e.let_frame = (l) => x(this, tp, wx).call(this, l), e.set_frame = (l) => x(this, ep, Ex).call(this, l), e.frame = (l) => x(this, ip, Tx).call(this, l), e.tsy_frame = (l) => x(this, rp, Sx).call(this, l);
  }
  setEvtMng(t) {
    g(this, lh, t);
  }
  destroy() {
    for (const t of Object.values(h(this, po)))
      t.parentElement.removeChild(t);
    g(this, po, /* @__PURE__ */ Object.create(null));
  }
  getFrmDisabled(t) {
    return h(this, uh)[t];
  }
  cvsResize() {
    for (const [t, e] of Object.entries(h(this, po))) {
      const i = "const.sn.frm." + t, n = Number(this.val.getVal(i + ".x")), s = Number(this.val.getVal(i + ".y")), o = Number(this.val.getVal(i + ".width")), a = Number(this.val.getVal(i + ".height"));
      e.style.left = `${this.sys.ofsLeft4elm + n * this.sys.cvsScale}px`, e.style.top = `${this.sys.ofsTop4elm + s * this.sys.cvsScale}px`, e.width = String(o * this.sys.cvsScale), e.height = String(a * this.sys.cvsScale);
    }
  }
}
lh = new WeakMap(), po = new WeakMap(), Qd = new WeakSet(), xx = function(t) {
  const { id: e, src: i, alpha: n = 1, scale_x: s = 1, scale_y: o = 1, rotate: a = 0 } = t;
  if (!e)
    throw "idは必須です";
  if (!i)
    throw "srcは必須です";
  const l = "const.sn.frm." + e;
  if (this.val.getVal(`tmp:${l}`))
    throw `frame【${e}】はすでにあります`;
  const u = K(t, "visible", !0), c = t.b_color ? ` background-color: ${t.b_color};` : "", d = x(this, ch, kf).call(this, t);
  ui.cvs.insertAdjacentHTML("beforebegin", `<iframe id="${e}" sandbox="allow-scripts allow-same-origin" style="opacity: ${n}; position: absolute; left:${this.sys.ofsLeft4elm + d.x * this.sys.cvsScale}px; top: ${this.sys.ofsTop4elm + d.y * this.sys.cvsScale}px; z-index: 1; ${c} border: 0px; overflow: hidden; display: ${u ? "inline" : "none"}; transform: scale(${s}, ${o}) rotate(${a}deg);" width="${d.width * this.sys.cvsScale}" height="${d.height * this.sys.cvsScale}"></iframe>`);
  const f = this.cfg.searchPath(i, Xe.HTML), v = new Oi().add({ name: i, url: f, xhrType: bt.XHR_RESPONSE_TYPE.TEXT });
  return this.sys.crypto && v.use((m, p) => {
    try {
      m.data = this.sys.decStr(m.extension, m.data);
    } catch (y) {
      this.main.errScript(`[add_frame]Html ロード失敗です src:${m.name} ${y}`, !1);
    }
    p == null || p();
  }), v.load((m, p) => {
    var b;
    const y = document.getElementById(e);
    h(this, po)[e] = y, h(this, uh)[e] = !1, y.srcdoc = String((b = p[i]) == null ? void 0 : b.data).replace("sn_repRes();", "").replaceAll(
      /\s(?:src|href)=(["'])(\S+)\1/g,
      (w, E, O) => O.slice(0, 3) === "../" ? this.sys.cur + O.slice(4) : w.replace(E, E + f.slice(0, f.lastIndexOf("/") + 1))
    ), y.onload = () => {
      var E;
      this.val.setVal_Nochk("tmp", l, !0), this.val.setVal_Nochk("tmp", l + ".alpha", n), this.val.setVal_Nochk("tmp", l + ".x", d.x), this.val.setVal_Nochk("tmp", l + ".y", d.y), this.val.setVal_Nochk("tmp", l + ".scale_x", s), this.val.setVal_Nochk("tmp", l + ".scale_y", o), this.val.setVal_Nochk("tmp", l + ".rotate", a), this.val.setVal_Nochk("tmp", l + ".width", d.width), this.val.setVal_Nochk("tmp", l + ".height", d.height), this.val.setVal_Nochk("tmp", l + ".visible", u);
      const w = y.contentWindow;
      h(this, lh).resvFlameEvent(w), (E = w.sn_repRes) == null || E.call(w, (O) => Pt.loadPic2Img(O.dataset.src ?? "", O)), this.main.resume();
    };
  }), !0;
}, uh = new WeakMap(), ch = new WeakSet(), kf = function(t) {
  const e = { ...t }, i = this.sys.resolution;
  return new DOMRect(
    j(e, "x", 0) * i,
    j(e, "y", 0) * i,
    j(e, "width", L.stageW) * i,
    j(e, "height", L.stageH) * i
  );
}, tp = new WeakSet(), wx = function(t) {
  const { id: e, var_name: i } = t;
  if (!e)
    throw "idは必須です";
  const n = document.getElementById(e);
  if (!n)
    throw `id【${e}】はフレームではありません`;
  const s = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${s}`))
    throw `frame【${e}】が読み込まれていません`;
  if (!i)
    throw "var_nameは必須です";
  const o = n.contentWindow;
  if (!o.hasOwnProperty(i))
    throw `frame【${e}】に変数/関数【${i}】がありません。変数は var付きにして下さい`;
  const a = o[i];
  return this.val.setVal_Nochk(
    "tmp",
    s + "." + i,
    K(t, "function", !1) ? a() : a
  ), !1;
}, ep = new WeakSet(), Ex = function(t) {
  const { id: e, var_name: i, text: n } = t;
  if (!e)
    throw "idは必須です";
  const s = document.getElementById(e);
  if (!s)
    throw `id【${e}】はフレームではありません`;
  const o = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${o}`))
    throw `frame【${e}】が読み込まれていません`;
  if (!i)
    throw "var_nameは必須です";
  if (!n)
    throw "textは必須です";
  this.val.setVal_Nochk("tmp", o + "." + i, n);
  const a = s.contentWindow;
  return a[i] = n, !1;
}, Bu = new WeakMap(), ip = new WeakSet(), Tx = function(t) {
  const { id: e } = t;
  if (!e)
    throw "idは必須です";
  const i = document.getElementById(e);
  if (!i)
    throw `id【${e}】はフレームではありません`;
  const n = "const.sn.frm." + e;
  if (!this.val.getVal("tmp:" + n))
    throw `frame【${e}】が読み込まれていません`;
  const s = i.style;
  if (K(t, "float", !1) ? s.zIndex = `${++Te(this, Bu)._}` : "index" in t ? s.zIndex = `${j(t, "index", 0)}` : t.dive && (s.zIndex = `-${++Te(this, Bu)._}`), "alpha" in t) {
    const a = s.opacity = String(t.alpha);
    this.val.setVal_Nochk("tmp", n + ".alpha", a);
  }
  const o = x(this, ch, kf).call(this, t);
  if (("x" in t || "y" in t) && (s.left = `${this.sys.ofsLeft4elm + o.x * this.sys.cvsScale}px`, s.top = `${this.sys.ofsTop4elm + o.y * this.sys.cvsScale}px`, this.val.setVal_Nochk("tmp", n + ".x", o.x), this.val.setVal_Nochk("tmp", n + ".y", o.y)), "scale_x" in t || "scale_y" in t || "rotate" in t) {
    const a = j(t, "scale_x", 1), l = j(t, "scale_y", 1), u = j(t, "rotate", 0);
    s.transform = `scale(${a}, ${l}) rotate(${u}deg)`, this.val.setVal_Nochk("tmp", n + ".scale_x", a), this.val.setVal_Nochk("tmp", n + ".scale_y", l), this.val.setVal_Nochk("tmp", n + ".rotate", u);
  }
  if ("width" in t && (i.width = String(o.width * this.sys.cvsScale), this.val.setVal_Nochk("tmp", n + ".width", o.width)), "height" in t && (i.height = String(o.height * this.sys.cvsScale), this.val.setVal_Nochk("tmp", n + ".height", o.height)), "visible" in t) {
    const a = K(t, "visible", !0);
    s.display = a ? "inline" : "none", this.val.setVal_Nochk("tmp", n + ".visible", a);
  }
  if ("b_color" in t && (s.backgroundColor = t.b_color), "disabled" in t) {
    const a = h(this, uh)[e] = K(t, "disabled", !0);
    i.contentDocument.body.querySelectorAll("input,select").forEach((u) => u.disabled = a);
  }
  return !1;
}, rp = new WeakSet(), Sx = function(t) {
  const { id: e, alpha: i, x: n, y: s, scale_x: o, scale_y: a, rotate: l, width: u, height: c, ease: d, path: f, chain: v } = t;
  if (!e)
    throw "idは必須です";
  const m = document.getElementById(e);
  if (!m)
    throw `id【${e}】はフレームではありません`;
  const p = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${p}`, 0))
    throw `frame【${e}】が読み込まれていません`;
  const y = {};
  i && (y.a = m.style.opacity), (n || s || o || a || l) && (y.x = Number(this.val.getVal(`tmp:${p}.x`)), y.y = Number(this.val.getVal(`tmp:${p}.y`)), y.sx = Number(this.val.getVal(`tmp:${p}.scale_x`)), y.sy = Number(this.val.getVal(`tmp:${p}.scale_y`)), y.r = Number(this.val.getVal(`tmp:${p}.rotate`))), u && (y.w = this.val.getVal(`tmp:${p}.width`)), c && (y.h = this.val.getVal(`tmp:${p}.height`));
  const b = zf(t, y), w = {};
  let E = () => {
  };
  i && (w.a = j(b, "alpha", 0), E = () => {
    m.style.opacity = y.a, this.val.setVal_Nochk("tmp", "alpha", y.a);
  });
  let O = () => {
  };
  const I = x(this, ch, kf).call(this, b);
  (n || s || o || a || l) && (w.x = I.x, w.y = I.y, w.sx = j(b, "scale_x", 1), w.sy = j(b, "scale_y", 1), w.r = j(b, "rotate", 0), O = () => {
    m.style.left = this.sys.ofsLeft4elm + y.x * this.sys.cvsScale + "px", m.style.top = this.sys.ofsTop4elm + y.y * this.sys.cvsScale + "px", m.style.transform = `scale(${y.sx}, ${y.sy}) rotate(${y.r}deg)`, this.val.setVal_Nochk("tmp", p + ".x", y.x), this.val.setVal_Nochk("tmp", p + ".y", y.y), this.val.setVal_Nochk("tmp", p + ".scale_x", y.sx), this.val.setVal_Nochk("tmp", p + ".scale_y", y.sy), this.val.setVal_Nochk("tmp", p + ".rotate", y.r);
  });
  let S = () => {
  };
  u && (w.w = I.width, S = () => {
    m.width = y.w * this.sys.cvsScale + "px", this.val.setVal_Nochk("tmp", p + ".width", y.w);
  });
  let C = () => {
  };
  c && (w.h = I.height, C = () => {
    m.height = y.h * this.sys.cvsScale + "px", this.val.setVal_Nochk("tmp", p + ".height", y.h);
  }), this.appPixi.stage.interactive = !1;
  const P = `frm
${e}`, R = () => {
    var et, Tt;
    this.appPixi.stage.interactive = !0;
    const mt = this.hTwInf[P];
    mt && (delete this.hTwInf[P], (et = mt.tw) == null || et.stop(), mt.resume && this.main.resume(), (Tt = mt.onEnd) == null || Tt.call(mt));
  }, N = j(t, "time", NaN) * (this.val.getVal("tmp:sn.skip.enabled") || h(this, lh).isSkippingByKeyDown() ? 0 : 1), F = Fn.ease(d), $ = j(t, "repeat", 1), q = $ === 0 ? 1 / 0 : $ - 1, ht = K(t, "yoyo", !1), V = j(t, "delay", 0), H = new zr(y).to(w, N).easing(F).repeat(q).yoyo(ht).delay(V).onUpdate(() => {
    E(), O(), S(), C();
  });
  let Q = H;
  if (f) {
    L.debugLog && console.group(`🍝 [tsy_frame] path=${f}= start(${y.x},${y.y},${y.alpha})`);
    for (const { groups: mt } of f.matchAll(Ds.REG_TSY_PATH)) {
      const { x: et, x2: Tt, y: it, y2: we, o: Bt, o2: Dt, json: Ut } = mt;
      let k = {};
      if (Ut)
        try {
          k = JSON.parse(Ut);
        } catch (me) {
          console.error(`🍝 json=${Ut} ` + me);
          continue;
        }
      else
        (et ?? Tt) && (k.x = et ?? Tt), (it ?? we) && (k.y = it ?? we), (Bt ?? Dt) && (k.alpha = Bt ?? Dt);
      const zt = zf(k, y);
      L.debugLog && console.info(`🍝 {x:${et} y:${it} o:${Bt}} => hTo:${JSON.stringify(zt)}`);
      const lt = new zr(y).to(zt, N).easing(F).repeat(q).yoyo(ht);
      Q.chain(lt), Q = lt;
    }
    L.debugLog && console.groupEnd();
  }
  if (Q.onComplete(R), v) {
    const mt = this.hTwInf[v ?? ""];
    if (!mt || !mt.tw)
      throw `${v}は存在しない・または終了したトゥイーンです`;
    delete mt.onEnd, mt.tw.chain(H);
  } else
    H.start();
  return this.hTwInf[P] = { tw: Q, resume: !1 }, !1;
};
var ji, At, re, rs, vo, fh, Uu, Gu, ju, dh, Hu, Em, ns, lr, np, Px, ai, sp, Ox, op, Ix, ap, Cx, Ot, Br, Ur, $u, hp, Mx, ph, Nf, lp, Rx, up, zu, cp, yo, mo, En, Pe, _o, fp, kx, Oe, ti, mi, dp, Nx, pp, Ax, vp, Lx, go, ol, yp, Dx, wi, mp, Fx, _p, Bx, gp, Ux, bp, Gx, xp, jx, ss, bo, al, Ei, wp, Hx, Vu, Ep, $x, Gr, xo, os, ha, ur, jr, Tp, zx, Sp, Vx, Pp, Xx, Op, Wx, Ip, Yx, Cp, qx, Mp, Zx, Xu, Tm, Rp, Kx, kp, Jx, Np, Qx, Ap, tw, Lp, ew, Dp, iw, Fp, rw;
const Xn = class {
  constructor(t, e, i, n, s, o, a, l, u, c) {
    _(this, Hu);
    // 既存の全文字レイヤの実際のバック不透明度、を再計算
    _(this, np);
    //	//	システム
    // スナップショット
    _(this, sp);
    // プラグインの読み込み
    _(this, op);
    //	//	レイヤ共通
    // レイヤを追加する
    _(this, ap);
    _(this, hp);
    _(this, ph);
    // レイヤ設定の消去
    _(this, lp);
    // ページ裏表を交換
    _(this, fp);
    _(this, ti);
    _(this, dp);
    _(this, pp);
    // トランス終了待ち
    _(this, vp);
    // レイヤのトランジションの停止
    _(this, go);
    // 画面を揺らす
    _(this, yp);
    _(this, mp);
    // トゥイーン終了待ち
    _(this, _p);
    // トゥイーン中断
    _(this, gp);
    // 一時停止
    _(this, bp);
    // 一時停止再開
    _(this, xp);
    // 文字を追加する
    _(this, bo);
    _(this, wp);
    _(this, Ep);
    _(this, os);
    _(this, Tp);
    // ハイパーリンクの終了
    _(this, Sp);
    // ページ両面の文字消去
    _(this, Pp);
    // インライン画像表示
    _(this, Op);
    // ハイパーリンク
    _(this, Ip);
    // 改行
    _(this, Cp);
    // 履歴改行
    _(this, Mp);
    // 履歴書き込み
    _(this, Xu);
    // 履歴リセット
    _(this, Rp);
    // 文字列と複数ルビの追加
    _(this, kp);
    // インラインスタイル設定
    _(this, Np);
    // tcy縦中横を表示する
    _(this, Ap);
    // レイヤのダンプ
    _(this, Lp);
    // イベント有無の切替
    _(this, Dp);
    // ボタンを表示
    _(this, Fp);
    _(this, ji, void 0);
    _(this, At, new Qt());
    _(this, re, new Qt());
    _(this, rs, void 0);
    _(this, vo, void 0);
    _(this, fh, new Dh());
    _(this, Uu, () => DC());
    _(this, Gu, {
      attach: (t) => (Nt.leaveMode(), !1),
      continue: (t) => (Nt.leaveMode(), !1),
      disconnect: (t) => (Nt.leaveMode(), !1),
      _enterDesign: (t) => {
        Nt.enterMode();
        for (const e of h(this, Br)) {
          const i = h(this, Ot)[e].fore;
          i.makeDesignCastChildren((n) => n.make()), i.makeDesignCast((n) => n.make());
        }
        return x(this, Hu, Em).call(this, h(this, Ur)), !1;
      },
      _replaceToken: (t, e) => (Nt.replaceToken(e), !1),
      _selectNode: (t, e) => (x(this, Hu, Em).call(this, e.node), !1)
    });
    _(this, ju, "");
    _(this, dh, "");
    D(this, "getFrmDisabled", (t) => h(this, rs).getFrmDisabled(t));
    _(this, ns, void 0);
    _(this, lr, void 0);
    _(this, ai, (t, e = this.currentTxtlayForeNeedErr, i = !0) => e.tagCh("｜　《" + t + "》"));
    D(this, "goTxt", () => {
    });
    D(this, "breakLine", () => {
    });
    D(this, "breakPage", () => {
    });
    _(this, Ot, {});
    // しおりLoad時再読込
    _(this, Br, []);
    // 最適化用
    _(this, Ur, "");
    _(this, $u, "");
    _(this, up, `
precision mediump float;

varying vec2 vTextureCoord;
uniform sampler2D uSampler;

uniform sampler2D rule;
uniform float vague;
uniform float tick;

uniform vec4 inputPixel;
uniform highp vec4 outputFrame;
vec2 getUV(vec2 coord) {
	return coord * inputPixel.xy / outputFrame.zw;
}

void main(void) {
	vec4 fg = texture2D(uSampler, vTextureCoord);
	vec4 ru = texture2D(rule, getUV(vTextureCoord));

	float v = ru.r - tick;
	if (abs(v) < vague) {
		float f_a = fg.a *(0.5 +v /vague *0.5);

		gl_FragColor.rgb = fg.rgb *f_a;
		gl_FragColor.a = f_a;
	}
	else {
		gl_FragColor = (v >= 0.0)? fg : vec4(0);
	}
}`);
    _(this, zu, {
      rule: ut.EMPTY,
      vague: 0,
      tick: 0
    });
    _(this, cp, new wr(void 0, h(this, up), h(this, zu)));
    _(this, yo, Wi.create({
      width: L.stageW,
      height: L.stageH
    }));
    _(this, mo, new ge(h(this, yo)));
    _(this, En, Wi.create({
      width: L.stageW,
      height: L.stageH
    }));
    _(this, Pe, new ge(h(this, En)));
    _(this, _o, []);
    _(this, Oe, { tw: void 0, resume: !1 });
    // トゥイーン開始
    _(this, wi, {});
    _(this, Ei, (t) => {
      throw h(this, xo).call(this), 0;
    });
    // 操作対象のメッセージレイヤの指定
    _(this, Vu, (t) => {
      throw h(this, xo).call(this), 0;
    });
    _(this, Gr, void 0);
    // カレントテキストレイヤ
    _(this, xo, () => {
      throw "文字レイヤーがありません。文字表示や操作する前に、[add_lay layer=（レイヤ名） class=txt]で文字レイヤを追加して下さい";
    });
    _(this, ur, "");
    _(this, jr, []);
    this.cfg = t, this.hTag = e, this.appPixi = i, this.val = n, this.main = s, this.scrItr = o, this.sys = a, this.sndMng = l, this.alzTagArg = u, this.prpPrs = c;
    const d = () => {
      if (a.cvsResize(), this.cvsResizeDesign(), h(this, dh))
        for (const p of h(this, Br))
          h(this, Ot)[p].fore.cvsResizeChildren();
      else
        for (const p of h(this, Br))
          h(this, Ot)[p].fore.cvsResize();
      h(this, rs).cvsResize(), h(this, lr).cvsResize();
    };
    if (L.isMobile)
      h(this, fh).add(globalThis, "orientationchange", d, { passive: !0 });
    else {
      let p;
      h(this, fh).add(globalThis, "resize", () => {
        p || (p = setTimeout(() => {
          p = void 0, d();
        }, 1e3 / 60 * 10));
      }, { passive: !0 });
    }
    a.cvsResize(), ne.init(t, e, n, this, (p) => h(this, Ot)[p.layname].fore === p, i), Pt.init(s, t, i, a, l, n), yr.init(t), g(this, rs, new QC(t, e, i, n, s, a, h(this, wi))), a.hFactoryCls.grp = () => new Pt(), a.hFactoryCls.txt = () => new ne(), e.loadplugin = (p) => x(this, op, Ix).call(this, p), e.snapshot = (p) => x(this, sp, Ox).call(this, p), e.add_lay = (p) => x(this, ap, Cx).call(this, p), e.clear_lay = (p) => x(this, lp, Rx).call(this, p), e.finish_trans = () => x(this, go, ol).call(this), e.lay = (p) => x(this, hp, Mx).call(this, p), e.trans = (p) => x(this, fp, kx).call(this, p), e.wt = (p) => x(this, vp, Lx).call(this, p), e.quake = (p) => x(this, yp, Dx).call(this, p), e.stop_quake = (p) => e.finish_trans(p), e.wq = (p) => e.wt(p), e.pause_tsy = (p) => x(this, bp, Gx).call(this, p), e.resume_tsy = (p) => x(this, xp, jx).call(this, p), e.stop_tsy = (p) => x(this, gp, Ux).call(this, p), e.tsy = (p) => x(this, mp, Fx).call(this, p), e.wait_tsy = (p) => x(this, _p, Bx).call(this, p), e.ch = (p) => x(this, bo, al).call(this, p), e.clear_text = (p) => x(this, Tp, zx).call(this, p), e.current = (p) => h(this, Vu).call(this, p), e.endlink = (p) => x(this, Sp, Vx).call(this, p), e.er = (p) => x(this, Pp, Xx).call(this, p), e.graph = (p) => x(this, Op, Wx).call(this, p), e.link = (p) => x(this, Ip, Yx).call(this, p), e.r = (p) => x(this, Cp, qx).call(this, p), e.rec_ch = (p) => x(this, Xu, Tm).call(this, p), e.rec_r = (p) => x(this, Mp, Zx).call(this, p), e.reset_rec = (p) => x(this, Rp, Kx).call(this, p), e.ruby2 = (p) => x(this, kp, Jx).call(this, p), e.span = (p) => x(this, Np, Qx).call(this, p), e.tcy = (p) => x(this, Ap, tw).call(this, p), e.add_face = (p) => Pt.add_face(p), e.wv = (p) => Pt.wv(p), e.dump_lay = (p) => x(this, Lp, ew).call(this, p), e.enable_event = (p) => x(this, Dp, iw).call(this, p), e.button = (p) => x(this, Fp, rw).call(this, p), t.existsBreakline && (this.breakLine = () => h(this, ai).call(this, 'grp｜{"id":"break","pic":"breakline"}')), t.existsBreakpage && (this.breakPage = () => h(this, ai).call(this, 'grp｜{"id":"break","pic":"breakpage"}')), g(this, vo, Ym(String(t.oCfg.init.bg_color)));
    const f = new Ci();
    f.beginFill(h(this, vo), 1).lineStyle(0, h(this, vo)).drawRect(0, 0, L.stageW, L.stageH).endFill(), h(this, At).addChild(f.clone()), h(this, re).addChild(f), h(this, re).visible = !1, h(this, At).name = "page:A", h(this, re).name = "page:B", g(this, ji, i.stage), h(this, ji).addChild(h(this, re)), h(this, ji).addChild(h(this, At)), h(this, ji).addChild(h(this, mo)), h(this, ji).addChild(h(this, Pe)), h(this, ji).name = "stage", i.ticker.add(h(this, Uu));
    const v = (p, y) => {
      x(this, np, Px).call(this, Number(y));
    };
    v("", n.getVal("sys:TextLayer.Back.Alpha", 1)), n.defValTrg("sys:TextLayer.Back.Alpha", v);
    const m = (p, y) => yr.fontFamily = y;
    m("", n.getVal("tmp:sn.button.fontFamily", yr.fontFamily)), n.defValTrg("tmp:sn.button.fontFamily", m), n.defTmp("const.sn.log.json", () => JSON.stringify(
      h(this, ur) ? [...h(this, jr), { text: h(this, ur).replaceAll("</span><span class='sn_ch'>", "") }] : h(this, jr)
    )), n.defTmp("const.sn.last_page_text", () => {
      var p;
      return ((p = this.currentTxtlayFore) == null ? void 0 : p.pageText) ?? "";
    }), n.defTmp("const.sn.last_page_plain_text", () => {
      var p;
      return ((p = this.currentTxtlayFore) == null ? void 0 : p.pagePlainText) ?? "";
    }), L.isDbg && (Nt.init(i, a, o, c, u, t, h(this, Ot)), this.cvsResizeDesign = () => Nt.cvsResizeDesign(), a.addHook((p, y) => {
      var b, w;
      (w = (b = h(this, Gu))[p]) != null && w.call(b, p, y) && delete h(this, Gu)[p];
    }));
  }
  cvsResizeDesign() {
  }
  cover(t, e = 0) {
    h(this, ns) && (h(this, ji).removeChild(h(this, ns)), h(this, ns).destroy(), g(this, ns, void 0)), t && h(this, ji).addChild(
      g(this, ns, new Ci()).beginFill(e).lineStyle(0, e).drawRect(0, 0, L.stageW, L.stageH).endFill()
    );
  }
  setEvtMng(t) {
    g(this, lr, t), h(this, rs).setEvtMng(t), Pt.setEvtMng(t);
  }
  before_destroy() {
    for (const t of Object.values(h(this, Ot)))
      t.destroy();
  }
  destroy() {
    h(this, fh).clear(), Pt.destroy(), ys.destroy(), le.destroy(), ne.destroy(), h(this, rs).destroy(), this.stopAllTw(), this.appPixi.ticker.remove(h(this, Uu)), g(Xn, ss, 10);
  }
  // トゥイーン全停止
  stopAllTw() {
    g(this, wi, {}), AC();
  }
  clearBreak() {
    this.currentTxtlayFore && (this.clearBreak = () => h(this, ai).call(this, "del｜break"), this.clearBreak());
  }
  clickTxtLay() {
    return this.currentTxtlayFore ? x(this, ti, mi).call(this).some((t) => {
      const e = h(this, Ot)[t].fore;
      return e instanceof ne && e.click();
    }) : !1;
  }
  static get msecChWait() {
    return h(Xn, ss);
  }
  static set msecChWait(t) {
    g(Xn, ss, t);
  }
  setNormalChWait() {
    g(Xn, ss, this.scrItr.normalWait);
  }
  get currentTxtlayForeNeedErr() {
    return h(this, xo).call(this), this.currentTxtlayFore;
  }
  get currentTxtlayFore() {
    return h(this, Gr) ? h(this, Gr).fore : null;
  }
  recText(t) {
    g(this, ur, t), this.val.setVal_Nochk(
      "save",
      "const.sn.sLog",
      String(this.val.getVal("const.sn.log.json"))
      // これを起動したい
    );
  }
  recPagebreak() {
    if (!h(this, ur))
      return;
    const t = h(this, ur).replaceAll("</span><span class='sn_ch'>", "");
    h(this, jr).push({ text: t }) > this.cfg.oCfg.log.max_len && g(this, jr, h(this, jr).slice(-this.cfg.oCfg.log.max_len)), g(this, ur, "");
  }
  record() {
    const t = {};
    for (const e of h(this, Br)) {
      const i = h(this, Ot)[e];
      t[e] = {
        cls: i.cls,
        fore: i.fore.record(),
        back: i.back.record()
      };
    }
    return t;
  }
  playback(t, e) {
    var o;
    g(this, jr, JSON.parse(String(this.val.getVal("save:const.sn.sLog")))), g(this, ur, "");
    const i = [], n = [];
    for (const [a, { fore: l, fore: { idx: u }, back: c, cls: d }] of Object.entries(t)) {
      n.push({ layer: a, idx: u });
      const f = (o = h(this, Ot))[a] ?? (o[a] = new ml(a, d, h(this, At), h(this, re), {}, this.sys, this.val, { isWait: !1 }));
      f.fore.playback(l, i), f.back.playback(c, i);
    }
    const s = h(this, At).children.length;
    Promise.allSettled(i).then(() => {
      for (const { layer: a, idx: l } of n.sort(({ idx: u }, { idx: c }) => u === c ? 0 : u < c ? -1 : 1)) {
        const { fore: u, back: c } = h(this, Ot)[a];
        if (!u)
          return;
        const d = s > l ? l : s - 1;
        h(this, At).setChildIndex(u.spLay, d), h(this, re).setChildIndex(c.spLay, d);
      }
      e();
    }).catch((a) => console.error("fn:LayerMng.ts playback e:%o", a));
  }
};
let Ds = Xn;
ji = new WeakMap(), At = new WeakMap(), re = new WeakMap(), rs = new WeakMap(), vo = new WeakMap(), fh = new WeakMap(), Uu = new WeakMap(), Gu = new WeakMap(), ju = new WeakMap(), dh = new WeakMap(), Hu = new WeakSet(), Em = function(t) {
  [Te(this, ju)._, this.dh = ""] = t.split("/");
  const e = h(this, Ot)[h(this, ju)];
  e && (Nt.allHide(), h(this, dh) ? e.fore.showDesignCastChildren() : e.fore.showDesignCast());
}, ns = new WeakMap(), lr = new WeakMap(), np = new WeakSet(), Px = function(t) {
  for (const e of x(this, ti, mi).call(this)) {
    const i = h(this, Ot)[e];
    i.fore instanceof ne && (i.fore.chgBackAlpha(t), i.back.chgBackAlpha(t));
  }
}, ai = new WeakMap(), sp = new WeakSet(), Ox = function(t) {
  const e = t.fn ? t.fn.slice(0, 10) === "userdata:/" ? t.fn : `downloads:/${t.fn + xl("-", "_", "", "_")}.png` : `downloads:/snapshot${xl("-", "_", "", "_")}.png`, i = this.cfg.searchPath(e);
  if (!("layer" in t) && this.sys.canCapturePage(i, () => this.main.resume()))
    return !0;
  const n = Vf(i), s = I0(t, "b_color", h(this, vo)), o = w_({
    width: j(t, "width", L.stageW),
    height: j(t, "height", L.stageH),
    backgroundAlpha: s > 16777216 && n === "png" ? 0 : 1,
    antialias: K(t, "smoothing", !1),
    preserveDrawingBuffer: !0,
    backgroundColor: s & 16777215,
    autoDensity: !0
  }), a = [], l = t.page !== "back" ? "fore" : "back";
  if (h(this, Oe).tw)
    a.push(new Promise((u) => {
      h(this, re).visible = !0;
      for (const c of h(this, _o))
        o.render(c, { clear: !1 });
      h(this, re).visible = !1, h(this, mo).visible = !0, h(this, At).filters = h(this, Pe).filters, h(this, At).visible = !0, o.render(h(this, At), { clear: !1 }), h(this, At).visible = !1, h(this, At).filters = [], u();
    }));
  else
    for (const u of x(this, ti, mi).call(this, t.layer))
      a.push(
        new Promise((c) => h(this, Ot)[u][l].snapshot(o, () => c()))
      );
  return Promise.allSettled(a).then(async () => {
    const u = Wi.create({ width: o.width, height: o.height });
    if (o.render(h(this, ji), { renderTexture: u }), await this.sys.savePic(
      i,
      o.plugins.extract.base64(ge.from(u))
    ), !h(this, Oe).tw)
      for (const c of x(this, ti, mi).call(this, t.layer))
        h(this, Ot)[c][l].snapshot_end();
    o.destroy(!0), this.main.resume();
  }), !0;
}, op = new WeakSet(), Ix = function(t) {
  const { fn: e } = t;
  if (!e)
    throw "fnは必須です";
  const i = K(t, "join", !0);
  switch (Vf(e)) {
    case "css":
      (async () => {
        const n = await fetch(e);
        if (!n.ok)
          throw new Error("Network response was not ok.");
        ba(await n.text()), i && this.main.resume();
      })();
      break;
    default:
      throw "サポートされない拡張子です";
  }
  return i;
}, ap = new WeakSet(), Cx = function(t) {
  const { layer: e, class: i } = t;
  if (!e)
    throw "layerは必須です";
  if (e.includes(","))
    throw "layer名に「,」は使えません";
  if (e in h(this, Ot))
    throw `layer【${e}】はすでにあります`;
  if (!i)
    throw "clsは必須です";
  const n = { isWait: !1 };
  switch (h(this, Ot)[e] = new ml(e, i, h(this, At), h(this, re), t, this.sys, this.val, n), h(this, Br).push(e), i) {
    case "txt":
      h(this, Ur) || (g(this, xo, () => {
      }), g(this, Ei, x(this, wp, Hx)), g(this, Vu, x(this, Ep, $x)), this.hTag.current({ layer: e }), this.goTxt = () => {
        this.val.getVal("sn.skip.enabled") ? g(Xn, ss, 0) : this.setNormalChWait();
        for (const s of x(this, ti, mi).call(this)) {
          const o = h(this, Ot)[s].fore;
          o instanceof ne && h(this, ai).call(this, "gotxt｜", o, !1);
        }
      }), this.val.setVal_Nochk(
        "save",
        "const.sn.layer." + (e ?? h(this, Ur)) + ".enabled",
        !0
      );
      break;
    case "grp":
      if (h(this, $u))
        break;
      g(this, $u, e);
      break;
  }
  return this.scrItr.recodeDesign(t), n.isWait;
}, Ot = new WeakMap(), Br = new WeakMap(), Ur = new WeakMap(), $u = new WeakMap(), hp = new WeakSet(), Mx = function(t) {
  const e = x(this, os, ha).call(this, t), i = h(this, Ot)[e], n = i.back.spLay, s = i.fore.spLay;
  if (K(t, "float", !1))
    h(this, re).setChildIndex(n, h(this, re).children.length - 1), h(this, At).setChildIndex(s, h(this, At).children.length - 1), x(this, ph, Nf).call(this);
  else if (t.index)
    j(t, "index", 0) && (h(this, re).setChildIndex(n, t.index), h(this, At).setChildIndex(s, t.index), x(this, ph, Nf).call(this));
  else if (t.dive) {
    const { dive: o } = t;
    let a = 0;
    if (e === o)
      throw "[lay] 属性 layerとdiveが同じ【" + o + "】です";
    const l = h(this, Ot)[o];
    if (!l)
      throw "[lay] 属性 dive【" + o + "】が不正です。レイヤーがありません";
    const u = l.back, c = l.fore, d = h(this, re).getChildIndex(u.spLay), f = h(this, At).getChildIndex(c.spLay);
    a = d < f ? d : f, a > h(this, re).getChildIndex(n) && --a, h(this, At).setChildIndex(s, a), h(this, re).setChildIndex(n, a), x(this, ph, Nf).call(this);
  }
  return t[":id_tag"] = i.fore.name.slice(0, -7), this.scrItr.recodeDesign(t), i.lay(t);
}, ph = new WeakSet(), Nf = function() {
  g(this, Br, x(this, pp, Ax).call(this));
}, lp = new WeakSet(), Rx = function(t) {
  return x(this, dp, Nx).call(this, t, (e) => {
    const i = h(this, Ot)[x(this, os, ha).call(this, { layer: e })];
    t.page === "both" ? (i.fore.clearLay(t), i.back.clearLay(t)) : i.getPage(t).clearLay(t);
  }), !1;
}, up = new WeakMap(), zu = new WeakMap(), cp = new WeakMap(), yo = new WeakMap(), mo = new WeakMap(), En = new WeakMap(), Pe = new WeakMap(), _o = new WeakMap(), fp = new WeakSet(), kx = function(t) {
  x(this, go, ol).call(this), h(this, lr).hideHint();
  const { layer: e } = t;
  g(this, _o, []);
  const i = {}, n = [];
  for (const y of x(this, ti, mi).call(this, e))
    i[y] = !0, n.push(h(this, Ot)[y].fore);
  const s = [];
  for (const y of x(this, ti, mi).call(this)) {
    const b = h(this, Ot)[y][i[y] ? "back" : "fore"];
    h(this, _o).push(b.spLay), s.push(b);
  }
  h(this, yo).resize(L.stageW, L.stageH), this.appPixi.renderer.render(h(this, re), { renderTexture: h(this, yo) });
  let o = () => {
    h(this, re).visible = !0;
    for (const y of h(this, _o))
      this.appPixi.renderer.render(y, { renderTexture: h(this, yo), clear: !1 });
    h(this, re).visible = !1;
  };
  if (!s.some((y) => y.containMovement)) {
    let y = o;
    o = () => {
      o = () => {
      }, y();
    };
  }
  h(this, En).resize(L.stageW, L.stageH), this.appPixi.renderer.render(h(this, At), { renderTexture: h(this, En) });
  let a = () => {
    h(this, At).visible = !0, this.appPixi.renderer.render(h(this, At), { renderTexture: h(this, En) }), h(this, At).visible = !1;
  };
  if (!n.some((y) => y.containMovement)) {
    let y = a;
    a = () => {
      a = () => {
      }, y();
    };
  }
  const l = () => {
    o(), h(this, mo).visible = !0, a(), h(this, Pe).visible = !0;
  };
  h(this, Pe).alpha = 1;
  const u = () => {
    var b;
    this.appPixi.ticker && this.appPixi.ticker.remove(l), [Te(this, At)._, Te(this, re)._] = [h(this, re), h(this, At)];
    const y = [];
    for (const [w, E] of Object.entries(h(this, Ot))) {
      if (i[w]) {
        E.transPage(y);
        continue;
      }
      const { fore: { spLay: O }, back: { spLay: I } } = E, S = h(this, At).getChildIndex(I);
      h(this, At).removeChild(I), h(this, re).removeChild(O), h(this, At).addChildAt(O, S), h(this, re).addChildAt(I, S);
    }
    Promise.allSettled(y), h(this, At).visible = !0, h(this, re).visible = !1, h(this, mo).visible = !1, h(this, Pe).visible = !1, (b = h(this, Oe).tw) == null || b.stop(), h(this, Oe).resume && this.main.resume(), g(this, Oe, { tw: void 0, resume: !1 });
  };
  g(this, Oe, { tw: void 0, resume: !1 });
  const c = j(t, "time", 0);
  if (c === 0 || h(this, lr).isSkippingByKeyDown())
    return u(), !1;
  const { ease: d, glsl: f, rule: v } = t, m = Fn.ease(d);
  if (!f && !v)
    return h(this, Pe).filters = [], h(this, Oe).tw = new zr(h(this, Pe)).to({ alpha: 0 }, c).delay(j(t, "delay", 0)).easing(m).onComplete(u).start(), this.appPixi.ticker.add(l), !1;
  const p = f ? new wr(void 0, f, h(this, zu)) : h(this, cp);
  if (p.uniforms.vague = j(t, "vague", 0.04), p.uniforms.tick = 0, h(this, Oe).tw = new zr(p.uniforms).to({ tick: 1 }, c).delay(j(t, "delay", 0)).easing(m).onComplete(u), h(this, Pe).filters = [p], f)
    return h(this, Oe).tw.start(), this.appPixi.ticker.add(l), !1;
  if (!v)
    throw "ruleが指定されていません";
  return Pt.csv2Sprites(v, void 0, (y) => {
    var b;
    p.uniforms.rule = y.texture, y.destroy(), (b = h(this, Oe).tw) == null || b.start(), this.appPixi.ticker.add(l);
  }), !1;
}, Oe = new WeakMap(), ti = new WeakSet(), mi = function(t = "") {
  return t ? t.split(",") : h(this, Br);
}, dp = new WeakSet(), Nx = function(t, e) {
  const i = x(this, ti, mi).call(this, t.layer);
  for (const n of i) {
    if (!n)
      continue;
    const s = h(this, Ot)[n];
    if (!s)
      throw "存在しないlayer【" + n + "】です";
    e(n, s);
  }
  return i;
}, pp = new WeakSet(), Ax = function(t = "") {
  return x(this, ti, mi).call(this, t).sort((e, i) => {
    const n = h(this, At).getChildIndex(h(this, Ot)[e].fore.spLay), s = h(this, At).getChildIndex(h(this, Ot)[i].fore.spLay);
    return n < s ? -1 : n > s ? 1 : 0;
  });
}, vp = new WeakSet(), Lx = function(t) {
  return h(this, Oe).tw ? (h(this, Oe).resume = !0, h(this, lr).waitLimitedEvent(t, () => x(this, go, ol).call(this))) : !1;
}, go = new WeakSet(), ol = function() {
  var t;
  return (t = h(this, Oe).tw) == null || t.end(), !1;
}, yp = new WeakSet(), Dx = function(t) {
  x(this, go, ol).call(this);
  const e = j(t, "time", NaN);
  if (e === 0 || this.val.getVal("tmp:sn.skip.enabled") || h(this, lr).isSkippingByKeyDown())
    return !1;
  const { layer: i, ease: n } = t, s = [];
  for (const v of x(this, ti, mi).call(this, i))
    s.push(h(this, Ot)[v].fore.spLay);
  h(this, En).resize(L.stageW, L.stageH);
  const o = () => {
    h(this, At).visible = !0;
    for (const v of s)
      this.appPixi.renderer.render(
        v,
        { renderTexture: h(this, En), clear: !1 }
      );
    h(this, At).visible = !1;
  };
  h(this, Pe).visible = !0, h(this, Pe).alpha = 1;
  const a = mr(j(t, "hmax", 10)), l = mr(j(t, "vmax", 10)), u = a === 0 ? () => {
  } : () => h(this, Pe).x = Math.round(Math.random() * a * 2) - a, c = l === 0 ? () => {
  } : () => h(this, Pe).y = Math.round(Math.random() * l * 2) - l;
  h(this, Pe).filters = [];
  const d = j(t, "repeat", 1), f = new zr(h(this, Pe)).to({ x: 0, y: 0 }, e).delay(j(t, "delay", 0)).easing(Fn.ease(n)).onUpdate(() => {
    u(), c();
  }).repeat(d === 0 ? 1 / 0 : d - 1).yoyo(K(t, "yoyo", !1)).onComplete(() => {
    var v, m;
    (v = this.appPixi.ticker) == null || v.remove(o), h(this, At).visible = !0, h(this, Pe).visible = !1, h(this, Pe).x = 0, h(this, Pe).y = 0, (m = h(this, Oe).tw) == null || m.stop(), h(this, Oe).resume && this.main.resume(), g(this, Oe, { tw: void 0, resume: !1 });
  }).start();
  return g(this, Oe, { tw: f, resume: !1 }), this.appPixi.ticker.add(o), !1;
}, wi = new WeakMap(), mp = new WeakSet(), Fx = function(t) {
  const { layer: e, render: i, path: n, name: s, ease: o, chain: a } = t;
  if (!e)
    throw "layerは必須です";
  const l = x(this, os, ha).call(this, t);
  let u = h(this, Ot)[l].fore, c = () => {
  };
  const d = h(this, lr).isSkippingByKeyDown();
  !d && i && (u.renderStart(), c = () => u.renderEnd());
  const f = s ?? e, v = () => {
    var N, F;
    const R = h(this, wi)[f];
    R && (c(), delete h(this, wi)[f], (N = R.tw) == null || N.stop(), R.resume && this.main.resume(), (F = R.onEnd) == null || F.call(R));
  }, m = zf(t, u), p = j(t, "time", NaN) * (this.val.getVal("tmp:sn.skip.enabled") || d ? 0 : 1), y = Fn.ease(o), b = j(t, "repeat", 1), w = b === 0 ? 1 / 0 : b - 1, E = K(t, "yoyo", !1), O = j(t, "delay", 0), I = new zr(u).to(m, p).easing(y).repeat(w).yoyo(E).delay(O);
  let S = I;
  if (n) {
    L.debugLog && console.group(`🍝 [tsy] path=${n}= start(${u.x},${u.y},${u.alpha})`);
    for (const { groups: R } of n.matchAll(Xn.REG_TSY_PATH)) {
      const { x: N, x2: F, y: $, y2: q, o: ht, o2: V, json: H } = R;
      let Q = {};
      if (H)
        try {
          Q = JSON.parse(H);
        } catch (Tt) {
          console.error(`🍝 json=${H} ` + Tt);
          continue;
        }
      else
        (N ?? F) && (Q.x = N ?? F), ($ ?? q) && (Q.y = $ ?? q), (ht ?? V) && (Q.alpha = ht ?? V);
      const mt = zf(Q, u);
      L.debugLog && console.info(`🍝 ${H ?? `{x:${N} y:${$} o:${ht}}`} => hTo:${JSON.stringify(mt)}`);
      const et = new zr(u).to(mt, p).easing(y).repeat(w).yoyo(E);
      S.chain(et), S = et;
    }
    L.debugLog && console.groupEnd();
  }
  if (S.onComplete(v), a) {
    const R = h(this, wi)[a ?? ""];
    if (!(R != null && R.tw))
      throw `${a}は存在しない・または終了したトゥイーンです`;
    delete R.onEnd, R.tw.chain(I);
  } else
    I.start();
  const C = K(t, "arrive", !1), P = K(t, "backlay", !1);
  return h(this, wi)[f] = { tw: S, resume: !1, onEnd: () => {
    if (C && Object.assign(u, m), P) {
      const R = h(this, Ot)[l].back.spLay;
      for (const N of Object.keys(P0))
        R[N] = u[N];
    }
  } }, !1;
}, _p = new WeakSet(), Bx = function(t) {
  const { layer: e = "", id: i, name: n } = t, s = i ? `frm
${i}` : n ?? e;
  if (!s)
    throw "トゥイーンが指定されていません";
  const o = h(this, wi)[s];
  return o != null && o.tw ? o.resume = h(this, lr).waitEvent(
    () => {
      var a;
      return (a = o.tw) == null ? void 0 : a.end();
    },
    // stop()とend()は別
    K(t, "canskip", !0),
    K(t, "global", !1)
  ) : !1;
}, gp = new WeakSet(), Ux = function(t) {
  var o, a;
  const { layer: e = "", id: i, name: n } = t, s = i ? `frm
${i}` : n ?? e;
  if (!s)
    throw "トゥイーンが指定されていません";
  return (a = (o = h(this, wi)[s]) == null ? void 0 : o.tw) == null || a.end(), !1;
}, bp = new WeakSet(), Gx = function(t) {
  var o, a;
  const { layer: e = "", id: i, name: n } = t, s = i ? `frm
${i}` : n ?? e;
  if (!s)
    throw "トゥイーンが指定されていません";
  return (a = (o = h(this, wi)[s]) == null ? void 0 : o.tw) == null || a.pause(), !1;
}, xp = new WeakSet(), jx = function(t) {
  var o, a;
  const { layer: e = "", id: i, name: n } = t, s = i ? `frm
${i}` : n ?? e;
  if (!s)
    throw "トゥイーンが指定されていません";
  return (a = (o = h(this, wi)[s]) == null ? void 0 : o.tw) == null || a.resume(), !1;
}, ss = new WeakMap(), bo = new WeakSet(), al = function(t) {
  const { text: e } = t;
  if (!e)
    throw "textは必須です";
  const i = h(this, Ei).call(this, t);
  delete t.text, this.val.getVal("tmp:sn.skip.enabled") ? t.wait = 0 : "wait" in t && j(t, "wait", NaN);
  const n = encodeURIComponent(JSON.stringify(t));
  h(this, ai).call(this, "add｜" + n, i);
  const s = K(t, "record", !0), o = this.val.doRecLog();
  return s || this.val.setVal_Nochk("save", "sn.doRecLog", s), i.tagCh(e.replaceAll("[r]", `
`)), this.val.setVal_Nochk("save", "sn.doRecLog", o), h(this, ai).call(this, "add_close｜", i), !1;
}, Ei = new WeakMap(), wp = new WeakSet(), Hx = function(t) {
  const e = x(this, os, ha).call(this, t, h(this, Ur)), n = h(this, Ot)[e].getPage(t);
  if (!(n instanceof ne))
    throw e + "はTxtLayerではありません";
  return n;
}, Vu = new WeakMap(), Ep = new WeakSet(), $x = function(t) {
  const { layer: e } = t;
  if (!e)
    throw "[current] layerは必須です";
  if (g(this, Gr, h(this, Ot)[e]), !(h(this, Gr).getPage(t) instanceof ne))
    throw `${e}はTxtLayerではありません`;
  this.recPagebreak(), g(this, Ur, e), this.val.setVal_Nochk("save", "const.sn.mesLayer", e);
  for (const i of x(this, ti, mi).call(this)) {
    const n = h(this, Ot)[i];
    n.fore instanceof ne && (n.fore.isCur = n.back.isCur = i === e);
  }
  return !1;
}, Gr = new WeakMap(), xo = new WeakMap(), os = new WeakSet(), ha = function(t, e = "") {
  const i = t.layer ?? e;
  if (i.includes(","))
    throw "layer名に「,」は使えません";
  if (!(i in h(this, Ot)))
    throw "属性 layer【" + i + "】が不正です。レイヤーがありません";
  return t.layer = i;
}, ur = new WeakMap(), jr = new WeakMap(), Tp = new WeakSet(), zx = function(t) {
  const e = h(this, Ei).call(this, t);
  return t.layer === h(this, Ur) && t.page === "fore" && this.recPagebreak(), e.clearText(), !1;
}, Sp = new WeakSet(), Vx = function(t) {
  return h(this, ai).call(this, "endlink｜", h(this, Ei).call(this, t)), !1;
}, Pp = new WeakSet(), Xx = function(t) {
  return K(t, "rec_page_break", !0) && this.recPagebreak(), h(this, Gr) && (h(this, Gr).fore.clearLay(t), h(this, Gr).back.clearLay(t)), !1;
}, Op = new WeakSet(), Wx = function(t) {
  if (!t.pic)
    throw "[graph] picは必須です";
  const e = encodeURIComponent(JSON.stringify(t));
  return h(this, ai).call(this, "grp｜" + e, h(this, Ei).call(this, t)), !1;
}, Ip = new WeakSet(), Yx = function(t) {
  t.style ?? (t.style = "background-color: rgba(255,0,0,0.5);"), t.style_hover ?? (t.style_hover = "background-color: rgba(255,0,0,0.9);"), t.style_clicked ?? (t.style_clicked = t.style);
  const e = encodeURIComponent(JSON.stringify(t));
  return h(this, ai).call(this, "link｜" + e, h(this, Ei).call(this, t)), !1;
}, Cp = new WeakSet(), qx = function(t) {
  return t.text = `
`, x(this, bo, al).call(this, t);
}, Mp = new WeakSet(), Zx = function(t) {
  return x(this, Xu, Tm).call(this, { ...t, text: "[r]" });
}, Xu = new WeakSet(), Tm = function(t) {
  return t.text ? (t.record = !0, t.style ?? (t.style = ""), t.style += "display: none;", t.wait = 0, x(this, bo, al).call(this, t)) : !1;
}, Rp = new WeakSet(), Kx = function(t) {
  return g(this, jr, []), g(this, ur, t.text ?? ""), this.val.setVal_Nochk(
    "save",
    "const.sn.sLog",
    t.text ? `[{text:"${t.text}"}]` : "[]"
  ), !1;
}, kp = new WeakSet(), Jx = function(t) {
  const { t: e, r: i } = t;
  if (!e)
    throw "[ruby2] tは必須です";
  if (!i)
    throw "[ruby2] rは必須です";
  return t.text = "｜" + encodeURIComponent(e) + "《" + encodeURIComponent(i) + "》", delete t.t, delete t.r, x(this, bo, al).call(this, t);
}, Np = new WeakSet(), Qx = function(t) {
  const e = encodeURIComponent(JSON.stringify(t));
  return h(this, ai).call(this, "span｜" + e, h(this, Ei).call(this, t)), !1;
}, Ap = new WeakSet(), tw = function(t) {
  if (!t.t)
    throw "[tcy] tは必須です";
  const e = encodeURIComponent(JSON.stringify(t));
  return h(this, ai).call(this, "tcy｜" + e, h(this, Ei).call(this, t)), !1;
}, Lp = new WeakSet(), ew = function(t) {
  console.group("🥟 [dump_lay]");
  for (const e of x(this, ti, mi).call(this, t.layer)) {
    const i = h(this, Ot)[e];
    try {
      console.info(
        `%c${i.fore.name.slice(0, -7)} %o`,
        `color:#${L.isDarkMode ? "49F" : "05A"};`,
        JSON.parse(`{"back":{${i.back.dump()}}, "fore":{${i.fore.dump()}}}`)
      );
    } catch (n) {
      console.error("dump_lay err:%o", n), console.error(`   back:${i.back.dump()}`), console.error(`   fore:${i.fore.dump()}`);
    }
  }
  return console.groupEnd(), !1;
}, Dp = new WeakSet(), iw = function(t) {
  const e = x(this, os, ha).call(this, t, h(this, Ur)), i = K(t, "enabled", !0);
  return h(this, Ei).call(this, t).enabled = i, this.val.setVal_Nochk("save", "const.sn.layer." + e + ".enabled", i), !1;
}, Fp = new WeakSet(), rw = function(t) {
  return ml.argChk_page(t, "back"), t.clicksebuf ?? (t.clicksebuf = "SYS"), t.entersebuf ?? (t.entersebuf = "SYS"), t.leavesebuf ?? (t.leavesebuf = "SYS"), t.fn || (t.fn = this.scrItr.scriptFn), h(this, Ei).call(this, t).addButton(t), this.scrItr.recodeDesign(t), !1;
}, // 11 match 301 step (0.1ms) PCRE2 https://regex101.com/r/reinpq/1
// List ${x}${x2}/${y}${y2}/${o}${o2}=${json}\n
/*
\(\s*
(?:	(?<x>[-=\d\.]+)	|	(['"])	(?<x2>.*?)	\2	)?
(?:
	\s*,\s*
	(?:	(?<y>[-=\d\.]+)	|	(['"])	(?<y2>.*?)	\5	)?
	(?:
		\s*,\s*
		(?:	(?<o>[-=\d\.]+)	|	(['"])	(?<o2>.*?)	\8	)

	)?
)?
|
(?<json>\{[^{}]*})
*/
D(Ds, "REG_TSY_PATH", /\(\s*(?:(?<x>[-=\d\.]+)|(['"])(?<x2>.*?)\2)?(?:\s*,\s*(?:(?<y>[-=\d\.]+)|(['"])(?<y2>.*?)\5)?(?:\s*,\s*(?:(?<o>[-=\d\.]+)|(['"])(?<o2>.*?)\8))?)?|(?<json>\{[^{}]*})/g), //	// 文字・文字レイヤ
_(Ds, ss, 10);
var oe, Kt, vh, Bp, nw, Wu, wo, hl;
class tM {
  constructor() {
    _(this, Bp);
    _(this, wo);
    _(this, oe, []);
    _(this, Kt, -1);
    _(this, vh, new Dh());
    _(this, Wu, L.debugLog ? (t) => console.log(`👾 <FocusMng idx:${t} btn:%o`, h(this, oe)[t].btn) : () => {
    });
  }
  destroy() {
    g(this, oe, []), g(this, Kt, -1), h(this, vh).clear();
  }
  add(t, e, i) {
    if (h(this, oe).findIndex((a) => a.btn === t) >= 0)
      return;
    if (t instanceof Qt) {
      t.on("pointerdown", () => {
        for (let a = h(this, oe).length - 1; a >= 0; --a)
          if (h(this, oe)[a].btn === t) {
            g(this, Kt, a);
            return;
          }
        g(this, Kt, -1);
      }), h(this, oe).push({ btn: t, on: e, off: i });
      return;
    }
    h(this, vh).add(t, "focus", () => {
      for (let a = h(this, oe).length - 1; a >= 0; --a)
        if (h(this, oe)[a].btn === t) {
          g(this, Kt, a);
          return;
        }
      g(this, Kt, -1);
    });
    let n = (a) => {
    }, s = t.localName === "button" || t.localName === "a" ? (a) => !a.isTrusted && a.key === "Enter" : (a) => a.key === "Enter";
    const o = t;
    switch (o.type ?? "") {
      case "checkbox":
        n = () => o.checked = !o.checked;
        break;
      case "":
        t.querySelectorAll("input[type]").length > 0 && (n = (a) => x(this, Bp, nw).call(this, t, a.key), s = () => !1);
        break;
      case "range":
        n = (a) => {
          a.isTrusted || (a.key === "ArrowUp" ? o.stepUp() : o.stepDown());
        };
        break;
      case "text":
      case "textarea":
        n = (a) => {
          if (a.isTrusted)
            return;
          let l = (o.selectionStart ?? 0) + (a.key === "ArrowUp" ? -1 : 1);
          l < 0 && (l = 0), o.setSelectionRange(l, l);
        };
        break;
    }
    h(this, vh).add(t, "keydown", (a) => {
      if (!(a.key !== "ArrowUp" && a.key !== "ArrowDown" && a.key !== "Enter")) {
        if (a.stopPropagation(), a.stopImmediatePropagation(), s(a)) {
          t.dispatchEvent(new MouseEvent("click"));
          return;
        }
        n(a);
      }
    }, { passive: !0 }), t.hasAttribute("tabindex") || (t.tabIndex = 0), h(this, oe).push({ btn: t, on: e, off: i });
  }
  remove(t) {
    const e = h(this, oe).findIndex((i) => i.btn === t);
    e < 0 || (h(this, oe).splice(e, 1), h(this, oe).length === 0 ? g(this, Kt, -1) : e <= h(this, Kt) && --Te(this, Kt)._);
  }
  isFocus(t) {
    return h(this, Kt) < 0 ? !1 : h(this, oe)[h(this, Kt)].btn === t;
  }
  prev() {
    x(this, wo, hl).call(this);
    const t = h(this, oe).length;
    if (t !== 0) {
      --Te(this, Kt)._ < 0 && g(this, Kt, t - 1);
      for (let e = t; e >= 1; --e) {
        const i = (h(this, Kt) + e) % t;
        if (h(this, oe)[i].on()) {
          g(this, Kt, i), h(this, Wu).call(this, i);
          return;
        }
      }
      g(this, Kt, -1);
    }
  }
  next() {
    x(this, wo, hl).call(this);
    const t = h(this, oe).length;
    if (t !== 0) {
      ++Te(this, Kt)._ >= t && g(this, Kt, 0);
      for (let e = 0; e < t; ++e) {
        const i = (h(this, Kt) + e) % t;
        if (h(this, oe)[i].on()) {
          g(this, Kt, i), h(this, Wu).call(this, i);
          return;
        }
      }
      g(this, Kt, -1);
    }
  }
  getFocus() {
    if (h(this, Kt) < 0)
      return null;
    x(this, wo, hl).call(this), h(this, Kt) >= h(this, oe).length && g(this, Kt, 0);
    const t = h(this, oe)[h(this, Kt)];
    return t.on() ? t.btn : null;
  }
  blur() {
    x(this, wo, hl).call(this), g(this, Kt, -1), globalThis.focus();
  }
}
oe = new WeakMap(), Kt = new WeakMap(), vh = new WeakMap(), Bp = new WeakSet(), nw = function(t, e) {
  const i = t.querySelectorAll("input[type]"), n = i.length;
  for (let s = 0; s < n; ++s)
    if (i[s].checked) {
      i[(s + n + (e === "ArrowUp" ? -1 : 1)) % n].checked = !0;
      break;
    }
}, Wu = new WeakMap(), wo = new WeakSet(), hl = function() {
  for (let t = h(this, oe).length - 1; t >= 0; --t) {
    const e = h(this, oe)[t];
    !(e.btn instanceof Qt) || e.btn.parent ? e.off() : h(this, oe).splice(t, 1);
  }
};
var fi = "top", Yi = "bottom", qi = "right", di = "left", Dv = "auto", kc = [fi, Yi, qi, di], Fh = "start", kl = "end", eM = "clippingParents", sw = "viewport", Jh = "popper", iM = "reference", i0 = /* @__PURE__ */ kc.reduce(function(r, t) {
  return r.concat([t + "-" + Fh, t + "-" + kl]);
}, []), ow = /* @__PURE__ */ [].concat(kc, [Dv]).reduce(function(r, t) {
  return r.concat([t, t + "-" + Fh, t + "-" + kl]);
}, []), rM = "beforeRead", nM = "read", sM = "afterRead", oM = "beforeMain", aM = "main", hM = "afterMain", lM = "beforeWrite", uM = "write", cM = "afterWrite", Sm = [rM, nM, sM, oM, aM, hM, lM, uM, cM];
function Jr(r) {
  return r ? (r.nodeName || "").toLowerCase() : null;
}
function Ri(r) {
  if (r == null)
    return window;
  if (r.toString() !== "[object Window]") {
    var t = r.ownerDocument;
    return t && t.defaultView || window;
  }
  return r;
}
function Jo(r) {
  var t = Ri(r).Element;
  return r instanceof t || r instanceof Element;
}
function Mi(r) {
  var t = Ri(r).HTMLElement;
  return r instanceof t || r instanceof HTMLElement;
}
function N_(r) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = Ri(r).ShadowRoot;
  return r instanceof t || r instanceof ShadowRoot;
}
function fM(r) {
  var t = r.state;
  Object.keys(t.elements).forEach(function(e) {
    var i = t.styles[e] || {}, n = t.attributes[e] || {}, s = t.elements[e];
    !Mi(s) || !Jr(s) || (Object.assign(s.style, i), Object.keys(n).forEach(function(o) {
      var a = n[o];
      a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a);
    }));
  });
}
function dM(r) {
  var t = r.state, e = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
    Object.keys(t.elements).forEach(function(i) {
      var n = t.elements[i], s = t.attributes[i] || {}, o = Object.keys(t.styles.hasOwnProperty(i) ? t.styles[i] : e[i]), a = o.reduce(function(l, u) {
        return l[u] = "", l;
      }, {});
      !Mi(n) || !Jr(n) || (Object.assign(n.style, a), Object.keys(s).forEach(function(l) {
        n.removeAttribute(l);
      }));
    });
  };
}
const pM = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: fM,
  effect: dM,
  requires: ["computeStyles"]
};
function gr(r) {
  return r.split("-")[0];
}
var Xo = Math.max, od = Math.min, Bh = Math.round;
function Pm() {
  var r = navigator.userAgentData;
  return r != null && r.brands && Array.isArray(r.brands) ? r.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function aw() {
  return !/^((?!chrome|android).)*safari/i.test(Pm());
}
function Uh(r, t, e) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  var i = r.getBoundingClientRect(), n = 1, s = 1;
  t && Mi(r) && (n = r.offsetWidth > 0 && Bh(i.width) / r.offsetWidth || 1, s = r.offsetHeight > 0 && Bh(i.height) / r.offsetHeight || 1);
  var o = Jo(r) ? Ri(r) : window, a = o.visualViewport, l = !aw() && e, u = (i.left + (l && a ? a.offsetLeft : 0)) / n, c = (i.top + (l && a ? a.offsetTop : 0)) / s, d = i.width / n, f = i.height / s;
  return {
    width: d,
    height: f,
    top: c,
    right: u + d,
    bottom: c + f,
    left: u,
    x: u,
    y: c
  };
}
function A_(r) {
  var t = Uh(r), e = r.offsetWidth, i = r.offsetHeight;
  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - i) <= 1 && (i = t.height), {
    x: r.offsetLeft,
    y: r.offsetTop,
    width: e,
    height: i
  };
}
function hw(r, t) {
  var e = t.getRootNode && t.getRootNode();
  if (r.contains(t))
    return !0;
  if (e && N_(e)) {
    var i = t;
    do {
      if (i && r.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function Er(r) {
  return Ri(r).getComputedStyle(r);
}
function vM(r) {
  return ["table", "td", "th"].indexOf(Jr(r)) >= 0;
}
function gs(r) {
  return ((Jo(r) ? r.ownerDocument : (
    // $FlowFixMe[prop-missing]
    r.document
  )) || window.document).documentElement;
}
function Fv(r) {
  return Jr(r) === "html" ? r : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    r.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    r.parentNode || // DOM Element detected
    (N_(r) ? r.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    gs(r)
  );
}
function r0(r) {
  return !Mi(r) || // https://github.com/popperjs/popper-core/issues/837
  Er(r).position === "fixed" ? null : r.offsetParent;
}
function yM(r) {
  var t = /firefox/i.test(Pm()), e = /Trident/i.test(Pm());
  if (e && Mi(r)) {
    var i = Er(r);
    if (i.position === "fixed")
      return null;
  }
  var n = Fv(r);
  for (N_(n) && (n = n.host); Mi(n) && ["html", "body"].indexOf(Jr(n)) < 0; ) {
    var s = Er(n);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || t && s.willChange === "filter" || t && s.filter && s.filter !== "none")
      return n;
    n = n.parentNode;
  }
  return null;
}
function Nc(r) {
  for (var t = Ri(r), e = r0(r); e && vM(e) && Er(e).position === "static"; )
    e = r0(e);
  return e && (Jr(e) === "html" || Jr(e) === "body" && Er(e).position === "static") ? t : e || yM(r) || t;
}
function L_(r) {
  return ["top", "bottom"].indexOf(r) >= 0 ? "x" : "y";
}
function _l(r, t, e) {
  return Xo(r, od(t, e));
}
function mM(r, t, e) {
  var i = _l(r, t, e);
  return i > e ? e : i;
}
function lw() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function uw(r) {
  return Object.assign({}, lw(), r);
}
function cw(r, t) {
  return t.reduce(function(e, i) {
    return e[i] = r, e;
  }, {});
}
var _M = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, uw(typeof t != "number" ? t : cw(t, kc));
};
function gM(r) {
  var t, e = r.state, i = r.name, n = r.options, s = e.elements.arrow, o = e.modifiersData.popperOffsets, a = gr(e.placement), l = L_(a), u = [di, qi].indexOf(a) >= 0, c = u ? "height" : "width";
  if (!(!s || !o)) {
    var d = _M(n.padding, e), f = A_(s), v = l === "y" ? fi : di, m = l === "y" ? Yi : qi, p = e.rects.reference[c] + e.rects.reference[l] - o[l] - e.rects.popper[c], y = o[l] - e.rects.reference[l], b = Nc(s), w = b ? l === "y" ? b.clientHeight || 0 : b.clientWidth || 0 : 0, E = p / 2 - y / 2, O = d[v], I = w - f[c] - d[m], S = w / 2 - f[c] / 2 + E, C = _l(O, S, I), P = l;
    e.modifiersData[i] = (t = {}, t[P] = C, t.centerOffset = C - S, t);
  }
}
function bM(r) {
  var t = r.state, e = r.options, i = e.element, n = i === void 0 ? "[data-popper-arrow]" : i;
  if (n != null && !(typeof n == "string" && (n = t.elements.popper.querySelector(n), !n))) {
    if (process.env.NODE_ENV !== "production" && (Mi(n) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !hw(t.elements.popper, n)) {
      process.env.NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    t.elements.arrow = n;
  }
}
const xM = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: gM,
  effect: bM,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Gh(r) {
  return r.split("-")[1];
}
var wM = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function EM(r, t) {
  var e = r.x, i = r.y, n = t.devicePixelRatio || 1;
  return {
    x: Bh(e * n) / n || 0,
    y: Bh(i * n) / n || 0
  };
}
function n0(r) {
  var t, e = r.popper, i = r.popperRect, n = r.placement, s = r.variation, o = r.offsets, a = r.position, l = r.gpuAcceleration, u = r.adaptive, c = r.roundOffsets, d = r.isFixed, f = o.x, v = f === void 0 ? 0 : f, m = o.y, p = m === void 0 ? 0 : m, y = typeof c == "function" ? c({
    x: v,
    y: p
  }) : {
    x: v,
    y: p
  };
  v = y.x, p = y.y;
  var b = o.hasOwnProperty("x"), w = o.hasOwnProperty("y"), E = di, O = fi, I = window;
  if (u) {
    var S = Nc(e), C = "clientHeight", P = "clientWidth";
    if (S === Ri(e) && (S = gs(e), Er(S).position !== "static" && a === "absolute" && (C = "scrollHeight", P = "scrollWidth")), S = S, n === fi || (n === di || n === qi) && s === kl) {
      O = Yi;
      var R = d && S === I && I.visualViewport ? I.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        S[C]
      );
      p -= R - i.height, p *= l ? 1 : -1;
    }
    if (n === di || (n === fi || n === Yi) && s === kl) {
      E = qi;
      var N = d && S === I && I.visualViewport ? I.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        S[P]
      );
      v -= N - i.width, v *= l ? 1 : -1;
    }
  }
  var F = Object.assign({
    position: a
  }, u && wM), $ = c === !0 ? EM({
    x: v,
    y: p
  }, Ri(e)) : {
    x: v,
    y: p
  };
  if (v = $.x, p = $.y, l) {
    var q;
    return Object.assign({}, F, (q = {}, q[O] = w ? "0" : "", q[E] = b ? "0" : "", q.transform = (I.devicePixelRatio || 1) <= 1 ? "translate(" + v + "px, " + p + "px)" : "translate3d(" + v + "px, " + p + "px, 0)", q));
  }
  return Object.assign({}, F, (t = {}, t[O] = w ? p + "px" : "", t[E] = b ? v + "px" : "", t.transform = "", t));
}
function TM(r) {
  var t = r.state, e = r.options, i = e.gpuAcceleration, n = i === void 0 ? !0 : i, s = e.adaptive, o = s === void 0 ? !0 : s, a = e.roundOffsets, l = a === void 0 ? !0 : a;
  if (process.env.NODE_ENV !== "production") {
    var u = Er(t.elements.popper).transitionProperty || "";
    o && ["transform", "top", "right", "bottom", "left"].some(function(d) {
      return u.indexOf(d) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var c = {
    placement: gr(t.placement),
    variation: Gh(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: n,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, n0(Object.assign({}, c, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: o,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, n0(Object.assign({}, c, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const SM = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: TM,
  data: {}
};
var af = {
  passive: !0
};
function PM(r) {
  var t = r.state, e = r.instance, i = r.options, n = i.scroll, s = n === void 0 ? !0 : n, o = i.resize, a = o === void 0 ? !0 : o, l = Ri(t.elements.popper), u = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return s && u.forEach(function(c) {
    c.addEventListener("scroll", e.update, af);
  }), a && l.addEventListener("resize", e.update, af), function() {
    s && u.forEach(function(c) {
      c.removeEventListener("scroll", e.update, af);
    }), a && l.removeEventListener("resize", e.update, af);
  };
}
const OM = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: PM,
  data: {}
};
var IM = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Af(r) {
  return r.replace(/left|right|bottom|top/g, function(t) {
    return IM[t];
  });
}
var CM = {
  start: "end",
  end: "start"
};
function s0(r) {
  return r.replace(/start|end/g, function(t) {
    return CM[t];
  });
}
function D_(r) {
  var t = Ri(r), e = t.pageXOffset, i = t.pageYOffset;
  return {
    scrollLeft: e,
    scrollTop: i
  };
}
function F_(r) {
  return Uh(gs(r)).left + D_(r).scrollLeft;
}
function MM(r, t) {
  var e = Ri(r), i = gs(r), n = e.visualViewport, s = i.clientWidth, o = i.clientHeight, a = 0, l = 0;
  if (n) {
    s = n.width, o = n.height;
    var u = aw();
    (u || !u && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: s,
    height: o,
    x: a + F_(r),
    y: l
  };
}
function RM(r) {
  var t, e = gs(r), i = D_(r), n = (t = r.ownerDocument) == null ? void 0 : t.body, s = Xo(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), o = Xo(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -i.scrollLeft + F_(r), l = -i.scrollTop;
  return Er(n || e).direction === "rtl" && (a += Xo(e.clientWidth, n ? n.clientWidth : 0) - s), {
    width: s,
    height: o,
    x: a,
    y: l
  };
}
function B_(r) {
  var t = Er(r), e = t.overflow, i = t.overflowX, n = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + n + i);
}
function fw(r) {
  return ["html", "body", "#document"].indexOf(Jr(r)) >= 0 ? r.ownerDocument.body : Mi(r) && B_(r) ? r : fw(Fv(r));
}
function gl(r, t) {
  var e;
  t === void 0 && (t = []);
  var i = fw(r), n = i === ((e = r.ownerDocument) == null ? void 0 : e.body), s = Ri(i), o = n ? [s].concat(s.visualViewport || [], B_(i) ? i : []) : i, a = t.concat(o);
  return n ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(gl(Fv(o)))
  );
}
function Om(r) {
  return Object.assign({}, r, {
    left: r.x,
    top: r.y,
    right: r.x + r.width,
    bottom: r.y + r.height
  });
}
function kM(r, t) {
  var e = Uh(r, !1, t === "fixed");
  return e.top = e.top + r.clientTop, e.left = e.left + r.clientLeft, e.bottom = e.top + r.clientHeight, e.right = e.left + r.clientWidth, e.width = r.clientWidth, e.height = r.clientHeight, e.x = e.left, e.y = e.top, e;
}
function o0(r, t, e) {
  return t === sw ? Om(MM(r, e)) : Jo(t) ? kM(t, e) : Om(RM(gs(r)));
}
function NM(r) {
  var t = gl(Fv(r)), e = ["absolute", "fixed"].indexOf(Er(r).position) >= 0, i = e && Mi(r) ? Nc(r) : r;
  return Jo(i) ? t.filter(function(n) {
    return Jo(n) && hw(n, i) && Jr(n) !== "body";
  }) : [];
}
function AM(r, t, e, i) {
  var n = t === "clippingParents" ? NM(r) : [].concat(t), s = [].concat(n, [e]), o = s[0], a = s.reduce(function(l, u) {
    var c = o0(r, u, i);
    return l.top = Xo(c.top, l.top), l.right = od(c.right, l.right), l.bottom = od(c.bottom, l.bottom), l.left = Xo(c.left, l.left), l;
  }, o0(r, o, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function dw(r) {
  var t = r.reference, e = r.element, i = r.placement, n = i ? gr(i) : null, s = i ? Gh(i) : null, o = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, l;
  switch (n) {
    case fi:
      l = {
        x: o,
        y: t.y - e.height
      };
      break;
    case Yi:
      l = {
        x: o,
        y: t.y + t.height
      };
      break;
    case qi:
      l = {
        x: t.x + t.width,
        y: a
      };
      break;
    case di:
      l = {
        x: t.x - e.width,
        y: a
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var u = n ? L_(n) : null;
  if (u != null) {
    var c = u === "y" ? "height" : "width";
    switch (s) {
      case Fh:
        l[u] = l[u] - (t[c] / 2 - e[c] / 2);
        break;
      case kl:
        l[u] = l[u] + (t[c] / 2 - e[c] / 2);
        break;
    }
  }
  return l;
}
function Nl(r, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = i === void 0 ? r.placement : i, s = e.strategy, o = s === void 0 ? r.strategy : s, a = e.boundary, l = a === void 0 ? eM : a, u = e.rootBoundary, c = u === void 0 ? sw : u, d = e.elementContext, f = d === void 0 ? Jh : d, v = e.altBoundary, m = v === void 0 ? !1 : v, p = e.padding, y = p === void 0 ? 0 : p, b = uw(typeof y != "number" ? y : cw(y, kc)), w = f === Jh ? iM : Jh, E = r.rects.popper, O = r.elements[m ? w : f], I = AM(Jo(O) ? O : O.contextElement || gs(r.elements.popper), l, c, o), S = Uh(r.elements.reference), C = dw({
    reference: S,
    element: E,
    strategy: "absolute",
    placement: n
  }), P = Om(Object.assign({}, E, C)), R = f === Jh ? P : S, N = {
    top: I.top - R.top + b.top,
    bottom: R.bottom - I.bottom + b.bottom,
    left: I.left - R.left + b.left,
    right: R.right - I.right + b.right
  }, F = r.modifiersData.offset;
  if (f === Jh && F) {
    var $ = F[n];
    Object.keys(N).forEach(function(q) {
      var ht = [qi, Yi].indexOf(q) >= 0 ? 1 : -1, V = [fi, Yi].indexOf(q) >= 0 ? "y" : "x";
      N[q] += $[V] * ht;
    });
  }
  return N;
}
function LM(r, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = e.boundary, s = e.rootBoundary, o = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, u = l === void 0 ? ow : l, c = Gh(i), d = c ? a ? i0 : i0.filter(function(m) {
    return Gh(m) === c;
  }) : kc, f = d.filter(function(m) {
    return u.indexOf(m) >= 0;
  });
  f.length === 0 && (f = d, process.env.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var v = f.reduce(function(m, p) {
    return m[p] = Nl(r, {
      placement: p,
      boundary: n,
      rootBoundary: s,
      padding: o
    })[gr(p)], m;
  }, {});
  return Object.keys(v).sort(function(m, p) {
    return v[m] - v[p];
  });
}
function DM(r) {
  if (gr(r) === Dv)
    return [];
  var t = Af(r);
  return [s0(r), t, s0(t)];
}
function FM(r) {
  var t = r.state, e = r.options, i = r.name;
  if (!t.modifiersData[i]._skip) {
    for (var n = e.mainAxis, s = n === void 0 ? !0 : n, o = e.altAxis, a = o === void 0 ? !0 : o, l = e.fallbackPlacements, u = e.padding, c = e.boundary, d = e.rootBoundary, f = e.altBoundary, v = e.flipVariations, m = v === void 0 ? !0 : v, p = e.allowedAutoPlacements, y = t.options.placement, b = gr(y), w = b === y, E = l || (w || !m ? [Af(y)] : DM(y)), O = [y].concat(E).reduce(function(Dt, Ut) {
      return Dt.concat(gr(Ut) === Dv ? LM(t, {
        placement: Ut,
        boundary: c,
        rootBoundary: d,
        padding: u,
        flipVariations: m,
        allowedAutoPlacements: p
      }) : Ut);
    }, []), I = t.rects.reference, S = t.rects.popper, C = /* @__PURE__ */ new Map(), P = !0, R = O[0], N = 0; N < O.length; N++) {
      var F = O[N], $ = gr(F), q = Gh(F) === Fh, ht = [fi, Yi].indexOf($) >= 0, V = ht ? "width" : "height", H = Nl(t, {
        placement: F,
        boundary: c,
        rootBoundary: d,
        altBoundary: f,
        padding: u
      }), Q = ht ? q ? qi : di : q ? Yi : fi;
      I[V] > S[V] && (Q = Af(Q));
      var mt = Af(Q), et = [];
      if (s && et.push(H[$] <= 0), a && et.push(H[Q] <= 0, H[mt] <= 0), et.every(function(Dt) {
        return Dt;
      })) {
        R = F, P = !1;
        break;
      }
      C.set(F, et);
    }
    if (P)
      for (var Tt = m ? 3 : 1, it = function(Ut) {
        var k = O.find(function(zt) {
          var lt = C.get(zt);
          if (lt)
            return lt.slice(0, Ut).every(function(me) {
              return me;
            });
        });
        if (k)
          return R = k, "break";
      }, we = Tt; we > 0; we--) {
        var Bt = it(we);
        if (Bt === "break")
          break;
      }
    t.placement !== R && (t.modifiersData[i]._skip = !0, t.placement = R, t.reset = !0);
  }
}
const BM = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: FM,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function a0(r, t, e) {
  return e === void 0 && (e = {
    x: 0,
    y: 0
  }), {
    top: r.top - t.height - e.y,
    right: r.right - t.width + e.x,
    bottom: r.bottom - t.height + e.y,
    left: r.left - t.width - e.x
  };
}
function h0(r) {
  return [fi, qi, Yi, di].some(function(t) {
    return r[t] >= 0;
  });
}
function UM(r) {
  var t = r.state, e = r.name, i = t.rects.reference, n = t.rects.popper, s = t.modifiersData.preventOverflow, o = Nl(t, {
    elementContext: "reference"
  }), a = Nl(t, {
    altBoundary: !0
  }), l = a0(o, i), u = a0(a, n, s), c = h0(l), d = h0(u);
  t.modifiersData[e] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: u,
    isReferenceHidden: c,
    hasPopperEscaped: d
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": c,
    "data-popper-escaped": d
  });
}
const GM = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: UM
};
function jM(r, t, e) {
  var i = gr(r), n = [di, fi].indexOf(i) >= 0 ? -1 : 1, s = typeof e == "function" ? e(Object.assign({}, t, {
    placement: r
  })) : e, o = s[0], a = s[1];
  return o = o || 0, a = (a || 0) * n, [di, qi].indexOf(i) >= 0 ? {
    x: a,
    y: o
  } : {
    x: o,
    y: a
  };
}
function HM(r) {
  var t = r.state, e = r.options, i = r.name, n = e.offset, s = n === void 0 ? [0, 0] : n, o = ow.reduce(function(c, d) {
    return c[d] = jM(d, t.rects, s), c;
  }, {}), a = o[t.placement], l = a.x, u = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += u), t.modifiersData[i] = o;
}
const $M = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: HM
};
function zM(r) {
  var t = r.state, e = r.name;
  t.modifiersData[e] = dw({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const VM = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: zM,
  data: {}
};
function XM(r) {
  return r === "x" ? "y" : "x";
}
function WM(r) {
  var t = r.state, e = r.options, i = r.name, n = e.mainAxis, s = n === void 0 ? !0 : n, o = e.altAxis, a = o === void 0 ? !1 : o, l = e.boundary, u = e.rootBoundary, c = e.altBoundary, d = e.padding, f = e.tether, v = f === void 0 ? !0 : f, m = e.tetherOffset, p = m === void 0 ? 0 : m, y = Nl(t, {
    boundary: l,
    rootBoundary: u,
    padding: d,
    altBoundary: c
  }), b = gr(t.placement), w = Gh(t.placement), E = !w, O = L_(b), I = XM(O), S = t.modifiersData.popperOffsets, C = t.rects.reference, P = t.rects.popper, R = typeof p == "function" ? p(Object.assign({}, t.rects, {
    placement: t.placement
  })) : p, N = typeof R == "number" ? {
    mainAxis: R,
    altAxis: R
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, R), F = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, $ = {
    x: 0,
    y: 0
  };
  if (S) {
    if (s) {
      var q, ht = O === "y" ? fi : di, V = O === "y" ? Yi : qi, H = O === "y" ? "height" : "width", Q = S[O], mt = Q + y[ht], et = Q - y[V], Tt = v ? -P[H] / 2 : 0, it = w === Fh ? C[H] : P[H], we = w === Fh ? -P[H] : -C[H], Bt = t.elements.arrow, Dt = v && Bt ? A_(Bt) : {
        width: 0,
        height: 0
      }, Ut = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : lw(), k = Ut[ht], zt = Ut[V], lt = _l(0, C[H], Dt[H]), me = E ? C[H] / 2 - Tt - lt - k - N.mainAxis : it - lt - k - N.mainAxis, jt = E ? -C[H] / 2 + Tt + lt + zt + N.mainAxis : we + lt + zt + N.mainAxis, Z = t.elements.arrow && Nc(t.elements.arrow), be = Z ? O === "y" ? Z.clientTop || 0 : Z.clientLeft || 0 : 0, ft = (q = F == null ? void 0 : F[O]) != null ? q : 0, B = Q + me - ft - be, at = Q + jt - ft, Et = _l(v ? od(mt, B) : mt, Q, v ? Xo(et, at) : et);
      S[O] = Et, $[O] = Et - Q;
    }
    if (a) {
      var U, Re = O === "x" ? fi : di, pi = O === "x" ? Yi : qi, ke = S[I], ki = I === "y" ? "height" : "width", Ni = ke + y[Re], ri = ke - y[pi], Sr = [fi, di].indexOf(b) !== -1, Ee = (U = F == null ? void 0 : F[I]) != null ? U : 0, ce = Sr ? Ni : ke - C[ki] - P[ki] - Ee + N.altAxis, Vt = Sr ? ke + C[ki] + P[ki] - Ee - N.altAxis : ri, Rt = v && Sr ? mM(ce, ke, Vt) : _l(v ? ce : Ni, ke, v ? Vt : ri);
      S[I] = Rt, $[I] = Rt - ke;
    }
    t.modifiersData[i] = $;
  }
}
const YM = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: WM,
  requiresIfExists: ["offset"]
};
function qM(r) {
  return {
    scrollLeft: r.scrollLeft,
    scrollTop: r.scrollTop
  };
}
function ZM(r) {
  return r === Ri(r) || !Mi(r) ? D_(r) : qM(r);
}
function KM(r) {
  var t = r.getBoundingClientRect(), e = Bh(t.width) / r.offsetWidth || 1, i = Bh(t.height) / r.offsetHeight || 1;
  return e !== 1 || i !== 1;
}
function JM(r, t, e) {
  e === void 0 && (e = !1);
  var i = Mi(t), n = Mi(t) && KM(t), s = gs(t), o = Uh(r, n, e), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (i || !i && !e) && ((Jr(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  B_(s)) && (a = ZM(t)), Mi(t) ? (l = Uh(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : s && (l.x = F_(s))), {
    x: o.left + a.scrollLeft - l.x,
    y: o.top + a.scrollTop - l.y,
    width: o.width,
    height: o.height
  };
}
function QM(r) {
  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), i = [];
  r.forEach(function(s) {
    t.set(s.name, s);
  });
  function n(s) {
    e.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function(a) {
      if (!e.has(a)) {
        var l = t.get(a);
        l && n(l);
      }
    }), i.push(s);
  }
  return r.forEach(function(s) {
    e.has(s.name) || n(s);
  }), i;
}
function tR(r) {
  var t = QM(r);
  return Sm.reduce(function(e, i) {
    return e.concat(t.filter(function(n) {
      return n.phase === i;
    }));
  }, []);
}
function eR(r) {
  var t;
  return function() {
    return t || (t = new Promise(function(e) {
      Promise.resolve().then(function() {
        t = void 0, e(r());
      });
    })), t;
  };
}
function Hn(r) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    e[i - 1] = arguments[i];
  return [].concat(e).reduce(function(n, s) {
    return n.replace(/%s/, s);
  }, r);
}
var Ss = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', iR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', l0 = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function rR(r) {
  r.forEach(function(t) {
    [].concat(Object.keys(t), l0).filter(function(e, i, n) {
      return n.indexOf(e) === i;
    }).forEach(function(e) {
      switch (e) {
        case "name":
          typeof t.name != "string" && console.error(Hn(Ss, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"'));
          break;
        case "enabled":
          typeof t.enabled != "boolean" && console.error(Hn(Ss, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"'));
          break;
        case "phase":
          Sm.indexOf(t.phase) < 0 && console.error(Hn(Ss, t.name, '"phase"', "either " + Sm.join(", "), '"' + String(t.phase) + '"'));
          break;
        case "fn":
          typeof t.fn != "function" && console.error(Hn(Ss, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "effect":
          t.effect != null && typeof t.effect != "function" && console.error(Hn(Ss, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "requires":
          t.requires != null && !Array.isArray(t.requires) && console.error(Hn(Ss, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(t.requiresIfExists) || console.error(Hn(Ss, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + l0.map(function(i) {
            return '"' + i + '"';
          }).join(", ") + '; but "' + e + '" was provided.');
      }
      t.requires && t.requires.forEach(function(i) {
        r.find(function(n) {
          return n.name === i;
        }) == null && console.error(Hn(iR, String(t.name), i, i));
      });
    });
  });
}
function nR(r, t) {
  var e = /* @__PURE__ */ new Set();
  return r.filter(function(i) {
    var n = t(i);
    if (!e.has(n))
      return e.add(n), !0;
  });
}
function sR(r) {
  var t = r.reduce(function(e, i) {
    var n = e[i.name];
    return e[i.name] = n ? Object.assign({}, n, i, {
      options: Object.assign({}, n.options, i.options),
      data: Object.assign({}, n.data, i.data)
    }) : i, e;
  }, {});
  return Object.keys(t).map(function(e) {
    return t[e];
  });
}
var u0 = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", oR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", c0 = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function f0() {
  for (var r = arguments.length, t = new Array(r), e = 0; e < r; e++)
    t[e] = arguments[e];
  return !t.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function aR(r) {
  r === void 0 && (r = {});
  var t = r, e = t.defaultModifiers, i = e === void 0 ? [] : e, n = t.defaultOptions, s = n === void 0 ? c0 : n;
  return function(a, l, u) {
    u === void 0 && (u = s);
    var c = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, c0, s),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, d = [], f = !1, v = {
      state: c,
      setOptions: function(b) {
        var w = typeof b == "function" ? b(c.options) : b;
        p(), c.options = Object.assign({}, s, c.options, w), c.scrollParents = {
          reference: Jo(a) ? gl(a) : a.contextElement ? gl(a.contextElement) : [],
          popper: gl(l)
        };
        var E = tR(sR([].concat(i, c.options.modifiers)));
        if (c.orderedModifiers = E.filter(function(F) {
          return F.enabled;
        }), process.env.NODE_ENV !== "production") {
          var O = nR([].concat(E, c.options.modifiers), function(F) {
            var $ = F.name;
            return $;
          });
          if (rR(O), gr(c.options.placement) === Dv) {
            var I = c.orderedModifiers.find(function(F) {
              var $ = F.name;
              return $ === "flip";
            });
            I || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var S = Er(l), C = S.marginTop, P = S.marginRight, R = S.marginBottom, N = S.marginLeft;
          [C, P, R, N].some(function(F) {
            return parseFloat(F);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return m(), v.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var b = c.elements, w = b.reference, E = b.popper;
          if (!f0(w, E)) {
            process.env.NODE_ENV !== "production" && console.error(u0);
            return;
          }
          c.rects = {
            reference: JM(w, Nc(E), c.options.strategy === "fixed"),
            popper: A_(E)
          }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(F) {
            return c.modifiersData[F.name] = Object.assign({}, F.data);
          });
          for (var O = 0, I = 0; I < c.orderedModifiers.length; I++) {
            if (process.env.NODE_ENV !== "production" && (O += 1, O > 100)) {
              console.error(oR);
              break;
            }
            if (c.reset === !0) {
              c.reset = !1, I = -1;
              continue;
            }
            var S = c.orderedModifiers[I], C = S.fn, P = S.options, R = P === void 0 ? {} : P, N = S.name;
            typeof C == "function" && (c = C({
              state: c,
              options: R,
              name: N,
              instance: v
            }) || c);
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: eR(function() {
        return new Promise(function(y) {
          v.forceUpdate(), y(c);
        });
      }),
      destroy: function() {
        p(), f = !0;
      }
    };
    if (!f0(a, l))
      return process.env.NODE_ENV !== "production" && console.error(u0), v;
    v.setOptions(u).then(function(y) {
      !f && u.onFirstUpdate && u.onFirstUpdate(y);
    });
    function m() {
      c.orderedModifiers.forEach(function(y) {
        var b = y.name, w = y.options, E = w === void 0 ? {} : w, O = y.effect;
        if (typeof O == "function") {
          var I = O({
            state: c,
            name: b,
            instance: v,
            options: E
          }), S = function() {
          };
          d.push(I || S);
        }
      });
    }
    function p() {
      d.forEach(function(y) {
        return y();
      }), d = [];
    }
    return v;
  };
}
var hR = [OM, VM, SM, pM, $M, BM, YM, xM, GM], lR = /* @__PURE__ */ aR({
  defaultModifiers: hR
});
const { GamepadListener: uR } = require("gamepad.js");
var ei, as, Fe, Yu, qu, Im, Zu, Cm, Ku, Mm, yh, mh, Ju, Rm, he, Hi, Tn, Sn, Qu, hs, la, tc, ec, We, _h, gh, ic, Up, pw, rc, Eo, Gp, vw, nc, km, jp, yw, sc, Nm, To, ll, So, Hp, mw, $p, _w, $i, zp, gw, Vp, bw, bh, Lf, Pn, Po, Oo, Xp, xw, ii;
class cR {
  constructor(t, e, i, n, s, o, a, l, u) {
    _(this, qu);
    _(this, Zu);
    _(this, Ku);
    _(this, Ju);
    _(this, hs);
    _(this, Up);
    // イベントを全消去
    _(this, Gp);
    _(this, nc);
    // イベントを予約
    _(this, jp);
    _(this, sc);
    _(this, To);
    // 行末クリック待ち
    _(this, Hp);
    // 改ページクリック待ち
    _(this, $p);
    _(this, zp);
    // フォーカス移動
    _(this, Vp);
    // ウェイトを入れる
    _(this, bh);
    // クリックを待つ
    _(this, Xp);
    _(this, ei, new Dh());
    _(this, as, new uR({
      analog: !1,
      deadZone: 0.3
    }));
    _(this, Fe, new tM());
    _(this, Yu, (t) => {
    });
    _(this, yh, !1);
    _(this, mh, !1);
    _(this, he, {});
    _(this, Hi, {});
    _(this, Tn, !1);
    _(this, Sn, !1);
    // 予約イベントの発生待ち中か
    _(this, Qu, (t) => h(this, he)[t] ?? h(this, Hi)[t]);
    _(this, tc, () => {
      g(this, tc, () => {
      }), this.scrItr.firstWait();
    });
    _(this, ec, {
      getBoundingClientRect: (t = 0, e = 0) => DOMRect.fromRect({ x: t, y: e, width: 0, height: 0 })
    });
    _(this, We, void 0);
    _(this, _h, void 0);
    _(this, gh, void 0);
    _(this, ic, {
      placement: "bottom",
      fallbackPlacements: ["top", "bottom"]
    });
    _(this, rc, (t, e) => {
    });
    _(this, Eo, new Dh());
    _(this, So, () => this.layMng.goTxt());
    // スキップ中断予約
    _(this, $i, () => !1);
    _(this, Pn, () => {
    });
    _(this, Po, new Zi());
    _(this, Oo, "sn:notice_comp_txt");
    // 0:no push  1:one push  2:push repeating
    _(this, ii, {
      Alt: 0,
      Meta: 0,
      // COMMANDキー
      Control: 0,
      ArrowDown: 0,
      End: 0,
      Enter: 0,
      Escape: 0,
      " ": 0,
      GoBack: 0
      // AndroidのBackキーだと思う
    });
    var p, y;
    if (this.cfg = t, this.hTag = e, this.appPixi = i, this.main = n, this.layMng = s, this.val = o, this.sndMng = a, this.scrItr = l, this.sys = u, e.clear_event = (b) => x(this, Gp, vw).call(this, b), e.event = (b) => x(this, jp, yw).call(this, b), e.l = (b) => x(this, Hp, mw).call(this, b), e.p = (b) => x(this, $p, _w).call(this, b), e.s = () => (l.recodePage(), x(this, hs, la).call(this, () => {
    }, !1, !0)), e.set_cancel_skip = () => x(this, zp, gw).call(this), e.set_focus = (b) => x(this, Vp, bw).call(this, b), e.wait = (b) => x(this, bh, Lf).call(this, b), e.waitclick = () => x(this, Xp, xw).call(this), a.setEvtMng(this), l.setOtherObj(this, s), ne.setEvtMng(n, this, u), s.setEvtMng(this), u.setFire((b, w) => this.fire(b, w)), L.isDbg) {
      const b = {
        pause: () => {
          if (g(this, Tn, !0), !h(this, Sn))
            return;
          const w = {};
          l.recodeDesign(w), u.callHook("_enterDesign", w), u.send2Dbg("_enterDesign", w);
        },
        stopOnBreakpoint: () => g(this, Tn, !0),
        stopOnDataBreakpoint: () => g(this, Tn, !0),
        continue: () => g(this, Tn, !1),
        disconnect: () => g(this, Tn, !1)
      };
      b.attach = b.stopOnEntry = b.stopOnStep = b.stopOnStepIn = b.stopOnStepOut = b.stopOnBackstep = b.pause, u.addHook((w) => {
        var E;
        return (E = b[w]) == null ? void 0 : E.call(b);
      });
    }
    ba(`
.sn_hint {
	background-color: #3c3225;
	color: white;
	padding: 4px 8px;
	border-radius: 4px;
	font-size: 1.2em;
	z-index: 10000;
	pointer-events: none;
	user-select: none;
}

.sn_hint_ar,
.sn_hint_ar::before {
	position: absolute;
	width: 8px;
	height: 8px;
	background: inherit;
}
.sn_hint_ar {
	visibility: hidden;
}
.sn_hint_ar::before {
	visibility: visible;
	content: '';
	transform: rotate(45deg);
}

.sn_hint[data-popper-placement^='top']		> .sn_hint_ar {bottom: -4px;}
.sn_hint[data-popper-placement^='bottom']	> .sn_hint_ar {top: -4px;}
.sn_hint[data-popper-placement^='left']		> .sn_hint_ar {right: -4px;}
.sn_hint[data-popper-placement^='right']	> .sn_hint_ar {left: -4px;}
`);
    for (const b of Array.from(document.getElementsByClassName("sn_hint")))
      (p = b.parentElement) == null || p.removeChild(b);
    (y = ui.cvs.parentElement) == null || y.insertAdjacentHTML("beforeend", `
<div class="sn_hint" role="tooltip">
	<span>Dummy</span>
	<div class="sn_hint_ar" data-popper-arrow></div>
</div>`), g(this, We, document.querySelector(".sn_hint")), g(this, _h, h(this, We).querySelector("span")), g(this, gh, lR(h(this, ec), h(this, We))), h(this, We).hidden = !0, i.stage.interactive = !0, L.isMobile ? i.stage.on("pointerdown", (b) => this.fire("click", b)) : h(this, ei).add(i.stage, "pointerdown", (b) => {
      switch (b.data.button) {
        case 0:
          this.fire("click", b);
          break;
        case 1:
          this.fire("middleclick", b);
          break;
      }
    }), h(this, ei).add(window, "keydown", (b) => x(this, qu, Im).call(this, b)), h(this, ei).add(ui.cvs, "contextmenu", (b) => x(this, Zu, Cm).call(this, b));
    const c = () => o.setVal_Nochk("tmp", "const.sn.navigator.language", navigator.language);
    h(this, ei).add(window, "languagechange", (b) => {
      c(), this.fire("sn:chgNavLang", b), z0();
    }), c();
    const d = (b) => {
      L.isDarkMode = b.matches, o.setVal_Nochk("tmp", "const.sn.isDarkMode", L.isDarkMode);
    }, f = globalThis.matchMedia("(prefers-color-scheme: dark)");
    d(f), h(this, ei).add(f, "change", (b) => {
      d(b), this.fire("sn:chgDarkMode", b);
    }), "WheelEvent" in window && (h(this, ei).add(ui.cvs, "wheel", (b) => x(this, Ku, Mm).call(this, b), { passive: !0 }), g(this, Yu, (b) => h(this, ei).add(b, "wheel", (w) => x(this, Ku, Mm).call(this, w), { passive: !0 })), g(this, rc, (b, w) => b.add(ui.cvs, "wheel", (E) => {
      E.isComposing || E.deltaY <= 0 || (E.stopPropagation(), w());
    }))), L.debugLog && (h(this, as).on("gamepad:connected", (b) => console.log(`👺<'gamepad:connected' index:${b.detail.index} id:${b.detail.gamepad.id}`)), h(this, as).on("gamepad:disconnected", (b) => console.log(`👺<'gamepad:disconnected' index:${b.detail.index} id:${b.detail.gamepad.id}`)));
    const v = [
      "",
      "ArrowUp",
      "",
      // '7', '8', '9',
      "ArrowLeft",
      "",
      "ArrowRight",
      // '4', '5', '6',
      "",
      "ArrowDown",
      ""
      // '1', '2', '3',
    ], m = [0, 0];
    h(this, as).on("gamepad:axis", (b) => {
      if (!document.hasFocus() || b.detail.stick !== 0)
        return;
      m[b.detail.axis] = b.detail.value;
      const w = (m[1] + 1) * 3 + (m[0] + 1), E = v[w];
      if (!E)
        return;
      const O = h(this, Fe).getFocus();
      (!O || O instanceof Qt ? globalThis : O).dispatchEvent(new KeyboardEvent("keydown", { key: E, bubbles: !0 })), !(!O || O instanceof Qt) && O.getAttribute("type") === "range" && O.dispatchEvent(new InputEvent("input", { bubbles: !0 }));
    }), h(this, as).on("gamepad:button", (b) => {
      if (document.hasFocus())
        if (b.detail.button % 2 === 0) {
          const w = h(this, Fe).getFocus();
          (!w || w instanceof Qt ? globalThis : w).dispatchEvent(new KeyboardEvent("keydown", { key: "Enter", bubbles: !0 }));
        } else
          ui.cvs.dispatchEvent(new Event("contextmenu"));
    }), h(this, as).start(), h(this, ei).add(window, "keyup", (b) => {
      b.isComposing || b.key in h(this, ii) && (h(this, ii)[b.key] = 0);
    }), o.defTmp("const.sn.key.alternate", () => h(this, ii).Alt > 0), o.defTmp("const.sn.key.command", () => h(this, ii).Meta > 0), o.defTmp("const.sn.key.control", () => h(this, ii).Control > 0), o.defTmp("const.sn.key.end", () => h(this, ii).End > 0), o.defTmp("const.sn.key.escape", () => h(this, ii).Escape > 0), o.defTmp("const.sn.key.back", () => h(this, ii).GoBack > 0);
  }
  resvFlameEvent(t) {
    h(this, ei).add(t, "keydown", (e) => x(this, qu, Im).call(this, e)), h(this, ei).add(t, "contextmenu", (e) => x(this, Zu, Cm).call(this, e)), h(this, Yu).call(this, t);
  }
  destroy() {
    h(this, Fe).destroy(), h(this, ei).clear();
  }
  fire(t, e) {
    var s;
    if (h(this, $i).call(this) || !h(this, Sn) || h(this, Tn))
      return;
    const i = t.toLowerCase();
    if (L.debugLog && console.log(`👺 fire<(key:\`${i}\` type:${e.type} e:%o)`, { ...e }), i === "enter") {
      const o = h(this, Fe).getFocus();
      if (o instanceof Qt) {
        o.emit("pointerdown", new Event("pointerdown"));
        return;
      }
    }
    const n = h(this, Qu).call(this, i);
    if (!n) {
      i.slice(0, 5) === "swipe" && globalThis.scrollBy(
        -e.deltaX,
        -e.deltaY
      );
      return;
    }
    i.slice(-5) !== "wheel" && ((s = e.preventDefault) == null || s.call(e)), e.stopPropagation(), !(i.slice(0, 4) !== "dom=" && this.layMng.clickTxtLay()) && (g(this, Sn, !1), n(e));
  }
  popLocalEvts() {
    const t = h(this, he);
    return g(this, he, {}), t;
  }
  pushLocalEvts(t) {
    g(this, he, t);
  }
  waitEvent(t, e = !0, i = !1) {
    if (e && i)
      throw "canskipとglobalを同時にtrue指定できません";
    if (this.val.getVal("tmp:sn.skip.enabled")) {
      if (this.val.getVal("tmp:sn.skip.all") || this.scrItr.isNextKidoku)
        return t(), !1;
      h(this, $i).call(this);
    }
    return x(this, hs, la).call(this, t, e, i);
  }
  unButton(t) {
    h(this, Fe).remove(t);
  }
  button(t, e, i, n, s) {
    var d;
    !t.fn && !t.label && this.main.errScript("fnまたはlabelは必須です"), e.interactive = e.buttonMode = !0;
    const o = ((d = t.key) == null ? void 0 : d.toLowerCase()) ?? " ";
    t.fn || (t.fn = this.scrItr.scriptFn);
    const a = K(t, "global", !1);
    a ? h(this, Hi)[o] = () => this.main.resumeByJumpOrCall(t) : h(this, he)[o] = () => this.main.resumeByJumpOrCall(t), e.on("pointerdown", (f) => this.fire(o, f));
    const l = t.hint ? () => x(this, Up, pw).call(this, t, e) : () => {
    }, u = () => {
      i(), h(this, We).hidden = !0;
    }, c = () => (l(), n());
    if (e.on("pointerover", c), e.on("pointerout", () => {
      h(this, Fe).isFocus(e) ? c() : u();
    }), e.on("pointerdown", () => {
      h(this, We).hidden = !0;
      const f = h(this, Fe).getFocus();
      s(), f instanceof yr && f.normal();
    }), e.on(
      "pointerup",
      L.isMobile ? u : () => {
        h(this, Fe).isFocus(e) ? c() : u();
      }
    ), h(this, Fe).add(e, c, u), t.clickse && (this.cfg.searchPath(t.clickse, Xe.SOUND), e.on("pointerdown", () => {
      const f = { fn: t.clickse, join: !1 };
      t.clicksebuf && (f.buf = t.clicksebuf), this.hTag.playse(f);
    })), t.enterse && (this.cfg.searchPath(t.enterse, Xe.SOUND), e.on("pointerover", () => {
      const f = { fn: t.enterse, join: !1 };
      t.entersebuf && (f.buf = t.entersebuf), this.hTag.playse(f);
    })), t.leavese && (this.cfg.searchPath(t.leavese, Xe.SOUND), e.on("pointerout", () => {
      const f = { fn: t.leavese, join: !1 };
      t.leavesebuf && (f.buf = t.leavesebuf), this.hTag.playse(f);
    })), t.onenter) {
      const f = o + t.onenter.toLowerCase(), v = { fn: t.fn, label: t.onenter, call: !0, key: f };
      a ? h(this, Hi)[f] = () => this.main.resumeByJumpOrCall(v) : h(this, he)[f] = () => this.main.resumeByJumpOrCall(v), e.on("pointerover", (m) => this.fire(f, m));
    }
    if (t.onleave) {
      const f = o + t.onleave.toLowerCase(), v = { fn: t.fn, label: t.onleave, call: !0, key: f };
      a ? h(this, Hi)[f] = () => this.main.resumeByJumpOrCall(v) : h(this, he)[f] = () => this.main.resumeByJumpOrCall(v), e.on("pointerout", (m) => this.fire(f, m));
    }
  }
  hideHint() {
    h(this, We).hidden = !0;
  }
  cvsResize() {
    h(this, We).hidden = !0;
  }
  // 予約イベントの発生待ちしない waitEvent()
  waitLimitedEvent(t, e) {
    h(this, So).call(this), this.val.saveKidoku();
    const i = () => {
      h(this, Eo).clear(), e();
    };
    if (this.val.getVal("tmp:sn.skip.enabled"))
      if (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
      !this.scrItr.isNextKidoku)
        h(this, $i).call(this);
      else
        return i(), !1;
    return K(t, "canskip", !0) && (h(this, Eo).add(window, "pointerdown", (n) => {
      n.stopPropagation(), i();
    }), h(this, Eo).add(window, "keydown", (n) => {
      n.isComposing || (n.stopPropagation(), i());
    }), h(this, rc).call(this, h(this, Eo), i)), !0;
  }
  noticeCompTxt() {
    h(this, Po).emit(h(this, Oo));
  }
  // キー押下によるスキップ中か
  isSkippingByKeyDown() {
    return this.scrItr.skip4page ? !0 : Object.keys(h(this, ii)).some((t) => h(this, ii)[t] === 2);
  }
}
ei = new WeakMap(), as = new WeakMap(), Fe = new WeakMap(), Yu = new WeakMap(), qu = new WeakSet(), Im = function(t) {
  if (t.isComposing)
    return;
  t.key in h(this, ii) && (h(this, ii)[t.key] = t.repeat ? 2 : 1);
  const e = (t.altKey ? t.key === "Alt" ? "" : "alt+" : "") + (t.ctrlKey ? t.key === "Control" ? "" : "ctrl+" : "") + (t.shiftKey ? t.key === "Shift" ? "" : "shift+" : "") + t.key;
  this.fire(e, t);
}, Zu = new WeakSet(), Cm = function(t) {
  const e = (t.altKey ? t.key === "Alt" ? "" : "alt+" : "") + (t.ctrlKey ? t.key === "Control" ? "" : "ctrl+" : "") + (t.shiftKey ? t.key === "Shift" ? "" : "shift+" : "") + "rightclick";
  this.fire(e, t), t.preventDefault();
}, Ku = new WeakSet(), Mm = function(t) {
  if (t.isComposing)
    return;
  if (h(this, yh)) {
    g(this, mh, !0);
    return;
  }
  g(this, yh, !0), x(this, Ju, Rm).call(this);
  const e = (t.altKey ? "alt+" : "") + (t.ctrlKey ? "ctrl+" : "") + (t.shiftKey ? "shift+" : "") + (t.deltaY > 0 ? "downwheel" : "upwheel");
  this.fire(e, t);
}, yh = new WeakMap(), mh = new WeakMap(), Ju = new WeakSet(), Rm = function() {
  setTimeout(() => {
    if (h(this, mh)) {
      g(this, mh, !1), x(this, Ju, Rm).call(this);
      return;
    }
    g(this, yh, !1);
  }, 250);
}, he = new WeakMap(), Hi = new WeakMap(), Tn = new WeakMap(), Sn = new WeakMap(), Qu = new WeakMap(), hs = new WeakSet(), la = function(t, e = !0, i = !0) {
  if (h(this, So).call(this), this.val.saveKidoku(), e ? h(this, he).click = //this.hTag.event({key:'enter', breakout: fnc});
  //hTag.event({key:'down', breakout: fnc});
  //	hTag.event()は内部で使わず、こうする
  h(this, he).enter = h(this, he).arrowdown = // hTag.event({key:'downwheel', breakout: fnc});
  //	hTag.event()は内部で使わず、こうする
  h(this, he)["wheel.y>0"] = t : (delete h(this, he).click, delete h(this, he).enter, delete h(this, he).arrowdown, delete h(this, he)["wheel.y>0"]), g(this, Qu, i ? (n) => h(this, he)[n] ?? h(this, Hi)[n] : (n) => h(this, he)[n]), g(this, Sn, !0), h(this, tc).call(this), L.debugLog) {
    const n = /* @__PURE__ */ Object.create(null);
    n.local = Object.keys(h(this, he)), n.global = Object.keys(h(this, Hi)), console.log("🎍 wait event... %o", n);
  }
  return !0;
}, tc = new WeakMap(), ec = new WeakMap(), We = new WeakMap(), _h = new WeakMap(), gh = new WeakMap(), ic = new WeakMap(), Up = new WeakSet(), pw = function(t, e) {
  const i = e instanceof yr ? e.getBtnBounds() : e.getBounds();
  if (!(t[":タグ名"] === "link")) {
    const s = e.parent.parent;
    i.x += s.x, i.y += s.y;
  }
  if (!t.hint) {
    h(this, We).hidden = !0;
    return;
  }
  h(this, We).style.cssText = `position:${h(this, We).style.position}; transform:${h(this, We).style.transform};` + (t.hint_style ?? ""), h(this, _h).style.cssText = "", h(this, _h).textContent = t.hint ?? "";
  try {
    const s = t.hint_opt ? { ...h(this, ic), ...JSON.parse(t.hint_opt) } : h(this, ic);
    h(this, gh).setOptions(s);
  } catch (s) {
    console.error(cf(t, "hint_opt", s.message));
  }
  h(this, ec).getBoundingClientRect = () => DOMRect.fromRect({
    x: this.sys.ofsLeft4elm + i.x * this.sys.cvsScale,
    y: this.sys.ofsTop4elm + i.y * this.sys.cvsScale,
    width: i.width,
    height: i.height
  }), h(this, gh).update(), h(this, We).hidden = !1;
}, rc = new WeakMap(), Eo = new WeakMap(), Gp = new WeakSet(), vw = function(t) {
  const e = K(t, "global", !1), i = e ? h(this, Hi) : h(this, he);
  for (const [n, s] of Object.entries(i))
    x(this, nc, km).call(this, n, s);
  return e ? g(this, Hi, {}) : g(this, he, {}), g(this, Sn, !1), !1;
}, nc = new WeakSet(), km = function(t, e) {
  t.slice(0, 4) === "dom=" && x(this, To, ll).call(this, t).el.forEach((i) => i.removeEventListener("click", e));
}, jp = new WeakSet(), yw = function(t) {
  const e = t.key;
  if (!e)
    throw "keyは必須です";
  const i = e.toLowerCase(), n = K(t, "call", !1), s = K(t, "global", !1) ? h(this, Hi) : h(this, he);
  if (K(t, "del", !1)) {
    if (t.fn || t.label || n)
      throw "fn/label/callとdelは同時指定できません";
    return x(this, nc, km).call(this, e, s[i]), delete s[i], !1;
  }
  if (t.fn ?? (t.fn = this.scrItr.scriptFn), e.slice(0, 4) === "dom=") {
    const o = x(this, To, ll).call(this, e);
    if (o.el.length === 0) {
      if (K(t, "need_err", !0))
        throw `HTML内にセレクタ（${o.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;
      return !1;
    }
    let a = ["click", "keydown"];
    switch (o.el[0].type ?? "") {
      case "checkbox":
        a = ["input"];
        break;
      case "range":
        a = ["input"];
        break;
      case "text":
      case "textarea":
        a = ["input", "change"];
        break;
    }
    a.forEach((u, c) => o.el.forEach((d) => {
      h(this, ei).add(d, u, (f) => {
        if (!h(this, Sn) || this.layMng.getFrmDisabled(o.id) || u === "keydown" && f.key !== "Enter")
          return;
        const v = d.dataset;
        for (const [m, p] of Object.entries(v))
          this.val.setVal_Nochk("tmp", `sn.event.domdata.${m}`, p);
        this.fire(e, f);
      }), c === 0 && h(this, Fe).add(
        d,
        () => x(this, sc, Nm).call(this, d) ? (d.focus(), !0) : !1,
        () => {
        }
      );
    }));
  }
  return s[i] = () => this.main.resumeByJumpOrCall(t), !1;
}, sc = new WeakSet(), Nm = function(t) {
  if (t.offsetParent === null)
    return !1;
  let e = t;
  do {
    if (getComputedStyle(e).display === "none" || e.dataset.focus === "false" || e != null && e.disabled)
      return !1;
    e = e.parentElement;
  } while (e !== null);
  return !0;
}, To = new WeakSet(), ll = function(t) {
  const e = t.indexOf(":");
  let i = "";
  if (e >= 0) {
    const n = t.slice(4, e), s = `const.sn.frm.${n}`;
    if (!this.val.getVal(`tmp:${s}`, 0))
      throw `HTML【${n}】が読み込まれていません`;
    const a = document.getElementById(n).contentWindow;
    return i = t.slice(e + 1), { el: a.document.querySelectorAll(i), id: n, sel: i };
  }
  return i = t.slice(4), { el: document.querySelectorAll(i), id: "", sel: i };
}, So = new WeakMap(), Hp = new WeakSet(), mw = function(t) {
  if (this.scrItr.skip4page)
    return !1;
  if (!this.val.getVal("tmp:sn.tagL.enabled"))
    return h(this, So).call(this), !1;
  if (this.val.getVal("tmp:sn.skip.enabled")) {
    if (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
    !this.scrItr.isNextKidoku)
      h(this, $i).call(this);
    else if ("ps".includes(this.val.getVal("sys:sn.skip.mode")))
      return !1;
  }
  return this.val.getVal("tmp:sn.auto.enabled") ? x(this, bh, Lf).call(this, {
    time: Number(this.scrItr.isKidoku ? this.val.getVal("sys:sn.auto.msecLineWait_Kidoku") : this.val.getVal("sys:sn.auto.msecLineWait"))
  }) : (K(t, "visible", !0) && this.layMng.breakLine(), x(this, hs, la).call(this, () => this.main.resume()));
}, $p = new WeakSet(), _w = function(t) {
  if (this.scrItr.recodePage(), this.val.getVal("tmp:sn.skip.enabled")) {
    if (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
    !this.scrItr.isNextKidoku)
      h(this, $i).call(this);
    else if (this.val.getVal("sys:sn.skip.mode") == "s")
      return h(this, So).call(this), !1;
  }
  if (this.val.getVal("tmp:sn.auto.enabled"))
    return x(this, bh, Lf).call(this, {
      time: Number(this.scrItr.isKidoku ? this.val.getVal("sys:sn.auto.msecPageWait_Kidoku") : this.val.getVal("sys:sn.auto.msecPageWait"))
    });
  K(t, "visible", !0) && this.layMng.breakPage();
  const e = () => {
    this.sndMng.clearCache(), this.main.resume();
  };
  return x(this, hs, la).call(this, K(t, "er", !1) && this.layMng.currentTxtlayFore ? () => {
    this.hTag.er(t), e();
  } : e);
}, $i = new WeakMap(), zp = new WeakSet(), gw = function() {
  return g(this, $i, () => (g(this, $i, () => !1), this.val.setVal_Nochk("tmp", "sn.tagL.enabled", !0), this.val.setVal_Nochk("tmp", "sn.skip.enabled", !1), this.val.setVal_Nochk("tmp", "sn.auto.enabled", !1), this.layMng.setNormalChWait(), h(this, Pn).call(this), !0)), !1;
}, Vp = new WeakSet(), bw = function(t) {
  const { add: e, del: i, to: n } = t;
  if ((e == null ? void 0 : e.slice(0, 4)) === "dom=") {
    const s = x(this, To, ll).call(this, e);
    if (s.el.length === 0 && K(t, "need_err", !0))
      throw `HTML内にセレクタ（${s.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;
    return s.el.forEach((o) => h(this, Fe).add(
      o,
      () => x(this, sc, Nm).call(this, o) ? (o.focus(), !0) : !1,
      () => {
      }
    )), !1;
  }
  if ((i == null ? void 0 : i.slice(0, 4)) === "dom=") {
    const s = x(this, To, ll).call(this, i);
    if (s.el.length === 0 && K(t, "need_err", !0))
      throw `HTML内にセレクタ（${s.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;
    return s.el.forEach((o) => h(this, Fe).remove(o)), !1;
  }
  if (!n)
    throw "[set_focus] add か to は必須です";
  switch (n) {
    case "null":
      h(this, Fe).blur();
      break;
    case "next":
      h(this, Fe).next();
      break;
    case "prev":
      h(this, Fe).prev();
      break;
  }
  return !1;
}, bh = new WeakSet(), Lf = function(t) {
  const e = j(t, "time", NaN);
  return this.scrItr.skip4page ? !1 : this.val.getVal("tmp:sn.skip.enabled") ? (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
  !this.scrItr.isNextKidoku && h(this, $i).call(this), !1) : (h(this, Po).once(h(this, Oo), () => {
    h(this, Po).off(h(this, Oo));
    const i = new zr({}).to({}, e).onComplete(() => {
      g(this, Pn, () => {
      }), i.stop(), this.main.resume();
    }).start();
    g(this, Pn, () => i.end());
  }), g(this, Pn, () => {
    g(this, Pn, () => {
    }), h(this, Po).off(h(this, Oo));
  }), this.waitEvent(
    () => h(this, Pn).call(this),
    K(t, "canskip", !0),
    // スキップ中は利かない
    K(t, "global", !1)
  ));
}, Pn = new WeakMap(), Po = new WeakMap(), Oo = new WeakMap(), Xp = new WeakSet(), xw = function() {
  return this.scrItr.skip4page ? !1 : ((this.val.getVal("tmp:sn.skip.enabled") || this.val.getVal("tmp:sn.auto.enabled")) && h(this, $i).call(this), x(this, hs, la).call(this, () => this.main.resume()));
}, ii = new WeakMap();
class d0 {
  constructor(t = "", e = 0, i = { ":hEvt1Time": {}, ":hMp": {} }) {
    D(this, "toString", () => `[fn:${this.fn}, idx:${this.idx}, csArg:${this.csArg}]`);
    this.fn = t, this.idx = e, this.csArg = i;
  }
}
var It, Ft, tt, Jt, Yt, On, oc, Am, Io, ls, Wp, us, ac, Lm, hc, Dm, lc, cs, ca, Co, ul, Mo, In, fe, Yp, ww, Ro, cl, qp, Ew, uc, xh, Ti, Zp, Tw, Kp, Sw, Cn, ks, Jp, Pw, ko, No, cc, fc, dc, Si, Qp, Ow, tv, Iw, ev, Cw, pc, Fm, iv, Mw, rv, Rw, nv, kw, vc, Bm, yc, Ao, fl, Lo, Mn, Ns, mc, Um, _c, gc, Gm, sv, ov, bc, av, Nw, He, hv, Aw, xc, jm, lv, uv, cv, Lw, fv, Dw, Rn, wc, Hm, dv, Fw, pv, Bw, vv, yv, Uw, Ec, wh, mv, Gw, Eh, Df, Th, _v, jw, cr, gv, Hw, Sh, Ff, bv, $w, fr, $e;
const _i = class {
  constructor(t, e, i, n, s, o, a, l, u) {
    _(this, oc);
    _(this, ac);
    _(this, hc);
    _(this, cs);
    _(this, Co);
    _(this, Yp);
    _(this, Ro);
    _(this, qp);
    //	//	変数操作
    // インラインテキスト代入
    _(this, Zp);
    //	// デバッグ・その他
    // スタックのダンプ
    _(this, Kp);
    _(this, Cn);
    // 外部へスクリプトを表示
    _(this, Jp);
    // FIFOバッファ（push/unshift）
    _(this, Qp);
    _(this, tv);
    //	// ラベル・ジャンプ
    // サブルーチンコール
    _(this, ev);
    _(this, pc);
    // シナリオジャンプ
    _(this, iv);
    // ページ移動
    _(this, rv);
    // コールスタック破棄
    _(this, nv);
    // サブルーチンから戻る
    _(this, vc);
    _(this, Ao);
    _(this, Mn);
    // 初期化前に終了した場合向け
    _(this, mc);
    _(this, gc);
    _(this, av);
    //{} シナリオキャッシュ
    _(this, hv);
    _(this, xc);
    _(this, cv);
    _(this, fv);
    _(this, wc);
    //	// マクロ
    // 括弧マクロの定義
    _(this, dv);
    // 一文字マクロの定義
    _(this, pv);
    _(this, yv);
    // https://regex101.com/r/Lk9ASK/1
    //	// しおり
    // しおりの読込
    _(this, mv);
    _(this, Eh);
    // スクリプト再読込
    _(this, _v);
    _(this, gv);
    _(this, Sh);
    // しおりの保存
    _(this, bv);
    _(this, It, { aToken: [""], len: 1, aLNum: [1] });
    _(this, Ft, "");
    _(this, tt, 0);
    _(this, Jt, 0);
    D(this, "addLineNum", (t) => g(this, Jt, h(this, Jt) + t));
    _(this, Yt, []);
    // FILOバッファ（push/pop）
    _(this, On, new MC());
    D(this, "firstWait", () => {
    });
    _(this, Io, {
      //auth: // constructorで
      //launch:	// ここでは冒頭停止に間に合わないのでanalyzeInit()で
      disconnect: () => {
        g(_i, Mo, {}), g(_i, In, {}), this.isBreak = () => !1, h(this, Io).continue({}), g(this, fe, 0);
      },
      restart: () => this.isBreak = () => !1,
      // ブレークポイント登録
      add_break: (t) => x(this, oc, Am).call(this, t.fn, t.o),
      data_break: (t) => {
        h(this, fe) === 0 && (g(this, fe, 1), this.main.setLoop(!1, `変数 ${t.dataId}【${t.old_v}】→【${t.new_v}】データブレーク`), this.sys.callHook("stopOnDataBreakpoint", {}), this.sys.send2Dbg("stopOnDataBreakpoint", {}));
      },
      set_func_break: (t) => {
        g(_i, In, {});
        for (const e of t.a)
          h(_i, In)[e.name] = 1;
        this.sys.send2Dbg(t.ri, {});
      },
      // 情報問い合わせ系
      stack: (t) => this.sys.send2Dbg(t.ri, { a: x(this, qp, Ew).call(this) }),
      eval: (t) => {
        this.sys.send2Dbg(t.ri, { v: this.prpPrs.parse(t.txt) });
      },
      // デバッガからの操作系
      continue: () => {
        x(this, Co, ul).call(this) || (g(this, tt, h(this, tt) - h(this, cs, ca)), g(this, fe, 3), this.main.setLoop(!0), this.main.resume());
      },
      stepover: (t) => x(this, ac, Lm).call(this, t),
      stepin: () => {
        if (x(this, Co, ul).call(this))
          return;
        const t = h(this, It).aToken[h(this, tt) - h(this, cs, ca)];
        this.sys.callHook(`stopOnStep${h(this, wh).test(t) ? "In" : ""}`, {}), g(this, tt, h(this, tt) - h(this, cs, ca)), g(this, fe, h(this, fe) === 1 ? 4 : 5), this.main.setLoop(!0), this.main.resume();
      },
      stepout: (t) => {
        x(this, Co, ul).call(this) || (h(this, Yt).length > 0 ? x(this, hc, Dm).call(this, !0) : x(this, ac, Lm).call(this, t));
      },
      pause: () => {
        g(this, fe, 4), this.main.setLoop(!1, "一時停止"), this.sys.send2Dbg("stopOnStep", {});
      },
      stopOnEntry: () => {
        g(this, fe, 4), this.main.setLoop(!1, "一時停止"), this.sys.send2Dbg("stopOnEntry", {});
      }
    });
    _(this, ls, (t) => this.cfg.searchPath(t, Xe.SCRIPT));
    // https://regex101.com/r/Km54EK/1 141 steps (~0ms)
    _(this, us, (t) => (this.sys.pathBaseCnvSnPath4Dbg + h(this, ls).call(this, t)).replace(h(_i, Wp), `$1/prj/$2/${h(this, Ft)}$3`));
    D(this, "cnvPath4Dbg", (t) => this.sys.pathBaseCnvSnPath4Dbg + t.replace("/crypto_prj/", "/prj/"));
    _(this, lc, 0);
    _(this, fe, 0);
    // https://raw.githubusercontent.com/famibee/SKYNovel-vscode-extension/master/src/doc/BreakStateSMD.pu
    D(this, "isBreak", (t) => !1);
    // result = true : waitする  resume()で再開
    _(this, uc, (t) => {
    });
    _(this, xh, void 0);
    _(this, Ti, void 0);
    _(this, ko, () => {
    });
    _(this, No, () => {
    });
    _(this, cc, "");
    _(this, fc, {});
    D(this, "noticeBreak", (t) => {
    });
    _(this, dc, 5);
    //	// 条件分岐
    _(this, Si, [-1]);
    _(this, yc, "");
    _(this, Lo, "");
    // シナリオ解析処理ループ・冒頭処理
    D(this, "nextToken", () => "");
    _(this, _c, (t) => {
    });
    _(this, sv, /(\*{2,})([^\|]*)/);
    _(this, ov, /\[macro\s/);
    _(this, bc, /\[endmacro[\s\]]/);
    _(this, He, /* @__PURE__ */ Object.create(null));
    _(this, lv, /^\[(call|loadplugin)\s/);
    _(this, uv, /\bfn\s*=\s*[^\s\]]+/);
    _(this, Rn, !1);
    // マクロ定義の開始
    _(this, vv, new RegExp(`["'#;\\]　]+`));
    _(this, Ec, "call");
    _(this, wh, /\[(call)\b/);
    _(this, Th, !1);
    // セーブポイント指定
    _(this, cr, {
      hSave: {},
      hPages: {},
      aIfStk: [-1]
    });
    _(this, fr, []);
    _(this, $e, -1);
    this.cfg = t, this.hTag = e, this.main = i, this.val = n, this.alzTagArg = s, this.runAnalyze = o, this.prpPrs = a, this.sndMng = l, this.sys = u, e.let_ml = (d) => x(this, Zp, Tw).call(this, d), e.endlet_ml = () => !1, e.dump_stack = () => x(this, Kp, Sw).call(this), e.dump_script = (d) => x(this, Jp, Pw).call(this, d), e.else = // その他ifブロック開始
    e.elsif = // 別条件のifブロック開始
    e.endif = () => x(this, Qp, Ow).call(this), e.if = (d) => x(this, tv, Iw).call(this, d), e.call = (d) => x(this, ev, Cw).call(this, d), e.jump = (d) => x(this, iv, Mw).call(this, d), e.page = (d) => x(this, rv, Rw).call(this, d), e.pop_stack = (d) => x(this, nv, kw).call(this, d), e.return = (d) => x(this, vc, Bm).call(this, d), e.bracket2macro = (d) => x(this, dv, Fw).call(this, d), e.char2macro = (d) => x(this, pv, Bw).call(this, d), e.endmacro = (d) => x(this, vc, Bm).call(this, d), e.macro = (d) => x(this, yv, Uw).call(this, d), e.load = (d) => x(this, mv, Gw).call(this, d), e.reload_script = (d) => x(this, _v, jw).call(this, d), e.record_place = () => x(this, gv, Hw).call(this), e.save = (d) => x(this, bv, $w).call(this, d), t.oCfg.debug.token && g(this, _c, (d) => console.log(`🌱 トークン fn:${h(this, Ft)} idx:${h(this, tt)} ln:${h(this, Jt)} token【${d}】`)), n.defTmp("const.sn.vctCallStk.length", () => h(this, Yt).length);
    const c = t.oCfg.init.escape;
    if (h(this, On).setEscape(c), ys.setEscape(c), L.isDbg) {
      u.addHook((f, v) => {
        var m, p;
        return (p = (m = h(this, Io))[f]) == null ? void 0 : p.call(m, v);
      }), this.isBreak = x(this, Yp, ww);
      const d = this.analyzeInit;
      this.analyzeInit = () => {
        this.analyzeInit = () => {
        }, this.sys.send2Dbg("hi", {});
      }, h(this, Io).auth = (f) => {
        const v = f.hBreakpoint.hFn2hLineBP;
        for (const [m, p] of Object.entries(v))
          x(this, oc, Am).call(this, m, p);
        g(_i, In, {});
        for (const m of f.hBreakpoint.aFunc)
          h(_i, In)[m.name] = 1;
        if (f.stopOnEntry) {
          for (; ; ) {
            let m = this.nextToken();
            if (!m)
              break;
            const p = m.charCodeAt(0);
            if (p === 91 || p === 38 || p === 42 && m.length === 1)
              break;
            p === 10 && g(this, Jt, h(this, Jt) + m.length);
          }
          this.sys.callHook("stopOnEntry", {}), this.analyzeInit = d, this.analyzeInit();
        } else
          this.firstWait = () => {
            this.sys.callHook("stopOnEntry", {});
          }, this.analyzeInit = d, this.analyzeInit();
      };
    } else
      this.recodeDesign = () => {
      };
    t.oCfg.debug.tag && g(this, uc, (d) => console.log(`🌲 タグ解析 fn:${h(this, Ft)} idx:${h(this, tt)} ln:${h(this, Jt)} [${d} %o]`, this.alzTagArg.hPrm));
  }
  get scriptFn() {
    return h(this, Ft);
  }
  subIdxToken() {
    --Te(this, tt)._;
  }
  get lineNum() {
    return h(this, Jt);
  }
  destroy() {
    this.isBreak = () => !1;
  }
  タグ解析(t) {
    const [e, i] = vf(t), n = this.hTag[e];
    if (!n)
      throw `未定義のタグ【${e}】です`;
    this.alzTagArg.parse(i), h(this, uc).call(this, e);
    const s = this.alzTagArg.hPrm;
    if (s.cond) {
      const l = s.cond.val;
      if (!l || l.at(0) === "&")
        throw "属性condは「&」が不要です";
      const u = this.prpPrs.parse(l), c = String(u);
      if (c === "null" || c === "undefined" || !u)
        return !1;
    }
    let o = {};
    const a = h(this, Yt).length;
    if (this.alzTagArg.isKomeParam) {
      if (a === 0)
        throw "属性「*」はマクロのみ有効です";
      o = { ...h(this, Yt)[h(this, Yt).length - 1].csArg };
    }
    o[":タグ名"] = e;
    for (const [l, { val: u, def: c }] of Object.entries(s)) {
      let d = u;
      if ((d == null ? void 0 : d.at(0)) === "%") {
        if (a === 0)
          throw "属性「%」はマクロ定義内でのみ使用できます（そのマクロの引数を示す簡略文法であるため）";
        const f = h(this, Yt)[h(this, Yt).length - 1].csArg[d.slice(1)];
        if (f) {
          o[l] = f;
          continue;
        }
        if (c === void 0 || c === "null")
          continue;
        d = c;
      }
      if (d = this.prpPrs.getValAmpersand(d ?? ""), d !== "undefined") {
        o[l] = d;
        continue;
      }
      c !== void 0 && (d = this.prpPrs.getValAmpersand(c), d !== "undefined" && (o[l] = d));
    }
    return n(o);
  }
  setOtherObj(t, e) {
    g(this, xh, t), g(this, Ti, e);
  }
  dumpErrForeLine() {
    if (h(this, tt) === 0) {
      console.group(`🥟 Error line (from 0 rows before) fn:${h(this, Ft)}`), console.groupEnd();
      return;
    }
    let t = "";
    for (let o = h(this, tt) - 1; o >= 0 && (t = h(this, It).aToken[o] + t, !((t.match(/\n/g) ?? []).length >= h(this, dc))); --o)
      ;
    const e = t.split(`
`).slice(-h(this, dc)), i = e.length;
    console.group(`🥟 Error line (from ${i} rows before) fn:${h(this, Ft)}`);
    const n = String(h(this, Jt)).length, s = x(this, Cn, ks).call(this, h(this, It), h(this, tt));
    for (let o = 0; o < i; ++o) {
      const a = h(this, Jt) - i + o + 1, l = `${String(a).padStart(n, " ")}: %c`, u = e[o], c = u.length > 75 ? u.slice(0, 75) + "…" : u;
      o === i - 1 ? console.info(
        l + c.slice(0, s.col_s) + "%c" + c.slice(s.col_s),
        "color: black; background-color: skyblue;",
        "color: black; background-color: pink;"
      ) : console.info(l + c, "color: black; background-color: skyblue;");
    }
    console.groupEnd();
  }
  analyzeInit() {
    const t = x(this, av, Nw).call(this, h(this, It), !!this.val.getVal("mp:const.sn.macro.name"), h(this, Jt), h(this, Lo), h(this, tt));
    g(this, tt, t.idx), g(this, Jt, t.ln), this.runAnalyze();
  }
  get isKidoku() {
    return h(this, Rn);
  }
  get isNextKidoku() {
    let t = h(this, Ft), e = h(this, tt), i = h(this, It).len;
    if (h(this, Yt).length > 0) {
      const s = h(this, Yt)[0];
      t = s.fn, e = s.idx;
      const o = h(this, He)[t];
      o && (i = o.len);
    }
    const n = this.val.getAreaKidoku(t);
    return !n || e === i ? !1 : n.search(e);
  }
  get normalWait() {
    return h(this, Rn) ? this.val.getVal("sys:sn.tagCh.doWait_Kidoku") ? mr(this.val.getVal("sys:sn.tagCh.msecWait_Kidoku")) : 0 : this.val.getVal("sys:sn.tagCh.doWait") ? mr(this.val.getVal("sys:sn.tagCh.msecWait")) : 0;
  }
  get skip4page() {
    return h(this, Th);
  }
  recodePage() {
    if (g(this, Th, !1), !this.val.getVal("save:sn.doRecLog"))
      return;
    const { fn: t, idx: e } = x(this, Sh, Ff).call(this), i = e - 1, n = i + ":" + t, s = h(this, fr).findIndex((a) => a.key === n);
    if (s > -1) {
      g(this, $e, s);
      return;
    }
    const o = {
      key: n,
      fn: t,
      idx: i,
      retFn: t,
      retIdx: 0,
      retMark: { ...h(this, cr) }
    };
    if (h(this, $e) >= 0) {
      const a = h(this, fr)[h(this, $e)];
      o.retFn = a.fn, o.retIdx = a.idx + 1;
    }
    ++Te(this, $e)._ === h(this, fr).length ? h(this, fr).push(o) : h(this, fr)[h(this, $e)] = o;
  }
  recodeDesign(t) {
    let e = "", i = 0;
    const n = h(this, Yt).length;
    if (t.design_unit && n > 0) {
      const a = h(this, Yt)[0];
      e = a.fn, i = a.idx;
    } else
      e = h(this, Ft), i = h(this, tt);
    t[":path"] = h(this, us).call(this, e);
    const s = x(this, Cn, ks).call(this, h(this, He)[e], i);
    t[":ln"] = s.ln, t[":col_s"] = s.col_s, t[":col_e"] = s.col_e;
    const o = i - 1;
    t[":idx_tkn"] = o, t[":token"] = h(this, He)[e].aToken[o], this.sys.send2Dbg("_recodeDesign", t);
  }
  replace(t, e) {
    h(this, It).aToken[t] = e;
  }
};
let ua = _i;
It = new WeakMap(), Ft = new WeakMap(), tt = new WeakMap(), Jt = new WeakMap(), Yt = new WeakMap(), On = new WeakMap(), oc = new WeakSet(), Am = function(t, e) {
  h(_i, Mo)[h(this, us).call(this, t)] = e;
}, Io = new WeakMap(), ls = new WeakMap(), Wp = new WeakMap(), us = new WeakMap(), ac = new WeakSet(), Lm = function(t) {
  if (x(this, Co, ul).call(this))
    return;
  const e = h(this, It).aToken[h(this, tt) - h(this, cs, ca)];
  h(this, wh).test(e) ? x(this, hc, Dm).call(this, !1) : (this.sys.callHook("stopOnStep", {}), h(this, Io).stepin(t));
}, hc = new WeakSet(), Dm = function(t) {
  this.sys.callHook(`stopOnStep${t ? "Out" : ""}`, {}), g(this, lc, h(this, Yt).length - (t ? 1 : 0)), g(this, tt, h(this, tt) - h(this, cs, ca)), g(this, fe, t ? 7 : 6), this.main.setLoop(!0), this.main.resume();
}, lc = new WeakMap(), cs = new WeakSet(), ca = function() {
  return h(this, fe) === 2 || h(this, fe) === 4 ? 1 : 0;
}, Co = new WeakSet(), ul = function() {
  return h(this, tt) < h(this, It).len ? !1 : (this.sys.callHook("stopOnEntry", {}), this.main.setLoop(!1, "スクリプト終端です"), !0);
}, Mo = new WeakMap(), In = new WeakMap(), fe = new WeakMap(), Yp = new WeakSet(), ww = function(t) {
  switch (h(this, fe)) {
    case 6:
      x(this, Ro, cl).call(this), g(this, fe, 7);
      break;
    case 7:
      if (h(this, Yt).length !== h(this, lc))
        break;
      return g(this, fe, 4), this.main.setLoop(!1, "ステップ実行"), this.sys.send2Dbg("stopOnStep", {}), !0;
    case 5:
      x(this, Ro, cl).call(this), g(this, fe, 4);
      break;
    case 4:
      return x(this, Ro, cl).call(this), this.main.setLoop(!1, "ステップ実行"), this.sys.send2Dbg("stopOnStep", {}), !0;
    case 3:
      x(this, Ro, cl).call(this), g(this, fe, 0);
      break;
    default:
      if (yf(t) in h(_i, In))
        return g(this, fe, 2), this.main.setLoop(!1, `関数 ${t} ブレーク`), this.sys.callHook("stopOnBreakpoint", {}), this.sys.send2Dbg("stopOnBreakpoint", {}), !0;
      {
        const e = h(_i, Mo)[h(this, us).call(this, h(this, Ft))];
        if (!e)
          break;
        const i = e[h(this, Jt)];
        if (!i)
          break;
        if (i.condition) {
          if (!this.prpPrs.parse(i.condition))
            break;
        } else if ("hitCondition" in i && --i.hitCondition > 0)
          break;
        const n = h(this, fe) === 0;
        g(this, fe, 2), this.main.setLoop(!1, n ? (i.condition ? "条件" : "ヒットカウント") + "ブレーク" : "ステップ実行");
        const s = n ? "stopOnBreakpoint" : "stopOnStep";
        this.sys.callHook(s, {}), this.sys.send2Dbg(s, {});
      }
      return !0;
  }
  return !1;
}, Ro = new WeakSet(), cl = function() {
  var e;
  const t = (e = h(_i, Mo)[vl(h(this, Ft))]) == null ? void 0 : e[h(this, Jt)];
  t != null && t.hitCondition && --t.hitCondition;
}, qp = new WeakSet(), Ew = function() {
  const t = h(this, fe) === 3 ? 1 : 0, e = h(this, It).aToken[h(this, tt) - 1 + t], i = h(this, us).call(this, h(this, Ft)), n = yf(e), s = n ? `[${n}]` : e, o = this.val.getVal("mp:const.sn.macro") ?? "{}";
  if (h(this, tt) === 0)
    return [{ fn: i, ln: 1, col: 1, nm: s, ma: o }];
  const a = x(this, Cn, ks).call(this, h(this, It), h(this, tt)), l = [{ fn: i, ln: a.ln, col: a.col_s + 1, nm: s, ma: o }], u = h(this, Yt).length;
  if (u === 0)
    return l;
  for (let c = u - 1; c >= 0; --c) {
    const d = h(this, Yt)[c], f = h(this, He)[d.fn], v = f.aToken[d.idx - 1], m = x(this, Cn, ks).call(this, f, d.idx), p = yf(v);
    l.push({
      fn: h(this, us).call(this, d.fn),
      ln: m.ln,
      col: m.col_s + 1,
      nm: p ? `[${p}]` : v,
      ma: d.csArg[":hMp"]["const.sn.macro"] ?? "{}"
    });
  }
  return l;
}, uc = new WeakMap(), xh = new WeakMap(), Ti = new WeakMap(), Zp = new WeakSet(), Tw = function(t) {
  const { name: e } = t;
  if (!e)
    throw "nameは必須です";
  let i = "";
  const n = h(this, It).len;
  for (; h(this, tt) < n && (i = h(this, It).aToken[h(this, tt)], i === ""); ++Te(this, tt)._)
    ;
  return t.text = i, t.cast = "str", this.hTag.let(t), g(this, tt, h(this, tt) + 2), g(this, Jt, h(this, Jt) + (i.match(/\n/g) ?? []).length), !1;
}, Kp = new WeakSet(), Sw = function() {
  if (h(this, tt) === 0)
    return console.group(`🥟 [dump_stack] スクリプト現在地 fn:${h(this, Ft)} line:1 col:0`), console.groupEnd(), !1;
  const t = x(this, Cn, ks).call(this, h(this, It), h(this, tt)), e = `スクリプト現在地 fn:${h(this, Ft)} line:${t.ln} col:${t.col_s + 1}`;
  console.group(`🥟 [dump_stack] ${e}`);
  const i = h(this, Yt).length;
  if (i > 0) {
    console.info(e);
    for (let n = i - 1; n >= 0; --n) {
      const s = h(this, Yt)[n], o = s.csArg[":hMp"], a = o ? o[":タグ名"] : void 0, l = s.csArg[":タグ名"] ?? "", u = x(this, Cn, ks).call(this, h(this, He)[s.fn], s.idx);
      console.info(
        `${i - n}つ前のコール元 fn:${s.fn} line:${u.ln} col:${u.col_s + 1}` + (a ? "（[" + a + "]マクロ内）" : " ") + `で [${l} ...]をコール`
      );
    }
  }
  return console.groupEnd(), !1;
}, Cn = new WeakSet(), ks = function(t, e) {
  const i = { ln: 1, col_s: 0, col_e: 0 };
  if (!t)
    return i;
  let n = e - 1;
  const s = i.ln = t.aLNum[n];
  for (; t.aLNum[n] === s; ) {
    if (t.aToken[n].at(0) !== `
`) {
      const o = t.aToken[n].length;
      i.col_e > 0 && (i.col_s += o), i.col_e += o;
    }
    if (--n < 0)
      break;
  }
  return i;
}, Jp = new WeakSet(), Pw = function(t) {
  const { set_fnc: e, break_fnc: i } = t;
  if (!e)
    throw "set_fncは必須です";
  if (g(this, ko, globalThis[e]), !h(this, ko)) {
    if (K(t, "need_err", !0))
      throw `HTML内に関数${e}が見つかりません`;
    return g(this, ko, () => {
    }), !1;
  }
  if (this.noticeBreak = (n) => {
    h(this, cc) !== h(this, Ft) && (g(this, cc, h(this, Ft)), h(this, ko).call(this, h(this, fc)[h(this, Ft)] = h(this, fc)[h(this, Ft)] ?? h(this, It).aToken.join(""))), h(this, No).call(this, h(this, Jt), n);
  }, this.noticeBreak(!0), !i)
    return !1;
  if (g(this, No, globalThis[i]), !h(this, No)) {
    if (K(t, "need_err", !0))
      throw `HTML内に関数${i}が見つかりません`;
    g(this, No, () => {
    });
  }
  return !1;
}, ko = new WeakMap(), No = new WeakMap(), cc = new WeakMap(), fc = new WeakMap(), dc = new WeakMap(), Si = new WeakMap(), Qp = new WeakSet(), Ow = function() {
  if (h(this, Si)[0] === -1)
    throw "ifブロック内ではありません";
  return g(this, tt, h(this, Si)[0]), h(this, Si).shift(), !1;
}, tv = new WeakSet(), Iw = function(t) {
  const { exp: e } = t;
  if (!e)
    throw "expは必須です";
  if (e.at(0) === "&")
    throw "属性expは「&」が不要です";
  let i = 0, n = this.prpPrs.parse(e) ? h(this, tt) : -1;
  const s = h(this, It).aLNum[h(this, tt)];
  let o = h(this, Jt) - (s || 0);
  const a = h(this, It).len;
  for (; h(this, tt) < a; ++Te(this, tt)._) {
    const l = h(this, It).aLNum[h(this, tt)];
    h(this, It).aLNum[h(this, tt)] = (l || 0) + o;
    const u = h(this, It).aToken[h(this, tt)];
    if (!u)
      continue;
    const c = u.charCodeAt(0);
    if (c === 10) {
      g(this, Jt, h(this, Jt) + u.length);
      continue;
    }
    if (c !== 91)
      continue;
    const [d, f] = vf(u);
    if (!(d in this.hTag))
      throw `未定義のタグ[${d}]です`;
    switch (this.alzTagArg.parse(f), d) {
      case "if":
        ++i;
        break;
      case "elsif":
        if (i > 0 || n > -1)
          break;
        const v = this.alzTagArg.hPrm.exp.val;
        if (v.at(0) === "&")
          throw "属性expは「&」が不要です";
        this.prpPrs.parse(v) && (n = h(this, tt) + 1);
        break;
      case "else":
        if (i > 0)
          break;
        n === -1 && (n = h(this, tt) + 1);
        break;
      case "endif":
        if (i > 0) {
          --i;
          break;
        }
        return n === -1 ? (++Te(this, tt)._, h(this, It).aLNum[h(this, tt)] += o) : (h(this, Si).unshift(h(this, tt) + 1), g(this, tt, n), g(this, Jt, h(this, It).aLNum[h(this, tt)])), !1;
    }
  }
  throw "[endif]がないままスクリプト終端です";
}, ev = new WeakSet(), Cw = function(t) {
  K(t, "count", !1) || x(this, wc, Hm).call(this);
  const { fn: e } = t;
  return e && h(this, ls).call(this, e), x(this, pc, Fm).call(this, { ":hEvt1Time": h(this, xh).popLocalEvts(), ":hMp": this.val.cloneMp() }), K(t, "clear_local_event", !1) && this.hTag.clear_event({}), x(this, Mn, Ns).call(this, e, t.label), !0;
}, pc = new WeakSet(), Fm = function(t) {
  h(this, It).aLNum[h(this, tt)] = h(this, Jt), h(this, yc) || (t[":resvToken"] = "", x(this, Ao, fl).call(this)), h(this, Yt).push(new d0(h(this, Ft), h(this, tt), t)), h(this, Si).unshift(-1);
}, iv = new WeakSet(), Mw = function(t) {
  return K(t, "count", !0) || x(this, wc, Hm).call(this), h(this, Si)[0] = -1, x(this, Mn, Ns).call(this, t.fn, t.label), !0;
}, rv = new WeakSet(), Rw = function(t) {
  if (h(this, $e) === -1)
    return !1;
  if (K(t, "clear", !1))
    return g(this, fr, []), g(this, $e, -1), !1;
  const { to: e } = t;
  if (!e)
    throw "clearかtoは必須です";
  const i = h(this, $e);
  switch (e) {
    case "prev":
      h(this, $e) > 0 && --Te(this, $e)._;
      break;
    case "next":
      const a = h(this, fr).length;
      h(this, $e) < a - 1 && ++Te(this, $e)._;
      break;
    default:
      throw `属性to「${e}」は異常です`;
  }
  if (i === h(this, $e))
    return !1;
  const n = h(this, fr)[h(this, $e)], { fn: s, idx: o } = x(this, Sh, Ff).call(this);
  return n.key === o + ":" + s ? !1 : x(this, Eh, Df).call(this, { fn: n.retFn, index: n.retIdx }, n.retMark);
}, nv = new WeakSet(), kw = function(t) {
  if (K(t, "clear", !1))
    g(this, Yt, []);
  else if (!h(this, Yt).pop())
    throw "[pop_stack] スタックが空です";
  return x(this, Ao, fl).call(this), g(this, Si, [-1]), this.val.setMp({}), !1;
}, vc = new WeakSet(), Bm = function(t) {
  const e = h(this, Yt).pop();
  if (!e)
    throw "[return] スタックが空です";
  const i = e.csArg;
  h(this, Si).shift();
  const n = i[":hMp"];
  n && this.val.setMp(n);
  const s = i[":resvToken"];
  s ? this.nextToken = () => (x(this, Ao, fl).call(this), s) : x(this, Ao, fl).call(this), i[":hEvt1Time"] && h(this, xh).pushLocalEvts(i[":hEvt1Time"]);
  const { fn: o, label: a } = t;
  return o || a ? (x(this, Mn, Ns).call(this, o, a), !0) : e.fn in h(this, He) ? (x(this, xc, jm).call(this, e), !1) : (x(this, Mn, Ns).call(this, e.fn, "", e.idx), !0);
}, yc = new WeakMap(), Ao = new WeakSet(), fl = function() {
  g(this, yc, ""), this.nextToken = x(this, mc, Um);
}, Lo = new WeakMap(), Mn = new WeakSet(), Ns = function(t = "", e = "", i = 0) {
  if (!t && !e && this.main.errScript("[jump系] fnまたはlabelは必須です"), e ? (e.at(0) !== "*" && this.main.errScript("[jump系] labelは*で始まります"), g(this, Lo, e), h(this, Lo).slice(0, 2) !== "**" && g(this, tt, i)) : (g(this, Lo, ""), g(this, tt, i)), !t) {
    this.analyzeInit();
    return;
  }
  if (t.includes("@"))
    throw "[jump系] fn には文字「@」は禁止です";
  const n = h(this, ls).call(this, t);
  if (t === h(this, Ft)) {
    this.analyzeInit();
    return;
  }
  g(this, Ft, t);
  const s = h(this, He)[t];
  if (s) {
    g(this, It, s), this.analyzeInit();
    return;
  }
  const o = new Oi();
  let a = "";
  try {
    a = h(this, ls).call(this, t + "@"), o.add({ name: t + ":base", url: n }), o.add({ name: t, url: a });
  } catch {
    o.add({ name: t, url: n });
  }
  o.use((l, u) => {
    try {
      l.data = this.sys.decStr(l.extension, l.data);
    } catch (c) {
      this.main.errScript(`[jump系]snロード失敗です fn:${l.name} ${c}`, !1);
    }
    u == null || u();
  }).load((l, u) => {
    if (a) {
      const c = u[t + ":base"].data, d = u[t].data, f = c.split(`
`), v = d.split(`
`), m = f.length, p = v.length;
      for (let y = 0; y < p && y < m; ++y)
        v[y] || (v[y] = f[y]);
      u[t].data = v.join(`
`), delete u[t + ":base"];
    }
    this.nextToken = x(this, mc, Um), g(this, Jt, 1), x(this, hv, Aw).call(this, u[t].data), this.hTag.record_place({}), this.main.resume(() => this.analyzeInit());
  }), this.main.stop();
}, mc = new WeakSet(), Um = function() {
  var e, i;
  if (x(this, gc, Gm).call(this))
    return "";
  x(this, fv, Dw).call(this), (e = h(this, It).aLNum)[i = h(this, tt)] || (e[i] = h(this, Jt));
  const t = h(this, It).aToken[h(this, tt)];
  return h(this, _c).call(this, t), ++Te(this, tt)._, t;
}, _c = new WeakMap(), gc = new WeakSet(), Gm = function() {
  return h(this, tt) < h(this, It).len ? !1 : (this.main.errScript("スクリプト終端です"), !0);
}, sv = new WeakMap(), ov = new WeakMap(), bc = new WeakMap(), av = new WeakSet(), Nw = function(t, e, i, n, s) {
  var c, d;
  const o = t.aToken.length;
  if (!n) {
    if (x(this, gc, Gm).call(this))
      return { idx: s, ln: i };
    if (t.aLNum[s])
      i = t.aLNum[s];
    else {
      i = 1;
      for (let f = 0; f < s; ++f) {
        (c = t.aLNum)[f] || (c[f] = i);
        const v = t.aToken[f];
        v.charCodeAt(0) === 10 ? i += v.length : i += (v.match(/\n/g) ?? []).length;
      }
      t.aLNum[s] = i;
    }
    return { idx: s, ln: i };
  }
  t.aLNum[0] = 1;
  const a = n.match(h(this, sv));
  if (a) {
    n = a[1];
    let f = s;
    switch (a[2]) {
      case "before":
        for (; t.aToken[--f] !== n; )
          f === 0 && wt.myTrace("[jump系 無名ラベルbefore] " + i + "行目以前で" + (e ? "マクロ内に" : "") + "ラベル【" + n + "】がありません", "ET"), e && t.aToken[f].search(h(this, ov)) > -1 && wt.myTrace("[jump系 無名ラベルbefore] マクロ内にラベル【" + n + "】がありません", "ET");
        return { idx: f + 1, ln: t.aLNum[f] };
      case "after":
        for (; t.aToken[++f] !== n; )
          f === o && wt.myTrace("[jump系 無名ラベルafter] " + i + "行目以後でマクロ内にラベル【" + n + "】がありません", "ET"), t.aToken[f].search(h(this, bc)) > -1 && wt.myTrace("[jump系 無名ラベルafter] " + i + "行目以後でマクロ内にラベル【" + n + "】がありません", "ET");
        return { idx: f + 1, ln: t.aLNum[f] };
      default:
        wt.myTrace("[jump系] 無名ラベル指定【label=" + n + "】が間違っています", "ET");
    }
  }
  i = 1;
  const l = new RegExp(
    "^" + n.replaceAll("*", "\\*") + "(?=\\s|;|\\[|\\||$)"
  );
  let u = !1;
  for (let f = 0; f < o; ++f) {
    (d = t.aLNum)[f] || (d[f] = i);
    const v = t.aToken[f];
    if (u) {
      h(this, On).testTagEndLetml(v) ? u = !1 : i += (v.match(/\n/g) ?? []).length;
      continue;
    }
    const m = v.charCodeAt(0);
    if (m === 10) {
      i += v.length;
      continue;
    }
    if (m === 42) {
      if (v.search(l) > -1)
        return { idx: f + 1, ln: i };
      continue;
    }
    m === 91 && (i += (v.match(/\n/g) ?? []).length, h(this, On).testTagLetml(v) && (u = !0));
  }
  throw u ? "[let_ml]の終端・[endlet_ml]がありません" : (wt.myTrace(`[jump系] ラベル【${n}】がありません`, "ET"), "Dummy");
}, He = new WeakMap(), hv = new WeakSet(), Aw = function(t) {
  let e = "";
  try {
    e = "ScriptIterator.resolveScript";
    const i = h(this, On).resolveScript(t);
    e = "ScriptIterator.replaceScript_Wildcard", x(this, cv, Lw).call(this, i), h(this, He)[h(this, Ft)] = g(this, It, i);
  } catch (i) {
    i instanceof Error ? e += `例外 mes=${i.message}(${i.name})` : e = i, this.main.errScript(e, !1);
  }
  this.val.loadScrWork(h(this, Ft));
}, xc = new WeakSet(), jm = function(t) {
  g(this, Ft, t.fn), g(this, tt, t.idx);
  const e = h(this, He)[h(this, Ft)];
  e && g(this, It, e), g(this, Jt, h(this, It).aLNum[t.idx]);
}, lv = new WeakMap(), uv = new WeakMap(), cv = new WeakSet(), Lw = function(t) {
  for (let e = t.len - 1; e >= 0; --e) {
    const i = t.aToken[e];
    if (!h(this, lv).test(i))
      continue;
    const [n, s] = vf(i);
    this.alzTagArg.parse(s);
    const o = this.alzTagArg.hPrm.fn;
    if (!o)
      continue;
    const { val: a } = o;
    if (!a || a.at(-1) !== "*")
      continue;
    t.aToken.splice(e, 1, "	", "; " + i), t.aLNum.splice(e, 1, NaN, NaN);
    const l = n === "loadplugin" ? Xe.CSS : Xe.SN, u = this.cfg.matchPath("^" + a.slice(0, -1) + ".*", l);
    for (const c of u) {
      const d = i.replace(
        h(this, uv),
        "fn=" + decodeURIComponent(vl(c[l]))
      );
      t.aToken.splice(e, 0, d), t.aLNum.splice(e, 0, NaN);
    }
  }
  t.len = t.aToken.length;
}, fv = new WeakSet(), Dw = function() {
  const t = this.val.getAreaKidoku(h(this, Ft));
  if (!t)
    throw `recordKidoku fn:'${h(this, Ft)}' (areas === null)`;
  if (h(this, Yt).length > 0) {
    t.record(h(this, tt));
    return;
  }
  g(this, Rn, t.search(h(this, tt))), this.val.setVal_Nochk("tmp", "const.sn.isKidoku", h(this, Rn)), !h(this, Rn) && t.record(h(this, tt));
}, Rn = new WeakMap(), wc = new WeakSet(), Hm = function() {
  var t;
  (t = this.val.getAreaKidoku(h(this, Ft))) == null || t.erase(h(this, tt)), g(this, Rn, !1);
}, dv = new WeakSet(), Fw = function(t) {
  return h(this, On).bracket2macro(t, this.hTag, h(this, It), h(this, tt)), !1;
}, pv = new WeakSet(), Bw = function(t) {
  return h(this, On).char2macro(t, this.hTag, h(this, It), h(this, tt)), !1;
}, vv = new WeakMap(), yv = new WeakSet(), Uw = function(t) {
  var s, o;
  const { name: e } = t;
  if (!e)
    throw "nameは必須です";
  if (e in this.hTag)
    throw `[${e}]はタグかすでに定義済みのマクロです`;
  if (h(this, vv).test(e))
    throw `[${e}]はマクロ名として異常です`;
  const i = h(this, Jt), n = new d0(h(this, Ft), h(this, tt));
  for (g(this, Ec, h(this, Ec) + ("|" + e)), g(this, wh, new RegExp(`\\[(${h(this, Ec)})\\b`)), this.hTag[e] = (a) => (a.design_unit = t.design_unit, x(this, pc, Fm).call(this, { ...a, ":hMp": this.val.cloneMp() }), this.val.setMp(a), this.val.setVal_Nochk("mp", "const.sn.macro", JSON.stringify(t)), this.val.setVal_Nochk("mp", "const.sn.me_call_scriptFn", h(this, Ft)), g(this, Jt, i), x(this, xc, jm).call(this, n), !1); h(this, tt) < h(this, It).len; ++Te(this, tt)._) {
    (s = h(this, It).aLNum)[o = h(this, tt)] || (s[o] = h(this, Jt));
    const a = h(this, It).aToken[h(this, tt)];
    if (a.search(h(this, bc)) > -1)
      return ++Te(this, tt)._, !1;
    const l = a.charCodeAt(0);
    l === 10 ? g(this, Jt, h(this, Jt) + a.length) : l === 91 && g(this, Jt, h(this, Jt) + (a.match(/\n/g) ?? []).length);
  }
  throw `マクロ[${e}]定義の終端・[endmacro]がありません`;
}, Ec = new WeakMap(), wh = new WeakMap(), mv = new WeakSet(), Gw = function(t) {
  if (!("place" in t))
    throw "placeは必須です";
  const e = Number(t.place);
  if ("fn" in t != "label" in t)
    throw "fnとlabelはセットで指定して下さい";
  const i = this.val.getMark(e);
  if (!i)
    throw `place【${e}】は存在しません`;
  return x(this, Eh, Df).call(this, t, i);
}, Eh = new WeakSet(), Df = function(t, e, i = !0) {
  this.hTag.clear_event({}), this.val.mark2save(e), this.val.setMp({}), h(this, Ti).recPagebreak(), i && this.sndMng.playLoopFromSaveObj(), K(t, "do_rec", !0) && g(this, cr, {
    hSave: this.val.cloneSave(),
    hPages: { ...e.hPages },
    aIfStk: [...e.aIfStk]
  });
  const n = {
    enabled: this.val.getVal("save:const.sn.autowc.enabled"),
    text: this.val.getVal("save:const.sn.autowc.text"),
    time: Number(this.val.getVal("save:const.sn.autowc.time"))
  };
  this.hTag.autowc(n);
  const s = String(this.val.getVal("save:const.sn.scriptFn")), o = Number(this.val.getVal("save:const.sn.scriptIdx"));
  return g(this, Si, [...h(this, cr).aIfStk]), g(this, Yt, []), h(this, Ti).cover(!0), h(this, Ti).stopAllTw(), "index" in t ? (h(this, Ti).playback(h(this, cr).hPages, () => {
    h(this, Ti).cover(!1), g(this, Th, !0), x(this, Mn, Ns).call(this, t.fn ?? s, "", t.index ?? o);
  }), !0) : (delete h(this, He)[s], h(this, Ti).playback(
    h(this, cr).hPages,
    "label" in t ? () => {
      h(this, Ti).cover(!1), g(this, Ft, s), g(this, tt, o), this.hTag.call({ fn: t.fn, label: t.label });
    } : () => {
      h(this, Ti).cover(!1), x(this, Mn, Ns).call(this, s, "", o);
    }
  ), !0);
}, Th = new WeakMap(), _v = new WeakSet(), jw = function(t) {
  const e = this.val.getMark(0);
  delete h(this, He)[vl(e.hSave["const.sn.scriptFn"])];
  const i = {};
  for (const n in h(this, He))
    try {
      h(this, ls).call(this, n + "@");
    } catch {
      i[n] = h(this, He)[n];
    }
  return g(this, He, i), t.do_rec = !1, x(this, Eh, Df).call(this, t, e, !1);
}, cr = new WeakMap(), gv = new WeakSet(), Hw = function() {
  if (this.main.isDestroyed())
    return !1;
  const { fn: t, idx: e } = x(this, Sh, Ff).call(this);
  return this.val.setVal_Nochk("save", "const.sn.scriptFn", t), this.val.setVal_Nochk("save", "const.sn.scriptIdx", e), g(this, cr, {
    hSave: this.val.cloneSave(),
    hPages: h(this, Ti).record(),
    aIfStk: h(this, Si).slice(h(this, Yt).length)
  }), !1;
}, Sh = new WeakSet(), Ff = function() {
  if (h(this, Yt).length === 0)
    return {
      fn: h(this, Ft),
      idx: h(this, tt)
    };
  const e = h(this, Yt)[0];
  return {
    fn: e.fn,
    idx: e.idx
  };
}, bv = new WeakSet(), $w = function(t) {
  if (!("place" in t))
    throw "placeは必須です";
  const e = Number(t.place);
  delete t[":タグ名"], delete t.place, t.text = t.text ?? "", h(this, cr).json = t, this.val.setMark(e, h(this, cr));
  const i = Number(this.val.getVal("sys:const.sn.save.place"));
  return e === i && this.val.setVal_Nochk("sys", "const.sn.save.place", i + 1), !1;
}, fr = new WeakMap(), $e = new WeakMap(), _(ua, Wp, /(.+)\/crypto_prj\/([^\/]+)\/[^\.]+(\.\w+)/), // reload 再生成 Main に受け渡すため static
_(ua, Mo, {}), _(ua, In, {});
var hi, zi, Ye, Vi, kn, Do, ze, Tc, Nn, Ph, Fo, Sc, Pc, Oh, xv, zw, Oc, Ic, Ih, Ch, Bf, Bo, Uo;
const ga = class {
  constructor(t) {
    _(this, xv);
    _(this, Ch);
    _(this, hi, void 0);
    _(this, zi, void 0);
    _(this, Ye, /* @__PURE__ */ Object.create(null));
    // タグ処理辞書
    _(this, Vi, void 0);
    _(this, kn, void 0);
    _(this, Do, void 0);
    _(this, ze, void 0);
    _(this, Tc, void 0);
    _(this, Nn, void 0);
    _(this, Ph, void 0);
    _(this, Fo, () => {
    });
    _(this, Sc, new RC());
    _(this, Pc, !1);
    _(this, Oh, "skynovel");
    _(this, Oc, () => h(this, Fo).call(this));
    // メイン処理（シナリオ解析）
    _(this, Ic, (t = x(this, Ch, Bf)) => {
      h(this, Bo) || (h(this, Nn).clearBreak(), g(this, Fo, t), this.resume = (e = x(this, Ch, Bf)) => {
        g(this, Fo, e);
      }, h(this, ze).noticeBreak(!1));
    });
    D(this, "resume", h(this, Ic));
    D(this, "stop", () => {
      g(this, Fo, () => {
      }), this.resume = h(this, Ic), h(this, ze).noticeBreak(!0);
    });
    _(this, Ih, !0);
    _(this, Bo, !1);
    D(this, "isDestroyed", () => h(this, Bo));
    _(this, Uo, void 0);
    this.sys = t, nT(), M_.generate(t).then((e) => g(this, hi, e)).then(() => x(this, xv, zw).call(this)).catch((e) => console.error("load err fn:prj.json e:%o", e));
  }
  // thisの扱いによりメソッド代入はダメ
  errScript(t, e = !0) {
    if (this.stop(), wt.myTrace(t), L.debugLog && console.log("🍜 SKYNovel err!"), e)
      throw t;
  }
  resumeByJumpOrCall(t) {
    if (t.url) {
      globalThis.open(t.url);
      return;
    }
    h(this, Vi).setVal_Nochk("tmp", "sn.eventArg", t.arg ?? ""), h(this, Vi).setVal_Nochk("tmp", "sn.eventLabel", t.label ?? ""), K(t, "call", !1) ? (h(this, ze).subIdxToken(), this.resume(() => h(this, Ye).call(t))) : (h(this, Ye).clear_event({}), this.resume(() => h(this, Ye).jump(t)));
  }
  setLoop(t, e = "") {
    g(this, Ih, t) ? this.resume() : this.stop(), this.sys.setTitleInfo(e ? ` -- ${e}中` : "");
  }
  fire(t, e) {
    h(this, Ph).fire(t, e);
  }
  async destroy(t = 0) {
    h(this, Bo) || (g(this, Bo, !0), h(this, Pc) && (this.stop(), g(this, Ih, !1), h(this, Nn).before_destroy(), t > 0 && await new Promise((e) => setTimeout(e, t)), g(this, Ye, {}), h(this, Ph).destroy(), h(this, ze).destroy(), h(this, Nn).destroy(), h(this, Tc).destroy(), h(this, zi).ticker.remove(h(this, Oc)), h(this, Uo) && h(this, zi) && ga.cvs.parentNode.appendChild(h(this, Uo)), z0(), h(this, zi).destroy(!0), this.sys.destroy()));
  }
};
let ui = ga;
hi = new WeakMap(), zi = new WeakMap(), Ye = new WeakMap(), Vi = new WeakMap(), kn = new WeakMap(), Do = new WeakMap(), ze = new WeakMap(), Tc = new WeakMap(), Nn = new WeakMap(), Ph = new WeakMap(), Fo = new WeakMap(), Sc = new WeakMap(), Pc = new WeakMap(), Oh = new WeakMap(), xv = new WeakSet(), zw = async function() {
  var n;
  const t = (n = document.createElement("canvas")) == null ? void 0 : n.getContext("2d");
  if (!t)
    throw "argChk_Color err";
  L.cc4ColorName = t;
  const e = {
    width: h(this, hi).oCfg.window.width,
    height: h(this, hi).oCfg.window.height,
    backgroundColor: Ym(String(h(this, hi).oCfg.init.bg_color)),
    // このString()は後方互換性のため必須
    //	resolution		: sys.resolution,
    resolution: globalThis.devicePixelRatio ?? 1
    // 理想
  }, i = document.getElementById(h(this, Oh));
  i && (g(this, Uo, i.cloneNode(!0)), h(this, Uo).id = h(this, Oh), e.view = i), g(this, zi, new Ab(e)), ga.cvs = h(this, zi).view, i || (document.body.appendChild(ga.cvs), ga.cvs.id = h(this, Oh)), g(this, Vi, new gf(h(this, hi), h(this, Ye))), g(this, kn, new Ls(h(this, Vi), h(this, hi).oCfg.init.escape ?? "\\")), await Promise.allSettled(this.sys.init(h(this, Ye), h(this, zi), h(this, Vi), this)), h(this, Ye).title({ text: h(this, hi).oCfg.book.title || "SKYNovel" }), g(this, Do, new Ef(h(this, hi), h(this, Ye), h(this, Vi), this, this.sys)), g(this, ze, new ua(h(this, hi), h(this, Ye), this, h(this, Vi), h(this, Sc), () => x(this, Ch, Bf).call(this), h(this, kn), h(this, Do), this.sys)), g(this, Tc, new wt(this.sys, h(this, Ye), h(this, ze))), g(this, Nn, new Ds(h(this, hi), h(this, Ye), h(this, zi), h(this, Vi), this, h(this, ze), this.sys, h(this, Do), h(this, Sc), h(this, kn))), g(this, Ph, new cR(h(this, hi), h(this, Ye), h(this, zi), this, h(this, Nn), h(this, Vi), h(this, Do), h(this, ze), this.sys)), h(this, zi).ticker.add(h(this, Oc)), this.resumeByJumpOrCall({ fn: "main" }), g(this, Pc, !0);
}, Oc = new WeakMap(), Ic = new WeakMap(), Ih = new WeakMap(), Ch = new WeakSet(), Bf = function() {
  for (; h(this, Ih); ) {
    let t = h(this, ze).nextToken();
    if (!t)
      break;
    const e = t.charCodeAt(0);
    if (e !== 9) {
      if (e === 10) {
        h(this, ze).addLineNum(t.length);
        continue;
      }
      if (e === 91) {
        if (h(this, ze).isBreak(t))
          return;
        try {
          const i = (t.match(/\n/g) ?? []).length;
          if (i > 0 && h(this, ze).addLineNum(i), h(this, ze).タグ解析(t)) {
            this.stop();
            break;
          }
          continue;
        } catch (i) {
          i instanceof Error ? this.errScript(`[${yf(t)}]タグ解析中例外 mes=${i.message}(${i.name})`, !1) : this.errScript(String(i), !1);
          return;
        }
      }
      if (e === 38)
        try {
          if (t.at(-1) !== "&") {
            if (h(this, ze).isBreak(t))
              return;
            const i = CC(t.slice(1));
            i.name = h(this, kn).getValAmpersand(i.name), i.text = String(h(this, kn).parse(i.text)), h(this, Ye).let(i);
            continue;
          }
          if (t.charAt(1) === "&")
            throw new Error("「&表示&」書式では「&」指定が不要です");
          t = String(h(this, kn).parse(t.slice(1, -1)));
        } catch (i) {
          this.errScript(
            i instanceof Error ? `& 変数操作・表示 mes=${i.message}(${i.name})` : i,
            !1
          );
          return;
        }
      else {
        if (e === 59)
          continue;
        if (e === 42 && t.length > 1)
          continue;
      }
      try {
        h(this, Nn).currentTxtlayForeNeedErr.tagCh(t);
      } catch (i) {
        this.errScript(
          i instanceof Error ? `文字表示 mes=${i.message}(${i.name})` : i,
          !1
        );
        return;
      }
    }
  }
}, Bo = new WeakMap(), Uo = new WeakMap(), D(ui, "cvs");
const Qr = /* @__PURE__ */ Object.create(null);
Qr.open = "0";
Qr.close = "1";
Qr.ping = "2";
Qr.pong = "3";
Qr.message = "4";
Qr.upgrade = "5";
Qr.noop = "6";
const Uf = /* @__PURE__ */ Object.create(null);
Object.keys(Qr).forEach((r) => {
  Uf[Qr[r]] = r;
});
const fR = { type: "error", data: "parser error" }, dR = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", pR = typeof ArrayBuffer == "function", vR = (r) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(r) : r && r.buffer instanceof ArrayBuffer, Vw = ({ type: r, data: t }, e, i) => dR && t instanceof Blob ? e ? i(t) : p0(t, i) : pR && (t instanceof ArrayBuffer || vR(t)) ? e ? i(t) : p0(new Blob([t]), i) : i(Qr[r] + (t || "")), p0 = (r, t) => {
  const e = new FileReader();
  return e.onload = function() {
    const i = e.result.split(",")[1];
    t("b" + (i || ""));
  }, e.readAsDataURL(r);
}, v0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", dl = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let r = 0; r < v0.length; r++)
  dl[v0.charCodeAt(r)] = r;
const yR = (r) => {
  let t = r.length * 0.75, e = r.length, i, n = 0, s, o, a, l;
  r[r.length - 1] === "=" && (t--, r[r.length - 2] === "=" && t--);
  const u = new ArrayBuffer(t), c = new Uint8Array(u);
  for (i = 0; i < e; i += 4)
    s = dl[r.charCodeAt(i)], o = dl[r.charCodeAt(i + 1)], a = dl[r.charCodeAt(i + 2)], l = dl[r.charCodeAt(i + 3)], c[n++] = s << 2 | o >> 4, c[n++] = (o & 15) << 4 | a >> 2, c[n++] = (a & 3) << 6 | l & 63;
  return u;
}, mR = typeof ArrayBuffer == "function", Xw = (r, t) => {
  if (typeof r != "string")
    return {
      type: "message",
      data: Ww(r, t)
    };
  const e = r.charAt(0);
  return e === "b" ? {
    type: "message",
    data: _R(r.substring(1), t)
  } : Uf[e] ? r.length > 1 ? {
    type: Uf[e],
    data: r.substring(1)
  } : {
    type: Uf[e]
  } : fR;
}, _R = (r, t) => {
  if (mR) {
    const e = yR(r);
    return Ww(e, t);
  } else
    return { base64: !0, data: r };
}, Ww = (r, t) => {
  switch (t) {
    case "blob":
      return r instanceof ArrayBuffer ? new Blob([r]) : r;
    case "arraybuffer":
    default:
      return r;
  }
}, Yw = String.fromCharCode(30), gR = (r, t) => {
  const e = r.length, i = new Array(e);
  let n = 0;
  r.forEach((s, o) => {
    Vw(s, !1, (a) => {
      i[o] = a, ++n === e && t(i.join(Yw));
    });
  });
}, bR = (r, t) => {
  const e = r.split(Yw), i = [];
  for (let n = 0; n < e.length; n++) {
    const s = Xw(e[n], t);
    if (i.push(s), s.type === "error")
      break;
  }
  return i;
}, qw = 4;
function Me(r) {
  if (r)
    return xR(r);
}
function xR(r) {
  for (var t in Me.prototype)
    r[t] = Me.prototype[t];
  return r;
}
Me.prototype.on = Me.prototype.addEventListener = function(r, t) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + r] = this._callbacks["$" + r] || []).push(t), this;
};
Me.prototype.once = function(r, t) {
  function e() {
    this.off(r, e), t.apply(this, arguments);
  }
  return e.fn = t, this.on(r, e), this;
};
Me.prototype.off = Me.prototype.removeListener = Me.prototype.removeAllListeners = Me.prototype.removeEventListener = function(r, t) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var e = this._callbacks["$" + r];
  if (!e)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + r], this;
  for (var i, n = 0; n < e.length; n++)
    if (i = e[n], i === t || i.fn === t) {
      e.splice(n, 1);
      break;
    }
  return e.length === 0 && delete this._callbacks["$" + r], this;
};
Me.prototype.emit = function(r) {
  this._callbacks = this._callbacks || {};
  for (var t = new Array(arguments.length - 1), e = this._callbacks["$" + r], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  if (e) {
    e = e.slice(0);
    for (var i = 0, n = e.length; i < n; ++i)
      e[i].apply(this, t);
  }
  return this;
};
Me.prototype.emitReserved = Me.prototype.emit;
Me.prototype.listeners = function(r) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + r] || [];
};
Me.prototype.hasListeners = function(r) {
  return !!this.listeners(r).length;
};
const Xi = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
function Zw(r, ...t) {
  return t.reduce((e, i) => (r.hasOwnProperty(i) && (e[i] = r[i]), e), {});
}
const wR = Xi.setTimeout, ER = Xi.clearTimeout;
function Bv(r, t) {
  t.useNativeTimers ? (r.setTimeoutFn = wR.bind(Xi), r.clearTimeoutFn = ER.bind(Xi)) : (r.setTimeoutFn = Xi.setTimeout.bind(Xi), r.clearTimeoutFn = Xi.clearTimeout.bind(Xi));
}
const TR = 1.33;
function SR(r) {
  return typeof r == "string" ? PR(r) : Math.ceil((r.byteLength || r.size) * TR);
}
function PR(r) {
  let t = 0, e = 0;
  for (let i = 0, n = r.length; i < n; i++)
    t = r.charCodeAt(i), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (i++, e += 4);
  return e;
}
class OR extends Error {
  constructor(t, e, i) {
    super(t), this.description = e, this.context = i, this.type = "TransportError";
  }
}
class Kw extends Me {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(t) {
    super(), this.writable = !1, Bv(this, t), this.opts = t, this.query = t.query, this.socket = t.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(t, e, i) {
    return super.emitReserved("error", new OR(t, e, i)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(t) {
    this.readyState === "open" && this.write(t);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(t) {
    const e = Xw(t, this.socket.binaryType);
    this.onPacket(e);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(t) {
    super.emitReserved("packet", t);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(t) {
    this.readyState = "closed", super.emitReserved("close", t);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(t) {
  }
}
const Jw = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), $m = 64, IR = {};
let y0 = 0, hf = 0, m0;
function _0(r) {
  let t = "";
  do
    t = Jw[r % $m] + t, r = Math.floor(r / $m);
  while (r > 0);
  return t;
}
function Qw() {
  const r = _0(+/* @__PURE__ */ new Date());
  return r !== m0 ? (y0 = 0, m0 = r) : r + "." + _0(y0++);
}
for (; hf < $m; hf++)
  IR[Jw[hf]] = hf;
function tE(r) {
  let t = "";
  for (let e in r)
    r.hasOwnProperty(e) && (t.length && (t += "&"), t += encodeURIComponent(e) + "=" + encodeURIComponent(r[e]));
  return t;
}
function CR(r) {
  let t = {}, e = r.split("&");
  for (let i = 0, n = e.length; i < n; i++) {
    let s = e[i].split("=");
    t[decodeURIComponent(s[0])] = decodeURIComponent(s[1]);
  }
  return t;
}
let eE = !1;
try {
  eE = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const MR = eE;
function iE(r) {
  const t = r.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!t || MR))
      return new XMLHttpRequest();
  } catch {
  }
  if (!t)
    try {
      return new Xi[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
function RR() {
}
const kR = function() {
  return new iE({
    xdomain: !1
  }).responseType != null;
}();
class NR extends Kw {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(t) {
    if (super(t), this.polling = !1, typeof location < "u") {
      const i = location.protocol === "https:";
      let n = location.port;
      n || (n = i ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || n !== t.port, this.xs = t.secure !== i;
    }
    const e = t && t.forceBase64;
    this.supportsBinary = kR && !e;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(t) {
    this.readyState = "pausing";
    const e = () => {
      this.readyState = "paused", t();
    };
    if (this.polling || !this.writable) {
      let i = 0;
      this.polling && (i++, this.once("pollComplete", function() {
        --i || e();
      })), this.writable || (i++, this.once("drain", function() {
        --i || e();
      }));
    } else
      e();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  poll() {
    this.polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(t) {
    const e = (i) => {
      if (this.readyState === "opening" && i.type === "open" && this.onOpen(), i.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(i);
    };
    bR(t, this.socket.binaryType).forEach(e), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const t = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? t() : this.once("open", t);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(t) {
    this.writable = !1, gR(t, (e) => {
      this.doWrite(e, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    let t = this.query || {};
    const e = this.opts.secure ? "https" : "http";
    let i = "";
    this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = Qw()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.opts.port && (e === "https" && Number(this.opts.port) !== 443 || e === "http" && Number(this.opts.port) !== 80) && (i = ":" + this.opts.port);
    const n = tE(t), s = this.opts.hostname.indexOf(":") !== -1;
    return e + "://" + (s ? "[" + this.opts.hostname + "]" : this.opts.hostname) + i + this.opts.path + (n.length ? "?" + n : "");
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @private
   */
  request(t = {}) {
    return Object.assign(t, { xd: this.xd, xs: this.xs }, this.opts), new qr(this.uri(), t);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(t, e) {
    const i = this.request({
      method: "POST",
      data: t
    });
    i.on("success", e), i.on("error", (n, s) => {
      this.onError("xhr post error", n, s);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const t = this.request();
    t.on("data", this.onData.bind(this)), t.on("error", (e, i) => {
      this.onError("xhr poll error", e, i);
    }), this.pollXhr = t;
  }
}
class qr extends Me {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(t, e) {
    super(), Bv(this, e), this.opts = e, this.method = e.method || "GET", this.uri = t, this.async = e.async !== !1, this.data = e.data !== void 0 ? e.data : null, this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  create() {
    const t = Zw(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    t.xdomain = !!this.opts.xd, t.xscheme = !!this.opts.xs;
    const e = this.xhr = new iE(t);
    try {
      e.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0);
          for (let i in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(i) && e.setRequestHeader(i, this.opts.extraHeaders[i]);
        }
      } catch {
      }
      if (this.method === "POST")
        try {
          e.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        e.setRequestHeader("Accept", "*/*");
      } catch {
      }
      "withCredentials" in e && (e.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (e.timeout = this.opts.requestTimeout), e.onreadystatechange = () => {
        e.readyState === 4 && (e.status === 200 || e.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
          this.onError(typeof e.status == "number" ? e.status : 0);
        }, 0));
      }, e.send(this.data);
    } catch (i) {
      this.setTimeoutFn(() => {
        this.onError(i);
      }, 0);
      return;
    }
    typeof document < "u" && (this.index = qr.requestsCount++, qr.requests[this.index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  onError(t) {
    this.emitReserved("error", t, this.xhr), this.cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  cleanup(t) {
    if (!(typeof this.xhr > "u" || this.xhr === null)) {
      if (this.xhr.onreadystatechange = RR, t)
        try {
          this.xhr.abort();
        } catch {
        }
      typeof document < "u" && delete qr.requests[this.index], this.xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  onLoad() {
    const t = this.xhr.responseText;
    t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this.cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this.cleanup();
  }
}
qr.requestsCount = 0;
qr.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", g0);
  else if (typeof addEventListener == "function") {
    const r = "onpagehide" in Xi ? "pagehide" : "unload";
    addEventListener(r, g0, !1);
  }
}
function g0() {
  for (let r in qr.requests)
    qr.requests.hasOwnProperty(r) && qr.requests[r].abort();
}
const rE = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0))(), lf = Xi.WebSocket || Xi.MozWebSocket, b0 = !0, AR = "arraybuffer", x0 = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class LR extends Kw {
  /**
   * WebSocket transport constructor.
   *
   * @param {Object} opts - connection options
   * @protected
   */
  constructor(t) {
    super(t), this.supportsBinary = !t.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check())
      return;
    const t = this.uri(), e = this.opts.protocols, i = x0 ? {} : Zw(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (i.headers = this.opts.extraHeaders);
    try {
      this.ws = b0 && !x0 ? e ? new lf(t, e) : new lf(t) : new lf(t, e, i);
    } catch (n) {
      return this.emitReserved("error", n);
    }
    this.ws.binaryType = this.socket.binaryType || AR, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const i = t[e], n = e === t.length - 1;
      Vw(i, this.supportsBinary, (s) => {
        const o = {};
        try {
          b0 && this.ws.send(s);
        } catch {
        }
        n && rE(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    let t = this.query || {};
    const e = this.opts.secure ? "wss" : "ws";
    let i = "";
    this.opts.port && (e === "wss" && Number(this.opts.port) !== 443 || e === "ws" && Number(this.opts.port) !== 80) && (i = ":" + this.opts.port), this.opts.timestampRequests && (t[this.opts.timestampParam] = Qw()), this.supportsBinary || (t.b64 = 1);
    const n = tE(t), s = this.opts.hostname.indexOf(":") !== -1;
    return e + "://" + (s ? "[" + this.opts.hostname + "]" : this.opts.hostname) + i + this.opts.path + (n.length ? "?" + n : "");
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @private
   */
  check() {
    return !!lf;
  }
}
const DR = {
  websocket: LR,
  polling: NR
}, FR = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, BR = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function zm(r) {
  const t = r, e = r.indexOf("["), i = r.indexOf("]");
  e != -1 && i != -1 && (r = r.substring(0, e) + r.substring(e, i).replace(/:/g, ";") + r.substring(i, r.length));
  let n = FR.exec(r || ""), s = {}, o = 14;
  for (; o--; )
    s[BR[o]] = n[o] || "";
  return e != -1 && i != -1 && (s.source = t, s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ":"), s.authority = s.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), s.ipv6uri = !0), s.pathNames = UR(s, s.path), s.queryKey = GR(s, s.query), s;
}
function UR(r, t) {
  const e = /\/{2,9}/g, i = t.replace(e, "/").split("/");
  return (t.slice(0, 1) == "/" || t.length === 0) && i.splice(0, 1), t.slice(-1) == "/" && i.splice(i.length - 1, 1), i;
}
function GR(r, t) {
  const e = {};
  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(i, n, s) {
    n && (e[n] = s);
  }), e;
}
let nE = class fa extends Me {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(t, e = {}) {
    super(), this.writeBuffer = [], t && typeof t == "object" && (e = t, t = null), t ? (t = zm(t), e.hostname = t.host, e.secure = t.protocol === "https" || t.protocol === "wss", e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = zm(e.host).host), Bv(this, e), this.secure = e.secure != null ? e.secure : typeof location < "u" && location.protocol === "https:", e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.hostname = e.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = e.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = e.transports || ["polling", "websocket"], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !0
    }, e), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = CR(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this.offlineEventListener = () => {
      this.onClose("transport close", {
        description: "network connection lost"
      });
    }, addEventListener("offline", this.offlineEventListener, !1))), this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(t) {
    const e = Object.assign({}, this.opts.query);
    e.EIO = qw, e.transport = t, this.id && (e.sid = this.id);
    const i = Object.assign({}, this.opts.transportOptions[t], this.opts, {
      query: e,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    });
    return new DR[t](i);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  open() {
    let t;
    if (this.opts.rememberUpgrade && fa.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
      t = "websocket";
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else
      t = this.transports[0];
    this.readyState = "opening";
    try {
      t = this.createTransport(t);
    } catch {
      this.transports.shift(), this.open();
      return;
    }
    t.open(), this.setTransport(t);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(t) {
    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (e) => this.onClose("transport close", e));
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  probe(t) {
    let e = this.createTransport(t), i = !1;
    fa.priorWebsocketSuccess = !1;
    const n = () => {
      i || (e.send([{ type: "ping", data: "probe" }]), e.once("packet", (d) => {
        if (!i)
          if (d.type === "pong" && d.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", e), !e)
              return;
            fa.priorWebsocketSuccess = e.name === "websocket", this.transport.pause(() => {
              i || this.readyState !== "closed" && (c(), this.setTransport(e), e.send([{ type: "upgrade" }]), this.emitReserved("upgrade", e), e = null, this.upgrading = !1, this.flush());
            });
          } else {
            const f = new Error("probe error");
            f.transport = e.name, this.emitReserved("upgradeError", f);
          }
      }));
    };
    function s() {
      i || (i = !0, c(), e.close(), e = null);
    }
    const o = (d) => {
      const f = new Error("probe error: " + d);
      f.transport = e.name, s(), this.emitReserved("upgradeError", f);
    };
    function a() {
      o("transport closed");
    }
    function l() {
      o("socket closed");
    }
    function u(d) {
      e && d.name !== e.name && s();
    }
    const c = () => {
      e.removeListener("open", n), e.removeListener("error", o), e.removeListener("close", a), this.off("close", l), this.off("upgrading", u);
    };
    e.once("open", n), e.once("error", o), e.once("close", a), this.once("close", l), this.once("upgrading", u), e.open();
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    if (this.readyState = "open", fa.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade) {
      let t = 0;
      const e = this.upgrades.length;
      for (; t < e; t++)
        this.probe(this.upgrades[t]);
    }
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  onPacket(t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;
        case "ping":
          this.resetPingTimeout(), this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
          break;
        case "error":
          const e = new Error("server error");
          e.code = t.data, this.onError(e);
          break;
        case "message":
          this.emitReserved("data", t.data), this.emitReserved("message", t.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(t) {
    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const t = this.getWritablePackets();
      this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  getWritablePackets() {
    if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let e = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const n = this.writeBuffer[i].data;
      if (n && (e += SR(n)), i > 0 && e > this.maxPayload)
        return this.writeBuffer.slice(0, i);
      e += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} callback function.
   * @return {Socket} for chaining.
   */
  write(t, e, i) {
    return this.sendPacket("message", t, e, i), this;
  }
  send(t, e, i) {
    return this.sendPacket("message", t, e, i), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  sendPacket(t, e, i, n) {
    if (typeof e == "function" && (n = e, e = void 0), typeof i == "function" && (n = i, i = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    i = i || {}, i.compress = i.compress !== !1;
    const s = {
      type: t,
      data: e,
      options: i
    };
    this.emitReserved("packetCreate", s), this.writeBuffer.push(s), n && this.once("flush", n), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const t = () => {
      this.onClose("forced close"), this.transport.close();
    }, e = () => {
      this.off("upgrade", e), this.off("upgradeError", e), t();
    }, i = () => {
      this.once("upgrade", e), this.once("upgradeError", e);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? i() : t();
    }) : this.upgrading ? i() : t()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  onError(t) {
    fa.priorWebsocketSuccess = !1, this.emitReserved("error", t), this.onClose("transport error", t);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  onClose(t, e) {
    (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", t, e), this.writeBuffer = [], this.prevBufferLen = 0);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  filterUpgrades(t) {
    const e = [];
    let i = 0;
    const n = t.length;
    for (; i < n; i++)
      ~this.transports.indexOf(t[i]) && e.push(t[i]);
    return e;
  }
};
nE.protocol = qw;
function jR(r, t = "", e) {
  let i = r;
  e = e || typeof location < "u" && location, r == null && (r = e.protocol + "//" + e.host), typeof r == "string" && (r.charAt(0) === "/" && (r.charAt(1) === "/" ? r = e.protocol + r : r = e.host + r), /^(https?|wss?):\/\//.test(r) || (typeof e < "u" ? r = e.protocol + "//" + r : r = "https://" + r), i = zm(r)), i.port || (/^(http|ws)$/.test(i.protocol) ? i.port = "80" : /^(http|ws)s$/.test(i.protocol) && (i.port = "443")), i.path = i.path || "/";
  const s = i.host.indexOf(":") !== -1 ? "[" + i.host + "]" : i.host;
  return i.id = i.protocol + "://" + s + ":" + i.port + t, i.href = i.protocol + "://" + s + (e && e.port === i.port ? "" : ":" + i.port), i;
}
const HR = typeof ArrayBuffer == "function", $R = (r) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(r) : r.buffer instanceof ArrayBuffer, sE = Object.prototype.toString, zR = typeof Blob == "function" || typeof Blob < "u" && sE.call(Blob) === "[object BlobConstructor]", VR = typeof File == "function" || typeof File < "u" && sE.call(File) === "[object FileConstructor]";
function U_(r) {
  return HR && (r instanceof ArrayBuffer || $R(r)) || zR && r instanceof Blob || VR && r instanceof File;
}
function Gf(r, t) {
  if (!r || typeof r != "object")
    return !1;
  if (Array.isArray(r)) {
    for (let e = 0, i = r.length; e < i; e++)
      if (Gf(r[e]))
        return !0;
    return !1;
  }
  if (U_(r))
    return !0;
  if (r.toJSON && typeof r.toJSON == "function" && arguments.length === 1)
    return Gf(r.toJSON(), !0);
  for (const e in r)
    if (Object.prototype.hasOwnProperty.call(r, e) && Gf(r[e]))
      return !0;
  return !1;
}
function XR(r) {
  const t = [], e = r.data, i = r;
  return i.data = Vm(e, t), i.attachments = t.length, { packet: i, buffers: t };
}
function Vm(r, t) {
  if (!r)
    return r;
  if (U_(r)) {
    const e = { _placeholder: !0, num: t.length };
    return t.push(r), e;
  } else if (Array.isArray(r)) {
    const e = new Array(r.length);
    for (let i = 0; i < r.length; i++)
      e[i] = Vm(r[i], t);
    return e;
  } else if (typeof r == "object" && !(r instanceof Date)) {
    const e = {};
    for (const i in r)
      Object.prototype.hasOwnProperty.call(r, i) && (e[i] = Vm(r[i], t));
    return e;
  }
  return r;
}
function WR(r, t) {
  return r.data = Xm(r.data, t), delete r.attachments, r;
}
function Xm(r, t) {
  if (!r)
    return r;
  if (r && r._placeholder === !0) {
    if (typeof r.num == "number" && r.num >= 0 && r.num < t.length)
      return t[r.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(r))
    for (let e = 0; e < r.length; e++)
      r[e] = Xm(r[e], t);
  else if (typeof r == "object")
    for (const e in r)
      Object.prototype.hasOwnProperty.call(r, e) && (r[e] = Xm(r[e], t));
  return r;
}
const YR = 5;
var Lt;
(function(r) {
  r[r.CONNECT = 0] = "CONNECT", r[r.DISCONNECT = 1] = "DISCONNECT", r[r.EVENT = 2] = "EVENT", r[r.ACK = 3] = "ACK", r[r.CONNECT_ERROR = 4] = "CONNECT_ERROR", r[r.BINARY_EVENT = 5] = "BINARY_EVENT", r[r.BINARY_ACK = 6] = "BINARY_ACK";
})(Lt || (Lt = {}));
class qR {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(t) {
    this.replacer = t;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(t) {
    return (t.type === Lt.EVENT || t.type === Lt.ACK) && Gf(t) ? this.encodeAsBinary({
      type: t.type === Lt.EVENT ? Lt.BINARY_EVENT : Lt.BINARY_ACK,
      nsp: t.nsp,
      data: t.data,
      id: t.id
    }) : [this.encodeAsString(t)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(t) {
    let e = "" + t.type;
    return (t.type === Lt.BINARY_EVENT || t.type === Lt.BINARY_ACK) && (e += t.attachments + "-"), t.nsp && t.nsp !== "/" && (e += t.nsp + ","), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(t) {
    const e = XR(t), i = this.encodeAsString(e.packet), n = e.buffers;
    return n.unshift(i), n;
  }
}
class G_ extends Me {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(t) {
    super(), this.reviver = t;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(t) {
    let e;
    if (typeof t == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      e = this.decodeString(t);
      const i = e.type === Lt.BINARY_EVENT;
      i || e.type === Lt.BINARY_ACK ? (e.type = i ? Lt.EVENT : Lt.ACK, this.reconstructor = new ZR(e), e.attachments === 0 && super.emitReserved("decoded", e)) : super.emitReserved("decoded", e);
    } else if (U_(t) || t.base64)
      if (this.reconstructor)
        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved("decoded", e));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + t);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(t) {
    let e = 0;
    const i = {
      type: Number(t.charAt(0))
    };
    if (Lt[i.type] === void 0)
      throw new Error("unknown packet type " + i.type);
    if (i.type === Lt.BINARY_EVENT || i.type === Lt.BINARY_ACK) {
      const s = e + 1;
      for (; t.charAt(++e) !== "-" && e != t.length; )
        ;
      const o = t.substring(s, e);
      if (o != Number(o) || t.charAt(e) !== "-")
        throw new Error("Illegal attachments");
      i.attachments = Number(o);
    }
    if (t.charAt(e + 1) === "/") {
      const s = e + 1;
      for (; ++e && !(t.charAt(e) === "," || e === t.length); )
        ;
      i.nsp = t.substring(s, e);
    } else
      i.nsp = "/";
    const n = t.charAt(e + 1);
    if (n !== "" && Number(n) == n) {
      const s = e + 1;
      for (; ++e; ) {
        const o = t.charAt(e);
        if (o == null || Number(o) != o) {
          --e;
          break;
        }
        if (e === t.length)
          break;
      }
      i.id = Number(t.substring(s, e + 1));
    }
    if (t.charAt(++e)) {
      const s = this.tryParse(t.substr(e));
      if (G_.isPayloadValid(i.type, s))
        i.data = s;
      else
        throw new Error("invalid payload");
    }
    return i;
  }
  tryParse(t) {
    try {
      return JSON.parse(t, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(t, e) {
    switch (t) {
      case Lt.CONNECT:
        return typeof e == "object";
      case Lt.DISCONNECT:
        return e === void 0;
      case Lt.CONNECT_ERROR:
        return typeof e == "string" || typeof e == "object";
      case Lt.EVENT:
      case Lt.BINARY_EVENT:
        return Array.isArray(e) && e.length > 0;
      case Lt.ACK:
      case Lt.BINARY_ACK:
        return Array.isArray(e);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class ZR {
  constructor(t) {
    this.packet = t, this.buffers = [], this.reconPack = t;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(t) {
    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
      const e = WR(this.reconPack, this.buffers);
      return this.finishedReconstruction(), e;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const KR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder: G_,
  Encoder: qR,
  get PacketType() {
    return Lt;
  },
  protocol: YR
}, Symbol.toStringTag, { value: "Module" }));
function pr(r, t, e) {
  return r.on(t, e), function() {
    r.off(t, e);
  };
}
const JR = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class oE extends Me {
  /**
   * `Socket` constructor.
   */
  constructor(t, e, i) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, i && i.auth && (this.auth = i.auth), this._opts = Object.assign({}, i), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const t = this.io;
    this.subs = [
      pr(t, "open", this.onopen.bind(this)),
      pr(t, "packet", this.onpacket.bind(this)),
      pr(t, "error", this.onerror.bind(this)),
      pr(t, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...t) {
    return t.unshift("message"), this.emit.apply(this, t), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(t, ...e) {
    if (JR.hasOwnProperty(t))
      throw new Error('"' + t.toString() + '" is a reserved event name');
    if (e.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(e), this;
    const i = {
      type: Lt.EVENT,
      data: e
    };
    if (i.options = {}, i.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == "function") {
      const o = this.ids++, a = e.pop();
      this._registerAckCallback(o, a), i.id = o;
    }
    const n = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    return this.flags.volatile && (!n || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(i), this.packet(i)) : this.sendBuffer.push(i)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(t, e) {
    var i;
    const n = (i = this.flags.timeout) !== null && i !== void 0 ? i : this._opts.ackTimeout;
    if (n === void 0) {
      this.acks[t] = e;
      return;
    }
    const s = this.io.setTimeoutFn(() => {
      delete this.acks[t];
      for (let o = 0; o < this.sendBuffer.length; o++)
        this.sendBuffer[o].id === t && this.sendBuffer.splice(o, 1);
      e.call(this, new Error("operation has timed out"));
    }, n);
    this.acks[t] = (...o) => {
      this.io.clearTimeoutFn(s), e.apply(this, [null, ...o]);
    };
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(t, ...e) {
    const i = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((n, s) => {
      e.push((o, a) => i ? o ? s(o) : n(a) : n(o)), this.emit(t, ...e);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(t) {
    let e;
    typeof t[t.length - 1] == "function" && (e = t.pop());
    const i = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: t,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    t.push((n, ...s) => i !== this._queue[0] ? void 0 : (n !== null ? i.tryCount > this._opts.retries && (this._queue.shift(), e && e(n)) : (this._queue.shift(), e && e(null, ...s)), i.pending = !1, this._drainQueue())), this._queue.push(i), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(t = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const e = this._queue[0];
    e.pending && !t || (e.pending = !0, e.tryCount++, this.flags = e.flags, this.emit.apply(this, e.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(t) {
    t.nsp = this.nsp, this.io._packet(t);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((t) => {
      this._sendConnectPacket(t);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(t) {
    this.packet({
      type: Lt.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(t) {
    this.connected || this.emitReserved("connect_error", t);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(t, e) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", t, e);
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case Lt.CONNECT:
          t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case Lt.EVENT:
        case Lt.BINARY_EVENT:
          this.onevent(t);
          break;
        case Lt.ACK:
        case Lt.BINARY_ACK:
          this.onack(t);
          break;
        case Lt.DISCONNECT:
          this.ondisconnect();
          break;
        case Lt.CONNECT_ERROR:
          this.destroy();
          const i = new Error(t.data.message);
          i.data = t.data.data, this.emitReserved("connect_error", i);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(t) {
    const e = t.data || [];
    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const e = this._anyListeners.slice();
      for (const i of e)
        i.apply(this, t);
    }
    super.emit.apply(this, t), this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(t) {
    const e = this;
    let i = !1;
    return function(...n) {
      i || (i = !0, e.packet({
        type: Lt.ACK,
        id: t,
        data: n
      }));
    };
  }
  /**
   * Called upon a server acknowlegement.
   *
   * @param packet
   * @private
   */
  onack(t) {
    const e = this.acks[t.id];
    typeof e == "function" && (e.apply(this, t.data), delete this.acks[t.id]);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(t, e) {
    this.id = t, this.recovered = e && this._pid === e, this._pid = e, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {
      this.notifyOutgoingListeners(t), this.packet(t);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: Lt.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(t) {
    return this.flags.compress = t, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(t) {
    return this.flags.timeout = t, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(t) {
    if (!this._anyListeners)
      return this;
    if (t) {
      const e = this._anyListeners;
      for (let i = 0; i < e.length; i++)
        if (t === e[i])
          return e.splice(i, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners)
      return this;
    if (t) {
      const e = this._anyOutgoingListeners;
      for (let i = 0; i < e.length; i++)
        if (t === e[i])
          return e.splice(i, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const e = this._anyOutgoingListeners.slice();
      for (const i of e)
        i.apply(this, t.data);
    }
  }
}
function zh(r) {
  r = r || {}, this.ms = r.min || 100, this.max = r.max || 1e4, this.factor = r.factor || 2, this.jitter = r.jitter > 0 && r.jitter <= 1 ? r.jitter : 0, this.attempts = 0;
}
zh.prototype.duration = function() {
  var r = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t = Math.random(), e = Math.floor(t * this.jitter * r);
    r = Math.floor(t * 10) & 1 ? r + e : r - e;
  }
  return Math.min(r, this.max) | 0;
};
zh.prototype.reset = function() {
  this.attempts = 0;
};
zh.prototype.setMin = function(r) {
  this.ms = r;
};
zh.prototype.setMax = function(r) {
  this.max = r;
};
zh.prototype.setJitter = function(r) {
  this.jitter = r;
};
class Wm extends Me {
  constructor(t, e) {
    var i;
    super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (e = t, t = void 0), e = e || {}, e.path = e.path || "/socket.io", this.opts = e, Bv(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((i = e.randomizationFactor) !== null && i !== void 0 ? i : 0.5), this.backoff = new zh({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = "closed", this.uri = t;
    const n = e.parser || KR;
    this.encoder = new n.Encoder(), this.decoder = new n.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(t) {
    return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);
  }
  reconnectionDelay(t) {
    var e;
    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);
  }
  randomizationFactor(t) {
    var e;
    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);
  }
  reconnectionDelayMax(t) {
    var e;
    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);
  }
  timeout(t) {
    return arguments.length ? (this._timeout = t, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(t) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new nE(this.uri, this.opts);
    const e = this.engine, i = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const n = pr(e, "open", function() {
      i.onopen(), t && t();
    }), s = pr(e, "error", (o) => {
      i.cleanup(), i._readyState = "closed", this.emitReserved("error", o), t ? t(o) : i.maybeReconnectOnOpen();
    });
    if (this._timeout !== !1) {
      const o = this._timeout;
      o === 0 && n();
      const a = this.setTimeoutFn(() => {
        n(), e.close(), e.emit("error", new Error("timeout"));
      }, o);
      this.opts.autoUnref && a.unref(), this.subs.push(function() {
        clearTimeout(a);
      });
    }
    return this.subs.push(n), this.subs.push(s), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(t) {
    return this.open(t);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const t = this.engine;
    this.subs.push(pr(t, "ping", this.onping.bind(this)), pr(t, "data", this.ondata.bind(this)), pr(t, "error", this.onerror.bind(this)), pr(t, "close", this.onclose.bind(this)), pr(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(t) {
    try {
      this.decoder.add(t);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(t) {
    rE(() => {
      this.emitReserved("packet", t);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(t) {
    this.emitReserved("error", t);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(t, e) {
    let i = this.nsps[t];
    return i ? this._autoConnect && !i.active && i.connect() : (i = new oE(this, t, e), this.nsps[t] = i), i;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(t) {
    const e = Object.keys(this.nsps);
    for (const i of e)
      if (this.nsps[i].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(t) {
    const e = this.encoder.encode(t);
    for (let i = 0; i < e.length; i++)
      this.engine.write(e[i], t.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(t, e) {
    this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, e), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const t = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const e = this.backoff.duration();
      this._reconnecting = !0;
      const i = this.setTimeoutFn(() => {
        t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open((n) => {
          n ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", n)) : t.onreconnect();
        }));
      }, e);
      this.opts.autoUnref && i.unref(), this.subs.push(function() {
        clearTimeout(i);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const t = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t);
  }
}
const Qh = {};
function jf(r, t) {
  typeof r == "object" && (t = r, r = void 0), t = t || {};
  const e = jR(r, t.path || "/socket.io"), i = e.source, n = e.id, s = e.path, o = Qh[n] && s in Qh[n].nsps, a = t.forceNew || t["force new connection"] || t.multiplex === !1 || o;
  let l;
  return a ? l = new Wm(i, t) : (Qh[n] || (Qh[n] = new Wm(i, t)), l = Qh[n]), e.query && !t.query && (t.query = e.queryKey), l.socket(e.path, t);
}
Object.assign(jf, {
  Manager: Wm,
  Socket: oE,
  io: jf,
  connect: jf
});
var dr, Hr, $r, Go, jo, fs, ds, ps, wv, Ev, Cc, Mh, Tv, Rh, Ho, Sv, $o, kh;
const Pv = class {
  constructor(t = {}, e) {
    D(this, "hFactoryCls", {});
    D(this, "elc", new Dh());
    D(this, "fetch", (t) => fetch(t));
    D(this, "resolution", 1);
    D(this, "cfg");
    D(this, "data", { sys: {}, mark: {}, kidoku: {} });
    D(this, "val");
    D(this, "appPixi");
    _(this, dr, 0);
    _(this, Hr, 0);
    _(this, $r, 1);
    _(this, Go, 0);
    _(this, jo, 0);
    _(this, fs, 0);
    _(this, ds, 0);
    D(this, "isFullScr", !1);
    D(this, "extPort", 3776);
    _(this, ps, void 0);
    _(this, wv, {
      auth: (t) => {
        if (t.t !== this.cfg.oCfg.debuger_token) {
          this.end();
          return;
        }
        this.toast("接続");
      },
      continue: () => this.toast("再生"),
      disconnect: () => this.toast("切断"),
      restart: (t) => {
        this.send2Dbg((t == null ? void 0 : t.ri) ?? "", {}), this.end(), this.run();
      },
      pause: () => this.toast("一時停止"),
      stopOnEntry: () => this.toast("一時停止"),
      stopOnDataBreakpoint: () => this.toast("注意"),
      stopOnBreakpoint: () => this.toast("注意"),
      stopOnStep: () => this.toast("一歩進む"),
      stopOnStepIn: () => this.toast("ステップイン"),
      stopOnStepOut: () => this.toast("ステップアウト"),
      stopOnBackstep: () => this.toast("一歩戻る"),
      _addPath: (t) => this.cfg.addPath(t.fn, t.o)
    });
    D(this, "pathBaseCnvSnPath4Dbg", "");
    D(this, "fire");
    _(this, Cc, []);
    D(this, "callHook", (t, e) => {
    });
    D(this, "send2Dbg", (t, e) => {
      var i;
      (i = h(this, ps)) == null || i.emit("data", t, e);
    });
    D(this, "copyBMFolder", (t, e) => {
    });
    D(this, "eraseBMFolder", (t) => {
    });
    D(this, "close", () => !1);
    D(this, "_export", () => !1);
    D(this, "_import", () => !1);
    D(this, "navigate_to", () => !1);
    D(this, "title", (t) => {
      const { text: e } = t;
      if (!e)
        throw "[title] textは必須です";
      return g(this, Mh, e), this.titleSub(h(this, Mh) + h(this, Rh)), !1;
    });
    _(this, Mh, "");
    _(this, Tv, (t) => {
      if (!t.key)
        return this.tglFlscr_sub(), !1;
      const e = t.key.toLowerCase();
      return this.elc.add(document, "keydown", (i) => {
        (i.altKey ? i.key === "Alt" ? "" : "alt+" : "") + (i.ctrlKey ? i.key === "Control" ? "" : "ctrl+" : "") + (i.shiftKey ? i.key === "Shift" ? "" : "shift+" : "") + i.key.toLowerCase() === e && (i.stopPropagation(), this.tglFlscr_sub());
      }, { passive: !0 }), !1;
    });
    D(this, "update_check", () => !1);
    D(this, "window", () => !1);
    _(this, Rh, "");
    _(this, Ho, (t, e) => ({ ret: e.toString(), ext_num: 0 }));
    _(this, Sv, {
      1: { ext: "jpeg", fnc: (t) => h(this, $o).call(this, t), mime: "image/jpeg" },
      2: { ext: "png", fnc: (t) => h(this, $o).call(this, t), mime: "image/png" },
      3: { ext: "svg", fnc: (t) => h(this, $o).call(this, t), mime: "image/svg+xml" },
      4: { ext: "webp", fnc: (t) => h(this, $o).call(this, t), mime: "image/webp" },
      10: { ext: "mp3", fnc: (t) => t.arrayBuffer(), mime: "audio/mpeg" },
      11: { ext: "m4a", fnc: (t) => t.arrayBuffer(), mime: "audio/aac" },
      12: { ext: "ogg", fnc: (t) => t.arrayBuffer(), mime: "audio/ogg" },
      13: { ext: "aac", fnc: (t) => t.arrayBuffer(), mime: "audio/aac" },
      14: { ext: "flac", fnc: (t) => t.arrayBuffer(), mime: "audio/flac" },
      15: { ext: "wav", fnc: (t) => t.arrayBuffer(), mime: "audio/wav" },
      20: { ext: "mp4", fnc: (t) => h(this, kh).call(this, t), mime: "video/mp4" },
      21: { ext: "webm", fnc: (t) => h(this, kh).call(this, t), mime: "video/webm" },
      22: { ext: "ogv", fnc: (t) => h(this, kh).call(this, t), mime: "video/ogv" }
    });
    _(this, $o, (t) => new Promise((e, i) => {
      const n = new Image();
      n.onload = () => e(n), n.onerror = (s) => i(s), n.src = URL.createObjectURL(t);
    }));
    _(this, kh, (t) => new Promise((e, i) => {
      const n = document.createElement("video");
      this.elc.add(n, "error", () => {
        var s;
        return i(((s = n == null ? void 0 : n.error) == null ? void 0 : s.message) ?? "");
      }), this.elc.add(n, "canplay", () => e(n)), n.src = URL.createObjectURL(t);
    }));
    D(this, "enc", (t) => t);
    D(this, "stk", () => "");
    D(this, "hash", (t) => "");
    D(this, "isApp", !1);
    D(this, "$path_downloads", "");
    D(this, "$path_userdata", "");
    this.hPlg = t, this.arg = e;
  }
  async loaded(t, e) {
    const i = t.snsys_pre;
    return delete t.snsys_pre, i == null ? void 0 : i.init({
      addTag: () => {
      },
      addLayCls: () => {
      },
      searchPath: () => "",
      getVal: () => ({}),
      resume: () => {
      },
      render: () => {
      },
      setDec: (n) => g(this, Ho, n),
      setEnc: (n) => this.enc = n,
      getStK: (n) => this.stk = n,
      getHash: (n) => this.hash = n
    });
  }
  get cur() {
    return this.arg.cur;
  }
  get crypto() {
    return this.arg.crypto;
  }
  destroy() {
    this.elc.clear();
  }
  async loadPath(t, e) {
    this.cfg = e;
  }
  initVal(t, e, i) {
  }
  flush() {
  }
  async run() {
  }
  init(t, e, i, n) {
    this.val = i, this.appPixi = e;
    let s = "";
    try {
      this.val.setSys(this), s = "sys", s += Number(this.val.getVal("sys:TextLayer.Back.Alpha", 1)), s = "kidoku", this.val.saveKidoku();
    } catch (o) {
      console.error(`セーブデータ（${s}）が壊れています。一度クリアする必要があります %o`, o);
    }
    return t.close = (o) => this.close(o), t.export = (o) => this._export(o), t.import = (o) => this._import(o), t.navigate_to = (o) => this.navigate_to(o), t.title = (o) => this.title(o), t.toggle_full_screen = (o) => h(this, Tv).call(this, o), t.update_check = (o) => this.update_check(o), t.window = (o) => this.window(o), i.setVal_Nochk("tmp", "const.sn.isApp", () => this.isApp), i.setVal_Nochk("tmp", "const.sn.isDbg", () => L.isDbg), i.setVal_Nochk("tmp", "const.sn.isPackaged", () => L.isPackaged), this.val.defTmp("const.sn.displayState", () => this.isFullScr), i.setVal_Nochk("sys", Pv.VALNM_CFG_NS, this.cfg.oCfg.save_ns), i.flush(), L.isDbg && this.attach_debug(n), this.hFactoryCls = {}, Object.values(this.hPlg).map((o) => o.init({
      addTag: (a, l) => {
        if (t[a])
          throw `すでに定義済みのタグ[${a}]です`;
        t[a] = l;
      },
      addLayCls: (a, l) => {
        if (this.hFactoryCls[a])
          throw `すでに定義済みのレイヤcls【${a}】です`;
        this.hFactoryCls[a] = l;
      },
      searchPath: (a, l = "") => this.cfg.searchPath(a, l),
      getVal: i.getVal,
      resume: () => n.resume(),
      render: (a, l, u = !1) => this.appPixi.renderer.render(a, { renderTexture: l, clear: u }),
      setDec: (a) => g(this, Ho, a),
      setEnc: (a) => this.enc = a,
      getStK: (a) => this.stk = a,
      getHash: (a) => this.hash = a
    }));
  }
  get cvsWidth() {
    return h(this, dr);
  }
  get cvsHeight() {
    return h(this, Hr);
  }
  get cvsScale() {
    return h(this, $r);
  }
  get ofsLeft4elm() {
    return h(this, Go);
  }
  get ofsTop4elm() {
    return h(this, jo);
  }
  get ofsPadLeft_Dom2PIXI() {
    return h(this, fs);
  }
  get ofsPadTop_Dom2PIXI() {
    return h(this, ds);
  }
  cvsResize() {
    var l;
    let t = globalThis.innerWidth, e = globalThis.innerHeight;
    const i = ui.cvs, n = i.parentElement !== document.body;
    if (n) {
      const u = globalThis.getComputedStyle(i);
      t = parseFloat(u.width), e = parseFloat(u.height);
    }
    if (L.isMobile) {
      const c = (((l = screen.orientation) == null ? void 0 : l.angle) ?? 0) % 180 === 0;
      (c && t > e || !c && t < e) && ([t, e] = [e, t]);
    }
    const s = i.getBoundingClientRect();
    if (K(L.hDip, "expanding", !0) || n || L.stageW > t || L.stageH > e)
      if (L.stageW / L.stageH <= t / e ? (g(this, Hr, e), g(this, dr, L.stageW / L.stageH * e)) : (g(this, dr, t), g(this, Hr, L.stageH / L.stageW * t)), g(this, $r, h(this, dr) / L.stageW), n)
        g(this, fs, 0), g(this, ds, 0);
      else {
        const u = 1 - h(this, $r);
        L.isMobile ? (g(this, fs, (t - h(this, dr)) / 2 * u), g(this, ds, (e - h(this, Hr)) / 2 * u)) : (g(this, fs, s.left * u), g(this, ds, s.top * u));
      }
    else
      g(this, dr, L.stageW), g(this, Hr, L.stageH), g(this, $r, 1), g(this, fs, 0), g(this, ds, 0);
    const o = i.parentElement.style;
    n || (o.position = "relative", o.width = `${h(this, dr)}px`, o.height = `${h(this, Hr)}px`);
    const a = i.style;
    a.width = o.width, a.height = o.height, n ? (g(this, Go, s.left), g(this, jo, s.top)) : (g(this, Go, 0), g(this, jo, 0)), this.isFullScr && (g(this, Go, h(this, Go) + (t - h(this, dr)) / 2), g(this, jo, h(this, jo) + (e - h(this, Hr)) / 2));
  }
  // デバッガ接続
  attach_debug(t) {
    this.attach_debug = () => {
    };
    const e = document.createElement("style");
    e.innerHTML = `/* SKYNovel Dbg */
.sn_BounceInOut { animation: sn_kfBounceInOut linear 1.5s; }
@keyframes sn_kfBounceInOut{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
10%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
20%	{				transform: scaleX(0.95) scaleY(0.95);}
30%	{				transform: scaleX(1.00) scaleY(1.00);}
70%	{opacity: 1;}
100%{opacity: 0;}
}
.sn_BounceIn { animation: sn_kfBounceIn linear 0.3s; }
@keyframes sn_kfBounceIn{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
50%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
100%{				transform: scaleX(0.95) scaleY(0.95);}
}
.sn_HopIn { animation: sn_kfHopIn linear 0.8s; }
@keyframes sn_kfHopIn{
0%	{transform:	translate(0px,   0px);}
15% {transform:	translate(0px, -25px);}
30% {transform:	translate(0px,   0px);}
45% {transform:	translate(0px, -15px);}
60% {transform:	translate(0px,   0px);}
75% {transform:	translate(0px,  -5px);}
100%{transform:	translate(0px,   0px);}
}`, document.getElementsByTagName("head")[0].appendChild(e), this.addHook((i, n) => {
      var s, o;
      return (o = (s = h(this, wv))[i]) == null ? void 0 : o.call(s, n);
    }), g(this, ps, jf(`http://localhost:${this.extPort}`)), h(this, ps).on("data", (i, n) => {
      this.callHook(i, n);
    }).on("disconnect", () => t.setLoop(!0)), this.callHook = (i, n) => {
      for (const s of h(this, Cc))
        s(i, n);
    };
  }
  end() {
    var t;
    (t = h(this, ps)) == null || t.disconnect(), g(this, ps, void 0);
  }
  toast(t) {
    const e = document.body;
    e.querySelectorAll(".sn_BounceIn, .sn_HopIn").forEach((o) => e.removeChild(o));
    const i = document.createElement("img"), n = h(Pv, Ev)[t];
    i.src = `data:image/svg+xml;base64,${n.dat}`;
    const s = Math.min(L.stageW, L.stageH) / 4 * h(this, $r);
    i.width = i.height = s, i.style.cssText = `position: absolute;
left: ${(L.stageW - s) / 2 * h(this, $r) + s * (n.dx ?? 0)}px;
top: ${(L.stageH - s) / 2 * h(this, $r) + s * (n.dy ?? 0)}px;`, i.classList.add("sn_toast", n.ease ?? "sn_BounceInOut"), n.ease || i.addEventListener("animationend", () => e.removeChild(i), { once: !0, passive: !0 }), e.insertBefore(i, ui.cvs);
  }
  setFire(t) {
    this.fire = t;
  }
  addHook(t) {
    h(this, Cc).push(t);
  }
  titleSub(t) {
  }
  tglFlscr_sub() {
  }
  setTitleInfo(t) {
    g(this, Rh, t), this.titleSub(h(this, Mh) + h(this, Rh));
  }
  decStr(t, e) {
    return h(this, Ho).call(this, t, e).ret;
  }
  async dec(t, e) {
    const { ret: i, ext_num: n } = h(this, Ho).call(this, t, e), s = h(this, Sv)[n];
    return s != null && s.fnc ? await s.fnc(new Blob([i], { type: s.mime })) : i;
  }
  get path_downloads() {
    return this.$path_downloads;
  }
  get path_userdata() {
    return this.$path_userdata;
  }
  canCapturePage(t, e) {
    return !1;
  }
  async savePic(t, e) {
  }
  async appendFile(t, e, i) {
  }
  async ensureFileSync(t) {
  }
};
let pl = Pv;
dr = new WeakMap(), Hr = new WeakMap(), $r = new WeakMap(), Go = new WeakMap(), jo = new WeakMap(), fs = new WeakMap(), ds = new WeakMap(), ps = new WeakMap(), wv = new WeakMap(), Ev = new WeakMap(), Cc = new WeakMap(), Mh = new WeakMap(), Tv = new WeakMap(), Rh = new WeakMap(), Ho = new WeakMap(), Sv = new WeakMap(), $o = new WeakMap(), kh = new WeakMap(), D(pl, "VALNM_CFG_NS", "const.sn.cfg.ns"), _(pl, Ev, {
  // Thanks ICOOON MONO https://icooon-mono.com/ 、 https://vectr.com/ で 640x640化、ImageOptim経由、Base64エンコーダー https://lab.syncer.jp/Tool/Base64-encode/ 
  接続: { dx: -1, dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMCAyOTJ2NTUuODhoMTI3LjEzYzEyLjM3IDQ2IDU0LjEyIDc5Ljg3IDEwNCA3OS44N2g3Ny44N3YtMjE1LjYyYy00Ni43MyAwLTcyLjY4IDAtNzcuODggMC00OS43NCAwLTkxLjYyIDMzLjg3LTEwMy45OSA3OS44Ny0xNi45NSAwLTU5LjMzIDAtMTI3LjEzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im01MTIuODggMjkyYy0xMi4zOC00Ni01NC4xMy03OS44Ny0xMDQtNzkuODctNS4yMSAwLTMxLjIxIDAtNzggMHYyMTUuNzRoNzcuODdjNDkuODggMCA5MS43NS0zMy44NyAxMDQtNzkuODdoMTI3LjI1di01NmMtNzYuMjcgMC0xMTguNjUgMC0xMjcuMTIgMHoiLz48L2RlZnM+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9IiMzYWFiZDIiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYiIvPjx1c2UgZmlsbD0iIzNhYWJkMiIgeGxpbms6aHJlZj0iI2MiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNjIi8+PC9zdmc+" },
  切断: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMTkxLjUzIDIyMS4yNGMtNDUuNjggMC04NC4wMSAzMS4wNC05NS4zIDczLjE2LTYuNDEgMC0zOC40OSAwLTk2LjIzIDB2NTEuMjFoOTYuMjNjMTEuMyA0Mi4xMSA0OS42MyA3My4xNiA5NS4zIDczLjE2aDcxLjMzdi00OC4yNGg1My43OHYtMTAxLjA1aC01My43OHYtNDguMjRjLTQyLjggMC02Ni41NyAwLTcxLjMzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im00NDguNDcgMjIxLjIzYy00Ljc2IDAtMjguNTMgMC03MS4zMyAwdjE5Ny41M2g3MS4zM2M0NS42OCAwIDgzLjk5LTMxLjA0IDk1LjI5LTczLjE1aDk2LjI0di01MS4yMWgtOTYuMjRjLTMzLjA4LTQ4Ljc4LTY0Ljg0LTczLjE3LTk1LjI5LTczLjE3eiIvPjwvZGVmcz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0iI2RmNTY1NiIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSIjZGY1NjU2IiB4bGluazpocmVmPSIjYyIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2MiLz48L3N2Zz4=" },
  再生: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yNTguODMgMTExLjA1Yy0xLjI5Ljc5LTIuOTMuODMtNC4yNi4wNC0xLjI5LS43NC0yLjExLTIuMTItMi4xMS0zLjY3IDAtNy4xNiAwLTQyLjk3IDAtMTA3LjQzczAtMTAwLjI3IDAtMTA3LjQzYzAtMS41My44Mi0yLjkzIDIuMTEtMy42OCAxLjMzLS43NiAyLjk3LS43MiA0LjI2LjA0IDE4IDEwLjc1IDE2MiA5Ni43MSAxODAgMTA3LjQ2IDEuMjkuNzMgMi4wNSAyLjE0IDIuMDUgMy42MSAwIDEuNDktLjc2IDIuODgtMi4wNSAzLjYzLTM2IDIxLjQ5LTE2MiA5Ni42OS0xODAgMTA3LjQzeiIvPjwvZGVmcz48cGF0aCBkPSJtMTU0LjU3IDE3MC4xOWgzNDYuMTV2MzA3LjY5aC0zNDYuMTV6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
  一時停止: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yMDAgMTAwdi0yMDBoODB2MjAwem0xNjAgMHYtMjAwaDgwdjIwMHoiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxODAuNDFoMzUyLjR2MjgyLjY5aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
  注意: { ease: "sn_HopIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMzQzLjM0IDI5LjJjLTEwLjM3LTE3Ljk3LTM2LjMxLTE3Ljk3LTQ2LjY5IDAtMjkuMyA1MC43NS0yNjMuNyA0NTYuNzQtMjkzIDUwNy40OS0xMC4zNyAxNy45NyAyLjU5IDQwLjQ0IDIzLjM0IDQwLjQ0aDU4Ni4wMWMyMC43NSAwIDMzLjcyLTIyLjQ2IDIzLjM1LTQwLjQ0LTU4LjYtMTAxLjUtMjYzLjctNDU2Ljc0LTI5My4wMS01MDcuNDl6bS0yMy4zNCA0ODIuODNjLTE0LjUyIDAtMjYuMjktMi43MS0yNi4yOS02LjA2IDAtNC4yMSAwLTM3Ljg2IDAtNDIuMDcgMC0zLjM1IDExLjc3LTYuMDcgMjYuMjktNi4wN3MyNi4yOSAyLjcyIDI2LjI5IDYuMDd2NDIuMDdjLTcuODQgNC4wNC0xNi42MSA2LjA2LTI2LjI5IDYuMDZ6bTIxLjk5LTEwMy44NGMwIDUuNDMtOS44NSA5LjgzLTIxLjk5IDkuODMtMTIuMTUgMC0yMS45OS00LjQtMjEuOTktOS44MyAwLS4xMy4wNy0uMjUuMDgtLjM4LTEuMzctMTcuNTYtMTIuMy0xNTguMDYtMTMuNjctMTc1LjYyIDAtNS40MyAxNS45My05Ljg0IDM1LjU4LTkuODRzMzUuNTggNC40MSAzNS41OCA5Ljg0Yy0uOTEgMTEuNy01LjQ3IDcwLjI1LTEzLjY3IDE3NS42Mi4wNi4xNi4wOC4yOS4wOC4zOHoiLz48L2RlZnM+PHBhdGggZD0ibTI0MS4yOSAxOTEuNDRoMTQ1LjQ5djM1MS42NmgtMTQ1LjQ5eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iI2QyYmYzYSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
  一歩進む: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0zNzYuOTMgOTEuOTdjMC01My41MSAwLTgzLjI0IDAtODkuMTktLjE1LjE0LS4yNS4zNC0uNDQuNDUtMTYuMTEgOS42Mi0xNDQuOTUgODYuNTQtMTYxLjA2IDk2LjE1LTEuMTUuNjktMi42Mi43My0zLjgxLjAyLTEuMTUtLjY0LTEuODktMS44OS0xLjg5LTMuMjggMC02LjQxIDAtMzguNDQgMC05Ni4xMSAwLTU3LjY5IDAtODkuNzQgMC05Ni4xNSAwLTEuMzUuNzQtMi42MiAxLjg5LTMuMjkgMS4xOS0uNjggMi42Ni0uNjQgMy44MS4wNCAxNi4xMSA5LjYyIDE0NC45NSA4Ni41NCAxNjEuMDYgOTYuMTYuMTkuMS4yOS4zMS40NC40NSAwLTYuMTMgMC0zNi43NyAwLTkxLjkyaDUzLjMydjE4Ni42N3oiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxNTQuMmgzNTIuNHYzMDguOWgtMzUyLjR6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
  一歩戻る: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem00MzAuMjcgOTYuMTRjMCAxLjM1LS43NCAyLjYyLTEuODkgMy4yOC0xLjE5LjY5LTIuNjYuNjUtMy44MS0uMDMtMTYuMTEtOS42Mi0xNDQuOTUtODYuNTQtMTYxLjA1LTk2LjE2LS4yLS4xLS4yOS0uMzEtLjQ1LS40NXY5MS45MmgtNTMuMzJ2LTE4Ni42N2g1My4zMnY4OS4xOWMuMTYtLjE0LjI1LS4zNC40NS0uNDUgMTYuMS05LjYyIDE0NC45NC04Ni41NCAxNjEuMDUtOTYuMTYgMS4xNS0uNjggMi42Mi0uNzIgMy44MS0uMDEgMS4xNS42NCAxLjg5IDEuODkgMS44OSAzLjI4djk2LjExeiIvPjwvZGVmcz48cGF0aCBkPSJtMTQ3LjQ5IDE1NC4yaDM1Mi40djMwOC45aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
  ステップイン: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMTkuOTljMCAxNzYuNzQgMTQzLjI3IDMyMC4wMSAzMjAuMDEgMzIwLjAxIDE3Ni43MiAwIDMxOS45OS0xNDMuMjcgMzE5Ljk5LTMyMC4wMSAwLTE3Ni43Mi0xNDMuMjctMzE5Ljk5LTMxOS45OS0zMTkuOTktMTc2Ljc0IDAtMzIwLjAxIDE0My4yNy0zMjAuMDEgMzE5Ljk5em0xNTMuMDUtMjkuNzIgNTUuMTItNTUuMTMgMTExLjg0IDExMS44MiAxMTEuODItMTExLjgyIDU1LjEyIDU1LjEyLTE2Ni45NCAxNjYuOTd6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
  ステップアウト: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjAuMDFjMCAxNzYuNzIgMTQzLjI3IDMxOS45OSAzMTkuOTkgMzE5Ljk5IDE3Ni43NCAwIDMyMC4wMS0xNDMuMjcgMzIwLjAxLTMxOS45OSAwLTE3Ni43NC0xNDMuMjctMzIwLjAxLTMyMC4wMS0zMjAuMDEtMTc2LjcyIDAtMzE5Ljk5IDE0My4yNy0zMTkuOTkgMzIwLjAxem0zMTkuOTktMjYuOTgtMTExLjgyIDExMS44My01NS4xMi01NS4xMyAxNjYuOTQtMTY2Ljk2IDE2Ni45NiAxNjYuOTYtNTUuMTIgNTUuMTN6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" }
});
window.Buffer = T0;
class QR extends pl {
  constructor() {
    super(...arguments);
    D(this, "isApp", !0);
  }
  async loadPath(e, i) {
    await super.loadPath(e, i);
    const n = this.arg.cur + "path.json", s = await this.readFileSync(n), o = JSON.parse(this.decStr(n, s));
    for (const [a, l] of Object.entries(o)) {
      const u = e[a] = l;
      for (const [c, d] of Object.entries(u))
        c !== ":cnt" && (u[c] = this.arg.cur + d);
    }
  }
  init(e, i, n, s) {
    const o = super.init(e, i, n, s);
    return document.body.style.backgroundColor = "#000", o;
  }
  async savePic(e, i) {
    const n = i.slice(i.indexOf(",", 20) + 1);
    try {
      this.ensureFileSync(e), await this.writeFileSync(e, T0.from(n, "base64")), L.debugLog && console.log(`画像ファイル ${e} を保存しました`);
    } catch (s) {
      throw s;
    }
  }
  async readFileSync(e) {
    return "";
  }
  async writeFileSync(e, i, n) {
  }
}
const Ht = window.to_app;
var Le, Mc, Nh, Ah, Hf;
class rk extends QR {
  constructor(e = {}, i = { cur: "prj/", crypto: !1, dip: "" }) {
    super(e, i);
    _(this, Ah);
    _(this, Le, {
      getAppPath: "",
      isPackaged: !1,
      downloads: "",
      userData: "",
      getVersion: "",
      env: {},
      platform: "",
      arch: ""
    });
    D(this, "readFileSync", Ht.readFileSync);
    D(this, "writeFileSync", Ht.writeFileSync);
    D(this, "appendFile", Ht.appendFile);
    D(this, "ensureFileSync", Ht.ensureFileSync);
    D(this, "$path_userdata", "");
    D(this, "$path_downloads", "");
    _(this, Mc, () => Ht.Store({
      cwd: this.$path_userdata + "storage",
      name: this.arg.crypto ? "data_" : "data",
      encryptionKey: this.arg.crypto ? this.stk() : void 0
    }));
    _(this, Nh, void 0);
    D(this, "copyBMFolder", async (e, i) => {
      const n = `${this.$path_userdata}storage/${e}/`, s = `${this.$path_userdata}storage/${i}/`;
      await Ht.existsSync(n) && Ht.copySync(n, s);
    });
    D(this, "eraseBMFolder", async (e) => {
      await Ht.removeSync(`${this.$path_userdata}storage/${e}/`);
    });
    // アプリの終了
    D(this, "close", () => (Ht.win_close(), !1));
    // プレイデータをエクスポート
    D(this, "_export", () => (Ht.zip(
      this.$path_userdata + "storage/",
      this.$path_downloads + (this.crypto ? "" : "no_crypto_") + this.cfg.getNs() + xl("-", "_", "") + ".spd"
    ), L.debugLog && console.log("プレイデータをエクスポートしました"), this.fire("sn:exported", new Event("click")), !1));
    // プレイデータをインポート
    D(this, "_import", () => {
      const e = this.flush;
      return new Promise((i, n) => {
        const s = document.createElement("input");
        s.type = "file", s.accept = ".spd, text/plain", s.onchange = () => {
          s.files ? i(s.files[0].path) : n();
        }, s.click();
      }).then(async (i) => {
        this.flush = () => {
        }, Ht.unzip(i, this.$path_userdata + "storage/"), await h(this, Mc).call(this);
        const n = await Ht.Store_get();
        this.data.sys = n.sys, this.data.mark = n.mark, this.data.kidoku = n.kidoku, this.flush = e, this.flush(), this.val.updateData(n), L.debugLog && console.log("プレイデータをインポートしました"), this.fire("sn:imported", new Event("click"));
      }), !1;
    });
    // ＵＲＬを開く
    D(this, "navigate_to", (e) => {
      const { url: i } = e;
      if (!i)
        throw "[navigate_to] urlは必須です";
      return Ht.navigate_to(i), !1;
    });
    // 全画面状態切替
    D(this, "tglFlscr_sub", async () => Ht.setSimpleFullScreen(
      this.isFullScr = !await Ht.isSimpleFullScreen()
    ));
    // 更新チェック
    D(this, "update_check", (e) => {
      const { url: i } = e;
      if (!i)
        throw "[update_check] urlは必須です";
      if (i.at(-1) !== "/")
        throw "[update_check] urlの最後は/です";
      return L.debugLog && wt.myTrace(`[update_check] url=${i}`, "D"), (async () => {
        let n = {}, s = "", o = "";
        const a = await this.fetch(i + "_index.json");
        if (a.ok)
          L.debugLog && wt.myTrace("[update_check] _index.jsonを取得しました", "D"), n = await a.json(), o = n.version;
        else {
          const d = await this.fetch(i + `latest${L.isMac ? "-mac" : ""}.yml`);
          if (!d.ok) {
            L.debugLog && wt.myTrace("[update_check] [update_check] .ymlが見つかりません");
            return;
          }
          L.debugLog && wt.myTrace("[update_check] .ymlを取得しました", "D"), s = await d.text();
          const f = /version: (.+)/.exec(s);
          if (!f)
            throw "[update_check] .yml に version が見つかりません";
          [, o] = f;
        }
        const l = h(this, Le).getVersion;
        if (L.debugLog && wt.myTrace(`[update_check] 現在ver=${l} 新規ver=${o}`, "D"), o === l) {
          L.debugLog && wt.myTrace("[update_check] バージョン更新なし", "I");
          return;
        }
        const u = {
          title: "アプリ更新",
          icon: h(this, Le).getAppPath + "/app/icon.png",
          buttons: ["OK", "Cancel"],
          defaultId: 0,
          cancelId: 1,
          message: `アプリ【${this.cfg.oCfg.book.title}】に更新があります。
ダウンロードしますか？`,
          detail: `現在 NOW ver ${l}
新規 NEW ver ${o}`
        }, { response: c } = await Ht.showMessageBox(u);
        if (!(c > 0)) {
          if (L.debugLog && wt.myTrace("[update_check] アプリダウンロード開始", "D"), a.ok) {
            const d = h(this, Le).platform + "_" + h(this, Le).arch, { cn: f, path: v } = n[d];
            if (f)
              await x(this, Ah, Hf).call(this, i, d + "-" + f, v);
            else {
              let m = "";
              const p = new RegExp("^" + h(this, Le).platform + "_"), y = Object.entries(n).flatMap(([w, { path: E, cn: O }]) => p.test(w) ? (m += `
- ` + E, () => x(this, Ah, Hf).call(this, i, w + "-" + O, E)) : []);
              u.message = `CPU = ${h(this, Le).arch}
に対応するファイルが見つかりません。同じOSのファイルをすべてダウンロードしますか？`, u.detail = y.length + " 個ファイルがあります" + m;
              const { response: b } = await Ht.showMessageBox(u);
              if (b > 0)
                return;
              await Promise.allSettled(y);
            }
          } else {
            const d = /path: (.+)/.exec(s);
            if (!d)
              throw "[update_check] path が見つかりません";
            const [, f] = d;
            L.debugLog && wt.myTrace(`[update_check] path=${f}`, "D");
            const v = /sha512: (.+)/.exec(s);
            if (!v)
              throw "[update_check] sha512 が見つかりません";
            const [, m] = v;
            L.debugLog && wt.myTrace(`[update_check] sha=${m}=`, "D");
            const [, p, y] = /(.+)(\.\w+)/.exec(f) ?? ["", "", ""];
            await x(this, Ah, Hf).call(this, i, p + "-" + h(this, Le).arch + y, f);
          }
          L.debugLog && wt.myTrace("アプリファイルを保存しました", "D"), u.buttons.pop(), u.message = `アプリ【${this.cfg.oCfg.book.title}】の更新パッケージを
ダウンロードしました`, Ht.showMessageBox(u);
        }
      })(), !1;
    });
    // アプリウインドウ設定
    D(this, "window", (e) => {
      const i = j(e, "x", Number(this.val.getVal("sys:const.sn.nativeWindow.x", 0))), n = j(e, "y", Number(this.val.getVal("sys:const.sn.nativeWindow.y", 0)));
      return Ht.window(K(e, "centering", !1), i, n, L.stageW, L.stageH), this.val.setVal_Nochk("sys", "const.sn.nativeWindow.x", i), this.val.setVal_Nochk("sys", "const.sn.nativeWindow.y", n), this.flush(), !1;
    });
    globalThis.addEventListener("DOMContentLoaded", async () => this.loaded(e, i), { once: !0, passive: !0 });
  }
  async loaded(e, i) {
    await super.loaded(e, i), g(this, Le, await Ht.getInfo()), L.isPackaged = h(this, Le).isPackaged, this.arg = i = { ...i, cur: h(this, Le).getAppPath.replaceAll("\\", "/") + (L.isPackaged ? "/doc/" : "/") + i.cur }, this.$path_downloads = h(this, Le).downloads.replaceAll("\\", "/") + "/", L.isDbg = !!h(this, Le).env.SKYNOVEL_DBG && !L.isPackaged, L.isDbg && (this.extPort = mr(h(this, Le).env.SKYNOVEL_PORT ?? "3776")), this.run();
  }
  initVal(e, i, n) {
    i["const.sn.isDebugger"] = !1, i["const.sn.screenResolutionX"] = screen.width, i["const.sn.screenResolutionY"] = screen.height, this.$path_userdata = L.isDbg ? h(this, Le).getAppPath.slice(0, -3) + ".vscode/" : h(this, Le).userData.replaceAll("\\", "/") + "/", this.flush = () => Ht.flush(this.data), h(this, Mc).call(this).then(async () => {
      const s = i["const.sn.isFirstBoot"] = await Ht.Store_isEmpty();
      if (s)
        this.data.sys = e.sys, this.data.mark = e.mark, this.data.kidoku = e.kidoku, this.flush();
      else {
        const l = await Ht.Store_get();
        this.data.sys = l.sys, this.data.mark = l.mark, this.data.kidoku = l.kidoku;
      }
      const o = this.data.sys["const.sn.nativeWindow.x"] ?? 0, a = this.data.sys["const.sn.nativeWindow.y"] ?? 0;
      Ht.window(s, o, a, L.stageW, L.stageH), Ht.on("save_win_pos", (l, u, c) => {
        this.val.setVal_Nochk("sys", "const.sn.nativeWindow.x", u), this.val.setVal_Nochk("sys", "const.sn.nativeWindow.y", c), this.flush();
      }), n(this.data);
    });
  }
  async run() {
    h(this, Nh) && (h(this, Nh).destroy(10), await new Promise((i) => setTimeout(i, 10))), g(this, Nh, new ui(this));
  }
  init(e, i, n, s) {
    const o = super.init(e, i, n, s), a = new Event("click");
    return Ht.on("fire", (l, u) => s.fire(u, a)), this.cfg.oCfg.debug.devtool ? Ht.openDevTools() : Ht.win_ev_devtools_opened(() => {
      console.error("DevToolは禁止されています。許可する場合は【プロジェクト設定】の【devtool】をONに。"), s.destroy();
    }), o;
  }
  cvsResize() {
    super.cvsResize();
    const e = ui.cvs, i = e.parentElement.style, n = e.style;
    this.isFullScr ? (i.position = "", i.width = "", i.height = "", n.position = "fixed", n.left = `${this.ofsLeft4elm}px`, n.top = `${this.ofsTop4elm}px`) : (i.position = "relative", i.width = `${this.cvsWidth}px`, i.height = `${this.cvsHeight}px`, n.position = "relative", n.left = "", n.top = "");
  }
  // タイトル指定
  titleSub(e) {
    Ht.win_setTitle(e);
  }
  canCapturePage(e, i) {
    return Ht.capturePage(e).then(() => i()), !0;
  }
}
Le = new WeakMap(), Mc = new WeakMap(), Nh = new WeakMap(), Ah = new WeakSet(), Hf = async function(e, i, n) {
  L.debugLog && wt.myTrace(`[update_check] アプリファイルDL試行... url=${e + i}`, "D");
  const s = await this.fetch(e + i);
  if (!s.ok) {
    L.debugLog && wt.myTrace(`[update_check] アプリファイルが見つかりません url=${e + n}`);
    return;
  }
  const o = h(this, Le).downloads + "/" + n;
  L.debugLog && wt.myTrace(`[update_check] pathDL=${o}`, "D");
  const a = await s.arrayBuffer();
  await this.writeFileSync(o, new DataView(a));
};
export {
  L as CmnLib,
  qe as Layer,
  rk as SysApp,
  K as argChk_Boolean,
  j as argChk_Num
};
//# sourceMappingURL=app.js.map
