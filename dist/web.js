var Ip = Object.defineProperty;
var Dp = (o, t, e) => t in o ? Ip(o, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : o[t] = e;
var Pt = (o, t, e) => (Dp(o, typeof t != "symbol" ? t + "" : t, e), e), jc = (o, t, e) => {
  if (!t.has(o))
    throw TypeError("Cannot " + e);
};
var z = (o, t, e) => (jc(o, t, "read from private field"), e ? e.call(o) : t.get(o)), tt = (o, t, e) => {
  if (t.has(o))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(o) : t.set(o, e);
}, at = (o, t, e, r) => (jc(o, t, "write to private field"), r ? r.call(o, e) : t.set(o, e), e), Oe = (o, t, e, r) => ({
  set _(S) {
    at(o, t, S, e);
  },
  get _() {
    return z(o, t, r);
  }
}), lt = (o, t, e) => (jc(o, t, "access private method"), e);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, platformExports = {}, platform = {
  get exports() {
    return platformExports;
  },
  set exports(o) {
    platformExports = o;
  }
};
/*!
 * Platform.js v1.3.6
 * Copyright 2014-2020 Benjamin Tan
 * Copyright 2011-2013 John-David Dalton
 * Available under MIT license
 */
(function(o, t) {
  (function() {
    var e = {
      function: !0,
      object: !0
    }, r = e[typeof window] && window || this, S = t, T = o && !o.nodeType && o, D = S && T && typeof commonjsGlobal == "object" && commonjsGlobal;
    D && (D.global === D || D.window === D || D.self === D) && (r = D);
    var N = Math.pow(2, 53) - 1, B = /\bOpera/, $ = Object.prototype, U = $.hasOwnProperty, H = $.toString;
    function V(st) {
      return st = String(st), st.charAt(0).toUpperCase() + st.slice(1);
    }
    function X(st, it, ot) {
      var ht = {
        "10.0": "10",
        "6.4": "10 Technical Preview",
        "6.3": "8.1",
        "6.2": "8",
        "6.1": "Server 2008 R2 / 7",
        "6.0": "Server 2008 / Vista",
        "5.2": "Server 2003 / XP 64-bit",
        "5.1": "XP",
        "5.01": "2000 SP1",
        "5.0": "2000",
        "4.0": "NT",
        "4.90": "ME"
      };
      return it && ot && /^Win/i.test(st) && !/^Windows Phone /i.test(st) && (ht = ht[/[\d.]+$/.exec(st)]) && (st = "Windows " + ht), st = String(st), it && ot && (st = st.replace(RegExp(it, "i"), ot)), st = Y(
        st.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]
      ), st;
    }
    function W(st, it) {
      var ot = -1, ht = st ? st.length : 0;
      if (typeof ht == "number" && ht > -1 && ht <= N)
        for (; ++ot < ht; )
          it(st[ot], ot, st);
      else
        q(st, it);
    }
    function Y(st) {
      return st = rt(st), /^(?:webOS|i(?:OS|P))/.test(st) ? st : V(st);
    }
    function q(st, it) {
      for (var ot in st)
        U.call(st, ot) && it(st[ot], ot, st);
    }
    function K(st) {
      return st == null ? V(st) : H.call(st).slice(8, -1);
    }
    function Z(st, it) {
      var ot = st != null ? typeof st[it] : "number";
      return !/^(?:boolean|number|string|undefined)$/.test(ot) && (ot == "object" ? !!st[it] : !0);
    }
    function J(st) {
      return String(st).replace(/([ -])(?!$)/g, "$1?");
    }
    function Q(st, it) {
      var ot = null;
      return W(st, function(ht, ct) {
        ot = it(ot, ht, ct, st);
      }), ot;
    }
    function rt(st) {
      return String(st).replace(/^ +| +$/g, "");
    }
    function et(st) {
      var it = r, ot = st && typeof st == "object" && K(st) != "String";
      ot && (it = st, st = null);
      var ht = it.navigator || {}, ct = ht.userAgent || "";
      st || (st = ct);
      var vt = ot ? !!ht.likeChrome : /\bChrome\b/.test(st) && !/internal|\n/i.test(H.toString()), _t = "Object", gt = ot ? _t : "ScriptBridgingProxyObject", mt = ot ? _t : "Environment", Et = ot && it.java ? "JavaPackage" : K(it.java), wt = ot ? _t : "RuntimeObject", xt = /\bJava/.test(Et) && it.java, pt = xt && K(it.environment) == mt, yt = xt ? "a" : "α", Dt = xt ? "b" : "β", At = it.document || {}, It = it.operamini || it.opera, Ot = B.test(Ot = ot && It ? It["[[Class]]"] : K(It)) ? Ot : It = null, ft, Ft = st, Mt = [], zt = null, Nt = st == ct, St = Nt && It && typeof It.version == "function" && It.version(), Ht, Lt = Wt([
        { label: "EdgeHTML", pattern: "Edge" },
        "Trident",
        { label: "WebKit", pattern: "AppleWebKit" },
        "iCab",
        "Presto",
        "NetFront",
        "Tasman",
        "KHTML",
        "Gecko"
      ]), Tt = qt([
        "Adobe AIR",
        "Arora",
        "Avant Browser",
        "Breach",
        "Camino",
        "Electron",
        "Epiphany",
        "Fennec",
        "Flock",
        "Galeon",
        "GreenBrowser",
        "iCab",
        "Iceweasel",
        "K-Meleon",
        "Konqueror",
        "Lunascape",
        "Maxthon",
        { label: "Microsoft Edge", pattern: "(?:Edge|Edg|EdgA|EdgiOS)" },
        "Midori",
        "Nook Browser",
        "PaleMoon",
        "PhantomJS",
        "Raven",
        "Rekonq",
        "RockMelt",
        { label: "Samsung Internet", pattern: "SamsungBrowser" },
        "SeaMonkey",
        { label: "Silk", pattern: "(?:Cloud9|Silk-Accelerated)" },
        "Sleipnir",
        "SlimBrowser",
        { label: "SRWare Iron", pattern: "Iron" },
        "Sunrise",
        "Swiftfox",
        "Vivaldi",
        "Waterfox",
        "WebPositive",
        { label: "Yandex Browser", pattern: "YaBrowser" },
        { label: "UC Browser", pattern: "UCBrowser" },
        "Opera Mini",
        { label: "Opera Mini", pattern: "OPiOS" },
        "Opera",
        { label: "Opera", pattern: "OPR" },
        "Chromium",
        "Chrome",
        { label: "Chrome", pattern: "(?:HeadlessChrome)" },
        { label: "Chrome Mobile", pattern: "(?:CriOS|CrMo)" },
        { label: "Firefox", pattern: "(?:Firefox|Minefield)" },
        { label: "Firefox for iOS", pattern: "FxiOS" },
        { label: "IE", pattern: "IEMobile" },
        { label: "IE", pattern: "MSIE" },
        "Safari"
      ]), kt = Me([
        { label: "BlackBerry", pattern: "BB10" },
        "BlackBerry",
        { label: "Galaxy S", pattern: "GT-I9000" },
        { label: "Galaxy S2", pattern: "GT-I9100" },
        { label: "Galaxy S3", pattern: "GT-I9300" },
        { label: "Galaxy S4", pattern: "GT-I9500" },
        { label: "Galaxy S5", pattern: "SM-G900" },
        { label: "Galaxy S6", pattern: "SM-G920" },
        { label: "Galaxy S6 Edge", pattern: "SM-G925" },
        { label: "Galaxy S7", pattern: "SM-G930" },
        { label: "Galaxy S7 Edge", pattern: "SM-G935" },
        "Google TV",
        "Lumia",
        "iPad",
        "iPod",
        "iPhone",
        "Kindle",
        { label: "Kindle Fire", pattern: "(?:Cloud9|Silk-Accelerated)" },
        "Nexus",
        "Nook",
        "PlayBook",
        "PlayStation Vita",
        "PlayStation",
        "TouchPad",
        "Transformer",
        { label: "Wii U", pattern: "WiiU" },
        "Wii",
        "Xbox One",
        { label: "Xbox 360", pattern: "Xbox" },
        "Xoom"
      ]), Ut = Jt({
        Apple: { iPad: 1, iPhone: 1, iPod: 1 },
        Alcatel: {},
        Archos: {},
        Amazon: { Kindle: 1, "Kindle Fire": 1 },
        Asus: { Transformer: 1 },
        "Barnes & Noble": { Nook: 1 },
        BlackBerry: { PlayBook: 1 },
        Google: { "Google TV": 1, Nexus: 1 },
        HP: { TouchPad: 1 },
        HTC: {},
        Huawei: {},
        Lenovo: {},
        LG: {},
        Microsoft: { Xbox: 1, "Xbox One": 1 },
        Motorola: { Xoom: 1 },
        Nintendo: { "Wii U": 1, Wii: 1 },
        Nokia: { Lumia: 1 },
        Oppo: {},
        Samsung: { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 },
        Sony: { PlayStation: 1, "PlayStation Vita": 1 },
        Xiaomi: { Mi: 1, Redmi: 1 }
      }), Ct = xe([
        "Windows Phone",
        "KaiOS",
        "Android",
        "CentOS",
        { label: "Chrome OS", pattern: "CrOS" },
        "Debian",
        { label: "DragonFly BSD", pattern: "DragonFly" },
        "Fedora",
        "FreeBSD",
        "Gentoo",
        "Haiku",
        "Kubuntu",
        "Linux Mint",
        "OpenBSD",
        "Red Hat",
        "SuSE",
        "Ubuntu",
        "Xubuntu",
        "Cygwin",
        "Symbian OS",
        "hpwOS",
        "webOS ",
        "webOS",
        "Tablet OS",
        "Tizen",
        "Linux",
        "Mac OS X",
        "Macintosh",
        "Mac",
        "Windows 98;",
        "Windows "
      ]);
      function Wt(fe) {
        return Q(fe, function(ce, ie) {
          return ce || RegExp("\\b" + (ie.pattern || J(ie)) + "\\b", "i").exec(st) && (ie.label || ie);
        });
      }
      function Jt(fe) {
        return Q(fe, function(ce, ie, ze) {
          return ce || (ie[kt] || ie[/^[a-z]+(?: +[a-z]+\b)*/i.exec(kt)] || RegExp("\\b" + J(ze) + "(?:\\b|\\w*\\d)", "i").exec(st)) && ze;
        });
      }
      function qt(fe) {
        return Q(fe, function(ce, ie) {
          return ce || RegExp("\\b" + (ie.pattern || J(ie)) + "\\b", "i").exec(st) && (ie.label || ie);
        });
      }
      function xe(fe) {
        return Q(fe, function(ce, ie) {
          var ze = ie.pattern || J(ie);
          return !ce && (ce = RegExp("\\b" + ze + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(st)) && (ce = X(ce, ze, ie.label || ie)), ce;
        });
      }
      function Me(fe) {
        return Q(fe, function(ce, ie) {
          var ze = ie.pattern || J(ie);
          return !ce && (ce = RegExp("\\b" + ze + " *\\d+[.\\w_]*", "i").exec(st) || RegExp("\\b" + ze + " *\\w+-[\\w]*", "i").exec(st) || RegExp("\\b" + ze + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(st)) && ((ce = String(ie.label && !RegExp(ze, "i").test(ie.label) ? ie.label : ce).split("/"))[1] && !/[\d.]+/.test(ce[0]) && (ce[0] += " " + ce[1]), ie = ie.label || ie, ce = Y(ce[0].replace(RegExp(ze, "i"), ie).replace(RegExp("; *(?:" + ie + "[_-])?", "i"), " ").replace(RegExp("(" + ie + ")[-_.]?(\\w)", "i"), "$1 $2"))), ce;
        });
      }
      function ue(fe) {
        return Q(fe, function(ce, ie) {
          return ce || (RegExp(ie + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(st) || 0)[1] || null;
        });
      }
      function me() {
        return this.description || "";
      }
      if (Lt && (Lt = [Lt]), /\bAndroid\b/.test(Ct) && !kt && (ft = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(st)) && (kt = rt(ft[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null), Ut && !kt ? kt = Me([Ut]) : Ut && kt && (kt = kt.replace(RegExp("^(" + J(Ut) + ")[-_.\\s]", "i"), Ut + " ").replace(RegExp("^(" + J(Ut) + ")[-_.]?(\\w)", "i"), Ut + " $2")), (ft = /\bGoogle TV\b/.exec(kt)) && (kt = ft[0]), /\bSimulator\b/i.test(st) && (kt = (kt ? kt + " " : "") + "Simulator"), Tt == "Opera Mini" && /\bOPiOS\b/.test(st) && Mt.push("running in Turbo/Uncompressed mode"), Tt == "IE" && /\blike iPhone OS\b/.test(st) ? (ft = et(st.replace(/like iPhone OS/, "")), Ut = ft.manufacturer, kt = ft.product) : /^iP/.test(kt) ? (Tt || (Tt = "Safari"), Ct = "iOS" + ((ft = / OS ([\d_]+)/i.exec(st)) ? " " + ft[1].replace(/_/g, ".") : "")) : Tt == "Konqueror" && /^Linux\b/i.test(Ct) ? Ct = "Kubuntu" : Ut && Ut != "Google" && (/Chrome/.test(Tt) && !/\bMobile Safari\b/i.test(st) || /\bVita\b/.test(kt)) || /\bAndroid\b/.test(Ct) && /^Chrome/.test(Tt) && /\bVersion\//i.test(st) ? (Tt = "Android Browser", Ct = /\bAndroid\b/.test(Ct) ? Ct : "Android") : Tt == "Silk" ? (/\bMobi/i.test(st) || (Ct = "Android", Mt.unshift("desktop mode")), /Accelerated *= *true/i.test(st) && Mt.unshift("accelerated")) : Tt == "UC Browser" && /\bUCWEB\b/.test(st) ? Mt.push("speed mode") : Tt == "PaleMoon" && (ft = /\bFirefox\/([\d.]+)\b/.exec(st)) ? Mt.push("identifying as Firefox " + ft[1]) : Tt == "Firefox" && (ft = /\b(Mobile|Tablet|TV)\b/i.exec(st)) ? (Ct || (Ct = "Firefox OS"), kt || (kt = ft[1])) : !Tt || (ft = !/\bMinefield\b/i.test(st) && /\b(?:Firefox|Safari)\b/.exec(Tt)) ? (Tt && !kt && /[\/,]|^[^(]+?\)/.test(st.slice(st.indexOf(ft + "/") + 8)) && (Tt = null), (ft = kt || Ut || Ct) && (kt || Ut || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(Ct)) && (Tt = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(Ct) ? Ct : ft) + " Browser")) : Tt == "Electron" && (ft = (/\bChrome\/([\d.]+)\b/.exec(st) || 0)[1]) && Mt.push("Chromium " + ft), St || (St = ue([
        "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
        "Version",
        J(Tt),
        "(?:Firefox|Minefield|NetFront)"
      ])), (ft = Lt == "iCab" && parseFloat(St) > 3 && "WebKit" || /\bOpera\b/.test(Tt) && (/\bOPR\b/.test(st) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(st) && !/^(?:Trident|EdgeHTML)$/.test(Lt) && "WebKit" || !Lt && /\bMSIE\b/i.test(st) && (Ct == "Mac OS" ? "Tasman" : "Trident") || Lt == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(Tt) && "NetFront") && (Lt = [ft]), Tt == "IE" && (ft = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(st) || 0)[1]) ? (Tt += " Mobile", Ct = "Windows Phone " + (/\+$/.test(ft) ? ft : ft + ".x"), Mt.unshift("desktop mode")) : /\bWPDesktop\b/i.test(st) ? (Tt = "IE Mobile", Ct = "Windows Phone 8.x", Mt.unshift("desktop mode"), St || (St = (/\brv:([\d.]+)/.exec(st) || 0)[1])) : Tt != "IE" && Lt == "Trident" && (ft = /\brv:([\d.]+)/.exec(st)) && (Tt && Mt.push("identifying as " + Tt + (St ? " " + St : "")), Tt = "IE", St = ft[1]), Nt) {
        if (Z(it, "global"))
          if (xt && (ft = xt.lang.System, Ft = ft.getProperty("os.arch"), Ct = Ct || ft.getProperty("os.name") + " " + ft.getProperty("os.version")), pt) {
            try {
              St = it.require("ringo/engine").version.join("."), Tt = "RingoJS";
            } catch {
              (ft = it.system) && ft.global.system == it.system && (Tt = "Narwhal", Ct || (Ct = ft[0].os || null));
            }
            Tt || (Tt = "Rhino");
          } else
            typeof it.process == "object" && !it.process.browser && (ft = it.process) && (typeof ft.versions == "object" && (typeof ft.versions.electron == "string" ? (Mt.push("Node " + ft.versions.node), Tt = "Electron", St = ft.versions.electron) : typeof ft.versions.nw == "string" && (Mt.push("Chromium " + St, "Node " + ft.versions.node), Tt = "NW.js", St = ft.versions.nw)), Tt || (Tt = "Node.js", Ft = ft.arch, Ct = ft.platform, St = /[\d.]+/.exec(ft.version), St = St ? St[0] : null));
        else
          K(ft = it.runtime) == gt ? (Tt = "Adobe AIR", Ct = ft.flash.system.Capabilities.os) : K(ft = it.phantom) == wt ? (Tt = "PhantomJS", St = (ft = ft.version || null) && ft.major + "." + ft.minor + "." + ft.patch) : typeof At.documentMode == "number" && (ft = /\bTrident\/(\d+)/i.exec(st)) ? (St = [St, At.documentMode], (ft = +ft[1] + 4) != St[1] && (Mt.push("IE " + St[1] + " mode"), Lt && (Lt[1] = ""), St[1] = ft), St = Tt == "IE" ? String(St[1].toFixed(1)) : St[0]) : typeof At.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(Tt) && (Mt.push("masking as " + Tt + " " + St), Tt = "IE", St = "11.0", Lt = ["Trident"], Ct = "Windows");
        Ct = Ct && Y(Ct);
      }
      if (St && (ft = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(St) || /(?:alpha|beta)(?: ?\d)?/i.exec(st + ";" + (Nt && ht.appMinorVersion)) || /\bMinefield\b/i.test(st) && "a") && (zt = /b/i.test(ft) ? "beta" : "alpha", St = St.replace(RegExp(ft + "\\+?$"), "") + (zt == "beta" ? Dt : yt) + (/\d+\+?/.exec(ft) || "")), Tt == "Fennec" || Tt == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(Ct))
        Tt = "Firefox Mobile";
      else if (Tt == "Maxthon" && St)
        St = St.replace(/\.[\d.]+/, ".x");
      else if (/\bXbox\b/i.test(kt))
        kt == "Xbox 360" && (Ct = null), kt == "Xbox 360" && /\bIEMobile\b/.test(st) && Mt.unshift("mobile mode");
      else if ((/^(?:Chrome|IE|Opera)$/.test(Tt) || Tt && !kt && !/Browser|Mobi/.test(Tt)) && (Ct == "Windows CE" || /Mobi/i.test(st)))
        Tt += " Mobile";
      else if (Tt == "IE" && Nt)
        try {
          it.external === null && Mt.unshift("platform preview");
        } catch {
          Mt.unshift("embedded");
        }
      else
        (/\bBlackBerry\b/.test(kt) || /\bBB10\b/.test(st)) && (ft = (RegExp(kt.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(st) || 0)[1] || St) ? (ft = [ft, /BB10/.test(st)], Ct = (ft[1] ? (kt = null, Ut = "BlackBerry") : "Device Software") + " " + ft[0], St = null) : this != q && kt != "Wii" && (Nt && It || /Opera/.test(Tt) && /\b(?:MSIE|Firefox)\b/i.test(st) || Tt == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(Ct) || Tt == "IE" && (Ct && !/^Win/.test(Ct) && St > 5.5 || /\bWindows XP\b/.test(Ct) && St > 8 || St == 8 && !/\bTrident\b/.test(st))) && !B.test(ft = et.call(q, st.replace(B, "") + ";")) && ft.name && (ft = "ing as " + ft.name + ((ft = ft.version) ? " " + ft : ""), B.test(Tt) ? (/\bIE\b/.test(ft) && Ct == "Mac OS" && (Ct = null), ft = "identify" + ft) : (ft = "mask" + ft, Ot ? Tt = Y(Ot.replace(/([a-z])([A-Z])/g, "$1 $2")) : Tt = "Opera", /\bIE\b/.test(ft) && (Ct = null), Nt || (St = null)), Lt = ["Presto"], Mt.push(ft));
      (ft = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(st) || 0)[1]) && (ft = [parseFloat(ft.replace(/\.(\d)$/, ".0$1")), ft], Tt == "Safari" && ft[1].slice(-1) == "+" ? (Tt = "WebKit Nightly", zt = "alpha", St = ft[1].slice(0, -1)) : (St == ft[1] || St == (ft[2] = (/\bSafari\/([\d.]+\+?)/i.exec(st) || 0)[1])) && (St = null), ft[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(st) || 0)[1], ft[0] == 537.36 && ft[2] == 537.36 && parseFloat(ft[1]) >= 28 && Lt == "WebKit" && (Lt = ["Blink"]), !Nt || !vt && !ft[1] ? (Lt && (Lt[1] = "like Safari"), ft = (ft = ft[0], ft < 400 ? 1 : ft < 500 ? 2 : ft < 526 ? 3 : ft < 533 ? 4 : ft < 534 ? "4+" : ft < 535 ? 5 : ft < 537 ? 6 : ft < 538 ? 7 : ft < 601 ? 8 : ft < 602 ? 9 : ft < 604 ? 10 : ft < 606 ? 11 : ft < 608 ? 12 : "12")) : (Lt && (Lt[1] = "like Chrome"), ft = ft[1] || (ft = ft[0], ft < 530 ? 1 : ft < 532 ? 2 : ft < 532.05 ? 3 : ft < 533 ? 4 : ft < 534.03 ? 5 : ft < 534.07 ? 6 : ft < 534.1 ? 7 : ft < 534.13 ? 8 : ft < 534.16 ? 9 : ft < 534.24 ? 10 : ft < 534.3 ? 11 : ft < 535.01 ? 12 : ft < 535.02 ? "13+" : ft < 535.07 ? 15 : ft < 535.11 ? 16 : ft < 535.19 ? 17 : ft < 536.05 ? 18 : ft < 536.1 ? 19 : ft < 537.01 ? 20 : ft < 537.11 ? "21+" : ft < 537.13 ? 23 : ft < 537.18 ? 24 : ft < 537.24 ? 25 : ft < 537.36 ? 26 : Lt != "Blink" ? "27" : "28")), Lt && (Lt[1] += " " + (ft += typeof ft == "number" ? ".x" : /[.+]/.test(ft) ? "" : "+")), Tt == "Safari" && (!St || parseInt(St) > 45) ? St = ft : Tt == "Chrome" && /\bHeadlessChrome/i.test(st) && Mt.unshift("headless")), Tt == "Opera" && (ft = /\bzbov|zvav$/.exec(Ct)) ? (Tt += " ", Mt.unshift("desktop mode"), ft == "zvav" ? (Tt += "Mini", St = null) : Tt += "Mobile", Ct = Ct.replace(RegExp(" *" + ft + "$"), "")) : Tt == "Safari" && /\bChrome\b/.exec(Lt && Lt[1]) ? (Mt.unshift("desktop mode"), Tt = "Chrome Mobile", St = null, /\bOS X\b/.test(Ct) ? (Ut = "Apple", Ct = "iOS 4.3+") : Ct = null) : /\bSRWare Iron\b/.test(Tt) && !St && (St = ue("Chrome")), St && St.indexOf(ft = /[\d.]+$/.exec(Ct)) == 0 && st.indexOf("/" + ft + "-") > -1 && (Ct = rt(Ct.replace(ft, ""))), Ct && Ct.indexOf(Tt) != -1 && !RegExp(Tt + " OS").test(Ct) && (Ct = Ct.replace(RegExp(" *" + J(Tt) + " *"), "")), Lt && !/\b(?:Avant|Nook)\b/.test(Tt) && (/Browser|Lunascape|Maxthon/.test(Tt) || Tt != "Safari" && /^iOS/.test(Ct) && /\bSafari\b/.test(Lt[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(Tt) && Lt[1]) && (ft = Lt[Lt.length - 1]) && Mt.push(ft), Mt.length && (Mt = ["(" + Mt.join("; ") + ")"]), Ut && kt && kt.indexOf(Ut) < 0 && Mt.push("on " + Ut), kt && Mt.push((/^on /.test(Mt[Mt.length - 1]) ? "" : "on ") + kt), Ct && (ft = / ([\d.+]+)$/.exec(Ct), Ht = ft && Ct.charAt(Ct.length - ft[0].length - 1) == "/", Ct = {
        architecture: 32,
        family: ft && !Ht ? Ct.replace(ft[0], "") : Ct,
        version: ft ? ft[1] : null,
        toString: function() {
          var fe = this.version;
          return this.family + (fe && !Ht ? " " + fe : "") + (this.architecture == 64 ? " 64-bit" : "");
        }
      }), (ft = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(Ft)) && !/\bi686\b/i.test(Ft) ? (Ct && (Ct.architecture = 64, Ct.family = Ct.family.replace(RegExp(" *" + ft), "")), Tt && (/\bWOW64\b/i.test(st) || Nt && /\w(?:86|32)$/.test(ht.cpuClass || ht.platform) && !/\bWin64; x64\b/i.test(st)) && Mt.unshift("32-bit")) : Ct && /^OS X/.test(Ct.family) && Tt == "Chrome" && parseFloat(St) >= 39 && (Ct.architecture = 64), st || (st = null);
      var pe = {};
      return pe.description = st, pe.layout = Lt && Lt[0], pe.manufacturer = Ut, pe.name = Tt, pe.prerelease = zt, pe.product = kt, pe.ua = st, pe.version = Tt && St, pe.os = Ct || {
        /**
         * The CPU architecture the OS is built for.
         *
         * @memberOf platform.os
         * @type number|null
         */
        architecture: null,
        /**
         * The family of the OS.
         *
         * Common values include:
         * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
         * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
         * "SuSE", "Android", "iOS" and "Windows Phone"
         *
         * @memberOf platform.os
         * @type string|null
         */
        family: null,
        /**
         * The version of the OS.
         *
         * @memberOf platform.os
         * @type string|null
         */
        version: null,
        /**
         * Returns the OS string.
         *
         * @memberOf platform.os
         * @returns {string} The OS string.
         */
        toString: function() {
          return "null";
        }
      }, pe.parse = et, pe.toString = me, pe.version && Mt.unshift(St), pe.name && Mt.unshift(Tt), Ct && Tt && !(Ct == String(Ct).split(" ")[0] && (Ct == Tt.split(" ")[0] || kt)) && Mt.push(kt ? "(" + Ct + ")" : "on " + Ct), Mt.length && (pe.description = Mt.join(" ")), pe;
    }
    var nt = et();
    S && T ? q(nt, function(st, it) {
      S[it] = st;
    }) : r.platform = nt;
  }).call(commonjsGlobal);
})(platform, platformExports);
function int(o) {
  return parseInt(String(o), 10);
}
function uint(o) {
  const t = parseInt(String(o), 10);
  return t < 0 ? -t : t;
}
"toInt" in String.prototype || (String.prototype.toInt = function() {
  return int(this);
});
"toUint" in String.prototype || (String.prototype.toUint = function() {
  const o = int(this);
  return o < 0 ? -o : o;
});
function getDateStr(o = "/", t = " ", e = ":", r = "") {
  const S = new Date();
  return S.getFullYear() + o + String(100 + S.getMonth() + 1).slice(1, 3) + o + String(100 + S.getDate()).slice(1, 3) + t + String(100 + S.getHours()).slice(1, 3) + e + String(100 + S.getMinutes()).slice(1, 3) + (r === "" ? "" : r + String(S.getMilliseconds()));
}
const hMemberCnt = {
  alpha: 0,
  height: 0,
  rotation: 0,
  scale_x: 0,
  scale_y: 0,
  pivot_x: 0,
  pivot_y: 0,
  width: 0,
  x: 0,
  y: 0
};
function cnvTweenArg(o, t) {
  const e = {};
  for (const r of Object.keys(hMemberCnt)) {
    if (!(r in o))
      continue;
    const S = String(o[r]), T = (S.at(0) === "=" ? S.slice(1) : S).split(","), D = e[r] = parseFloat(T[0]);
    T.length > 1 && (e[r] += Math.round(Math.random() * (parseFloat(T[1]) - D + 1))), S.at(0) === "=" && (e[r] += parseFloat(t[r]));
  }
  return e;
}
const css_key4del = "/* SKYNovel */";
function initStyle() {
  const o = document.getElementsByTagName("head")[0], t = o.children.length;
  for (let e = t - 1; e >= 0; --e) {
    const r = o.children[e];
    r instanceof HTMLStyleElement && r.innerText.slice(0, 14) === css_key4del && o.removeChild(r);
  }
}
function addStyle(o) {
  const t = document.createElement("style");
  t.innerHTML = css_key4del + o, document.getElementsByTagName("head")[0].appendChild(t);
}
function argChk_Num(o, t, e) {
  const r = o[t];
  if (!(t in o)) {
    if (isNaN(e))
      throw `[${o[":タグ名"]}]属性 ${t} は必須です`;
    return o[t] = e, e;
  }
  const S = String(r).slice(0, 2) === "0x" ? parseInt(r) : parseFloat(r);
  if (isNaN(S))
    throw `[${o[":タグ名"]}]属性 ${t} の値【${r}】が数値ではありません`;
  return o[t] = S;
}
function argChk_Boolean(o, t, e) {
  if (!(t in o))
    return o[t] = e;
  const r = o[t];
  if (r === null)
    return !1;
  const S = String(r);
  return o[t] = S === "false" ? !1 : Boolean(S);
}
function parseColor(o) {
  if (o.at(0) === "#")
    return parseInt(o.slice(1), 16);
  const t = Number(o);
  if (!isNaN(t))
    return t;
  if (o === "black")
    return 0;
  CmnLib.cc4ColorName.fillStyle = o;
  const e = CmnLib.cc4ColorName.fillStyle;
  if (e === "#000000")
    throw `色名前 ${o} が異常です`;
  return parseInt(e.slice(1), 16);
}
function argChk_Color(o, t, e) {
  const r = o[t];
  return r ? o[t] = parseColor(String(r)) : o[t] = e;
}
const REG_ERRMES_JSON = /JSON at position (\d+)$/;
function mesErrJSON(o, t = "", e = "") {
  const r = (e.match(REG_ERRMES_JSON) ?? ["", ""])[1];
  return `[${o[":タグ名"]}] ${t} 属性の解析エラー : ${e}
${o[t]}${r ? `
${"^".padStart(Number(r))}` : ""}`;
}
const REG_FN = /^[^\/\.]+$|[^\/]+(?=\.)/;
function getFn(o) {
  return (o.match(REG_FN) ?? [""])[0];
}
const REG_EXT = /\.([^\.]+)$/;
function getExt(o) {
  return (o.match(REG_EXT) ?? ["", ""])[1];
}
var Nf, Lf;
class CmnLib {
}
Pt(CmnLib, "stageW", 0), Pt(CmnLib, "stageH", 0), Pt(CmnLib, "debugLog", !1), Pt(CmnLib, "isSafari", platformExports.name === "Safari"), Pt(CmnLib, "isFirefox", platformExports.name === "Firefox"), Pt(CmnLib, "isMac", new RegExp("OS X").test(((Nf = platformExports.os) == null ? void 0 : Nf.family) ?? "")), Pt(CmnLib, "isMobile", !new RegExp("(Windows|OS X)").test(((Lf = platformExports.os) == null ? void 0 : Lf.family) ?? "")), Pt(CmnLib, "hDip", {}), Pt(CmnLib, "isDbg", !1), Pt(CmnLib, "isPackaged", !1), Pt(CmnLib, "isDarkMode", !1), Pt(CmnLib, "cc4ColorName");
function finallyConstructor(o) {
  var t = this.constructor;
  return this.then(
    function(e) {
      return t.resolve(o()).then(function() {
        return e;
      });
    },
    function(e) {
      return t.resolve(o()).then(function() {
        return t.reject(e);
      });
    }
  );
}
function allSettled(o) {
  var t = this;
  return new t(function(e, r) {
    if (!(o && typeof o.length < "u"))
      return r(
        new TypeError(
          typeof o + " " + o + " is not iterable(cannot read property Symbol(Symbol.iterator))"
        )
      );
    var S = Array.prototype.slice.call(o);
    if (S.length === 0)
      return e([]);
    var T = S.length;
    function D(B, $) {
      if ($ && (typeof $ == "object" || typeof $ == "function")) {
        var U = $.then;
        if (typeof U == "function") {
          U.call(
            $,
            function(H) {
              D(B, H);
            },
            function(H) {
              S[B] = { status: "rejected", reason: H }, --T === 0 && e(S);
            }
          );
          return;
        }
      }
      S[B] = { status: "fulfilled", value: $ }, --T === 0 && e(S);
    }
    for (var N = 0; N < S.length; N++)
      D(N, S[N]);
  });
}
var setTimeoutFunc = setTimeout;
function isArray$1(o) {
  return Boolean(o && typeof o.length < "u");
}
function noop() {
}
function bind$2(o, t) {
  return function() {
    o.apply(t, arguments);
  };
}
function Promise$1(o) {
  if (!(this instanceof Promise$1))
    throw new TypeError("Promises must be constructed via new");
  if (typeof o != "function")
    throw new TypeError("not a function");
  this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], doResolve(o, this);
}
function handle(o, t) {
  for (; o._state === 3; )
    o = o._value;
  if (o._state === 0) {
    o._deferreds.push(t);
    return;
  }
  o._handled = !0, Promise$1._immediateFn(function() {
    var e = o._state === 1 ? t.onFulfilled : t.onRejected;
    if (e === null) {
      (o._state === 1 ? resolve$1 : reject)(t.promise, o._value);
      return;
    }
    var r;
    try {
      r = e(o._value);
    } catch (S) {
      reject(t.promise, S);
      return;
    }
    resolve$1(t.promise, r);
  });
}
function resolve$1(o, t) {
  try {
    if (t === o)
      throw new TypeError("A promise cannot be resolved with itself.");
    if (t && (typeof t == "object" || typeof t == "function")) {
      var e = t.then;
      if (t instanceof Promise$1) {
        o._state = 3, o._value = t, finale(o);
        return;
      } else if (typeof e == "function") {
        doResolve(bind$2(e, t), o);
        return;
      }
    }
    o._state = 1, o._value = t, finale(o);
  } catch (r) {
    reject(o, r);
  }
}
function reject(o, t) {
  o._state = 2, o._value = t, finale(o);
}
function finale(o) {
  o._state === 2 && o._deferreds.length === 0 && Promise$1._immediateFn(function() {
    o._handled || Promise$1._unhandledRejectionFn(o._value);
  });
  for (var t = 0, e = o._deferreds.length; t < e; t++)
    handle(o, o._deferreds[t]);
  o._deferreds = null;
}
function Handler(o, t, e) {
  this.onFulfilled = typeof o == "function" ? o : null, this.onRejected = typeof t == "function" ? t : null, this.promise = e;
}
function doResolve(o, t) {
  var e = !1;
  try {
    o(
      function(r) {
        e || (e = !0, resolve$1(t, r));
      },
      function(r) {
        e || (e = !0, reject(t, r));
      }
    );
  } catch (r) {
    if (e)
      return;
    e = !0, reject(t, r);
  }
}
Promise$1.prototype.catch = function(o) {
  return this.then(null, o);
};
Promise$1.prototype.then = function(o, t) {
  var e = new this.constructor(noop);
  return handle(this, new Handler(o, t, e)), e;
};
Promise$1.prototype.finally = finallyConstructor;
Promise$1.all = function(o) {
  return new Promise$1(function(t, e) {
    if (!isArray$1(o))
      return e(new TypeError("Promise.all accepts an array"));
    var r = Array.prototype.slice.call(o);
    if (r.length === 0)
      return t([]);
    var S = r.length;
    function T(N, B) {
      try {
        if (B && (typeof B == "object" || typeof B == "function")) {
          var $ = B.then;
          if (typeof $ == "function") {
            $.call(
              B,
              function(U) {
                T(N, U);
              },
              e
            );
            return;
          }
        }
        r[N] = B, --S === 0 && t(r);
      } catch (U) {
        e(U);
      }
    }
    for (var D = 0; D < r.length; D++)
      T(D, r[D]);
  });
};
Promise$1.allSettled = allSettled;
Promise$1.resolve = function(o) {
  return o && typeof o == "object" && o.constructor === Promise$1 ? o : new Promise$1(function(t) {
    t(o);
  });
};
Promise$1.reject = function(o) {
  return new Promise$1(function(t, e) {
    e(o);
  });
};
Promise$1.race = function(o) {
  return new Promise$1(function(t, e) {
    if (!isArray$1(o))
      return e(new TypeError("Promise.race accepts an array"));
    for (var r = 0, S = o.length; r < S; r++)
      Promise$1.resolve(o[r]).then(t, e);
  });
};
Promise$1._immediateFn = typeof setImmediate == "function" && function(o) {
  setImmediate(o);
} || function(o) {
  setTimeoutFunc(o, 0);
};
Promise$1._unhandledRejectionFn = function(t) {
  typeof console < "u" && console && console.warn("Possible Unhandled Promise Rejection:", t);
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty$1 = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(o) {
  if (o == null)
    throw new TypeError("Object.assign cannot be called with null or undefined");
  return Object(o);
}
function shouldUseNative() {
  try {
    if (!Object.assign)
      return !1;
    var o = new String("abc");
    if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
      return !1;
    for (var t = {}, e = 0; e < 10; e++)
      t["_" + String.fromCharCode(e)] = e;
    var r = Object.getOwnPropertyNames(t).map(function(T) {
      return t[T];
    });
    if (r.join("") !== "0123456789")
      return !1;
    var S = {};
    return "abcdefghijklmnopqrst".split("").forEach(function(T) {
      S[T] = T;
    }), Object.keys(Object.assign({}, S)).join("") === "abcdefghijklmnopqrst";
  } catch {
    return !1;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(o, t) {
  for (var e, r = toObject(o), S, T = 1; T < arguments.length; T++) {
    e = Object(arguments[T]);
    for (var D in e)
      hasOwnProperty$1.call(e, D) && (r[D] = e[D]);
    if (getOwnPropertySymbols) {
      S = getOwnPropertySymbols(e);
      for (var N = 0; N < S.length; N++)
        propIsEnumerable.call(e, S[N]) && (r[S[N]] = e[S[N]]);
    }
  }
  return r;
};
/*!
 * @pixi/polyfill - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/polyfill is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
typeof globalThis > "u" && (typeof self < "u" ? self.globalThis = self : typeof global < "u" && (global.globalThis = global));
globalThis.Promise || (globalThis.Promise = Promise$1);
Object.assign || (Object.assign = objectAssign);
var ONE_FRAME_TIME = 16;
Date.now && Date.prototype.getTime || (Date.now = function() {
  return new Date().getTime();
});
if (!(globalThis.performance && globalThis.performance.now)) {
  var startTime_1 = Date.now();
  globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {
    return Date.now() - startTime_1;
  };
}
var lastTime = Date.now(), vendors = ["ms", "moz", "webkit", "o"];
for (var x$1 = 0; x$1 < vendors.length && !globalThis.requestAnimationFrame; ++x$1) {
  var p$1 = vendors[x$1];
  globalThis.requestAnimationFrame = globalThis[p$1 + "RequestAnimationFrame"], globalThis.cancelAnimationFrame = globalThis[p$1 + "CancelAnimationFrame"] || globalThis[p$1 + "CancelRequestAnimationFrame"];
}
globalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(o) {
  if (typeof o != "function")
    throw new TypeError(o + "is not a function");
  var t = Date.now(), e = ONE_FRAME_TIME + lastTime - t;
  return e < 0 && (e = 0), lastTime = t, globalThis.self.setTimeout(function() {
    lastTime = Date.now(), o(performance.now());
  }, e);
});
globalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(o) {
  return clearTimeout(o);
});
Math.sign || (Math.sign = function(t) {
  return t = Number(t), t === 0 || isNaN(t) ? t : t > 0 ? 1 : -1;
});
Number.isInteger || (Number.isInteger = function(t) {
  return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
});
globalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array);
globalThis.Float32Array || (globalThis.Float32Array = Array);
globalThis.Uint32Array || (globalThis.Uint32Array = Array);
globalThis.Uint16Array || (globalThis.Uint16Array = Array);
globalThis.Uint8Array || (globalThis.Uint8Array = Array);
globalThis.Int32Array || (globalThis.Int32Array = Array);
/*!
 * @pixi/constants - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV;
(function(o) {
  o[o.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", o[o.WEBGL = 1] = "WEBGL", o[o.WEBGL2 = 2] = "WEBGL2";
})(ENV || (ENV = {}));
var RENDERER_TYPE;
(function(o) {
  o[o.UNKNOWN = 0] = "UNKNOWN", o[o.WEBGL = 1] = "WEBGL", o[o.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE || (RENDERER_TYPE = {}));
var BUFFER_BITS;
(function(o) {
  o[o.COLOR = 16384] = "COLOR", o[o.DEPTH = 256] = "DEPTH", o[o.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS || (BUFFER_BITS = {}));
var BLEND_MODES;
(function(o) {
  o[o.NORMAL = 0] = "NORMAL", o[o.ADD = 1] = "ADD", o[o.MULTIPLY = 2] = "MULTIPLY", o[o.SCREEN = 3] = "SCREEN", o[o.OVERLAY = 4] = "OVERLAY", o[o.DARKEN = 5] = "DARKEN", o[o.LIGHTEN = 6] = "LIGHTEN", o[o.COLOR_DODGE = 7] = "COLOR_DODGE", o[o.COLOR_BURN = 8] = "COLOR_BURN", o[o.HARD_LIGHT = 9] = "HARD_LIGHT", o[o.SOFT_LIGHT = 10] = "SOFT_LIGHT", o[o.DIFFERENCE = 11] = "DIFFERENCE", o[o.EXCLUSION = 12] = "EXCLUSION", o[o.HUE = 13] = "HUE", o[o.SATURATION = 14] = "SATURATION", o[o.COLOR = 15] = "COLOR", o[o.LUMINOSITY = 16] = "LUMINOSITY", o[o.NORMAL_NPM = 17] = "NORMAL_NPM", o[o.ADD_NPM = 18] = "ADD_NPM", o[o.SCREEN_NPM = 19] = "SCREEN_NPM", o[o.NONE = 20] = "NONE", o[o.SRC_OVER = 0] = "SRC_OVER", o[o.SRC_IN = 21] = "SRC_IN", o[o.SRC_OUT = 22] = "SRC_OUT", o[o.SRC_ATOP = 23] = "SRC_ATOP", o[o.DST_OVER = 24] = "DST_OVER", o[o.DST_IN = 25] = "DST_IN", o[o.DST_OUT = 26] = "DST_OUT", o[o.DST_ATOP = 27] = "DST_ATOP", o[o.ERASE = 26] = "ERASE", o[o.SUBTRACT = 28] = "SUBTRACT", o[o.XOR = 29] = "XOR";
})(BLEND_MODES || (BLEND_MODES = {}));
var DRAW_MODES;
(function(o) {
  o[o.POINTS = 0] = "POINTS", o[o.LINES = 1] = "LINES", o[o.LINE_LOOP = 2] = "LINE_LOOP", o[o.LINE_STRIP = 3] = "LINE_STRIP", o[o.TRIANGLES = 4] = "TRIANGLES", o[o.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", o[o.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES || (DRAW_MODES = {}));
var FORMATS;
(function(o) {
  o[o.RGBA = 6408] = "RGBA", o[o.RGB = 6407] = "RGB", o[o.RG = 33319] = "RG", o[o.RED = 6403] = "RED", o[o.RGBA_INTEGER = 36249] = "RGBA_INTEGER", o[o.RGB_INTEGER = 36248] = "RGB_INTEGER", o[o.RG_INTEGER = 33320] = "RG_INTEGER", o[o.RED_INTEGER = 36244] = "RED_INTEGER", o[o.ALPHA = 6406] = "ALPHA", o[o.LUMINANCE = 6409] = "LUMINANCE", o[o.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", o[o.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", o[o.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS || (FORMATS = {}));
var TARGETS;
(function(o) {
  o[o.TEXTURE_2D = 3553] = "TEXTURE_2D", o[o.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", o[o.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", o[o.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", o[o.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", o[o.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", o[o.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS || (TARGETS = {}));
var TYPES;
(function(o) {
  o[o.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", o[o.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", o[o.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", o[o.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", o[o.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", o[o.UNSIGNED_INT = 5125] = "UNSIGNED_INT", o[o.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", o[o.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", o[o.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", o[o.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", o[o.BYTE = 5120] = "BYTE", o[o.SHORT = 5122] = "SHORT", o[o.INT = 5124] = "INT", o[o.FLOAT = 5126] = "FLOAT", o[o.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", o[o.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES || (TYPES = {}));
var SAMPLER_TYPES;
(function(o) {
  o[o.FLOAT = 0] = "FLOAT", o[o.INT = 1] = "INT", o[o.UINT = 2] = "UINT";
})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));
var SCALE_MODES;
(function(o) {
  o[o.NEAREST = 0] = "NEAREST", o[o.LINEAR = 1] = "LINEAR";
})(SCALE_MODES || (SCALE_MODES = {}));
var WRAP_MODES;
(function(o) {
  o[o.CLAMP = 33071] = "CLAMP", o[o.REPEAT = 10497] = "REPEAT", o[o.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES || (WRAP_MODES = {}));
var MIPMAP_MODES;
(function(o) {
  o[o.OFF = 0] = "OFF", o[o.POW2 = 1] = "POW2", o[o.ON = 2] = "ON", o[o.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES || (MIPMAP_MODES = {}));
var ALPHA_MODES;
(function(o) {
  o[o.NPM = 0] = "NPM", o[o.UNPACK = 1] = "UNPACK", o[o.PMA = 2] = "PMA", o[o.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", o[o.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", o[o.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", o[o.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES || (ALPHA_MODES = {}));
var CLEAR_MODES;
(function(o) {
  o[o.NO = 0] = "NO", o[o.YES = 1] = "YES", o[o.AUTO = 2] = "AUTO", o[o.BLEND = 0] = "BLEND", o[o.CLEAR = 1] = "CLEAR", o[o.BLIT = 2] = "BLIT";
})(CLEAR_MODES || (CLEAR_MODES = {}));
var GC_MODES;
(function(o) {
  o[o.AUTO = 0] = "AUTO", o[o.MANUAL = 1] = "MANUAL";
})(GC_MODES || (GC_MODES = {}));
var PRECISION;
(function(o) {
  o.LOW = "lowp", o.MEDIUM = "mediump", o.HIGH = "highp";
})(PRECISION || (PRECISION = {}));
var MASK_TYPES;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.SCISSOR = 1] = "SCISSOR", o[o.STENCIL = 2] = "STENCIL", o[o.SPRITE = 3] = "SPRITE", o[o.COLOR = 4] = "COLOR";
})(MASK_TYPES || (MASK_TYPES = {}));
var COLOR_MASK_BITS;
(function(o) {
  o[o.RED = 1] = "RED", o[o.GREEN = 2] = "GREEN", o[o.BLUE = 4] = "BLUE", o[o.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS || (COLOR_MASK_BITS = {}));
var MSAA_QUALITY;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.LOW = 2] = "LOW", o[o.MEDIUM = 4] = "MEDIUM", o[o.HIGH = 8] = "HIGH";
})(MSAA_QUALITY || (MSAA_QUALITY = {}));
var BUFFER_TYPE;
(function(o) {
  o[o.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", o[o.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", o[o.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE || (BUFFER_TYPE = {}));
/*!
 * @pixi/settings - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var BrowserAdapter = {
  /**
   * Creates a canvas element of the given size.
   * This canvas is created using the browser's native canvas element.
   * @param width - width of the canvas
   * @param height - height of the canvas
   */
  createCanvas: function(o, t) {
    var e = document.createElement("canvas");
    return e.width = o, e.height = t, e;
  },
  getWebGLRenderingContext: function() {
    return WebGLRenderingContext;
  },
  getNavigator: function() {
    return navigator;
  },
  getBaseUrl: function() {
    var o;
    return (o = document.baseURI) !== null && o !== void 0 ? o : window.location.href;
  },
  fetch: function(o, t) {
    return fetch(o, t);
  }
}, appleIphone = /iPhone/i, appleIpod = /iPod/i, appleTablet = /iPad/i, appleUniversal = /\biOS-universal(?:.+)Mac\b/i, androidPhone = /\bAndroid(?:.+)Mobile\b/i, androidTablet = /Android/i, amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, amazonTablet = /Silk/i, windowsPhone = /Windows Phone/i, windowsTablet = /\bWindows(?:.+)ARM\b/i, otherBlackBerry = /BlackBerry/i, otherBlackBerry10 = /BB10/i, otherOpera = /Opera Mini/i, otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i, otherFirefox = /Mobile(?:.+)Firefox\b/i, isAppleTabletOnIos13 = function(o) {
  return typeof o < "u" && o.platform === "MacIntel" && typeof o.maxTouchPoints == "number" && o.maxTouchPoints > 1 && typeof MSStream > "u";
};
function createMatch(o) {
  return function(t) {
    return t.test(o);
  };
}
function isMobile$1(o) {
  var t = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  !o && typeof navigator < "u" ? t = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    maxTouchPoints: navigator.maxTouchPoints || 0
  } : typeof o == "string" ? t.userAgent = o : o && o.userAgent && (t = {
    userAgent: o.userAgent,
    platform: o.platform,
    maxTouchPoints: o.maxTouchPoints || 0
  });
  var e = t.userAgent, r = e.split("[FBAN");
  typeof r[1] < "u" && (e = r[0]), r = e.split("Twitter"), typeof r[1] < "u" && (e = r[0]);
  var S = createMatch(e), T = {
    apple: {
      phone: S(appleIphone) && !S(windowsPhone),
      ipod: S(appleIpod),
      tablet: !S(appleIphone) && (S(appleTablet) || isAppleTabletOnIos13(t)) && !S(windowsPhone),
      universal: S(appleUniversal),
      device: (S(appleIphone) || S(appleIpod) || S(appleTablet) || S(appleUniversal) || isAppleTabletOnIos13(t)) && !S(windowsPhone)
    },
    amazon: {
      phone: S(amazonPhone),
      tablet: !S(amazonPhone) && S(amazonTablet),
      device: S(amazonPhone) || S(amazonTablet)
    },
    android: {
      phone: !S(windowsPhone) && S(amazonPhone) || !S(windowsPhone) && S(androidPhone),
      tablet: !S(windowsPhone) && !S(amazonPhone) && !S(androidPhone) && (S(amazonTablet) || S(androidTablet)),
      device: !S(windowsPhone) && (S(amazonPhone) || S(amazonTablet) || S(androidPhone) || S(androidTablet)) || S(/\bokhttp\b/i)
    },
    windows: {
      phone: S(windowsPhone),
      tablet: S(windowsTablet),
      device: S(windowsPhone) || S(windowsTablet)
    },
    other: {
      blackberry: S(otherBlackBerry),
      blackberry10: S(otherBlackBerry10),
      opera: S(otherOpera),
      firefox: S(otherFirefox),
      chrome: S(otherChrome),
      device: S(otherBlackBerry) || S(otherBlackBerry10) || S(otherOpera) || S(otherFirefox) || S(otherChrome)
    },
    any: !1,
    phone: !1,
    tablet: !1
  };
  return T.any = T.apple.device || T.android.device || T.windows.device || T.other.device, T.phone = T.apple.phone || T.android.phone || T.windows.phone, T.tablet = T.apple.tablet || T.android.tablet || T.windows.tablet, T;
}
var isMobile = isMobile$1(globalThis.navigator);
function canUploadSameBuffer() {
  return !isMobile.apple.device;
}
function maxRecommendedTextures(o) {
  var t = !0;
  if (isMobile.tablet || isMobile.phone) {
    if (isMobile.apple.device) {
      var e = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (e) {
        var r = parseInt(e[1], 10);
        r < 11 && (t = !1);
      }
    }
    if (isMobile.android.device) {
      var e = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (e) {
        var r = parseInt(e[1], 10);
        r < 7 && (t = !1);
      }
    }
  }
  return t ? o : 4;
}
var settings = {
  /**
   * This adapter is used to call methods that are platform dependent.
   * For example `document.createElement` only runs on the web but fails in node environments.
   * This allows us to support more platforms by abstracting away specific implementations per platform.
   *
   * By default the adapter is set to work in the browser. However you can create your own
   * by implementing the `IAdapter` interface. See `IAdapter` for more information.
   * @name ADAPTER
   * @memberof PIXI.settings
   * @type {PIXI.IAdapter}
   * @default PIXI.BrowserAdapter
   */
  ADAPTER: BrowserAdapter,
  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  MIPMAP_TEXTURES: MIPMAP_MODES.POW2,
  /**
   * Default anisotropic filtering level of textures.
   * Usually from 0 to 16
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @default 0
   */
  ANISOTROPIC_LEVEL: 0,
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Default filter resolution.
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,
  /**
   * Default filter samples.
   * @static
   * @name FILTER_MULTISAMPLE
   * @memberof PIXI.settings
   * @type {PIXI.MSAA_QUALITY}
   * @default PIXI.MSAA_QUALITY.NONE
   */
  FILTER_MULTISAMPLE: MSAA_QUALITY.NONE,
  /**
   * The maximum textures that this device supports.
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @type {number}
   * @default 32
   */
  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,
  /**
   * The default render options if none are supplied to {@link PIXI.Renderer}
   * or {@link PIXI.CanvasRenderer}.
   * @static
   * @name RENDER_OPTIONS
   * @memberof PIXI.settings
   * @type {object}
   * @property {HTMLCanvasElement} [view=null] -
   * @property {boolean} [antialias=false] -
   * @property {boolean} [autoDensity=false] -
   * @property {boolean} [useContextAlpha=true]  -
   * @property {number} [backgroundColor=0x000000] -
   * @property {number} [backgroundAlpha=1] -
   * @property {boolean} [clearBeforeRender=true] -
   * @property {boolean} [preserveDrawingBuffer=false] -
   * @property {number} [width=800] -
   * @property {number} [height=600] -
   * @property {boolean} [legacy=false] -
   */
  RENDER_OPTIONS: {
    view: null,
    antialias: !1,
    autoDensity: !1,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: !0,
    clearBeforeRender: !0,
    preserveDrawingBuffer: !1,
    width: 800,
    height: 600,
    legacy: !1
  },
  /**
   * Default Garbage Collection mode.
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: GC_MODES.AUTO,
  /**
   * Default Garbage Collection max idle.
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,
  /**
   * Default Garbage Collection maximum check count.
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,
  /**
   * Default wrap modes that are supported by pixi.
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: WRAP_MODES.CLAMP,
  /**
   * Default scale mode for textures.
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: SCALE_MODES.LINEAR,
  /**
   * Default specify float precision in vertex shader.
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.HIGH
   */
  PRECISION_VERTEX: PRECISION.HIGH,
  /**
   * Default specify float precision in fragment shader.
   * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM,
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: !1,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: !1
}, eventemitter3Exports = {}, eventemitter3 = {
  get exports() {
    return eventemitter3Exports;
  },
  set exports(o) {
    eventemitter3Exports = o;
  }
};
(function(o) {
  var t = Object.prototype.hasOwnProperty, e = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (e = !1));
  function S(B, $, U) {
    this.fn = B, this.context = $, this.once = U || !1;
  }
  function T(B, $, U, H, V) {
    if (typeof U != "function")
      throw new TypeError("The listener must be a function");
    var X = new S(U, H || B, V), W = e ? e + $ : $;
    return B._events[W] ? B._events[W].fn ? B._events[W] = [B._events[W], X] : B._events[W].push(X) : (B._events[W] = X, B._eventsCount++), B;
  }
  function D(B, $) {
    --B._eventsCount === 0 ? B._events = new r() : delete B._events[$];
  }
  function N() {
    this._events = new r(), this._eventsCount = 0;
  }
  N.prototype.eventNames = function() {
    var $ = [], U, H;
    if (this._eventsCount === 0)
      return $;
    for (H in U = this._events)
      t.call(U, H) && $.push(e ? H.slice(1) : H);
    return Object.getOwnPropertySymbols ? $.concat(Object.getOwnPropertySymbols(U)) : $;
  }, N.prototype.listeners = function($) {
    var U = e ? e + $ : $, H = this._events[U];
    if (!H)
      return [];
    if (H.fn)
      return [H.fn];
    for (var V = 0, X = H.length, W = new Array(X); V < X; V++)
      W[V] = H[V].fn;
    return W;
  }, N.prototype.listenerCount = function($) {
    var U = e ? e + $ : $, H = this._events[U];
    return H ? H.fn ? 1 : H.length : 0;
  }, N.prototype.emit = function($, U, H, V, X, W) {
    var Y = e ? e + $ : $;
    if (!this._events[Y])
      return !1;
    var q = this._events[Y], K = arguments.length, Z, J;
    if (q.fn) {
      switch (q.once && this.removeListener($, q.fn, void 0, !0), K) {
        case 1:
          return q.fn.call(q.context), !0;
        case 2:
          return q.fn.call(q.context, U), !0;
        case 3:
          return q.fn.call(q.context, U, H), !0;
        case 4:
          return q.fn.call(q.context, U, H, V), !0;
        case 5:
          return q.fn.call(q.context, U, H, V, X), !0;
        case 6:
          return q.fn.call(q.context, U, H, V, X, W), !0;
      }
      for (J = 1, Z = new Array(K - 1); J < K; J++)
        Z[J - 1] = arguments[J];
      q.fn.apply(q.context, Z);
    } else {
      var Q = q.length, rt;
      for (J = 0; J < Q; J++)
        switch (q[J].once && this.removeListener($, q[J].fn, void 0, !0), K) {
          case 1:
            q[J].fn.call(q[J].context);
            break;
          case 2:
            q[J].fn.call(q[J].context, U);
            break;
          case 3:
            q[J].fn.call(q[J].context, U, H);
            break;
          case 4:
            q[J].fn.call(q[J].context, U, H, V);
            break;
          default:
            if (!Z)
              for (rt = 1, Z = new Array(K - 1); rt < K; rt++)
                Z[rt - 1] = arguments[rt];
            q[J].fn.apply(q[J].context, Z);
        }
    }
    return !0;
  }, N.prototype.on = function($, U, H) {
    return T(this, $, U, H, !1);
  }, N.prototype.once = function($, U, H) {
    return T(this, $, U, H, !0);
  }, N.prototype.removeListener = function($, U, H, V) {
    var X = e ? e + $ : $;
    if (!this._events[X])
      return this;
    if (!U)
      return D(this, X), this;
    var W = this._events[X];
    if (W.fn)
      W.fn === U && (!V || W.once) && (!H || W.context === H) && D(this, X);
    else {
      for (var Y = 0, q = [], K = W.length; Y < K; Y++)
        (W[Y].fn !== U || V && !W[Y].once || H && W[Y].context !== H) && q.push(W[Y]);
      q.length ? this._events[X] = q.length === 1 ? q[0] : q : D(this, X);
    }
    return this;
  }, N.prototype.removeAllListeners = function($) {
    var U;
    return $ ? (U = e ? e + $ : $, this._events[U] && D(this, U)) : (this._events = new r(), this._eventsCount = 0), this;
  }, N.prototype.off = N.prototype.removeListener, N.prototype.addListener = N.prototype.on, N.prefixed = e, N.EventEmitter = N, o.exports = N;
})(eventemitter3);
var earcutExports = {}, earcut$1 = {
  get exports() {
    return earcutExports;
  },
  set exports(o) {
    earcutExports = o;
  }
};
earcut$1.exports = earcut;
earcutExports.default = earcut;
function earcut(o, t, e) {
  e = e || 2;
  var r = t && t.length, S = r ? t[0] * e : o.length, T = linkedList(o, 0, S, e, !0), D = [];
  if (!T || T.next === T.prev)
    return D;
  var N, B, $, U, H, V, X;
  if (r && (T = eliminateHoles(o, t, T, e)), o.length > 80 * e) {
    N = $ = o[0], B = U = o[1];
    for (var W = e; W < S; W += e)
      H = o[W], V = o[W + 1], H < N && (N = H), V < B && (B = V), H > $ && ($ = H), V > U && (U = V);
    X = Math.max($ - N, U - B), X = X !== 0 ? 32767 / X : 0;
  }
  return earcutLinked(T, D, e, N, B, X, 0), D;
}
function linkedList(o, t, e, r, S) {
  var T, D;
  if (S === signedArea(o, t, e, r) > 0)
    for (T = t; T < e; T += r)
      D = insertNode(T, o[T], o[T + 1], D);
  else
    for (T = e - r; T >= t; T -= r)
      D = insertNode(T, o[T], o[T + 1], D);
  return D && equals$1(D, D.next) && (removeNode(D), D = D.next), D;
}
function filterPoints(o, t) {
  if (!o)
    return o;
  t || (t = o);
  var e = o, r;
  do
    if (r = !1, !e.steiner && (equals$1(e, e.next) || area(e.prev, e, e.next) === 0)) {
      if (removeNode(e), e = t = e.prev, e === e.next)
        break;
      r = !0;
    } else
      e = e.next;
  while (r || e !== t);
  return t;
}
function earcutLinked(o, t, e, r, S, T, D) {
  if (o) {
    !D && T && indexCurve(o, r, S, T);
    for (var N = o, B, $; o.prev !== o.next; ) {
      if (B = o.prev, $ = o.next, T ? isEarHashed(o, r, S, T) : isEar(o)) {
        t.push(B.i / e | 0), t.push(o.i / e | 0), t.push($.i / e | 0), removeNode(o), o = $.next, N = $.next;
        continue;
      }
      if (o = $, o === N) {
        D ? D === 1 ? (o = cureLocalIntersections(filterPoints(o), t, e), earcutLinked(o, t, e, r, S, T, 2)) : D === 2 && splitEarcut(o, t, e, r, S, T) : earcutLinked(filterPoints(o), t, e, r, S, T, 1);
        break;
      }
    }
  }
}
function isEar(o) {
  var t = o.prev, e = o, r = o.next;
  if (area(t, e, r) >= 0)
    return !1;
  for (var S = t.x, T = e.x, D = r.x, N = t.y, B = e.y, $ = r.y, U = S < T ? S < D ? S : D : T < D ? T : D, H = N < B ? N < $ ? N : $ : B < $ ? B : $, V = S > T ? S > D ? S : D : T > D ? T : D, X = N > B ? N > $ ? N : $ : B > $ ? B : $, W = r.next; W !== t; ) {
    if (W.x >= U && W.x <= V && W.y >= H && W.y <= X && pointInTriangle(S, N, T, B, D, $, W.x, W.y) && area(W.prev, W, W.next) >= 0)
      return !1;
    W = W.next;
  }
  return !0;
}
function isEarHashed(o, t, e, r) {
  var S = o.prev, T = o, D = o.next;
  if (area(S, T, D) >= 0)
    return !1;
  for (var N = S.x, B = T.x, $ = D.x, U = S.y, H = T.y, V = D.y, X = N < B ? N < $ ? N : $ : B < $ ? B : $, W = U < H ? U < V ? U : V : H < V ? H : V, Y = N > B ? N > $ ? N : $ : B > $ ? B : $, q = U > H ? U > V ? U : V : H > V ? H : V, K = zOrder(X, W, t, e, r), Z = zOrder(Y, q, t, e, r), J = o.prevZ, Q = o.nextZ; J && J.z >= K && Q && Q.z <= Z; ) {
    if (J.x >= X && J.x <= Y && J.y >= W && J.y <= q && J !== S && J !== D && pointInTriangle(N, U, B, H, $, V, J.x, J.y) && area(J.prev, J, J.next) >= 0 || (J = J.prevZ, Q.x >= X && Q.x <= Y && Q.y >= W && Q.y <= q && Q !== S && Q !== D && pointInTriangle(N, U, B, H, $, V, Q.x, Q.y) && area(Q.prev, Q, Q.next) >= 0))
      return !1;
    Q = Q.nextZ;
  }
  for (; J && J.z >= K; ) {
    if (J.x >= X && J.x <= Y && J.y >= W && J.y <= q && J !== S && J !== D && pointInTriangle(N, U, B, H, $, V, J.x, J.y) && area(J.prev, J, J.next) >= 0)
      return !1;
    J = J.prevZ;
  }
  for (; Q && Q.z <= Z; ) {
    if (Q.x >= X && Q.x <= Y && Q.y >= W && Q.y <= q && Q !== S && Q !== D && pointInTriangle(N, U, B, H, $, V, Q.x, Q.y) && area(Q.prev, Q, Q.next) >= 0)
      return !1;
    Q = Q.nextZ;
  }
  return !0;
}
function cureLocalIntersections(o, t, e) {
  var r = o;
  do {
    var S = r.prev, T = r.next.next;
    !equals$1(S, T) && intersects(S, r, r.next, T) && locallyInside(S, T) && locallyInside(T, S) && (t.push(S.i / e | 0), t.push(r.i / e | 0), t.push(T.i / e | 0), removeNode(r), removeNode(r.next), r = o = T), r = r.next;
  } while (r !== o);
  return filterPoints(r);
}
function splitEarcut(o, t, e, r, S, T) {
  var D = o;
  do {
    for (var N = D.next.next; N !== D.prev; ) {
      if (D.i !== N.i && isValidDiagonal(D, N)) {
        var B = splitPolygon(D, N);
        D = filterPoints(D, D.next), B = filterPoints(B, B.next), earcutLinked(D, t, e, r, S, T, 0), earcutLinked(B, t, e, r, S, T, 0);
        return;
      }
      N = N.next;
    }
    D = D.next;
  } while (D !== o);
}
function eliminateHoles(o, t, e, r) {
  var S = [], T, D, N, B, $;
  for (T = 0, D = t.length; T < D; T++)
    N = t[T] * r, B = T < D - 1 ? t[T + 1] * r : o.length, $ = linkedList(o, N, B, r, !1), $ === $.next && ($.steiner = !0), S.push(getLeftmost($));
  for (S.sort(compareX), T = 0; T < S.length; T++)
    e = eliminateHole(S[T], e);
  return e;
}
function compareX(o, t) {
  return o.x - t.x;
}
function eliminateHole(o, t) {
  var e = findHoleBridge(o, t);
  if (!e)
    return t;
  var r = splitPolygon(e, o);
  return filterPoints(r, r.next), filterPoints(e, e.next);
}
function findHoleBridge(o, t) {
  var e = t, r = o.x, S = o.y, T = -1 / 0, D;
  do {
    if (S <= e.y && S >= e.next.y && e.next.y !== e.y) {
      var N = e.x + (S - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (N <= r && N > T && (T = N, D = e.x < e.next.x ? e : e.next, N === r))
        return D;
    }
    e = e.next;
  } while (e !== t);
  if (!D)
    return null;
  var B = D, $ = D.x, U = D.y, H = 1 / 0, V;
  e = D;
  do
    r >= e.x && e.x >= $ && r !== e.x && pointInTriangle(S < U ? r : T, S, $, U, S < U ? T : r, S, e.x, e.y) && (V = Math.abs(S - e.y) / (r - e.x), locallyInside(e, o) && (V < H || V === H && (e.x > D.x || e.x === D.x && sectorContainsSector(D, e))) && (D = e, H = V)), e = e.next;
  while (e !== B);
  return D;
}
function sectorContainsSector(o, t) {
  return area(o.prev, o, t.prev) < 0 && area(t.next, o, o.next) < 0;
}
function indexCurve(o, t, e, r) {
  var S = o;
  do
    S.z === 0 && (S.z = zOrder(S.x, S.y, t, e, r)), S.prevZ = S.prev, S.nextZ = S.next, S = S.next;
  while (S !== o);
  S.prevZ.nextZ = null, S.prevZ = null, sortLinked(S);
}
function sortLinked(o) {
  var t, e, r, S, T, D, N, B, $ = 1;
  do {
    for (e = o, o = null, T = null, D = 0; e; ) {
      for (D++, r = e, N = 0, t = 0; t < $ && (N++, r = r.nextZ, !!r); t++)
        ;
      for (B = $; N > 0 || B > 0 && r; )
        N !== 0 && (B === 0 || !r || e.z <= r.z) ? (S = e, e = e.nextZ, N--) : (S = r, r = r.nextZ, B--), T ? T.nextZ = S : o = S, S.prevZ = T, T = S;
      e = r;
    }
    T.nextZ = null, $ *= 2;
  } while (D > 1);
  return o;
}
function zOrder(o, t, e, r, S) {
  return o = (o - e) * S | 0, t = (t - r) * S | 0, o = (o | o << 8) & 16711935, o = (o | o << 4) & 252645135, o = (o | o << 2) & 858993459, o = (o | o << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, o | t << 1;
}
function getLeftmost(o) {
  var t = o, e = o;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== o);
  return e;
}
function pointInTriangle(o, t, e, r, S, T, D, N) {
  return (S - D) * (t - N) >= (o - D) * (T - N) && (o - D) * (r - N) >= (e - D) * (t - N) && (e - D) * (T - N) >= (S - D) * (r - N);
}
function isValidDiagonal(o, t) {
  return o.next.i !== t.i && o.prev.i !== t.i && !intersectsPolygon(o, t) && (locallyInside(o, t) && locallyInside(t, o) && middleInside(o, t) && (area(o.prev, o, t.prev) || area(o, t.prev, t)) || // does not create opposite-facing sectors
  equals$1(o, t) && area(o.prev, o, o.next) > 0 && area(t.prev, t, t.next) > 0);
}
function area(o, t, e) {
  return (t.y - o.y) * (e.x - t.x) - (t.x - o.x) * (e.y - t.y);
}
function equals$1(o, t) {
  return o.x === t.x && o.y === t.y;
}
function intersects(o, t, e, r) {
  var S = sign$1(area(o, t, e)), T = sign$1(area(o, t, r)), D = sign$1(area(e, r, o)), N = sign$1(area(e, r, t));
  return !!(S !== T && D !== N || S === 0 && onSegment(o, e, t) || T === 0 && onSegment(o, r, t) || D === 0 && onSegment(e, o, r) || N === 0 && onSegment(e, t, r));
}
function onSegment(o, t, e) {
  return t.x <= Math.max(o.x, e.x) && t.x >= Math.min(o.x, e.x) && t.y <= Math.max(o.y, e.y) && t.y >= Math.min(o.y, e.y);
}
function sign$1(o) {
  return o > 0 ? 1 : o < 0 ? -1 : 0;
}
function intersectsPolygon(o, t) {
  var e = o;
  do {
    if (e.i !== o.i && e.next.i !== o.i && e.i !== t.i && e.next.i !== t.i && intersects(e, e.next, o, t))
      return !0;
    e = e.next;
  } while (e !== o);
  return !1;
}
function locallyInside(o, t) {
  return area(o.prev, o, o.next) < 0 ? area(o, t, o.next) >= 0 && area(o, o.prev, t) >= 0 : area(o, t, o.prev) < 0 || area(o, o.next, t) < 0;
}
function middleInside(o, t) {
  var e = o, r = !1, S = (o.x + t.x) / 2, T = (o.y + t.y) / 2;
  do
    e.y > T != e.next.y > T && e.next.y !== e.y && S < (e.next.x - e.x) * (T - e.y) / (e.next.y - e.y) + e.x && (r = !r), e = e.next;
  while (e !== o);
  return r;
}
function splitPolygon(o, t) {
  var e = new Node$1(o.i, o.x, o.y), r = new Node$1(t.i, t.x, t.y), S = o.next, T = t.prev;
  return o.next = t, t.prev = o, e.next = S, S.prev = e, r.next = e, e.prev = r, T.next = r, r.prev = T, r;
}
function insertNode(o, t, e, r) {
  var S = new Node$1(o, t, e);
  return r ? (S.next = r.next, S.prev = r, r.next.prev = S, r.next = S) : (S.prev = S, S.next = S), S;
}
function removeNode(o) {
  o.next.prev = o.prev, o.prev.next = o.next, o.prevZ && (o.prevZ.nextZ = o.nextZ), o.nextZ && (o.nextZ.prevZ = o.prevZ);
}
function Node$1(o, t, e) {
  this.i = o, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
earcut.deviation = function(o, t, e, r) {
  var S = t && t.length, T = S ? t[0] * e : o.length, D = Math.abs(signedArea(o, 0, T, e));
  if (S)
    for (var N = 0, B = t.length; N < B; N++) {
      var $ = t[N] * e, U = N < B - 1 ? t[N + 1] * e : o.length;
      D -= Math.abs(signedArea(o, $, U, e));
    }
  var H = 0;
  for (N = 0; N < r.length; N += 3) {
    var V = r[N] * e, X = r[N + 1] * e, W = r[N + 2] * e;
    H += Math.abs(
      (o[V] - o[W]) * (o[X + 1] - o[V + 1]) - (o[V] - o[X]) * (o[W + 1] - o[V + 1])
    );
  }
  return D === 0 && H === 0 ? 0 : Math.abs((H - D) / D);
};
function signedArea(o, t, e, r) {
  for (var S = 0, T = t, D = e - r; T < e; T += r)
    S += (o[D] - o[T]) * (o[T + 1] + o[D + 1]), D = T;
  return S;
}
earcut.flatten = function(o) {
  for (var t = o[0][0].length, e = { vertices: [], holes: [], dimensions: t }, r = 0, S = 0; S < o.length; S++) {
    for (var T = 0; T < o[S].length; T++)
      for (var D = 0; D < t; D++)
        e.vertices.push(o[S][T][D]);
    S > 0 && (r += o[S - 1].length, e.holes.push(r));
  }
  return e;
};
var punycodeExports = {}, punycode$1 = {
  get exports() {
    return punycodeExports;
  },
  set exports(o) {
    punycodeExports = o;
  }
};
/*! https://mths.be/punycode v1.3.2 by @mathias */
(function(o, t) {
  (function(e) {
    var r = t && !t.nodeType && t, S = o && !o.nodeType && o, T = typeof commonjsGlobal == "object" && commonjsGlobal;
    (T.global === T || T.window === T || T.self === T) && (e = T);
    var D, N = 2147483647, B = 36, $ = 1, U = 26, H = 38, V = 700, X = 72, W = 128, Y = "-", q = /^xn--/, K = /[^\x20-\x7E]/, Z = /[\x2E\u3002\uFF0E\uFF61]/g, J = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, Q = B - $, rt = Math.floor, et = String.fromCharCode, nt;
    function st(pt) {
      throw RangeError(J[pt]);
    }
    function it(pt, yt) {
      for (var Dt = pt.length, At = []; Dt--; )
        At[Dt] = yt(pt[Dt]);
      return At;
    }
    function ot(pt, yt) {
      var Dt = pt.split("@"), At = "";
      Dt.length > 1 && (At = Dt[0] + "@", pt = Dt[1]), pt = pt.replace(Z, ".");
      var It = pt.split("."), Ot = it(It, yt).join(".");
      return At + Ot;
    }
    function ht(pt) {
      for (var yt = [], Dt = 0, At = pt.length, It, Ot; Dt < At; )
        It = pt.charCodeAt(Dt++), It >= 55296 && It <= 56319 && Dt < At ? (Ot = pt.charCodeAt(Dt++), (Ot & 64512) == 56320 ? yt.push(((It & 1023) << 10) + (Ot & 1023) + 65536) : (yt.push(It), Dt--)) : yt.push(It);
      return yt;
    }
    function ct(pt) {
      return it(pt, function(yt) {
        var Dt = "";
        return yt > 65535 && (yt -= 65536, Dt += et(yt >>> 10 & 1023 | 55296), yt = 56320 | yt & 1023), Dt += et(yt), Dt;
      }).join("");
    }
    function vt(pt) {
      return pt - 48 < 10 ? pt - 22 : pt - 65 < 26 ? pt - 65 : pt - 97 < 26 ? pt - 97 : B;
    }
    function _t(pt, yt) {
      return pt + 22 + 75 * (pt < 26) - ((yt != 0) << 5);
    }
    function gt(pt, yt, Dt) {
      var At = 0;
      for (pt = Dt ? rt(pt / V) : pt >> 1, pt += rt(pt / yt); pt > Q * U >> 1; At += B)
        pt = rt(pt / Q);
      return rt(At + (Q + 1) * pt / (pt + H));
    }
    function mt(pt) {
      var yt = [], Dt = pt.length, At, It = 0, Ot = W, ft = X, Ft, Mt, zt, Nt, St, Ht, Lt, Tt, kt;
      for (Ft = pt.lastIndexOf(Y), Ft < 0 && (Ft = 0), Mt = 0; Mt < Ft; ++Mt)
        pt.charCodeAt(Mt) >= 128 && st("not-basic"), yt.push(pt.charCodeAt(Mt));
      for (zt = Ft > 0 ? Ft + 1 : 0; zt < Dt; ) {
        for (Nt = It, St = 1, Ht = B; zt >= Dt && st("invalid-input"), Lt = vt(pt.charCodeAt(zt++)), (Lt >= B || Lt > rt((N - It) / St)) && st("overflow"), It += Lt * St, Tt = Ht <= ft ? $ : Ht >= ft + U ? U : Ht - ft, !(Lt < Tt); Ht += B)
          kt = B - Tt, St > rt(N / kt) && st("overflow"), St *= kt;
        At = yt.length + 1, ft = gt(It - Nt, At, Nt == 0), rt(It / At) > N - Ot && st("overflow"), Ot += rt(It / At), It %= At, yt.splice(It++, 0, Ot);
      }
      return ct(yt);
    }
    function Et(pt) {
      var yt, Dt, At, It, Ot, ft, Ft, Mt, zt, Nt, St, Ht = [], Lt, Tt, kt, Ut;
      for (pt = ht(pt), Lt = pt.length, yt = W, Dt = 0, Ot = X, ft = 0; ft < Lt; ++ft)
        St = pt[ft], St < 128 && Ht.push(et(St));
      for (At = It = Ht.length, It && Ht.push(Y); At < Lt; ) {
        for (Ft = N, ft = 0; ft < Lt; ++ft)
          St = pt[ft], St >= yt && St < Ft && (Ft = St);
        for (Tt = At + 1, Ft - yt > rt((N - Dt) / Tt) && st("overflow"), Dt += (Ft - yt) * Tt, yt = Ft, ft = 0; ft < Lt; ++ft)
          if (St = pt[ft], St < yt && ++Dt > N && st("overflow"), St == yt) {
            for (Mt = Dt, zt = B; Nt = zt <= Ot ? $ : zt >= Ot + U ? U : zt - Ot, !(Mt < Nt); zt += B)
              Ut = Mt - Nt, kt = B - Nt, Ht.push(
                et(_t(Nt + Ut % kt, 0))
              ), Mt = rt(Ut / kt);
            Ht.push(et(_t(Mt, 0))), Ot = gt(Dt, Tt, At == It), Dt = 0, ++At;
          }
        ++Dt, ++yt;
      }
      return Ht.join("");
    }
    function wt(pt) {
      return ot(pt, function(yt) {
        return q.test(yt) ? mt(yt.slice(4).toLowerCase()) : yt;
      });
    }
    function xt(pt) {
      return ot(pt, function(yt) {
        return K.test(yt) ? "xn--" + Et(yt) : yt;
      });
    }
    if (D = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "1.3.2",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: ht,
        encode: ct
      },
      decode: mt,
      encode: Et,
      toASCII: xt,
      toUnicode: wt
    }, r && S)
      if (o.exports == r)
        S.exports = D;
      else
        for (nt in D)
          D.hasOwnProperty(nt) && (r[nt] = D[nt]);
    else
      e.punycode = D;
  })(commonjsGlobal);
})(punycode$1, punycodeExports);
var util$8 = {
  isString: function(o) {
    return typeof o == "string";
  },
  isObject: function(o) {
    return typeof o == "object" && o !== null;
  },
  isNull: function(o) {
    return o === null;
  },
  isNullOrUndefined: function(o) {
    return o == null;
  }
}, querystring$1 = {};
function hasOwnProperty(o, t) {
  return Object.prototype.hasOwnProperty.call(o, t);
}
var decode$2 = function(o, t, e, r) {
  t = t || "&", e = e || "=";
  var S = {};
  if (typeof o != "string" || o.length === 0)
    return S;
  var T = /\+/g;
  o = o.split(t);
  var D = 1e3;
  r && typeof r.maxKeys == "number" && (D = r.maxKeys);
  var N = o.length;
  D > 0 && N > D && (N = D);
  for (var B = 0; B < N; ++B) {
    var $ = o[B].replace(T, "%20"), U = $.indexOf(e), H, V, X, W;
    U >= 0 ? (H = $.substr(0, U), V = $.substr(U + 1)) : (H = $, V = ""), X = decodeURIComponent(H), W = decodeURIComponent(V), hasOwnProperty(S, X) ? Array.isArray(S[X]) ? S[X].push(W) : S[X] = [S[X], W] : S[X] = W;
  }
  return S;
}, stringifyPrimitive = function(o) {
  switch (typeof o) {
    case "string":
      return o;
    case "boolean":
      return o ? "true" : "false";
    case "number":
      return isFinite(o) ? o : "";
    default:
      return "";
  }
}, encode$2 = function(o, t, e, r) {
  return t = t || "&", e = e || "=", o === null && (o = void 0), typeof o == "object" ? Object.keys(o).map(function(S) {
    var T = encodeURIComponent(stringifyPrimitive(S)) + e;
    return Array.isArray(o[S]) ? o[S].map(function(D) {
      return T + encodeURIComponent(stringifyPrimitive(D));
    }).join(t) : T + encodeURIComponent(stringifyPrimitive(o[S]));
  }).join(t) : r ? encodeURIComponent(stringifyPrimitive(r)) + e + encodeURIComponent(stringifyPrimitive(o)) : "";
};
querystring$1.decode = querystring$1.parse = decode$2;
querystring$1.encode = querystring$1.stringify = encode$2;
var punycode = punycodeExports, util$7 = util$8, parse$2 = urlParse, resolve = urlResolve, format$1 = urlFormat;
function Url() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", `
`, "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  javascript: !0,
  "javascript:": !0
}, hostlessProtocol = {
  javascript: !0,
  "javascript:": !0
}, slashedProtocol = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
}, querystring = querystring$1;
function urlParse(o, t, e) {
  if (o && util$7.isObject(o) && o instanceof Url)
    return o;
  var r = new Url();
  return r.parse(o, t, e), r;
}
Url.prototype.parse = function(o, t, e) {
  if (!util$7.isString(o))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof o);
  var r = o.indexOf("?"), S = r !== -1 && r < o.indexOf("#") ? "?" : "#", T = o.split(S), D = /\\/g;
  T[0] = T[0].replace(D, "/"), o = T.join(S);
  var N = o;
  if (N = N.trim(), !e && o.split("#").length === 1) {
    var B = simplePathPattern.exec(N);
    if (B)
      return this.path = N, this.href = N, this.pathname = B[1], B[2] ? (this.search = B[2], t ? this.query = querystring.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
  }
  var $ = protocolPattern.exec(N);
  if ($) {
    $ = $[0];
    var U = $.toLowerCase();
    this.protocol = U, N = N.substr($.length);
  }
  if (e || $ || N.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var H = N.substr(0, 2) === "//";
    H && !($ && hostlessProtocol[$]) && (N = N.substr(2), this.slashes = !0);
  }
  if (!hostlessProtocol[$] && (H || $ && !slashedProtocol[$])) {
    for (var V = -1, X = 0; X < hostEndingChars.length; X++) {
      var W = N.indexOf(hostEndingChars[X]);
      W !== -1 && (V === -1 || W < V) && (V = W);
    }
    var Y, q;
    V === -1 ? q = N.lastIndexOf("@") : q = N.lastIndexOf("@", V), q !== -1 && (Y = N.slice(0, q), N = N.slice(q + 1), this.auth = decodeURIComponent(Y)), V = -1;
    for (var X = 0; X < nonHostChars.length; X++) {
      var W = N.indexOf(nonHostChars[X]);
      W !== -1 && (V === -1 || W < V) && (V = W);
    }
    V === -1 && (V = N.length), this.host = N.slice(0, V), N = N.slice(V), this.parseHost(), this.hostname = this.hostname || "";
    var K = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!K)
      for (var Z = this.hostname.split(/\./), X = 0, J = Z.length; X < J; X++) {
        var Q = Z[X];
        if (Q && !Q.match(hostnamePartPattern)) {
          for (var rt = "", et = 0, nt = Q.length; et < nt; et++)
            Q.charCodeAt(et) > 127 ? rt += "x" : rt += Q[et];
          if (!rt.match(hostnamePartPattern)) {
            var st = Z.slice(0, X), it = Z.slice(X + 1), ot = Q.match(hostnamePartStart);
            ot && (st.push(ot[1]), it.unshift(ot[2])), it.length && (N = "/" + it.join(".") + N), this.hostname = st.join(".");
            break;
          }
        }
      }
    this.hostname.length > hostnameMaxLen ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), K || (this.hostname = punycode.toASCII(this.hostname));
    var ht = this.port ? ":" + this.port : "", ct = this.hostname || "";
    this.host = ct + ht, this.href += this.host, K && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), N[0] !== "/" && (N = "/" + N));
  }
  if (!unsafeProtocol[U])
    for (var X = 0, J = autoEscape.length; X < J; X++) {
      var vt = autoEscape[X];
      if (N.indexOf(vt) !== -1) {
        var _t = encodeURIComponent(vt);
        _t === vt && (_t = escape(vt)), N = N.split(vt).join(_t);
      }
    }
  var gt = N.indexOf("#");
  gt !== -1 && (this.hash = N.substr(gt), N = N.slice(0, gt));
  var mt = N.indexOf("?");
  if (mt !== -1 ? (this.search = N.substr(mt), this.query = N.substr(mt + 1), t && (this.query = querystring.parse(this.query)), N = N.slice(0, mt)) : t && (this.search = "", this.query = {}), N && (this.pathname = N), slashedProtocol[U] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var ht = this.pathname || "", Et = this.search || "";
    this.path = ht + Et;
  }
  return this.href = this.format(), this;
};
function urlFormat(o) {
  return util$7.isString(o) && (o = urlParse(o)), o instanceof Url ? o.format() : Url.prototype.format.call(o);
}
Url.prototype.format = function() {
  var o = this.auth || "";
  o && (o = encodeURIComponent(o), o = o.replace(/%3A/i, ":"), o += "@");
  var t = this.protocol || "", e = this.pathname || "", r = this.hash || "", S = !1, T = "";
  this.host ? S = o + this.host : this.hostname && (S = o + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (S += ":" + this.port)), this.query && util$7.isObject(this.query) && Object.keys(this.query).length && (T = querystring.stringify(this.query));
  var D = this.search || T && "?" + T || "";
  return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || slashedProtocol[t]) && S !== !1 ? (S = "//" + (S || ""), e && e.charAt(0) !== "/" && (e = "/" + e)) : S || (S = ""), r && r.charAt(0) !== "#" && (r = "#" + r), D && D.charAt(0) !== "?" && (D = "?" + D), e = e.replace(/[?#]/g, function(N) {
    return encodeURIComponent(N);
  }), D = D.replace("#", "%23"), t + S + e + D + r;
};
function urlResolve(o, t) {
  return urlParse(o, !1, !0).resolve(t);
}
Url.prototype.resolve = function(o) {
  return this.resolveObject(urlParse(o, !1, !0)).format();
};
Url.prototype.resolveObject = function(o) {
  if (util$7.isString(o)) {
    var t = new Url();
    t.parse(o, !1, !0), o = t;
  }
  for (var e = new Url(), r = Object.keys(this), S = 0; S < r.length; S++) {
    var T = r[S];
    e[T] = this[T];
  }
  if (e.hash = o.hash, o.href === "")
    return e.href = e.format(), e;
  if (o.slashes && !o.protocol) {
    for (var D = Object.keys(o), N = 0; N < D.length; N++) {
      var B = D[N];
      B !== "protocol" && (e[B] = o[B]);
    }
    return slashedProtocol[e.protocol] && e.hostname && !e.pathname && (e.path = e.pathname = "/"), e.href = e.format(), e;
  }
  if (o.protocol && o.protocol !== e.protocol) {
    if (!slashedProtocol[o.protocol]) {
      for (var $ = Object.keys(o), U = 0; U < $.length; U++) {
        var H = $[U];
        e[H] = o[H];
      }
      return e.href = e.format(), e;
    }
    if (e.protocol = o.protocol, !o.host && !hostlessProtocol[o.protocol]) {
      for (var J = (o.pathname || "").split("/"); J.length && !(o.host = J.shift()); )
        ;
      o.host || (o.host = ""), o.hostname || (o.hostname = ""), J[0] !== "" && J.unshift(""), J.length < 2 && J.unshift(""), e.pathname = J.join("/");
    } else
      e.pathname = o.pathname;
    if (e.search = o.search, e.query = o.query, e.host = o.host || "", e.auth = o.auth, e.hostname = o.hostname || o.host, e.port = o.port, e.pathname || e.search) {
      var V = e.pathname || "", X = e.search || "";
      e.path = V + X;
    }
    return e.slashes = e.slashes || o.slashes, e.href = e.format(), e;
  }
  var W = e.pathname && e.pathname.charAt(0) === "/", Y = o.host || o.pathname && o.pathname.charAt(0) === "/", q = Y || W || e.host && o.pathname, K = q, Z = e.pathname && e.pathname.split("/") || [], J = o.pathname && o.pathname.split("/") || [], Q = e.protocol && !slashedProtocol[e.protocol];
  if (Q && (e.hostname = "", e.port = null, e.host && (Z[0] === "" ? Z[0] = e.host : Z.unshift(e.host)), e.host = "", o.protocol && (o.hostname = null, o.port = null, o.host && (J[0] === "" ? J[0] = o.host : J.unshift(o.host)), o.host = null), q = q && (J[0] === "" || Z[0] === "")), Y)
    e.host = o.host || o.host === "" ? o.host : e.host, e.hostname = o.hostname || o.hostname === "" ? o.hostname : e.hostname, e.search = o.search, e.query = o.query, Z = J;
  else if (J.length)
    Z || (Z = []), Z.pop(), Z = Z.concat(J), e.search = o.search, e.query = o.query;
  else if (!util$7.isNullOrUndefined(o.search)) {
    if (Q) {
      e.hostname = e.host = Z.shift();
      var rt = e.host && e.host.indexOf("@") > 0 ? e.host.split("@") : !1;
      rt && (e.auth = rt.shift(), e.host = e.hostname = rt.shift());
    }
    return e.search = o.search, e.query = o.query, (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : "") + (e.search ? e.search : "")), e.href = e.format(), e;
  }
  if (!Z.length)
    return e.pathname = null, e.search ? e.path = "/" + e.search : e.path = null, e.href = e.format(), e;
  for (var et = Z.slice(-1)[0], nt = (e.host || o.host || Z.length > 1) && (et === "." || et === "..") || et === "", st = 0, it = Z.length; it >= 0; it--)
    et = Z[it], et === "." ? Z.splice(it, 1) : et === ".." ? (Z.splice(it, 1), st++) : st && (Z.splice(it, 1), st--);
  if (!q && !K)
    for (; st--; st)
      Z.unshift("..");
  q && Z[0] !== "" && (!Z[0] || Z[0].charAt(0) !== "/") && Z.unshift(""), nt && Z.join("/").substr(-1) !== "/" && Z.push("");
  var ot = Z[0] === "" || Z[0] && Z[0].charAt(0) === "/";
  if (Q) {
    e.hostname = e.host = ot ? "" : Z.length ? Z.shift() : "";
    var rt = e.host && e.host.indexOf("@") > 0 ? e.host.split("@") : !1;
    rt && (e.auth = rt.shift(), e.host = e.hostname = rt.shift());
  }
  return q = q || e.host && Z.length, q && !ot && Z.unshift(""), Z.length ? e.pathname = Z.join("/") : (e.pathname = null, e.path = null), (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : "") + (e.search ? e.search : "")), e.auth = o.auth || e.auth, e.slashes = e.slashes || o.slashes, e.href = e.format(), e;
};
Url.prototype.parseHost = function() {
  var o = this.host, t = portPattern.exec(o);
  t && (t = t[0], t !== ":" && (this.port = t.substr(1)), o = o.substr(0, o.length - t.length)), o && (this.hostname = o);
};
/*!
 * @pixi/utils - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var url$1 = {
  parse: parse$2,
  format: format$1,
  resolve
};
settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var saidHello = !1, VERSION$1 = "6.5.8";
function skipHello() {
  saidHello = !0;
}
function sayHello(o) {
  var t;
  if (!saidHello) {
    if (settings.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      var e = [
        `
 %c %c %c PixiJS ` + VERSION$1 + " - ✰ " + o + ` ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ 

`,
        "background: #ff66a5; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff66a5; background: #030307; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "background: #ffc3dc; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;"
      ];
      (t = globalThis.console).log.apply(t, e);
    } else
      globalThis.console && globalThis.console.log("PixiJS " + VERSION$1 + " - " + o + " - http://www.pixijs.com/");
    saidHello = !0;
  }
}
var supported;
function isWebGLSupported() {
  return typeof supported > "u" && (supported = function() {
    var t = {
      stencil: !0,
      failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
    };
    try {
      if (!settings.ADAPTER.getWebGLRenderingContext())
        return !1;
      var e = settings.ADAPTER.createCanvas(), r = e.getContext("webgl", t) || e.getContext("experimental-webgl", t), S = !!(r && r.getContextAttributes().stencil);
      if (r) {
        var T = r.getExtension("WEBGL_lose_context");
        T && T.loseContext();
      }
      return r = null, S;
    } catch {
      return !1;
    }
  }()), supported;
}
var aliceblue = "#f0f8ff", antiquewhite = "#faebd7", aqua = "#00ffff", aquamarine = "#7fffd4", azure = "#f0ffff", beige = "#f5f5dc", bisque = "#ffe4c4", black = "#000000", blanchedalmond = "#ffebcd", blue = "#0000ff", blueviolet = "#8a2be2", brown = "#a52a2a", burlywood = "#deb887", cadetblue = "#5f9ea0", chartreuse = "#7fff00", chocolate = "#d2691e", coral = "#ff7f50", cornflowerblue = "#6495ed", cornsilk = "#fff8dc", crimson = "#dc143c", cyan = "#00ffff", darkblue = "#00008b", darkcyan = "#008b8b", darkgoldenrod = "#b8860b", darkgray = "#a9a9a9", darkgreen = "#006400", darkgrey = "#a9a9a9", darkkhaki = "#bdb76b", darkmagenta = "#8b008b", darkolivegreen = "#556b2f", darkorange = "#ff8c00", darkorchid = "#9932cc", darkred = "#8b0000", darksalmon = "#e9967a", darkseagreen = "#8fbc8f", darkslateblue = "#483d8b", darkslategray = "#2f4f4f", darkslategrey = "#2f4f4f", darkturquoise = "#00ced1", darkviolet = "#9400d3", deeppink = "#ff1493", deepskyblue = "#00bfff", dimgray = "#696969", dimgrey = "#696969", dodgerblue = "#1e90ff", firebrick = "#b22222", floralwhite = "#fffaf0", forestgreen = "#228b22", fuchsia = "#ff00ff", gainsboro = "#dcdcdc", ghostwhite = "#f8f8ff", goldenrod = "#daa520", gold = "#ffd700", gray = "#808080", green = "#008000", greenyellow = "#adff2f", grey = "#808080", honeydew = "#f0fff0", hotpink = "#ff69b4", indianred = "#cd5c5c", indigo = "#4b0082", ivory = "#fffff0", khaki = "#f0e68c", lavenderblush = "#fff0f5", lavender = "#e6e6fa", lawngreen = "#7cfc00", lemonchiffon = "#fffacd", lightblue = "#add8e6", lightcoral = "#f08080", lightcyan = "#e0ffff", lightgoldenrodyellow = "#fafad2", lightgray = "#d3d3d3", lightgreen = "#90ee90", lightgrey = "#d3d3d3", lightpink = "#ffb6c1", lightsalmon = "#ffa07a", lightseagreen = "#20b2aa", lightskyblue = "#87cefa", lightslategray = "#778899", lightslategrey = "#778899", lightsteelblue = "#b0c4de", lightyellow = "#ffffe0", lime = "#00ff00", limegreen = "#32cd32", linen = "#faf0e6", magenta = "#ff00ff", maroon = "#800000", mediumaquamarine = "#66cdaa", mediumblue = "#0000cd", mediumorchid = "#ba55d3", mediumpurple = "#9370db", mediumseagreen = "#3cb371", mediumslateblue = "#7b68ee", mediumspringgreen = "#00fa9a", mediumturquoise = "#48d1cc", mediumvioletred = "#c71585", midnightblue = "#191970", mintcream = "#f5fffa", mistyrose = "#ffe4e1", moccasin = "#ffe4b5", navajowhite = "#ffdead", navy = "#000080", oldlace = "#fdf5e6", olive = "#808000", olivedrab = "#6b8e23", orange = "#ffa500", orangered = "#ff4500", orchid = "#da70d6", palegoldenrod = "#eee8aa", palegreen = "#98fb98", paleturquoise = "#afeeee", palevioletred = "#db7093", papayawhip = "#ffefd5", peachpuff = "#ffdab9", peru = "#cd853f", pink = "#ffc0cb", plum = "#dda0dd", powderblue = "#b0e0e6", purple = "#800080", rebeccapurple = "#663399", red = "#ff0000", rosybrown = "#bc8f8f", royalblue = "#4169e1", saddlebrown = "#8b4513", salmon = "#fa8072", sandybrown = "#f4a460", seagreen = "#2e8b57", seashell = "#fff5ee", sienna = "#a0522d", silver = "#c0c0c0", skyblue = "#87ceeb", slateblue = "#6a5acd", slategray = "#708090", slategrey = "#708090", snow = "#fffafa", springgreen = "#00ff7f", steelblue = "#4682b4", tan = "#d2b48c", teal = "#008080", thistle = "#d8bfd8", tomato = "#ff6347", turquoise = "#40e0d0", violet = "#ee82ee", wheat = "#f5deb3", white = "#ffffff", whitesmoke = "#f5f5f5", yellow = "#ffff00", yellowgreen = "#9acd32", cssColorNames = {
  aliceblue,
  antiquewhite,
  aqua,
  aquamarine,
  azure,
  beige,
  bisque,
  black,
  blanchedalmond,
  blue,
  blueviolet,
  brown,
  burlywood,
  cadetblue,
  chartreuse,
  chocolate,
  coral,
  cornflowerblue,
  cornsilk,
  crimson,
  cyan,
  darkblue,
  darkcyan,
  darkgoldenrod,
  darkgray,
  darkgreen,
  darkgrey,
  darkkhaki,
  darkmagenta,
  darkolivegreen,
  darkorange,
  darkorchid,
  darkred,
  darksalmon,
  darkseagreen,
  darkslateblue,
  darkslategray,
  darkslategrey,
  darkturquoise,
  darkviolet,
  deeppink,
  deepskyblue,
  dimgray,
  dimgrey,
  dodgerblue,
  firebrick,
  floralwhite,
  forestgreen,
  fuchsia,
  gainsboro,
  ghostwhite,
  goldenrod,
  gold,
  gray,
  green,
  greenyellow,
  grey,
  honeydew,
  hotpink,
  indianred,
  indigo,
  ivory,
  khaki,
  lavenderblush,
  lavender,
  lawngreen,
  lemonchiffon,
  lightblue,
  lightcoral,
  lightcyan,
  lightgoldenrodyellow,
  lightgray,
  lightgreen,
  lightgrey,
  lightpink,
  lightsalmon,
  lightseagreen,
  lightskyblue,
  lightslategray,
  lightslategrey,
  lightsteelblue,
  lightyellow,
  lime,
  limegreen,
  linen,
  magenta,
  maroon,
  mediumaquamarine,
  mediumblue,
  mediumorchid,
  mediumpurple,
  mediumseagreen,
  mediumslateblue,
  mediumspringgreen,
  mediumturquoise,
  mediumvioletred,
  midnightblue,
  mintcream,
  mistyrose,
  moccasin,
  navajowhite,
  navy,
  oldlace,
  olive,
  olivedrab,
  orange,
  orangered,
  orchid,
  palegoldenrod,
  palegreen,
  paleturquoise,
  palevioletred,
  papayawhip,
  peachpuff,
  peru,
  pink,
  plum,
  powderblue,
  purple,
  rebeccapurple,
  red,
  rosybrown,
  royalblue,
  saddlebrown,
  salmon,
  sandybrown,
  seagreen,
  seashell,
  sienna,
  silver,
  skyblue,
  slateblue,
  slategray,
  slategrey,
  snow,
  springgreen,
  steelblue,
  tan,
  teal,
  thistle,
  tomato,
  turquoise,
  violet,
  wheat,
  white,
  whitesmoke,
  yellow,
  yellowgreen
};
function hex2rgb(o, t) {
  return t === void 0 && (t = []), t[0] = (o >> 16 & 255) / 255, t[1] = (o >> 8 & 255) / 255, t[2] = (o & 255) / 255, t;
}
function hex2string(o) {
  var t = o.toString(16);
  return t = "000000".substring(0, 6 - t.length) + t, "#" + t;
}
function string2hex(o) {
  return typeof o == "string" && (o = cssColorNames[o.toLowerCase()] || o, o[0] === "#" && (o = o.slice(1))), parseInt(o, 16);
}
function mapPremultipliedBlendModes() {
  for (var o = [], t = [], e = 0; e < 32; e++)
    o[e] = e, t[e] = e;
  o[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL, o[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD, o[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN, t[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM, t[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM, t[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
  var r = [];
  return r.push(t), r.push(o), r;
}
var premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(o, t) {
  return premultiplyBlendMode[t ? 1 : 0][o];
}
function premultiplyRgba(o, t, e, r) {
  return e = e || new Float32Array(4), r || r === void 0 ? (e[0] = o[0] * t, e[1] = o[1] * t, e[2] = o[2] * t) : (e[0] = o[0], e[1] = o[1], e[2] = o[2]), e[3] = t, e;
}
function premultiplyTint(o, t) {
  if (t === 1)
    return (t * 255 << 24) + o;
  if (t === 0)
    return 0;
  var e = o >> 16 & 255, r = o >> 8 & 255, S = o & 255;
  return e = e * t + 0.5 | 0, r = r * t + 0.5 | 0, S = S * t + 0.5 | 0, (t * 255 << 24) + (e << 16) + (r << 8) + S;
}
function premultiplyTintToRgba(o, t, e, r) {
  return e = e || new Float32Array(4), e[0] = (o >> 16 & 255) / 255, e[1] = (o >> 8 & 255) / 255, e[2] = (o & 255) / 255, (r || r === void 0) && (e[0] *= t, e[1] *= t, e[2] *= t), e[3] = t, e;
}
function createIndicesForQuads(o, t) {
  t === void 0 && (t = null);
  var e = o * 6;
  if (t = t || new Uint16Array(e), t.length !== e)
    throw new Error("Out buffer length is incorrect, got " + t.length + " and expected " + e);
  for (var r = 0, S = 0; r < e; r += 6, S += 4)
    t[r + 0] = S + 0, t[r + 1] = S + 1, t[r + 2] = S + 2, t[r + 3] = S + 0, t[r + 4] = S + 2, t[r + 5] = S + 3;
  return t;
}
function getBufferType(o) {
  if (o.BYTES_PER_ELEMENT === 4)
    return o instanceof Float32Array ? "Float32Array" : o instanceof Uint32Array ? "Uint32Array" : "Int32Array";
  if (o.BYTES_PER_ELEMENT === 2) {
    if (o instanceof Uint16Array)
      return "Uint16Array";
  } else if (o.BYTES_PER_ELEMENT === 1 && o instanceof Uint8Array)
    return "Uint8Array";
  return null;
}
function nextPow2(o) {
  return o += o === 0 ? 1 : 0, --o, o |= o >>> 1, o |= o >>> 2, o |= o >>> 4, o |= o >>> 8, o |= o >>> 16, o + 1;
}
function isPow2(o) {
  return !(o & o - 1) && !!o;
}
function log2(o) {
  var t = (o > 65535 ? 1 : 0) << 4;
  o >>>= t;
  var e = (o > 255 ? 1 : 0) << 3;
  return o >>>= e, t |= e, e = (o > 15 ? 1 : 0) << 2, o >>>= e, t |= e, e = (o > 3 ? 1 : 0) << 1, o >>>= e, t |= e, t | o >> 1;
}
function removeItems(o, t, e) {
  var r = o.length, S;
  if (!(t >= r || e === 0)) {
    e = t + e > r ? r - t : e;
    var T = r - e;
    for (S = t; S < T; ++S)
      o[S] = o[S + e];
    o.length = T;
  }
}
function sign(o) {
  return o === 0 ? 0 : o < 0 ? -1 : 1;
}
var nextUid = 0;
function uid() {
  return ++nextUid;
}
var warnings = {};
function deprecation(o, t, e) {
  if (e === void 0 && (e = 3), !warnings[t]) {
    var r = new Error().stack;
    typeof r > "u" ? console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + o) : (r = r.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", t + `
Deprecated since v` + o), console.warn(r), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + o), console.warn(r))), warnings[t] = !0;
  }
}
var ProgramCache = {}, TextureCache = /* @__PURE__ */ Object.create(null), BaseTextureCache = /* @__PURE__ */ Object.create(null);
function clearTextureCache() {
  var o;
  for (o in TextureCache)
    delete TextureCache[o];
  for (o in BaseTextureCache)
    delete BaseTextureCache[o];
}
var CanvasRenderTarget = function() {
  function o(t, e, r) {
    this.canvas = settings.ADAPTER.createCanvas(), this.context = this.canvas.getContext("2d"), this.resolution = r || settings.RESOLUTION, this.resize(t, e);
  }
  return o.prototype.clear = function() {
    this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }, o.prototype.resize = function(t, e) {
    this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);
  }, o.prototype.destroy = function() {
    this.context = null, this.canvas = null;
  }, Object.defineProperty(o.prototype, "width", {
    /**
     * The width of the canvas buffer in pixels.
     * @member {number}
     */
    get: function() {
      return this.canvas.width;
    },
    set: function(t) {
      this.canvas.width = Math.round(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "height", {
    /**
     * The height of the canvas buffer in pixels.
     * @member {number}
     */
    get: function() {
      return this.canvas.height;
    },
    set: function(t) {
      this.canvas.height = Math.round(t);
    },
    enumerable: !1,
    configurable: !0
  }), o;
}();
function trimCanvas(o) {
  var t = o.width, e = o.height, r = o.getContext("2d", {
    willReadFrequently: !0
  }), S = r.getImageData(0, 0, t, e), T = S.data, D = T.length, N = {
    top: null,
    left: null,
    right: null,
    bottom: null
  }, B = null, $, U, H;
  for ($ = 0; $ < D; $ += 4)
    T[$ + 3] !== 0 && (U = $ / 4 % t, H = ~~($ / 4 / t), N.top === null && (N.top = H), (N.left === null || U < N.left) && (N.left = U), (N.right === null || N.right < U) && (N.right = U + 1), (N.bottom === null || N.bottom < H) && (N.bottom = H));
  return N.top !== null && (t = N.right - N.left, e = N.bottom - N.top + 1, B = r.getImageData(N.left, N.top, t, e)), {
    height: e,
    width: t,
    data: B
  };
}
var tempAnchor$1;
function determineCrossOrigin(o, t) {
  if (t === void 0 && (t = globalThis.location), o.indexOf("data:") === 0)
    return "";
  t = t || globalThis.location, tempAnchor$1 || (tempAnchor$1 = document.createElement("a")), tempAnchor$1.href = o;
  var e = url$1.parse(tempAnchor$1.href), r = !e.port && t.port === "" || e.port === t.port;
  return e.hostname !== t.hostname || !r || e.protocol !== t.protocol ? "anonymous" : "";
}
function getResolutionOfUrl(o, t) {
  var e = settings.RETINA_PREFIX.exec(o);
  return e ? parseFloat(e[1]) : t !== void 0 ? t : 1;
}
/*!
 * @pixi/math - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var PI_2 = Math.PI * 2, RAD_TO_DEG = 180 / Math.PI, DEG_TO_RAD = Math.PI / 180, SHAPES;
(function(o) {
  o[o.POLY = 0] = "POLY", o[o.RECT = 1] = "RECT", o[o.CIRC = 2] = "CIRC", o[o.ELIP = 3] = "ELIP", o[o.RREC = 4] = "RREC";
})(SHAPES || (SHAPES = {}));
var Point = function() {
  function o(t, e) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e;
  }
  return o.prototype.clone = function() {
    return new o(this.x, this.y);
  }, o.prototype.copyFrom = function(t) {
    return this.set(t.x, t.y), this;
  }, o.prototype.copyTo = function(t) {
    return t.set(this.x, this.y), t;
  }, o.prototype.equals = function(t) {
    return t.x === this.x && t.y === this.y;
  }, o.prototype.set = function(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = t), this.x = t, this.y = e, this;
  }, o.prototype.toString = function() {
    return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
  }, o;
}(), tempPoints$1 = [new Point(), new Point(), new Point(), new Point()], Rectangle = function() {
  function o(t, e, r, S) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), S === void 0 && (S = 0), this.x = Number(t), this.y = Number(e), this.width = Number(r), this.height = Number(S), this.type = SHAPES.RECT;
  }
  return Object.defineProperty(o.prototype, "left", {
    /** Returns the left edge of the rectangle. */
    get: function() {
      return this.x;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "right", {
    /** Returns the right edge of the rectangle. */
    get: function() {
      return this.x + this.width;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "top", {
    /** Returns the top edge of the rectangle. */
    get: function() {
      return this.y;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "bottom", {
    /** Returns the bottom edge of the rectangle. */
    get: function() {
      return this.y + this.height;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "EMPTY", {
    /** A constant empty rectangle. */
    get: function() {
      return new o(0, 0, 0, 0);
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.clone = function() {
    return new o(this.x, this.y, this.width, this.height);
  }, o.prototype.copyFrom = function(t) {
    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
  }, o.prototype.copyTo = function(t) {
    return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
  }, o.prototype.contains = function(t, e) {
    return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
  }, o.prototype.intersects = function(t, e) {
    if (!e) {
      var r = this.x < t.x ? t.x : this.x, S = this.right > t.right ? t.right : this.right;
      if (S <= r)
        return !1;
      var T = this.y < t.y ? t.y : this.y, D = this.bottom > t.bottom ? t.bottom : this.bottom;
      return D > T;
    }
    var N = this.left, B = this.right, $ = this.top, U = this.bottom;
    if (B <= N || U <= $)
      return !1;
    var H = tempPoints$1[0].set(t.left, t.top), V = tempPoints$1[1].set(t.left, t.bottom), X = tempPoints$1[2].set(t.right, t.top), W = tempPoints$1[3].set(t.right, t.bottom);
    if (X.x <= H.x || V.y <= H.y)
      return !1;
    var Y = Math.sign(e.a * e.d - e.b * e.c);
    if (Y === 0 || (e.apply(H, H), e.apply(V, V), e.apply(X, X), e.apply(W, W), Math.max(H.x, V.x, X.x, W.x) <= N || Math.min(H.x, V.x, X.x, W.x) >= B || Math.max(H.y, V.y, X.y, W.y) <= $ || Math.min(H.y, V.y, X.y, W.y) >= U))
      return !1;
    var q = Y * (V.y - H.y), K = Y * (H.x - V.x), Z = q * N + K * $, J = q * B + K * $, Q = q * N + K * U, rt = q * B + K * U;
    if (Math.max(Z, J, Q, rt) <= q * H.x + K * H.y || Math.min(Z, J, Q, rt) >= q * W.x + K * W.y)
      return !1;
    var et = Y * (H.y - X.y), nt = Y * (X.x - H.x), st = et * N + nt * $, it = et * B + nt * $, ot = et * N + nt * U, ht = et * B + nt * U;
    return !(Math.max(st, it, ot, ht) <= et * H.x + nt * H.y || Math.min(st, it, ot, ht) >= et * W.x + nt * W.y);
  }, o.prototype.pad = function(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = t), this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
  }, o.prototype.fit = function(t) {
    var e = Math.max(this.x, t.x), r = Math.min(this.x + this.width, t.x + t.width), S = Math.max(this.y, t.y), T = Math.min(this.y + this.height, t.y + t.height);
    return this.x = e, this.width = Math.max(r - e, 0), this.y = S, this.height = Math.max(T - S, 0), this;
  }, o.prototype.ceil = function(t, e) {
    t === void 0 && (t = 1), e === void 0 && (e = 1e-3);
    var r = Math.ceil((this.x + this.width - e) * t) / t, S = Math.ceil((this.y + this.height - e) * t) / t;
    return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = r - this.x, this.height = S - this.y, this;
  }, o.prototype.enlarge = function(t) {
    var e = Math.min(this.x, t.x), r = Math.max(this.x + this.width, t.x + t.width), S = Math.min(this.y, t.y), T = Math.max(this.y + this.height, t.y + t.height);
    return this.x = e, this.width = r - e, this.y = S, this.height = T - S, this;
  }, o.prototype.toString = function() {
    return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
  }, o;
}(), Circle = function() {
  function o(t, e, r) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), this.x = t, this.y = e, this.radius = r, this.type = SHAPES.CIRC;
  }
  return o.prototype.clone = function() {
    return new o(this.x, this.y, this.radius);
  }, o.prototype.contains = function(t, e) {
    if (this.radius <= 0)
      return !1;
    var r = this.radius * this.radius, S = this.x - t, T = this.y - e;
    return S *= S, T *= T, S + T <= r;
  }, o.prototype.getBounds = function() {
    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }, o.prototype.toString = function() {
    return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
  }, o;
}(), Ellipse = function() {
  function o(t, e, r, S) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), S === void 0 && (S = 0), this.x = t, this.y = e, this.width = r, this.height = S, this.type = SHAPES.ELIP;
  }
  return o.prototype.clone = function() {
    return new o(this.x, this.y, this.width, this.height);
  }, o.prototype.contains = function(t, e) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    var r = (t - this.x) / this.width, S = (e - this.y) / this.height;
    return r *= r, S *= S, r + S <= 1;
  }, o.prototype.getBounds = function() {
    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
  }, o.prototype.toString = function() {
    return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
  }, o;
}(), Polygon = function() {
  function o() {
    for (var t = arguments, e = [], r = 0; r < arguments.length; r++)
      e[r] = t[r];
    var S = Array.isArray(e[0]) ? e[0] : e;
    if (typeof S[0] != "number") {
      for (var T = [], D = 0, N = S.length; D < N; D++)
        T.push(S[D].x, S[D].y);
      S = T;
    }
    this.points = S, this.type = SHAPES.POLY, this.closeStroke = !0;
  }
  return o.prototype.clone = function() {
    var t = this.points.slice(), e = new o(t);
    return e.closeStroke = this.closeStroke, e;
  }, o.prototype.contains = function(t, e) {
    for (var r = !1, S = this.points.length / 2, T = 0, D = S - 1; T < S; D = T++) {
      var N = this.points[T * 2], B = this.points[T * 2 + 1], $ = this.points[D * 2], U = this.points[D * 2 + 1], H = B > e != U > e && t < ($ - N) * ((e - B) / (U - B)) + N;
      H && (r = !r);
    }
    return r;
  }, o.prototype.toString = function() {
    return "[@pixi/math:Polygon" + ("closeStroke=" + this.closeStroke) + ("points=" + this.points.reduce(function(t, e) {
      return t + ", " + e;
    }, "") + "]");
  }, o;
}(), RoundedRectangle = function() {
  function o(t, e, r, S, T) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), S === void 0 && (S = 0), T === void 0 && (T = 20), this.x = t, this.y = e, this.width = r, this.height = S, this.radius = T, this.type = SHAPES.RREC;
  }
  return o.prototype.clone = function() {
    return new o(this.x, this.y, this.width, this.height, this.radius);
  }, o.prototype.contains = function(t, e) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
      var r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
      if (e >= this.y + r && e <= this.y + this.height - r || t >= this.x + r && t <= this.x + this.width - r)
        return !0;
      var S = t - (this.x + r), T = e - (this.y + r), D = r * r;
      if (S * S + T * T <= D || (S = t - (this.x + this.width - r), S * S + T * T <= D) || (T = e - (this.y + this.height - r), S * S + T * T <= D) || (S = t - (this.x + r), S * S + T * T <= D))
        return !0;
    }
    return !1;
  }, o.prototype.toString = function() {
    return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + ("width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]");
  }, o;
}(), ObservablePoint = function() {
  function o(t, e, r, S) {
    r === void 0 && (r = 0), S === void 0 && (S = 0), this._x = r, this._y = S, this.cb = t, this.scope = e;
  }
  return o.prototype.clone = function(t, e) {
    return t === void 0 && (t = this.cb), e === void 0 && (e = this.scope), new o(t, e, this._x, this._y);
  }, o.prototype.set = function(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = t), (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this.cb.call(this.scope)), this;
  }, o.prototype.copyFrom = function(t) {
    return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this;
  }, o.prototype.copyTo = function(t) {
    return t.set(this._x, this._y), t;
  }, o.prototype.equals = function(t) {
    return t.x === this._x && t.y === this._y;
  }, o.prototype.toString = function() {
    return "[@pixi/math:ObservablePoint x=" + 0 + " y=" + 0 + " scope=" + this.scope + "]";
  }, Object.defineProperty(o.prototype, "x", {
    /** Position of the observable point on the x axis. */
    get: function() {
      return this._x;
    },
    set: function(t) {
      this._x !== t && (this._x = t, this.cb.call(this.scope));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "y", {
    /** Position of the observable point on the y axis. */
    get: function() {
      return this._y;
    },
    set: function(t) {
      this._y !== t && (this._y = t, this.cb.call(this.scope));
    },
    enumerable: !1,
    configurable: !0
  }), o;
}(), Matrix = function() {
  function o(t, e, r, S, T, D) {
    t === void 0 && (t = 1), e === void 0 && (e = 0), r === void 0 && (r = 0), S === void 0 && (S = 1), T === void 0 && (T = 0), D === void 0 && (D = 0), this.array = null, this.a = t, this.b = e, this.c = r, this.d = S, this.tx = T, this.ty = D;
  }
  return o.prototype.fromArray = function(t) {
    this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
  }, o.prototype.set = function(t, e, r, S, T, D) {
    return this.a = t, this.b = e, this.c = r, this.d = S, this.tx = T, this.ty = D, this;
  }, o.prototype.toArray = function(t, e) {
    this.array || (this.array = new Float32Array(9));
    var r = e || this.array;
    return t ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r;
  }, o.prototype.apply = function(t, e) {
    e = e || new Point();
    var r = t.x, S = t.y;
    return e.x = this.a * r + this.c * S + this.tx, e.y = this.b * r + this.d * S + this.ty, e;
  }, o.prototype.applyInverse = function(t, e) {
    e = e || new Point();
    var r = 1 / (this.a * this.d + this.c * -this.b), S = t.x, T = t.y;
    return e.x = this.d * r * S + -this.c * r * T + (this.ty * this.c - this.tx * this.d) * r, e.y = this.a * r * T + -this.b * r * S + (-this.ty * this.a + this.tx * this.b) * r, e;
  }, o.prototype.translate = function(t, e) {
    return this.tx += t, this.ty += e, this;
  }, o.prototype.scale = function(t, e) {
    return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
  }, o.prototype.rotate = function(t) {
    var e = Math.cos(t), r = Math.sin(t), S = this.a, T = this.c, D = this.tx;
    return this.a = S * e - this.b * r, this.b = S * r + this.b * e, this.c = T * e - this.d * r, this.d = T * r + this.d * e, this.tx = D * e - this.ty * r, this.ty = D * r + this.ty * e, this;
  }, o.prototype.append = function(t) {
    var e = this.a, r = this.b, S = this.c, T = this.d;
    return this.a = t.a * e + t.b * S, this.b = t.a * r + t.b * T, this.c = t.c * e + t.d * S, this.d = t.c * r + t.d * T, this.tx = t.tx * e + t.ty * S + this.tx, this.ty = t.tx * r + t.ty * T + this.ty, this;
  }, o.prototype.setTransform = function(t, e, r, S, T, D, N, B, $) {
    return this.a = Math.cos(N + $) * T, this.b = Math.sin(N + $) * T, this.c = -Math.sin(N - B) * D, this.d = Math.cos(N - B) * D, this.tx = t - (r * this.a + S * this.c), this.ty = e - (r * this.b + S * this.d), this;
  }, o.prototype.prepend = function(t) {
    var e = this.tx;
    if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
      var r = this.a, S = this.c;
      this.a = r * t.a + this.b * t.c, this.b = r * t.b + this.b * t.d, this.c = S * t.a + this.d * t.c, this.d = S * t.b + this.d * t.d;
    }
    return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
  }, o.prototype.decompose = function(t) {
    var e = this.a, r = this.b, S = this.c, T = this.d, D = t.pivot, N = -Math.atan2(-S, T), B = Math.atan2(r, e), $ = Math.abs(N + B);
    return $ < 1e-5 || Math.abs(PI_2 - $) < 1e-5 ? (t.rotation = B, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = N, t.skew.y = B), t.scale.x = Math.sqrt(e * e + r * r), t.scale.y = Math.sqrt(S * S + T * T), t.position.x = this.tx + (D.x * e + D.y * S), t.position.y = this.ty + (D.x * r + D.y * T), t;
  }, o.prototype.invert = function() {
    var t = this.a, e = this.b, r = this.c, S = this.d, T = this.tx, D = t * S - e * r;
    return this.a = S / D, this.b = -e / D, this.c = -r / D, this.d = t / D, this.tx = (r * this.ty - S * T) / D, this.ty = -(t * this.ty - e * T) / D, this;
  }, o.prototype.identity = function() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  }, o.prototype.clone = function() {
    var t = new o();
    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
  }, o.prototype.copyTo = function(t) {
    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
  }, o.prototype.copyFrom = function(t) {
    return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
  }, o.prototype.toString = function() {
    return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
  }, Object.defineProperty(o, "IDENTITY", {
    /**
     * A default (identity) matrix
     * @readonly
     */
    get: function() {
      return new o();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "TEMP_MATRIX", {
    /**
     * A temp matrix
     * @readonly
     */
    get: function() {
      return new o();
    },
    enumerable: !1,
    configurable: !0
  }), o;
}(), ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], rotationCayley = [], rotationMatrices = [], signum = Math.sign;
function init() {
  for (var o = 0; o < 16; o++) {
    var t = [];
    rotationCayley.push(t);
    for (var e = 0; e < 16; e++)
      for (var r = signum(ux[o] * ux[e] + vx[o] * uy[e]), S = signum(uy[o] * ux[e] + vy[o] * uy[e]), T = signum(ux[o] * vx[e] + vx[o] * vy[e]), D = signum(uy[o] * vx[e] + vy[o] * vy[e]), N = 0; N < 16; N++)
        if (ux[N] === r && uy[N] === S && vx[N] === T && vy[N] === D) {
          t.push(N);
          break;
        }
  }
  for (var o = 0; o < 16; o++) {
    var B = new Matrix();
    B.set(ux[o], uy[o], vx[o], vy[o], 0, 0), rotationMatrices.push(B);
  }
}
init();
var groupD8 = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: function(o) {
    return ux[o];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: function(o) {
    return uy[o];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: function(o) {
    return vx[o];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: function(o) {
    return vy[o];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: function(o) {
    return o & 8 ? o & 15 : -o & 7;
  },
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {PIXI.GD8Symmetry} Composed operation
   */
  add: function(o, t) {
    return rotationCayley[o][t];
  },
  /**
   * Reverse of `add`.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @returns {PIXI.GD8Symmetry} Result
   */
  sub: function(o, t) {
    return rotationCayley[o][groupD8.inv(t)];
  },
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @memberof PIXI.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: function(o) {
    return o ^ 4;
  },
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: function(o) {
    return (o & 3) === 2;
  },
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @memberof PIXI.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: function(o, t) {
    return Math.abs(o) * 2 <= Math.abs(t) ? t >= 0 ? groupD8.S : groupD8.N : Math.abs(t) * 2 <= Math.abs(o) ? o > 0 ? groupD8.E : groupD8.W : t > 0 ? o > 0 ? groupD8.SE : groupD8.SW : o > 0 ? groupD8.NE : groupD8.NW;
  },
  /**
   * Helps sprite to compensate texture packer rotation.
   * @memberof PIXI.groupD8
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: function(o, t, e, r) {
    e === void 0 && (e = 0), r === void 0 && (r = 0);
    var S = rotationMatrices[groupD8.inv(t)];
    S.tx = e, S.ty = r, o.append(S);
  }
}, Transform = function() {
  function o() {
    this.worldTransform = new Matrix(), this.localTransform = new Matrix(), this.position = new ObservablePoint(this.onChange, this, 0, 0), this.scale = new ObservablePoint(this.onChange, this, 1, 1), this.pivot = new ObservablePoint(this.onChange, this, 0, 0), this.skew = new ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
  }
  return o.prototype.onChange = function() {
    this._localID++;
  }, o.prototype.updateSkew = function() {
    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
  }, o.prototype.toString = function() {
    return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
  }, o.prototype.updateLocalTransform = function() {
    var t = this.localTransform;
    this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1);
  }, o.prototype.updateTransform = function(t) {
    var e = this.localTransform;
    if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {
      var r = t.worldTransform, S = this.worldTransform;
      S.a = e.a * r.a + e.b * r.c, S.b = e.a * r.b + e.b * r.d, S.c = e.c * r.a + e.d * r.c, S.d = e.c * r.b + e.d * r.d, S.tx = e.tx * r.a + e.ty * r.c + r.tx, S.ty = e.tx * r.b + e.ty * r.d + r.ty, this._parentID = t._worldID, this._worldID++;
    }
  }, o.prototype.setFromMatrix = function(t) {
    t.decompose(this), this._localID++;
  }, Object.defineProperty(o.prototype, "rotation", {
    /** The rotation of the object in radians. */
    get: function() {
      return this._rotation;
    },
    set: function(t) {
      this._rotation !== t && (this._rotation = t, this.updateSkew());
    },
    enumerable: !1,
    configurable: !0
  }), o.IDENTITY = new o(), o;
}();
/*!
 * @pixi/display - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.SORTABLE_CHILDREN = !1;
var Bounds = function() {
  function o() {
    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
  }
  return o.prototype.isEmpty = function() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }, o.prototype.clear = function() {
    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
  }, o.prototype.getRectangle = function(t) {
    return this.minX > this.maxX || this.minY > this.maxY ? Rectangle.EMPTY : (t = t || new Rectangle(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t);
  }, o.prototype.addPoint = function(t) {
    this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y);
  }, o.prototype.addPointMatrix = function(t, e) {
    var r = t.a, S = t.b, T = t.c, D = t.d, N = t.tx, B = t.ty, $ = r * e.x + T * e.y + N, U = S * e.x + D * e.y + B;
    this.minX = Math.min(this.minX, $), this.maxX = Math.max(this.maxX, $), this.minY = Math.min(this.minY, U), this.maxY = Math.max(this.maxY, U);
  }, o.prototype.addQuad = function(t) {
    var e = this.minX, r = this.minY, S = this.maxX, T = this.maxY, D = t[0], N = t[1];
    e = D < e ? D : e, r = N < r ? N : r, S = D > S ? D : S, T = N > T ? N : T, D = t[2], N = t[3], e = D < e ? D : e, r = N < r ? N : r, S = D > S ? D : S, T = N > T ? N : T, D = t[4], N = t[5], e = D < e ? D : e, r = N < r ? N : r, S = D > S ? D : S, T = N > T ? N : T, D = t[6], N = t[7], e = D < e ? D : e, r = N < r ? N : r, S = D > S ? D : S, T = N > T ? N : T, this.minX = e, this.minY = r, this.maxX = S, this.maxY = T;
  }, o.prototype.addFrame = function(t, e, r, S, T) {
    this.addFrameMatrix(t.worldTransform, e, r, S, T);
  }, o.prototype.addFrameMatrix = function(t, e, r, S, T) {
    var D = t.a, N = t.b, B = t.c, $ = t.d, U = t.tx, H = t.ty, V = this.minX, X = this.minY, W = this.maxX, Y = this.maxY, q = D * e + B * r + U, K = N * e + $ * r + H;
    V = q < V ? q : V, X = K < X ? K : X, W = q > W ? q : W, Y = K > Y ? K : Y, q = D * S + B * r + U, K = N * S + $ * r + H, V = q < V ? q : V, X = K < X ? K : X, W = q > W ? q : W, Y = K > Y ? K : Y, q = D * e + B * T + U, K = N * e + $ * T + H, V = q < V ? q : V, X = K < X ? K : X, W = q > W ? q : W, Y = K > Y ? K : Y, q = D * S + B * T + U, K = N * S + $ * T + H, V = q < V ? q : V, X = K < X ? K : X, W = q > W ? q : W, Y = K > Y ? K : Y, this.minX = V, this.minY = X, this.maxX = W, this.maxY = Y;
  }, o.prototype.addVertexData = function(t, e, r) {
    for (var S = this.minX, T = this.minY, D = this.maxX, N = this.maxY, B = e; B < r; B += 2) {
      var $ = t[B], U = t[B + 1];
      S = $ < S ? $ : S, T = U < T ? U : T, D = $ > D ? $ : D, N = U > N ? U : N;
    }
    this.minX = S, this.minY = T, this.maxX = D, this.maxY = N;
  }, o.prototype.addVertices = function(t, e, r, S) {
    this.addVerticesMatrix(t.worldTransform, e, r, S);
  }, o.prototype.addVerticesMatrix = function(t, e, r, S, T, D) {
    T === void 0 && (T = 0), D === void 0 && (D = T);
    for (var N = t.a, B = t.b, $ = t.c, U = t.d, H = t.tx, V = t.ty, X = this.minX, W = this.minY, Y = this.maxX, q = this.maxY, K = r; K < S; K += 2) {
      var Z = e[K], J = e[K + 1], Q = N * Z + $ * J + H, rt = U * J + B * Z + V;
      X = Math.min(X, Q - T), Y = Math.max(Y, Q + T), W = Math.min(W, rt - D), q = Math.max(q, rt + D);
    }
    this.minX = X, this.minY = W, this.maxX = Y, this.maxY = q;
  }, o.prototype.addBounds = function(t) {
    var e = this.minX, r = this.minY, S = this.maxX, T = this.maxY;
    this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < r ? t.minY : r, this.maxX = t.maxX > S ? t.maxX : S, this.maxY = t.maxY > T ? t.maxY : T;
  }, o.prototype.addBoundsMask = function(t, e) {
    var r = t.minX > e.minX ? t.minX : e.minX, S = t.minY > e.minY ? t.minY : e.minY, T = t.maxX < e.maxX ? t.maxX : e.maxX, D = t.maxY < e.maxY ? t.maxY : e.maxY;
    if (r <= T && S <= D) {
      var N = this.minX, B = this.minY, $ = this.maxX, U = this.maxY;
      this.minX = r < N ? r : N, this.minY = S < B ? S : B, this.maxX = T > $ ? T : $, this.maxY = D > U ? D : U;
    }
  }, o.prototype.addBoundsMatrix = function(t, e) {
    this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);
  }, o.prototype.addBoundsArea = function(t, e) {
    var r = t.minX > e.x ? t.minX : e.x, S = t.minY > e.y ? t.minY : e.y, T = t.maxX < e.x + e.width ? t.maxX : e.x + e.width, D = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
    if (r <= T && S <= D) {
      var N = this.minX, B = this.minY, $ = this.maxX, U = this.maxY;
      this.minX = r < N ? r : N, this.minY = S < B ? S : B, this.maxX = T > $ ? T : $, this.maxY = D > U ? D : U;
    }
  }, o.prototype.pad = function(t, e) {
    t === void 0 && (t = 0), e === void 0 && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e);
  }, o.prototype.addFramePad = function(t, e, r, S, T, D) {
    t -= T, e -= D, r += T, S += D, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > r ? this.maxX : r, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > S ? this.maxY : S;
  }, o;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$q = function(o, t) {
  return extendStatics$q = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$q(o, t);
};
function __extends$q(o, t) {
  extendStatics$q(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var DisplayObject = function(o) {
  __extends$q(t, o);
  function t() {
    var e = o.call(this) || this;
    return e.tempDisplayObjectParent = null, e.transform = new Transform(), e.alpha = 1, e.visible = !0, e.renderable = !0, e.cullable = !1, e.cullArea = null, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new Bounds(), e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._maskRefCount = 0, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e;
  }
  return t.mixin = function(e) {
    for (var r = Object.keys(e), S = 0; S < r.length; ++S) {
      var T = r[S];
      Object.defineProperty(t.prototype, T, Object.getOwnPropertyDescriptor(e, T));
    }
  }, Object.defineProperty(t.prototype, "destroyed", {
    /**
     * Fired when this DisplayObject is added to a Container.
     * @instance
     * @event added
     * @param {PIXI.Container} container - The container added to.
     */
    /**
     * Fired when this DisplayObject is removed from a Container.
     * @instance
     * @event removed
     * @param {PIXI.Container} container - The container removed from.
     */
    /**
     * Fired when this DisplayObject is destroyed. This event is emitted once
     * destroy is finished.
     * @instance
     * @event destroyed
     */
    /** Readonly flag for destroyed display objects. */
    get: function() {
      return this._destroyed;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._recursivePostUpdateTransform = function() {
    this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
  }, t.prototype.updateTransform = function() {
    this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
  }, t.prototype.getBounds = function(e, r) {
    return e || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), r || (this._boundsRect || (this._boundsRect = new Rectangle()), r = this._boundsRect), this._bounds.getRectangle(r);
  }, t.prototype.getLocalBounds = function(e) {
    e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds || (this._localBounds = new Bounds());
    var r = this.transform, S = this.parent;
    this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
    var T = this._bounds, D = this._boundsID;
    this._bounds = this._localBounds;
    var N = this.getBounds(!1, e);
    return this.parent = S, this.transform = r, this._bounds = T, this._bounds.updateID += this._boundsID - D, N;
  }, t.prototype.toGlobal = function(e, r, S) {
    return S === void 0 && (S = !1), S || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(e, r);
  }, t.prototype.toLocal = function(e, r, S, T) {
    return r && (e = r.toGlobal(e, S, T)), T || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(e, S);
  }, t.prototype.setParent = function(e) {
    if (!e || !e.addChild)
      throw new Error("setParent: Argument must be a Container");
    return e.addChild(this), e;
  }, t.prototype.setTransform = function(e, r, S, T, D, N, B, $, U) {
    return e === void 0 && (e = 0), r === void 0 && (r = 0), S === void 0 && (S = 1), T === void 0 && (T = 1), D === void 0 && (D = 0), N === void 0 && (N = 0), B === void 0 && (B = 0), $ === void 0 && ($ = 0), U === void 0 && (U = 0), this.position.x = e, this.position.y = r, this.scale.x = S || 1, this.scale.y = T || 1, this.rotation = D, this.skew.x = N, this.skew.y = B, this.pivot.x = $, this.pivot.y = U, this;
  }, t.prototype.destroy = function(e) {
    this.parent && this.parent.removeChild(this), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners();
  }, Object.defineProperty(t.prototype, "_tempDisplayObjectParent", {
    /**
     * @protected
     * @member {PIXI.Container}
     */
    get: function() {
      return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new TemporaryDisplayObject()), this.tempDisplayObjectParent;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.enableTempParent = function() {
    var e = this.parent;
    return this.parent = this._tempDisplayObjectParent, e;
  }, t.prototype.disableTempParent = function(e) {
    this.parent = e;
  }, Object.defineProperty(t.prototype, "x", {
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     * An alias to position.x
     */
    get: function() {
      return this.position.x;
    },
    set: function(e) {
      this.transform.position.x = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "y", {
    /**
     * The position of the displayObject on the y axis relative to the local coordinates of the parent.
     * An alias to position.y
     */
    get: function() {
      return this.position.y;
    },
    set: function(e) {
      this.transform.position.y = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "worldTransform", {
    /**
     * Current transform of the object based on world (parent) factors.
     * @readonly
     */
    get: function() {
      return this.transform.worldTransform;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "localTransform", {
    /**
     * Current transform of the object based on local factors: position, scale, other stuff.
     * @readonly
     */
    get: function() {
      return this.transform.localTransform;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "position", {
    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     * @since 4.0.0
     */
    get: function() {
      return this.transform.position;
    },
    set: function(e) {
      this.transform.position.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "scale", {
    /**
     * The scale factors of this object along the local coordinate axes.
     *
     * The default scale is (1, 1).
     * @since 4.0.0
     */
    get: function() {
      return this.transform.scale;
    },
    set: function(e) {
      this.transform.scale.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "pivot", {
    /**
     * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
     * is the projection of `pivot` in the parent's local space.
     *
     * By default, the pivot is the origin (0, 0).
     * @since 4.0.0
     */
    get: function() {
      return this.transform.pivot;
    },
    set: function(e) {
      this.transform.pivot.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "skew", {
    /**
     * The skew factor for the object in radians.
     * @since 4.0.0
     */
    get: function() {
      return this.transform.skew;
    },
    set: function(e) {
      this.transform.skew.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "rotation", {
    /**
     * The rotation of the object in radians.
     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
     */
    get: function() {
      return this.transform.rotation;
    },
    set: function(e) {
      this.transform.rotation = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "angle", {
    /**
     * The angle of the object in degrees.
     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
     */
    get: function() {
      return this.transform.rotation * RAD_TO_DEG;
    },
    set: function(e) {
      this.transform.rotation = e * DEG_TO_RAD;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "zIndex", {
    /**
     * The zIndex of the displayObject.
     *
     * If a container has the sortableChildren property set to true, children will be automatically
     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
     * and thus rendered on top of other display objects within the same container.
     * @see PIXI.Container#sortableChildren
     */
    get: function() {
      return this._zIndex;
    },
    set: function(e) {
      this._zIndex = e, this.parent && (this.parent.sortDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "worldVisible", {
    /**
     * Indicates if the object is globally visible.
     * @readonly
     */
    get: function() {
      var e = this;
      do {
        if (!e.visible)
          return !1;
        e = e.parent;
      } while (e);
      return !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "mask", {
    /**
     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
     * To remove a mask, set this property to `null`.
     *
     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
     * @example
     * const graphics = new PIXI.Graphics();
     * graphics.beginFill(0xFF3300);
     * graphics.drawRect(50, 250, 100, 100);
     * graphics.endFill();
     *
     * const sprite = new PIXI.Sprite(texture);
     * sprite.mask = graphics;
     * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
     */
    get: function() {
      return this._mask;
    },
    set: function(e) {
      if (this._mask !== e) {
        if (this._mask) {
          var r = this._mask.isMaskData ? this._mask.maskObject : this._mask;
          r && (r._maskRefCount--, r._maskRefCount === 0 && (r.renderable = !0, r.isMask = !1));
        }
        if (this._mask = e, this._mask) {
          var r = this._mask.isMaskData ? this._mask.maskObject : this._mask;
          r && (r._maskRefCount === 0 && (r.renderable = !1, r.isMask = !0), r._maskRefCount++);
        }
      }
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(eventemitter3Exports), TemporaryDisplayObject = function(o) {
  __extends$q(t, o);
  function t() {
    var e = o !== null && o.apply(this, arguments) || this;
    return e.sortDirty = null, e;
  }
  return t;
}(DisplayObject);
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
function sortChildren(o, t) {
  return o.zIndex === t.zIndex ? o._lastSortedIndex - t._lastSortedIndex : o.zIndex - t.zIndex;
}
var Container = function(o) {
  __extends$q(t, o);
  function t() {
    var e = o.call(this) || this;
    return e.children = [], e.sortableChildren = settings.SORTABLE_CHILDREN, e.sortDirty = !1, e;
  }
  return t.prototype.onChildrenChange = function(e) {
  }, t.prototype.addChild = function() {
    for (var e = arguments, r = [], S = 0; S < arguments.length; S++)
      r[S] = e[S];
    if (r.length > 1)
      for (var T = 0; T < r.length; T++)
        this.addChild(r[T]);
    else {
      var D = r[0];
      D.parent && D.parent.removeChild(D), D.parent = this, this.sortDirty = !0, D.transform._parentID = -1, this.children.push(D), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", D, this, this.children.length - 1), D.emit("added", this);
    }
    return r[0];
  }, t.prototype.addChildAt = function(e, r) {
    if (r < 0 || r > this.children.length)
      throw new Error(e + "addChildAt: The index " + r + " supplied is out of bounds " + this.children.length);
    return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(r, 0, e), this._boundsID++, this.onChildrenChange(r), e.emit("added", this), this.emit("childAdded", e, this, r), e;
  }, t.prototype.swapChildren = function(e, r) {
    if (e !== r) {
      var S = this.getChildIndex(e), T = this.getChildIndex(r);
      this.children[S] = r, this.children[T] = e, this.onChildrenChange(S < T ? S : T);
    }
  }, t.prototype.getChildIndex = function(e) {
    var r = this.children.indexOf(e);
    if (r === -1)
      throw new Error("The supplied DisplayObject must be a child of the caller");
    return r;
  }, t.prototype.setChildIndex = function(e, r) {
    if (r < 0 || r >= this.children.length)
      throw new Error("The index " + r + " supplied is out of bounds " + this.children.length);
    var S = this.getChildIndex(e);
    removeItems(this.children, S, 1), this.children.splice(r, 0, e), this.onChildrenChange(r);
  }, t.prototype.getChildAt = function(e) {
    if (e < 0 || e >= this.children.length)
      throw new Error("getChildAt: Index (" + e + ") does not exist.");
    return this.children[e];
  }, t.prototype.removeChild = function() {
    for (var e = arguments, r = [], S = 0; S < arguments.length; S++)
      r[S] = e[S];
    if (r.length > 1)
      for (var T = 0; T < r.length; T++)
        this.removeChild(r[T]);
    else {
      var D = r[0], N = this.children.indexOf(D);
      if (N === -1)
        return null;
      D.parent = null, D.transform._parentID = -1, removeItems(this.children, N, 1), this._boundsID++, this.onChildrenChange(N), D.emit("removed", this), this.emit("childRemoved", D, this, N);
    }
    return r[0];
  }, t.prototype.removeChildAt = function(e) {
    var r = this.getChildAt(e);
    return r.parent = null, r.transform._parentID = -1, removeItems(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), r.emit("removed", this), this.emit("childRemoved", r, this, e), r;
  }, t.prototype.removeChildren = function(e, r) {
    e === void 0 && (e = 0), r === void 0 && (r = this.children.length);
    var S = e, T = r, D = T - S, N;
    if (D > 0 && D <= T) {
      N = this.children.splice(S, D);
      for (var B = 0; B < N.length; ++B)
        N[B].parent = null, N[B].transform && (N[B].transform._parentID = -1);
      this._boundsID++, this.onChildrenChange(e);
      for (var B = 0; B < N.length; ++B)
        N[B].emit("removed", this), this.emit("childRemoved", N[B], this, B);
      return N;
    } else if (D === 0 && this.children.length === 0)
      return [];
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  }, t.prototype.sortChildren = function() {
    for (var e = !1, r = 0, S = this.children.length; r < S; ++r) {
      var T = this.children[r];
      T._lastSortedIndex = r, !e && T.zIndex !== 0 && (e = !0);
    }
    e && this.children.length > 1 && this.children.sort(sortChildren), this.sortDirty = !1;
  }, t.prototype.updateTransform = function() {
    this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
    for (var e = 0, r = this.children.length; e < r; ++e) {
      var S = this.children[e];
      S.visible && S.updateTransform();
    }
  }, t.prototype.calculateBounds = function() {
    this._bounds.clear(), this._calculateBounds();
    for (var e = 0; e < this.children.length; e++) {
      var r = this.children[e];
      if (!(!r.visible || !r.renderable))
        if (r.calculateBounds(), r._mask) {
          var S = r._mask.isMaskData ? r._mask.maskObject : r._mask;
          S ? (S.calculateBounds(), this._bounds.addBoundsMask(r._bounds, S._bounds)) : this._bounds.addBounds(r._bounds);
        } else
          r.filterArea ? this._bounds.addBoundsArea(r._bounds, r.filterArea) : this._bounds.addBounds(r._bounds);
    }
    this._bounds.updateID = this._boundsID;
  }, t.prototype.getLocalBounds = function(e, r) {
    r === void 0 && (r = !1);
    var S = o.prototype.getLocalBounds.call(this, e);
    if (!r)
      for (var T = 0, D = this.children.length; T < D; ++T) {
        var N = this.children[T];
        N.visible && N.updateTransform();
      }
    return S;
  }, t.prototype._calculateBounds = function() {
  }, t.prototype._renderWithCulling = function(e) {
    var r = e.renderTexture.sourceFrame;
    if (r.width > 0 && r.height > 0) {
      var S, T;
      if (this.cullArea ? (S = this.cullArea, T = this.worldTransform) : this._render !== t.prototype._render && (S = this.getBounds(!0)), S && r.intersects(S, T))
        this._render(e);
      else if (this.cullArea)
        return;
      for (var D = 0, N = this.children.length; D < N; ++D) {
        var B = this.children[D], $ = B.cullable;
        B.cullable = $ || !this.cullArea, B.render(e), B.cullable = $;
      }
    }
  }, t.prototype.render = function(e) {
    if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
      if (this._mask || this.filters && this.filters.length)
        this.renderAdvanced(e);
      else if (this.cullable)
        this._renderWithCulling(e);
      else {
        this._render(e);
        for (var r = 0, S = this.children.length; r < S; ++r)
          this.children[r].render(e);
      }
  }, t.prototype.renderAdvanced = function(e) {
    var r = this.filters, S = this._mask;
    if (r) {
      this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
      for (var T = 0; T < r.length; T++)
        r[T].enabled && this._enabledFilters.push(r[T]);
    }
    var D = r && this._enabledFilters && this._enabledFilters.length || S && (!S.isMaskData || S.enabled && (S.autoDetect || S.type !== MASK_TYPES.NONE));
    if (D && e.batch.flush(), r && this._enabledFilters && this._enabledFilters.length && e.filter.push(this, this._enabledFilters), S && e.mask.push(this, this._mask), this.cullable)
      this._renderWithCulling(e);
    else {
      this._render(e);
      for (var T = 0, N = this.children.length; T < N; ++T)
        this.children[T].render(e);
    }
    D && e.batch.flush(), S && e.mask.pop(this), r && this._enabledFilters && this._enabledFilters.length && e.filter.pop();
  }, t.prototype._render = function(e) {
  }, t.prototype.destroy = function(e) {
    o.prototype.destroy.call(this), this.sortDirty = !1;
    var r = typeof e == "boolean" ? e : e && e.children, S = this.removeChildren(0, this.children.length);
    if (r)
      for (var T = 0; T < S.length; ++T)
        S[T].destroy(e);
  }, Object.defineProperty(t.prototype, "width", {
    /** The width of the Container, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this.scale.x * this.getLocalBounds().width;
    },
    set: function(e) {
      var r = this.getLocalBounds().width;
      r !== 0 ? this.scale.x = e / r : this.scale.x = 1, this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    /** The height of the Container, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this.scale.y * this.getLocalBounds().height;
    },
    set: function(e) {
      var r = this.getLocalBounds().height;
      r !== 0 ? this.scale.y = e / r : this.scale.y = 1, this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(DisplayObject);
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
/*!
 * @pixi/extensions - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/extensions is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$8 = function() {
  return __assign$8 = Object.assign || function(t) {
    for (var e = arguments, r, S = 1, T = arguments.length; S < T; S++) {
      r = e[S];
      for (var D in r)
        Object.prototype.hasOwnProperty.call(r, D) && (t[D] = r[D]);
    }
    return t;
  }, __assign$8.apply(this, arguments);
}, ExtensionType;
(function(o) {
  o.Application = "application", o.RendererPlugin = "renderer-webgl-plugin", o.CanvasRendererPlugin = "renderer-canvas-plugin", o.Loader = "loader", o.LoadParser = "load-parser", o.ResolveParser = "resolve-parser", o.CacheParser = "cache-parser", o.DetectionParser = "detection-parser";
})(ExtensionType || (ExtensionType = {}));
var normalizeExtension = function(o) {
  if (typeof o == "function" || typeof o == "object" && o.extension) {
    if (!o.extension)
      throw new Error("Extension class must have an extension object");
    var t = typeof o.extension != "object" ? { type: o.extension } : o.extension;
    o = __assign$8(__assign$8({}, t), { ref: o });
  }
  if (typeof o == "object")
    o = __assign$8({}, o);
  else
    throw new Error("Invalid extension type");
  return typeof o.type == "string" && (o.type = [o.type]), o;
}, extensions = {
  /** @ignore */
  _addHandlers: null,
  /** @ignore */
  _removeHandlers: null,
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {PIXI.extensions} For chaining.
   */
  remove: function() {
    for (var o = arguments, t = this, e = [], r = 0; r < arguments.length; r++)
      e[r] = o[r];
    return e.map(normalizeExtension).forEach(function(S) {
      S.type.forEach(function(T) {
        var D, N;
        return (N = (D = t._removeHandlers)[T]) === null || N === void 0 ? void 0 : N.call(D, S);
      });
    }), this;
  },
  /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {PIXI.extensions} For chaining.
   */
  add: function() {
    for (var o = arguments, t = this, e = [], r = 0; r < arguments.length; r++)
      e[r] = o[r];
    return e.map(normalizeExtension).forEach(function(S) {
      S.type.forEach(function(T) {
        var D = t._addHandlers, N = t._queue;
        D[T] ? D[T](S) : (N[T] = N[T] || [], N[T].push(S));
      });
    }), this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.
   * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.
   * @returns {PIXI.extensions} For chaining.
   */
  handle: function(o, t, e) {
    var r = this._addHandlers = this._addHandlers || {}, S = this._removeHandlers = this._removeHandlers || {};
    if (r[o] || S[o])
      throw new Error("Extension type " + o + " already has a handler");
    r[o] = t, S[o] = e;
    var T = this._queue;
    return T[o] && (T[o].forEach(function(D) {
      return t(D);
    }), delete T[o]), this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByMap: function(o, t) {
    return this.handle(o, function(e) {
      t[e.name] = e.ref;
    }, function(e) {
      delete t[e.name];
    });
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByList: function(o, t) {
    return this.handle(o, function(e) {
      var r, S;
      t.push(e.ref), o === ExtensionType.Loader && ((S = (r = e.ref).add) === null || S === void 0 || S.call(r));
    }, function(e) {
      var r = t.indexOf(e.ref);
      r !== -1 && t.splice(r, 1);
    });
  }
};
/*!
 * @pixi/runner - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Runner = function() {
  function o(t) {
    this.items = [], this._name = t, this._aliasCount = 0;
  }
  return o.prototype.emit = function(t, e, r, S, T, D, N, B) {
    if (arguments.length > 8)
      throw new Error("max arguments reached");
    var $ = this, U = $.name, H = $.items;
    this._aliasCount++;
    for (var V = 0, X = H.length; V < X; V++)
      H[V][U](t, e, r, S, T, D, N, B);
    return H === this.items && this._aliasCount--, this;
  }, o.prototype.ensureNonAliasedItems = function() {
    this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
  }, o.prototype.add = function(t) {
    return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this;
  }, o.prototype.remove = function(t) {
    var e = this.items.indexOf(t);
    return e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this;
  }, o.prototype.contains = function(t) {
    return this.items.indexOf(t) !== -1;
  }, o.prototype.removeAll = function() {
    return this.ensureNonAliasedItems(), this.items.length = 0, this;
  }, o.prototype.destroy = function() {
    this.removeAll(), this.items = null, this._name = null;
  }, Object.defineProperty(o.prototype, "empty", {
    /**
     * `true` if there are no this Runner contains no listeners
     * @readonly
     */
    get: function() {
      return this.items.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "name", {
    /**
     * The name of the runner.
     * @readonly
     */
    get: function() {
      return this._name;
    },
    enumerable: !1,
    configurable: !0
  }), o;
}();
Object.defineProperties(Runner.prototype, {
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method dispatch
   * @see PIXI.Runner#emit
   */
  dispatch: { value: Runner.prototype.emit },
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method run
   * @see PIXI.Runner#emit
   */
  run: { value: Runner.prototype.emit }
});
/*!
 * @pixi/ticker - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/ticker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.TARGET_FPMS = 0.06;
var UPDATE_PRIORITY;
(function(o) {
  o[o.INTERACTION = 50] = "INTERACTION", o[o.HIGH = 25] = "HIGH", o[o.NORMAL = 0] = "NORMAL", o[o.LOW = -25] = "LOW", o[o.UTILITY = -50] = "UTILITY";
})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
var TickerListener = function() {
  function o(t, e, r, S) {
    e === void 0 && (e = null), r === void 0 && (r = 0), S === void 0 && (S = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = r, this.once = S;
  }
  return o.prototype.match = function(t, e) {
    return e === void 0 && (e = null), this.fn === t && this.context === e;
  }, o.prototype.emit = function(t) {
    this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
    var e = this.next;
    return this.once && this.destroy(!0), this._destroyed && (this.next = null), e;
  }, o.prototype.connect = function(t) {
    this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
  }, o.prototype.destroy = function(t) {
    t === void 0 && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
    var e = this.next;
    return this.next = t ? null : e, this.previous = null, e;
  }, o;
}(), Ticker = function() {
  function o() {
    var t = this;
    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new TickerListener(null, null, 1 / 0), this.deltaMS = 1 / settings.TARGET_FPMS, this.elapsedMS = 1 / settings.TARGET_FPMS, this._tick = function(e) {
      t._requestId = null, t.started && (t.update(e), t.started && t._requestId === null && t._head.next && (t._requestId = requestAnimationFrame(t._tick)));
    };
  }
  return o.prototype._requestIfNeeded = function() {
    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
  }, o.prototype._cancelIfNeeded = function() {
    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
  }, o.prototype._startIfPossible = function() {
    this.started ? this._requestIfNeeded() : this.autoStart && this.start();
  }, o.prototype.add = function(t, e, r) {
    return r === void 0 && (r = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, r));
  }, o.prototype.addOnce = function(t, e, r) {
    return r === void 0 && (r = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, r, !0));
  }, o.prototype._addListener = function(t) {
    var e = this._head.next, r = this._head;
    if (!e)
      t.connect(r);
    else {
      for (; e; ) {
        if (t.priority > e.priority) {
          t.connect(r);
          break;
        }
        r = e, e = e.next;
      }
      t.previous || t.connect(r);
    }
    return this._startIfPossible(), this;
  }, o.prototype.remove = function(t, e) {
    for (var r = this._head.next; r; )
      r.match(t, e) ? r = r.destroy() : r = r.next;
    return this._head.next || this._cancelIfNeeded(), this;
  }, Object.defineProperty(o.prototype, "count", {
    /**
     * The number of listeners on this ticker, calculated by walking through linked list
     * @readonly
     * @member {number}
     */
    get: function() {
      if (!this._head)
        return 0;
      for (var t = 0, e = this._head; e = e.next; )
        t++;
      return t;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.start = function() {
    this.started || (this.started = !0, this._requestIfNeeded());
  }, o.prototype.stop = function() {
    this.started && (this.started = !1, this._cancelIfNeeded());
  }, o.prototype.destroy = function() {
    if (!this._protected) {
      this.stop();
      for (var t = this._head.next; t; )
        t = t.destroy(!0);
      this._head.destroy(), this._head = null;
    }
  }, o.prototype.update = function(t) {
    t === void 0 && (t = performance.now());
    var e;
    if (t > this.lastTime) {
      if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
        var r = t - this._lastFrame | 0;
        if (r < this._minElapsedMS)
          return;
        this._lastFrame = t - r % this._minElapsedMS;
      }
      this.deltaMS = e, this.deltaTime = this.deltaMS * settings.TARGET_FPMS;
      for (var S = this._head, T = S.next; T; )
        T = T.emit(this.deltaTime);
      S.next || this._cancelIfNeeded();
    } else
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    this.lastTime = t;
  }, Object.defineProperty(o.prototype, "FPS", {
    /**
     * The frames per second at which this ticker is running.
     * The default is approximately 60 in most modern browsers.
     * **Note:** This does not factor in the value of
     * {@link PIXI.Ticker#speed}, which is specific
     * to scaling {@link PIXI.Ticker#deltaTime}.
     * @member {number}
     * @readonly
     */
    get: function() {
      return 1e3 / this.elapsedMS;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "minFPS", {
    /**
     * Manages the maximum amount of milliseconds allowed to
     * elapse between invoking {@link PIXI.Ticker#update}.
     * This value is used to cap {@link PIXI.Ticker#deltaTime},
     * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
     * When setting this property it is clamped to a value between
     * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
     * @member {number}
     * @default 10
     */
    get: function() {
      return 1e3 / this._maxElapsedMS;
    },
    set: function(t) {
      var e = Math.min(this.maxFPS, t), r = Math.min(Math.max(0, e) / 1e3, settings.TARGET_FPMS);
      this._maxElapsedMS = 1 / r;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "maxFPS", {
    /**
     * Manages the minimum amount of milliseconds required to
     * elapse between invoking {@link PIXI.Ticker#update}.
     * This will effect the measured value of {@link PIXI.Ticker#FPS}.
     * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
     * Otherwise it will be at least `minFPS`
     * @member {number}
     * @default 0
     */
    get: function() {
      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
    },
    set: function(t) {
      if (t === 0)
        this._minElapsedMS = 0;
      else {
        var e = Math.max(this.minFPS, t);
        this._minElapsedMS = 1 / (e / 1e3);
      }
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "shared", {
    /**
     * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
     * {@link PIXI.VideoResource} to update animation frames / video textures.
     *
     * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
     *
     * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
     * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
     * @example
     * let ticker = PIXI.Ticker.shared;
     * // Set this to prevent starting this ticker when listeners are added.
     * // By default this is true only for the PIXI.Ticker.shared instance.
     * ticker.autoStart = false;
     * // FYI, call this to ensure the ticker is stopped. It should be stopped
     * // if you have not attempted to render anything yet.
     * ticker.stop();
     * // Call this when you are ready for a running shared ticker.
     * ticker.start();
     * @example
     * // You may use the shared ticker to render...
     * let renderer = PIXI.autoDetectRenderer();
     * let stage = new PIXI.Container();
     * document.body.appendChild(renderer.view);
     * ticker.add(function (time) {
     *     renderer.render(stage);
     * });
     * @example
     * // Or you can just update it manually.
     * ticker.autoStart = false;
     * ticker.stop();
     * function animate(time) {
     *     ticker.update(time);
     *     renderer.render(stage);
     *     requestAnimationFrame(animate);
     * }
     * animate(performance.now());
     * @member {PIXI.Ticker}
     * @static
     */
    get: function() {
      if (!o._shared) {
        var t = o._shared = new o();
        t.autoStart = !0, t._protected = !0;
      }
      return o._shared;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "system", {
    /**
     * The system ticker instance used by {@link PIXI.InteractionManager} and by
     * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
     * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
     *
     * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
     * @member {PIXI.Ticker}
     * @static
     */
    get: function() {
      if (!o._system) {
        var t = o._system = new o();
        t.autoStart = !0, t._protected = !0;
      }
      return o._system;
    },
    enumerable: !1,
    configurable: !0
  }), o;
}(), TickerPlugin = function() {
  function o() {
  }
  return o.init = function(t) {
    var e = this;
    t = Object.assign({
      autoStart: !0,
      sharedTicker: !1
    }, t), Object.defineProperty(this, "ticker", {
      set: function(r) {
        this._ticker && this._ticker.remove(this.render, this), this._ticker = r, r && r.add(this.render, this, UPDATE_PRIORITY.LOW);
      },
      get: function() {
        return this._ticker;
      }
    }), this.stop = function() {
      e._ticker.stop();
    }, this.start = function() {
      e._ticker.start();
    }, this._ticker = null, this.ticker = t.sharedTicker ? Ticker.shared : new Ticker(), t.autoStart && this.start();
  }, o.destroy = function() {
    if (this._ticker) {
      var t = this._ticker;
      this.ticker = null, t.destroy();
    }
  }, o.extension = ExtensionType.Application, o;
}();
/*!
 * @pixi/core - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.PREFER_ENV = isMobile.any ? ENV.WEBGL : ENV.WEBGL2;
settings.STRICT_TEXTURE_CACHE = !1;
var INSTALLED = [];
function autoDetectResource(o, t) {
  if (!o)
    return null;
  var e = "";
  if (typeof o == "string") {
    var r = /\.(\w{3,4})(?:$|\?|#)/i.exec(o);
    r && (e = r[1].toLowerCase());
  }
  for (var S = INSTALLED.length - 1; S >= 0; --S) {
    var T = INSTALLED[S];
    if (T.test && T.test(o, e))
      return new T(o, t);
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$p = function(o, t) {
  return extendStatics$p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$p(o, t);
};
function __extends$p(o, t) {
  extendStatics$p(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$7 = function() {
  return __assign$7 = Object.assign || function(t) {
    for (var e = arguments, r, S = 1, T = arguments.length; S < T; S++) {
      r = e[S];
      for (var D in r)
        Object.prototype.hasOwnProperty.call(r, D) && (t[D] = r[D]);
    }
    return t;
  }, __assign$7.apply(this, arguments);
};
function __rest$3(o, t) {
  var e = {};
  for (var r in o)
    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var S = 0, r = Object.getOwnPropertySymbols(o); S < r.length; S++)
      t.indexOf(r[S]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[S]) && (e[r[S]] = o[r[S]]);
  return e;
}
var Resource = function() {
  function o(t, e) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new Runner("setRealSize"), this.onUpdate = new Runner("update"), this.onError = new Runner("onError");
  }
  return o.prototype.bind = function(t) {
    this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height);
  }, o.prototype.unbind = function(t) {
    this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t);
  }, o.prototype.resize = function(t, e) {
    (t !== this._width || e !== this._height) && (this._width = t, this._height = e, this.onResize.emit(t, e));
  }, Object.defineProperty(o.prototype, "valid", {
    /**
     * Has been validated
     * @readonly
     */
    get: function() {
      return !!this._width && !!this._height;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.update = function() {
    this.destroyed || this.onUpdate.emit();
  }, o.prototype.load = function() {
    return Promise.resolve(this);
  }, Object.defineProperty(o.prototype, "width", {
    /**
     * The width of the resource.
     * @readonly
     */
    get: function() {
      return this._width;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "height", {
    /**
     * The height of the resource.
     * @readonly
     */
    get: function() {
      return this._height;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.style = function(t, e, r) {
    return !1;
  }, o.prototype.dispose = function() {
  }, o.prototype.destroy = function() {
    this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
  }, o.test = function(t, e) {
    return !1;
  }, o;
}(), BufferResource = function(o) {
  __extends$p(t, o);
  function t(e, r) {
    var S = this, T = r || {}, D = T.width, N = T.height;
    if (!D || !N)
      throw new Error("BufferResource width or height invalid");
    return S = o.call(this, D, N) || this, S.data = e, S;
  }
  return t.prototype.upload = function(e, r, S) {
    var T = e.gl;
    T.pixelStorei(T.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === ALPHA_MODES.UNPACK);
    var D = r.realWidth, N = r.realHeight;
    return S.width === D && S.height === N ? T.texSubImage2D(r.target, 0, 0, 0, D, N, r.format, S.type, this.data) : (S.width = D, S.height = N, T.texImage2D(r.target, 0, S.internalFormat, D, N, 0, r.format, S.type, this.data)), !0;
  }, t.prototype.dispose = function() {
    this.data = null;
  }, t.test = function(e) {
    return e instanceof Float32Array || e instanceof Uint8Array || e instanceof Uint32Array;
  }, t;
}(Resource), defaultBufferOptions = {
  scaleMode: SCALE_MODES.NEAREST,
  format: FORMATS.RGBA,
  alphaMode: ALPHA_MODES.NPM
}, BaseTexture = function(o) {
  __extends$p(t, o);
  function t(e, r) {
    e === void 0 && (e = null), r === void 0 && (r = null);
    var S = o.call(this) || this;
    r = r || {};
    var T = r.alphaMode, D = r.mipmap, N = r.anisotropicLevel, B = r.scaleMode, $ = r.width, U = r.height, H = r.wrapMode, V = r.format, X = r.type, W = r.target, Y = r.resolution, q = r.resourceOptions;
    return e && !(e instanceof Resource) && (e = autoDetectResource(e, q), e.internal = !0), S.resolution = Y || settings.RESOLUTION, S.width = Math.round(($ || 0) * S.resolution) / S.resolution, S.height = Math.round((U || 0) * S.resolution) / S.resolution, S._mipmap = D !== void 0 ? D : settings.MIPMAP_TEXTURES, S.anisotropicLevel = N !== void 0 ? N : settings.ANISOTROPIC_LEVEL, S._wrapMode = H || settings.WRAP_MODE, S._scaleMode = B !== void 0 ? B : settings.SCALE_MODE, S.format = V || FORMATS.RGBA, S.type = X || TYPES.UNSIGNED_BYTE, S.target = W || TARGETS.TEXTURE_2D, S.alphaMode = T !== void 0 ? T : ALPHA_MODES.UNPACK, S.uid = uid(), S.touched = 0, S.isPowerOfTwo = !1, S._refreshPOT(), S._glTextures = {}, S.dirtyId = 0, S.dirtyStyleId = 0, S.cacheId = null, S.valid = $ > 0 && U > 0, S.textureCacheIds = [], S.destroyed = !1, S.resource = null, S._batchEnabled = 0, S._batchLocation = 0, S.parentTextureArray = null, S.setResource(e), S;
  }
  return Object.defineProperty(t.prototype, "realWidth", {
    /**
     * Pixel width of the source of this texture
     * @readonly
     */
    get: function() {
      return Math.round(this.width * this.resolution);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "realHeight", {
    /**
     * Pixel height of the source of this texture
     * @readonly
     */
    get: function() {
      return Math.round(this.height * this.resolution);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "mipmap", {
    /**
     * Mipmap mode of the texture, affects downscaled images
     * @default PIXI.settings.MIPMAP_TEXTURES
     */
    get: function() {
      return this._mipmap;
    },
    set: function(e) {
      this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "scaleMode", {
    /**
     * The scale mode to apply when scaling this texture
     * @default PIXI.settings.SCALE_MODE
     */
    get: function() {
      return this._scaleMode;
    },
    set: function(e) {
      this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "wrapMode", {
    /**
     * How the texture wraps
     * @default PIXI.settings.WRAP_MODE
     */
    get: function() {
      return this._wrapMode;
    },
    set: function(e) {
      this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.setStyle = function(e, r) {
    var S;
    return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e, S = !0), r !== void 0 && r !== this.mipmap && (this.mipmap = r, S = !0), S && this.dirtyStyleId++, this;
  }, t.prototype.setSize = function(e, r, S) {
    return S = S || this.resolution, this.setRealSize(e * S, r * S, S);
  }, t.prototype.setRealSize = function(e, r, S) {
    return this.resolution = S || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(r) / this.resolution, this._refreshPOT(), this.update(), this;
  }, t.prototype._refreshPOT = function() {
    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
  }, t.prototype.setResolution = function(e) {
    var r = this.resolution;
    return r === e ? this : (this.resolution = e, this.valid && (this.width = Math.round(this.width * r) / e, this.height = Math.round(this.height * r) / e, this.emit("update", this)), this._refreshPOT(), this);
  }, t.prototype.setResource = function(e) {
    if (this.resource === e)
      return this;
    if (this.resource)
      throw new Error("Resource can be set only once");
    return e.bind(this), this.resource = e, this;
  }, t.prototype.update = function() {
    this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this));
  }, t.prototype.onError = function(e) {
    this.emit("error", this, e);
  }, t.prototype.destroy = function() {
    this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete BaseTextureCache[this.cacheId], delete TextureCache[this.cacheId], this.cacheId = null), this.dispose(), t.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0;
  }, t.prototype.dispose = function() {
    this.emit("dispose", this);
  }, t.prototype.castToBaseTexture = function() {
    return this;
  }, t.from = function(e, r, S) {
    S === void 0 && (S = settings.STRICT_TEXTURE_CACHE);
    var T = typeof e == "string", D = null;
    if (T)
      D = e;
    else {
      if (!e._pixiId) {
        var N = r && r.pixiIdPrefix || "pixiid";
        e._pixiId = N + "_" + uid();
      }
      D = e._pixiId;
    }
    var B = BaseTextureCache[D];
    if (T && S && !B)
      throw new Error('The cacheId "' + D + '" does not exist in BaseTextureCache.');
    return B || (B = new t(e, r), B.cacheId = D, t.addToCache(B, D)), B;
  }, t.fromBuffer = function(e, r, S, T) {
    e = e || new Float32Array(r * S * 4);
    var D = new BufferResource(e, { width: r, height: S }), N = e instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
    return new t(D, Object.assign({}, defaultBufferOptions, T || { width: r, height: S, type: N }));
  }, t.addToCache = function(e, r) {
    r && (e.textureCacheIds.indexOf(r) === -1 && e.textureCacheIds.push(r), BaseTextureCache[r] && console.warn("BaseTexture added to the cache with an id [" + r + "] that already had an entry"), BaseTextureCache[r] = e);
  }, t.removeFromCache = function(e) {
    if (typeof e == "string") {
      var r = BaseTextureCache[e];
      if (r) {
        var S = r.textureCacheIds.indexOf(e);
        return S > -1 && r.textureCacheIds.splice(S, 1), delete BaseTextureCache[e], r;
      }
    } else if (e && e.textureCacheIds) {
      for (var T = 0; T < e.textureCacheIds.length; ++T)
        delete BaseTextureCache[e.textureCacheIds[T]];
      return e.textureCacheIds.length = 0, e;
    }
    return null;
  }, t._globalBatch = 0, t;
}(eventemitter3Exports), AbstractMultiResource = function(o) {
  __extends$p(t, o);
  function t(e, r) {
    var S = this, T = r || {}, D = T.width, N = T.height;
    S = o.call(this, D, N) || this, S.items = [], S.itemDirtyIds = [];
    for (var B = 0; B < e; B++) {
      var $ = new BaseTexture();
      S.items.push($), S.itemDirtyIds.push(-2);
    }
    return S.length = e, S._load = null, S.baseTexture = null, S;
  }
  return t.prototype.initFromArray = function(e, r) {
    for (var S = 0; S < this.length; S++)
      e[S] && (e[S].castToBaseTexture ? this.addBaseTextureAt(e[S].castToBaseTexture(), S) : e[S] instanceof Resource ? this.addResourceAt(e[S], S) : this.addResourceAt(autoDetectResource(e[S], r), S));
  }, t.prototype.dispose = function() {
    for (var e = 0, r = this.length; e < r; e++)
      this.items[e].destroy();
    this.items = null, this.itemDirtyIds = null, this._load = null;
  }, t.prototype.addResourceAt = function(e, r) {
    if (!this.items[r])
      throw new Error("Index " + r + " is out of bounds");
    return e.valid && !this.valid && this.resize(e.width, e.height), this.items[r].setResource(e), this;
  }, t.prototype.bind = function(e) {
    if (this.baseTexture !== null)
      throw new Error("Only one base texture per TextureArray is allowed");
    o.prototype.bind.call(this, e);
    for (var r = 0; r < this.length; r++)
      this.items[r].parentTextureArray = e, this.items[r].on("update", e.update, e);
  }, t.prototype.unbind = function(e) {
    o.prototype.unbind.call(this, e);
    for (var r = 0; r < this.length; r++)
      this.items[r].parentTextureArray = null, this.items[r].off("update", e.update, e);
  }, t.prototype.load = function() {
    var e = this;
    if (this._load)
      return this._load;
    var r = this.items.map(function(T) {
      return T.resource;
    }).filter(function(T) {
      return T;
    }), S = r.map(function(T) {
      return T.load();
    });
    return this._load = Promise.all(S).then(function() {
      var T = e.items[0], D = T.realWidth, N = T.realHeight;
      return e.resize(D, N), Promise.resolve(e);
    }), this._load;
  }, t;
}(Resource), ArrayResource = function(o) {
  __extends$p(t, o);
  function t(e, r) {
    var S = this, T = r || {}, D = T.width, N = T.height, B, $;
    return Array.isArray(e) ? (B = e, $ = e.length) : $ = e, S = o.call(this, $, { width: D, height: N }) || this, B && S.initFromArray(B, r), S;
  }
  return t.prototype.addBaseTextureAt = function(e, r) {
    if (e.resource)
      this.addResourceAt(e.resource, r);
    else
      throw new Error("ArrayResource does not support RenderTexture");
    return this;
  }, t.prototype.bind = function(e) {
    o.prototype.bind.call(this, e), e.target = TARGETS.TEXTURE_2D_ARRAY;
  }, t.prototype.upload = function(e, r, S) {
    var T = this, D = T.length, N = T.itemDirtyIds, B = T.items, $ = e.gl;
    S.dirtyId < 0 && $.texImage3D($.TEXTURE_2D_ARRAY, 0, S.internalFormat, this._width, this._height, D, 0, r.format, S.type, null);
    for (var U = 0; U < D; U++) {
      var H = B[U];
      N[U] < H.dirtyId && (N[U] = H.dirtyId, H.valid && $.texSubImage3D(
        $.TEXTURE_2D_ARRAY,
        0,
        0,
        // xoffset
        0,
        // yoffset
        U,
        // zoffset
        H.resource.width,
        H.resource.height,
        1,
        r.format,
        S.type,
        H.resource.source
      ));
    }
    return !0;
  }, t;
}(AbstractMultiResource), BaseImageResource = function(o) {
  __extends$p(t, o);
  function t(e) {
    var r = this, S = e, T = S.naturalWidth || S.videoWidth || S.width, D = S.naturalHeight || S.videoHeight || S.height;
    return r = o.call(this, T, D) || this, r.source = e, r.noSubImage = !1, r;
  }
  return t.crossOrigin = function(e, r, S) {
    S === void 0 && r.indexOf("data:") !== 0 ? e.crossOrigin = determineCrossOrigin(r) : S !== !1 && (e.crossOrigin = typeof S == "string" ? S : "anonymous");
  }, t.prototype.upload = function(e, r, S, T) {
    var D = e.gl, N = r.realWidth, B = r.realHeight;
    if (T = T || this.source, T instanceof HTMLImageElement) {
      if (!T.complete || T.naturalWidth === 0)
        return !1;
    } else if (T instanceof HTMLVideoElement && T.readyState <= 1)
      return !1;
    return D.pixelStorei(D.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === ALPHA_MODES.UNPACK), !this.noSubImage && r.target === D.TEXTURE_2D && S.width === N && S.height === B ? D.texSubImage2D(D.TEXTURE_2D, 0, 0, 0, r.format, S.type, T) : (S.width = N, S.height = B, D.texImage2D(r.target, 0, S.internalFormat, r.format, S.type, T)), !0;
  }, t.prototype.update = function() {
    if (!this.destroyed) {
      var e = this.source, r = e.naturalWidth || e.videoWidth || e.width, S = e.naturalHeight || e.videoHeight || e.height;
      this.resize(r, S), o.prototype.update.call(this);
    }
  }, t.prototype.dispose = function() {
    this.source = null;
  }, t;
}(Resource), CanvasResource = function(o) {
  __extends$p(t, o);
  function t(e) {
    return o.call(this, e) || this;
  }
  return t.test = function(e) {
    var r = globalThis.OffscreenCanvas;
    return r && e instanceof r ? !0 : globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement;
  }, t;
}(BaseImageResource), CubeResource = function(o) {
  __extends$p(t, o);
  function t(e, r) {
    var S = this, T = r || {}, D = T.width, N = T.height, B = T.autoLoad, $ = T.linkBaseTexture;
    if (e && e.length !== t.SIDES)
      throw new Error("Invalid length. Got " + e.length + ", expected 6");
    S = o.call(this, 6, { width: D, height: N }) || this;
    for (var U = 0; U < t.SIDES; U++)
      S.items[U].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + U;
    return S.linkBaseTexture = $ !== !1, e && S.initFromArray(e, r), B !== !1 && S.load(), S;
  }
  return t.prototype.bind = function(e) {
    o.prototype.bind.call(this, e), e.target = TARGETS.TEXTURE_CUBE_MAP;
  }, t.prototype.addBaseTextureAt = function(e, r, S) {
    if (!this.items[r])
      throw new Error("Index " + r + " is out of bounds");
    if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)
      if (e.resource)
        this.addResourceAt(e.resource, r);
      else
        throw new Error("CubeResource does not support copying of renderTexture.");
    else
      e.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + r, e.parentTextureArray = this.baseTexture, this.items[r] = e;
    return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[r] = e, this;
  }, t.prototype.upload = function(e, r, S) {
    for (var T = this.itemDirtyIds, D = 0; D < t.SIDES; D++) {
      var N = this.items[D];
      (T[D] < N.dirtyId || S.dirtyId < r.dirtyId) && (N.valid && N.resource ? (N.resource.upload(e, N, S), T[D] = N.dirtyId) : T[D] < -1 && (e.gl.texImage2D(N.target, 0, S.internalFormat, r.realWidth, r.realHeight, 0, r.format, S.type, null), T[D] = -1));
    }
    return !0;
  }, t.test = function(e) {
    return Array.isArray(e) && e.length === t.SIDES;
  }, t.SIDES = 6, t;
}(AbstractMultiResource), ImageResource = function(o) {
  __extends$p(t, o);
  function t(e, r) {
    var S = this;
    if (r = r || {}, !(e instanceof HTMLImageElement)) {
      var T = new Image();
      BaseImageResource.crossOrigin(T, e, r.crossorigin), T.src = e, e = T;
    }
    return S = o.call(this, e) || this, !e.complete && S._width && S._height && (S._width = 0, S._height = 0), S.url = e.src, S._process = null, S.preserveBitmap = !1, S.createBitmap = (r.createBitmap !== void 0 ? r.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, S.alphaMode = typeof r.alphaMode == "number" ? r.alphaMode : null, S.bitmap = null, S._load = null, r.autoLoad !== !1 && S.load(), S;
  }
  return t.prototype.load = function(e) {
    var r = this;
    return this._load ? this._load : (e !== void 0 && (this.createBitmap = e), this._load = new Promise(function(S, T) {
      var D = r.source;
      r.url = D.src;
      var N = function() {
        r.destroyed || (D.onload = null, D.onerror = null, r.resize(D.width, D.height), r._load = null, r.createBitmap ? S(r.process()) : S(r));
      };
      D.complete && D.src ? N() : (D.onload = N, D.onerror = function(B) {
        T(B), r.onError.emit(B);
      });
    }), this._load);
  }, t.prototype.process = function() {
    var e = this, r = this.source;
    if (this._process !== null)
      return this._process;
    if (this.bitmap !== null || !globalThis.createImageBitmap)
      return Promise.resolve(this);
    var S = globalThis.createImageBitmap, T = !r.crossOrigin || r.crossOrigin === "anonymous";
    return this._process = fetch(r.src, {
      mode: T ? "cors" : "no-cors"
    }).then(function(D) {
      return D.blob();
    }).then(function(D) {
      return S(D, 0, 0, r.width, r.height, {
        premultiplyAlpha: e.alphaMode === null || e.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
      });
    }).then(function(D) {
      return e.destroyed ? Promise.reject() : (e.bitmap = D, e.update(), e._process = null, Promise.resolve(e));
    }), this._process;
  }, t.prototype.upload = function(e, r, S) {
    if (typeof this.alphaMode == "number" && (r.alphaMode = this.alphaMode), !this.createBitmap)
      return o.prototype.upload.call(this, e, r, S);
    if (!this.bitmap && (this.process(), !this.bitmap))
      return !1;
    if (o.prototype.upload.call(this, e, r, S, this.bitmap), !this.preserveBitmap) {
      var T = !0, D = r._glTextures;
      for (var N in D) {
        var B = D[N];
        if (B !== S && B.dirtyId !== r.dirtyId) {
          T = !1;
          break;
        }
      }
      T && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
    }
    return !0;
  }, t.prototype.dispose = function() {
    this.source.onload = null, this.source.onerror = null, o.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
  }, t.test = function(e) {
    return typeof e == "string" || e instanceof HTMLImageElement;
  }, t;
}(BaseImageResource), SVGResource = function(o) {
  __extends$p(t, o);
  function t(e, r) {
    var S = this;
    return r = r || {}, S = o.call(this, settings.ADAPTER.createCanvas()) || this, S._width = 0, S._height = 0, S.svg = e, S.scale = r.scale || 1, S._overrideWidth = r.width, S._overrideHeight = r.height, S._resolve = null, S._crossorigin = r.crossorigin, S._load = null, r.autoLoad !== !1 && S.load(), S;
  }
  return t.prototype.load = function() {
    var e = this;
    return this._load ? this._load : (this._load = new Promise(function(r) {
      if (e._resolve = function() {
        e.resize(e.source.width, e.source.height), r(e);
      }, t.SVG_XML.test(e.svg.trim())) {
        if (!btoa)
          throw new Error("Your browser doesn't support base64 conversions.");
        e.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(e.svg)));
      }
      e._loadSvg();
    }), this._load);
  }, t.prototype._loadSvg = function() {
    var e = this, r = new Image();
    BaseImageResource.crossOrigin(r, this.svg, this._crossorigin), r.src = this.svg, r.onerror = function(S) {
      e._resolve && (r.onerror = null, e.onError.emit(S));
    }, r.onload = function() {
      if (e._resolve) {
        var S = r.width, T = r.height;
        if (!S || !T)
          throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
        var D = S * e.scale, N = T * e.scale;
        (e._overrideWidth || e._overrideHeight) && (D = e._overrideWidth || e._overrideHeight / T * S, N = e._overrideHeight || e._overrideWidth / S * T), D = Math.round(D), N = Math.round(N);
        var B = e.source;
        B.width = D, B.height = N, B._pixiId = "canvas_" + uid(), B.getContext("2d").drawImage(r, 0, 0, S, T, 0, 0, D, N), e._resolve(), e._resolve = null;
      }
    };
  }, t.getSize = function(e) {
    var r = t.SVG_SIZE.exec(e), S = {};
    return r && (S[r[1]] = Math.round(parseFloat(r[3])), S[r[5]] = Math.round(parseFloat(r[7]))), S;
  }, t.prototype.dispose = function() {
    o.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;
  }, t.test = function(e, r) {
    return r === "svg" || typeof e == "string" && e.startsWith("data:image/svg+xml") || typeof e == "string" && t.SVG_XML.test(e);
  }, t.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, t.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, t;
}(BaseImageResource), VideoResource = function(o) {
  __extends$p(t, o);
  function t(e, r) {
    var S = this;
    if (r = r || {}, !(e instanceof HTMLVideoElement)) {
      var T = document.createElement("video");
      T.setAttribute("preload", "auto"), T.setAttribute("webkit-playsinline", ""), T.setAttribute("playsinline", ""), typeof e == "string" && (e = [e]);
      var D = e[0].src || e[0];
      BaseImageResource.crossOrigin(T, D, r.crossorigin);
      for (var N = 0; N < e.length; ++N) {
        var B = document.createElement("source"), $ = e[N], U = $.src, H = $.mime;
        U = U || e[N];
        var V = U.split("?").shift().toLowerCase(), X = V.slice(V.lastIndexOf(".") + 1);
        H = H || t.MIME_TYPES[X] || "video/" + X, B.src = U, B.type = H, T.appendChild(B);
      }
      e = T;
    }
    return S = o.call(this, e) || this, S.noSubImage = !0, S._autoUpdate = !0, S._isConnectedToTicker = !1, S._updateFPS = r.updateFPS || 0, S._msToNextUpdate = 0, S.autoPlay = r.autoPlay !== !1, S._load = null, S._resolve = null, S._onCanPlay = S._onCanPlay.bind(S), S._onError = S._onError.bind(S), r.autoLoad !== !1 && S.load(), S;
  }
  return t.prototype.update = function(e) {
    if (!this.destroyed) {
      var r = Ticker.shared.elapsedMS * this.source.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - r), (!this._updateFPS || this._msToNextUpdate <= 0) && (o.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
    }
  }, t.prototype.load = function() {
    var e = this;
    if (this._load)
      return this._load;
    var r = this.source;
    return (r.readyState === r.HAVE_ENOUGH_DATA || r.readyState === r.HAVE_FUTURE_DATA) && r.width && r.height && (r.complete = !0), r.addEventListener("play", this._onPlayStart.bind(this)), r.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (r.addEventListener("canplay", this._onCanPlay), r.addEventListener("canplaythrough", this._onCanPlay), r.addEventListener("error", this._onError, !0)), this._load = new Promise(function(S) {
      e.valid ? S(e) : (e._resolve = S, r.load());
    }), this._load;
  }, t.prototype._onError = function(e) {
    this.source.removeEventListener("error", this._onError, !0), this.onError.emit(e);
  }, t.prototype._isSourcePlaying = function() {
    var e = this.source;
    return !e.paused && !e.ended && this._isSourceReady();
  }, t.prototype._isSourceReady = function() {
    var e = this.source;
    return e.readyState > 2;
  }, t.prototype._onPlayStart = function() {
    this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0);
  }, t.prototype._onPlayStop = function() {
    this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);
  }, t.prototype._onCanPlay = function() {
    var e = this.source;
    e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlay);
    var r = this.valid;
    this.resize(e.videoWidth, e.videoHeight), !r && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play();
  }, t.prototype.dispose = function() {
    this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);
    var e = this.source;
    e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), o.prototype.dispose.call(this);
  }, Object.defineProperty(t.prototype, "autoUpdate", {
    /** Should the base texture automatically update itself, set to true by default. */
    get: function() {
      return this._autoUpdate;
    },
    set: function(e) {
      e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "updateFPS", {
    /**
     * How many times a second to update the texture from the video. Leave at 0 to update at every render.
     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
     */
    get: function() {
      return this._updateFPS;
    },
    set: function(e) {
      e !== this._updateFPS && (this._updateFPS = e);
    },
    enumerable: !1,
    configurable: !0
  }), t.test = function(e, r) {
    return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || t.TYPES.indexOf(r) > -1;
  }, t.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], t.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  }, t;
}(BaseImageResource), ImageBitmapResource = function(o) {
  __extends$p(t, o);
  function t(e) {
    return o.call(this, e) || this;
  }
  return t.test = function(e) {
    return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && e instanceof ImageBitmap;
  }, t;
}(BaseImageResource);
INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
var _resources = {
  __proto__: null,
  Resource,
  BaseImageResource,
  INSTALLED,
  autoDetectResource,
  AbstractMultiResource,
  ArrayResource,
  BufferResource,
  CanvasResource,
  CubeResource,
  ImageResource,
  SVGResource,
  VideoResource,
  ImageBitmapResource
}, DepthResource = function(o) {
  __extends$p(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  return t.prototype.upload = function(e, r, S) {
    var T = e.gl;
    T.pixelStorei(T.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === ALPHA_MODES.UNPACK);
    var D = r.realWidth, N = r.realHeight;
    return S.width === D && S.height === N ? T.texSubImage2D(r.target, 0, 0, 0, D, N, r.format, S.type, this.data) : (S.width = D, S.height = N, T.texImage2D(r.target, 0, S.internalFormat, D, N, 0, r.format, S.type, this.data)), !0;
  }, t;
}(BufferResource), Framebuffer = function() {
  function o(t, e) {
    this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Runner("disposeFramebuffer"), this.multisample = MSAA_QUALITY.NONE;
  }
  return Object.defineProperty(o.prototype, "colorTexture", {
    /**
     * Reference to the colorTexture.
     * @readonly
     */
    get: function() {
      return this.colorTextures[0];
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.addColorTexture = function(t, e) {
    return t === void 0 && (t = 0), this.colorTextures[t] = e || new BaseTexture(null, {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      mipmap: MIPMAP_MODES.OFF,
      width: this.width,
      height: this.height
    }), this.dirtyId++, this.dirtyFormat++, this;
  }, o.prototype.addDepthTexture = function(t) {
    return this.depthTexture = t || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: MIPMAP_MODES.OFF,
      format: FORMATS.DEPTH_COMPONENT,
      type: TYPES.UNSIGNED_SHORT
    }), this.dirtyId++, this.dirtyFormat++, this;
  }, o.prototype.enableDepth = function() {
    return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;
  }, o.prototype.enableStencil = function() {
    return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;
  }, o.prototype.resize = function(t, e) {
    if (t = Math.round(t), e = Math.round(e), !(t === this.width && e === this.height)) {
      this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;
      for (var r = 0; r < this.colorTextures.length; r++) {
        var S = this.colorTextures[r], T = S.resolution;
        S.setSize(t / T, e / T);
      }
      if (this.depthTexture) {
        var T = this.depthTexture.resolution;
        this.depthTexture.setSize(t / T, e / T);
      }
    }
  }, o.prototype.dispose = function() {
    this.disposeRunner.emit(this, !1);
  }, o.prototype.destroyDepthTexture = function() {
    this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
  }, o;
}(), BaseRenderTexture = function(o) {
  __extends$p(t, o);
  function t(e) {
    e === void 0 && (e = {});
    var r = this;
    if (typeof e == "number") {
      var S = arguments[0], T = arguments[1], D = arguments[2], N = arguments[3];
      e = { width: S, height: T, scaleMode: D, resolution: N };
    }
    return e.width = e.width || 100, e.height = e.height || 100, e.multisample = e.multisample !== void 0 ? e.multisample : MSAA_QUALITY.NONE, r = o.call(this, null, e) || this, r.mipmap = MIPMAP_MODES.OFF, r.valid = !0, r.clearColor = [0, 0, 0, 0], r.framebuffer = new Framebuffer(r.realWidth, r.realHeight).addColorTexture(0, r), r.framebuffer.multisample = e.multisample, r.maskStack = [], r.filterStack = [{}], r;
  }
  return t.prototype.resize = function(e, r) {
    this.framebuffer.resize(e * this.resolution, r * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  }, t.prototype.dispose = function() {
    this.framebuffer.dispose(), o.prototype.dispose.call(this);
  }, t.prototype.destroy = function() {
    o.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
  }, t;
}(BaseTexture), TextureUvs = function() {
  function o() {
    this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
  }
  return o.prototype.set = function(t, e, r) {
    var S = e.width, T = e.height;
    if (r) {
      var D = t.width / 2 / S, N = t.height / 2 / T, B = t.x / S + D, $ = t.y / T + N;
      r = groupD8.add(r, groupD8.NW), this.x0 = B + D * groupD8.uX(r), this.y0 = $ + N * groupD8.uY(r), r = groupD8.add(r, 2), this.x1 = B + D * groupD8.uX(r), this.y1 = $ + N * groupD8.uY(r), r = groupD8.add(r, 2), this.x2 = B + D * groupD8.uX(r), this.y2 = $ + N * groupD8.uY(r), r = groupD8.add(r, 2), this.x3 = B + D * groupD8.uX(r), this.y3 = $ + N * groupD8.uY(r);
    } else
      this.x0 = t.x / S, this.y0 = t.y / T, this.x1 = (t.x + t.width) / S, this.y1 = t.y / T, this.x2 = (t.x + t.width) / S, this.y2 = (t.y + t.height) / T, this.x3 = t.x / S, this.y3 = (t.y + t.height) / T;
    this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
  }, o.prototype.toString = function() {
    return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
  }, o;
}(), DEFAULT_UVS = new TextureUvs();
function removeAllHandlers(o) {
  o.destroy = function() {
  }, o.on = function() {
  }, o.once = function() {
  }, o.emit = function() {
  };
}
var Texture = function(o) {
  __extends$p(t, o);
  function t(e, r, S, T, D, N) {
    var B = o.call(this) || this;
    if (B.noFrame = !1, r || (B.noFrame = !0, r = new Rectangle(0, 0, 1, 1)), e instanceof t && (e = e.baseTexture), B.baseTexture = e, B._frame = r, B.trim = T, B.valid = !1, B._uvs = DEFAULT_UVS, B.uvMatrix = null, B.orig = S || r, B._rotate = Number(D || 0), D === !0)
      B._rotate = 2;
    else if (B._rotate % 2 !== 0)
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    return B.defaultAnchor = N ? new Point(N.x, N.y) : new Point(0, 0), B._updateID = 0, B.textureCacheIds = [], e.valid ? B.noFrame ? e.valid && B.onBaseTextureUpdated(e) : B.frame = r : e.once("loaded", B.onBaseTextureUpdated, B), B.noFrame && e.on("update", B.onBaseTextureUpdated, B), B;
  }
  return t.prototype.update = function() {
    this.baseTexture.resource && this.baseTexture.resource.update();
  }, t.prototype.onBaseTextureUpdated = function(e) {
    if (this.noFrame) {
      if (!this.baseTexture.valid)
        return;
      this._frame.width = e.width, this._frame.height = e.height, this.valid = !0, this.updateUvs();
    } else
      this.frame = this._frame;
    this.emit("update", this);
  }, t.prototype.destroy = function(e) {
    if (this.baseTexture) {
      if (e) {
        var r = this.baseTexture.resource;
        r && r.url && TextureCache[r.url] && t.removeFromCache(r.url), this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
    }
    this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, t.removeFromCache(this), this.textureCacheIds = null;
  }, t.prototype.clone = function() {
    var e = this._frame.clone(), r = this._frame === this.orig ? e : this.orig.clone(), S = new t(this.baseTexture, !this.noFrame && e, r, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
    return this.noFrame && (S._frame = e), S;
  }, t.prototype.updateUvs = function() {
    this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
  }, t.from = function(e, r, S) {
    r === void 0 && (r = {}), S === void 0 && (S = settings.STRICT_TEXTURE_CACHE);
    var T = typeof e == "string", D = null;
    if (T)
      D = e;
    else if (e instanceof BaseTexture) {
      if (!e.cacheId) {
        var N = r && r.pixiIdPrefix || "pixiid";
        e.cacheId = N + "-" + uid(), BaseTexture.addToCache(e, e.cacheId);
      }
      D = e.cacheId;
    } else {
      if (!e._pixiId) {
        var N = r && r.pixiIdPrefix || "pixiid";
        e._pixiId = N + "_" + uid();
      }
      D = e._pixiId;
    }
    var B = TextureCache[D];
    if (T && S && !B)
      throw new Error('The cacheId "' + D + '" does not exist in TextureCache.');
    return !B && !(e instanceof BaseTexture) ? (r.resolution || (r.resolution = getResolutionOfUrl(e)), B = new t(new BaseTexture(e, r)), B.baseTexture.cacheId = D, BaseTexture.addToCache(B.baseTexture, D), t.addToCache(B, D)) : !B && e instanceof BaseTexture && (B = new t(e), t.addToCache(B, D)), B;
  }, t.fromURL = function(e, r) {
    var S = Object.assign({ autoLoad: !1 }, r == null ? void 0 : r.resourceOptions), T = t.from(e, Object.assign({ resourceOptions: S }, r), !1), D = T.baseTexture.resource;
    return T.baseTexture.valid ? Promise.resolve(T) : D.load().then(function() {
      return Promise.resolve(T);
    });
  }, t.fromBuffer = function(e, r, S, T) {
    return new t(BaseTexture.fromBuffer(e, r, S, T));
  }, t.fromLoader = function(e, r, S, T) {
    var D = new BaseTexture(e, Object.assign({
      scaleMode: settings.SCALE_MODE,
      resolution: getResolutionOfUrl(r)
    }, T)), N = D.resource;
    N instanceof ImageResource && (N.url = r);
    var B = new t(D);
    return S || (S = r), BaseTexture.addToCache(B.baseTexture, S), t.addToCache(B, S), S !== r && (BaseTexture.addToCache(B.baseTexture, r), t.addToCache(B, r)), B.baseTexture.valid ? Promise.resolve(B) : new Promise(function($) {
      B.baseTexture.once("loaded", function() {
        return $(B);
      });
    });
  }, t.addToCache = function(e, r) {
    r && (e.textureCacheIds.indexOf(r) === -1 && e.textureCacheIds.push(r), TextureCache[r] && console.warn("Texture added to the cache with an id [" + r + "] that already had an entry"), TextureCache[r] = e);
  }, t.removeFromCache = function(e) {
    if (typeof e == "string") {
      var r = TextureCache[e];
      if (r) {
        var S = r.textureCacheIds.indexOf(e);
        return S > -1 && r.textureCacheIds.splice(S, 1), delete TextureCache[e], r;
      }
    } else if (e && e.textureCacheIds) {
      for (var T = 0; T < e.textureCacheIds.length; ++T)
        TextureCache[e.textureCacheIds[T]] === e && delete TextureCache[e.textureCacheIds[T]];
      return e.textureCacheIds.length = 0, e;
    }
    return null;
  }, Object.defineProperty(t.prototype, "resolution", {
    /**
     * Returns resolution of baseTexture
     * @readonly
     */
    get: function() {
      return this.baseTexture.resolution;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "frame", {
    /**
     * The frame specifies the region of the base texture that this texture uses.
     * Please call `updateUvs()` after you change coordinates of `frame` manually.
     */
    get: function() {
      return this._frame;
    },
    set: function(e) {
      this._frame = e, this.noFrame = !1;
      var r = e.x, S = e.y, T = e.width, D = e.height, N = r + T > this.baseTexture.width, B = S + D > this.baseTexture.height;
      if (N || B) {
        var $ = N && B ? "and" : "or", U = "X: " + r + " + " + T + " = " + (r + T) + " > " + this.baseTexture.width, H = "Y: " + S + " + " + D + " = " + (S + D) + " > " + this.baseTexture.height;
        throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (U + " " + $ + " " + H));
      }
      this.valid = T && D && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = e), this.valid && this.updateUvs();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "rotate", {
    /**
     * Indicates whether the texture is rotated inside the atlas
     * set to 2 to compensate for texture packer rotation
     * set to 6 to compensate for spine packer rotation
     * can be used to rotate or mirror sprites
     * See {@link PIXI.groupD8} for explanation
     */
    get: function() {
      return this._rotate;
    },
    set: function(e) {
      this._rotate = e, this.valid && this.updateUvs();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "width", {
    /** The width of the Texture in pixels. */
    get: function() {
      return this.orig.width;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    /** The height of the Texture in pixels. */
    get: function() {
      return this.orig.height;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.castToBaseTexture = function() {
    return this.baseTexture;
  }, Object.defineProperty(t, "EMPTY", {
    /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */
    get: function() {
      return t._EMPTY || (t._EMPTY = new t(new BaseTexture()), removeAllHandlers(t._EMPTY), removeAllHandlers(t._EMPTY.baseTexture)), t._EMPTY;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t, "WHITE", {
    /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */
    get: function() {
      if (!t._WHITE) {
        var e = settings.ADAPTER.createCanvas(16, 16), r = e.getContext("2d");
        e.width = 16, e.height = 16, r.fillStyle = "white", r.fillRect(0, 0, 16, 16), t._WHITE = new t(BaseTexture.from(e)), removeAllHandlers(t._WHITE), removeAllHandlers(t._WHITE.baseTexture);
      }
      return t._WHITE;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(eventemitter3Exports), RenderTexture = function(o) {
  __extends$p(t, o);
  function t(e, r) {
    var S = o.call(this, e, r) || this;
    return S.valid = !0, S.filterFrame = null, S.filterPoolKey = null, S.updateUvs(), S;
  }
  return Object.defineProperty(t.prototype, "framebuffer", {
    /**
     * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
     * @readonly
     */
    get: function() {
      return this.baseTexture.framebuffer;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "multisample", {
    /**
     * Shortcut to `this.framebuffer.multisample`.
     * @default PIXI.MSAA_QUALITY.NONE
     */
    get: function() {
      return this.framebuffer.multisample;
    },
    set: function(e) {
      this.framebuffer.multisample = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.resize = function(e, r, S) {
    S === void 0 && (S = !0);
    var T = this.baseTexture.resolution, D = Math.round(e * T) / T, N = Math.round(r * T) / T;
    this.valid = D > 0 && N > 0, this._frame.width = this.orig.width = D, this._frame.height = this.orig.height = N, S && this.baseTexture.resize(D, N), this.updateUvs();
  }, t.prototype.setResolution = function(e) {
    var r = this.baseTexture;
    r.resolution !== e && (r.setResolution(e), this.resize(r.width, r.height, !1));
  }, t.create = function(e) {
    for (var r = arguments, S = [], T = 1; T < arguments.length; T++)
      S[T - 1] = r[T];
    return typeof e == "number" && (deprecation("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), e = {
      width: e,
      height: S[0],
      scaleMode: S[1],
      resolution: S[2]
    }), new t(new BaseRenderTexture(e));
  }, t;
}(Texture), RenderTexturePool = function() {
  function o(t) {
    this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;
  }
  return o.prototype.createTexture = function(t, e, r) {
    r === void 0 && (r = MSAA_QUALITY.NONE);
    var S = new BaseRenderTexture(Object.assign({
      width: t,
      height: e,
      resolution: 1,
      multisample: r
    }, this.textureOptions));
    return new RenderTexture(S);
  }, o.prototype.getOptimalTexture = function(t, e, r, S) {
    r === void 0 && (r = 1), S === void 0 && (S = MSAA_QUALITY.NONE);
    var T;
    t = Math.ceil(t * r - 1e-6), e = Math.ceil(e * r - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || e !== this._pixelsHeight ? (t = nextPow2(t), e = nextPow2(e), T = ((t & 65535) << 16 | e & 65535) >>> 0, S > 1 && (T += S * 4294967296)) : T = S > 1 ? -S : -1, this.texturePool[T] || (this.texturePool[T] = []);
    var D = this.texturePool[T].pop();
    return D || (D = this.createTexture(t, e, S)), D.filterPoolKey = T, D.setResolution(r), D;
  }, o.prototype.getFilterTexture = function(t, e, r) {
    var S = this.getOptimalTexture(t.width, t.height, e || t.resolution, r || MSAA_QUALITY.NONE);
    return S.filterFrame = t.filterFrame, S;
  }, o.prototype.returnTexture = function(t) {
    var e = t.filterPoolKey;
    t.filterFrame = null, this.texturePool[e].push(t);
  }, o.prototype.returnFilterTexture = function(t) {
    this.returnTexture(t);
  }, o.prototype.clear = function(t) {
    if (t = t !== !1, t)
      for (var e in this.texturePool) {
        var r = this.texturePool[e];
        if (r)
          for (var S = 0; S < r.length; S++)
            r[S].destroy(!0);
      }
    this.texturePool = {};
  }, o.prototype.setScreenSize = function(t) {
    if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {
      this.enableFullScreen = t.width > 0 && t.height > 0;
      for (var e in this.texturePool)
        if (Number(e) < 0) {
          var r = this.texturePool[e];
          if (r)
            for (var S = 0; S < r.length; S++)
              r[S].destroy(!0);
          this.texturePool[e] = [];
        }
      this._pixelsWidth = t.width, this._pixelsHeight = t.height;
    }
  }, o.SCREEN_KEY = -1, o;
}(), Attribute = function() {
  function o(t, e, r, S, T, D, N) {
    e === void 0 && (e = 0), r === void 0 && (r = !1), S === void 0 && (S = TYPES.FLOAT), this.buffer = t, this.size = e, this.normalized = r, this.type = S, this.stride = T, this.start = D, this.instance = N;
  }
  return o.prototype.destroy = function() {
    this.buffer = null;
  }, o.from = function(t, e, r, S, T) {
    return new o(t, e, r, S, T);
  }, o;
}(), UID$4 = 0, Buffer$1 = function() {
  function o(t, e, r) {
    e === void 0 && (e = !0), r === void 0 && (r = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = r, this.static = e, this.id = UID$4++, this.disposeRunner = new Runner("disposeBuffer");
  }
  return o.prototype.update = function(t) {
    t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++;
  }, o.prototype.dispose = function() {
    this.disposeRunner.emit(this, !1);
  }, o.prototype.destroy = function() {
    this.dispose(), this.data = null;
  }, Object.defineProperty(o.prototype, "index", {
    get: function() {
      return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    },
    /**
     * Flags whether this is an index buffer.
     *
     * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make
     * the buffer of type `ARRAY_BUFFER`.
     *
     * For backwards compatibility.
     */
    set: function(t) {
      this.type = t ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
    },
    enumerable: !1,
    configurable: !0
  }), o.from = function(t) {
    return t instanceof Array && (t = new Float32Array(t)), new o(t);
  }, o;
}(), map$1$1 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(o, t) {
  for (var e = 0, r = 0, S = {}, T = 0; T < o.length; T++)
    r += t[T], e += o[T].length;
  for (var D = new ArrayBuffer(e * 4), N = null, B = 0, T = 0; T < o.length; T++) {
    var $ = t[T], U = o[T], H = getBufferType(U);
    S[H] || (S[H] = new map$1$1[H](D)), N = S[H];
    for (var V = 0; V < U.length; V++) {
      var X = (V / $ | 0) * r + B, W = V % $;
      N[X + W] = U[V];
    }
    B += $;
  }
  return new Float32Array(D);
}
var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 }, UID$3 = 0, map$2 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
}, Geometry = function() {
  function o(t, e) {
    t === void 0 && (t = []), e === void 0 && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = UID$3++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new Runner("disposeGeometry"), this.refCount = 0;
  }
  return o.prototype.addAttribute = function(t, e, r, S, T, D, N, B) {
    if (r === void 0 && (r = 0), S === void 0 && (S = !1), B === void 0 && (B = !1), !e)
      throw new Error("You must pass a buffer when creating an attribute");
    e instanceof Buffer$1 || (e instanceof Array && (e = new Float32Array(e)), e = new Buffer$1(e));
    var $ = t.split("|");
    if ($.length > 1) {
      for (var U = 0; U < $.length; U++)
        this.addAttribute($[U], e, r, S, T);
      return this;
    }
    var H = this.buffers.indexOf(e);
    return H === -1 && (this.buffers.push(e), H = this.buffers.length - 1), this.attributes[t] = new Attribute(H, r, S, T, D, N, B), this.instanced = this.instanced || B, this;
  }, o.prototype.getAttribute = function(t) {
    return this.attributes[t];
  }, o.prototype.getBuffer = function(t) {
    return this.buffers[this.getAttribute(t).buffer];
  }, o.prototype.addIndex = function(t) {
    return t instanceof Buffer$1 || (t instanceof Array && (t = new Uint16Array(t)), t = new Buffer$1(t)), t.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.indexOf(t) === -1 && this.buffers.push(t), this;
  }, o.prototype.getIndex = function() {
    return this.indexBuffer;
  }, o.prototype.interleave = function() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
      return this;
    var t = [], e = [], r = new Buffer$1(), S;
    for (S in this.attributes) {
      var T = this.attributes[S], D = this.buffers[T.buffer];
      t.push(D.data), e.push(T.size * byteSizeMap$1[T.type] / 4), T.buffer = 0;
    }
    for (r.data = interleaveTypedArrays(t, e), S = 0; S < this.buffers.length; S++)
      this.buffers[S] !== this.indexBuffer && this.buffers[S].destroy();
    return this.buffers = [r], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
  }, o.prototype.getSize = function() {
    for (var t in this.attributes) {
      var e = this.attributes[t], r = this.buffers[e.buffer];
      return r.data.length / (e.stride / 4 || e.size);
    }
    return 0;
  }, o.prototype.dispose = function() {
    this.disposeRunner.emit(this, !1);
  }, o.prototype.destroy = function() {
    this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
  }, o.prototype.clone = function() {
    for (var t = new o(), e = 0; e < this.buffers.length; e++)
      t.buffers[e] = new Buffer$1(this.buffers[e].data.slice(0));
    for (var e in this.attributes) {
      var r = this.attributes[e];
      t.attributes[e] = new Attribute(r.buffer, r.size, r.normalized, r.type, r.stride, r.start, r.instance);
    }
    return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER), t;
  }, o.merge = function(t) {
    for (var e = new o(), r = [], S = [], T = [], D, N = 0; N < t.length; N++) {
      D = t[N];
      for (var B = 0; B < D.buffers.length; B++)
        S[B] = S[B] || 0, S[B] += D.buffers[B].data.length, T[B] = 0;
    }
    for (var N = 0; N < D.buffers.length; N++)
      r[N] = new map$2[getBufferType(D.buffers[N].data)](S[N]), e.buffers[N] = new Buffer$1(r[N]);
    for (var N = 0; N < t.length; N++) {
      D = t[N];
      for (var B = 0; B < D.buffers.length; B++)
        r[B].set(D.buffers[B].data, T[B]), T[B] += D.buffers[B].data.length;
    }
    if (e.attributes = D.attributes, D.indexBuffer) {
      e.indexBuffer = e.buffers[D.buffers.indexOf(D.indexBuffer)], e.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      for (var $ = 0, U = 0, H = 0, V = 0, N = 0; N < D.buffers.length; N++)
        if (D.buffers[N] !== D.indexBuffer) {
          V = N;
          break;
        }
      for (var N in D.attributes) {
        var X = D.attributes[N];
        (X.buffer | 0) === V && (U += X.size * byteSizeMap$1[X.type] / 4);
      }
      for (var N = 0; N < t.length; N++) {
        for (var W = t[N].indexBuffer.data, B = 0; B < W.length; B++)
          e.indexBuffer.data[B + H] += $;
        $ += t[N].buffers[V].data.length / U, H += W.length;
      }
    }
    return e;
  }, o;
}(), Quad = function(o) {
  __extends$p(t, o);
  function t() {
    var e = o.call(this) || this;
    return e.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]), e;
  }
  return t;
}(Geometry), QuadUv = function(o) {
  __extends$p(t, o);
  function t() {
    var e = o.call(this) || this;
    return e.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]), e.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]), e.vertexBuffer = new Buffer$1(e.vertices), e.uvBuffer = new Buffer$1(e.uvs), e.addAttribute("aVertexPosition", e.vertexBuffer).addAttribute("aTextureCoord", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e;
  }
  return t.prototype.map = function(e, r) {
    var S = 0, T = 0;
    return this.uvs[0] = S, this.uvs[1] = T, this.uvs[2] = S + r.width / e.width, this.uvs[3] = T, this.uvs[4] = S + r.width / e.width, this.uvs[5] = T + r.height / e.height, this.uvs[6] = S, this.uvs[7] = T + r.height / e.height, S = r.x, T = r.y, this.vertices[0] = S, this.vertices[1] = T, this.vertices[2] = S + r.width, this.vertices[3] = T, this.vertices[4] = S + r.width, this.vertices[5] = T + r.height, this.vertices[6] = S, this.vertices[7] = T + r.height, this.invalidate(), this;
  }, t.prototype.invalidate = function() {
    return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
  }, t;
}(Geometry), UID$2 = 0, UniformGroup = function() {
  function o(t, e, r) {
    this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = UID$2++, this.static = !!e, this.ubo = !!r, t instanceof Buffer$1 ? (this.buffer = t, this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Buffer$1(new Float32Array(1)), this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !0));
  }
  return o.prototype.update = function() {
    this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
  }, o.prototype.add = function(t, e, r) {
    if (!this.ubo)
      this.uniforms[t] = new o(e, r);
    else
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
  }, o.from = function(t, e, r) {
    return new o(t, e, r);
  }, o.uboFrom = function(t, e) {
    return new o(t, e ?? !0, !0);
  }, o;
}(), FilterState = function() {
  function o() {
    this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = MSAA_QUALITY.NONE, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.bindingSourceFrame = new Rectangle(), this.bindingDestinationFrame = new Rectangle(), this.filters = [], this.transform = null;
  }
  return o.prototype.clear = function() {
    this.target = null, this.filters = null, this.renderTexture = null;
  }, o;
}(), tempPoints = [new Point(), new Point(), new Point(), new Point()], tempMatrix$2 = new Matrix(), FilterSystem = function() {
  function o(t) {
    this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool(), this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new Quad(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup({
      outputFrame: new Rectangle(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      // legacy variables
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, !0), this.forceClear = !1, this.useMaxPadding = !1;
  }
  return o.prototype.push = function(t, e) {
    for (var r, S, T = this.renderer, D = this.defaultFilterStack, N = this.statePool.pop() || new FilterState(), B = this.renderer.renderTexture, $ = e[0].resolution, U = e[0].multisample, H = e[0].padding, V = e[0].autoFit, X = (r = e[0].legacy) !== null && r !== void 0 ? r : !0, W = 1; W < e.length; W++) {
      var Y = e[W];
      $ = Math.min($, Y.resolution), U = Math.min(U, Y.multisample), H = this.useMaxPadding ? Math.max(H, Y.padding) : H + Y.padding, V = V && Y.autoFit, X = X || ((S = Y.legacy) !== null && S !== void 0 ? S : !0);
    }
    D.length === 1 && (this.defaultFilterStack[0].renderTexture = B.current), D.push(N), N.resolution = $, N.multisample = U, N.legacy = X, N.target = t, N.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), N.sourceFrame.pad(H);
    var q = this.tempRect.copyFrom(B.sourceFrame);
    T.projection.transform && this.transformAABB(tempMatrix$2.copyFrom(T.projection.transform).invert(), q), V ? (N.sourceFrame.fit(q), (N.sourceFrame.width <= 0 || N.sourceFrame.height <= 0) && (N.sourceFrame.width = 0, N.sourceFrame.height = 0)) : N.sourceFrame.intersects(q) || (N.sourceFrame.width = 0, N.sourceFrame.height = 0), this.roundFrame(N.sourceFrame, B.current ? B.current.resolution : T.resolution, B.sourceFrame, B.destinationFrame, T.projection.transform), N.renderTexture = this.getOptimalFilterTexture(N.sourceFrame.width, N.sourceFrame.height, $, U), N.filters = e, N.destinationFrame.width = N.renderTexture.width, N.destinationFrame.height = N.renderTexture.height;
    var K = this.tempRect;
    K.x = 0, K.y = 0, K.width = N.sourceFrame.width, K.height = N.sourceFrame.height, N.renderTexture.filterFrame = N.sourceFrame, N.bindingSourceFrame.copyFrom(B.sourceFrame), N.bindingDestinationFrame.copyFrom(B.destinationFrame), N.transform = T.projection.transform, T.projection.transform = null, B.bind(N.renderTexture, N.sourceFrame, K), T.framebuffer.clear(0, 0, 0, 0);
  }, o.prototype.pop = function() {
    var t = this.defaultFilterStack, e = t.pop(), r = e.filters;
    this.activeState = e;
    var S = this.globalUniforms.uniforms;
    S.outputFrame = e.sourceFrame, S.resolution = e.resolution;
    var T = S.inputSize, D = S.inputPixel, N = S.inputClamp;
    if (T[0] = e.destinationFrame.width, T[1] = e.destinationFrame.height, T[2] = 1 / T[0], T[3] = 1 / T[1], D[0] = Math.round(T[0] * e.resolution), D[1] = Math.round(T[1] * e.resolution), D[2] = 1 / D[0], D[3] = 1 / D[1], N[0] = 0.5 * D[2], N[1] = 0.5 * D[3], N[2] = e.sourceFrame.width * T[2] - 0.5 * D[2], N[3] = e.sourceFrame.height * T[3] - 0.5 * D[3], e.legacy) {
      var B = S.filterArea;
      B[0] = e.destinationFrame.width, B[1] = e.destinationFrame.height, B[2] = e.sourceFrame.x, B[3] = e.sourceFrame.y, S.filterClamp = S.inputClamp;
    }
    this.globalUniforms.update();
    var $ = t[t.length - 1];
    if (this.renderer.framebuffer.blit(), r.length === 1)
      r[0].apply(this, e.renderTexture, $.renderTexture, CLEAR_MODES.BLEND, e), this.returnFilterTexture(e.renderTexture);
    else {
      var U = e.renderTexture, H = this.getOptimalFilterTexture(U.width, U.height, e.resolution);
      H.filterFrame = U.filterFrame;
      var V = 0;
      for (V = 0; V < r.length - 1; ++V) {
        V === 1 && e.multisample > 1 && (H = this.getOptimalFilterTexture(U.width, U.height, e.resolution), H.filterFrame = U.filterFrame), r[V].apply(this, U, H, CLEAR_MODES.CLEAR, e);
        var X = U;
        U = H, H = X;
      }
      r[V].apply(this, U, $.renderTexture, CLEAR_MODES.BLEND, e), V > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture(U), this.returnFilterTexture(H);
    }
    e.clear(), this.statePool.push(e);
  }, o.prototype.bindAndClear = function(t, e) {
    e === void 0 && (e = CLEAR_MODES.CLEAR);
    var r = this.renderer, S = r.renderTexture, T = r.state;
    if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) {
      var D = this.tempRect;
      D.x = 0, D.y = 0, D.width = t.filterFrame.width, D.height = t.filterFrame.height, S.bind(t, t.filterFrame, D);
    } else
      t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? S.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
    var N = T.stateId & 1 || this.forceClear;
    (e === CLEAR_MODES.CLEAR || e === CLEAR_MODES.BLIT && N) && this.renderer.framebuffer.clear(0, 0, 0, 0);
  }, o.prototype.applyFilter = function(t, e, r, S) {
    var T = this.renderer;
    T.state.set(t.state), this.bindAndClear(r, S), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, T.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), T.geometry.bind(this.quadUv), T.geometry.draw(DRAW_MODES.TRIANGLES)) : (T.geometry.bind(this.quad), T.geometry.draw(DRAW_MODES.TRIANGLE_STRIP));
  }, o.prototype.calculateSpriteMatrix = function(t, e) {
    var r = this.activeState, S = r.sourceFrame, T = r.destinationFrame, D = e._texture.orig, N = t.set(T.width, 0, 0, T.height, S.x, S.y), B = e.worldTransform.copyTo(Matrix.TEMP_MATRIX);
    return B.invert(), N.prepend(B), N.scale(1 / D.width, 1 / D.height), N.translate(e.anchor.x, e.anchor.y), N;
  }, o.prototype.destroy = function() {
    this.renderer = null, this.texturePool.clear(!1);
  }, o.prototype.getOptimalFilterTexture = function(t, e, r, S) {
    return r === void 0 && (r = 1), S === void 0 && (S = MSAA_QUALITY.NONE), this.texturePool.getOptimalTexture(t, e, r, S);
  }, o.prototype.getFilterTexture = function(t, e, r) {
    if (typeof t == "number") {
      var S = t;
      t = e, e = S;
    }
    t = t || this.activeState.renderTexture;
    var T = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, r || MSAA_QUALITY.NONE);
    return T.filterFrame = t.filterFrame, T;
  }, o.prototype.returnFilterTexture = function(t) {
    this.texturePool.returnTexture(t);
  }, o.prototype.emptyPool = function() {
    this.texturePool.clear(!0);
  }, o.prototype.resize = function() {
    this.texturePool.setScreenSize(this.renderer.view);
  }, o.prototype.transformAABB = function(t, e) {
    var r = tempPoints[0], S = tempPoints[1], T = tempPoints[2], D = tempPoints[3];
    r.set(e.left, e.top), S.set(e.left, e.bottom), T.set(e.right, e.top), D.set(e.right, e.bottom), t.apply(r, r), t.apply(S, S), t.apply(T, T), t.apply(D, D);
    var N = Math.min(r.x, S.x, T.x, D.x), B = Math.min(r.y, S.y, T.y, D.y), $ = Math.max(r.x, S.x, T.x, D.x), U = Math.max(r.y, S.y, T.y, D.y);
    e.x = N, e.y = B, e.width = $ - N, e.height = U - B;
  }, o.prototype.roundFrame = function(t, e, r, S, T) {
    if (!(t.width <= 0 || t.height <= 0 || r.width <= 0 || r.height <= 0)) {
      if (T) {
        var D = T.a, N = T.b, B = T.c, $ = T.d;
        if ((Math.abs(N) > 1e-4 || Math.abs(B) > 1e-4) && (Math.abs(D) > 1e-4 || Math.abs($) > 1e-4))
          return;
      }
      T = T ? tempMatrix$2.copyFrom(T) : tempMatrix$2.identity(), T.translate(-r.x, -r.y).scale(S.width / r.width, S.height / r.height).translate(S.x, S.y), this.transformAABB(T, t), t.ceil(e), this.transformAABB(T.invert(), t);
    }
  }, o;
}(), ObjectRenderer = function() {
  function o(t) {
    this.renderer = t;
  }
  return o.prototype.flush = function() {
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o.prototype.start = function() {
  }, o.prototype.stop = function() {
    this.flush();
  }, o.prototype.render = function(t) {
  }, o;
}(), BatchSystem = function() {
  function o(t) {
    this.renderer = t, this.emptyRenderer = new ObjectRenderer(t), this.currentRenderer = this.emptyRenderer;
  }
  return o.prototype.setObjectRenderer = function(t) {
    this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start());
  }, o.prototype.flush = function() {
    this.setObjectRenderer(this.emptyRenderer);
  }, o.prototype.reset = function() {
    this.setObjectRenderer(this.emptyRenderer);
  }, o.prototype.copyBoundTextures = function(t, e) {
    for (var r = this.renderer.texture.boundTextures, S = e - 1; S >= 0; --S)
      t[S] = r[S] || null, t[S] && (t[S]._batchLocation = S);
  }, o.prototype.boundArray = function(t, e, r, S) {
    for (var T = t.elements, D = t.ids, N = t.count, B = 0, $ = 0; $ < N; $++) {
      var U = T[$], H = U._batchLocation;
      if (H >= 0 && H < S && e[H] === U) {
        D[$] = H;
        continue;
      }
      for (; B < S; ) {
        var V = e[B];
        if (V && V._batchEnabled === r && V._batchLocation === B) {
          B++;
          continue;
        }
        D[$] = B, U._batchLocation = B, e[B] = U;
        break;
      }
    }
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}(), CONTEXT_UID_COUNTER = 0, ContextSystem = function() {
  function o(t) {
    this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {
      uint32Indices: !1
    }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener("webglcontextlost", this.handleContextLost, !1), t.view.addEventListener("webglcontextrestored", this.handleContextRestored, !1);
  }
  return Object.defineProperty(o.prototype, "isLost", {
    /**
     * `true` if the context is lost
     * @readonly
     */
    get: function() {
      return !this.gl || this.gl.isContextLost();
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.contextChange = function(t) {
    this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, t.isContextLost() && t.getExtension("WEBGL_lose_context") && t.getExtension("WEBGL_lose_context").restoreContext();
  }, o.prototype.initFromContext = function(t) {
    this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, this.renderer.runners.contextChange.emit(t);
  }, o.prototype.initFromOptions = function(t) {
    var e = this.createContext(this.renderer.view, t);
    this.initFromContext(e);
  }, o.prototype.createContext = function(t, e) {
    var r;
    if (settings.PREFER_ENV >= ENV.WEBGL2 && (r = t.getContext("webgl2", e)), r)
      this.webGLVersion = 2;
    else if (this.webGLVersion = 1, r = t.getContext("webgl", e) || t.getContext("experimental-webgl", e), !r)
      throw new Error("This browser does not support WebGL. Try using the canvas renderer");
    return this.gl = r, this.getExtensions(), this.gl;
  }, o.prototype.getExtensions = function() {
    var t = this.gl, e = {
      anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: t.getExtension("OES_texture_float_linear"),
      s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: t.getExtension("WEBGL_compressed_texture_etc"),
      etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: t.getExtension("WEBGL_compressed_texture_atc"),
      astc: t.getExtension("WEBGL_compressed_texture_astc")
    };
    this.webGLVersion === 1 ? Object.assign(this.extensions, e, {
      drawBuffers: t.getExtension("WEBGL_draw_buffers"),
      depthTexture: t.getExtension("WEBGL_depth_texture"),
      loseContext: t.getExtension("WEBGL_lose_context"),
      vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
      uint32ElementIndex: t.getExtension("OES_element_index_uint"),
      // Floats and half-floats
      floatTexture: t.getExtension("OES_texture_float"),
      floatTextureLinear: t.getExtension("OES_texture_float_linear"),
      textureHalfFloat: t.getExtension("OES_texture_half_float"),
      textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
    }) : this.webGLVersion === 2 && Object.assign(this.extensions, e, {
      // Floats and half-floats
      colorBufferFloat: t.getExtension("EXT_color_buffer_float")
    });
  }, o.prototype.handleContextLost = function(t) {
    t.preventDefault();
  }, o.prototype.handleContextRestored = function() {
    this.renderer.runners.contextChange.emit(this.gl);
  }, o.prototype.destroy = function() {
    var t = this.renderer.view;
    this.renderer = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
  }, o.prototype.postrender = function() {
    this.renderer.renderingToScreen && this.gl.flush();
  }, o.prototype.validateContext = function(t) {
    var e = t.getContextAttributes(), r = "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext;
    r && (this.webGLVersion = 2), e && !e.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    var S = r || !!t.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = S, S || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
  }, o;
}(), GLFramebuffer = function() {
  function o(t) {
    this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = MSAA_QUALITY.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
  }
  return o;
}(), tempRectangle = new Rectangle(), FramebufferSystem = function() {
  function o(t) {
    this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer(10, 10), this.msaaSamples = null;
  }
  return o.prototype.contextChange = function() {
    var t = this.gl = this.renderer.gl;
    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Rectangle(), this.hasMRT = !0, this.writeDepthTexture = !0, this.disposeAll(!0), this.renderer.context.webGLVersion === 1) {
      var e = this.renderer.context.extensions.drawBuffers, r = this.renderer.context.extensions.depthTexture;
      settings.PREFER_ENV === ENV.WEBGL_LEGACY && (e = null, r = null), e ? t.drawBuffers = function(S) {
        return e.drawBuffersWEBGL(S);
      } : (this.hasMRT = !1, t.drawBuffers = function() {
      }), r || (this.writeDepthTexture = !1);
    } else
      this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES);
  }, o.prototype.bind = function(t, e, r) {
    r === void 0 && (r = 0);
    var S = this.gl;
    if (t) {
      var T = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
      this.current !== t && (this.current = t, S.bindFramebuffer(S.FRAMEBUFFER, T.framebuffer)), T.mipLevel !== r && (t.dirtyId++, t.dirtyFormat++, T.mipLevel = r), T.dirtyId !== t.dirtyId && (T.dirtyId = t.dirtyId, T.dirtyFormat !== t.dirtyFormat ? (T.dirtyFormat = t.dirtyFormat, T.dirtySize = t.dirtySize, this.updateFramebuffer(t, r)) : T.dirtySize !== t.dirtySize && (T.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));
      for (var D = 0; D < t.colorTextures.length; D++) {
        var N = t.colorTextures[D];
        this.renderer.texture.unbind(N.parentTextureArray || N);
      }
      if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {
        var B = e.width >> r, $ = e.height >> r, U = B / e.width;
        this.setViewport(e.x * U, e.y * U, B, $);
      } else {
        var B = t.width >> r, $ = t.height >> r;
        this.setViewport(0, 0, B, $);
      }
    } else
      this.current && (this.current = null, S.bindFramebuffer(S.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
  }, o.prototype.setViewport = function(t, e, r, S) {
    var T = this.viewport;
    t = Math.round(t), e = Math.round(e), r = Math.round(r), S = Math.round(S), (T.width !== r || T.height !== S || T.x !== t || T.y !== e) && (T.x = t, T.y = e, T.width = r, T.height = S, this.gl.viewport(t, e, r, S));
  }, Object.defineProperty(o.prototype, "size", {
    /**
     * Get the size of the current width and height. Returns object with `width` and `height` values.
     * @readonly
     */
    get: function() {
      return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.clear = function(t, e, r, S, T) {
    T === void 0 && (T = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH);
    var D = this.gl;
    D.clearColor(t, e, r, S), D.clear(T);
  }, o.prototype.initFramebuffer = function(t) {
    var e = this.gl, r = new GLFramebuffer(e.createFramebuffer());
    return r.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = r, this.managedFramebuffers.push(t), t.disposeRunner.add(this), r;
  }, o.prototype.resizeFramebuffer = function(t) {
    var e = this.gl, r = t.glFramebuffers[this.CONTEXT_UID];
    r.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, r.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.RGBA8, t.width, t.height)), r.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, r.stencil), r.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));
    var S = t.colorTextures, T = S.length;
    e.drawBuffers || (T = Math.min(T, 1));
    for (var D = 0; D < T; D++) {
      var N = S[D], B = N.parentTextureArray || N;
      this.renderer.texture.bind(B, 0);
    }
    t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0);
  }, o.prototype.updateFramebuffer = function(t, e) {
    var r = this.gl, S = t.glFramebuffers[this.CONTEXT_UID], T = t.colorTextures, D = T.length;
    r.drawBuffers || (D = Math.min(D, 1)), S.multisample > 1 && this.canMultisampleFramebuffer(t) ? (S.msaaBuffer = S.msaaBuffer || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, S.msaaBuffer), r.renderbufferStorageMultisample(r.RENDERBUFFER, S.multisample, r.RGBA8, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, S.msaaBuffer)) : S.msaaBuffer && (r.deleteRenderbuffer(S.msaaBuffer), S.msaaBuffer = null, S.blitFramebuffer && (S.blitFramebuffer.dispose(), S.blitFramebuffer = null));
    for (var N = [], B = 0; B < D; B++) {
      var $ = T[B], U = $.parentTextureArray || $;
      this.renderer.texture.bind(U, 0), !(B === 0 && S.msaaBuffer) && (r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + B, $.target, U._glTextures[this.CONTEXT_UID].texture, e), N.push(r.COLOR_ATTACHMENT0 + B));
    }
    if (N.length > 1 && r.drawBuffers(N), t.depthTexture) {
      var H = this.writeDepthTexture;
      if (H) {
        var V = t.depthTexture;
        this.renderer.texture.bind(V, 0), r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, V._glTextures[this.CONTEXT_UID].texture, e);
      }
    }
    (t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (S.stencil = S.stencil || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, S.stencil), S.msaaBuffer ? r.renderbufferStorageMultisample(r.RENDERBUFFER, S.multisample, r.DEPTH24_STENCIL8, t.width, t.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, S.stencil)) : S.stencil && (r.deleteRenderbuffer(S.stencil), S.stencil = null);
  }, o.prototype.canMultisampleFramebuffer = function(t) {
    return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture;
  }, o.prototype.detectSamples = function(t) {
    var e = this.msaaSamples, r = MSAA_QUALITY.NONE;
    if (t <= 1 || e === null)
      return r;
    for (var S = 0; S < e.length; S++)
      if (e[S] <= t) {
        r = e[S];
        break;
      }
    return r === 1 && (r = MSAA_QUALITY.NONE), r;
  }, o.prototype.blit = function(t, e, r) {
    var S = this, T = S.current, D = S.renderer, N = S.gl, B = S.CONTEXT_UID;
    if (D.context.webGLVersion === 2 && T) {
      var $ = T.glFramebuffers[B];
      if ($) {
        if (!t) {
          if (!$.msaaBuffer)
            return;
          var U = T.colorTextures[0];
          if (!U)
            return;
          $.blitFramebuffer || ($.blitFramebuffer = new Framebuffer(T.width, T.height), $.blitFramebuffer.addColorTexture(0, U)), t = $.blitFramebuffer, t.colorTextures[0] !== U && (t.colorTextures[0] = U, t.dirtyId++, t.dirtyFormat++), (t.width !== T.width || t.height !== T.height) && (t.width = T.width, t.height = T.height, t.dirtyId++, t.dirtySize++);
        }
        e || (e = tempRectangle, e.width = T.width, e.height = T.height), r || (r = e);
        var H = e.width === r.width && e.height === r.height;
        this.bind(t), N.bindFramebuffer(N.READ_FRAMEBUFFER, $.framebuffer), N.blitFramebuffer(e.left, e.top, e.right, e.bottom, r.left, r.top, r.right, r.bottom, N.COLOR_BUFFER_BIT, H ? N.NEAREST : N.LINEAR);
      }
    }
  }, o.prototype.disposeFramebuffer = function(t, e) {
    var r = t.glFramebuffers[this.CONTEXT_UID], S = this.gl;
    if (r) {
      delete t.glFramebuffers[this.CONTEXT_UID];
      var T = this.managedFramebuffers.indexOf(t);
      T >= 0 && this.managedFramebuffers.splice(T, 1), t.disposeRunner.remove(this), e || (S.deleteFramebuffer(r.framebuffer), r.msaaBuffer && S.deleteRenderbuffer(r.msaaBuffer), r.stencil && S.deleteRenderbuffer(r.stencil)), r.blitFramebuffer && r.blitFramebuffer.dispose();
    }
  }, o.prototype.disposeAll = function(t) {
    var e = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (var r = 0; r < e.length; r++)
      this.disposeFramebuffer(e[r], t);
  }, o.prototype.forceStencil = function() {
    var t = this.current;
    if (t) {
      var e = t.glFramebuffers[this.CONTEXT_UID];
      if (!(!e || e.stencil)) {
        t.stencil = !0;
        var r = t.width, S = t.height, T = this.gl, D = T.createRenderbuffer();
        T.bindRenderbuffer(T.RENDERBUFFER, D), e.msaaBuffer ? T.renderbufferStorageMultisample(T.RENDERBUFFER, e.multisample, T.DEPTH24_STENCIL8, r, S) : T.renderbufferStorage(T.RENDERBUFFER, T.DEPTH_STENCIL, r, S), e.stencil = D, T.framebufferRenderbuffer(T.FRAMEBUFFER, T.DEPTH_STENCIL_ATTACHMENT, T.RENDERBUFFER, D);
      }
    }
  }, o.prototype.reset = function() {
    this.current = this.unknownFramebuffer, this.viewport = new Rectangle();
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}(), byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 }, GeometrySystem = function() {
  function o(t) {
    this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};
  }
  return o.prototype.contextChange = function() {
    this.disposeAll(!0);
    var t = this.gl = this.renderer.gl, e = this.renderer.context;
    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e.webGLVersion !== 2) {
      var r = this.renderer.context.extensions.vertexArrayObject;
      settings.PREFER_ENV === ENV.WEBGL_LEGACY && (r = null), r ? (t.createVertexArray = function() {
        return r.createVertexArrayOES();
      }, t.bindVertexArray = function(T) {
        return r.bindVertexArrayOES(T);
      }, t.deleteVertexArray = function(T) {
        return r.deleteVertexArrayOES(T);
      }) : (this.hasVao = !1, t.createVertexArray = function() {
        return null;
      }, t.bindVertexArray = function() {
        return null;
      }, t.deleteVertexArray = function() {
        return null;
      });
    }
    if (e.webGLVersion !== 2) {
      var S = t.getExtension("ANGLE_instanced_arrays");
      S ? (t.vertexAttribDivisor = function(T, D) {
        return S.vertexAttribDivisorANGLE(T, D);
      }, t.drawElementsInstanced = function(T, D, N, B, $) {
        return S.drawElementsInstancedANGLE(T, D, N, B, $);
      }, t.drawArraysInstanced = function(T, D, N, B) {
        return S.drawArraysInstancedANGLE(T, D, N, B);
      }) : this.hasInstance = !1;
    }
    this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex;
  }, o.prototype.bind = function(t, e) {
    e = e || this.renderer.shader.shader;
    var r = this.gl, S = t.glVertexArrayObjects[this.CONTEXT_UID], T = !1;
    S || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = S = {}, T = !0);
    var D = S[e.program.id] || this.initGeometryVao(t, e, T);
    this._activeGeometry = t, this._activeVao !== D && (this._activeVao = D, this.hasVao ? r.bindVertexArray(D) : this.activateVao(t, e.program)), this.updateBuffers();
  }, o.prototype.reset = function() {
    this.unbind();
  }, o.prototype.updateBuffers = function() {
    for (var t = this._activeGeometry, e = this.renderer.buffer, r = 0; r < t.buffers.length; r++) {
      var S = t.buffers[r];
      e.update(S);
    }
  }, o.prototype.checkCompatibility = function(t, e) {
    var r = t.attributes, S = e.attributeData;
    for (var T in S)
      if (!r[T])
        throw new Error('shader and geometry incompatible, geometry missing the "' + T + '" attribute');
  }, o.prototype.getSignature = function(t, e) {
    var r = t.attributes, S = e.attributeData, T = ["g", t.id];
    for (var D in r)
      S[D] && T.push(D, S[D].location);
    return T.join("-");
  }, o.prototype.initGeometryVao = function(t, e, r) {
    r === void 0 && (r = !0);
    var S = this.gl, T = this.CONTEXT_UID, D = this.renderer.buffer, N = e.program;
    N.glPrograms[T] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, N);
    var B = this.getSignature(t, N), $ = t.glVertexArrayObjects[this.CONTEXT_UID], U = $[B];
    if (U)
      return $[N.id] = U, U;
    var H = t.buffers, V = t.attributes, X = {}, W = {};
    for (var Y in H)
      X[Y] = 0, W[Y] = 0;
    for (var Y in V)
      !V[Y].size && N.attributeData[Y] ? V[Y].size = N.attributeData[Y].size : V[Y].size || console.warn("PIXI Geometry attribute '" + Y + "' size cannot be determined (likely the bound shader does not have the attribute)"), X[V[Y].buffer] += V[Y].size * byteSizeMap[V[Y].type];
    for (var Y in V) {
      var q = V[Y], K = q.size;
      q.stride === void 0 && (X[q.buffer] === K * byteSizeMap[q.type] ? q.stride = 0 : q.stride = X[q.buffer]), q.start === void 0 && (q.start = W[q.buffer], W[q.buffer] += K * byteSizeMap[q.type]);
    }
    U = S.createVertexArray(), S.bindVertexArray(U);
    for (var Z = 0; Z < H.length; Z++) {
      var J = H[Z];
      D.bind(J), r && J._glBuffers[T].refCount++;
    }
    return this.activateVao(t, N), this._activeVao = U, $[N.id] = U, $[B] = U, U;
  }, o.prototype.disposeGeometry = function(t, e) {
    var r;
    if (this.managedGeometries[t.id]) {
      delete this.managedGeometries[t.id];
      var S = t.glVertexArrayObjects[this.CONTEXT_UID], T = this.gl, D = t.buffers, N = (r = this.renderer) === null || r === void 0 ? void 0 : r.buffer;
      if (t.disposeRunner.remove(this), !!S) {
        if (N)
          for (var B = 0; B < D.length; B++) {
            var $ = D[B]._glBuffers[this.CONTEXT_UID];
            $ && ($.refCount--, $.refCount === 0 && !e && N.dispose(D[B], e));
          }
        if (!e) {
          for (var U in S)
            if (U[0] === "g") {
              var H = S[U];
              this._activeVao === H && this.unbind(), T.deleteVertexArray(H);
            }
        }
        delete t.glVertexArrayObjects[this.CONTEXT_UID];
      }
    }
  }, o.prototype.disposeAll = function(t) {
    for (var e = Object.keys(this.managedGeometries), r = 0; r < e.length; r++)
      this.disposeGeometry(this.managedGeometries[e[r]], t);
  }, o.prototype.activateVao = function(t, e) {
    var r = this.gl, S = this.CONTEXT_UID, T = this.renderer.buffer, D = t.buffers, N = t.attributes;
    t.indexBuffer && T.bind(t.indexBuffer);
    var B = null;
    for (var $ in N) {
      var U = N[$], H = D[U.buffer], V = H._glBuffers[S];
      if (e.attributeData[$]) {
        B !== V && (T.bind(H), B = V);
        var X = e.attributeData[$].location;
        if (r.enableVertexAttribArray(X), r.vertexAttribPointer(X, U.size, U.type || r.FLOAT, U.normalized, U.stride, U.start), U.instance)
          if (this.hasInstance)
            r.vertexAttribDivisor(X, 1);
          else
            throw new Error("geometry error, GPU Instancing is not supported on this device");
      }
    }
  }, o.prototype.draw = function(t, e, r, S) {
    var T = this.gl, D = this._activeGeometry;
    if (D.indexBuffer) {
      var N = D.indexBuffer.data.BYTES_PER_ELEMENT, B = N === 2 ? T.UNSIGNED_SHORT : T.UNSIGNED_INT;
      N === 2 || N === 4 && this.canUseUInt32ElementIndex ? D.instanced ? T.drawElementsInstanced(t, e || D.indexBuffer.data.length, B, (r || 0) * N, S || 1) : T.drawElements(t, e || D.indexBuffer.data.length, B, (r || 0) * N) : console.warn("unsupported index buffer type: uint32");
    } else
      D.instanced ? T.drawArraysInstanced(t, r, e || D.getSize(), S || 1) : T.drawArrays(t, r, e || D.getSize());
    return this;
  }, o.prototype.unbind = function() {
    this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}(), MaskData = function() {
  function o(t) {
    t === void 0 && (t = null), this.type = MASK_TYPES.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = settings.FILTER_MULTISAMPLE, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;
  }
  return Object.defineProperty(o.prototype, "filter", {
    /**
     * The sprite mask filter.
     * If set to `null`, the default sprite mask filter is used.
     * @default null
     */
    get: function() {
      return this._filters ? this._filters[0] : null;
    },
    set: function(t) {
      t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.reset = function() {
    this.pooled && (this.maskObject = null, this.type = MASK_TYPES.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;
  }, o.prototype.copyCountersOrReset = function(t) {
    t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
  }, o;
}();
function compileShader(o, t, e) {
  var r = o.createShader(t);
  return o.shaderSource(r, e), o.compileShader(r), r;
}
function logPrettyShaderError(o, t) {
  var e = o.getShaderSource(t).split(`
`).map(function($, U) {
    return U + ": " + $;
  }), r = o.getShaderInfoLog(t), S = r.split(`
`), T = {}, D = S.map(function($) {
    return parseFloat($.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
  }).filter(function($) {
    return $ && !T[$] ? (T[$] = !0, !0) : !1;
  }), N = [""];
  D.forEach(function($) {
    e[$ - 1] = "%c" + e[$ - 1] + "%c", N.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  var B = e.join(`
`);
  N[0] = B, console.error(r), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, N), console.groupEnd();
}
function logProgramError(o, t, e, r) {
  o.getProgramParameter(t, o.LINK_STATUS) || (o.getShaderParameter(e, o.COMPILE_STATUS) || logPrettyShaderError(o, e), o.getShaderParameter(r, o.COMPILE_STATUS) || logPrettyShaderError(o, r), console.error("PixiJS Error: Could not initialize shader."), o.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", o.getProgramInfoLog(t)));
}
function booleanArray(o) {
  for (var t = new Array(o), e = 0; e < t.length; e++)
    t[e] = !1;
  return t;
}
function defaultValue(o, t) {
  switch (o) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * t);
    case "vec3":
      return new Float32Array(3 * t);
    case "vec4":
      return new Float32Array(4 * t);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * t);
    case "ivec3":
      return new Int32Array(3 * t);
    case "ivec4":
      return new Int32Array(4 * t);
    case "uvec2":
      return new Uint32Array(2 * t);
    case "uvec3":
      return new Uint32Array(3 * t);
    case "uvec4":
      return new Uint32Array(4 * t);
    case "bool":
      return !1;
    case "bvec2":
      return booleanArray(2 * t);
    case "bvec3":
      return booleanArray(3 * t);
    case "bvec4":
      return booleanArray(4 * t);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var unknownContext = {}, context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context && context.isContextLost()) {
    var o = settings.ADAPTER.createCanvas(), t = void 0;
    settings.PREFER_ENV >= ENV.WEBGL2 && (t = o.getContext("webgl2", {})), t || (t = o.getContext("webgl", {}) || o.getContext("experimental-webgl", {}), t ? t.getExtension("WEBGL_draw_buffers") : t = null), context = t;
  }
  return context;
}
var maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION.MEDIUM;
    var o = getTestContext();
    if (o && o.getShaderPrecisionFormat) {
      var t = o.getShaderPrecisionFormat(o.FRAGMENT_SHADER, o.HIGH_FLOAT);
      maxFragmentPrecision = t.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
    }
  }
  return maxFragmentPrecision;
}
function setPrecision(o, t, e) {
  if (o.substring(0, 9) !== "precision") {
    var r = t;
    return t === PRECISION.HIGH && e !== PRECISION.HIGH && (r = PRECISION.MEDIUM), "precision " + r + ` float;
` + o;
  } else if (e !== PRECISION.HIGH && o.substring(0, 15) === "precision highp")
    return o.replace("precision highp", "precision mediump");
  return o;
}
var GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(o) {
  return GLSL_TO_SIZE[o];
}
var GL_TABLE = null, GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(o, t) {
  if (!GL_TABLE) {
    var e = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (var r = 0; r < e.length; ++r) {
      var S = e[r];
      GL_TABLE[o[S]] = GL_TO_GLSL_TYPES[S];
    }
  }
  return GL_TABLE[t];
}
var uniformParsers = [
  // a float cache layer
  {
    test: function(o) {
      return o.type === "float" && o.size === 1 && !o.isArray;
    },
    code: function(o) {
      return `
            if(uv["` + o + '"] !== ud["' + o + `"].value)
            {
                ud["` + o + '"].value = uv["' + o + `"]
                gl.uniform1f(ud["` + o + '"].location, uv["' + o + `"])
            }
            `;
    }
  },
  // handling samplers
  {
    test: function(o, t) {
      return (o.type === "sampler2D" || o.type === "samplerCube" || o.type === "sampler2DArray") && o.size === 1 && !o.isArray && (t == null || t.castToBaseTexture !== void 0);
    },
    code: function(o) {
      return `t = syncData.textureCount++;

            renderer.texture.bind(uv["` + o + `"], t);

            if(ud["` + o + `"].value !== t)
            {
                ud["` + o + `"].value = t;
                gl.uniform1i(ud["` + o + `"].location, t);
; // eslint-disable-line max-len
            }`;
    }
  },
  // uploading pixi matrix object to mat3
  {
    test: function(o, t) {
      return o.type === "mat3" && o.size === 1 && !o.isArray && t.a !== void 0;
    },
    code: function(o) {
      return `
            gl.uniformMatrix3fv(ud["` + o + '"].location, false, uv["' + o + `"].toArray(true));
            `;
    },
    codeUbo: function(o) {
      return `
                var ` + o + "_matrix = uv." + o + `.toArray(true);

                data[offset] = ` + o + `_matrix[0];
                data[offset+1] = ` + o + `_matrix[1];
                data[offset+2] = ` + o + `_matrix[2];
        
                data[offset + 4] = ` + o + `_matrix[3];
                data[offset + 5] = ` + o + `_matrix[4];
                data[offset + 6] = ` + o + `_matrix[5];
        
                data[offset + 8] = ` + o + `_matrix[6];
                data[offset + 9] = ` + o + `_matrix[7];
                data[offset + 10] = ` + o + `_matrix[8];
            `;
    }
  },
  // uploading a pixi point as a vec2 with caching layer
  {
    test: function(o, t) {
      return o.type === "vec2" && o.size === 1 && !o.isArray && t.x !== void 0;
    },
    code: function(o) {
      return `
                cv = ud["` + o + `"].value;
                v = uv["` + o + `"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["` + o + `"].location, v.x, v.y);
                }`;
    },
    codeUbo: function(o) {
      return `
                v = uv.` + o + `;

                data[offset] = v.x;
                data[offset+1] = v.y;
            `;
    }
  },
  // caching layer for a vec2
  {
    test: function(o) {
      return o.type === "vec2" && o.size === 1 && !o.isArray;
    },
    code: function(o) {
      return `
                cv = ud["` + o + `"].value;
                v = uv["` + o + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["` + o + `"].location, v[0], v[1]);
                }
            `;
    }
  },
  // upload a pixi rectangle as a vec4 with caching layer
  {
    test: function(o, t) {
      return o.type === "vec4" && o.size === 1 && !o.isArray && t.width !== void 0;
    },
    code: function(o) {
      return `
                cv = ud["` + o + `"].value;
                v = uv["` + o + `"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["` + o + `"].location, v.x, v.y, v.width, v.height)
                }`;
    },
    codeUbo: function(o) {
      return `
                    v = uv.` + o + `;

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `;
    }
  },
  // a caching layer for vec4 uploading
  {
    test: function(o) {
      return o.type === "vec4" && o.size === 1 && !o.isArray;
    },
    code: function(o) {
      return `
                cv = ud["` + o + `"].value;
                v = uv["` + o + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["` + o + `"].location, v[0], v[1], v[2], v[3])
                }`;
    }
  }
], GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
}, GLSL_TO_ARRAY_SETTERS = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(o, t) {
  var e, r = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (var S in o.uniforms) {
    var T = t[S];
    if (!T) {
      !((e = o.uniforms[S]) === null || e === void 0) && e.group && (o.uniforms[S].ubo ? r.push(`
                        renderer.shader.syncUniformBufferGroup(uv.` + S + ", '" + S + `');
                    `) : r.push(`
                        renderer.shader.syncUniformGroup(uv.` + S + `, syncData);
                    `));
      continue;
    }
    for (var D = o.uniforms[S], N = !1, B = 0; B < uniformParsers.length; B++)
      if (uniformParsers[B].test(T, D)) {
        r.push(uniformParsers[B].code(S, D)), N = !0;
        break;
      }
    if (!N) {
      var $ = T.size === 1 && !T.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS, U = $[T.type].replace("location", 'ud["' + S + '"].location');
      r.push(`
            cu = ud["` + S + `"];
            cv = cu.value;
            v = uv["` + S + `"];
            ` + U + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", r.join(`
`));
}
var fragTemplate$1 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function generateIfTestSrc(o) {
  for (var t = "", e = 0; e < o; ++e)
    e > 0 && (t += `
else `), e < o - 1 && (t += "if(test == " + e + ".0){}");
  return t;
}
function checkMaxIfStatementsInShader(o, t) {
  if (o === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  for (var e = t.createShader(t.FRAGMENT_SHADER); ; ) {
    var r = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(o));
    if (t.shaderSource(e, r), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))
      o = o / 2 | 0;
    else
      break;
  }
  return o;
}
var unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval == "boolean")
    return unsafeEval;
  try {
    var o = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = o({ a: "b" }, "a", "b") === !0;
  } catch {
    unsafeEval = !1;
  }
  return unsafeEval;
}
var defaultFragment$2 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`, defaultVertex$3 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`, UID$1 = 0, nameCache = {}, Program = function() {
  function o(t, e, r) {
    r === void 0 && (r = "pixi-shader"), this.id = UID$1++, this.vertexSrc = t || o.defaultVertexSrc, this.fragmentSrc = e || o.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== "#version" && (r = r.replace(/\s+/g, "-"), nameCache[r] ? (nameCache[r]++, r += "-" + nameCache[r]) : nameCache[r] = 1, this.vertexSrc = "#define SHADER_NAME " + r + `
` + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + r + `
` + this.fragmentSrc, this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION.HIGH), this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision())), this.glPrograms = {}, this.syncUniforms = null;
  }
  return Object.defineProperty(o, "defaultVertexSrc", {
    /**
     * The default vertex shader source.
     * @constant
     */
    get: function() {
      return defaultVertex$3;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "defaultFragmentSrc", {
    /**
     * The default fragment shader source.
     * @constant
     */
    get: function() {
      return defaultFragment$2;
    },
    enumerable: !1,
    configurable: !0
  }), o.from = function(t, e, r) {
    var S = t + e, T = ProgramCache[S];
    return T || (ProgramCache[S] = T = new o(t, e, r)), T;
  }, o;
}(), Shader = function() {
  function o(t, e) {
    this.uniformBindCount = 0, this.program = t, e ? e instanceof UniformGroup ? this.uniformGroup = e : this.uniformGroup = new UniformGroup(e) : this.uniformGroup = new UniformGroup({}), this.disposeRunner = new Runner("disposeShader");
  }
  return o.prototype.checkUniformExists = function(t, e) {
    if (e.uniforms[t])
      return !0;
    for (var r in e.uniforms) {
      var S = e.uniforms[r];
      if (S.group && this.checkUniformExists(t, S))
        return !0;
    }
    return !1;
  }, o.prototype.destroy = function() {
    this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();
  }, Object.defineProperty(o.prototype, "uniforms", {
    /**
     * Shader uniform values, shortcut for `uniformGroup.uniforms`.
     * @readonly
     */
    get: function() {
      return this.uniformGroup.uniforms;
    },
    enumerable: !1,
    configurable: !0
  }), o.from = function(t, e, r) {
    var S = Program.from(t, e);
    return new o(S, r);
  }, o;
}(), BLEND$1 = 0, OFFSET$1 = 1, CULLING$1 = 2, DEPTH_TEST$1 = 3, WINDING$1 = 4, DEPTH_MASK$1 = 5, State = function() {
  function o() {
    this.data = 0, this.blendMode = BLEND_MODES.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;
  }
  return Object.defineProperty(o.prototype, "blend", {
    /**
     * Activates blending of the computed fragment color values.
     * @default true
     */
    get: function() {
      return !!(this.data & 1 << BLEND$1);
    },
    set: function(t) {
      !!(this.data & 1 << BLEND$1) !== t && (this.data ^= 1 << BLEND$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "offsets", {
    /**
     * Activates adding an offset to depth values of polygon's fragments
     * @default false
     */
    get: function() {
      return !!(this.data & 1 << OFFSET$1);
    },
    set: function(t) {
      !!(this.data & 1 << OFFSET$1) !== t && (this.data ^= 1 << OFFSET$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "culling", {
    /**
     * Activates culling of polygons.
     * @default false
     */
    get: function() {
      return !!(this.data & 1 << CULLING$1);
    },
    set: function(t) {
      !!(this.data & 1 << CULLING$1) !== t && (this.data ^= 1 << CULLING$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "depthTest", {
    /**
     * Activates depth comparisons and updates to the depth buffer.
     * @default false
     */
    get: function() {
      return !!(this.data & 1 << DEPTH_TEST$1);
    },
    set: function(t) {
      !!(this.data & 1 << DEPTH_TEST$1) !== t && (this.data ^= 1 << DEPTH_TEST$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "depthMask", {
    /**
     * Enables or disables writing to the depth buffer.
     * @default true
     */
    get: function() {
      return !!(this.data & 1 << DEPTH_MASK$1);
    },
    set: function(t) {
      !!(this.data & 1 << DEPTH_MASK$1) !== t && (this.data ^= 1 << DEPTH_MASK$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "clockwiseFrontFace", {
    /**
     * Specifies whether or not front or back-facing polygons can be culled.
     * @default false
     */
    get: function() {
      return !!(this.data & 1 << WINDING$1);
    },
    set: function(t) {
      !!(this.data & 1 << WINDING$1) !== t && (this.data ^= 1 << WINDING$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "blendMode", {
    /**
     * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get: function() {
      return this._blendMode;
    },
    set: function(t) {
      this.blend = t !== BLEND_MODES.NONE, this._blendMode = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "polygonOffset", {
    /**
     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
     * @default 0
     */
    get: function() {
      return this._polygonOffset;
    },
    set: function(t) {
      this.offsets = !!t, this._polygonOffset = t;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.toString = function() {
    return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
  }, o.for2d = function() {
    var t = new o();
    return t.depthTest = !1, t.blend = !0, t;
  }, o;
}(), defaultFragment$1 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`, defaultVertex$2 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, Filter = function(o) {
  __extends$p(t, o);
  function t(e, r, S) {
    var T = this, D = Program.from(e || t.defaultVertexSrc, r || t.defaultFragmentSrc);
    return T = o.call(this, D, S) || this, T.padding = 0, T.resolution = settings.FILTER_RESOLUTION, T.multisample = settings.FILTER_MULTISAMPLE, T.enabled = !0, T.autoFit = !0, T.state = new State(), T;
  }
  return t.prototype.apply = function(e, r, S, T, D) {
    e.applyFilter(this, r, S, T);
  }, Object.defineProperty(t.prototype, "blendMode", {
    /**
     * Sets the blend mode of the filter.
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get: function() {
      return this.state.blendMode;
    },
    set: function(e) {
      this.state.blendMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "resolution", {
    /**
     * The resolution of the filter. Setting this to be lower will lower the quality but
     * increase the performance of the filter.
     */
    get: function() {
      return this._resolution;
    },
    set: function(e) {
      this._resolution = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t, "defaultVertexSrc", {
    /**
     * The default vertex shader source
     * @constant
     */
    get: function() {
      return defaultVertex$2;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t, "defaultFragmentSrc", {
    /**
     * The default fragment shader source
     * @constant
     */
    get: function() {
      return defaultFragment$1;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Shader), vertex$4 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`, fragment$7 = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`, tempMat$1 = new Matrix(), TextureMatrix = function() {
  function o(t, e) {
    this._texture = t, this.mapCoord = new Matrix(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof e > "u" ? 0.5 : e, this.isSimple = !1;
  }
  return Object.defineProperty(o.prototype, "texture", {
    /** Texture property. */
    get: function() {
      return this._texture;
    },
    set: function(t) {
      this._texture = t, this._textureID = -1;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.multiplyUvs = function(t, e) {
    e === void 0 && (e = t);
    for (var r = this.mapCoord, S = 0; S < t.length; S += 2) {
      var T = t[S], D = t[S + 1];
      e[S] = T * r.a + D * r.c + r.tx, e[S + 1] = T * r.b + D * r.d + r.ty;
    }
    return e;
  }, o.prototype.update = function(t) {
    var e = this._texture;
    if (!e || !e.valid || !t && this._textureID === e._updateID)
      return !1;
    this._textureID = e._updateID, this._updateID++;
    var r = e._uvs;
    this.mapCoord.set(r.x1 - r.x0, r.y1 - r.y0, r.x3 - r.x0, r.y3 - r.y0, r.x0, r.y0);
    var S = e.orig, T = e.trim;
    T && (tempMat$1.set(S.width / T.width, 0, 0, S.height / T.height, -T.x / T.width, -T.y / T.height), this.mapCoord.append(tempMat$1));
    var D = e.baseTexture, N = this.uClampFrame, B = this.clampMargin / D.resolution, $ = this.clampOffset;
    return N[0] = (e._frame.x + B + $) / D.width, N[1] = (e._frame.y + B + $) / D.height, N[2] = (e._frame.x + e._frame.width - B + $) / D.width, N[3] = (e._frame.y + e._frame.height - B + $) / D.height, this.uClampOffset[0] = $ / D.realWidth, this.uClampOffset[1] = $ / D.realHeight, this.isSimple = e._frame.width === D.width && e._frame.height === D.height && e.rotate === 0, !0;
  }, o;
}(), SpriteMaskFilter = function(o) {
  __extends$p(t, o);
  function t(e, r, S) {
    var T = this, D = null;
    return typeof e != "string" && r === void 0 && S === void 0 && (D = e, e = void 0, r = void 0, S = void 0), T = o.call(this, e || vertex$4, r || fragment$7, S) || this, T.maskSprite = D, T.maskMatrix = new Matrix(), T;
  }
  return Object.defineProperty(t.prototype, "maskSprite", {
    /**
     * Sprite mask
     * @type {PIXI.DisplayObject}
     */
    get: function() {
      return this._maskSprite;
    },
    set: function(e) {
      this._maskSprite = e, this._maskSprite && (this._maskSprite.renderable = !1);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.apply = function(e, r, S, T) {
    var D = this._maskSprite, N = D._texture;
    N.valid && (N.uvMatrix || (N.uvMatrix = new TextureMatrix(N, 0)), N.uvMatrix.update(), this.uniforms.npmAlpha = N.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = N, this.uniforms.otherMatrix = e.calculateSpriteMatrix(this.maskMatrix, D).prepend(N.uvMatrix.mapCoord), this.uniforms.alpha = D.worldAlpha, this.uniforms.maskClamp = N.uvMatrix.uClampFrame, e.applyFilter(this, r, S, T));
  }, t;
}(Filter), MaskSystem = function() {
  function o(t) {
    this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
  }
  return o.prototype.setMaskStack = function(t) {
    this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t);
  }, o.prototype.push = function(t, e) {
    var r = e;
    if (!r.isMaskData) {
      var S = this.maskDataPool.pop() || new MaskData();
      S.pooled = !0, S.maskObject = e, r = S;
    }
    var T = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    if (r.copyCountersOrReset(T), r._colorMask = T ? T._colorMask : 15, r.autoDetect && this.detect(r), r._target = t, r.type !== MASK_TYPES.SPRITE && this.maskStack.push(r), r.enabled)
      switch (r.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.push(r);
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.push(r);
          break;
        case MASK_TYPES.SPRITE:
          r.copyCountersOrReset(null), this.pushSpriteMask(r);
          break;
        case MASK_TYPES.COLOR:
          this.pushColorMask(r);
          break;
      }
    r.type === MASK_TYPES.SPRITE && this.maskStack.push(r);
  }, o.prototype.pop = function(t) {
    var e = this.maskStack.pop();
    if (!(!e || e._target !== t)) {
      if (e.enabled)
        switch (e.type) {
          case MASK_TYPES.SCISSOR:
            this.renderer.scissor.pop(e);
            break;
          case MASK_TYPES.STENCIL:
            this.renderer.stencil.pop(e.maskObject);
            break;
          case MASK_TYPES.SPRITE:
            this.popSpriteMask(e);
            break;
          case MASK_TYPES.COLOR:
            this.popColorMask(e);
            break;
        }
      if (e.reset(), e.pooled && this.maskDataPool.push(e), this.maskStack.length !== 0) {
        var r = this.maskStack[this.maskStack.length - 1];
        r.type === MASK_TYPES.SPRITE && r._filters && (r._filters[0].maskSprite = r.maskObject);
      }
    }
  }, o.prototype.detect = function(t) {
    var e = t.maskObject;
    e ? e.isSprite ? t.type = MASK_TYPES.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = MASK_TYPES.SCISSOR : t.type = MASK_TYPES.STENCIL : t.type = MASK_TYPES.COLOR;
  }, o.prototype.pushSpriteMask = function(t) {
    var e, r, S = t.maskObject, T = t._target, D = t._filters;
    D || (D = this.alphaMaskPool[this.alphaMaskIndex], D || (D = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()]));
    var N = this.renderer, B = N.renderTexture, $, U;
    if (B.current) {
      var H = B.current;
      $ = t.resolution || H.resolution, U = (e = t.multisample) !== null && e !== void 0 ? e : H.multisample;
    } else
      $ = t.resolution || N.resolution, U = (r = t.multisample) !== null && r !== void 0 ? r : N.multisample;
    D[0].resolution = $, D[0].multisample = U, D[0].maskSprite = S;
    var V = T.filterArea;
    T.filterArea = S.getBounds(!0), N.filter.push(T, D), T.filterArea = V, t._filters || this.alphaMaskIndex++;
  }, o.prototype.popSpriteMask = function(t) {
    this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
  }, o.prototype.pushColorMask = function(t) {
    var e = t._colorMask, r = t._colorMask = e & t.colorMask;
    r !== e && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0);
  }, o.prototype.popColorMask = function(t) {
    var e = t._colorMask, r = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
    r !== e && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0);
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}(), AbstractMaskSystem = function() {
  function o(t) {
    this.renderer = t, this.maskStack = [], this.glConst = 0;
  }
  return o.prototype.getStackLength = function() {
    return this.maskStack.length;
  }, o.prototype.setMaskStack = function(t) {
    var e = this.renderer.gl, r = this.getStackLength();
    this.maskStack = t;
    var S = this.getStackLength();
    S !== r && (S === 0 ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()));
  }, o.prototype._useCurrent = function() {
  }, o.prototype.destroy = function() {
    this.renderer = null, this.maskStack = null;
  }, o;
}(), tempMatrix$1 = new Matrix(), rectPool = [], ScissorSystem = function(o) {
  __extends$p(t, o);
  function t(e) {
    var r = o.call(this, e) || this;
    return r.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST, r;
  }
  return t.prototype.getStackLength = function() {
    var e = this.maskStack[this.maskStack.length - 1];
    return e ? e._scissorCounter : 0;
  }, t.prototype.calcScissorRect = function(e) {
    var r;
    if (!e._scissorRectLocal) {
      var S = e._scissorRect, T = e.maskObject, D = this.renderer, N = D.renderTexture, B = T.getBounds(!0, (r = rectPool.pop()) !== null && r !== void 0 ? r : new Rectangle());
      this.roundFrameToPixels(B, N.current ? N.current.resolution : D.resolution, N.sourceFrame, N.destinationFrame, D.projection.transform), S && B.fit(S), e._scissorRectLocal = B;
    }
  }, t.isMatrixRotated = function(e) {
    if (!e)
      return !1;
    var r = e.a, S = e.b, T = e.c, D = e.d;
    return (Math.abs(S) > 1e-4 || Math.abs(T) > 1e-4) && (Math.abs(r) > 1e-4 || Math.abs(D) > 1e-4);
  }, t.prototype.testScissor = function(e) {
    var r = e.maskObject;
    if (!r.isFastRect || !r.isFastRect() || t.isMatrixRotated(r.worldTransform) || t.isMatrixRotated(this.renderer.projection.transform))
      return !1;
    this.calcScissorRect(e);
    var S = e._scissorRectLocal;
    return S.width > 0 && S.height > 0;
  }, t.prototype.roundFrameToPixels = function(e, r, S, T, D) {
    t.isMatrixRotated(D) || (D = D ? tempMatrix$1.copyFrom(D) : tempMatrix$1.identity(), D.translate(-S.x, -S.y).scale(T.width / S.width, T.height / S.height).translate(T.x, T.y), this.renderer.filter.transformAABB(D, e), e.fit(T), e.x = Math.round(e.x * r), e.y = Math.round(e.y * r), e.width = Math.round(e.width * r), e.height = Math.round(e.height * r));
  }, t.prototype.push = function(e) {
    e._scissorRectLocal || this.calcScissorRect(e);
    var r = this.renderer.gl;
    e._scissorRect || r.enable(r.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent();
  }, t.prototype.pop = function(e) {
    var r = this.renderer.gl;
    e && rectPool.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : r.disable(r.SCISSOR_TEST);
  }, t.prototype._useCurrent = function() {
    var e = this.maskStack[this.maskStack.length - 1]._scissorRect, r;
    this.renderer.renderTexture.current ? r = e.y : r = this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, r, e.width, e.height);
  }, t;
}(AbstractMaskSystem), StencilSystem = function(o) {
  __extends$p(t, o);
  function t(e) {
    var r = o.call(this, e) || this;
    return r.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST, r;
  }
  return t.prototype.getStackLength = function() {
    var e = this.maskStack[this.maskStack.length - 1];
    return e ? e._stencilCounter : 0;
  }, t.prototype.push = function(e) {
    var r = e.maskObject, S = this.renderer.gl, T = e._stencilCounter;
    T === 0 && (this.renderer.framebuffer.forceStencil(), S.clearStencil(0), S.clear(S.STENCIL_BUFFER_BIT), S.enable(S.STENCIL_TEST)), e._stencilCounter++;
    var D = e._colorMask;
    D !== 0 && (e._colorMask = 0, S.colorMask(!1, !1, !1, !1)), S.stencilFunc(S.EQUAL, T, 4294967295), S.stencilOp(S.KEEP, S.KEEP, S.INCR), r.renderable = !0, r.render(this.renderer), this.renderer.batch.flush(), r.renderable = !1, D !== 0 && (e._colorMask = D, S.colorMask((D & 1) !== 0, (D & 2) !== 0, (D & 4) !== 0, (D & 8) !== 0)), this._useCurrent();
  }, t.prototype.pop = function(e) {
    var r = this.renderer.gl;
    if (this.getStackLength() === 0)
      r.disable(r.STENCIL_TEST);
    else {
      var S = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, T = S ? S._colorMask : 15;
      T !== 0 && (S._colorMask = 0, r.colorMask(!1, !1, !1, !1)), r.stencilOp(r.KEEP, r.KEEP, r.DECR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, T !== 0 && (S._colorMask = T, r.colorMask((T & 1) !== 0, (T & 2) !== 0, (T & 4) !== 0, (T & 8) !== 0)), this._useCurrent();
    }
  }, t.prototype._useCurrent = function() {
    var e = this.renderer.gl;
    e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP);
  }, t;
}(AbstractMaskSystem), ProjectionSystem = function() {
  function o(t) {
    this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Matrix(), this.transform = null;
  }
  return o.prototype.update = function(t, e, r, S) {
    this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, r, S), this.transform && this.projectionMatrix.append(this.transform);
    var T = this.renderer;
    T.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, T.globalUniforms.update(), T.shader.shader && T.shader.syncUniformGroup(T.shader.shader.uniforms.globals);
  }, o.prototype.calculateProjection = function(t, e, r, S) {
    var T = this.projectionMatrix, D = S ? -1 : 1;
    T.identity(), T.a = 1 / e.width * 2, T.d = D * (1 / e.height * 2), T.tx = -1 - e.x * T.a, T.ty = -D - e.y * T.d;
  }, o.prototype.setTransform = function(t) {
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}(), tempRect = new Rectangle(), tempRect2 = new Rectangle(), RenderTextureSystem = function() {
  function o(t) {
    this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.viewportFrame = new Rectangle();
  }
  return o.prototype.bind = function(t, e, r) {
    t === void 0 && (t = null);
    var S = this.renderer;
    this.current = t;
    var T, D, N;
    t ? (T = t.baseTexture, N = T.resolution, e || (tempRect.width = t.frame.width, tempRect.height = t.frame.height, e = tempRect), r || (tempRect2.x = t.frame.x, tempRect2.y = t.frame.y, tempRect2.width = e.width, tempRect2.height = e.height, r = tempRect2), D = T.framebuffer) : (N = S.resolution, e || (tempRect.width = S.screen.width, tempRect.height = S.screen.height, e = tempRect), r || (r = tempRect, r.width = e.width, r.height = e.height));
    var B = this.viewportFrame;
    B.x = r.x * N, B.y = r.y * N, B.width = r.width * N, B.height = r.height * N, t || (B.y = S.view.height - (B.y + B.height)), B.ceil(), this.renderer.framebuffer.bind(D, B), this.renderer.projection.update(r, e, N, !D), t ? this.renderer.mask.setMaskStack(T.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(r);
  }, o.prototype.clear = function(t, e) {
    this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.clearColor;
    var r = this.destinationFrame, S = this.current ? this.current.baseTexture : this.renderer.screen, T = r.width !== S.width || r.height !== S.height;
    if (T) {
      var D = this.viewportFrame, N = D.x, B = D.y, $ = D.width, U = D.height;
      N = Math.round(N), B = Math.round(B), $ = Math.round($), U = Math.round(U), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(N, B, $, U);
    }
    this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), T && this.renderer.scissor.pop();
  }, o.prototype.resize = function() {
    this.bind(null);
  }, o.prototype.reset = function() {
    this.bind(null);
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}();
function uboUpdate(o, t, e, r, S) {
  e.buffer.update(S);
}
var UBO_TO_SINGLE_SETTERS = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}, GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(o) {
  for (var t = o.map(function(B) {
    return {
      data: B,
      offset: 0,
      dataLen: 0,
      dirty: 0
    };
  }), e = 0, r = 0, S = 0, T = 0; T < t.length; T++) {
    var D = t[T];
    if (e = GLSL_TO_STD40_SIZE[D.data.type], D.data.size > 1 && (e = Math.max(e, 16) * D.data.size), D.dataLen = e, r % e !== 0 && r < 16) {
      var N = r % e % 16;
      r += N, S += N;
    }
    r + e > 16 ? (S = Math.ceil(S / 16) * 16, D.offset = S, S += e, r = e) : (D.offset = S, r += e, S += e);
  }
  return S = Math.ceil(S / 16) * 16, { uboElements: t, size: S };
}
function getUBOData(o, t) {
  var e = [];
  for (var r in o)
    t[r] && e.push(t[r]);
  return e.sort(function(S, T) {
    return S.index - T.index;
  }), e;
}
function generateUniformBufferSync(o, t) {
  if (!o.autoManage)
    return { size: 0, syncFunc: uboUpdate };
  for (var e = getUBOData(o.uniforms, t), r = createUBOElements(e), S = r.uboElements, T = r.size, D = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `], N = 0; N < S.length; N++) {
    for (var B = S[N], $ = o.uniforms[B.data.name], U = B.data.name, H = !1, V = 0; V < uniformParsers.length; V++) {
      var X = uniformParsers[V];
      if (X.codeUbo && X.test(B.data, $)) {
        D.push("offset = " + B.offset / 4 + ";", uniformParsers[V].codeUbo(B.data.name, $)), H = !0;
        break;
      }
    }
    if (!H)
      if (B.data.size > 1) {
        var W = mapSize(B.data.type), Y = Math.max(GLSL_TO_STD40_SIZE[B.data.type] / 16, 1), q = W / Y, K = (4 - q % 4) % 4;
        D.push(`
                cv = ud.` + U + `.value;
                v = uv.` + U + `;
                offset = ` + B.offset / 4 + `;

                t = 0;

                for(var i=0; i < ` + B.data.size * Y + `; i++)
                {
                    for(var j = 0; j < ` + q + `; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ` + K + `;
                }

                `);
      } else {
        var Z = UBO_TO_SINGLE_SETTERS[B.data.type];
        D.push(`
                cv = ud.` + U + `.value;
                v = uv.` + U + `;
                offset = ` + B.offset / 4 + `;
                ` + Z + `;
                `);
      }
  }
  return D.push(`
       renderer.buffer.update(buffer);
    `), {
    size: T,
    // eslint-disable-next-line no-new-func
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", D.join(`
`))
  };
}
var IGLUniformData = function() {
  function o() {
  }
  return o;
}(), GLProgram = function() {
  function o(t, e) {
    this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
  }
  return o.prototype.destroy = function() {
    this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
  }, o;
}();
function getAttributeData(o, t) {
  for (var e = {}, r = t.getProgramParameter(o, t.ACTIVE_ATTRIBUTES), S = 0; S < r; S++) {
    var T = t.getActiveAttrib(o, S);
    if (T.name.indexOf("gl_") !== 0) {
      var D = mapType(t, T.type), N = {
        type: D,
        name: T.name,
        size: mapSize(D),
        location: t.getAttribLocation(o, T.name)
      };
      e[T.name] = N;
    }
  }
  return e;
}
function getUniformData(o, t) {
  for (var e = {}, r = t.getProgramParameter(o, t.ACTIVE_UNIFORMS), S = 0; S < r; S++) {
    var T = t.getActiveUniform(o, S), D = T.name.replace(/\[.*?\]$/, ""), N = !!T.name.match(/\[.*?\]$/), B = mapType(t, T.type);
    e[D] = {
      name: D,
      index: S,
      type: B,
      size: T.size,
      isArray: N,
      value: defaultValue(B, T.size)
    };
  }
  return e;
}
function generateProgram(o, t) {
  var e = compileShader(o, o.VERTEX_SHADER, t.vertexSrc), r = compileShader(o, o.FRAGMENT_SHADER, t.fragmentSrc), S = o.createProgram();
  if (o.attachShader(S, e), o.attachShader(S, r), o.linkProgram(S), o.getProgramParameter(S, o.LINK_STATUS) || logProgramError(o, S, e, r), t.attributeData = getAttributeData(S, o), t.uniformData = getUniformData(S, o), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc)) {
    var T = Object.keys(t.attributeData);
    T.sort(function(U, H) {
      return U > H ? 1 : -1;
    });
    for (var D = 0; D < T.length; D++)
      t.attributeData[T[D]].location = D, o.bindAttribLocation(S, D, T[D]);
    o.linkProgram(S);
  }
  o.deleteShader(e), o.deleteShader(r);
  var N = {};
  for (var D in t.uniformData) {
    var B = t.uniformData[D];
    N[D] = {
      location: o.getUniformLocation(S, D),
      value: defaultValue(B.type, B.size)
    };
  }
  var $ = new GLProgram(S, N);
  return $;
}
var UID = 0, defaultSyncData = { textureCount: 0, uboCount: 0 }, ShaderSystem = function() {
  function o(t) {
    this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = UID++;
  }
  return o.prototype.systemCheck = function() {
    if (!unsafeEvalSupported())
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
  }, o.prototype.contextChange = function(t) {
    this.gl = t, this.reset();
  }, o.prototype.bind = function(t, e) {
    t.disposeRunner.add(this), t.uniforms.globals = this.renderer.globalUniforms;
    var r = t.program, S = r.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
    return this.shader = t, this.program !== r && (this.program = r, this.gl.useProgram(S.program)), e || (defaultSyncData.textureCount = 0, defaultSyncData.uboCount = 0, this.syncUniformGroup(t.uniformGroup, defaultSyncData)), S;
  }, o.prototype.setUniforms = function(t) {
    var e = this.shader.program, r = e.glPrograms[this.renderer.CONTEXT_UID];
    e.syncUniforms(r.uniformData, t, this.renderer);
  }, o.prototype.syncUniformGroup = function(t, e) {
    var r = this.getGlProgram();
    (!t.static || t.dirtyId !== r.uniformDirtyGroups[t.id]) && (r.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, r, e));
  }, o.prototype.syncUniforms = function(t, e, r) {
    var S = t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t);
    S(e.uniformData, t.uniforms, this.renderer, r);
  }, o.prototype.createSyncGroups = function(t) {
    var e = this.getSignature(t, this.shader.program.uniformData, "u");
    return this.cache[e] || (this.cache[e] = generateUniformsSync(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id];
  }, o.prototype.syncUniformBufferGroup = function(t, e) {
    var r = this.getGlProgram();
    if (!t.static || t.dirtyId !== 0 || !r.uniformGroups[t.id]) {
      t.dirtyId = 0;
      var S = r.uniformGroups[t.id] || this.createSyncBufferGroup(t, r, e);
      t.buffer.update(), S(r.uniformData, t.uniforms, this.renderer, defaultSyncData, t.buffer);
    }
    this.renderer.buffer.bindBufferBase(t.buffer, r.uniformBufferBindings[e]);
  }, o.prototype.createSyncBufferGroup = function(t, e, r) {
    var S = this.renderer.gl;
    this.renderer.buffer.bind(t.buffer);
    var T = this.gl.getUniformBlockIndex(e.program, r);
    e.uniformBufferBindings[r] = this.shader.uniformBindCount, S.uniformBlockBinding(e.program, T, this.shader.uniformBindCount), this.shader.uniformBindCount++;
    var D = this.getSignature(t, this.shader.program.uniformData, "ubo"), N = this._uboCache[D];
    if (N || (N = this._uboCache[D] = generateUniformBufferSync(t, this.shader.program.uniformData)), t.autoManage) {
      var B = new Float32Array(N.size / 4);
      t.buffer.update(B);
    }
    return e.uniformGroups[t.id] = N.syncFunc, e.uniformGroups[t.id];
  }, o.prototype.getSignature = function(t, e, r) {
    var S = t.uniforms, T = [r + "-"];
    for (var D in S)
      T.push(D), e[D] && T.push(e[D].type);
    return T.join("-");
  }, o.prototype.getGlProgram = function() {
    return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
  }, o.prototype.generateProgram = function(t) {
    var e = this.gl, r = t.program, S = generateProgram(e, r);
    return r.glPrograms[this.renderer.CONTEXT_UID] = S, S;
  }, o.prototype.reset = function() {
    this.program = null, this.shader = null;
  }, o.prototype.disposeShader = function(t) {
    this.shader === t && (this.shader = null);
  }, o.prototype.destroy = function() {
    this.renderer = null, this.destroyed = !0;
  }, o;
}();
function mapWebGLBlendModesToPixi(o, t) {
  return t === void 0 && (t = []), t[BLEND_MODES.NORMAL] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.ADD] = [o.ONE, o.ONE], t[BLEND_MODES.MULTIPLY] = [o.DST_COLOR, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SCREEN] = [o.ONE, o.ONE_MINUS_SRC_COLOR, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.OVERLAY] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DARKEN] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.LIGHTEN] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.COLOR_DODGE] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.COLOR_BURN] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.HARD_LIGHT] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SOFT_LIGHT] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DIFFERENCE] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.EXCLUSION] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.HUE] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SATURATION] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.COLOR] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.LUMINOSITY] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.NONE] = [0, 0], t[BLEND_MODES.NORMAL_NPM] = [o.SRC_ALPHA, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.ADD_NPM] = [o.SRC_ALPHA, o.ONE, o.ONE, o.ONE], t[BLEND_MODES.SCREEN_NPM] = [o.SRC_ALPHA, o.ONE_MINUS_SRC_COLOR, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SRC_IN] = [o.DST_ALPHA, o.ZERO], t[BLEND_MODES.SRC_OUT] = [o.ONE_MINUS_DST_ALPHA, o.ZERO], t[BLEND_MODES.SRC_ATOP] = [o.DST_ALPHA, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DST_OVER] = [o.ONE_MINUS_DST_ALPHA, o.ONE], t[BLEND_MODES.DST_IN] = [o.ZERO, o.SRC_ALPHA], t[BLEND_MODES.DST_OUT] = [o.ZERO, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DST_ATOP] = [o.ONE_MINUS_DST_ALPHA, o.SRC_ALPHA], t[BLEND_MODES.XOR] = [o.ONE_MINUS_DST_ALPHA, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SUBTRACT] = [o.ONE, o.ONE, o.ONE, o.ONE, o.FUNC_REVERSE_SUBTRACT, o.FUNC_ADD], t;
}
var BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5, StateSystem = function() {
  function o() {
    this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = BLEND_MODES.NONE, this._blendEq = !1, this.map = [], this.map[BLEND] = this.setBlend, this.map[OFFSET] = this.setOffset, this.map[CULLING] = this.setCullFace, this.map[DEPTH_TEST] = this.setDepthTest, this.map[WINDING] = this.setFrontFace, this.map[DEPTH_MASK] = this.setDepthMask, this.checks = [], this.defaultState = new State(), this.defaultState.blend = !0;
  }
  return o.prototype.contextChange = function(t) {
    this.gl = t, this.blendModes = mapWebGLBlendModesToPixi(t), this.set(this.defaultState), this.reset();
  }, o.prototype.set = function(t) {
    if (t = t || this.defaultState, this.stateId !== t.data) {
      for (var e = this.stateId ^ t.data, r = 0; e; )
        e & 1 && this.map[r].call(this, !!(t.data & 1 << r)), e = e >> 1, r++;
      this.stateId = t.data;
    }
    for (var r = 0; r < this.checks.length; r++)
      this.checks[r](this, t);
  }, o.prototype.forceState = function(t) {
    t = t || this.defaultState;
    for (var e = 0; e < this.map.length; e++)
      this.map[e].call(this, !!(t.data & 1 << e));
    for (var e = 0; e < this.checks.length; e++)
      this.checks[e](this, t);
    this.stateId = t.data;
  }, o.prototype.setBlend = function(t) {
    this.updateCheck(o.checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND);
  }, o.prototype.setOffset = function(t) {
    this.updateCheck(o.checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }, o.prototype.setDepthTest = function(t) {
    this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }, o.prototype.setDepthMask = function(t) {
    this.gl.depthMask(t);
  }, o.prototype.setCullFace = function(t) {
    this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE);
  }, o.prototype.setFrontFace = function(t) {
    this.gl.frontFace(this.gl[t ? "CW" : "CCW"]);
  }, o.prototype.setBlendMode = function(t) {
    if (t !== this.blendMode) {
      this.blendMode = t;
      var e = this.blendModes[t], r = this.gl;
      e.length === 2 ? r.blendFunc(e[0], e[1]) : r.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, r.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD));
    }
  }, o.prototype.setPolygonOffset = function(t, e) {
    this.gl.polygonOffset(t, e);
  }, o.prototype.reset = function() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);
  }, o.prototype.updateCheck = function(t, e) {
    var r = this.checks.indexOf(t);
    e && r === -1 ? this.checks.push(t) : !e && r !== -1 && this.checks.splice(r, 1);
  }, o.checkBlendMode = function(t, e) {
    t.setBlendMode(e.blendMode);
  }, o.checkPolygonOffset = function(t, e) {
    t.setPolygonOffset(1, e.polygonOffset);
  }, o.prototype.destroy = function() {
    this.gl = null;
  }, o;
}(), TextureGCSystem = function() {
  function o(t) {
    this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = settings.GC_MAX_IDLE, this.checkCountMax = settings.GC_MAX_CHECK_COUNT, this.mode = settings.GC_MODE;
  }
  return o.prototype.postrender = function() {
    this.renderer.renderingToScreen && (this.count++, this.mode !== GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
  }, o.prototype.run = function() {
    for (var t = this.renderer.texture, e = t.managedTextures, r = !1, S = 0; S < e.length; S++) {
      var T = e[S];
      !T.framebuffer && this.count - T.touched > this.maxIdle && (t.destroyTexture(T, !0), e[S] = null, r = !0);
    }
    if (r) {
      for (var D = 0, S = 0; S < e.length; S++)
        e[S] !== null && (e[D++] = e[S]);
      e.length = D;
    }
  }, o.prototype.unload = function(t) {
    var e = this.renderer.texture, r = t._texture;
    r && !r.framebuffer && e.destroyTexture(r);
    for (var S = t.children.length - 1; S >= 0; S--)
      this.unload(t.children[S]);
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}();
function mapTypeAndFormatToInternalFormat(o) {
  var t, e, r, S, T, D, N, B, $, U, H, V, X, W, Y, q, K, Z, J, Q, rt, et, nt;
  return "WebGL2RenderingContext" in globalThis && o instanceof globalThis.WebGL2RenderingContext ? nt = (t = {}, t[TYPES.UNSIGNED_BYTE] = (e = {}, e[FORMATS.RGBA] = o.RGBA8, e[FORMATS.RGB] = o.RGB8, e[FORMATS.RG] = o.RG8, e[FORMATS.RED] = o.R8, e[FORMATS.RGBA_INTEGER] = o.RGBA8UI, e[FORMATS.RGB_INTEGER] = o.RGB8UI, e[FORMATS.RG_INTEGER] = o.RG8UI, e[FORMATS.RED_INTEGER] = o.R8UI, e[FORMATS.ALPHA] = o.ALPHA, e[FORMATS.LUMINANCE] = o.LUMINANCE, e[FORMATS.LUMINANCE_ALPHA] = o.LUMINANCE_ALPHA, e), t[TYPES.BYTE] = (r = {}, r[FORMATS.RGBA] = o.RGBA8_SNORM, r[FORMATS.RGB] = o.RGB8_SNORM, r[FORMATS.RG] = o.RG8_SNORM, r[FORMATS.RED] = o.R8_SNORM, r[FORMATS.RGBA_INTEGER] = o.RGBA8I, r[FORMATS.RGB_INTEGER] = o.RGB8I, r[FORMATS.RG_INTEGER] = o.RG8I, r[FORMATS.RED_INTEGER] = o.R8I, r), t[TYPES.UNSIGNED_SHORT] = (S = {}, S[FORMATS.RGBA_INTEGER] = o.RGBA16UI, S[FORMATS.RGB_INTEGER] = o.RGB16UI, S[FORMATS.RG_INTEGER] = o.RG16UI, S[FORMATS.RED_INTEGER] = o.R16UI, S[FORMATS.DEPTH_COMPONENT] = o.DEPTH_COMPONENT16, S), t[TYPES.SHORT] = (T = {}, T[FORMATS.RGBA_INTEGER] = o.RGBA16I, T[FORMATS.RGB_INTEGER] = o.RGB16I, T[FORMATS.RG_INTEGER] = o.RG16I, T[FORMATS.RED_INTEGER] = o.R16I, T), t[TYPES.UNSIGNED_INT] = (D = {}, D[FORMATS.RGBA_INTEGER] = o.RGBA32UI, D[FORMATS.RGB_INTEGER] = o.RGB32UI, D[FORMATS.RG_INTEGER] = o.RG32UI, D[FORMATS.RED_INTEGER] = o.R32UI, D[FORMATS.DEPTH_COMPONENT] = o.DEPTH_COMPONENT24, D), t[TYPES.INT] = (N = {}, N[FORMATS.RGBA_INTEGER] = o.RGBA32I, N[FORMATS.RGB_INTEGER] = o.RGB32I, N[FORMATS.RG_INTEGER] = o.RG32I, N[FORMATS.RED_INTEGER] = o.R32I, N), t[TYPES.FLOAT] = (B = {}, B[FORMATS.RGBA] = o.RGBA32F, B[FORMATS.RGB] = o.RGB32F, B[FORMATS.RG] = o.RG32F, B[FORMATS.RED] = o.R32F, B[FORMATS.DEPTH_COMPONENT] = o.DEPTH_COMPONENT32F, B), t[TYPES.HALF_FLOAT] = ($ = {}, $[FORMATS.RGBA] = o.RGBA16F, $[FORMATS.RGB] = o.RGB16F, $[FORMATS.RG] = o.RG16F, $[FORMATS.RED] = o.R16F, $), t[TYPES.UNSIGNED_SHORT_5_6_5] = (U = {}, U[FORMATS.RGB] = o.RGB565, U), t[TYPES.UNSIGNED_SHORT_4_4_4_4] = (H = {}, H[FORMATS.RGBA] = o.RGBA4, H), t[TYPES.UNSIGNED_SHORT_5_5_5_1] = (V = {}, V[FORMATS.RGBA] = o.RGB5_A1, V), t[TYPES.UNSIGNED_INT_2_10_10_10_REV] = (X = {}, X[FORMATS.RGBA] = o.RGB10_A2, X[FORMATS.RGBA_INTEGER] = o.RGB10_A2UI, X), t[TYPES.UNSIGNED_INT_10F_11F_11F_REV] = (W = {}, W[FORMATS.RGB] = o.R11F_G11F_B10F, W), t[TYPES.UNSIGNED_INT_5_9_9_9_REV] = (Y = {}, Y[FORMATS.RGB] = o.RGB9_E5, Y), t[TYPES.UNSIGNED_INT_24_8] = (q = {}, q[FORMATS.DEPTH_STENCIL] = o.DEPTH24_STENCIL8, q), t[TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV] = (K = {}, K[FORMATS.DEPTH_STENCIL] = o.DEPTH32F_STENCIL8, K), t) : nt = (Z = {}, Z[TYPES.UNSIGNED_BYTE] = (J = {}, J[FORMATS.RGBA] = o.RGBA, J[FORMATS.RGB] = o.RGB, J[FORMATS.ALPHA] = o.ALPHA, J[FORMATS.LUMINANCE] = o.LUMINANCE, J[FORMATS.LUMINANCE_ALPHA] = o.LUMINANCE_ALPHA, J), Z[TYPES.UNSIGNED_SHORT_5_6_5] = (Q = {}, Q[FORMATS.RGB] = o.RGB, Q), Z[TYPES.UNSIGNED_SHORT_4_4_4_4] = (rt = {}, rt[FORMATS.RGBA] = o.RGBA, rt), Z[TYPES.UNSIGNED_SHORT_5_5_5_1] = (et = {}, et[FORMATS.RGBA] = o.RGBA, et), Z), nt;
}
var GLTexture = function() {
  function o(t) {
    this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = TYPES.UNSIGNED_BYTE, this.internalFormat = FORMATS.RGBA, this.samplerType = 0;
  }
  return o;
}(), TextureSystem = function() {
  function o(t) {
    this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new BaseTexture(), this.hasIntegerTextures = !1;
  }
  return o.prototype.contextChange = function() {
    var t = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat(t);
    var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = e;
    for (var r = 0; r < e; r++)
      this.boundTextures[r] = null;
    this.emptyTextures = {};
    var S = new GLTexture(t.createTexture());
    t.bindTexture(t.TEXTURE_2D, S.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = S, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new GLTexture(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
    for (var r = 0; r < 6; r++)
      t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
    t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
    for (var r = 0; r < this.boundTextures.length; r++)
      this.bind(null, r);
  }, o.prototype.bind = function(t, e) {
    e === void 0 && (e = 0);
    var r = this.gl;
    if (t = t == null ? void 0 : t.castToBaseTexture(), t && t.valid && !t.parentTextureArray) {
      t.touched = this.renderer.textureGC.count;
      var S = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
      this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(t.target, S.texture)), S.dirtyId !== t.dirtyId ? (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), this.updateTexture(t)) : S.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t), this.boundTextures[e] = t;
    } else
      this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(r.TEXTURE_2D, this.emptyTextures[r.TEXTURE_2D].texture), this.boundTextures[e] = null;
  }, o.prototype.reset = function() {
    this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;
    for (var t = 0; t < this.boundTextures.length; t++)
      this.boundTextures[t] = this.unknownTexture;
  }, o.prototype.unbind = function(t) {
    var e = this, r = e.gl, S = e.boundTextures;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = !1;
      for (var T = 0; T < S.length; T++)
        S[T] === this.unknownTexture && this.bind(null, T);
    }
    for (var T = 0; T < S.length; T++)
      S[T] === t && (this.currentLocation !== T && (r.activeTexture(r.TEXTURE0 + T), this.currentLocation = T), r.bindTexture(t.target, this.emptyTextures[t.target].texture), S[T] = null);
  }, o.prototype.ensureSamplerType = function(t) {
    var e = this, r = e.boundTextures, S = e.hasIntegerTextures, T = e.CONTEXT_UID;
    if (S)
      for (var D = t - 1; D >= 0; --D) {
        var N = r[D];
        if (N) {
          var B = N._glTextures[T];
          B.samplerType !== SAMPLER_TYPES.FLOAT && this.renderer.texture.unbind(N);
        }
      }
  }, o.prototype.initTexture = function(t) {
    var e = new GLTexture(this.gl.createTexture());
    return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), e;
  }, o.prototype.initTextureType = function(t, e) {
    var r, S;
    e.internalFormat = (S = (r = this.internalFormats[t.type]) === null || r === void 0 ? void 0 : r[t.format]) !== null && S !== void 0 ? S : t.format, this.webGLVersion === 2 && t.type === TYPES.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type;
  }, o.prototype.updateTexture = function(t) {
    var e = t._glTextures[this.CONTEXT_UID];
    if (e) {
      var r = this.renderer;
      if (this.initTextureType(t, e), t.resource && t.resource.upload(r, t, e))
        e.samplerType !== SAMPLER_TYPES.FLOAT && (this.hasIntegerTextures = !0);
      else {
        var S = t.realWidth, T = t.realHeight, D = r.gl;
        (e.width !== S || e.height !== T || e.dirtyId < 0) && (e.width = S, e.height = T, D.texImage2D(t.target, 0, e.internalFormat, S, T, 0, t.format, e.type, null));
      }
      t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId;
    }
  }, o.prototype.destroyTexture = function(t, e) {
    var r = this.gl;
    if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), r.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {
      var S = this.managedTextures.indexOf(t);
      S !== -1 && removeItems(this.managedTextures, S, 1);
    }
  }, o.prototype.updateTextureStyle = function(t) {
    var e = t._glTextures[this.CONTEXT_UID];
    e && ((t.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? e.mipmap = !1 : e.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? e.wrapMode = WRAP_MODES.CLAMP : e.wrapMode = t.wrapMode, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId);
  }, o.prototype.setStyle = function(t, e) {
    var r = this.gl;
    if (e.mipmap && t.mipmap !== MIPMAP_MODES.ON_MANUAL && r.generateMipmap(t.target), r.texParameteri(t.target, r.TEXTURE_WRAP_S, e.wrapMode), r.texParameteri(t.target, r.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {
      r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES.LINEAR ? r.LINEAR_MIPMAP_LINEAR : r.NEAREST_MIPMAP_NEAREST);
      var S = this.renderer.context.extensions.anisotropicFiltering;
      if (S && t.anisotropicLevel > 0 && t.scaleMode === SCALE_MODES.LINEAR) {
        var T = Math.min(t.anisotropicLevel, r.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        r.texParameterf(t.target, S.TEXTURE_MAX_ANISOTROPY_EXT, T);
      }
    } else
      r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES.LINEAR ? r.LINEAR : r.NEAREST);
    r.texParameteri(t.target, r.TEXTURE_MAG_FILTER, t.scaleMode === SCALE_MODES.LINEAR ? r.LINEAR : r.NEAREST);
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}(), _systems = {
  __proto__: null,
  FilterSystem,
  BatchSystem,
  ContextSystem,
  FramebufferSystem,
  GeometrySystem,
  MaskSystem,
  ScissorSystem,
  StencilSystem,
  ProjectionSystem,
  RenderTextureSystem,
  ShaderSystem,
  StateSystem,
  TextureGCSystem,
  TextureSystem
}, tempMatrix = new Matrix(), AbstractRenderer = function(o) {
  __extends$p(t, o);
  function t(e, r) {
    e === void 0 && (e = RENDERER_TYPE.UNKNOWN);
    var S = o.call(this) || this;
    return r = Object.assign({}, settings.RENDER_OPTIONS, r), S.options = r, S.type = e, S.screen = new Rectangle(0, 0, r.width, r.height), S.view = r.view || settings.ADAPTER.createCanvas(), S.resolution = r.resolution || settings.RESOLUTION, S.useContextAlpha = r.useContextAlpha, S.autoDensity = !!r.autoDensity, S.preserveDrawingBuffer = r.preserveDrawingBuffer, S.clearBeforeRender = r.clearBeforeRender, S._backgroundColor = 0, S._backgroundColorRgba = [0, 0, 0, 1], S._backgroundColorString = "#000000", S.backgroundColor = r.backgroundColor || S._backgroundColor, S.backgroundAlpha = r.backgroundAlpha, r.transparent !== void 0 && (deprecation("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), S.useContextAlpha = r.transparent, S.backgroundAlpha = r.transparent ? 0 : 1), S._lastObjectRendered = null, S.plugins = {}, S;
  }
  return t.prototype.initPlugins = function(e) {
    for (var r in e)
      this.plugins[r] = new e[r](this);
  }, Object.defineProperty(t.prototype, "width", {
    /**
     * Same as view.width, actual number of pixels in the canvas by horizontal.
     * @member {number}
     * @readonly
     * @default 800
     */
    get: function() {
      return this.view.width;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    /**
     * Same as view.height, actual number of pixels in the canvas by vertical.
     * @member {number}
     * @readonly
     * @default 600
     */
    get: function() {
      return this.view.height;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.resize = function(e, r) {
    this.view.width = Math.round(e * this.resolution), this.view.height = Math.round(r * this.resolution);
    var S = this.view.width / this.resolution, T = this.view.height / this.resolution;
    this.screen.width = S, this.screen.height = T, this.autoDensity && (this.view.style.width = S + "px", this.view.style.height = T + "px"), this.emit("resize", S, T);
  }, t.prototype.generateTexture = function(e, r, S, T) {
    r === void 0 && (r = {}), typeof r == "number" && (deprecation("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), r = { scaleMode: r, resolution: S, region: T });
    var D = r.region, N = __rest$3(r, ["region"]);
    T = D || e.getLocalBounds(null, !0), T.width === 0 && (T.width = 1), T.height === 0 && (T.height = 1);
    var B = RenderTexture.create(__assign$7({ width: T.width, height: T.height }, N));
    return tempMatrix.tx = -T.x, tempMatrix.ty = -T.y, this.render(e, {
      renderTexture: B,
      clear: !1,
      transform: tempMatrix,
      skipUpdateTransform: !!e.parent
    }), B;
  }, t.prototype.destroy = function(e) {
    for (var r in this.plugins)
      this.plugins[r].destroy(), this.plugins[r] = null;
    e && this.view.parentNode && this.view.parentNode.removeChild(this.view);
    var S = this;
    S.plugins = null, S.type = RENDERER_TYPE.UNKNOWN, S.view = null, S.screen = null, S._tempDisplayObjectParent = null, S.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;
  }, Object.defineProperty(t.prototype, "backgroundColor", {
    /**
     * The background color to fill if not transparent
     * @member {number}
     */
    get: function() {
      return this._backgroundColor;
    },
    set: function(e) {
      this._backgroundColor = e, this._backgroundColorString = hex2string(e), hex2rgb(e, this._backgroundColorRgba);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "backgroundAlpha", {
    /**
     * The background color alpha. Setting this to 0 will make the canvas transparent.
     * @member {number}
     */
    get: function() {
      return this._backgroundColorRgba[3];
    },
    set: function(e) {
      this._backgroundColorRgba[3] = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(eventemitter3Exports), GLBuffer = function() {
  function o(t) {
    this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
  }
  return o;
}(), BufferSystem = function() {
  function o(t) {
    this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {};
  }
  return o.prototype.destroy = function() {
    this.renderer = null;
  }, o.prototype.contextChange = function() {
    this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }, o.prototype.bind = function(t) {
    var e = this, r = e.gl, S = e.CONTEXT_UID, T = t._glBuffers[S] || this.createGLBuffer(t);
    r.bindBuffer(t.type, T.buffer);
  }, o.prototype.bindBufferBase = function(t, e) {
    var r = this, S = r.gl, T = r.CONTEXT_UID;
    if (this.boundBufferBases[e] !== t) {
      var D = t._glBuffers[T] || this.createGLBuffer(t);
      this.boundBufferBases[e] = t, S.bindBufferBase(S.UNIFORM_BUFFER, e, D.buffer);
    }
  }, o.prototype.bindBufferRange = function(t, e, r) {
    var S = this, T = S.gl, D = S.CONTEXT_UID;
    r = r || 0;
    var N = t._glBuffers[D] || this.createGLBuffer(t);
    T.bindBufferRange(T.UNIFORM_BUFFER, e || 0, N.buffer, r * 256, 256);
  }, o.prototype.update = function(t) {
    var e = this, r = e.gl, S = e.CONTEXT_UID, T = t._glBuffers[S];
    if (t._updateID !== T.updateID)
      if (T.updateID = t._updateID, r.bindBuffer(t.type, T.buffer), T.byteLength >= t.data.byteLength)
        r.bufferSubData(t.type, 0, t.data);
      else {
        var D = t.static ? r.STATIC_DRAW : r.DYNAMIC_DRAW;
        T.byteLength = t.data.byteLength, r.bufferData(t.type, t.data, D);
      }
  }, o.prototype.dispose = function(t, e) {
    if (this.managedBuffers[t.id]) {
      delete this.managedBuffers[t.id];
      var r = t._glBuffers[this.CONTEXT_UID], S = this.gl;
      t.disposeRunner.remove(this), r && (e || S.deleteBuffer(r.buffer), delete t._glBuffers[this.CONTEXT_UID]);
    }
  }, o.prototype.disposeAll = function(t) {
    for (var e = Object.keys(this.managedBuffers), r = 0; r < e.length; r++)
      this.dispose(this.managedBuffers[e[r]], t);
  }, o.prototype.createGLBuffer = function(t) {
    var e = this, r = e.CONTEXT_UID, S = e.gl;
    return t._glBuffers[r] = new GLBuffer(S.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[r];
  }, o;
}(), Renderer = function(o) {
  __extends$p(t, o);
  function t(e) {
    var r = o.call(this, RENDERER_TYPE.WEBGL, e) || this;
    return e = r.options, r.gl = null, r.CONTEXT_UID = 0, r.runners = {
      destroy: new Runner("destroy"),
      contextChange: new Runner("contextChange"),
      reset: new Runner("reset"),
      update: new Runner("update"),
      postrender: new Runner("postrender"),
      prerender: new Runner("prerender"),
      resize: new Runner("resize")
    }, r.runners.contextChange.add(r), r.globalUniforms = new UniformGroup({
      projectionMatrix: new Matrix()
    }, !0), r.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(BufferSystem, "buffer").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch"), r.initPlugins(t.__plugins), r.multisample = void 0, e.context ? r.context.initFromContext(e.context) : r.context.initFromOptions({
      alpha: !!r.useContextAlpha,
      antialias: e.antialias,
      premultipliedAlpha: r.useContextAlpha && r.useContextAlpha !== "notMultiplied",
      stencil: !0,
      preserveDrawingBuffer: e.preserveDrawingBuffer,
      powerPreference: r.options.powerPreference
    }), r.renderingToScreen = !0, sayHello(r.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1"), r.resize(r.options.width, r.options.height), r;
  }
  return t.create = function(e) {
    if (isWebGLSupported())
      return new t(e);
    throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
  }, t.prototype.contextChange = function() {
    var e = this.gl, r;
    if (this.context.webGLVersion === 1) {
      var S = e.getParameter(e.FRAMEBUFFER_BINDING);
      e.bindFramebuffer(e.FRAMEBUFFER, null), r = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, S);
    } else {
      var S = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);
      e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), r = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, S);
    }
    r >= MSAA_QUALITY.HIGH ? this.multisample = MSAA_QUALITY.HIGH : r >= MSAA_QUALITY.MEDIUM ? this.multisample = MSAA_QUALITY.MEDIUM : r >= MSAA_QUALITY.LOW ? this.multisample = MSAA_QUALITY.LOW : this.multisample = MSAA_QUALITY.NONE;
  }, t.prototype.addSystem = function(e, r) {
    var S = new e(this);
    if (this[r])
      throw new Error('Whoops! The name "' + r + '" is already in use');
    this[r] = S;
    for (var T in this.runners)
      this.runners[T].add(S);
    return this;
  }, t.prototype.render = function(e, r) {
    var S, T, D, N;
    if (r && (r instanceof RenderTexture ? (deprecation("6.0.0", "Renderer#render arguments changed, use options instead."), S = r, T = arguments[2], D = arguments[3], N = arguments[4]) : (S = r.renderTexture, T = r.clear, D = r.transform, N = r.skipUpdateTransform)), this.renderingToScreen = !S, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = D, !this.context.isLost) {
      if (S || (this._lastObjectRendered = e), !N) {
        var B = e.enableTempParent();
        e.updateTransform(), e.disableTempParent(B);
      }
      this.renderTexture.bind(S), this.batch.currentRenderer.start(), (T !== void 0 ? T : this.clearBeforeRender) && this.renderTexture.clear(), e.render(this), this.batch.currentRenderer.flush(), S && S.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender");
    }
  }, t.prototype.generateTexture = function(e, r, S, T) {
    r === void 0 && (r = {});
    var D = o.prototype.generateTexture.call(this, e, r, S, T);
    return this.framebuffer.blit(), D;
  }, t.prototype.resize = function(e, r) {
    o.prototype.resize.call(this, e, r), this.runners.resize.emit(this.screen.height, this.screen.width);
  }, t.prototype.reset = function() {
    return this.runners.reset.emit(), this;
  }, t.prototype.clear = function() {
    this.renderTexture.bind(), this.renderTexture.clear();
  }, t.prototype.destroy = function(e) {
    this.runners.destroy.emit();
    for (var r in this.runners)
      this.runners[r].destroy();
    o.prototype.destroy.call(this, e), this.gl = null;
  }, Object.defineProperty(t.prototype, "extract", {
    /**
     * Please use `plugins.extract` instead.
     * @member {PIXI.Extract} extract
     * @deprecated since 6.0.0
     * @readonly
     */
    get: function() {
      return deprecation("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract;
    },
    enumerable: !1,
    configurable: !0
  }), t.registerPlugin = function(e, r) {
    deprecation("6.5.0", "Renderer.registerPlugin() has been deprecated, please use extensions.add() instead."), extensions.add({
      name: e,
      type: ExtensionType.RendererPlugin,
      ref: r
    });
  }, t.__plugins = {}, t;
}(AbstractRenderer);
extensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
function autoDetectRenderer(o) {
  return Renderer.create(o);
}
var $defaultVertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`, $defaultFilterVertex = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, defaultVertex$1 = $defaultVertex, defaultFilterVertex = $defaultFilterVertex, System = function() {
  function o(t) {
    deprecation("6.1.0", "System class is deprecated, implemement ISystem interface instead."), this.renderer = t;
  }
  return o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}(), BatchDrawCall = function() {
  function o() {
    this.texArray = null, this.blend = 0, this.type = DRAW_MODES.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
  }
  return o;
}(), BatchTextureArray = function() {
  function o() {
    this.elements = [], this.ids = [], this.count = 0;
  }
  return o.prototype.clear = function() {
    for (var t = 0; t < this.count; t++)
      this.elements[t] = null;
    this.count = 0;
  }, o;
}(), ViewableBuffer = function() {
  function o(t) {
    typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
  }
  return Object.defineProperty(o.prototype, "int8View", {
    /** View on the raw binary data as a `Int8Array`. */
    get: function() {
      return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "uint8View", {
    /** View on the raw binary data as a `Uint8Array`. */
    get: function() {
      return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "int16View", {
    /**  View on the raw binary data as a `Int16Array`. */
    get: function() {
      return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "uint16View", {
    /** View on the raw binary data as a `Uint16Array`. */
    get: function() {
      return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "int32View", {
    /** View on the raw binary data as a `Int32Array`. */
    get: function() {
      return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.view = function(t) {
    return this[t + "View"];
  }, o.prototype.destroy = function() {
    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
  }, o.sizeOf = function(t) {
    switch (t) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(t + " isn't a valid view type");
    }
  }, o;
}(), AbstractBatchRenderer = function(o) {
  __extends$p(t, o);
  function t(e) {
    var r = o.call(this, e) || this;
    return r.shaderGenerator = null, r.geometryClass = null, r.vertexSize = null, r.state = State.for2d(), r.size = settings.SPRITE_BATCH_SIZE * 4, r._vertexCount = 0, r._indexCount = 0, r._bufferedElements = [], r._bufferedTextures = [], r._bufferSize = 0, r._shader = null, r._packedGeometries = [], r._packedGeometryPoolSize = 2, r._flushId = 0, r._aBuffers = {}, r._iBuffers = {}, r.MAX_TEXTURES = 1, r.renderer.on("prerender", r.onPrerender, r), e.runners.contextChange.add(r), r._dcIndex = 0, r._aIndex = 0, r._iIndex = 0, r._attributeBuffer = null, r._indexBuffer = null, r._tempBoundTextures = [], r;
  }
  return t.prototype.contextChange = function() {
    var e = this.renderer.gl;
    settings.PREFER_ENV === ENV.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, e)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
    for (var r = 0; r < this._packedGeometryPoolSize; r++)
      this._packedGeometries[r] = new this.geometryClass();
    this.initFlushBuffers();
  }, t.prototype.initFlushBuffers = function() {
    for (var e = t._drawCallPool, r = t._textureArrayPool, S = this.size / 4, T = Math.floor(S / this.MAX_TEXTURES) + 1; e.length < S; )
      e.push(new BatchDrawCall());
    for (; r.length < T; )
      r.push(new BatchTextureArray());
    for (var D = 0; D < this.MAX_TEXTURES; D++)
      this._tempBoundTextures[D] = null;
  }, t.prototype.onPrerender = function() {
    this._flushId = 0;
  }, t.prototype.render = function(e) {
    e._texture.valid && (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e);
  }, t.prototype.buildTexturesAndDrawCalls = function() {
    var e = this, r = e._bufferedTextures, S = e.MAX_TEXTURES, T = t._textureArrayPool, D = this.renderer.batch, N = this._tempBoundTextures, B = this.renderer.textureGC.count, $ = ++BaseTexture._globalBatch, U = 0, H = T[0], V = 0;
    D.copyBoundTextures(N, S);
    for (var X = 0; X < this._bufferSize; ++X) {
      var W = r[X];
      r[X] = null, W._batchEnabled !== $ && (H.count >= S && (D.boundArray(H, N, $, S), this.buildDrawCalls(H, V, X), V = X, H = T[++U], ++$), W._batchEnabled = $, W.touched = B, H.elements[H.count++] = W);
    }
    H.count > 0 && (D.boundArray(H, N, $, S), this.buildDrawCalls(H, V, this._bufferSize), ++U, ++$);
    for (var X = 0; X < N.length; X++)
      N[X] = null;
    BaseTexture._globalBatch = $;
  }, t.prototype.buildDrawCalls = function(e, r, S) {
    var T = this, D = T._bufferedElements, N = T._attributeBuffer, B = T._indexBuffer, $ = T.vertexSize, U = t._drawCallPool, H = this._dcIndex, V = this._aIndex, X = this._iIndex, W = U[H];
    W.start = this._iIndex, W.texArray = e;
    for (var Y = r; Y < S; ++Y) {
      var q = D[Y], K = q._texture.baseTexture, Z = premultiplyBlendMode[K.alphaMode ? 1 : 0][q.blendMode];
      D[Y] = null, r < Y && W.blend !== Z && (W.size = X - W.start, r = Y, W = U[++H], W.texArray = e, W.start = X), this.packInterleavedGeometry(q, N, B, V, X), V += q.vertexData.length / 2 * $, X += q.indices.length, W.blend = Z;
    }
    r < S && (W.size = X - W.start, ++H), this._dcIndex = H, this._aIndex = V, this._iIndex = X;
  }, t.prototype.bindAndClearTexArray = function(e) {
    for (var r = this.renderer.texture, S = 0; S < e.count; S++)
      r.bind(e.elements[S], e.ids[S]), e.elements[S] = null;
    e.count = 0;
  }, t.prototype.updateGeometry = function() {
    var e = this, r = e._packedGeometries, S = e._attributeBuffer, T = e._indexBuffer;
    settings.CAN_UPLOAD_SAME_BUFFER ? (r[this._flushId]._buffer.update(S.rawBinaryData), r[this._flushId]._indexBuffer.update(T), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, r[this._flushId] = new this.geometryClass()), r[this._flushId]._buffer.update(S.rawBinaryData), r[this._flushId]._indexBuffer.update(T), this.renderer.geometry.bind(r[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
  }, t.prototype.drawBatches = function() {
    for (var e = this._dcIndex, r = this.renderer, S = r.gl, T = r.state, D = t._drawCallPool, N = null, B = 0; B < e; B++) {
      var $ = D[B], U = $.texArray, H = $.type, V = $.size, X = $.start, W = $.blend;
      N !== U && (N = U, this.bindAndClearTexArray(U)), this.state.blendMode = W, T.set(this.state), S.drawElements(H, V, S.UNSIGNED_SHORT, X * 2);
    }
  }, t.prototype.flush = function() {
    this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
  }, t.prototype.start = function() {
    this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), settings.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
  }, t.prototype.stop = function() {
    this.flush();
  }, t.prototype.destroy = function() {
    for (var e = 0; e < this._packedGeometryPoolSize; e++)
      this._packedGeometries[e] && this._packedGeometries[e].destroy();
    this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), o.prototype.destroy.call(this);
  }, t.prototype.getAttributeBuffer = function(e) {
    var r = nextPow2(Math.ceil(e / 8)), S = log2(r), T = r * 8;
    this._aBuffers.length <= S && (this._iBuffers.length = S + 1);
    var D = this._aBuffers[T];
    return D || (this._aBuffers[T] = D = new ViewableBuffer(T * this.vertexSize * 4)), D;
  }, t.prototype.getIndexBuffer = function(e) {
    var r = nextPow2(Math.ceil(e / 12)), S = log2(r), T = r * 12;
    this._iBuffers.length <= S && (this._iBuffers.length = S + 1);
    var D = this._iBuffers[S];
    return D || (this._iBuffers[S] = D = new Uint16Array(T)), D;
  }, t.prototype.packInterleavedGeometry = function(e, r, S, T, D) {
    for (var N = r.uint32View, B = r.float32View, $ = T / this.vertexSize, U = e.uvs, H = e.indices, V = e.vertexData, X = e._texture.baseTexture._batchLocation, W = Math.min(e.worldAlpha, 1), Y = W < 1 && e._texture.baseTexture.alphaMode ? premultiplyTint(e._tintRGB, W) : e._tintRGB + (W * 255 << 24), q = 0; q < V.length; q += 2)
      B[T++] = V[q], B[T++] = V[q + 1], B[T++] = U[q], B[T++] = U[q + 1], N[T++] = Y, B[T++] = X;
    for (var q = 0; q < H.length; q++)
      S[D++] = $ + H[q];
  }, t._drawCallPool = [], t._textureArrayPool = [], t;
}(ObjectRenderer), BatchShaderGenerator = function() {
  function o(t, e) {
    if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf("%count%") < 0)
      throw new Error('Fragment template must contain "%count%".');
    if (e.indexOf("%forloop%") < 0)
      throw new Error('Fragment template must contain "%forloop%".');
  }
  return o.prototype.generateShader = function(t) {
    if (!this.programCache[t]) {
      for (var e = new Int32Array(t), r = 0; r < t; r++)
        e[r] = r;
      this.defaultGroupCache[t] = UniformGroup.from({ uSamplers: e }, !0);
      var S = this.fragTemplate;
      S = S.replace(/%count%/gi, "" + t), S = S.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new Program(this.vertexSrc, S);
    }
    var T = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new Matrix(),
      default: this.defaultGroupCache[t]
    };
    return new Shader(this.programCache[t], T);
  }, o.prototype.generateSampleSrc = function(t) {
    var e = "";
    e += `
`, e += `
`;
    for (var r = 0; r < t; r++)
      r > 0 && (e += `
else `), r < t - 1 && (e += "if(vTextureId < " + r + ".5)"), e += `
{`, e += `
	color = texture2D(uSamplers[` + r + "], vTextureCoord);", e += `
}`;
    return e += `
`, e += `
`, e;
  }, o;
}(), BatchGeometry = function(o) {
  __extends$p(t, o);
  function t(e) {
    e === void 0 && (e = !1);
    var r = o.call(this) || this;
    return r._buffer = new Buffer$1(null, e, !1), r._indexBuffer = new Buffer$1(null, e, !0), r.addAttribute("aVertexPosition", r._buffer, 2, !1, TYPES.FLOAT).addAttribute("aTextureCoord", r._buffer, 2, !1, TYPES.FLOAT).addAttribute("aColor", r._buffer, 4, !0, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", r._buffer, 1, !0, TYPES.FLOAT).addIndex(r._indexBuffer), r;
  }
  return t;
}(Geometry), defaultVertex = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`, defaultFragment = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`, BatchPluginFactory = function() {
  function o() {
  }
  return o.create = function(t) {
    var e = Object.assign({
      vertex: defaultVertex,
      fragment: defaultFragment,
      geometryClass: BatchGeometry,
      vertexSize: 6
    }, t), r = e.vertex, S = e.fragment, T = e.vertexSize, D = e.geometryClass;
    return function(N) {
      __extends$p(B, N);
      function B($) {
        var U = N.call(this, $) || this;
        return U.shaderGenerator = new BatchShaderGenerator(r, S), U.geometryClass = D, U.vertexSize = T, U;
      }
      return B;
    }(AbstractBatchRenderer);
  }, Object.defineProperty(o, "defaultVertexSrc", {
    /**
     * The default vertex shader source
     * @readonly
     */
    get: function() {
      return defaultVertex;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "defaultFragmentTemplate", {
    /**
     * The default fragment shader source
     * @readonly
     */
    get: function() {
      return defaultFragment;
    },
    enumerable: !1,
    configurable: !0
  }), o;
}(), BatchRenderer = BatchPluginFactory.create();
Object.assign(BatchRenderer, {
  extension: {
    name: "batch",
    type: ExtensionType.RendererPlugin
  }
});
var resources = {}, _loop_1 = function(o) {
  Object.defineProperty(resources, o, {
    get: function() {
      return deprecation("6.0.0", "PIXI.systems." + o + " has moved to PIXI." + o), _resources[o];
    }
  });
};
for (var name in _resources)
  _loop_1(name);
var systems = {}, _loop_2 = function(o) {
  Object.defineProperty(systems, o, {
    get: function() {
      return deprecation("6.0.0", "PIXI.resources." + o + " has moved to PIXI." + o), _systems[o];
    }
  });
};
for (var name in _systems)
  _loop_2(name);
var VERSION = "6.5.8";
const n = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbstractBatchRenderer,
  AbstractMultiResource,
  AbstractRenderer,
  ArrayResource,
  Attribute,
  BaseImageResource,
  BaseRenderTexture,
  BaseTexture,
  BatchDrawCall,
  BatchGeometry,
  BatchPluginFactory,
  BatchRenderer,
  BatchShaderGenerator,
  BatchSystem,
  BatchTextureArray,
  Buffer: Buffer$1,
  BufferResource,
  CanvasResource,
  ContextSystem,
  CubeResource,
  get ExtensionType() {
    return ExtensionType;
  },
  Filter,
  FilterState,
  FilterSystem,
  Framebuffer,
  FramebufferSystem,
  GLFramebuffer,
  GLProgram,
  GLTexture,
  Geometry,
  GeometrySystem,
  IGLUniformData,
  INSTALLED,
  ImageBitmapResource,
  ImageResource,
  MaskData,
  MaskSystem,
  ObjectRenderer,
  Program,
  ProjectionSystem,
  Quad,
  QuadUv,
  RenderTexture,
  RenderTexturePool,
  RenderTextureSystem,
  Renderer,
  Resource,
  SVGResource,
  ScissorSystem,
  Shader,
  ShaderSystem,
  SpriteMaskFilter,
  State,
  StateSystem,
  StencilSystem,
  System,
  Texture,
  TextureGCSystem,
  TextureMatrix,
  TextureSystem,
  TextureUvs,
  UniformGroup,
  VERSION,
  VideoResource,
  ViewableBuffer,
  autoDetectRenderer,
  autoDetectResource,
  checkMaxIfStatementsInShader,
  createUBOElements,
  defaultFilterVertex,
  defaultVertex: defaultVertex$1,
  extensions,
  generateProgram,
  generateUniformBufferSync,
  getTestContext,
  getUBOData,
  resources,
  systems,
  uniformParsers
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * @pixi/accessibility - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/accessibility is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var accessibleTarget = {
  /**
   *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
   *   shadow div with attributes set
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  accessible: !1,
  /**
   * Sets the title attribute of the shadow div
   * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
   * @member {?string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleTitle: null,
  /**
   * Sets the aria-label attribute of the shadow div
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleHint: null,
  /**
   * @member {number}
   * @memberof PIXI.DisplayObject#
   * @private
   * @todo Needs docs.
   */
  tabIndex: 0,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleActive: !1,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleDiv: null,
  /**
   * Specify the type of div the accessible layer is. Screen readers treat the element differently
   * depending on this type. Defaults to button.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'button'
   */
  accessibleType: "button",
  /**
   * Specify the pointer-events the accessible div will use
   * Defaults to auto.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'auto'
   */
  accessiblePointerEvents: "auto",
  /**
   * Setting to false will prevent any children inside this container to
   * be accessible. Defaults to true.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @default true
   */
  accessibleChildren: !0,
  renderId: -1
};
DisplayObject.mixin(accessibleTarget);
var KEY_CODE_TAB = 9, DIV_TOUCH_SIZE = 100, DIV_TOUCH_POS_X = 0, DIV_TOUCH_POS_Y = 0, DIV_TOUCH_ZINDEX = 2, DIV_HOOK_SIZE = 1, DIV_HOOK_POS_X = -1e3, DIV_HOOK_POS_Y = -1e3, DIV_HOOK_ZINDEX = 2, AccessibilityManager = function() {
  function o(t) {
    this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (isMobile.tablet || isMobile.phone) && this.createTouchHook();
    var e = document.createElement("div");
    e.style.width = DIV_TOUCH_SIZE + "px", e.style.height = DIV_TOUCH_SIZE + "px", e.style.position = "absolute", e.style.top = DIV_TOUCH_POS_X + "px", e.style.left = DIV_TOUCH_POS_Y + "px", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1);
  }
  return Object.defineProperty(o.prototype, "isActive", {
    /**
     * Value of `true` if accessibility is currently active and accessibility layers are showing.
     * @member {boolean}
     * @readonly
     */
    get: function() {
      return this._isActive;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "isMobileAccessibility", {
    /**
     * Value of `true` if accessibility is enabled for touch devices.
     * @member {boolean}
     * @readonly
     */
    get: function() {
      return this._isMobileAccessibility;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.createTouchHook = function() {
    var t = this, e = document.createElement("button");
    e.style.width = DIV_HOOK_SIZE + "px", e.style.height = DIV_HOOK_SIZE + "px", e.style.position = "absolute", e.style.top = DIV_HOOK_POS_X + "px", e.style.left = DIV_HOOK_POS_Y + "px", e.style.zIndex = DIV_HOOK_ZINDEX.toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessibility for this content", e.addEventListener("focus", function() {
      t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook();
    }), document.body.appendChild(e), this._hookDiv = e;
  }, o.prototype.destroyTouchHook = function() {
    this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
  }, o.prototype.activate = function() {
    var t;
    this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), (t = this.renderer.view.parentNode) === null || t === void 0 || t.appendChild(this.div));
  }, o.prototype.deactivate = function() {
    var t;
    !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), (t = this.div.parentNode) === null || t === void 0 || t.removeChild(this.div));
  }, o.prototype.updateAccessibleObjects = function(t) {
    if (!(!t.visible || !t.accessibleChildren)) {
      t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);
      var e = t.children;
      if (e)
        for (var r = 0; r < e.length; r++)
          this.updateAccessibleObjects(e[r]);
    }
  }, o.prototype.update = function() {
    var t = performance.now();
    if (!(isMobile.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, !!this.renderer.renderingToScreen)) {
      this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);
      var e = this.renderer.view.getBoundingClientRect(), r = e.left, S = e.top, T = e.width, D = e.height, N = this.renderer, B = N.width, $ = N.height, U = N.resolution, H = T / B * U, V = D / $ * U, X = this.div;
      X.style.left = r + "px", X.style.top = S + "px", X.style.width = B + "px", X.style.height = $ + "px";
      for (var W = 0; W < this.children.length; W++) {
        var Y = this.children[W];
        if (Y.renderId !== this.renderId)
          Y._accessibleActive = !1, removeItems(this.children, W, 1), this.div.removeChild(Y._accessibleDiv), this.pool.push(Y._accessibleDiv), Y._accessibleDiv = null, W--;
        else {
          X = Y._accessibleDiv;
          var q = Y.hitArea, K = Y.worldTransform;
          Y.hitArea ? (X.style.left = (K.tx + q.x * K.a) * H + "px", X.style.top = (K.ty + q.y * K.d) * V + "px", X.style.width = q.width * K.a * H + "px", X.style.height = q.height * K.d * V + "px") : (q = Y.getBounds(), this.capHitArea(q), X.style.left = q.x * H + "px", X.style.top = q.y * V + "px", X.style.width = q.width * H + "px", X.style.height = q.height * V + "px", X.title !== Y.accessibleTitle && Y.accessibleTitle !== null && (X.title = Y.accessibleTitle), X.getAttribute("aria-label") !== Y.accessibleHint && Y.accessibleHint !== null && X.setAttribute("aria-label", Y.accessibleHint)), (Y.accessibleTitle !== X.title || Y.tabIndex !== X.tabIndex) && (X.title = Y.accessibleTitle, X.tabIndex = Y.tabIndex, this.debug && this.updateDebugHTML(X));
        }
      }
      this.renderId++;
    }
  }, o.prototype.updateDebugHTML = function(t) {
    t.innerHTML = "type: " + t.type + "</br> title : " + t.title + "</br> tabIndex: " + t.tabIndex;
  }, o.prototype.capHitArea = function(t) {
    t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
    var e = this.renderer, r = e.width, S = e.height;
    t.x + t.width > r && (t.width = r - t.x), t.y + t.height > S && (t.height = S - t.y);
  }, o.prototype.addChild = function(t) {
    var e = this.pool.pop();
    e || (e = document.createElement("button"), e.style.width = DIV_TOUCH_SIZE + "px", e.style.height = DIV_TOUCH_SIZE + "px", e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = "displayObject " + t.tabIndex), t.accessibleHint && t.accessibleHint !== null && e.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex;
  }, o.prototype._onClick = function(t) {
    var e = this.renderer.plugins.interaction, r = t.target.displayObject, S = e.eventData;
    e.dispatchEvent(r, "click", S), e.dispatchEvent(r, "pointertap", S), e.dispatchEvent(r, "tap", S);
  }, o.prototype._onFocus = function(t) {
    t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive");
    var e = this.renderer.plugins.interaction, r = t.target.displayObject, S = e.eventData;
    e.dispatchEvent(r, "mouseover", S);
  }, o.prototype._onFocusOut = function(t) {
    t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite");
    var e = this.renderer.plugins.interaction, r = t.target.displayObject, S = e.eventData;
    e.dispatchEvent(r, "mouseout", S);
  }, o.prototype._onKeyDown = function(t) {
    t.keyCode === KEY_CODE_TAB && this.activate();
  }, o.prototype._onMouseMove = function(t) {
    t.movementX === 0 && t.movementY === 0 || this.deactivate();
  }, o.prototype.destroy = function() {
    this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;
  }, o.extension = {
    name: "accessibility",
    type: [
      ExtensionType.RendererPlugin,
      ExtensionType.CanvasRendererPlugin
    ]
  }, o;
}();
/*!
 * @pixi/interaction - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var InteractionData = function() {
  function o() {
    this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new Point(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;
  }
  return Object.defineProperty(o.prototype, "pointerId", {
    /**
     * The unique identifier of the pointer. It will be the same as `identifier`.
     * @readonly
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
     */
    get: function() {
      return this.identifier;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.getLocalPosition = function(t, e, r) {
    return t.worldTransform.applyInverse(r || this.global, e);
  }, o.prototype.copyEvent = function(t) {
    "isPrimary" in t && t.isPrimary && (this.isPrimary = !0), this.button = "button" in t && t.button;
    var e = "buttons" in t && t.buttons;
    this.buttons = Number.isInteger(e) ? e : "which" in t && t.which, this.width = "width" in t && t.width, this.height = "height" in t && t.height, this.tiltX = "tiltX" in t && t.tiltX, this.tiltY = "tiltY" in t && t.tiltY, this.pointerType = "pointerType" in t && t.pointerType, this.pressure = "pressure" in t && t.pressure, this.rotationAngle = "rotationAngle" in t && t.rotationAngle, this.twist = "twist" in t && t.twist || 0, this.tangentialPressure = "tangentialPressure" in t && t.tangentialPressure || 0;
  }, o.prototype.reset = function() {
    this.isPrimary = !1;
  }, o;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$o = function(o, t) {
  return extendStatics$o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$o(o, t);
};
function __extends$o(o, t) {
  extendStatics$o(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var InteractionEvent = function() {
  function o() {
    this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null;
  }
  return o.prototype.stopPropagation = function() {
    this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget;
  }, o.prototype.reset = function() {
    this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null;
  }, o;
}(), InteractionTrackingData = function() {
  function o(t) {
    this._pointerId = t, this._flags = o.FLAGS.NONE;
  }
  return o.prototype._doSet = function(t, e) {
    e ? this._flags = this._flags | t : this._flags = this._flags & ~t;
  }, Object.defineProperty(o.prototype, "pointerId", {
    /**
     * Unique pointer id of the event
     * @readonly
     * @private
     * @member {number}
     */
    get: function() {
      return this._pointerId;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "flags", {
    /**
     * State of the tracking data, expressed as bit flags
     * @private
     * @member {number}
     */
    get: function() {
      return this._flags;
    },
    set: function(t) {
      this._flags = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "none", {
    /**
     * Is the tracked event inactive (not over or down)?
     * @private
     * @member {number}
     */
    get: function() {
      return this._flags === o.FLAGS.NONE;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "over", {
    /**
     * Is the tracked event over the DisplayObject?
     * @private
     * @member {boolean}
     */
    get: function() {
      return (this._flags & o.FLAGS.OVER) !== 0;
    },
    set: function(t) {
      this._doSet(o.FLAGS.OVER, t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "rightDown", {
    /**
     * Did the right mouse button come down in the DisplayObject?
     * @private
     * @member {boolean}
     */
    get: function() {
      return (this._flags & o.FLAGS.RIGHT_DOWN) !== 0;
    },
    set: function(t) {
      this._doSet(o.FLAGS.RIGHT_DOWN, t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "leftDown", {
    /**
     * Did the left mouse button come down in the DisplayObject?
     * @private
     * @member {boolean}
     */
    get: function() {
      return (this._flags & o.FLAGS.LEFT_DOWN) !== 0;
    },
    set: function(t) {
      this._doSet(o.FLAGS.LEFT_DOWN, t);
    },
    enumerable: !1,
    configurable: !0
  }), o.FLAGS = Object.freeze({
    NONE: 0,
    OVER: 1 << 0,
    LEFT_DOWN: 1 << 1,
    RIGHT_DOWN: 1 << 2
  }), o;
}(), TreeSearch = function() {
  function o() {
    this._tempPoint = new Point();
  }
  return o.prototype.recursiveFindHit = function(t, e, r, S, T) {
    var D;
    if (!e || !e.visible)
      return !1;
    var N = t.data.global;
    T = e.interactive || T;
    var B = !1, $ = T, U = !0;
    if (e.hitArea)
      S && (e.worldTransform.applyInverse(N, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? B = !0 : (S = !1, U = !1)), $ = !1;
    else if (e._mask && S) {
      var H = e._mask.isMaskData ? e._mask.maskObject : e._mask;
      H && !(!((D = H.containsPoint) === null || D === void 0) && D.call(H, N)) && (S = !1);
    }
    if (U && e.interactiveChildren && e.children)
      for (var V = e.children, X = V.length - 1; X >= 0; X--) {
        var W = V[X], Y = this.recursiveFindHit(t, W, r, S, $);
        if (Y) {
          if (!W.parent)
            continue;
          $ = !1, Y && (t.target && (S = !1), B = !0);
        }
      }
    return T && (S && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(N) && (B = !0), e.interactive && (B && !t.target && (t.target = e), r && r(t, e, !!B))), B;
  }, o.prototype.findHit = function(t, e, r, S) {
    this.recursiveFindHit(t, e, r, S, !1);
  }, o;
}(), interactiveTarget = {
  interactive: !1,
  interactiveChildren: !0,
  hitArea: null,
  /**
   * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
   * Setting this changes the 'cursor' property to `'pointer'`.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.buttonMode = true;
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  get buttonMode() {
    return this.cursor === "pointer";
  },
  set buttonMode(o) {
    o ? this.cursor = "pointer" : this.cursor === "pointer" && (this.cursor = null);
  },
  /**
   * This defines what cursor mode is used when the mouse cursor
   * is hovered over the displayObject.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.cursor = 'wait';
   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  cursor: null,
  /**
   * Internal set of all active pointers, by identifier
   * @member {Map<number, InteractionTrackingData>}
   * @memberof PIXI.DisplayObject#
   * @private
   */
  get trackedPointers() {
    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;
  },
  /**
   * Map of all tracked pointers, by identifier. Use trackedPointers to access.
   * @private
   * @type {Map<number, InteractionTrackingData>}
   */
  _trackedPointers: void 0
};
DisplayObject.mixin(interactiveTarget);
var MOUSE_POINTER_ID = 1, hitTestEvent = {
  target: null,
  data: {
    global: null
  }
}, InteractionManager = function(o) {
  __extends$o(t, o);
  function t(e, r) {
    var S = o.call(this) || this;
    return r = r || {}, S.renderer = e, S.autoPreventDefault = r.autoPreventDefault !== void 0 ? r.autoPreventDefault : !0, S.interactionFrequency = r.interactionFrequency || 10, S.mouse = new InteractionData(), S.mouse.identifier = MOUSE_POINTER_ID, S.mouse.global.set(-999999), S.activeInteractionData = {}, S.activeInteractionData[MOUSE_POINTER_ID] = S.mouse, S.interactionDataPool = [], S.eventData = new InteractionEvent(), S.interactionDOMElement = null, S.moveWhenInside = !1, S.eventsAdded = !1, S.tickerAdded = !1, S.mouseOverRenderer = !("PointerEvent" in globalThis), S.supportsTouchEvents = "ontouchstart" in globalThis, S.supportsPointerEvents = !!globalThis.PointerEvent, S.onPointerUp = S.onPointerUp.bind(S), S.processPointerUp = S.processPointerUp.bind(S), S.onPointerCancel = S.onPointerCancel.bind(S), S.processPointerCancel = S.processPointerCancel.bind(S), S.onPointerDown = S.onPointerDown.bind(S), S.processPointerDown = S.processPointerDown.bind(S), S.onPointerMove = S.onPointerMove.bind(S), S.processPointerMove = S.processPointerMove.bind(S), S.onPointerOut = S.onPointerOut.bind(S), S.processPointerOverOut = S.processPointerOverOut.bind(S), S.onPointerOver = S.onPointerOver.bind(S), S.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    }, S.currentCursorMode = null, S.cursor = null, S.resolution = 1, S.delayedEvents = [], S.search = new TreeSearch(), S._tempDisplayObject = new TemporaryDisplayObject(), S._eventListenerOptions = { capture: !0, passive: !1 }, S._useSystemTicker = r.useSystemTicker !== void 0 ? r.useSystemTicker : !0, S.setTargetElement(S.renderer.view, S.renderer.resolution), S;
  }
  return Object.defineProperty(t.prototype, "useSystemTicker", {
    /**
     * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.
     * @default true
     */
    get: function() {
      return this._useSystemTicker;
    },
    set: function(e) {
      this._useSystemTicker = e, e ? this.addTickerListener() : this.removeTickerListener();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "lastObjectRendered", {
    /**
     * Last rendered object or temp object.
     * @readonly
     * @protected
     */
    get: function() {
      return this.renderer._lastObjectRendered || this._tempDisplayObject;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.hitTest = function(e, r) {
    return hitTestEvent.target = null, hitTestEvent.data.global = e, r || (r = this.lastObjectRendered), this.processInteractive(hitTestEvent, r, null, !0), hitTestEvent.target;
  }, t.prototype.setTargetElement = function(e, r) {
    r === void 0 && (r = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = e, this.resolution = r, this.addEvents(), this.addTickerListener();
  }, t.prototype.addTickerListener = function() {
    this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker || (Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION), this.tickerAdded = !0);
  }, t.prototype.removeTickerListener = function() {
    this.tickerAdded && (Ticker.system.remove(this.tickerUpdate, this), this.tickerAdded = !1);
  }, t.prototype.addEvents = function() {
    if (!(this.eventsAdded || !this.interactionDOMElement)) {
      var e = this.interactionDOMElement.style;
      globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "none", e.msTouchAction = "none") : this.supportsPointerEvents && (e.touchAction = "none"), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0;
    }
  }, t.prototype.removeEvents = function() {
    if (!(!this.eventsAdded || !this.interactionDOMElement)) {
      var e = this.interactionDOMElement.style;
      globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "", e.msTouchAction = "") : this.supportsPointerEvents && (e.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1;
    }
  }, t.prototype.tickerUpdate = function(e) {
    this._deltaTime += e, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());
  }, t.prototype.update = function() {
    if (this.interactionDOMElement) {
      if (this._didMove) {
        this._didMove = !1;
        return;
      }
      this.cursor = null;
      for (var e in this.activeInteractionData)
        if (this.activeInteractionData.hasOwnProperty(e)) {
          var r = this.activeInteractionData[e];
          if (r.originalEvent && r.pointerType !== "touch") {
            var S = this.configureInteractionEventForDOMEvent(this.eventData, r.originalEvent, r);
            this.processInteractive(S, this.lastObjectRendered, this.processPointerOverOut, !0);
          }
        }
      this.setCursorMode(this.cursor);
    }
  }, t.prototype.setCursorMode = function(e) {
    e = e || "default";
    var r = !0;
    if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (r = !1), this.currentCursorMode !== e) {
      this.currentCursorMode = e;
      var S = this.cursorStyles[e];
      if (S)
        switch (typeof S) {
          case "string":
            r && (this.interactionDOMElement.style.cursor = S);
            break;
          case "function":
            S(e);
            break;
          case "object":
            r && Object.assign(this.interactionDOMElement.style, S);
            break;
        }
      else
        r && typeof e == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.interactionDOMElement.style.cursor = e);
    }
  }, t.prototype.dispatchEvent = function(e, r, S) {
    (!S.stopPropagationHint || e === S.stopsPropagatingAt) && (S.currentTarget = e, S.type = r, e.emit(r, S), e[r] && e[r](S));
  }, t.prototype.delayDispatchEvent = function(e, r, S) {
    this.delayedEvents.push({ displayObject: e, eventString: r, eventData: S });
  }, t.prototype.mapPositionToPoint = function(e, r, S) {
    var T;
    this.interactionDOMElement.parentElement ? T = this.interactionDOMElement.getBoundingClientRect() : T = {
      x: 0,
      y: 0,
      width: this.interactionDOMElement.width,
      height: this.interactionDOMElement.height,
      left: 0,
      top: 0
    };
    var D = 1 / this.resolution;
    e.x = (r - T.left) * (this.interactionDOMElement.width / T.width) * D, e.y = (S - T.top) * (this.interactionDOMElement.height / T.height) * D;
  }, t.prototype.processInteractive = function(e, r, S, T) {
    var D = this.search.findHit(e, r, S, T), N = this.delayedEvents;
    if (!N.length)
      return D;
    e.stopPropagationHint = !1;
    var B = N.length;
    this.delayedEvents = [];
    for (var $ = 0; $ < B; $++) {
      var U = N[$], H = U.displayObject, V = U.eventString, X = U.eventData;
      X.stopsPropagatingAt === H && (X.stopPropagationHint = !0), this.dispatchEvent(H, V, X);
    }
    return D;
  }, t.prototype.onPointerDown = function(e) {
    if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
      var r = this.normalizeToPointerData(e);
      if (this.autoPreventDefault && r[0].isNormalized) {
        var S = e.cancelable || !("cancelable" in e);
        S && e.preventDefault();
      }
      for (var T = r.length, D = 0; D < T; D++) {
        var N = r[D], B = this.getInteractionDataForPointerId(N), $ = this.configureInteractionEventForDOMEvent(this.eventData, N, B);
        if ($.data.originalEvent = e, this.processInteractive($, this.lastObjectRendered, this.processPointerDown, !0), this.emit("pointerdown", $), N.pointerType === "touch")
          this.emit("touchstart", $);
        else if (N.pointerType === "mouse" || N.pointerType === "pen") {
          var U = N.button === 2;
          this.emit(U ? "rightdown" : "mousedown", this.eventData);
        }
      }
    }
  }, t.prototype.processPointerDown = function(e, r, S) {
    var T = e.data, D = e.data.identifier;
    if (S) {
      if (r.trackedPointers[D] || (r.trackedPointers[D] = new InteractionTrackingData(D)), this.dispatchEvent(r, "pointerdown", e), T.pointerType === "touch")
        this.dispatchEvent(r, "touchstart", e);
      else if (T.pointerType === "mouse" || T.pointerType === "pen") {
        var N = T.button === 2;
        N ? r.trackedPointers[D].rightDown = !0 : r.trackedPointers[D].leftDown = !0, this.dispatchEvent(r, N ? "rightdown" : "mousedown", e);
      }
    }
  }, t.prototype.onPointerComplete = function(e, r, S) {
    var T = this.normalizeToPointerData(e), D = T.length, N = e.target;
    e.composedPath && e.composedPath().length > 0 && (N = e.composedPath()[0]);
    for (var B = N !== this.interactionDOMElement ? "outside" : "", $ = 0; $ < D; $++) {
      var U = T[$], H = this.getInteractionDataForPointerId(U), V = this.configureInteractionEventForDOMEvent(this.eventData, U, H);
      if (V.data.originalEvent = e, this.processInteractive(V, this.lastObjectRendered, S, r || !B), this.emit(r ? "pointercancel" : "pointerup" + B, V), U.pointerType === "mouse" || U.pointerType === "pen") {
        var X = U.button === 2;
        this.emit(X ? "rightup" + B : "mouseup" + B, V);
      } else
        U.pointerType === "touch" && (this.emit(r ? "touchcancel" : "touchend" + B, V), this.releaseInteractionDataForPointerId(U.pointerId));
    }
  }, t.prototype.onPointerCancel = function(e) {
    this.supportsTouchEvents && e.pointerType === "touch" || this.onPointerComplete(e, !0, this.processPointerCancel);
  }, t.prototype.processPointerCancel = function(e, r) {
    var S = e.data, T = e.data.identifier;
    r.trackedPointers[T] !== void 0 && (delete r.trackedPointers[T], this.dispatchEvent(r, "pointercancel", e), S.pointerType === "touch" && this.dispatchEvent(r, "touchcancel", e));
  }, t.prototype.onPointerUp = function(e) {
    this.supportsTouchEvents && e.pointerType === "touch" || this.onPointerComplete(e, !1, this.processPointerUp);
  }, t.prototype.processPointerUp = function(e, r, S) {
    var T = e.data, D = e.data.identifier, N = r.trackedPointers[D], B = T.pointerType === "touch", $ = T.pointerType === "mouse" || T.pointerType === "pen", U = !1;
    if ($) {
      var H = T.button === 2, V = InteractionTrackingData.FLAGS, X = H ? V.RIGHT_DOWN : V.LEFT_DOWN, W = N !== void 0 && N.flags & X;
      S ? (this.dispatchEvent(r, H ? "rightup" : "mouseup", e), W && (this.dispatchEvent(r, H ? "rightclick" : "click", e), U = !0)) : W && this.dispatchEvent(r, H ? "rightupoutside" : "mouseupoutside", e), N && (H ? N.rightDown = !1 : N.leftDown = !1);
    }
    S ? (this.dispatchEvent(r, "pointerup", e), B && this.dispatchEvent(r, "touchend", e), N && ((!$ || U) && this.dispatchEvent(r, "pointertap", e), B && (this.dispatchEvent(r, "tap", e), N.over = !1))) : N && (this.dispatchEvent(r, "pointerupoutside", e), B && this.dispatchEvent(r, "touchendoutside", e)), N && N.none && delete r.trackedPointers[D];
  }, t.prototype.onPointerMove = function(e) {
    if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
      var r = this.normalizeToPointerData(e);
      (r[0].pointerType === "mouse" || r[0].pointerType === "pen") && (this._didMove = !0, this.cursor = null);
      for (var S = r.length, T = 0; T < S; T++) {
        var D = r[T], N = this.getInteractionDataForPointerId(D), B = this.configureInteractionEventForDOMEvent(this.eventData, D, N);
        B.data.originalEvent = e, this.processInteractive(B, this.lastObjectRendered, this.processPointerMove, !0), this.emit("pointermove", B), D.pointerType === "touch" && this.emit("touchmove", B), (D.pointerType === "mouse" || D.pointerType === "pen") && this.emit("mousemove", B);
      }
      r[0].pointerType === "mouse" && this.setCursorMode(this.cursor);
    }
  }, t.prototype.processPointerMove = function(e, r, S) {
    var T = e.data, D = T.pointerType === "touch", N = T.pointerType === "mouse" || T.pointerType === "pen";
    N && this.processPointerOverOut(e, r, S), (!this.moveWhenInside || S) && (this.dispatchEvent(r, "pointermove", e), D && this.dispatchEvent(r, "touchmove", e), N && this.dispatchEvent(r, "mousemove", e));
  }, t.prototype.onPointerOut = function(e) {
    if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
      var r = this.normalizeToPointerData(e), S = r[0];
      S.pointerType === "mouse" && (this.mouseOverRenderer = !1, this.setCursorMode(null));
      var T = this.getInteractionDataForPointerId(S), D = this.configureInteractionEventForDOMEvent(this.eventData, S, T);
      D.data.originalEvent = S, this.processInteractive(D, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit("pointerout", D), S.pointerType === "mouse" || S.pointerType === "pen" ? this.emit("mouseout", D) : this.releaseInteractionDataForPointerId(T.identifier);
    }
  }, t.prototype.processPointerOverOut = function(e, r, S) {
    var T = e.data, D = e.data.identifier, N = T.pointerType === "mouse" || T.pointerType === "pen", B = r.trackedPointers[D];
    S && !B && (B = r.trackedPointers[D] = new InteractionTrackingData(D)), B !== void 0 && (S && this.mouseOverRenderer ? (B.over || (B.over = !0, this.delayDispatchEvent(r, "pointerover", e), N && this.delayDispatchEvent(r, "mouseover", e)), N && this.cursor === null && (this.cursor = r.cursor)) : B.over && (B.over = !1, this.dispatchEvent(r, "pointerout", this.eventData), N && this.dispatchEvent(r, "mouseout", e), B.none && delete r.trackedPointers[D]));
  }, t.prototype.onPointerOver = function(e) {
    if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
      var r = this.normalizeToPointerData(e), S = r[0], T = this.getInteractionDataForPointerId(S), D = this.configureInteractionEventForDOMEvent(this.eventData, S, T);
      D.data.originalEvent = S, S.pointerType === "mouse" && (this.mouseOverRenderer = !0), this.emit("pointerover", D), (S.pointerType === "mouse" || S.pointerType === "pen") && this.emit("mouseover", D);
    }
  }, t.prototype.getInteractionDataForPointerId = function(e) {
    var r = e.pointerId, S;
    return r === MOUSE_POINTER_ID || e.pointerType === "mouse" ? S = this.mouse : this.activeInteractionData[r] ? S = this.activeInteractionData[r] : (S = this.interactionDataPool.pop() || new InteractionData(), S.identifier = r, this.activeInteractionData[r] = S), S.copyEvent(e), S;
  }, t.prototype.releaseInteractionDataForPointerId = function(e) {
    var r = this.activeInteractionData[e];
    r && (delete this.activeInteractionData[e], r.reset(), this.interactionDataPool.push(r));
  }, t.prototype.configureInteractionEventForDOMEvent = function(e, r, S) {
    return e.data = S, this.mapPositionToPoint(S.global, r.clientX, r.clientY), r.pointerType === "touch" && (r.globalX = S.global.x, r.globalY = S.global.y), S.originalEvent = r, e.reset(), e;
  }, t.prototype.normalizeToPointerData = function(e) {
    var r = [];
    if (this.supportsTouchEvents && e instanceof TouchEvent)
      for (var S = 0, T = e.changedTouches.length; S < T; S++) {
        var D = e.changedTouches[S];
        typeof D.button > "u" && (D.button = e.touches.length ? 1 : 0), typeof D.buttons > "u" && (D.buttons = e.touches.length ? 1 : 0), typeof D.isPrimary > "u" && (D.isPrimary = e.touches.length === 1 && e.type === "touchstart"), typeof D.width > "u" && (D.width = D.radiusX || 1), typeof D.height > "u" && (D.height = D.radiusY || 1), typeof D.tiltX > "u" && (D.tiltX = 0), typeof D.tiltY > "u" && (D.tiltY = 0), typeof D.pointerType > "u" && (D.pointerType = "touch"), typeof D.pointerId > "u" && (D.pointerId = D.identifier || 0), typeof D.pressure > "u" && (D.pressure = D.force || 0.5), typeof D.twist > "u" && (D.twist = 0), typeof D.tangentialPressure > "u" && (D.tangentialPressure = 0), typeof D.layerX > "u" && (D.layerX = D.offsetX = D.clientX), typeof D.layerY > "u" && (D.layerY = D.offsetY = D.clientY), D.isNormalized = !0, r.push(D);
      }
    else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {
      var N = e;
      typeof N.isPrimary > "u" && (N.isPrimary = !0), typeof N.width > "u" && (N.width = 1), typeof N.height > "u" && (N.height = 1), typeof N.tiltX > "u" && (N.tiltX = 0), typeof N.tiltY > "u" && (N.tiltY = 0), typeof N.pointerType > "u" && (N.pointerType = "mouse"), typeof N.pointerId > "u" && (N.pointerId = MOUSE_POINTER_ID), typeof N.pressure > "u" && (N.pressure = 0.5), typeof N.twist > "u" && (N.twist = 0), typeof N.tangentialPressure > "u" && (N.tangentialPressure = 0), N.isNormalized = !0, r.push(N);
    } else
      r.push(e);
    return r;
  }, t.prototype.destroy = function() {
    this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;
  }, t.extension = {
    name: "interaction",
    type: [
      ExtensionType.RendererPlugin,
      ExtensionType.CanvasRendererPlugin
    ]
  }, t;
}(eventemitter3Exports);
/*!
 * @pixi/extract - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var TEMP_RECT = new Rectangle(), BYTES_PER_PIXEL = 4, Extract = function() {
  function o(t) {
    this.renderer = t;
  }
  return o.prototype.image = function(t, e, r) {
    var S = new Image();
    return S.src = this.base64(t, e, r), S;
  }, o.prototype.base64 = function(t, e, r) {
    return this.canvas(t).toDataURL(e, r);
  }, o.prototype.canvas = function(t, e) {
    var r = this.renderer, S, T = !1, D, N = !1;
    t && (t instanceof RenderTexture ? D = t : (D = this.renderer.generateTexture(t), N = !0)), D ? (S = D.baseTexture.resolution, e = e ?? D.frame, T = !1, r.renderTexture.bind(D)) : (S = r.resolution, e || (e = TEMP_RECT, e.width = r.width, e.height = r.height), T = !0, r.renderTexture.bind(null));
    var B = Math.round(e.width * S), $ = Math.round(e.height * S), U = new CanvasRenderTarget(B, $, 1), H = new Uint8Array(BYTES_PER_PIXEL * B * $), V = r.gl;
    V.readPixels(Math.round(e.x * S), Math.round(e.y * S), B, $, V.RGBA, V.UNSIGNED_BYTE, H);
    var X = U.context.getImageData(0, 0, B, $);
    if (o.arrayPostDivide(H, X.data), U.context.putImageData(X, 0, 0), T) {
      var W = new CanvasRenderTarget(U.width, U.height, 1);
      W.context.scale(1, -1), W.context.drawImage(U.canvas, 0, -$), U.destroy(), U = W;
    }
    return N && D.destroy(!0), U.canvas;
  }, o.prototype.pixels = function(t, e) {
    var r = this.renderer, S, T, D = !1;
    t && (t instanceof RenderTexture ? T = t : (T = this.renderer.generateTexture(t), D = !0)), T ? (S = T.baseTexture.resolution, e = e ?? T.frame, r.renderTexture.bind(T)) : (S = r.resolution, e || (e = TEMP_RECT, e.width = r.width, e.height = r.height), r.renderTexture.bind(null));
    var N = Math.round(e.width * S), B = Math.round(e.height * S), $ = new Uint8Array(BYTES_PER_PIXEL * N * B), U = r.gl;
    return U.readPixels(Math.round(e.x * S), Math.round(e.y * S), N, B, U.RGBA, U.UNSIGNED_BYTE, $), D && T.destroy(!0), o.arrayPostDivide($, $), $;
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o.arrayPostDivide = function(t, e) {
    for (var r = 0; r < t.length; r += 4) {
      var S = e[r + 3] = t[r + 3];
      S !== 0 ? (e[r] = Math.round(Math.min(t[r] * 255 / S, 255)), e[r + 1] = Math.round(Math.min(t[r + 1] * 255 / S, 255)), e[r + 2] = Math.round(Math.min(t[r + 2] * 255 / S, 255))) : (e[r] = t[r], e[r + 1] = t[r + 1], e[r + 2] = t[r + 2]);
    }
  }, o.extension = {
    name: "extract",
    type: ExtensionType.RendererPlugin
  }, o;
}();
/*!
 * @pixi/loaders - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var SignalBinding = function() {
  function o(t, e, r) {
    e === void 0 && (e = !1), this._fn = t, this._once = e, this._thisArg = r, this._next = this._prev = this._owner = null;
  }
  return o.prototype.detach = function() {
    return this._owner === null ? !1 : (this._owner.detach(this), !0);
  }, o;
}();
function _addSignalBinding(o, t) {
  return o._head ? (o._tail._next = t, t._prev = o._tail, o._tail = t) : (o._head = t, o._tail = t), t._owner = o, t;
}
var Signal = function() {
  function o() {
    this._head = this._tail = void 0;
  }
  return o.prototype.handlers = function(t) {
    t === void 0 && (t = !1);
    var e = this._head;
    if (t)
      return !!e;
    for (var r = []; e; )
      r.push(e), e = e._next;
    return r;
  }, o.prototype.has = function(t) {
    if (!(t instanceof SignalBinding))
      throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
    return t._owner === this;
  }, o.prototype.dispatch = function() {
    for (var t = arguments, e = [], r = 0; r < arguments.length; r++)
      e[r] = t[r];
    var S = this._head;
    if (!S)
      return !1;
    for (; S; )
      S._once && this.detach(S), S._fn.apply(S._thisArg, e), S = S._next;
    return !0;
  }, o.prototype.add = function(t, e) {
    if (e === void 0 && (e = null), typeof t != "function")
      throw new Error("MiniSignal#add(): First arg must be a Function.");
    return _addSignalBinding(this, new SignalBinding(t, !1, e));
  }, o.prototype.once = function(t, e) {
    if (e === void 0 && (e = null), typeof t != "function")
      throw new Error("MiniSignal#once(): First arg must be a Function.");
    return _addSignalBinding(this, new SignalBinding(t, !0, e));
  }, o.prototype.detach = function(t) {
    if (!(t instanceof SignalBinding))
      throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
    return t._owner !== this ? this : (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, t._next === null && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null, this);
  }, o.prototype.detachAll = function() {
    var t = this._head;
    if (!t)
      return this;
    for (this._head = this._tail = null; t; )
      t._owner = null, t = t._next;
    return this;
  }, o;
}();
function parseUri(o, t) {
  t = t || {};
  for (var e = {
    // eslint-disable-next-line max-len
    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
    q: {
      name: "queryKey",
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      // eslint-disable-next-line max-len
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      // eslint-disable-next-line max-len
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  }, r = e.parser[t.strictMode ? "strict" : "loose"].exec(o), S = {}, T = 14; T--; )
    S[e.key[T]] = r[T] || "";
  return S[e.q.name] = {}, S[e.key[12]].replace(e.q.parser, function(D, N, B) {
    N && (S[e.q.name][N] = B);
  }), S;
}
var useXdr, tempAnchor = null, STATUS_NONE = 0, STATUS_OK = 200, STATUS_EMPTY = 204, STATUS_IE_BUG_EMPTY = 1223, STATUS_TYPE_OK = 2;
function _noop$1() {
}
function setExtMap(o, t, e) {
  t && t.indexOf(".") === 0 && (t = t.substring(1)), t && (o[t] = e);
}
function reqType(o) {
  return o.toString().replace("object ", "");
}
var LoaderResource = function() {
  function o(t, e, r) {
    if (this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof t != "string" || typeof e != "string")
      throw new Error("Both name and url are required for constructing a resource.");
    r = r || {}, this._flags = 0, this._setFlag(o.STATUS_FLAGS.DATA_URL, e.indexOf("data:") === 0), this.name = t, this.url = e, this.extension = this._getExtension(), this.data = null, this.crossOrigin = r.crossOrigin === !0 ? "anonymous" : r.crossOrigin, this.timeout = r.timeout || 0, this.loadType = r.loadType || this._determineLoadType(), this.xhrType = r.xhrType, this.metadata = r.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = o.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new Signal(), this.onProgress = new Signal(), this.onComplete = new Signal(), this.onAfterMiddleware = new Signal();
  }
  return o.setExtensionLoadType = function(t, e) {
    setExtMap(o._loadTypeMap, t, e);
  }, o.setExtensionXhrType = function(t, e) {
    setExtMap(o._xhrTypeMap, t, e);
  }, Object.defineProperty(o.prototype, "isDataUrl", {
    /**
     * When the resource starts to load.
     * @memberof PIXI.LoaderResource
     * @callback OnStartSignal
     * @param {PIXI.Resource} resource - The resource that the event happened on.
     */
    /**
     * When the resource reports loading progress.
     * @memberof PIXI.LoaderResource
     * @callback OnProgressSignal
     * @param {PIXI.Resource} resource - The resource that the event happened on.
     * @param {number} percentage - The progress of the load in the range [0, 1].
     */
    /**
     * When the resource finishes loading.
     * @memberof PIXI.LoaderResource
     * @callback OnCompleteSignal
     * @param {PIXI.Resource} resource - The resource that the event happened on.
     */
    /**
     * @memberof PIXI.LoaderResource
     * @typedef {object} IMetadata
     * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
     *      element to use for loading, instead of creating one.
     * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
     *      is useful if you want to pass in a `loadElement` that you already added load sources to.
     * @property {string|string[]} [mimeType] - The mime type to use for the source element
     *      of a video/audio elment. If the urls are an array, you can pass this as an array as well
     *      where each index is the mime type to use for the corresponding url index.
     */
    /**
     * Stores whether or not this url is a data url.
     * @readonly
     * @member {boolean}
     */
    get: function() {
      return this._hasFlag(o.STATUS_FLAGS.DATA_URL);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "isComplete", {
    /**
     * Describes if this resource has finished loading. Is true when the resource has completely
     * loaded.
     * @readonly
     * @member {boolean}
     */
    get: function() {
      return this._hasFlag(o.STATUS_FLAGS.COMPLETE);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "isLoading", {
    /**
     * Describes if this resource is currently loading. Is true when the resource starts loading,
     * and is false again when complete.
     * @readonly
     * @member {boolean}
     */
    get: function() {
      return this._hasFlag(o.STATUS_FLAGS.LOADING);
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.complete = function() {
    this._clearEvents(), this._finish();
  }, o.prototype.abort = function(t) {
    if (!this.error) {
      if (this.error = new Error(t), this._clearEvents(), this.xhr)
        this.xhr.abort();
      else if (this.xdr)
        this.xdr.abort();
      else if (this.data)
        if (this.data.src)
          this.data.src = o.EMPTY_GIF;
        else
          for (; this.data.firstChild; )
            this.data.removeChild(this.data.firstChild);
      this._finish();
    }
  }, o.prototype.load = function(t) {
    var e = this;
    if (!this.isLoading) {
      if (this.isComplete) {
        t && setTimeout(function() {
          return t(e);
        }, 1);
        return;
      } else
        t && this.onComplete.once(t);
      switch (this._setFlag(o.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), (this.crossOrigin === !1 || typeof this.crossOrigin != "string") && (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
        case o.LOAD_TYPE.IMAGE:
          this.type = o.TYPE.IMAGE, this._loadElement("image");
          break;
        case o.LOAD_TYPE.AUDIO:
          this.type = o.TYPE.AUDIO, this._loadSourceElement("audio");
          break;
        case o.LOAD_TYPE.VIDEO:
          this.type = o.TYPE.VIDEO, this._loadSourceElement("video");
          break;
        case o.LOAD_TYPE.XHR:
        default:
          typeof useXdr > "u" && (useXdr = !!(globalThis.XDomainRequest && !("withCredentials" in new XMLHttpRequest()))), useXdr && this.crossOrigin ? this._loadXdr() : this._loadXhr();
          break;
      }
    }
  }, o.prototype._hasFlag = function(t) {
    return (this._flags & t) !== 0;
  }, o.prototype._setFlag = function(t, e) {
    this._flags = e ? this._flags | t : this._flags & ~t;
  }, o.prototype._clearEvents = function() {
    clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));
  }, o.prototype._finish = function() {
    if (this.isComplete)
      throw new Error("Complete called again for an already completed resource.");
    this._setFlag(o.STATUS_FLAGS.COMPLETE, !0), this._setFlag(o.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this);
  }, o.prototype._loadElement = function(t) {
    this.metadata.loadElement ? this.data = this.metadata.loadElement : t === "image" && typeof globalThis.Image < "u" ? this.data = new Image() : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
  }, o.prototype._loadSourceElement = function(t) {
    if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t === "audio" && typeof globalThis.Audio < "u" ? this.data = new Audio() : this.data = document.createElement(t), this.data === null) {
      this.abort("Unsupported element: " + t);
      return;
    }
    if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)
      if (navigator.isCocoonJS)
        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
      else if (Array.isArray(this.url))
        for (var e = this.metadata.mimeType, r = 0; r < this.url.length; ++r)
          this.data.appendChild(this._createSource(t, this.url[r], Array.isArray(e) ? e[r] : e));
      else {
        var e = this.metadata.mimeType;
        this.data.appendChild(this._createSource(t, this.url, Array.isArray(e) ? e[0] : e));
      }
    this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
  }, o.prototype._loadXhr = function() {
    typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
    var t = this.xhr = new XMLHttpRequest();
    this.crossOrigin === "use-credentials" && (t.withCredentials = !0), t.open("GET", this.url, !0), t.timeout = this.timeout, this.xhrType === o.XHR_RESPONSE_TYPE.JSON || this.xhrType === o.XHR_RESPONSE_TYPE.DOCUMENT ? t.responseType = o.XHR_RESPONSE_TYPE.TEXT : t.responseType = this.xhrType, t.addEventListener("error", this._boundXhrOnError, !1), t.addEventListener("timeout", this._boundXhrOnTimeout, !1), t.addEventListener("abort", this._boundXhrOnAbort, !1), t.addEventListener("progress", this._boundOnProgress, !1), t.addEventListener("load", this._boundXhrOnLoad, !1), t.send();
  }, o.prototype._loadXdr = function() {
    typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
    var t = this.xhr = new globalThis.XDomainRequest();
    t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open("GET", this.url, !0), setTimeout(function() {
      return t.send();
    }, 1);
  }, o.prototype._createSource = function(t, e, r) {
    r || (r = t + "/" + this._getExtension(e));
    var S = document.createElement("source");
    return S.src = e, S.type = r, S;
  }, o.prototype._onError = function(t) {
    this.abort("Failed to load element using: " + t.target.nodeName);
  }, o.prototype._onProgress = function(t) {
    t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total);
  }, o.prototype._onTimeout = function() {
    this.abort("Load timed out.");
  }, o.prototype._xhrOnError = function() {
    var t = this.xhr;
    this.abort(reqType(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"');
  }, o.prototype._xhrOnTimeout = function() {
    var t = this.xhr;
    this.abort(reqType(t) + " Request timed out.");
  }, o.prototype._xhrOnAbort = function() {
    var t = this.xhr;
    this.abort(reqType(t) + " Request was aborted by the user.");
  }, o.prototype._xhrOnLoad = function() {
    var t = this.xhr, e = "", r = typeof t.status > "u" ? STATUS_OK : t.status;
    (t.responseType === "" || t.responseType === "text" || typeof t.responseType > "u") && (e = t.responseText), r === STATUS_NONE && (e.length > 0 || t.responseType === o.XHR_RESPONSE_TYPE.BUFFER) ? r = STATUS_OK : r === STATUS_IE_BUG_EMPTY && (r = STATUS_EMPTY);
    var S = r / 100 | 0;
    if (S === STATUS_TYPE_OK)
      if (this.xhrType === o.XHR_RESPONSE_TYPE.TEXT)
        this.data = e, this.type = o.TYPE.TEXT;
      else if (this.xhrType === o.XHR_RESPONSE_TYPE.JSON)
        try {
          this.data = JSON.parse(e), this.type = o.TYPE.JSON;
        } catch (N) {
          this.abort("Error trying to parse loaded json: " + N);
          return;
        }
      else if (this.xhrType === o.XHR_RESPONSE_TYPE.DOCUMENT)
        try {
          if (globalThis.DOMParser) {
            var T = new DOMParser();
            this.data = T.parseFromString(e, "text/xml");
          } else {
            var D = document.createElement("div");
            D.innerHTML = e, this.data = D;
          }
          this.type = o.TYPE.XML;
        } catch (N) {
          this.abort("Error trying to parse loaded xml: " + N);
          return;
        }
      else
        this.data = t.response || e;
    else {
      this.abort("[" + t.status + "] " + t.statusText + ": " + t.responseURL);
      return;
    }
    this.complete();
  }, o.prototype._determineCrossOrigin = function(t, e) {
    if (t.indexOf("data:") === 0)
      return "";
    if (globalThis.origin !== globalThis.location.origin)
      return "anonymous";
    e = e || globalThis.location, tempAnchor || (tempAnchor = document.createElement("a")), tempAnchor.href = t;
    var r = parseUri(tempAnchor.href, { strictMode: !0 }), S = !r.port && e.port === "" || r.port === e.port, T = r.protocol ? r.protocol + ":" : "";
    return r.host !== e.hostname || !S || T !== e.protocol ? "anonymous" : "";
  }, o.prototype._determineXhrType = function() {
    return o._xhrTypeMap[this.extension] || o.XHR_RESPONSE_TYPE.TEXT;
  }, o.prototype._determineLoadType = function() {
    return o._loadTypeMap[this.extension] || o.LOAD_TYPE.XHR;
  }, o.prototype._getExtension = function(t) {
    t === void 0 && (t = this.url);
    var e = "";
    if (this.isDataUrl) {
      var r = t.indexOf("/");
      e = t.substring(r + 1, t.indexOf(";", r));
    } else {
      var S = t.indexOf("?"), T = t.indexOf("#"), D = Math.min(S > -1 ? S : t.length, T > -1 ? T : t.length);
      t = t.substring(0, D), e = t.substring(t.lastIndexOf(".") + 1);
    }
    return e.toLowerCase();
  }, o.prototype._getMimeFromXhrType = function(t) {
    switch (t) {
      case o.XHR_RESPONSE_TYPE.BUFFER:
        return "application/octet-binary";
      case o.XHR_RESPONSE_TYPE.BLOB:
        return "application/blob";
      case o.XHR_RESPONSE_TYPE.DOCUMENT:
        return "application/xml";
      case o.XHR_RESPONSE_TYPE.JSON:
        return "application/json";
      case o.XHR_RESPONSE_TYPE.DEFAULT:
      case o.XHR_RESPONSE_TYPE.TEXT:
      default:
        return "text/plain";
    }
  }, o;
}();
(function(o) {
  (function(t) {
    t[t.NONE = 0] = "NONE", t[t.DATA_URL = 1] = "DATA_URL", t[t.COMPLETE = 2] = "COMPLETE", t[t.LOADING = 4] = "LOADING";
  })(o.STATUS_FLAGS || (o.STATUS_FLAGS = {})), function(t) {
    t[t.UNKNOWN = 0] = "UNKNOWN", t[t.JSON = 1] = "JSON", t[t.XML = 2] = "XML", t[t.IMAGE = 3] = "IMAGE", t[t.AUDIO = 4] = "AUDIO", t[t.VIDEO = 5] = "VIDEO", t[t.TEXT = 6] = "TEXT";
  }(o.TYPE || (o.TYPE = {})), function(t) {
    t[t.XHR = 1] = "XHR", t[t.IMAGE = 2] = "IMAGE", t[t.AUDIO = 3] = "AUDIO", t[t.VIDEO = 4] = "VIDEO";
  }(o.LOAD_TYPE || (o.LOAD_TYPE = {})), function(t) {
    t.DEFAULT = "text", t.BUFFER = "arraybuffer", t.BLOB = "blob", t.DOCUMENT = "document", t.JSON = "json", t.TEXT = "text";
  }(o.XHR_RESPONSE_TYPE || (o.XHR_RESPONSE_TYPE = {})), o._loadTypeMap = {
    // images
    gif: o.LOAD_TYPE.IMAGE,
    png: o.LOAD_TYPE.IMAGE,
    bmp: o.LOAD_TYPE.IMAGE,
    jpg: o.LOAD_TYPE.IMAGE,
    jpeg: o.LOAD_TYPE.IMAGE,
    tif: o.LOAD_TYPE.IMAGE,
    tiff: o.LOAD_TYPE.IMAGE,
    webp: o.LOAD_TYPE.IMAGE,
    tga: o.LOAD_TYPE.IMAGE,
    avif: o.LOAD_TYPE.IMAGE,
    svg: o.LOAD_TYPE.IMAGE,
    "svg+xml": o.LOAD_TYPE.IMAGE,
    // audio
    mp3: o.LOAD_TYPE.AUDIO,
    ogg: o.LOAD_TYPE.AUDIO,
    wav: o.LOAD_TYPE.AUDIO,
    // videos
    mp4: o.LOAD_TYPE.VIDEO,
    webm: o.LOAD_TYPE.VIDEO
  }, o._xhrTypeMap = {
    // xml
    xhtml: o.XHR_RESPONSE_TYPE.DOCUMENT,
    html: o.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: o.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: o.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: o.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: o.XHR_RESPONSE_TYPE.DOCUMENT,
    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
    // this should probably be fine.
    tsx: o.XHR_RESPONSE_TYPE.DOCUMENT,
    // images
    gif: o.XHR_RESPONSE_TYPE.BLOB,
    png: o.XHR_RESPONSE_TYPE.BLOB,
    bmp: o.XHR_RESPONSE_TYPE.BLOB,
    jpg: o.XHR_RESPONSE_TYPE.BLOB,
    jpeg: o.XHR_RESPONSE_TYPE.BLOB,
    tif: o.XHR_RESPONSE_TYPE.BLOB,
    tiff: o.XHR_RESPONSE_TYPE.BLOB,
    webp: o.XHR_RESPONSE_TYPE.BLOB,
    tga: o.XHR_RESPONSE_TYPE.BLOB,
    avif: o.XHR_RESPONSE_TYPE.BLOB,
    // json
    json: o.XHR_RESPONSE_TYPE.JSON,
    // text
    text: o.XHR_RESPONSE_TYPE.TEXT,
    txt: o.XHR_RESPONSE_TYPE.TEXT,
    // fonts
    ttf: o.XHR_RESPONSE_TYPE.BUFFER,
    otf: o.XHR_RESPONSE_TYPE.BUFFER
  }, o.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
})(LoaderResource || (LoaderResource = {}));
function _noop() {
}
function onlyOnce(o) {
  return function() {
    for (var e = arguments, r = [], S = 0; S < arguments.length; S++)
      r[S] = e[S];
    if (o === null)
      throw new Error("Callback was already called.");
    var T = o;
    o = null, T.apply(this, r);
  };
}
var AsyncQueueItem = function() {
  function o(t, e) {
    this.data = t, this.callback = e;
  }
  return o;
}(), AsyncQueue = function() {
  function o(t, e) {
    var r = this;
    if (e === void 0 && (e = 1), this.workers = 0, this.saturated = _noop, this.unsaturated = _noop, this.empty = _noop, this.drain = _noop, this.error = _noop, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function(S, T, D) {
      if (D && typeof D != "function")
        throw new Error("task callback must be a function");
      if (r.started = !0, S == null && r.idle()) {
        setTimeout(function() {
          return r.drain();
        }, 1);
        return;
      }
      var N = new AsyncQueueItem(S, typeof D == "function" ? D : _noop);
      T ? r._tasks.unshift(N) : r._tasks.push(N), setTimeout(r.process, 1);
    }, this.process = function() {
      for (; !r.paused && r.workers < r.concurrency && r._tasks.length; ) {
        var S = r._tasks.shift();
        r._tasks.length === 0 && r.empty(), r.workers += 1, r.workers === r.concurrency && r.saturated(), r._worker(S.data, onlyOnce(r._next(S)));
      }
    }, this._worker = t, e === 0)
      throw new Error("Concurrency must not be zero");
    this.concurrency = e, this.buffer = e / 4;
  }
  return o.prototype._next = function(t) {
    var e = this;
    return function() {
      for (var r = arguments, S = [], T = 0; T < arguments.length; T++)
        S[T] = r[T];
      e.workers -= 1, t.callback.apply(t, S), S[0] != null && e.error(S[0], t.data), e.workers <= e.concurrency - e.buffer && e.unsaturated(), e.idle() && e.drain(), e.process();
    };
  }, o.prototype.push = function(t, e) {
    this._insert(t, !1, e);
  }, o.prototype.kill = function() {
    this.workers = 0, this.drain = _noop, this.started = !1, this._tasks = [];
  }, o.prototype.unshift = function(t, e) {
    this._insert(t, !0, e);
  }, o.prototype.length = function() {
    return this._tasks.length;
  }, o.prototype.running = function() {
    return this.workers;
  }, o.prototype.idle = function() {
    return this._tasks.length + this.workers === 0;
  }, o.prototype.pause = function() {
    this.paused !== !0 && (this.paused = !0);
  }, o.prototype.resume = function() {
    if (this.paused !== !1) {
      this.paused = !1;
      for (var t = 1; t <= this.concurrency; t++)
        this.process();
    }
  }, o.eachSeries = function(t, e, r, S) {
    var T = 0, D = t.length;
    function N(B) {
      if (B || T === D) {
        r && r(B);
        return;
      }
      S ? setTimeout(function() {
        e(t[T++], N);
      }, 1) : e(t[T++], N);
    }
    N();
  }, o.queue = function(t, e) {
    return new o(t, e);
  }, o;
}(), MAX_PROGRESS = 100, rgxExtractUrlHash = /(#[\w-]+)?$/, Loader = function() {
  function o(t, e) {
    var r = this;
    t === void 0 && (t = ""), e === void 0 && (e = 10), this.progress = 0, this.loading = !1, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(B, $) {
      return r._loadResource(B, $);
    }, this.resources = {}, this.baseUrl = t, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(B, $) {
      return r._loadResource(B, $);
    }, this._queue = AsyncQueue.queue(this._boundLoadResource, e), this._queue.pause(), this.resources = {}, this.onProgress = new Signal(), this.onError = new Signal(), this.onLoad = new Signal(), this.onStart = new Signal(), this.onComplete = new Signal();
    for (var S = 0; S < o._plugins.length; ++S) {
      var T = o._plugins[S], D = T.pre, N = T.use;
      D && this.pre(D), N && this.use(N);
    }
    this._protected = !1;
  }
  return o.prototype._add = function(t, e, r, S) {
    if (this.loading && (!r || !r.parentResource))
      throw new Error("Cannot add resources while the loader is running.");
    if (this.resources[t])
      throw new Error('Resource named "' + t + '" already exists.');
    if (e = this._prepareUrl(e), this.resources[t] = new LoaderResource(t, e, r), typeof S == "function" && this.resources[t].onAfterMiddleware.once(S), this.loading) {
      for (var T = r.parentResource, D = [], N = 0; N < T.children.length; ++N)
        T.children[N].isComplete || D.push(T.children[N]);
      var B = T.progressChunk * (D.length + 1), $ = B / (D.length + 2);
      T.children.push(this.resources[t]), T.progressChunk = $;
      for (var N = 0; N < D.length; ++N)
        D[N].progressChunk = $;
      this.resources[t].progressChunk = $;
    }
    return this._queue.push(this.resources[t]), this;
  }, o.prototype.pre = function(t) {
    return this._beforeMiddleware.push(t), this;
  }, o.prototype.use = function(t) {
    return this._afterMiddleware.push(t), this;
  }, o.prototype.reset = function() {
    this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause();
    for (var t in this.resources) {
      var e = this.resources[t];
      e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort("loader reset");
    }
    return this.resources = {}, this;
  }, o.prototype.load = function(t) {
    if (deprecation("6.5.0", "@pixi/loaders is being replaced with @pixi/assets in the next major release."), typeof t == "function" && this.onComplete.once(t), this.loading)
      return this;
    if (this._queue.idle())
      this._onStart(), this._onComplete();
    else {
      for (var e = this._queue._tasks.length, r = MAX_PROGRESS / e, S = 0; S < this._queue._tasks.length; ++S)
        this._queue._tasks[S].data.progressChunk = r;
      this._onStart(), this._queue.resume();
    }
    return this;
  }, Object.defineProperty(o.prototype, "concurrency", {
    /**
     * The number of resources to load concurrently.
     * @default 10
     */
    get: function() {
      return this._queue.concurrency;
    },
    set: function(t) {
      this._queue.concurrency = t;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype._prepareUrl = function(t) {
    var e = parseUri(t, { strictMode: !0 }), r;
    if (e.protocol || !e.path || t.indexOf("//") === 0 ? r = t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && t.charAt(0) !== "/" ? r = this.baseUrl + "/" + t : r = this.baseUrl + t, this.defaultQueryString) {
      var S = rgxExtractUrlHash.exec(r)[0];
      r = r.slice(0, r.length - S.length), r.indexOf("?") !== -1 ? r += "&" + this.defaultQueryString : r += "?" + this.defaultQueryString, r += S;
    }
    return r;
  }, o.prototype._loadResource = function(t, e) {
    var r = this;
    t._dequeue = e, AsyncQueue.eachSeries(this._beforeMiddleware, function(S, T) {
      S.call(r, t, function() {
        T(t.isComplete ? {} : null);
      });
    }, function() {
      t.isComplete ? r._onLoad(t) : (t._onLoadBinding = t.onComplete.once(r._onLoad, r), t.load());
    }, !0);
  }, o.prototype._onStart = function() {
    this.progress = 0, this.loading = !0, this.onStart.dispatch(this);
  }, o.prototype._onComplete = function() {
    this.progress = MAX_PROGRESS, this.loading = !1, this.onComplete.dispatch(this, this.resources);
  }, o.prototype._onLoad = function(t) {
    var e = this;
    t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), AsyncQueue.eachSeries(this._afterMiddleware, function(r, S) {
      r.call(e, t, S);
    }, function() {
      t.onAfterMiddleware.dispatch(t), e.progress = Math.min(MAX_PROGRESS, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && e._resourcesParsing.length === 0 && e._onComplete();
    }, !0);
  }, o.prototype.destroy = function() {
    this._protected || this.reset();
  }, Object.defineProperty(o, "shared", {
    /** A premade instance of the loader that can be used to load resources. */
    get: function() {
      var t = o._shared;
      return t || (t = new o(), t._protected = !0, o._shared = t), t;
    },
    enumerable: !1,
    configurable: !0
  }), o.registerPlugin = function(t) {
    return deprecation("6.5.0", "Loader.registerPlugin() is deprecated, use extensions.add() instead."), extensions.add({
      type: ExtensionType.Loader,
      ref: t
    }), o;
  }, o._plugins = [], o;
}();
extensions.handleByList(ExtensionType.Loader, Loader._plugins);
Loader.prototype.add = function(t, e, r, S) {
  if (Array.isArray(t)) {
    for (var T = 0; T < t.length; ++T)
      this.add(t[T]);
    return this;
  }
  if (typeof t == "object" && (r = t, S = e || r.callback || r.onComplete, e = r.url, t = r.name || r.key || r.url), typeof e != "string" && (S = r, r = e, e = t), typeof e != "string")
    throw new Error("No url passed to add resource to loader.");
  return typeof r == "function" && (S = r, r = null), this._add(t, e, r, S);
};
var AppLoaderPlugin = function() {
  function o() {
  }
  return o.init = function(t) {
    t = Object.assign({
      sharedLoader: !1
    }, t), this.loader = t.sharedLoader ? Loader.shared : new Loader();
  }, o.destroy = function() {
    this.loader && (this.loader.destroy(), this.loader = null);
  }, o.extension = ExtensionType.Application, o;
}(), TextureLoader = function() {
  function o() {
  }
  return o.add = function() {
    LoaderResource.setExtensionLoadType("svg", LoaderResource.LOAD_TYPE.XHR), LoaderResource.setExtensionXhrType("svg", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
  }, o.use = function(t, e) {
    if (t.data && (t.type === LoaderResource.TYPE.IMAGE || t.extension === "svg")) {
      var r = t.data, S = t.url, T = t.name, D = t.metadata;
      Texture.fromLoader(r, S, T, D).then(function(N) {
        t.texture = N, e();
      }).catch(e);
    } else
      e();
  }, o.extension = ExtensionType.Loader, o;
}(), _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encodeBinary(o) {
  for (var t = "", e = 0; e < o.length; ) {
    for (var r = [0, 0, 0], S = [0, 0, 0, 0], T = 0; T < r.length; ++T)
      e < o.length ? r[T] = o.charCodeAt(e++) & 255 : r[T] = 0;
    S[0] = r[0] >> 2, S[1] = (r[0] & 3) << 4 | r[1] >> 4, S[2] = (r[1] & 15) << 2 | r[2] >> 6, S[3] = r[2] & 63;
    var D = e - (o.length - 1);
    switch (D) {
      case 2:
        S[3] = 64, S[2] = 64;
        break;
      case 1:
        S[3] = 64;
        break;
    }
    for (var T = 0; T < S.length; ++T)
      t += _keyStr.charAt(S[T]);
  }
  return t;
}
function parsing(o, t) {
  if (!o.data) {
    t();
    return;
  }
  if (o.xhr && o.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {
    if (!self.Blob || typeof o.data == "string") {
      var e = o.xhr.getResponseHeader("content-type");
      if (e && e.indexOf("image") === 0) {
        o.data = new Image(), o.data.src = "data:" + e + ";base64," + encodeBinary(o.xhr.responseText), o.type = LoaderResource.TYPE.IMAGE, o.data.onload = function() {
          o.data.onload = null, t();
        };
        return;
      }
    } else if (o.data.type.indexOf("image") === 0) {
      var r = globalThis.URL || globalThis.webkitURL, S = r.createObjectURL(o.data);
      o.blob = o.data, o.data = new Image(), o.data.src = S, o.type = LoaderResource.TYPE.IMAGE, o.data.onload = function() {
        r.revokeObjectURL(S), o.data.onload = null, t();
      };
      return;
    }
  }
  t();
}
var ParsingLoader = function() {
  function o() {
  }
  return o.extension = ExtensionType.Loader, o.use = parsing, o;
}();
extensions.add(TextureLoader, ParsingLoader);
/*!
 * @pixi/compressed-textures - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/compressed-textures is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var _a$2, INTERNAL_FORMATS;
(function(o) {
  o[o.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", o[o.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", o[o.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", o[o.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", o[o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", o[o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", o[o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", o[o.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", o[o.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", o[o.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", o[o.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", o[o.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", o[o.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", o[o.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", o[o.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", o[o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", o[o.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", o[o.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", o[o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", o[o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", o[o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", o[o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", o[o.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", o[o.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", o[o.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", o[o.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", o[o.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
})(INTERNAL_FORMATS || (INTERNAL_FORMATS = {}));
var INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = (_a$2 = {}, // WEBGL_compressed_texture_s3tc
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_s3tc
_a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_etc
_a$2[INTERNAL_FORMATS.COMPRESSED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, // WEBGL_compressed_texture_pvrtc
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, // WEBGL_compressed_texture_etc1
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, // @see https://www.khronos.org/registry/OpenGL/extensions/AMD/AMD_compressed_ATC_texture.txt
// WEBGL_compressed_texture_atc
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, // @see https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt
// WEBGL_compressed_texture_astc
/* eslint-disable-next-line camelcase */
_a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ASTC_4x4_KHR] = 1, _a$2);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$n = function(o, t) {
  return extendStatics$n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$n(o, t);
};
function __extends$n(o, t) {
  extendStatics$n(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function __awaiter(o, t, e, r) {
  function S(T) {
    return T instanceof e ? T : new e(function(D) {
      D(T);
    });
  }
  return new (e || (e = Promise))(function(T, D) {
    function N(U) {
      try {
        $(r.next(U));
      } catch (H) {
        D(H);
      }
    }
    function B(U) {
      try {
        $(r.throw(U));
      } catch (H) {
        D(H);
      }
    }
    function $(U) {
      U.done ? T(U.value) : S(U.value).then(N, B);
    }
    $((r = r.apply(o, t || [])).next());
  });
}
function __generator(o, t) {
  var e = { label: 0, sent: function() {
    if (T[0] & 1)
      throw T[1];
    return T[1];
  }, trys: [], ops: [] }, r, S, T, D;
  return D = { next: N(0), throw: N(1), return: N(2) }, typeof Symbol == "function" && (D[Symbol.iterator] = function() {
    return this;
  }), D;
  function N($) {
    return function(U) {
      return B([$, U]);
    };
  }
  function B($) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (r = 1, S && (T = $[0] & 2 ? S.return : $[0] ? S.throw || ((T = S.return) && T.call(S), 0) : S.next) && !(T = T.call(S, $[1])).done)
          return T;
        switch (S = 0, T && ($ = [$[0] & 2, T.value]), $[0]) {
          case 0:
          case 1:
            T = $;
            break;
          case 4:
            return e.label++, { value: $[1], done: !1 };
          case 5:
            e.label++, S = $[1], $ = [0];
            continue;
          case 7:
            $ = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (T = e.trys, !(T = T.length > 0 && T[T.length - 1]) && ($[0] === 6 || $[0] === 2)) {
              e = 0;
              continue;
            }
            if ($[0] === 3 && (!T || $[1] > T[0] && $[1] < T[3])) {
              e.label = $[1];
              break;
            }
            if ($[0] === 6 && e.label < T[1]) {
              e.label = T[1], T = $;
              break;
            }
            if (T && e.label < T[2]) {
              e.label = T[2], e.ops.push($);
              break;
            }
            T[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        $ = t.call(o, e);
      } catch (U) {
        $ = [6, U], S = 0;
      } finally {
        r = T = 0;
      }
    if ($[0] & 5)
      throw $[1];
    return { value: $[0] ? $[1] : void 0, done: !0 };
  }
}
var BlobResource = function(o) {
  __extends$n(t, o);
  function t(e, r) {
    r === void 0 && (r = { width: 1, height: 1, autoLoad: !0 });
    var S = this, T, D;
    return typeof e == "string" ? (T = e, D = new Uint8Array()) : (T = null, D = e), S = o.call(this, D, r) || this, S.origin = T, S.buffer = D ? new ViewableBuffer(D) : null, S.origin && r.autoLoad !== !1 && S.load(), D && D.length && (S.loaded = !0, S.onBlobLoaded(S.buffer.rawBinaryData)), S;
  }
  return t.prototype.onBlobLoaded = function(e) {
  }, t.prototype.load = function() {
    return __awaiter(this, void 0, Promise, function() {
      var e, r, S;
      return __generator(this, function(T) {
        switch (T.label) {
          case 0:
            return [4, fetch(this.origin)];
          case 1:
            return e = T.sent(), [4, e.blob()];
          case 2:
            return r = T.sent(), [4, r.arrayBuffer()];
          case 3:
            return S = T.sent(), this.data = new Uint32Array(S), this.buffer = new ViewableBuffer(S), this.loaded = !0, this.onBlobLoaded(S), this.update(), [2, this];
        }
      });
    });
  }, t;
}(BufferResource), CompressedTextureResource = function(o) {
  __extends$n(t, o);
  function t(e, r) {
    var S = o.call(this, e, r) || this;
    return S.format = r.format, S.levels = r.levels || 1, S._width = r.width, S._height = r.height, S._extension = t._formatToExtension(S.format), (r.levelBuffers || S.buffer) && (S._levelBuffers = r.levelBuffers || t._createLevelBuffers(
      e instanceof Uint8Array ? e : S.buffer.uint8View,
      S.format,
      S.levels,
      4,
      4,
      // PVRTC has 8x4 blocks in 2bpp mode
      S.width,
      S.height
    )), S;
  }
  return t.prototype.upload = function(e, r, S) {
    var T = e.gl, D = e.context.extensions[this._extension];
    if (!D)
      throw new Error(this._extension + " textures are not supported on the current machine");
    if (!this._levelBuffers)
      return !1;
    for (var N = 0, B = this.levels; N < B; N++) {
      var $ = this._levelBuffers[N], U = $.levelID, H = $.levelWidth, V = $.levelHeight, X = $.levelBuffer;
      T.compressedTexImage2D(T.TEXTURE_2D, U, this.format, H, V, 0, X);
    }
    return !0;
  }, t.prototype.onBlobLoaded = function() {
    this._levelBuffers = t._createLevelBuffers(
      this.buffer.uint8View,
      this.format,
      this.levels,
      4,
      4,
      // PVRTC has 8x4 blocks in 2bpp mode
      this.width,
      this.height
    );
  }, t._formatToExtension = function(e) {
    if (e >= 33776 && e <= 33779)
      return "s3tc";
    if (e >= 37488 && e <= 37497)
      return "etc";
    if (e >= 35840 && e <= 35843)
      return "pvrtc";
    if (e >= 36196)
      return "etc1";
    if (e >= 35986 && e <= 34798)
      return "atc";
    throw new Error("Invalid (compressed) texture format given!");
  }, t._createLevelBuffers = function(e, r, S, T, D, N, B) {
    for (var $ = new Array(S), U = e.byteOffset, H = N, V = B, X = H + T - 1 & ~(T - 1), W = V + D - 1 & ~(D - 1), Y = X * W * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[r], q = 0; q < S; q++)
      $[q] = {
        levelID: q,
        levelWidth: S > 1 ? H : X,
        levelHeight: S > 1 ? V : W,
        levelBuffer: new Uint8Array(e.buffer, U, Y)
      }, U += Y, H = H >> 1 || 1, V = V >> 1 || 1, X = H + T - 1 & ~(T - 1), W = V + D - 1 & ~(D - 1), Y = X * W * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[r];
    return $;
  }, t;
}(BlobResource), CompressedTextureLoader = function() {
  function o() {
  }
  return o.use = function(t, e) {
    var r = t.data, S = this;
    if (t.type === LoaderResource.TYPE.JSON && r && r.cacheID && r.textures) {
      for (var T = r.textures, D = void 0, N = void 0, B = 0, $ = T.length; B < $; B++) {
        var U = T[B], H = U.src, V = U.format;
        if (V || (N = H), o.textureFormats[V]) {
          D = H;
          break;
        }
      }
      if (D = D || N, !D) {
        e(new Error("Cannot load compressed-textures in " + t.url + ", make sure you provide a fallback"));
        return;
      }
      if (D === t.url) {
        e(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
        return;
      }
      var X = {
        crossOrigin: t.crossOrigin,
        metadata: t.metadata.imageMetadata,
        parentResource: t
      }, W = url$1.resolve(t.url.replace(S.baseUrl, ""), D), Y = r.cacheID;
      S.add(Y, W, X, function(q) {
        if (q.error) {
          e(q.error);
          return;
        }
        var K = q.texture, Z = K === void 0 ? null : K, J = q.textures, Q = J === void 0 ? {} : J;
        Object.assign(t, { texture: Z, textures: Q }), e();
      });
    } else
      e();
  }, Object.defineProperty(o, "textureExtensions", {
    /**  Map of available texture extensions. */
    get: function() {
      if (!o._textureExtensions) {
        var t = settings.ADAPTER.createCanvas(), e = t.getContext("webgl");
        if (!e)
          return console.warn("WebGL not available for compressed textures. Silently failing."), {};
        var r = {
          s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          etc: e.getExtension("WEBGL_compressed_texture_etc"),
          etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: e.getExtension("WEBGL_compressed_texture_atc"),
          astc: e.getExtension("WEBGL_compressed_texture_astc")
        };
        o._textureExtensions = r;
      }
      return o._textureExtensions;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "textureFormats", {
    /** Map of available texture formats. */
    get: function() {
      if (!o._textureFormats) {
        var t = o.textureExtensions;
        o._textureFormats = {};
        for (var e in t) {
          var r = t[e];
          r && Object.assign(o._textureFormats, Object.getPrototypeOf(r));
        }
      }
      return o._textureFormats;
    },
    enumerable: !1,
    configurable: !0
  }), o.extension = ExtensionType.Loader, o;
}();
function registerCompressedTextures(o, t, e) {
  var r = {
    textures: {},
    texture: null
  };
  if (!t)
    return r;
  var S = t.map(function(T) {
    return new Texture(new BaseTexture(T, Object.assign({
      mipmap: MIPMAP_MODES.OFF,
      alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA
    }, e)));
  });
  return S.forEach(function(T, D) {
    var N = T.baseTexture, B = o + "-" + (D + 1);
    BaseTexture.addToCache(N, B), Texture.addToCache(T, B), D === 0 && (BaseTexture.addToCache(N, o), Texture.addToCache(T, o), r.texture = T), r.textures[B] = T;
  }), r;
}
var _a$1, _b$1, DDS_MAGIC_SIZE = 4, DDS_HEADER_SIZE = 124, DDS_HEADER_PF_SIZE = 32, DDS_HEADER_DX10_SIZE = 20, DDS_MAGIC = 542327876, DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
}, DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
}, DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
}, DXGI_FORMAT;
(function(o) {
  o[o.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", o[o.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", o[o.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", o[o.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", o[o.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", o[o.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", o[o.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", o[o.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", o[o.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", o[o.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", o[o.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", o[o.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", o[o.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", o[o.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", o[o.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", o[o.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", o[o.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", o[o.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", o[o.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", o[o.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", o[o.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", o[o.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", o[o.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", o[o.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", o[o.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", o[o.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", o[o.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", o[o.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", o[o.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", o[o.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", o[o.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", o[o.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", o[o.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", o[o.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", o[o.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", o[o.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", o[o.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", o[o.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", o[o.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", o[o.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", o[o.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", o[o.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", o[o.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", o[o.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", o[o.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", o[o.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", o[o.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", o[o.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", o[o.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", o[o.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", o[o.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", o[o.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", o[o.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", o[o.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", o[o.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", o[o.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", o[o.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", o[o.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", o[o.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", o[o.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", o[o.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", o[o.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", o[o.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", o[o.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", o[o.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", o[o.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", o[o.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", o[o.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", o[o.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", o[o.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", o[o.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", o[o.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", o[o.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", o[o.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", o[o.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", o[o.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", o[o.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", o[o.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", o[o.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", o[o.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", o[o.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", o[o.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", o[o.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", o[o.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", o[o.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", o[o.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", o[o.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", o[o.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", o[o.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", o[o.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", o[o.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", o[o.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", o[o.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", o[o.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", o[o.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", o[o.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", o[o.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", o[o.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", o[o.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", o[o.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", o[o.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV", o[o.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410", o[o.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416", o[o.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12", o[o.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010", o[o.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016", o[o.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE", o[o.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2", o[o.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210", o[o.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216", o[o.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11", o[o.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44", o[o.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44", o[o.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8", o[o.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8", o[o.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", o[o.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208", o[o.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208", o[o.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408", o[o.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", o[o.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", o[o.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT";
})(DXGI_FORMAT || (DXGI_FORMAT = {}));
var D3D10_RESOURCE_DIMENSION;
(function(o) {
  o[o.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", o[o.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", o[o.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D";
})(D3D10_RESOURCE_DIMENSION || (D3D10_RESOURCE_DIMENSION = {}));
var PF_FLAGS = 1, DDPF_ALPHA = 2, DDPF_FOURCC = 4, DDPF_RGB = 64, DDPF_YUV = 512, DDPF_LUMINANCE = 131072, FOURCC_DXT1 = 827611204, FOURCC_DXT3 = 861165636, FOURCC_DXT5 = 894720068, FOURCC_DX10 = 808540228, DDS_RESOURCE_MISC_TEXTURECUBE = 4, FOURCC_TO_FORMAT = (_a$1 = {}, _a$1[FOURCC_DXT1] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _a$1[FOURCC_DXT3] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _a$1[FOURCC_DXT5] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _a$1), DXGI_TO_FORMAT = (_b$1 = {}, // WEBGL_compressed_texture_s3tc
_b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, // WEBGL_compressed_texture_s3tc_srgb
_b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _b$1);
function parseDDS(o) {
  var t = new Uint32Array(o), e = t[0];
  if (e !== DDS_MAGIC)
    throw new Error("Invalid DDS file magic word");
  var r = new Uint32Array(o, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT), S = r[DDS_FIELDS.HEIGHT], T = r[DDS_FIELDS.WIDTH], D = r[DDS_FIELDS.MIPMAP_COUNT], N = new Uint32Array(o, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT), B = N[PF_FLAGS];
  if (B & DDPF_FOURCC) {
    var $ = N[DDS_PF_FIELDS.FOURCC];
    if ($ !== FOURCC_DX10) {
      var U = FOURCC_TO_FORMAT[$], H = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, V = new Uint8Array(o, H), X = new CompressedTextureResource(V, {
        format: U,
        width: T,
        height: S,
        levels: D
        // CompressedTextureResource will separate the levelBuffers for us!
      });
      return [X];
    }
    var W = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, Y = new Uint32Array(t.buffer, W, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT), q = Y[DDS_DX10_FIELDS.DXGI_FORMAT], K = Y[DDS_DX10_FIELDS.RESOURCE_DIMENSION], Z = Y[DDS_DX10_FIELDS.MISC_FLAG], J = Y[DDS_DX10_FIELDS.ARRAY_SIZE], Q = DXGI_TO_FORMAT[q];
    if (Q === void 0)
      throw new Error("DDSParser cannot parse texture data with DXGI format " + q);
    if (Z === DDS_RESOURCE_MISC_TEXTURECUBE)
      throw new Error("DDSParser does not support cubemap textures");
    if (K === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D)
      throw new Error("DDSParser does not supported 3D texture data");
    var rt = new Array(), et = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
    if (J === 1)
      rt.push(new Uint8Array(o, et));
    else {
      for (var nt = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[Q], st = 0, it = T, ot = S, ht = 0; ht < D; ht++) {
        var ct = Math.max(1, it + 3 & -4), vt = Math.max(1, ot + 3 & -4), _t = ct * vt * nt;
        st += _t, it = it >>> 1, ot = ot >>> 1;
      }
      for (var gt = et, ht = 0; ht < J; ht++)
        rt.push(new Uint8Array(o, gt, st)), gt += st;
    }
    return rt.map(function(mt) {
      return new CompressedTextureResource(mt, {
        format: Q,
        width: T,
        height: S,
        levels: D
      });
    });
  }
  throw B & DDPF_RGB ? new Error("DDSParser does not support uncompressed texture data.") : B & DDPF_YUV ? new Error("DDSParser does not supported YUV uncompressed texture data.") : B & DDPF_LUMINANCE ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : B & DDPF_ALPHA ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
var _a$3, _b, _c, FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], ENDIANNESS = 67305985, KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
}, FILE_HEADER_SIZE = 64, TYPES_TO_BYTES_PER_COMPONENT = (_a$3 = {}, _a$3[TYPES.UNSIGNED_BYTE] = 1, _a$3[TYPES.UNSIGNED_SHORT] = 2, _a$3[TYPES.INT] = 4, _a$3[TYPES.UNSIGNED_INT] = 4, _a$3[TYPES.FLOAT] = 4, _a$3[TYPES.HALF_FLOAT] = 8, _a$3), FORMATS_TO_COMPONENTS = (_b = {}, _b[FORMATS.RGBA] = 4, _b[FORMATS.RGB] = 3, _b[FORMATS.RG] = 2, _b[FORMATS.RED] = 1, _b[FORMATS.LUMINANCE] = 1, _b[FORMATS.LUMINANCE_ALPHA] = 2, _b[FORMATS.ALPHA] = 1, _b), TYPES_TO_BYTES_PER_PIXEL = (_c = {}, _c[TYPES.UNSIGNED_SHORT_4_4_4_4] = 2, _c[TYPES.UNSIGNED_SHORT_5_5_5_1] = 2, _c[TYPES.UNSIGNED_SHORT_5_6_5] = 2, _c);
function parseKTX(o, t, e) {
  e === void 0 && (e = !1);
  var r = new DataView(t);
  if (!validate(o, r))
    return null;
  var S = r.getUint32(KTX_FIELDS.ENDIANNESS, !0) === ENDIANNESS, T = r.getUint32(KTX_FIELDS.GL_TYPE, S), D = r.getUint32(KTX_FIELDS.GL_FORMAT, S), N = r.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, S), B = r.getUint32(KTX_FIELDS.PIXEL_WIDTH, S), $ = r.getUint32(KTX_FIELDS.PIXEL_HEIGHT, S) || 1, U = r.getUint32(KTX_FIELDS.PIXEL_DEPTH, S) || 1, H = r.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, S) || 1, V = r.getUint32(KTX_FIELDS.NUMBER_OF_FACES, S), X = r.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, S), W = r.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, S);
  if ($ === 0 || U !== 1)
    throw new Error("Only 2D textures are supported");
  if (V !== 1)
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  if (H !== 1)
    throw new Error("WebGL does not support array textures");
  var Y = 4, q = 4, K = B + 3 & -4, Z = $ + 3 & -4, J = new Array(H), Q = B * $;
  T === 0 && (Q = K * Z);
  var rt;
  if (T !== 0 ? TYPES_TO_BYTES_PER_COMPONENT[T] ? rt = TYPES_TO_BYTES_PER_COMPONENT[T] * FORMATS_TO_COMPONENTS[D] : rt = TYPES_TO_BYTES_PER_PIXEL[T] : rt = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[N], rt === void 0)
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  for (var et = e ? parseKvData(r, W, S) : null, nt = Q * rt, st = nt, it = B, ot = $, ht = K, ct = Z, vt = FILE_HEADER_SIZE + W, _t = 0; _t < X; _t++) {
    for (var gt = r.getUint32(vt, S), mt = vt + 4, Et = 0; Et < H; Et++) {
      var wt = J[Et];
      wt || (wt = J[Et] = new Array(X)), wt[_t] = {
        levelID: _t,
        // don't align mipWidth when texture not compressed! (glType not zero)
        levelWidth: X > 1 || T !== 0 ? it : ht,
        levelHeight: X > 1 || T !== 0 ? ot : ct,
        levelBuffer: new Uint8Array(t, mt, st)
      }, mt += st;
    }
    vt += gt + 4, vt = vt % 4 !== 0 ? vt + 4 - vt % 4 : vt, it = it >> 1 || 1, ot = ot >> 1 || 1, ht = it + Y - 1 & ~(Y - 1), ct = ot + q - 1 & ~(q - 1), st = ht * ct * rt;
  }
  return T !== 0 ? {
    uncompressed: J.map(function(xt) {
      var pt = xt[0].levelBuffer, yt = !1;
      return T === TYPES.FLOAT ? pt = new Float32Array(xt[0].levelBuffer.buffer, xt[0].levelBuffer.byteOffset, xt[0].levelBuffer.byteLength / 4) : T === TYPES.UNSIGNED_INT ? (yt = !0, pt = new Uint32Array(xt[0].levelBuffer.buffer, xt[0].levelBuffer.byteOffset, xt[0].levelBuffer.byteLength / 4)) : T === TYPES.INT && (yt = !0, pt = new Int32Array(xt[0].levelBuffer.buffer, xt[0].levelBuffer.byteOffset, xt[0].levelBuffer.byteLength / 4)), {
        resource: new BufferResource(pt, {
          width: xt[0].levelWidth,
          height: xt[0].levelHeight
        }),
        type: T,
        format: yt ? convertFormatToInteger(D) : D
      };
    }),
    kvData: et
  } : {
    compressed: J.map(function(xt) {
      return new CompressedTextureResource(null, {
        format: N,
        width: B,
        height: $,
        levels: X,
        levelBuffers: xt
      });
    }),
    kvData: et
  };
}
function validate(o, t) {
  for (var e = 0; e < FILE_IDENTIFIER.length; e++)
    if (t.getUint8(e) !== FILE_IDENTIFIER[e])
      return console.error(o + " is not a valid *.ktx file!"), !1;
  return !0;
}
function convertFormatToInteger(o) {
  switch (o) {
    case FORMATS.RGBA:
      return FORMATS.RGBA_INTEGER;
    case FORMATS.RGB:
      return FORMATS.RGB_INTEGER;
    case FORMATS.RG:
      return FORMATS.RG_INTEGER;
    case FORMATS.RED:
      return FORMATS.RED_INTEGER;
    default:
      return o;
  }
}
function parseKvData(o, t, e) {
  for (var r = /* @__PURE__ */ new Map(), S = 0; S < t; ) {
    var T = o.getUint32(FILE_HEADER_SIZE + S, e), D = FILE_HEADER_SIZE + S + 4, N = 3 - (T + 3) % 4;
    if (T === 0 || T > t - S) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    for (var B = 0; B < T && o.getUint8(D + B) !== 0; B++)
      ;
    if (B === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    var $ = new TextDecoder().decode(new Uint8Array(o.buffer, D, B)), U = new DataView(o.buffer, D + B + 1, T - B - 1);
    r.set($, U), S += 4 + T + N;
  }
  return r;
}
LoaderResource.setExtensionXhrType("dds", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var DDSLoader = function() {
  function o() {
  }
  return o.use = function(t, e) {
    if (t.extension === "dds" && t.data)
      try {
        Object.assign(t, registerCompressedTextures(t.name || t.url, parseDDS(t.data), t.metadata));
      } catch (r) {
        e(r);
        return;
      }
    e();
  }, o.extension = ExtensionType.Loader, o;
}();
LoaderResource.setExtensionXhrType("ktx", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var KTXLoader = function() {
  function o() {
  }
  return o.use = function(t, e) {
    if (t.extension === "ktx" && t.data)
      try {
        var r = t.name || t.url, S = parseKTX(r, t.data, this.loadKeyValueData), T = S.compressed, D = S.uncompressed, N = S.kvData;
        if (T) {
          var B = registerCompressedTextures(r, T, t.metadata);
          if (N && B.textures)
            for (var $ in B.textures)
              B.textures[$].baseTexture.ktxKeyValueData = N;
          Object.assign(t, B);
        } else if (D) {
          var U = {};
          D.forEach(function(H, V) {
            var X = new Texture(new BaseTexture(H.resource, {
              mipmap: MIPMAP_MODES.OFF,
              alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
              type: H.type,
              format: H.format
            })), W = r + "-" + (V + 1);
            N && (X.baseTexture.ktxKeyValueData = N), BaseTexture.addToCache(X.baseTexture, W), Texture.addToCache(X, W), V === 0 && (U[r] = X, BaseTexture.addToCache(X.baseTexture, r), Texture.addToCache(X, r)), U[W] = X;
          }), Object.assign(t, { textures: U });
        }
      } catch (H) {
        e(H);
        return;
      }
    e();
  }, o.extension = ExtensionType.Loader, o.loadKeyValueData = !1, o;
}();
/*!
 * @pixi/particle-container - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/particle-container is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$m = function(o, t) {
  return extendStatics$m = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$m(o, t);
};
function __extends$m(o, t) {
  extendStatics$m(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
(function(o) {
  __extends$m(t, o);
  function t(e, r, S, T) {
    e === void 0 && (e = 1500), S === void 0 && (S = 16384), T === void 0 && (T = !1);
    var D = o.call(this) || this, N = 16384;
    return S > N && (S = N), D._properties = [!1, !0, !1, !1, !1], D._maxSize = e, D._batchSize = S, D._buffers = null, D._bufferUpdateIDs = [], D._updateID = 0, D.interactiveChildren = !1, D.blendMode = BLEND_MODES.NORMAL, D.autoResize = T, D.roundPixels = !0, D.baseTexture = null, D.setProperties(r), D._tint = 0, D.tintRgb = new Float32Array(4), D.tint = 16777215, D;
  }
  return t.prototype.setProperties = function(e) {
    e && (this._properties[0] = "vertices" in e || "scale" in e ? !!e.vertices || !!e.scale : this._properties[0], this._properties[1] = "position" in e ? !!e.position : this._properties[1], this._properties[2] = "rotation" in e ? !!e.rotation : this._properties[2], this._properties[3] = "uvs" in e ? !!e.uvs : this._properties[3], this._properties[4] = "tint" in e || "alpha" in e ? !!e.tint || !!e.alpha : this._properties[4]);
  }, t.prototype.updateTransform = function() {
    this.displayObjectUpdateTransform();
  }, Object.defineProperty(t.prototype, "tint", {
    /**
     * The tint applied to the container. This is a hex value.
     * A value of 0xFFFFFF will remove any tint effect.
     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
     * @default 0xFFFFFF
     */
    get: function() {
      return this._tint;
    },
    set: function(e) {
      this._tint = e, hex2rgb(e, this.tintRgb);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.render = function(e) {
    var r = this;
    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", function() {
      return r.onChildrenChange(0);
    })), e.batch.setObjectRenderer(e.plugins.particle), e.plugins.particle.render(this));
  }, t.prototype.onChildrenChange = function(e) {
    for (var r = Math.floor(e / this._batchSize); this._bufferUpdateIDs.length < r; )
      this._bufferUpdateIDs.push(0);
    this._bufferUpdateIDs[r] = ++this._updateID;
  }, t.prototype.dispose = function() {
    if (this._buffers) {
      for (var e = 0; e < this._buffers.length; ++e)
        this._buffers[e].destroy();
      this._buffers = null;
    }
  }, t.prototype.destroy = function(e) {
    o.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;
  }, t;
})(Container);
var ParticleBuffer = function() {
  function o(t, e, r) {
    this.geometry = new Geometry(), this.indexBuffer = null, this.size = r, this.dynamicProperties = [], this.staticProperties = [];
    for (var S = 0; S < t.length; ++S) {
      var T = t[S];
      T = {
        attributeName: T.attributeName,
        size: T.size,
        uploadFunction: T.uploadFunction,
        type: T.type || TYPES.FLOAT,
        offset: T.offset
      }, e[S] ? this.dynamicProperties.push(T) : this.staticProperties.push(T);
    }
    this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();
  }
  return o.prototype.initBuffers = function() {
    var t = this.geometry, e = 0;
    this.indexBuffer = new Buffer$1(createIndicesForQuads(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;
    for (var r = 0; r < this.dynamicProperties.length; ++r) {
      var S = this.dynamicProperties[r];
      S.offset = e, e += S.size, this.dynamicStride += S.size;
    }
    var T = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(T), this.dynamicDataUint32 = new Uint32Array(T), this.dynamicBuffer = new Buffer$1(this.dynamicData, !1, !1);
    var D = 0;
    this.staticStride = 0;
    for (var r = 0; r < this.staticProperties.length; ++r) {
      var S = this.staticProperties[r];
      S.offset = D, D += S.size, this.staticStride += S.size;
    }
    var N = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(N), this.staticDataUint32 = new Uint32Array(N), this.staticBuffer = new Buffer$1(this.staticData, !0, !1);
    for (var r = 0; r < this.dynamicProperties.length; ++r) {
      var S = this.dynamicProperties[r];
      t.addAttribute(S.attributeName, this.dynamicBuffer, 0, S.type === TYPES.UNSIGNED_BYTE, S.type, this.dynamicStride * 4, S.offset * 4);
    }
    for (var r = 0; r < this.staticProperties.length; ++r) {
      var S = this.staticProperties[r];
      t.addAttribute(S.attributeName, this.staticBuffer, 0, S.type === TYPES.UNSIGNED_BYTE, S.type, this.staticStride * 4, S.offset * 4);
    }
  }, o.prototype.uploadDynamic = function(t, e, r) {
    for (var S = 0; S < this.dynamicProperties.length; S++) {
      var T = this.dynamicProperties[S];
      T.uploadFunction(t, e, r, T.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, T.offset);
    }
    this.dynamicBuffer._updateID++;
  }, o.prototype.uploadStatic = function(t, e, r) {
    for (var S = 0; S < this.staticProperties.length; S++) {
      var T = this.staticProperties[S];
      T.uploadFunction(t, e, r, T.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, T.offset);
    }
    this.staticBuffer._updateID++;
  }, o.prototype.destroy = function() {
    this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();
  }, o;
}(), fragment$6 = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`, vertex$3 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`, ParticleRenderer = function(o) {
  __extends$m(t, o);
  function t(e) {
    var r = o.call(this, e) || this;
    return r.shader = null, r.properties = null, r.tempMatrix = new Matrix(), r.properties = [
      // verticesData
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: r.uploadVertices,
        offset: 0
      },
      // positionData
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: r.uploadPosition,
        offset: 0
      },
      // rotationData
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: r.uploadRotation,
        offset: 0
      },
      // uvsData
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: r.uploadUvs,
        offset: 0
      },
      // tintData
      {
        attributeName: "aColor",
        size: 1,
        type: TYPES.UNSIGNED_BYTE,
        uploadFunction: r.uploadTint,
        offset: 0
      }
    ], r.shader = Shader.from(vertex$3, fragment$6, {}), r.state = State.for2d(), r;
  }
  return t.prototype.render = function(e) {
    var r = e.children, S = e._maxSize, T = e._batchSize, D = this.renderer, N = r.length;
    if (N !== 0) {
      N > S && !e.autoResize && (N = S);
      var B = e._buffers;
      B || (B = e._buffers = this.generateBuffers(e));
      var $ = r[0]._texture.baseTexture, U = $.alphaMode > 0;
      this.state.blendMode = correctBlendMode(e.blendMode, U), D.state.set(this.state);
      var H = D.gl, V = e.worldTransform.copyTo(this.tempMatrix);
      V.prepend(D.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = V.toArray(!0), this.shader.uniforms.uColor = premultiplyRgba(e.tintRgb, e.worldAlpha, this.shader.uniforms.uColor, U), this.shader.uniforms.uSampler = $, this.renderer.shader.bind(this.shader);
      for (var X = !1, W = 0, Y = 0; W < N; W += T, Y += 1) {
        var q = N - W;
        q > T && (q = T), Y >= B.length && B.push(this._generateOneMoreBuffer(e));
        var K = B[Y];
        K.uploadDynamic(r, W, q);
        var Z = e._bufferUpdateIDs[Y] || 0;
        X = X || K._updateID < Z, X && (K._updateID = e._updateID, K.uploadStatic(r, W, q)), D.geometry.bind(K.geometry), H.drawElements(H.TRIANGLES, q * 6, H.UNSIGNED_SHORT, 0);
      }
    }
  }, t.prototype.generateBuffers = function(e) {
    for (var r = [], S = e._maxSize, T = e._batchSize, D = e._properties, N = 0; N < S; N += T)
      r.push(new ParticleBuffer(this.properties, D, T));
    return r;
  }, t.prototype._generateOneMoreBuffer = function(e) {
    var r = e._batchSize, S = e._properties;
    return new ParticleBuffer(this.properties, S, r);
  }, t.prototype.uploadVertices = function(e, r, S, T, D, N) {
    for (var B = 0, $ = 0, U = 0, H = 0, V = 0; V < S; ++V) {
      var X = e[r + V], W = X._texture, Y = X.scale.x, q = X.scale.y, K = W.trim, Z = W.orig;
      K ? ($ = K.x - X.anchor.x * Z.width, B = $ + K.width, H = K.y - X.anchor.y * Z.height, U = H + K.height) : (B = Z.width * (1 - X.anchor.x), $ = Z.width * -X.anchor.x, U = Z.height * (1 - X.anchor.y), H = Z.height * -X.anchor.y), T[N] = $ * Y, T[N + 1] = H * q, T[N + D] = B * Y, T[N + D + 1] = H * q, T[N + D * 2] = B * Y, T[N + D * 2 + 1] = U * q, T[N + D * 3] = $ * Y, T[N + D * 3 + 1] = U * q, N += D * 4;
    }
  }, t.prototype.uploadPosition = function(e, r, S, T, D, N) {
    for (var B = 0; B < S; B++) {
      var $ = e[r + B].position;
      T[N] = $.x, T[N + 1] = $.y, T[N + D] = $.x, T[N + D + 1] = $.y, T[N + D * 2] = $.x, T[N + D * 2 + 1] = $.y, T[N + D * 3] = $.x, T[N + D * 3 + 1] = $.y, N += D * 4;
    }
  }, t.prototype.uploadRotation = function(e, r, S, T, D, N) {
    for (var B = 0; B < S; B++) {
      var $ = e[r + B].rotation;
      T[N] = $, T[N + D] = $, T[N + D * 2] = $, T[N + D * 3] = $, N += D * 4;
    }
  }, t.prototype.uploadUvs = function(e, r, S, T, D, N) {
    for (var B = 0; B < S; ++B) {
      var $ = e[r + B]._texture._uvs;
      $ ? (T[N] = $.x0, T[N + 1] = $.y0, T[N + D] = $.x1, T[N + D + 1] = $.y1, T[N + D * 2] = $.x2, T[N + D * 2 + 1] = $.y2, T[N + D * 3] = $.x3, T[N + D * 3 + 1] = $.y3, N += D * 4) : (T[N] = 0, T[N + 1] = 0, T[N + D] = 0, T[N + D + 1] = 0, T[N + D * 2] = 0, T[N + D * 2 + 1] = 0, T[N + D * 3] = 0, T[N + D * 3 + 1] = 0, N += D * 4);
    }
  }, t.prototype.uploadTint = function(e, r, S, T, D, N) {
    for (var B = 0; B < S; ++B) {
      var $ = e[r + B], U = $._texture.baseTexture.alphaMode > 0, H = $.alpha, V = H < 1 && U ? premultiplyTint($._tintRGB, H) : $._tintRGB + (H * 255 << 24);
      T[N] = V, T[N + D] = V, T[N + D * 2] = V, T[N + D * 3] = V, N += D * 4;
    }
  }, t.prototype.destroy = function() {
    o.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;
  }, t.extension = {
    name: "particle",
    type: ExtensionType.RendererPlugin
  }, t;
}(ObjectRenderer);
/*!
 * @pixi/graphics - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/graphics is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var LINE_JOIN;
(function(o) {
  o.MITER = "miter", o.BEVEL = "bevel", o.ROUND = "round";
})(LINE_JOIN || (LINE_JOIN = {}));
var LINE_CAP;
(function(o) {
  o.BUTT = "butt", o.ROUND = "round", o.SQUARE = "square";
})(LINE_CAP || (LINE_CAP = {}));
var GRAPHICS_CURVES = {
  adaptive: !0,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount: function(o, t) {
    if (t === void 0 && (t = 20), !this.adaptive || !o || isNaN(o))
      return t;
    var e = Math.ceil(o / this.maxLength);
    return e < this.minSegments ? e = this.minSegments : e > this.maxSegments && (e = this.maxSegments), e;
  }
}, FillStyle = function() {
  function o() {
    this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1, this.reset();
  }
  return o.prototype.clone = function() {
    var t = new o();
    return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t;
  }, o.prototype.reset = function() {
    this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1;
  }, o.prototype.destroy = function() {
    this.texture = null, this.matrix = null;
  }, o;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$l = function(o, t) {
  return extendStatics$l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$l(o, t);
};
function __extends$l(o, t) {
  extendStatics$l(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function fixOrientation(o, t) {
  var e, r;
  t === void 0 && (t = !1);
  var S = o.length;
  if (!(S < 6)) {
    for (var T = 0, D = 0, N = o[S - 2], B = o[S - 1]; D < S; D += 2) {
      var $ = o[D], U = o[D + 1];
      T += ($ - N) * (U + B), N = $, B = U;
    }
    if (!t && T > 0 || t && T <= 0)
      for (var H = S / 2, D = H + H % 2; D < S; D += 2) {
        var V = S - D - 2, X = S - D - 1, W = D, Y = D + 1;
        e = [o[W], o[V]], o[V] = e[0], o[W] = e[1], r = [o[Y], o[X]], o[X] = r[0], o[Y] = r[1];
      }
  }
}
var buildPoly = {
  build: function(o) {
    o.points = o.shape.points.slice();
  },
  triangulate: function(o, t) {
    var e = o.points, r = o.holes, S = t.points, T = t.indices;
    if (e.length >= 6) {
      fixOrientation(e, !1);
      for (var D = [], N = 0; N < r.length; N++) {
        var B = r[N];
        fixOrientation(B.points, !0), D.push(e.length / 2), e = e.concat(B.points);
      }
      var $ = earcutExports(e, D, 2);
      if (!$)
        return;
      for (var U = S.length / 2, N = 0; N < $.length; N += 3)
        T.push($[N] + U), T.push($[N + 1] + U), T.push($[N + 2] + U);
      for (var N = 0; N < e.length; N++)
        S.push(e[N]);
    }
  }
}, buildCircle = {
  build: function(o) {
    var t = o.points, e, r, S, T, D, N;
    if (o.type === SHAPES.CIRC) {
      var B = o.shape;
      e = B.x, r = B.y, D = N = B.radius, S = T = 0;
    } else if (o.type === SHAPES.ELIP) {
      var $ = o.shape;
      e = $.x, r = $.y, D = $.width, N = $.height, S = T = 0;
    } else {
      var U = o.shape, H = U.width / 2, V = U.height / 2;
      e = U.x + H, r = U.y + V, D = N = Math.max(0, Math.min(U.radius, Math.min(H, V))), S = H - D, T = V - N;
    }
    if (!(D >= 0 && N >= 0 && S >= 0 && T >= 0)) {
      t.length = 0;
      return;
    }
    var X = Math.ceil(2.3 * Math.sqrt(D + N)), W = X * 8 + (S ? 4 : 0) + (T ? 4 : 0);
    if (t.length = W, W !== 0) {
      if (X === 0) {
        t.length = 8, t[0] = t[6] = e + S, t[1] = t[3] = r + T, t[2] = t[4] = e - S, t[5] = t[7] = r - T;
        return;
      }
      var Y = 0, q = X * 4 + (S ? 2 : 0) + 2, K = q, Z = W;
      {
        var J = S + D, Q = T, rt = e + J, et = e - J, nt = r + Q;
        if (t[Y++] = rt, t[Y++] = nt, t[--q] = nt, t[--q] = et, T) {
          var st = r - Q;
          t[K++] = et, t[K++] = st, t[--Z] = st, t[--Z] = rt;
        }
      }
      for (var it = 1; it < X; it++) {
        var ot = Math.PI / 2 * (it / X), J = S + Math.cos(ot) * D, Q = T + Math.sin(ot) * N, rt = e + J, et = e - J, nt = r + Q, st = r - Q;
        t[Y++] = rt, t[Y++] = nt, t[--q] = nt, t[--q] = et, t[K++] = et, t[K++] = st, t[--Z] = st, t[--Z] = rt;
      }
      {
        var J = S, Q = T + N, rt = e + J, et = e - J, nt = r + Q, st = r - Q;
        t[Y++] = rt, t[Y++] = nt, t[--Z] = st, t[--Z] = rt, S && (t[Y++] = et, t[Y++] = nt, t[--Z] = st, t[--Z] = et);
      }
    }
  },
  triangulate: function(o, t) {
    var e = o.points, r = t.points, S = t.indices;
    if (e.length !== 0) {
      var T = r.length / 2, D = T, N, B;
      if (o.type !== SHAPES.RREC) {
        var $ = o.shape;
        N = $.x, B = $.y;
      } else {
        var U = o.shape;
        N = U.x + U.width / 2, B = U.y + U.height / 2;
      }
      var H = o.matrix;
      r.push(o.matrix ? H.a * N + H.c * B + H.tx : N, o.matrix ? H.b * N + H.d * B + H.ty : B), T++, r.push(e[0], e[1]);
      for (var V = 2; V < e.length; V += 2)
        r.push(e[V], e[V + 1]), S.push(T++, D, T);
      S.push(D + 1, D, T);
    }
  }
}, buildRectangle = {
  build: function(o) {
    var t = o.shape, e = t.x, r = t.y, S = t.width, T = t.height, D = o.points;
    D.length = 0, D.push(e, r, e + S, r, e + S, r + T, e, r + T);
  },
  triangulate: function(o, t) {
    var e = o.points, r = t.points, S = r.length / 2;
    r.push(e[0], e[1], e[2], e[3], e[6], e[7], e[4], e[5]), t.indices.push(S, S + 1, S + 2, S + 1, S + 2, S + 3);
  }
};
function getPt(o, t, e) {
  var r = t - o;
  return o + r * e;
}
function quadraticBezierCurve(o, t, e, r, S, T, D) {
  D === void 0 && (D = []);
  for (var N = 20, B = D, $ = 0, U = 0, H = 0, V = 0, X = 0, W = 0, Y = 0, q = 0; Y <= N; ++Y)
    q = Y / N, $ = getPt(o, e, q), U = getPt(t, r, q), H = getPt(e, S, q), V = getPt(r, T, q), X = getPt($, H, q), W = getPt(U, V, q), !(Y === 0 && B[B.length - 2] === X && B[B.length - 1] === W) && B.push(X, W);
  return B;
}
var buildRoundedRectangle = {
  build: function(o) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.build(o);
      return;
    }
    var t = o.shape, e = o.points, r = t.x, S = t.y, T = t.width, D = t.height, N = Math.max(0, Math.min(t.radius, Math.min(T, D) / 2));
    e.length = 0, N ? (quadraticBezierCurve(r, S + N, r, S, r + N, S, e), quadraticBezierCurve(r + T - N, S, r + T, S, r + T, S + N, e), quadraticBezierCurve(r + T, S + D - N, r + T, S + D, r + T - N, S + D, e), quadraticBezierCurve(r + N, S + D, r, S + D, r, S + D - N, e)) : e.push(r, S, r + T, S, r + T, S + D, r, S + D);
  },
  triangulate: function(o, t) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.triangulate(o, t);
      return;
    }
    for (var e = o.points, r = t.points, S = t.indices, T = r.length / 2, D = earcutExports(e, null, 2), N = 0, B = D.length; N < B; N += 3)
      S.push(D[N] + T), S.push(D[N + 1] + T), S.push(D[N + 2] + T);
    for (var N = 0, B = e.length; N < B; N++)
      r.push(e[N], e[++N]);
  }
};
function square(o, t, e, r, S, T, D, N) {
  var B = o - e * S, $ = t - r * S, U = o + e * T, H = t + r * T, V, X;
  D ? (V = r, X = -e) : (V = -r, X = e);
  var W = B + V, Y = $ + X, q = U + V, K = H + X;
  return N.push(W, Y), N.push(q, K), 2;
}
function round$1(o, t, e, r, S, T, D, N) {
  var B = e - o, $ = r - t, U = Math.atan2(B, $), H = Math.atan2(S - o, T - t);
  N && U < H ? U += Math.PI * 2 : !N && U > H && (H += Math.PI * 2);
  var V = U, X = H - U, W = Math.abs(X), Y = Math.sqrt(B * B + $ * $), q = (15 * W * Math.sqrt(Y) / Math.PI >> 0) + 1, K = X / q;
  if (V += K, N) {
    D.push(o, t), D.push(e, r);
    for (var Z = 1, J = V; Z < q; Z++, J += K)
      D.push(o, t), D.push(o + Math.sin(J) * Y, t + Math.cos(J) * Y);
    D.push(o, t), D.push(S, T);
  } else {
    D.push(e, r), D.push(o, t);
    for (var Z = 1, J = V; Z < q; Z++, J += K)
      D.push(o + Math.sin(J) * Y, t + Math.cos(J) * Y), D.push(o, t);
    D.push(S, T), D.push(o, t);
  }
  return q * 2;
}
function buildNonNativeLine(o, t) {
  var e = o.shape, r = o.points || e.points.slice(), S = t.closePointEps;
  if (r.length !== 0) {
    var T = o.lineStyle, D = new Point(r[0], r[1]), N = new Point(r[r.length - 2], r[r.length - 1]), B = e.type !== SHAPES.POLY || e.closeStroke, $ = Math.abs(D.x - N.x) < S && Math.abs(D.y - N.y) < S;
    if (B) {
      r = r.slice(), $ && (r.pop(), r.pop(), N.set(r[r.length - 2], r[r.length - 1]));
      var U = (D.x + N.x) * 0.5, H = (N.y + D.y) * 0.5;
      r.unshift(U, H), r.push(U, H);
    }
    var V = t.points, X = r.length / 2, W = r.length, Y = V.length / 2, q = T.width / 2, K = q * q, Z = T.miterLimit * T.miterLimit, J = r[0], Q = r[1], rt = r[2], et = r[3], nt = 0, st = 0, it = -(Q - et), ot = J - rt, ht = 0, ct = 0, vt = Math.sqrt(it * it + ot * ot);
    it /= vt, ot /= vt, it *= q, ot *= q;
    var _t = T.alignment, gt = (1 - _t) * 2, mt = _t * 2;
    B || (T.cap === LINE_CAP.ROUND ? W += round$1(J - it * (gt - mt) * 0.5, Q - ot * (gt - mt) * 0.5, J - it * gt, Q - ot * gt, J + it * mt, Q + ot * mt, V, !0) + 2 : T.cap === LINE_CAP.SQUARE && (W += square(J, Q, it, ot, gt, mt, !0, V))), V.push(J - it * gt, Q - ot * gt), V.push(J + it * mt, Q + ot * mt);
    for (var Et = 1; Et < X - 1; ++Et) {
      J = r[(Et - 1) * 2], Q = r[(Et - 1) * 2 + 1], rt = r[Et * 2], et = r[Et * 2 + 1], nt = r[(Et + 1) * 2], st = r[(Et + 1) * 2 + 1], it = -(Q - et), ot = J - rt, vt = Math.sqrt(it * it + ot * ot), it /= vt, ot /= vt, it *= q, ot *= q, ht = -(et - st), ct = rt - nt, vt = Math.sqrt(ht * ht + ct * ct), ht /= vt, ct /= vt, ht *= q, ct *= q;
      var wt = rt - J, xt = Q - et, pt = rt - nt, yt = st - et, Dt = wt * pt + xt * yt, At = xt * pt - yt * wt, It = At < 0;
      if (Math.abs(At) < 1e-3 * Math.abs(Dt)) {
        V.push(rt - it * gt, et - ot * gt), V.push(rt + it * mt, et + ot * mt), Dt >= 0 && (T.join === LINE_JOIN.ROUND ? W += round$1(rt, et, rt - it * gt, et - ot * gt, rt - ht * gt, et - ct * gt, V, !1) + 4 : W += 2, V.push(rt - ht * mt, et - ct * mt), V.push(rt + ht * gt, et + ct * gt));
        continue;
      }
      var Ot = (-it + J) * (-ot + et) - (-it + rt) * (-ot + Q), ft = (-ht + nt) * (-ct + et) - (-ht + rt) * (-ct + st), Ft = (wt * ft - pt * Ot) / At, Mt = (yt * Ot - xt * ft) / At, zt = (Ft - rt) * (Ft - rt) + (Mt - et) * (Mt - et), Nt = rt + (Ft - rt) * gt, St = et + (Mt - et) * gt, Ht = rt - (Ft - rt) * mt, Lt = et - (Mt - et) * mt, Tt = Math.min(wt * wt + xt * xt, pt * pt + yt * yt), kt = It ? gt : mt, Ut = Tt + kt * kt * K, Ct = zt <= Ut;
      Ct ? T.join === LINE_JOIN.BEVEL || zt / K > Z ? (It ? (V.push(Nt, St), V.push(rt + it * mt, et + ot * mt), V.push(Nt, St), V.push(rt + ht * mt, et + ct * mt)) : (V.push(rt - it * gt, et - ot * gt), V.push(Ht, Lt), V.push(rt - ht * gt, et - ct * gt), V.push(Ht, Lt)), W += 2) : T.join === LINE_JOIN.ROUND ? It ? (V.push(Nt, St), V.push(rt + it * mt, et + ot * mt), W += round$1(rt, et, rt + it * mt, et + ot * mt, rt + ht * mt, et + ct * mt, V, !0) + 4, V.push(Nt, St), V.push(rt + ht * mt, et + ct * mt)) : (V.push(rt - it * gt, et - ot * gt), V.push(Ht, Lt), W += round$1(rt, et, rt - it * gt, et - ot * gt, rt - ht * gt, et - ct * gt, V, !1) + 4, V.push(rt - ht * gt, et - ct * gt), V.push(Ht, Lt)) : (V.push(Nt, St), V.push(Ht, Lt)) : (V.push(rt - it * gt, et - ot * gt), V.push(rt + it * mt, et + ot * mt), T.join === LINE_JOIN.ROUND ? It ? W += round$1(rt, et, rt + it * mt, et + ot * mt, rt + ht * mt, et + ct * mt, V, !0) + 2 : W += round$1(rt, et, rt - it * gt, et - ot * gt, rt - ht * gt, et - ct * gt, V, !1) + 2 : T.join === LINE_JOIN.MITER && zt / K <= Z && (It ? (V.push(Ht, Lt), V.push(Ht, Lt)) : (V.push(Nt, St), V.push(Nt, St)), W += 2), V.push(rt - ht * gt, et - ct * gt), V.push(rt + ht * mt, et + ct * mt), W += 2);
    }
    J = r[(X - 2) * 2], Q = r[(X - 2) * 2 + 1], rt = r[(X - 1) * 2], et = r[(X - 1) * 2 + 1], it = -(Q - et), ot = J - rt, vt = Math.sqrt(it * it + ot * ot), it /= vt, ot /= vt, it *= q, ot *= q, V.push(rt - it * gt, et - ot * gt), V.push(rt + it * mt, et + ot * mt), B || (T.cap === LINE_CAP.ROUND ? W += round$1(rt - it * (gt - mt) * 0.5, et - ot * (gt - mt) * 0.5, rt - it * gt, et - ot * gt, rt + it * mt, et + ot * mt, V, !1) + 2 : T.cap === LINE_CAP.SQUARE && (W += square(rt, et, it, ot, gt, mt, !1, V)));
    for (var Wt = t.indices, Jt = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon, Et = Y; Et < W + Y - 2; ++Et)
      J = V[Et * 2], Q = V[Et * 2 + 1], rt = V[(Et + 1) * 2], et = V[(Et + 1) * 2 + 1], nt = V[(Et + 2) * 2], st = V[(Et + 2) * 2 + 1], !(Math.abs(J * (et - st) + rt * (st - Q) + nt * (Q - et)) < Jt) && Wt.push(Et, Et + 1, Et + 2);
  }
}
function buildNativeLine(o, t) {
  var e = 0, r = o.shape, S = o.points || r.points, T = r.type !== SHAPES.POLY || r.closeStroke;
  if (S.length !== 0) {
    var D = t.points, N = t.indices, B = S.length / 2, $ = D.length / 2, U = $;
    for (D.push(S[0], S[1]), e = 1; e < B; e++)
      D.push(S[e * 2], S[e * 2 + 1]), N.push(U, U + 1), U++;
    T && N.push(U, $);
  }
}
function buildLine(o, t) {
  o.lineStyle.native ? buildNativeLine(o, t) : buildNonNativeLine(o, t);
}
var ArcUtils = function() {
  function o() {
  }
  return o.curveTo = function(t, e, r, S, T, D) {
    var N = D[D.length - 2], B = D[D.length - 1], $ = B - e, U = N - t, H = S - e, V = r - t, X = Math.abs($ * V - U * H);
    if (X < 1e-8 || T === 0)
      return (D[D.length - 2] !== t || D[D.length - 1] !== e) && D.push(t, e), null;
    var W = $ * $ + U * U, Y = H * H + V * V, q = $ * H + U * V, K = T * Math.sqrt(W) / X, Z = T * Math.sqrt(Y) / X, J = K * q / W, Q = Z * q / Y, rt = K * V + Z * U, et = K * H + Z * $, nt = U * (Z + J), st = $ * (Z + J), it = V * (K + Q), ot = H * (K + Q), ht = Math.atan2(st - et, nt - rt), ct = Math.atan2(ot - et, it - rt);
    return {
      cx: rt + t,
      cy: et + e,
      radius: T,
      startAngle: ht,
      endAngle: ct,
      anticlockwise: U * H > V * $
    };
  }, o.arc = function(t, e, r, S, T, D, N, B, $) {
    for (var U = N - D, H = GRAPHICS_CURVES._segmentsCount(Math.abs(U) * T, Math.ceil(Math.abs(U) / PI_2) * 40), V = U / (H * 2), X = V * 2, W = Math.cos(V), Y = Math.sin(V), q = H - 1, K = q % 1 / q, Z = 0; Z <= q; ++Z) {
      var J = Z + K * Z, Q = V + D + X * J, rt = Math.cos(Q), et = -Math.sin(Q);
      $.push((W * rt + Y * et) * T + r, (W * -et + Y * rt) * T + S);
    }
  }, o;
}(), BezierUtils = function() {
  function o() {
  }
  return o.curveLength = function(t, e, r, S, T, D, N, B) {
    for (var $ = 10, U = 0, H = 0, V = 0, X = 0, W = 0, Y = 0, q = 0, K = 0, Z = 0, J = 0, Q = 0, rt = t, et = e, nt = 1; nt <= $; ++nt)
      H = nt / $, V = H * H, X = V * H, W = 1 - H, Y = W * W, q = Y * W, K = q * t + 3 * Y * H * r + 3 * W * V * T + X * N, Z = q * e + 3 * Y * H * S + 3 * W * V * D + X * B, J = rt - K, Q = et - Z, rt = K, et = Z, U += Math.sqrt(J * J + Q * Q);
    return U;
  }, o.curveTo = function(t, e, r, S, T, D, N) {
    var B = N[N.length - 2], $ = N[N.length - 1];
    N.length -= 2;
    var U = GRAPHICS_CURVES._segmentsCount(o.curveLength(B, $, t, e, r, S, T, D)), H = 0, V = 0, X = 0, W = 0, Y = 0;
    N.push(B, $);
    for (var q = 1, K = 0; q <= U; ++q)
      K = q / U, H = 1 - K, V = H * H, X = V * H, W = K * K, Y = W * K, N.push(X * B + 3 * V * K * t + 3 * H * W * r + Y * T, X * $ + 3 * V * K * e + 3 * H * W * S + Y * D);
  }, o;
}(), QuadraticUtils = function() {
  function o() {
  }
  return o.curveLength = function(t, e, r, S, T, D) {
    var N = t - 2 * r + T, B = e - 2 * S + D, $ = 2 * r - 2 * t, U = 2 * S - 2 * e, H = 4 * (N * N + B * B), V = 4 * (N * $ + B * U), X = $ * $ + U * U, W = 2 * Math.sqrt(H + V + X), Y = Math.sqrt(H), q = 2 * H * Y, K = 2 * Math.sqrt(X), Z = V / Y;
    return (q * W + Y * V * (W - K) + (4 * X * H - V * V) * Math.log((2 * Y + Z + W) / (Z + K))) / (4 * q);
  }, o.curveTo = function(t, e, r, S, T) {
    for (var D = T[T.length - 2], N = T[T.length - 1], B = GRAPHICS_CURVES._segmentsCount(o.curveLength(D, N, t, e, r, S)), $ = 0, U = 0, H = 1; H <= B; ++H) {
      var V = H / B;
      $ = D + (t - D) * V, U = N + (e - N) * V, T.push($ + (t + (r - t) * V - $) * V, U + (e + (S - e) * V - U) * V);
    }
  }, o;
}(), BatchPart = function() {
  function o() {
    this.reset();
  }
  return o.prototype.begin = function(t, e, r) {
    this.reset(), this.style = t, this.start = e, this.attribStart = r;
  }, o.prototype.end = function(t, e) {
    this.attribSize = e - this.attribStart, this.size = t - this.start;
  }, o.prototype.reset = function() {
    this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;
  }, o;
}(), _a, FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a), BATCH_POOL = [], DRAW_CALL_POOL = [], GraphicsData = function() {
  function o(t, e, r, S) {
    e === void 0 && (e = null), r === void 0 && (r = null), S === void 0 && (S = null), this.points = [], this.holes = [], this.shape = t, this.lineStyle = r, this.fillStyle = e, this.matrix = S, this.type = t.type;
  }
  return o.prototype.clone = function() {
    return new o(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  }, o.prototype.destroy = function() {
    this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;
  }, o;
}(), tmpPoint = new Point(), GraphicsGeometry = function(o) {
  __extends$l(t, o);
  function t() {
    var e = o.call(this) || this;
    return e.closePointEps = 1e-4, e.boundsPadding = 0, e.uvsFloat32 = null, e.indicesUint16 = null, e.batchable = !1, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.drawCalls = [], e.batchDirty = -1, e.batches = [], e.dirty = 0, e.cacheDirty = -1, e.clearDirty = 0, e.shapeIndex = 0, e._bounds = new Bounds(), e.boundsDirty = -1, e;
  }
  return Object.defineProperty(t.prototype, "bounds", {
    /**
     * Get the current bounds of the graphic geometry.
     * @readonly
     */
    get: function() {
      return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.invalidate = function() {
    this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
    for (var e = 0; e < this.drawCalls.length; e++)
      this.drawCalls[e].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[e]);
    this.drawCalls.length = 0;
    for (var e = 0; e < this.batches.length; e++) {
      var r = this.batches[e];
      r.reset(), BATCH_POOL.push(r);
    }
    this.batches.length = 0;
  }, t.prototype.clear = function() {
    return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;
  }, t.prototype.drawShape = function(e, r, S, T) {
    r === void 0 && (r = null), S === void 0 && (S = null), T === void 0 && (T = null);
    var D = new GraphicsData(e, r, S, T);
    return this.graphicsData.push(D), this.dirty++, this;
  }, t.prototype.drawHole = function(e, r) {
    if (r === void 0 && (r = null), !this.graphicsData.length)
      return null;
    var S = new GraphicsData(e, null, null, r), T = this.graphicsData[this.graphicsData.length - 1];
    return S.lineStyle = T.lineStyle, T.holes.push(S), this.dirty++, this;
  }, t.prototype.destroy = function() {
    o.prototype.destroy.call(this);
    for (var e = 0; e < this.graphicsData.length; ++e)
      this.graphicsData[e].destroy();
    this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;
  }, t.prototype.containsPoint = function(e) {
    for (var r = this.graphicsData, S = 0; S < r.length; ++S) {
      var T = r[S];
      if (T.fillStyle.visible && T.shape && (T.matrix ? T.matrix.applyInverse(e, tmpPoint) : tmpPoint.copyFrom(e), T.shape.contains(tmpPoint.x, tmpPoint.y))) {
        var D = !1;
        if (T.holes)
          for (var N = 0; N < T.holes.length; N++) {
            var B = T.holes[N];
            if (B.shape.contains(tmpPoint.x, tmpPoint.y)) {
              D = !0;
              break;
            }
          }
        if (!D)
          return !0;
      }
    }
    return !1;
  }, t.prototype.updateBatches = function() {
    if (!this.graphicsData.length) {
      this.batchable = !0;
      return;
    }
    if (this.validateBatching()) {
      this.cacheDirty = this.dirty;
      var e = this.uvs, r = this.graphicsData, S = null, T = null;
      this.batches.length > 0 && (S = this.batches[this.batches.length - 1], T = S.style);
      for (var D = this.shapeIndex; D < r.length; D++) {
        this.shapeIndex++;
        var N = r[D], B = N.fillStyle, $ = N.lineStyle, U = FILL_COMMANDS[N.type];
        U.build(N), N.matrix && this.transformPoints(N.points, N.matrix), (B.visible || $.visible) && this.processHoles(N.holes);
        for (var H = 0; H < 2; H++) {
          var V = H === 0 ? B : $;
          if (V.visible) {
            var X = V.texture.baseTexture, W = this.indices.length, Y = this.points.length / 2;
            X.wrapMode = WRAP_MODES.REPEAT, H === 0 ? this.processFill(N) : this.processLine(N);
            var q = this.points.length / 2 - Y;
            q !== 0 && (S && !this._compareStyles(T, V) && (S.end(W, Y), S = null), S || (S = BATCH_POOL.pop() || new BatchPart(), S.begin(V, W, Y), this.batches.push(S), T = V), this.addUvs(this.points, e, V.texture, Y, q, V.matrix));
          }
        }
      }
      var K = this.indices.length, Z = this.points.length / 2;
      if (S && S.end(K, Z), this.batches.length === 0) {
        this.batchable = !0;
        return;
      }
      var J = Z > 65535;
      this.indicesUint16 && this.indices.length === this.indicesUint16.length && J === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = J ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();
    }
  }, t.prototype._compareStyles = function(e, r) {
    return !(!e || !r || e.texture.baseTexture !== r.texture.baseTexture || e.color + e.alpha !== r.color + r.alpha || !!e.native != !!r.native);
  }, t.prototype.validateBatching = function() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length)
      return !1;
    for (var e = 0, r = this.graphicsData.length; e < r; e++) {
      var S = this.graphicsData[e], T = S.fillStyle, D = S.lineStyle;
      if (T && !T.texture.baseTexture.valid || D && !D.texture.baseTexture.valid)
        return !1;
    }
    return !0;
  }, t.prototype.packBatches = function() {
    this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
    for (var e = this.batches, r = 0, S = e.length; r < S; r++)
      for (var T = e[r], D = 0; D < T.size; D++) {
        var N = T.start + D;
        this.indicesUint16[N] = this.indicesUint16[N] - T.attribStart;
      }
  }, t.prototype.isBatchable = function() {
    if (this.points.length > 65535 * 2)
      return !1;
    for (var e = this.batches, r = 0; r < e.length; r++)
      if (e[r].style.native)
        return !1;
    return this.points.length < t.BATCHABLE_SIZE * 2;
  }, t.prototype.buildDrawCalls = function() {
    for (var e = ++BaseTexture._globalBatch, r = 0; r < this.drawCalls.length; r++)
      this.drawCalls[r].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[r]);
    this.drawCalls.length = 0;
    var S = this.colors, T = this.textureIds, D = DRAW_CALL_POOL.pop();
    D || (D = new BatchDrawCall(), D.texArray = new BatchTextureArray()), D.texArray.count = 0, D.start = 0, D.size = 0, D.type = DRAW_MODES.TRIANGLES;
    var N = 0, B = null, $ = 0, U = !1, H = DRAW_MODES.TRIANGLES, V = 0;
    this.drawCalls.push(D);
    for (var r = 0; r < this.batches.length; r++) {
      var X = this.batches[r], W = 8, Y = X.style, q = Y.texture.baseTexture;
      U !== !!Y.native && (U = !!Y.native, H = U ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES, B = null, N = W, e++), B !== q && (B = q, q._batchEnabled !== e && (N === W && (e++, N = 0, D.size > 0 && (D = DRAW_CALL_POOL.pop(), D || (D = new BatchDrawCall(), D.texArray = new BatchTextureArray()), this.drawCalls.push(D)), D.start = V, D.size = 0, D.texArray.count = 0, D.type = H), q.touched = 1, q._batchEnabled = e, q._batchLocation = N, q.wrapMode = WRAP_MODES.REPEAT, D.texArray.elements[D.texArray.count++] = q, N++)), D.size += X.size, V += X.size, $ = q._batchLocation, this.addColors(S, Y.color, Y.alpha, X.attribSize, X.attribStart), this.addTextureIds(T, $, X.attribSize, X.attribStart);
    }
    BaseTexture._globalBatch = e, this.packAttributes();
  }, t.prototype.packAttributes = function() {
    for (var e = this.points, r = this.uvs, S = this.colors, T = this.textureIds, D = new ArrayBuffer(e.length * 3 * 4), N = new Float32Array(D), B = new Uint32Array(D), $ = 0, U = 0; U < e.length / 2; U++)
      N[$++] = e[U * 2], N[$++] = e[U * 2 + 1], N[$++] = r[U * 2], N[$++] = r[U * 2 + 1], B[$++] = S[U], N[$++] = T[U];
    this._buffer.update(D), this._indexBuffer.update(this.indicesUint16);
  }, t.prototype.processFill = function(e) {
    if (e.holes.length)
      buildPoly.triangulate(e, this);
    else {
      var r = FILL_COMMANDS[e.type];
      r.triangulate(e, this);
    }
  }, t.prototype.processLine = function(e) {
    buildLine(e, this);
    for (var r = 0; r < e.holes.length; r++)
      buildLine(e.holes[r], this);
  }, t.prototype.processHoles = function(e) {
    for (var r = 0; r < e.length; r++) {
      var S = e[r], T = FILL_COMMANDS[S.type];
      T.build(S), S.matrix && this.transformPoints(S.points, S.matrix);
    }
  }, t.prototype.calculateBounds = function() {
    var e = this._bounds;
    e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding);
  }, t.prototype.transformPoints = function(e, r) {
    for (var S = 0; S < e.length / 2; S++) {
      var T = e[S * 2], D = e[S * 2 + 1];
      e[S * 2] = r.a * T + r.c * D + r.tx, e[S * 2 + 1] = r.b * T + r.d * D + r.ty;
    }
  }, t.prototype.addColors = function(e, r, S, T, D) {
    D === void 0 && (D = 0);
    var N = (r >> 16) + (r & 65280) + ((r & 255) << 16), B = premultiplyTint(N, S);
    e.length = Math.max(e.length, D + T);
    for (var $ = 0; $ < T; $++)
      e[D + $] = B;
  }, t.prototype.addTextureIds = function(e, r, S, T) {
    T === void 0 && (T = 0), e.length = Math.max(e.length, T + S);
    for (var D = 0; D < S; D++)
      e[T + D] = r;
  }, t.prototype.addUvs = function(e, r, S, T, D, N) {
    N === void 0 && (N = null);
    for (var B = 0, $ = r.length, U = S.frame; B < D; ) {
      var H = e[(T + B) * 2], V = e[(T + B) * 2 + 1];
      if (N) {
        var X = N.a * H + N.c * V + N.tx;
        V = N.b * H + N.d * V + N.ty, H = X;
      }
      B++, r.push(H / U.width, V / U.height);
    }
    var W = S.baseTexture;
    (U.width < W.width || U.height < W.height) && this.adjustUvs(r, S, $, D);
  }, t.prototype.adjustUvs = function(e, r, S, T) {
    for (var D = r.baseTexture, N = 1e-6, B = S + T * 2, $ = r.frame, U = $.width / D.width, H = $.height / D.height, V = $.x / $.width, X = $.y / $.height, W = Math.floor(e[S] + N), Y = Math.floor(e[S + 1] + N), q = S + 2; q < B; q += 2)
      W = Math.min(W, Math.floor(e[q] + N)), Y = Math.min(Y, Math.floor(e[q + 1] + N));
    V -= W, X -= Y;
    for (var q = S; q < B; q += 2)
      e[q] = (e[q] + V) * U, e[q + 1] = (e[q + 1] + X) * H;
  }, t.BATCHABLE_SIZE = 100, t;
}(BatchGeometry), LineStyle = function(o) {
  __extends$l(t, o);
  function t() {
    var e = o !== null && o.apply(this, arguments) || this;
    return e.width = 0, e.alignment = 0.5, e.native = !1, e.cap = LINE_CAP.BUTT, e.join = LINE_JOIN.MITER, e.miterLimit = 10, e;
  }
  return t.prototype.clone = function() {
    var e = new t();
    return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e.width = this.width, e.alignment = this.alignment, e.native = this.native, e.cap = this.cap, e.join = this.join, e.miterLimit = this.miterLimit, e;
  }, t.prototype.reset = function() {
    o.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1;
  }, t;
}(FillStyle), temp = new Float32Array(3), DEFAULT_SHADERS = {}, Graphics = function(o) {
  __extends$l(t, o);
  function t(e) {
    e === void 0 && (e = null);
    var r = o.call(this) || this;
    return r.shader = null, r.pluginName = "batch", r.currentPath = null, r.batches = [], r.batchTint = -1, r.batchDirty = -1, r.vertexData = null, r._fillStyle = new FillStyle(), r._lineStyle = new LineStyle(), r._matrix = null, r._holeMode = !1, r.state = State.for2d(), r._geometry = e || new GraphicsGeometry(), r._geometry.refCount++, r._transformID = -1, r.tint = 16777215, r.blendMode = BLEND_MODES.NORMAL, r;
  }
  return Object.defineProperty(t.prototype, "geometry", {
    /**
     * Includes vertex positions, face indices, normals, colors, UVs, and
     * custom attributes within buffers, reducing the cost of passing all
     * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
     * @readonly
     */
    get: function() {
      return this._geometry;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.clone = function() {
    return this.finishPoly(), new t(this._geometry);
  }, Object.defineProperty(t.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    /**
     * The blend mode to be applied to the graphic shape. Apply a value of
     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each
     * primitive in the GraphicsGeometry list is rendered sequentially, modes
     * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will
     * be applied per-primitive.
     * @default PIXI.BLEND_MODES.NORMAL
     */
    set: function(e) {
      this.state.blendMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tint", {
    /**
     * The tint applied to each graphic shape. This is a hex value. A value of
     * 0xFFFFFF will remove any tint effect.
     * @default 0xFFFFFF
     */
    get: function() {
      return this._tint;
    },
    set: function(e) {
      this._tint = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fill", {
    /**
     * The current fill style.
     * @readonly
     */
    get: function() {
      return this._fillStyle;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "line", {
    /**
     * The current line style.
     * @readonly
     */
    get: function() {
      return this._lineStyle;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.lineStyle = function(e, r, S, T, D) {
    return e === void 0 && (e = null), r === void 0 && (r = 0), S === void 0 && (S = 1), T === void 0 && (T = 0.5), D === void 0 && (D = !1), typeof e == "number" && (e = { width: e, color: r, alpha: S, alignment: T, native: D }), this.lineTextureStyle(e);
  }, t.prototype.lineTextureStyle = function(e) {
    e = Object.assign({
      width: 0,
      texture: Texture.WHITE,
      color: e && e.texture ? 16777215 : 0,
      alpha: 1,
      matrix: null,
      alignment: 0.5,
      native: !1,
      cap: LINE_CAP.BUTT,
      join: LINE_JOIN.MITER,
      miterLimit: 10
    }, e), this.currentPath && this.startPoly();
    var r = e.width > 0 && e.alpha > 0;
    return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, { visible: r }, e)) : this._lineStyle.reset(), this;
  }, t.prototype.startPoly = function() {
    if (this.currentPath) {
      var e = this.currentPath.points, r = this.currentPath.points.length;
      r > 2 && (this.drawShape(this.currentPath), this.currentPath = new Polygon(), this.currentPath.closeStroke = !1, this.currentPath.points.push(e[r - 2], e[r - 1]));
    } else
      this.currentPath = new Polygon(), this.currentPath.closeStroke = !1;
  }, t.prototype.finishPoly = function() {
    this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);
  }, t.prototype.moveTo = function(e, r) {
    return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = r, this;
  }, t.prototype.lineTo = function(e, r) {
    this.currentPath || this.moveTo(0, 0);
    var S = this.currentPath.points, T = S[S.length - 2], D = S[S.length - 1];
    return (T !== e || D !== r) && S.push(e, r), this;
  }, t.prototype._initCurve = function(e, r) {
    e === void 0 && (e = 0), r === void 0 && (r = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, r]) : this.moveTo(e, r);
  }, t.prototype.quadraticCurveTo = function(e, r, S, T) {
    this._initCurve();
    var D = this.currentPath.points;
    return D.length === 0 && this.moveTo(0, 0), QuadraticUtils.curveTo(e, r, S, T, D), this;
  }, t.prototype.bezierCurveTo = function(e, r, S, T, D, N) {
    return this._initCurve(), BezierUtils.curveTo(e, r, S, T, D, N, this.currentPath.points), this;
  }, t.prototype.arcTo = function(e, r, S, T, D) {
    this._initCurve(e, r);
    var N = this.currentPath.points, B = ArcUtils.curveTo(e, r, S, T, D, N);
    if (B) {
      var $ = B.cx, U = B.cy, H = B.radius, V = B.startAngle, X = B.endAngle, W = B.anticlockwise;
      this.arc($, U, H, V, X, W);
    }
    return this;
  }, t.prototype.arc = function(e, r, S, T, D, N) {
    if (N === void 0 && (N = !1), T === D)
      return this;
    !N && D <= T ? D += PI_2 : N && T <= D && (T += PI_2);
    var B = D - T;
    if (B === 0)
      return this;
    var $ = e + Math.cos(T) * S, U = r + Math.sin(T) * S, H = this._geometry.closePointEps, V = this.currentPath ? this.currentPath.points : null;
    if (V) {
      var X = Math.abs(V[V.length - 2] - $), W = Math.abs(V[V.length - 1] - U);
      X < H && W < H || V.push($, U);
    } else
      this.moveTo($, U), V = this.currentPath.points;
    return ArcUtils.arc($, U, e, r, S, T, D, N, V), this;
  }, t.prototype.beginFill = function(e, r) {
    return e === void 0 && (e = 0), r === void 0 && (r = 1), this.beginTextureFill({ texture: Texture.WHITE, color: e, alpha: r });
  }, t.prototype.beginTextureFill = function(e) {
    e = Object.assign({
      texture: Texture.WHITE,
      color: 16777215,
      alpha: 1,
      matrix: null
    }, e), this.currentPath && this.startPoly();
    var r = e.alpha > 0;
    return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, { visible: r }, e)) : this._fillStyle.reset(), this;
  }, t.prototype.endFill = function() {
    return this.finishPoly(), this._fillStyle.reset(), this;
  }, t.prototype.drawRect = function(e, r, S, T) {
    return this.drawShape(new Rectangle(e, r, S, T));
  }, t.prototype.drawRoundedRect = function(e, r, S, T, D) {
    return this.drawShape(new RoundedRectangle(e, r, S, T, D));
  }, t.prototype.drawCircle = function(e, r, S) {
    return this.drawShape(new Circle(e, r, S));
  }, t.prototype.drawEllipse = function(e, r, S, T) {
    return this.drawShape(new Ellipse(e, r, S, T));
  }, t.prototype.drawPolygon = function() {
    for (var e = arguments, r = [], S = 0; S < arguments.length; S++)
      r[S] = e[S];
    var T, D = !0, N = r[0];
    N.points ? (D = N.closeStroke, T = N.points) : Array.isArray(r[0]) ? T = r[0] : T = r;
    var B = new Polygon(T);
    return B.closeStroke = D, this.drawShape(B), this;
  }, t.prototype.drawShape = function(e) {
    return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;
  }, t.prototype.clear = function() {
    return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;
  }, t.prototype.isFastRect = function() {
    var e = this._geometry.graphicsData;
    return e.length === 1 && e[0].shape.type === SHAPES.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width);
  }, t.prototype._render = function(e) {
    this.finishPoly();
    var r = this._geometry;
    r.updateBatches(), r.batchable ? (this.batchDirty !== r.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e));
  }, t.prototype._populateBatches = function() {
    var e = this._geometry, r = this.blendMode, S = e.batches.length;
    this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = S, this.vertexData = new Float32Array(e.points);
    for (var T = 0; T < S; T++) {
      var D = e.batches[T], N = D.style.color, B = new Float32Array(this.vertexData.buffer, D.attribStart * 4 * 2, D.attribSize * 2), $ = new Float32Array(e.uvsFloat32.buffer, D.attribStart * 4 * 2, D.attribSize * 2), U = new Uint16Array(e.indicesUint16.buffer, D.start * 2, D.size), H = {
        vertexData: B,
        blendMode: r,
        indices: U,
        uvs: $,
        _batchRGB: hex2rgb(N),
        _tintRGB: N,
        _texture: D.style.texture,
        alpha: D.style.alpha,
        worldAlpha: 1
      };
      this.batches[T] = H;
    }
  }, t.prototype._renderBatched = function(e) {
    if (this.batches.length) {
      e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
      for (var r = 0, S = this.batches.length; r < S; r++) {
        var T = this.batches[r];
        T.worldAlpha = this.worldAlpha * T.alpha, e.plugins[this.pluginName].render(T);
      }
    }
  }, t.prototype._renderDirect = function(e) {
    var r = this._resolveDirectShader(e), S = this._geometry, T = this.tint, D = this.worldAlpha, N = r.uniforms, B = S.drawCalls;
    N.translationMatrix = this.transform.worldTransform, N.tint[0] = (T >> 16 & 255) / 255 * D, N.tint[1] = (T >> 8 & 255) / 255 * D, N.tint[2] = (T & 255) / 255 * D, N.tint[3] = D, e.shader.bind(r), e.geometry.bind(S, r), e.state.set(this.state);
    for (var $ = 0, U = B.length; $ < U; $++)
      this._renderDrawCallDirect(e, S.drawCalls[$]);
  }, t.prototype._renderDrawCallDirect = function(e, r) {
    for (var S = r.texArray, T = r.type, D = r.size, N = r.start, B = S.count, $ = 0; $ < B; $++)
      e.texture.bind(S.elements[$], $);
    e.geometry.draw(T, D, N);
  }, t.prototype._resolveDirectShader = function(e) {
    var r = this.shader, S = this.pluginName;
    if (!r) {
      if (!DEFAULT_SHADERS[S]) {
        for (var T = e.plugins[S].MAX_TEXTURES, D = new Int32Array(T), N = 0; N < T; N++)
          D[N] = N;
        var B = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix(),
          default: UniformGroup.from({ uSamplers: D }, !0)
        }, $ = e.plugins[S]._shader.program;
        DEFAULT_SHADERS[S] = new Shader($, B);
      }
      r = DEFAULT_SHADERS[S];
    }
    return r;
  }, t.prototype._calculateBounds = function() {
    this.finishPoly();
    var e = this._geometry;
    if (e.graphicsData.length) {
      var r = e.bounds, S = r.minX, T = r.minY, D = r.maxX, N = r.maxY;
      this._bounds.addFrame(this.transform, S, T, D, N);
    }
  }, t.prototype.containsPoint = function(e) {
    return this.worldTransform.applyInverse(e, t._TEMP_POINT), this._geometry.containsPoint(t._TEMP_POINT);
  }, t.prototype.calculateTints = function() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this.tint;
      for (var e = hex2rgb(this.tint, temp), r = 0; r < this.batches.length; r++) {
        var S = this.batches[r], T = S._batchRGB, D = e[0] * T[0] * 255, N = e[1] * T[1] * 255, B = e[2] * T[2] * 255, $ = (D << 16) + (N << 8) + (B | 0);
        S._tintRGB = ($ >> 16) + ($ & 65280) + (($ & 255) << 16);
      }
    }
  }, t.prototype.calculateVertices = function() {
    var e = this.transform._worldID;
    if (this._transformID !== e) {
      this._transformID = e;
      for (var r = this.transform.worldTransform, S = r.a, T = r.b, D = r.c, N = r.d, B = r.tx, $ = r.ty, U = this._geometry.points, H = this.vertexData, V = 0, X = 0; X < U.length; X += 2) {
        var W = U[X], Y = U[X + 1];
        H[V++] = S * W + D * Y + B, H[V++] = N * Y + T * W + $;
      }
    }
  }, t.prototype.closePath = function() {
    var e = this.currentPath;
    return e && (e.closeStroke = !0, this.finishPoly()), this;
  }, t.prototype.setMatrix = function(e) {
    return this._matrix = e, this;
  }, t.prototype.beginHole = function() {
    return this.finishPoly(), this._holeMode = !0, this;
  }, t.prototype.endHole = function() {
    return this.finishPoly(), this._holeMode = !1, this;
  }, t.prototype.destroy = function(e) {
    this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, o.prototype.destroy.call(this, e);
  }, t.nextRoundedRectBehavior = !1, t._TEMP_POINT = new Point(), t;
}(Container);
/*!
 * @pixi/sprite - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/sprite is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$k = function(o, t) {
  return extendStatics$k = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$k(o, t);
};
function __extends$k(o, t) {
  extendStatics$k(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var tempPoint$2 = new Point(), indices = new Uint16Array([0, 1, 2, 0, 2, 3]), Sprite = function(o) {
  __extends$k(t, o);
  function t(e) {
    var r = o.call(this) || this;
    return r._anchor = new ObservablePoint(r._onAnchorUpdate, r, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), r._texture = null, r._width = 0, r._height = 0, r._tint = null, r._tintRGB = null, r.tint = 16777215, r.blendMode = BLEND_MODES.NORMAL, r._cachedTint = 16777215, r.uvs = null, r.texture = e || Texture.EMPTY, r.vertexData = new Float32Array(8), r.vertexTrimmedData = null, r._transformID = -1, r._textureID = -1, r._transformTrimmedID = -1, r._textureTrimmedID = -1, r.indices = indices, r.pluginName = "batch", r.isSprite = !0, r._roundPixels = settings.ROUND_PIXELS, r;
  }
  return t.prototype._onTextureUpdate = function() {
    this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height);
  }, t.prototype._onAnchorUpdate = function() {
    this._transformID = -1, this._transformTrimmedID = -1;
  }, t.prototype.calculateVertices = function() {
    var e = this._texture;
    if (!(this._transformID === this.transform._worldID && this._textureID === e._updateID)) {
      this._textureID !== e._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = e._updateID;
      var r = this.transform.worldTransform, S = r.a, T = r.b, D = r.c, N = r.d, B = r.tx, $ = r.ty, U = this.vertexData, H = e.trim, V = e.orig, X = this._anchor, W = 0, Y = 0, q = 0, K = 0;
      if (H ? (Y = H.x - X._x * V.width, W = Y + H.width, K = H.y - X._y * V.height, q = K + H.height) : (Y = -X._x * V.width, W = Y + V.width, K = -X._y * V.height, q = K + V.height), U[0] = S * Y + D * K + B, U[1] = N * K + T * Y + $, U[2] = S * W + D * K + B, U[3] = N * K + T * W + $, U[4] = S * W + D * q + B, U[5] = N * q + T * W + $, U[6] = S * Y + D * q + B, U[7] = N * q + T * Y + $, this._roundPixels)
        for (var Z = settings.RESOLUTION, J = 0; J < U.length; ++J)
          U[J] = Math.round((U[J] * Z | 0) / Z);
    }
  }, t.prototype.calculateTrimmedVertices = function() {
    if (!this.vertexTrimmedData)
      this.vertexTrimmedData = new Float32Array(8);
    else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
      return;
    this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
    var e = this._texture, r = this.vertexTrimmedData, S = e.orig, T = this._anchor, D = this.transform.worldTransform, N = D.a, B = D.b, $ = D.c, U = D.d, H = D.tx, V = D.ty, X = -T._x * S.width, W = X + S.width, Y = -T._y * S.height, q = Y + S.height;
    r[0] = N * X + $ * Y + H, r[1] = U * Y + B * X + V, r[2] = N * W + $ * Y + H, r[3] = U * Y + B * W + V, r[4] = N * W + $ * q + H, r[5] = U * q + B * W + V, r[6] = N * X + $ * q + H, r[7] = U * q + B * X + V;
  }, t.prototype._render = function(e) {
    this.calculateVertices(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this);
  }, t.prototype._calculateBounds = function() {
    var e = this._texture.trim, r = this._texture.orig;
    !e || e.width === r.width && e.height === r.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
  }, t.prototype.getLocalBounds = function(e) {
    return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Bounds()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds.getRectangle(e)) : o.prototype.getLocalBounds.call(this, e);
  }, t.prototype.containsPoint = function(e) {
    this.worldTransform.applyInverse(e, tempPoint$2);
    var r = this._texture.orig.width, S = this._texture.orig.height, T = -r * this.anchor.x, D = 0;
    return tempPoint$2.x >= T && tempPoint$2.x < T + r && (D = -S * this.anchor.y, tempPoint$2.y >= D && tempPoint$2.y < D + S);
  }, t.prototype.destroy = function(e) {
    o.prototype.destroy.call(this, e), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null;
    var r = typeof e == "boolean" ? e : e && e.texture;
    if (r) {
      var S = typeof e == "boolean" ? e : e && e.baseTexture;
      this._texture.destroy(!!S);
    }
    this._texture = null;
  }, t.from = function(e, r) {
    var S = e instanceof Texture ? e : Texture.from(e, r);
    return new t(S);
  }, Object.defineProperty(t.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     *
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     *
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.
     * @default false
     */
    set: function(e) {
      this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "width", {
    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    },
    set: function(e) {
      var r = sign(this.scale.x) || 1;
      this.scale.x = r * e / this._texture.orig.width, this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    },
    set: function(e) {
      var r = sign(this.scale.y) || 1;
      this.scale.y = r * e / this._texture.orig.height, this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "anchor", {
    /**
     * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}
     * and passed to the constructor.
     *
     * The default is `(0,0)`, this means the sprite's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
     *
     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
     * @example
     * const sprite = new PIXI.Sprite(texture);
     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
     */
    get: function() {
      return this._anchor;
    },
    set: function(e) {
      this._anchor.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tint", {
    /**
     * The tint applied to the sprite. This is a hex value.
     *
     * A value of 0xFFFFFF will remove any tint effect.
     * @default 0xFFFFFF
     */
    get: function() {
      return this._tint;
    },
    set: function(e) {
      this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "texture", {
    /** The texture that the sprite is using. */
    get: function() {
      return this._texture;
    },
    set: function(e) {
      this._texture !== e && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = e || Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, e && (e.baseTexture.valid ? this._onTextureUpdate() : e.once("update", this._onTextureUpdate, this)));
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Container);
/*!
 * @pixi/text - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/text is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$j = function(o, t) {
  return extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$j(o, t);
};
function __extends$j(o, t) {
  extendStatics$j(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var TEXT_GRADIENT;
(function(o) {
  o[o.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", o[o.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL";
})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));
var defaultStyle = {
  align: "left",
  breakWords: !1,
  dropShadow: !1,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: !1,
  whiteSpace: "pre",
  wordWrap: !1,
  wordWrapWidth: 100,
  leading: 0
}, genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
], TextStyle = function() {
  function o(t) {
    this.styleID = 0, this.reset(), deepCopyProperties(this, t, t);
  }
  return o.prototype.clone = function() {
    var t = {};
    return deepCopyProperties(t, this, defaultStyle), new o(t);
  }, o.prototype.reset = function() {
    deepCopyProperties(this, defaultStyle, defaultStyle);
  }, Object.defineProperty(o.prototype, "align", {
    /**
     * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
     *
     * @member {string}
     */
    get: function() {
      return this._align;
    },
    set: function(t) {
      this._align !== t && (this._align = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "breakWords", {
    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
    get: function() {
      return this._breakWords;
    },
    set: function(t) {
      this._breakWords !== t && (this._breakWords = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "dropShadow", {
    /** Set a drop shadow for the text. */
    get: function() {
      return this._dropShadow;
    },
    set: function(t) {
      this._dropShadow !== t && (this._dropShadow = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "dropShadowAlpha", {
    /** Set alpha for the drop shadow. */
    get: function() {
      return this._dropShadowAlpha;
    },
    set: function(t) {
      this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "dropShadowAngle", {
    /** Set a angle of the drop shadow. */
    get: function() {
      return this._dropShadowAngle;
    },
    set: function(t) {
      this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "dropShadowBlur", {
    /** Set a shadow blur radius. */
    get: function() {
      return this._dropShadowBlur;
    },
    set: function(t) {
      this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "dropShadowColor", {
    /** A fill style to be used on the dropshadow e.g 'red', '#00FF00'. */
    get: function() {
      return this._dropShadowColor;
    },
    set: function(t) {
      var e = getColor(t);
      this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "dropShadowDistance", {
    /** Set a distance of the drop shadow. */
    get: function() {
      return this._dropShadowDistance;
    },
    set: function(t) {
      this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fill", {
    /**
     * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
     *
     * Can be an array to create a gradient eg ['#000000','#FFFFFF']
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
     *
     * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
     */
    get: function() {
      return this._fill;
    },
    set: function(t) {
      var e = getColor(t);
      this._fill !== e && (this._fill = e, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fillGradientType", {
    /**
     * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
     *
     * @see PIXI.TEXT_GRADIENT
     */
    get: function() {
      return this._fillGradientType;
    },
    set: function(t) {
      this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fillGradientStops", {
    /**
     * If fill is an array of colours to create a gradient, this array can set the stop points
     * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
     */
    get: function() {
      return this._fillGradientStops;
    },
    set: function(t) {
      areArraysEqual(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fontFamily", {
    /** The font family. */
    get: function() {
      return this._fontFamily;
    },
    set: function(t) {
      this.fontFamily !== t && (this._fontFamily = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fontSize", {
    /**
     * The font size
     * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
     */
    get: function() {
      return this._fontSize;
    },
    set: function(t) {
      this._fontSize !== t && (this._fontSize = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fontStyle", {
    /**
     * The font style
     * ('normal', 'italic' or 'oblique')
     *
     * @member {string}
     */
    get: function() {
      return this._fontStyle;
    },
    set: function(t) {
      this._fontStyle !== t && (this._fontStyle = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fontVariant", {
    /**
     * The font variant
     * ('normal' or 'small-caps')
     *
     * @member {string}
     */
    get: function() {
      return this._fontVariant;
    },
    set: function(t) {
      this._fontVariant !== t && (this._fontVariant = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fontWeight", {
    /**
     * The font weight
     * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
     *
     * @member {string}
     */
    get: function() {
      return this._fontWeight;
    },
    set: function(t) {
      this._fontWeight !== t && (this._fontWeight = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "letterSpacing", {
    /** The amount of spacing between letters, default is 0. */
    get: function() {
      return this._letterSpacing;
    },
    set: function(t) {
      this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "lineHeight", {
    /** The line height, a number that represents the vertical space that a letter uses. */
    get: function() {
      return this._lineHeight;
    },
    set: function(t) {
      this._lineHeight !== t && (this._lineHeight = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "leading", {
    /** The space between lines. */
    get: function() {
      return this._leading;
    },
    set: function(t) {
      this._leading !== t && (this._leading = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "lineJoin", {
    /**
     * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
     * Default is 'miter' (creates a sharp corner).
     *
     * @member {string}
     */
    get: function() {
      return this._lineJoin;
    },
    set: function(t) {
      this._lineJoin !== t && (this._lineJoin = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "miterLimit", {
    /**
     * The miter limit to use when using the 'miter' lineJoin mode.
     *
     * This can reduce or increase the spikiness of rendered text.
     */
    get: function() {
      return this._miterLimit;
    },
    set: function(t) {
      this._miterLimit !== t && (this._miterLimit = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "padding", {
    /**
     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
     * by adding padding to all sides of the text.
     */
    get: function() {
      return this._padding;
    },
    set: function(t) {
      this._padding !== t && (this._padding = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "stroke", {
    /**
     * A canvas fillstyle that will be used on the text stroke
     * e.g 'blue', '#FCFF00'
     */
    get: function() {
      return this._stroke;
    },
    set: function(t) {
      var e = getColor(t);
      this._stroke !== e && (this._stroke = e, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "strokeThickness", {
    /**
     * A number that represents the thickness of the stroke.
     *
     * @default 0
     */
    get: function() {
      return this._strokeThickness;
    },
    set: function(t) {
      this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "textBaseline", {
    /**
     * The baseline of the text that is rendered.
     *
     * @member {string}
     */
    get: function() {
      return this._textBaseline;
    },
    set: function(t) {
      this._textBaseline !== t && (this._textBaseline = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "trim", {
    /** Trim transparent borders. */
    get: function() {
      return this._trim;
    },
    set: function(t) {
      this._trim !== t && (this._trim = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "whiteSpace", {
    /**
     * How newlines and spaces should be handled.
     * Default is 'pre' (preserve, preserve).
     *
     *  value       | New lines     |   Spaces
     *  ---         | ---           |   ---
     * 'normal'     | Collapse      |   Collapse
     * 'pre'        | Preserve      |   Preserve
     * 'pre-line'   | Preserve      |   Collapse
     *
     * @member {string}
     */
    get: function() {
      return this._whiteSpace;
    },
    set: function(t) {
      this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "wordWrap", {
    /** Indicates if word wrap should be used. */
    get: function() {
      return this._wordWrap;
    },
    set: function(t) {
      this._wordWrap !== t && (this._wordWrap = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "wordWrapWidth", {
    /** The width at which text will wrap, it needs wordWrap to be set to true. */
    get: function() {
      return this._wordWrapWidth;
    },
    set: function(t) {
      this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.toFontString = function() {
    var t = typeof this.fontSize == "number" ? this.fontSize + "px" : this.fontSize, e = this.fontFamily;
    Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
    for (var r = e.length - 1; r >= 0; r--) {
      var S = e[r].trim();
      !/([\"\'])[^\'\"]+\1/.test(S) && genericFontFamilies.indexOf(S) < 0 && (S = '"' + S + '"'), e[r] = S;
    }
    return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t + " " + e.join(",");
  }, o;
}();
function getSingleColor(o) {
  return typeof o == "number" ? hex2string(o) : (typeof o == "string" && o.indexOf("0x") === 0 && (o = o.replace("0x", "#")), o);
}
function getColor(o) {
  if (Array.isArray(o)) {
    for (var t = 0; t < o.length; ++t)
      o[t] = getSingleColor(o[t]);
    return o;
  } else
    return getSingleColor(o);
}
function areArraysEqual(o, t) {
  if (!Array.isArray(o) || !Array.isArray(t) || o.length !== t.length)
    return !1;
  for (var e = 0; e < o.length; ++e)
    if (o[e] !== t[e])
      return !1;
  return !0;
}
function deepCopyProperties(o, t, e) {
  for (var r in e)
    Array.isArray(t[r]) ? o[r] = t[r].slice() : o[r] = t[r];
}
var contextSettings = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: !0
}, TextMetrics = function() {
  function o(t, e, r, S, T, D, N, B, $) {
    this.text = t, this.style = e, this.width = r, this.height = S, this.lines = T, this.lineWidths = D, this.lineHeight = N, this.maxLineWidth = B, this.fontProperties = $;
  }
  return o.measureText = function(t, e, r, S) {
    S === void 0 && (S = o._canvas), r = r ?? e.wordWrap;
    var T = e.toFontString(), D = o.measureFont(T);
    D.fontSize === 0 && (D.fontSize = e.fontSize, D.ascent = e.fontSize);
    var N = S.getContext("2d", contextSettings);
    N.font = T;
    for (var B = r ? o.wordWrap(t, e, S) : t, $ = B.split(/(?:\r\n|\r|\n)/), U = new Array($.length), H = 0, V = 0; V < $.length; V++) {
      var X = N.measureText($[V]).width + ($[V].length - 1) * e.letterSpacing;
      U[V] = X, H = Math.max(H, X);
    }
    var W = H + e.strokeThickness;
    e.dropShadow && (W += e.dropShadowDistance);
    var Y = e.lineHeight || D.fontSize + e.strokeThickness, q = Math.max(Y, D.fontSize + e.strokeThickness) + ($.length - 1) * (Y + e.leading);
    return e.dropShadow && (q += e.dropShadowDistance), new o(t, e, W, q, $, U, Y + e.leading, H, D);
  }, o.wordWrap = function(t, e, r) {
    r === void 0 && (r = o._canvas);
    for (var S = r.getContext("2d", contextSettings), T = 0, D = "", N = "", B = /* @__PURE__ */ Object.create(null), $ = e.letterSpacing, U = e.whiteSpace, H = o.collapseSpaces(U), V = o.collapseNewlines(U), X = !H, W = e.wordWrapWidth + $, Y = o.tokenize(t), q = 0; q < Y.length; q++) {
      var K = Y[q];
      if (o.isNewline(K)) {
        if (!V) {
          N += o.addLine(D), X = !H, D = "", T = 0;
          continue;
        }
        K = " ";
      }
      if (H) {
        var Z = o.isBreakingSpace(K), J = o.isBreakingSpace(D[D.length - 1]);
        if (Z && J)
          continue;
      }
      var Q = o.getFromCache(K, $, B, S);
      if (Q > W)
        if (D !== "" && (N += o.addLine(D), D = "", T = 0), o.canBreakWords(K, e.breakWords))
          for (var rt = o.wordWrapSplit(K), et = 0; et < rt.length; et++) {
            for (var nt = rt[et], st = 1; rt[et + st]; ) {
              var it = rt[et + st], ot = nt[nt.length - 1];
              if (!o.canBreakChars(ot, it, K, et, e.breakWords))
                nt += it;
              else
                break;
              st++;
            }
            et += nt.length - 1;
            var ht = o.getFromCache(nt, $, B, S);
            ht + T > W && (N += o.addLine(D), X = !1, D = "", T = 0), D += nt, T += ht;
          }
        else {
          D.length > 0 && (N += o.addLine(D), D = "", T = 0);
          var ct = q === Y.length - 1;
          N += o.addLine(K, !ct), X = !1, D = "", T = 0;
        }
      else
        Q + T > W && (X = !1, N += o.addLine(D), D = "", T = 0), (D.length > 0 || !o.isBreakingSpace(K) || X) && (D += K, T += Q);
    }
    return N += o.addLine(D, !1), N;
  }, o.addLine = function(t, e) {
    return e === void 0 && (e = !0), t = o.trimRight(t), t = e ? t + `
` : t, t;
  }, o.getFromCache = function(t, e, r, S) {
    var T = r[t];
    if (typeof T != "number") {
      var D = t.length * e;
      T = S.measureText(t).width + D, r[t] = T;
    }
    return T;
  }, o.collapseSpaces = function(t) {
    return t === "normal" || t === "pre-line";
  }, o.collapseNewlines = function(t) {
    return t === "normal";
  }, o.trimRight = function(t) {
    if (typeof t != "string")
      return "";
    for (var e = t.length - 1; e >= 0; e--) {
      var r = t[e];
      if (!o.isBreakingSpace(r))
        break;
      t = t.slice(0, -1);
    }
    return t;
  }, o.isNewline = function(t) {
    return typeof t != "string" ? !1 : o._newlines.indexOf(t.charCodeAt(0)) >= 0;
  }, o.isBreakingSpace = function(t, e) {
    return typeof t != "string" ? !1 : o._breakingSpaces.indexOf(t.charCodeAt(0)) >= 0;
  }, o.tokenize = function(t) {
    var e = [], r = "";
    if (typeof t != "string")
      return e;
    for (var S = 0; S < t.length; S++) {
      var T = t[S], D = t[S + 1];
      if (o.isBreakingSpace(T, D) || o.isNewline(T)) {
        r !== "" && (e.push(r), r = ""), e.push(T);
        continue;
      }
      r += T;
    }
    return r !== "" && e.push(r), e;
  }, o.canBreakWords = function(t, e) {
    return e;
  }, o.canBreakChars = function(t, e, r, S, T) {
    return !0;
  }, o.wordWrapSplit = function(t) {
    return t.split("");
  }, o.measureFont = function(t) {
    if (o._fonts[t])
      return o._fonts[t];
    var e = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    }, r = o._canvas, S = o._context;
    S.font = t;
    var T = o.METRICS_STRING + o.BASELINE_SYMBOL, D = Math.ceil(S.measureText(T).width), N = Math.ceil(S.measureText(o.BASELINE_SYMBOL).width), B = Math.ceil(o.HEIGHT_MULTIPLIER * N);
    N = N * o.BASELINE_MULTIPLIER | 0, r.width = D, r.height = B, S.fillStyle = "#f00", S.fillRect(0, 0, D, B), S.font = t, S.textBaseline = "alphabetic", S.fillStyle = "#000", S.fillText(T, 0, N);
    var $ = S.getImageData(0, 0, D, B).data, U = $.length, H = D * 4, V = 0, X = 0, W = !1;
    for (V = 0; V < N; ++V) {
      for (var Y = 0; Y < H; Y += 4)
        if ($[X + Y] !== 255) {
          W = !0;
          break;
        }
      if (!W)
        X += H;
      else
        break;
    }
    for (e.ascent = N - V, X = U - H, W = !1, V = B; V > N; --V) {
      for (var Y = 0; Y < H; Y += 4)
        if ($[X + Y] !== 255) {
          W = !0;
          break;
        }
      if (!W)
        X -= H;
      else
        break;
    }
    return e.descent = V - N, e.fontSize = e.ascent + e.descent, o._fonts[t] = e, e;
  }, o.clearMetrics = function(t) {
    t === void 0 && (t = ""), t ? delete o._fonts[t] : o._fonts = {};
  }, Object.defineProperty(o, "_canvas", {
    /**
     * Cached canvas element for measuring text
     * TODO: this should be private, but isn't because of backward compat, will fix later.
     * @ignore
     */
    get: function() {
      if (!o.__canvas) {
        var t = void 0;
        try {
          var e = new OffscreenCanvas(0, 0), r = e.getContext("2d", contextSettings);
          if (r && r.measureText)
            return o.__canvas = e, e;
          t = settings.ADAPTER.createCanvas();
        } catch {
          t = settings.ADAPTER.createCanvas();
        }
        t.width = t.height = 10, o.__canvas = t;
      }
      return o.__canvas;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "_context", {
    /**
     * TODO: this should be private, but isn't because of backward compat, will fix later.
     * @ignore
     */
    get: function() {
      return o.__context || (o.__context = o._canvas.getContext("2d", contextSettings)), o.__context;
    },
    enumerable: !1,
    configurable: !0
  }), o;
}();
TextMetrics._fonts = {};
TextMetrics.METRICS_STRING = "|ÉqÅ";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
var defaultDestroyOptions = {
  texture: !0,
  children: !1,
  baseTexture: !0
}, Text = function(o) {
  __extends$j(t, o);
  function t(e, r, S) {
    var T = this, D = !1;
    S || (S = settings.ADAPTER.createCanvas(), D = !0), S.width = 3, S.height = 3;
    var N = Texture.from(S);
    return N.orig = new Rectangle(), N.trim = new Rectangle(), T = o.call(this, N) || this, T._ownCanvas = D, T.canvas = S, T.context = S.getContext("2d", {
      // required for trimming to work without warnings
      willReadFrequently: !0
    }), T._resolution = settings.RESOLUTION, T._autoResolution = !0, T._text = null, T._style = null, T._styleListener = null, T._font = "", T.text = e, T.style = r, T.localStyleID = -1, T;
  }
  return t.prototype.updateText = function(e) {
    var r = this._style;
    if (this.localStyleID !== r.styleID && (this.dirty = !0, this.localStyleID = r.styleID), !(!this.dirty && e)) {
      this._font = this._style.toFontString();
      var S = this.context, T = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), D = T.width, N = T.height, B = T.lines, $ = T.lineHeight, U = T.lineWidths, H = T.maxLineWidth, V = T.fontProperties;
      this.canvas.width = Math.ceil(Math.ceil(Math.max(1, D) + r.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, N) + r.padding * 2) * this._resolution), S.scale(this._resolution, this._resolution), S.clearRect(0, 0, this.canvas.width, this.canvas.height), S.font = this._font, S.lineWidth = r.strokeThickness, S.textBaseline = r.textBaseline, S.lineJoin = r.lineJoin, S.miterLimit = r.miterLimit;
      for (var X, W, Y = r.dropShadow ? 2 : 1, q = 0; q < Y; ++q) {
        var K = r.dropShadow && q === 0, Z = K ? Math.ceil(Math.max(1, N) + r.padding * 2) : 0, J = Z * this._resolution;
        if (K) {
          S.fillStyle = "black", S.strokeStyle = "black";
          var Q = r.dropShadowColor, rt = hex2rgb(typeof Q == "number" ? Q : string2hex(Q)), et = r.dropShadowBlur * this._resolution, nt = r.dropShadowDistance * this._resolution;
          S.shadowColor = "rgba(" + rt[0] * 255 + "," + rt[1] * 255 + "," + rt[2] * 255 + "," + r.dropShadowAlpha + ")", S.shadowBlur = et, S.shadowOffsetX = Math.cos(r.dropShadowAngle) * nt, S.shadowOffsetY = Math.sin(r.dropShadowAngle) * nt + J;
        } else
          S.fillStyle = this._generateFillStyle(r, B, T), S.strokeStyle = r.stroke, S.shadowColor = "black", S.shadowBlur = 0, S.shadowOffsetX = 0, S.shadowOffsetY = 0;
        var st = ($ - V.fontSize) / 2;
        (!t.nextLineHeightBehavior || $ - V.fontSize < 0) && (st = 0);
        for (var it = 0; it < B.length; it++)
          X = r.strokeThickness / 2, W = r.strokeThickness / 2 + it * $ + V.ascent + st, r.align === "right" ? X += H - U[it] : r.align === "center" && (X += (H - U[it]) / 2), r.stroke && r.strokeThickness && this.drawLetterSpacing(B[it], X + r.padding, W + r.padding - Z, !0), r.fill && this.drawLetterSpacing(B[it], X + r.padding, W + r.padding - Z);
      }
      this.updateTexture();
    }
  }, t.prototype.drawLetterSpacing = function(e, r, S, T) {
    T === void 0 && (T = !1);
    var D = this._style, N = D.letterSpacing, B = t.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
    if (N === 0 || B) {
      B && (this.context.letterSpacing = N, this.context.textLetterSpacing = N), T ? this.context.strokeText(e, r, S) : this.context.fillText(e, r, S);
      return;
    }
    for (var $ = r, U = Array.from ? Array.from(e) : e.split(""), H = this.context.measureText(e).width, V = 0, X = 0; X < U.length; ++X) {
      var W = U[X];
      T ? this.context.strokeText(W, $, S) : this.context.fillText(W, $, S);
      for (var Y = "", q = X + 1; q < U.length; ++q)
        Y += U[q];
      V = this.context.measureText(Y).width, $ += H - V + N, H = V;
    }
  }, t.prototype.updateTexture = function() {
    var e = this.canvas;
    if (this._style.trim) {
      var r = trimCanvas(e);
      r.data && (e.width = r.width, e.height = r.height, this.context.putImageData(r.data, 0, 0));
    }
    var S = this._texture, T = this._style, D = T.trim ? 0 : T.padding, N = S.baseTexture;
    S.trim.width = S._frame.width = e.width / this._resolution, S.trim.height = S._frame.height = e.height / this._resolution, S.trim.x = -D, S.trim.y = -D, S.orig.width = S._frame.width - D * 2, S.orig.height = S._frame.height - D * 2, this._onTextureUpdate(), N.setRealSize(e.width, e.height, this._resolution), S.updateUvs(), this.dirty = !1;
  }, t.prototype._render = function(e) {
    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), o.prototype._render.call(this, e);
  }, t.prototype.updateTransform = function() {
    this.updateText(!0), o.prototype.updateTransform.call(this);
  }, t.prototype.getBounds = function(e, r) {
    return this.updateText(!0), this._textureID === -1 && (e = !1), o.prototype.getBounds.call(this, e, r);
  }, t.prototype.getLocalBounds = function(e) {
    return this.updateText(!0), o.prototype.getLocalBounds.call(this, e);
  }, t.prototype._calculateBounds = function() {
    this.calculateVertices(), this._bounds.addQuad(this.vertexData);
  }, t.prototype._generateFillStyle = function(e, r, S) {
    var T = e.fill;
    if (Array.isArray(T)) {
      if (T.length === 1)
        return T[0];
    } else
      return T;
    var D, N = e.dropShadow ? e.dropShadowDistance : 0, B = e.padding || 0, $ = this.canvas.width / this._resolution - N - B * 2, U = this.canvas.height / this._resolution - N - B * 2, H = T.slice(), V = e.fillGradientStops.slice();
    if (!V.length)
      for (var X = H.length + 1, W = 1; W < X; ++W)
        V.push(W / X);
    if (H.unshift(T[0]), V.unshift(0), H.push(T[T.length - 1]), V.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      D = this.context.createLinearGradient($ / 2, B, $ / 2, U + B);
      for (var Y = S.fontProperties.fontSize + e.strokeThickness, W = 0; W < r.length; W++) {
        var q = S.lineHeight * (W - 1) + Y, K = S.lineHeight * W, Z = K;
        W > 0 && q > K && (Z = (K + q) / 2);
        var J = K + Y, Q = S.lineHeight * (W + 1), rt = J;
        W + 1 < r.length && Q < J && (rt = (J + Q) / 2);
        for (var et = (rt - Z) / U, nt = 0; nt < H.length; nt++) {
          var st = 0;
          typeof V[nt] == "number" ? st = V[nt] : st = nt / H.length;
          var it = Math.min(1, Math.max(0, Z / U + st * et));
          it = Number(it.toFixed(5)), D.addColorStop(it, H[nt]);
        }
      }
    } else {
      D = this.context.createLinearGradient(B, U / 2, $ + B, U / 2);
      for (var ot = H.length + 1, ht = 1, W = 0; W < H.length; W++) {
        var ct = void 0;
        typeof V[W] == "number" ? ct = V[W] : ct = ht / ot, D.addColorStop(ct, H[W]), ht++;
      }
    }
    return D;
  }, t.prototype.destroy = function(e) {
    typeof e == "boolean" && (e = { children: e }), e = Object.assign({}, defaultDestroyOptions, e), o.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;
  }, Object.defineProperty(t.prototype, "width", {
    /** The width of the Text, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;
    },
    set: function(e) {
      this.updateText(!0);
      var r = sign(this.scale.x) || 1;
      this.scale.x = r * e / this._texture.orig.width, this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    /** The height of the Text, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;
    },
    set: function(e) {
      this.updateText(!0);
      var r = sign(this.scale.y) || 1;
      this.scale.y = r * e / this._texture.orig.height, this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "style", {
    /**
     * Set the style of the text.
     *
     * Set up an event listener to listen for changes on the style object and mark the text as dirty.
     */
    get: function() {
      return this._style;
    },
    set: function(e) {
      e = e || {}, e instanceof TextStyle ? this._style = e : this._style = new TextStyle(e), this.localStyleID = -1, this.dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "text", {
    /** Set the copy for the text object. To split a line you can use '\n'. */
    get: function() {
      return this._text;
    },
    set: function(e) {
      e = String(e ?? ""), this._text !== e && (this._text = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "resolution", {
    /**
     * The resolution / device pixel ratio of the canvas.
     *
     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
     * @default 1
     */
    get: function() {
      return this._resolution;
    },
    set: function(e) {
      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), t.nextLineHeightBehavior = !1, t.experimentalLetterSpacing = !1, t;
}(Sprite);
/*!
 * @pixi/prepare - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/prepare is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.UPLOADS_PER_FRAME = 4;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$i = function(o, t) {
  return extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$i(o, t);
};
function __extends$i(o, t) {
  extendStatics$i(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var CountLimiter = function() {
  function o(t) {
    this.maxItemsPerFrame = t, this.itemsLeft = 0;
  }
  return o.prototype.beginFrame = function() {
    this.itemsLeft = this.maxItemsPerFrame;
  }, o.prototype.allowedToUpload = function() {
    return this.itemsLeft-- > 0;
  }, o;
}();
function findMultipleBaseTextures(o, t) {
  var e = !1;
  if (o && o._textures && o._textures.length) {
    for (var r = 0; r < o._textures.length; r++)
      if (o._textures[r] instanceof Texture) {
        var S = o._textures[r].baseTexture;
        t.indexOf(S) === -1 && (t.push(S), e = !0);
      }
  }
  return e;
}
function findBaseTexture(o, t) {
  if (o.baseTexture instanceof BaseTexture) {
    var e = o.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function findTexture(o, t) {
  if (o._texture && o._texture instanceof Texture) {
    var e = o._texture.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function drawText(o, t) {
  return t instanceof Text ? (t.updateText(!0), !0) : !1;
}
function calculateTextStyle(o, t) {
  if (t instanceof TextStyle) {
    var e = t.toFontString();
    return TextMetrics.measureFont(e), !0;
  }
  return !1;
}
function findText(o, t) {
  if (o instanceof Text) {
    t.indexOf(o.style) === -1 && t.push(o.style), t.indexOf(o) === -1 && t.push(o);
    var e = o._texture.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function findTextStyle(o, t) {
  return o instanceof TextStyle ? (t.indexOf(o) === -1 && t.push(o), !0) : !1;
}
var BasePrepare = function() {
  function o(t) {
    var e = this;
    this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function() {
      e.queue && e.prepareItems();
    }, this.registerFindHook(findText), this.registerFindHook(findTextStyle), this.registerFindHook(findMultipleBaseTextures), this.registerFindHook(findBaseTexture), this.registerFindHook(findTexture), this.registerUploadHook(drawText), this.registerUploadHook(calculateTextStyle);
  }
  return o.prototype.upload = function(t, e) {
    var r = this;
    return typeof t == "function" && (e = t, t = null), e && deprecation("6.5.0", "BasePrepare.upload callback is deprecated, use the return Promise instead."), new Promise(function(S) {
      t && r.add(t);
      var T = function() {
        e == null || e(), S();
      };
      r.queue.length ? (r.completes.push(T), r.ticking || (r.ticking = !0, Ticker.system.addOnce(r.tick, r, UPDATE_PRIORITY.UTILITY))) : T();
    });
  }, o.prototype.tick = function() {
    setTimeout(this.delayedTick, 0);
  }, o.prototype.prepareItems = function() {
    for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
      var t = this.queue[0], e = !1;
      if (t && !t._destroyed) {
        for (var r = 0, S = this.uploadHooks.length; r < S; r++)
          if (this.uploadHooks[r](this.uploadHookHelper, t)) {
            this.queue.shift(), e = !0;
            break;
          }
      }
      e || this.queue.shift();
    }
    if (this.queue.length)
      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
    else {
      this.ticking = !1;
      var T = this.completes.slice(0);
      this.completes.length = 0;
      for (var r = 0, S = T.length; r < S; r++)
        T[r]();
    }
  }, o.prototype.registerFindHook = function(t) {
    return t && this.addHooks.push(t), this;
  }, o.prototype.registerUploadHook = function(t) {
    return t && this.uploadHooks.push(t), this;
  }, o.prototype.add = function(t) {
    for (var e = 0, r = this.addHooks.length; e < r && !this.addHooks[e](t, this.queue); e++)
      ;
    if (t instanceof Container)
      for (var e = t.children.length - 1; e >= 0; e--)
        this.add(t.children[e]);
    return this;
  }, o.prototype.destroy = function() {
    this.ticking && Ticker.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;
  }, o;
}();
function uploadBaseTextures(o, t) {
  return t instanceof BaseTexture ? (t._glTextures[o.CONTEXT_UID] || o.texture.bind(t), !0) : !1;
}
function uploadGraphics(o, t) {
  if (!(t instanceof Graphics))
    return !1;
  var e = t.geometry;
  t.finishPoly(), e.updateBatches();
  for (var r = e.batches, S = 0; S < r.length; S++) {
    var T = r[S].style.texture;
    T && uploadBaseTextures(o, T.baseTexture);
  }
  return e.batchable || o.geometry.bind(e, t._resolveDirectShader(o)), !0;
}
function findGraphics(o, t) {
  return o instanceof Graphics ? (t.push(o), !0) : !1;
}
var Prepare = function(o) {
  __extends$i(t, o);
  function t(e) {
    var r = o.call(this, e) || this;
    return r.uploadHookHelper = r.renderer, r.registerFindHook(findGraphics), r.registerUploadHook(uploadBaseTextures), r.registerUploadHook(uploadGraphics), r;
  }
  return t.extension = {
    name: "prepare",
    type: ExtensionType.RendererPlugin
  }, t;
}(BasePrepare);
/*!
 * @pixi/spritesheet - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/spritesheet is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Spritesheet = function() {
  function o(t, e, r) {
    r === void 0 && (r = null), this.linkedSheets = [], this._texture = t instanceof Texture ? t : null, this.baseTexture = t instanceof BaseTexture ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;
    var S = this.baseTexture.resource;
    this.resolution = this._updateResolution(r || (S ? S.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
  }
  return o.prototype._updateResolution = function(t) {
    t === void 0 && (t = null);
    var e = this.data.meta.scale, r = getResolutionOfUrl(t, null);
    return r === null && (r = e !== void 0 ? parseFloat(e) : 1), r !== 1 && this.baseTexture.setResolution(r), r;
  }, o.prototype.parse = function(t) {
    var e = this;
    return t && deprecation("6.5.0", "Spritesheet.parse callback is deprecated, use the return Promise instead."), new Promise(function(r) {
      e._callback = function(S) {
        t == null || t(S), r(S);
      }, e._batchIndex = 0, e._frameKeys.length <= o.BATCH_SIZE ? (e._processFrames(0), e._processAnimations(), e._parseComplete()) : e._nextBatch();
    });
  }, o.prototype._processFrames = function(t) {
    for (var e = t, r = o.BATCH_SIZE; e - t < r && e < this._frameKeys.length; ) {
      var S = this._frameKeys[e], T = this._frames[S], D = T.frame;
      if (D) {
        var N = null, B = null, $ = T.trimmed !== !1 && T.sourceSize ? T.sourceSize : T.frame, U = new Rectangle(0, 0, Math.floor($.w) / this.resolution, Math.floor($.h) / this.resolution);
        T.rotated ? N = new Rectangle(Math.floor(D.x) / this.resolution, Math.floor(D.y) / this.resolution, Math.floor(D.h) / this.resolution, Math.floor(D.w) / this.resolution) : N = new Rectangle(Math.floor(D.x) / this.resolution, Math.floor(D.y) / this.resolution, Math.floor(D.w) / this.resolution, Math.floor(D.h) / this.resolution), T.trimmed !== !1 && T.spriteSourceSize && (B = new Rectangle(Math.floor(T.spriteSourceSize.x) / this.resolution, Math.floor(T.spriteSourceSize.y) / this.resolution, Math.floor(D.w) / this.resolution, Math.floor(D.h) / this.resolution)), this.textures[S] = new Texture(this.baseTexture, N, U, B, T.rotated ? 2 : 0, T.anchor), Texture.addToCache(this.textures[S], S);
      }
      e++;
    }
  }, o.prototype._processAnimations = function() {
    var t = this.data.animations || {};
    for (var e in t) {
      this.animations[e] = [];
      for (var r = 0; r < t[e].length; r++) {
        var S = t[e][r];
        this.animations[e].push(this.textures[S]);
      }
    }
  }, o.prototype._parseComplete = function() {
    var t = this._callback;
    this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
  }, o.prototype._nextBatch = function() {
    var t = this;
    this._processFrames(this._batchIndex * o.BATCH_SIZE), this._batchIndex++, setTimeout(function() {
      t._batchIndex * o.BATCH_SIZE < t._frameKeys.length ? t._nextBatch() : (t._processAnimations(), t._parseComplete());
    }, 0);
  }, o.prototype.destroy = function(t) {
    var e;
    t === void 0 && (t = !1);
    for (var r in this.textures)
      this.textures[r].destroy();
    this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) === null || e === void 0 || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];
  }, o.BATCH_SIZE = 1e3, o;
}(), SpritesheetLoader = function() {
  function o() {
  }
  return o.use = function(t, e) {
    var r, S, T = this, D = t.name + "_image";
    if (!t.data || t.type !== LoaderResource.TYPE.JSON || !t.data.frames || T.resources[D]) {
      e();
      return;
    }
    var N = (S = (r = t.data) === null || r === void 0 ? void 0 : r.meta) === null || S === void 0 ? void 0 : S.related_multi_packs;
    if (Array.isArray(N))
      for (var B = function(W) {
        if (typeof W != "string")
          return "continue";
        var Y = W.replace(".json", ""), q = url$1.resolve(t.url.replace(T.baseUrl, ""), W);
        if (T.resources[Y] || Object.values(T.resources).some(function(Z) {
          return url$1.format(url$1.parse(Z.url)) === q;
        }))
          return "continue";
        var K = {
          crossOrigin: t.crossOrigin,
          loadType: LoaderResource.LOAD_TYPE.XHR,
          xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,
          parentResource: t,
          metadata: t.metadata
        };
        T.add(Y, q, K);
      }, $ = 0, U = N; $ < U.length; $++) {
        var H = U[$];
        B(H);
      }
    var V = {
      crossOrigin: t.crossOrigin,
      metadata: t.metadata.imageMetadata,
      parentResource: t
    }, X = o.getResourcePath(t, T.baseUrl);
    T.add(D, X, V, function(Y) {
      if (Y.error) {
        e(Y.error);
        return;
      }
      var q = new Spritesheet(Y.texture, t.data, t.url);
      q.parse().then(function() {
        t.spritesheet = q, t.textures = q.textures, e();
      });
    });
  }, o.getResourcePath = function(t, e) {
    return t.isDataUrl ? t.data.meta.image : url$1.resolve(t.url.replace(e, ""), t.data.meta.image);
  }, o.extension = ExtensionType.Loader, o;
}();
/*!
 * @pixi/sprite-tiling - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$h = function(o, t) {
  return extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$h(o, t);
};
function __extends$h(o, t) {
  extendStatics$h(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var tempPoint$1 = new Point();
(function(o) {
  __extends$h(t, o);
  function t(e, r, S) {
    r === void 0 && (r = 100), S === void 0 && (S = 100);
    var T = o.call(this, e) || this;
    return T.tileTransform = new Transform(), T._width = r, T._height = S, T.uvMatrix = T.texture.uvMatrix || new TextureMatrix(e), T.pluginName = "tilingSprite", T.uvRespectAnchor = !1, T;
  }
  return Object.defineProperty(t.prototype, "clampMargin", {
    /**
     * Changes frame clamping in corresponding textureTransform, shortcut
     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
     * @default 0.5
     * @member {number}
     */
    get: function() {
      return this.uvMatrix.clampMargin;
    },
    set: function(e) {
      this.uvMatrix.clampMargin = e, this.uvMatrix.update(!0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tileScale", {
    /** The scaling of the image that is being tiled. */
    get: function() {
      return this.tileTransform.scale;
    },
    set: function(e) {
      this.tileTransform.scale.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tilePosition", {
    /** The offset of the image that is being tiled. */
    get: function() {
      return this.tileTransform.position;
    },
    set: function(e) {
      this.tileTransform.position.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._onTextureUpdate = function() {
    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;
  }, t.prototype._render = function(e) {
    var r = this._texture;
    !r || !r.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this));
  }, t.prototype._calculateBounds = function() {
    var e = this._width * -this._anchor._x, r = this._height * -this._anchor._y, S = this._width * (1 - this._anchor._x), T = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, e, r, S, T);
  }, t.prototype.getLocalBounds = function(e) {
    return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._bounds.getRectangle(e)) : o.prototype.getLocalBounds.call(this, e);
  }, t.prototype.containsPoint = function(e) {
    this.worldTransform.applyInverse(e, tempPoint$1);
    var r = this._width, S = this._height, T = -r * this.anchor._x;
    if (tempPoint$1.x >= T && tempPoint$1.x < T + r) {
      var D = -S * this.anchor._y;
      if (tempPoint$1.y >= D && tempPoint$1.y < D + S)
        return !0;
    }
    return !1;
  }, t.prototype.destroy = function(e) {
    o.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null;
  }, t.from = function(e, r) {
    var S = e instanceof Texture ? e : Texture.from(e, r);
    return new t(S, r.width, r.height);
  }, Object.defineProperty(t.prototype, "width", {
    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this._width;
    },
    set: function(e) {
      this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this._height;
    },
    set: function(e) {
      this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Sprite);
var fragmentSimpleSrc = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`, gl1VertexSrc = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, gl1FragmentSrc = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`, gl2VertexSrc = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, gl2FragmentSrc = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`, tempMat = new Matrix(), TilingSpriteRenderer = function(o) {
  __extends$h(t, o);
  function t(e) {
    var r = o.call(this, e) || this;
    return e.runners.contextChange.add(r), r.quad = new QuadUv(), r.state = State.for2d(), r;
  }
  return t.prototype.contextChange = function() {
    var e = this.renderer, r = { globals: e.globalUniforms };
    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, r), this.shader = e.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, r) : Shader.from(gl1VertexSrc, gl1FragmentSrc, r);
  }, t.prototype.render = function(e) {
    var r = this.renderer, S = this.quad, T = S.vertices;
    T[0] = T[6] = e._width * -e.anchor.x, T[1] = T[3] = e._height * -e.anchor.y, T[2] = T[4] = e._width * (1 - e.anchor.x), T[5] = T[7] = e._height * (1 - e.anchor.y);
    var D = e.uvRespectAnchor ? e.anchor.x : 0, N = e.uvRespectAnchor ? e.anchor.y : 0;
    T = S.uvs, T[0] = T[6] = -D, T[1] = T[3] = -N, T[2] = T[4] = 1 - D, T[5] = T[7] = 1 - N, S.invalidate();
    var B = e._texture, $ = B.baseTexture, U = $.alphaMode > 0, H = e.tileTransform.localTransform, V = e.uvMatrix, X = $.isPowerOfTwo && B.frame.width === $.width && B.frame.height === $.height;
    X && ($._glTextures[r.CONTEXT_UID] ? X = $.wrapMode !== WRAP_MODES.CLAMP : $.wrapMode === WRAP_MODES.CLAMP && ($.wrapMode = WRAP_MODES.REPEAT));
    var W = X ? this.simpleShader : this.shader, Y = B.width, q = B.height, K = e._width, Z = e._height;
    tempMat.set(H.a * Y / K, H.b * Y / Z, H.c * q / K, H.d * q / Z, H.tx / K, H.ty / Z), tempMat.invert(), X ? tempMat.prepend(V.mapCoord) : (W.uniforms.uMapCoord = V.mapCoord.toArray(!0), W.uniforms.uClampFrame = V.uClampFrame, W.uniforms.uClampOffset = V.uClampOffset), W.uniforms.uTransform = tempMat.toArray(!0), W.uniforms.uColor = premultiplyTintToRgba(e.tint, e.worldAlpha, W.uniforms.uColor, U), W.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0), W.uniforms.uSampler = B, r.shader.bind(W), r.geometry.bind(S), this.state.blendMode = correctBlendMode(e.blendMode, U), r.state.set(this.state), r.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
  }, t.extension = {
    name: "tilingSprite",
    type: ExtensionType.RendererPlugin
  }, t;
}(ObjectRenderer);
/*!
 * @pixi/mesh - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/mesh is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$g = function(o, t) {
  return extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$g(o, t);
};
function __extends$g(o, t) {
  extendStatics$g(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var MeshBatchUvs = function() {
  function o(t, e) {
    this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;
  }
  return o.prototype.update = function(t) {
    if (!(!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)) {
      this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
      var e = this.uvBuffer.data;
      (!this.data || this.data.length !== e.length) && (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++;
    }
  }, o;
}(), tempPoint = new Point(), tempPolygon = new Polygon(), Mesh = function(o) {
  __extends$g(t, o);
  function t(e, r, S, T) {
    T === void 0 && (T = DRAW_MODES.TRIANGLES);
    var D = o.call(this) || this;
    return D.geometry = e, D.shader = r, D.state = S || State.for2d(), D.drawMode = T, D.start = 0, D.size = 0, D.uvs = null, D.indices = null, D.vertexData = new Float32Array(1), D.vertexDirty = -1, D._transformID = -1, D._roundPixels = settings.ROUND_PIXELS, D.batchUvs = null, D;
  }
  return Object.defineProperty(t.prototype, "geometry", {
    /**
     * Includes vertex positions, face indices, normals, colors, UVs, and
     * custom attributes within buffers, reducing the cost of passing all
     * this data to the GPU. Can be shared between multiple Mesh objects.
     */
    get: function() {
      return this._geometry;
    },
    set: function(e) {
      this._geometry !== e && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "uvBuffer", {
    /**
     * To change mesh uv's, change its uvBuffer data and increment its _updateID.
     * @readonly
     */
    get: function() {
      return this.geometry.buffers[1];
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "verticesBuffer", {
    /**
     * To change mesh vertices, change its uvBuffer data and increment its _updateID.
     * Incrementing _updateID is optional because most of Mesh objects do it anyway.
     * @readonly
     */
    get: function() {
      return this.geometry.buffers[0];
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "material", {
    get: function() {
      return this.shader;
    },
    /** Alias for {@link PIXI.Mesh#shader}. */
    set: function(e) {
      this.shader = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    /**
     * The blend mode to be applied to the Mesh. Apply a value of
     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     * @default PIXI.BLEND_MODES.NORMAL;
     */
    set: function(e) {
      this.state.blendMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     * @default false
     */
    set: function(e) {
      this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tint", {
    /**
     * The multiply tint applied to the Mesh. This is a hex value. A value of
     * `0xFFFFFF` will remove any tint effect.
     *
     * Null for non-MeshMaterial shaders
     * @default 0xFFFFFF
     */
    get: function() {
      return "tint" in this.shader ? this.shader.tint : null;
    },
    set: function(e) {
      this.shader.tint = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "texture", {
    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
    get: function() {
      return "texture" in this.shader ? this.shader.texture : null;
    },
    set: function(e) {
      this.shader.texture = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._render = function(e) {
    var r = this.geometry.buffers[0].data, S = this.shader;
    S.batchable && this.drawMode === DRAW_MODES.TRIANGLES && r.length < t.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e);
  }, t.prototype._renderDefault = function(e) {
    var r = this.shader;
    r.alpha = this.worldAlpha, r.update && r.update(), e.batch.flush(), r.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(r), e.state.set(this.state), e.geometry.bind(this.geometry, r), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  }, t.prototype._renderToBatch = function(e) {
    var r = this.geometry, S = this.shader;
    S.uvMatrix && (S.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = r.indexBuffer.data, this._tintRGB = S._tintRGB, this._texture = S.texture;
    var T = this.material.pluginName;
    e.batch.setObjectRenderer(e.plugins[T]), e.plugins[T].render(this);
  }, t.prototype.calculateVertices = function() {
    var e = this.geometry, r = e.buffers[0], S = r.data, T = r._updateID;
    if (!(T === this.vertexDirty && this._transformID === this.transform._worldID)) {
      this._transformID = this.transform._worldID, this.vertexData.length !== S.length && (this.vertexData = new Float32Array(S.length));
      for (var D = this.transform.worldTransform, N = D.a, B = D.b, $ = D.c, U = D.d, H = D.tx, V = D.ty, X = this.vertexData, W = 0; W < X.length / 2; W++) {
        var Y = S[W * 2], q = S[W * 2 + 1];
        X[W * 2] = N * Y + $ * q + H, X[W * 2 + 1] = B * Y + U * q + V;
      }
      if (this._roundPixels)
        for (var K = settings.RESOLUTION, W = 0; W < X.length; ++W)
          X[W] = Math.round((X[W] * K | 0) / K);
      this.vertexDirty = T;
    }
  }, t.prototype.calculateUvs = function() {
    var e = this.geometry.buffers[1], r = this.shader;
    r.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs(e, r.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);
  }, t.prototype._calculateBounds = function() {
    this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  }, t.prototype.containsPoint = function(e) {
    if (!this.getBounds().contains(e.x, e.y))
      return !1;
    this.worldTransform.applyInverse(e, tempPoint);
    for (var r = this.geometry.getBuffer("aVertexPosition").data, S = tempPolygon.points, T = this.geometry.getIndex().data, D = T.length, N = this.drawMode === 4 ? 3 : 1, B = 0; B + 2 < D; B += N) {
      var $ = T[B] * 2, U = T[B + 1] * 2, H = T[B + 2] * 2;
      if (S[0] = r[$], S[1] = r[$ + 1], S[2] = r[U], S[3] = r[U + 1], S[4] = r[H], S[5] = r[H + 1], tempPolygon.contains(tempPoint.x, tempPoint.y))
        return !0;
    }
    return !1;
  }, t.prototype.destroy = function(e) {
    o.prototype.destroy.call(this, e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;
  }, t.BATCHABLE_SIZE = 100, t;
}(Container), fragment$5 = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`, vertex$2 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`, MeshMaterial = function(o) {
  __extends$g(t, o);
  function t(e, r) {
    var S = this, T = {
      uSampler: e,
      alpha: 1,
      uTextureMatrix: Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    return r = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, r), r.uniforms && Object.assign(T, r.uniforms), S = o.call(this, r.program || Program.from(vertex$2, fragment$5), T) || this, S._colorDirty = !1, S.uvMatrix = new TextureMatrix(e), S.batchable = r.program === void 0, S.pluginName = r.pluginName, S.tint = r.tint, S.alpha = r.alpha, S;
  }
  return Object.defineProperty(t.prototype, "texture", {
    /** Reference to the texture being rendered. */
    get: function() {
      return this.uniforms.uSampler;
    },
    set: function(e) {
      this.uniforms.uSampler !== e && (!this.uniforms.uSampler.baseTexture.alphaMode != !e.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = e, this.uvMatrix.texture = e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "alpha", {
    get: function() {
      return this._alpha;
    },
    /**
     * This gets automatically set by the object using this.
     * @default 1
     */
    set: function(e) {
      e !== this._alpha && (this._alpha = e, this._colorDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    /**
     * Multiply tint for the material.
     * @default 0xFFFFFF
     */
    set: function(e) {
      e !== this._tint && (this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16), this._colorDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.update = function() {
    if (this._colorDirty) {
      this._colorDirty = !1;
      var e = this.texture.baseTexture;
      premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, e.alphaMode);
    }
    this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
  }, t;
}(Shader), MeshGeometry = function(o) {
  __extends$g(t, o);
  function t(e, r, S) {
    var T = o.call(this) || this, D = new Buffer$1(e), N = new Buffer$1(r, !0), B = new Buffer$1(S, !0, !0);
    return T.addAttribute("aVertexPosition", D, 2, !1, TYPES.FLOAT).addAttribute("aTextureCoord", N, 2, !1, TYPES.FLOAT).addIndex(B), T._updateId = -1, T;
  }
  return Object.defineProperty(t.prototype, "vertexDirtyId", {
    /**
     * If the vertex position is updated.
     * @readonly
     * @private
     */
    get: function() {
      return this.buffers[0]._updateID;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Geometry);
/*!
 * @pixi/text-bitmap - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/text-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$f = function(o, t) {
  return extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$f(o, t);
};
function __extends$f(o, t) {
  extendStatics$f(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var BitmapFontData = function() {
  function o() {
    this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];
  }
  return o;
}(), TextFormat = function() {
  function o() {
  }
  return o.test = function(t) {
    return typeof t == "string" && t.indexOf("info face=") === 0;
  }, o.parse = function(t) {
    var e = t.match(/^[a-z]+\s+.+$/gm), r = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (var S in e) {
      var T = e[S].match(/^[a-z]+/gm)[0], D = e[S].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), N = {};
      for (var B in D) {
        var $ = D[B].split("="), U = $[0], H = $[1].replace(/"/gm, ""), V = parseFloat(H), X = isNaN(V) ? H : V;
        N[U] = X;
      }
      r[T].push(N);
    }
    var W = new BitmapFontData();
    return r.info.forEach(function(Y) {
      return W.info.push({
        face: Y.face,
        size: parseInt(Y.size, 10)
      });
    }), r.common.forEach(function(Y) {
      return W.common.push({
        lineHeight: parseInt(Y.lineHeight, 10)
      });
    }), r.page.forEach(function(Y) {
      return W.page.push({
        id: parseInt(Y.id, 10),
        file: Y.file
      });
    }), r.char.forEach(function(Y) {
      return W.char.push({
        id: parseInt(Y.id, 10),
        page: parseInt(Y.page, 10),
        x: parseInt(Y.x, 10),
        y: parseInt(Y.y, 10),
        width: parseInt(Y.width, 10),
        height: parseInt(Y.height, 10),
        xoffset: parseInt(Y.xoffset, 10),
        yoffset: parseInt(Y.yoffset, 10),
        xadvance: parseInt(Y.xadvance, 10)
      });
    }), r.kerning.forEach(function(Y) {
      return W.kerning.push({
        first: parseInt(Y.first, 10),
        second: parseInt(Y.second, 10),
        amount: parseInt(Y.amount, 10)
      });
    }), r.distanceField.forEach(function(Y) {
      return W.distanceField.push({
        distanceRange: parseInt(Y.distanceRange, 10),
        fieldType: Y.fieldType
      });
    }), W;
  }, o;
}(), XMLFormat = function() {
  function o() {
  }
  return o.test = function(t) {
    return t instanceof XMLDocument && t.getElementsByTagName("page").length && t.getElementsByTagName("info")[0].getAttribute("face") !== null;
  }, o.parse = function(t) {
    for (var e = new BitmapFontData(), r = t.getElementsByTagName("info"), S = t.getElementsByTagName("common"), T = t.getElementsByTagName("page"), D = t.getElementsByTagName("char"), N = t.getElementsByTagName("kerning"), B = t.getElementsByTagName("distanceField"), $ = 0; $ < r.length; $++)
      e.info.push({
        face: r[$].getAttribute("face"),
        size: parseInt(r[$].getAttribute("size"), 10)
      });
    for (var $ = 0; $ < S.length; $++)
      e.common.push({
        lineHeight: parseInt(S[$].getAttribute("lineHeight"), 10)
      });
    for (var $ = 0; $ < T.length; $++)
      e.page.push({
        id: parseInt(T[$].getAttribute("id"), 10) || 0,
        file: T[$].getAttribute("file")
      });
    for (var $ = 0; $ < D.length; $++) {
      var U = D[$];
      e.char.push({
        id: parseInt(U.getAttribute("id"), 10),
        page: parseInt(U.getAttribute("page"), 10) || 0,
        x: parseInt(U.getAttribute("x"), 10),
        y: parseInt(U.getAttribute("y"), 10),
        width: parseInt(U.getAttribute("width"), 10),
        height: parseInt(U.getAttribute("height"), 10),
        xoffset: parseInt(U.getAttribute("xoffset"), 10),
        yoffset: parseInt(U.getAttribute("yoffset"), 10),
        xadvance: parseInt(U.getAttribute("xadvance"), 10)
      });
    }
    for (var $ = 0; $ < N.length; $++)
      e.kerning.push({
        first: parseInt(N[$].getAttribute("first"), 10),
        second: parseInt(N[$].getAttribute("second"), 10),
        amount: parseInt(N[$].getAttribute("amount"), 10)
      });
    for (var $ = 0; $ < B.length; $++)
      e.distanceField.push({
        fieldType: B[$].getAttribute("fieldType"),
        distanceRange: parseInt(B[$].getAttribute("distanceRange"), 10)
      });
    return e;
  }, o;
}(), XMLStringFormat = function() {
  function o() {
  }
  return o.test = function(t) {
    if (typeof t == "string" && t.indexOf("<font>") > -1) {
      var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
      return XMLFormat.test(e);
    }
    return !1;
  }, o.parse = function(t) {
    var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
    return XMLFormat.parse(e);
  }, o;
}(), formats = [
  TextFormat,
  XMLFormat,
  XMLStringFormat
];
function autoDetectFormat(o) {
  for (var t = 0; t < formats.length; t++)
    if (formats[t].test(o))
      return formats[t];
  return null;
}
function generateFillStyle(o, t, e, r, S, T) {
  var D = e.fill;
  if (Array.isArray(D)) {
    if (D.length === 1)
      return D[0];
  } else
    return D;
  var N, B = e.dropShadow ? e.dropShadowDistance : 0, $ = e.padding || 0, U = o.width / r - B - $ * 2, H = o.height / r - B - $ * 2, V = D.slice(), X = e.fillGradientStops.slice();
  if (!X.length)
    for (var W = V.length + 1, Y = 1; Y < W; ++Y)
      X.push(Y / W);
  if (V.unshift(D[0]), X.unshift(0), V.push(D[D.length - 1]), X.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    N = t.createLinearGradient(U / 2, $, U / 2, H + $);
    for (var q = 0, K = T.fontProperties.fontSize + e.strokeThickness, Z = K / H, Y = 0; Y < S.length; Y++)
      for (var J = T.lineHeight * Y, Q = 0; Q < V.length; Q++) {
        var rt = 0;
        typeof X[Q] == "number" ? rt = X[Q] : rt = Q / V.length;
        var et = J / H + rt * Z, nt = Math.max(q, et);
        nt = Math.min(nt, 1), N.addColorStop(nt, V[Q]), q = nt;
      }
  } else {
    N = t.createLinearGradient($, H / 2, U + $, H / 2);
    for (var st = V.length + 1, it = 1, Y = 0; Y < V.length; Y++) {
      var ot = void 0;
      typeof X[Y] == "number" ? ot = X[Y] : ot = it / st, N.addColorStop(ot, V[Y]), it++;
    }
  }
  return N;
}
function drawGlyph(o, t, e, r, S, T, D) {
  var N = e.text, B = e.fontProperties;
  t.translate(r, S), t.scale(T, T);
  var $ = D.strokeThickness / 2, U = -(D.strokeThickness / 2);
  if (t.font = D.toFontString(), t.lineWidth = D.strokeThickness, t.textBaseline = D.textBaseline, t.lineJoin = D.lineJoin, t.miterLimit = D.miterLimit, t.fillStyle = generateFillStyle(o, t, D, T, [N], e), t.strokeStyle = D.stroke, D.dropShadow) {
    var H = D.dropShadowColor, V = hex2rgb(typeof H == "number" ? H : string2hex(H)), X = D.dropShadowBlur * T, W = D.dropShadowDistance * T;
    t.shadowColor = "rgba(" + V[0] * 255 + "," + V[1] * 255 + "," + V[2] * 255 + "," + D.dropShadowAlpha + ")", t.shadowBlur = X, t.shadowOffsetX = Math.cos(D.dropShadowAngle) * W, t.shadowOffsetY = Math.sin(D.dropShadowAngle) * W;
  } else
    t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
  D.stroke && D.strokeThickness && t.strokeText(N, $, U + e.lineHeight - B.descent), D.fill && t.fillText(N, $, U + e.lineHeight - B.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = "rgba(0, 0, 0, 0)";
}
function splitTextToCharacters(o) {
  return Array.from ? Array.from(o) : o.split("");
}
function resolveCharacters(o) {
  typeof o == "string" && (o = [o]);
  for (var t = [], e = 0, r = o.length; e < r; e++) {
    var S = o[e];
    if (Array.isArray(S)) {
      if (S.length !== 2)
        throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + S.length + ".");
      var T = S[0].charCodeAt(0), D = S[1].charCodeAt(0);
      if (D < T)
        throw new Error("[BitmapFont]: Invalid character range.");
      for (var N = T, B = D; N <= B; N++)
        t.push(String.fromCharCode(N));
    } else
      t.push.apply(t, splitTextToCharacters(S));
  }
  if (t.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return t;
}
function extractCharCode(o) {
  return o.codePointAt ? o.codePointAt(0) : o.charCodeAt(0);
}
var BitmapFont = function() {
  function o(t, e, r) {
    var S, T, D = t.info[0], N = t.common[0], B = t.page[0], $ = t.distanceField[0], U = getResolutionOfUrl(B.file), H = {};
    this._ownsTextures = r, this.font = D.face, this.size = D.size, this.lineHeight = N.lineHeight / U, this.chars = {}, this.pageTextures = H;
    for (var V = 0; V < t.page.length; V++) {
      var X = t.page[V], W = X.id, Y = X.file;
      H[W] = e instanceof Array ? e[V] : e[Y], $ != null && $.fieldType && $.fieldType !== "none" && (H[W].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA, H[W].baseTexture.mipmap = MIPMAP_MODES.OFF);
    }
    for (var V = 0; V < t.char.length; V++) {
      var q = t.char[V], W = q.id, K = q.page, Z = t.char[V], J = Z.x, Q = Z.y, rt = Z.width, et = Z.height, nt = Z.xoffset, st = Z.yoffset, it = Z.xadvance;
      J /= U, Q /= U, rt /= U, et /= U, nt /= U, st /= U, it /= U;
      var ot = new Rectangle(J + H[K].frame.x / U, Q + H[K].frame.y / U, rt, et);
      this.chars[W] = {
        xOffset: nt,
        yOffset: st,
        xAdvance: it,
        kerning: {},
        texture: new Texture(H[K].baseTexture, ot),
        page: K
      };
    }
    for (var V = 0; V < t.kerning.length; V++) {
      var ht = t.kerning[V], ct = ht.first, vt = ht.second, _t = ht.amount;
      ct /= U, vt /= U, _t /= U, this.chars[vt] && (this.chars[vt].kerning[ct] = _t);
    }
    this.distanceFieldRange = $ == null ? void 0 : $.distanceRange, this.distanceFieldType = (T = (S = $ == null ? void 0 : $.fieldType) === null || S === void 0 ? void 0 : S.toLowerCase()) !== null && T !== void 0 ? T : "none";
  }
  return o.prototype.destroy = function() {
    for (var t in this.chars)
      this.chars[t].texture.destroy(), this.chars[t].texture = null;
    for (var t in this.pageTextures)
      this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;
    this.chars = null, this.pageTextures = null;
  }, o.install = function(t, e, r) {
    var S;
    if (t instanceof BitmapFontData)
      S = t;
    else {
      var T = autoDetectFormat(t);
      if (!T)
        throw new Error("Unrecognized data format for font.");
      S = T.parse(t);
    }
    e instanceof Texture && (e = [e]);
    var D = new o(S, e, r);
    return o.available[D.font] = D, D;
  }, o.uninstall = function(t) {
    var e = o.available[t];
    if (!e)
      throw new Error("No font found named '" + t + "'");
    e.destroy(), delete o.available[t];
  }, o.from = function(t, e, r) {
    if (!t)
      throw new Error("[BitmapFont] Property `name` is required.");
    var S = Object.assign({}, o.defaultOptions, r), T = S.chars, D = S.padding, N = S.resolution, B = S.textureWidth, $ = S.textureHeight, U = resolveCharacters(T), H = e instanceof TextStyle ? e : new TextStyle(e), V = B, X = new BitmapFontData();
    X.info[0] = {
      face: H.fontFamily,
      size: H.fontSize
    }, X.common[0] = {
      lineHeight: H.fontSize
    };
    for (var W = 0, Y = 0, q, K, Z, J = 0, Q = [], rt = 0; rt < U.length; rt++) {
      q || (q = settings.ADAPTER.createCanvas(), q.width = B, q.height = $, K = q.getContext("2d"), Z = new BaseTexture(q, { resolution: N }), Q.push(new Texture(Z)), X.page.push({
        id: Q.length - 1,
        file: ""
      }));
      var et = U[rt], nt = TextMetrics.measureText(et, H, !1, q), st = nt.width, it = Math.ceil(nt.height), ot = Math.ceil((H.fontStyle === "italic" ? 2 : 1) * st);
      if (Y >= $ - it * N) {
        if (Y === 0)
          throw new Error("[BitmapFont] textureHeight " + $ + "px is too small " + ("(fontFamily: '" + H.fontFamily + "', fontSize: " + H.fontSize + "px, char: '" + et + "')"));
        --rt, q = null, K = null, Z = null, Y = 0, W = 0, J = 0;
        continue;
      }
      if (J = Math.max(it + nt.fontProperties.descent, J), ot * N + W >= V) {
        if (W === 0)
          throw new Error("[BitmapFont] textureWidth " + B + "px is too small " + ("(fontFamily: '" + H.fontFamily + "', fontSize: " + H.fontSize + "px, char: '" + et + "')"));
        --rt, Y += J * N, Y = Math.ceil(Y), W = 0, J = 0;
        continue;
      }
      drawGlyph(q, K, nt, W, Y, N, H);
      var ht = extractCharCode(nt.text);
      X.char.push({
        id: ht,
        page: Q.length - 1,
        x: W / N,
        y: Y / N,
        width: ot,
        height: it,
        xoffset: 0,
        yoffset: 0,
        xadvance: Math.ceil(st - (H.dropShadow ? H.dropShadowDistance : 0) - (H.stroke ? H.strokeThickness : 0))
      }), W += (ot + 2 * D) * N, W = Math.ceil(W);
    }
    for (var rt = 0, ct = U.length; rt < ct; rt++)
      for (var vt = U[rt], _t = 0; _t < ct; _t++) {
        var gt = U[_t], mt = K.measureText(vt).width, Et = K.measureText(gt).width, wt = K.measureText(vt + gt).width, xt = wt - (mt + Et);
        xt && X.kerning.push({
          first: extractCharCode(vt),
          second: extractCharCode(gt),
          amount: xt
        });
      }
    var pt = new o(X, Q, !0);
    return o.available[t] !== void 0 && o.uninstall(t), o.available[t] = pt, pt;
  }, o.ALPHA = [["a", "z"], ["A", "Z"], " "], o.NUMERIC = [["0", "9"]], o.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], o.ASCII = [[" ", "~"]], o.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: o.ALPHANUMERIC
  }, o.available = {}, o;
}(), msdfFrag = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r
\r
}\r
`, msdfVert = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`, pageMeshDataDefaultPageMeshData = [], pageMeshDataMSDFPageMeshData = [], charRenderDataPool = [];
(function(o) {
  __extends$f(t, o);
  function t(e, r) {
    r === void 0 && (r = {});
    var S = o.call(this) || this;
    S._tint = 16777215;
    var T = Object.assign({}, t.styleDefaults, r), D = T.align, N = T.tint, B = T.maxWidth, $ = T.letterSpacing, U = T.fontName, H = T.fontSize;
    if (!BitmapFont.available[U])
      throw new Error('Missing BitmapFont "' + U + '"');
    return S._activePagesMeshData = [], S._textWidth = 0, S._textHeight = 0, S._align = D, S._tint = N, S._font = void 0, S._fontName = U, S._fontSize = H, S.text = e, S._maxWidth = B, S._maxLineHeight = 0, S._letterSpacing = $, S._anchor = new ObservablePoint(function() {
      S.dirty = !0;
    }, S, 0, 0), S._roundPixels = settings.ROUND_PIXELS, S.dirty = !0, S._resolution = settings.RESOLUTION, S._autoResolution = !0, S._textureCache = {}, S;
  }
  return t.prototype.updateText = function() {
    for (var e, r = BitmapFont.available[this._fontName], S = this.fontSize, T = S / r.size, D = new Point(), N = [], B = [], $ = [], U = this._text.replace(/(?:\r\n|\r)/g, `
`) || " ", H = splitTextToCharacters(U), V = this._maxWidth * r.size / S, X = r.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData, W = null, Y = 0, q = 0, K = 0, Z = -1, J = 0, Q = 0, rt = 0, et = 0, nt = 0; nt < H.length; nt++) {
      var st = H[nt], it = extractCharCode(st);
      if (/(?:\s)/.test(st) && (Z = nt, J = Y, et++), st === "\r" || st === `
`) {
        B.push(Y), $.push(-1), q = Math.max(q, Y), ++K, ++Q, D.x = 0, D.y += r.lineHeight, W = null, et = 0;
        continue;
      }
      var ot = r.chars[it];
      if (ot) {
        W && ot.kerning[W] && (D.x += ot.kerning[W]);
        var ht = charRenderDataPool.pop() || {
          texture: Texture.EMPTY,
          line: 0,
          charCode: 0,
          prevSpaces: 0,
          position: new Point()
        };
        ht.texture = ot.texture, ht.line = K, ht.charCode = it, ht.position.x = D.x + ot.xOffset + this._letterSpacing / 2, ht.position.y = D.y + ot.yOffset, ht.prevSpaces = et, N.push(ht), Y = ht.position.x + Math.max(ot.xAdvance - ot.xOffset, ot.texture.orig.width), D.x += ot.xAdvance + this._letterSpacing, rt = Math.max(rt, ot.yOffset + ot.texture.height), W = it, Z !== -1 && V > 0 && D.x > V && (++Q, removeItems(N, 1 + Z - Q, 1 + nt - Z), nt = Z, Z = -1, B.push(J), $.push(N.length > 0 ? N[N.length - 1].prevSpaces : 0), q = Math.max(q, J), K++, D.x = 0, D.y += r.lineHeight, W = null, et = 0);
      }
    }
    var ct = H[H.length - 1];
    ct !== "\r" && ct !== `
` && (/(?:\s)/.test(ct) && (Y = J), B.push(Y), q = Math.max(q, Y), $.push(-1));
    for (var vt = [], nt = 0; nt <= K; nt++) {
      var _t = 0;
      this._align === "right" ? _t = q - B[nt] : this._align === "center" ? _t = (q - B[nt]) / 2 : this._align === "justify" && (_t = $[nt] < 0 ? 0 : (q - B[nt]) / $[nt]), vt.push(_t);
    }
    var gt = N.length, mt = {}, Et = [], wt = this._activePagesMeshData;
    X.push.apply(X, wt);
    for (var nt = 0; nt < gt; nt++) {
      var xt = N[nt].texture, pt = xt.baseTexture.uid;
      if (!mt[pt]) {
        var yt = X.pop();
        if (!yt) {
          var Dt = new MeshGeometry(), At = void 0, It = void 0;
          r.distanceFieldType === "none" ? (At = new MeshMaterial(Texture.EMPTY), It = BLEND_MODES.NORMAL) : (At = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } }), It = BLEND_MODES.NORMAL_NPM);
          var Ot = new Mesh(Dt, At);
          Ot.blendMode = It, yt = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh: Ot,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        yt.index = 0, yt.indexCount = 0, yt.vertexCount = 0, yt.uvsCount = 0, yt.total = 0;
        var ft = this._textureCache;
        ft[pt] = ft[pt] || new Texture(xt.baseTexture), yt.mesh.texture = ft[pt], yt.mesh.tint = this._tint, Et.push(yt), mt[pt] = yt;
      }
      mt[pt].total++;
    }
    for (var nt = 0; nt < wt.length; nt++)
      Et.indexOf(wt[nt]) === -1 && this.removeChild(wt[nt].mesh);
    for (var nt = 0; nt < Et.length; nt++)
      Et[nt].mesh.parent !== this && this.addChild(Et[nt].mesh);
    this._activePagesMeshData = Et;
    for (var nt in mt) {
      var yt = mt[nt], Ft = yt.total;
      if (!(((e = yt.indices) === null || e === void 0 ? void 0 : e.length) > 6 * Ft) || yt.vertices.length < Mesh.BATCHABLE_SIZE * 2)
        yt.vertices = new Float32Array(4 * 2 * Ft), yt.uvs = new Float32Array(4 * 2 * Ft), yt.indices = new Uint16Array(6 * Ft);
      else
        for (var Mt = yt.total, zt = yt.vertices, Nt = Mt * 4 * 2; Nt < zt.length; Nt++)
          zt[Nt] = 0;
      yt.mesh.size = 6 * Ft;
    }
    for (var nt = 0; nt < gt; nt++) {
      var st = N[nt], St = st.position.x + vt[st.line] * (this._align === "justify" ? st.prevSpaces : 1);
      this._roundPixels && (St = Math.round(St));
      var Ht = St * T, Lt = st.position.y * T, xt = st.texture, Tt = mt[xt.baseTexture.uid], kt = xt.frame, Ut = xt._uvs, Ct = Tt.index++;
      Tt.indices[Ct * 6 + 0] = 0 + Ct * 4, Tt.indices[Ct * 6 + 1] = 1 + Ct * 4, Tt.indices[Ct * 6 + 2] = 2 + Ct * 4, Tt.indices[Ct * 6 + 3] = 0 + Ct * 4, Tt.indices[Ct * 6 + 4] = 2 + Ct * 4, Tt.indices[Ct * 6 + 5] = 3 + Ct * 4, Tt.vertices[Ct * 8 + 0] = Ht, Tt.vertices[Ct * 8 + 1] = Lt, Tt.vertices[Ct * 8 + 2] = Ht + kt.width * T, Tt.vertices[Ct * 8 + 3] = Lt, Tt.vertices[Ct * 8 + 4] = Ht + kt.width * T, Tt.vertices[Ct * 8 + 5] = Lt + kt.height * T, Tt.vertices[Ct * 8 + 6] = Ht, Tt.vertices[Ct * 8 + 7] = Lt + kt.height * T, Tt.uvs[Ct * 8 + 0] = Ut.x0, Tt.uvs[Ct * 8 + 1] = Ut.y0, Tt.uvs[Ct * 8 + 2] = Ut.x1, Tt.uvs[Ct * 8 + 3] = Ut.y1, Tt.uvs[Ct * 8 + 4] = Ut.x2, Tt.uvs[Ct * 8 + 5] = Ut.y2, Tt.uvs[Ct * 8 + 6] = Ut.x3, Tt.uvs[Ct * 8 + 7] = Ut.y3;
    }
    this._textWidth = q * T, this._textHeight = (D.y + r.lineHeight) * T;
    for (var nt in mt) {
      var yt = mt[nt];
      if (this.anchor.x !== 0 || this.anchor.y !== 0)
        for (var Wt = 0, Jt = this._textWidth * this.anchor.x, qt = this._textHeight * this.anchor.y, xe = 0; xe < yt.total; xe++)
          yt.vertices[Wt++] -= Jt, yt.vertices[Wt++] -= qt, yt.vertices[Wt++] -= Jt, yt.vertices[Wt++] -= qt, yt.vertices[Wt++] -= Jt, yt.vertices[Wt++] -= qt, yt.vertices[Wt++] -= Jt, yt.vertices[Wt++] -= qt;
      this._maxLineHeight = rt * T;
      var Me = yt.mesh.geometry.getBuffer("aVertexPosition"), ue = yt.mesh.geometry.getBuffer("aTextureCoord"), me = yt.mesh.geometry.getIndex();
      Me.data = yt.vertices, ue.data = yt.uvs, me.data = yt.indices, Me.update(), ue.update(), me.update();
    }
    for (var nt = 0; nt < N.length; nt++)
      charRenderDataPool.push(N[nt]);
    this._font = r, this.dirty = !1;
  }, t.prototype.updateTransform = function() {
    this.validate(), this.containerUpdateTransform();
  }, t.prototype._render = function(e) {
    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);
    var r = BitmapFont.available[this._fontName], S = r.distanceFieldRange, T = r.distanceFieldType, D = r.size;
    if (T !== "none")
      for (var N = this.worldTransform, B = N.a, $ = N.b, U = N.c, H = N.d, V = Math.sqrt(B * B + $ * $), X = Math.sqrt(U * U + H * H), W = (Math.abs(V) + Math.abs(X)) / 2, Y = this.fontSize / D, q = 0, K = this._activePagesMeshData; q < K.length; q++) {
        var Z = K[q];
        Z.mesh.shader.uniforms.uFWidth = W * S * Y * this._resolution;
      }
    o.prototype._render.call(this, e);
  }, t.prototype.getLocalBounds = function() {
    return this.validate(), o.prototype.getLocalBounds.call(this);
  }, t.prototype.validate = function() {
    var e = BitmapFont.available[this._fontName];
    if (!e)
      throw new Error('Missing BitmapFont "' + this._fontName + '"');
    this._font !== e && (this.dirty = !0), this.dirty && this.updateText();
  }, Object.defineProperty(t.prototype, "tint", {
    /**
     * The tint of the BitmapText object.
     * @default 0xffffff
     */
    get: function() {
      return this._tint;
    },
    set: function(e) {
      if (this._tint !== e) {
        this._tint = e;
        for (var r = 0; r < this._activePagesMeshData.length; r++)
          this._activePagesMeshData[r].mesh.tint = e;
      }
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "align", {
    /**
     * The alignment of the BitmapText object.
     * @member {string}
     * @default 'left'
     */
    get: function() {
      return this._align;
    },
    set: function(e) {
      this._align !== e && (this._align = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fontName", {
    /** The name of the BitmapFont. */
    get: function() {
      return this._fontName;
    },
    set: function(e) {
      if (!BitmapFont.available[e])
        throw new Error('Missing BitmapFont "' + e + '"');
      this._fontName !== e && (this._fontName = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fontSize", {
    /** The size of the font to display. */
    get: function() {
      var e;
      return (e = this._fontSize) !== null && e !== void 0 ? e : BitmapFont.available[this._fontName].size;
    },
    set: function(e) {
      this._fontSize !== e && (this._fontSize = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "anchor", {
    /**
     * The anchor sets the origin point of the text.
     *
     * The default is `(0,0)`, this means the text's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
     */
    get: function() {
      return this._anchor;
    },
    set: function(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "text", {
    /** The text of the BitmapText object. */
    get: function() {
      return this._text;
    },
    set: function(e) {
      e = String(e ?? ""), this._text !== e && (this._text = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "maxWidth", {
    /**
     * The max width of this bitmap text in pixels. If the text provided is longer than the
     * value provided, line breaks will be automatically inserted in the last whitespace.
     * Disable by setting the value to 0.
     */
    get: function() {
      return this._maxWidth;
    },
    set: function(e) {
      this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "maxLineHeight", {
    /**
     * The max line height. This is useful when trying to use the total height of the Text,
     * i.e. when trying to vertically align.
     * @readonly
     */
    get: function() {
      return this.validate(), this._maxLineHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textWidth", {
    /**
     * The width of the overall text, different from fontSize,
     * which is defined in the style object.
     * @readonly
     */
    get: function() {
      return this.validate(), this._textWidth;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "letterSpacing", {
    /** Additional space between characters. */
    get: function() {
      return this._letterSpacing;
    },
    set: function(e) {
      this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "roundPixels", {
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     * @default PIXI.settings.ROUND_PIXELS
     */
    get: function() {
      return this._roundPixels;
    },
    set: function(e) {
      e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textHeight", {
    /**
     * The height of the overall text, different from fontSize,
     * which is defined in the style object.
     * @readonly
     */
    get: function() {
      return this.validate(), this._textHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "resolution", {
    /**
     * The resolution / device pixel ratio of the canvas.
     *
     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
     * @default 1
     */
    get: function() {
      return this._resolution;
    },
    set: function(e) {
      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.destroy = function(e) {
    var r = this._textureCache, S = BitmapFont.available[this._fontName], T = S.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    T.push.apply(T, this._activePagesMeshData);
    for (var D = 0, N = this._activePagesMeshData; D < N.length; D++) {
      var B = N[D];
      this.removeChild(B.mesh);
    }
    this._activePagesMeshData = [], T.filter(function(H) {
      return r[H.mesh.texture.baseTexture.uid];
    }).forEach(function(H) {
      H.mesh.texture = Texture.EMPTY;
    });
    for (var $ in r) {
      var U = r[$];
      U.destroy(), delete r[$];
    }
    this._font = null, this._textureCache = null, o.prototype.destroy.call(this, e);
  }, t.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
  }, t;
})(Container);
var BitmapFontLoader = function() {
  function o() {
  }
  return o.add = function() {
    LoaderResource.setExtensionXhrType("fnt", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
  }, o.use = function(t, e) {
    var r = autoDetectFormat(t.data);
    if (!r) {
      e();
      return;
    }
    for (var S = o.getBaseUrl(this, t), T = r.parse(t.data), D = {}, N = function(Y) {
      D[Y.metadata.pageFile] = Y.texture, Object.keys(D).length === T.page.length && (t.bitmapFont = BitmapFont.install(T, D, !0), e());
    }, B = 0; B < T.page.length; ++B) {
      var $ = T.page[B].file, U = S + $, H = !1;
      for (var V in this.resources) {
        var X = this.resources[V];
        if (X.url === U) {
          X.metadata.pageFile = $, X.texture ? N(X) : X.onAfterMiddleware.add(N), H = !0;
          break;
        }
      }
      if (!H) {
        var W = {
          crossOrigin: t.crossOrigin,
          loadType: LoaderResource.LOAD_TYPE.IMAGE,
          metadata: Object.assign({ pageFile: $ }, t.metadata.imageMetadata),
          parentResource: t
        };
        this.add(U, W, N);
      }
    }
  }, o.getBaseUrl = function(t, e) {
    var r = e.isDataUrl ? "" : o.dirname(e.url);
    return e.isDataUrl && (r === "." && (r = ""), t.baseUrl && r && t.baseUrl.charAt(t.baseUrl.length - 1) === "/" && (r += "/")), r = r.replace(t.baseUrl, ""), r && r.charAt(r.length - 1) !== "/" && (r += "/"), r;
  }, o.dirname = function(t) {
    var e = t.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
    return e === t ? "." : e === "" ? "/" : e;
  }, o.extension = ExtensionType.Loader, o;
}();
/*!
 * @pixi/filter-alpha - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/filter-alpha is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$e = function(o, t) {
  return extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$e(o, t);
};
function __extends$e(o, t) {
  extendStatics$e(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment$4 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
(function(o) {
  __extends$e(t, o);
  function t(e) {
    e === void 0 && (e = 1);
    var r = o.call(this, defaultVertex$1, fragment$4, { uAlpha: 1 }) || this;
    return r.alpha = e, r;
  }
  return Object.defineProperty(t.prototype, "alpha", {
    /**
     * Coefficient for alpha multiplication
     * @default 1
     */
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(e) {
      this.uniforms.uAlpha = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/filter-blur - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/filter-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$d = function(o, t) {
  return extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$d(o, t);
};
function __extends$d(o, t) {
  extendStatics$d(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function generateBlurVertSource(o, t) {
  var e = Math.ceil(o / 2), r = vertTemplate, S = "", T;
  t ? T = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : T = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  for (var D = 0; D < o; D++) {
    var N = T.replace("%index%", D.toString());
    N = N.replace("%sampleIndex%", D - (e - 1) + ".0"), S += N, S += `
`;
  }
  return r = r.replace("%blur%", S), r = r.replace("%size%", o.toString()), r;
}
var GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
}, fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join(`
`);
function generateBlurFragSource(o) {
  for (var t = GAUSSIAN_VALUES[o], e = t.length, r = fragTemplate, S = "", T = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;", D, N = 0; N < o; N++) {
    var B = T.replace("%index%", N.toString());
    D = N, N >= e && (D = o - N - 1), B = B.replace("%value%", t[D].toString()), S += B, S += `
`;
  }
  return r = r.replace("%blur%", S), r = r.replace("%size%", o.toString()), r;
}
var BlurFilterPass = function(o) {
  __extends$d(t, o);
  function t(e, r, S, T, D) {
    r === void 0 && (r = 8), S === void 0 && (S = 4), T === void 0 && (T = settings.FILTER_RESOLUTION), D === void 0 && (D = 5);
    var N = this, B = generateBlurVertSource(D, e), $ = generateBlurFragSource(D);
    return N = o.call(
      this,
      // vertex shader
      B,
      // fragment shader
      $
    ) || this, N.horizontal = e, N.resolution = T, N._quality = 0, N.quality = S, N.blur = r, N;
  }
  return t.prototype.apply = function(e, r, S, T) {
    if (S ? this.horizontal ? this.uniforms.strength = 1 / S.width * (S.width / r.width) : this.uniforms.strength = 1 / S.height * (S.height / r.height) : this.horizontal ? this.uniforms.strength = 1 / e.renderer.width * (e.renderer.width / r.width) : this.uniforms.strength = 1 / e.renderer.height * (e.renderer.height / r.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)
      e.applyFilter(this, r, S, T);
    else {
      var D = e.getFilterTexture(), N = e.renderer, B = r, $ = D;
      this.state.blend = !1, e.applyFilter(this, B, $, CLEAR_MODES.CLEAR);
      for (var U = 1; U < this.passes - 1; U++) {
        e.bindAndClear(B, CLEAR_MODES.BLIT), this.uniforms.uSampler = $;
        var H = $;
        $ = B, B = H, N.shader.bind(this), N.geometry.draw(5);
      }
      this.state.blend = !0, e.applyFilter(this, $, S, T), e.returnFilterTexture(D);
    }
  }, Object.defineProperty(t.prototype, "blur", {
    /**
     * Sets the strength of both the blur.
     * @default 16
     */
    get: function() {
      return this.strength;
    },
    set: function(e) {
      this.padding = 1 + Math.abs(e) * 2, this.strength = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "quality", {
    /**
     * Sets the quality of the blur by modifying the number of passes. More passes means higher
     * quality bluring but the lower the performance.
     * @default 4
     */
    get: function() {
      return this._quality;
    },
    set: function(e) {
      this._quality = e, this.passes = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Filter);
(function(o) {
  __extends$d(t, o);
  function t(e, r, S, T) {
    e === void 0 && (e = 8), r === void 0 && (r = 4), S === void 0 && (S = settings.FILTER_RESOLUTION), T === void 0 && (T = 5);
    var D = o.call(this) || this;
    return D.blurXFilter = new BlurFilterPass(!0, e, r, S, T), D.blurYFilter = new BlurFilterPass(!1, e, r, S, T), D.resolution = S, D.quality = r, D.blur = e, D.repeatEdgePixels = !1, D;
  }
  return t.prototype.apply = function(e, r, S, T) {
    var D = Math.abs(this.blurXFilter.strength), N = Math.abs(this.blurYFilter.strength);
    if (D && N) {
      var B = e.getFilterTexture();
      this.blurXFilter.apply(e, r, B, CLEAR_MODES.CLEAR), this.blurYFilter.apply(e, B, S, T), e.returnFilterTexture(B);
    } else
      N ? this.blurYFilter.apply(e, r, S, T) : this.blurXFilter.apply(e, r, S, T);
  }, t.prototype.updatePadding = function() {
    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
  }, Object.defineProperty(t.prototype, "blur", {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     * @default 2
     */
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(e) {
      this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "quality", {
    /**
     * Sets the number of passes for blur. More passes means higher quality bluring.
     * @default 1
     */
    get: function() {
      return this.blurXFilter.quality;
    },
    set: function(e) {
      this.blurXFilter.quality = this.blurYFilter.quality = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blurX", {
    /**
     * Sets the strength of the blurX property
     * @default 2
     */
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(e) {
      this.blurXFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blurY", {
    /**
     * Sets the strength of the blurY property
     * @default 2
     */
    get: function() {
      return this.blurYFilter.blur;
    },
    set: function(e) {
      this.blurYFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blendMode", {
    /**
     * Sets the blendmode of the filter
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get: function() {
      return this.blurYFilter.blendMode;
    },
    set: function(e) {
      this.blurYFilter.blendMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "repeatEdgePixels", {
    /**
     * If set to true the edge of the target will be clamped
     * @default false
     */
    get: function() {
      return this._repeatEdgePixels;
    },
    set: function(e) {
      this._repeatEdgePixels = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/filter-color-matrix - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/filter-color-matrix is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$c = function(o, t) {
  return extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$c(o, t);
};
function __extends$c(o, t) {
  extendStatics$c(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment$3 = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`, ColorMatrixFilter = function(o) {
  __extends$c(t, o);
  function t() {
    var e = this, r = {
      m: new Float32Array([
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]),
      uAlpha: 1
    };
    return e = o.call(this, defaultFilterVertex, fragment$3, r) || this, e.alpha = 1, e;
  }
  return t.prototype._loadMatrix = function(e, r) {
    r === void 0 && (r = !1);
    var S = e;
    r && (this._multiply(S, this.uniforms.m, e), S = this._colorMatrix(S)), this.uniforms.m = S;
  }, t.prototype._multiply = function(e, r, S) {
    return e[0] = r[0] * S[0] + r[1] * S[5] + r[2] * S[10] + r[3] * S[15], e[1] = r[0] * S[1] + r[1] * S[6] + r[2] * S[11] + r[3] * S[16], e[2] = r[0] * S[2] + r[1] * S[7] + r[2] * S[12] + r[3] * S[17], e[3] = r[0] * S[3] + r[1] * S[8] + r[2] * S[13] + r[3] * S[18], e[4] = r[0] * S[4] + r[1] * S[9] + r[2] * S[14] + r[3] * S[19] + r[4], e[5] = r[5] * S[0] + r[6] * S[5] + r[7] * S[10] + r[8] * S[15], e[6] = r[5] * S[1] + r[6] * S[6] + r[7] * S[11] + r[8] * S[16], e[7] = r[5] * S[2] + r[6] * S[7] + r[7] * S[12] + r[8] * S[17], e[8] = r[5] * S[3] + r[6] * S[8] + r[7] * S[13] + r[8] * S[18], e[9] = r[5] * S[4] + r[6] * S[9] + r[7] * S[14] + r[8] * S[19] + r[9], e[10] = r[10] * S[0] + r[11] * S[5] + r[12] * S[10] + r[13] * S[15], e[11] = r[10] * S[1] + r[11] * S[6] + r[12] * S[11] + r[13] * S[16], e[12] = r[10] * S[2] + r[11] * S[7] + r[12] * S[12] + r[13] * S[17], e[13] = r[10] * S[3] + r[11] * S[8] + r[12] * S[13] + r[13] * S[18], e[14] = r[10] * S[4] + r[11] * S[9] + r[12] * S[14] + r[13] * S[19] + r[14], e[15] = r[15] * S[0] + r[16] * S[5] + r[17] * S[10] + r[18] * S[15], e[16] = r[15] * S[1] + r[16] * S[6] + r[17] * S[11] + r[18] * S[16], e[17] = r[15] * S[2] + r[16] * S[7] + r[17] * S[12] + r[18] * S[17], e[18] = r[15] * S[3] + r[16] * S[8] + r[17] * S[13] + r[18] * S[18], e[19] = r[15] * S[4] + r[16] * S[9] + r[17] * S[14] + r[18] * S[19] + r[19], e;
  }, t.prototype._colorMatrix = function(e) {
    var r = new Float32Array(e);
    return r[4] /= 255, r[9] /= 255, r[14] /= 255, r[19] /= 255, r;
  }, t.prototype.brightness = function(e, r) {
    var S = [
      e,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(S, r);
  }, t.prototype.tint = function(e, r) {
    var S = e >> 16 & 255, T = e >> 8 & 255, D = e & 255, N = [
      S / 255,
      0,
      0,
      0,
      0,
      0,
      T / 255,
      0,
      0,
      0,
      0,
      0,
      D / 255,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(N, r);
  }, t.prototype.greyscale = function(e, r) {
    var S = [
      e,
      e,
      e,
      0,
      0,
      e,
      e,
      e,
      0,
      0,
      e,
      e,
      e,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(S, r);
  }, t.prototype.blackAndWhite = function(e) {
    var r = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(r, e);
  }, t.prototype.hue = function(e, r) {
    e = (e || 0) / 180 * Math.PI;
    var S = Math.cos(e), T = Math.sin(e), D = Math.sqrt, N = 1 / 3, B = D(N), $ = S + (1 - S) * N, U = N * (1 - S) - B * T, H = N * (1 - S) + B * T, V = N * (1 - S) + B * T, X = S + N * (1 - S), W = N * (1 - S) - B * T, Y = N * (1 - S) - B * T, q = N * (1 - S) + B * T, K = S + N * (1 - S), Z = [
      $,
      U,
      H,
      0,
      0,
      V,
      X,
      W,
      0,
      0,
      Y,
      q,
      K,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(Z, r);
  }, t.prototype.contrast = function(e, r) {
    var S = (e || 0) + 1, T = -0.5 * (S - 1), D = [
      S,
      0,
      0,
      0,
      T,
      0,
      S,
      0,
      0,
      T,
      0,
      0,
      S,
      0,
      T,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(D, r);
  }, t.prototype.saturate = function(e, r) {
    e === void 0 && (e = 0);
    var S = e * 2 / 3 + 1, T = (S - 1) * -0.5, D = [
      S,
      T,
      T,
      0,
      0,
      T,
      S,
      T,
      0,
      0,
      T,
      T,
      S,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(D, r);
  }, t.prototype.desaturate = function() {
    this.saturate(-1);
  }, t.prototype.negative = function(e) {
    var r = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(r, e);
  }, t.prototype.sepia = function(e) {
    var r = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(r, e);
  }, t.prototype.technicolor = function(e) {
    var r = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(r, e);
  }, t.prototype.polaroid = function(e) {
    var r = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(r, e);
  }, t.prototype.toBGR = function(e) {
    var r = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(r, e);
  }, t.prototype.kodachrome = function(e) {
    var r = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(r, e);
  }, t.prototype.browni = function(e) {
    var r = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(r, e);
  }, t.prototype.vintage = function(e) {
    var r = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(r, e);
  }, t.prototype.colorTone = function(e, r, S, T, D) {
    e = e || 0.2, r = r || 0.15, S = S || 16770432, T = T || 3375104;
    var N = (S >> 16 & 255) / 255, B = (S >> 8 & 255) / 255, $ = (S & 255) / 255, U = (T >> 16 & 255) / 255, H = (T >> 8 & 255) / 255, V = (T & 255) / 255, X = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      N,
      B,
      $,
      e,
      0,
      U,
      H,
      V,
      r,
      0,
      N - U,
      B - H,
      $ - V,
      0,
      0
    ];
    this._loadMatrix(X, D);
  }, t.prototype.night = function(e, r) {
    e = e || 0.1;
    var S = [
      e * -2,
      -e,
      0,
      0,
      0,
      -e,
      0,
      e,
      0,
      0,
      0,
      e,
      e * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(S, r);
  }, t.prototype.predator = function(e, r) {
    var S = [
      // row 1
      11.224130630493164 * e,
      -4.794486999511719 * e,
      -2.8746118545532227 * e,
      0 * e,
      0.40342438220977783 * e,
      // row 2
      -3.6330697536468506 * e,
      9.193157196044922 * e,
      -2.951810836791992 * e,
      0 * e,
      -1.316135048866272 * e,
      // row 3
      -3.2184197902679443 * e,
      -4.2375030517578125 * e,
      7.476448059082031 * e,
      0 * e,
      0.8044459223747253 * e,
      // row 4
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(S, r);
  }, t.prototype.lsd = function(e) {
    var r = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(r, e);
  }, t.prototype.reset = function() {
    var e = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(e, !1);
  }, Object.defineProperty(t.prototype, "matrix", {
    /**
     * The matrix of the color matrix filter
     * @member {number[]}
     * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
     */
    get: function() {
      return this.uniforms.m;
    },
    set: function(e) {
      this.uniforms.m = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "alpha", {
    /**
     * The opacity value to use when mixing the original and resultant colors.
     *
     * When the value is 0, the original color is used without modification.
     * When the value is 1, the result color is used.
     * When in the range (0, 1) the color is interpolated between the original and result by this amount.
     * @default 1
     */
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(e) {
      this.uniforms.uAlpha = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Filter);
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
/*!
 * @pixi/filter-displacement - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/filter-displacement is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$b = function(o, t) {
  return extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$b(o, t);
};
function __extends$b(o, t) {
  extendStatics$b(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment$2 = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`, vertex$1 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
(function(o) {
  __extends$b(t, o);
  function t(e, r) {
    var S = this, T = new Matrix();
    return e.renderable = !1, S = o.call(this, vertex$1, fragment$2, {
      mapSampler: e._texture,
      filterMatrix: T,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    }) || this, S.maskSprite = e, S.maskMatrix = T, r == null && (r = 20), S.scale = new Point(r, r), S;
  }
  return t.prototype.apply = function(e, r, S, T) {
    this.uniforms.filterMatrix = e.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
    var D = this.maskSprite.worldTransform, N = Math.sqrt(D.a * D.a + D.b * D.b), B = Math.sqrt(D.c * D.c + D.d * D.d);
    N !== 0 && B !== 0 && (this.uniforms.rotation[0] = D.a / N, this.uniforms.rotation[1] = D.b / N, this.uniforms.rotation[2] = D.c / B, this.uniforms.rotation[3] = D.d / B), e.applyFilter(this, r, S, T);
  }, Object.defineProperty(t.prototype, "map", {
    /** The texture used for the displacement map. Must be power of 2 sized texture. */
    get: function() {
      return this.uniforms.mapSampler;
    },
    set: function(e) {
      this.uniforms.mapSampler = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/filter-fxaa - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/filter-fxaa is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$a = function(o, t) {
  return extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$a(o, t);
};
function __extends$a(o, t) {
  extendStatics$a(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var vertex = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`, fragment$1 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
(function(o) {
  __extends$a(t, o);
  function t() {
    return o.call(this, vertex, fragment$1) || this;
  }
  return t;
})(Filter);
/*!
 * @pixi/filter-noise - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/filter-noise is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$9 = function(o, t) {
  return extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$9(o, t);
};
function __extends$9(o, t) {
  extendStatics$9(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
(function(o) {
  __extends$9(t, o);
  function t(e, r) {
    e === void 0 && (e = 0.5), r === void 0 && (r = Math.random());
    var S = o.call(this, defaultFilterVertex, fragment, {
      uNoise: 0,
      uSeed: 0
    }) || this;
    return S.noise = e, S.seed = r, S;
  }
  return Object.defineProperty(t.prototype, "noise", {
    /**
     * The amount of noise to apply, this value should be in the range (0, 1].
     * @default 0.5
     */
    get: function() {
      return this.uniforms.uNoise;
    },
    set: function(e) {
      this.uniforms.uNoise = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "seed", {
    /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */
    get: function() {
      return this.uniforms.uSeed;
    },
    set: function(e) {
      this.uniforms.uSeed = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/mixin-cache-as-bitmap - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var _tempMatrix = new Matrix();
DisplayObject.prototype._cacheAsBitmap = !1;
DisplayObject.prototype._cacheData = null;
DisplayObject.prototype._cacheAsBitmapResolution = null;
DisplayObject.prototype._cacheAsBitmapMultisample = MSAA_QUALITY.NONE;
var CacheData = function() {
  function o() {
    this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;
  }
  return o;
}();
Object.defineProperties(DisplayObject.prototype, {
  /**
   * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution
   * but can be overriden for performance. Lower values will reduce memory usage at the expense
   * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.
   * @member {number} cacheAsBitmapResolution
   * @memberof PIXI.DisplayObject#
   * @default null
   */
  cacheAsBitmapResolution: {
    get: function() {
      return this._cacheAsBitmapResolution;
    },
    set: function(o) {
      o !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = o, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  /**
   * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's
   * sample count is used.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.
   * @member {number} cacheAsBitmapMultisample
   * @memberof PIXI.DisplayObject#
   * @default PIXI.MSAA_QUALITY.NONE
   */
  cacheAsBitmapMultisample: {
    get: function() {
      return this._cacheAsBitmapMultisample;
    },
    set: function(o) {
      o !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = o, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  /**
   * Set this to true if you want this display object to be cached as a bitmap.
   * This basically takes a snap shot of the display object as it is at that moment. It can
   * provide a performance benefit for complex static displayObjects.
   * To remove simply set this property to `false`
   *
   * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
   * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  cacheAsBitmap: {
    get: function() {
      return this._cacheAsBitmap;
    },
    set: function(o) {
      if (this._cacheAsBitmap !== o) {
        this._cacheAsBitmap = o;
        var t;
        o ? (this._cacheData || (this._cacheData = new CacheData()), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea);
      }
    }
  }
});
DisplayObject.prototype._renderCached = function(t) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t));
};
DisplayObject.prototype._initCachedDisplayObject = function(t) {
  var e;
  if (!(this._cacheData && this._cacheData.sprite)) {
    var r = this.alpha;
    this.alpha = 1, t.batch.flush();
    var S = this.getLocalBounds(null, !0).clone();
    if (this.filters && this.filters.length) {
      var T = this.filters[0].padding;
      S.pad(T);
    }
    S.ceil(settings.RESOLUTION);
    var D = t.renderTexture.current, N = t.renderTexture.sourceFrame.clone(), B = t.renderTexture.destinationFrame.clone(), $ = t.projection.transform, U = RenderTexture.create({
      width: S.width,
      height: S.height,
      resolution: this.cacheAsBitmapResolution || t.resolution,
      multisample: (e = this.cacheAsBitmapMultisample) !== null && e !== void 0 ? e : t.multisample
    }), H = "cacheAsBitmap_" + uid();
    this._cacheData.textureCacheId = H, BaseTexture.addToCache(U.baseTexture, H), Texture.addToCache(U, H);
    var V = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-S.x, -S.y);
    this.render = this._cacheData.originalRender, t.render(this, { renderTexture: U, clear: !0, transform: V, skipUpdateTransform: !1 }), t.framebuffer.blit(), t.projection.transform = $, t.renderTexture.bind(D, N, B), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r;
    var X = new Sprite(U);
    X.transform.worldTransform = this.transform.worldTransform, X.anchor.x = -(S.x / S.width), X.anchor.y = -(S.y / S.height), X.alpha = r, X._bounds = this._bounds, this._cacheData.sprite = X, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = X.containsPoint.bind(X);
  }
};
DisplayObject.prototype._renderCachedCanvas = function(t) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t));
};
DisplayObject.prototype._initCachedDisplayObjectCanvas = function(t) {
  if (!(this._cacheData && this._cacheData.sprite)) {
    var e = this.getLocalBounds(null, !0), r = this.alpha;
    this.alpha = 1;
    var S = t.context, T = t._projTransform;
    e.ceil(settings.RESOLUTION);
    var D = RenderTexture.create({ width: e.width, height: e.height }), N = "cacheAsBitmap_" + uid();
    this._cacheData.textureCacheId = N, BaseTexture.addToCache(D.baseTexture, N), Texture.addToCache(D, N);
    var B = _tempMatrix;
    this.transform.localTransform.copyTo(B), B.invert(), B.tx -= e.x, B.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, { renderTexture: D, clear: !0, transform: B, skipUpdateTransform: !1 }), t.context = S, t._projTransform = T, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r;
    var $ = new Sprite(D);
    $.transform.worldTransform = this.transform.worldTransform, $.anchor.x = -(e.x / e.width), $.anchor.y = -(e.y / e.height), $.alpha = r, $._bounds = this._bounds, this._cacheData.sprite = $, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = $.containsPoint.bind($);
  }
};
DisplayObject.prototype._calculateCachedBounds = function() {
  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;
};
DisplayObject.prototype._getCachedLocalBounds = function() {
  return this._cacheData.sprite.getLocalBounds(null);
};
DisplayObject.prototype._destroyCachedDisplayObject = function() {
  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, BaseTexture.removeFromCache(this._cacheData.textureCacheId), Texture.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;
};
DisplayObject.prototype._cacheAsBitmapDestroy = function(t) {
  this.cacheAsBitmap = !1, this.destroy(t);
};
/*!
 * @pixi/mixin-get-child-by-name - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.name = null;
Container.prototype.getChildByName = function(t, e) {
  for (var r = 0, S = this.children.length; r < S; r++)
    if (this.children[r].name === t)
      return this.children[r];
  if (e)
    for (var r = 0, S = this.children.length; r < S; r++) {
      var T = this.children[r];
      if (T.getChildByName) {
        var D = T.getChildByName(t, !0);
        if (D)
          return D;
      }
    }
  return null;
};
/*!
 * @pixi/mixin-get-global-position - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.getGlobalPosition = function(t, e) {
  return t === void 0 && (t = new Point()), e === void 0 && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t;
};
/*!
 * @pixi/app - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/app is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ResizePlugin = function() {
  function o() {
  }
  return o.init = function(t) {
    var e = this;
    Object.defineProperty(
      this,
      "resizeTo",
      /**
       * The HTML element or window to automatically resize the
       * renderer's view element to match width and height.
       * @member {Window|HTMLElement}
       * @name resizeTo
       * @memberof PIXI.Application#
       */
      {
        set: function(r) {
          globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = r, r && (globalThis.addEventListener("resize", this.queueResize), this.resize());
        },
        get: function() {
          return this._resizeTo;
        }
      }
    ), this.queueResize = function() {
      e._resizeTo && (e.cancelResize(), e._resizeId = requestAnimationFrame(function() {
        return e.resize();
      }));
    }, this.cancelResize = function() {
      e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null);
    }, this.resize = function() {
      if (e._resizeTo) {
        e.cancelResize();
        var r, S;
        if (e._resizeTo === globalThis.window)
          r = globalThis.innerWidth, S = globalThis.innerHeight;
        else {
          var T = e._resizeTo, D = T.clientWidth, N = T.clientHeight;
          r = D, S = N;
        }
        e.renderer.resize(r, S);
      }
    }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;
  }, o.destroy = function() {
    globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
  }, o.extension = ExtensionType.Application, o;
}(), Application = function() {
  function o(t) {
    var e = this;
    this.stage = new Container(), t = Object.assign({
      forceCanvas: !1
    }, t), this.renderer = autoDetectRenderer(t), o._plugins.forEach(function(r) {
      r.init.call(e, t);
    });
  }
  return o.registerPlugin = function(t) {
    deprecation("6.5.0", "Application.registerPlugin() is deprecated, use extensions.add()"), extensions.add({
      type: ExtensionType.Application,
      ref: t
    });
  }, o.prototype.render = function() {
    this.renderer.render(this.stage);
  }, Object.defineProperty(o.prototype, "view", {
    /**
     * Reference to the renderer's canvas element.
     * @member {HTMLCanvasElement}
     * @readonly
     */
    get: function() {
      return this.renderer.view;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "screen", {
    /**
     * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
     * @member {PIXI.Rectangle}
     * @readonly
     */
    get: function() {
      return this.renderer.screen;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.destroy = function(t, e) {
    var r = this, S = o._plugins.slice(0);
    S.reverse(), S.forEach(function(T) {
      T.destroy.call(r);
    }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;
  }, o._plugins = [], o;
}();
extensions.handleByList(ExtensionType.Application, Application._plugins);
extensions.add(ResizePlugin);
/*!
 * @pixi/mesh-extras - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/mesh-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$8 = function(o, t) {
  return extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$8(o, t);
};
function __extends$8(o, t) {
  extendStatics$8(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var PlaneGeometry = function(o) {
  __extends$8(t, o);
  function t(e, r, S, T) {
    e === void 0 && (e = 100), r === void 0 && (r = 100), S === void 0 && (S = 10), T === void 0 && (T = 10);
    var D = o.call(this) || this;
    return D.segWidth = S, D.segHeight = T, D.width = e, D.height = r, D.build(), D;
  }
  return t.prototype.build = function() {
    for (var e = this.segWidth * this.segHeight, r = [], S = [], T = [], D = this.segWidth - 1, N = this.segHeight - 1, B = this.width / D, $ = this.height / N, U = 0; U < e; U++) {
      var H = U % this.segWidth, V = U / this.segWidth | 0;
      r.push(H * B, V * $), S.push(H / D, V / N);
    }
    for (var X = D * N, U = 0; U < X; U++) {
      var W = U % D, Y = U / D | 0, q = Y * this.segWidth + W, K = Y * this.segWidth + W + 1, Z = (Y + 1) * this.segWidth + W, J = (Y + 1) * this.segWidth + W + 1;
      T.push(q, K, Z, K, J, Z);
    }
    this.buffers[0].data = new Float32Array(r), this.buffers[1].data = new Float32Array(S), this.indexBuffer.data = new Uint16Array(T), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
  }, t;
}(MeshGeometry), RopeGeometry = function(o) {
  __extends$8(t, o);
  function t(e, r, S) {
    e === void 0 && (e = 200), S === void 0 && (S = 0);
    var T = o.call(this, new Float32Array(r.length * 4), new Float32Array(r.length * 4), new Uint16Array((r.length - 1) * 6)) || this;
    return T.points = r, T._width = e, T.textureScale = S, T.build(), T;
  }
  return Object.defineProperty(t.prototype, "width", {
    /**
     * The width (i.e., thickness) of the rope.
     * @readonly
     */
    get: function() {
      return this._width;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.build = function() {
    var e = this.points;
    if (e) {
      var r = this.getBuffer("aVertexPosition"), S = this.getBuffer("aTextureCoord"), T = this.getIndex();
      if (!(e.length < 1)) {
        r.data.length / 4 !== e.length && (r.data = new Float32Array(e.length * 4), S.data = new Float32Array(e.length * 4), T.data = new Uint16Array((e.length - 1) * 6));
        var D = S.data, N = T.data;
        D[0] = 0, D[1] = 0, D[2] = 0, D[3] = 1;
        for (var B = 0, $ = e[0], U = this._width * this.textureScale, H = e.length, V = 0; V < H; V++) {
          var X = V * 4;
          if (this.textureScale > 0) {
            var W = $.x - e[V].x, Y = $.y - e[V].y, q = Math.sqrt(W * W + Y * Y);
            $ = e[V], B += q / U;
          } else
            B = V / (H - 1);
          D[X] = B, D[X + 1] = 0, D[X + 2] = B, D[X + 3] = 1;
        }
        for (var K = 0, V = 0; V < H - 1; V++) {
          var X = V * 2;
          N[K++] = X, N[K++] = X + 1, N[K++] = X + 2, N[K++] = X + 2, N[K++] = X + 1, N[K++] = X + 3;
        }
        S.update(), T.update(), this.updateVertices();
      }
    }
  }, t.prototype.updateVertices = function() {
    var e = this.points;
    if (!(e.length < 1)) {
      for (var r = e[0], S, T = 0, D = 0, N = this.buffers[0].data, B = e.length, $ = 0; $ < B; $++) {
        var U = e[$], H = $ * 4;
        $ < e.length - 1 ? S = e[$ + 1] : S = U, D = -(S.x - r.x), T = S.y - r.y;
        var V = Math.sqrt(T * T + D * D), X = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
        T /= V, D /= V, T *= X, D *= X, N[H] = U.x + T, N[H + 1] = U.y + D, N[H + 2] = U.x - T, N[H + 3] = U.y - D, r = U;
      }
      this.buffers[0].update();
    }
  }, t.prototype.update = function() {
    this.textureScale > 0 ? this.build() : this.updateVertices();
  }, t;
}(MeshGeometry);
(function(o) {
  __extends$8(t, o);
  function t(e, r, S) {
    S === void 0 && (S = 0);
    var T = this, D = new RopeGeometry(e.height, r, S), N = new MeshMaterial(e);
    return S > 0 && (e.baseTexture.wrapMode = WRAP_MODES.REPEAT), T = o.call(this, D, N) || this, T.autoUpdate = !0, T;
  }
  return t.prototype._render = function(e) {
    var r = this.geometry;
    (this.autoUpdate || r._width !== this.shader.texture.height) && (r._width = this.shader.texture.height, r.update()), o.prototype._render.call(this, e);
  }, t;
})(Mesh);
var SimplePlane = function(o) {
  __extends$8(t, o);
  function t(e, r, S) {
    var T = this, D = new PlaneGeometry(e.width, e.height, r, S), N = new MeshMaterial(Texture.WHITE);
    return T = o.call(this, D, N) || this, T.texture = e, T.autoResize = !0, T;
  }
  return t.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID;
    var e = this.geometry, r = this.shader.texture, S = r.width, T = r.height;
    this.autoResize && (e.width !== S || e.height !== T) && (e.width = this.shader.texture.width, e.height = this.shader.texture.height, e.build());
  }, Object.defineProperty(t.prototype, "texture", {
    get: function() {
      return this.shader.texture;
    },
    set: function(e) {
      this.shader.texture !== e && (this.shader.texture = e, this._textureID = -1, e.baseTexture.valid ? this.textureUpdated() : e.once("update", this.textureUpdated, this));
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._render = function(e) {
    this._textureID !== this.shader.texture._updateID && this.textureUpdated(), o.prototype._render.call(this, e);
  }, t.prototype.destroy = function(e) {
    this.shader.texture.off("update", this.textureUpdated, this), o.prototype.destroy.call(this, e);
  }, t;
}(Mesh);
(function(o) {
  __extends$8(t, o);
  function t(e, r, S, T, D) {
    e === void 0 && (e = Texture.EMPTY);
    var N = this, B = new MeshGeometry(r, S, T);
    B.getBuffer("aVertexPosition").static = !1;
    var $ = new MeshMaterial(e);
    return N = o.call(this, B, $, null, D) || this, N.autoUpdate = !0, N;
  }
  return Object.defineProperty(t.prototype, "vertices", {
    /**
     * Collection of vertices data.
     * @type {Float32Array}
     */
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(e) {
      this.geometry.getBuffer("aVertexPosition").data = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._render = function(e) {
    this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), o.prototype._render.call(this, e);
  }, t;
})(Mesh);
var DEFAULT_BORDER_SIZE = 10;
(function(o) {
  __extends$8(t, o);
  function t(e, r, S, T, D) {
    r === void 0 && (r = DEFAULT_BORDER_SIZE), S === void 0 && (S = DEFAULT_BORDER_SIZE), T === void 0 && (T = DEFAULT_BORDER_SIZE), D === void 0 && (D = DEFAULT_BORDER_SIZE);
    var N = o.call(this, Texture.WHITE, 4, 4) || this;
    return N._origWidth = e.orig.width, N._origHeight = e.orig.height, N._width = N._origWidth, N._height = N._origHeight, N._leftWidth = r, N._rightWidth = T, N._topHeight = S, N._bottomHeight = D, N.texture = e, N;
  }
  return t.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID, this._refresh();
  }, Object.defineProperty(t.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(e) {
      this.geometry.getBuffer("aVertexPosition").data = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.updateHorizontalVertices = function() {
    var e = this.vertices, r = this._getMinScale();
    e[9] = e[11] = e[13] = e[15] = this._topHeight * r, e[17] = e[19] = e[21] = e[23] = this._height - this._bottomHeight * r, e[25] = e[27] = e[29] = e[31] = this._height;
  }, t.prototype.updateVerticalVertices = function() {
    var e = this.vertices, r = this._getMinScale();
    e[2] = e[10] = e[18] = e[26] = this._leftWidth * r, e[4] = e[12] = e[20] = e[28] = this._width - this._rightWidth * r, e[6] = e[14] = e[22] = e[30] = this._width;
  }, t.prototype._getMinScale = function() {
    var e = this._leftWidth + this._rightWidth, r = this._width > e ? 1 : this._width / e, S = this._topHeight + this._bottomHeight, T = this._height > S ? 1 : this._height / S, D = Math.min(r, T);
    return D;
  }, Object.defineProperty(t.prototype, "width", {
    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    get: function() {
      return this._width;
    },
    set: function(e) {
      this._width = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    get: function() {
      return this._height;
    },
    set: function(e) {
      this._height = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "leftWidth", {
    /** The width of the left column. */
    get: function() {
      return this._leftWidth;
    },
    set: function(e) {
      this._leftWidth = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "rightWidth", {
    /** The width of the right column. */
    get: function() {
      return this._rightWidth;
    },
    set: function(e) {
      this._rightWidth = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "topHeight", {
    /** The height of the top row. */
    get: function() {
      return this._topHeight;
    },
    set: function(e) {
      this._topHeight = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "bottomHeight", {
    /** The height of the bottom row. */
    get: function() {
      return this._bottomHeight;
    },
    set: function(e) {
      this._bottomHeight = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._refresh = function() {
    var e = this.texture, r = this.geometry.buffers[1].data;
    this._origWidth = e.orig.width, this._origHeight = e.orig.height;
    var S = 1 / this._origWidth, T = 1 / this._origHeight;
    r[0] = r[8] = r[16] = r[24] = 0, r[1] = r[3] = r[5] = r[7] = 0, r[6] = r[14] = r[22] = r[30] = 1, r[25] = r[27] = r[29] = r[31] = 1, r[2] = r[10] = r[18] = r[26] = S * this._leftWidth, r[4] = r[12] = r[20] = r[28] = 1 - S * this._rightWidth, r[9] = r[11] = r[13] = r[15] = T * this._topHeight, r[17] = r[19] = r[21] = r[23] = 1 - T * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();
  }, t;
})(SimplePlane);
/*!
 * @pixi/sprite-animated - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * @pixi/sprite-animated is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$7 = function(o, t) {
  return extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$7(o, t);
};
function __extends$7(o, t) {
  extendStatics$7(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var AnimatedSprite = function(o) {
  __extends$7(t, o);
  function t(e, r) {
    r === void 0 && (r = !0);
    var S = o.call(this, e[0] instanceof Texture ? e[0] : e[0].texture) || this;
    return S._textures = null, S._durations = null, S._autoUpdate = r, S._isConnectedToTicker = !1, S.animationSpeed = 1, S.loop = !0, S.updateAnchor = !1, S.onComplete = null, S.onFrameChange = null, S.onLoop = null, S._currentTime = 0, S._playing = !1, S._previousFrame = null, S.textures = e, S;
  }
  return t.prototype.stop = function() {
    this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1));
  }, t.prototype.play = function() {
    this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH), this._isConnectedToTicker = !0));
  }, t.prototype.gotoAndStop = function(e) {
    this.stop();
    var r = this.currentFrame;
    this._currentTime = e, r !== this.currentFrame && this.updateTexture();
  }, t.prototype.gotoAndPlay = function(e) {
    var r = this.currentFrame;
    this._currentTime = e, r !== this.currentFrame && this.updateTexture(), this.play();
  }, t.prototype.update = function(e) {
    if (this._playing) {
      var r = this.animationSpeed * e, S = this.currentFrame;
      if (this._durations !== null) {
        var T = this._currentTime % 1 * this._durations[this.currentFrame];
        for (T += r / 60 * 1e3; T < 0; )
          this._currentTime--, T += this._durations[this.currentFrame];
        var D = Math.sign(this.animationSpeed * e);
        for (this._currentTime = Math.floor(this._currentTime); T >= this._durations[this.currentFrame]; )
          T -= this._durations[this.currentFrame] * D, this._currentTime += D;
        this._currentTime += T / this._durations[this.currentFrame];
      } else
        this._currentTime += r;
      this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : S !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < S ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > S && this.onLoop()), this.updateTexture());
    }
  }, t.prototype.updateTexture = function() {
    var e = this.currentFrame;
    this._previousFrame !== e && (this._previousFrame = e, this._texture = this._textures[e], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));
  }, t.prototype.destroy = function(e) {
    this.stop(), o.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;
  }, t.fromFrames = function(e) {
    for (var r = [], S = 0; S < e.length; ++S)
      r.push(Texture.from(e[S]));
    return new t(r);
  }, t.fromImages = function(e) {
    for (var r = [], S = 0; S < e.length; ++S)
      r.push(Texture.from(e[S]));
    return new t(r);
  }, Object.defineProperty(t.prototype, "totalFrames", {
    /**
     * The total number of frames in the AnimatedSprite. This is the same as number of textures
     * assigned to the AnimatedSprite.
     * @readonly
     * @default 0
     */
    get: function() {
      return this._textures.length;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textures", {
    /** The array of textures used for this AnimatedSprite. */
    get: function() {
      return this._textures;
    },
    set: function(e) {
      if (e[0] instanceof Texture)
        this._textures = e, this._durations = null;
      else {
        this._textures = [], this._durations = [];
        for (var r = 0; r < e.length; r++)
          this._textures.push(e[r].texture), this._durations.push(e[r].time);
      }
      this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "currentFrame", {
    /**
     * The AnimatedSprites current frame index.
     * @readonly
     */
    get: function() {
      var e = Math.floor(this._currentTime) % this._textures.length;
      return e < 0 && (e += this._textures.length), e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "playing", {
    /**
     * Indicates if the AnimatedSprite is currently playing.
     * @readonly
     */
    get: function() {
      return this._playing;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "autoUpdate", {
    /** Whether to use PIXI.Ticker.shared to auto update animation time. */
    get: function() {
      return this._autoUpdate;
    },
    set: function(e) {
      e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Sprite);
/*!
 * pixi.js - v6.5.8
 * Compiled Sun, 23 Oct 2022 23:01:45 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
extensions.add(
  // Install renderer plugins
  AccessibilityManager,
  Extract,
  InteractionManager,
  ParticleRenderer,
  Prepare,
  BatchRenderer,
  TilingSpriteRenderer,
  // Install loader plugins
  BitmapFontLoader,
  CompressedTextureLoader,
  DDSLoader,
  KTXLoader,
  SpritesheetLoader,
  // Install application plugins
  TickerPlugin,
  AppLoaderPlugin
);
var Ai;
class EventListenerCtn {
  constructor() {
    // リソースリーク対策
    tt(this, Ai, []);
  }
  add(t, e, r, S = {}) {
    if (t instanceof BaseTexture) {
      switch (e) {
        case "loaded":
        case "update":
        case "error":
        case "dispose":
          t.on(e, r, S), z(this, Ai).push(() => t.off(e, r, S));
          break;
      }
      return;
    }
    if (t instanceof eventemitter3Exports) {
      t.on(e, r, S), z(this, Ai).push(() => t.off(e, r, S));
      return;
    }
    t.addEventListener(e, r, S), z(this, Ai).push(() => t.removeEventListener(e, r, { capture: S.capture ?? !1 }));
  }
  clear() {
    for (const t of z(this, Ai))
      t();
    at(this, Ai, []);
  }
}
Ai = new WeakMap();
var SEARCH_PATH_ARG_EXT = /* @__PURE__ */ ((o) => (o.DEFAULT = "", o.SP_GSM = "png|jpg|jpeg|json|svg|webp|mp4|webm", o.SCRIPT = "sn|ssn", o.FONT = "woff2|woff|otf|ttf", o.SOUND = "mp3|m4a|ogg|aac|flac|wav", o.HTML = "htm|html", o.CSS = "css", o.SN = "sn", o.PSD = "psd", o.TST_PNGPNG_ = "png|png_", o.TST_HH = "hh", o.TST_EEE = "eee", o.TST_GGG = "ggg", o.TST_PNGXML = "png|xml", o))(SEARCH_PATH_ARG_EXT || {}), Qa, to, bu;
class ConfigBase {
  constructor(t) {
    Pt(this, "oCfg", {
      save_ns: "",
      // 扱うセーブデータを一意に識別するキーワード文字列
      window: {
        // アプリケーションウインドウサイズ
        width: 300,
        height: 300
      },
      book: {
        // プロジェクトの詳細情報です
        title: "",
        //作品タイトル
        creator: "",
        //著作者。同人ならペンネーム
        cre_url: "",
        //著作者URL。ツイッターやメール、サイトなど
        publisher: "",
        //出版社。同人ならサークル名
        pub_url: "",
        //出版社URL。無ければ省略します
        detail: "",
        // 内容紹介。端的に記入
        version: "1.0"
      },
      log: { max_len: 1024 },
      // プレイヤーが読んだ文章を読み返せる履歴の長さ
      init: {
        bg_color: "#000000",
        // 背景色
        tagch_msecwait: 10,
        // 通常文字表示待ち時間（未読／既読）
        auto_msecpagewait: 3500,
        // 自動文字表示、行クリック待ち時間（未読／既読）
        escape: ""
        // エスケープ文字
      },
      debug: {
        devtool: !1,
        token: !1,
        tag: !1,
        putCh: !1,
        debugLog: !1,
        baseTx: !1,
        masume: !1,
        // テキストレイヤ：ガイドマス目を表示するか
        variable: !1
      },
      code: {},
      // 暗号化しないフォルダ
      debuger_token: ""
      // デバッガとの接続トークン
    });
    Pt(this, "userFnTail", "");
    // 4tst public
    Pt(this, "hPathFn2Exts", {});
    tt(this, Qa, !1);
    tt(this, to, !1);
    tt(this, bu, /([^\/\s]+)\.([^\d]\w+)/);
    this.sys = t;
  }
  async load(t) {
    var e, r, S, T;
    if (this.oCfg.save_ns = (t == null ? void 0 : t.save_ns) ?? this.oCfg.save_ns, this.oCfg.window.width = Number(((e = t == null ? void 0 : t.window) == null ? void 0 : e.width) ?? this.oCfg.window.width), this.oCfg.window.height = Number(((r = t == null ? void 0 : t.window) == null ? void 0 : r.height) ?? this.oCfg.window.height), this.oCfg.book = { ...this.oCfg.book, ...t.book }, this.oCfg.log.max_len = ((T = (S = t.log) == null ? void 0 : S.max_len) == null ? void 0 : T.max_len) ?? this.oCfg.log.max_len, this.oCfg.init = { ...this.oCfg.init, ...t.init }, this.oCfg.debug = { ...this.oCfg.debug, ...t.debug }, this.oCfg.debuger_token = t.debuger_token, await this.sys.loadPath(this.hPathFn2Exts, this), at(this, Qa, this.matchPath(
      "^breakline$",
      "png|jpg|jpeg|json|svg|webp|mp4|webm"
      /* SP_GSM */
    ).length > 0), at(this, to, this.matchPath(
      "^breakpage$",
      "png|jpg|jpeg|json|svg|webp|mp4|webm"
      /* SP_GSM */
    ).length > 0), !!this.sys.crypto)
      for (const D of Object.values(this.hPathFn2Exts))
        for (const [N, B] of Object.entries(D)) {
          if (N.slice(-10) !== ":RIPEMD160")
            continue;
          const $ = B.slice(B.lastIndexOf("/") + 1), U = D[N.slice(0, -10)], V = await (await this.sys.fetch(U)).text(), X = this.sys.hash(V);
          if ($ !== X)
            throw `ファイル改竄エラーです fn:${U}`;
        }
  }
  get existsBreakline() {
    return z(this, Qa);
  }
  get existsBreakpage() {
    return z(this, to);
  }
  getNs() {
    return `skynovel.${this.oCfg.save_ns} - `;
  }
  // 4 match 498 step(~1ms)  https://regex101.com/r/tpVgmI/1
  searchPath(t, e = "") {
    if (!t)
      throw "[searchPath] fnが空です";
    if (t.slice(0, 7) === "http://")
      return t;
    const r = t.match(z(this, bu));
    let S = r ? r[1] : t;
    const T = r ? r[2] : "";
    if (this.userFnTail) {
      const B = S + "@@" + this.userFnTail;
      if (B in this.hPathFn2Exts) {
        if (e === "")
          S = B;
        else
          for (const $ of Object.keys(this.hPathFn2Exts[B]))
            if (`|${e}|`.indexOf(`|${$}|`) !== -1) {
              S = B;
              break;
            }
      }
    }
    const D = this.hPathFn2Exts[S];
    if (!D)
      throw `サーチパスに存在しないファイル【${t}】です`;
    let N = "";
    if (!T) {
      const B = int(D[":cnt"]);
      if (e === "") {
        if (B > 1)
          throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;
        return t;
      }
      const $ = `|${e}|`;
      if (B > 1) {
        let U = 0;
        for (const H of Object.keys(D))
          if ($.indexOf(`|${H}|`) !== -1 && ++U > 1)
            throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;
      }
      for (let U of Object.keys(D))
        if ($.indexOf(`|${U}|`) > -1)
          return D[U];
      throw `サーチ対象拡張子群【${e}】にマッチするファイルがサーチパスに存在しません。探索ファイル名=【${t}】`;
    }
    if (e !== "" && `|${e}|`.indexOf(`|${T}|`) === -1)
      throw `指定ファイルの拡張子【${T}】は、サーチ対象拡張子群【${e}】にマッチしません。探索ファイル名=【${t}】`;
    if (N = D[T], !N)
      throw `サーチパスに存在しない拡張子【${T}】です。探索ファイル名=【${t}】、サーチ対象拡張子群【${e}】`;
    return N;
  }
  matchPath(t, e = "") {
    const r = [], S = new RegExp(t), T = new RegExp(e);
    for (const [D, N] of Object.entries(this.hPathFn2Exts)) {
      if (D.search(S) === -1)
        continue;
      if (e === "") {
        r.push(N);
        continue;
      }
      const B = {};
      let $ = !1;
      for (const U of Object.keys(N))
        U.search(T) !== -1 && (B[U] = D, $ = !0);
      $ && r.push(B);
    }
    return r;
  }
  addPath(t, e) {
    const r = {};
    for (const [S, T] of Object.entries(e))
      r[S] = (S.at(0) === ":" ? "" : this.sys.cur) + T;
    this.hPathFn2Exts[t] = r;
  }
}
Qa = new WeakMap(), to = new WeakMap(), bu = new WeakMap();
class Config extends ConfigBase {
  constructor(t) {
    super(t), this.sys = t;
  }
  static async generate(t) {
    const e = new Config(t), r = t.cur + "prj.json", S = await (await t.fetch(r)).text(), T = JSON.parse(t.decStr(r, S));
    return await e.load(T), e;
  }
  async load(t) {
    await super.load(t), CmnLib.stageW = this.oCfg.window.width, CmnLib.stageH = this.oCfg.window.height, CmnLib.debugLog = this.oCfg.debug.debugLog;
  }
  searchPath(t, e = SEARCH_PATH_ARG_EXT.DEFAULT) {
    return t.slice(0, 11) === "downloads:/" ? this.sys.path_downloads + t.slice(11) : t.slice(0, 10) === "userdata:/" ? this.sys.path_userdata + "storage/" + t.slice(10) : super.searchPath(t, e);
  }
}
const REG_TAG = /(?<name>[^\s;\]]+)/;
function tagToken2Name_Args(o) {
  const t = REG_TAG.exec(o.slice(1, -1)), e = t == null ? void 0 : t.groups;
  if (!e)
    throw `タグ記述【${o}】異常です(タグ解析)`;
  const r = e.name;
  return [r, o.slice(1 + r.length, -1)];
}
function tagToken2Name(o) {
  const t = REG_TAG.exec(o.slice(1)), e = t == null ? void 0 : t.groups;
  if (!e)
    throw `タグ記述【${o}】異常です(タグ解析)`;
  return e.name;
}
function splitAmpersand(o) {
  const t = o.replaceAll("==", "＝").replaceAll("!=", "≠").split("="), e = t.length;
  if (e < 2 || e > 3)
    throw "「&計算」書式では「=」指定が一つか二つ必要です";
  if (t[1].at(0) === "&")
    throw "「&計算」書式では「&」指定が不要です";
  return {
    name: t[0].replaceAll("＝", "==").replaceAll("≠", "!="),
    text: t[1].replaceAll("＝", "==").replaceAll("≠", "!="),
    cast: e === 3 ? t[2].trim() : void 0
  };
}
var ln, un, eo, ro, io, Ve, no, Cs, eu;
class Grammar {
  constructor() {
    tt(this, Cs);
    tt(this, ln, void 0);
    tt(this, un, void 0);
    tt(this, eo, new RegExp(""));
    tt(this, ro, "");
    tt(this, io, "");
    tt(this, Ve, void 0);
    tt(this, no, void 0);
    this.setEscape("");
  }
  setEscape(t) {
    if (z(this, Ve) && t in z(this, Ve))
      throw "[エスケープ文字] char【" + t + "】が登録済みの括弧マクロまたは一文字マクロです";
    at(this, ln, new RegExp(
      (t ? `\\${t}\\S|` : "") + // エスケープシーケンス
      `\\n+|\\t+|\\[let_ml\\s+[^\\]]+\\].+?(?=\\[endlet_ml[\\]\\s])|\\[(?:(?=([^"'#;\\]]+))\\1|(["'#]).*?\\2|;[^\\n]*)*?]|;[^\\n]*|&[^&\\n]+&|&&?[^&;\\n\\t]+|^\\*[^\\s\\[&;\\\\]+|[^\\n\\t\\[;${t ? `\\${t}` : ""}]+`,
      // 本文
      "gs"
    )), at(this, un, new RegExp(`[\\w\\s;[\\]*=&｜《》${t ? `\\${t}` : ""}]`)), at(this, no, new RegExp(`[\\n\\t;\\[*&${t ? `\\${t}` : ""}]`));
  }
  // 括弧マクロの定義
  bracket2macro(t, e, r, S) {
    const { name: T, text: D } = t;
    if (!T)
      throw "[bracket2macro] nameは必須です";
    if (!D)
      throw "[bracket2macro] textは必須です";
    const N = D.at(0);
    if (!N)
      throw "[bracket2macro] textは必須です";
    if (D.length !== 2)
      throw "[bracket2macro] textは括弧の前後を示す二文字を指定してください";
    if (!(T in e))
      throw `[bracket2macro] 未定義のタグ又はマクロ[${T}]です`;
    z(this, Ve) ?? at(this, Ve, {});
    const B = D.charAt(1);
    if (N in z(this, Ve))
      throw "[bracket2macro] text【" + N + "】が登録済みの括弧マクロまたは一文字マクロです";
    if (B in z(this, Ve))
      throw "[bracket2macro] text【" + B + "】が登録済みの括弧マクロまたは一文字マクロです";
    if (z(this, un).test(N))
      throw "[bracket2macro] text【" + N + "】は括弧マクロに使用できない文字です";
    if (z(this, un).test(B))
      throw "[bracket2macro] text【" + B + "】は括弧マクロに使用できない文字です";
    z(this, Ve)[B] = "0", z(this, Ve)[N] = `[${T} text=`, this.addC2M(`\\${N}[^\\${B}]*\\${B}`, `\\${N}\\${B}`), lt(this, Cs, eu).call(this, r, S);
  }
  // 一文字マクロの定義
  char2macro(t, e, r, S) {
    const { char: T, name: D } = t;
    if (!T)
      throw "[char2macro] charは必須です";
    if (z(this, Ve) ?? at(this, Ve, {}), T in z(this, Ve))
      throw "[char2macro] char【" + T + "】が登録済みの括弧マクロまたは一文字マクロです";
    if (z(this, un).test(T))
      throw "[char2macro] char【" + T + "】は一文字マクロに使用できない文字です";
    if (!D)
      throw "[char2macro] nameは必須です";
    if (!(D in e))
      throw `[char2macro] 未定義のタグ又はマクロ[${D}]です`;
    z(this, Ve)[T] = `[${D}]`, this.addC2M(`\\${T}`, `\\${T}`), lt(this, Cs, eu).call(this, r, S);
  }
  addC2M(t, e) {
    at(this, ro, z(this, ro) + `${t}|`), at(this, io, z(this, io) + `${e}`), at(this, eo, new RegExp(
      `(${z(this, ro)}[^${z(this, io)}]+)`,
      "g"
    ));
  }
  resolveScript(t) {
    var S;
    const e = ((S = t.replaceAll(/(\r\n|\r)/g, `
`).match(z(this, ln))) == null ? void 0 : S.flatMap((T) => {
      if (!this.testTagLetml(T))
        return T;
      const D = /^([^\]]+?])(.*)$/s.exec(T);
      if (!D)
        return T;
      const [, N, B] = D;
      return [N, B];
    })) ?? [], r = { aToken: e, len: e.length, aLNum: [] };
    return lt(this, Cs, eu).call(this, r), r;
  }
  testTagLetml(t) {
    return /^\[let_ml\s/.test(t);
  }
  testTagEndLetml(t) {
    return /^\[endlet_ml\s*]/.test(t);
  }
  analyzToken(t) {
    return z(this, ln).lastIndex = 0, z(this, ln).exec(t);
  }
  testNoTxt(t) {
    return z(this, no).test(t);
  }
  //4tst
}
ln = new WeakMap(), un = new WeakMap(), eo = new WeakMap(), ro = new WeakMap(), io = new WeakMap(), Ve = new WeakMap(), no = new WeakMap(), Cs = new WeakSet(), eu = function(t, e = 0) {
  if (z(this, Ve)) {
    for (let r = t.len - 1; r >= e; --r) {
      const S = t.aToken[r];
      if (this.testNoTxt(S.at(0) ?? `
`))
        continue;
      const T = t.aLNum[r], D = S.match(z(this, eo));
      if (!D)
        continue;
      let N = 1;
      for (let B = D.length - 1; B >= 0; --B) {
        let $ = D[B];
        const U = z(this, Ve)[$.at(0) ?? " "];
        U && ($ = U + (U.slice(-1) === "]" ? "" : `'${$.slice(1, -1)}']`)), t.aToken.splice(r, N, $), t.aLNum.splice(r, N, T), N = 0;
      }
    }
    t.len = t.aToken.length;
  }
};
var so, Ps, ru, hn, Rs;
class AnalyzeTagArg {
  constructor() {
    tt(this, Ps);
    // 87 match 2725 step(0.5ms) PCRE2 https://regex101.com/r/aeN57J/1
    /*
    ;[^\n]*
    |	(?<key>[^\s="'#|;]+)
    	(?: \s | ;[^\n]*\n)*
    	=
    	(?: \s | ;[^\n]*\n)*
    	(?:	(?<val> [^\s"'#|;]+)
    	|	(["'#]) (?<val2>.*?) \3 )
    	(?: \|
    		(?: (?<def> [^\s"'#;]+)
    	|	(["'#]) (?<def2>.*?) \6 ) )?
    |	(?<literal>[^\s;]+)
    	*/
    tt(this, so, /;[^\n]*|(?<key>[^\s="'#|;]+)(?:\s|;[^\n]*\n)*=(?:\s|;[^\n]*\n)*(?:(?<val>[^\s"'#|;]+)|(["'#])(?<val2>.*?)\3)(?:\|(?:(?<def>[^\s"'#;]+)|(["'#])(?<def2>.*?)\6))?|(?<literal>[^\s;]+)/g);
    tt(this, hn, {});
    tt(this, Rs, !1);
  }
  // 【属性 = 値 | 省略値】の分析
  parse(t) {
    at(this, hn, {}), at(this, Rs, !1);
    for (const { groups: e } of t.matchAll(z(this, so))) {
      const { key: r, val: S, val2: T, def: D, def2: N, literal: B } = e;
      r ? z(this, hn)[r] = {
        val: S ?? T,
        def: D ?? N
      } : B && (B === "*" ? at(this, Rs, !0) : z(this, hn)[B] = { val: "1" });
    }
  }
  // 属性と値の位置をまとめて返す
  parseinDetail(t, e, r, S) {
    const T = {}, D = t.slice(1 + e, -1);
    for (const { groups: N, index: B, 0: $ } of D.matchAll(z(this, so))) {
      if (B === void 0)
        continue;
      const { key: U, val: H, val2: V, literal: X } = N;
      if (X) {
        if (X.slice(-1) === "=") {
          const Z = X.length - 1, { ch: J } = lt(this, Ps, ru).call(this, e, r, S, D, B + Z);
          T[X.slice(0, -1)] = {
            k_ln: r,
            k_ch: J - Z,
            v_ln: r,
            v_ch: J + 1,
            //	v_ch: ch +1+lenNm +literal.length +1,
            v_len: 0
          };
        }
        continue;
      }
      if (!U)
        continue;
      const { ln: W, ch: Y } = lt(this, Ps, ru).call(this, e, r, S, D, B), { ln: q, ch: K } = lt(this, Ps, ru).call(this, e, r, S, D, B + $.lastIndexOf(H ?? V) - (H ? 0 : 1));
      T[U] = { k_ln: W, k_ch: Y, v_ln: q, v_ch: K, v_len: H ? H.length : V.length + 2 };
    }
    return T;
  }
  get hPrm() {
    return z(this, hn);
  }
  get isKomeParam() {
    return z(this, Rs);
  }
}
so = new WeakMap(), Ps = new WeakSet(), ru = function(t, e, r, S, T) {
  const N = S.slice(0, T).split(`
`), B = N.length;
  return {
    ln: e + B - 1,
    ch: B < 2 ? r + 1 + t + T : N.at(-1).length
  };
}, hn = new WeakMap(), Rs = new WeakMap();
var parsimmon_umd_minExports = {}, parsimmon_umd_min = {
  get exports() {
    return parsimmon_umd_minExports;
  },
  set exports(o) {
    parsimmon_umd_minExports = o;
  }
};
(function(o, t) {
  (function(e, r) {
    o.exports = r();
  })(typeof self < "u" ? self : commonjsGlobal, function() {
    return function(e) {
      var r = {};
      function S(T) {
        if (r[T])
          return r[T].exports;
        var D = r[T] = { i: T, l: !1, exports: {} };
        return e[T].call(D.exports, D, D.exports, S), D.l = !0, D.exports;
      }
      return S.m = e, S.c = r, S.d = function(T, D, N) {
        S.o(T, D) || Object.defineProperty(T, D, { configurable: !1, enumerable: !0, get: N });
      }, S.r = function(T) {
        Object.defineProperty(T, "__esModule", { value: !0 });
      }, S.n = function(T) {
        var D = T && T.__esModule ? function() {
          return T.default;
        } : function() {
          return T;
        };
        return S.d(D, "a", D), D;
      }, S.o = function(T, D) {
        return Object.prototype.hasOwnProperty.call(T, D);
      }, S.p = "", S(S.s = 0);
    }([function(e, r, S) {
      function T(ut) {
        if (!(this instanceof T))
          return new T(ut);
        this._ = ut;
      }
      var D = T.prototype;
      function N(ut, dt) {
        for (var bt = 0; bt < ut; bt++)
          dt(bt);
      }
      function B(ut, dt, bt) {
        return function(Rt, Bt) {
          N(Bt.length, function($t) {
            Rt(Bt[$t], $t, Bt);
          });
        }(function(Rt, Bt, $t) {
          dt = ut(dt, Rt, Bt, $t);
        }, bt), dt;
      }
      function $(ut, dt) {
        return B(function(bt, Rt, Bt, $t) {
          return bt.concat([ut(Rt, Bt, $t)]);
        }, [], dt);
      }
      function U(ut, dt) {
        var bt = { v: 0, buf: dt };
        return N(ut, function() {
          var Rt;
          bt = { v: bt.v << 1 | (Rt = bt.buf, Rt[0] >> 7), buf: function(Bt) {
            var $t = B(function(Gt, te, Se, He) {
              return Gt.concat(Se === He.length - 1 ? Buffer.from([te, 0]).readUInt16BE(0) : He.readUInt16BE(Se));
            }, [], Bt);
            return Buffer.from($(function(Gt) {
              return (Gt << 1 & 65535) >> 8;
            }, $t));
          }(bt.buf) };
        }), bt;
      }
      function H() {
        return typeof Buffer < "u";
      }
      function V() {
        if (!H())
          throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
      }
      function X(ut) {
        V();
        var dt = B(function($t, Gt) {
          return $t + Gt;
        }, 0, ut);
        if (dt % 8 != 0)
          throw new Error("The bits [" + ut.join(", ") + "] add up to " + dt + " which is not an even number of bytes; the total should be divisible by 8");
        var bt, Rt = dt / 8, Bt = (bt = function($t) {
          return $t > 48;
        }, B(function($t, Gt) {
          return $t || (bt(Gt) ? Gt : $t);
        }, null, ut));
        if (Bt)
          throw new Error(Bt + " bit range requested exceeds 48 bit (6 byte) Number max.");
        return new T(function($t, Gt) {
          var te = Rt + Gt;
          return te > $t.length ? st(Gt, Rt.toString() + " bytes") : nt(te, B(function(Se, He) {
            var Be = U(He, Se.buf);
            return { coll: Se.coll.concat(Be.v), buf: Be.buf };
          }, { coll: [], buf: $t.slice(Gt, te) }, ut).coll);
        });
      }
      function W(ut, dt) {
        return new T(function(bt, Rt) {
          return V(), Rt + dt > bt.length ? st(Rt, dt + " bytes for " + ut) : nt(Rt + dt, bt.slice(Rt, Rt + dt));
        });
      }
      function Y(ut, dt) {
        if (typeof (bt = dt) != "number" || Math.floor(bt) !== bt || dt < 0 || dt > 6)
          throw new Error(ut + " requires integer length in range [0, 6].");
        var bt;
      }
      function q(ut) {
        return Y("uintBE", ut), W("uintBE(" + ut + ")", ut).map(function(dt) {
          return dt.readUIntBE(0, ut);
        });
      }
      function K(ut) {
        return Y("uintLE", ut), W("uintLE(" + ut + ")", ut).map(function(dt) {
          return dt.readUIntLE(0, ut);
        });
      }
      function Z(ut) {
        return Y("intBE", ut), W("intBE(" + ut + ")", ut).map(function(dt) {
          return dt.readIntBE(0, ut);
        });
      }
      function J(ut) {
        return Y("intLE", ut), W("intLE(" + ut + ")", ut).map(function(dt) {
          return dt.readIntLE(0, ut);
        });
      }
      function Q(ut) {
        return ut instanceof T;
      }
      function rt(ut) {
        return {}.toString.call(ut) === "[object Array]";
      }
      function et(ut) {
        return H() && Buffer.isBuffer(ut);
      }
      function nt(ut, dt) {
        return { status: !0, index: ut, value: dt, furthest: -1, expected: [] };
      }
      function st(ut, dt) {
        return rt(dt) || (dt = [dt]), { status: !1, index: -1, value: null, furthest: ut, expected: dt };
      }
      function it(ut, dt) {
        if (!dt || ut.furthest > dt.furthest)
          return ut;
        var bt = ut.furthest === dt.furthest ? function(Rt, Bt) {
          if (function() {
            if (T._supportsSet !== void 0)
              return T._supportsSet;
            var ei = typeof Set < "u";
            return T._supportsSet = ei, ei;
          }() && Array.from) {
            for (var $t = new Set(Rt), Gt = 0; Gt < Bt.length; Gt++)
              $t.add(Bt[Gt]);
            var te = Array.from($t);
            return te.sort(), te;
          }
          for (var Se = {}, He = 0; He < Rt.length; He++)
            Se[Rt[He]] = !0;
          for (var Be = 0; Be < Bt.length; Be++)
            Se[Bt[Be]] = !0;
          var ti = [];
          for (var er in Se)
            ({}).hasOwnProperty.call(Se, er) && ti.push(er);
          return ti.sort(), ti;
        }(ut.expected, dt.expected) : dt.expected;
        return { status: ut.status, index: ut.index, value: ut.value, furthest: dt.furthest, expected: bt };
      }
      var ot = {};
      function ht(ut, dt) {
        if (et(ut))
          return { offset: dt, line: -1, column: -1 };
        ut in ot || (ot[ut] = {});
        for (var bt = ot[ut], Rt = 0, Bt = 0, $t = 0, Gt = dt; Gt >= 0; ) {
          if (Gt in bt) {
            Rt = bt[Gt].line, $t === 0 && ($t = bt[Gt].lineStart);
            break;
          }
          (ut.charAt(Gt) === `
` || ut.charAt(Gt) === "\r" && ut.charAt(Gt + 1) !== `
`) && (Bt++, $t === 0 && ($t = Gt + 1)), Gt--;
        }
        var te = Rt + Bt, Se = dt - $t;
        return bt[dt] = { line: te, lineStart: $t }, { offset: dt, line: te + 1, column: Se + 1 };
      }
      function ct(ut) {
        if (!Q(ut))
          throw new Error("not a parser: " + ut);
      }
      function vt(ut, dt) {
        return typeof ut == "string" ? ut.charAt(dt) : ut[dt];
      }
      function _t(ut) {
        if (typeof ut != "number")
          throw new Error("not a number: " + ut);
      }
      function gt(ut) {
        if (typeof ut != "function")
          throw new Error("not a function: " + ut);
      }
      function mt(ut) {
        if (typeof ut != "string")
          throw new Error("not a string: " + ut);
      }
      var Et = 2, wt = 3, xt = 8, pt = 5 * xt, yt = 4 * xt, Dt = "  ";
      function At(ut, dt) {
        return new Array(dt + 1).join(ut);
      }
      function It(ut, dt, bt) {
        var Rt = dt - ut.length;
        return Rt <= 0 ? ut : At(bt, Rt) + ut;
      }
      function Ot(ut, dt, bt, Rt) {
        return { from: ut - dt > 0 ? ut - dt : 0, to: ut + bt > Rt ? Rt : ut + bt };
      }
      function ft(ut, dt) {
        var bt, Rt, Bt, $t, Gt, te = dt.index, Se = te.offset, He = 1;
        if (Se === ut.length)
          return "Got the end of the input";
        if (et(ut)) {
          var Be = Se - Se % xt, ti = Se - Be, er = Ot(Be, pt, yt + xt, ut.length), ei = $(function(Ne) {
            return $(function(gs) {
              return It(gs.toString(16), 2, "0");
            }, Ne);
          }, function(Ne, gs) {
            var ms = Ne.length, en = [], _s = 0;
            if (ms <= gs)
              return [Ne.slice()];
            for (var ys = 0; ys < ms; ys++)
              en[_s] || en.push([]), en[_s].push(Ne[ys]), (ys + 1) % gs == 0 && _s++;
            return en;
          }(ut.slice(er.from, er.to).toJSON().data, xt));
          $t = function(Ne) {
            return Ne.from === 0 && Ne.to === 1 ? { from: Ne.from, to: Ne.to } : { from: Ne.from / xt, to: Math.floor(Ne.to / xt) };
          }(er), Rt = Be / xt, bt = 3 * ti, ti >= 4 && (bt += 1), He = 2, Bt = $(function(Ne) {
            return Ne.length <= 4 ? Ne.join(" ") : Ne.slice(0, 4).join(" ") + "  " + Ne.slice(4).join(" ");
          }, ei), (Gt = (8 * ($t.to > 0 ? $t.to - 1 : $t.to)).toString(16).length) < 2 && (Gt = 2);
        } else {
          var vs = ut.split(/\r\n|[\n\r\u2028\u2029]/);
          bt = te.column - 1, Rt = te.line - 1, $t = Ot(Rt, Et, wt, vs.length), Bt = vs.slice($t.from, $t.to), Gt = $t.to.toString().length;
        }
        var Op = Rt - $t.from;
        return et(ut) && (Gt = (8 * ($t.to > 0 ? $t.to - 1 : $t.to)).toString(16).length) < 2 && (Gt = 2), B(function(Ne, gs, ms) {
          var en, _s = ms === Op, ys = _s ? "> " : Dt;
          return en = et(ut) ? It((8 * ($t.from + ms)).toString(16), Gt, "0") : It(($t.from + ms + 1).toString(), Gt, " "), [].concat(Ne, [ys + en + " | " + gs], _s ? [Dt + At(" ", Gt) + " | " + It("", bt, " ") + At("^", He)] : []);
        }, [], Bt).join(`
`);
      }
      function Ft(ut, dt) {
        return [`
`, "-- PARSING FAILED " + At("-", 50), `

`, ft(ut, dt), `

`, (bt = dt.expected, bt.length === 1 ? `Expected:

` + bt[0] : `Expected one of the following: 

` + bt.join(", ")), `
`].join("");
        var bt;
      }
      function Mt(ut) {
        return ut.flags !== void 0 ? ut.flags : [ut.global ? "g" : "", ut.ignoreCase ? "i" : "", ut.multiline ? "m" : "", ut.unicode ? "u" : "", ut.sticky ? "y" : ""].join("");
      }
      function zt() {
        for (var ut = [].slice.call(arguments), dt = ut.length, bt = 0; bt < dt; bt += 1)
          ct(ut[bt]);
        return T(function(Rt, Bt) {
          for (var $t, Gt = new Array(dt), te = 0; te < dt; te += 1) {
            if (!($t = it(ut[te]._(Rt, Bt), $t)).status)
              return $t;
            Gt[te] = $t.value, Bt = $t.index;
          }
          return it(nt(Bt, Gt), $t);
        });
      }
      function Nt() {
        var ut = [].slice.call(arguments);
        if (ut.length === 0)
          throw new Error("seqMap needs at least one argument");
        var dt = ut.pop();
        return gt(dt), zt.apply(null, ut).map(function(bt) {
          return dt.apply(null, bt);
        });
      }
      function St() {
        var ut = [].slice.call(arguments), dt = ut.length;
        if (dt === 0)
          return Ct("zero alternates");
        for (var bt = 0; bt < dt; bt += 1)
          ct(ut[bt]);
        return T(function(Rt, Bt) {
          for (var $t, Gt = 0; Gt < ut.length; Gt += 1)
            if (($t = it(ut[Gt]._(Rt, Bt), $t)).status)
              return $t;
          return $t;
        });
      }
      function Ht(ut, dt) {
        return Lt(ut, dt).or(Ut([]));
      }
      function Lt(ut, dt) {
        return ct(ut), ct(dt), Nt(ut, dt.then(ut).many(), function(bt, Rt) {
          return [bt].concat(Rt);
        });
      }
      function Tt(ut) {
        mt(ut);
        var dt = "'" + ut + "'";
        return T(function(bt, Rt) {
          var Bt = Rt + ut.length, $t = bt.slice(Rt, Bt);
          return $t === ut ? nt(Bt, $t) : st(Rt, dt);
        });
      }
      function kt(ut, dt) {
        (function(Bt) {
          if (!(Bt instanceof RegExp))
            throw new Error("not a regexp: " + Bt);
          for (var $t = Mt(Bt), Gt = 0; Gt < $t.length; Gt++) {
            var te = $t.charAt(Gt);
            if (te !== "i" && te !== "m" && te !== "u" && te !== "s")
              throw new Error('unsupported regexp flag "' + te + '": ' + Bt);
          }
        })(ut), arguments.length >= 2 ? _t(dt) : dt = 0;
        var bt = function(Bt) {
          return RegExp("^(?:" + Bt.source + ")", Mt(Bt));
        }(ut), Rt = "" + ut;
        return T(function(Bt, $t) {
          var Gt = bt.exec(Bt.slice($t));
          if (Gt) {
            if (0 <= dt && dt <= Gt.length) {
              var te = Gt[0], Se = Gt[dt];
              return nt($t + te.length, Se);
            }
            return st($t, "valid match group (0 to " + Gt.length + ") in " + Rt);
          }
          return st($t, Rt);
        });
      }
      function Ut(ut) {
        return T(function(dt, bt) {
          return nt(bt, ut);
        });
      }
      function Ct(ut) {
        return T(function(dt, bt) {
          return st(bt, ut);
        });
      }
      function Wt(ut) {
        if (Q(ut))
          return T(function(dt, bt) {
            var Rt = ut._(dt, bt);
            return Rt.index = bt, Rt.value = "", Rt;
          });
        if (typeof ut == "string")
          return Wt(Tt(ut));
        if (ut instanceof RegExp)
          return Wt(kt(ut));
        throw new Error("not a string, regexp, or parser: " + ut);
      }
      function Jt(ut) {
        return ct(ut), T(function(dt, bt) {
          var Rt = ut._(dt, bt), Bt = dt.slice(bt, Rt.index);
          return Rt.status ? st(bt, 'not "' + Bt + '"') : nt(bt, null);
        });
      }
      function qt(ut) {
        return gt(ut), T(function(dt, bt) {
          var Rt = vt(dt, bt);
          return bt < dt.length && ut(Rt) ? nt(bt + 1, Rt) : st(bt, "a character/byte matching " + ut);
        });
      }
      function xe(ut, dt) {
        arguments.length < 2 && (dt = ut, ut = void 0);
        var bt = T(function(Rt, Bt) {
          return bt._ = dt()._, bt._(Rt, Bt);
        });
        return ut ? bt.desc(ut) : bt;
      }
      function Me() {
        return Ct("fantasy-land/empty");
      }
      D.parse = function(ut) {
        if (typeof ut != "string" && !et(ut))
          throw new Error(".parse must be called with a string or Buffer as its argument");
        var dt, bt = this.skip(fe)._(ut, 0);
        return dt = bt.status ? { status: !0, value: bt.value } : { status: !1, index: ht(ut, bt.furthest), expected: bt.expected }, delete ot[ut], dt;
      }, D.tryParse = function(ut) {
        var dt = this.parse(ut);
        if (dt.status)
          return dt.value;
        var bt = Ft(ut, dt), Rt = new Error(bt);
        throw Rt.type = "ParsimmonError", Rt.result = dt, Rt;
      }, D.assert = function(ut, dt) {
        return this.chain(function(bt) {
          return ut(bt) ? Ut(bt) : Ct(dt);
        });
      }, D.or = function(ut) {
        return St(this, ut);
      }, D.trim = function(ut) {
        return this.wrap(ut, ut);
      }, D.wrap = function(ut, dt) {
        return Nt(ut, this, dt, function(bt, Rt) {
          return Rt;
        });
      }, D.thru = function(ut) {
        return ut(this);
      }, D.then = function(ut) {
        return ct(ut), zt(this, ut).map(function(dt) {
          return dt[1];
        });
      }, D.many = function() {
        var ut = this;
        return T(function(dt, bt) {
          for (var Rt = [], Bt = void 0; ; ) {
            if (!(Bt = it(ut._(dt, bt), Bt)).status)
              return it(nt(bt, Rt), Bt);
            if (bt === Bt.index)
              throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
            bt = Bt.index, Rt.push(Bt.value);
          }
        });
      }, D.tieWith = function(ut) {
        return mt(ut), this.map(function(dt) {
          if (function(Bt) {
            if (!rt(Bt))
              throw new Error("not an array: " + Bt);
          }(dt), dt.length) {
            mt(dt[0]);
            for (var bt = dt[0], Rt = 1; Rt < dt.length; Rt++)
              mt(dt[Rt]), bt += ut + dt[Rt];
            return bt;
          }
          return "";
        });
      }, D.tie = function() {
        return this.tieWith("");
      }, D.times = function(ut, dt) {
        var bt = this;
        return arguments.length < 2 && (dt = ut), _t(ut), _t(dt), T(function(Rt, Bt) {
          for (var $t = [], Gt = void 0, te = void 0, Se = 0; Se < ut; Se += 1) {
            if (te = it(Gt = bt._(Rt, Bt), te), !Gt.status)
              return te;
            Bt = Gt.index, $t.push(Gt.value);
          }
          for (; Se < dt && (te = it(Gt = bt._(Rt, Bt), te), Gt.status); Se += 1)
            Bt = Gt.index, $t.push(Gt.value);
          return it(nt(Bt, $t), te);
        });
      }, D.result = function(ut) {
        return this.map(function() {
          return ut;
        });
      }, D.atMost = function(ut) {
        return this.times(0, ut);
      }, D.atLeast = function(ut) {
        return Nt(this.times(ut), this.many(), function(dt, bt) {
          return dt.concat(bt);
        });
      }, D.map = function(ut) {
        gt(ut);
        var dt = this;
        return T(function(bt, Rt) {
          var Bt = dt._(bt, Rt);
          return Bt.status ? it(nt(Bt.index, ut(Bt.value)), Bt) : Bt;
        });
      }, D.contramap = function(ut) {
        gt(ut);
        var dt = this;
        return T(function(bt, Rt) {
          var Bt = dt.parse(ut(bt.slice(Rt)));
          return Bt.status ? nt(Rt + bt.length, Bt.value) : Bt;
        });
      }, D.promap = function(ut, dt) {
        return gt(ut), gt(dt), this.contramap(ut).map(dt);
      }, D.skip = function(ut) {
        return zt(this, ut).map(function(dt) {
          return dt[0];
        });
      }, D.mark = function() {
        return Nt(ue, this, ue, function(ut, dt, bt) {
          return { start: ut, value: dt, end: bt };
        });
      }, D.node = function(ut) {
        return Nt(ue, this, ue, function(dt, bt, Rt) {
          return { name: ut, value: bt, start: dt, end: Rt };
        });
      }, D.sepBy = function(ut) {
        return Ht(this, ut);
      }, D.sepBy1 = function(ut) {
        return Lt(this, ut);
      }, D.lookahead = function(ut) {
        return this.skip(Wt(ut));
      }, D.notFollowedBy = function(ut) {
        return this.skip(Jt(ut));
      }, D.desc = function(ut) {
        rt(ut) || (ut = [ut]);
        var dt = this;
        return T(function(bt, Rt) {
          var Bt = dt._(bt, Rt);
          return Bt.status || (Bt.expected = ut), Bt;
        });
      }, D.fallback = function(ut) {
        return this.or(Ut(ut));
      }, D.ap = function(ut) {
        return Nt(ut, this, function(dt, bt) {
          return dt(bt);
        });
      }, D.chain = function(ut) {
        var dt = this;
        return T(function(bt, Rt) {
          var Bt = dt._(bt, Rt);
          return Bt.status ? it(ut(Bt.value)._(bt, Bt.index), Bt) : Bt;
        });
      }, D.concat = D.or, D.empty = Me, D.of = Ut, D["fantasy-land/ap"] = D.ap, D["fantasy-land/chain"] = D.chain, D["fantasy-land/concat"] = D.concat, D["fantasy-land/empty"] = D.empty, D["fantasy-land/of"] = D.of, D["fantasy-land/map"] = D.map;
      var ue = T(function(ut, dt) {
        return nt(dt, ht(ut, dt));
      }), me = T(function(ut, dt) {
        return dt >= ut.length ? st(dt, "any character/byte") : nt(dt + 1, vt(ut, dt));
      }), pe = T(function(ut, dt) {
        return nt(ut.length, ut.slice(dt));
      }), fe = T(function(ut, dt) {
        return dt < ut.length ? st(dt, "EOF") : nt(dt, null);
      }), ce = kt(/[0-9]/).desc("a digit"), ie = kt(/[0-9]*/).desc("optional digits"), ze = kt(/[a-z]/i).desc("a letter"), ds = kt(/[a-z]*/i).desc("optional letters"), $a = kt(/\s*/).desc("optional whitespace"), Gc = kt(/\s+/).desc("whitespace"), Ga = Tt("\r"), ps = Tt(`
`), Ql = Tt(`\r
`), tu = St(Ql, ps, Ga).desc("newline"), Uc = St(tu, fe);
      T.all = pe, T.alt = St, T.any = me, T.cr = Ga, T.createLanguage = function(ut) {
        var dt = {};
        for (var bt in ut)
          ({}).hasOwnProperty.call(ut, bt) && function(Rt) {
            dt[Rt] = xe(function() {
              return ut[Rt](dt);
            });
          }(bt);
        return dt;
      }, T.crlf = Ql, T.custom = function(ut) {
        return T(ut(nt, st));
      }, T.digit = ce, T.digits = ie, T.empty = Me, T.end = Uc, T.eof = fe, T.fail = Ct, T.formatError = Ft, T.index = ue, T.isParser = Q, T.lazy = xe, T.letter = ze, T.letters = ds, T.lf = ps, T.lookahead = Wt, T.makeFailure = st, T.makeSuccess = nt, T.newline = tu, T.noneOf = function(ut) {
        return qt(function(dt) {
          return ut.indexOf(dt) < 0;
        }).desc("none of '" + ut + "'");
      }, T.notFollowedBy = Jt, T.of = Ut, T.oneOf = function(ut) {
        for (var dt = ut.split(""), bt = 0; bt < dt.length; bt++)
          dt[bt] = "'" + dt[bt] + "'";
        return qt(function(Rt) {
          return ut.indexOf(Rt) >= 0;
        }).desc(dt);
      }, T.optWhitespace = $a, T.Parser = T, T.range = function(ut, dt) {
        return qt(function(bt) {
          return ut <= bt && bt <= dt;
        }).desc(ut + "-" + dt);
      }, T.regex = kt, T.regexp = kt, T.sepBy = Ht, T.sepBy1 = Lt, T.seq = zt, T.seqMap = Nt, T.seqObj = function() {
        for (var ut, dt = {}, bt = 0, Rt = (ut = arguments, Array.prototype.slice.call(ut)), Bt = Rt.length, $t = 0; $t < Bt; $t += 1) {
          var Gt = Rt[$t];
          if (!Q(Gt)) {
            if (rt(Gt) && Gt.length === 2 && typeof Gt[0] == "string" && Q(Gt[1])) {
              var te = Gt[0];
              if (Object.prototype.hasOwnProperty.call(dt, te))
                throw new Error("seqObj: duplicate key " + te);
              dt[te] = !0, bt++;
              continue;
            }
            throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
          }
        }
        if (bt === 0)
          throw new Error("seqObj expects at least one named parser, found zero");
        return T(function(Se, He) {
          for (var Be, ti = {}, er = 0; er < Bt; er += 1) {
            var ei, vs;
            if (rt(Rt[er]) ? (ei = Rt[er][0], vs = Rt[er][1]) : (ei = null, vs = Rt[er]), !(Be = it(vs._(Se, He), Be)).status)
              return Be;
            ei && (ti[ei] = Be.value), He = Be.index;
          }
          return it(nt(He, ti), Be);
        });
      }, T.string = Tt, T.succeed = Ut, T.takeWhile = function(ut) {
        return gt(ut), T(function(dt, bt) {
          for (var Rt = bt; Rt < dt.length && ut(vt(dt, Rt)); )
            Rt++;
          return nt(Rt, dt.slice(bt, Rt));
        });
      }, T.test = qt, T.whitespace = Gc, T["fantasy-land/empty"] = Me, T["fantasy-land/of"] = Ut, T.Binary = { bitSeq: X, bitSeqObj: function(ut) {
        V();
        var dt = {}, bt = 0, Rt = $(function($t) {
          if (rt($t)) {
            var Gt = $t;
            if (Gt.length !== 2)
              throw new Error("[" + Gt.join(", ") + "] should be length 2, got length " + Gt.length);
            if (mt(Gt[0]), _t(Gt[1]), Object.prototype.hasOwnProperty.call(dt, Gt[0]))
              throw new Error("duplicate key in bitSeqObj: " + Gt[0]);
            return dt[Gt[0]] = !0, bt++, Gt;
          }
          return _t($t), [null, $t];
        }, ut);
        if (bt < 1)
          throw new Error("bitSeqObj expects at least one named pair, got [" + ut.join(", ") + "]");
        var Bt = $(function($t) {
          return $t[0];
        }, Rt);
        return X($(function($t) {
          return $t[1];
        }, Rt)).map(function($t) {
          return B(function(Gt, te) {
            return te[0] !== null && (Gt[te[0]] = te[1]), Gt;
          }, {}, $(function(Gt, te) {
            return [Gt, $t[te]];
          }, Bt));
        });
      }, byte: function(ut) {
        if (V(), _t(ut), ut > 255)
          throw new Error("Value specified to byte constructor (" + ut + "=0x" + ut.toString(16) + ") is larger in value than a single byte.");
        var dt = (ut > 15 ? "0x" : "0x0") + ut.toString(16);
        return T(function(bt, Rt) {
          var Bt = vt(bt, Rt);
          return Bt === ut ? nt(Rt + 1, Bt) : st(Rt, dt);
        });
      }, buffer: function(ut) {
        return W("buffer", ut).map(function(dt) {
          return Buffer.from(dt);
        });
      }, encodedString: function(ut, dt) {
        return W("string", dt).map(function(bt) {
          return bt.toString(ut);
        });
      }, uintBE: q, uint8BE: q(1), uint16BE: q(2), uint32BE: q(4), uintLE: K, uint8LE: K(1), uint16LE: K(2), uint32LE: K(4), intBE: Z, int8BE: Z(1), int16BE: Z(2), int32BE: Z(4), intLE: J, int8LE: J(1), int16LE: J(2), int32LE: J(4), floatBE: W("floatBE", 4).map(function(ut) {
        return ut.readFloatBE(0);
      }), floatLE: W("floatLE", 4).map(function(ut) {
        return ut.readFloatLE(0);
      }), doubleBE: W("doubleBE", 8).map(function(ut) {
        return ut.readDoubleBE(0);
      }), doubleLE: W("doubleLE", 8).map(function(ut) {
        return ut.readDoubleLE(0);
      }) }, e.exports = T;
    }]);
  });
})(parsimmon_umd_min);
var cn, Kt, Zt, Ni, Li, bs, xu, ao, zc, Su, Eu, kf;
const Df = class {
  constructor(t, e = "\\") {
    tt(this, Kt);
    tt(this, Li);
    tt(this, ao);
    tt(this, cn, null);
    tt(this, Ni, {
      "!num!": (t) => t.shift(),
      "!str!": (t) => lt(this, ao, zc).call(this, t.shift()),
      "!bool!": (t) => t.shift(),
      // 論理 NOT
      "!": (t) => {
        const e = t.shift();
        return e[0] === "!bool!" ? !Boolean(e[1]) : String(lt(this, Kt, Zt).call(this, e)) !== "true";
      },
      // チルダ演算子（ビット反転）
      "~": (t) => ~Number(lt(this, Kt, Zt).call(this, t.shift())),
      // 乗算、除算、剰余
      "**": (t) => Number(lt(this, Kt, Zt).call(this, t.shift())) ** Number(lt(this, Kt, Zt).call(this, t.shift())),
      "*": (t) => Number(lt(this, Kt, Zt).call(this, t.shift())) * Number(lt(this, Kt, Zt).call(this, t.shift())),
      "/": (t) => Number(lt(this, Kt, Zt).call(this, t.shift())) / Number(lt(this, Kt, Zt).call(this, t.shift())),
      "¥": (t) => Math.floor(z(this, Ni)["/"](t)),
      "%": (t) => Number(lt(this, Kt, Zt).call(this, t.shift())) % Number(lt(this, Kt, Zt).call(this, t.shift())),
      // 加算、減算、文字列の連結
      "+": (t) => {
        const e = lt(this, Kt, Zt).call(this, t.shift()), r = lt(this, Kt, Zt).call(this, t.shift());
        return Object.prototype.toString.call(e) === "[object String]" || Object.prototype.toString.call(r) === "[object String]" ? String(e) + String(r) : Number(e) + Number(r);
      },
      "-": (t) => Number(lt(this, Kt, Zt).call(this, t.shift())) - Number(lt(this, Kt, Zt).call(this, t.shift())),
      // 関数
      int: (t) => int(lt(this, Li, bs).call(this, t.shift())),
      parseInt: (t) => int(z(this, Ni).Number(t)),
      Number: (t) => {
        const e = lt(this, Kt, Zt).call(this, t.shift());
        return Object.prototype.toString.call(e) !== "[object String]" ? Number(e) : lt(this, Li, bs).call(this, z(this, cn).parse(String(e)).value);
      },
      ceil: (t) => Math.ceil(lt(this, Li, bs).call(this, t.shift())),
      floor: (t) => Math.floor(lt(this, Li, bs).call(this, t.shift())),
      round: (t) => Math.round(lt(this, Li, bs).call(this, t.shift())),
      isNaN: (t) => isNaN(Number(lt(this, Kt, Zt).call(this, t.shift()))),
      // ビットシフト
      "<<": (t) => Number(lt(this, Kt, Zt).call(this, t.shift())) << Number(lt(this, Kt, Zt).call(this, t.shift())),
      ">>": (t) => Number(lt(this, Kt, Zt).call(this, t.shift())) >> Number(lt(this, Kt, Zt).call(this, t.shift())),
      ">>>": (t) => Number(lt(this, Kt, Zt).call(this, t.shift())) >>> Number(lt(this, Kt, Zt).call(this, t.shift())),
      // 等値、非等値、厳密等価、厳密非等価
      "<": (t) => Number(lt(this, Kt, Zt).call(this, t.shift())) < Number(lt(this, Kt, Zt).call(this, t.shift())),
      "<=": (t) => Number(lt(this, Kt, Zt).call(this, t.shift())) <= Number(lt(this, Kt, Zt).call(this, t.shift())),
      ">": (t) => Number(lt(this, Kt, Zt).call(this, t.shift())) > Number(lt(this, Kt, Zt).call(this, t.shift())),
      ">=": (t) => Number(lt(this, Kt, Zt).call(this, t.shift())) >= Number(lt(this, Kt, Zt).call(this, t.shift())),
      // 小なり、以下、大なり、以上
      "==": (t) => {
        const e = lt(this, Kt, Zt).call(this, t.shift()), r = lt(this, Kt, Zt).call(this, t.shift());
        return e == null && r == null && (!e || !r) ? e == r : String(e) === String(r);
      },
      "!=": (t) => !z(this, Ni)["=="](t),
      "===": (t) => {
        const e = lt(this, Kt, Zt).call(this, t.shift()), r = lt(this, Kt, Zt).call(this, t.shift());
        return Object.prototype.toString.call(e) != Object.prototype.toString.call(r) ? !1 : String(e) === String(r);
      },
      "!==": (t) => !z(this, Ni)["==="](t),
      // ビット演算子
      "&": (t) => Number(lt(this, Kt, Zt).call(this, t.shift())) & Number(lt(this, Kt, Zt).call(this, t.shift())),
      "^": (t) => Number(lt(this, Kt, Zt).call(this, t.shift())) ^ Number(lt(this, Kt, Zt).call(this, t.shift())),
      "|": (t) => Number(lt(this, Kt, Zt).call(this, t.shift())) | Number(lt(this, Kt, Zt).call(this, t.shift())),
      // 論理 AND,OR
      "&&": (t) => String(lt(this, Kt, Zt).call(this, t.shift())) === "true" && String(lt(this, Kt, Zt).call(this, t.shift())) === "true",
      "||": (t) => String(lt(this, Kt, Zt).call(this, t.shift())) === "true" || String(lt(this, Kt, Zt).call(this, t.shift())) === "true",
      // 条件
      "?": (t) => {
        const e = t.shift();
        let r = !1;
        if (e[0] === "!bool!")
          r = Boolean(e[1]);
        else {
          const T = String(lt(this, Kt, Zt).call(this, e));
          r = T !== "true" && T !== "false" ? int(T) !== 0 : T === "true";
        }
        const S = t.shift();
        if (S[0] !== ":")
          throw Error("(PropParser)三項演算子の文法エラーです。: が見つかりません");
        return lt(this, Kt, Zt).call(this, S[r ? 1 : 2]);
      },
      ":": () => {
        throw Error("(PropParser)三項演算子の文法エラーです。? が見つかりません");
      }
    });
    tt(this, xu, /(\$((tmp|sys|save|mp):)?[^\s!--\/:-@[-^`{-~]+|\#\{[^\}]+})/g);
    Pt(this, "getValAmpersand", (t) => t.at(0) === "&" ? String(this.parse(t.slice(1))) : t);
    this.val = t;
    function r(q) {
      const K = [];
      for (const Z of q)
        K.push(
          (Z instanceof RegExp ? parsimmon_umd_minExports.regex(Z) : parsimmon_umd_minExports.string(Z)).trim(parsimmon_umd_minExports.optWhitespace)
        );
      return parsimmon_umd_minExports.alt.apply(null, K);
    }
    function S(q, K) {
      const Z = parsimmon_umd_minExports.lazy(() => parsimmon_umd_minExports.seq(q, Z).or(K));
      return Z;
    }
    function T(q, K) {
      let Z = parsimmon_umd_minExports.lazy(
        () => K.chain(
          (J) => parsimmon_umd_minExports.seq(
            q,
            parsimmon_umd_minExports.of(J),
            Z
          ).or(parsimmon_umd_minExports.of(J))
        )
      );
      return Z;
    }
    function D(q, K) {
      return parsimmon_umd_minExports.seqMap(
        K,
        parsimmon_umd_minExports.seq(q, K).many(),
        (Z, J) => J.reduce((Q, rt) => [rt[0], Q, rt[1]], Z)
      );
    }
    const N = parsimmon_umd_minExports.alt(
      parsimmon_umd_minExports.alt(
        parsimmon_umd_minExports.regex(/-?(0|[1-9][0-9]*)\.[0-9]+/),
        parsimmon_umd_minExports.regex(/0x[0-9a-fA-F]+/)
      ).map(Number),
      parsimmon_umd_minExports.alt(
        parsimmon_umd_minExports.regex(/-?(0|[1-9][0-9]*)/)
      ).map((q) => int(q))
    ).map((q) => ["!num!", q]).desc("number"), B = parsimmon_umd_minExports.string("null").map(() => ["!str!", null]), $ = parsimmon_umd_minExports.regex(/(true|false)/).map((q) => ["!bool!", q === "true"]).desc("boolean"), U = parsimmon_umd_minExports.regex(new RegExp(`(?:"(?:\\${e}["'#\\n]|[^"])*"|'(?:\\${e}["'#\\n]|[^'])*'|\\#(?:\\${e}["'#\\n]|[^#])*\\#)`)).map((q) => ["!str!", q.slice(1, -1).replaceAll(e, "")]).desc("string"), H = /\[[^\]]+\]/g, V = parsimmon_umd_minExports.regex(/-?(?:(?:tmp|sys|save|mp):)?[^\s!-\/:-@[-^`{-~]+(?:\.[^\s!-\/:-@[-^`{-~]+|\[[^\]]+\])*(?:@str)?/).map((q) => {
      const K = String(q).replaceAll(
        H,
        (J) => "." + this.parse(J.slice(1, -1))
      );
      if (K.at(0) === "-") {
        const J = this.val.getVal(K.slice(1));
        if (J == null || String(J) === "null")
          throw Error("(PropParser)数値以外に-符号がついています");
        return ["!num!", -Number(J)];
      }
      const Z = this.val.getVal(K);
      return Z == null ? ["!str!", Z] : typeof Z == "boolean" ? ["!bool!", Z] : Object.prototype.toString.call(Z) === "[object String]" ? ["!str!", String(Z)] : ["!num!", Number(Z)];
    }).desc("string"), X = parsimmon_umd_minExports.lazy(
      () => parsimmon_umd_minExports.string("(").then(z(this, cn)).skip(parsimmon_umd_minExports.string(")")).or(N).or(B).or($).or(U).or(V)
    ), Y = [
      // 優先順位：19（メンバーへのアクセス、計算値によるメンバーへのアクセス）
      // a.b  a[b]
      { type: S, ops: r([/[A-Za-z_][A-Za-z0-9_]*(?=\()/]) },
      // ++ --		// 優先順位：17（後置インクリメント・デクリメント）
      { type: S, ops: r([/(!(?!=)|~)/]) },
      // 優先順位：16
      //	{type: PREFIX, ops: ope([/(!(?!=)|++|--)/])},
      // 「n!」階乗演算子は優先順位がよく判らないし、使わない・ミスも考え無いほうが
      //		// 優先順位：16（前置インクリメント・デクリメント）
      { type: T, ops: r(["**"]) },
      { type: D, ops: r(["*", "/", "¥", "%"]) },
      { type: D, ops: r(["+", "-"]) },
      { type: D, ops: r([/(>>>|<<|>>)/]) },
      { type: D, ops: r([/(<=|<|>=|>)/]) },
      { type: D, ops: r([/(===|!==|==|!=)/]) },
      { type: D, ops: r([/&(?!&)/]) },
      { type: D, ops: r(["^"]) },
      { type: D, ops: r([/\|(?!\|)/]) },
      { type: D, ops: r(["&&"]) },
      { type: D, ops: r(["||"]) },
      { type: T, ops: r([":"]) },
      { type: T, ops: r(["?"]) }
    ].reduce(
      (q, K) => K.type(K.ops, q),
      X
    );
    at(this, cn, Y.trim(parsimmon_umd_minExports.optWhitespace));
  }
  parse(t) {
    const e = z(this, cn).parse(t);
    if (!e.status)
      throw Error("(PropParser)文法エラー【" + t + "】");
    const r = e.value;
    return r[0] === "!str!" ? lt(this, ao, zc).call(this, r[1]) : lt(this, Kt, Zt).call(this, r);
  }
  // 522 match 18413 step(~10ms) https://regex101.com/r/tmCKuE/1
  // →これは改良しようがない。いい意味で改善の余地なし
  static getValName(t) {
    var N;
    const e = z(this, Su).exec(t.trim()), r = e == null ? void 0 : e.groups;
    if (!r)
      return null;
    const { scope: S = "tmp", name: T, at: D = "" } = r;
    return {
      scope: S,
      name: lt(N = Df, Eu, kf).call(N, T),
      at: D
    };
  }
};
let PropParser = Df;
cn = new WeakMap(), Kt = new WeakSet(), Zt = function(t) {
  const e = t.shift();
  if (e instanceof Array)
    return lt(this, Kt, Zt).call(this, e);
  const r = z(this, Ni)[e];
  return r ? r(t) : Object(null);
}, Ni = new WeakMap(), Li = new WeakSet(), bs = function(t) {
  const e = lt(this, Kt, Zt).call(this, t);
  if (Object.prototype.toString.call(e) !== "[object Number]")
    throw Error("(PropParser)引数【" + e + "】が数値ではありません");
  return Number(e);
}, xu = new WeakMap(), ao = new WeakSet(), zc = function(t) {
  return t == null ? t : String(t).replaceAll(z(this, xu), (e) => e.at(0) === "$" ? this.val.getVal(e.slice(1)) : this.parse(e.slice(2, -1)));
}, Su = new WeakMap(), Eu = new WeakSet(), kf = function(t) {
  let e = 0, r = 0;
  for (; ; ) {
    if (e = t.indexOf('["'), e < 0) {
      if (e = t.indexOf("['"), e < 0)
        break;
      r = t.indexOf("']", e + 2);
    } else
      r = t.indexOf('"]', e + 2);
    if (r < 0)
      break;
    t = t.slice(0, e) + "." + t.slice(e + 2, r) + t.slice(r + 2), e = r - 2;
  }
  return t;
}, tt(PropParser, Eu), tt(PropParser, Su, /^((?<scope>\w+?):)?(?<name>[^\s :@]+)(?<at>\@str)?$/);
var Er, fn, Ms, Tr, oo, Tu, Bf, wu, Ff, Cu, $f, Pu, Gf;
const de = class {
  constructor(t, e, r) {
    tt(this, Tu);
    tt(this, wu);
    // ログ出力
    tt(this, oo, !0);
    this.sys = t, at(de, Er, r), at(de, fn, e), at(de, Ms, e.title), de.myTrace = lt(de, Cu, $f), e.log = (S) => lt(this, Tu, Bf).call(this, S), e.trace = (S) => lt(this, wu, Ff).call(this, S), at(de, Tr, document.createElement("span")), z(de, Tr).hidden = !0, z(de, Tr).textContent = "", z(de, Tr).style.cssText = `	z-index: ${Number.MAX_SAFE_INTEGER};
			position: absolute; left: 0; top: 0;
			color: black;
			background-color: rgba(255, 255, 255, 0.7);`, document.body.appendChild(z(de, Tr));
  }
  destroy() {
    at(de, Ms, () => !1), document.body.removeChild(z(de, Tr)), de.myTrace = de.trace_beforeNew;
  }
  // private禁止、galleryでエラーになる
  static trace_beforeNew(t, e = "E") {
    let r = `{${e}} ` + t, S = "";
    switch (e) {
      case "D":
        S = `color:#${CmnLib.isDarkMode ? "49F" : "05A"};`;
        break;
      case "W":
        S = "color:#FF8800;";
        break;
      case "F":
        S = "color:#BB0000;";
        break;
      case "ET":
        throw r;
      case "E":
        console.error("%c" + r, "color:#FF3300;");
        return;
      default:
        S = "color:black;", r = " " + r;
    }
    console.info("%c" + r, S);
  }
};
let DebugMng = de;
Er = new WeakMap(), fn = new WeakMap(), Ms = new WeakMap(), Tr = new WeakMap(), oo = new WeakMap(), Tu = new WeakSet(), Bf = function(t) {
  let e = "";
  return z(this, oo) && (at(this, oo, !1), e = `== ${platformExports.description} ==
`), this.sys.appendFile(
    this.sys.path_downloads + "log.txt",
    `${e}--- ${getDateStr("-", "_", "")} [fn:${z(de, Er).scriptFn} line:${z(de, Er).lineNum}] prj:${this.sys.cur}
${t.text || `(text is ${t.text})`}
`,
    (r) => {
      r && console.log(r);
    }
  ), !1;
}, wu = new WeakSet(), Ff = function(t) {
  return de.myTrace(t.text || `(text is ${t.text})`, "I"), !1;
}, Cu = new WeakSet(), $f = function(t, e = "E") {
  var T, D;
  let r = `{${e}} ` + de.strPos() + t;
  lt(T = de, Pu, Gf).call(T, r, e);
  let S = "";
  switch (e) {
    case "D":
      S = `color:#${CmnLib.isDarkMode ? "49F" : "05A"};`;
      break;
    case "W":
      S = "color:#F80;";
      break;
    case "F":
      S = "color:#B00;";
      break;
    case "ET":
    case "E":
      if (z(D = de, Ms).call(D, { text: t }), z(this, fn).dump_lay({}), z(this, fn).dump_val({}), z(de, Er).dumpErrForeLine(), z(this, fn).dump_stack({}), e === "ET")
        throw r;
      console.error("%c" + r, "color:#F30;");
      return;
    default:
      S = "", r = " " + r;
  }
  console.info("%c" + r, S);
}, Pu = new WeakSet(), Gf = function(t, e) {
  let r = "";
  switch (e) {
    case "D":
      r = "color:#05A;";
      break;
    case "W":
      r = "color:#F80;";
      break;
    case "F":
      r = "color:#B00;";
      break;
    case "ET":
    case "E":
      r = "color:#F30;";
      break;
    default:
      r = "";
  }
  z(de, Tr).innerHTML += `<span style='${r}'>${t}</span><br/>`, z(de, Tr).hidden = !1;
}, tt(DebugMng, Cu), tt(DebugMng, Pu), tt(DebugMng, Er, void 0), tt(DebugMng, fn, void 0), tt(DebugMng, Ms, void 0), tt(DebugMng, Tr, void 0), Pt(DebugMng, "myTrace", de.trace_beforeNew), Pt(DebugMng, "strPos", () => z(de, Er) && z(de, Er).lineNum > 0 ? `(fn:${z(de, Er).scriptFn} line:${z(de, Er).lineNum}) ` : "");
class Areas {
  constructor() {
    Pt(this, "hAreas", /* @__PURE__ */ Object.create(null));
  }
  clear() {
    this.hAreas = {};
  }
  search(t) {
    return Object.entries(this.hAreas).some(([e, r]) => t >= parseInt(e) && t <= r);
  }
  record(t) {
    if (!this.search(t)) {
      for (const [e, r] of Object.entries(this.hAreas))
        if (r + 1 === t) {
          String(t + 1) in this.hAreas ? (this.hAreas[e] = this.hAreas[t + 1], delete this.hAreas[t + 1]) : this.hAreas[e] = t;
          return;
        }
      if (String(t + 1) in this.hAreas) {
        this.hAreas[t] = this.hAreas[t + 1], delete this.hAreas[t + 1];
        return;
      }
      this.hAreas[t] = t;
    }
  }
  erase(t) {
    if (this.search(t)) {
      if (String(t) in this.hAreas) {
        this.hAreas[t] > t && (this.hAreas[t + 1] = this.hAreas[t]), delete this.hAreas[t];
        return;
      }
      for (const [e, r] of Object.entries(this.hAreas))
        if (!(t < parseInt(e) || r < t)) {
          if (this.hAreas[e] === t) {
            this.hAreas[e] = t - 1;
            return;
          }
          this.hAreas[t + 1] = r, this.hAreas[e] = t - 1;
          return;
        }
    }
  }
  get count() {
    return Object.keys(this.hAreas).length;
  }
  // 4tst
  toString() {
    let t = ",";
    for (const e of Object.keys(this.hAreas).map((r) => parseInt(r)).sort((r, S) => r - S))
      t += e === this.hAreas[e] ? "," + e : "," + e + "~" + this.hAreas[e];
    return t.slice(1);
  }
}
var Le, dr, Te, ri, Ie, nr, Br, lo, Ru, uo, Hc, ho, co, Mu, Uf, Ou, jf, pr, kr, Iu, zf, Du, Hf, Au, Vf, Nu, Xf, Lu, Yf, ku, Wf, Bu, qf, Fu, Kf, Os, iu, fo, Vc, po, dn, vo, Xc, $u, Gu, Is, go, Ds, nu, Uu, Zf, ju, Jf, mo, Yc, _o, Wc, zu, Qf, Hu, td, As, su;
const Ts = class {
  constructor(t, e) {
    tt(this, uo);
    //	// しおり
    // しおりの複写
    tt(this, Mu);
    // しおりの消去
    tt(this, Ou);
    //	//	変数操作
    // 変数代入・演算
    tt(this, pr);
    // 絶対値
    tt(this, Iu);
    // 文字列から一字取りだし
    tt(this, Du);
    // 文字列で検索
    tt(this, Au);
    // 文字列の長さ
    tt(this, Nu);
    // 正規表現で置換
    tt(this, Lu);
    // 四捨五入
    tt(this, ku);
    // 正規表現で検索
    tt(this, Bu);
    // 文字列から抜きだし
    tt(this, Fu);
    //	// デバッグ・その他
    // システム変数の全消去
    tt(this, Os);
    // ゲーム変数の全消去
    tt(this, fo);
    tt(this, vo);
    tt(this, Ds);
    tt(this, Uu);
    tt(this, ju);
    tt(this, mo);
    tt(this, _o);
    tt(this, zu);
    tt(this, Hu);
    tt(this, As);
    tt(this, Le, { sys: {}, save: {}, tmp: {}, mp: {} });
    tt(this, dr, z(this, Le).save);
    tt(this, Te, z(this, Le).tmp);
    tt(this, ri, void 0);
    tt(this, Ie, { sys: {}, mark: {}, kidoku: {} });
    tt(this, nr, void 0);
    tt(this, Br, {});
    tt(this, lo, void 0);
    tt(this, Ru, {
      auth: (t, e) => lt(this, uo, Hc).call(this, e.hBreakpoint.aData),
      var: (t, e) => z(this, ri).send2Dbg(e.ri, { v: z(this, Le)[e.scope] ?? {} }),
      set_var: (t, e) => {
        try {
          z(this, po).call(this, e.nm, e.val), z(this, ri).send2Dbg(e.ri, {});
        } catch {
        }
      },
      set_data_break: (t, e) => {
        lt(this, uo, Hc).call(this, e.a), z(this, ri).send2Dbg(e.ri, {});
      },
      disconnect: (t) => at(Ts, dn, {})
    });
    tt(this, ho, () => {
    });
    tt(this, co, (t) => {
    });
    Pt(this, "getMark", (t) => z(this, Ie).mark[t]);
    Pt(this, "getAreaKidoku", (t) => z(this, Br)[t]);
    tt(this, po, (t, e, r = !0) => {
      if (!t)
        throw "[変数に値セット] nameは必須です";
      if (e == null)
        throw "[変数に値セット] textは必須です（空文字はOK）";
      const S = PropParser.getValName(t);
      if (S === null)
        throw "[変数参照] name(" + t + ")が変数名として異常です";
      const T = z(this, Le)[S.scope];
      if (!T)
        throw "[変数に値セット] scopeが異常【" + S.scope + "】です";
      const D = S.name;
      if (D.slice(0, 6) === "const." && D in T)
        throw "[変数に値セット] 変数【" + D + "】は書き換え不可です";
      this.setVal_Nochk(S.scope, D, e, r);
    });
    Pt(this, "getVal", (t, e) => {
      if (!t)
        throw "[変数参照] nameは必須です";
      const r = PropParser.getValName(t);
      if (r === null)
        throw "[変数参照] name(" + t + ")が変数名として異常です";
      const S = z(this, Le)[r.scope];
      if (!S)
        throw "[変数参照] scopeが異常【" + r.scope + "】です";
      const T = r.name;
      let D = S[T];
      if (!(T in S)) {
        D = e;
        let N = "";
        const B = T.split("."), $ = B.length;
        for (let U = 0; U < $; ++U, N += ".") {
          if (N += B[U], !(N in S))
            continue;
          let H = JSON.parse(S[N]);
          if (Object.prototype.toString.call(H) !== "[object Object]") {
            if (U + 1 === $) {
              D = H;
              break;
            }
            continue;
          }
          let V = U;
          for (; ++V < $; ) {
            if (!(B[V] in H)) {
              D = e;
              break;
            }
            if (H = H[B[V]], Object.prototype.toString.call(H) !== "[object Object]" || V + 1 === $) {
              D = H;
              break;
            }
          }
          D instanceof Object && (D = JSON.stringify(D));
          break;
        }
      }
      return D instanceof Function && (D = D()), r.at === "@str" ? D : lt(this, vo, Xc).call(this, D);
    });
    tt(this, $u, /^-?[\d\.]+$/);
    // 変数のダンプ
    tt(this, Gu, () => {
      const t = { tmp: {}, sys: {}, save: {}, mp: {} };
      for (let e in t) {
        const r = z(this, Le)[e], S = t[e];
        for (let [T, D] of Object.entries(r))
          S[T] = Object.prototype.toString.call(D) === "[object Function]" ? D() : D;
      }
      return console.info("🥟 [dump_val]", t), !1;
    });
    tt(this, Is, !1);
    tt(this, go, {
      // sys
      "sys:sn.tagCh.doWait": (t) => lt(this, Ds, nu).call(this, t),
      "sys:sn.tagCh.doWait_Kidoku": (t) => lt(this, Ds, nu).call(this, t),
      "sys:sn.tagCh.msecWait": (t) => lt(this, Uu, Zf).call(this, t),
      "sys:sn.tagCh.msecWait_Kidoku": (t) => lt(this, ju, Jf).call(this, t),
      "sys:sn.tagCh.canskip": (t) => lt(this, Ds, nu).call(this, t),
      "sys:sn.auto.msecPageWait": (t) => lt(this, mo, Yc).call(this, t),
      "sys:sn.auto.msecPageWait_Kidoku": (t) => lt(this, mo, Yc).call(this, t),
      "sys:sn.auto.msecLineWait": (t) => lt(this, _o, Wc).call(this, t),
      "sys:sn.auto.msecLineWait_Kidoku": (t) => lt(this, _o, Wc).call(this, t),
      // save
      "save:sn.doRecLog": (t) => {
        z(this, co).call(this, at(this, Is, lt(this, zu, Qf).call(this, t)));
      },
      "save:sn.userFnTail": (t, e) => this.cfg.userFnTail = e,
      // tmp
      "tmp:sn.tagL.enabled": (t) => lt(this, Hu, td).call(this, t),
      "tmp:sn.skip.all": (t) => lt(this, As, su).call(this, t),
      "tmp:sn.skip.enabled": (t) => lt(this, As, su).call(this, t),
      "tmp:sn.auto.enabled": (t) => lt(this, As, su).call(this, t),
      "tmp:flash.desktop.NativeApplication.nativeApplication.systemIdleMode": () => {
      }
    });
    if (this.cfg = t, e.let = (T) => lt(this, pr, kr).call(this, T), e.let_abs = (T) => lt(this, Iu, zf).call(this, T), e.let_char_at = (T) => lt(this, Du, Hf).call(this, T), e.let_index_of = (T) => lt(this, Au, Vf).call(this, T), e.let_length = (T) => lt(this, Nu, Xf).call(this, T), e.let_replace = (T) => lt(this, Lu, Yf).call(this, T), e.let_round = (T) => lt(this, ku, Wf).call(this, T), e.let_search = (T) => lt(this, Bu, qf).call(this, T), e.let_substr = (T) => lt(this, Fu, Kf).call(this, T), e.clearsysvar = () => lt(this, Os, iu).call(this), e.clearvar = () => lt(this, fo, Vc).call(this), e.dump_val = () => z(this, Gu).call(this), e.copybookmark = (T) => lt(this, Mu, Uf).call(this, T), e.erasebookmark = (T) => lt(this, Ou, jf).call(this, T), z(this, dr)["sn.userFnTail"] = "", this.defTmp("const.sn.bookmark.json", () => {
      const T = [];
      for (const D of Object.keys(z(this, Ie).mark).sort()) {
        const N = { ...z(this, Ie).mark[D].json };
        N.place = D, T.push(N);
      }
      return JSON.stringify(T);
    }), z(this, Te)["const.sn.isFirstBoot"] = !0, z(this, Te)["sn.tagL.enabled"] = !0, z(this, Te)["sn.skip.all"] = !1, z(this, Te)["sn.skip.enabled"] = !1, z(this, Te)["sn.auto.enabled"] = !1, z(this, Te)["const.sn.last_page_text"] = "", z(this, Te)["const.sn.displayState"] = !1, z(this, Te)["const.Date.getTime"] = () => new Date().getTime(), z(this, Te)["const.Date.getDateStr"] = () => getDateStr(), z(this, Te)["const.sn.platform"] = JSON.stringify(platformExports), lt(this, Os, iu).call(this), lt(this, fo, Vc).call(this), z(this, Te)["const.sn.config.window.width"] = t.oCfg.window.width, z(this, Te)["const.sn.config.window.height"] = t.oCfg.window.height, z(this, Te)["const.sn.config.book.title"] = t.oCfg.book.title, z(this, Te)["const.sn.config.book.version"] = t.oCfg.book.version, z(this, Te)["const.sn.Math.PI"] = Math.PI, typeof window > "u")
      return;
    const r = window, S = r.AudioContext ?? r.webkitAudioContext;
    z(this, Te)["const.sn.needClick2Play"] = () => new S().state === "suspended";
  }
  setSys(t) {
    at(this, ri, t), t.initVal(z(this, Ie), z(this, Te), (e) => {
      this.updateData(e), sessionStorage.clear();
      const r = this.cfg.getNs();
      at(this, ho, this.cfg.oCfg.debug.variable ? () => {
        const T = {};
        for (const [H, V] of Object.entries(z(this, nr)))
          T["sys:" + H] = V instanceof Function ? V() : V;
        sessionStorage[r + "sys"] = JSON.stringify(T);
        const D = {};
        for (const [H, V] of Object.entries(z(this, dr)))
          D["save:" + H] = V instanceof Function ? V() : V;
        sessionStorage[r + "save"] = JSON.stringify(D);
        const N = {};
        for (const [H, V] of Object.entries(z(this, Te)))
          N[H] = V instanceof Function ? V() : V;
        sessionStorage[r + "tmp"] = JSON.stringify(N);
        const B = {};
        for (const [H, V] of Object.entries(z(this, Le).mp))
          B[H] = V instanceof Function ? V() : V;
        sessionStorage[r + "mp"] = JSON.stringify(B);
        const $ = {};
        for (const [H, V] of Object.entries(z(this, Ie).mark))
          $[H] = V instanceof Function ? V() : V;
        sessionStorage[r + "mark"] = JSON.stringify($);
        const U = {};
        for (const [H, V] of Object.entries(z(this, Ie).kidoku))
          U[H] = V instanceof Function ? V() : V;
        sessionStorage[r + "kidoku"] = JSON.stringify(U), t.flush();
      } : () => t.flush()), at(this, lo, (T, D) => t.callHook(T, D)), t.addHook((T, D) => {
        var N, B;
        return (B = (N = z(this, Ru))[T]) == null ? void 0 : B.call(N, T, D);
      });
      const S = this.getVal("sys:sn.tagCh.msecWait", -1);
      (z(this, Te)["const.sn.isFirstBoot"] || S === -1) && lt(this, Os, iu).call(this);
    });
  }
  updateData(t) {
    at(this, Ie, t), at(this, nr, z(this, Le).sys = z(this, Ie).sys), at(this, Br, {});
    for (const [e, r] of Object.entries(z(this, Ie).kidoku)) {
      const S = new Areas();
      S.hAreas = { ...r }, z(this, Br)[e] = S;
    }
  }
  flush() {
    z(this, ho).call(this);
  }
  // 先にこのメソッドへの参照を配ってしまうので、中身を入れ替える
  setDoRecProc(t) {
    at(this, co, t);
  }
  defTmp(t, e) {
    z(this, Te)[t] = e;
  }
  cloneMp() {
    return { ...z(this, Le).mp };
  }
  setMp(t) {
    z(this, Le).mp = t;
  }
  setMark(t, e) {
    z(this, Ie).mark[t] = e, this.flush();
  }
  cloneSave() {
    return { ...z(this, Le).save };
  }
  mark2save(t) {
    at(this, dr, z(this, Le).save = { ...t.hSave }), at(this, Is, z(this, dr)["sn.doRecLog"] ?? !1);
  }
  // 既読系
  loadScrWork(t) {
    t in z(this, Br) || (z(this, Br)[t] = new Areas());
  }
  saveKidoku() {
    for (const [t, { hAreas: e }] of Object.entries(z(this, Br)))
      z(this, Ie).kidoku[t] = { ...e };
    this.flush();
  }
  setVal_Nochk(t, e, r, S = !1) {
    var N, B;
    const T = z(this, Le)[t];
    S && (r = lt(this, vo, Xc).call(this, r));
    const D = t + ":" + e;
    if (D in z(Ts, dn)) {
      const $ = T[e], U = r;
      $ != U && z(this, lo).call(this, "data_break", {
        dataId: D,
        old_v: $,
        new_v: U
      });
    }
    T[e] = r, (B = (N = z(this, go))[D]) == null || B.call(N, e, r);
  }
  doRecLog() {
    return z(this, Is);
  }
  defValTrg(t, e) {
    z(this, go)[t] = e;
  }
};
let Variable = Ts;
Le = new WeakMap(), dr = new WeakMap(), Te = new WeakMap(), ri = new WeakMap(), Ie = new WeakMap(), nr = new WeakMap(), Br = new WeakMap(), lo = new WeakMap(), Ru = new WeakMap(), uo = new WeakSet(), Hc = function(t) {
  at(Ts, dn, {});
  for (const e of t)
    z(Ts, dn)[e.dataId] = 1;
}, ho = new WeakMap(), co = new WeakMap(), Mu = new WeakSet(), Uf = function(t) {
  if (!("from" in t))
    throw "fromは必須です";
  if (!("to" in t))
    throw "toは必須です";
  const e = Number(t.from), r = Number(t.to);
  if (e === r)
    return !1;
  if (!(e in z(this, Ie).mark))
    throw `from:${e} のセーブデータは存在しません`;
  return this.setMark(r, { ...z(this, Ie).mark[e] }), z(this, ri).copyBMFolder(e, r), !1;
}, Ou = new WeakSet(), jf = function(t) {
  const { place: e } = t;
  if (!e)
    throw "placeは必須です";
  return delete z(this, Ie).mark[e], this.flush(), z(this, ri).eraseBMFolder(e), !1;
}, pr = new WeakSet(), kr = function(t) {
  if (!t.name)
    throw "nameは必須です";
  let e = !0;
  if (t.cast)
    switch (t.cast) {
      case "num":
        argChk_Num(t, "text", NaN);
        break;
      case "int":
        t.text = String(int(argChk_Num(t, "text", NaN)));
        break;
      case "uint":
        t.text = String(uint(argChk_Num(t, "text", NaN)));
        break;
      case "bool":
        argChk_Boolean(t, "text", !1);
        break;
      case "str":
        e = !1;
        break;
      default:
        throw "cast【" + t.cast + "】は未定義です";
    }
  return z(this, po).call(this, t.name, t.text, e), !1;
}, Iu = new WeakSet(), zf = function(t) {
  const e = argChk_Num(t, "text", 0);
  return t.text = String(e < 0 ? -e : e), lt(this, pr, kr).call(this, t), !1;
}, Du = new WeakSet(), Hf = function(t) {
  return t.text = (t.text ?? "").charAt(argChk_Num(t, "pos", 0)), lt(this, pr, kr).call(this, t), !1;
}, Au = new WeakSet(), Vf = function(t) {
  const { val: e } = t;
  if (!e)
    throw "valは必須です";
  const r = argChk_Num(t, "start", 0);
  return t.text = String((t.text ?? "").indexOf(e, r)), lt(this, pr, kr).call(this, t), !1;
}, Nu = new WeakSet(), Xf = function(t) {
  return t.text = String((t.text ?? "").length), lt(this, pr, kr).call(this, t), !1;
}, Lu = new WeakSet(), Yf = function(t) {
  if (!t.reg)
    throw "regは必須です";
  const { flags: e } = t, r = e ? new RegExp(t.reg, e) : new RegExp(t.reg);
  return t.text = String(t.text ?? "").replace(r, String(t.val)), lt(this, pr, kr).call(this, t), !1;
}, ku = new WeakSet(), Wf = function(t) {
  const e = argChk_Num(t, "text", 0);
  return t.text = String(Math.round(e)), lt(this, pr, kr).call(this, t), !1;
}, Bu = new WeakSet(), qf = function(t) {
  if (!t.reg)
    throw "regは必須です";
  const { flags: e } = t, r = e ? new RegExp(t.reg, e) : new RegExp(t.reg);
  return t.text = String((t.text ?? "").search(r)), lt(this, pr, kr).call(this, t), !1;
}, Fu = new WeakSet(), Kf = function(t) {
  const e = argChk_Num(t, "pos", 0);
  return t.text = t.len !== "all" ? (t.text ?? "").slice(e, e + int(argChk_Num(t, "len", 1))) : (t.text ?? "").slice(e), lt(this, pr, kr).call(this, t), !1;
}, Os = new WeakSet(), iu = function() {
  const t = at(this, nr, z(this, Le).sys = z(this, Ie).sys = {});
  typeof process < "u" || (this.setVal_Nochk("sys", "const.sn.window.x", 0), this.setVal_Nochk("sys", "const.sn.window.y", 0)), this.setVal_Nochk("sys", "sn.tagCh.doWait", !0), this.setVal_Nochk("sys", "sn.tagCh.doWait_Kidoku", !0), this.setVal_Nochk("sys", "sn.tagCh.msecWait", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk("sys", "sn.tagCh.msecWait_Kidoku", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk("sys", "sn.tagCh.canskip", !0), this.setVal_Nochk("sys", "sn.skip.mode", "s"), this.setVal_Nochk("sys", "sn.auto.msecPageWait", argChk_Num(t, "sn.auto.msecPageWait", this.cfg.oCfg.init.auto_msecpagewait ?? 3500)), this.setVal_Nochk("sys", "sn.auto.msecPageWait_Kidoku", argChk_Num(t, "sn.auto.msecPageWait", this.cfg.oCfg.init.auto_msecpagewait ?? 3500)), this.setVal_Nochk("sys", "sn.auto.msecLineWait", 500), this.setVal_Nochk("sys", "sn.auto.msecLineWait_Kidoku", 500), this.setVal_Nochk("sys", "const.sn.sound.BGM.volume", 1), this.setVal_Nochk("sys", "const.sn.sound.SE.volume", 1), this.setVal_Nochk("sys", "const.sn.sound.SYS.volume", 1);
  for (const [r, S] of Object.entries(z(this, Ie).kidoku))
    S.hAreas = {}, z(this, Br)[r].clear();
  return this.setVal_Nochk("sys", "TextLayer.Back.Alpha", 0.5), z(this, Le).mark = z(this, Ie).mark = {}, this.setVal_Nochk("sys", "const.sn.save.place", 1), this.flush(), !1;
}, fo = new WeakSet(), Vc = function() {
  const t = z(this, dr)["const.sn.mesLayer"] ?? "", e = z(this, dr)["sn.doRecLog"] ?? !1, r = z(this, dr)["const.sn.sLog"] ?? "[]";
  return at(this, dr, z(this, Le).save = {}), this.setVal_Nochk("save", "const.sn.mesLayer", t), this.setVal_Nochk("save", "sn.doRecLog", e), this.setVal_Nochk("save", "const.sn.sLog", r), !1;
}, po = new WeakMap(), dn = new WeakMap(), vo = new WeakSet(), Xc = function(t) {
  const e = t;
  if (e === "true")
    return !0;
  if (e === "false")
    return !1;
  if (e === "null")
    return null;
  if (e !== "undefined")
    return z(this, $u).test(e) ? parseFloat(e) : t;
}, $u = new WeakMap(), Gu = new WeakMap(), Is = new WeakMap(), go = new WeakMap(), Ds = new WeakSet(), nu = function(t) {
  argChk_Boolean(z(this, nr), t, !0);
}, Uu = new WeakSet(), Zf = function(t) {
  argChk_Num(z(this, nr), t, 10), z(this, nr)["sn.tagCh.doWait"];
}, ju = new WeakSet(), Jf = function(t) {
  argChk_Num(
    z(this, nr),
    t,
    this.cfg.oCfg.init.tagch_msecwait === void 0 ? 10 : this.cfg.oCfg.init.tagch_msecwait
  ), z(this, nr)["sn.tagCh.doWait_Kidoku"];
}, mo = new WeakSet(), Yc = function(t) {
  argChk_Num(
    z(this, nr),
    t,
    this.cfg.oCfg.init.auto_msecpagewait === void 0 ? 3500 : this.cfg.oCfg.init.auto_msecpagewait
  );
}, _o = new WeakSet(), Wc = function(t) {
  argChk_Num(z(this, nr), t, 500);
}, zu = new WeakSet(), Qf = function(t) {
  return argChk_Boolean(z(this, dr), t, !0);
}, Hu = new WeakSet(), td = function(t) {
  argChk_Boolean(z(this, Te), t, !0);
}, As = new WeakSet(), su = function(t) {
  argChk_Boolean(z(this, Te), t, !1);
}, // reload 再生成 Main に受け渡すため static
tt(Variable, dn, {});
var Easing = {
  Linear: {
    None: function(o) {
      return o;
    }
  },
  Quadratic: {
    In: function(o) {
      return o * o;
    },
    Out: function(o) {
      return o * (2 - o);
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o : -0.5 * (--o * (o - 2) - 1);
    }
  },
  Cubic: {
    In: function(o) {
      return o * o * o;
    },
    Out: function(o) {
      return --o * o * o + 1;
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o * o : 0.5 * ((o -= 2) * o * o + 2);
    }
  },
  Quartic: {
    In: function(o) {
      return o * o * o * o;
    },
    Out: function(o) {
      return 1 - --o * o * o * o;
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o * o * o : -0.5 * ((o -= 2) * o * o * o - 2);
    }
  },
  Quintic: {
    In: function(o) {
      return o * o * o * o * o;
    },
    Out: function(o) {
      return --o * o * o * o * o + 1;
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o * o * o * o : 0.5 * ((o -= 2) * o * o * o * o + 2);
    }
  },
  Sinusoidal: {
    In: function(o) {
      return 1 - Math.cos(o * Math.PI / 2);
    },
    Out: function(o) {
      return Math.sin(o * Math.PI / 2);
    },
    InOut: function(o) {
      return 0.5 * (1 - Math.cos(Math.PI * o));
    }
  },
  Exponential: {
    In: function(o) {
      return o === 0 ? 0 : Math.pow(1024, o - 1);
    },
    Out: function(o) {
      return o === 1 ? 1 : 1 - Math.pow(2, -10 * o);
    },
    InOut: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : (o *= 2) < 1 ? 0.5 * Math.pow(1024, o - 1) : 0.5 * (-Math.pow(2, -10 * (o - 1)) + 2);
    }
  },
  Circular: {
    In: function(o) {
      return 1 - Math.sqrt(1 - o * o);
    },
    Out: function(o) {
      return Math.sqrt(1 - --o * o);
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? -0.5 * (Math.sqrt(1 - o * o) - 1) : 0.5 * (Math.sqrt(1 - (o -= 2) * o) + 1);
    }
  },
  Elastic: {
    In: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : -Math.pow(2, 10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI);
    },
    Out: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : Math.pow(2, -10 * o) * Math.sin((o - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : (o *= 2, o < 1 ? -0.5 * Math.pow(2, 10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI) + 1);
    }
  },
  Back: {
    In: function(o) {
      var t = 1.70158;
      return o * o * ((t + 1) * o - t);
    },
    Out: function(o) {
      var t = 1.70158;
      return --o * o * ((t + 1) * o + t) + 1;
    },
    InOut: function(o) {
      var t = 2.5949095;
      return (o *= 2) < 1 ? 0.5 * (o * o * ((t + 1) * o - t)) : 0.5 * ((o -= 2) * o * ((t + 1) * o + t) + 2);
    }
  },
  Bounce: {
    In: function(o) {
      return 1 - Easing.Bounce.Out(1 - o);
    },
    Out: function(o) {
      return o < 1 / 2.75 ? 7.5625 * o * o : o < 2 / 2.75 ? 7.5625 * (o -= 1.5 / 2.75) * o + 0.75 : o < 2.5 / 2.75 ? 7.5625 * (o -= 2.25 / 2.75) * o + 0.9375 : 7.5625 * (o -= 2.625 / 2.75) * o + 0.984375;
    },
    InOut: function(o) {
      return o < 0.5 ? Easing.Bounce.In(o * 2) * 0.5 : Easing.Bounce.Out(o * 2 - 1) * 0.5 + 0.5;
    }
  }
}, now$2;
typeof self > "u" && typeof process < "u" && process.hrtime ? now$2 = function() {
  var o = process.hrtime();
  return o[0] * 1e3 + o[1] / 1e6;
} : typeof self < "u" && self.performance !== void 0 && self.performance.now !== void 0 ? now$2 = self.performance.now.bind(self.performance) : Date.now !== void 0 ? now$2 = Date.now : now$2 = function() {
  return new Date().getTime();
};
var now$1$1 = now$2, Group = function() {
  function o() {
    this._tweens = {}, this._tweensAddedDuringUpdate = {};
  }
  return o.prototype.getAll = function() {
    var t = this;
    return Object.keys(this._tweens).map(function(e) {
      return t._tweens[e];
    });
  }, o.prototype.removeAll = function() {
    this._tweens = {};
  }, o.prototype.add = function(t) {
    this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t;
  }, o.prototype.remove = function(t) {
    delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()];
  }, o.prototype.update = function(t, e) {
    t === void 0 && (t = now$1$1()), e === void 0 && (e = !1);
    var r = Object.keys(this._tweens);
    if (r.length === 0)
      return !1;
    for (; r.length > 0; ) {
      this._tweensAddedDuringUpdate = {};
      for (var S = 0; S < r.length; S++) {
        var T = this._tweens[r[S]], D = !e;
        T && T.update(t, D) === !1 && !e && delete this._tweens[r[S]];
      }
      r = Object.keys(this._tweensAddedDuringUpdate);
    }
    return !0;
  }, o;
}(), Interpolation = {
  Linear: function(o, t) {
    var e = o.length - 1, r = e * t, S = Math.floor(r), T = Interpolation.Utils.Linear;
    return t < 0 ? T(o[0], o[1], r) : t > 1 ? T(o[e], o[e - 1], e - r) : T(o[S], o[S + 1 > e ? e : S + 1], r - S);
  },
  Bezier: function(o, t) {
    for (var e = 0, r = o.length - 1, S = Math.pow, T = Interpolation.Utils.Bernstein, D = 0; D <= r; D++)
      e += S(1 - t, r - D) * S(t, D) * o[D] * T(r, D);
    return e;
  },
  CatmullRom: function(o, t) {
    var e = o.length - 1, r = e * t, S = Math.floor(r), T = Interpolation.Utils.CatmullRom;
    return o[0] === o[e] ? (t < 0 && (S = Math.floor(r = e * (1 + t))), T(o[(S - 1 + e) % e], o[S], o[(S + 1) % e], o[(S + 2) % e], r - S)) : t < 0 ? o[0] - (T(o[0], o[0], o[1], o[1], -r) - o[0]) : t > 1 ? o[e] - (T(o[e], o[e], o[e - 1], o[e - 1], r - e) - o[e]) : T(o[S ? S - 1 : 0], o[S], o[e < S + 1 ? e : S + 1], o[e < S + 2 ? e : S + 2], r - S);
  },
  Utils: {
    Linear: function(o, t, e) {
      return (t - o) * e + o;
    },
    Bernstein: function(o, t) {
      var e = Interpolation.Utils.Factorial;
      return e(o) / e(t) / e(o - t);
    },
    Factorial: function() {
      var o = [1];
      return function(t) {
        var e = 1;
        if (o[t])
          return o[t];
        for (var r = t; r > 1; r--)
          e *= r;
        return o[t] = e, e;
      };
    }(),
    CatmullRom: function(o, t, e, r, S) {
      var T = (e - o) * 0.5, D = (r - t) * 0.5, N = S * S, B = S * N;
      return (2 * t - 2 * e + T + D) * B + (-3 * t + 3 * e - 2 * T - D) * N + T * S + t;
    }
  }
}, Sequence = function() {
  function o() {
  }
  return o.nextId = function() {
    return o._nextId++;
  }, o._nextId = 0, o;
}(), mainGroup = new Group(), Tween = function() {
  function o(t, e) {
    e === void 0 && (e = mainGroup), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = Easing.Linear.None, this._interpolationFunction = Interpolation.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._id = Sequence.nextId(), this._isChainStopped = !1, this._goToEnd = !1;
  }
  return o.prototype.getId = function() {
    return this._id;
  }, o.prototype.isPlaying = function() {
    return this._isPlaying;
  }, o.prototype.isPaused = function() {
    return this._isPaused;
  }, o.prototype.to = function(t, e) {
    return this._valuesEnd = Object.create(t), e !== void 0 && (this._duration = e), this;
  }, o.prototype.duration = function(t) {
    return this._duration = t, this;
  }, o.prototype.start = function(t) {
    if (this._isPlaying)
      return this;
    if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {
      this._reversed = !1;
      for (var e in this._valuesStartRepeat)
        this._swapEndStartRepeatValues(e), this._valuesStart[e] = this._valuesStartRepeat[e];
    }
    return this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t !== void 0 ? typeof t == "string" ? now$1$1() + parseFloat(t) : t : now$1$1(), this._startTime += this._delayTime, this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat), this;
  }, o.prototype._setupProperties = function(t, e, r, S) {
    for (var T in r) {
      var D = t[T], N = Array.isArray(D), B = N ? "array" : typeof D, $ = !N && Array.isArray(r[T]);
      if (!(B === "undefined" || B === "function")) {
        if ($) {
          var U = r[T];
          if (U.length === 0)
            continue;
          U = U.map(this._handleRelativeValue.bind(this, D)), r[T] = [D].concat(U);
        }
        if ((B === "object" || N) && D && !$) {
          e[T] = N ? [] : {};
          for (var H in D)
            e[T][H] = D[H];
          S[T] = N ? [] : {}, this._setupProperties(D, e[T], r[T], S[T]);
        } else
          typeof e[T] > "u" && (e[T] = D), N || (e[T] *= 1), $ ? S[T] = r[T].slice().reverse() : S[T] = e[T] || 0;
      }
    }
  }, o.prototype.stop = function() {
    return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
  }, o.prototype.end = function() {
    return this._goToEnd = !0, this.update(1 / 0), this;
  }, o.prototype.pause = function(t) {
    return t === void 0 && (t = now$1$1()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this), this);
  }, o.prototype.resume = function(t) {
    return t === void 0 && (t = now$1$1()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);
  }, o.prototype.stopChainedTweens = function() {
    for (var t = 0, e = this._chainedTweens.length; t < e; t++)
      this._chainedTweens[t].stop();
    return this;
  }, o.prototype.group = function(t) {
    return this._group = t, this;
  }, o.prototype.delay = function(t) {
    return this._delayTime = t, this;
  }, o.prototype.repeat = function(t) {
    return this._initialRepeat = t, this._repeat = t, this;
  }, o.prototype.repeatDelay = function(t) {
    return this._repeatDelayTime = t, this;
  }, o.prototype.yoyo = function(t) {
    return this._yoyo = t, this;
  }, o.prototype.easing = function(t) {
    return this._easingFunction = t, this;
  }, o.prototype.interpolation = function(t) {
    return this._interpolationFunction = t, this;
  }, o.prototype.chain = function() {
    for (var t = [], e = 0; e < arguments.length; e++)
      t[e] = arguments[e];
    return this._chainedTweens = t, this;
  }, o.prototype.onStart = function(t) {
    return this._onStartCallback = t, this;
  }, o.prototype.onUpdate = function(t) {
    return this._onUpdateCallback = t, this;
  }, o.prototype.onRepeat = function(t) {
    return this._onRepeatCallback = t, this;
  }, o.prototype.onComplete = function(t) {
    return this._onCompleteCallback = t, this;
  }, o.prototype.onStop = function(t) {
    return this._onStopCallback = t, this;
  }, o.prototype.update = function(t, e) {
    if (t === void 0 && (t = now$1$1()), e === void 0 && (e = !0), this._isPaused)
      return !0;
    var r, S, T = this._startTime + this._duration;
    if (!this._goToEnd && !this._isPlaying) {
      if (t > T)
        return !1;
      e && this.start(t);
    }
    if (this._goToEnd = !1, t < this._startTime)
      return !0;
    this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), S = (t - this._startTime) / this._duration, S = this._duration === 0 || S > 1 ? 1 : S;
    var D = this._easingFunction(S);
    if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, D), this._onUpdateCallback && this._onUpdateCallback(this._object, S), S === 1)
      if (this._repeat > 0) {
        isFinite(this._repeat) && this._repeat--;
        for (r in this._valuesStartRepeat)
          !this._yoyo && typeof this._valuesEnd[r] == "string" && (this._valuesStartRepeat[r] = // eslint-disable-next-line
          // @ts-ignore FIXME?
          this._valuesStartRepeat[r] + parseFloat(this._valuesEnd[r])), this._yoyo && this._swapEndStartRepeatValues(r), this._valuesStart[r] = this._valuesStartRepeat[r];
        return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), !0;
      } else {
        this._onCompleteCallback && this._onCompleteCallback(this._object);
        for (var N = 0, B = this._chainedTweens.length; N < B; N++)
          this._chainedTweens[N].start(this._startTime + this._duration);
        return this._isPlaying = !1, !1;
      }
    return !0;
  }, o.prototype._updateProperties = function(t, e, r, S) {
    for (var T in r)
      if (e[T] !== void 0) {
        var D = e[T] || 0, N = r[T], B = Array.isArray(t[T]), $ = Array.isArray(N), U = !B && $;
        U ? t[T] = this._interpolationFunction(N, S) : typeof N == "object" && N ? this._updateProperties(t[T], D, N, S) : (N = this._handleRelativeValue(D, N), typeof N == "number" && (t[T] = D + (N - D) * S));
      }
  }, o.prototype._handleRelativeValue = function(t, e) {
    return typeof e != "string" ? e : e.charAt(0) === "+" || e.charAt(0) === "-" ? t + parseFloat(e) : parseFloat(e);
  }, o.prototype._swapEndStartRepeatValues = function(t) {
    var e = this._valuesStartRepeat[t], r = this._valuesEnd[t];
    typeof r == "string" ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(r) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = e;
  }, o;
}();
Sequence.nextId;
var TWEEN = mainGroup;
TWEEN.getAll.bind(TWEEN);
var removeAll = TWEEN.removeAll.bind(TWEEN);
TWEEN.add.bind(TWEEN);
var remove$6 = TWEEN.remove.bind(TWEEN), update = TWEEN.update.bind(TWEEN), yo;
const Vu = class {
  static ease(t) {
    if (!t)
      return (e) => Easing.Linear.None(e);
    if (!(t in z(Vu, yo)))
      throw "異常なease指定です";
    return z(Vu, yo)[t];
  }
};
let CmnTween = Vu;
yo = new WeakMap(), tt(CmnTween, yo, {
  "Back.In": (t) => Easing.Back.In(t),
  "Back.InOut": (t) => Easing.Back.InOut(t),
  "Back.Out": (t) => Easing.Back.Out(t),
  "Bounce.In": (t) => Easing.Bounce.In(t),
  "Bounce.InOut": (t) => Easing.Bounce.InOut(t),
  "Bounce.Out": (t) => Easing.Bounce.Out(t),
  "Circular.In": (t) => Easing.Circular.In(t),
  "Circular.InOut": (t) => Easing.Circular.InOut(t),
  "Circular.Out": (t) => Easing.Circular.Out(t),
  "Cubic.In": (t) => Easing.Cubic.In(t),
  "Cubic.InOut": (t) => Easing.Cubic.InOut(t),
  "Cubic.Out": (t) => Easing.Cubic.Out(t),
  "Elastic.In": (t) => Easing.Elastic.In(t),
  "Elastic.InOut": (t) => Easing.Elastic.InOut(t),
  "Elastic.Out": (t) => Easing.Elastic.Out(t),
  "Exponential.In": (t) => Easing.Exponential.In(t),
  "Exponential.InOut": (t) => Easing.Exponential.InOut(t),
  "Exponential.Out": (t) => Easing.Exponential.Out(t),
  "Linear.None": (t) => Easing.Linear.None(t),
  "Quadratic.In": (t) => Easing.Quadratic.In(t),
  "Quadratic.InOut": (t) => Easing.Quadratic.InOut(t),
  "Quadratic.Out": (t) => Easing.Quadratic.Out(t),
  "Quartic.In": (t) => Easing.Quartic.In(t),
  "Quartic.InOut": (t) => Easing.Quartic.InOut(t),
  "Quartic.Out": (t) => Easing.Quartic.Out(t),
  "Quintic.In": (t) => Easing.Quintic.In(t),
  "Quintic.InOut": (t) => Easing.Quintic.InOut(t),
  "Quintic.Out": (t) => Easing.Quintic.Out(t),
  "Sinusoidal.In": (t) => Easing.Sinusoidal.In(t),
  "Sinusoidal.InOut": (t) => Easing.Sinusoidal.InOut(t),
  "Sinusoidal.Out": (t) => Easing.Sinusoidal.Out(t)
});
/*!
 * @pixi/sound - v4.3.1
 * https://github.com/pixijs/pixi-sound
 * Compiled Mon, 19 Sep 2022 19:18:55 UTC
 *
 * @pixi/sound is licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license
 */
var s;
function u() {
  return s;
}
var a = function(o, t) {
  return (a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      Object.prototype.hasOwnProperty.call(r, S) && (e[S] = r[S]);
  })(o, t);
};
function c(o, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function e() {
    this.constructor = o;
  }
  a(o, t), o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var l = function() {
  return (l = Object.assign || function(o) {
    for (var t, e = 1, r = arguments.length; e < r; e++)
      for (var S in t = arguments[e])
        Object.prototype.hasOwnProperty.call(t, S) && (o[S] = t[S]);
    return o;
  }).apply(this, arguments);
}, p = ["mp3", "ogg", "oga", "opus", "mpeg", "wav", "m4a", "aiff", "wma", "mid", "caf"], h = {};
function f(o) {
  var t = l({ m4a: "audio/mp4", oga: "audio/ogg", opus: 'audio/ogg; codecs="opus"', caf: 'audio/x-caf; codecs="opus"' }, o || {}), e = document.createElement("audio"), r = {}, S = /^no$/;
  p.forEach(function(T) {
    var D = e.canPlayType("audio/".concat(T)).replace(S, ""), N = t[T] ? e.canPlayType(t[T]).replace(S, "") : "";
    r[T] = !!D || !!N;
  }), Object.assign(h, r);
}
f();
var d = /\.(\{([^\}]+)\})(\?.*)?$/;
function _(o) {
  var t = d, e = typeof o == "string" ? o : o.url;
  if (!t.test(e))
    return e;
  for (var r = t.exec(e), S = r[2].split(","), T = S[S.length - 1], D = 0, N = S.length; D < N; D++) {
    var B = S[D];
    if (h[B]) {
      T = B;
      break;
    }
  }
  var $ = e.replace(r[1], T);
  if (typeof o != "string") {
    var U = o;
    U.extension = T, U.url = $;
  }
  return $;
}
var y = function() {
  function o() {
  }
  return o.add = function() {
    o.setLegacy(u().useLegacy);
  }, o.setLegacy = function(t) {
    var e = p;
    t ? e.forEach(function(r) {
      LoaderResource.setExtensionXhrType(r, LoaderResource.XHR_RESPONSE_TYPE.DEFAULT), LoaderResource.setExtensionLoadType(r, LoaderResource.LOAD_TYPE.AUDIO);
    }) : e.forEach(function(r) {
      LoaderResource.setExtensionXhrType(r, LoaderResource.XHR_RESPONSE_TYPE.BUFFER), LoaderResource.setExtensionLoadType(r, LoaderResource.LOAD_TYPE.XHR);
    });
  }, o.pre = function(t, e) {
    _(t), e();
  }, o.use = function(t, e) {
    t.data && p.indexOf(t.extension) > -1 ? t.sound = u().add(t.name, { loaded: e, preload: !0, url: t.url, source: t.data }) : e();
  }, o.extension = "loader", o;
}(), m = 0, g = function(o) {
  function t(e) {
    var r = o.call(this) || this;
    return r.id = m++, r.init(e), r;
  }
  return c(t, o), t.prototype.set = function(e, r) {
    if (this[e] === void 0)
      throw new Error("Property with name ".concat(e, " does not exist."));
    switch (e) {
      case "speed":
        this.speed = r;
        break;
      case "volume":
        this.volume = r;
        break;
      case "paused":
        this.paused = r;
        break;
      case "loop":
        this.loop = r;
        break;
      case "muted":
        this.muted = r;
    }
    return this;
  }, Object.defineProperty(t.prototype, "progress", { get: function() {
    return this._source.currentTime / this._duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    this._paused = e, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), t.prototype._onPlay = function() {
    this._playing = !0;
  }, t.prototype._onPause = function() {
    this._playing = !1;
  }, t.prototype.init = function(e) {
    this._playing = !1, this._duration = e.source.duration;
    var r = this._source = e.source.cloneNode(!1);
    r.src = e.parent.url, r.onplay = this._onPlay.bind(this), r.onpause = this._onPause.bind(this), e.context.on("refresh", this.refresh, this), e.context.on("refreshPaused", this.refreshPaused, this), this._media = e;
  }, t.prototype._internalStop = function() {
    this._source && this._playing && (this._source.onended = null, this._source.pause());
  }, t.prototype.stop = function() {
    this._internalStop(), this._source && this.emit("stop");
  }, Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(e) {
    this._speed = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(e) {
    this._volume = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(e) {
    this._loop = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(e) {
    this._muted = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    var e = this._media.context, r = this._media.parent;
    this._source.loop = this._loop || r.loop;
    var S = e.volume * (e.muted ? 0 : 1), T = r.volume * (r.muted ? 0 : 1), D = this._volume * (this._muted ? 0 : 1);
    this._source.volume = D * S * T, this._source.playbackRate = this._speed * e.speed * r.speed;
  }, t.prototype.refreshPaused = function() {
    var e = this._media.context, r = this._media.parent, S = this._paused || r.paused || e.paused;
    S !== this._pausedReal && (this._pausedReal = S, S ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop })), this.emit("pause", S));
  }, t.prototype.play = function(e) {
    var r = this, S = e.start, T = e.end, D = e.speed, N = e.loop, B = e.volume, $ = e.muted;
    this._speed = D, this._volume = B, this._loop = !!N, this._muted = $, this.refresh(), this.loop && T !== null && (this.loop = !1), this._start = S, this._end = T || this._duration, this._start = Math.max(0, this._start - t.PADDING), this._end = Math.min(this._end + t.PADDING, this._duration), this._source.onloadedmetadata = function() {
      r._source && (r._source.currentTime = S, r._source.onloadedmetadata = null, r.emit("progress", S, r._duration), Ticker.shared.add(r._onUpdate, r));
    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit("start");
  }, t.prototype._onUpdate = function() {
    this.emit("progress", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();
  }, t.prototype._onComplete = function() {
    Ticker.shared.remove(this._onUpdate, this), this._internalStop(), this.emit("progress", 1, this._duration), this.emit("end", this);
  }, t.prototype.destroy = function() {
    Ticker.shared.remove(this._onUpdate, this), this.removeAllListeners();
    var e = this._source;
    e && (e.onended = null, e.onplay = null, e.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = !1, this._end = null, this._start = 0, this._duration = 0, this._playing = !1, this._pausedReal = !1, this._paused = !1, this._muted = !1, this._media && (this._media.context.off("refresh", this.refresh, this), this._media.context.off("refreshPaused", this.refreshPaused, this), this._media = null);
  }, t.prototype.toString = function() {
    return "[HTMLAudioInstance id=".concat(this.id, "]");
  }, t.PADDING = 0.1, t;
}(eventemitter3Exports), b = function(o) {
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  return c(t, o), t.prototype.init = function(e) {
    this.parent = e, this._source = e.options.source || new Audio(), e.url && (this._source.src = e.url);
  }, t.prototype.create = function() {
    return new g(this);
  }, Object.defineProperty(t.prototype, "isPlayable", { get: function() {
    return !!this._source && this._source.readyState === 4;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "duration", { get: function() {
    return this._source.duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = "", this._source.load(), this._source = null);
  }, Object.defineProperty(t.prototype, "source", { get: function() {
    return this._source;
  }, enumerable: !1, configurable: !0 }), t.prototype.load = function(e) {
    var r = this._source, S = this.parent;
    if (r.readyState !== 4)
      if (S.url) {
        r.src = S.url;
        var T = function() {
          B(), S.isLoaded = !0;
          var U = S.autoPlayStart();
          e && e(null, S, U);
        }, D = function() {
          B(), e && e(new Error("Sound loading has been aborted"));
        }, N = function() {
          B();
          var U = "Failed to load audio element (code: ".concat(r.error.code, ")");
          e && e(new Error(U));
        }, B = function() {
          r.removeEventListener("canplaythrough", T), r.removeEventListener("load", T), r.removeEventListener("abort", D), r.removeEventListener("error", N);
        };
        r.addEventListener("canplaythrough", T, !1), r.addEventListener("load", T, !1), r.addEventListener("abort", D, !1), r.addEventListener("error", N, !1), r.load();
      } else
        e(new Error("sound.url or sound.source must be set"));
    else {
      S.isLoaded = !0;
      var $ = S.autoPlayStart();
      e && setTimeout(function() {
        e(null, S, $);
      }, 0);
    }
  }, t;
}(eventemitter3Exports), v = function() {
  function o(t, e) {
    this.parent = t, Object.assign(this, e), this.duration = this.end - this.start;
  }
  return o.prototype.play = function(t) {
    return this.parent.play({ complete: t, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop });
  }, o.prototype.destroy = function() {
    this.parent = null;
  }, o;
}(), P = function() {
  function o() {
  }
  return o.setParamValue = function(t, e) {
    if (t.setValueAtTime) {
      var r = u().context;
      t.setValueAtTime(e, r.audioContext.currentTime);
    } else
      t.value = e;
    return e;
  }, o;
}(), x = 0, O = function(o) {
  function t(e) {
    var r = o.call(this) || this;
    return r.id = x++, r._media = null, r._paused = !1, r._muted = !1, r._elapsed = 0, r.init(e), r;
  }
  return c(t, o), t.prototype.set = function(e, r) {
    if (this[e] === void 0)
      throw new Error("Property with name ".concat(e, " does not exist."));
    switch (e) {
      case "speed":
        this.speed = r;
        break;
      case "volume":
        this.volume = r;
        break;
      case "muted":
        this.muted = r;
        break;
      case "loop":
        this.loop = r;
        break;
      case "paused":
        this.paused = r;
    }
    return this;
  }, t.prototype.stop = function() {
    this._source && (this._internalStop(), this.emit("stop"));
  }, Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(e) {
    this._speed = e, this.refresh(), this._update(!0);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(e) {
    this._volume = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(e) {
    this._muted = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(e) {
    this._loop = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(e) {
    var r;
    this._filters && ((r = this._filters) === null || r === void 0 || r.filter(function(S) {
      return S;
    }).forEach(function(S) {
      return S.disconnect();
    }), this._filters = null, this._source.connect(this._gain)), this._filters = e != null && e.length ? e.slice(0) : null, this.refresh();
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    if (this._source) {
      var e = this._media.context, r = this._media.parent;
      this._source.loop = this._loop || r.loop;
      var S = e.volume * (e.muted ? 0 : 1), T = r.volume * (r.muted ? 0 : 1), D = this._volume * (this._muted ? 0 : 1);
      P.setParamValue(this._gain.gain, D * T * S), P.setParamValue(this._source.playbackRate, this._speed * r.speed * e.speed), this.applyFilters();
    }
  }, t.prototype.applyFilters = function() {
    var e;
    if (!((e = this._filters) === null || e === void 0) && e.length) {
      this._source.disconnect();
      var r = this._source;
      this._filters.forEach(function(S) {
        r.connect(S.destination), r = S;
      }), r.connect(this._gain);
    }
  }, t.prototype.refreshPaused = function() {
    var e = this._media.context, r = this._media.parent, S = this._paused || r.paused || e.paused;
    S !== this._pausedReal && (this._pausedReal = S, S ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume })), this.emit("pause", S));
  }, t.prototype.play = function(e) {
    var r = e.start, S = e.end, T = e.speed, D = e.loop, N = e.volume, B = e.muted, $ = e.filters;
    this._paused = !1;
    var U = this._media.nodes.cloneBufferSource(), H = U.source, V = U.gain;
    this._source = H, this._gain = V, this._speed = T, this._volume = N, this._loop = !!D, this._muted = B, this._filters = $, this.refresh();
    var X = this._source.buffer.duration;
    this._duration = X, this._end = S, this._lastUpdate = this._now(), this._elapsed = r, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = S, this._source.loopStart = r, this._source.start(0, r)) : S ? this._source.start(0, r, S - r) : this._source.start(0, r), this.emit("start"), this._update(!0), this.enableTicker(!0);
  }, t.prototype.enableTicker = function(e) {
    Ticker.shared.remove(this._updateListener, this), e && Ticker.shared.add(this._updateListener, this);
  }, Object.defineProperty(t.prototype, "progress", { get: function() {
    return this._progress;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    this._paused = e, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    var e;
    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off("refresh", this.refresh, this), this._media.context.events.off("refreshPaused", this.refreshPaused, this), this._media = null), (e = this._filters) === null || e === void 0 || e.forEach(function(r) {
      return r.disconnect();
    }), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = !1, this._elapsed = 0, this._duration = 0, this._paused = !1, this._muted = !1, this._pausedReal = !1;
  }, t.prototype.toString = function() {
    return "[WebAudioInstance id=".concat(this.id, "]");
  }, t.prototype._now = function() {
    return this._media.context.audioContext.currentTime;
  }, t.prototype._updateListener = function() {
    this._update();
  }, t.prototype._update = function(e) {
    if (e === void 0 && (e = !1), this._source) {
      var r = this._now(), S = r - this._lastUpdate;
      if (S > 0 || e) {
        var T = this._source.playbackRate.value;
        this._elapsed += S * T, this._lastUpdate = r;
        var D = this._duration, N = void 0;
        if (this._source.loopStart) {
          var B = this._source.loopEnd - this._source.loopStart;
          N = (this._source.loopStart + this._elapsed % B) / D;
        } else
          N = this._elapsed % D / D;
        this._progress = N, this.emit("progress", this._progress, D);
      }
    }
  }, t.prototype.init = function(e) {
    this._media = e, e.context.events.on("refresh", this.refresh, this), e.context.events.on("refreshPaused", this.refreshPaused, this);
  }, t.prototype._internalStop = function() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.stop(0), this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch {
      }
      this._source = null;
    }
  }, t.prototype._onComplete = function() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch {
      }
    }
    this._source = null, this._progress = 1, this.emit("progress", 1, this._duration), this.emit("end", this);
  }, t;
}(eventemitter3Exports), j = function() {
  function o(t, e) {
    this._output = e, this._input = t;
  }
  return Object.defineProperty(o.prototype, "destination", { get: function() {
    return this._input;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(t) {
    var e = this;
    if (this._filters && (this._filters.forEach(function(S) {
      S && S.disconnect();
    }), this._filters = null, this._input.connect(this._output)), t && t.length) {
      this._filters = t.slice(0), this._input.disconnect();
      var r = null;
      t.forEach(function(S) {
        r === null ? e._input.connect(S.destination) : r.connect(S.destination), r = S;
      }), r.connect(this._output);
    }
  }, enumerable: !1, configurable: !0 }), o.prototype.destroy = function() {
    this.filters = null, this._input = null, this._output = null;
  }, o;
}(), w = function(o) {
  function t(e) {
    var r = this, S = e.audioContext, T = S.createBufferSource(), D = S.createGain(), N = S.createAnalyser();
    return T.connect(N), N.connect(D), D.connect(e.destination), (r = o.call(this, N, D) || this).context = e, r.bufferSource = T, r.gain = D, r.analyser = N, r;
  }
  return c(t, o), Object.defineProperty(t.prototype, "script", { get: function() {
    return this._script || (this._script = this.context.audioContext.createScriptProcessor(t.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    o.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;
  }, t.prototype.cloneBufferSource = function() {
    var e = this.bufferSource, r = this.context.audioContext.createBufferSource();
    r.buffer = e.buffer, P.setParamValue(r.playbackRate, e.playbackRate.value), r.loop = e.loop;
    var S = this.context.audioContext.createGain();
    return r.connect(S), S.connect(this.destination), { source: r, gain: S };
  }, Object.defineProperty(t.prototype, "bufferSize", { get: function() {
    return this.script.bufferSize;
  }, enumerable: !1, configurable: !0 }), t.BUFFER_SIZE = 0, t;
}(j), A = function() {
  function o() {
  }
  return o.prototype.init = function(t) {
    this.parent = t, this._nodes = new w(this.context), this._source = this._nodes.bufferSource, this.source = t.options.source;
  }, o.prototype.destroy = function() {
    this.parent = null, this._nodes.destroy(), this._nodes = null;
    try {
      this._source.buffer = null;
    } catch {
    }
    this._source = null, this.source = null;
  }, o.prototype.create = function() {
    return new O(this);
  }, Object.defineProperty(o.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "isPlayable", { get: function() {
    return !!this._source && !!this._source.buffer;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "filters", { get: function() {
    return this._nodes.filters;
  }, set: function(t) {
    this._nodes.filters = t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "duration", { get: function() {
    return this._source.buffer.duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "buffer", { get: function() {
    return this._source.buffer;
  }, set: function(t) {
    this._source.buffer = t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "nodes", { get: function() {
    return this._nodes;
  }, enumerable: !1, configurable: !0 }), o.prototype.load = function(t) {
    this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t && t(new Error("sound.url or sound.source must be set"));
  }, o.prototype._loadUrl = function(t) {
    var e = this, r = new XMLHttpRequest(), S = this.parent.url;
    r.open("GET", S, !0), r.responseType = "arraybuffer", r.onload = function() {
      e.source = r.response, e._decode(r.response, t);
    }, r.send();
  }, o.prototype._decode = function(t, e) {
    var r = this, S = function(T, D) {
      if (T)
        e && e(T);
      else {
        r.parent.isLoaded = !0, r.buffer = D;
        var N = r.parent.autoPlayStart();
        e && e(null, r.parent, N);
      }
    };
    t instanceof AudioBuffer ? S(null, t) : this.parent.context.decode(t, S);
  }, o;
}(), F = function() {
  function o(t, e) {
    this.media = t, this.options = e, this._instances = [], this._sprites = {}, this.media.init(this);
    var r = e.complete;
    this._autoPlayOptions = r ? { complete: r } : null, this.isLoaded = !1, this.isPlaying = !1, this.autoPlay = e.autoPlay, this.singleInstance = e.singleInstance, this.preload = e.preload || this.autoPlay, this.url = e.url, this.speed = e.speed, this.volume = e.volume, this.loop = e.loop, e.sprites && this.addSprites(e.sprites), this.preload && this._preload(e.loaded);
  }
  return o.from = function(t) {
    var e = {};
    return typeof t == "string" ? e.url = t : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? e.source = t : e = t, (e = l({ autoPlay: !1, singleInstance: !1, url: null, source: null, preload: !1, volume: 1, speed: 1, complete: null, loaded: null, loop: !1 }, e)).url && (e.url = _(e.url)), Object.freeze(e), new o(u().useLegacy ? new b() : new A(), e);
  }, Object.defineProperty(o.prototype, "context", { get: function() {
    return u().context;
  }, enumerable: !1, configurable: !0 }), o.prototype.pause = function() {
    return this.isPlaying = !1, this.paused = !0, this;
  }, o.prototype.resume = function() {
    return this.isPlaying = this._instances.length > 0, this.paused = !1, this;
  }, Object.defineProperty(o.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(t) {
    this._paused = t, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(t) {
    this._speed = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "filters", { get: function() {
    return this.media.filters;
  }, set: function(t) {
    this.media.filters = t;
  }, enumerable: !1, configurable: !0 }), o.prototype.addSprites = function(t, e) {
    if (typeof t == "object") {
      var r = {};
      for (var S in t)
        r[S] = this.addSprites(S, t[S]);
      return r;
    }
    var T = new v(this, e);
    return this._sprites[t] = T, T;
  }, o.prototype.destroy = function() {
    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;
  }, o.prototype.removeSprites = function(t) {
    if (t) {
      var e = this._sprites[t];
      e !== void 0 && (e.destroy(), delete this._sprites[t]);
    } else
      for (var r in this._sprites)
        this.removeSprites(r);
    return this;
  }, Object.defineProperty(o.prototype, "isPlayable", { get: function() {
    return this.isLoaded && this.media && this.media.isPlayable;
  }, enumerable: !1, configurable: !0 }), o.prototype.stop = function() {
    if (!this.isPlayable)
      return this.autoPlay = !1, this._autoPlayOptions = null, this;
    this.isPlaying = !1;
    for (var t = this._instances.length - 1; t >= 0; t--)
      this._instances[t].stop();
    return this;
  }, o.prototype.play = function(t, e) {
    var r, S = this;
    if (typeof t == "string" ? r = { sprite: D = t, loop: this.loop, complete: e } : typeof t == "function" ? (r = {}).complete = t : r = t, (r = l({ complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: !1, loop: !1 }, r || {})).sprite) {
      var T = r.sprite, D = this._sprites[T];
      r.start = D.start + (r.start || 0), r.end = D.end, r.speed = D.speed || 1, r.loop = D.loop || r.loop, delete r.sprite;
    }
    if (r.offset && (r.start = r.offset), !this.isLoaded)
      return new Promise(function(B, $) {
        S.autoPlay = !0, S._autoPlayOptions = r, S._preload(function(U, H, V) {
          U ? $(U) : (r.loaded && r.loaded(U, H, V), B(V));
        });
      });
    (this.singleInstance || r.singleInstance) && this._removeInstances();
    var N = this._createInstance();
    return this._instances.push(N), this.isPlaying = !0, N.once("end", function() {
      r.complete && r.complete(S), S._onComplete(N);
    }), N.once("stop", function() {
      S._onComplete(N);
    }), N.play(r), N;
  }, o.prototype.refresh = function() {
    for (var t = this._instances.length, e = 0; e < t; e++)
      this._instances[e].refresh();
  }, o.prototype.refreshPaused = function() {
    for (var t = this._instances.length, e = 0; e < t; e++)
      this._instances[e].refreshPaused();
  }, Object.defineProperty(o.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(t) {
    this._volume = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(t) {
    this._muted = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(t) {
    this._loop = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), o.prototype._preload = function(t) {
    this.media.load(t);
  }, Object.defineProperty(o.prototype, "instances", { get: function() {
    return this._instances;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "sprites", { get: function() {
    return this._sprites;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "duration", { get: function() {
    return this.media.duration;
  }, enumerable: !1, configurable: !0 }), o.prototype.autoPlayStart = function() {
    var t;
    return this.autoPlay && (t = this.play(this._autoPlayOptions)), t;
  }, o.prototype._removeInstances = function() {
    for (var t = this._instances.length - 1; t >= 0; t--)
      this._poolInstance(this._instances[t]);
    this._instances.length = 0;
  }, o.prototype._onComplete = function(t) {
    if (this._instances) {
      var e = this._instances.indexOf(t);
      e > -1 && this._instances.splice(e, 1), this.isPlaying = this._instances.length > 0;
    }
    this._poolInstance(t);
  }, o.prototype._createInstance = function() {
    if (o._pool.length > 0) {
      var t = o._pool.pop();
      return t.init(this.media), t;
    }
    return this.media.create();
  }, o.prototype._poolInstance = function(t) {
    t.destroy(), o._pool.indexOf(t) < 0 && o._pool.push(t);
  }, o._pool = [], o;
}(), C = function(o) {
  function t() {
    var e = o !== null && o.apply(this, arguments) || this;
    return e.speed = 1, e.muted = !1, e.volume = 1, e.paused = !1, e;
  }
  return c(t, o), t.prototype.refresh = function() {
    this.emit("refresh");
  }, t.prototype.refreshPaused = function() {
    this.emit("refreshPaused");
  }, Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "audioContext", { get: function() {
    return null;
  }, enumerable: !1, configurable: !0 }), t.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, t.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this.paused;
  }, t.prototype.destroy = function() {
    this.removeAllListeners();
  }, t;
}(eventemitter3Exports), E = function(o) {
  function t() {
    var e = this, r = window, S = new t.AudioContext(), T = S.createDynamicsCompressor(), D = S.createAnalyser();
    return D.connect(T), T.connect(S.destination), (e = o.call(this, D, T) || this)._ctx = S, e._offlineCtx = new t.OfflineAudioContext(1, 2, r.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, S.sampleRate)) : 44100), e._unlocked = !1, e.compressor = T, e.analyser = D, e.events = new eventemitter3Exports(), e.volume = 1, e.speed = 1, e.muted = !1, e.paused = !1, S.state !== "running" && (e._unlock(), e._unlock = e._unlock.bind(e), document.addEventListener("mousedown", e._unlock, !0), document.addEventListener("touchstart", e._unlock, !0), document.addEventListener("touchend", e._unlock, !0)), e;
  }
  return c(t, o), t.prototype._unlock = function() {
    this._unlocked || (this.playEmptySound(), this._ctx.state === "running" && (document.removeEventListener("mousedown", this._unlock, !0), document.removeEventListener("touchend", this._unlock, !0), document.removeEventListener("touchstart", this._unlock, !0), this._unlocked = !0));
  }, t.prototype.playEmptySound = function() {
    var e = this._ctx.createBufferSource();
    e.buffer = this._ctx.createBuffer(1, 1, 22050), e.connect(this._ctx.destination), e.start(0, 0, 0), e.context.state === "suspended" && e.context.resume();
  }, Object.defineProperty(t, "AudioContext", { get: function() {
    var e = window;
    return e.AudioContext || e.webkitAudioContext || null;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "OfflineAudioContext", { get: function() {
    var e = window;
    return e.OfflineAudioContext || e.webkitOfflineAudioContext || null;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    o.prototype.destroy.call(this);
    var e = this._ctx;
    e.close !== void 0 && e.close(), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;
  }, Object.defineProperty(t.prototype, "audioContext", { get: function() {
    return this._ctx;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "offlineContext", { get: function() {
    return this._offlineCtx;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    e && this._ctx.state === "running" ? this._ctx.suspend() : e || this._ctx.state !== "suspended" || this._ctx.resume(), this._paused = e;
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    this.events.emit("refresh");
  }, t.prototype.refreshPaused = function() {
    this.events.emit("refreshPaused");
  }, t.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, t.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this._paused;
  }, t.prototype.decode = function(e, r) {
    var S = function(D) {
      r(new Error((D == null ? void 0 : D.message) || "Unable to decode file"));
    }, T = this._offlineCtx.decodeAudioData(e, function(D) {
      r(null, D);
    }, S);
    T && T.catch(S);
  }, t;
}(j), L = function() {
  function o() {
    this.init();
  }
  return o.prototype.init = function() {
    return this.supported && (this._webAudioContext = new E()), this._htmlAudioContext = new C(), this._sounds = {}, this.useLegacy = !this.supported, this;
  }, Object.defineProperty(o.prototype, "context", { get: function() {
    return this._context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "filtersAll", { get: function() {
    return this.useLegacy ? [] : this._context.filters;
  }, set: function(t) {
    this.useLegacy || (this._context.filters = t);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "supported", { get: function() {
    return E.AudioContext !== null;
  }, enumerable: !1, configurable: !0 }), o.prototype.add = function(t, e) {
    if (typeof t == "object") {
      var r = {};
      for (var S in t) {
        var T = this._getOptions(t[S], e);
        r[S] = this.add(S, T);
      }
      return r;
    }
    if (e instanceof F)
      return this._sounds[t] = e, e;
    var D = this._getOptions(e), N = F.from(D);
    return this._sounds[t] = N, N;
  }, o.prototype._getOptions = function(t, e) {
    var r;
    return r = typeof t == "string" ? { url: t } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? { source: t } : t, r = l(l({}, r), e || {});
  }, Object.defineProperty(o.prototype, "useLegacy", { get: function() {
    return this._useLegacy;
  }, set: function(t) {
    y.setLegacy(t), this._useLegacy = t, this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext;
  }, enumerable: !1, configurable: !0 }), o.prototype.remove = function(t) {
    return this.exists(t, !0), this._sounds[t].destroy(), delete this._sounds[t], this;
  }, Object.defineProperty(o.prototype, "volumeAll", { get: function() {
    return this._context.volume;
  }, set: function(t) {
    this._context.volume = t, this._context.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "speedAll", { get: function() {
    return this._context.speed;
  }, set: function(t) {
    this._context.speed = t, this._context.refresh();
  }, enumerable: !1, configurable: !0 }), o.prototype.togglePauseAll = function() {
    return this._context.togglePause();
  }, o.prototype.pauseAll = function() {
    return this._context.paused = !0, this._context.refreshPaused(), this;
  }, o.prototype.resumeAll = function() {
    return this._context.paused = !1, this._context.refreshPaused(), this;
  }, o.prototype.toggleMuteAll = function() {
    return this._context.toggleMute();
  }, o.prototype.muteAll = function() {
    return this._context.muted = !0, this._context.refresh(), this;
  }, o.prototype.unmuteAll = function() {
    return this._context.muted = !1, this._context.refresh(), this;
  }, o.prototype.removeAll = function() {
    for (var t in this._sounds)
      this._sounds[t].destroy(), delete this._sounds[t];
    return this;
  }, o.prototype.stopAll = function() {
    for (var t in this._sounds)
      this._sounds[t].stop();
    return this;
  }, o.prototype.exists = function(t, e) {
    return !!this._sounds[t];
  }, o.prototype.find = function(t) {
    return this.exists(t, !0), this._sounds[t];
  }, o.prototype.play = function(t, e) {
    return this.find(t).play(e);
  }, o.prototype.stop = function(t) {
    return this.find(t).stop();
  }, o.prototype.pause = function(t) {
    return this.find(t).pause();
  }, o.prototype.resume = function(t) {
    return this.find(t).resume();
  }, o.prototype.volume = function(t, e) {
    var r = this.find(t);
    return e !== void 0 && (r.volume = e), r.volume;
  }, o.prototype.speed = function(t, e) {
    var r = this.find(t);
    return e !== void 0 && (r.speed = e), r.speed;
  }, o.prototype.duration = function(t) {
    return this.find(t).duration;
  }, o.prototype.close = function() {
    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;
  }, o;
}(), k = function() {
  function o(t, e) {
    this.init(t, e);
  }
  return o.prototype.init = function(t, e) {
    this.destination = t, this.source = e || t;
  }, o.prototype.connect = function(t) {
    this.source.connect(t);
  }, o.prototype.disconnect = function() {
    this.source.disconnect();
  }, o.prototype.destroy = function() {
    this.disconnect(), this.destination = null, this.source = null;
  }, o;
}(), M = { __proto__: null, Filter: k, EqualizerFilter: function(o) {
  function t(e, r, S, T, D, N, B, $, U, H) {
    e === void 0 && (e = 0), r === void 0 && (r = 0), S === void 0 && (S = 0), T === void 0 && (T = 0), D === void 0 && (D = 0), N === void 0 && (N = 0), B === void 0 && (B = 0), $ === void 0 && ($ = 0), U === void 0 && (U = 0), H === void 0 && (H = 0);
    var V = this;
    if (!u().useLegacy) {
      var X = [{ f: t.F32, type: "lowshelf", gain: e }, { f: t.F64, type: "peaking", gain: r }, { f: t.F125, type: "peaking", gain: S }, { f: t.F250, type: "peaking", gain: T }, { f: t.F500, type: "peaking", gain: D }, { f: t.F1K, type: "peaking", gain: N }, { f: t.F2K, type: "peaking", gain: B }, { f: t.F4K, type: "peaking", gain: $ }, { f: t.F8K, type: "peaking", gain: U }, { f: t.F16K, type: "highshelf", gain: H }].map(function(q) {
        var K = u().context.audioContext.createBiquadFilter();
        return K.type = q.type, P.setParamValue(K.Q, 1), K.frequency.value = q.f, P.setParamValue(K.gain, q.gain), K;
      });
      (V = o.call(this, X[0], X[X.length - 1]) || this).bands = X, V.bandsMap = {};
      for (var W = 0; W < V.bands.length; W++) {
        var Y = V.bands[W];
        W > 0 && V.bands[W - 1].connect(Y), V.bandsMap[Y.frequency.value] = Y;
      }
      return V;
    }
    V = o.call(this, null) || this;
  }
  return c(t, o), t.prototype.setGain = function(e, r) {
    if (r === void 0 && (r = 0), !this.bandsMap[e])
      throw new Error("No band found for frequency ".concat(e));
    P.setParamValue(this.bandsMap[e].gain, r);
  }, t.prototype.getGain = function(e) {
    if (!this.bandsMap[e])
      throw new Error("No band found for frequency ".concat(e));
    return this.bandsMap[e].gain.value;
  }, Object.defineProperty(t.prototype, "f32", { get: function() {
    return this.getGain(t.F32);
  }, set: function(e) {
    this.setGain(t.F32, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f64", { get: function() {
    return this.getGain(t.F64);
  }, set: function(e) {
    this.setGain(t.F64, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f125", { get: function() {
    return this.getGain(t.F125);
  }, set: function(e) {
    this.setGain(t.F125, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f250", { get: function() {
    return this.getGain(t.F250);
  }, set: function(e) {
    this.setGain(t.F250, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f500", { get: function() {
    return this.getGain(t.F500);
  }, set: function(e) {
    this.setGain(t.F500, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f1k", { get: function() {
    return this.getGain(t.F1K);
  }, set: function(e) {
    this.setGain(t.F1K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f2k", { get: function() {
    return this.getGain(t.F2K);
  }, set: function(e) {
    this.setGain(t.F2K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f4k", { get: function() {
    return this.getGain(t.F4K);
  }, set: function(e) {
    this.setGain(t.F4K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f8k", { get: function() {
    return this.getGain(t.F8K);
  }, set: function(e) {
    this.setGain(t.F8K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f16k", { get: function() {
    return this.getGain(t.F16K);
  }, set: function(e) {
    this.setGain(t.F16K, e);
  }, enumerable: !1, configurable: !0 }), t.prototype.reset = function() {
    this.bands.forEach(function(e) {
      P.setParamValue(e.gain, 0);
    });
  }, t.prototype.destroy = function() {
    this.bands.forEach(function(e) {
      e.disconnect();
    }), this.bands = null, this.bandsMap = null;
  }, t.F32 = 32, t.F64 = 64, t.F125 = 125, t.F250 = 250, t.F500 = 500, t.F1K = 1e3, t.F2K = 2e3, t.F4K = 4e3, t.F8K = 8e3, t.F16K = 16e3, t;
}(k), DistortionFilter: function(o) {
  function t(e) {
    e === void 0 && (e = 0);
    var r = this;
    if (!u().useLegacy) {
      var S = u().context.audioContext.createWaveShaper();
      return (r = o.call(this, S) || this)._distortion = S, r.amount = e, r;
    }
    r = o.call(this, null) || this;
  }
  return c(t, o), Object.defineProperty(t.prototype, "amount", { get: function() {
    return this._amount;
  }, set: function(e) {
    this._amount = e;
    for (var r, S = 1e3 * e, T = 44100, D = new Float32Array(T), N = Math.PI / 180, B = 0; B < T; ++B)
      r = 2 * B / T - 1, D[B] = (3 + S) * r * 20 * N / (Math.PI + S * Math.abs(r));
    this._distortion.curve = D, this._distortion.oversample = "4x";
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this._distortion = null, o.prototype.destroy.call(this);
  }, t;
}(k), StereoFilter: function(o) {
  function t(e) {
    e === void 0 && (e = 0);
    var r = this;
    if (!u().useLegacy) {
      var S, T, D, N = u().context.audioContext;
      return N.createStereoPanner ? D = S = N.createStereoPanner() : ((T = N.createPanner()).panningModel = "equalpower", D = T), (r = o.call(this, D) || this)._stereo = S, r._panner = T, r.pan = e, r;
    }
    r = o.call(this, null) || this;
  }
  return c(t, o), Object.defineProperty(t.prototype, "pan", { get: function() {
    return this._pan;
  }, set: function(e) {
    this._pan = e, this._stereo ? P.setParamValue(this._stereo.pan, e) : this._panner.setPosition(e, 0, 1 - Math.abs(e));
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    o.prototype.destroy.call(this), this._stereo = null, this._panner = null;
  }, t;
}(k), ReverbFilter: function(o) {
  function t(e, r, S) {
    e === void 0 && (e = 3), r === void 0 && (r = 2), S === void 0 && (S = !1);
    var T = this;
    if (!u().useLegacy)
      return (T = o.call(this, null) || this)._seconds = T._clamp(e, 1, 50), T._decay = T._clamp(r, 0, 100), T._reverse = S, T._rebuild(), T;
    T = o.call(this, null) || this;
  }
  return c(t, o), t.prototype._clamp = function(e, r, S) {
    return Math.min(S, Math.max(r, e));
  }, Object.defineProperty(t.prototype, "seconds", { get: function() {
    return this._seconds;
  }, set: function(e) {
    this._seconds = this._clamp(e, 1, 50), this._rebuild();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "decay", { get: function() {
    return this._decay;
  }, set: function(e) {
    this._decay = this._clamp(e, 0, 100), this._rebuild();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "reverse", { get: function() {
    return this._reverse;
  }, set: function(e) {
    this._reverse = e, this._rebuild();
  }, enumerable: !1, configurable: !0 }), t.prototype._rebuild = function() {
    for (var e, r = u().context.audioContext, S = r.sampleRate, T = S * this._seconds, D = r.createBuffer(2, T, S), N = D.getChannelData(0), B = D.getChannelData(1), $ = 0; $ < T; $++)
      e = this._reverse ? T - $ : $, N[$] = (2 * Math.random() - 1) * Math.pow(1 - e / T, this._decay), B[$] = (2 * Math.random() - 1) * Math.pow(1 - e / T, this._decay);
    var U = u().context.audioContext.createConvolver();
    U.buffer = D, this.init(U);
  }, t;
}(k), MonoFilter: function(o) {
  function t() {
    var e = this;
    if (!u().useLegacy) {
      var r = u().context.audioContext, S = r.createChannelSplitter(), T = r.createChannelMerger();
      return T.connect(S), (e = o.call(this, T, S) || this)._merger = T, e;
    }
    e = o.call(this, null) || this;
  }
  return c(t, o), t.prototype.destroy = function() {
    this._merger.disconnect(), this._merger = null, o.prototype.destroy.call(this);
  }, t;
}(k), StreamFilter: function(o) {
  function t() {
    var e = this;
    if (!u().useLegacy) {
      var r = u().context.audioContext, S = r.createMediaStreamDestination(), T = r.createMediaStreamSource(S.stream);
      return (e = o.call(this, S, T) || this)._stream = S.stream, e;
    }
    e = o.call(this, null) || this;
  }
  return c(t, o), Object.defineProperty(t.prototype, "stream", { get: function() {
    return this._stream;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this._stream = null, o.prototype.destroy.call(this);
  }, t;
}(k), TelephoneFilter: function(o) {
  function t() {
    if (!u().useLegacy) {
      var e = u().context.audioContext, r = e.createBiquadFilter(), S = e.createBiquadFilter(), T = e.createBiquadFilter(), D = e.createBiquadFilter();
      return r.type = "lowpass", P.setParamValue(r.frequency, 2e3), S.type = "lowpass", P.setParamValue(S.frequency, 2e3), T.type = "highpass", P.setParamValue(T.frequency, 500), D.type = "highpass", P.setParamValue(D.frequency, 500), r.connect(S), S.connect(T), T.connect(D), o.call(this, r, D) || this;
    }
    o.call(this, null);
  }
  return c(t, o), t;
}(k) }, G = 0, I = { __proto__: null, playOnce: function(o, t) {
  var e = "alias".concat(G++);
  return u().add(e, { url: o, preload: !0, autoPlay: !0, loaded: function(r) {
    r && (u().remove(e), t && t(r));
  }, complete: function() {
    u().remove(e), t && t(null);
  } }), e;
}, get PLAY_ID() {
  return G;
}, render: function(o, t) {
  var e = document.createElement("canvas");
  t = l({ width: 512, height: 128, fill: "black" }, t || {}), e.width = t.width, e.height = t.height;
  var r = BaseTexture.from(e);
  if (!(o.media instanceof A))
    return r;
  var S = o.media, T = e.getContext("2d");
  T.fillStyle = t.fill;
  for (var D = S.buffer.getChannelData(0), N = Math.ceil(D.length / t.width), B = t.height / 2, $ = 0; $ < t.width; $++) {
    for (var U = 1, H = -1, V = 0; V < N; V++) {
      var X = D[$ * N + V];
      X < U && (U = X), X > H && (H = X);
    }
    T.fillRect($, (1 + U) * B, 1, Math.max(1, (H - U) * B));
  }
  return r;
}, resolveUrl: _, sineTone: function(o, t) {
  o === void 0 && (o = 200), t === void 0 && (t = 1);
  var e = F.from({ singleInstance: !0 });
  if (!(e.media instanceof A))
    return e;
  for (var r = e.media, S = e.context.audioContext.createBuffer(1, 48e3 * t, 48e3), T = S.getChannelData(0), D = 0; D < T.length; D++) {
    var N = o * (D / S.sampleRate) * Math.PI;
    T[D] = 2 * Math.sin(N);
  }
  return r.buffer = S, e.isLoaded = !0, e;
}, validateFormats: f, supported: h, extensions: p }, R = function(o) {
  return s = o, o;
}(new L());
"extensions" in n ? extensions.add(y) : Loader.registerPlugin(y);
var Ce, Fe, ki, Xu, ed, Ns, au, Yu, rd, Wu, id, bo, qc, pn, Ua, xo, Kc, Ls, ks, ou, So, Zc, Eo, Bs, lu, qu, nd, Fr, Mi, Ku, sd, To, Jc, vn, ja, Zu, ad, wo, Qc, Ju, od, Qu, ld, Fs, uu;
const Ja = class {
  constructor(t, e, r, S, T) {
    // 音量設定（独自拡張）
    tt(this, Xu);
    tt(this, Ns);
    // BGM/効果音のフェードアウト（loadから使うのでマクロ化禁止）
    tt(this, Yu);
    // 効果音のフェードアウト（loadから使うのでマクロ化禁止）
    tt(this, Wu);
    // BGMのフェード（loadから使うのでマクロ化禁止）
    tt(this, bo);
    // 効果音のフェード
    tt(this, pn);
    // BGM の演奏
    tt(this, xo);
    tt(this, ks);
    tt(this, So);
    // 全効果音再生の停止
    tt(this, Bs);
    // BGM 演奏の停止（loadから使うのでマクロ化禁止）
    tt(this, qu);
    // 効果音再生の停止
    tt(this, Fr);
    // BGM フェードの終了待ち
    tt(this, Ku);
    // 効果音フェードの終了待ち
    tt(this, To);
    // 音声フェードの停止
    tt(this, vn);
    // BGM 再生の終了待ち
    tt(this, Zu);
    // 効果音再生の終了待ち
    tt(this, wo);
    // 再生トラックの交換
    tt(this, Ju);
    tt(this, Qu);
    tt(this, Fs);
    tt(this, Ce, {});
    tt(this, Fe, {});
    tt(this, ki, void 0);
    tt(this, Eo, () => {
      R.volumeAll = Number(this.val.getVal("sys:sn.sound.global_volume", 1)), at(this, Eo, () => {
      });
    });
    this.cfg = t, this.val = r, this.main = S, this.sys = T, e.volume = (D) => lt(this, Xu, ed).call(this, D), e.fadebgm = (D) => lt(this, bo, qc).call(this, D), e.fadeoutbgm = (D) => lt(this, Yu, rd).call(this, D), e.fadeoutse = (D) => lt(this, Wu, id).call(this, D), e.fadese = (D) => lt(this, pn, Ua).call(this, D), e.playbgm = (D) => lt(this, xo, Kc).call(this, D), e.playse = (D) => lt(this, ks, ou).call(this, D), e.stop_allse = () => lt(this, Bs, lu).call(this), e.stopbgm = (D) => lt(this, qu, nd).call(this, D), e.stopse = (D) => lt(this, Fr, Mi).call(this, D), e.wb = (D) => lt(this, Ku, sd).call(this, D), e.wf = (D) => lt(this, To, Jc).call(this, D), e.stopfadese = (D) => lt(this, vn, ja).call(this, D), e.wl = (D) => lt(this, Zu, ad).call(this, D), e.ws = (D) => lt(this, wo, Qc).call(this, D), e.xchgbuf = (D) => lt(this, Ju, od).call(this, D), this.val.setVal_Nochk("save", "const.sn.loopPlaying", "{}"), r.setVal_Nochk("tmp", "const.sn.sound.codecs", JSON.stringify(I.supported));
  }
  setEvtMng(t) {
    at(this, ki, t);
  }
  setNoticeChgVolume(t, e) {
    this.val.defValTrg("sys:sn.sound.global_volume", (r, S) => t(R.volumeAll = Number(S))), this.val.defValTrg("sys:sn.sound.movie_volume", (r, S) => e(Number(S))), this.val.setVal_Nochk("sys", "sn.sound.global_volume", this.val.getVal("sys:sn.sound.global_volume", 1)), this.val.setVal_Nochk("sys", "sn.sound.movie_volume", this.val.getVal("sys:sn.sound.movie_volume", 1));
  }
  clearCache() {
    R.removeAll();
  }
  // しおりの読込（BGM状態復元）
  playLoopFromSaveObj() {
    const t = String(this.val.getVal("save:const.sn.loopPlaying", "{}"));
    if (this.val.flush(), t === "{}") {
      lt(this, Bs, lu).call(this);
      return;
    }
    at(this, Fe, JSON.parse(t));
    const e = Object.keys(z(this, Fe)).map((r) => () => {
      const S = "save:const.sn.sound." + r + ".", T = {
        fn: String(this.val.getVal(S + "fn")),
        buf: r,
        join: !1,
        loop: !0,
        volume: Number(this.val.getVal(S + "volume")),
        start_ms: Number(this.val.getVal(S + "start_ms")),
        end_ms: Number(this.val.getVal(S + "end_ms")),
        ret_ms: Number(this.val.getVal(S + "ret_ms"))
      };
      T.buf === "BGM" ? lt(this, xo, Kc).call(this, T) : lt(this, ks, ou).call(this, T);
    });
    lt(this, Bs, lu).call(this);
    for (const r of e)
      r();
  }
};
let SoundMng = Ja;
Ce = new WeakMap(), Fe = new WeakMap(), ki = new WeakMap(), Xu = new WeakSet(), ed = function(t) {
  const { buf: e = "SE" } = t, r = "const.sn.sound." + e + ".volume", S = lt(this, Ns, au).call(this, t, 1);
  return Number(this.val.getVal("sys:" + r)) === S ? !1 : (this.val.setVal_Nochk("sys", r, S), this.val.flush(), t.time = 0, t.volume = Number(this.val.getVal("save:" + r)), lt(this, pn, Ua).call(this, t));
}, Ns = new WeakSet(), au = function(t, e) {
  const r = argChk_Num(t, "volume", e);
  return r < 0 ? 0 : r > 1 ? 1 : r;
}, Yu = new WeakSet(), rd = function(t) {
  return t.volume = 0, lt(this, bo, qc).call(this, t);
}, Wu = new WeakSet(), id = function(t) {
  return t.volume = 0, lt(this, pn, Ua).call(this, t);
}, bo = new WeakSet(), qc = function(t) {
  return t.buf = "BGM", lt(this, pn, Ua).call(this, t);
}, pn = new WeakSet(), Ua = function(t) {
  lt(this, vn, ja).call(this, t);
  const { buf: e = "SE" } = t, r = z(this, Ce)[e];
  if (!(r != null && r.playing()) || !r.snd)
    return !1;
  const S = "const.sn.sound." + e + ".", T = S + "volume", D = lt(this, Ns, au).call(this, t, NaN);
  this.val.setVal_Nochk("save", T, D);
  const N = D * Number(this.val.getVal("sys:" + T, 1)), B = argChk_Boolean(t, "stop", D === 0);
  B && (lt(this, Fs, uu).call(this, e), this.val.setVal_Nochk("save", S + "fn", "")), this.val.flush();
  const $ = argChk_Num(t, "time", NaN), U = argChk_Num(t, "delay", 0);
  if ($ === 0 && U === 0 || this.val.getVal("tmp:sn.skip.enabled") || z(this, ki).isSkippingByKeyDown())
    return r.snd.volume = N, B && lt(this, Fr, Mi).call(this, t), !1;
  const H = argChk_Num(t, "repeat", 1);
  return r.updFade = (V) => r.snd.volume = V, r.twFade = new Tween({ v: r.snd.volume }).to({ v: N }, $).delay(U).easing(CmnTween.ease(t.ease)).repeat(H === 0 ? 1 / 0 : H - 1).yoyo(argChk_Boolean(t, "yoyo", !1)).onUpdate(({ v: V }) => r.updFade(V)).onComplete(() => {
    const V = z(this, Ce)[r.now_buf];
    (V == null ? void 0 : V.twFade) !== void 0 && (V.updFade = () => {
    }, remove$6(V.twFade), delete V.twFade, B && (t.buf = r.now_buf, lt(this, Fr, Mi).call(this, t)), V.resumeFade && this.main.resume());
  }).start(), !1;
}, xo = new WeakSet(), Kc = function(t) {
  return t.buf = "BGM", t.canskip = !1, argChk_Boolean(t, "loop", !0), lt(this, ks, ou).call(this, t);
}, Ls = new WeakMap(), ks = new WeakSet(), ou = function(t) {
  const { buf: e = "SE", fn: r } = t;
  if (lt(this, Fr, Mi).call(this, { buf: e }), !r)
    throw `[playse] fnは必須です buf:${e}`;
  if (argChk_Boolean(t, "canskip", !0) && z(this, ki).isSkippingByKeyDown())
    return !1;
  const S = argChk_Boolean(t, "loop", !1);
  lt(this, Qu, ld).call(this, e, S);
  const T = "const.sn.sound." + e + ".";
  this.val.setVal_Nochk("save", T + "fn", r);
  const D = lt(this, Ns, au).call(this, t, 1);
  this.val.setVal_Nochk("save", T + "volume", D);
  const N = D * Number(this.val.getVal("sys:" + T + "volume", 1)), B = argChk_Num(t, "start_ms", 0), $ = argChk_Num(t, "end_ms", z(Ja, Ls)), U = argChk_Num(t, "ret_ms", 0), H = argChk_Num(t, "pan", 0), V = argChk_Num(t, "speed", 1);
  if (B < 0)
    throw `[playse] start_ms:${B} が負の値です`;
  if (U < 0)
    throw `[playse] ret_ms:${U} が負の値です`;
  if ($ > 0) {
    if (B >= $)
      throw `[playse] start_ms:${B} >= end_ms:${$} は異常値です`;
    if (U >= $)
      throw `[playse] ret_ms:${U} >= end_ms:${$} は異常値です`;
  }
  this.val.setVal_Nochk("save", T + "start_ms", B), this.val.setVal_Nochk("save", T + "end_ms", $), this.val.setVal_Nochk("save", T + "ret_ms", U), this.val.flush();
  const X = R.find(r), W = z(this, Ce)[e] = {
    now_buf: e,
    snd: X,
    loop: S,
    start_ms: B,
    end_ms: $,
    ret_ms: U,
    resume: !1,
    pan: H,
    playing: () => !0,
    // [ws]的にはここでtrueが欲しい
    updFade: () => {
    },
    onend: () => {
      const Z = W.now_buf, J = z(this, Ce)[Z];
      if (!J)
        return;
      delete z(this, Ce)[Z], J.playing = () => !1;
      const Q = "const.sn.sound." + Z + ".";
      this.val.setVal_Nochk("tmp", Q + "playing", !1), t.buf = Z, lt(this, vn, ja).call(this, t), J.resume && this.main.resume();
    }
  };
  this.val.setVal_Nochk("tmp", T + "playing", !0);
  const Y = {
    loop: S,
    speed: V,
    volume: N,
    loaded: (Z, J) => {
      if (Z) {
        this.main.errScript(`Sound ロード失敗ですa fn:${r} ${Z}`, !1);
        return;
      }
      if (!J)
        return;
      const Q = z(this, Ce)[W.now_buf];
      Q && (Q.snd = J);
    }
  };
  let q = "";
  if (B > 0 || $ < z(Ja, Ls)) {
    q = `${r};${B};${$};${U}`;
    const Z = (Y.sprites ?? (Y.sprites = {}))[q] = {
      start: B / 1e3,
      end: $ / 1e3
    };
    Y.preload = !0;
    const J = Y.loaded;
    Y.loaded = (Q, rt) => {
      J(Q, rt);
      const et = rt, nt = et.duration;
      if (Z.end < 0) {
        if (Z.end += nt, et.removeSprites(q), et.addSprites(q, Z), Z.start >= Z.end)
          throw `[playse] start_ms:${B} >= end_ms:${$}(${Z.end * 1e3}) は異常値です`;
        if (U >= Z.end * 1e3)
          throw `[playse] ret_ms:${U} >= end_ms:${$}(${Z.end * 1e3}) は異常値です`;
      }
      if (Z.start >= nt)
        throw `[playse] start_ms:${B} >= 音声ファイル再生時間:${nt} は異常値です`;
      if ($ !== z(Ja, Ls) && Z.end >= nt)
        throw `[playse] end_ms:${$} >= 音声ファイル再生時間:${nt} は異常値です`;
      et.play(q, Y.complete);
    };
  } else
    Y.autoPlay = !0;
  if (S ? U !== 0 && (Y.loop = !1, Y.complete = async (Z) => {
    const J = Z.duration, Q = U / 1e3, rt = $ / 1e3;
    if (Q >= J)
      throw `[playse] ret_ms:${U} >= 音声ファイル再生時間:${J} は異常値です`;
    await R.play(r, {
      // 一周目はループなし、なのでキャッシュされてる
      start: Q,
      end: rt < 0 ? rt + J : rt,
      // 負の値は末尾から
      speed: V,
      loop: !0,
      volume: N,
      //	sprite	: sp_nm2,	// err
      //-	muted?: boolean;
      filters: W.pan !== 0 ? [new M.StereoFilter(W.pan)] : []
      //-	complete?: CompleteCallback;
      //-	loaded?: LoadedCallback;
      //-	singleInstance?: boolean;
    });
    const et = z(this, Ce)[W.now_buf];
    et && (et.snd = R.find(r));
  }) : Y.complete = () => {
    var Z;
    return (Z = z(this, Ce)[W.now_buf]) == null ? void 0 : Z.onend();
  }, z(this, Eo).call(this), X) {
    if (X.volume = N, q)
      lt(this, So, Zc).call(this, e, r, Y);
    else if (X.isPlayable) {
      const Z = X.options.source;
      !(Z instanceof ArrayBuffer) || Z.byteLength === 0 ? X.play(Y) : W.snd = F.from({
        ...Y,
        url: X.options.url,
        source: Z
      }), X.filters = [new M.StereoFilter(H)];
    }
    return !1;
  }
  const K = argChk_Boolean(t, "join", !0);
  if (K) {
    const Z = Y.loaded;
    Y.loaded = (J, Q) => {
      Z == null || Z(J, Q), this.main.resume();
    };
  }
  return lt(this, So, Zc).call(this, e, r, Y), K;
}, So = new WeakSet(), Zc = function(t, e, r) {
  const S = this.cfg.searchPath(e, SEARCH_PATH_ARG_EXT.SOUND);
  if (S.slice(-4) !== ".bin") {
    r.url = S;
    const T = F.from(r);
    if (t) {
      const D = z(this, Ce)[t];
      if (!D)
        return;
      D.snd = T, D.pan !== 0 && (T.filters = [new M.StereoFilter(D.pan)]);
    }
    r.loop || R.add(e, T);
    return;
  }
  new Loader().add({ name: e, url: S, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).use((T, D) => {
    this.sys.dec(T.extension, T.data).then((N) => {
      T.data = N, D == null || D();
    }).catch((N) => this.main.errScript(`Sound ロード失敗ですc fn:${T.name} ${N}`, !1));
  }).load((T, D) => {
    var B;
    r.source = (B = D[e]) == null ? void 0 : B.data;
    const N = F.from(r);
    if (t) {
      const $ = z(this, Ce)[t];
      if (!$)
        return;
      $.snd = N, $.pan !== 0 && (N.filters = [new M.StereoFilter($.pan)]);
    }
    r.loop || R.add(e, N);
  });
}, Eo = new WeakMap(), Bs = new WeakSet(), lu = function() {
  for (const t of Object.keys(z(this, Ce)))
    lt(this, Fr, Mi).call(this, { buf: t });
  return at(this, Ce, {}), R.stopAll(), !1;
}, qu = new WeakSet(), nd = function(t) {
  return t.buf = "BGM", lt(this, Fr, Mi).call(this, t);
}, Fr = new WeakSet(), Mi = function(t) {
  var S;
  const { buf: e = "SE" } = t;
  lt(this, Fs, uu).call(this, e);
  const r = z(this, Ce)[e];
  return r && ((S = r.snd) == null || S.stop(), r.onend()), !1;
}, Ku = new WeakSet(), sd = function(t) {
  return t.buf = "BGM", lt(this, To, Jc).call(this, t);
}, To = new WeakSet(), Jc = function(t) {
  const { buf: e = "SE" } = t, r = z(this, Ce)[e];
  return !(r != null && r.twFade) || !r.playing() ? !1 : r.resumeFade = z(this, ki).waitEvent(
    () => lt(this, vn, ja).call(this, t),
    argChk_Boolean(t, "canskip", !0),
    argChk_Boolean(t, "global", !1)
  );
}, vn = new WeakSet(), ja = function(t) {
  var r, S;
  const { buf: e = "SE" } = t;
  return (S = (r = z(this, Ce)[e]) == null ? void 0 : r.twFade) == null || S.stop().end(), !1;
}, Zu = new WeakSet(), ad = function(t) {
  return t.buf = "BGM", lt(this, wo, Qc).call(this, t);
}, wo = new WeakSet(), Qc = function(t) {
  const { buf: e = "SE" } = t, r = z(this, Ce)[e];
  return !(r != null && r.playing()) || r.loop ? !1 : r.resume = z(this, ki).waitEvent(
    () => {
      t.buf = r.now_buf, lt(this, Fr, Mi).call(this, t);
      const S = z(this, Ce)[t.buf];
      !(S != null && S.playing()) || S.loop || S.onend();
    },
    argChk_Boolean(t, "canskip", !1),
    argChk_Boolean(t, "global", !1)
  );
}, Ju = new WeakSet(), od = function(t) {
  const { buf: e = "SE", buf2: r = "SE" } = t;
  if (e === r)
    return !1;
  const S = z(this, Ce)[e];
  S && (S.now_buf = r);
  const T = z(this, Ce)[r];
  T && (T.now_buf = e), [z(this, Ce)[e], z(this, Ce)[r]] = [T, S];
  const D = "const.sn.sound." + e + ".", N = Number(this.val.getVal("save:" + D + "volume")), B = Number(this.val.getVal("save:" + D + "fn")), $ = String(this.val.getVal("tmp:" + D + "playing")) === "true", U = "const.sn.sound." + r + ".", H = Number(this.val.getVal("save:" + U + "volume")), V = Number(this.val.getVal("save:" + U + "fn")), X = String(this.val.getVal("tmp:" + U + "playing")) === "true";
  return this.val.setVal_Nochk("save", D + "volume", H), this.val.setVal_Nochk("save", U + "volume", N), this.val.setVal_Nochk("save", D + "fn", V), this.val.setVal_Nochk("save", U + "fn", B), this.val.setVal_Nochk("tmp", D + "playing", X), this.val.setVal_Nochk("tmp", U + "playing", $), e in z(this, Fe) == r in z(this, Fe) && (e in z(this, Fe) ? (delete z(this, Fe)[e], z(this, Fe)[r] = 0) : (delete z(this, Fe)[r], z(this, Fe)[e] = 0), this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(z(this, Fe)))), this.val.flush(), !1;
}, Qu = new WeakSet(), ld = function(t, e) {
  if (!e) {
    lt(this, Fs, uu).call(this, t);
    return;
  }
  z(this, Fe)[t] = 0, this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(z(this, Fe))), this.val.flush();
}, Fs = new WeakSet(), uu = function(t) {
  delete z(this, Fe)[t], this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(z(this, Fe))), this.val.flush();
}, // 効果音の再生
tt(SoundMng, Ls, 999e3);
var _e;
const Af = class {
  constructor(t, e, r, S, T, D, N, B) {
    tt(this, _e, void 0);
    Pt(this, "lay", (t) => this.getPage(t).lay(t));
    Pt(this, "getPage", (t) => Af.argChk_page(t, "fore") !== "back" ? z(this, _e).fore : z(this, _e).back);
    this.cls = e, this.hArg = T, this.sys = D, this.val = N, this.ret = B;
    const $ = D.hFactoryCls[e];
    if (!$)
      throw `属性 class【${e}】が不正です`;
    const U = $(), H = $();
    U.layname = H.layname = t;
    const V = T[":id_tag"] = `layer:${t} cls:${e} page:`;
    U.spLay.name = U.name = V + "A", U.spLay.name = H.name = V + "B", r.addChild(U.spLay), S.addChild(H.spLay), argChk_Boolean(T, "visible", !0), argChk_Boolean(T, "visible", !0), B.isWait = U.lay(T) || H.lay(T), at(this, _e, { fore: U, back: H });
    const X = `const.sn.lay.${t}`;
    N.setVal_Nochk("tmp", X, !0), N.defTmp(X + ".fore.alpha", () => z(this, _e).fore.alpha), N.defTmp(X + ".back.alpha", () => z(this, _e).back.alpha), N.defTmp(X + ".fore.height", () => z(this, _e).fore.height), N.defTmp(X + ".back.height", () => z(this, _e).back.height), N.defTmp(X + ".fore.visible", () => z(this, _e).fore.spLay.visible), N.defTmp(X + ".back.visible", () => z(this, _e).back.spLay.visible), N.defTmp(X + ".fore.width", () => z(this, _e).fore.width), N.defTmp(X + ".back.width", () => z(this, _e).back.width), N.defTmp(X + ".fore.x", () => z(this, _e).fore.x), N.defTmp(X + ".back.x", () => z(this, _e).back.x), N.defTmp(X + ".fore.y", () => z(this, _e).fore.y), N.defTmp(X + ".back.y", () => z(this, _e).back.y);
  }
  destroy() {
    z(this, _e).fore.destroy(), z(this, _e).back.destroy();
  }
  static argChk_page(t, e) {
    const r = t.page ?? e;
    if (r === "fore" || r === "back")
      return t.page = r;
    throw Error("属性 page【" + r + "】が不正です");
  }
  get fore() {
    return z(this, _e).fore;
  }
  get back() {
    return z(this, _e).back;
  }
  transPage(t) {
    [z(this, _e).back, z(this, _e).fore] = [z(this, _e).fore, z(this, _e).back], z(this, _e).back.copy(z(this, _e).fore, t);
  }
};
let Pages = Af;
_e = new WeakMap();
var th, eh;
const Oi = class {
  constructor() {
    Pt(this, "layname", "");
    Pt(this, "name_", "");
    Pt(this, "spLay", new Sprite(Texture.EMPTY));
  }
  set name(t) {
    this.name_ = t;
  }
  get name() {
    return this.name_;
  }
  // tsy用
  get alpha() {
    return this.spLay.alpha;
  }
  set alpha(t) {
    this.spLay.alpha = t;
  }
  get height() {
    return this.spLay.height;
  }
  get rotation() {
    return this.spLay.angle;
  }
  set rotation(t) {
    this.spLay.angle = t;
  }
  get scale_x() {
    return this.spLay.scale.x;
  }
  set scale_x(t) {
    this.spLay.scale.x = t;
  }
  get scale_y() {
    return this.spLay.scale.y;
  }
  set scale_y(t) {
    this.spLay.scale.y = t;
  }
  get width() {
    return this.spLay.width;
  }
  get x() {
    return this.spLay.x;
  }
  set x(t) {
    this.spLay.x = t;
  }
  get y() {
    return this.spLay.y;
  }
  set y(t) {
    this.spLay.y = t;
  }
  destroy() {
  }
  lay(t) {
    return "alpha" in t && (this.spLay.alpha = argChk_Num(t, "alpha", 1)), Oi.setBlendmode(this.spLay, t), ("pivot_x" in t || "pivot_y" in t) && this.spLay.pivot.set(
      argChk_Num(t, "pivot_x", this.spLay.pivot.x),
      argChk_Num(t, "pivot_y", this.spLay.pivot.y)
    ), "rotation" in t && (this.spLay.angle = argChk_Num(t, "rotation", 0)), ("scale_x" in t || "scale_y" in t) && this.spLay.scale.set(
      argChk_Num(t, "scale_x", this.spLay.scale.x),
      argChk_Num(t, "scale_y", this.spLay.scale.y)
    ), "visible" in t && (this.spLay.visible = argChk_Boolean(t, "visible", !0)), !1;
  }
  static setBlendmode(t, e) {
    const { blendmode: r } = e;
    if (!r)
      return;
    const S = Oi.getBlendmodeNum(r);
    t instanceof Sprite && (t.blendMode = S);
    for (const T of t.children)
      T instanceof Sprite && (T.blendMode = S);
  }
  static getBlendmodeNum(t) {
    if (!t)
      return BLEND_MODES.NORMAL;
    const e = z(Oi, th)[t];
    if (e !== void 0)
      return e;
    throw `${t} はサポートされない blendmode です`;
  }
  static getNum2Blendmode(t) {
    return z(Oi, eh)[t] ?? "normal";
  }
  // アニメ・動画があるか
  get containMovement() {
    return !1;
  }
  renderStart() {
  }
  renderEnd() {
  }
  clearLay(t) {
    this.spLay.alpha = 1, this.spLay.blendMode = BLEND_MODES.NORMAL, this.spLay.pivot.set(0, 0), this.spLay.angle = 0, this.spLay.scale.set(1, 1), argChk_Boolean(t, "filter", !1) && (this.spLay.filters = []);
  }
  copy(t, e) {
    const r = this.name_;
    this.playback(t.record(), e), this.name = r;
  }
  record() {
    return {
      name: this.name_,
      idx: this.spLay.parent.getChildIndex(this.spLay),
      alpha: this.spLay.alpha,
      blendMode: this.spLay.blendMode,
      rotation: this.spLay.angle,
      scale_x: this.spLay.scale.x,
      scale_y: this.spLay.scale.y,
      pivot_x: this.spLay.pivot.x,
      pivot_y: this.spLay.pivot.y,
      x: this.spLay.x,
      y: this.spLay.y,
      visible: this.spLay.visible
    };
  }
  playback(t, e) {
    this.name = t.name, this.clearLay({ filter: "true" }), this.spLay.alpha = t.alpha, this.spLay.blendMode = t.blendMode, this.spLay.angle = t.rotation, this.spLay.scale.set(t.scale_x, t.scale_y), this.spLay.pivot.set(t.pivot_x, t.pivot_y), this.spLay.position.set(t.x, t.y), this.spLay.visible = t.visible;
  }
  snapshot(t, e) {
    t.render(this.spLay, { clear: !1 }), e();
  }
  snapshot_end() {
  }
  makeDesignCast(t) {
  }
  makeDesignCastChildren(t) {
  }
  showDesignCast() {
  }
  showDesignCastChildren() {
  }
  cvsResize() {
  }
  cvsResizeChildren() {
  }
  dump() {
    return ` "idx":${this.spLay.parent.getChildIndex(this.spLay)}, "visible":"${this.spLay.visible}", "left":${this.spLay.x}, "top":${this.spLay.y}, "alpha":${this.spLay.alpha}, "rotation":${this.spLay.angle}, "name":"${this.name_}", "scale_x":${this.spLay.scale.x}, "scale_y":${this.spLay.scale.y}`;
  }
  static setXY(t, e, r, S = !1, T = !1) {
    if (e.pos) {
      Oi.setXYByPos(t, e.pos, r);
      return;
    }
    const D = t.getBounds(), N = r.scale.x < 0 ? -r.scale.x : r.scale.x, B = N === 1 ? D.width : D.width * N, $ = r.scale.y < 0 ? -r.scale.y : r.scale.y, U = $ === 1 ? D.height : D.height * $;
    let H = r.x;
    "left" in e ? (H = argChk_Num(e, "left", 0), H > -1 && H < 1 && (H *= CmnLib.stageW)) : "center" in e ? (H = argChk_Num(e, "center", 0), H > -1 && H < 1 && (H *= CmnLib.stageW), H = H - (T ? B / 3 : B) / 2) : "right" in e ? (H = argChk_Num(e, "right", 0), H > -1 && H < 1 && (H *= CmnLib.stageW), H = H - (T ? B / 3 : B)) : "s_right" in e && (H = argChk_Num(e, "s_right", 0), H > -1 && H < 1 && (H *= CmnLib.stageW), H = CmnLib.stageW - H - (T ? B / 3 : B)), r.x = int(r.scale.x < 0 ? H + (T ? B / 3 : B) : H);
    let V = r.y;
    "top" in e ? (V = argChk_Num(e, "top", 0), V > -1 && V < 1 && (V *= CmnLib.stageH)) : "middle" in e ? (V = argChk_Num(e, "middle", 0), V > -1 && V < 1 && (V *= CmnLib.stageH), V = V - U / 2) : "bottom" in e ? (V = argChk_Num(e, "bottom", 0), V > -1 && V < 1 && (V *= CmnLib.stageH), V = V - U) : "s_bottom" in e && (V = argChk_Num(e, "s_bottom", 0), V > -1 && V < 1 && (V *= CmnLib.stageH), V = CmnLib.stageH - V - U), r.y = int(r.scale.y < 0 ? V + U : V), S && !("left" in e) && !("center" in e) && !("right" in e) && !("s_right" in e) && !("top" in e) && !("middle" in e) && !("bottom" in e) && !("s_bottom" in e) && Oi.setXYByPos(t, "c", r);
  }
  static setXYByPos(t, e, r) {
    if (e === "stay")
      return;
    if (t === void 0)
      throw "setXYByPos base === undefined";
    if (r === void 0)
      throw "setXYByPos result === undefined";
    const S = t.getBounds(), T = r.scale.x < 0 ? -r.scale.x : r.scale.x, D = T === 1 ? S.width : S.width * T, N = r.scale.y < 0 ? -r.scale.y : r.scale.y, B = N === 1 ? S.height : S.height * N;
    let $ = 0;
    !e || e === "c" ? $ = CmnLib.stageW * 0.5 : e === "r" ? $ = CmnLib.stageW - D * 0.5 : e === "l" ? $ = D * 0.5 : $ = int(e), r.x = int($ - D * 0.5), r.y = CmnLib.stageH - B, r.scale.x < 0 && (r.x += D), r.scale.y < 0 && (r.y += B);
  }
  static setXYCenter(t) {
    const e = t.getBounds();
    t.x = (CmnLib.stageW - e.width) * 0.5, t.y = (CmnLib.stageH - e.height) * 0.5;
  }
};
let Layer = Oi;
th = new WeakMap(), eh = new WeakMap(), tt(Layer, th, {
  normal: BLEND_MODES.NORMAL,
  add: BLEND_MODES.ADD,
  multiply: BLEND_MODES.MULTIPLY,
  screen: BLEND_MODES.SCREEN
  /*
  		'overlay'		: BLEND_MODES.OVERLAY,
  		'darken'		: BLEND_MODES.DARKEN,
  		'lighten'		: BLEND_MODES.LIGHTEN,
  		'color_dodge'	: BLEND_MODES.COLOR_DODGE,
  		'color_burn'	: BLEND_MODES.COLOR_BURN,
  		'hard_light'	: BLEND_MODES.HARD_LIGHT,
  		'soft_light'	: BLEND_MODES.SOFT_LIGHT,
  		'difference'	: BLEND_MODES.DIFFERENCE,
  		'exclusion'		: BLEND_MODES.EXCLUSION,
  		'hue'			: BLEND_MODES.HUE,
  		'saturation'	: BLEND_MODES.SATURATION,
  		'color'			: BLEND_MODES.COLOR,
  		'luminosity'	: BLEND_MODES.LUMINOSITY,
  
  		'normal_npm'	: BLEND_MODES.NORMAL_NPM,
  		'add_npm'		: BLEND_MODES.ADD_NPM,
  		'screen_npm'	: BLEND_MODES.SCREEN_NPM,
  		'none'			: BLEND_MODES.NONE,
  		'src_in'		: BLEND_MODES.SRC_IN,
  		'src_out'		: BLEND_MODES.SRC_OUT,
  		'src_atop'		: BLEND_MODES.SRC_ATOP,
  		'dst_over'		: BLEND_MODES.DST_OVER,
  		'dst_in'		: BLEND_MODES.DST_IN,
  		'dst_out'		: BLEND_MODES.DST_OUT,
  		'dst_atop'		: BLEND_MODES.DST_ATOP,
  		'subtract'		: BLEND_MODES.SUBTRACT,
  		'src_over'		: BLEND_MODES.SRC_OVER,
  		'erase'			: BLEND_MODES.ERASE,
  		'xor'			: BLEND_MODES.XOR,
  */
}), tt(Layer, eh, {
  0: "normal",
  1: "add",
  2: "multiply",
  3: "screen"
});
function prefixNames(o) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  return t.map(function(r) {
    return r.split(" ").map(function(S) {
      return S ? "" + o + S : "";
    }).join(" ");
  }).join(" ");
}
function prefixCSS(o, t) {
  return t.replace(/([^}{]*){/gm, function(e, r) {
    return r.replace(/\.([^{,\s\d.]+)/g, "." + o + "$1") + "{";
  });
}
function ref(o, t) {
  return function(e) {
    e && (o[t] = e);
  };
}
function refs(o, t, e) {
  return function(r) {
    r && (o[t][e] = r);
  };
}
function Properties(o, t) {
  return function(e) {
    var r = e.prototype;
    o.forEach(function(S) {
      t(r, S);
    });
  };
}
function withMethods(o, t) {
  return t === void 0 && (t = {}), function(e, r) {
    o.forEach(function(S) {
      var T = t[S] || S;
      T in e || (e[T] = function() {
        for (var D, N = [], B = 0; B < arguments.length; B++)
          N[B] = arguments[B];
        var $ = (D = this[r])[S].apply(D, N);
        return $ === this[r] ? this : $;
      });
    });
  };
}
var PolyMap = /* @__PURE__ */ function() {
  function o() {
    this.keys = [], this.values = [];
  }
  var t = o.prototype;
  return t.get = function(e) {
    return this.values[this.keys.indexOf(e)];
  }, t.set = function(e, r) {
    var S = this.keys, T = this.values, D = S.indexOf(e), N = D === -1 ? S.length : D;
    S[N] = e, T[N] = r;
  }, o;
}(), HashMap = /* @__PURE__ */ function() {
  function o() {
    this.object = {};
  }
  var t = o.prototype;
  return t.get = function(e) {
    return this.object[e];
  }, t.set = function(e, r) {
    this.object[e] = r;
  }, o;
}(), SUPPORT_MAP = typeof Map == "function", Link = /* @__PURE__ */ function() {
  function o() {
  }
  var t = o.prototype;
  return t.connect = function(e, r) {
    this.prev = e, this.next = r, e && (e.next = this), r && (r.prev = this);
  }, t.disconnect = function() {
    var e = this.prev, r = this.next;
    e && (e.next = r), r && (r.prev = e);
  }, t.getIndex = function() {
    for (var e = this, r = -1; e; )
      e = e.prev, ++r;
    return r;
  }, o;
}();
function orderChanged(o, t) {
  var e = [], r = [];
  return o.forEach(function(S) {
    var T = S[0], D = S[1], N = new Link();
    e[T] = N, r[D] = N;
  }), e.forEach(function(S, T) {
    S.connect(e[T - 1]);
  }), o.filter(function(S, T) {
    return !t[T];
  }).map(function(S, T) {
    var D = S[0], N = S[1];
    if (D === N)
      return [0, 0];
    var B = e[D], $ = r[N - 1], U = B.getIndex();
    B.disconnect(), $ ? B.connect($, $.next) : B.connect(void 0, e[0]);
    var H = B.getIndex();
    return [U, H];
  });
}
var Result = /* @__PURE__ */ function() {
  function o(e, r, S, T, D, N, B, $) {
    this.prevList = e, this.list = r, this.added = S, this.removed = T, this.changed = D, this.maintained = N, this.changedBeforeAdded = B, this.fixed = $;
  }
  var t = o.prototype;
  return Object.defineProperty(t, "ordered", {
    get: function() {
      return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t, "pureChanged", {
    get: function() {
      return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged;
    },
    enumerable: !0,
    configurable: !0
  }), t.caculateOrdered = function() {
    var e = orderChanged(this.changedBeforeAdded, this.fixed), r = this.changed, S = [];
    this.cacheOrdered = e.filter(function(T, D) {
      var N = T[0], B = T[1], $ = r[D], U = $[0], H = $[1];
      if (N !== B)
        return S.push([U, H]), !0;
    }), this.cachePureChanged = S;
  }, o;
}();
function diff$1(o, t, e) {
  var r = SUPPORT_MAP ? Map : e ? HashMap : PolyMap, S = e || function(Z) {
    return Z;
  }, T = [], D = [], N = [], B = o.map(S), $ = t.map(S), U = new r(), H = new r(), V = [], X = [], W = {}, Y = [], q = 0, K = 0;
  return B.forEach(function(Z, J) {
    U.set(Z, J);
  }), $.forEach(function(Z, J) {
    H.set(Z, J);
  }), B.forEach(function(Z, J) {
    var Q = H.get(Z);
    typeof Q > "u" ? (++K, D.push(J)) : W[Q] = K;
  }), $.forEach(function(Z, J) {
    var Q = U.get(Z);
    typeof Q > "u" ? (T.push(J), ++q) : (N.push([Q, J]), K = W[J] || 0, V.push([Q - K, J - q]), X.push(J === Q), Q !== J && Y.push([Q, J]));
  }), D.reverse(), new Result(o, t, T, D, Y, N, V, X);
}
var ListDiffer = /* @__PURE__ */ function() {
  function o(e, r) {
    e === void 0 && (e = []), this.findKeyCallback = r, this.list = [].slice.call(e);
  }
  var t = o.prototype;
  return t.update = function(e) {
    var r = [].slice.call(e), S = diff$1(this.list, r, this.findKeyCallback);
    return this.list = r, S;
  }, o;
}(), FUNCTION$1 = "function", OBJECT = "object", STRING$1 = "string", NUMBER = "number", UNDEFINED = "undefined", IS_WINDOW = typeof window !== UNDEFINED, OPEN_CLOSED_CHARACTERS = [{
  open: "(",
  close: ")"
}, {
  open: '"',
  close: '"'
}, {
  open: "'",
  close: "'"
}, {
  open: '\\"',
  close: '\\"'
}, {
  open: "\\'",
  close: "\\'"
}], TINY_NUM$1 = 1e-7, DEFAULT_UNIT_PRESETS = {
  cm: function(o) {
    return o * 96 / 2.54;
  },
  mm: function(o) {
    return o * 96 / 254;
  },
  in: function(o) {
    return o * 96;
  },
  pt: function(o) {
    return o * 96 / 72;
  },
  pc: function(o) {
    return o * 96 / 6;
  },
  "%": function(o, t) {
    return o * t / 100;
  },
  vw: function(o, t) {
    return t === void 0 && (t = window.innerWidth), o / 100 * t;
  },
  vh: function(o, t) {
    return t === void 0 && (t = window.innerHeight), o / 100 * t;
  },
  vmax: function(o, t) {
    return t === void 0 && (t = Math.max(window.innerWidth, window.innerHeight)), o / 100 * t;
  },
  vmin: function(o, t) {
    return t === void 0 && (t = Math.min(window.innerWidth, window.innerHeight)), o / 100 * t;
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __spreadArrays$3() {
  for (var o = 0, t = 0, e = arguments.length; t < e; t++)
    o += arguments[t].length;
  for (var r = Array(o), S = 0, t = 0; t < e; t++)
    for (var T = arguments[t], D = 0, N = T.length; D < N; D++, S++)
      r[S] = T[D];
  return r;
}
function dot(o, t, e, r) {
  return (o * r + t * e) / (e + r);
}
function isUndefined(o) {
  return typeof o === UNDEFINED;
}
function isObject$2(o) {
  return o && typeof o === OBJECT;
}
function isArray(o) {
  return Array.isArray(o);
}
function isString$1(o) {
  return typeof o === STRING$1;
}
function isNumber(o) {
  return typeof o === NUMBER;
}
function isFunction$3(o) {
  return typeof o === FUNCTION$1;
}
function isEqualSeparator(o, t) {
  var e = o === "" || o == " ", r = t === "" || t == " ";
  return r && e || o === t;
}
function findOpen(o, t, e, r, S) {
  var T = findIgnore(o, t, e);
  return T ? e : findClose(o, t, e + 1, r, S);
}
function findIgnore(o, t, e) {
  if (!o.ignore)
    return null;
  var r = t.slice(Math.max(e - 3, 0), e + 3).join("");
  return new RegExp(o.ignore).exec(r);
}
function findClose(o, t, e, r, S) {
  for (var T = function($) {
    var U = t[$].trim();
    if (U === o.close && !findIgnore(o, t, $))
      return {
        value: $
      };
    var H = $, V = find$1(S, function(X) {
      var W = X.open;
      return W === U;
    });
    if (V && (H = findOpen(V, t, $, r, S)), H === -1)
      return D = $, "break";
    $ = H, D = $;
  }, D, N = e; N < r; ++N) {
    var B = T(N);
    if (N = D, typeof B == "object")
      return B.value;
    if (B === "break")
      break;
  }
  return -1;
}
function splitText(o, t) {
  var e = isString$1(t) ? {
    separator: t
  } : t, r = e.separator, S = r === void 0 ? "," : r, T = e.isSeparateFirst, D = e.isSeparateOnlyOpenClose, N = e.isSeparateOpenClose, B = N === void 0 ? D : N, $ = e.openCloseCharacters, U = $ === void 0 ? OPEN_CLOSED_CHARACTERS : $, H = U.map(function(nt) {
    var st = nt.open, it = nt.close;
    return st === it ? st : st + "|" + it;
  }).join("|"), V = "(\\s*" + S + "\\s*|" + H + "|\\s+)", X = new RegExp(V, "g"), W = o.split(X).filter(Boolean), Y = W.length, q = [], K = [];
  function Z() {
    return K.length ? (q.push(K.join("")), K = [], !0) : !1;
  }
  for (var J = function(nt) {
    var st = W[nt].trim(), it = nt, ot = find$1(U, function(vt) {
      var _t = vt.open;
      return _t === st;
    }), ht = find$1(U, function(vt) {
      var _t = vt.close;
      return _t === st;
    });
    if (ot) {
      if (it = findOpen(ot, W, nt, Y, U), it !== -1 && B)
        return Z() && T || (q.push(W.slice(nt, it + 1).join("")), nt = it, T) ? (Q = nt, "break") : (Q = nt, "continue");
    } else if (ht && !findIgnore(ht, W, nt)) {
      var ct = __spreadArrays$3(U);
      return ct.splice(U.indexOf(ht), 1), {
        value: splitText(o, {
          separator: S,
          isSeparateFirst: T,
          isSeparateOnlyOpenClose: D,
          isSeparateOpenClose: B,
          openCloseCharacters: ct
        })
      };
    } else if (isEqualSeparator(st, S) && !D)
      return Z(), T ? (Q = nt, "break") : (Q = nt, "continue");
    it === -1 && (it = Y - 1), K.push(W.slice(nt, it + 1).join("")), nt = it, Q = nt;
  }, Q, rt = 0; rt < Y; ++rt) {
    var et = J(rt);
    if (rt = Q, typeof et == "object")
      return et.value;
    if (et === "break")
      break;
  }
  return K.length && q.push(K.join("")), q;
}
function splitSpace(o) {
  return splitText(o, "");
}
function splitComma(o) {
  return splitText(o, ",");
}
function splitBracket(o) {
  var t = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(o);
  return !t || t.length < 4 ? {} : {
    prefix: t[1],
    value: t[2],
    suffix: t[3]
  };
}
function splitUnit(o) {
  var t = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(o);
  if (!t)
    return {
      prefix: "",
      unit: "",
      value: NaN
    };
  var e = t[1], r = t[2], S = t[3];
  return {
    prefix: e,
    unit: S,
    value: parseFloat(r)
  };
}
function camelize(o) {
  return o.replace(/[\s-_]([a-z])/g, function(t, e) {
    return e.toUpperCase();
  });
}
function decamelize(o, t) {
  return t === void 0 && (t = "-"), o.replace(/([a-z])([A-Z])/g, function(e, r, S) {
    return "" + r + t + S.toLowerCase();
  });
}
function now$1() {
  return Date.now ? Date.now() : new Date().getTime();
}
function findIndex(o, t, e) {
  e === void 0 && (e = -1);
  for (var r = o.length, S = 0; S < r; ++S)
    if (t(o[S], S, o))
      return S;
  return e;
}
function find$1(o, t, e) {
  var r = findIndex(o, t);
  return r > -1 ? o[r] : e;
}
var requestAnimationFrame$1 = /* @__PURE__ */ function() {
  var o = now$1(), t = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return t ? t.bind(window) : function(e) {
    var r = now$1(), S = setTimeout(function() {
      e(r - o);
    }, 1e3 / 60);
    return S;
  };
}(), cancelAnimationFrame$1 = /* @__PURE__ */ function() {
  var o = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return o ? o.bind(window) : function(t) {
    clearTimeout(t);
  };
}();
function getKeys(o) {
  return Object.keys(o);
}
function convertUnitSize(o, t) {
  var e = splitUnit(o), r = e.value, S = e.unit;
  if (isObject$2(t)) {
    var T = t[S];
    if (T) {
      if (isFunction$3(T))
        return T(r);
      if (DEFAULT_UNIT_PRESETS[S])
        return DEFAULT_UNIT_PRESETS[S](r, T);
    }
  } else if (S === "%")
    return r * t / 100;
  return DEFAULT_UNIT_PRESETS[S] ? DEFAULT_UNIT_PRESETS[S](r) : r;
}
function between(o, t, e) {
  return Math.max(t, Math.min(o, e));
}
function checkBoundSize(o, t, e, r) {
  return r === void 0 && (r = o[0] / o[1]), [[throttle(t[0], TINY_NUM$1), throttle(t[0] / r, TINY_NUM$1)], [throttle(t[1] * r, TINY_NUM$1), throttle(t[1], TINY_NUM$1)]].filter(function(S) {
    return S.every(function(T, D) {
      var N = t[D], B = throttle(N, TINY_NUM$1);
      return e ? T <= N || T <= B : T >= N || T >= B;
    });
  })[0] || o;
}
function calculateBoundSize(o, t, e, r) {
  if (!r)
    return o.map(function(X, W) {
      return between(X, t[W], e[W]);
    });
  var S = o[0], T = o[1], D = r === !0 ? S / T : r, N = checkBoundSize(o, t, !1, D), B = N[0], $ = N[1], U = checkBoundSize(o, e, !0, D), H = U[0], V = U[1];
  return S < B || T < $ ? (S = B, T = $) : (S > H || T > V) && (S = H, T = V), [S, T];
}
function sum(o) {
  for (var t = o.length, e = 0, r = t - 1; r >= 0; --r)
    e += o[r];
  return e;
}
function average(o) {
  for (var t = o.length, e = 0, r = t - 1; r >= 0; --r)
    e += o[r];
  return t ? e / t : 0;
}
function getRad$1(o, t) {
  var e = t[0] - o[0], r = t[1] - o[1], S = Math.atan2(r, e);
  return S >= 0 ? S : S + Math.PI * 2;
}
function getCenterPoint(o) {
  return [0, 1].map(function(t) {
    return average(o.map(function(e) {
      return e[t];
    }));
  });
}
function getShapeDirection(o) {
  var t = getCenterPoint(o), e = getRad$1(t, o[0]), r = getRad$1(t, o[1]);
  return e < r && r - e < Math.PI || e > r && r - e < -Math.PI ? 1 : -1;
}
function getDist$2(o, t) {
  return Math.sqrt(Math.pow((t ? t[0] : 0) - o[0], 2) + Math.pow((t ? t[1] : 0) - o[1], 2));
}
function throttle(o, t) {
  if (!t)
    return o;
  var e = 1 / t;
  return Math.round(o / t) / e;
}
function throttleArray(o, t) {
  return o.forEach(function(e, r) {
    o[r] = throttle(o[r], t);
  }), o;
}
function hasClass(o, t) {
  return o.classList ? o.classList.contains(t) : !!o.className.match(new RegExp("(\\s|^)" + t + "(\\s|$)"));
}
function addClass(o, t) {
  o.classList ? o.classList.add(t) : o.className += " " + t;
}
function removeClass(o, t) {
  if (o.classList)
    o.classList.remove(t);
  else {
    var e = new RegExp("(\\s|^)" + t + "(\\s|$)");
    o.className = o.className.replace(e, " ");
  }
}
function addEvent(o, t, e, r) {
  o.addEventListener(t, e, r);
}
function removeEvent(o, t, e, r) {
  o.removeEventListener(t, e, r);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$6 = function(o, t) {
  return extendStatics$6 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$6(o, t);
};
function __extends$6(o, t) {
  extendStatics$6(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$6 = function() {
  return __assign$6 = Object.assign || function(t) {
    for (var e, r = 1, S = arguments.length; r < S; r++) {
      e = arguments[r];
      for (var T in e)
        Object.prototype.hasOwnProperty.call(e, T) && (t[T] = e[T]);
    }
    return t;
  }, __assign$6.apply(this, arguments);
};
function __rest$2(o, t) {
  var e = {};
  for (var r in o)
    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var S = 0, r = Object.getOwnPropertySymbols(o); S < r.length; S++)
      t.indexOf(r[S]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[S]) && (e[r[S]] = o[r[S]]);
  return e;
}
function __spreadArrays$2() {
  for (var o = 0, t = 0, e = arguments.length; t < e; t++)
    o += arguments[t].length;
  for (var r = Array(o), S = 0, t = 0; t < e; t++)
    for (var T = arguments[t], D = 0, N = T.length; D < N; D++, S++)
      r[S] = T[D];
  return r;
}
function isDiff(o, t) {
  if (o === t)
    return !1;
  for (var e in o)
    if (!(e in t))
      return !0;
  for (var e in t)
    if (o[e] !== t[e])
      return !0;
  return !1;
}
function diffObject(o, t) {
  var e = Object.keys(o), r = Object.keys(t), S = diff$1(e, r, function(B) {
    return B;
  }), T = {}, D = {}, N = {};
  return S.added.forEach(function(B) {
    var $ = r[B];
    T[$] = t[$];
  }), S.removed.forEach(function(B) {
    var $ = e[B];
    D[$] = o[$];
  }), S.maintained.forEach(function(B) {
    var $ = B[0], U = e[$], H = [o[U], t[U]];
    o[U] !== t[U] && (N[U] = H);
  }), {
    added: T,
    removed: D,
    changed: N
  };
}
function executeHooks(o) {
  o.forEach(function(t) {
    t();
  });
}
function fillKeys(o) {
  var t = 0;
  return o.map(function(e) {
    return e == null ? "$compat" + ++t : "" + e;
  });
}
function createProvider(o, t, e, r) {
  if (isString$1(o) || isNumber(o))
    return new TextProvider("text_" + o, t, e, r, null, {});
  var S = typeof o.type == "string" ? ElementProvider : o.type.prototype.render ? ComponentProvider : FunctionProvider;
  return new S(o.type, t, e, r, o.ref, o.props);
}
function flat$1(o) {
  var t = [];
  return o.forEach(function(e) {
    t = t.concat(isArray(e) ? flat$1(e) : e);
  }), t;
}
function getAttributes(o) {
  var t = o.className, e = __rest$2(o, ["className"]);
  return t != null && (e.class = t), delete e.style, delete e.children, e;
}
function fillProps(o, t) {
  if (!t)
    return o;
  for (var e in t)
    isUndefined(o[e]) && (o[e] = t[e]);
  return o;
}
function createElement(o, t) {
  for (var e = [], r = 2; r < arguments.length; r++)
    e[r - 2] = arguments[r];
  var S = t || {}, T = S.key, D = S.ref, N = __rest$2(S, ["key", "ref"]);
  return {
    type: o,
    key: T,
    ref: D,
    props: __assign$6(__assign$6({}, N), {
      children: flat$1(e).filter(function(B) {
        return B != null && B !== !1;
      })
    })
  };
}
var Provider = /* @__PURE__ */ function() {
  function o(e, r, S, T, D, N) {
    N === void 0 && (N = {}), this.type = e, this.key = r, this.index = S, this.container = T, this.ref = D, this.props = N, this._providers = [];
  }
  var t = o.prototype;
  return t._should = function(e, r) {
    return !0;
  }, t._update = function(e, r, S, T) {
    if (this.base && !isString$1(r) && !T && !this._should(r.props, S))
      return !1;
    this.original = r, this._setState(S);
    var D = this.props;
    return isString$1(r) || (this.props = r.props, this.ref = r.ref), this._render(e, this.base ? D : {}, S), !0;
  }, t._mounted = function() {
    var e = this.ref;
    e && e(this.base);
  }, t._setState = function(e) {
  }, t._updated = function() {
    var e = this.ref;
    e && e(this.base);
  }, t._destroy = function() {
    var e = this.ref;
    e && e(null);
  }, o;
}();
function diffAttributes(o, t, e) {
  var r = diffObject(o, t), S = r.added, T = r.removed, D = r.changed;
  for (var N in S)
    e.setAttribute(N, S[N]);
  for (var N in D)
    e.setAttribute(N, D[N][1]);
  for (var N in T)
    e.removeAttribute(N);
}
function diffEvents(o, t, e) {
  var r = diffObject(o, t), S = r.added, T = r.removed, D = r.changed;
  for (var N in T)
    e.removeEventListener(N);
  for (var N in S)
    e.addEventListener(N, S[N]);
  for (var N in D)
    e.removeEventListener(N), e.addEventListener(N, D[N][1]);
  for (var N in T)
    e.removeEventListener(N);
}
function diffStyle(o, t, e) {
  var r = e.style, S = diffObject(o, t), T = S.added, D = S.removed, N = S.changed;
  for (var B in T) {
    var $ = decamelize(B, "-");
    r.setProperty ? r.setProperty($, T[B]) : r[$] = T[B];
  }
  for (var B in N) {
    var $ = decamelize(B, "-");
    r.setProperty ? r.setProperty($, N[B][1]) : r[$] = N[B][1];
  }
  for (var B in D) {
    var $ = decamelize(B, "-");
    r.removeProperty ? r.removeProperty($) : r[$] = "";
  }
}
function splitProps(o) {
  var t = {}, e = {};
  for (var r in o)
    r.indexOf("on") === 0 ? e[r.replace("on", "").toLowerCase()] = o[r] : t[r] = o[r];
  return {
    attributes: t,
    events: e
  };
}
var TextProvider = /* @__PURE__ */ function(o) {
  __extends$6(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e._render = function(r) {
    var S = this, T = !this.base;
    return T && (this.base = document.createTextNode(this.type.replace("text_", ""))), r.push(function() {
      T ? S._mounted() : S._updated();
    }), !0;
  }, e._unmount = function() {
    this.base.parentNode.removeChild(this.base);
  }, t;
}(Provider), ElementProvider = /* @__PURE__ */ function(o) {
  __extends$6(t, o);
  function t() {
    var r = o !== null && o.apply(this, arguments) || this;
    return r.events = {}, r._isSVG = !1, r;
  }
  var e = t.prototype;
  return e.addEventListener = function(r, S) {
    var T = this.events;
    T[r] = function(D) {
      D.nativeEvent = D, S(D);
    }, this.base.addEventListener(r, T[r]);
  }, e.removeEventListener = function(r) {
    var S = this.events;
    this.base.removeEventListener(r, S[r]), delete S[r];
  }, e._should = function(r) {
    return isDiff(this.props, r);
  }, e._render = function(r, S) {
    var T = this, D = !this.base;
    if (D) {
      var N = this._hasSVG();
      this._isSVG = N;
      var B = this.props.portalContainer;
      if (!B) {
        var $ = this.type;
        N ? B = document.createElementNS("http://www.w3.org/2000/svg", $) : B = document.createElement($);
      }
      this.base = B;
    }
    renderProviders(this, this._providers, this.props.children, r, null);
    var U = this.base, H = splitProps(S), V = H.attributes, X = H.events, W = splitProps(this.props), Y = W.attributes, q = W.events;
    return diffAttributes(getAttributes(V), getAttributes(Y), U), diffEvents(X, q, this), diffStyle(S.style || {}, this.props.style || {}, U), r.push(function() {
      D ? T._mounted() : T._updated();
    }), !0;
  }, e._unmount = function() {
    var r = this.events, S = this.base;
    for (var T in r)
      S.removeEventListener(T, r[T]);
    this._providers.forEach(function(D) {
      D._unmount();
    }), this.events = {}, this.props.portalContainer || S.parentNode.removeChild(S);
  }, e._hasSVG = function() {
    if (this._isSVG || this.type === "svg")
      return !0;
    var r = findContainerNode(this.container);
    return r && "ownerSVGElement" in r;
  }, t;
}(Provider);
function findContainerNode(o) {
  if (!o)
    return null;
  var t = o.base;
  return t instanceof Node ? t : findContainerNode(o.container);
}
function findDOMNode(o) {
  if (!o)
    return null;
  if (o instanceof Node)
    return o;
  var t = o.$_provider._providers;
  return t.length ? findDOMNode(t[0].base) : null;
}
var FunctionProvider = /* @__PURE__ */ function(o) {
  __extends$6(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e._render = function(r) {
    var S = this.type(this.props);
    return renderProviders(this, this._providers, S ? [S] : [], r), !0;
  }, e._unmount = function() {
    this._providers.forEach(function(r) {
      r._unmount();
    });
  }, t;
}(Provider), ContainerProvider = /* @__PURE__ */ function(o) {
  __extends$6(t, o);
  function t(r) {
    var S = o.call(this, "container", "container", 0, null) || this;
    return S.base = r, S;
  }
  var e = t.prototype;
  return e._render = function() {
    return !0;
  }, e._unmount = function() {
  }, t;
}(Provider), ComponentProvider = /* @__PURE__ */ function(o) {
  __extends$6(t, o);
  function t(r, S, T, D, N, B) {
    return B === void 0 && (B = {}), o.call(this, r, S, T, D, N, fillProps(B, r.defaultProps)) || this;
  }
  var e = t.prototype;
  return e._should = function(r, S) {
    return this.base.shouldComponentUpdate(fillProps(r, this.type.defaultProps), S || this.base.state);
  }, e._render = function(r, S) {
    var T = this;
    this.props = fillProps(this.props, this.type.defaultProps);
    var D = !this.base;
    D ? (this.base = new this.type(this.props), this.base.$_provider = this) : this.base.props = this.props;
    var N = this.base, B = N.state, $ = N.render();
    $ && $.props && !$.props.children.length && ($.props.children = this.props.children), renderProviders(this, this._providers, $ ? [$] : [], r), r.push(function() {
      D ? (T._mounted(), N.componentDidMount()) : (T._updated(), N.componentDidUpdate(S, B));
    });
  }, e._setState = function(r) {
    var S = this.base;
    !S || !r || (S.state = r);
  }, e._unmount = function() {
    this._providers.forEach(function(r) {
      r._unmount();
    }), clearTimeout(this.base.$_timer), this.base.componentWillUnmount();
  }, t;
}(Provider), Component = /* @__PURE__ */ function() {
  function o(e) {
    e === void 0 && (e = {}), this.props = e, this.state = {}, this.$_timer = 0, this.$_state = {};
  }
  var t = o.prototype;
  return t.shouldComponentUpdate = function(e, r) {
    return !0;
  }, t.render = function() {
    return null;
  }, t.setState = function(e, r, S) {
    var T = this;
    this.$_timer || (this.$_state = {}), clearTimeout(this.$_timer), this.$_timer = 0, this.$_state = __assign$6(__assign$6({}, this.$_state), e), S ? this.$_setState(r, S) : this.$_timer = setTimeout(function() {
      T.$_timer = 0, T.$_setState(r, S);
    });
  }, t.forceUpdate = function(e) {
    this.setState({}, e, !0);
  }, t.componentDidMount = function() {
  }, t.componentDidUpdate = function(e, r) {
  }, t.componentWillUnmount = function() {
  }, t.$_setState = function(e, r) {
    var S = [], T = this.$_provider, D = renderProviders(T.container, [T], [T.original], S, __assign$6(__assign$6({}, this.state), this.$_state), r);
    D && (e && S.push(e), executeHooks(S));
  }, o;
}(), PureComponent = /* @__PURE__ */ function(o) {
  __extends$6(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.shouldComponentUpdate = function(r, S) {
    return isDiff(this.props, r) || isDiff(this.state, S);
  }, t;
}(Component), _Portal = /* @__PURE__ */ function(o) {
  __extends$6(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.componentDidMount = function() {
    var r = this.props, S = r.element, T = r.container;
    this._portalProvider = new ContainerProvider(T), renderProvider(S, T, this._portalProvider);
  }, e.componentDidUpdate = function() {
    var r = this.props, S = r.element, T = r.container;
    renderProvider(S, T, this._portalProvider);
  }, e.componentWillUnmount = function() {
    var r = this.props.container;
    renderProvider(null, r, this._portalProvider), this._portalProvider = null;
  }, t;
}(PureComponent);
function updateProvider(o, t, e) {
  var r = [];
  renderProviders(o, o._providers, t, r, e), executeHooks(r);
}
function getNextSibiling(o, t) {
  for (var e = o._providers, r = e.length, S = t.index + 1; S < r; ++S) {
    var T = findDOMNode(e[S].base);
    if (T)
      return T;
  }
  return null;
}
function diffProviders(o, t, e) {
  var r = e.map(function(B) {
    return isString$1(B) ? null : B.key;
  }), S = fillKeys(t.map(function(B) {
    return B.key;
  })), T = fillKeys(r), D = diff$1(S, T, function(B) {
    return B;
  });
  D.removed.forEach(function(B) {
    t.splice(B, 1)[0]._unmount();
  }), D.ordered.forEach(function(B) {
    var $ = B[0], U = B[1], H = t.splice($, 1)[0];
    t.splice(U, 0, H);
    var V = findDOMNode(H.base), X = findDOMNode(t[U + 1] && t[U + 1].base);
    V && V.parentNode.insertBefore(V, X);
  }), D.added.forEach(function(B) {
    t.splice(B, 0, createProvider(e[B], r[B], B, o));
  });
  var N = D.maintained.filter(function(B) {
    B[0];
    var $ = B[1], U = e[$], H = t[$], V = isString$1(U) ? "text_" + U : U.type;
    return V !== H.type ? (H._unmount(), t.splice($, 1, createProvider(U, r[$], $, o)), !0) : (H.index = $, !1);
  });
  return __spreadArrays$2(D.added, N.map(function(B) {
    B[0];
    var $ = B[1];
    return $;
  }));
}
function renderProviders(o, t, e, r, S, T) {
  var D = diffProviders(o, t, e), N = t.filter(function($, U) {
    return $._update(r, e[U], S, T);
  }), B = findContainerNode(o);
  return B && D.reverse().forEach(function($) {
    var U = t[$], H = findDOMNode(U.base);
    if (H && B !== H && !H.parentNode) {
      var V = getNextSibiling(o, U);
      B.insertBefore(H, V);
    }
  }), N.length > 0;
}
function renderProvider(o, t, e) {
  e === void 0 && (e = t.__REACT_COMPAT__);
  var r = !!e;
  return e || (e = new ContainerProvider(t)), updateProvider(e, o ? [o] : []), r || (t.__REACT_COMPAT__ = e), e;
}
function render(o, t, e) {
  var r = t.__REACT_COMPAT__;
  o && !r && (t.innerHTML = ""), renderProvider(o, t, r), e && e();
}
function createPortal(o, t) {
  return createElement(_Portal, {
    element: o,
    container: t
  });
}
var version = "simple-1.1.0";
function some(o, t) {
  for (var e = o.length, r = 0; r < e; ++r)
    if (t(o[r], r))
      return !0;
  return !1;
}
function find(o, t) {
  for (var e = o.length, r = 0; r < e; ++r)
    if (t(o[r], r))
      return o[r];
  return null;
}
function getUserAgentString(o) {
  var t = o;
  if (typeof t > "u") {
    if (typeof navigator > "u" || !navigator)
      return "";
    t = navigator.userAgent || "";
  }
  return t.toLowerCase();
}
function execRegExp(o, t) {
  try {
    return new RegExp(o, "g").exec(t);
  } catch {
    return null;
  }
}
function hasUserAgentData() {
  if (typeof navigator > "u" || !navigator || !navigator.userAgentData)
    return !1;
  var o = navigator.userAgentData, t = o.brands || o.uaList;
  return !!(t && t.length);
}
function findVersion(o, t) {
  var e = execRegExp("(" + o + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", t);
  return e ? e[3] : "";
}
function convertVersion(o) {
  return o.replace(/_/g, ".");
}
function findPreset(o, t) {
  var e = null, r = "-1";
  return some(o, function(S) {
    var T = execRegExp("(" + S.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", t);
    return !T || S.brand ? !1 : (e = S, r = T[3] || "-1", S.versionAlias ? r = S.versionAlias : S.versionTest && (r = findVersion(S.versionTest.toLowerCase(), t) || r), r = convertVersion(r), !0);
  }), {
    preset: e,
    version: r
  };
}
function findPresetBrand(o, t) {
  var e = {
    brand: "",
    version: "-1"
  };
  return some(o, function(r) {
    var S = findBrand(t, r);
    return S ? (e.brand = r.id, e.version = r.versionAlias || S.version, e.version !== "-1") : !1;
  }), e;
}
function findBrand(o, t) {
  return find(o, function(e) {
    var r = e.brand;
    return execRegExp("" + t.test, r.toLowerCase());
  });
}
var BROWSER_PRESETS = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}], CHROMIUM_PRESETS = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: !0
}], WEBKIT_PRESETS = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}], WEBVIEW_PRESETS = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}], OS_PRESETS = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];
function isWebView(o) {
  return !!findPreset(WEBVIEW_PRESETS, o).preset;
}
function getLegacyAgent(o) {
  var t = getUserAgentString(o), e = !!/mobi/g.exec(t), r = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: isWebView(t),
    chromium: !1,
    chromiumVersion: "-1",
    webkit: !1,
    webkitVersion: "-1"
  }, S = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  }, T = findPreset(BROWSER_PRESETS, t), D = T.preset, N = T.version, B = findPreset(OS_PRESETS, t), $ = B.preset, U = B.version, H = findPreset(CHROMIUM_PRESETS, t);
  if (r.chromium = !!H.preset, r.chromiumVersion = H.version, !r.chromium) {
    var V = findPreset(WEBKIT_PRESETS, t);
    r.webkit = !!V.preset, r.webkitVersion = V.version;
  }
  return $ && (S.name = $.id, S.version = U, S.majorVersion = parseInt(U, 10)), D && (r.name = D.id, r.version = N, r.webview && S.name === "ios" && r.name !== "safari" && (r.webview = !1)), r.majorVersion = parseInt(r.version, 10), {
    browser: r,
    os: S,
    isMobile: e,
    isHints: !1
  };
}
function getClientHintsAgent(o) {
  var t = navigator.userAgentData, e = (t.uaList || t.brands).slice(), r = o && o.fullVersionList, S = t.mobile || !1, T = e[0], D = (o && o.platform || t.platform || navigator.platform).toLowerCase(), N = {
    name: T.brand,
    version: T.version,
    majorVersion: -1,
    webkit: !1,
    webkitVersion: "-1",
    chromium: !1,
    chromiumVersion: "-1",
    webview: !!findPresetBrand(WEBVIEW_PRESETS, e).brand || isWebView(getUserAgentString())
  }, B = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  N.webkit = !N.chromium && some(WEBKIT_PRESETS, function(W) {
    return findBrand(e, W);
  });
  var $ = findPresetBrand(CHROMIUM_PRESETS, e);
  if (N.chromium = !!$.brand, N.chromiumVersion = $.version, !N.chromium) {
    var U = findPresetBrand(WEBKIT_PRESETS, e);
    N.webkit = !!U.brand, N.webkitVersion = U.version;
  }
  var H = find(OS_PRESETS, function(W) {
    return new RegExp("" + W.test, "g").exec(D);
  });
  if (B.name = H ? H.id : "", o && (B.version = o.platformVersion), r && r.length) {
    var V = findPresetBrand(BROWSER_PRESETS, r);
    N.name = V.brand || N.name, N.version = V.version || N.version;
  } else {
    var X = findPresetBrand(BROWSER_PRESETS, e);
    N.name = X.brand || N.name, N.version = X.brand && o ? o.uaFullVersion : X.version;
  }
  return N.webkit && (B.name = S ? "ios" : "mac"), B.name === "ios" && N.webview && (N.version = "-1"), B.version = convertVersion(B.version), N.version = convertVersion(N.version), B.majorVersion = parseInt(B.version, 10), N.majorVersion = parseInt(N.version, 10), {
    browser: N,
    os: B,
    isMobile: S,
    isHints: !0
  };
}
function agent$1(o) {
  return typeof o > "u" && hasUserAgentData() ? getClientHintsAgent() : getLegacyAgent(o);
}
function add(o, t, e, r, S, T) {
  for (var D = 0; D < S; ++D) {
    var N = e + D * S, B = r + D * S;
    o[N] += o[B] * T, t[N] += t[B] * T;
  }
}
function swap(o, t, e, r, S) {
  for (var T = 0; T < S; ++T) {
    var D = e + T * S, N = r + T * S, B = o[D], $ = t[D];
    o[D] = o[N], o[N] = B, t[D] = t[N], t[N] = $;
  }
}
function divide(o, t, e, r, S) {
  for (var T = 0; T < r; ++T) {
    var D = e + T * r;
    o[D] /= S, t[D] /= S;
  }
}
function ignoreDimension(o, t, e) {
  e === void 0 && (e = Math.sqrt(o.length));
  for (var r = o.slice(), S = 0; S < e; ++S)
    r[S * e + t - 1] = 0, r[(t - 1) * e + S] = 0;
  return r[(t - 1) * (e + 1)] = 1, r;
}
function invert(o, t) {
  t === void 0 && (t = Math.sqrt(o.length));
  for (var e = o.slice(), r = createIdentityMatrix(t), S = 0; S < t; ++S) {
    var T = t * S + S;
    if (!throttle(e[T], TINY_NUM$1)) {
      for (var D = S + 1; D < t; ++D)
        if (e[t * S + D]) {
          swap(e, r, S, D, t);
          break;
        }
    }
    if (!throttle(e[T], TINY_NUM$1))
      return [];
    divide(e, r, S, t, e[T]);
    for (var D = 0; D < t; ++D) {
      var N = D, B = D + S * t, $ = e[B];
      !throttle($, TINY_NUM$1) || S === D || add(e, r, N, S, t, -$);
    }
  }
  return r;
}
function transpose(o, t) {
  t === void 0 && (t = Math.sqrt(o.length));
  for (var e = [], r = 0; r < t; ++r)
    for (var S = 0; S < t; ++S)
      e[S * t + r] = o[t * r + S];
  return e;
}
function getOrigin(o, t) {
  t === void 0 && (t = Math.sqrt(o.length));
  for (var e = [], r = o[t * t - 1], S = 0; S < t - 1; ++S)
    e[S] = o[t * (t - 1) + S] / r;
  return e[t - 1] = 0, e;
}
function fromTranslation(o, t) {
  for (var e = createIdentityMatrix(t), r = 0; r < t - 1; ++r)
    e[t * (t - 1) + r] = o[r] || 0;
  return e;
}
function convertPositionMatrix(o, t) {
  for (var e = o.slice(), r = o.length; r < t - 1; ++r)
    e[r] = 0;
  return e[t - 1] = 1, e;
}
function convertDimension(o, t, e) {
  if (t === void 0 && (t = Math.sqrt(o.length)), t === e)
    return o;
  for (var r = createIdentityMatrix(e), S = Math.min(t, e), T = 0; T < S - 1; ++T) {
    for (var D = 0; D < S - 1; ++D)
      r[T * e + D] = o[T * t + D];
    r[(T + 1) * e - 1] = o[(T + 1) * t - 1], r[(e - 1) * e + T] = o[(t - 1) * t + T];
  }
  return r[e * e - 1] = o[t * t - 1], r;
}
function multiplies(o) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  var r = createIdentityMatrix(o);
  return t.forEach(function(S) {
    r = multiply(r, S, o);
  }), r;
}
function multiply(o, t, e) {
  e === void 0 && (e = Math.sqrt(o.length));
  var r = [], S = o.length / e, T = t.length / S;
  if (S) {
    if (!T)
      return o;
  } else
    return t;
  for (var D = 0; D < e; ++D)
    for (var N = 0; N < T; ++N) {
      r[N * e + D] = 0;
      for (var B = 0; B < S; ++B)
        r[N * e + D] += o[B * e + D] * t[N * S + B];
    }
  return r;
}
function plus(o, t) {
  for (var e = Math.min(o.length, t.length), r = o.slice(), S = 0; S < e; ++S)
    r[S] = r[S] + t[S];
  return r;
}
function minus(o, t) {
  for (var e = Math.min(o.length, t.length), r = o.slice(), S = 0; S < e; ++S)
    r[S] = r[S] - t[S];
  return r;
}
function convertCSStoMatrix(o, t) {
  return t === void 0 && (t = o.length === 6), t ? [o[0], o[1], 0, o[2], o[3], 0, o[4], o[5], 1] : o;
}
function convertMatrixtoCSS(o, t) {
  return t === void 0 && (t = o.length === 9), t ? [o[0], o[1], o[3], o[4], o[6], o[7]] : o;
}
function calculate(o, t, e) {
  e === void 0 && (e = t.length);
  var r = multiply(o, t, e), S = r[e - 1];
  return r.map(function(T) {
    return T / S;
  });
}
function rotateX3d(o, t) {
  return multiply(o, [1, 0, 0, 0, 0, Math.cos(t), Math.sin(t), 0, 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1], 4);
}
function rotateY3d(o, t) {
  return multiply(o, [Math.cos(t), 0, -Math.sin(t), 0, 0, 1, 0, 0, Math.sin(t), 0, Math.cos(t), 0, 0, 0, 0, 1], 4);
}
function rotateZ3d(o, t) {
  return multiply(o, createRotateMatrix(t, 4));
}
function scale3d(o, t) {
  var e = t[0], r = e === void 0 ? 1 : e, S = t[1], T = S === void 0 ? 1 : S, D = t[2], N = D === void 0 ? 1 : D;
  return multiply(o, [r, 0, 0, 0, 0, T, 0, 0, 0, 0, N, 0, 0, 0, 0, 1], 4);
}
function rotate(o, t) {
  return calculate(createRotateMatrix(t, 3), convertPositionMatrix(o, 3));
}
function translate3d(o, t) {
  var e = t[0], r = e === void 0 ? 0 : e, S = t[1], T = S === void 0 ? 0 : S, D = t[2], N = D === void 0 ? 0 : D;
  return multiply(o, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, r, T, N, 1], 4);
}
function matrix3d(o, t) {
  return multiply(o, t, 4);
}
function createRotateMatrix(o, t) {
  var e = Math.cos(o), r = Math.sin(o), S = createIdentityMatrix(t);
  return S[0] = e, S[1] = r, S[t] = -r, S[t + 1] = e, S;
}
function createIdentityMatrix(o) {
  for (var t = o * o, e = [], r = 0; r < t; ++r)
    e[r] = r % (o + 1) ? 0 : 1;
  return e;
}
function createScaleMatrix(o, t) {
  for (var e = createIdentityMatrix(t), r = Math.min(o.length, t - 1), S = 0; S < r; ++S)
    e[(t + 1) * S] = o[S];
  return e;
}
function createOriginMatrix(o, t) {
  for (var e = createIdentityMatrix(t), r = Math.min(o.length, t - 1), S = 0; S < r; ++S)
    e[t * (t - 1) + S] = o[S];
  return e;
}
function createWarpMatrix(o, t, e, r, S, T, D, N) {
  var B = o[0], $ = o[1], U = t[0], H = t[1], V = e[0], X = e[1], W = r[0], Y = r[1], q = S[0], K = S[1], Z = T[0], J = T[1], Q = D[0], rt = D[1], et = N[0], nt = N[1], st = [B, 0, U, 0, V, 0, W, 0, $, 0, H, 0, X, 0, Y, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, B, 0, U, 0, V, 0, W, 0, $, 0, H, 0, X, 0, Y, 0, 1, 0, 1, 0, 1, 0, 1, -q * B, -K * B, -Z * U, -J * U, -Q * V, -rt * V, -et * W, -nt * W, -q * $, -K * $, -Z * H, -J * H, -Q * X, -rt * X, -et * Y, -nt * Y], it = invert(st, 8);
  if (!it.length)
    return [];
  var ot = multiply(it, [q, K, Z, J, Q, rt, et, nt], 8);
  return ot[8] = 1, convertDimension(transpose(ot), 3, 4);
}
function createMatrix() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function parseMat(o) {
  return toMat(parse$1(o));
}
function calculateMatrixDist(o, t) {
  var e = calculate(o, [t[0], t[1] || 0, t[2] || 0, 1], 4), r = e[3] || 1;
  return [e[0] / r, e[1] / r, e[2] / r];
}
function toMat(o) {
  var t = createMatrix();
  return o.forEach(function(e) {
    var r = e.matrixFunction, S = e.functionValue;
    r && (t = r(t, S));
  }), t;
}
function parse$1(o) {
  var t = isArray(o) ? o : splitSpace(o);
  return t.map(function(e) {
    var r = splitBracket(e), S = r.prefix, T = r.value, D = null, N = S, B = "";
    if (S === "translate" || S === "translateX" || S === "translate3d") {
      var $ = splitComma(T).map(function(ot) {
        return parseFloat(ot);
      }), U = $[0], H = $[1], V = H === void 0 ? 0 : H, X = $[2], W = X === void 0 ? 0 : X;
      D = translate3d, B = [U, V, W];
    } else if (S === "translateY") {
      var V = parseFloat(T);
      D = translate3d, B = [0, V, 0];
    } else if (S === "translateZ") {
      var W = parseFloat(T);
      D = translate3d, B = [0, 0, W];
    } else if (S === "scale" || S === "scale3d") {
      var Y = splitComma(T).map(function(ot) {
        return parseFloat(ot);
      }), q = Y[0], K = Y[1], Z = K === void 0 ? q : K, J = Y[2], Q = J === void 0 ? 1 : J;
      D = scale3d, B = [q, Z, Q];
    } else if (S === "scaleX") {
      var q = parseFloat(T);
      D = scale3d, B = [q, 1, 1];
    } else if (S === "scaleY") {
      var Z = parseFloat(T);
      D = scale3d, B = [1, Z, 1];
    } else if (S === "scaleZ") {
      var Q = parseFloat(T);
      D = scale3d, B = [1, 1, Q];
    } else if (S === "rotate" || S === "rotateZ" || S === "rotateX" || S === "rotateY") {
      var rt = splitUnit(T), et = rt.unit, nt = rt.value, st = et === "rad" ? nt : nt * Math.PI / 180;
      S === "rotate" || S === "rotateZ" ? (N = "rotateZ", D = rotateZ3d) : S === "rotateX" ? D = rotateX3d : S === "rotateY" && (D = rotateY3d), B = st;
    } else if (S === "matrix3d")
      D = matrix3d, B = splitComma(T).map(function(ot) {
        return parseFloat(ot);
      });
    else if (S === "matrix") {
      var it = splitComma(T).map(function(ot) {
        return parseFloat(ot);
      });
      D = matrix3d, B = [it[0], it[1], 0, 0, it[2], it[3], 0, 0, 0, 0, 1, 0, it[4], it[5], 0, 1];
    } else
      N = "";
    return {
      name: S,
      functionName: N,
      value: T,
      matrixFunction: D,
      functionValue: B
    };
  });
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$5 = function(o, t) {
  return extendStatics$5 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$5(o, t);
};
function __extends$5(o, t) {
  extendStatics$5(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var findKeyCallback = typeof Map == "function" ? void 0 : function() {
  var o = 0;
  return function(t) {
    return t.__DIFF_KEY__ || (t.__DIFF_KEY__ = ++o);
  };
}(), ChildrenDiffer = /* @__PURE__ */ function(o) {
  __extends$5(t, o);
  function t(e) {
    return e === void 0 && (e = []), o.call(this, e, findKeyCallback) || this;
  }
  return t;
}(ListDiffer);
function diff(o, t) {
  return diff$1(o, t, findKeyCallback);
}
const ChildrenDiffer$1 = ChildrenDiffer;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __spreadArrays$1() {
  for (var o = 0, t = 0, e = arguments.length; t < e; t++)
    o += arguments[t].length;
  for (var r = Array(o), S = 0, t = 0; t < e; t++)
    for (var T = arguments[t], D = 0, N = T.length; D < N; D++, S++)
      r[S] = T[D];
  return r;
}
function tinyThrottle(o) {
  return throttle(o, TINY_NUM$1);
}
function isSameConstants(o, t) {
  return o.every(function(e, r) {
    return tinyThrottle(e - t[r]) === 0;
  });
}
function isSamePoint(o, t) {
  return !tinyThrottle(o[0] - t[0]) && !tinyThrottle(o[1] - t[1]);
}
function getAreaSize(o) {
  return o.length < 3 ? 0 : Math.abs(sum(o.map(function(t, e) {
    var r = o[e + 1] || o[0];
    return t[0] * r[1] - r[0] * t[1];
  }))) / 2;
}
function fitPoints(o, t) {
  var e = t.width, r = t.height, S = t.left, T = t.top, D = getMinMaxs(o), N = D.minX, B = D.minY, $ = D.maxX, U = D.maxY, H = e / ($ - N), V = r / (U - B);
  return o.map(function(X) {
    return [S + (X[0] - N) * H, T + (X[1] - B) * V];
  });
}
function getMinMaxs(o) {
  var t = o.map(function(r) {
    return r[0];
  }), e = o.map(function(r) {
    return r[1];
  });
  return {
    minX: Math.min.apply(Math, t),
    minY: Math.min.apply(Math, e),
    maxX: Math.max.apply(Math, t),
    maxY: Math.max.apply(Math, e)
  };
}
function isInside(o, t, e) {
  var r = o[0], S = o[1], T = getMinMaxs(t), D = T.minX, N = T.maxX, B = [[D, S], [N, S]], $ = getLinearConstants(B[0], B[1]), U = convertLines(t), H = [];
  if (U.forEach(function(W) {
    var Y = getLinearConstants(W[0], W[1]), q = W[0];
    if (isSameConstants($, Y))
      H.push({
        pos: o,
        line: W,
        type: "line"
      });
    else {
      var K = getPointsOnLines(getIntersectionPointsByConstants($, Y), [B, W]);
      K.forEach(function(Z) {
        W.some(function(J) {
          return isSamePoint(J, Z);
        }) ? H.push({
          pos: Z,
          line: W,
          type: "point"
        }) : tinyThrottle(q[1] - S) !== 0 && H.push({
          pos: Z,
          line: W,
          type: "intersection"
        });
      });
    }
  }), !e && find$1(H, function(W) {
    return W[0] === r;
  }))
    return !0;
  var V = 0, X = {};
  return H.forEach(function(W) {
    var Y = W.pos, q = W.type, K = W.line;
    if (!(Y[0] > r))
      if (q === "intersection")
        ++V;
      else {
        if (q === "line")
          return;
        if (q === "point") {
          var Z = find$1(K, function(rt) {
            return rt[1] !== S;
          }), J = X[Y[0]], Q = Z[1] > S ? 1 : -1;
          J ? J !== Q && ++V : X[Y[0]] = Q;
        }
      }
  }), V % 2 === 1;
}
function getLinearConstants(o, t) {
  var e = o[0], r = o[1], S = t[0], T = t[1], D = S - e, N = T - r;
  Math.abs(D) < TINY_NUM$1 && (D = 0), Math.abs(N) < TINY_NUM$1 && (N = 0);
  var B = 0, $ = 0, U = 0;
  return D ? N ? (B = -N / D, $ = 1, U = -B * e - r) : ($ = 1, U = -r) : N && (B = -1, U = e), [B, $, U];
}
function getIntersectionPointsByConstants(o, t) {
  var e = o[0], r = o[1], S = o[2], T = t[0], D = t[1], N = t[2], B = e === 0 && T === 0, $ = r === 0 && D === 0, U = [];
  if (B && $)
    return [];
  if (B) {
    var H = -S / r, V = -N / D;
    return H !== V ? [] : [[-1 / 0, H], [1 / 0, H]];
  } else if ($) {
    var X = -S / e, W = -N / T;
    return X !== W ? [] : [[X, -1 / 0], [X, 1 / 0]];
  } else if (e === 0) {
    var Y = -S / r, q = -(D * Y + N) / T;
    U = [[q, Y]];
  } else if (T === 0) {
    var Y = -N / D, q = -(r * Y + S) / e;
    U = [[q, Y]];
  } else if (r === 0) {
    var q = -S / e, Y = -(T * q + N) / D;
    U = [[q, Y]];
  } else if (D === 0) {
    var q = -N / T, Y = -(e * q + S) / r;
    U = [[q, Y]];
  } else {
    var q = (r * N - D * S) / (D * e - r * T), Y = -(e * q + S) / r;
    U = [[q, Y]];
  }
  return U.map(function(K) {
    return [K[0], K[1]];
  });
}
function getPointsOnLines(o, t) {
  var e = t.map(function(H) {
    return [0, 1].map(function(V) {
      return [Math.min(H[0][V], H[1][V]), Math.max(H[0][V], H[1][V])];
    });
  }), r = [];
  if (o.length === 2) {
    var S = o[0], T = S[0], D = S[1];
    if (tinyThrottle(T - o[1][0])) {
      if (!tinyThrottle(D - o[1][1])) {
        var $ = Math.max.apply(Math, e.map(function(H) {
          return H[0][0];
        })), U = Math.min.apply(Math, e.map(function(H) {
          return H[0][1];
        }));
        if (tinyThrottle($ - U) > 0)
          return [];
        r = [[$, D], [U, D]];
      }
    } else {
      var N = Math.max.apply(Math, e.map(function(H) {
        return H[1][0];
      })), B = Math.min.apply(Math, e.map(function(H) {
        return H[1][1];
      }));
      if (tinyThrottle(N - B) > 0)
        return [];
      r = [[T, N], [T, B]];
    }
  }
  return r.length || (r = o.filter(function(H) {
    var V = H[0], X = H[1];
    return e.every(function(W) {
      return 0 <= tinyThrottle(V - W[0][0]) && 0 <= tinyThrottle(W[0][1] - V) && 0 <= tinyThrottle(X - W[1][0]) && 0 <= tinyThrottle(W[1][1] - X);
    });
  })), r.map(function(H) {
    return [tinyThrottle(H[0]), tinyThrottle(H[1])];
  });
}
function convertLines(o) {
  return __spreadArrays$1(o.slice(1), [o[0]]).map(function(t, e) {
    return [o[e], t];
  });
}
function getOverlapPointInfos(o, t) {
  var e = o.slice(), r = t.slice();
  getShapeDirection(e) === -1 && e.reverse(), getShapeDirection(r) === -1 && r.reverse();
  var S = convertLines(e), T = convertLines(r), D = S.map(function(U) {
    return getLinearConstants(U[0], U[1]);
  }), N = T.map(function(U) {
    return getLinearConstants(U[0], U[1]);
  }), B = [];
  D.forEach(function(U, H) {
    var V = S[H], X = [];
    N.forEach(function(W, Y) {
      var q = getIntersectionPointsByConstants(U, W), K = getPointsOnLines(q, [V, T[Y]]);
      X.push.apply(X, K.map(function(Z) {
        return {
          index1: H,
          index2: Y,
          pos: Z,
          type: "intersection"
        };
      }));
    }), X.sort(function(W, Y) {
      return getDist$2(V[0], W.pos) - getDist$2(V[0], Y.pos);
    }), B.push.apply(B, X), isInside(V[1], r) && B.push({
      index1: H,
      index2: -1,
      pos: V[1],
      type: "inside"
    });
  }), T.forEach(function(U, H) {
    if (isInside(U[1], e)) {
      var V = !1, X = findIndex(B, function(W) {
        var Y = W.index2;
        return Y === H ? (V = !0, !1) : !!V;
      });
      X === -1 && (V = !1, X = findIndex(B, function(W) {
        var Y = W.index1, q = W.index2;
        return Y === -1 && q + 1 === H ? (V = !0, !1) : !!V;
      })), X === -1 ? B.push({
        index1: -1,
        index2: H,
        pos: U[1],
        type: "inside"
      }) : B.splice(X, 0, {
        index1: -1,
        index2: H,
        pos: U[1],
        type: "inside"
      });
    }
  });
  var $ = {};
  return B.filter(function(U) {
    var H = U.pos, V = H[0] + "x" + H[1];
    return $[V] ? !1 : ($[V] = !0, !0);
  });
}
function getOverlapPoints(o, t) {
  var e = getOverlapPointInfos(o, t);
  return e.map(function(r) {
    var S = r.pos;
    return S;
  });
}
function getOverlapSize(o, t) {
  var e = getOverlapPoints(o, t);
  return getAreaSize(e);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$5 = function() {
  return __assign$5 = Object.assign || function(t) {
    for (var e, r = 1, S = arguments.length; r < S; r++) {
      e = arguments[r];
      for (var T in e)
        Object.prototype.hasOwnProperty.call(e, T) && (t[T] = e[T]);
    }
    return t;
  }, __assign$5.apply(this, arguments);
};
function __spreadArrays() {
  for (var o = 0, t = 0, e = arguments.length; t < e; t++)
    o += arguments[t].length;
  for (var r = Array(o), S = 0, t = 0; t < e; t++)
    for (var T = arguments[t], D = 0, N = T.length; D < N; D++, S++)
      r[S] = T[D];
  return r;
}
var EventEmitter = /* @__PURE__ */ function() {
  function o() {
    this._events = {};
  }
  var t = o.prototype;
  return t.on = function(e, r) {
    if (isObject$2(e))
      for (var S in e)
        this.on(S, e[S]);
    else
      this._addEvent(e, r, {});
    return this;
  }, t.off = function(e, r) {
    if (!e)
      this._events = {};
    else if (isObject$2(e))
      for (var S in e)
        this.off(S);
    else if (!r)
      this._events[e] = [];
    else {
      var T = this._events[e];
      if (T) {
        var D = findIndex(T, function(N) {
          return N.listener === r;
        });
        D > -1 && T.splice(D, 1);
      }
    }
    return this;
  }, t.once = function(e, r) {
    var S = this;
    return r && this._addEvent(e, r, {
      once: !0
    }), new Promise(function(T) {
      S._addEvent(e, T, {
        once: !0
      });
    });
  }, t.emit = function(e, r) {
    var S = this;
    r === void 0 && (r = {});
    var T = this._events[e];
    if (!e || !T)
      return !0;
    var D = !1;
    return r.eventType = e, r.stop = function() {
      D = !0;
    }, r.currentTarget = this, __spreadArrays(T).forEach(function(N) {
      N.listener(r), N.once && S.off(e, N.listener);
    }), !D;
  }, t.trigger = function(e, r) {
    return r === void 0 && (r = {}), this.emit(e, r);
  }, t._addEvent = function(e, r, S) {
    var T = this._events;
    T[e] = T[e] || [];
    var D = T[e];
    D.push(__assign$5({
      listener: r
    }, S));
  }, o;
}();
const EventEmitter$1 = EventEmitter;
var FUNCTION = "function", STRING = "string";
function isString(o) {
  return typeof o === STRING;
}
function isFunction$2(o) {
  return typeof o === FUNCTION;
}
function now() {
  return Date.now ? Date.now() : new Date().getTime();
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$4 = function(o, t) {
  return extendStatics$4 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$4(o, t);
};
function __extends$4(o, t) {
  extendStatics$4(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$4 = function() {
  return __assign$4 = Object.assign || function(t) {
    for (var e, r = 1, S = arguments.length; r < S; r++) {
      e = arguments[r];
      for (var T in e)
        Object.prototype.hasOwnProperty.call(e, T) && (t[T] = e[T]);
    }
    return t;
  }, __assign$4.apply(this, arguments);
};
function getDefaultScrollPosition$1(o) {
  var t = o.container;
  return t === document.body ? [t.scrollLeft || document.documentElement.scrollLeft, t.scrollTop || document.documentElement.scrollTop] : [t.scrollLeft, t.scrollTop];
}
function getContainerElement(o) {
  if (o) {
    if (isString(o))
      return document.querySelector(o);
  } else
    return null;
  if (isFunction$2(o))
    return o();
  if (o instanceof Element)
    return o;
  if ("current" in o)
    return o.current;
  if ("value" in o)
    return o.value;
}
var DragScroll = /* @__PURE__ */ function(o) {
  __extends$4(t, o);
  function t() {
    var r = o !== null && o.apply(this, arguments) || this;
    return r._startRect = null, r._startPos = [], r._prevTime = 0, r._timer = 0, r._prevScrollPos = [0, 0], r._isWait = !1, r._flag = !1, r;
  }
  var e = t.prototype;
  return e.dragStart = function(r, S) {
    var T = getContainerElement(S.container);
    if (!T) {
      this._flag = !1;
      return;
    }
    var D = 0, N = 0, B = 0, $ = 0;
    if (T === document.body)
      B = window.innerWidth, $ = window.innerHeight;
    else {
      var U = T.getBoundingClientRect();
      D = U.top, N = U.left, B = U.width, $ = U.height;
    }
    this._flag = !0, this._startPos = [r.clientX, r.clientY], this._startRect = {
      top: D,
      left: N,
      width: B,
      height: $
    }, this._prevScrollPos = this._getScrollPosition([0, 0], S);
  }, e.drag = function(r, S) {
    if (clearTimeout(this._timer), !!this._flag) {
      var T = r.clientX, D = r.clientY, N = S.threshold, B = N === void 0 ? 0 : N, $ = this, U = $._startRect, H = $._startPos, V = [0, 0];
      return U.top > D - B ? (H[1] > U.top || D < H[1]) && (V[1] = -1) : U.top + U.height < D + B && (H[1] < U.top + U.height || D > H[1]) && (V[1] = 1), U.left > T - B ? (H[0] > U.left || T < H[0]) && (V[0] = -1) : U.left + U.width < T + B && (H[0] < U.left + U.width || T > H[0]) && (V[0] = 1), !V[0] && !V[1] ? !1 : this._continueDrag(__assign$4(__assign$4({}, S), {
        direction: V,
        inputEvent: r,
        isDrag: !0
      }));
    }
  }, e.checkScroll = function(r) {
    var S = this;
    if (this._isWait)
      return !1;
    var T = r.prevScrollPos, D = T === void 0 ? this._prevScrollPos : T, N = r.direction, B = r.throttleTime, $ = B === void 0 ? 0 : B, U = r.inputEvent, H = r.isDrag, V = this._getScrollPosition(N || [0, 0], r), X = V[0] - D[0], W = V[1] - D[1], Y = N || [X ? Math.abs(X) / X : 0, W ? Math.abs(W) / W : 0];
    return this._prevScrollPos = V, !X && !W ? !1 : (this.trigger("move", {
      offsetX: Y[0] ? X : 0,
      offsetY: Y[1] ? W : 0,
      inputEvent: U
    }), $ && H && (clearTimeout(this._timer), this._timer = window.setTimeout(function() {
      S._continueDrag(r);
    }, $)), !0);
  }, e.dragEnd = function() {
    this._flag = !1, clearTimeout(this._timer);
  }, e._getScrollPosition = function(r, S) {
    var T = S.container, D = S.getScrollPosition, N = D === void 0 ? getDefaultScrollPosition$1 : D;
    return N({
      container: getContainerElement(T),
      direction: r
    });
  }, e._continueDrag = function(r) {
    var S = this, T, D, N = r.container, B = r.direction, $ = r.throttleTime, U = r.useScroll, H = r.isDrag, V = r.inputEvent;
    if (!(!this._flag || H && this._isWait)) {
      var X = now(), W = Math.max($ + this._prevTime - X, 0);
      if (W > 0)
        return clearTimeout(this._timer), this._timer = window.setTimeout(function() {
          S._continueDrag(r);
        }, W), !1;
      this._prevTime = X;
      var Y = this._getScrollPosition(B, r);
      this._prevScrollPos = Y, H && (this._isWait = !0);
      var q = {
        container: getContainerElement(N),
        direction: B,
        inputEvent: V
      };
      return (D = (T = r).requestScroll) === null || D === void 0 || D.call(T, q), this.trigger("scroll", q), this._isWait = !1, U || this.checkScroll(__assign$4(__assign$4({}, r), {
        prevScrollPos: Y,
        direction: B,
        inputEvent: V
      }));
    }
  }, t;
}(EventEmitter$1);
const DragScroll$1 = DragScroll;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$3 = function(o, t) {
  return extendStatics$3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$3(o, t);
};
function __extends$3(o, t) {
  extendStatics$3(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$3 = function() {
  return __assign$3 = Object.assign || function(t) {
    for (var e, r = 1, S = arguments.length; r < S; r++) {
      e = arguments[r];
      for (var T in e)
        Object.prototype.hasOwnProperty.call(e, T) && (t[T] = e[T]);
    }
    return t;
  }, __assign$3.apply(this, arguments);
};
function getRad(o, t) {
  var e = t[0] - o[0], r = t[1] - o[1], S = Math.atan2(r, e);
  return S >= 0 ? S : S + Math.PI * 2;
}
function getRotatiion(o) {
  return getRad([
    o[0].clientX,
    o[0].clientY
  ], [
    o[1].clientX,
    o[1].clientY
  ]) / Math.PI * 180;
}
function isMultiTouch(o) {
  return o.touches && o.touches.length >= 2;
}
function getEventClients(o) {
  return o ? o.touches ? getClients(o.touches) : [getClient(o)] : [];
}
function isMouseEvent(o) {
  return o && (o.type.indexOf("mouse") > -1 || "button" in o);
}
function getPosition(o, t, e) {
  var r = e.length, S = getAverageClient(o, r), T = S.clientX, D = S.clientY, N = S.originalClientX, B = S.originalClientY, $ = getAverageClient(t, r), U = $.clientX, H = $.clientY, V = getAverageClient(e, r), X = V.clientX, W = V.clientY, Y = T - U, q = D - H, K = T - X, Z = D - W;
  return {
    clientX: N,
    clientY: B,
    deltaX: Y,
    deltaY: q,
    distX: K,
    distY: Z
  };
}
function getDist$1(o) {
  return Math.sqrt(Math.pow(o[0].clientX - o[1].clientX, 2) + Math.pow(o[0].clientY - o[1].clientY, 2));
}
function getClients(o) {
  for (var t = Math.min(o.length, 2), e = [], r = 0; r < t; ++r)
    e.push(getClient(o[r]));
  return e;
}
function getClient(o) {
  return {
    clientX: o.clientX,
    clientY: o.clientY
  };
}
function getAverageClient(o, t) {
  t === void 0 && (t = o.length);
  for (var e = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  }, r = 0; r < t; ++r) {
    var S = o[r];
    e.originalClientX += "originalClientX" in S ? S.originalClientX : S.clientX, e.originalClientY += "originalClientY" in S ? S.originalClientY : S.clientY, e.clientX += S.clientX, e.clientY += S.clientY;
  }
  return t ? {
    clientX: e.clientX / t,
    clientY: e.clientY / t,
    originalClientX: e.originalClientX / t,
    originalClientY: e.originalClientY / t
  } : e;
}
var ClientStore = /* @__PURE__ */ function() {
  function o(t) {
    this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = t, this.prevClients = t, this.length = t.length;
  }
  return o.prototype.getAngle = function(t) {
    return t === void 0 && (t = this.prevClients), getRotatiion(t);
  }, o.prototype.getRotation = function(t) {
    return t === void 0 && (t = this.prevClients), getRotatiion(t) - getRotatiion(this.startClients);
  }, o.prototype.getPosition = function(t, e) {
    t === void 0 && (t = this.prevClients);
    var r = getPosition(t || this.prevClients, this.prevClients, this.startClients), S = r.deltaX, T = r.deltaY;
    return this.movement += Math.sqrt(S * S + T * T), this.prevClients = t, r;
  }, o.prototype.getPositions = function(t) {
    t === void 0 && (t = this.prevClients);
    var e = this.prevClients;
    return this.startClients.map(function(r, S) {
      return getPosition([t[S]], [e[S]], [r]);
    });
  }, o.prototype.getMovement = function(t) {
    var e = this.movement;
    if (!t)
      return e;
    var r = getAverageClient(t, this.length), S = getAverageClient(this.prevClients, this.length), T = r.clientX - S.clientX, D = r.clientY - S.clientY;
    return Math.sqrt(T * T + D * D) + e;
  }, o.prototype.getDistance = function(t) {
    return t === void 0 && (t = this.prevClients), getDist$1(t);
  }, o.prototype.getScale = function(t) {
    return t === void 0 && (t = this.prevClients), getDist$1(t) / getDist$1(this.startClients);
  }, o.prototype.move = function(t, e) {
    this.startClients.forEach(function(r) {
      r.clientX -= t, r.clientY -= e;
    }), this.prevClients.forEach(function(r) {
      r.clientX -= t, r.clientY -= e;
    });
  }, o;
}(), INPUT_TAGNAMES = ["textarea", "input"], Gesto = /* @__PURE__ */ function(o) {
  __extends$3(t, o);
  function t(e, r) {
    r === void 0 && (r = {});
    var S = o.call(this) || this;
    S.options = {}, S.flag = !1, S.pinchFlag = !1, S.data = {}, S.isDrag = !1, S.isPinch = !1, S.isMouse = !1, S.isTouch = !1, S.clientStores = [], S.targets = [], S.prevTime = 0, S.doubleFlag = !1, S._dragFlag = !1, S._isTrusted = !1, S._isMouseEvent = !1, S._isSecondaryButton = !1, S._preventMouseEvent = !1, S.onDragStart = function(H, V) {
      if (V === void 0 && (V = !0), !(!S.flag && H.cancelable === !1)) {
        var X = S.options, W = X.container, Y = X.pinchOutside, q = X.preventWheelClick, K = X.preventRightClick, Z = X.preventDefault, J = X.checkInput, Q = X.preventClickEventOnDragStart, rt = X.preventClickEventOnDrag, et = X.preventClickEventByCondition, nt = S.isTouch, st = !S.flag;
        if (S._isSecondaryButton = H.which === 3 || H.button === 2, q && (H.which === 2 || H.button === 1) || K && (H.which === 3 || H.button === 2))
          return S.stop(), !1;
        if (st) {
          var it = document.activeElement, ot = H.target;
          if (ot) {
            var ht = ot.tagName.toLowerCase(), ct = INPUT_TAGNAMES.indexOf(ht) > -1, vt = ot.isContentEditable;
            if (ct || vt) {
              if (J || it === ot || it && vt && it.isContentEditable && it.contains(ot))
                return !1;
            } else if ((Z || H.type === "touchstart") && it) {
              var _t = it.tagName.toLowerCase();
              (it.isContentEditable || INPUT_TAGNAMES.indexOf(_t) > -1) && it.blur();
            }
            (Q || rt || et) && addEvent(window, "click", S._onClick, !0);
          }
          S.clientStores = [new ClientStore(getEventClients(H))], S.flag = !0, S.isDrag = !1, S._isTrusted = V, S._dragFlag = !0, S.data = {}, S.doubleFlag = now$1() - S.prevTime < 200, S._isMouseEvent = isMouseEvent(H), !S._isMouseEvent && S._preventMouseEvent && (S._preventMouseEvent = !1);
          var gt = S._preventMouseEvent || S.emit("dragStart", __assign$3(__assign$3({ data: S.data, datas: S.data, inputEvent: H, isMouseEvent: S._isMouseEvent, isSecondaryButton: S._isSecondaryButton, isTrusted: V, isDouble: S.doubleFlag }, S.getCurrentStore().getPosition()), { preventDefault: function() {
            H.preventDefault();
          }, preventDrag: function() {
            S._dragFlag = !1;
          } }));
          gt === !1 && S.stop(), S._isMouseEvent && S.flag && Z && H.preventDefault();
        }
        if (!S.flag)
          return !1;
        var mt = 0;
        if (st ? (S._attchDragEvent(), nt && Y && (mt = setTimeout(function() {
          addEvent(W, "touchstart", S.onDragStart, {
            passive: !1
          });
        }))) : nt && Y && removeEvent(W, "touchstart", S.onDragStart), S.flag && isMultiTouch(H)) {
          if (clearTimeout(mt), st && H.touches.length !== H.changedTouches.length)
            return;
          S.pinchFlag || S.onPinchStart(H);
        }
      }
    }, S.onDrag = function(H, V) {
      if (S.flag) {
        var X = S.options.preventDefault;
        !S._isMouseEvent && X && H.preventDefault();
        var W = getEventClients(H), Y = S.moveClients(W, H, !1);
        if (S._dragFlag) {
          if (S.pinchFlag || Y.deltaX || Y.deltaY) {
            var q = S._preventMouseEvent || S.emit("drag", __assign$3(__assign$3({}, Y), { isScroll: !!V, inputEvent: H }));
            if (q === !1) {
              S.stop();
              return;
            }
          }
          S.pinchFlag && S.onPinch(H, W);
        }
        S.getCurrentStore().getPosition(W, !0);
      }
    }, S.onDragEnd = function(H) {
      if (S.flag) {
        var V = S.options, X = V.pinchOutside, W = V.container, Y = V.preventClickEventOnDrag, q = V.preventClickEventOnDragStart, K = V.preventClickEventByCondition, Z = S.isDrag;
        (Y || q || K) && requestAnimationFrame(function() {
          S._allowClickEvent();
        }), !K && !q && Y && !Z && S._allowClickEvent(), S.isTouch && X && removeEvent(W, "touchstart", S.onDragStart), S.pinchFlag && S.onPinchEnd(H);
        var J = H != null && H.touches ? getEventClients(H) : [], Q = J.length;
        Q === 0 || !S.options.keepDragging ? S.flag = !1 : S._addStore(new ClientStore(J));
        var rt = S._getPosition(), et = now$1(), nt = !Z && S.doubleFlag;
        S.prevTime = Z || nt ? 0 : et, S.flag || (S._dettachDragEvent(), S._preventMouseEvent || S.emit("dragEnd", __assign$3({ data: S.data, datas: S.data, isDouble: nt, isDrag: Z, isClick: !Z, isMouseEvent: S._isMouseEvent, isSecondaryButton: S._isSecondaryButton, inputEvent: H, isTrusted: S._isTrusted }, rt)), S.clientStores = [], S._isMouseEvent || (S._preventMouseEvent = !0, requestAnimationFrame(function() {
          requestAnimationFrame(function() {
            S._preventMouseEvent = !1;
          });
        })));
      }
    }, S.onBlur = function() {
      S.onDragEnd();
    }, S._allowClickEvent = function() {
      removeEvent(window, "click", S._onClick, !0);
    }, S._onClick = function(H) {
      S._allowClickEvent(), S._preventMouseEvent = !1;
      var V = S.options.preventClickEventByCondition;
      V != null && V(H) || (H.stopPropagation(), H.preventDefault());
    }, S._onContextMenu = function(H) {
      var V = S.options;
      V.preventRightClick ? S.onDragEnd(H) : H.preventDefault();
    }, S._passCallback = function() {
    };
    var T = [].concat(e);
    S.options = __assign$3({ checkInput: !1, container: T.length > 1 ? window : T[0], preventRightClick: !0, preventWheelClick: !0, preventClickEventOnDragStart: !1, preventClickEventOnDrag: !1, preventClickEventByCondition: null, preventDefault: !0, checkWindowBlur: !1, keepDragging: !1, pinchThreshold: 0, events: ["touch", "mouse"] }, r);
    var D = S.options, N = D.container, B = D.events, $ = D.checkWindowBlur;
    if (S.isTouch = B.indexOf("touch") > -1, S.isMouse = B.indexOf("mouse") > -1, S.targets = T, S.isMouse && (T.forEach(function(H) {
      addEvent(H, "mousedown", S.onDragStart), addEvent(H, "mousemove", S._passCallback);
    }), addEvent(N, "contextmenu", S._onContextMenu)), $ && addEvent(window, "blur", S.onBlur), S.isTouch) {
      var U = {
        passive: !1
      };
      T.forEach(function(H) {
        addEvent(H, "touchstart", S.onDragStart, U), addEvent(H, "touchmove", S._passCallback, U);
      });
    }
    return S;
  }
  return t.prototype.stop = function() {
    this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._allowClickEvent(), this._dettachDragEvent();
  }, t.prototype.getMovement = function(e) {
    return this.getCurrentStore().getMovement(e) + this.clientStores.slice(1).reduce(function(r, S) {
      return r + S.movement;
    }, 0);
  }, t.prototype.isDragging = function() {
    return this.isDrag;
  }, t.prototype.isFlag = function() {
    return this.flag;
  }, t.prototype.isPinchFlag = function() {
    return this.pinchFlag;
  }, t.prototype.isDoubleFlag = function() {
    return this.doubleFlag;
  }, t.prototype.isPinching = function() {
    return this.isPinch;
  }, t.prototype.scrollBy = function(e, r, S, T) {
    T === void 0 && (T = !0), this.flag && (this.clientStores[0].move(e, r), T && this.onDrag(S, !0));
  }, t.prototype.move = function(e, r) {
    var S = e[0], T = e[1], D = this.getCurrentStore(), N = D.prevClients;
    return this.moveClients(N.map(function(B) {
      var $ = B.clientX, U = B.clientY;
      return {
        clientX: $ + S,
        clientY: U + T,
        originalClientX: $,
        originalClientY: U
      };
    }), r, !0);
  }, t.prototype.triggerDragStart = function(e) {
    this.onDragStart(e, !1);
  }, t.prototype.setEventData = function(e) {
    var r = this.data;
    for (var S in e)
      r[S] = e[S];
    return this;
  }, t.prototype.setEventDatas = function(e) {
    return this.setEventData(e);
  }, t.prototype.getCurrentEvent = function(e) {
    return __assign$3(__assign$3({ data: this.data, datas: this.data }, this._getPosition()), { movement: this.getMovement(), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, inputEvent: e });
  }, t.prototype.getEventData = function() {
    return this.data;
  }, t.prototype.getEventDatas = function() {
    return this.data;
  }, t.prototype.unset = function() {
    var e = this, r = this.targets, S = this.options.container;
    this.off(), removeEvent(window, "blur", this.onBlur), this.isMouse && (r.forEach(function(T) {
      removeEvent(T, "mousedown", e.onDragStart);
    }), removeEvent(S, "contextmenu", this._onContextMenu)), this.isTouch && (r.forEach(function(T) {
      removeEvent(T, "touchstart", e.onDragStart);
    }), removeEvent(S, "touchstart", this.onDragStart)), this._allowClickEvent(), this._dettachDragEvent();
  }, t.prototype.onPinchStart = function(e) {
    var r = this.options.pinchThreshold;
    if (!(this.isDrag && this.getMovement() > r)) {
      var S = new ClientStore(getEventClients(e));
      this.pinchFlag = !0, this._addStore(S);
      var T = this.emit("pinchStart", __assign$3(__assign$3({ data: this.data, datas: this.data, angle: S.getAngle(), touches: this.getCurrentStore().getPositions() }, S.getPosition()), { inputEvent: e, isTrusted: this._isTrusted }));
      T === !1 && (this.pinchFlag = !1);
    }
  }, t.prototype.onPinch = function(e, r) {
    if (!(!this.flag || !this.pinchFlag || r.length < 2)) {
      var S = this.getCurrentStore();
      this.isPinch = !0, this.emit("pinch", __assign$3(__assign$3({ data: this.data, datas: this.data, movement: this.getMovement(r), angle: S.getAngle(r), rotation: S.getRotation(r), touches: S.getPositions(r), scale: S.getScale(r), distance: S.getDistance(r) }, S.getPosition(r)), { inputEvent: e, isTrusted: this._isTrusted }));
    }
  }, t.prototype.onPinchEnd = function(e) {
    if (this.pinchFlag) {
      var r = this.isPinch;
      this.isPinch = !1, this.pinchFlag = !1;
      var S = this.getCurrentStore();
      this.emit("pinchEnd", __assign$3(__assign$3({ data: this.data, datas: this.data, isPinch: r, touches: S.getPositions() }, S.getPosition()), { inputEvent: e }));
    }
  }, t.prototype.getCurrentStore = function() {
    return this.clientStores[0];
  }, t.prototype.moveClients = function(e, r, S) {
    var T = this._getPosition(e, S), D = this.isDrag;
    (T.deltaX || T.deltaY) && (this.isDrag = !0);
    var N = !1;
    return !D && this.isDrag && (N = !0), __assign$3(__assign$3({ data: this.data, datas: this.data }, T), { movement: this.getMovement(e), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, isMouseEvent: this._isMouseEvent, isSecondaryButton: this._isSecondaryButton, inputEvent: r, isTrusted: this._isTrusted, isFirstDrag: N });
  }, t.prototype._addStore = function(e) {
    this.clientStores.splice(0, 0, e);
  }, t.prototype._getPosition = function(e, r) {
    var S = this.getCurrentStore(), T = S.getPosition(e, r), D = this.clientStores.slice(1).reduce(function($, U) {
      var H = U.getPosition();
      return $.distX += H.distX, $.distY += H.distY, $;
    }, T), N = D.distX, B = D.distY;
    return __assign$3(__assign$3({}, T), { distX: N, distY: B });
  }, t.prototype._attchDragEvent = function() {
    var e = this.options.container, r = {
      passive: !1
    };
    this.isMouse && (addEvent(e, "mousemove", this.onDrag), addEvent(e, "mouseup", this.onDragEnd)), this.isTouch && (addEvent(e, "touchmove", this.onDrag, r), addEvent(e, "touchend", this.onDragEnd, r), addEvent(e, "touchcancel", this.onDragEnd, r));
  }, t.prototype._dettachDragEvent = function() {
    var e = this.options.container;
    this.isMouse && (removeEvent(e, "mousemove", this.onDrag), removeEvent(e, "mouseup", this.onDragEnd)), this.isTouch && (removeEvent(e, "touchstart", this.onDragStart), removeEvent(e, "touchmove", this.onDrag), removeEvent(e, "touchend", this.onDragEnd), removeEvent(e, "touchcancel", this.onDragEnd));
  }, t;
}(EventEmitter$1);
function hash$2(o) {
  for (var t = 5381, e = o.length; e; )
    t = t * 33 ^ o.charCodeAt(--e);
  return t >>> 0;
}
var stringHash = hash$2;
function getHash(o) {
  return stringHash(o).toString(36);
}
function getShadowRoot$1(o) {
  if (o && o.getRootNode) {
    var t = o.getRootNode();
    if (t.nodeType === 11)
      return t;
  }
}
function replaceStyle(o, t, e) {
  return e.original ? t : t.replace(/([^};{\s}][^};{]*|^\s*){/mg, function(r, S) {
    var T = S.trim();
    return (T ? splitComma(T) : [""]).map(function(D) {
      var N = D.trim();
      return N.indexOf("@") === 0 ? N : N.indexOf(":global") > -1 ? N.replace(/\:global/g, "") : N.indexOf(":host") > -1 ? "" + N.replace(/\:host/g, "." + o) : N ? "." + o + " " + N : "." + o;
    }).join(", ") + " {";
  });
}
function injectStyle(o, t, e, r) {
  var S = document.createElement("style");
  return S.setAttribute("type", "text/css"), S.setAttribute("data-styled-id", o), e.nonce && S.setAttribute("nonce", e.nonce), S.innerHTML = replaceStyle(o, t, e), (r || document.head || document.body).appendChild(S), S;
}
function styled$1(o) {
  var t = "rCS" + getHash(o), e = 0, r;
  return {
    className: t,
    inject: function(S, T) {
      T === void 0 && (T = {});
      var D = getShadowRoot$1(S), N = e === 0, B;
      return (D || N) && (B = injectStyle(t, o, T, D)), N && (r = B), D || ++e, {
        destroy: function() {
          D ? (D.removeChild(B), B = null) : (e > 0 && --e, e === 0 && r && (r.parentNode.removeChild(r), r = null));
        }
      };
    }
  };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$2 = function(o, t) {
  return extendStatics$2 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics$2(o, t);
};
function __extends$2(o, t) {
  extendStatics$2(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$2 = function() {
  return __assign$2 = Object.assign || function(t) {
    for (var e, r = 1, S = arguments.length; r < S; r++) {
      e = arguments[r];
      for (var T in e)
        Object.prototype.hasOwnProperty.call(e, T) && (t[T] = e[T]);
    }
    return t;
  }, __assign$2.apply(this, arguments);
};
function __rest$1(o, t) {
  var e = {};
  for (var r in o)
    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var S = 0, r = Object.getOwnPropertySymbols(o); S < r.length; S++)
      t.indexOf(r[S]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[S]) && (e[r[S]] = o[r[S]]);
  return e;
}
var StyledElement = /* @__PURE__ */ function(o) {
  __extends$2(t, o);
  function t() {
    var r = o !== null && o.apply(this, arguments) || this;
    return r.injectResult = null, r.tag = "div", r;
  }
  var e = t.prototype;
  return e.render = function() {
    var r = this.props, S = r.className, T = S === void 0 ? "" : S;
    r.cspNonce;
    var D = r.portalContainer, N = __rest$1(r, ["className", "cspNonce", "portalContainer"]), B = this.injector.className, $ = this.tag, U = {};
    return version.indexOf("simple") > -1 && D && (U = {
      portalContainer: D
    }), createElement($, __assign$2({
      ref: ref(this, "element"),
      "data-styled-id": B,
      className: T + " " + B
    }, U, N));
  }, e.componentDidMount = function() {
    this.injectResult = this.injector.inject(this.element, {
      nonce: this.props.cspNonce
    });
  }, e.componentWillUnmount = function() {
    this.injectResult.destroy(), this.injectResult = null;
  }, e.getElement = function() {
    return this.element;
  }, t;
}(Component);
function styled(o, t) {
  var e = styled$1(t);
  return /* @__PURE__ */ function(r) {
    __extends$2(S, r);
    function S() {
      var T = r !== null && r.apply(this, arguments) || this;
      return T.injector = e, T.tag = o, T;
    }
    return S;
  }(StyledElement);
}
var extendStatics$1 = function(o, t) {
  return extendStatics$1 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      Object.prototype.hasOwnProperty.call(r, S) && (e[S] = r[S]);
  }, extendStatics$1(o, t);
};
function __extends$1(o, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  extendStatics$1(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$1 = function() {
  return __assign$1 = Object.assign || function(t) {
    for (var e, r = 1, S = arguments.length; r < S; r++) {
      e = arguments[r];
      for (var T in e)
        Object.prototype.hasOwnProperty.call(e, T) && (t[T] = e[T]);
    }
    return t;
  }, __assign$1.apply(this, arguments);
};
function __rest(o, t) {
  var e = {};
  for (var r in o)
    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var S = 0, r = Object.getOwnPropertySymbols(o); S < r.length; S++)
      t.indexOf(r[S]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[S]) && (e[r[S]] = o[r[S]]);
  return e;
}
function __decorate$1(o, t, e, r) {
  var S = arguments.length, T = S < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, D;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    T = Reflect.decorate(o, t, e, r);
  else
    for (var N = o.length - 1; N >= 0; N--)
      (D = o[N]) && (T = (S < 3 ? D(T) : S > 3 ? D(t, e, T) : D(t, e)) || T);
  return S > 3 && T && Object.defineProperty(t, e, T), T;
}
function __spreadArray(o, t, e) {
  if (e || arguments.length === 2)
    for (var r = 0, S = t.length, T; r < S; r++)
      (T || !(r in t)) && (T || (T = Array.prototype.slice.call(t, 0, r)), T[r] = t[r]);
  return o.concat(T || Array.prototype.slice.call(t));
}
function makeAble(o, t) {
  var e;
  return __assign$1({
    events: {},
    props: (e = {}, e[o] = Boolean, e),
    name: o
  }, t);
}
function getSVGCursor(o, t) {
  return 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="'.concat(32 * o, 'px" height="').concat(32 * o, 'px" viewBox="0 0 32 32" ><path d="M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z" stroke-linejoin="round" stroke-width="1.2" fill="black" stroke="white" style="transform:rotate(').concat(t, 'deg);transform-origin: 16px 16px"></path></svg>');
}
function getCursorCSS(o) {
  var t = getSVGCursor(1, o), e = Math.round(o / 45) * 45 % 180, r = "ns-resize";
  return e === 135 ? r = "nwse-resize" : e === 45 ? r = "nesw-resize" : e === 90 && (r = "ew-resize"), "cursor:".concat(r, ";cursor: url('").concat(t, "') 16 16, ").concat(r, ";");
}
var agent = agent$1(), IS_WEBKIT = agent.browser.webkit, IS_WEBKIT605 = IS_WEBKIT && function() {
  var o = typeof window > "u" ? {
    userAgent: ""
  } : window.navigator, t = /applewebkit\/([^\s]+)/g.exec(o.userAgent.toLowerCase());
  return t ? parseFloat(t[1]) < 605 : !1;
}(), IS_FIREFOX = agent.browser.name === "firefox", IS_SAFARI_ABOVE15 = parseInt(agent.browser.webkitVersion, 10) >= 612 || parseInt(agent.browser.version, 10) >= 15, PREFIX = "moveable-", MOVEABLE_CSS = `
{
	position: absolute;
	width: 1px;
	height: 1px;
	left: 0;
	top: 0;
    z-index: 3000;
    --moveable-color: #4af;
    --zoom: 1;
    --zoompx: 1px;
    will-change: transform;
    outline: 1px solid transparent;
}
.control-box {
    z-index: 0;
}
.line, .control {
    position: absolute;
	left: 0;
    top: 0;
    will-change: transform;
}
.control {
	width: 14px;
	height: 14px;
	border-radius: 50%;
	border: 2px solid #fff;
	box-sizing: border-box;
    background: #4af;
    background: var(--moveable-color);
	margin-top: -7px;
    margin-left: -7px;
    border: 2px solid #fff;
    z-index: 10;
}
.padding {
    position: absolute;
    top: 0px;
    left: 0px;
    width: 100px;
    height: 100px;
    transform-origin: 0 0;
}
.line {
	width: 1px;
    height: 1px;
    background: #4af;
    background: var(--moveable-color);
	transform-origin: 0px 50%;
}
.line.edge {
    z-index: 1;
    background: transparent;
}
.line.dashed {
    box-sizing: border-box;
    background: transparent;
}
.line.dashed.horizontal {
    border-top: 1px dashed #4af;
    border-top-color: #4af;
    border-top-color: var(--moveable-color);
}
.line.dashed.vertical {
    border-left: 1px dashed #4af;
    border-left-color: #4af;
    border-left-color: var(--moveable-color);
}
.line.vertical {
    transform: translateX(-50%);
}
.line.horizontal {
    transform: translateY(-50%);
}
.line.vertical.bold {
    width: 2px;
}
.line.horizontal.bold {
    height: 2px;
}

.control.origin {
	border-color: #f55;
	background: #fff;
	width: 12px;
	height: 12px;
	margin-top: -6px;
    margin-left: -6px;
	pointer-events: none;
}
`.concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function(o) {
  return `
.direction[data-rotation="`.concat(o, '"], :global .view-control-rotation').concat(o, ` {
	`).concat(getCursorCSS(o), `
}
`);
}).join(`
`), `
.group {
    z-index: -1;
}
.area {
    position: absolute;
}
.area-pieces {
    position: absolute;
    top: 0;
    left: 0;
    display: none;
}
.area.avoid, .area.pass {
    pointer-events: none;
}
.area.avoid+.area-pieces {
    display: block;
}
.area-piece {
    position: absolute;
}

`).concat(IS_WEBKIT605 ? `:global svg *:before {
	content:"";
	transform-origin: inherit;
}` : "", `
`), NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]], FLOAT_POINT_NUM = 1e-4, TINY_NUM = 1e-7, MIN_SCALE = 1e-9, MAX_NUM = Math.pow(10, 10), MIN_NUM = -MAX_NUM, DIRECTIONS4 = ["n", "w", "s", "e"], DIRECTIONS = ["n", "w", "s", "e", "nw", "ne", "sw", "se"], DIRECTION_REGION_TO_DIRECTION = {
  n: [0, -1],
  e: [1, 0],
  s: [0, 1],
  w: [-1, 0],
  nw: [-1, -1],
  ne: [1, -1],
  sw: [-1, 1],
  se: [1, 1]
}, DIRECTION_INDEXES = {
  n: [0, 1],
  e: [1, 3],
  s: [3, 2],
  w: [2, 0],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
}, DIRECTION_ROTATIONS = {
  n: 0,
  s: 180,
  w: 270,
  e: 90,
  nw: 315,
  ne: 45,
  sw: 225,
  se: 135
}, MOVEABLE_METHODS = ["isMoveableElement", "updateRect", "updateTarget", "destroy", "dragStart", "isInside", "hitTest", "setState", "getRect", "request", "isDragging", "getManager", "forceUpdate", "waitToChangeTarget", "updateSelectors", "getTargets", "stopDrag"];
function setCustomDrag(o, t, e, r, S, T) {
  var D, N;
  T === void 0 && (T = "draggable");
  var B = (N = (D = t.gestos[T]) === null || D === void 0 ? void 0 : D.move(e, o.inputEvent)) !== null && N !== void 0 ? N : {}, $ = B.originalDatas || B.datas, U = $[T] || ($[T] = {});
  return __assign$1(__assign$1({}, S ? convertDragDist(t, B) : B), {
    isPinch: !!r,
    parentEvent: !0,
    datas: U,
    originalDatas: o.originalDatas
  });
}
var CustomGesto = /* @__PURE__ */ function() {
  function o(e) {
    var r;
    e === void 0 && (e = "draggable"), this.ableName = e, this.prevX = 0, this.prevY = 0, this.startX = 0, this.startY = 0, this.isDrag = !1, this.isFlag = !1, this.datas = {
      draggable: {}
    }, this.datas = (r = {}, r[e] = {}, r);
  }
  var t = o.prototype;
  return t.dragStart = function(e, r) {
    this.isDrag = !1, this.isFlag = !1;
    var S = r.originalDatas;
    return this.datas = S, S[this.ableName] || (S[this.ableName] = {}), __assign$1(__assign$1({}, this.move(e, r.inputEvent)), {
      type: "dragstart"
    });
  }, t.drag = function(e, r) {
    return this.move([e[0] - this.prevX, e[1] - this.prevY], r);
  }, t.move = function(e, r) {
    var S, T, D = !1;
    if (!this.isFlag)
      this.prevX = e[0], this.prevY = e[1], this.startX = e[0], this.startY = e[1], S = e[0], T = e[1], this.isFlag = !0;
    else {
      var N = this.isDrag;
      S = this.prevX + e[0], T = this.prevY + e[1], (e[0] || e[1]) && (this.isDrag = !0), !N && this.isDrag && (D = !0);
    }
    return this.prevX = S, this.prevY = T, {
      type: "drag",
      clientX: S,
      clientY: T,
      inputEvent: r,
      isFirstDrag: D,
      isDrag: this.isDrag,
      distX: S - this.startX,
      distY: T - this.startY,
      deltaX: e[0],
      deltaY: e[1],
      datas: this.datas[this.ableName],
      originalDatas: this.datas,
      parentEvent: !0,
      parentGesto: this
    };
  }, o;
}();
function calculatePointerDist(o, t) {
  var e = t.clientX, r = t.clientY, S = t.datas, T = o.state, D = T.moveableClientRect, N = T.rootMatrix, B = T.is3d, $ = T.pos1, U = D.left, H = D.top, V = B ? 4 : 3, X = minus(calculateInversePosition(N, [e - U, r - H], V), $), W = X[0], Y = X[1], q = getDragDist({
    datas: S,
    distX: W,
    distY: Y
  }), K = q[0], Z = q[1];
  return [K, Z];
}
function setDragStart(o, t) {
  var e = t.datas, r = o.state, S = r.allMatrix, T = r.beforeMatrix, D = r.is3d, N = r.left, B = r.top, $ = r.origin, U = r.offsetMatrix, H = r.targetMatrix, V = r.transformOrigin, X = D ? 4 : 3;
  e.is3d = D, e.matrix = S, e.targetMatrix = H, e.beforeMatrix = T, e.offsetMatrix = U, e.transformOrigin = V, e.inverseMatrix = invert(S, X), e.inverseBeforeMatrix = invert(T, X), e.absoluteOrigin = convertPositionMatrix(plus([N, B], $), X), e.startDragBeforeDist = calculate(e.inverseBeforeMatrix, e.absoluteOrigin, X), e.startDragDist = calculate(e.inverseMatrix, e.absoluteOrigin, X);
}
function getTransformDirection(o) {
  return calculateMoveablePosition(o.datas.beforeTransform, [50, 50], 100, 100).direction;
}
function resolveTransformEvent(o, t) {
  var e = o.datas, r = o.originalDatas.beforeRenderable, S = e.transformIndex, T = r.nextTransforms, D = T.length, N = r.nextTransformAppendedIndexes, B = 0;
  S === -1 ? (t === "translate" ? B = 0 : t === "rotate" && (B = findIndex(T, function(V) {
    return V.match(/scale\(/g);
  })), B === -1 && (B = T.length), e.transformIndex = B) : find$1(N, function(V) {
    return V.index === S && V.functionName === t;
  }) ? B = S : B = S + N.filter(function(V) {
    return V.index < S;
  }).length;
  var $ = convertTransformInfo(T, B), U = $.targetFunction, H = t === "rotate" ? "rotateZ" : t;
  e.beforeFunctionTexts = $.beforeFunctionTexts, e.afterFunctionTexts = $.afterFunctionTexts, e.beforeTransform = $.beforeFunctionMatrix, e.beforeTransform2 = $.beforeFunctionMatrix2, e.targetTansform = $.targetFunctionMatrix, e.afterTransform = $.afterFunctionMatrix, e.afterTransform2 = $.afterFunctionMatrix2, e.targetAllTransform = $.allFunctionMatrix, U.functionName === H ? (e.afterFunctionTexts.splice(0, 1), e.isAppendTransform = !1) : D > B && (e.isAppendTransform = !0, r.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], N, !0), [{
    functionName: t,
    index: B,
    isAppend: !0
  }], !1));
}
function convertTransformFormat(o, t, e) {
  return "".concat(o.beforeFunctionTexts.join(" "), " ").concat(o.isAppendTransform ? e : t, " ").concat(o.afterFunctionTexts.join(" "));
}
function getTransformDist(o) {
  var t = o.datas, e = o.distX, r = o.distY, S = getBeforeDragDist({
    datas: t,
    distX: e,
    distY: r
  }), T = S[0], D = S[1], N = getTransfromMatrix(t, fromTranslation([T, D], 4));
  return calculate(N, convertPositionMatrix([0, 0, 0], 4), 4);
}
function getTransfromMatrix(o, t, e) {
  var r = o.beforeTransform, S = o.afterTransform, T = o.beforeTransform2, D = o.afterTransform2, N = o.targetAllTransform, B = e ? multiply(N, t, 4) : multiply(t, N, 4), $ = multiply(invert(e ? T : r, 4), B, 4), U = multiply($, invert(e ? D : S, 4), 4);
  return U;
}
function getBeforeDragDist(o) {
  var t = o.datas, e = o.distX, r = o.distY, S = t.inverseBeforeMatrix, T = t.is3d, D = t.startDragBeforeDist, N = t.absoluteOrigin, B = T ? 4 : 3;
  return minus(calculate(S, plus(N, [e, r]), B), D);
}
function getDragDist(o, t) {
  var e = o.datas, r = o.distX, S = o.distY, T = e.inverseBeforeMatrix, D = e.inverseMatrix, N = e.is3d, B = e.startDragBeforeDist, $ = e.startDragDist, U = e.absoluteOrigin, H = N ? 4 : 3;
  return minus(calculate(t ? T : D, plus(U, [r, S]), H), t ? B : $);
}
function getInverseDragDist(o, t) {
  var e = o.datas, r = o.distX, S = o.distY, T = e.beforeMatrix, D = e.matrix, N = e.is3d, B = e.startDragBeforeDist, $ = e.startDragDist, U = e.absoluteOrigin, H = N ? 4 : 3;
  return minus(calculate(t ? T : D, plus(t ? B : $, [r, S]), H), U);
}
function calculateTransformOrigin(o, t, e, r, S, T) {
  return r === void 0 && (r = t), S === void 0 && (S = e), T === void 0 && (T = [0, 0]), o ? o.map(function(D, N) {
    var B = splitUnit(D), $ = B.value, U = B.unit, H = N ? S : r, V = N ? e : t;
    if (D === "%" || isNaN($)) {
      var X = H ? T[N] / H : 0;
      return V * X;
    } else if (U !== "%")
      return $;
    return V * $ / 100;
  }) : T;
}
function getPosIndexesByDirection(o) {
  var t = [];
  return o[1] >= 0 && (o[0] >= 0 && t.push(3), o[0] <= 0 && t.push(2)), o[1] <= 0 && (o[0] >= 0 && t.push(1), o[0] <= 0 && t.push(0)), t;
}
function getPosesByDirection(o, t) {
  return getPosIndexesByDirection(t).map(function(e) {
    return o[e];
  });
}
function getPosByDirection(o, t) {
  var e = (t[0] + 1) / 2, r = (t[1] + 1) / 2, S = [dot(o[0][0], o[1][0], e, 1 - e), dot(o[0][1], o[1][1], e, 1 - e)], T = [dot(o[2][0], o[3][0], e, 1 - e), dot(o[2][1], o[3][1], e, 1 - e)];
  return [dot(S[0], T[0], r, 1 - r), dot(S[1], T[1], r, 1 - r)];
}
function getDist(o, t, e, r, S, T) {
  var D = calculatePoses(t, e, r, S), N = getPosByDirection(D, T), B = o[0] - N[0], $ = o[1] - N[1];
  return [B, $];
}
function getNextMatrix(o, t, e, r) {
  return multiply(o, getAbsoluteMatrix(t, r, e), r);
}
function getNextTransformMatrix(o, t, e) {
  var r = o.transformOrigin, S = o.offsetMatrix, T = o.is3d, D = t.beforeTransform, N = t.afterTransform, B = T ? 4 : 3, $ = parseMat([e]);
  return getNextMatrix(S, convertDimension(multiply(multiply(D, $, 4), N, 4), 4, B), r, B);
}
function scaleMatrix(o, t) {
  var e = o.transformOrigin, r = o.offsetMatrix, S = o.is3d, T = o.targetMatrix, D = S ? 4 : 3;
  return getNextMatrix(r, multiply(T, createScaleMatrix(t, D), D), e, D);
}
function fillTransformStartEvent(o) {
  var t = getBeforeRenderableDatas(o);
  return {
    setTransform: function(e, r) {
      r === void 0 && (r = -1), t.startTransforms = isArray(e) ? e : splitSpace(e), setTransformIndex(o, r);
    },
    setTransformIndex: function(e) {
      setTransformIndex(o, e);
    }
  };
}
function setDefaultTransformIndex(o, t) {
  var e = getBeforeRenderableDatas(o), r = e.startTransforms;
  setTransformIndex(o, findIndex(r, function(S) {
    return S.indexOf("".concat(t, "(")) === 0;
  }));
}
function setTransformIndex(o, t) {
  var e = getBeforeRenderableDatas(o), r = o.datas;
  if (r.transformIndex = t, t !== -1) {
    var S = e.startTransforms[t];
    if (S) {
      var T = parse$1([S]);
      r.startValue = T[0].functionValue;
    }
  }
}
function fillOriginalTransform(o, t) {
  var e = getBeforeRenderableDatas(o);
  e.nextTransforms = splitSpace(t);
}
function getBeforeRenderableDatas(o) {
  return o.originalDatas.beforeRenderable;
}
function getNextTransforms(o) {
  var t = o.originalDatas.beforeRenderable;
  return t.nextTransforms;
}
function getNextTransformText(o) {
  return getNextTransforms(o).join(" ");
}
function getNextStyle(o) {
  return getBeforeRenderableDatas(o).nextStyle;
}
function fillTransformEvent(o, t, e, r, S) {
  fillOriginalTransform(S, t);
  var T = Draggable.drag(o, setCustomDrag(S, o.state, e, r, !1)), D = T ? T.transform : t;
  return __assign$1(__assign$1({
    transform: t,
    drag: T
  }, fillCSSObject({
    transform: D
  }, S)), {
    afterTransform: D
  });
}
function getTranslateDist(o, t, e, r, S) {
  var T = o.state, D = T.left, N = T.top, B = o.props.groupable, $ = getNextTransformMatrix(o.state, S, t), U = B ? D : 0, H = B ? N : 0, V = getDirectionOffset(o, e, $), X = minus(r, V);
  return minus(X, [U, H]);
}
function getScaleDist(o, t, e, r, S) {
  var T = getTranslateDist(o, "scale(".concat(t.join(", "), ")"), e, r, S);
  return T;
}
function getDirectionByPos(o, t, e) {
  return [-1 + o[0] / (t / 2), -1 + o[1] / (e / 2)];
}
function getDirectionOffset(o, t, e) {
  e === void 0 && (e = o.state.allMatrix);
  var r = o.state, S = r.width, T = r.height, D = r.is3d, N = D ? 4 : 3, B = [S / 2 * (1 + t[0]), T / 2 * (1 + t[1])];
  return calculatePosition(e, B, N);
}
function getRotateDist(o, t, e) {
  var r = e.fixedDirection, S = e.fixedPosition;
  return getTranslateDist(o, "rotate(".concat(t, "deg)"), r, S, e);
}
function getResizeDist(o, t, e, r, S, T) {
  var D = o.props.groupable, N = o.state, B = N.transformOrigin, $ = N.offsetMatrix, U = N.is3d, H = N.width, V = N.height, X = N.left, W = N.top, Y = T.fixedDirection, q = T.nextTargetMatrix || N.targetMatrix, K = U ? 4 : 3, Z = calculateTransformOrigin(S, t, e, H, V, B), J = D ? X : 0, Q = D ? W : 0, rt = getNextMatrix($, q, Z, K), et = getDist(r, rt, t, e, K, Y);
  return minus(et, [J, Q]);
}
function getAbsolutePosition(o, t) {
  return getPosByDirection(getAbsolutePosesByState(o.state), t);
}
function getGestoData(o, t) {
  var e = o.targetGesto, r = o.controlGesto, S;
  return e != null && e.isFlag() && (S = e.getEventData()[t]), !S && (r != null && r.isFlag()) && (S = r.getEventData()[t]), S || {};
}
function multiply2(o, t) {
  return [o[0] * t[0], o[1] * t[1]];
}
function prefix() {
  for (var o = [], t = 0; t < arguments.length; t++)
    o[t] = arguments[t];
  return prefixNames.apply(void 0, __spreadArray([PREFIX], o, !1));
}
function defaultSync(o) {
  o();
}
function getTransformMatrix(o) {
  return !o || o === "none" ? [1, 0, 0, 1, 0, 0] : isObject$2(o) ? o : parseMat(o);
}
function getAbsoluteMatrix(o, t, e) {
  return multiplies(t, createOriginMatrix(e, t), o, createOriginMatrix(e.map(function(r) {
    return -r;
  }), t));
}
function measureSVGSize(o, t, e) {
  if (t === "%") {
    var r = getSVGViewBox(o.ownerSVGElement);
    return r[e ? "width" : "height"] / 100;
  }
  return 1;
}
function getBeforeTransformOrigin(o) {
  var t = getTransformOrigin(getComputedStyle$1$1(o, ":before"));
  return t.map(function(e, r) {
    var S = splitUnit(e), T = S.value, D = S.unit;
    return T * measureSVGSize(o, D, r === 0);
  });
}
function getTransformOrigin(o) {
  var t = o.transformOrigin;
  return t ? t.split(" ") : ["0", "0"];
}
function getElementTransform(o, t) {
  t === void 0 && (t = getComputedStyle$1$1(o));
  var e = t.transform;
  if (e && e !== "none")
    return t.transform;
  if ("transform" in o) {
    var r = o.transform, S = r.baseVal;
    if (!S)
      return "";
    var T = S.length;
    if (!T)
      return "";
    for (var D = [], N = function($) {
      var U = S[$].matrix;
      D.push("matrix(".concat(["a", "b", "c", "d", "e", "f"].map(function(H) {
        return U[H];
      }).join(", "), ")"));
    }, B = 0; B < T; ++B)
      N(B);
    return D.join(" ");
  }
  return "";
}
function getOffsetInfo(o, t, e, r, S) {
  var T, D, N, B = o && o.ownerDocument ? o.ownerDocument : document, $ = B.documentElement || B.body, U = !1, H, V;
  if (!o || e)
    H = o;
  else {
    var X = (T = o == null ? void 0 : o.assignedSlot) === null || T === void 0 ? void 0 : T.parentElement, W = o.parentElement;
    X ? (U = !0, V = W, H = X) : H = W;
  }
  for (var Y = !1, q = o === t || H === t, K = "relative", Z = 1, J = parseFloat((D = S) === null || D === void 0 ? void 0 : D.zoom) || 1, Q = S == null ? void 0 : S.position; H && H !== $; ) {
    t === H && (q = !0);
    var rt = getComputedStyle$1$1(H), et = H.tagName.toLowerCase(), nt = getElementTransform(H, rt), st = rt.willChange, it = parseFloat(rt.zoom) || 1;
    if (K = rt.position, r && it !== 1) {
      Z = it;
      break;
    }
    if (// offsetParent is the parentElement if the target's zoom is not 1 and not absolute.
    !e && r && J !== 1 && Q && Q !== "absolute" || et === "svg" || K !== "static" || nt && nt !== "none" || st === "transform")
      break;
    var ot = (N = o == null ? void 0 : o.assignedSlot) === null || N === void 0 ? void 0 : N.parentNode, ht = H.parentNode;
    ot && (U = !0, V = ht);
    var ct = ot || ht;
    if (ct && ct.nodeType === 11) {
      H = ct.host, Y = !0;
      break;
    }
    H = ct, K = "relative";
  }
  return {
    offsetZoom: Z,
    hasSlot: U,
    parentSlotElement: V,
    isCustomElement: Y,
    isStatic: K === "static",
    isEnd: q || !H || H === $,
    offsetParent: H || $
  };
}
function getOffsetPosInfo(o, t, e) {
  var r, S = o.tagName.toLowerCase(), T = o.offsetLeft, D = o.offsetTop, N = isUndefined(T), B = !N, $, U;
  return !B && S !== "svg" ? ($ = IS_WEBKIT605 ? getBeforeTransformOrigin(o) : getTransformOrigin(e).map(function(H) {
    return parseFloat(H);
  }), U = $.slice(), B = !0, r = getSVGGraphicsOffset(o, $, o === t && t.tagName.toLowerCase() === "g"), T = r[0], D = r[1], $[0] = r[2], $[1] = r[3]) : ($ = getTransformOrigin(e).map(function(H) {
    return parseFloat(H);
  }), U = $.slice()), {
    tagName: S,
    isSVG: N,
    hasOffset: B,
    offset: [T || 0, D || 0],
    origin: $,
    targetOrigin: U
  };
}
function getBodyOffset(o, t, e) {
  e === void 0 && (e = getComputedStyle$1$1(o));
  var r = getComputedStyle$1$1(document.body), S = r.position;
  if (!t && (!S || S === "static"))
    return [0, 0];
  var T = parseInt(r.marginLeft, 10), D = parseInt(r.marginTop, 10);
  return e.position === "absolute" && ((e.top !== "auto" || e.bottom !== "auto") && (D = 0), (e.left !== "auto" || e.right !== "auto") && (T = 0)), [T, D];
}
function convert3DMatrixes(o) {
  o.forEach(function(t) {
    var e = t.matrix;
    e && (t.matrix = convertDimension(e, 3, 4));
  });
}
function getPositionFixedInfo(o) {
  for (var t = o.parentElement, e = !1; t; ) {
    var r = getComputedStyle$1$1(t).transform;
    if (r && r !== "none") {
      e = !0;
      break;
    }
    if (t === document.body)
      break;
    t = t.parentElement;
  }
  return {
    fixedContainer: t || document.body,
    hasTransform: e
  };
}
function makeMatrixCSS(o, t) {
  return t === void 0 && (t = o.length > 9), "".concat(t ? "matrix3d" : "matrix", "(").concat(convertMatrixtoCSS(o, !t).join(","), ")");
}
function getSVGViewBox(o) {
  var t = o.clientWidth, e = o.clientHeight;
  if (!o)
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      clientWidth: t,
      clientHeight: e
    };
  var r = o.viewBox, S = r && r.baseVal || {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  return {
    x: S.x,
    y: S.y,
    width: S.width || t,
    height: S.height || e,
    clientWidth: t,
    clientHeight: e
  };
}
function getSVGMatrix(o, t) {
  var e = getSVGViewBox(o), r = e.width, S = e.height, T = e.clientWidth, D = e.clientHeight, N = T / r, B = D / S, $ = o.preserveAspectRatio.baseVal, U = $.align, H = $.meetOrSlice, V = [0, 0], X = [N, B], W = [0, 0];
  if (U !== 1) {
    var Y = (U - 2) % 3, q = Math.floor((U - 2) / 3);
    V[0] = r * Y / 2, V[1] = S * q / 2;
    var K = H === 2 ? Math.max(B, N) : Math.min(N, B);
    X[0] = K, X[1] = K, W[0] = (T - r) / 2 * Y, W[1] = (D - S) / 2 * q;
  }
  var Z = createScaleMatrix(X, t);
  return Z[t * (t - 1)] = W[0], Z[t * (t - 1) + 1] = W[1], getAbsoluteMatrix(Z, t, V);
}
function getSVGGraphicsOffset(o, t, e) {
  if (!o.getBBox || !e && o.tagName.toLowerCase() === "g")
    return [0, 0, 0, 0];
  var r = o.getBBox(), S = getSVGViewBox(o.ownerSVGElement), T = r.x - S.x, D = r.y - S.y;
  return [T, D, t[0] - T, t[1] - D];
}
function calculatePosition(o, t, e) {
  return calculate(o, convertPositionMatrix(t, e), e);
}
function calculatePoses(o, t, e, r) {
  return [[0, 0], [t, 0], [0, e], [t, e]].map(function(S) {
    return calculatePosition(o, S, r);
  });
}
function getRect(o) {
  var t = o.map(function($) {
    return $[0];
  }), e = o.map(function($) {
    return $[1];
  }), r = Math.min.apply(Math, t), S = Math.min.apply(Math, e), T = Math.max.apply(Math, t), D = Math.max.apply(Math, e), N = T - r, B = D - S;
  return {
    left: r,
    top: S,
    right: T,
    bottom: D,
    width: N,
    height: B
  };
}
function calculateRect(o, t, e, r) {
  var S = calculatePoses(o, t, e, r);
  return getRect(S);
}
function getSVGOffset(o, t, e, r, S) {
  var T, D = o.target, N = o.origin, B = t.matrix, $ = getSize(D), U = $.offsetWidth, H = $.offsetHeight, V = e.getBoundingClientRect(), X = [0, 0];
  e === document.body && (X = getBodyOffset(D, !0));
  for (var W = D.getBoundingClientRect(), Y = W.left - V.left + e.scrollLeft - (e.clientLeft || 0) + X[0], q = W.top - V.top + e.scrollTop - (e.clientTop || 0) + X[1], K = W.width, Z = W.height, J = multiplies(r, S, B), Q = calculateRect(J, U, H, r), rt = Q.left, et = Q.top, nt = Q.width, st = Q.height, it = calculatePosition(J, N, r), ot = minus(it, [rt, et]), ht = [Y + ot[0] * K / nt, q + ot[1] * Z / st], ct = [0, 0], vt = 0; ++vt < 10; ) {
    var _t = invert(S, r);
    T = minus(calculatePosition(_t, ht, r), calculatePosition(_t, it, r)), ct[0] = T[0], ct[1] = T[1];
    var gt = multiplies(r, S, createOriginMatrix(ct, r), B), mt = calculateRect(gt, U, H, r), Et = mt.left, wt = mt.top, xt = Et - Y, pt = wt - q;
    if (Math.abs(xt) < 2 && Math.abs(pt) < 2)
      break;
    ht[0] -= xt, ht[1] -= pt;
  }
  return ct.map(function(yt) {
    return Math.round(yt);
  });
}
function calculateMoveableClientPositions(o, t, e) {
  var r = o.length === 16, S = r ? 4 : 3, T = t.map(function(B) {
    return calculatePosition(o, B, S);
  }), D = e.left, N = e.top;
  return T.map(function(B) {
    return [B[0] + D, B[1] + N];
  });
}
function calculateMoveablePosition(o, t, e, r) {
  var S = o.length === 16, T = S ? 4 : 3, D = calculatePoses(o, e, r, T), N = D[0], B = N[0], $ = N[1], U = D[1], H = U[0], V = U[1], X = D[2], W = X[0], Y = X[1], q = D[3], K = q[0], Z = q[1], J = calculatePosition(o, t, T), Q = J[0], rt = J[1], et = Math.min(B, H, W, K), nt = Math.min($, V, Y, Z), st = Math.max(B, H, W, K), it = Math.max($, V, Y, Z);
  B = B - et || 0, H = H - et || 0, W = W - et || 0, K = K - et || 0, $ = $ - nt || 0, V = V - nt || 0, Y = Y - nt || 0, Z = Z - nt || 0, Q = Q - et || 0, rt = rt - nt || 0;
  var ot = getShapeDirection(calculatePoses(o, 100, 100, T));
  return {
    left: et,
    top: nt,
    right: st,
    bottom: it,
    origin: [Q, rt],
    pos1: [B, $],
    pos2: [H, V],
    pos3: [W, Y],
    pos4: [K, Z],
    direction: ot
  };
}
function getDistSize(o) {
  return Math.sqrt(o[0] * o[0] + o[1] * o[1]);
}
function getDiagonalSize(o, t) {
  return getDistSize([t[0] - o[0], t[1] - o[1]]);
}
function getLineStyle(o, t, e, r) {
  e === void 0 && (e = 1), r === void 0 && (r = getRad$1(o, t));
  var S = getDiagonalSize(o, t);
  return {
    transform: "translateY(-50%) translate(".concat(o[0], "px, ").concat(o[1], "px) rotate(").concat(r, "rad) scaleY(").concat(e, ")"),
    width: "".concat(S, "px")
  };
}
function getControlTransform(o, t) {
  for (var e = [], r = 2; r < arguments.length; r++)
    e[r - 2] = arguments[r];
  var S = e.length, T = e.reduce(function(N, B) {
    return N + B[0];
  }, 0) / S, D = e.reduce(function(N, B) {
    return N + B[1];
  }, 0) / S;
  return {
    transform: "translateZ(0px) translate(".concat(T, "px, ").concat(D, "px) rotate(").concat(o, "rad) scale(").concat(t, ")")
  };
}
function getProps(o, t) {
  var e = o[t];
  return isObject$2(e) ? __assign$1(__assign$1({}, o), e) : o;
}
function getSize(o, t) {
  t === void 0 && (t = o ? getComputedStyle$1$1(o) : null);
  var e = o && !isUndefined(o.offsetWidth), r = 0, S = 0, T = 0, D = 0, N = 0, B = 0, $ = 0, U = 0, H = 0, V = 0, X = 0, W = 0, Y = 1 / 0, q = 1 / 0, K = 1 / 0, Z = 1 / 0, J = 0, Q = 0, rt = !1;
  if (o)
    if (!e && o.tagName.toLowerCase() !== "svg") {
      var et = o.getBBox();
      rt = !0, r = et.width, S = et.height, N = r, B = S, $ = r, U = S, T = r, D = S;
    } else {
      var nt = o.style, st = t.boxSizing === "border-box", it = parseFloat(t.borderLeftWidth) || 0, ot = parseFloat(t.borderRightWidth) || 0, ht = parseFloat(t.borderTopWidth) || 0, ct = parseFloat(t.borderBottomWidth) || 0, vt = parseFloat(t.paddingLeft) || 0, _t = parseFloat(t.paddingRight) || 0, gt = parseFloat(t.paddingTop) || 0, mt = parseFloat(t.paddingBottom) || 0, Et = vt + _t, wt = gt + mt, xt = it + ot, pt = ht + ct, yt = Et + xt, Dt = wt + pt, At = t.position, It = 0, Ot = 0;
      if ("clientLeft" in o) {
        var ft = null;
        if (At === "absolute") {
          var Ft = getOffsetInfo(o, document.body);
          ft = Ft.offsetParent;
        } else
          ft = o.parentElement;
        if (ft) {
          var Mt = getComputedStyle$1$1(ft);
          It = parseFloat(Mt.width), Ot = parseFloat(Mt.height);
        }
      }
      H = Math.max(Et, convertUnitSize(t.minWidth, It) || 0), V = Math.max(wt, convertUnitSize(t.minHeight, Ot) || 0), Y = convertUnitSize(t.maxWidth, It), q = convertUnitSize(t.maxHeight, Ot), isNaN(Y) && (Y = 1 / 0), isNaN(q) && (q = 1 / 0), J = convertUnitSize(nt.width, 0) || 0, Q = convertUnitSize(nt.height, 0) || 0, N = parseFloat(t.width) || 0, B = parseFloat(t.height) || 0, $ = Math.abs(N - J) < 1 ? between(H, J || N, Y) : N, U = Math.abs(B - Q) < 1 ? between(V, Q || B, q) : B, r = $, S = U, T = $, D = U, st ? (K = Y, Z = q, X = H, W = V, $ = r - yt, U = S - Dt) : (K = Y + yt, Z = q + Dt, X = H + yt, W = V + Dt, r = $ + yt, S = U + Dt), T = $ + Et, D = U + wt;
    }
  return {
    svg: rt,
    offsetWidth: r,
    offsetHeight: S,
    clientWidth: T,
    clientHeight: D,
    contentWidth: $,
    contentHeight: U,
    inlineCSSWidth: J,
    inlineCSSHeight: Q,
    cssWidth: N,
    cssHeight: B,
    minWidth: H,
    minHeight: V,
    maxWidth: Y,
    maxHeight: q,
    minOffsetWidth: X,
    minOffsetHeight: W,
    maxOffsetWidth: K,
    maxOffsetHeight: Z
  };
}
function getRotationRad(o, t) {
  return getRad$1(t > 0 ? o[0] : o[1], t > 0 ? o[1] : o[0]);
}
function resetClientRect() {
  return {
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    right: 0,
    bottom: 0,
    clientLeft: 0,
    clientTop: 0,
    clientWidth: 0,
    clientHeight: 0,
    scrollWidth: 0,
    scrollHeight: 0
  };
}
function getExtendsRect(o, t) {
  var e = o === document.body || o === document.documentElement, r = {
    clientLeft: o.clientLeft,
    clientTop: o.clientTop,
    clientWidth: o.clientWidth,
    clientHeight: o.clientHeight,
    scrollWidth: o.scrollWidth,
    scrollHeight: o.scrollHeight,
    overflow: !1
  };
  return e && (r.clientHeight = Math.max(t.height, r.clientHeight), r.scrollHeight = Math.max(t.height, r.scrollHeight)), r.overflow = getComputedStyle$1$1(o).overflow !== "visible", __assign$1(__assign$1({}, t), r);
}
function getClientRectByPosition(o, t, e, r) {
  var S = o.left, T = o.right, D = o.top, N = o.bottom, B = t.top, $ = t.left, U = {
    left: $ + S,
    top: B + D,
    right: $ + T,
    bottom: B + N,
    width: T - S,
    height: N - D
  };
  return e && r ? getExtendsRect(e, U) : U;
}
function getClientRect(o, t) {
  var e = 0, r = 0, S = 0, T = 0;
  if (o) {
    var D = o.getBoundingClientRect();
    e = D.left, r = D.top, S = D.width, T = D.height;
  }
  var N = {
    left: e,
    top: r,
    width: S,
    height: T,
    right: e + S,
    bottom: r + T
  };
  return o && t ? getExtendsRect(o, N) : N;
}
function getTotalDirection(o, t, e, r) {
  var S;
  if (o)
    S = o;
  else if (t)
    S = [0, 0];
  else {
    var T = e.target;
    S = getDirection(T, r);
  }
  return S;
}
function getDirection(o, t) {
  if (o) {
    var e = o.getAttribute("data-rotation") || "", r = o.getAttribute("data-direction");
    if (t.deg = e, !!r) {
      var S = [0, 0];
      return r.indexOf("w") > -1 && (S[0] = -1), r.indexOf("e") > -1 && (S[0] = 1), r.indexOf("n") > -1 && (S[1] = -1), r.indexOf("s") > -1 && (S[1] = 1), S;
    }
  }
}
function getAbsolutePoses(o, t) {
  return [plus(t, o[0]), plus(t, o[1]), plus(t, o[2]), plus(t, o[3])];
}
function getAbsolutePosesByState(o) {
  var t = o.left, e = o.top, r = o.pos1, S = o.pos2, T = o.pos3, D = o.pos4;
  return getAbsolutePoses([r, S, T, D], [t, e]);
}
function roundSign(o) {
  return Math.round(o % 1 === -0.5 ? o - 1 : o);
}
function unset(o, t) {
  var e;
  (e = o[t]) === null || e === void 0 || e.unset(), o[t] = null;
}
function fillCSSObject(o, t) {
  if (t) {
    var e = getBeforeRenderableDatas(t);
    e.nextStyle = __assign$1(__assign$1({}, e.nextStyle), o);
  }
  return {
    style: o,
    cssText: getKeys(o).map(function(r) {
      return "".concat(decamelize(r, "-"), ": ").concat(o[r], ";");
    }).join("")
  };
}
function fillAfterTransform(o, t, e) {
  var r = t.afterTransform || t.transform;
  return __assign$1(__assign$1({}, fillCSSObject(__assign$1(__assign$1(__assign$1({}, o.style), t.style), {
    transform: r
  }), e)), {
    afterTransform: r,
    transform: o.transform
  });
}
function fillParams(o, t, e, r) {
  var S = t.datas;
  S.datas || (S.datas = {});
  var T = __assign$1(__assign$1({}, e), {
    target: o.state.target,
    clientX: t.clientX,
    clientY: t.clientY,
    inputEvent: t.inputEvent,
    currentTarget: o,
    moveable: o,
    datas: S.datas,
    isFirstDrag: !!t.isFirstDrag,
    stopAble: function() {
      S.isEventStart = !1;
    },
    stopDrag: function() {
      var D;
      (D = t.stop) === null || D === void 0 || D.call(t);
    }
  });
  return S.isStartEvent ? r || (S.lastEvent = T) : S.isStartEvent = !0, T;
}
function fillEndParams(o, t, e) {
  var r = t.datas, S = "isDrag" in e ? e.isDrag : t.isDrag;
  return r.datas || (r.datas = {}), __assign$1(__assign$1({
    isDrag: S
  }, e), {
    moveable: o,
    target: o.state.target,
    clientX: t.clientX,
    clientY: t.clientY,
    inputEvent: t.inputEvent,
    currentTarget: o,
    lastEvent: r.lastEvent,
    isDouble: t.isDouble,
    datas: r.datas,
    isFirstDrag: !!t.isFirstDrag
  });
}
function catchEvent(o, t, e) {
  o._emitter.on(t, e);
}
function triggerEvent(o, t, e, r) {
  return o.triggerEvent(t, e, r);
}
function getComputedStyle$1$1(o, t) {
  return window.getComputedStyle(o, t);
}
function filterAbles(o, t, e) {
  var r = {}, S = {};
  return o.filter(function(T) {
    var D = T.name;
    if (r[D] || !t.some(function(N) {
      return T[N];
    }))
      return !1;
    if (!e && T.ableGroup) {
      if (S[T.ableGroup])
        return !1;
      S[T.ableGroup] = !0;
    }
    return r[D] = !0, !0;
  });
}
function equals(o, t) {
  return o === t || o == null && t == null;
}
function selectValue() {
  for (var o = [], t = 0; t < arguments.length; t++)
    o[t] = arguments[t];
  for (var e = o.length - 1, r = 0; r < e; ++r) {
    var S = o[r];
    if (!isUndefined(S))
      return S;
  }
  return o[e];
}
function groupBy(o, t) {
  var e = [], r = [];
  return o.forEach(function(S, T) {
    var D = t(S, T, o), N = r.indexOf(D), B = e[N] || [];
    N === -1 && (r.push(D), e.push(B)), B.push(S);
  }), e;
}
function groupByMap(o, t) {
  var e = [], r = {};
  return o.forEach(function(S, T) {
    var D = t(S, T, o), N = r[D];
    N || (N = [], r[D] = N, e.push(N)), N.push(S);
  }), e;
}
function flat(o) {
  return o.reduce(function(t, e) {
    return t.concat(e);
  }, []);
}
function maxOffset() {
  for (var o = [], t = 0; t < arguments.length; t++)
    o[t] = arguments[t];
  return o.sort(function(e, r) {
    return Math.abs(r) - Math.abs(e);
  }), o[0];
}
function calculateInversePosition(o, t, e) {
  return calculate(invert(o, e), convertPositionMatrix(t, e), e);
}
function convertDragDist(o, t) {
  var e, r = o.is3d, S = o.rootMatrix, T = r ? 4 : 3;
  return e = calculateInversePosition(S, [t.distX, t.distY], T), t.distX = e[0], t.distY = e[1], t;
}
function calculatePadding(o, t, e, r, S) {
  return minus(calculatePosition(o, plus(e, t), S), r);
}
function convertCSSSize(o, t, e) {
  return e ? "".concat(o / t * 100, "%") : "".concat(o, "px");
}
function getTinyDist(o) {
  return Math.abs(o) <= TINY_NUM ? 0 : o;
}
function getDirectionViewClassName(o) {
  return function(t) {
    if (!t.isDragging(o))
      return "";
    var e = getGestoData(t, o), r = e.deg;
    return r ? prefix("view-control-rotation".concat(r)) : "";
  };
}
function getDirectionCondition(o, t) {
  return t === void 0 && (t = [o]), function(e, r) {
    if (r.isRequest)
      return t.some(function(T) {
        return r.requestAble === T;
      }) ? r.parentDirection : !1;
    var S = r.inputEvent.target;
    return hasClass(S, prefix("direction")) && (!o || hasClass(S, prefix(o)));
  };
}
function invertObject(o) {
  var t = {};
  for (var e in o)
    t[o[e]] = e;
  return t;
}
function convertTransformInfo(o, t) {
  var e = o.slice(0, t < 0 ? void 0 : t), r = o.slice(0, t < 0 ? void 0 : t + 1), S = o[t] || "", T = t < 0 ? [] : o.slice(t), D = t < 0 ? [] : o.slice(t + 1), N = parse$1(e), B = parse$1(r), $ = parse$1([S]), U = parse$1(T), H = parse$1(D), V = toMat(N), X = toMat(B), W = toMat(U), Y = toMat(H), q = multiply(V, W, 4);
  return {
    transforms: o,
    beforeFunctionMatrix: V,
    beforeFunctionMatrix2: X,
    targetFunctionMatrix: toMat($),
    afterFunctionMatrix: W,
    afterFunctionMatrix2: Y,
    allFunctionMatrix: q,
    beforeFunctions: N,
    beforeFunctions2: B,
    targetFunction: $[0],
    afterFunctions: U,
    afterFunctions2: H,
    beforeFunctionTexts: e,
    beforeFunctionTexts2: r,
    targetFunctionText: S,
    afterFunctionTexts: T,
    afterFunctionTexts2: D
  };
}
function isArrayFormat(o) {
  return !o || !isObject$2(o) || o instanceof Element ? !1 : isArray(o) || "length" in o;
}
function getRefTarget(o, t) {
  return o ? o instanceof Element ? o : isString$1(o) ? t ? document.querySelector(o) : o : isFunction$3(o) ? o() : "current" in o ? o.current : o : null;
}
function getRefTargets(o, t) {
  if (!o)
    return [];
  var e = isArrayFormat(o) ? [].slice.call(o) : [o];
  return e.reduce(function(r, S) {
    return isString$1(S) && t ? __spreadArray(__spreadArray([], r, !0), [].slice.call(document.querySelectorAll(S)), !0) : (isArray(S) ? r.push(getRefTargets(S, t)) : r.push(getRefTarget(S, t)), r);
  }, []);
}
function getAbsoluteRotation(o, t, e) {
  var r = getRad$1(o, t) / Math.PI * 180;
  return r = e >= 0 ? r : 180 - r, r = r >= 0 ? r : 360 + r, r;
}
function getDragDistByState(o, t) {
  var e = o.rootMatrix, r = o.is3d, S = r ? 4 : 3, T = invert(e, S);
  return r || (T = convertDimension(T, 3, 4)), T[12] = 0, T[13] = 0, T[14] = 0, calculateMatrixDist(T, t);
}
function getSizeDistByDist(o, t, e, r, S) {
  var T = o[0], D = o[1], N = 0, B = 0;
  if (S && T && D) {
    var $ = getRad$1([0, 0], t), U = getRad$1([0, 0], r), H = getDistSize(t), V = Math.cos($ - U) * H;
    if (!r[0])
      B = V, N = B * e;
    else if (!r[1])
      N = V, B = N / e;
    else {
      var X = r[0] * 2 * T, W = r[1] * 2 * D, Y = getDistSize([X + t[0], W + t[1]]) - getDistSize([X, W]), q = getRad$1([0, 0], [e, 1]);
      N = Math.cos(q) * Y, B = Math.sin(q) * Y;
    }
  } else
    N = r[0] * t[0], B = r[1] * t[1];
  return [N, B];
}
function getOffsetSizeDist(o, t, e, r) {
  var S, T = e.ratio, D = e.startOffsetWidth, N = e.startOffsetHeight, B = 0, $ = 0, U = r.distX, H = r.distY, V = r.parentDistance, X = r.parentDist, W = r.parentScale, Y = e.fixedDirection, q = [0, 1].map(function(et) {
    return Math.abs(o[et] - Y[et]);
  }), K = [0, 1].map(function(et) {
    var nt = q[et];
    return nt !== 0 && (nt = 2 / nt), nt;
  });
  if (X)
    B = X[0], $ = X[1], t && (B ? $ || ($ = B / T) : B = $ * T);
  else if (W)
    B = (W[0] - 1) * D, $ = (W[1] - 1) * N;
  else if (V) {
    var Z = D * q[0], J = N * q[1], Q = getDistSize([Z, J]);
    B = V / Q * Z * K[0], $ = V / Q * J * K[1];
  } else {
    var rt = getDragDist({
      datas: e,
      distX: U,
      distY: H
    });
    rt = K.map(function(et, nt) {
      return rt[nt] * et;
    }), S = getSizeDistByDist([D, N], rt, T, o, t), B = S[0], $ = S[1];
  }
  return {
    // direction,
    // sizeDirection,
    distWidth: B,
    distHeight: $
  };
}
function convertTransformUnit(o, t) {
  if (t) {
    if (o === "left")
      return {
        x: "0%",
        y: "50%"
      };
    if (o === "top")
      return {
        x: "50%",
        y: "50%"
      };
    if (o === "center")
      return {
        x: "50%",
        y: "50%"
      };
    if (o === "right")
      return {
        x: "100%",
        y: "50%"
      };
    if (o === "bottom")
      return {
        x: "50%",
        y: "100%"
      };
    var e = o.split(" "), r = e[0], S = e[1], T = convertTransformUnit(r || ""), D = convertTransformUnit(S || ""), N = __assign$1(__assign$1({}, T), D), B = {
      x: "50%",
      y: "50%"
    };
    return N.x && (B.x = N.x), N.y && (B.y = N.y), N.value && (N.x && !N.y && (B.y = N.value), !N.x && N.y && (B.x = N.value)), B;
  }
  return o === "left" ? {
    x: "0%"
  } : o === "right" ? {
    x: "100%"
  } : o === "top" ? {
    y: "0%"
  } : o === "bottom" ? {
    y: "100%"
  } : o ? o === "center" ? {
    value: "50%"
  } : {
    value: o
  } : {};
}
function convertTransformOriginArray(o, t, e) {
  var r = convertTransformUnit(o, !0), S = r.x, T = r.y;
  return [convertUnitSize(S, t) || 0, convertUnitSize(T, e) || 0];
}
function rotatePosesInfo(o, t, e) {
  var r = o.map(function(T) {
    return minus(T, t);
  }), S = r.map(function(T) {
    return rotate(T, e);
  });
  return {
    prev: r,
    next: S,
    result: S.map(function(T) {
      return plus(T, t);
    })
  };
}
function isDeepArrayEquals(o, t) {
  return o.length === t.length && o.every(function(e, r) {
    var S = t[r], T = isArray(e), D = isArray(S);
    return T && D ? isDeepArrayEquals(e, S) : !T && !D ? e === S : !1;
  });
}
var Pinchable = makeAble("pinchable", {
  events: {
    onPinchStart: "pinchStart",
    onPinch: "pinch",
    onPinchEnd: "pinchEnd",
    onPinchGroupStart: "pinchGroupStart",
    onPinchGroup: "pinchGroup",
    onPinchGroupEnd: "pinchGroupEnd"
  },
  dragStart: function() {
    return !0;
  },
  pinchStart: function(o, t) {
    var e = t.datas, r = t.targets, S = t.angle, T = t.originalDatas, D = o.props, N = D.pinchable, B = D.ables;
    if (!N)
      return !1;
    var $ = "onPinch".concat(r ? "Group" : "", "Start"), U = "drag".concat(r ? "Group" : "", "ControlStart"), H = (N === !0 ? o.controlAbles : B.filter(function(Y) {
      return N.indexOf(Y.name) > -1;
    })).filter(function(Y) {
      return Y.canPinch && Y[U];
    }), V = fillParams(o, t, {});
    r && (V.targets = r);
    var X = triggerEvent(o, $, V);
    e.isPinch = X !== !1, e.ables = H;
    var W = e.isPinch;
    return W ? (H.forEach(function(Y) {
      if (T[Y.name] = T[Y.name] || {}, !!Y[U]) {
        var q = __assign$1(__assign$1({}, t), {
          datas: T[Y.name],
          parentRotate: S,
          isPinch: !0
        });
        Y[U](o, q);
      }
    }), o.state.snapRenderInfo = {
      request: t.isRequest,
      direction: [0, 0]
    }, W) : !1;
  },
  pinch: function(o, t) {
    var e = t.datas, r = t.scale, S = t.distance, T = t.originalDatas, D = t.inputEvent, N = t.targets, B = t.angle;
    if (e.isPinch) {
      var $ = S * (1 - 1 / r), U = fillParams(o, t, {});
      N && (U.targets = N);
      var H = "onPinch".concat(N ? "Group" : "");
      triggerEvent(o, H, U);
      var V = e.ables, X = "drag".concat(N ? "Group" : "", "Control");
      return V.forEach(function(W) {
        W[X] && W[X](o, __assign$1(__assign$1({}, t), {
          datas: T[W.name],
          inputEvent: D,
          parentDistance: $,
          parentRotate: B,
          isPinch: !0
        }));
      }), U;
    }
  },
  pinchEnd: function(o, t) {
    var e = t.datas, r = t.isPinch, S = t.inputEvent, T = t.targets, D = t.originalDatas;
    if (e.isPinch) {
      var N = "onPinch".concat(T ? "Group" : "", "End"), B = fillEndParams(o, t, {
        isDrag: r
      });
      T && (B.targets = T), triggerEvent(o, N, B);
      var $ = e.ables, U = "drag".concat(T ? "Group" : "", "ControlEnd");
      return $.forEach(function(H) {
        H[U] && H[U](o, __assign$1(__assign$1({}, t), {
          isDrag: r,
          datas: D[H.name],
          inputEvent: S,
          isPinch: !0
        }));
      }), r;
    }
  },
  pinchGroupStart: function(o, t) {
    return this.pinchStart(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  },
  pinchGroup: function(o, t) {
    return this.pinch(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  },
  pinchGroupEnd: function(o, t) {
    return this.pinchEnd(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  }
});
function fillChildEvents(o, t, e) {
  var r = e.originalDatas;
  r.groupable = r.groupable || {};
  var S = r.groupable;
  S.childDatas = S.childDatas || [];
  var T = S.childDatas;
  return o.moveables.map(function(D, N) {
    return T[N] = T[N] || {}, T[N][t] = T[N][t] || {}, __assign$1(__assign$1({}, e), {
      datas: T[N][t],
      originalDatas: T[N]
    });
  });
}
function triggerChildGesto(o, t, e, r, S, T, D) {
  var N = !!e.match(/Start$/g), B = !!e.match(/End$/g), $ = S.isPinch, U = S.datas, H = fillChildEvents(o, t.name, S), V = o.moveables, X = H.map(function(W, Y) {
    var q = V[Y], K = q.state, Z = K.gestos, J = W;
    if (N)
      J = new CustomGesto(D).dragStart(r, W);
    else {
      if (Z[D] || (Z[D] = U.childGestos[Y]), !Z[D])
        return;
      J = setCustomDrag(W, K, r, $, T, D);
    }
    var Q = t[e](q, __assign$1(__assign$1({}, J), {
      parentFlag: !0
    }));
    return B && (Z[D] = null), Q;
  });
  return N && (U.childGestos = V.map(function(W) {
    return W.state.gestos[D];
  })), X;
}
function triggerChildAbles(o, t, e, r, S, T) {
  S === void 0 && (S = function(U, H) {
    return H;
  });
  var D = !!e.match(/End$/g), N = fillChildEvents(o, t.name, r), B = o.moveables, $ = N.map(function(U, H) {
    var V = B[H], X = U;
    X = S(V, U);
    var W = t[e](V, __assign$1(__assign$1({}, X), {
      parentFlag: !0
    }));
    return W && T && T(V, U, W, H), D && (V.state.gestos = {}), W;
  });
  return $;
}
var VERTICAL_NAMES = ["left", "right", "center"], HORIZONTAL_NAMES = ["top", "bottom", "middle"], VERTICAL_NAMES_MAP = {
  start: "left",
  end: "right",
  center: "center"
}, HORIZONTAL_NAMES_MAP = {
  start: "top",
  end: "bottom",
  center: "middle"
};
function hasGuidelines(o, t) {
  var e = o.props, r = e.snappable, S = e.bounds, T = e.innerBounds, D = e.verticalGuidelines, N = e.horizontalGuidelines, B = e.snapGridWidth, $ = e.snapGridHeight, U = o.state, H = U.guidelines, V = U.enableSnap;
  return !r || !V || t && r !== !0 && r.indexOf(t) < 0 ? !1 : !!(B || $ || S || T || H && H.length || D && D.length || N && N.length);
}
function getSnapDirections(o) {
  return o === !1 ? {} : o === !0 || !o ? {
    left: !0,
    right: !0,
    top: !0,
    bottom: !0
  } : o;
}
function mapSnapDirectionPoses(o, t) {
  var e = getSnapDirections(o), r = {};
  for (var S in e)
    S in t && e[S] && (r[S] = t[S]);
  return r;
}
function splitSnapDirectionPoses(o, t) {
  var e = mapSnapDirectionPoses(o, t), r = HORIZONTAL_NAMES.filter(function(T) {
    return T in e;
  }), S = VERTICAL_NAMES.filter(function(T) {
    return T in e;
  });
  return {
    horizontal: r.map(function(T) {
      return e[T];
    }),
    vertical: S.map(function(T) {
      return e[T];
    })
  };
}
function calculateContainerPos(o, t, e) {
  var r = calculatePosition(o, [t.clientLeft, t.clientTop], e);
  return [t.left + r[0], t.top + r[1]];
}
function solveLineConstants(o) {
  var t = o[0], e = o[1], r = e[0] - t[0], S = e[1] - t[1];
  Math.abs(r) < TINY_NUM$1 && (r = 0), Math.abs(S) < TINY_NUM$1 && (S = 0);
  var T = 0, D = 0, N = 0;
  return r ? S ? (T = -S / r, D = 1, N = T * t[0] - t[1]) : (D = 1, N = -t[1]) : (T = -1, N = t[0]), [T, D, N].map(function(B) {
    return throttle(B, TINY_NUM$1);
  });
}
function checkMoveableSnapPoses(o, t, e, r) {
  var S = o.props, T = selectValue(r, S.snapThreshold, 5);
  return checkSnapPoses(o.state.guidelines, t, e, T);
}
function checkSnapPoses(o, t, e, r) {
  return {
    vertical: checkSnap(o, "vertical", t, r),
    horizontal: checkSnap(o, "horizontal", e, r)
  };
}
function checkSnapKeepRatio(o, t, e) {
  var r = e[0], S = e[1], T = t[0], D = t[1], N = minus(e, t), B = N[0], $ = N[1], U = $ > 0, H = B > 0;
  B = getTinyDist(B), $ = getTinyDist($);
  var V = {
    isSnap: !1,
    offset: 0,
    pos: 0
  }, X = {
    isSnap: !1,
    offset: 0,
    pos: 0
  };
  if (B === 0 && $ === 0)
    return {
      vertical: V,
      horizontal: X
    };
  var W = checkMoveableSnapPoses(o, B ? [r] : [], $ ? [S] : []), Y = W.vertical, q = W.horizontal;
  Y.posInfos.filter(function(_t) {
    var gt = _t.pos;
    return H ? gt >= T : gt <= T;
  }), q.posInfos.filter(function(_t) {
    var gt = _t.pos;
    return U ? gt >= D : gt <= D;
  }), Y.isSnap = Y.posInfos.length > 0, q.isSnap = q.posInfos.length > 0;
  var K = getNearestSnapGuidelineInfo(Y), Z = K.isSnap, J = K.guideline, Q = getNearestSnapGuidelineInfo(q), rt = Q.isSnap, et = Q.guideline, nt = rt ? et.pos[1] : 0, st = Z ? J.pos[0] : 0;
  if (B === 0)
    rt && (X.isSnap = !0, X.pos = et.pos[1], X.offset = S - X.pos);
  else if ($ === 0)
    Z && (V.isSnap = !0, V.pos = st, V.offset = r - st);
  else {
    var it = $ / B, ot = e[1] - it * r, ht = 0, ct = 0, vt = !1;
    Z ? (ct = st, ht = it * ct + ot, vt = !0) : rt && (ht = nt, ct = (ht - ot) / it, vt = !0), vt && (V.isSnap = !0, V.pos = ct, V.offset = r - ct, X.isSnap = !0, X.pos = ht, X.offset = S - ht);
  }
  return {
    vertical: V,
    horizontal: X
  };
}
function checkSnaps(o, t, e) {
  var r = splitSnapDirectionPoses(o.props.snapDirections, t);
  return checkMoveableSnapPoses(o, r.vertical, r.horizontal, e);
}
function getNearestSnapGuidelineInfo(o) {
  var t = o.isSnap;
  if (!t)
    return {
      isSnap: !1,
      offset: 0,
      dist: -1,
      pos: 0,
      guideline: null
    };
  var e = o.posInfos[0], r = e.guidelineInfos[0], S = r.offset, T = r.dist, D = r.guideline;
  return {
    isSnap: t,
    offset: S,
    dist: T,
    pos: e.pos,
    guideline: D
  };
}
function checkSnap(o, t, e, r) {
  if (!o || !o.length)
    return {
      isSnap: !1,
      index: -1,
      posInfos: []
    };
  var S = t === "vertical", T = S ? 0 : 1, D = e.map(function(B, $) {
    var U = o.map(function(H) {
      var V = H.pos, X = B - V[T];
      return {
        offset: X,
        dist: Math.abs(X),
        guideline: H
      };
    }).filter(function(H) {
      var V = H.guideline, X = H.dist, W = V.type;
      return !(W !== t || X > r);
    }).sort(function(H, V) {
      return H.dist - V.dist;
    });
    return {
      pos: B,
      index: $,
      guidelineInfos: U
    };
  }).filter(function(B) {
    return B.guidelineInfos.length > 0;
  }).sort(function(B, $) {
    return B.guidelineInfos[0].dist - $.guidelineInfos[0].dist;
  }), N = D.length > 0;
  return {
    isSnap: N,
    index: N ? D[0].index : -1,
    posInfos: D
  };
}
function getSnapInfosByDirection(o, t, e, r) {
  r === void 0 && (r = 1);
  var S = [];
  if (e[0] && e[1])
    S = [e, [-e[0], e[1]], [e[0], -e[1]]].map(function(N) {
      return getPosByDirection(t, N);
    });
  else if (!e[0] && !e[1])
    for (var T = [t[0], t[1], t[3], t[2], t[0]], D = 0; D < 4; ++D)
      S.push(T[D]), S.push([(T[D][0] + T[D + 1][0]) / 2, (T[D][1] + T[D + 1][1]) / 2]);
  else
    o.props.keepRatio ? S = [[-1, -1], [-1, 1], [1, -1], [1, 1], e].map(function(N) {
      return getPosByDirection(t, N);
    }) : (S = getPosesByDirection(t, e), S.length > 1 && S.push([(S[0][0] + S[1][0]) / 2, (S[0][1] + S[1][1]) / 2]));
  return checkMoveableSnapPoses(o, S.map(function(N) {
    return N[0];
  }), S.map(function(N) {
    return N[1];
  }), r);
}
function checkSnapBoundPriority(o, t) {
  var e = Math.abs(o.offset), r = Math.abs(t.offset);
  return o.isBound && t.isBound ? r - e : o.isBound ? -1 : t.isBound ? 1 : o.isSnap && t.isSnap ? r - e : o.isSnap ? -1 : t.isSnap || e < TINY_NUM ? 1 : r < TINY_NUM ? -1 : e - r;
}
function getNearOffsetInfo(o, t) {
  return o.slice().sort(function(e, r) {
    var S = e.sign[t], T = r.sign[t], D = e.offset[t], N = r.offset[t];
    if (S) {
      if (!T)
        return -1;
    } else
      return 1;
    return checkSnapBoundPriority({
      isBound: e.isBound,
      isSnap: e.isSnap,
      offset: D
    }, {
      isBound: r.isBound,
      isSnap: r.isSnap,
      offset: N
    });
  })[0];
}
function getCheckSnapDirections(o, t, e) {
  var r = [];
  if (e)
    Math.abs(t[0]) !== 1 || Math.abs(t[1]) !== 1 ? r.push([t, [-1, -1]], [t, [-1, 1]], [t, [1, -1]], [t, [1, 1]]) : r.push([t, [o[0], -o[1]]], [t, [-o[0], o[1]]]), r.push([t, o]);
  else if (o[0] && o[1] || !o[0] && !o[1]) {
    var S = o[0] ? o : [1, 1];
    [1, -1].forEach(function(D) {
      [1, -1].forEach(function(N) {
        var B = [D * S[0], N * S[1]];
        t[0] === B[0] && t[1] === B[1] || r.push([t, B]);
      });
    });
  } else if (o[0]) {
    var T = Math.abs(t[0]) === 1 ? [1] : [1, -1];
    T.forEach(function(D) {
      r.push([[t[0], -1], [D * o[0], -1]], [[t[0], 0], [D * o[0], 0]], [[t[0], 1], [D * o[0], 1]]);
    });
  } else if (o[1]) {
    var T = Math.abs(t[1]) === 1 ? [1] : [1, -1];
    T.forEach(function(N) {
      r.push([[-1, t[1]], [-1, N * o[1]]], [[0, t[1]], [0, N * o[1]]], [[1, t[1]], [1, N * o[1]]]);
    });
  }
  return r;
}
function isStartLine(o, t) {
  var e = average([t[0][0], t[1][0]]), r = average([t[0][1], t[1][1]]);
  return {
    vertical: e <= o[0],
    horizontal: r <= o[1]
  };
}
function hitTestLine(o, t) {
  var e = t[0], r = t[1], S = r[0] - e[0], T = r[1] - e[1];
  Math.abs(S) < TINY_NUM && (S = 0), Math.abs(T) < TINY_NUM && (T = 0);
  var D, N;
  if (!S)
    D = e[0], N = o[0];
  else if (!T)
    D = e[1], N = o[1];
  else {
    var B = T / S;
    D = B * (o[0] - e[0]) + e[1], N = o[1];
  }
  return D - N;
}
function isSameStartLine(o, t, e, r) {
  return r === void 0 && (r = TINY_NUM), o.every(function(S) {
    var T = hitTestLine(S, t), D = T <= 0;
    return D === e || Math.abs(T) <= r;
  });
}
function checkInnerBoundDot(o, t, e, r, S) {
  return S === void 0 && (S = 0), r && t - S <= o || !r && o <= e + S ? {
    isBound: !0,
    offset: r ? t - o : e - o
  } : {
    isBound: !1,
    offset: 0
  };
}
function checkInnerBound(o, t) {
  var e = t.line, r = t.centerSign, S = t.verticalSign, T = t.horizontalSign, D = t.lineConstants, N = o.props.innerBounds;
  if (!N)
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  var B = N.left, $ = N.top, U = N.width, H = N.height, V = [[B, $], [B, $ + H]], X = [[B, $], [B + U, $]], W = [[B + U, $], [B + U, $ + H]], Y = [[B, $ + H], [B + U, $ + H]];
  if (isSameStartLine([[B, $], [B + U, $], [B, $ + H], [B + U, $ + H]], e, r))
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  var q = checkLineBoundCollision(e, D, X, S), K = checkLineBoundCollision(e, D, Y, S), Z = checkLineBoundCollision(e, D, V, T), J = checkLineBoundCollision(e, D, W, T), Q = q.isBound && K.isBound, rt = q.isBound || K.isBound, et = Z.isBound && J.isBound, nt = Z.isBound || J.isBound, st = maxOffset(q.offset, K.offset), it = maxOffset(Z.offset, J.offset), ot = [0, 0], ht = !1, ct = !1;
  return Math.abs(it) < Math.abs(st) ? (ot = [st, 0], ht = rt, ct = Q) : (ot = [0, it], ht = nt, ct = et), {
    isAllBound: ct,
    isVerticalBound: rt,
    isHorizontalBound: nt,
    isBound: ht,
    offset: ot
  };
}
function checkLineBoundCollision(o, t, e, r, S, T) {
  var D = t[0], N = t[1], B = o[0], $ = e[0], U = e[1], H = getTinyDist(U[1] - $[1]), V = getTinyDist(U[0] - $[0]), X = N, W = D, Y = -D / N;
  if (V) {
    if (!H) {
      if (T && !X)
        return {
          isBound: !1,
          offset: 0
        };
      if (W) {
        var J = ($[1] - B[1]) / Y + B[0];
        return checkInnerBoundDot(J, $[0], U[0], r, S);
      } else {
        var K = $[1] - B[1], Z = Math.abs(K) <= (S || 0);
        return {
          isBound: Z,
          offset: Z ? K : 0
        };
      }
    }
  } else {
    if (T && !W)
      return {
        isBound: !1,
        offset: 0
      };
    if (X) {
      var q = Y * ($[0] - B[0]) + B[1];
      return checkInnerBoundDot(q, $[1], U[1], r, S);
    } else {
      var K = $[0] - B[0], Z = Math.abs(K) <= (S || 0);
      return {
        isBound: Z,
        offset: Z ? K : 0
      };
    }
  }
  return {
    isBound: !1,
    offset: 0
  };
}
function getInnerBoundInfo(o, t, e) {
  return t.map(function(r) {
    var S = checkInnerBound(o, r), T = S.isBound, D = S.offset, N = S.isVerticalBound, B = S.isHorizontalBound, $ = r.multiple, U = getDragDist({
      datas: e,
      distX: D[0],
      distY: D[1]
    }).map(function(H, V) {
      return H * ($[V] ? 2 / $[V] : 0);
    });
    return {
      sign: $,
      isBound: T,
      isVerticalBound: N,
      isHorizontalBound: B,
      isSnap: !1,
      offset: U
    };
  });
}
function getInnerBoundDragInfo(o, t, e) {
  var r, S = getCheckInnerBoundLineInfos(o, t, [0, 0], !1).map(function(V) {
    return __assign$1(__assign$1({}, V), {
      multiple: V.multiple.map(function(X) {
        return Math.abs(X) * 2;
      })
    });
  }), T = getInnerBoundInfo(o, S, e), D = getNearOffsetInfo(T, 0), N = getNearOffsetInfo(T, 1), B = 0, $ = 0, U = D.isVerticalBound || N.isVerticalBound, H = D.isHorizontalBound || N.isHorizontalBound;
  return (U || H) && (r = getInverseDragDist({
    datas: e,
    distX: -D.offset[0],
    distY: -N.offset[1]
  }), B = r[0], $ = r[1]), {
    vertical: {
      isBound: U,
      offset: B
    },
    horizontal: {
      isBound: H,
      offset: $
    }
  };
}
function getCheckSnapLineDirections(o, t) {
  var e = [], r = o[0], S = o[1];
  return r && S ? e.push([[0, S * 2], o, [-r, S]], [[r * 2, 0], o, [r, -S]]) : r ? (e.push([[r * 2, 0], [r, 1], [r, -1]]), t && e.push([[0, -1], [r, -1], [-r, -1]], [[0, 1], [r, 1], [-r, 1]])) : S ? (e.push([[0, S * 2], [1, S], [-1, S]]), t && e.push([[-1, 0], [-1, S], [-1, -S]], [[1, 0], [1, S], [1, -S]])) : e.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]), e;
}
function getCheckInnerBoundLineInfos(o, t, e, r) {
  var S = o.state, T = S.allMatrix, D = S.is3d, N = calculatePoses(T, 100, 100, D ? 4 : 3), B = getPosByDirection(N, [0, 0]);
  return getCheckSnapLineDirections(e, r).map(function($) {
    var U = $[0], H = $[1], V = $[2], X = [getPosByDirection(N, H), getPosByDirection(N, V)], W = solveLineConstants(X), Y = isStartLine(B, X), q = Y.vertical, K = Y.horizontal, Z = hitTestLine(B, X) <= 0;
    return {
      multiple: U,
      centerSign: Z,
      verticalSign: q,
      horizontalSign: K,
      lineConstants: W,
      line: [getPosByDirection(t, H), getPosByDirection(t, V)]
    };
  });
}
function isBoundRotate$1(o, t, e, r) {
  var S = r ? o.map(function(T) {
    return rotate(T, r);
  }) : o;
  return [[S[0], S[1]], [S[1], S[3]], [S[3], S[2]], [S[2], S[0]]].some(function(T) {
    var D = hitTestLine(e, T) <= 0;
    return !isSameStartLine(t, T, D);
  });
}
function getDistPointLine(o) {
  var t = o[0], e = o[1], r = e[0] - t[0], S = e[1] - t[1];
  if (!r)
    return Math.abs(t[0]);
  if (!S)
    return Math.abs(t[1]);
  var T = S / r;
  return Math.abs((-T * t[0] + t[1]) / Math.sqrt(Math.pow(T, 2) + 1));
}
function solveReverseLine(o) {
  var t = o[0], e = o[1], r = e[0] - t[0], S = e[1] - t[1];
  if (!r)
    return [t[0], 0];
  if (!S)
    return [0, t[1]];
  var T = S / r, D = -T * t[0] + t[1];
  return [-D / (T + 1 / T), D / (T * T + 1)];
}
function checkRotateInnerBounds(o, t, e, r, S) {
  var T = o.props.innerBounds, D = S * Math.PI / 180;
  if (!T)
    return [];
  var N = T.left, B = T.top, $ = T.width, U = T.height, H = N - r[0], V = N + $ - r[0], X = B - r[1], W = B + U - r[1], Y = [[H, X], [V, X], [H, W], [V, W]], q = getPosByDirection(e, [0, 0]);
  if (!isBoundRotate$1(e, Y, q, 0))
    return [];
  var K = [], Z = Y.map(function(J) {
    return [getDistSize(J), getRad$1([0, 0], J)];
  });
  return [[e[0], e[1]], [e[1], e[3]], [e[3], e[2]], [e[2], e[0]]].forEach(function(J) {
    var Q = getRad$1([0, 0], solveReverseLine(J)), rt = getDistPointLine(J);
    K.push.apply(K, Z.filter(function(et) {
      var nt = et[0];
      return nt && rt <= nt;
    }).map(function(et) {
      var nt = et[0], st = et[1], it = Math.acos(nt ? rt / nt : 0), ot = st + it, ht = st - it;
      return [D + ot - Q, D + ht - Q];
    }).reduce(function(et, nt) {
      return et.push.apply(et, nt), et;
    }, []).filter(function(et) {
      return !isBoundRotate$1(t, Y, q, et);
    }).map(function(et) {
      return throttle(et * 180 / Math.PI, TINY_NUM);
    }));
  }), K;
}
function checkInnerBoundPoses(o) {
  var t = o.props.innerBounds;
  if (!t)
    return {
      vertical: [],
      horizontal: []
    };
  var e = o.getRect(), r = e.pos1, S = e.pos2, T = e.pos3, D = e.pos4, N = [r, S, T, D], B = getPosByDirection(N, [0, 0]), $ = t.left, U = t.top, H = t.width, V = t.height, X = [[$, U], [$, U + V]], W = [[$, U], [$ + H, U]], Y = [[$ + H, U], [$ + H, U + V]], q = [[$, U + V], [$ + H, U + V]], K = getCheckInnerBoundLineInfos(o, N, [0, 0], !1), Z = [], J = [], Q = {
    top: !1,
    bottom: !1,
    left: !1,
    right: !1
  };
  return K.forEach(function(rt) {
    var et = rt.line, nt = rt.lineConstants, st = isStartLine(B, et), it = st.horizontal, ot = st.vertical, ht = checkLineBoundCollision(et, nt, W, ot, 1, !0), ct = checkLineBoundCollision(et, nt, q, ot, 1, !0), vt = checkLineBoundCollision(et, nt, X, it, 1, !0), _t = checkLineBoundCollision(et, nt, Y, it, 1, !0);
    ht.isBound && !Q.top && (Z.push(U), Q.top = !0), ct.isBound && !Q.bottom && (Z.push(U + V), Q.bottom = !0), vt.isBound && !Q.left && (J.push($), Q.left = !0), _t.isBound && !Q.right && (J.push($ + H), Q.right = !0);
  }), {
    horizontal: Z,
    vertical: J
  };
}
function checkBoundPoses(o, t, e) {
  var r = o || {}, S = r.position, T = S === void 0 ? "client" : S, D = r.left, N = D === void 0 ? -1 / 0 : D, B = r.top, $ = B === void 0 ? -1 / 0 : B, U = r.right, H = U === void 0 ? 1 / 0 : U, V = r.bottom, X = V === void 0 ? 1 / 0 : V, W = {
    position: T,
    left: N,
    top: $,
    right: H,
    bottom: X
  };
  return {
    vertical: checkBounds(W, t, !0),
    horizontal: checkBounds(W, e, !1)
  };
}
function getBounds(o, t) {
  var e = o.state, r = e.containerClientRect, S = r.clientHeight, T = r.clientWidth, D = r.clientLeft, N = r.clientTop, B = e.snapOffset, $ = B.left, U = B.top, H = B.right, V = B.bottom, X = t || o.props.bounds || {}, W = X.position || "client", Y = W === "css", q = X.left, K = q === void 0 ? -1 / 0 : q, Z = X.top, J = Z === void 0 ? -1 / 0 : Z, Q = X.right, rt = Q === void 0 ? Y ? -1 / 0 : 1 / 0 : Q, et = X.bottom, nt = et === void 0 ? Y ? -1 / 0 : 1 / 0 : et;
  return Y && (rt = T + H - $ - rt, nt = S + V - U - nt), {
    left: K + $ - D,
    right: rt + $ - D,
    top: J + U - N,
    bottom: nt + U - N
  };
}
function checkBoundKeepRatio(o, t, e) {
  var r = getBounds(o), S = r.left, T = r.top, D = r.right, N = r.bottom, B = e[0], $ = e[1], U = minus(e, t), H = U[0], V = U[1];
  Math.abs(H) < TINY_NUM && (H = 0), Math.abs(V) < TINY_NUM && (V = 0);
  var X = V > 0, W = H > 0, Y = {
    isBound: !1,
    offset: 0,
    pos: 0
  }, q = {
    isBound: !1,
    offset: 0,
    pos: 0
  };
  if (H === 0 && V === 0)
    return {
      vertical: Y,
      horizontal: q
    };
  if (H === 0)
    X ? N < $ && (q.pos = N, q.offset = $ - N) : T > $ && (q.pos = T, q.offset = $ - T);
  else if (V === 0)
    W ? D < B && (Y.pos = D, Y.offset = B - D) : S > B && (Y.pos = S, Y.offset = B - S);
  else {
    var K = V / H, Z = e[1] - K * B, J = 0, Q = 0, rt = !1;
    W && D <= B ? (J = K * D + Z, Q = D, rt = !0) : !W && B <= S && (J = K * S + Z, Q = S, rt = !0), rt && (J < T || J > N) && (rt = !1), rt || (X && N <= $ ? (J = N, Q = (J - Z) / K, rt = !0) : !X && $ <= T && (J = T, Q = (J - Z) / K, rt = !0)), rt && (Y.isBound = !0, Y.pos = Q, Y.offset = B - Q, q.isBound = !0, q.pos = J, q.offset = $ - J);
  }
  return {
    vertical: Y,
    horizontal: q
  };
}
function checkBounds(o, t, e) {
  var r = o[e ? "left" : "top"], S = o[e ? "right" : "bottom"], T = Math.min.apply(Math, t), D = Math.max.apply(Math, t), N = [];
  return r + 1 > T && N.push({
    isBound: !0,
    offset: T - r,
    pos: r
  }), S - 1 < D && N.push({
    isBound: !0,
    offset: D - S,
    pos: S
  }), N.length || N.push({
    isBound: !1,
    offset: 0,
    pos: 0
  }), N.sort(function(B, $) {
    return Math.abs($.offset) - Math.abs(B.offset);
  });
}
function isBoundRotate(o, t, e) {
  var r = e ? o.map(function(S) {
    return rotate(S, e);
  }) : o;
  return r.some(function(S) {
    return S[0] < t.left && Math.abs(S[0] - t.left) > 0.1 || S[0] > t.right && Math.abs(S[0] - t.right) > 0.1 || S[1] < t.top && Math.abs(S[1] - t.top) > 0.1 || S[1] > t.bottom && Math.abs(S[1] - t.bottom) > 0.1;
  });
}
function boundRotate(o, t, e) {
  var r = getDistSize(o), S = Math.sqrt(r * r - t * t) || 0;
  return [S, -S].sort(function(T, D) {
    return Math.abs(T - o[e ? 0 : 1]) - Math.abs(D - o[e ? 0 : 1]);
  }).map(function(T) {
    return getRad$1([0, 0], e ? [T, t] : [t, T]);
  });
}
function checkRotateBounds(o, t, e, r, S) {
  if (!o.props.bounds)
    return [];
  var T = S * Math.PI / 180, D = getBounds(o), N = D.left, B = D.top, $ = D.right, U = D.bottom, H = N - r[0], V = $ - r[0], X = B - r[1], W = U - r[1], Y = {
    left: H,
    top: X,
    right: V,
    bottom: W
  };
  if (!isBoundRotate(e, Y, 0))
    return [];
  var q = [];
  return [[H, 0], [V, 0], [X, 1], [W, 1]].forEach(function(K) {
    var Z = K[0], J = K[1];
    e.forEach(function(Q) {
      var rt = getRad$1([0, 0], Q);
      q.push.apply(q, boundRotate(Q, Z, J).map(function(et) {
        return T + et - rt;
      }).filter(function(et) {
        return !isBoundRotate(t, Y, et);
      }).map(function(et) {
        return throttle(et * 180 / Math.PI, TINY_NUM);
      }));
    });
  }), q;
}
function renderGuideline(o, t) {
  var e, r = o.direction, S = o.classNames, T = o.size, D = o.pos, N = o.zoom, B = o.key, $ = r === "horizontal", U = $ ? "Y" : "X";
  return t.createElement("div", {
    key: B,
    className: S.join(" "),
    style: (e = {}, e[$ ? "width" : "height"] = "".concat(T), e.transform = "translate(".concat(D[0], ", ").concat(D[1], ") translate").concat(U, "(-50%) scale").concat(U, "(").concat(N, ")"), e)
  });
}
function renderInnerGuideline(o, t) {
  return renderGuideline(__assign$1(__assign$1({}, o), {
    classNames: __spreadArray([prefix("line", "guideline", o.direction)], o.classNames, !0).filter(function(e) {
      return e;
    }),
    size: o.size || "".concat(o.sizeValue, "px"),
    pos: o.pos || o.posValue.map(function(e) {
      return "".concat(throttle(e, 0.1), "px");
    })
  }), t);
}
function renderSnapPoses(o, t, e, r, S, T, D, N) {
  var B = o.props.zoom;
  return e.map(function($, U) {
    var H = $.type, V = $.pos, X = [0, 0];
    return X[D] = r, X[D ? 0 : 1] = -S + V, renderInnerGuideline({
      key: "".concat(t, "TargetGuideline").concat(U),
      classNames: [prefix("target", "bold", H)],
      posValue: X,
      sizeValue: T,
      zoom: B,
      direction: t
    }, N);
  });
}
function renderGuidelines(o, t, e, r, S, T) {
  var D = o.props, N = D.zoom, B = D.isDisplayInnerSnapDigit, $ = t === "horizontal" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, U = S[$.start], H = S[$.end];
  return e.filter(function(V) {
    var X = V.hide, W = V.elementRect;
    if (X)
      return !1;
    if (B && W) {
      var Y = W.rect;
      if (Y[$.start] <= U && H <= Y[$.end])
        return !1;
    }
    return !0;
  }).map(function(V, X) {
    var W = V.pos, Y = V.size, q = V.element, K = V.className, Z = [-r[0] + W[0], -r[1] + W[1]];
    return renderInnerGuideline({
      key: "".concat(t, "-default-guideline-").concat(X),
      classNames: q ? [prefix("bold"), K] : [prefix("normal"), K],
      direction: t,
      posValue: Z,
      sizeValue: Y,
      zoom: N
    }, T);
  });
}
function renderDigitLine(o, t, e, r, S, T, D, N) {
  var B, $ = o.props, U = $.snapDigit, H = U === void 0 ? 0 : U, V = $.isDisplaySnapDigit, X = V === void 0 ? !0 : V, W = $.snapDistFormat, Y = W === void 0 ? function(rt, et) {
    return rt;
  } : W, q = $.zoom, K = t === "horizontal" ? "X" : "Y", Z = t === "vertical" ? "height" : "width", J = Math.abs(S), Q = X ? parseFloat(J.toFixed(H)) : 0;
  return N.createElement("div", {
    key: "".concat(t, "-").concat(e, "-guideline-").concat(r),
    className: prefix("guideline-group", t),
    style: (B = {
      left: "".concat(T[0], "px"),
      top: "".concat(T[1], "px")
    }, B[Z] = "".concat(J, "px"), B)
  }, renderInnerGuideline({
    direction: t,
    classNames: [prefix(e), D],
    size: "100%",
    posValue: [0, 0],
    sizeValue: J,
    zoom: q
  }, N), N.createElement("div", {
    className: prefix("size-value", "gap"),
    style: {
      transform: "translate".concat(K, "(-50%) scale(").concat(q, ")")
    }
  }, Q > 0 ? Y(Q, t) : ""));
}
function groupByElementGuidelines(o, t, e, r) {
  var S = o === "vertical" ? 0 : 1, T = o === "vertical" ? 1 : 0, D = S ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, N = e[D.start], B = e[D.end];
  return groupBy(t, function($) {
    return $.pos[S];
  }).map(function($) {
    var U = [], H = [], V = [];
    return $.forEach(function(X) {
      var W, Y, q = X.element, K = X.elementRect.rect;
      if (K[D.end] < N)
        U.push(X);
      else if (B < K[D.start])
        H.push(X);
      else if (K[D.start] <= N && B <= K[D.end] && r) {
        var Z = X.pos, J = {
          element: q,
          rect: __assign$1(__assign$1({}, K), (W = {}, W[D.end] = K[D.start], W))
        }, Q = {
          element: q,
          rect: __assign$1(__assign$1({}, K), (Y = {}, Y[D.start] = K[D.end], Y))
        }, rt = [0, 0], et = [0, 0];
        rt[S] = Z[S], rt[T] = Z[T], et[S] = Z[S], et[T] = Z[T] + X.size, U.push({
          type: o,
          pos: rt,
          size: 0,
          elementRect: J
        }), H.push({
          type: o,
          pos: et,
          size: 0,
          elementRect: Q
        });
      }
    }), U.sort(function(X, W) {
      return W.pos[T] - X.pos[T];
    }), H.sort(function(X, W) {
      return X.pos[T] - W.pos[T];
    }), {
      total: $,
      start: U,
      end: H,
      inner: V
    };
  });
}
function renderDashedGuidelines(o, t, e, r, S) {
  var T = o.props.isDisplayInnerSnapDigit, D = [];
  return ["vertical", "horizontal"].forEach(function(N) {
    var B = t.filter(function(q) {
      return q.type === N;
    }), $ = N === "vertical" ? 1 : 0, U = $ ? 0 : 1, H = groupByElementGuidelines(N, B, r, T), V = $ ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, X = $ ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, W = r[V.start], Y = r[V.end];
    H.forEach(function(q) {
      var K = q.total, Z = q.start, J = q.end, Q = q.inner, rt = e[U] + K[0].pos[U] - r[X.start], et = r;
      Z.forEach(function(nt) {
        var st = nt.elementRect.rect, it = et[V.start] - st[V.end];
        if (it > 0) {
          var ot = [0, 0];
          ot[$] = e[$] + et[V.start] - W - it, ot[U] = rt, D.push(renderDigitLine(o, N, "dashed", D.length, it, ot, nt.className, S));
        }
        et = st;
      }), et = r, J.forEach(function(nt) {
        var st = nt.elementRect.rect, it = st[V.start] - et[V.end];
        if (it > 0) {
          var ot = [0, 0];
          ot[$] = e[$] + et[V.end] - W, ot[U] = rt, D.push(renderDigitLine(o, N, "dashed", D.length, it, ot, nt.className, S));
        }
        et = st;
      }), Q.forEach(function(nt) {
        var st = nt.elementRect.rect, it = W - st[V.start], ot = st[V.end] - Y, ht = [0, 0], ct = [0, 0];
        ht[$] = e[$] - it, ht[U] = rt, ct[$] = e[$] + Y - W, ct[U] = rt, D.push(renderDigitLine(o, N, "dashed", D.length, it, ht, nt.className, S)), D.push(renderDigitLine(o, N, "dashed", D.length, ot, ct, nt.className, S));
      });
    });
  }), D;
}
function renderGapGuidelines(o, t, e, r, S) {
  var T = [];
  return ["horizontal", "vertical"].forEach(function(D) {
    var N = t.filter(function(q) {
      return q.type === D;
    }).slice(0, 1), B = D === "vertical" ? 0 : 1, $ = B ? 0 : 1, U = B ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, H = B ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, V = r[U.start], X = r[U.end], W = r[H.start], Y = r[H.end];
    N.forEach(function(q) {
      var K = q.gap, Z = q.gapRects, J = Math.max.apply(Math, __spreadArray([W], Z.map(function(et) {
        var nt = et.rect;
        return nt[H.start];
      }), !1)), Q = Math.min.apply(Math, __spreadArray([Y], Z.map(function(et) {
        var nt = et.rect;
        return nt[H.end];
      }), !1)), rt = (J + Q) / 2;
      J === Q || rt === (W + Y) / 2 || Z.forEach(function(et) {
        var nt = et.rect, st = et.className, it = [e[0], e[1]];
        if (nt[U.end] < V)
          it[B] += nt[U.end] - V;
        else if (X < nt[U.start])
          it[B] += nt[U.start] - V - K;
        else
          return;
        it[$] += rt - W, T.push(renderDigitLine(o, B ? "vertical" : "horizontal", "gap", T.length, K, it, st, S));
      });
    });
  }), T;
}
function solveEquation(o, t, e, r) {
  var S = t[0] - o[0], T = t[1] - o[1];
  if (Math.abs(S) < TINY_NUM$1 && (S = 0), Math.abs(T) < TINY_NUM$1 && (T = 0), !S)
    return r ? [0, 0] : [0, e];
  if (!T)
    return r ? [e, 0] : [0, 0];
  var D = T / S, N = o[1] - D * o[0];
  if (r) {
    var B = D * (t[0] + e) + N;
    return [e, B - t[1]];
  } else {
    var $ = (t[1] + e - N) / D;
    return [$ - t[0], e];
  }
}
function solveNextOffset(o, t, e, r, S) {
  var T = solveEquation(o, t, e, r);
  if (!T)
    return {
      isOutside: !1,
      offset: [0, 0]
    };
  var D = getDist$2(o, t), N = getDist$2(T, o), B = getDist$2(T, t), $ = N > D || B > D, U = getDragDist({
    datas: S,
    distX: T[0],
    distY: T[1]
  }), H = U[0], V = U[1];
  return {
    offset: [H, V],
    isOutside: $
  };
}
function getSnapBound(o, t) {
  return o.isBound ? o.offset : t.isSnap ? getNearestSnapGuidelineInfo(t).offset : 0;
}
function checkThrottleDragRotate(o, t, e, r, S) {
  var T = t[0], D = t[1], N = e[0], B = e[1], $ = r[0], U = r[1], H = S[0], V = S[1], X = -H, W = -V;
  if (o && T && D) {
    X = 0, W = 0;
    var Y = [];
    if (N && B ? Y.push([0, V], [H, 0]) : N ? Y.push([H, 0]) : B ? Y.push([0, V]) : $ && U ? Y.push([0, V], [H, 0]) : $ ? Y.push([H, 0]) : U && Y.push([0, V]), Y.length) {
      Y.sort(function(J, Q) {
        return getDistSize(minus([T, D], J)) - getDistSize(minus([T, D], Q));
      });
      var q = Y[0];
      if (q[0] && Math.abs(T) > TINY_NUM$1)
        X = -q[0], W = D * Math.abs(T + X) / Math.abs(T) - D;
      else if (q[1] && Math.abs(D) > TINY_NUM$1) {
        var K = D;
        W = -q[1], X = T * Math.abs(D + W) / Math.abs(K) - T;
      }
      if (o && B && N)
        if (Math.abs(X) > TINY_NUM$1 && Math.abs(X) < Math.abs(H)) {
          var Z = Math.abs(H) / Math.abs(X);
          X *= Z, W *= Z;
        } else if (Math.abs(W) > TINY_NUM$1 && Math.abs(W) < Math.abs(V)) {
          var Z = Math.abs(V) / Math.abs(W);
          X *= Z, W *= Z;
        } else
          X = maxOffset(-H, X), W = maxOffset(-V, W);
    }
  } else
    X = T || N ? -H : 0, W = D || B ? -V : 0;
  return [X, W];
}
function checkSnapBoundsDrag(o, t, e, r, S, T) {
  if (!hasGuidelines(o, "draggable"))
    return [{
      isSnap: !1,
      isBound: !1,
      offset: 0
    }, {
      isSnap: !1,
      isBound: !1,
      offset: 0
    }];
  var D = getAbsolutePoses(T.absolutePoses, [t, e]), N = getRect(D), B = N.left, $ = N.right, U = N.top, H = N.bottom, V = {
    horizontal: D.map(function(_t) {
      return _t[1];
    }),
    vertical: D.map(function(_t) {
      return _t[0];
    })
  }, X = getSnapDirections(o.props.snapDirections), W = splitSnapDirectionPoses(X, {
    left: B,
    right: $,
    top: U,
    bottom: H,
    center: (B + $) / 2,
    middle: (U + H) / 2
  }), Y = checkMoveableSnapBounds(o, S, W, V), q = Y.vertical, K = Y.horizontal, Z = getInnerBoundDragInfo(o, D, T), J = Z.vertical, Q = Z.horizontal, rt = q.isSnap, et = K.isSnap, nt = q.isBound || J.isBound, st = K.isBound || Q.isBound, it = maxOffset(q.offset, J.offset), ot = maxOffset(K.offset, Q.offset), ht = checkThrottleDragRotate(r, [t, e], [nt, st], [rt, et], [it, ot]), ct = ht[0], vt = ht[1];
  return [{
    isBound: nt,
    isSnap: rt,
    offset: ct
  }, {
    isBound: st,
    isSnap: et,
    offset: vt
  }];
}
function checkMoveableSnapBounds(o, t, e, r) {
  r === void 0 && (r = e);
  var S = checkBoundPoses(getBounds(o), r.vertical, r.horizontal), T = S.horizontal, D = S.vertical, N = t ? {
    horizontal: {
      isSnap: !1,
      index: -1
    },
    vertical: {
      isSnap: !1,
      index: -1
    }
  } : checkMoveableSnapPoses(o, e.vertical, e.horizontal), B = N.horizontal, $ = N.vertical, U = getSnapBound(T[0], B), H = getSnapBound(D[0], $), V = Math.abs(U), X = Math.abs(H);
  return {
    horizontal: {
      isBound: T[0].isBound,
      isSnap: B.isSnap,
      snapIndex: B.index,
      offset: U,
      dist: V,
      bounds: T,
      snap: B
    },
    vertical: {
      isBound: D[0].isBound,
      isSnap: $.isSnap,
      snapIndex: $.index,
      offset: H,
      dist: X,
      bounds: D,
      snap: $
    }
  };
}
function checkSnapBounds(o, t, e, r, S) {
  var T = checkBoundPoses(t, e, r), D = T.horizontal, N = T.vertical, B = checkSnapPoses(o, e, r, S), $ = B.horizontal, U = B.vertical, H = getSnapBound(D[0], $), V = getSnapBound(N[0], U), X = Math.abs(H), W = Math.abs(V);
  return {
    horizontal: {
      isBound: D[0].isBound,
      isSnap: $.isSnap,
      snapIndex: $.index,
      offset: H,
      dist: X,
      bounds: D,
      snap: $
    },
    vertical: {
      isBound: N[0].isBound,
      isSnap: U.isSnap,
      snapIndex: U.index,
      offset: V,
      dist: W,
      bounds: N,
      snap: U
    }
  };
}
function checkSnapRightLine(o, t, e, r) {
  var S = getRad$1(o, t) / Math.PI * 180, T = e.vertical, D = T.isBound, N = T.isSnap, B = T.dist, $ = e.horizontal, U = $.isBound, H = $.isSnap, V = $.dist, X = S % 180, W = X < 3 || X > 177, Y = X > 87 && X < 93;
  return V < B && (D || N && !Y && (!r || !W)) ? "vertical" : U || H && !W && (!r || !Y) ? "horizontal" : "";
}
function getSnapBoundInfo(o, t, e, r, S, T) {
  return e.map(function(D) {
    var N = D[0], B = D[1], $ = getPosByDirection(t, N), U = getPosByDirection(t, B), H = r ? checkSnapBoundsKeepRatio(o, $, U, S) : checkMoveableSnapBounds(o, S, {
      vertical: [U[0]],
      horizontal: [U[1]]
    }), V = H.horizontal, X = V.offset, W = V.isBound, Y = V.isSnap, q = H.vertical, K = q.offset, Z = q.isBound, J = q.isSnap, Q = minus(B, N);
    if (!K && !X)
      return {
        isBound: Z || W,
        isSnap: J || Y,
        sign: Q,
        offset: [0, 0]
      };
    var rt = checkSnapRightLine($, U, H, r);
    if (!rt)
      return {
        sign: Q,
        isBound: !1,
        isSnap: !1,
        offset: [0, 0]
      };
    var et = rt === "vertical", nt = [0, 0];
    return !r && Math.abs(B[0]) === 1 && Math.abs(B[1]) === 1 && N[0] !== B[0] && N[1] !== B[1] ? nt = getDragDist({
      datas: T,
      distX: -K,
      distY: -X
    }) : nt = solveNextOffset($, U, -(et ? K : X), et, T).offset, nt = nt.map(function(st, it) {
      return st * (Q[it] ? 2 / Q[it] : 0);
    }), {
      sign: Q,
      isBound: et ? Z : W,
      isSnap: et ? J : Y,
      offset: nt
    };
  });
}
function getSnapBoundOffset(o, t) {
  return o.isBound ? o.offset : t.isSnap ? t.offset : 0;
}
function checkSnapBoundsKeepRatio(o, t, e, r) {
  var S = checkBoundKeepRatio(o, t, e), T = S.horizontal, D = S.vertical, N = r ? {
    horizontal: {
      isSnap: !1
    },
    vertical: {
      isSnap: !1
    }
  } : checkSnapKeepRatio(o, t, e), B = N.horizontal, $ = N.vertical, U = getSnapBoundOffset(T, B), H = getSnapBoundOffset(D, $), V = Math.abs(U), X = Math.abs(H);
  return {
    horizontal: {
      isBound: T.isBound,
      isSnap: B.isSnap,
      offset: U,
      dist: V
    },
    vertical: {
      isBound: D.isBound,
      isSnap: $.isSnap,
      offset: H,
      dist: X
    }
  };
}
function checkMaxBounds(o, t, e, r, S) {
  var T = [-e[0], -e[1]], D = o.state, N = D.width, B = D.height, $ = o.props.bounds, U = 1 / 0, H = 1 / 0;
  if ($) {
    var V = [[e[0], -e[1]], [-e[0], e[1]]], X = $.left, W = X === void 0 ? -1 / 0 : X, Y = $.top, q = Y === void 0 ? -1 / 0 : Y, K = $.right, Z = K === void 0 ? 1 / 0 : K, J = $.bottom, Q = J === void 0 ? 1 / 0 : J;
    V.forEach(function(rt) {
      var et = rt[0] !== T[0], nt = rt[1] !== T[1], st = getPosByDirection(t, rt), it = getRad$1(r, st) * 360 / Math.PI;
      if (nt) {
        var ot = st.slice();
        (Math.abs(it - 360) < 2 || Math.abs(it - 180) < 2) && (ot[1] = r[1]);
        var ht = solveNextOffset(r, ot, (r[1] < st[1] ? Q : q) - st[1], !1, S), ct = ht.offset, vt = ct[1], _t = ht.isOutside;
        isNaN(vt) || (H = B + (_t ? 1 : -1) * Math.abs(vt));
      }
      if (et) {
        var ot = st.slice();
        (Math.abs(it - 90) < 2 || Math.abs(it - 270) < 2) && (ot[0] = r[0]);
        var gt = solveNextOffset(r, ot, (r[0] < st[0] ? Z : W) - st[0], !0, S), mt = gt.offset[0], Et = gt.isOutside;
        isNaN(mt) || (U = N + (Et ? 1 : -1) * Math.abs(mt));
      }
    });
  }
  return {
    maxWidth: U,
    maxHeight: H
  };
}
function getTotalGuidelines(o) {
  var t = o.state, e = t.containerClientRect, r = t.hasFixed, S = e.overflow, T = e.scrollHeight, D = e.scrollWidth, N = e.clientHeight, B = e.clientWidth, $ = e.clientLeft, U = e.clientTop, H = o.props, V = H.snapGap, X = V === void 0 ? !0 : V, W = H.verticalGuidelines, Y = H.horizontalGuidelines, q = H.snapThreshold, K = q === void 0 ? 5 : q, Z = H.snapGridWidth, J = Z === void 0 ? 0 : Z, Q = H.snapGridHeight, rt = Q === void 0 ? 0 : Q, et = H.maxSnapElementGuidelineDistance, nt = et === void 0 ? 1 / 0 : et, st = getRect(getAbsolutePosesByState(o.state)), it = st.top, ot = st.left, ht = st.bottom, ct = st.right, vt = {
    top: it,
    left: ot,
    bottom: ht,
    right: ct,
    center: (ot + ct) / 2,
    middle: (it + ht) / 2
  }, _t = getElementGuidelines(o), gt = __spreadArray([], _t, !0);
  X && gt.push.apply(gt, getGapGuidelines(o, vt, K)), gt.push.apply(gt, getGridGuidelines(J, rt, S ? D : B, S ? T : N, $, U));
  var mt = __assign$1({}, t.snapOffset || {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  });
  if (r) {
    var Et = e.left, wt = e.top;
    mt.left += Et, mt.top += wt, mt.right += Et, mt.bottom += wt;
  }
  return gt.push.apply(gt, getDefaultGuidelines(Y || !1, W || !1, S ? D : B, S ? T : N, $, U, mt)), gt = gt.filter(function(xt) {
    var pt = xt.element, yt = xt.elementRect, Dt = xt.type;
    if (!pt || !yt)
      return !0;
    var At = yt.rect;
    return checkBetweenRects(vt, At, Dt, nt);
  }), gt;
}
function getGapGuidelines(o, t, e) {
  var r = o.props, S = r.maxSnapElementGuidelineDistance, T = S === void 0 ? 1 / 0 : S, D = r.maxSnapElementGapDistance, N = D === void 0 ? 1 / 0 : D, B = o.state.elementRects, $ = [];
  return [["vertical", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP], ["horizontal", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP]].forEach(function(U) {
    var H = U[0], V = U[1], X = U[2], W = t[V.start], Y = t[V.end], q = t[V.center], K = t[X.start], Z = t[X.end];
    function J(et) {
      var nt = et.rect;
      return nt[V.end] < W + e ? W - nt[V.end] : Y - e < nt[V.start] ? nt[V.start] - Y : -1;
    }
    var Q = B.filter(function(et) {
      var nt = et.rect;
      return nt[X.start] > Z || nt[X.end] < K ? !1 : J(et) > 0;
    }).sort(function(et, nt) {
      return J(et) - J(nt);
    }), rt = [];
    Q.forEach(function(et) {
      Q.forEach(function(nt) {
        if (et !== nt) {
          var st = et.rect, it = nt.rect, ot = st[X.start], ht = st[X.end], ct = it[X.start], vt = it[X.end];
          ot > vt || ct > ht || rt.push([et, nt]);
        }
      });
    }), rt.forEach(function(et) {
      var nt = et[0], st = et[1], it = nt.rect, ot = st.rect, ht = it[V.start], ct = it[V.end], vt = ot[V.start], _t = ot[V.end], gt = 0, mt = 0, Et = !1, wt = !1, xt = !1;
      if (ct <= W && Y <= vt) {
        if (wt = !0, gt = (vt - ct - (Y - W)) / 2, mt = ct + gt + (Y - W) / 2, Math.abs(mt - q) > e)
          return;
      } else if (ct < vt && _t < W + e) {
        if (Et = !0, gt = vt - ct, mt = _t + gt, Math.abs(mt - W) > e)
          return;
      } else if (ct < vt && Y - e < ht) {
        if (xt = !0, gt = vt - ct, mt = ht - gt, Math.abs(mt - Y) > e)
          return;
      } else
        return;
      gt && checkBetweenRects(t, ot, H, T) && (gt > N || $.push({
        type: H,
        pos: H === "vertical" ? [mt, 0] : [0, mt],
        element: st.element,
        size: 0,
        className: st.className,
        isStart: Et,
        isCenter: wt,
        isEnd: xt,
        gap: gt,
        hide: !0,
        gapRects: [nt, st]
      }));
    });
  }), $;
}
function getGridGuidelines(o, t, e, r, S, T) {
  S === void 0 && (S = 0), T === void 0 && (T = 0);
  var D = [];
  if (t)
    for (var N = 0; N <= r; N += t)
      D.push({
        type: "horizontal",
        pos: [0, throttle(N - T, 0.1)],
        size: e,
        hide: !0
      });
  if (o)
    for (var N = 0; N <= e; N += o)
      D.push({
        type: "vertical",
        pos: [throttle(N - S, 0.1), 0],
        size: r,
        hide: !0
      });
  return D;
}
function checkBetweenRects(o, t, e, r) {
  return e === "horizontal" ? Math.abs(o.right - t.left) <= r || Math.abs(o.left - t.right) <= r || o.left <= t.right && t.left <= o.right : e === "vertical" ? Math.abs(o.bottom - t.top) <= r || Math.abs(o.top - t.bottom) <= r || o.top <= t.bottom && t.top <= o.bottom : !0;
}
function getElementGuidelines(o) {
  var t = o.state, e = o.props.elementGuidelines, r = e === void 0 ? [] : e;
  if (!r.length)
    return t.elementRects = [], [];
  var S = (t.elementRects || []).filter(function(V) {
    return !V.refresh;
  }), T = r.map(function(V) {
    return isObject$2(V) && "element" in V ? __assign$1(__assign$1({}, V), {
      element: getRefTarget(V.element, !0)
    }) : {
      element: getRefTarget(V, !0)
    };
  }).filter(function(V) {
    return V.element;
  }), D = diff(S.map(function(V) {
    return V.element;
  }), T.map(function(V) {
    return V.element;
  })), N = D.maintained, B = D.added, $ = [];
  N.forEach(function(V) {
    var X = V[0], W = V[1];
    $[W] = S[X];
  }), getSnapElementRects(o, B.map(function(V) {
    return T[V];
  })).map(function(V, X) {
    $[B[X]] = V;
  }), t.elementRects = $;
  var U = getSnapDirections(o.props.elementSnapDirections), H = [];
  return $.forEach(function(V) {
    var X = V.element, W = V.top, Y = W === void 0 ? U.top : W, q = V.left, K = q === void 0 ? U.left : q, Z = V.right, J = Z === void 0 ? U.right : Z, Q = V.bottom, rt = Q === void 0 ? U.bottom : Q, et = V.center, nt = et === void 0 ? U.center : et, st = V.middle, it = st === void 0 ? U.middle : st, ot = V.className, ht = V.rect, ct = splitSnapDirectionPoses({
      top: Y,
      right: J,
      left: K,
      bottom: rt,
      center: nt,
      middle: it
    }, ht), vt = ct.horizontal, _t = ct.vertical, gt = ht.top, mt = ht.left, Et = ht.right - mt, wt = ht.bottom - gt, xt = [Et, wt];
    _t.forEach(function(pt) {
      H.push({
        type: "vertical",
        element: X,
        pos: [throttle(pt, 0.1), gt],
        size: wt,
        sizes: xt,
        className: ot,
        elementRect: V
      });
    }), vt.forEach(function(pt) {
      H.push({
        type: "horizontal",
        element: X,
        pos: [mt, throttle(pt, 0.1)],
        size: Et,
        sizes: xt,
        className: ot,
        elementRect: V
      });
    });
  }), H;
}
function getDefaultGuidelines(o, t, e, r, S, T, D) {
  S === void 0 && (S = 0), T === void 0 && (T = 0), D === void 0 && (D = {
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  });
  var N = [], B = D.left, $ = D.top, U = D.bottom, H = D.right, V = e + H - B, X = r + U - $;
  return o && o.forEach(function(W) {
    var Y = isObject$2(W) ? W : {
      pos: W
    };
    N.push({
      type: "horizontal",
      pos: [B, throttle(Y.pos - T + $, 0.1)],
      size: V,
      className: Y.className
    });
  }), t && t.forEach(function(W) {
    var Y = isObject$2(W) ? W : {
      pos: W
    };
    N.push({
      type: "vertical",
      pos: [throttle(Y.pos - S + B, 0.1), $],
      size: X,
      className: Y.className
    });
  }), N;
}
function getSnapElementRects(o, t) {
  if (!t.length)
    return [];
  var e = o.state, r = e.containerClientRect, S = e.targetClientRect, T = S.top, D = S.left, N = e.rootMatrix, B = e.is3d, $ = B ? 4 : 3, U = calculateContainerPos(N, r, $), H = U[0], V = U[1], X = getAbsolutePosesByState(e), W = getMinMaxs(X), Y = W.minX, q = W.minY, K = minus([Y, q], calculateInversePosition(N, [D - H, T - V], $)).map(function(Q) {
    return roundSign(Q);
  }), Z = K[0], J = K[1];
  return t.map(function(Q) {
    var rt = Q.element.getBoundingClientRect(), et = rt.left - H, nt = rt.top - V, st = nt + rt.height, it = et + rt.width, ot = calculateInversePosition(N, [et, nt], $), ht = ot[0], ct = ot[1], vt = calculateInversePosition(N, [it, st], $), _t = vt[0], gt = vt[1];
    return __assign$1(__assign$1({}, Q), {
      rect: {
        left: ht + Z,
        right: _t + Z,
        top: ct + J,
        bottom: gt + J,
        center: (ht + _t) / 2 + Z,
        middle: (ct + gt) / 2 + J
      }
    });
  });
}
function checkSnapInfo(o) {
  var t = o.state, e = t.container, r = o.props.snapContainer || e;
  if (t.snapContainer === r && t.guidelines && t.guidelines.length)
    return !1;
  var S = t.containerClientRect, T = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  };
  if (e !== r) {
    var D = getRefTarget(r, !0);
    if (D) {
      var N = getClientRect(D), B = getDragDistByState(t, [N.left - S.left, N.top - S.top]), $ = getDragDistByState(t, [N.right - S.right, N.bottom - S.bottom]);
      T.left = throttle(B[0], 1e-5), T.top = throttle(B[1], 1e-5), T.right = throttle($[0], 1e-5), T.bottom = throttle($[1], 1e-5);
    }
  }
  return t.snapContainer = r, t.snapOffset = T, t.guidelines = getTotalGuidelines(o), t.enableSnap = !0, !0;
}
function getNextFixedPoses(o, t, e, r, S, T) {
  var D = calculatePoses(o, t, e, T ? 4 : 3), N = getPosByDirection(D, r);
  return getAbsolutePoses(D, minus(S, N));
}
function getSizeOffsetInfo(o, t, e, r, S, T) {
  var D = T.fixedDirection, N = getCheckSnapDirections(e, D, r), B = getCheckInnerBoundLineInfos(o, t, e, r), $ = __spreadArray(__spreadArray([], getSnapBoundInfo(o, t, N, r, S, T), !0), getInnerBoundInfo(o, B, T), !0), U = getNearOffsetInfo($, 0), H = getNearOffsetInfo($, 1);
  return {
    width: {
      isBound: U.isBound,
      offset: U.offset[0]
    },
    height: {
      isBound: H.isBound,
      offset: H.offset[1]
    }
  };
}
function recheckSizeByTwoDirection(o, t, e, r, S, T, D, N, B) {
  var $ = getPosByDirection(t, D), U = checkMoveableSnapBounds(o, N, {
    vertical: [$[0]],
    horizontal: [$[1]]
  }), H = U.horizontal.offset, V = U.vertical.offset;
  if (throttle(V, FLOAT_POINT_NUM) || throttle(H, FLOAT_POINT_NUM)) {
    var X = getDragDist({
      datas: B,
      distX: -V,
      distY: -H
    }), W = X[0], Y = X[1], q = Math.min(S || 1 / 0, e + D[0] * W), K = Math.min(T || 1 / 0, r + D[1] * Y);
    return [q - e, K - r];
  }
  return [0, 0];
}
function checkSizeDist(o, t, e, r, S, T, D, N) {
  for (var B = getAbsolutePosesByState(o.state), $ = o.props.keepRatio, U = 0, H = 0, V = 0; V < 2; ++V) {
    var X = t(U, H), W = getSizeOffsetInfo(o, X, S, $, D, N), Y = W.width, q = W.height, K = Y.isBound, Z = q.isBound, J = Y.offset, Q = q.offset;
    if (V === 1 && (K || (J = 0), Z || (Q = 0)), V === 0 && D && !K && !Z)
      return [0, 0];
    if ($) {
      var rt = Math.abs(J) * (e ? 1 / e : 1), et = Math.abs(Q) * (r ? 1 / r : 1), nt = K && Z ? rt < et : Z || !K && rt < et;
      nt ? J = e * Q / r : Q = r * J / e;
    }
    U += J, H += Q;
  }
  if (S[0] && S[1]) {
    var st = checkMaxBounds(o, B, S, T, N), it = st.maxWidth, ot = st.maxHeight, ht = recheckSizeByTwoDirection(o, t(U, H).map(function(_t) {
      return _t.map(function(gt) {
        return throttle(gt, FLOAT_POINT_NUM);
      });
    }), e + U, r + H, it, ot, S, D, N), J = ht[0], Q = ht[1];
    U += J, H += Q;
  }
  return [U, H];
}
function checkSnapRotate(o, t, e) {
  if (!hasGuidelines(o, "rotatable"))
    return {
      isSnap: !1,
      rotation: e
    };
  var r = t.pos1, S = t.pos2, T = t.pos3, D = t.pos4, N = t.origin, B = e * Math.PI / 180, $ = [r, S, T, D].map(function(X) {
    return minus(X, N);
  }), U = $.map(function(X) {
    return rotate(X, B);
  }), H = __spreadArray(__spreadArray([], checkRotateBounds(o, $, U, N, e), !0), checkRotateInnerBounds(o, $, U, N, e), !0);
  H.sort(function(X, W) {
    return Math.abs(X - e) - Math.abs(W - e);
  });
  var V = H.length > 0;
  return {
    isSnap: V,
    rotation: V ? H[0] : e
  };
}
function checkSnapResize(o, t, e, r, S, T, D) {
  if (!hasGuidelines(o, "resizable"))
    return [0, 0];
  var N = D.fixedDirection, B = D.nextAllMatrix, $ = o.state, U = $.allMatrix, H = $.is3d;
  return checkSizeDist(o, function(V, X) {
    return getNextFixedPoses(B || U, t + V, e + X, N, S, H);
  }, t, e, r, S, T, D);
}
function checkSnapScale(o, t, e, r, S) {
  if (!hasGuidelines(o, "scalable"))
    return [0, 0];
  var T = S.startOffsetWidth, D = S.startOffsetHeight, N = S.fixedPosition, B = S.fixedDirection, $ = S.is3d, U = checkSizeDist(o, function(H, V) {
    return getNextFixedPoses(scaleMatrix(S, plus(t, [H / T, V / D])), T, D, B, N, $);
  }, T, D, e, N, r, S);
  return [U[0] / T, U[1] / D];
}
function startCheckSnapDrag(o, t) {
  t.absolutePoses = getAbsolutePosesByState(o.state);
}
function getSnapGuidelines(o) {
  var t = [];
  return o.forEach(function(e) {
    e.guidelineInfos.forEach(function(r) {
      var S = r.guideline;
      t.indexOf(S) > -1 || t.push(S);
    });
  }), t;
}
function addBoundGuidelines(o, t, e, r, S, T) {
  var D = checkBoundPoses(getBounds(o, T), t, e), N = D.vertical, B = D.horizontal;
  N.forEach(function(V) {
    V.isBound && r.push({
      type: "bounds",
      pos: V.pos
    });
  }), B.forEach(function(V) {
    V.isBound && S.push({
      type: "bounds",
      pos: V.pos
    });
  });
  var $ = checkInnerBoundPoses(o), U = $.vertical, H = $.horizontal;
  U.forEach(function(V) {
    findIndex(r, function(X) {
      var W = X.type, Y = X.pos;
      return W === "bounds" && Y === V;
    }) >= 0 || r.push({
      type: "bounds",
      pos: V
    });
  }), H.forEach(function(V) {
    findIndex(S, function(X) {
      var W = X.type, Y = X.pos;
      return W === "bounds" && Y === V;
    }) >= 0 || S.push({
      type: "bounds",
      pos: V
    });
  });
}
var directionCondition$2 = getDirectionCondition("", ["resizable", "scalable"]), Snappable = {
  name: "snappable",
  dragRelation: "strong",
  props: {
    snappable: [Boolean, Array],
    snapContainer: Object,
    snapDirections: [Boolean, Object],
    elementSnapDirections: [Boolean, Object],
    snapGap: Boolean,
    snapGridWidth: Number,
    snapGridHeight: Number,
    isDisplaySnapDigit: Boolean,
    isDisplayInnerSnapDigit: Boolean,
    snapDigit: Number,
    snapThreshold: Number,
    snapRenderThreshold: Number,
    horizontalGuidelines: Array,
    verticalGuidelines: Array,
    elementGuidelines: Array,
    bounds: Object,
    innerBounds: Object,
    snapDistFormat: Function,
    maxSnapElementGuidelineDistance: Number,
    maxSnapElementGapDistance: Number
  },
  events: {
    onSnap: "snap"
  },
  css: [`:host {
    --bounds-color: #d66;
}
.guideline {
    pointer-events: none;
    z-index: 2;
}
.guideline.bounds {
    background: #d66;
    background: var(--bounds-color);
}
.guideline-group {
    position: absolute;
    top: 0;
    left: 0;
}
.guideline-group .size-value {
    position: absolute;
    color: #f55;
    font-size: 12px;
    font-weight: bold;
}
.guideline-group.horizontal .size-value {
    transform-origin: 50% 100%;
    transform: translateX(-50%);
    left: 50%;
    bottom: 5px;
}
.guideline-group.vertical .size-value {
    transform-origin: 0% 50%;
    top: 50%;
    transform: translateY(-50%);
    left: 5px;
}
.guideline.gap {
    background: #f55;
}
.size-value.gap {
    color: #f55;
}
`],
  render: function(o, t) {
    var e = o.state, r = e.top, S = e.left, T = e.pos1, D = e.pos2, N = e.pos3, B = e.pos4, $ = e.snapRenderInfo, U = o.props.snapRenderThreshold, H = U === void 0 ? 1 : U;
    if (!$ || !$.render || !hasGuidelines(o, ""))
      return [];
    e.guidelines = getTotalGuidelines(o);
    var V = Math.min(T[0], D[0], N[0], B[0]), X = Math.min(T[1], D[1], N[1], B[1]), W = $.externalPoses || [], Y = getAbsolutePosesByState(o.state), q = [], K = [], Z = [], J = [], Q = [], rt = getRect(Y), et = rt.width, nt = rt.height, st = rt.top, it = rt.left, ot = rt.bottom, ht = rt.right, ct = {
      left: it,
      right: ht,
      top: st,
      bottom: ot,
      center: (it + ht) / 2,
      middle: (st + ot) / 2
    }, vt = W.length > 0, _t = vt ? getRect(W) : {};
    if (!$.request) {
      if ($.direction && Q.push(getSnapInfosByDirection(o, Y, $.direction, H)), $.snap) {
        var gt = getRect(Y);
        $.center && (gt.middle = (gt.top + gt.bottom) / 2, gt.center = (gt.left + gt.right) / 2), Q.push(checkSnaps(o, gt, H));
      }
      vt && ($.center && (_t.middle = (_t.top + _t.bottom) / 2, _t.center = (_t.left + _t.right) / 2), Q.push(checkSnaps(o, _t, H))), Q.forEach(function(xt) {
        var pt = xt.vertical.posInfos, yt = xt.horizontal.posInfos;
        q.push.apply(q, pt.filter(function(Dt) {
          var At = Dt.guidelineInfos;
          return At.some(function(It) {
            var Ot = It.guideline;
            return !Ot.hide;
          });
        }).map(function(Dt) {
          return {
            type: "snap",
            pos: Dt.pos
          };
        })), K.push.apply(K, yt.filter(function(Dt) {
          var At = Dt.guidelineInfos;
          return At.some(function(It) {
            var Ot = It.guideline;
            return !Ot.hide;
          });
        }).map(function(Dt) {
          return {
            type: "snap",
            pos: Dt.pos
          };
        })), Z.push.apply(Z, getSnapGuidelines(pt)), J.push.apply(J, getSnapGuidelines(yt));
      });
    }
    addBoundGuidelines(o, [it, ht], [st, ot], q, K), vt && addBoundGuidelines(o, [_t.left, _t.right], [_t.top, _t.bottom], q, K, $.externalBounds);
    var mt = __spreadArray(__spreadArray([], Z, !0), J, !0), Et = mt.filter(function(xt) {
      return xt.element && !xt.gapRects;
    }), wt = mt.filter(function(xt) {
      return xt.gapRects;
    }).sort(function(xt, pt) {
      return xt.gap - pt.gap;
    });
    return triggerEvent(o, "onSnap", {
      guidelines: mt.filter(function(xt) {
        var pt = xt.element;
        return !pt;
      }),
      elements: Et,
      gaps: wt
    }, !0), __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], renderDashedGuidelines(o, Et, [V, X], ct, t), !0), renderGapGuidelines(o, wt, [V, X], ct, t), !0), renderGuidelines(o, "horizontal", J, [S, r], ct, t), !0), renderGuidelines(o, "vertical", Z, [S, r], ct, t), !0), renderSnapPoses(o, "horizontal", K, V, r, et, 0, t), !0), renderSnapPoses(o, "vertical", q, X, S, nt, 1, t), !0);
  },
  dragStart: function(o, t) {
    o.state.snapRenderInfo = {
      request: t.isRequest,
      snap: !0,
      center: !0
    }, checkSnapInfo(o);
  },
  drag: function(o) {
    var t = o.state;
    checkSnapInfo(o) || (t.guidelines = getTotalGuidelines(o)), t.snapRenderInfo && (t.snapRenderInfo.render = !0);
  },
  pinchStart: function(o) {
    this.unset(o);
  },
  dragEnd: function(o) {
    this.unset(o);
  },
  dragControlCondition: function(o, t) {
    if (directionCondition$2(o, t) || dragControlCondition(o, t))
      return !0;
    if (!t.isRequest && t.inputEvent)
      return hasClass(t.inputEvent.target, prefix("snap-control"));
  },
  dragControlStart: function(o) {
    o.state.snapRenderInfo = null, checkSnapInfo(o);
  },
  dragControl: function(o) {
    this.drag(o);
  },
  dragControlEnd: function(o) {
    this.unset(o);
  },
  dragGroupStart: function(o, t) {
    this.dragStart(o, t);
  },
  dragGroup: function(o) {
    this.drag(o);
  },
  dragGroupEnd: function(o) {
    this.unset(o);
  },
  dragGroupControlStart: function(o) {
    o.state.snapRenderInfo = null, checkSnapInfo(o);
  },
  dragGroupControl: function(o) {
    this.drag(o);
  },
  dragGroupControlEnd: function(o) {
    this.unset(o);
  },
  unset: function(o) {
    var t = o.state;
    t.enableSnap = !1, t.guidelines = [], t.snapRenderInfo = null, t.elementRects = [];
  }
};
function renderDirectionControlsByInfos(o, t, e, r) {
  var S = o.getState(), T = S.renderPoses, D = S.rotation, N = S.direction, B = getProps(o.props, t).zoom, $ = N > 0 ? 1 : -1, U = D / Math.PI * 180, H = {}, V = o.renderState;
  V.renderDirectionMap || (V.renderDirectionMap = {});
  var X = V.renderDirectionMap;
  return e.forEach(function(W) {
    var Y = W.dir;
    H[Y] = !0;
  }), e.map(function(W) {
    var Y = W.data, q = W.classNames, K = W.dir, Z = DIRECTION_INDEXES[K];
    if (!Z || !H[K])
      return null;
    X[K] = !0;
    var J = (throttle(U, 15) + $ * DIRECTION_ROTATIONS[K] + 720) % 180, Q = {};
    return getKeys(Y).forEach(function(rt) {
      Q["data-".concat(rt)] = Y[rt];
    }), r.createElement("div", __assign$1({
      className: prefix.apply(void 0, __spreadArray(["control", "direction", K, t], q, !1)),
      "data-rotation": J,
      "data-direction": K
    }, Q, {
      key: "direction-".concat(K),
      style: getControlTransform.apply(void 0, __spreadArray([D, B], Z.map(function(rt) {
        return T[rt];
      }), !1))
    }));
  });
}
function renderDirectionControls(o, t, e, r) {
  var S = getProps(o.props, e).renderDirections, T = S === void 0 ? t : S;
  if (!T)
    return [];
  var D = T === !0 ? DIRECTIONS : T;
  return renderDirectionControlsByInfos(o, e, D.map(function(N) {
    return {
      data: {},
      classNames: [],
      dir: N
    };
  }), r);
}
function renderAroundControls(o, t) {
  var e = o.renderState;
  e.renderDirectionMap || (e.renderDirectionMap = {});
  var r = o.getState(), S = r.renderPoses, T = r.rotation, D = r.direction, N = e.renderDirectionMap, B = o.props.zoom, $ = D > 0 ? 1 : -1, U = T / Math.PI * 180;
  return getKeys(N).map(function(H) {
    var V = DIRECTION_INDEXES[H];
    if (!V)
      return null;
    var X = (throttle(U, 15) + $ * DIRECTION_ROTATIONS[H] + 720) % 180;
    return t.createElement("div", {
      className: prefix("around-control"),
      "data-rotation": X,
      "data-direction": H,
      key: "direction-around-".concat(H),
      style: getControlTransform.apply(void 0, __spreadArray([T, B], V.map(function(W) {
        return S[W];
      }), !1))
    });
  });
}
function renderLine(o, t, e, r, S, T) {
  for (var D = [], N = 6; N < arguments.length; N++)
    D[N - 6] = arguments[N];
  var B = getRad$1(e, r), $ = t ? throttle(B / Math.PI * 180, 15) % 180 : -1;
  return o.createElement("div", {
    key: "line-".concat(T),
    className: prefix.apply(void 0, __spreadArray(["line", "direction", t ? "edge" : "", t], D, !1)),
    "data-rotation": $,
    "data-line-key": T,
    "data-direction": t,
    style: getLineStyle(e, r, S, B)
  });
}
function renderEdgeLines(o, t, e, r, S) {
  var T = e === !0 ? DIRECTIONS4 : e;
  return T.map(function(D, N) {
    var B = DIRECTION_INDEXES[D], $ = B[0], U = B[1];
    if (U != null)
      return renderLine(o, D, r[$], r[U], S, "".concat(t, "Edge").concat(N), t);
  }).filter(Boolean);
}
function getRenderDirections(o) {
  return function(t, e) {
    var r = getProps(t.props, o).edge;
    return r && (r === !0 || r.length) ? __spreadArray(__spreadArray([], renderEdgeLines(e, o, r, t.getState().renderPoses, t.props.zoom), !0), renderDiagonalDirections(t, o, e), !0) : renderAllDirections(t, o, e);
  };
}
function renderAllDirections(o, t, e) {
  return renderDirectionControls(o, DIRECTIONS, t, e);
}
function renderDiagonalDirections(o, t, e) {
  return renderDirectionControls(o, ["nw", "ne", "sw", "se"], t, e);
}
var Draggable = {
  name: "draggable",
  props: {
    draggable: Boolean,
    throttleDrag: Number,
    throttleDragRotate: Number,
    startDragRotate: Number,
    edgeDraggable: Boolean
  },
  events: {
    onDragStart: "dragStart",
    onDrag: "drag",
    onDragEnd: "dragEnd",
    onDragGroupStart: "dragGroupStart",
    onDragGroup: "dragGroup",
    onDragGroupEnd: "dragGroupEnd"
  },
  requestStyle: function() {
    return ["left", "top", "right", "bottom"];
  },
  render: function(o, t) {
    var e = o.props, r = e.throttleDragRotate, S = e.zoom, T = o.getState(), D = T.dragInfo, N = T.beforeOrigin;
    if (!r || !D)
      return [];
    var B = D.dist;
    if (!B[0] && !B[1])
      return [];
    var $ = getDistSize(B), U = getRad$1(B, [0, 0]);
    return [t.createElement("div", {
      className: prefix("line", "horizontal", "dragline", "dashed"),
      key: "dragRotateGuideline",
      style: {
        width: "".concat($, "px"),
        transform: "translate(".concat(N[0], "px, ").concat(N[1], "px) rotate(").concat(U, "rad) scaleY(").concat(S, ")")
      }
    })];
  },
  dragStart: function(o, t) {
    var e = t.datas, r = t.parentEvent, S = t.parentGesto, T = o.state, D = T.gestos, N = T.style;
    if (D.draggable)
      return !1;
    D.draggable = S || o.targetGesto, e.datas = {}, e.left = parseFloat(N.left || "") || 0, e.top = parseFloat(N.top || "") || 0, e.bottom = parseFloat(N.bottom || "") || 0, e.right = parseFloat(N.right || "") || 0, e.startValue = [0, 0], setDragStart(o, t), setDefaultTransformIndex(t, "translate"), startCheckSnapDrag(o, e), e.prevDist = [0, 0], e.prevBeforeDist = [0, 0], e.isDrag = !1, e.deltaOffset = [0, 0];
    var B = fillParams(o, t, __assign$1({
      set: function(U) {
        e.startValue = U;
      }
    }, fillTransformStartEvent(t))), $ = r || triggerEvent(o, "onDragStart", B);
    return $ !== !1 ? (e.isDrag = !0, o.state.dragInfo = {
      startRect: o.getRect(),
      dist: [0, 0]
    }) : (D.draggable = null, e.isPinch = !1), e.isDrag ? B : !1;
  },
  drag: function(o, t) {
    if (t) {
      resolveTransformEvent(t, "translate");
      var e = t.datas, r = t.parentEvent, S = t.parentFlag, T = t.isPinch, D = t.isRequest, N = t.deltaOffset, B = t.distX, $ = t.distY, U = e.isDrag, H = e.prevDist, V = e.prevBeforeDist, X = e.startValue;
      if (U) {
        N && (B += N[0], $ += N[1]);
        var W = o.props, Y = W.parentMoveable, q = r ? 0 : W.throttleDrag || 0, K = r ? 0 : W.throttleDragRotate || 0, Z = 0, J = !1, Q = !1, rt = !1, et = !1;
        if (!r && K > 0 && (B || $)) {
          var nt = W.startDragRotate || 0, st = throttle(nt + getRad$1([0, 0], [B, $]) * 180 / Math.PI, K) - nt, it = $ * Math.abs(Math.cos((st - 90) / 180 * Math.PI)), ot = B * Math.abs(Math.cos(st / 180 * Math.PI)), ht = getDistSize([ot, it]);
          Z = st * Math.PI / 180, B = ht * Math.cos(Z), $ = ht * Math.sin(Z);
        }
        if (!T && !r && !S) {
          var ct = checkSnapBoundsDrag(o, B, $, K, D || N, e), vt = ct[0], _t = ct[1];
          J = vt.isSnap, Q = vt.isBound, rt = _t.isSnap, et = _t.isBound;
          var gt = vt.offset, mt = _t.offset;
          B += gt, $ += mt;
        }
        var Et = plus(getBeforeDragDist({
          datas: e,
          distX: B,
          distY: $
        }), X), wt = plus(getTransformDist({
          datas: e,
          distX: B,
          distY: $
        }), X);
        throttleArray(wt, TINY_NUM), throttleArray(Et, TINY_NUM), K || (!J && !Q && (wt[0] = throttle(wt[0], q), Et[0] = throttle(Et[0], q)), !rt && !et && (wt[1] = throttle(wt[1], q), Et[1] = throttle(Et[1], q)));
        var xt = minus(Et, X), pt = minus(wt, X), yt = minus(pt, H), Dt = minus(xt, V);
        e.prevDist = pt, e.prevBeforeDist = xt, e.passDelta = yt, e.passDist = pt;
        var At = e.left + xt[0], It = e.top + xt[1], Ot = e.right - xt[0], ft = e.bottom - xt[1], Ft = convertTransformFormat(e, "translate(".concat(wt[0], "px, ").concat(wt[1], "px)"), "translate(".concat(pt[0], "px, ").concat(pt[1], "px)"));
        if (fillOriginalTransform(t, Ft), o.state.dragInfo.dist = r ? [0, 0] : pt, !(!r && !Y && yt.every(function(Ht) {
          return !Ht;
        }) && Dt.some(function(Ht) {
          return !Ht;
        }))) {
          var Mt = o.state, zt = Mt.width, Nt = Mt.height, St = fillParams(o, t, __assign$1({
            transform: Ft,
            dist: pt,
            delta: yt,
            translate: wt,
            beforeDist: xt,
            beforeDelta: Dt,
            beforeTranslate: Et,
            left: At,
            top: It,
            right: Ot,
            bottom: ft,
            width: zt,
            height: Nt,
            isPinch: T
          }, fillCSSObject({
            transform: Ft
          }, t)));
          return !r && triggerEvent(o, "onDrag", St), St;
        }
      }
    }
  },
  dragAfter: function(o, t) {
    var e = t.datas, r = e.deltaOffset;
    return r[0] || r[1] ? (e.deltaOffset = [0, 0], this.drag(o, __assign$1(__assign$1({}, t), {
      deltaOffset: r
    }))) : !1;
  },
  dragEnd: function(o, t) {
    var e = t.parentEvent, r = t.datas;
    if (o.state.dragInfo = null, !!r.isDrag) {
      r.isDrag = !1;
      var S = fillEndParams(o, t, {});
      return !e && triggerEvent(o, "onDragEnd", S), S;
    }
  },
  dragGroupStart: function(o, t) {
    var e = t.datas, r = t.clientX, S = t.clientY, T = this.dragStart(o, t);
    if (!T)
      return !1;
    var D = triggerChildGesto(o, this, "dragStart", [r || 0, S || 0], t, !1, "draggable"), N = __assign$1(__assign$1({}, T), {
      targets: o.props.targets,
      events: D
    }), B = triggerEvent(o, "onDragGroupStart", N);
    return e.isDrag = B !== !1, e.isDrag ? T : !1;
  },
  dragGroup: function(o, t) {
    var e = t.datas;
    if (e.isDrag) {
      var r = this.drag(o, t), S = t.datas.passDelta, T = triggerChildGesto(o, this, "drag", S, t, !1, "draggable");
      if (r) {
        var D = __assign$1({
          targets: o.props.targets,
          events: T
        }, r);
        return triggerEvent(o, "onDragGroup", D), D;
      }
    }
  },
  dragGroupEnd: function(o, t) {
    var e = t.isDrag, r = t.datas;
    if (r.isDrag) {
      this.dragEnd(o, t);
      var S = triggerChildGesto(o, this, "dragEnd", [0, 0], t, !1, "draggable");
      return triggerEvent(o, "onDragGroupEnd", fillEndParams(o, t, {
        targets: o.props.targets,
        events: S
      })), e;
    }
  },
  /**
   * @method Moveable.Draggable#request
   * @param {object} [e] - the draggable's request parameter
   * @param {number} [e.x] - x position
   * @param {number} [e.y] - y position
   * @param {number} [e.deltaX] - X number to move
   * @param {number} [e.deltaY] - Y number to move
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * // Use Relative Value
   * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
   * // Use Absolute Value
   * moveable.request("draggable", { x: 200, y: 100 }, true);
   *
   * // requestStart
   * const requester = moveable.request("draggable");
   *
   * // request
   * // Use Relative Value
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * // Use Absolute Value
   * moveable.request("draggable", { x: 200, y: 100 });
   * moveable.request("draggable", { x: 220, y: 100 });
   * moveable.request("draggable", { x: 240, y: 100 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function(o) {
    var t = {}, e = o.getRect(), r = 0, S = 0;
    return {
      isControl: !1,
      requestStart: function() {
        return {
          datas: t
        };
      },
      request: function(T) {
        return "x" in T ? r = T.x - e.left : "deltaX" in T && (r += T.deltaX), "y" in T ? S = T.y - e.top : "deltaY" in T && (S += T.deltaY), {
          datas: t,
          distX: r,
          distY: S
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  },
  unset: function(o) {
    o.state.gestos.draggable = null, o.state.dragInfo = null;
  }
}, directionCondition$1 = getDirectionCondition("resizable"), Resizable = {
  name: "resizable",
  ableGroup: "size",
  canPinch: !0,
  props: {
    resizable: Boolean,
    throttleResize: Number,
    renderDirections: Array,
    keepRatio: Boolean,
    resizeFormat: Function,
    keepRatioFinally: Boolean,
    edge: Boolean,
    checkResizableError: Boolean
  },
  events: {
    onResizeStart: "resizeStart",
    onBeforeResize: "beforeResize",
    onResize: "resize",
    onResizeEnd: "resizeEnd",
    onResizeGroupStart: "resizeGroupStart",
    onBeforeResizeGroup: "beforeResizeGroup",
    onResizeGroup: "resizeGroup",
    onResizeGroupEnd: "resizeGroupEnd"
  },
  render: getRenderDirections("resizable"),
  dragControlCondition: directionCondition$1,
  viewClassName: getDirectionViewClassName("resizable"),
  dragControlStart: function(o, t) {
    var e, r = t.inputEvent, S = t.isPinch, T = t.isGroup, D = t.parentDirection, N = t.parentGesto, B = t.datas, $ = t.parentFixedDirection, U = t.parentEvent, H = getTotalDirection(D, S, r, B), V = o.state, X = V.target, W = V.width, Y = V.height, q = V.gestos;
    if (!H || !X || q.resizable)
      return !1;
    q.resizable = N || o.controlGesto, !S && setDragStart(o, t), B.datas = {}, B.direction = H, B.startOffsetWidth = W, B.startOffsetHeight = Y, B.prevWidth = 0, B.prevHeight = 0, B.minSize = [0, 0], B.startWidth = V.inlineCSSWidth || V.cssWidth, B.startHeight = V.inlineCSSHeight || V.cssHeight, B.maxSize = [1 / 0, 1 / 0], T || (B.minSize = [V.minOffsetWidth, V.minOffsetHeight], B.maxSize = [V.maxOffsetWidth, V.maxOffsetHeight]);
    var K = o.props.transformOrigin || "% %";
    B.transformOrigin = K && isString$1(K) ? K.split(" ") : K, B.startOffsetMatrix = V.offsetMatrix, B.startTransformOrigin = V.transformOrigin, B.isWidth = (e = t == null ? void 0 : t.parentIsWidth) !== null && e !== void 0 ? e : !H[0] && !H[1] || H[0] || !H[1];
    function Z(it) {
      B.ratio = it && isFinite(it) ? it : 0;
    }
    B.startPositions = getAbsolutePosesByState(o.state);
    function J(it) {
      B.fixedDirection = it, B.fixedPosition = getPosByDirection(B.startPositions, it);
    }
    function Q(it) {
      var ot = o.state, ht = ot.width, ct = ot.height;
      B.fixedPosition = it, B.fixedDirection = getDirectionByPos(it, ht, ct);
    }
    function rt(it) {
      B.minSize = [convertUnitSize("".concat(it[0]), 0) || 0, convertUnitSize("".concat(it[1]), 0) || 0];
    }
    function et(it) {
      var ot = [it[0] || 1 / 0, it[1] || 1 / 0];
      (!isNumber(ot[0]) || isFinite(ot[0])) && (ot[0] = convertUnitSize("".concat(ot[0]), 0) || 1 / 0), (!isNumber(ot[1]) || isFinite(ot[1])) && (ot[1] = convertUnitSize("".concat(ot[1]), 0) || 1 / 0), B.maxSize = ot;
    }
    Z(W / Y), J($ || [-H[0], -H[1]]), B.setFixedDirection = J, B.setFixedPosition = Q, B.setMin = rt, B.setMax = et;
    var nt = fillParams(o, t, {
      direction: H,
      startRatio: B.ratio,
      set: function(it) {
        var ot = it[0], ht = it[1];
        B.startWidth = ot, B.startHeight = ht;
      },
      setMin: rt,
      setMax: et,
      setRatio: Z,
      setFixedDirection: J,
      setFixedPosition: Q,
      setOrigin: function(it) {
        B.transformOrigin = it;
      },
      dragStart: Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))
    }), st = U || triggerEvent(o, "onResizeStart", nt);
    return B.startFixedDirection = B.fixedDirection, B.startFixedPosition = B.fixedPosition, st !== !1 && (B.isResize = !0, o.state.snapRenderInfo = {
      request: t.isRequest,
      direction: H
    }), B.isResize ? nt : !1;
  },
  dragControl: function(o, t) {
    var e, r = t.datas, S = t.parentFlag, T = t.isPinch, D = t.parentKeepRatio, N = t.dragClient, B = t.parentDist, $ = t.isRequest, U = t.isGroup, H = t.parentEvent, V = t.resolveMatrix, X = r.isResize, W = r.transformOrigin, Y = r.startWidth, q = r.startHeight, K = r.prevWidth, Z = r.prevHeight, J = r.minSize, Q = r.maxSize, rt = r.ratio, et = r.startOffsetWidth, nt = r.startOffsetHeight, st = r.isWidth;
    if (!X)
      return;
    if (V) {
      var it = o.state.is3d, ot = r.startOffsetMatrix, ht = r.startTransformOrigin, ct = it ? 4 : 3, vt = parseMat(getNextTransforms(t)), _t = Math.sqrt(vt.length);
      ct !== _t && (vt = convertDimension(vt, _t, ct));
      var gt = getNextMatrix(ot, vt, ht, ct), mt = calculatePoses(gt, et, nt, ct);
      r.startPositions = mt, r.nextTargetMatrix = vt, r.nextAllMatrix = gt;
    }
    var Et = getProps(o.props, "resizable"), wt = Et.resizeFormat, xt = Et.throttleResize, pt = xt === void 0 ? S ? 0 : 1 : xt, yt = Et.parentMoveable, Dt = Et.keepRatioFinally, At = r.direction, It = At, Ot = 0, ft = 0;
    !At[0] && !At[1] && (It = [1, 1]);
    var Ft = rt && (D ?? Et.keepRatio) || !1;
    function Mt() {
      var ue = r.fixedDirection, me = getOffsetSizeDist(It, Ft, r, t);
      Ot = me.distWidth, ft = me.distHeight;
      var pe = It[0] - ue[0] || Ft ? Math.max(et + Ot, TINY_NUM) : et, fe = It[1] - ue[1] || Ft ? Math.max(nt + ft, TINY_NUM) : nt;
      return Ft && et && nt && (st ? fe = pe / rt : pe = fe * rt), [pe, fe];
    }
    var zt = Mt(), Nt = zt[0], St = zt[1];
    H || (r.setFixedDirection(r.fixedDirection), triggerEvent(o, "onBeforeResize", fillParams(o, t, {
      startFixedDirection: r.startFixedDirection,
      startFixedPosition: r.startFixedPosition,
      setFixedDirection: function(ue) {
        var me;
        return r.setFixedDirection(ue), me = Mt(), Nt = me[0], St = me[1], [Nt, St];
      },
      setFixedPosition: function(ue) {
        var me;
        return r.setFixedPosition(ue), me = Mt(), Nt = me[0], St = me[1], [Nt, St];
      },
      boundingWidth: Nt,
      boundingHeight: St,
      setSize: function(ue) {
        Nt = ue[0], St = ue[1];
      }
    }, !0)));
    var Ht = N;
    N || (!S && T ? Ht = getAbsolutePosition(o, [0, 0]) : Ht = r.fixedPosition);
    var Lt = [0, 0];
    T || (Lt = checkSnapResize(o, Nt, St, At, Ht, $, r)), B && (!B[0] && (Lt[0] = 0), !B[1] && (Lt[1] = 0));
    function Tt() {
      var ue;
      wt && (ue = wt([Nt, St]), Nt = ue[0], St = ue[1]), Nt = throttle(Nt, pt), St = throttle(St, pt);
    }
    if (Ft) {
      It[0] && It[1] && Lt[0] && Lt[1] && (Math.abs(Lt[0]) > Math.abs(Lt[1]) ? Lt[1] = 0 : Lt[0] = 0);
      var kt = !Lt[0] && !Lt[1];
      kt && Tt(), It[0] && !It[1] || Lt[0] && !Lt[1] || kt && st ? (Nt += Lt[0], St = Nt / rt) : (!It[0] && It[1] || !Lt[0] && Lt[1] || kt && !st) && (St += Lt[1], Nt = St * rt);
    } else
      Nt += Lt[0], St += Lt[1], Nt = Math.max(0, Nt), St = Math.max(0, St);
    e = calculateBoundSize([Nt, St], J, Q, Ft ? rt : !1), Nt = e[0], St = e[1], Tt(), Ft && (U || Dt) && (st ? St = Nt / rt : Nt = St * rt), Ot = Nt - et, ft = St - nt;
    var Ut = [Ot - K, ft - Z];
    r.prevWidth = Ot, r.prevHeight = ft;
    var Ct = getResizeDist(o, Nt, St, Ht, W, r);
    if (!(!yt && Ut.every(function(ue) {
      return !ue;
    }) && Ct.every(function(ue) {
      return !ue;
    }))) {
      var Wt = Draggable.drag(o, setCustomDrag(t, o.state, Ct, !!T, !1, "draggable")), Jt = Wt.transform, qt = Y + Ot, xe = q + ft, Me = fillParams(o, t, __assign$1({
        width: qt,
        height: xe,
        offsetWidth: Math.round(Nt),
        offsetHeight: Math.round(St),
        startRatio: rt,
        boundingWidth: Nt,
        boundingHeight: St,
        direction: At,
        dist: [Ot, ft],
        delta: Ut,
        isPinch: !!T,
        drag: Wt
      }, fillAfterTransform({
        style: {
          width: "".concat(qt, "px"),
          height: "".concat(xe, "px")
        },
        transform: Jt
      }, Wt, t)));
      return !H && triggerEvent(o, "onResize", Me), Me;
    }
  },
  dragControlAfter: function(o, t) {
    var e = t.datas, r = e.isResize, S = e.startOffsetWidth, T = e.startOffsetHeight, D = e.prevWidth, N = e.prevHeight;
    if (!(!r || o.props.checkResizableError === !1)) {
      var B = o.state, $ = B.width, U = B.height, H = $ - (S + D), V = U - (T + N), X = Math.abs(H) > 3, W = Math.abs(V) > 3;
      if (X && (e.startWidth += H, e.startOffsetWidth += H, e.prevWidth += H), W && (e.startHeight += V, e.startOffsetHeight += V, e.prevHeight += V), X || W)
        return this.dragControl(o, t);
    }
  },
  dragControlEnd: function(o, t) {
    var e = t.datas, r = t.parentEvent;
    if (e.isResize) {
      e.isResize = !1;
      var S = fillEndParams(o, t, {});
      return !r && triggerEvent(o, "onResizeEnd", S), S;
    }
  },
  dragGroupControlCondition: directionCondition$1,
  dragGroupControlStart: function(o, t) {
    var e = t.datas, r = this.dragControlStart(o, __assign$1(__assign$1({}, t), {
      isGroup: !0
    }));
    if (!r)
      return !1;
    var S = fillChildEvents(o, "resizable", t);
    function T(W, Y) {
      var q = e.fixedDirection, K = e.fixedPosition, Z = Y.datas.startPositions || getAbsolutePosesByState(W.state), J = getPosByDirection(Z, q), Q = calculate(createRotateMatrix(-o.rotation / 180 * Math.PI, 3), [J[0] - K[0], J[1] - K[1], 1], 3), rt = Q[0], et = Q[1];
      return Y.datas.originalX = rt, Y.datas.originalY = et, Y;
    }
    var D = e.startOffsetWidth, N = e.startOffsetHeight;
    function B() {
      var W = e.minSize;
      S.forEach(function(Y) {
        var q = Y.datas, K = q.minSize, Z = q.startOffsetWidth, J = q.startOffsetHeight, Q = D * (Z ? K[0] / Z : 0), rt = N * (J ? K[1] / J : 0);
        W[0] = Math.max(W[0], Q), W[1] = Math.max(W[1], rt);
      });
    }
    function $() {
      var W = e.maxSize;
      S.forEach(function(Y) {
        var q = Y.datas, K = q.maxSize, Z = q.startOffsetWidth, J = q.startOffsetHeight, Q = D * (Z ? K[0] / Z : 0), rt = N * (J ? K[1] / J : 0);
        W[0] = Math.min(W[0], Q), W[1] = Math.min(W[1], rt);
      });
    }
    var U = triggerChildAbles(o, this, "dragControlStart", t, function(W, Y) {
      return T(W, Y);
    });
    B(), $();
    var H = function(W) {
      r.setFixedDirection(W), U.forEach(function(Y, q) {
        Y.setFixedDirection(W), T(Y.moveable, S[q]);
      });
    };
    e.setFixedDirection = H;
    var V = __assign$1(__assign$1({}, r), {
      targets: o.props.targets,
      events: U.map(function(W) {
        return __assign$1(__assign$1({}, W), {
          setMin: function(Y) {
            W.setMin(Y), B();
          },
          setMax: function(Y) {
            W.setMax(Y), $();
          }
        });
      }),
      setFixedDirection: H,
      setMin: function(W) {
        r.setMin(W), B();
      },
      setMax: function(W) {
        r.setMax(W), $();
      }
    }), X = triggerEvent(o, "onResizeGroupStart", V);
    return e.isResize = X !== !1, e.isResize ? r : !1;
  },
  dragGroupControl: function(o, t) {
    var e = t.datas;
    if (e.isResize) {
      var r = getProps(o.props, "resizable");
      catchEvent(o, "onBeforeResize", function(X) {
        triggerEvent(o, "onBeforeResizeGroup", fillParams(o, t, __assign$1(__assign$1({}, X), {
          targets: r.targets
        }), !0));
      });
      var S = this.dragControl(o, __assign$1(__assign$1({}, t), {
        isGroup: !0
      }));
      if (S) {
        var T = S.boundingWidth, D = S.boundingHeight, N = S.dist, B = r.keepRatio, $ = [T / (T - N[0]), D / (D - N[1])], U = e.fixedPosition, H = triggerChildAbles(o, this, "dragControl", t, function(X, W) {
          var Y = calculate(createRotateMatrix(o.rotation / 180 * Math.PI, 3), [W.datas.originalX * $[0], W.datas.originalY * $[1], 1], 3), q = Y[0], K = Y[1];
          return __assign$1(__assign$1({}, W), {
            parentDist: null,
            parentScale: $,
            dragClient: plus(U, [q, K]),
            parentKeepRatio: B
          });
        }), V = __assign$1({
          targets: r.targets,
          events: H
        }, S);
        return triggerEvent(o, "onResizeGroup", V), V;
      }
    }
  },
  dragGroupControlEnd: function(o, t) {
    var e = t.isDrag, r = t.datas;
    if (r.isResize) {
      this.dragControlEnd(o, t);
      var S = triggerChildAbles(o, this, "dragControlEnd", t), T = fillEndParams(o, t, {
        targets: o.props.targets,
        events: S
      });
      return triggerEvent(o, "onResizeGroupEnd", T), e;
    }
  },
  /**
   * @method Moveable.Resizable#request
   * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * // Use Relative Value
   * moveable.request("resizable", { deltaWidth: 10, deltaHeight: 10 }, true);
   *
   * // Use Absolute Value
   * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 }, true);
   *
   * // requestStart
   * const requester = moveable.request("resizable");
   *
   * // request
   * // Use Relative Value
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   *
   * // Use Absolute Value
   * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 });
   * moveable.request("resizable", { offsetWidth: 110, offsetHeight: 100 });
   * moveable.request("resizable", { offsetWidth: 120, offsetHeight: 100 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function(o) {
    var t = {}, e = 0, r = 0, S = o.getRect();
    return {
      isControl: !0,
      requestStart: function(T) {
        var D;
        return {
          datas: t,
          parentDirection: T.direction || [1, 1],
          parentIsWidth: (D = T == null ? void 0 : T.horizontal) !== null && D !== void 0 ? D : !0
        };
      },
      request: function(T) {
        return "offsetWidth" in T ? e = T.offsetWidth - S.offsetWidth : "deltaWidth" in T && (e += T.deltaWidth), "offsetHeight" in T ? r = T.offsetHeight - S.offsetHeight : "deltaHeight" in T && (r += T.deltaHeight), {
          datas: t,
          parentDist: [e, r],
          parentKeepRatio: T.keepRatio
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  },
  unset: function(o) {
    o.state.gestos.resizable = null;
  }
};
function setRotateStartInfo(o, t, e, r, S) {
  var T = o.props.groupable, D = o.state, N = D.is3d ? 4 : 3, B = t.origin, $ = calculatePosition(
    o.state.rootMatrix,
    // TO-DO #710
    minus([B[0], B[1]], T ? [0, 0] : [D.left, D.top]),
    N
  ), U = plus([S.left, S.top], $);
  t.startAbsoluteOrigin = U, t.prevDeg = getRad$1(U, [e, r]) / Math.PI * 180, t.defaultDeg = t.prevDeg, t.prevSnapDeg = 0, t.loop = 0, t.startDist = getDist$2(U, [e, r]);
}
function getAbsoluteDist(o, t, e) {
  var r = e.defaultDeg, S = e.prevDeg, T = S % 360, D = Math.floor(S / 360);
  T < 0 && (T += 360), T > o && T > 270 && o < 90 ? ++D : T < o && T < 90 && o > 270 && --D;
  var N = t * (D * 360 + o - r);
  return e.prevDeg = r + N, N;
}
function getAbsoluteDistByClient(o, t, e, r) {
  return getAbsoluteDist(getRad$1(r.startAbsoluteOrigin, [o, t]) / Math.PI * 180, e, r);
}
function getRotateInfo(o, t, e, r, S, T) {
  var D = o.props.throttleRotate, N = D === void 0 ? 0 : D, B = e.prevSnapDeg, $ = 0, U = !1;
  if (T) {
    var H = checkSnapRotate(o, t, r);
    U = H.isSnap, $ = S + H.rotation;
  }
  U || ($ = throttle(S + r, N));
  var V = $ - S;
  return e.prevSnapDeg = V, [V - B, V, $];
}
function getRotationPositions(o, t, e) {
  var r = t[0], S = t[1], T = t[2], D = t[3];
  if (o === "none")
    return [];
  if (isArray(o))
    return o.map(function(Y) {
      return getRotationPositions(Y, [r, S, T, D], e)[0];
    });
  var N = (o || "top").split("-"), B = N[0], $ = N[1], U = [r, S];
  B === "left" ? U = [T, r] : B === "right" ? U = [S, D] : B === "bottom" && (U = [D, T]);
  var H = [(U[0][0] + U[1][0]) / 2, (U[0][1] + U[1][1]) / 2], V = getRotationRad(U, e);
  if ($) {
    var X = $ === "top" || $ === "left", W = B === "bottom" || B === "left";
    H = U[X && !W || !X && W ? 0 : 1];
  }
  return [[H, V]];
}
function dragControlCondition(o, t) {
  if (t.isRequest)
    return t.requestAble === "rotatable";
  var e = t.inputEvent.target;
  if (hasClass(e, prefix("rotation-control")) || hasClass(e, prefix("around-control")) || hasClass(e, prefix("control")) && hasClass(e, prefix("rotatable")))
    return !0;
  var r = o.props.rotationTarget;
  return r ? getRefTargets(r, !0).some(function(S) {
    return S ? e === S || e.contains(S) : !1;
  }) : !1;
}
var directionCSS = DIRECTIONS.map(function(o) {
  var t = "", e = "", r = "center", S = "center";
  return o.indexOf("n") > -1 && (t = "top: -20px;", S = "bottom"), o.indexOf("s") > -1 && (t = "top: 0px;", S = "top"), o.indexOf("w") > -1 && (e = "left: -20px;", r = "right"), o.indexOf("e") > -1 && (e = "left: 0px;", r = "left"), '.around-control[data-direction*="'.concat(o, `"] {
        `).concat(e).concat(t, `
        transform-origin: `).concat(r, " ").concat(S, `;
    }`);
}).join(`
`), css = `.rotation {
    position: absolute;
    height: 40px;
    width: 1px;
    transform-origin: 50% 100%;
    height: calc(40px * var(--zoom));
    top: auto;
    left: 0;
    bottom: 100%;
    will-change: transform;
}
.rotation .rotation-line {
    display: block;
    width: 100%;
    height: 100%;
    transform-origin: 50% 50%;
}
.rotation .rotation-control {
    border-color: #4af;
    border-color: var(--moveable-color);
    background:#fff;
    cursor: alias;
}
:global .view-rotation-dragging, .rotatable.direction.control {
    cursor: alias;
}
.around-control {
    position: absolute;
    will-change: transform;
    width: 20px;
    height: 20px;
    left: -10px;
    top: -10px;
    box-sizing: border-box;
    background: transparent;
    z-index: 8;
    cursor: alias;
    transform-origin: center center;
}
.rotatable.direction.control.move {
    cursor: move;
}
`.concat(directionCSS, `
`), Rotatable = {
  name: "rotatable",
  canPinch: !0,
  props: {
    rotatable: Boolean,
    rotationPosition: String,
    throttleRotate: Number,
    renderDirections: Object,
    rotationTarget: Object,
    rotateAroundControls: Boolean,
    edge: Boolean,
    resolveAblesWithRotatable: Object
  },
  events: {
    onRotateStart: "rotateStart",
    onBeforeRotate: "beforeRotate",
    onRotate: "rotate",
    onRotateEnd: "rotateEnd",
    onRotateGroupStart: "rotateGroupStart",
    onBeforeRotateGroup: "beforeRotateGroup",
    onRotateGroup: "rotateGroup",
    onRotateGroupEnd: "rotateGroupEnd"
  },
  css: [css],
  viewClassName: function(o) {
    return o.isDragging("rotatable") ? prefix("view-rotation-dragging") : "";
  },
  render: function(o, t) {
    var e = getProps(o.props, "rotatable"), r = e.rotatable, S = e.rotationPosition, T = e.zoom, D = e.renderDirections, N = e.rotateAroundControls, B = e.resolveAblesWithRotatable, $ = o.getState(), U = $.renderPoses, H = $.direction;
    if (!r)
      return null;
    var V = getRotationPositions(S, U, H), X = [];
    if (V.forEach(function(K, Z) {
      var J = K[0], Q = K[1];
      X.push(t.createElement("div", {
        key: "rotation".concat(Z),
        className: prefix("rotation"),
        style: {
          // tslint:disable-next-line: max-line-length
          transform: "translate(-50%) translate(".concat(J[0], "px, ").concat(J[1], "px) rotate(").concat(Q, "rad)")
        }
      }, t.createElement("div", {
        className: prefix("line rotation-line"),
        style: {
          transform: "scaleX(".concat(T, ")")
        }
      }), t.createElement("div", {
        className: prefix("control rotation-control"),
        style: {
          transform: "translate(0.5px) scale(".concat(T, ")")
        }
      })));
    }), D) {
      var W = getKeys(B || {}), Y = {};
      W.forEach(function(K) {
        B[K].forEach(function(Z) {
          Y[Z] = K;
        });
      });
      var q = [];
      isArray(D) && (q = D.map(function(K) {
        var Z = Y[K];
        return {
          data: Z ? {
            resolve: Z
          } : {},
          classNames: Z ? ["move"] : [],
          dir: K
        };
      })), X.push.apply(X, renderDirectionControlsByInfos(o, "rotatable", q, t));
    }
    return N && X.push.apply(X, renderAroundControls(o, t)), X;
  },
  dragControlCondition,
  dragControlStart: function(o, t) {
    var e, r, S = t.datas, T = t.clientX, D = t.clientY, N = t.parentRotate, B = t.parentFlag, $ = t.isPinch, U = t.isRequest, H = o.state, V = H.target, X = H.left, W = H.top, Y = H.direction, q = H.beforeDirection, K = H.targetTransform, Z = H.moveableClientRect, J = H.offsetMatrix, Q = H.targetMatrix, rt = H.allMatrix, et = H.width, nt = H.height;
    if (!U && !V)
      return !1;
    var st = o.getRect();
    S.rect = st, S.transform = K, S.left = X, S.top = W;
    var it = function(Ot) {
      var ft = o.state, Ft = ft.allMatrix, Mt = ft.is3d, zt = ft.width, Nt = ft.height, St = getDirectionByPos(Ot, zt, Nt);
      S.fixedDirection = St, S.fixedPosition = calculatePosition(Ft, Ot, Mt ? 4 : 3), yt && yt.setFixedPosition(Ot);
    }, ot = function(Ot) {
      S.fixedDirection = Ot, S.fixedPosition = getDirectionOffset(o, Ot), yt && yt.setFixedDirection(Ot);
    }, ht = T, ct = D;
    if (U || $ || B) {
      var vt = N || 0;
      S.beforeInfo = {
        origin: st.beforeOrigin,
        prevDeg: vt,
        defaultDeg: vt,
        prevSnapDeg: 0,
        startDist: 0
      }, S.afterInfo = __assign$1(__assign$1({}, S.beforeInfo), {
        origin: st.origin
      }), S.absoluteInfo = __assign$1(__assign$1({}, S.beforeInfo), {
        origin: st.origin,
        startValue: vt
      });
    } else {
      var _t = (r = t.inputEvent) === null || r === void 0 ? void 0 : r.target;
      if (_t) {
        var gt = _t.getAttribute("data-direction") || "", mt = DIRECTION_REGION_TO_DIRECTION[gt];
        if (mt) {
          S.isControl = !0, S.isAroundControl = hasClass(_t, prefix("around-control")), S.controlDirection = mt;
          var Et = _t.getAttribute("data-resolve");
          Et && (S.resolveAble = Et);
          var wt = calculateMoveableClientPositions(H.rootMatrix, H.renderPoses, Z);
          e = getPosByDirection(wt, mt), ht = e[0], ct = e[1];
        }
      }
      S.beforeInfo = {
        origin: st.beforeOrigin
      }, S.afterInfo = {
        origin: st.origin
      }, S.absoluteInfo = {
        origin: st.origin,
        startValue: st.rotation
      };
      var xt = it;
      it = function(Ot) {
        var ft = H.is3d ? 4 : 3, Ft = plus(getOrigin(Q, ft), Ot), Mt = Ft[0], zt = Ft[1], Nt = calculate(J, convertPositionMatrix([Mt, zt], ft)), St = calculate(rt, convertPositionMatrix([Ot[0], Ot[1]], ft));
        xt(Ot);
        var Ht = H.posDelta;
        S.beforeInfo.origin = minus(Nt, Ht), S.afterInfo.origin = minus(St, Ht), S.absoluteInfo.origin = minus(St, Ht), setRotateStartInfo(o, S.beforeInfo, ht, ct, Z), setRotateStartInfo(o, S.afterInfo, ht, ct, Z), setRotateStartInfo(o, S.absoluteInfo, ht, ct, Z);
      }, ot = function(Ot) {
        var ft = getPosByDirection([[0, 0], [et, 0], [0, nt], [et, nt]], Ot);
        it(ft);
      };
    }
    S.startClientX = ht, S.startClientY = ct, S.direction = Y, S.beforeDirection = q, S.startValue = 0, S.datas = {}, setDefaultTransformIndex(t, "rotate");
    var pt = !1, yt = !1;
    if (S.isControl && S.resolveAble) {
      var Dt = S.resolveAble;
      Dt === "resizable" && (yt = Resizable.dragControlStart(o, __assign$1(__assign$1({}, new CustomGesto("resizable").dragStart([0, 0], t)), {
        parentPosition: S.controlPosition,
        parentFixedPosition: S.fixedPosition
      })));
    }
    yt || (pt = Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))), it(H.transformOrigin);
    var At = fillParams(o, t, __assign$1(__assign$1({
      set: function(Ot) {
        S.startValue = Ot * Math.PI / 180;
      },
      setFixedDirection: ot,
      setFixedPosition: it
    }, fillTransformStartEvent(t)), {
      dragStart: pt,
      resizeStart: yt
    })), It = triggerEvent(o, "onRotateStart", At);
    return S.isRotate = It !== !1, H.snapRenderInfo = {
      request: t.isRequest
    }, S.isRotate ? At : !1;
  },
  dragControl: function(o, t) {
    var e, r, S, T = t.datas, D = t.clientDistX, N = t.clientDistY, B = t.parentRotate, $ = t.parentFlag, U = t.isPinch, H = t.groupDelta, V = T.beforeDirection, X = T.beforeInfo, W = T.afterInfo, Y = T.absoluteInfo, q = T.isRotate, K = T.startValue, Z = T.rect, J = T.startClientX, Q = T.startClientY;
    if (q) {
      resolveTransformEvent(t, "rotate");
      var rt = getTransformDirection(t), et = V * rt, nt = o.props.parentMoveable, st = 0, it, ot, ht = 0, ct, vt, _t = 0, gt, mt, Et = 180 / Math.PI * K, wt = Y.startValue, xt = !1, pt = J + D, yt = Q + N;
      if (!$ && "parentDist" in t) {
        var Dt = t.parentDist;
        it = Dt, ct = Dt, gt = Dt;
      } else
        U || $ ? (it = getAbsoluteDist(B, V, X), ct = getAbsoluteDist(B, et, W), gt = getAbsoluteDist(B, et, Y)) : (it = getAbsoluteDistByClient(pt, yt, V, X), ct = getAbsoluteDistByClient(pt, yt, et, W), gt = getAbsoluteDistByClient(pt, yt, et, Y), xt = !0);
      if (ot = Et + it, vt = Et + ct, mt = wt + gt, triggerEvent(o, "onBeforeRotate", fillParams(o, t, {
        beforeRotation: ot,
        rotation: vt,
        absoluteRotation: mt,
        setRotation: function(Ht) {
          ct = Ht - Et, it = ct, gt = ct;
        }
      }, !0)), e = getRotateInfo(o, Z, X, it, Et, xt), st = e[0], it = e[1], ot = e[2], r = getRotateInfo(o, Z, W, ct, Et, xt), ht = r[0], ct = r[1], vt = r[2], S = getRotateInfo(o, Z, Y, gt, wt, xt), _t = S[0], gt = S[1], mt = S[2], !(!_t && !ht && !st && !nt)) {
        var At = convertTransformFormat(T, "rotate(".concat(vt, "deg)"), "rotate(".concat(ct, "deg)")), It = getRotateDist(o, ct, T), Ot = minus(plus(H || [0, 0], It), T.prevInverseDist || [0, 0]);
        T.prevInverseDist = It, T.requestValue = null;
        var ft = fillTransformEvent(o, At, Ot, U, t), Ft = ft, Mt = getDist$2([pt, yt], Y.startAbsoluteOrigin) - Y.startDist, zt = void 0;
        if (T.resolveAble === "resizable") {
          var Nt = Resizable.dragControl(o, __assign$1(__assign$1({}, setCustomDrag(t, o.state, [t.deltaX, t.deltaY], !!U, !1, "resizable")), {
            resolveMatrix: !0,
            parentDistance: Mt
          }));
          Nt && (zt = Nt, Ft = fillAfterTransform(Ft, Nt, t));
        }
        var St = fillParams(o, t, __assign$1(__assign$1({
          delta: ht,
          dist: ct,
          rotate: vt,
          rotation: vt,
          beforeDist: it,
          beforeDelta: st,
          beforeRotate: ot,
          beforeRotation: ot,
          absoluteDist: gt,
          absoluteDelta: _t,
          absoluteRotate: mt,
          absoluteRotation: mt,
          isPinch: !!U,
          resize: zt
        }, ft), Ft));
        return triggerEvent(o, "onRotate", St), St;
      }
    }
  },
  dragControlEnd: function(o, t) {
    var e = t.datas;
    if (e.isRotate) {
      e.isRotate = !1;
      var r = fillEndParams(o, t, {});
      return triggerEvent(o, "onRotateEnd", r), r;
    }
  },
  dragGroupControlCondition: dragControlCondition,
  dragGroupControlStart: function(o, t) {
    var e = t.datas, r = o.state, S = r.left, T = r.top, D = r.beforeOrigin, N = this.dragControlStart(o, t);
    if (!N)
      return !1;
    N.set(e.beforeDirection * o.rotation);
    var B = triggerChildAbles(o, this, "dragControlStart", t, function(H, V) {
      var X = H.state, W = X.left, Y = X.top, q = X.beforeOrigin, K = plus(minus([W, Y], [S, T]), minus(q, D));
      return V.datas.startGroupClient = K, V.datas.groupClient = K, __assign$1(__assign$1({}, V), {
        parentRotate: 0
      });
    }), $ = __assign$1(__assign$1({}, N), {
      targets: o.props.targets,
      events: B
    }), U = triggerEvent(o, "onRotateGroupStart", $);
    return e.isRotate = U !== !1, e.isRotate ? N : !1;
  },
  dragGroupControl: function(o, t) {
    var e = t.datas;
    if (e.isRotate) {
      catchEvent(o, "onBeforeRotate", function($) {
        triggerEvent(o, "onBeforeRotateGroup", fillParams(o, t, __assign$1(__assign$1({}, $), {
          targets: o.props.targets
        }), !0));
      });
      var r = this.dragControl(o, t);
      if (r) {
        var S = e.beforeDirection, T = r.beforeDist, D = T / 180 * Math.PI, N = triggerChildAbles(o, this, "dragControl", t, function($, U) {
          var H = U.datas.startGroupClient, V = U.datas.groupClient, X = V[0], W = V[1], Y = rotate(H, D * S), q = Y[0], K = Y[1], Z = [q - X, K - W];
          return U.datas.groupClient = [q, K], __assign$1(__assign$1({}, U), {
            parentRotate: T,
            groupDelta: Z
          });
        });
        o.rotation = S * r.beforeRotation;
        var B = __assign$1({
          targets: o.props.targets,
          events: N,
          set: function($) {
            o.rotation = $;
          },
          setGroupRotation: function($) {
            o.rotation = $;
          }
        }, r);
        return triggerEvent(o, "onRotateGroup", B), B;
      }
    }
  },
  dragGroupControlEnd: function(o, t) {
    var e = t.isDrag, r = t.datas;
    if (r.isRotate) {
      this.dragControlEnd(o, t);
      var S = triggerChildAbles(o, this, "dragControlEnd", t), T = fillEndParams(o, t, {
        targets: o.props.targets,
        events: S
      });
      return triggerEvent(o, "onRotateGroupEnd", T), e;
    }
  },
  /**
   * @method Moveable.Rotatable#request
   * @param {object} [e] - the Resizable's request parameter
   * @param {number} [e.deltaRotate=0] -  delta number of rotation
   * @param {number} [e.rotate=0] - absolute number of moveable's rotation
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("rotatable", { deltaRotate: 10 }, true);
   *
   * * moveable.request("rotatable", { rotate: 10 }, true);
   *
   * // requestStart
   * const requester = moveable.request("rotatable");
   *
   * // request
   * requester.request({ deltaRotate: 10 });
   * requester.request({ deltaRotate: 10 });
   * requester.request({ deltaRotate: 10 });
   *
   * requester.request({ rotate: 10 });
   * requester.request({ rotate: 20 });
   * requester.request({ rotate: 30 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function(o) {
    var t = {}, e = 0, r = o.getRotation();
    return {
      isControl: !0,
      requestStart: function() {
        return {
          datas: t
        };
      },
      request: function(S) {
        return "deltaRotate" in S ? e += S.deltaRotate : "rotate" in S && (e = S.rotate - r), {
          datas: t,
          parentDist: e
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  }
}, directionCondition = getDirectionCondition("scalable"), Scalable = {
  name: "scalable",
  ableGroup: "size",
  canPinch: !0,
  props: {
    scalable: Boolean,
    throttleScale: Number,
    renderDirections: String,
    keepRatio: Boolean,
    edge: Boolean
  },
  events: {
    onScaleStart: "scaleStart",
    onBeforeScale: "beforeScale",
    onScale: "scale",
    onScaleEnd: "scaleEnd",
    onScaleGroupStart: "scaleGroupStart",
    onBeforeScaleGroup: "beforeScaleGroup",
    onScaleGroup: "scaleGroup",
    onScaleGroupEnd: "scaleGroupEnd"
  },
  render: getRenderDirections("scalable"),
  dragControlCondition: directionCondition,
  viewClassName: getDirectionViewClassName("scalable"),
  dragControlStart: function(o, t) {
    var e = t.datas, r = t.isPinch, S = t.inputEvent, T = t.parentDirection, D = getTotalDirection(T, r, S, e), N = o.state, B = N.width, $ = N.height, U = N.targetTransform, H = N.target, V = N.pos1, X = N.pos2, W = N.pos4;
    if (!D || !H)
      return !1;
    r || setDragStart(o, t), e.datas = {}, e.transform = U, e.prevDist = [1, 1], e.direction = D, e.startOffsetWidth = B, e.startOffsetHeight = $, e.startValue = [1, 1];
    var Y = getDist$2(V, X), q = getDist$2(X, W), K = !D[0] && !D[1] || D[0] || !D[1];
    e.scaleWidth = Y, e.scaleHeight = q, e.scaleXRatio = Y / B, e.scaleYRatio = q / $, setDefaultTransformIndex(t, "scale"), e.isWidth = K;
    function Z(et) {
      e.ratio = et && isFinite(et) ? et : 0;
    }
    e.startPositions = getAbsolutePosesByState(o.state);
    function J(et) {
      e.fixedDirection = et, e.fixedPosition = getPosByDirection(e.startPositions, et);
    }
    e.setFixedDirection = J, Z(getDist$2(V, X) / getDist$2(X, W)), J([-D[0], -D[1]]);
    var Q = fillParams(o, t, __assign$1(__assign$1({
      direction: D,
      set: function(et) {
        e.startValue = et;
      },
      setRatio: Z,
      setFixedDirection: J
    }, fillTransformStartEvent(t)), {
      dragStart: Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))
    })), rt = triggerEvent(o, "onScaleStart", Q);
    return e.startFixedDirection = e.fixedDirection, rt !== !1 && (e.isScale = !0, o.state.snapRenderInfo = {
      request: t.isRequest,
      direction: D
    }), e.isScale ? Q : !1;
  },
  dragControl: function(o, t) {
    resolveTransformEvent(t, "scale");
    var e = t.datas, r = t.parentKeepRatio, S = t.parentFlag, T = t.isPinch, D = t.dragClient, N = t.isRequest, B = e.prevDist, $ = e.direction, U = e.startOffsetWidth, H = e.startOffsetHeight, V = e.isScale, X = e.startValue, W = e.isWidth, Y = e.ratio;
    if (!V)
      return !1;
    var q = o.props, K = q.throttleScale, Z = q.parentMoveable, J = $;
    !$[0] && !$[1] && (J = [1, 1]);
    var Q = Y && (r ?? q.keepRatio) || !1, rt = o.state;
    function et() {
      var yt = getOffsetSizeDist(J, Q, e, t), Dt = yt.distWidth, At = yt.distHeight, It = U ? (U + Dt) / U : 1, Ot = H ? (H + At) / H : 1;
      return It = J[0] || Q ? It * X[0] : X[0], Ot = J[1] || Q ? Ot * X[1] : X[1], It === 0 && (It = (B[0] > 0 ? 1 : -1) * MIN_SCALE), Ot === 0 && (Ot = (B[1] > 0 ? 1 : -1) * MIN_SCALE), [It, Ot];
    }
    var nt = et();
    if (!T && o.props.groupable) {
      var st = rt.snapRenderInfo || {}, it = st.direction;
      isArray(it) && (it[0] || it[1]) && (rt.snapRenderInfo = {
        direction: $,
        request: t.isRequest
      });
    }
    triggerEvent(o, "onBeforeScale", fillParams(o, t, {
      scale: nt,
      setFixedDirection: function(yt) {
        return e.setFixedDirection(yt), nt = et(), nt;
      },
      startFixedDirection: e.startFixedDirection,
      setScale: function(yt) {
        nt = yt;
      }
    }, !0));
    var ot = [nt[0] / X[0], nt[1] / X[1]], ht = D, ct = [0, 0];
    if (D || (!S && T ? ht = getAbsolutePosition(o, [0, 0]) : ht = e.fixedPosition), T || (ct = checkSnapScale(o, ot, $, N, e)), Q) {
      J[0] && J[1] && ct[0] && ct[1] && (Math.abs(ct[0] * U) > Math.abs(ct[1] * H) ? ct[1] = 0 : ct[0] = 0);
      var vt = !ct[0] && !ct[1];
      if (vt && (W ? ot[0] = throttle(ot[0] * X[0], K) / X[0] : ot[1] = throttle(ot[1] * X[1], K) / X[1]), J[0] && !J[1] || ct[0] && !ct[1] || vt && W) {
        ot[0] += ct[0];
        var _t = U * ot[0] * X[0] / Y;
        ot[1] = _t / H / X[1];
      } else if (!J[0] && J[1] || !ct[0] && ct[1] || vt && !W) {
        ot[1] += ct[1];
        var gt = H * ot[1] * X[1] * Y;
        ot[0] = gt / U / X[0];
      }
    } else
      ot[0] += ct[0], ot[1] += ct[1], ct[0] || (ot[0] = throttle(ot[0] * X[0], K) / X[0]), ct[1] || (ot[1] = throttle(ot[1] * X[1], K) / X[1]);
    ot[0] === 0 && (ot[0] = (B[0] > 0 ? 1 : -1) * MIN_SCALE), ot[1] === 0 && (ot[1] = (B[1] > 0 ? 1 : -1) * MIN_SCALE);
    var mt = [ot[0] / B[0], ot[1] / B[1]];
    nt = multiply2(ot, X);
    var Et = getScaleDist(o, ot, e.fixedDirection, ht, e), wt = minus(Et, e.prevInverseDist || [0, 0]);
    if (e.prevDist = ot, e.prevInverseDist = Et, nt[0] === B[0] && nt[1] === B[1] && wt.every(function(yt) {
      return !yt;
    }) && !Z)
      return !1;
    var xt = convertTransformFormat(e, "scale(".concat(nt.join(", "), ")"), "scale(".concat(ot.join(", "), ")")), pt = fillParams(o, t, __assign$1({
      offsetWidth: U,
      offsetHeight: H,
      direction: $,
      scale: nt,
      dist: ot,
      delta: mt,
      isPinch: !!T
    }, fillTransformEvent(o, xt, wt, T, t)));
    return triggerEvent(o, "onScale", pt), pt;
  },
  dragControlEnd: function(o, t) {
    var e = t.datas;
    if (!e.isScale)
      return !1;
    e.isScale = !1;
    var r = fillEndParams(o, t, {});
    return triggerEvent(o, "onScaleEnd", r), r;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function(o, t) {
    var e = t.datas, r = this.dragControlStart(o, t);
    if (!r)
      return !1;
    var S = fillChildEvents(o, "resizable", t);
    function T(U, H) {
      var V = e.fixedDirection, X = e.fixedPosition, W = H.datas.startPositions || getAbsolutePosesByState(U.state), Y = getPosByDirection(W, V), q = calculate(createRotateMatrix(-o.rotation / 180 * Math.PI, 3), [Y[0] - X[0], Y[1] - X[1], 1], 3), K = q[0], Z = q[1];
      return H.datas.originalX = K, H.datas.originalY = Z, H;
    }
    e.moveableScale = o.scale;
    var D = triggerChildAbles(o, this, "dragControlStart", t, function(U, H) {
      return T(U, H);
    }), N = function(U) {
      r.setFixedDirection(U), D.forEach(function(H, V) {
        H.setFixedDirection(U), T(H.moveable, S[V]);
      });
    };
    e.setFixedDirection = N;
    var B = __assign$1(__assign$1({}, r), {
      targets: o.props.targets,
      events: D,
      setFixedDirection: N
    }), $ = triggerEvent(o, "onScaleGroupStart", B);
    return e.isScale = $ !== !1, e.isScale ? B : !1;
  },
  dragGroupControl: function(o, t) {
    var e = t.datas;
    if (e.isScale) {
      catchEvent(o, "onBeforeScale", function(H) {
        triggerEvent(o, "onBeforeScaleGroup", fillParams(o, t, __assign$1(__assign$1({}, H), {
          targets: o.props.targets
        }), !0));
      });
      var r = this.dragControl(o, t);
      if (r) {
        var S = e.moveableScale;
        o.scale = [r.scale[0] * S[0], r.scale[1] * S[1]];
        var T = o.props.keepRatio, D = r.dist, N = r.scale, B = e.fixedPosition, $ = triggerChildAbles(o, this, "dragControl", t, function(H, V) {
          var X = calculate(createRotateMatrix(o.rotation / 180 * Math.PI, 3), [V.datas.originalX * D[0], V.datas.originalY * D[1], 1], 3), W = X[0], Y = X[1];
          return __assign$1(__assign$1({}, V), {
            parentDist: null,
            parentScale: N,
            parentKeepRatio: T,
            dragClient: plus(B, [W, Y])
          });
        }), U = __assign$1({
          targets: o.props.targets,
          events: $
        }, r);
        return triggerEvent(o, "onScaleGroup", U), U;
      }
    }
  },
  dragGroupControlEnd: function(o, t) {
    var e = t.isDrag, r = t.datas;
    if (r.isScale) {
      this.dragControlEnd(o, t);
      var S = triggerChildAbles(o, this, "dragControlEnd", t), T = fillEndParams(o, t, {
        targets: o.props.targets,
        events: S
      });
      return triggerEvent(o, "onScaleGroupEnd", T), e;
    }
  },
  /**
   * @method Moveable.Scalable#request
   * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("scalable", { deltaWidth: 10, deltaHeight: 10 }, true);
   *
   * // requestStart
   * const requester = moveable.request("scalable");
   *
   * // request
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function() {
    var o = {}, t = 0, e = 0;
    return {
      isControl: !0,
      requestStart: function(r) {
        return {
          datas: o,
          parentDirection: r.direction || [1, 1]
        };
      },
      request: function(r) {
        return t += r.deltaWidth, e += r.deltaHeight, {
          datas: o,
          parentDist: [t, e],
          parentKeepRatio: r.keepRatio
        };
      },
      requestEnd: function() {
        return {
          datas: o,
          isDrag: !0
        };
      }
    };
  }
};
function getMiddleLinePos(o, t) {
  return o.map(function(e, r) {
    return dot(e, t[r], 1, 2);
  });
}
function getTriangleRad(o, t, e) {
  var r = getRad$1(o, t), S = getRad$1(o, e), T = S - r;
  return T >= 0 ? T : T + 2 * Math.PI;
}
function isValidPos(o, t) {
  var e = getTriangleRad(o[0], o[1], o[2]), r = getTriangleRad(t[0], t[1], t[2]), S = Math.PI;
  return !(e >= S && r <= S || e <= S && r >= S);
}
var Warpable = {
  name: "warpable",
  ableGroup: "size",
  props: {
    warpable: Boolean,
    renderDirections: Array,
    edge: Boolean
  },
  events: {
    onWarpStart: "warpStart",
    onWarp: "warp",
    onWarpEnd: "warpEnd"
  },
  viewClassName: getDirectionViewClassName("warpable"),
  render: function(o, t) {
    var e = o.props, r = e.resizable, S = e.scalable, T = e.warpable, D = e.zoom;
    if (r || S || !T)
      return [];
    var N = o.state, B = N.pos1, $ = N.pos2, U = N.pos3, H = N.pos4, V = getMiddleLinePos(B, $), X = getMiddleLinePos($, B), W = getMiddleLinePos(B, U), Y = getMiddleLinePos(U, B), q = getMiddleLinePos(U, H), K = getMiddleLinePos(H, U), Z = getMiddleLinePos($, H), J = getMiddleLinePos(H, $);
    return __spreadArray([t.createElement("div", {
      className: prefix("line"),
      key: "middeLine1",
      style: getLineStyle(V, q, D)
    }), t.createElement("div", {
      className: prefix("line"),
      key: "middeLine2",
      style: getLineStyle(X, K, D)
    }), t.createElement("div", {
      className: prefix("line"),
      key: "middeLine3",
      style: getLineStyle(W, Z, D)
    }), t.createElement("div", {
      className: prefix("line"),
      key: "middeLine4",
      style: getLineStyle(Y, J, D)
    })], renderAllDirections(o, "warpable", t), !0);
  },
  dragControlCondition: function(o, t) {
    if (t.isRequest)
      return !1;
    var e = t.inputEvent.target;
    return hasClass(e, prefix("direction")) && hasClass(e, prefix("warpable"));
  },
  dragControlStart: function(o, t) {
    var e = t.datas, r = t.inputEvent, S = o.props.target, T = r.target, D = getDirection(T, e);
    if (!D || !S)
      return !1;
    var N = o.state, B = N.transformOrigin, $ = N.is3d, U = N.targetTransform, H = N.targetMatrix, V = N.width, X = N.height, W = N.left, Y = N.top;
    e.datas = {}, e.targetTransform = U, e.warpTargetMatrix = $ ? H : convertDimension(H, 3, 4), e.targetInverseMatrix = ignoreDimension(invert(e.warpTargetMatrix, 4), 3, 4), e.direction = D, e.left = W, e.top = Y, e.poses = [[0, 0], [V, 0], [0, X], [V, X]].map(function(Z) {
      return minus(Z, B);
    }), e.nextPoses = e.poses.map(function(Z) {
      var J = Z[0], Q = Z[1];
      return calculate(e.warpTargetMatrix, [J, Q, 0, 1], 4);
    }), e.startValue = createIdentityMatrix(4), e.prevMatrix = createIdentityMatrix(4), e.absolutePoses = getAbsolutePosesByState(N), e.posIndexes = getPosIndexesByDirection(D), setDragStart(o, t), setDefaultTransformIndex(t, "matrix3d"), N.snapRenderInfo = {
      request: t.isRequest,
      direction: D
    };
    var q = fillParams(o, t, __assign$1({
      set: function(Z) {
        e.startValue = Z;
      }
    }, fillTransformStartEvent(t))), K = triggerEvent(o, "onWarpStart", q);
    return K !== !1 && (e.isWarp = !0), e.isWarp;
  },
  dragControl: function(o, t) {
    var e = t.datas, r = t.isRequest, S = t.distX, T = t.distY, D = e.targetInverseMatrix, N = e.prevMatrix, B = e.isWarp, $ = e.startValue, U = e.poses, H = e.posIndexes, V = e.absolutePoses;
    if (!B)
      return !1;
    if (resolveTransformEvent(t, "matrix3d"), hasGuidelines(o, "warpable")) {
      var X = H.map(function(it) {
        return V[it];
      });
      X.length > 1 && X.push([(X[0][0] + X[1][0]) / 2, (X[0][1] + X[1][1]) / 2]);
      var W = checkMoveableSnapBounds(o, r, {
        horizontal: X.map(function(it) {
          return it[1] + T;
        }),
        vertical: X.map(function(it) {
          return it[0] + S;
        })
      }), Y = W.horizontal, q = W.vertical;
      T -= Y.offset, S -= q.offset;
    }
    var K = getDragDist({
      datas: e,
      distX: S,
      distY: T
    }, !0), Z = e.nextPoses.slice();
    if (H.forEach(function(it) {
      Z[it] = plus(Z[it], K);
    }), !NEARBY_POS.every(function(it) {
      return isValidPos(it.map(function(ot) {
        return U[ot];
      }), it.map(function(ot) {
        return Z[ot];
      }));
    }))
      return !1;
    var J = createWarpMatrix(U[0], U[2], U[1], U[3], Z[0], Z[2], Z[1], Z[3]);
    if (!J.length)
      return !1;
    var Q = multiply(D, J, 4), rt = getTransfromMatrix(e, Q, !0), et = multiply(invert(N, 4), rt, 4);
    e.prevMatrix = rt;
    var nt = multiply($, rt, 4), st = convertTransformFormat(e, "matrix3d(".concat(nt.join(", "), ")"), "matrix3d(".concat(rt.join(", "), ")"));
    return fillOriginalTransform(t, st), triggerEvent(o, "onWarp", fillParams(o, t, __assign$1({
      delta: et,
      matrix: nt,
      dist: rt,
      multiply,
      transform: st
    }, fillCSSObject({
      transform: st
    }, t)))), !0;
  },
  dragControlEnd: function(o, t) {
    var e = t.datas, r = t.isDrag;
    return e.isWarp ? (e.isWarp = !1, triggerEvent(o, "onWarpEnd", fillEndParams(o, t, {})), r) : !1;
  }
}, AREA_PIECES = /* @__PURE__ */ prefix("area-pieces"), AREA_PIECE = /* @__PURE__ */ prefix("area-piece"), AVOID = /* @__PURE__ */ prefix("avoid"), VIEW_DRAGGING = prefix("view-dragging");
function restoreStyle(o) {
  var t = o.areaElement;
  if (t) {
    var e = o.state, r = e.width, S = e.height;
    removeClass(t, AVOID), t.style.cssText += "left: 0px; top: 0px; width: ".concat(r, "px; height: ").concat(S, "px");
  }
}
function renderPieces(o) {
  return o.createElement("div", {
    key: "area_pieces",
    className: AREA_PIECES
  }, o.createElement("div", {
    className: AREA_PIECE
  }), o.createElement("div", {
    className: AREA_PIECE
  }), o.createElement("div", {
    className: AREA_PIECE
  }), o.createElement("div", {
    className: AREA_PIECE
  }));
}
var DragArea = {
  name: "dragArea",
  props: {
    dragArea: Boolean,
    passDragArea: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  render: function(o, t) {
    var e = o.props, r = e.target, S = e.dragArea, T = e.groupable, D = e.passDragArea, N = o.getState(), B = N.width, $ = N.height, U = N.renderPoses, H = D ? prefix("area", "pass") : prefix("area");
    if (T)
      return [t.createElement("div", {
        key: "area",
        ref: ref(o, "areaElement"),
        className: H
      }), renderPieces(t)];
    if (!r || !S)
      return [];
    var V = createWarpMatrix([0, 0], [B, 0], [0, $], [B, $], U[0], U[1], U[2], U[3]), X = V.length ? makeMatrixCSS(V, !0) : "none";
    return [t.createElement("div", {
      key: "area",
      ref: ref(o, "areaElement"),
      className: H,
      style: {
        top: "0px",
        left: "0px",
        width: "".concat(B, "px"),
        height: "".concat($, "px"),
        transformOrigin: "0 0",
        transform: X
      }
    }), renderPieces(t)];
  },
  dragStart: function(o, t) {
    var e = t.datas, r = t.clientX, S = t.clientY, T = t.inputEvent;
    if (!T)
      return !1;
    e.isDragArea = !1;
    var D = o.areaElement, N = o.state, B = N.moveableClientRect, $ = N.renderPoses, U = N.rootMatrix, H = N.is3d, V = B.left, X = B.top, W = getRect($), Y = W.left, q = W.top, K = W.width, Z = W.height, J = H ? 4 : 3, Q = calculateInversePosition(U, [r - V, S - X], J), rt = Q[0], et = Q[1];
    rt -= Y, et -= q;
    var nt = [{
      left: Y,
      top: q,
      width: K,
      height: et - 10
    }, {
      left: Y,
      top: q,
      width: rt - 10,
      height: Z
    }, {
      left: Y,
      top: q + et + 10,
      width: K,
      height: Z - et - 10
    }, {
      left: Y + rt + 10,
      top: q,
      width: K - rt - 10,
      height: Z
    }], st = [].slice.call(D.nextElementSibling.children);
    nt.forEach(function(it, ot) {
      st[ot].style.cssText = "left: ".concat(it.left, "px;top: ").concat(it.top, "px; width: ").concat(it.width, "px; height: ").concat(it.height, "px;");
    }), addClass(D, AVOID), N.disableNativeEvent = !0;
  },
  drag: function(o, t) {
    var e = t.datas, r = t.inputEvent;
    if (this.enableNativeEvent(o), !r)
      return !1;
    e.isDragArea || (e.isDragArea = !0, restoreStyle(o));
  },
  dragEnd: function(o, t) {
    this.enableNativeEvent(o);
    var e = t.inputEvent, r = t.datas;
    if (!e)
      return !1;
    r.isDragArea || restoreStyle(o);
  },
  dragGroupStart: function(o, t) {
    return this.dragStart(o, t);
  },
  dragGroup: function(o, t) {
    return this.drag(o, t);
  },
  dragGroupEnd: function(o, t) {
    return this.dragEnd(o, t);
  },
  unset: function(o) {
    restoreStyle(o), o.state.disableNativeEvent = !1;
  },
  enableNativeEvent: function(o) {
    var t = o.state;
    t.disableNativeEvent && requestAnimationFrame$1(function() {
      t.disableNativeEvent = !1;
    });
  }
}, Origin = makeAble("origin", {
  render: function(o, t) {
    var e = o.props.zoom, r = o.getState(), S = r.beforeOrigin, T = r.rotation;
    return [t.createElement("div", {
      className: prefix("control", "origin"),
      style: getControlTransform(T, e, S),
      key: "beforeOrigin"
    })];
  }
});
function getDefaultScrollPosition(o) {
  var t = o.scrollContainer;
  return [t.scrollLeft, t.scrollTop];
}
var Scrollable = {
  name: "scrollable",
  canPinch: !0,
  props: {
    scrollable: Boolean,
    scrollContainer: Object,
    scrollThreshold: Number,
    scrollThrottleTime: Number,
    getScrollPosition: Function
  },
  events: {
    onScroll: "scroll",
    onScrollGroup: "scrollGroup"
  },
  dragRelation: "strong",
  dragStart: function(o, t) {
    var e = o.props, r = e.scrollContainer, S = r === void 0 ? o.getContainer() : r, T = new DragScroll$1(), D = getRefTarget(S, !0);
    t.datas.dragScroll = T;
    var N = t.isControl ? "controlGesto" : "targetGesto", B = t.targets;
    T.on("scroll", function($) {
      var U = $.container, H = $.direction, V = fillParams(o, t, {
        scrollContainer: U,
        direction: H
      }), X = B ? "onScrollGroup" : "onScroll";
      B && (V.targets = B), triggerEvent(o, X, V);
    }).on("move", function($) {
      var U = $.offsetX, H = $.offsetY, V = $.inputEvent;
      o[N].scrollBy(U, H, V.inputEvent, !1);
    }), T.dragStart(t, {
      container: D
    });
  },
  checkScroll: function(o, t) {
    var e = t.datas.dragScroll;
    if (e) {
      var r = o.props, S = r.scrollContainer, T = S === void 0 ? o.getContainer() : S, D = r.scrollThreshold, N = D === void 0 ? 0 : D, B = r.scrollThrottleTime, $ = B === void 0 ? 0 : B, U = r.getScrollPosition, H = U === void 0 ? getDefaultScrollPosition : U;
      return e.drag(t, {
        container: T,
        threshold: N,
        throttleTime: $,
        getScrollPosition: function(V) {
          return H({
            scrollContainer: V.container,
            direction: V.direction
          });
        }
      }), !0;
    }
  },
  drag: function(o, t) {
    return this.checkScroll(o, t);
  },
  dragEnd: function(o, t) {
    t.datas.dragScroll.dragEnd(), t.datas.dragScroll = null;
  },
  dragControlStart: function(o, t) {
    return this.dragStart(o, __assign$1(__assign$1({}, t), {
      isControl: !0
    }));
  },
  dragControl: function(o, t) {
    return this.drag(o, t);
  },
  dragControlEnd: function(o, t) {
    return this.dragEnd(o, t);
  },
  dragGroupStart: function(o, t) {
    return this.dragStart(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  },
  dragGroup: function(o, t) {
    return this.drag(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  },
  dragGroupEnd: function(o, t) {
    return this.dragEnd(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  },
  dragGroupControlStart: function(o, t) {
    return this.dragStart(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets,
      isControl: !0
    }));
  },
  dragGroupContro: function(o, t) {
    return this.drag(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  },
  dragGroupControEnd: function(o, t) {
    return this.dragEnd(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  }
}, Default = {
  name: "",
  props: {
    target: Object,
    dragTarget: Object,
    container: Object,
    portalContainer: Object,
    rootContainer: Object,
    useResizeObserver: Boolean,
    zoom: Number,
    transformOrigin: Array,
    edge: Object,
    ables: Array,
    className: String,
    pinchThreshold: Number,
    pinchOutside: Boolean,
    triggerAblesSimultaneously: Boolean,
    checkInput: Boolean,
    cspNonce: String,
    translateZ: Number,
    hideDefaultLines: Boolean,
    props: Object,
    flushSync: Function,
    stopPropagation: Boolean,
    preventClickEventOnDrag: Boolean,
    preventClickDefault: Boolean,
    viewContainer: Object,
    persistData: Object,
    useAccuratePosition: Boolean,
    firstRenderState: Object
  },
  events: {
    onChangeTargets: "changeTargets"
  }
}, Padding = makeAble("padding", {
  render: function(o, t) {
    var e = o.props;
    if (e.dragArea)
      return [];
    var r = e.padding || {}, S = r.left, T = S === void 0 ? 0 : S, D = r.top, N = D === void 0 ? 0 : D, B = r.right, $ = B === void 0 ? 0 : B, U = r.bottom, H = U === void 0 ? 0 : U, V = o.getState(), X = V.renderPoses, W = V.pos1, Y = V.pos2, q = V.pos3, K = V.pos4, Z = [W, Y, q, K], J = [];
    return T > 0 && J.push([0, 2]), N > 0 && J.push([0, 1]), $ > 0 && J.push([1, 3]), H > 0 && J.push([2, 3]), J.map(function(Q, rt) {
      var et = Q[0], nt = Q[1], st = Z[et], it = Z[nt], ot = X[et], ht = X[nt], ct = createWarpMatrix([0, 0], [100, 0], [0, 100], [100, 100], st, it, ot, ht);
      if (ct.length)
        return t.createElement("div", {
          key: "padding".concat(rt),
          className: prefix("padding"),
          style: {
            transform: makeMatrixCSS(ct, !0)
          }
        });
    });
  }
}), RADIUS_DIRECTIONS = ["nw", "ne", "se", "sw"];
function calculateRatio(o, t) {
  var e = o[0] + o[1], r = e > t ? t / e : 1;
  return o[0] *= r, o[1] = t - o[1] * r, o;
}
var HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6], VERTICAL_RADIUS_ORDER = [0, 3, 4, 7], HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1], VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];
function getRadiusStyles(o, t, e, r, S, T, D, N) {
  S === void 0 && (S = 0), T === void 0 && (T = 0), D === void 0 && (D = e), N === void 0 && (N = r);
  var B = [], $ = !1, U = o.filter(function(V) {
    return !V.virtual;
  }), H = U.map(function(V) {
    var X = V.horizontal, W = V.vertical, Y = V.pos;
    if (W && !$ && ($ = !0, B.push("/")), $) {
      var q = Math.max(0, W === 1 ? Y[1] - T : N - Y[1]);
      return B.push(convertCSSSize(q, r, t)), q;
    } else {
      var q = Math.max(0, X === 1 ? Y[0] - S : D - Y[0]);
      return B.push(convertCSSSize(q, e, t)), q;
    }
  });
  return {
    radiusPoses: U,
    styles: B,
    raws: H
  };
}
function getRadiusRange(o) {
  for (var t = [0, 0], e = [0, 0], r = o.length, S = 0; S < r; ++S) {
    var T = o[S];
    T.sub && (T.horizontal && (t[1] === 0 && (t[0] = S), t[1] = S - t[0] + 1, e[0] = S + 1), T.vertical && (e[1] === 0 && (e[0] = S), e[1] = S - e[0] + 1));
  }
  return {
    horizontalRange: t,
    verticalRange: e
  };
}
function getRadiusValues(o, t, e, r, S, T, D) {
  var N, B, $, U;
  T === void 0 && (T = [0, 0]), D === void 0 && (D = !1);
  var H = o.indexOf("/"), V = (H > -1 ? o.slice(0, H) : o).length, X = o.slice(0, V), W = o.slice(V + 1), Y = X.length, q = W.length, K = q > 0, Z = X[0], J = Z === void 0 ? "0px" : Z, Q = X[1], rt = Q === void 0 ? J : Q, et = X[2], nt = et === void 0 ? J : et, st = X[3], it = st === void 0 ? rt : st, ot = W[0], ht = ot === void 0 ? J : ot, ct = W[1], vt = ct === void 0 ? K ? ht : rt : ct, _t = W[2], gt = _t === void 0 ? K ? ht : nt : _t, mt = W[3], Et = mt === void 0 ? K ? vt : it : mt, wt = [J, rt, nt, it].map(function(It) {
    return convertUnitSize(It, t);
  }), xt = [ht, vt, gt, Et].map(function(It) {
    return convertUnitSize(It, e);
  }), pt = wt.slice(), yt = xt.slice();
  N = calculateRatio([pt[0], pt[1]], t), pt[0] = N[0], pt[1] = N[1], B = calculateRatio([pt[3], pt[2]], t), pt[3] = B[0], pt[2] = B[1], $ = calculateRatio([yt[0], yt[3]], e), yt[0] = $[0], yt[3] = $[1], U = calculateRatio([yt[1], yt[2]], e), yt[1] = U[0], yt[2] = U[1];
  var Dt = D ? pt : pt.slice(0, Math.max(T[0], Y)), At = D ? yt : yt.slice(0, Math.max(T[1], q));
  return __spreadArray(__spreadArray([], Dt.map(function(It, Ot) {
    var ft = RADIUS_DIRECTIONS[Ot];
    return {
      virtual: Ot >= Y,
      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[Ot],
      vertical: 0,
      pos: [r + It, S + (VERTICAL_RADIUS_DIRECTIONS[Ot] === -1 ? e : 0)],
      sub: !0,
      raw: wt[Ot],
      direction: ft
    };
  }), !0), At.map(function(It, Ot) {
    var ft = RADIUS_DIRECTIONS[Ot];
    return {
      virtual: Ot >= q,
      horizontal: 0,
      vertical: VERTICAL_RADIUS_DIRECTIONS[Ot],
      pos: [r + (HORIZONTAL_RADIUS_DIRECTIONS[Ot] === -1 ? t : 0), S + It],
      sub: !0,
      raw: xt[Ot],
      direction: ft
    };
  }), !0);
}
function removeRadiusPos(o, t, e, r, S) {
  S === void 0 && (S = t.length);
  var T = getRadiusRange(o.slice(r)), D = T.horizontalRange, N = T.verticalRange, B = e - r, $ = 0;
  if (B === 0)
    $ = S;
  else if (B > 0 && B < D[1])
    $ = D[1] - B;
  else if (B >= N[0])
    $ = N[0] + N[1] - B;
  else
    return;
  o.splice(e, $), t.splice(e, $);
}
function addRadiusPos(o, t, e, r, S, T, D, N, B, $, U) {
  $ === void 0 && ($ = 0), U === void 0 && (U = 0);
  var H = getRadiusRange(o.slice(e)), V = H.horizontalRange, X = H.verticalRange;
  if (r > -1)
    for (var W = HORIZONTAL_RADIUS_DIRECTIONS[r] === 1 ? T - $ : N - T, Y = V[1]; Y <= r; ++Y) {
      var q = VERTICAL_RADIUS_DIRECTIONS[Y] === 1 ? U : B, K = 0;
      if (r === Y ? K = T : Y === 0 ? K = $ + W : HORIZONTAL_RADIUS_DIRECTIONS[Y] === -1 && (K = N - (t[e][0] - $)), o.splice(e + Y, 0, {
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[Y],
        vertical: 0,
        pos: [K, q]
      }), t.splice(e + Y, 0, [K, q]), Y === 0)
        break;
    }
  else if (S > -1) {
    var Z = VERTICAL_RADIUS_DIRECTIONS[S] === 1 ? D - U : B - D;
    if (V[1] === 0 && X[1] === 0) {
      var J = [$ + Z, U];
      o.push({
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],
        vertical: 0,
        pos: J
      }), t.push(J);
    }
    for (var Q = X[0], Y = X[1]; Y <= S; ++Y) {
      var K = HORIZONTAL_RADIUS_DIRECTIONS[Y] === 1 ? $ : N, q = 0;
      if (S === Y ? q = D : Y === 0 ? q = U + Z : VERTICAL_RADIUS_DIRECTIONS[Y] === 1 ? q = t[e + Q][1] : VERTICAL_RADIUS_DIRECTIONS[Y] === -1 && (q = B - (t[e + Q][1] - U)), o.push({
        horizontal: 0,
        vertical: VERTICAL_RADIUS_DIRECTIONS[Y],
        pos: [K, q]
      }), t.push([K, q]), Y === 0)
        break;
    }
  }
}
function splitRadiusPoses(o, t) {
  t === void 0 && (t = o.map(function(S) {
    return S.raw;
  }));
  var e = o.map(function(S, T) {
    return S.horizontal ? t[T] : null;
  }).filter(function(S) {
    return S != null;
  }), r = o.map(function(S, T) {
    return S.vertical ? t[T] : null;
  }).filter(function(S) {
    return S != null;
  });
  return {
    horizontals: e,
    verticals: r
  };
}
var CLIP_DIRECTIONS = [[0, -1, "n"], [1, 0, "e"]], CLIP_RECT_DIRECTIONS = [[-1, -1, "nw"], [0, -1, "n"], [1, -1, "ne"], [1, 0, "e"], [1, 1, "se"], [0, 1, "s"], [-1, 1, "sw"], [-1, 0, "w"]];
function getClipStyles(o, t, e) {
  var r = o.props.clipRelative, S = o.state, T = S.width, D = S.height, N = t, B = N.type, $ = N.poses, U = B === "rect", H = B === "circle";
  if (B === "polygon")
    return e.map(function(et) {
      return "".concat(convertCSSSize(et[0], T, r), " ").concat(convertCSSSize(et[1], D, r));
    });
  if (U || B === "inset") {
    var V = e[1][1], X = e[3][0], W = e[7][0], Y = e[5][1];
    if (U)
      return [V, X, Y, W].map(function(et) {
        return "".concat(et, "px");
      });
    var q = [V, T - X, D - Y, W].map(function(et, nt) {
      return convertCSSSize(et, nt % 2 ? T : D, r);
    });
    if (e.length > 8) {
      var K = minus(e[4], e[0]), Z = K[0], J = K[1];
      q.push.apply(q, __spreadArray(["round"], getRadiusStyles($.slice(8).map(function(et, nt) {
        return __assign$1(__assign$1({}, et), {
          pos: e[nt]
        });
      }), r, Z, J, W, V, X, Y).styles, !1));
    }
    return q;
  } else if (H || B === "ellipse") {
    var Q = e[0], rt = convertCSSSize(Math.abs(e[1][1] - Q[1]), H ? Math.sqrt((T * T + D * D) / 2) : D, r), q = H ? [rt] : [convertCSSSize(Math.abs(e[2][0] - Q[0]), T, r), rt];
    return q.push("at", convertCSSSize(Q[0], T, r), convertCSSSize(Q[1], D, r)), q;
  }
}
function getRectPoses(o, t, e, r) {
  var S = [r, (r + t) / 2, t], T = [o, (o + e) / 2, e];
  return CLIP_RECT_DIRECTIONS.map(function(D) {
    var N = D[0], B = D[1], $ = D[2], U = S[N + 1], H = T[B + 1];
    return {
      vertical: Math.abs(B),
      horizontal: Math.abs(N),
      direction: $,
      pos: [U, H]
    };
  });
}
function getControlSize(o) {
  var t = [1 / 0, -1 / 0], e = [1 / 0, -1 / 0];
  return o.forEach(function(r) {
    var S = r.pos;
    t[0] = Math.min(t[0], S[0]), t[1] = Math.max(t[1], S[0]), e[0] = Math.min(e[0], S[1]), e[1] = Math.max(e[1], S[1]);
  }), [Math.abs(t[1] - t[0]), Math.abs(e[1] - e[0])];
}
function getClipPath(o, t, e, r, S) {
  var T, D, N, B, $, U, H;
  if (o) {
    var V = S;
    if (!V) {
      var X = getComputedStyle(o), W = X.clipPath;
      V = W !== "none" ? W : X.clip;
    }
    if (!((!V || V === "none" || V === "auto") && (V = r, !V))) {
      var Y = splitBracket(V), q = Y.prefix, K = q === void 0 ? V : q, Z = Y.value, J = Z === void 0 ? "" : Z, Q = K === "circle", rt = " ";
      if (K === "polygon") {
        var et = splitComma(J || "0% 0%, 100% 0%, 100% 100%, 0% 100%");
        rt = ",";
        var nt = et.map(function(Wt) {
          var Jt = Wt.split(" "), qt = Jt[0], xe = Jt[1];
          return {
            vertical: 1,
            horizontal: 1,
            pos: [convertUnitSize(qt, t), convertUnitSize(xe, e)]
          };
        }), st = getMinMaxs(nt.map(function(Wt) {
          return Wt.pos;
        }));
        return {
          type: K,
          clipText: V,
          poses: nt,
          splitter: rt,
          left: st.minX,
          right: st.maxX,
          top: st.minY,
          bottom: st.maxY
        };
      } else if (Q || K === "ellipse") {
        var it = "", ot = "", ht = 0, ct = 0, et = splitSpace(J);
        if (Q) {
          var vt = "";
          T = et[0], vt = T === void 0 ? "50%" : T, D = et[2], it = D === void 0 ? "50%" : D, N = et[3], ot = N === void 0 ? "50%" : N, ht = convertUnitSize(vt, Math.sqrt((t * t + e * e) / 2)), ct = ht;
        } else {
          var _t = "", gt = "";
          B = et[0], _t = B === void 0 ? "50%" : B, $ = et[1], gt = $ === void 0 ? "50%" : $, U = et[3], it = U === void 0 ? "50%" : U, H = et[4], ot = H === void 0 ? "50%" : H, ht = convertUnitSize(_t, t), ct = convertUnitSize(gt, e);
        }
        var mt = [convertUnitSize(it, t), convertUnitSize(ot, e)], nt = __spreadArray([{
          vertical: 1,
          horizontal: 1,
          pos: mt,
          direction: "nesw"
        }], CLIP_DIRECTIONS.slice(0, Q ? 1 : 2).map(function(qt) {
          return {
            vertical: Math.abs(qt[1]),
            horizontal: qt[0],
            direction: qt[2],
            sub: !0,
            pos: [mt[0] + qt[0] * ht, mt[1] + qt[1] * ct]
          };
        }), !0);
        return {
          type: K,
          clipText: V,
          radiusX: ht,
          radiusY: ct,
          left: mt[0] - ht,
          top: mt[1] - ct,
          right: mt[0] + ht,
          bottom: mt[1] + ct,
          poses: nt,
          splitter: rt
        };
      } else if (K === "inset") {
        var et = splitSpace(J || "0 0 0 0"), Et = et.indexOf("round"), wt = (Et > -1 ? et.slice(0, Et) : et).length, xt = et.slice(wt + 1), pt = et.slice(0, wt), yt = pt[0], Dt = pt[1], At = Dt === void 0 ? yt : Dt, It = pt[2], Ot = It === void 0 ? yt : It, ft = pt[3], Ft = ft === void 0 ? At : ft, Mt = [yt, Ot].map(function(qt) {
          return convertUnitSize(qt, e);
        }), zt = Mt[0], Nt = Mt[1], St = [Ft, At].map(function(qt) {
          return convertUnitSize(qt, t);
        }), Ht = St[0], Lt = St[1], Tt = t - Lt, kt = e - Nt, Ut = getRadiusValues(xt, Tt - Ht, kt - zt, Ht, zt), nt = __spreadArray(__spreadArray([], getRectPoses(zt, Tt, kt, Ht), !0), Ut, !0);
        return {
          type: "inset",
          clipText: V,
          poses: nt,
          top: zt,
          left: Ht,
          right: Tt,
          bottom: kt,
          radius: xt,
          splitter: rt
        };
      } else if (K === "rect") {
        var et = splitComma(J || "0px, ".concat(t, "px, ").concat(e, "px, 0px"));
        rt = ",";
        var Ct = et.map(function(me) {
          var pe = splitUnit(me).value;
          return pe;
        }), zt = Ct[0], Lt = Ct[1], Nt = Ct[2], Ht = Ct[3], nt = getRectPoses(zt, Lt, Nt, Ht);
        return {
          type: "rect",
          clipText: V,
          poses: nt,
          top: zt,
          right: Lt,
          bottom: Nt,
          left: Ht,
          values: et,
          splitter: rt
        };
      }
    }
  }
}
function moveControlPos(o, t, e, r, S) {
  var T = o[t], D = T.direction, N = T.sub, B = o.map(function() {
    return [0, 0];
  }), $ = D ? D.split("") : [];
  if (r && t < 8) {
    var U = $.filter(function(vt) {
      return vt === "w" || vt === "e";
    }), H = $.filter(function(vt) {
      return vt === "n" || vt === "s";
    }), V = U[0], X = H[0];
    B[t] = e;
    var W = getControlSize(o), Y = W[0], q = W[1], K = Y && q ? Y / q : 0;
    if (K && S) {
      var Z = (t + 4) % 8, J = o[Z].pos, Q = [0, 0];
      D.indexOf("w") > -1 ? Q[0] = -1 : D.indexOf("e") > -1 && (Q[0] = 1), D.indexOf("n") > -1 ? Q[1] = -1 : D.indexOf("s") > -1 && (Q[1] = 1);
      var rt = getSizeDistByDist([Y, q], e, K, Q, !0), et = Y + rt[0], nt = q + rt[1], st = J[1], it = J[1], ot = J[0], ht = J[0];
      Q[0] === -1 ? ot = ht - et : Q[0] === 1 ? ht = ot + et : (ot = ot - et / 2, ht = ht + et / 2), Q[1] === -1 ? st = it - nt : (Q[1] === 1 || (st = it - nt / 2), it = st + nt);
      var ct = getRectPoses(st, ht, it, ot);
      o.forEach(function(vt, _t) {
        B[_t][0] = ct[_t].pos[0] - vt.pos[0], B[_t][1] = ct[_t].pos[1] - vt.pos[1];
      });
    } else
      o.forEach(function(vt, _t) {
        var gt = vt.direction;
        gt && (gt.indexOf(V) > -1 && (B[_t][0] = e[0]), gt.indexOf(X) > -1 && (B[_t][1] = e[1]));
      }), V && (B[1][0] = e[0] / 2, B[5][0] = e[0] / 2), X && (B[3][1] = e[1] / 2, B[7][1] = e[1] / 2);
  } else
    D && !N ? $.forEach(function(vt) {
      var _t = vt === "n" || vt === "s";
      o.forEach(function(gt, mt) {
        var Et = gt.direction, wt = gt.horizontal, xt = gt.vertical;
        !Et || Et.indexOf(vt) === -1 || (B[mt] = [_t || !wt ? 0 : e[0], !_t || !xt ? 0 : e[1]]);
      });
    }) : B[t] = e;
  return B;
}
function addClipPath(o, t) {
  var e = calculatePointerDist(o, t), r = e[0], S = e[1], T = t.datas, D = T.clipPath, N = T.clipIndex, B = D, $ = B.type, U = B.poses, H = B.splitter, V = U.map(function(Z) {
    return Z.pos;
  });
  if ($ === "polygon")
    V.splice(N, 0, [r, S]);
  else if ($ === "inset") {
    var X = HORIZONTAL_RADIUS_ORDER.indexOf(N), W = VERTICAL_RADIUS_ORDER.indexOf(N), Y = U.length;
    if (addRadiusPos(U, V, 8, X, W, r, S, V[4][0], V[4][1], V[0][0], V[0][1]), Y === U.length)
      return;
  } else
    return;
  var q = getClipStyles(o, D, V), K = "".concat($, "(").concat(q.join(H), ")");
  triggerEvent(o, "onClip", fillParams(o, t, __assign$1({
    clipEventType: "added",
    clipType: $,
    poses: V,
    clipStyles: q,
    clipStyle: K,
    distX: 0,
    distY: 0
  }, fillCSSObject({
    clipPath: K
  }, t))));
}
function removeClipPath(o, t) {
  var e = t.datas, r = e.clipPath, S = e.clipIndex, T = r, D = T.type, N = T.poses, B = T.splitter, $ = N.map(function(X) {
    return X.pos;
  }), U = $.length;
  if (D === "polygon")
    N.splice(S, 1), $.splice(S, 1);
  else if (D === "inset") {
    if (S < 8 || (removeRadiusPos(N, $, S, 8, U), U === N.length))
      return;
  } else
    return;
  var H = getClipStyles(o, r, $), V = "".concat(D, "(").concat(H.join(B), ")");
  triggerEvent(o, "onClip", fillParams(o, t, __assign$1({
    clipEventType: "removed",
    clipType: D,
    poses: $,
    clipStyles: H,
    clipStyle: V,
    distX: 0,
    distY: 0
  }, fillCSSObject({
    clipPath: V
  }, t))));
}
var Clippable = {
  name: "clippable",
  props: {
    clippable: Boolean,
    defaultClipPath: String,
    customClipPath: String,
    keepRatio: Boolean,
    clipRelative: Boolean,
    clipArea: Boolean,
    dragWithClip: Boolean,
    clipTargetBounds: Boolean,
    clipVerticalGuidelines: Array,
    clipHorizontalGuidelines: Array,
    clipSnapThreshold: Boolean
  },
  events: {
    onClipStart: "clipStart",
    onClip: "clip",
    onClipEnd: "clipEnd"
  },
  css: [`.control.clip-control {
    background: #6d6;
    cursor: pointer;
}
.control.clip-control.clip-radius {
    background: #d66;
}
.line.clip-line {
    background: #6e6;
    cursor: move;
    z-index: 1;
}
.clip-area {
    position: absolute;
    top: 0;
    left: 0;
}
.clip-ellipse {
    position: absolute;
    cursor: move;
    border: 1px solid #6d6;
    border: var(--zoompx) solid #6d6;
    border-radius: 50%;
    transform-origin: 0px 0px;
}`, `:host {
    --bounds-color: #d66;
}`, `.guideline {
    pointer-events: none;
    z-index: 2;
}`, `.line.guideline.bounds {
    background: #d66;
    background: var(--bounds-color);
}`],
  render: function(o, t) {
    var e = o.props, r = e.customClipPath, S = e.defaultClipPath, T = e.clipArea, D = e.zoom, N = e.groupable, B = o.getState(), $ = B.target, U = B.width, H = B.height, V = B.allMatrix, X = B.is3d, W = B.left, Y = B.top, q = B.pos1, K = B.pos2, Z = B.pos3, J = B.pos4, Q = B.clipPathState, rt = B.snapBoundInfos, et = B.rotation;
    if (!$ || N)
      return [];
    var nt = getClipPath($, U, H, S || "inset", Q || r);
    if (!nt)
      return [];
    var st = X ? 4 : 3, it = nt.type, ot = nt.poses, ht = ot.map(function(kt) {
      var Ut = calculatePosition(V, kt.pos, st);
      return [Ut[0] - W, Ut[1] - Y];
    }), ct = [], vt = [], _t = it === "rect", gt = it === "inset", mt = it === "polygon";
    if (_t || gt || mt) {
      var Et = gt ? ht.slice(0, 8) : ht;
      vt = Et.map(function(kt, Ut) {
        var Ct = Ut === 0 ? Et[Et.length - 1] : Et[Ut - 1], Wt = getRad$1(Ct, kt), Jt = getDiagonalSize(Ct, kt);
        return t.createElement("div", {
          key: "clipLine".concat(Ut),
          className: prefix("line", "clip-line", "snap-control"),
          "data-clip-index": Ut,
          style: {
            width: "".concat(Jt, "px"),
            transform: "translate(".concat(Ct[0], "px, ").concat(Ct[1], "px) rotate(").concat(Wt, "rad) scaleY(").concat(D, ")")
          }
        });
      });
    }
    if (ct = ht.map(function(kt, Ut) {
      return t.createElement("div", {
        key: "clipControl".concat(Ut),
        className: prefix("control", "clip-control", "snap-control"),
        "data-clip-index": Ut,
        style: {
          transform: "translate(".concat(kt[0], "px, ").concat(kt[1], "px) rotate(").concat(et, "rad) scale(").concat(D, ")")
        }
      });
    }), gt && ct.push.apply(ct, ht.slice(8).map(function(kt, Ut) {
      return t.createElement("div", {
        key: "clipRadiusControl".concat(Ut),
        className: prefix("control", "clip-control", "clip-radius", "snap-control"),
        "data-clip-index": 8 + Ut,
        style: {
          transform: "translate(".concat(kt[0], "px, ").concat(kt[1], "px) rotate(").concat(et, "rad) scale(").concat(D, ")")
        }
      });
    })), it === "circle" || it === "ellipse") {
      var wt = nt.left, xt = nt.top, pt = nt.radiusX, yt = nt.radiusY, Dt = minus(calculatePosition(V, [wt, xt], st), calculatePosition(V, [0, 0], st)), At = Dt[0], It = Dt[1], Ot = "none";
      if (!T) {
        for (var ft = Math.max(10, pt / 5, yt / 5), Ft = [], Mt = 0; Mt <= ft; ++Mt) {
          var zt = Math.PI * 2 / ft * Mt;
          Ft.push([pt + (pt - D) * Math.cos(zt), yt + (yt - D) * Math.sin(zt)]);
        }
        Ft.push([pt, -2]), Ft.push([-2, -2]), Ft.push([-2, yt * 2 + 2]), Ft.push([pt * 2 + 2, yt * 2 + 2]), Ft.push([pt * 2 + 2, -2]), Ft.push([pt, -2]), Ot = "polygon(".concat(Ft.map(function(kt) {
          return "".concat(kt[0], "px ").concat(kt[1], "px");
        }).join(", "), ")");
      }
      ct.push(t.createElement("div", {
        key: "clipEllipse",
        className: prefix("clip-ellipse", "snap-control"),
        style: {
          width: "".concat(pt * 2, "px"),
          height: "".concat(yt * 2, "px"),
          clipPath: Ot,
          transform: "translate(".concat(-W + At, "px, ").concat(-Y + It, "px) ").concat(makeMatrixCSS(V))
        }
      }));
    }
    if (T) {
      var Nt = getRect(__spreadArray([q, K, Z, J], ht, !0)), St = Nt.width, Ht = Nt.height, Lt = Nt.left, Tt = Nt.top;
      if (mt || _t || gt) {
        var Ft = gt ? ht.slice(0, 8) : ht;
        ct.push(t.createElement("div", {
          key: "clipArea",
          className: prefix("clip-area", "snap-control"),
          style: {
            width: "".concat(St, "px"),
            height: "".concat(Ht, "px"),
            transform: "translate(".concat(Lt, "px, ").concat(Tt, "px)"),
            clipPath: "polygon(".concat(Ft.map(function(Ut) {
              return "".concat(Ut[0] - Lt, "px ").concat(Ut[1] - Tt, "px");
            }).join(", "), ")")
          }
        }));
      }
    }
    return rt && ["vertical", "horizontal"].forEach(function(kt) {
      var Ut = rt[kt], Ct = kt === "horizontal";
      Ut.isSnap && vt.push.apply(vt, Ut.snap.posInfos.map(function(Wt, Jt) {
        var qt = Wt.pos, xe = minus(calculatePosition(V, Ct ? [0, qt] : [qt, 0], st), [W, Y]), Me = minus(calculatePosition(V, Ct ? [U, qt] : [qt, H], st), [W, Y]);
        return renderLine(t, "", xe, Me, D, "clip".concat(kt, "snap").concat(Jt), "guideline");
      })), Ut.isBound && vt.push.apply(vt, Ut.bounds.map(function(Wt, Jt) {
        var qt = Wt.pos, xe = minus(calculatePosition(V, Ct ? [0, qt] : [qt, 0], st), [W, Y]), Me = minus(calculatePosition(V, Ct ? [U, qt] : [qt, H], st), [W, Y]);
        return renderLine(t, "", xe, Me, D, "clip".concat(kt, "bounds").concat(Jt), "guideline", "bounds", "bold");
      }));
    }), __spreadArray(__spreadArray([], ct, !0), vt, !0);
  },
  dragControlCondition: function(o, t) {
    return t.inputEvent && (t.inputEvent.target.getAttribute("class") || "").indexOf("clip") > -1;
  },
  dragStart: function(o, t) {
    var e = o.props, r = e.dragWithClip, S = r === void 0 ? !0 : r;
    return S ? !1 : this.dragControlStart(o, t);
  },
  drag: function(o, t) {
    return this.dragControl(o, __assign$1(__assign$1({}, t), {
      isDragTarget: !0
    }));
  },
  dragEnd: function(o, t) {
    return this.dragControlEnd(o, t);
  },
  dragControlStart: function(o, t) {
    var e = o.state, r = o.props, S = r.defaultClipPath, T = r.customClipPath, D = e.target, N = e.width, B = e.height, $ = t.inputEvent ? t.inputEvent.target : null, U = $ && $.getAttribute("class") || "", H = t.datas, V = getClipPath(D, N, B, S || "inset", T);
    if (!V)
      return !1;
    var X = V.clipText, W = V.type, Y = V.poses, q = triggerEvent(o, "onClipStart", fillParams(o, t, {
      clipType: W,
      clipStyle: X,
      poses: Y.map(function(K) {
        return K.pos;
      })
    }));
    return q === !1 ? (H.isClipStart = !1, !1) : (H.isControl = U && U.indexOf("clip-control") > -1, H.isLine = U.indexOf("clip-line") > -1, H.isArea = U.indexOf("clip-area") > -1 || U.indexOf("clip-ellipse") > -1, H.clipIndex = $ ? parseInt($.getAttribute("data-clip-index"), 10) : -1, H.clipPath = V, H.isClipStart = !0, e.clipPathState = X, setDragStart(o, t), !0);
  },
  dragControl: function(o, t) {
    var e, r, S = t.datas, T = t.originalDatas, D = t.isDragTarget;
    if (!S.isClipStart)
      return !1;
    var N = S, B = N.isControl, $ = N.isLine, U = N.isArea, H = N.clipIndex, V = N.clipPath;
    if (!V)
      return !1;
    var X = getProps(o.props, "clippable"), W = X.keepRatio, Y = 0, q = 0, K = T.draggable, Z = getDragDist(t);
    D && K ? (e = K.prevBeforeDist, Y = e[0], q = e[1]) : (Y = Z[0], q = Z[1]);
    var J = [Y, q], Q = o.state, rt = Q.width, et = Q.height, nt = !U && !B && !$, st = V.type, it = V.poses, ot = V.splitter, ht = it.map(function(dt) {
      return dt.pos;
    });
    nt && (Y = -Y, q = -q);
    var ct = !B || it[H].direction === "nesw", vt = st === "inset" || st === "rect", _t = it.map(function() {
      return [0, 0];
    });
    if (B && !ct) {
      var gt = it[H], mt = gt.horizontal, Et = gt.vertical, wt = [Y * Math.abs(mt), q * Math.abs(Et)];
      _t = moveControlPos(it, H, wt, vt, W);
    } else
      ct && (_t = ht.map(function() {
        return [Y, q];
      }));
    var xt = ht.map(function(dt, bt) {
      return plus(dt, _t[bt]);
    }), pt = __spreadArray([], xt, !0);
    Q.snapBoundInfos = null;
    var yt = V.type === "circle", Dt = V.type === "ellipse";
    if (yt || Dt) {
      var At = getRect(xt), It = Math.abs(At.bottom - At.top), Ot = Math.abs(Dt ? At.right - At.left : It), ft = xt[0][1] + It, Ft = xt[0][0] - Ot, Mt = xt[0][0] + Ot;
      yt && (pt.push([Mt, At.bottom]), _t.push([1, 0])), pt.push([At.left, ft]), _t.push([0, 1]), pt.push([Ft, At.bottom]), _t.push([1, 0]);
    }
    var zt = getDefaultGuidelines((X.clipHorizontalGuidelines || []).map(function(dt) {
      return convertUnitSize("".concat(dt), et);
    }), (X.clipVerticalGuidelines || []).map(function(dt) {
      return convertUnitSize("".concat(dt), rt);
    }), rt, et), Nt = [], St = [];
    if (yt || Dt)
      Nt = [pt[4][0], pt[2][0]], St = [pt[1][1], pt[3][1]];
    else if (vt) {
      var Ht = [pt[0], pt[2], pt[4], pt[6]], Lt = [_t[0], _t[2], _t[4], _t[6]];
      Nt = Ht.filter(function(dt, bt) {
        return Lt[bt][0];
      }).map(function(dt) {
        return dt[0];
      }), St = Ht.filter(function(dt, bt) {
        return Lt[bt][1];
      }).map(function(dt) {
        return dt[1];
      });
    } else
      Nt = pt.filter(function(dt, bt) {
        return _t[bt][0];
      }).map(function(dt) {
        return dt[0];
      }), St = pt.filter(function(dt, bt) {
        return _t[bt][1];
      }).map(function(dt) {
        return dt[1];
      });
    var Tt = [0, 0], kt = checkSnapBounds(zt, X.clipTargetBounds && {
      left: 0,
      top: 0,
      right: rt,
      bottom: et
    }, Nt, St, 5), Ut = kt.horizontal, Ct = kt.vertical, Wt = Ut.offset, Jt = Ct.offset;
    if (Ut.isBound && (Tt[1] += Wt), Ct.isBound && (Tt[0] += Jt), (Dt || yt) && _t[0][0] === 0 && _t[0][1] === 0) {
      var At = getRect(xt), qt = At.bottom - At.top, xe = Dt ? At.right - At.left : qt, Me = Ct.isBound ? Math.abs(Jt) : Ct.snapIndex === 0 ? -Jt : Jt, ue = Ut.isBound ? Math.abs(Wt) : Ut.snapIndex === 0 ? -Wt : Wt;
      xe -= Me, qt -= ue, yt && (qt = checkSnapBoundPriority(Ct, Ut) > 0 ? qt : xe, xe = qt);
      var me = pt[0];
      pt[1][1] = me[1] - qt, pt[2][0] = me[0] + xe, pt[3][1] = me[1] + qt, pt[4][0] = me[0] - xe;
    } else if (vt && W && B) {
      var pe = getControlSize(it), fe = pe[0], ce = pe[1], ie = fe && ce ? fe / ce : 0, ze = it[H], ds = ze.direction || "", $a = pt[1][1], ft = pt[5][1], Ft = pt[7][0], Mt = pt[3][0];
      Wt <= Jt ? Wt = Jt / ie : Jt = Wt * ie, ds.indexOf("w") > -1 ? Ft -= Jt : ds.indexOf("e") > -1 ? Mt -= Jt : (Ft += Jt / 2, Mt -= Jt / 2), ds.indexOf("n") > -1 ? $a -= Wt : ds.indexOf("s") > -1 ? ft -= Wt : ($a += Wt / 2, ft -= Wt / 2);
      var Gc = getRectPoses($a, Mt, ft, Ft);
      pt.forEach(function(Bt, $t) {
        var Gt;
        Gt = Gc[$t].pos, Bt[0] = Gt[0], Bt[1] = Gt[1];
      });
    } else
      pt.forEach(function(dt, bt) {
        var Rt = _t[bt];
        Rt[0] && (dt[0] -= Jt), Rt[1] && (dt[1] -= Wt);
      });
    var Ga = getClipStyles(o, V, xt), ps = "".concat(st, "(").concat(Ga.join(ot), ")");
    if (Q.clipPathState = ps, yt || Dt)
      Nt = [pt[4][0], pt[2][0]], St = [pt[1][1], pt[3][1]];
    else if (vt) {
      var Ht = [pt[0], pt[2], pt[4], pt[6]];
      Nt = Ht.map(function(bt) {
        return bt[0];
      }), St = Ht.map(function(bt) {
        return bt[1];
      });
    } else
      Nt = pt.map(function(dt) {
        return dt[0];
      }), St = pt.map(function(dt) {
        return dt[1];
      });
    if (Q.snapBoundInfos = checkSnapBounds(zt, X.clipTargetBounds && {
      left: 0,
      top: 0,
      right: rt,
      bottom: et
    }, Nt, St, 1), K) {
      var Ql = Q.is3d, tu = Q.allMatrix, Uc = Ql ? 4 : 3, ut = Tt;
      D && (ut = [J[0] + Tt[0] - Z[0], J[1] + Tt[1] - Z[1]]), K.deltaOffset = multiply(tu, [ut[0], ut[1], 0, 0], Uc);
    }
    return triggerEvent(o, "onClip", fillParams(o, t, __assign$1({
      clipEventType: "changed",
      clipType: st,
      poses: xt,
      clipStyle: ps,
      clipStyles: Ga,
      distX: Y,
      distY: q
    }, fillCSSObject((r = {}, r[st === "rect" ? "clip" : "clipPath"] = ps, r), t)))), !0;
  },
  dragControlEnd: function(o, t) {
    this.unset(o);
    var e = t.isDrag, r = t.datas, S = t.isDouble, T = r.isLine, D = r.isClipStart, N = r.isControl;
    return D ? (triggerEvent(o, "onClipEnd", fillEndParams(o, t, {})), S && (N ? removeClipPath(o, t) : T && addClipPath(o, t)), S || e) : !1;
  },
  unset: function(o) {
    o.state.clipPathState = "", o.state.snapBoundInfos = null;
  }
}, OriginDraggable = {
  name: "originDraggable",
  props: {
    originDraggable: Boolean,
    originRelative: Boolean
  },
  events: {
    onDragOriginStart: "dragOriginStart",
    onDragOrigin: "dragOrigin",
    onDragOriginEnd: "dragOriginEnd"
  },
  css: [`:host[data-able-origindraggable] .control.origin {
    pointer-events: auto;
}`],
  dragControlCondition: function(o, t) {
    return t.isRequest ? t.requestAble === "originDraggable" : hasClass(t.inputEvent.target, prefix("origin"));
  },
  dragControlStart: function(o, t) {
    var e = t.datas;
    setDragStart(o, t);
    var r = fillParams(o, t, {
      dragStart: Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))
    }), S = triggerEvent(o, "onDragOriginStart", r);
    return e.startOrigin = o.state.transformOrigin, e.startTargetOrigin = o.state.targetOrigin, e.prevOrigin = [0, 0], e.isDragOrigin = !0, S === !1 ? (e.isDragOrigin = !1, !1) : r;
  },
  dragControl: function(o, t) {
    var e = t.datas, r = t.isPinch, S = t.isRequest;
    if (!e.isDragOrigin)
      return !1;
    var T = getDragDist(t), D = T[0], N = T[1], B = o.state, $ = B.width, U = B.height, H = B.offsetMatrix, V = B.targetMatrix, X = B.is3d, W = o.props.originRelative, Y = W === void 0 ? !0 : W, q = X ? 4 : 3, K = [D, N];
    if (S) {
      var Z = t.distOrigin;
      (Z[0] || Z[1]) && (K = Z);
    }
    var J = plus(e.startOrigin, K), Q = plus(e.startTargetOrigin, K), rt = minus(K, e.prevOrigin), et = getNextMatrix(H, V, J, q), nt = o.getRect(), st = getRect(calculatePoses(et, $, U, q)), it = [nt.left - st.left, nt.top - st.top];
    e.prevOrigin = K;
    var ot = [convertCSSSize(Q[0], $, Y), convertCSSSize(Q[1], U, Y)].join(" "), ht = Draggable.drag(o, setCustomDrag(t, o.state, it, !!r, !1)), ct = fillParams(o, t, __assign$1(__assign$1({
      width: $,
      height: U,
      origin: J,
      dist: K,
      delta: rt,
      transformOrigin: ot,
      drag: ht
    }, fillCSSObject({
      transformOrigin: ot,
      transform: ht.transform
    }, t)), {
      afterTransform: ht.transform
    }));
    return triggerEvent(o, "onDragOrigin", ct), ct;
  },
  dragControlEnd: function(o, t) {
    var e = t.datas;
    return e.isDragOrigin ? (triggerEvent(o, "onDragOriginEnd", fillEndParams(o, t, {})), !0) : !1;
  },
  dragGroupControlCondition: function(o, t) {
    return this.dragControlCondition(o, t);
  },
  dragGroupControlStart: function(o, t) {
    var e = this.dragControlStart(o, t);
    return !!e;
  },
  dragGroupControl: function(o, t) {
    var e = this.dragControl(o, t);
    return e ? (o.transformOrigin = e.transformOrigin, !0) : !1;
  },
  /**
  * @method Moveable.OriginDraggable#request
  * @param {object} e - the OriginDraggable's request parameter
  * @param {number} [e.x] - x position
  * @param {number} [e.y] - y position
  * @param {number} [e.deltaX] - x number to move
  * @param {number} [e.deltaY] - y number to move
  * @param {array} [e.deltaOrigin] - left, top number to move transform-origin
  * @param {array} [e.origin] - transform-origin position
  * @param {number} [e.isInstant] - Whether to execute the request instantly
  * @return {Moveable.Requester} Moveable Requester
  * @example
   * // Instantly Request (requestStart - request - requestEnd)
  * // Use Relative Value
  * moveable.request("originDraggable", { deltaX: 10, deltaY: 10 }, true);
  * // Use Absolute Value
  * moveable.request("originDraggable", { x: 200, y: 100 }, true);
  * // Use Transform Value
  * moveable.request("originDraggable", { deltaOrigin: [10, 0] }, true);
  * moveable.request("originDraggable", { origin: [100, 0] }, true);
  * // requestStart
  * const requester = moveable.request("originDraggable");
  *
  * // request
  * // Use Relative Value
  * requester.request({ deltaX: 10, deltaY: 10 });
  * requester.request({ deltaX: 10, deltaY: 10 });
  * requester.request({ deltaX: 10, deltaY: 10 });
  * // Use Absolute Value
  * moveable.request("originDraggable", { x: 200, y: 100 });
  * moveable.request("originDraggable", { x: 220, y: 100 });
  * moveable.request("originDraggable", { x: 240, y: 100 });
  *
  * // requestEnd
  * requester.requestEnd();
  */
  request: function(o) {
    var t = {}, e = o.getRect(), r = 0, S = 0, T = e.transformOrigin, D = [0, 0];
    return {
      isControl: !0,
      requestStart: function() {
        return {
          datas: t
        };
      },
      request: function(N) {
        return "deltaOrigin" in N ? (D[0] += N.deltaOrigin[0], D[1] += N.deltaOrigin[1]) : "origin" in N ? (D[0] = N.origin[0] - T[0], D[1] = N.origin[1] - T[1]) : ("x" in N ? r = N.x - e.left : "deltaX" in N && (r += N.deltaX), "y" in N ? S = N.y - e.top : "deltaY" in N && (S += N.deltaY)), {
          datas: t,
          distX: r,
          distY: S,
          distOrigin: D
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  }
};
function addBorderRadiusByLine(o, t, e, r) {
  var S = o.filter(function(B) {
    var $ = B.virtual, U = B.horizontal;
    return U && !$;
  }).length, T = o.filter(function(B) {
    var $ = B.virtual, U = B.vertical;
    return U && !$;
  }).length, D = -1;
  if (t === 0 && (S === 0 ? D = 0 : S === 1 && (D = 1)), t === 2 && (S <= 2 ? D = 2 : S <= 3 && (D = 3)), t === 3 && (T === 0 ? D = 4 : T < 4 && (D = 7)), t === 1 && (T <= 1 ? D = 5 : T <= 2 && (D = 6)), !(D === -1 || !o[D].virtual)) {
    var N = o[D];
    addBorderRadius(o, D), D < 4 ? N.pos[0] = e : N.pos[1] = r;
  }
}
function addBorderRadius(o, t) {
  t < 4 ? o.slice(0, t + 1).forEach(function(e) {
    e.virtual = !1;
  }) : (o[0].virtual && (o[0].virtual = !1), o.slice(4, t + 1).forEach(function(e) {
    e.virtual = !1;
  }));
}
function removeBorderRadius(o, t) {
  t < 4 ? o.slice(t, 4).forEach(function(e) {
    e.virtual = !0;
  }) : o.slice(t).forEach(function(e) {
    e.virtual = !0;
  });
}
function getBorderRadius(o, t, e, r, S) {
  r === void 0 && (r = [0, 0]);
  var T = [];
  return !o || o === "0px" ? T = [] : T = splitSpace(o), getRadiusValues(T, t, e, 0, 0, r, S);
}
function triggerRoundEvent(o, t, e, r, S) {
  var T = o.state, D = T.width, N = T.height, B = getRadiusStyles(S, o.props.roundRelative, D, N), $ = B.raws, U = B.styles, H = B.radiusPoses, V = splitRadiusPoses(H, $), X = V.horizontals, W = V.verticals, Y = U.join(" ");
  T.borderRadiusState = Y;
  var q = fillParams(o, t, __assign$1({
    horizontals: X,
    verticals: W,
    borderRadius: Y,
    width: D,
    height: N,
    delta: r,
    dist: e
  }, fillCSSObject({
    borderRadius: Y
  }, t)));
  return triggerEvent(o, "onRound", q), q;
}
function getStyleBorderRadius(o) {
  var t = o.getState().style, e = t.borderRadius || "";
  if (!e && o.props.groupable) {
    var r = o.getTargets()[0];
    r && (e = getComputedStyle(r).borderRadius, t.borderRadius = e);
  }
  return e;
}
var Roundable = {
  name: "roundable",
  props: {
    roundable: Boolean,
    roundRelative: Boolean,
    minRoundControls: Array,
    maxRoundControls: Array,
    roundClickable: Boolean,
    roundPadding: Number,
    isDisplayShadowRoundControls: Boolean
  },
  events: {
    onRoundStart: "roundStart",
    onRound: "round",
    onRoundEnd: "roundEnd",
    onRoundGroupStart: "roundGroupStart",
    onRoundGroup: "roundGroup",
    onRoundGroupEnd: "roundGroupEnd"
  },
  css: [`.control.border-radius {
    background: #d66;
    cursor: pointer;
    z-index: 3;
}`, `.control.border-radius.vertical {
    background: #d6d;
    z-index: 2;
}`, `.control.border-radius.virtual {
    opacity: 0.5;
    z-index: 1;
}`, `:host.round-line-clickable .line.direction {
    cursor: pointer;
}`],
  className: function(o) {
    var t = o.props.roundClickable;
    return t === !0 || t === "line" ? prefix("round-line-clickable") : "";
  },
  requestStyle: function() {
    return ["borderRadius"];
  },
  render: function(o, t) {
    var e = o.getState(), r = e.target, S = e.width, T = e.height, D = e.allMatrix, N = e.is3d, B = e.left, $ = e.top, U = e.borderRadiusState, H = o.props, V = H.minRoundControls, X = V === void 0 ? [0, 0] : V, W = H.maxRoundControls, Y = W === void 0 ? [4, 4] : W, q = H.zoom, K = H.roundPadding, Z = K === void 0 ? 0 : K, J = H.isDisplayShadowRoundControls, Q = H.groupable;
    if (!r)
      return null;
    var rt = U || getStyleBorderRadius(o), et = N ? 4 : 3, nt = getBorderRadius(rt, S, T, X, !0);
    if (!nt)
      return null;
    var st = 0, it = 0, ot = Q ? [0, 0] : [B, $];
    return nt.map(function(ht, ct) {
      var vt = ht.horizontal, _t = ht.vertical, gt = ht.direction || "", mt = __spreadArray([], ht.pos, !0);
      it += Math.abs(vt), st += Math.abs(_t), vt && gt.indexOf("n") > -1 && (mt[1] -= Z), _t && gt.indexOf("w") > -1 && (mt[0] -= Z), vt && gt.indexOf("s") > -1 && (mt[1] += Z), _t && gt.indexOf("e") > -1 && (mt[0] += Z);
      var Et = minus(calculatePosition(D, mt, et), ot), wt = ht.vertical ? st <= Y[1] && (J || !ht.virtual) : it <= Y[0] && (J || !ht.virtual);
      return t.createElement("div", {
        key: "borderRadiusControl".concat(ct),
        className: prefix("control", "border-radius", ht.vertical ? "vertical" : "", ht.virtual ? "virtual" : ""),
        "data-radius-index": ct,
        style: {
          display: wt ? "block" : "none",
          transform: "translate(".concat(Et[0], "px, ").concat(Et[1], "px) scale(").concat(q, ")")
        }
      });
    });
  },
  dragControlCondition: function(o, t) {
    if (!t.inputEvent || t.isRequest)
      return !1;
    var e = t.inputEvent.target.getAttribute("class") || "";
    return e.indexOf("border-radius") > -1 || e.indexOf("moveable-line") > -1 && e.indexOf("moveable-direction") > -1;
  },
  dragGroupControlCondition: function(o, t) {
    return this.dragControlCondition(o, t);
  },
  dragControlStart: function(o, t) {
    var e = t.inputEvent, r = t.datas, S = e.target, T = S.getAttribute("class") || "", D = T.indexOf("border-radius") > -1, N = T.indexOf("moveable-line") > -1 && T.indexOf("moveable-direction") > -1, B = D ? parseInt(S.getAttribute("data-radius-index"), 10) : -1, $ = -1;
    if (N) {
      var U = S.getAttribute("data-line-key") || "";
      U && ($ = parseInt(U.replace(/render-line-/g, ""), 10), isNaN($) && ($ = -1));
    }
    if (!D && !N)
      return !1;
    var H = fillParams(o, t, {}), V = triggerEvent(o, "onRoundStart", H);
    if (V === !1)
      return !1;
    r.lineIndex = $, r.controlIndex = B, r.isControl = D, r.isLine = N, setDragStart(o, t);
    var X = o.props, W = X.roundRelative, Y = X.minRoundControls, q = Y === void 0 ? [0, 0] : Y, K = o.state, Z = K.width, J = K.height;
    r.isRound = !0, r.prevDist = [0, 0];
    var Q = getStyleBorderRadius(o), rt = getBorderRadius(Q || "", Z, J, q, !0) || [];
    return r.controlPoses = rt, K.borderRadiusState = getRadiusStyles(rt, W, Z, J).styles.join(" "), H;
  },
  dragControl: function(o, t) {
    var e = t.datas, r = e.controlPoses;
    if (!e.isRound || !e.isControl || !r.length)
      return !1;
    var S = e.controlIndex, T = getDragDist(t), D = T[0], N = T[1], B = [D, N], $ = minus(B, e.prevDist), U = o.props.maxRoundControls, H = U === void 0 ? [4, 4] : U, V = o.state, X = V.width, W = V.height, Y = r[S], q = Y.vertical, K = Y.horizontal, Z = r.map(function(Q) {
      var rt = Q.horizontal, et = Q.vertical, nt = [rt * K * B[0], et * q * B[1]];
      if (rt) {
        if (H[0] === 1)
          return nt;
        if (H[0] < 4 && rt !== K)
          return nt;
      } else {
        if (H[1] === 0)
          return nt[1] = et * K * B[0] / X * W, nt;
        if (q) {
          if (H[1] === 1)
            return nt;
          if (H[1] < 4 && et !== q)
            return nt;
        }
      }
      return [0, 0];
    });
    Z[S] = B;
    var J = r.map(function(Q, rt) {
      return __assign$1(__assign$1({}, Q), {
        pos: plus(Q.pos, Z[rt])
      });
    });
    return S < 4 ? J.slice(0, S + 1).forEach(function(Q) {
      Q.virtual = !1;
    }) : J.slice(4, S + 1).forEach(function(Q) {
      Q.virtual = !1;
    }), e.prevDist = [D, N], triggerRoundEvent(o, t, B, $, J);
  },
  dragControlEnd: function(o, t) {
    var e = o.state;
    e.borderRadiusState = "";
    var r = t.datas, S = t.isDouble;
    if (!r.isRound)
      return !1;
    var T = r.isControl, D = r.controlIndex, N = r.isLine, B = r.lineIndex, $ = r.controlPoses, U = $.filter(function(K) {
      var Z = K.virtual;
      return Z;
    }).length, H = o.props.roundClickable, V = H === void 0 ? !0 : H;
    if (S && V) {
      if (T && (V === !0 || V === "control"))
        removeBorderRadius($, D);
      else if (N && (V === !0 || V === "line")) {
        var X = calculatePointerDist(o, t), W = X[0], Y = X[1];
        addBorderRadiusByLine($, B, W, Y);
      }
      U !== $.filter(function(K) {
        var Z = K.virtual;
        return Z;
      }).length && triggerRoundEvent(o, t, [0, 0], [0, 0], $);
    }
    var q = fillEndParams(o, t, {});
    return triggerEvent(o, "onRoundEnd", q), e.borderRadiusState = "", q;
  },
  dragGroupControlStart: function(o, t) {
    var e = this.dragControlStart(o, t);
    if (!e)
      return !1;
    var r = o.moveables, S = o.props.targets, T = fillChildEvents(o, "roundable", t), D = __assign$1({
      targets: o.props.targets,
      events: T.map(function(N, B) {
        return __assign$1(__assign$1({}, N), {
          target: S[B],
          moveable: r[B],
          currentTarget: r[B]
        });
      })
    }, e);
    return triggerEvent(o, "onRoundGroupStart", D), e;
  },
  dragGroupControl: function(o, t) {
    var e = this.dragControl(o, t);
    if (!e)
      return !1;
    var r = o.moveables, S = o.props.targets, T = fillChildEvents(o, "roundable", t), D = __assign$1({
      targets: o.props.targets,
      events: T.map(function(N, B) {
        return __assign$1(__assign$1(__assign$1({}, N), {
          target: S[B],
          moveable: r[B],
          currentTarget: r[B]
        }), fillCSSObject({
          borderRadius: e.borderRadius
        }, N));
      })
    }, e);
    return triggerEvent(o, "onRoundGroup", D), D;
  },
  dragGroupControlEnd: function(o, t) {
    var e = o.moveables, r = o.props.targets, S = fillChildEvents(o, "roundable", t);
    catchEvent(o, "onRound", function(N) {
      var B = __assign$1({
        targets: o.props.targets,
        events: S.map(function($, U) {
          return __assign$1(__assign$1(__assign$1({}, $), {
            target: r[U],
            moveable: e[U],
            currentTarget: e[U]
          }), fillCSSObject({
            borderRadius: N.borderRadius
          }, $));
        })
      }, N);
      triggerEvent(o, "onRoundGroup", B);
    });
    var T = this.dragControlEnd(o, t);
    if (!T)
      return !1;
    var D = __assign$1({
      targets: o.props.targets,
      events: S.map(function(N, B) {
        var $;
        return __assign$1(__assign$1({}, N), {
          target: r[B],
          moveable: e[B],
          currentTarget: e[B],
          lastEvent: ($ = N.datas) === null || $ === void 0 ? void 0 : $.lastEvent
        });
      })
    }, T);
    return triggerEvent(o, "onRoundGroupEnd", D), D;
  },
  unset: function(o) {
    o.state.borderRadiusState = "";
  }
};
function isIdentityMatrix(o, t) {
  var e = t ? 4 : 3, r = createIdentityMatrix(e), S = "matrix".concat(t ? "3d" : "", "(").concat(r.join(","), ")");
  return o === S || o === "matrix(1,0,0,1,0,0)";
}
var BeforeRenderable = {
  isPinch: !0,
  name: "beforeRenderable",
  props: {},
  events: {
    onBeforeRenderStart: "beforeRenderStart",
    onBeforeRender: "beforeRender",
    onBeforeRenderEnd: "beforeRenderEnd",
    onBeforeRenderGroupStart: "beforeRenderGroupStart",
    onBeforeRenderGroup: "beforeRenderGroup",
    onBeforeRenderGroupEnd: "beforeRenderGroupEnd"
  },
  dragRelation: "weak",
  setTransform: function(o, t) {
    var e = o.state, r = e.is3d, S = e.target, T = e.targetMatrix, D = S == null ? void 0 : S.style.transform, N = r ? "matrix3d(".concat(T.join(","), ")") : "matrix(".concat(convertMatrixtoCSS(T, !0), ")"), B = !D || D === "none" ? N : D;
    t.datas.startTransforms = isIdentityMatrix(B, r) ? [] : splitSpace(B);
  },
  resetStyle: function(o) {
    var t = o.datas;
    t.nextStyle = {}, t.nextTransforms = o.datas.startTransforms, t.nextTransformAppendedIndexes = [];
  },
  fillDragStartParams: function(o, t) {
    return fillParams(o, t, {
      setTransform: function(e) {
        t.datas.startTransforms = isArray(e) ? e : splitSpace(e);
      },
      isPinch: !!t.isPinch
    });
  },
  fillDragParams: function(o, t) {
    return fillParams(o, t, {
      isPinch: !!t.isPinch
    });
  },
  dragStart: function(o, t) {
    this.setTransform(o, t), this.resetStyle(t), triggerEvent(o, "onBeforeRenderStart", this.fillDragStartParams(o, t));
  },
  drag: function(o, t) {
    this.resetStyle(t), triggerEvent(o, "onBeforeRender", fillParams(o, t, {
      isPinch: !!t.isPinch
    }));
  },
  dragEnd: function(o, t) {
    triggerEvent(o, "onBeforeRenderEnd", fillParams(o, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag
    }));
  },
  dragGroupStart: function(o, t) {
    var e = this;
    this.dragStart(o, t);
    var r = fillChildEvents(o, "beforeRenderable", t), S = o.moveables, T = r.map(function(D, N) {
      var B = S[N];
      return e.setTransform(B, D), e.resetStyle(D), e.fillDragStartParams(B, D);
    });
    triggerEvent(o, "onBeforeRenderGroupStart", fillParams(o, t, {
      isPinch: !!t.isPinch,
      targets: o.props.targets,
      setTransform: function() {
      },
      events: T
    }));
  },
  dragGroup: function(o, t) {
    var e = this;
    this.drag(o, t);
    var r = fillChildEvents(o, "beforeRenderable", t), S = o.moveables, T = r.map(function(D, N) {
      var B = S[N];
      return e.resetStyle(D), e.fillDragParams(B, D);
    });
    triggerEvent(o, "onBeforeRenderGroup", fillParams(o, t, {
      isPinch: !!t.isPinch,
      targets: o.props.targets,
      events: T
    }));
  },
  dragGroupEnd: function(o, t) {
    this.dragEnd(o, t), triggerEvent(o, "onBeforeRenderGroupEnd", fillParams(o, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      targets: o.props.targets
    }));
  },
  dragControlStart: function(o, t) {
    return this.dragStart(o, t);
  },
  dragControl: function(o, t) {
    return this.drag(o, t);
  },
  dragControlEnd: function(o, t) {
    return this.dragEnd(o, t);
  },
  dragGroupControlStart: function(o, t) {
    return this.dragGroupStart(o, t);
  },
  dragGroupControl: function(o, t) {
    return this.dragGroup(o, t);
  },
  dragGroupControlEnd: function(o, t) {
    return this.dragGroupEnd(o, t);
  }
}, Renderable = {
  name: "renderable",
  props: {},
  events: {
    onRenderStart: "renderStart",
    onRender: "render",
    onRenderEnd: "renderEnd",
    onRenderGroupStart: "renderGroupStart",
    onRenderGroup: "renderGroup",
    onRenderGroupEnd: "renderGroupEnd"
  },
  dragRelation: "weak",
  dragStart: function(o, t) {
    triggerEvent(o, "onRenderStart", fillParams(o, t, {
      isPinch: !!t.isPinch
    }));
  },
  drag: function(o, t) {
    triggerEvent(o, "onRender", this.fillDragParams(o, t));
  },
  dragAfter: function(o, t) {
    if (t.resultCount)
      return this.drag(o, t);
  },
  dragEnd: function(o, t) {
    triggerEvent(o, "onRenderEnd", this.fillDragEndParams(o, t));
  },
  dragGroupStart: function(o, t) {
    triggerEvent(o, "onRenderGroupStart", fillParams(o, t, {
      isPinch: !!t.isPinch,
      targets: o.props.targets
    }));
  },
  dragGroup: function(o, t) {
    var e = this, r = fillChildEvents(o, "beforeRenderable", t), S = o.moveables, T = r.map(function(D, N) {
      var B = S[N];
      return e.fillDragParams(B, D);
    });
    triggerEvent(o, "onRenderGroup", fillParams(o, t, __assign$1(__assign$1({
      isPinch: !!t.isPinch,
      targets: o.props.targets,
      transform: getNextTransformText(t)
    }, fillCSSObject(getNextStyle(t))), {
      events: T
    })));
  },
  dragGroupEnd: function(o, t) {
    var e = this, r = fillChildEvents(o, "beforeRenderable", t), S = o.moveables, T = r.map(function(D, N) {
      var B = S[N];
      return e.fillDragEndParams(B, D);
    });
    triggerEvent(o, "onRenderGroupEnd", fillParams(o, t, __assign$1({
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      targets: o.props.targets,
      events: T,
      transform: getNextTransformText(t)
    }, fillCSSObject(getNextStyle(t)))));
  },
  dragControlStart: function(o, t) {
    return this.dragStart(o, t);
  },
  dragControl: function(o, t) {
    return this.drag(o, t);
  },
  dragControlAfter: function(o, t) {
    return this.dragAfter(o, t);
  },
  dragControlEnd: function(o, t) {
    return this.dragEnd(o, t);
  },
  dragGroupControlStart: function(o, t) {
    return this.dragGroupStart(o, t);
  },
  dragGroupControl: function(o, t) {
    return this.dragGroup(o, t);
  },
  dragGroupControlEnd: function(o, t) {
    return this.dragGroupEnd(o, t);
  },
  fillDragParams: function(o, t) {
    return fillParams(o, t, __assign$1({
      isPinch: !!t.isPinch,
      transform: getNextTransformText(t)
    }, fillCSSObject(getNextStyle(t))));
  },
  fillDragEndParams: function(o, t) {
    return fillParams(o, t, __assign$1({
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      transform: getNextTransformText(t)
    }, fillCSSObject(getNextStyle(t))));
  }
};
function triggerAble(o, t, e, r, S, T, D) {
  var N = S === "Start", B = o.state.target, $ = T.isRequest;
  if (!B || N && r.indexOf("Control") > -1 && !$ && o.areaElement === T.inputEvent.target)
    return !1;
  var U = "".concat(e).concat(r).concat(S), H = "".concat(e).concat(r, "Condition"), V = S === "End", X = S === "After", W = N && (!o.targetGesto || !o.controlGesto || !o.targetGesto.isFlag() || !o.controlGesto.isFlag());
  W && o.updateRect(S, !0, !1), T.clientDistX = T.distX, T.clientDistY = T.distY, S === "" && !$ && convertDragDist(o.state, T);
  var Y = __spreadArray([], o[t], !0);
  if ($) {
    var q = T.requestAble;
    Y.some(function(ct) {
      return ct.name === q;
    }) || Y.push.apply(Y, o.props.ables.filter(function(ct) {
      return ct.name === q;
    }));
  }
  if (!Y.length || Y.every(function(ct) {
    return ct.dragRelation;
  }))
    return !1;
  var K = __spreadArray(__spreadArray([BeforeRenderable], Y, !0), [Renderable], !1).filter(function(ct) {
    return ct[U];
  }), Z = T.datas;
  W && K.forEach(function(ct) {
    ct.unset && ct.unset(o);
  });
  var J = T.inputEvent, Q;
  V && J && (Q = document.elementFromPoint(T.clientX, T.clientY) || J.target);
  var rt = 0, et = !1, nt = function() {
    var ct;
    et = !0, (ct = T.stop) === null || ct === void 0 || ct.call(T);
  }, st = K.filter(function(ct) {
    var vt = ct.name, _t = Z[vt] || (Z[vt] = {});
    if (N && (_t.isEventStart = !ct[H] || ct[H](o, T)), _t.isEventStart) {
      var gt = ct[U](o, __assign$1(__assign$1({}, T), {
        stop: nt,
        resultCount: rt,
        datas: _t,
        originalDatas: Z,
        inputTarget: Q
      }));
      return o._emitter.off(), N && gt === !1 && (_t.isEventStart = !1), rt += gt || _t.isEventStart ? 1 : 0, gt;
    }
    return !1;
  }), it = st.length, ot = !1;
  if (et && (ot = !0), !ot && N && K.length && !it && (ot = K.filter(function(ct) {
    var vt = ct.name, _t = Z[vt];
    return _t.isEventStart ? ct.dragRelation !== "strong" : !1;
  }).length), (V || ot) && (o.state.gestos = {}, o.moveables && o.moveables.forEach(function(ct) {
    ct.state.gestos = {};
  }), K.forEach(function(ct) {
    ct.unset && ct.unset(o);
  })), N && !ot && !$ && it && (T == null || T.preventDefault()), o.isUnmounted || ot)
    return !1;
  if (!N && it && !D || V) {
    var ht = o.props.flushSync || defaultSync;
    ht(function() {
      o.updateRect(V ? S : "", !0, !1), o.forceUpdate();
    });
  }
  return !N && !V && !X && it && !D && triggerAble(o, t, e, r, S + "After", T), !0;
}
function checkMoveableTarget(o) {
  return function(t) {
    var e = o.props.dragTarget, r = t.inputEvent.target, S = o.areaElement;
    return e && (r === e || e.contains(r)) || r === S || !o.isMoveableElement(r) && !o.controlBox.getElement().contains(r) || hasClass(r, "moveable-area") || hasClass(r, "moveable-padding") || hasClass(r, "moveable-edgeDraggable");
  };
}
function getTargetAbleGesto(o, t, e) {
  var r = o.controlBox.getElement(), S = [], T = o.props.dragTarget;
  return S.push(r), (!o.props.dragArea || T) && S.push(t), getAbleGesto(o, S, "targetAbles", e, {
    dragStart: checkMoveableTarget(o),
    pinchStart: checkMoveableTarget(o)
  });
}
function getAbleGesto(o, t, e, r, S) {
  S === void 0 && (S = {});
  var T = e === "targetAbles", D = o.props, N = D.pinchOutside, B = D.pinchThreshold, $ = D.preventClickEventOnDrag, U = D.preventClickDefault, H = D.checkInput, V = {
    preventDefault: !0,
    preventRightClick: !0,
    preventWheelClick: !0,
    container: window,
    pinchThreshold: B,
    pinchOutside: N,
    preventClickEventOnDrag: T ? $ : !1,
    preventClickEventOnDragStart: T ? U : !1,
    preventClickEventByCondition: T ? null : function(Y) {
      return o.controlBox.getElement().contains(Y.target);
    },
    checkInput: T ? H : !1
  }, X = new Gesto(t, V), W = r === "Control";
  return ["drag", "pinch"].forEach(function(Y) {
    ["Start", "", "End"].forEach(function(q) {
      X.on("".concat(Y).concat(q), function(K) {
        var Z, J = K.eventType;
        if (S[J] && !S[J](K)) {
          K.stop();
          return;
        }
        var Q = triggerAble(o, e, Y, r, q, K);
        Q ? (o.props.stopPropagation || q === "Start" && W) && ((Z = K == null ? void 0 : K.inputEvent) === null || Z === void 0 || Z.stopPropagation()) : K.stop();
      });
    });
  }), X;
}
var EventManager = /* @__PURE__ */ function() {
  function o(e, r, S) {
    var T = this;
    this.target = e, this.moveable = r, this.eventName = S, this.ables = [], this._onEvent = function(D) {
      var N = T.eventName, B = T.moveable;
      B.state.disableNativeEvent || T.ables.forEach(function($) {
        $[N](B, {
          inputEvent: D
        });
      });
    }, e.addEventListener(S.toLowerCase(), this._onEvent);
  }
  var t = o.prototype;
  return t.setAbles = function(e) {
    this.ables = e;
  }, t.destroy = function() {
    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent), this.target = null, this.moveable = null;
  }, o;
}();
function getShadowRoot(o) {
  if (o && o.getRootNode) {
    var t = o.getRootNode();
    if (t.nodeType === 11)
      return t;
  }
}
function getMatrixStackInfo(o, t, e) {
  for (var r = o, S = [], T = document.documentElement || document.body, D = !e && o === t || o === T, N = D, B = !1, $ = 3, U, H, V, X = !1, W = getOffsetInfo(t, t, !0).offsetParent, Y = 1; r && !N; ) {
    N = D;
    var q = getComputedStyle(r), K = q.position, Z = getElementTransform(r, q), J = convertCSStoMatrix(getTransformMatrix(Z)), Q = K === "fixed", rt = {
      hasTransform: !1,
      fixedContainer: null
    };
    Q && (X = !0, rt = getPositionFixedInfo(r), W = rt.fixedContainer);
    var et = J.length;
    !B && et === 16 && (B = !0, $ = 4, convert3DMatrixes(S), V && (V = convertDimension(V, 3, 4))), B && et === 9 && (J = convertDimension(J, 3, 4));
    var nt = getOffsetPosInfo(r, o, q), st = nt.tagName, it = nt.hasOffset, ot = nt.isSVG, ht = nt.origin, ct = nt.targetOrigin, vt = nt.offset, _t = vt[0], gt = vt[1];
    st === "svg" && V && (S.push({
      type: "target",
      target: r,
      matrix: getSVGMatrix(r, $)
    }), S.push({
      type: "offset",
      target: r,
      matrix: createIdentityMatrix($)
    }));
    var mt = void 0, Et = !1, wt = !1, xt = parseFloat(q.zoom) || 1;
    if (Q)
      mt = rt.fixedContainer, Et = !0;
    else {
      var pt = getOffsetInfo(r, t, !1, !0, q), yt = pt.offsetZoom;
      if (mt = pt.offsetParent, Et = pt.isEnd, wt = pt.isStatic, Y *= yt, yt !== 1 && wt)
        _t -= mt.offsetLeft, gt -= mt.offsetTop;
      else if (IS_FIREFOX) {
        var Dt = pt.parentSlotElement;
        if (Dt) {
          for (var At = mt, It = 0, Ot = 0; At && getShadowRoot(At); )
            It += At.offsetLeft, Ot += At.offsetTop, At = At.offsetParent;
          _t -= It, gt -= Ot;
        }
      }
    }
    IS_WEBKIT && !IS_SAFARI_ABOVE15 && it && !ot && wt && (K === "relative" || K === "static") && (_t -= mt.offsetLeft, gt -= mt.offsetTop, D = D || Et);
    var ft = 0, Ft = 0, Mt = 0, zt = 0;
    if (Q)
      it && rt.hasTransform && (Mt = mt.clientLeft, zt = mt.clientTop);
    else if (it && W !== mt && (ft = mt.clientLeft, Ft = mt.clientTop), it && mt === T) {
      var Nt = getBodyOffset(r, !1, q);
      _t += Nt[0], gt += Nt[1];
    }
    if (S.push({
      type: "target",
      target: r,
      matrix: getAbsoluteMatrix(J, $, ht)
    }), it) {
      var St = r === o, Ht = St ? 0 : r.scrollLeft, Lt = St ? 0 : r.scrollTop;
      S.push({
        type: "offset",
        target: r,
        matrix: createOriginMatrix([_t - Ht + ft - Mt, gt - Lt + Ft - zt], $)
      });
    } else
      S.push({
        type: "offset",
        target: r,
        origin: ht
      });
    if (xt !== 1 && S.push({
      type: "zoom",
      target: r,
      matrix: getAbsoluteMatrix(createScaleMatrix([xt, xt], $), $, [0, 0])
    }), V || (V = J), U || (U = ht), H || (H = ct), N || Q)
      break;
    r = mt, D = Et, (!e || r === T) && (N = D);
  }
  return V || (V = createIdentityMatrix($)), U || (U = [0, 0]), H || (H = [0, 0]), {
    zoom: Y,
    offsetContainer: W,
    matrixes: S,
    targetMatrix: V,
    transformOrigin: U,
    targetOrigin: H,
    is3d: B,
    hasFixed: X
  };
}
function calculateMatrixStack(o, t, e, r) {
  var S;
  e === void 0 && (e = t);
  var T = getMatrixStackInfo(o, t), D = T.matrixes, N = T.is3d, B = T.targetMatrix, $ = T.transformOrigin, U = T.targetOrigin, H = T.offsetContainer, V = T.hasFixed, X = T.zoom, W = getMatrixStackInfo(H, e, !0), Y = W.matrixes, q = W.is3d, K = W.offsetContainer, Z = W.zoom, J = r || q || N, Q = J ? 4 : 3, rt = o.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in o, et = B, nt = createIdentityMatrix(Q), st = createIdentityMatrix(Q), it = createIdentityMatrix(Q), ot = createIdentityMatrix(Q), ht = D.length;
  Y.reverse(), D.reverse(), !N && J && (et = convertDimension(et, 3, 4), convert3DMatrixes(D)), !q && J && convert3DMatrixes(Y), Y.forEach(function(wt) {
    st = multiply(st, wt.matrix, Q);
  });
  var ct = e || document.body, vt = ((S = Y[0]) === null || S === void 0 ? void 0 : S.target) || getOffsetInfo(ct, ct, !0).offsetParent, _t = Y.slice(1).reduce(function(wt, xt) {
    return multiply(wt, xt.matrix, Q);
  }, createIdentityMatrix(Q));
  D.forEach(function(wt, xt) {
    if (ht - 2 === xt && (it = nt.slice()), ht - 1 === xt && (ot = nt.slice()), !wt.matrix) {
      var pt = D[xt + 1], yt = getSVGOffset(wt, pt, vt, Q, multiply(_t, nt, Q));
      wt.matrix = createOriginMatrix(yt, Q);
    }
    nt = multiply(nt, wt.matrix, Q);
  });
  var gt = !rt && N;
  et || (et = createIdentityMatrix(gt ? 4 : 3));
  var mt = makeMatrixCSS(rt && et.length === 16 ? convertDimension(et, 4, 3) : et, gt), Et = st;
  return st = ignoreDimension(st, Q, Q), {
    hasZoom: X !== 1 || Z !== 1,
    hasFixed: V,
    rootMatrix: st,
    originalRootMatrix: Et,
    beforeMatrix: it,
    offsetMatrix: ot,
    allMatrix: nt,
    targetMatrix: et,
    targetTransform: mt,
    transformOrigin: $,
    targetOrigin: U,
    is3d: J,
    offsetContainer: H,
    offsetRootContainer: K
  };
}
function calculateElementInfo(o, t, e, r) {
  e === void 0 && (e = t);
  var S = 0, T = 0, D = 0, N = {}, B = getSize(o);
  if (o && (S = B.offsetWidth, T = B.offsetHeight), o) {
    var $ = calculateMatrixStack(o, t, e, r), U = calculateMoveablePosition($.allMatrix, $.transformOrigin, S, T);
    N = __assign$1(__assign$1({}, $), U);
    var H = calculateMoveablePosition($.allMatrix, [50, 50], 100, 100);
    D = getRotationRad([H.pos1, H.pos2], H.direction);
  }
  var V = r ? 4 : 3;
  return __assign$1(__assign$1(__assign$1({
    hasZoom: !1,
    width: S,
    height: T,
    rotation: D
  }, B), {
    originalRootMatrix: createIdentityMatrix(V),
    rootMatrix: createIdentityMatrix(V),
    beforeMatrix: createIdentityMatrix(V),
    offsetMatrix: createIdentityMatrix(V),
    allMatrix: createIdentityMatrix(V),
    targetMatrix: createIdentityMatrix(V),
    targetTransform: "",
    transformOrigin: [0, 0],
    targetOrigin: [0, 0],
    is3d: !!r,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    origin: [0, 0],
    pos1: [0, 0],
    pos2: [0, 0],
    pos3: [0, 0],
    pos4: [0, 0],
    direction: 1,
    hasFixed: !1,
    offsetContainer: null,
    offsetRootContainer: null
  }), N);
}
function getMoveableTargetInfo(o, t, e, r, S, T) {
  T === void 0 && (T = []);
  var D = 1, N = [0, 0], B = resetClientRect(), $ = resetClientRect(), U = resetClientRect(), H = resetClientRect(), V = [0, 0], X = {}, W = calculateElementInfo(t, e, S, !0);
  if (t) {
    var Y = getComputedStyle(t);
    T.forEach(function(ct) {
      X[ct] = Y[ct];
    });
    var q = W.is3d ? 4 : 3, K = calculateMoveablePosition(W.offsetMatrix, plus(W.transformOrigin, getOrigin(W.targetMatrix, q)), W.width, W.height);
    D = K.direction, N = plus(K.origin, [K.left - W.left, K.top - W.top]), H = getClientRect(W.offsetRootContainer);
    var Z = getOffsetInfo(r, r, !0).offsetParent || W.offsetRootContainer;
    if (W.hasZoom) {
      var J = calculateMoveablePosition(multiply(W.originalRootMatrix, W.allMatrix), W.transformOrigin, W.width, W.height), Q = calculateMoveablePosition(W.originalRootMatrix, getTransformOrigin(getComputedStyle(Z)).map(function(ct) {
        return parseFloat(ct);
      }), Z.offsetWidth, Z.offsetHeight);
      if (B = getClientRectByPosition(J, H), U = getClientRectByPosition(Q, H, Z, !0), o) {
        var rt = J.left, et = J.top;
        $ = getClientRectByPosition({
          left: rt,
          top: et,
          bottom: et,
          right: et
        }, H);
      }
    } else {
      B = getClientRect(t), U = getClientRect(Z, !0), o && ($ = getClientRect(o));
      var nt = U.left, st = U.top, it = U.clientLeft, ot = U.clientTop, ht = [B.left - nt, B.top - st];
      V = minus(calculateInversePosition(W.rootMatrix, ht, 4), [it + W.left, ot + W.top]);
    }
  }
  return __assign$1({
    targetClientRect: B,
    containerClientRect: U,
    moveableClientRect: $,
    rootContainerClientRect: H,
    beforeDirection: D,
    beforeOrigin: N,
    originalBeforeOrigin: N,
    target: t,
    style: X,
    offsetDelta: V
  }, W);
}
function getPersistState(o) {
  var t = o.pos1, e = o.pos2, r = o.pos3, S = o.pos4;
  if (!t || !e || !r || !S)
    return null;
  var T = getMinMaxs([t, e, r, S]), D = [T.minX, T.minY], N = minus(o.origin, D);
  return t = minus(t, D), e = minus(e, D), r = minus(r, D), S = minus(S, D), __assign$1(__assign$1({}, o), {
    left: o.left,
    top: o.top,
    posDelta: D,
    pos1: t,
    pos2: e,
    pos3: r,
    pos4: S,
    origin: N,
    beforeOrigin: N,
    // originalBeforeOrigin: origin,
    isPersisted: !0
  });
}
var MoveableManager$1 = /* @__PURE__ */ function(o) {
  __extends$1(t, o);
  function t() {
    var r = o !== null && o.apply(this, arguments) || this;
    return r.state = __assign$1({
      container: null,
      gestos: {},
      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],
      disableNativeEvent: !1,
      posDelta: [0, 0]
    }, getMoveableTargetInfo(null)), r.renderState = {}, r.enabledAbles = [], r.targetAbles = [], r.controlAbles = [], r.rotation = 0, r.scale = [1, 1], r.isMoveableMounted = !1, r.isUnmounted = !1, r.events = {
      mouseEnter: null,
      mouseLeave: null
    }, r._emitter = new EventEmitter$1(), r._prevTarget = null, r._prevDragArea = !1, r._isPropTargetChanged = !1, r._hasFirstTarget = !1, r._observer = null, r._observerId = 0, r._rootContainer = null, r._viewContainer = null, r._viewClassNames = [], r.checkUpdateRect = function() {
      if (!r.isDragging()) {
        var S = r.props.parentMoveable;
        if (S) {
          S.checkUpdateRect();
          return;
        }
        cancelAnimationFrame$1(r._observerId), r._observerId = requestAnimationFrame$1(function() {
          r.isDragging() || r.updateRect();
        });
      }
    }, r._onPreventClick = function(S) {
      S.stopPropagation(), S.preventDefault();
    }, r;
  }
  var e = t.prototype;
  return e.render = function() {
    var r = this.props, S = this.getState(), T = r.parentPosition, D = r.className, N = r.target, B = r.zoom, $ = r.cspNonce, U = r.translateZ, H = r.cssStyled, V = r.portalContainer, X = r.groupable;
    this._checkUpdateRootContainer(), this.checkUpdate(), this.updateRenderPoses();
    var W = T || [0, 0], Y = W[0], q = W[1], K = S.left, Z = S.top, J = S.target, Q = S.direction, rt = S.hasFixed, et = S.offsetDelta, nt = r.targets, st = this.isDragging(), it = {};
    this.getEnabledAbles().forEach(function(_t) {
      it["data-able-".concat(_t.name.toLowerCase())] = !0;
    });
    var ot = this._getAbleClassName(), ht = nt && nt.length && (J || X) || N || !this._hasFirstTarget && this.state.isPersisted, ct = this.controlBox || this.props.firstRenderState || this.props.persistData, vt = [K - Y, Z - q];
    return !X && r.useAccuratePosition && (vt[0] += et[0], vt[1] += et[1]), createElement(H, __assign$1({
      cspNonce: $,
      ref: ref(this, "controlBox"),
      className: "".concat(prefix("control-box", Q === -1 ? "reverse" : "", st ? "dragging" : ""), " ").concat(ot, " ").concat(D)
    }, it, {
      onClick: this._onPreventClick,
      portalContainer: V,
      style: {
        position: rt ? "fixed" : "absolute",
        display: ht ? "block" : "none",
        visibility: ct ? "visible" : "hidden",
        transform: "translate3d(".concat(vt[0], "px, ").concat(vt[1], "px, ").concat(U, ")"),
        "--zoom": B,
        "--zoompx": "".concat(B, "px")
      }
    }), this.renderAbles(), this._renderLines());
  }, e.componentDidMount = function() {
    this.isMoveableMounted = !0, this.isUnmounted = !1, this.controlBox.getElement();
    var r = this.props, S = r.parentMoveable, T = r.container, D = r.wrapperMoveable;
    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(this.props), !T && !S && !D && !this.state.isPersisted && (this.updateRect("", !1, !1), this.forceUpdate());
  }, e.componentDidUpdate = function(r) {
    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateNativeEvents(), this._updateEvents(), this._updateTargets(), this.updateCheckInput(), this._updateObserver(r);
  }, e.componentWillUnmount = function() {
    this.isMoveableMounted = !1, this.isUnmounted = !0, this._emitter.off();
    var r = this._viewContainer;
    r && this._changeAbleViewClassNames([]), unset(this, "targetGesto"), unset(this, "controlGesto");
    var S = this.events;
    for (var T in S) {
      var D = S[T];
      D && D.destroy();
    }
  }, e.getTargets = function() {
    var r = this.props.target;
    return r ? [r] : [];
  }, e.getAble = function(r) {
    var S = this.props.ables || [];
    return find$1(S, function(T) {
      return T.name === r;
    });
  }, e.getContainer = function() {
    var r = this.props, S = r.parentMoveable, T = r.wrapperMoveable, D = r.container;
    return D || T && T.getContainer() || S && S.getContainer() || this.controlBox.getElement().parentElement;
  }, e.isMoveableElement = function(r) {
    var S;
    return r && (((S = r.getAttribute) === null || S === void 0 ? void 0 : S.call(r, "class")) || "").indexOf(PREFIX) > -1;
  }, e.dragStart = function(r) {
    var S = this.targetGesto, T = this.controlGesto;
    return S && checkMoveableTarget(this)({
      inputEvent: r
    }) ? S.isFlag() || S.triggerDragStart(r) : T && this.isMoveableElement(r.target) && (T.isFlag() || T.triggerDragStart(r)), this;
  }, e.hitTest = function(r) {
    var S = this.state, T = S.target, D = S.pos1, N = S.pos2, B = S.pos3, $ = S.pos4, U = S.targetClientRect;
    if (!T)
      return 0;
    var H;
    if (r instanceof Element) {
      var V = r.getBoundingClientRect();
      H = {
        left: V.left,
        top: V.top,
        width: V.width,
        height: V.height
      };
    } else
      H = __assign$1({
        width: 0,
        height: 0
      }, r);
    var X = H.left, W = H.top, Y = H.width, q = H.height, K = fitPoints([D, N, $, B], U), Z = getOverlapSize(K, [[X, W], [X + Y, W], [X + Y, W + q], [X, W + q]]), J = getAreaSize(K);
    return !Z || !J ? 0 : Math.min(100, Z / J * 100);
  }, e.isInside = function(r, S) {
    var T = this.state, D = T.target, N = T.pos1, B = T.pos2, $ = T.pos3, U = T.pos4, H = T.targetClientRect;
    return D ? isInside([r, S], fitPoints([N, B, U, $], H)) : !1;
  }, e.updateRect = function(r, S, T) {
    T === void 0 && (T = !0);
    var D = this.props, N = D.parentMoveable, B = this.state, $ = B.target || this.props.target, U = this.getContainer(), H = N ? N._rootContainer : this._rootContainer, V = getMoveableTargetInfo(this.controlBox && this.controlBox.getElement(), $, U, U, H || U, this._getRequestStyles());
    if (!$ && this._hasFirstTarget && D.persistData) {
      var X = getPersistState(D.persistData);
      for (var W in X)
        V[W] = X[W];
    }
    this.updateState(V, N ? !1 : T);
  }, e.isDragging = function(r) {
    var S, T, D = this.targetGesto, N = this.controlGesto;
    if (D != null && D.isFlag()) {
      if (!r)
        return !0;
      var B = D.getEventData();
      return !!(!((S = B[r]) === null || S === void 0) && S.isEventStart);
    }
    if (N != null && N.isFlag()) {
      if (!r)
        return !0;
      var B = N.getEventData();
      return !!(!((T = B[r]) === null || T === void 0) && T.isEventStart);
    }
    return !1;
  }, e.updateTarget = function(r) {
    this.updateRect(r, !0);
  }, e.getRect = function() {
    var r = this.state, S = getAbsolutePosesByState(this.state), T = S[0], D = S[1], N = S[2], B = S[3], $ = getRect(S), U = r.width, H = r.height, V = $.width, X = $.height, W = $.left, Y = $.top, q = [r.left, r.top], K = plus(q, r.origin), Z = plus(q, r.beforeOrigin), J = r.transformOrigin;
    return {
      width: V,
      height: X,
      left: W,
      top: Y,
      pos1: T,
      pos2: D,
      pos3: N,
      pos4: B,
      offsetWidth: U,
      offsetHeight: H,
      beforeOrigin: Z,
      origin: K,
      transformOrigin: J,
      rotation: this.getRotation()
    };
  }, e.getManager = function() {
    return this;
  }, e.stopDrag = function(r) {
    var S, T;
    (!r || r === "target") && ((S = this.targetGesto) === null || S === void 0 || S.stop()), (!r || r === "control") && ((T = this.controlGesto) === null || T === void 0 || T.stop());
  }, e.getRotation = function() {
    var r = this.state, S = r.pos1, T = r.pos2, D = r.direction;
    return getAbsoluteRotation(S, T, D);
  }, e.request = function(r, S, T) {
    S === void 0 && (S = {});
    var D = this.props, N = D.ables, B = D.groupable, $ = N.filter(function(q) {
      return q.name === r;
    })[0];
    if (this.isDragging() || !$ || !$.request)
      return {
        request: function() {
          return this;
        },
        requestEnd: function() {
          return this;
        }
      };
    var U = this, H = $.request(this), V = T || S.isInstant, X = H.isControl ? "controlAbles" : "targetAbles", W = "".concat(B ? "Group" : "").concat(H.isControl ? "Control" : ""), Y = {
      request: function(q) {
        return triggerAble(U, X, "drag", W, "", __assign$1(__assign$1({}, H.request(q)), {
          requestAble: r,
          isRequest: !0
        }), V), this;
      },
      requestEnd: function() {
        return triggerAble(U, X, "drag", W, "End", __assign$1(__assign$1({}, H.requestEnd()), {
          requestAble: r,
          isRequest: !0
        }), V), this;
      }
    };
    return triggerAble(U, X, "drag", W, "Start", __assign$1(__assign$1({}, H.requestStart(S)), {
      requestAble: r,
      isRequest: !0
    }), V), V ? Y.request(S).requestEnd() : Y;
  }, e.destroy = function() {
    this.componentWillUnmount();
  }, e.updateRenderPoses = function() {
    var r = this.getState(), S = this.props, T = r.originalBeforeOrigin, D = r.transformOrigin, N = r.allMatrix, B = r.is3d, $ = r.pos1, U = r.pos2, H = r.pos3, V = r.pos4, X = r.left, W = r.top, Y = r.isPersisted, q = S.padding || {}, K = q.left, Z = K === void 0 ? 0 : K, J = q.top, Q = J === void 0 ? 0 : J, rt = q.bottom, et = rt === void 0 ? 0 : rt, nt = q.right, st = nt === void 0 ? 0 : nt, it = B ? 4 : 3, ot = [];
    Y ? ot = D : this.controlBox && S.groupable ? ot = T : ot = plus(T, [X, W]), r.renderPoses = [plus($, calculatePadding(N, [-Z, -Q], D, ot, it)), plus(U, calculatePadding(N, [st, -Q], D, ot, it)), plus(H, calculatePadding(N, [-Z, et], D, ot, it)), plus(V, calculatePadding(N, [st, et], D, ot, it))];
  }, e.checkUpdate = function() {
    this._isPropTargetChanged = !1;
    var r = this.props, S = r.target, T = r.container, D = r.parentMoveable, N = this.state, B = N.target, $ = N.container;
    if (!(!B && !S)) {
      this.updateAbles();
      var U = !equals(B, S), H = U || !equals($, T);
      if (H) {
        var V = T || this.controlBox;
        V && this.unsetAbles(), this.updateState({
          target: S,
          container: T
        }), !D && V && this.updateRect("End", !1, !1), this._isPropTargetChanged = U;
      }
    }
  }, e.waitToChangeTarget = function() {
    return new Promise(function() {
    });
  }, e.triggerEvent = function(r, S) {
    this._emitter.trigger(r, S);
    var T = this.props[r];
    return T && T(S);
  }, e.useCSS = function(r, S) {
    var T = this.props.customStyledMap, D = r + S;
    return T[D] || (T[D] = styled(r, S)), T[D];
  }, e.getState = function() {
    var r, S = this.props;
    (S.target || !((r = S.targets) === null || r === void 0) && r.length) && (this._hasFirstTarget = !0);
    var T = this.controlBox, D = S.persistData, N = S.firstRenderState;
    if (N && !T)
      return N;
    if (!this._hasFirstTarget && D) {
      var B = getPersistState(D);
      if (B)
        return this.updateState(B, !1), this.state;
    }
    return this.state.isPersisted = !1, this.state;
  }, e.updateSelectors = function() {
  }, e.unsetAbles = function() {
    var r = this;
    this.targetAbles.forEach(function(S) {
      S.unset && S.unset(r);
    });
  }, e.updateAbles = function(r, S) {
    r === void 0 && (r = this.props.ables), S === void 0 && (S = "");
    var T = this.props, D = T.triggerAblesSimultaneously, N = this.getEnabledAbles(r), B = "drag".concat(S, "Start"), $ = "pinch".concat(S, "Start"), U = "drag".concat(S, "ControlStart"), H = filterAbles(N, [B, $], D), V = filterAbles(N, [U], D);
    this.enabledAbles = N, this.targetAbles = H, this.controlAbles = V;
  }, e.updateState = function(r, S) {
    if (S) {
      if (this.isUnmounted)
        return;
      this.setState(r);
    } else {
      var T = this.state;
      for (var D in r)
        T[D] = r[D];
    }
  }, e.getEnabledAbles = function(r) {
    r === void 0 && (r = this.props.ables);
    var S = this.props;
    return r.filter(function(T) {
      return T && (T.always && S[T.name] !== !1 || S[T.name]);
    });
  }, e.renderAbles = function() {
    var r = this, S = this.props, T = S.triggerAblesSimultaneously, D = {
      createElement
    };
    return this.renderState = {}, groupByMap(flat(filterAbles(this.getEnabledAbles(), ["render"], T).map(function(N) {
      var B = N.render;
      return B(r, D) || [];
    })).filter(function(N) {
      return N;
    }), function(N) {
      var B = N.key;
      return B;
    }).map(function(N) {
      return N[0];
    });
  }, e.updateCheckInput = function() {
    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);
  }, e._getRequestStyles = function() {
    var r = this.getEnabledAbles().reduce(function(S, T) {
      var D, N, B = (N = (D = T.requestStyle) === null || D === void 0 ? void 0 : D.call(T)) !== null && N !== void 0 ? N : [];
      return __spreadArray(__spreadArray([], S, !0), B, !0);
    }, []);
    return r;
  }, e._updateObserver = function(r) {
    var S, T = this.props, D = T.target;
    if (!window.ResizeObserver || !D || !T.useResizeObserver) {
      (S = this._observer) === null || S === void 0 || S.disconnect();
      return;
    }
    if (!(r.target === D && this._observer)) {
      var N = new ResizeObserver(this.checkUpdateRect);
      N.observe(D, {
        box: "border-box"
      }), this._observer = N;
    }
  }, e._updateEvents = function() {
    var r = this.controlBox.getElement(), S = this.targetAbles.length, T = this.controlAbles.length, D = this.props, N = D.dragTarget || D.target, B = !S && this.targetGesto || this._isTargetChanged(!0);
    B && (unset(this, "targetGesto"), this.updateState({
      gesto: null
    })), T || unset(this, "controlGesto"), N && S && !this.targetGesto && (this.targetGesto = getTargetAbleGesto(this, N, "")), !this.controlGesto && T && (this.controlGesto = getAbleGesto(this, r, "controlAbles", "Control"));
  }, e._updateTargets = function() {
    var r = this.props;
    this._prevTarget = r.dragTarget || r.target, this._prevDragArea = r.dragArea;
  }, e._renderLines = function() {
    var r = this.props, S = r, T = S.zoom, D = S.hideDefaultLines, N = S.hideChildMoveableDefaultLines, B = S.parentMoveable;
    if (D || B && N)
      return [];
    var $ = this.getState().renderPoses, U = {
      createElement
    };
    return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(H, V) {
      var X = H[0], W = H[1];
      return renderLine(U, "", $[X], $[W], T, "render-line-".concat(V));
    });
  }, e._isTargetChanged = function(r) {
    var S = this.props, T = S.dragTarget || S.target, D = this._prevTarget, N = this._prevDragArea, B = S.dragArea, $ = !B && D !== T, U = (r || B) && N !== B;
    return $ || U;
  }, e._updateNativeEvents = function() {
    var r = this, S = this.props, T = S.dragArea ? this.areaElement : this.state.target, D = this.events, N = getKeys(D);
    if (this._isTargetChanged())
      for (var B in D) {
        var $ = D[B];
        $ && $.destroy(), D[B] = null;
      }
    if (T) {
      var U = this.enabledAbles;
      N.forEach(function(H) {
        var V = filterAbles(U, [H]), X = V.length > 0, W = D[H];
        if (!X) {
          W && (W.destroy(), D[H] = null);
          return;
        }
        W || (W = new EventManager(T, r, H), D[H] = W), W.setAbles(V);
      });
    }
  }, e._checkUpdateRootContainer = function() {
    var r = this.props.rootContainer;
    !this._rootContainer && r && (this._rootContainer = getRefTarget(r, !0));
  }, e._checkUpdateViewContainer = function() {
    var r = this.props.viewContainer;
    !this._viewContainer && r && (this._viewContainer = getRefTarget(r, !0));
    var S = this._viewContainer;
    S && this._changeAbleViewClassNames(__spreadArray(__spreadArray([], this._getAbleViewClassNames(), !0), [this.isDragging() ? VIEW_DRAGGING : ""], !1));
  }, e._changeAbleViewClassNames = function(r) {
    var S = this._viewContainer, T = groupBy(r.filter(Boolean), function(U) {
      return U;
    }).map(function(U) {
      var H = U[0];
      return H;
    }), D = this._viewClassNames, N = diff$1(D, T), B = N.removed, $ = N.added;
    B.forEach(function(U) {
      removeClass(S, D[U]);
    }), $.forEach(function(U) {
      addClass(S, T[U]);
    }), this._viewClassNames = T;
  }, e._getAbleViewClassNames = function() {
    var r = this;
    return (this.getEnabledAbles().map(function(S) {
      var T;
      return ((T = S.viewClassName) === null || T === void 0 ? void 0 : T.call(S, r)) || "";
    }).join(" ") + " ".concat(this._getAbleClassName("-view"))).split(/\s+/g);
  }, e._getAbleClassName = function(r) {
    var S = this;
    r === void 0 && (r = "");
    var T = this.getEnabledAbles(), D = this.targetGesto, N = this.controlGesto, B = D != null && D.isFlag() ? D.getEventData() : {}, $ = N != null && N.isFlag() ? N.getEventData() : {};
    return T.map(function(U) {
      var H, V, X, W = U.name, Y = ((H = U.className) === null || H === void 0 ? void 0 : H.call(U, S)) || "";
      return (!((V = B[W]) === null || V === void 0) && V.isEventStart || !((X = $[W]) === null || X === void 0) && X.isEventStart) && (Y += " ".concat(prefix("".concat(W).concat(r, "-dragging")))), Y.trim();
    }).filter(Boolean).join(" ");
  }, t.defaultProps = {
    target: null,
    dragTarget: null,
    container: null,
    rootContainer: null,
    origin: !0,
    parentMoveable: null,
    wrapperMoveable: null,
    isWrapperMounted: !1,
    parentPosition: null,
    portalContainer: null,
    useResizeObserver: !1,
    ables: [],
    pinchThreshold: 20,
    dragArea: !1,
    passDragArea: !1,
    transformOrigin: "",
    className: "",
    zoom: 1,
    triggerAblesSimultaneously: !1,
    padding: {},
    pinchOutside: !0,
    checkInput: !1,
    groupable: !1,
    hideDefaultLines: !1,
    cspNonce: "",
    translateZ: 0,
    cssStyled: null,
    customStyledMap: {},
    props: {},
    stopPropagation: !1,
    preventClickDefault: !1,
    preventClickEventOnDrag: !0,
    flushSync: defaultSync,
    firstRenderState: null,
    persistData: null,
    viewContainer: null,
    useAccuratePosition: !1
  }, t;
}(PureComponent), Groupable = {
  name: "groupable",
  props: {
    defaultGroupRotate: Number,
    defaultGroupOrigin: String,
    groupable: Boolean,
    groupableProps: Object,
    targetGroups: Object,
    hideChildMoveableDefaultLines: Boolean
  },
  events: {},
  render: function(o, t) {
    var e, r = o.props, S = r.targets || [];
    o.moveables = [];
    var T = o.getState(), D = T.left, N = T.top, B = T.isPersisted, $ = [D, N], U = r.zoom || 1, H = o.renderGroupRects, V = ((e = r.persistData) === null || e === void 0 ? void 0 : e.children) || [];
    return B ? S = V.map(function() {
      return null;
    }) : V = [], __spreadArray(__spreadArray([], S.map(function(X, W) {
      return t.createElement(MoveableManager$1, {
        key: "moveable" + W,
        ref: refs(o, "moveables", W),
        target: X,
        origin: !1,
        cssStyled: r.cssStyled,
        customStyledMap: r.customStyledMap,
        useResizeObserver: r.useResizeObserver,
        hideChildMoveableDefaultLines: r.hideChildMoveableDefaultLines,
        parentMoveable: o,
        parentPosition: $,
        persistData: V[W],
        zoom: U
      });
    }), !0), flat(H.map(function(X, W) {
      var Y = X.pos1, q = X.pos2, K = X.pos3, Z = X.pos4, J = [Y, q, K, Z];
      return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(Q, rt) {
        var et = Q[0], nt = Q[1];
        return renderLine(t, "", minus(J[et], $), minus(J[nt], $), U, "group-rect-".concat(W, "-").concat(rt));
      });
    })), !0);
  }
}, Clickable = makeAble("clickable", {
  props: {
    clickable: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  always: !0,
  dragRelation: "weak",
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  dragStart: function() {
  },
  dragControlStart: function() {
  },
  dragGroupStart: function(o, t) {
    t.datas.inputTarget = t.inputEvent && t.inputEvent.target;
  },
  dragEnd: function(o, t) {
    var e = o.props.target, r = t.inputEvent, S = t.inputTarget, T = o.isMoveableElement(S), D = !T && o.controlBox.getElement().contains(S);
    if (!(!r || !S || t.isDrag || o.isMoveableElement(S) || D)) {
      var N = e.contains(S);
      triggerEvent(o, "onClick", fillParams(o, t, {
        isDouble: t.isDouble,
        inputTarget: S,
        isTarget: e === S,
        moveableTarget: o.props.target,
        containsTarget: N
      }));
    }
  },
  dragGroupEnd: function(o, t) {
    var e = t.inputEvent, r = t.inputTarget;
    if (!(!e || !r || t.isDrag || o.isMoveableElement(r) || t.datas.inputTarget === r)) {
      var S = o.props.targets, T = S.indexOf(r), D = T > -1, N = !1;
      T === -1 && (T = findIndex(S, function(B) {
        return B.contains(r);
      }), N = T > -1), triggerEvent(o, "onClickGroup", fillParams(o, t, {
        isDouble: t.isDouble,
        targets: S,
        inputTarget: r,
        targetIndex: T,
        isTarget: D,
        containsTarget: N,
        moveableTarget: S[T]
      }));
    }
  },
  dragControlEnd: function(o, t) {
    this.dragEnd(o, t);
  },
  dragGroupControlEnd: function(o, t) {
    this.dragEnd(o, t);
  }
});
function getDraggableEvent(o) {
  var t = o.originalDatas.draggable;
  return t || (o.originalDatas.draggable = {}, t = o.originalDatas.draggable), __assign$1(__assign$1({}, o), {
    datas: t
  });
}
var edgeDraggable = makeAble("edgeDraggable", {
  css: [`.edge.edgeDraggable.line {
    cursor: move;
}`],
  render: function(o, t) {
    var e = o.props, r = e.edgeDraggable;
    return r ? renderEdgeLines(t, "edgeDraggable", r, o.getState().renderPoses, e.zoom) : [];
  },
  dragCondition: function(o, t) {
    var e, r = o.props, S = (e = t.inputEvent) === null || e === void 0 ? void 0 : e.target;
    return !r.edgeDraggable || !S ? !1 : !r.draggable && hasClass(S, prefix("direction")) && hasClass(S, prefix("edge")) && hasClass(S, prefix("edgeDraggable"));
  },
  dragStart: function(o, t) {
    return Draggable.dragStart(o, getDraggableEvent(t));
  },
  drag: function(o, t) {
    return Draggable.drag(o, getDraggableEvent(t));
  },
  dragEnd: function(o, t) {
    return Draggable.dragEnd(o, getDraggableEvent(t));
  },
  dragGroupCondition: function(o, t) {
    var e, r = o.props, S = (e = t.inputEvent) === null || e === void 0 ? void 0 : e.target;
    return !r.edgeDraggable || !S ? !1 : !r.draggable && hasClass(S, prefix("direction")) && hasClass(S, prefix("line"));
  },
  dragGroupStart: function(o, t) {
    return Draggable.dragGroupStart(o, getDraggableEvent(t));
  },
  dragGroup: function(o, t) {
    return Draggable.dragGroup(o, getDraggableEvent(t));
  },
  dragGroupEnd: function(o, t) {
    return Draggable.dragGroupEnd(o, getDraggableEvent(t));
  },
  unset: function(o) {
    return Draggable.unset(o);
  }
}), IndividualGroupable = {
  name: "individualGroupable",
  props: {
    individualGroupable: Boolean
  },
  events: {}
}, MOVEABLE_ABLES = [BeforeRenderable, Default, Snappable, Pinchable, Draggable, edgeDraggable, Resizable, Scalable, Warpable, Rotatable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable], MOVEABLE_EVENTS_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(o, t) {
  return __assign$1(__assign$1({}, o), "events" in t ? t.events : {});
}, {}), MOVEABLE_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(o, t) {
  return __assign$1(__assign$1({}, o), t.props);
}, {}), MOVEABLE_EVENTS_MAP = /* @__PURE__ */ invertObject(MOVEABLE_EVENTS_PROPS_MAP), MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP), MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);
function solveConstantsDistance(o, t) {
  var e = o[0], r = o[1], S = o[2];
  return (e * t[0] + r * t[1] + S) / Math.sqrt(e * e + r * r);
}
function solveC(o, t) {
  var e = o[0], r = o[1];
  return -e * t[0] - r * t[1];
}
function getMaxPos(o, t) {
  return Math.max.apply(Math, o.map(function(e) {
    var r = e[0], S = e[1], T = e[2], D = e[3];
    return Math.max(r[t], S[t], T[t], D[t]);
  }));
}
function getMinPos(o, t) {
  return Math.min.apply(Math, o.map(function(e) {
    var r = e[0], S = e[1], T = e[2], D = e[3];
    return Math.min(r[t], S[t], T[t], D[t]);
  }));
}
function getGroupRect(o, t) {
  var e, r = [0, 0], S = [0, 0], T = [0, 0], D = [0, 0], N = 0, B = 0;
  if (!o.length)
    return {
      pos1: r,
      pos2: S,
      pos3: T,
      pos4: D,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: N,
      height: B,
      rotation: t
    };
  var $ = throttle(t, TINY_NUM);
  if ($ % 90) {
    var U = $ / 180 * Math.PI, H = Math.tan(U), V = -1 / H, X = [MAX_NUM, MIN_NUM], W = [[0, 0], [0, 0]], Y = [MAX_NUM, MIN_NUM], q = [[0, 0], [0, 0]];
    o.forEach(function(xt) {
      xt.forEach(function(pt) {
        var yt = solveConstantsDistance([-H, 1, 0], pt), Dt = solveConstantsDistance([-V, 1, 0], pt);
        X[0] > yt && (W[0] = pt, X[0] = yt), X[1] < yt && (W[1] = pt, X[1] = yt), Y[0] > Dt && (q[0] = pt, Y[0] = Dt), Y[1] < Dt && (q[1] = pt, Y[1] = Dt);
      });
    });
    var K = W[0], Z = W[1], J = q[0], Q = q[1], rt = [-H, 1, solveC([-H, 1], K)], et = [-H, 1, solveC([-H, 1], Z)], nt = [-V, 1, solveC([-V, 1], J)], st = [-V, 1, solveC([-V, 1], Q)];
    e = [[rt, nt], [rt, st], [et, nt], [et, st]].map(function(xt) {
      var pt = xt[0], yt = xt[1];
      return getIntersectionPointsByConstants(pt, yt)[0];
    }), r = e[0], S = e[1], T = e[2], D = e[3], N = Y[1] - Y[0], B = X[1] - X[0];
  } else {
    var it = getMinPos(o, 0), ot = getMinPos(o, 1), ht = getMaxPos(o, 0), ct = getMaxPos(o, 1);
    if (r = [it, ot], S = [ht, ot], T = [it, ct], D = [ht, ct], N = ht - it, B = ct - ot, $ % 180) {
      var vt = [T, r, D, S];
      r = vt[0], S = vt[1], T = vt[2], D = vt[3], N = ct - ot, B = ht - it;
    }
  }
  if ($ % 360 > 180) {
    var vt = [D, T, S, r];
    r = vt[0], S = vt[1], T = vt[2], D = vt[3];
  }
  var _t = getMinMaxs([r, S, T, D]), gt = _t.minX, mt = _t.minY, Et = _t.maxX, wt = _t.maxY;
  return {
    pos1: r,
    pos2: S,
    pos3: T,
    pos4: D,
    width: N,
    height: B,
    minX: gt,
    minY: mt,
    maxX: Et,
    maxY: wt,
    rotation: t
  };
}
function findMoveableGroups(o, t) {
  var e = t.map(function(r) {
    if (isArray(r)) {
      var S = findMoveableGroups(o, r), T = S.length;
      return T > 1 ? S : T === 1 ? S[0] : null;
    } else {
      var D = find$1(o, function(N) {
        var B = N.manager;
        return B.props.target === r;
      });
      return D ? (D.finded = !0, D.manager) : null;
    }
  }).filter(Boolean);
  return e.length === 1 && isArray(e[0]) ? e[0] : e;
}
var MoveableGroup = /* @__PURE__ */ function(o) {
  __extends$1(t, o);
  function t() {
    var r = o !== null && o.apply(this, arguments) || this;
    return r.differ = new ChildrenDiffer$1(), r.moveables = [], r.transformOrigin = "50% 50%", r.renderGroupRects = [], r._targetGroups = [], r._hasFirstTargets = !1, r;
  }
  var e = t.prototype;
  return e.componentDidMount = function() {
    o.prototype.componentDidMount.call(this);
  }, e.checkUpdate = function() {
    this._isPropTargetChanged = !1, this.updateAbles();
  }, e.getTargets = function() {
    return this.props.targets;
  }, e.updateRect = function(r, S, T) {
    var D;
    T === void 0 && (T = !0);
    var N = this.state;
    if (!this.controlBox || N.isPersisted)
      return;
    this.moveables.forEach(function(Mt) {
      Mt.updateRect(r, !1, !1);
    });
    var B = this.props, $ = this.moveables, U = N.target || B.target, H = $.map(function(Mt) {
      return {
        finded: !1,
        manager: Mt
      };
    }), V = this.props.targetGroups || [], X = findMoveableGroups(H, V);
    X.push.apply(X, H.filter(function(Mt) {
      var zt = Mt.finded;
      return !zt;
    }).map(function(Mt) {
      var zt = Mt.manager;
      return zt;
    }));
    var W = [], Y = !S || r !== "" && B.updateGroup, q = B.defaultGroupRotate || 0;
    if (!this._hasFirstTargets) {
      var K = (D = this.props.persistData) === null || D === void 0 ? void 0 : D.rotation;
      K != null && (q = K);
    }
    function Z(Mt, zt, Nt) {
      var St = Mt.map(function(Wt) {
        if (isArray(Wt)) {
          var Jt = Z(Wt, zt), qt = [Jt.pos1, Jt.pos2, Jt.pos3, Jt.pos4];
          return W.push(Jt), {
            poses: qt,
            rotation: Jt.rotation
          };
        } else
          return {
            poses: getAbsolutePosesByState(Wt.state),
            rotation: Wt.getRotation()
          };
      }), Ht = St.map(function(Wt) {
        var Jt = Wt.rotation;
        return Jt;
      }), Lt = 0, Tt = Ht[0], kt = Ht.every(function(Wt) {
        return Math.abs(Tt - Wt) < 0.1;
      });
      Y ? Lt = kt ? Tt : q : Lt = !Nt && kt ? Tt : zt;
      var Ut = St.map(function(Wt) {
        var Jt = Wt.poses;
        return Jt;
      }), Ct = getGroupRect(Ut, Lt);
      return Ct;
    }
    var J = Z(X, this.rotation, !0);
    Y && (this.rotation = J.rotation, this.transformOrigin = B.defaultGroupOrigin || "50% 50%", this.scale = [1, 1]), this._targetGroups = V, this.renderGroupRects = W;
    var Q = this.transformOrigin, rt = this.rotation, et = this.scale, nt = J.width, st = J.height, it = J.minX, ot = J.minY, ht = rotatePosesInfo([[0, 0], [nt, 0], [0, st], [nt, st]], convertTransformOriginArray(Q, nt, st), this.rotation / 180 * Math.PI), ct = getMinMaxs(ht.result), vt = ct.minX, _t = ct.minY, gt = " rotate(".concat(rt, "deg)") + " scale(".concat(et[0] >= 0 ? 1 : -1, ", ").concat(et[1] >= 0 ? 1 : -1, ")"), mt = "translate(".concat(-vt, "px, ").concat(-_t, "px)").concat(gt);
    this.controlBox.getElement().style.transform = "translate3d(".concat(it, "px, ").concat(ot, "px, ").concat(this.props.translateZ || 0, ")"), U.style.cssText += "left:0px;top:0px;" + "transform-origin:".concat(Q, ";") + "width:".concat(nt, "px;height:").concat(st, "px;") + "transform: ".concat(mt), N.width = nt, N.height = st;
    var Et = this.getContainer(), wt = getMoveableTargetInfo(this.controlBox.getElement(), U, this.controlBox.getElement(), this.getContainer(), this._rootContainer || Et, []), xt = [wt.left, wt.top], pt = getAbsolutePosesByState(wt), yt = pt[0], Dt = pt[1], At = pt[2], It = pt[3], Ot = getMinMaxs([yt, Dt, At, It]), ft = [Ot.minX, Ot.minY], Ft = et[0] * et[1] > 0 ? 1 : -1;
    wt.pos1 = minus(yt, ft), wt.pos2 = minus(Dt, ft), wt.pos3 = minus(At, ft), wt.pos4 = minus(It, ft), wt.left = it - wt.left + ft[0], wt.top = ot - wt.top + ft[1], wt.origin = minus(plus(xt, wt.origin), ft), wt.beforeOrigin = minus(plus(xt, wt.beforeOrigin), ft), wt.originalBeforeOrigin = plus(xt, wt.originalBeforeOrigin), wt.transformOrigin = minus(plus(xt, wt.transformOrigin), ft), U.style.transform = "translate(".concat(-vt - ft[0], "px, ").concat(-_t - ft[1], "px)") + gt, this.updateState(__assign$1(__assign$1({}, wt), {
      posDelta: ft,
      direction: Ft,
      beforeDirection: Ft
    }), T);
  }, e.getRect = function() {
    return __assign$1(__assign$1({}, o.prototype.getRect.call(this)), {
      children: this.moveables.map(function(r) {
        return r.getRect();
      })
    });
  }, e.triggerEvent = function(r, S, T) {
    if (T || r.indexOf("Group") > -1)
      return o.prototype.triggerEvent.call(this, r, S);
    this._emitter.trigger(r, S);
  }, e.updateAbles = function() {
    o.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], this.props.ables, !0), [Groupable], !1), "Group");
  }, e._updateTargets = function() {
    o.prototype._updateTargets.call(this), this._prevTarget = this.props.dragTarget || this.areaElement;
  }, e._updateEvents = function() {
    var r = this.state, S = this.props, T = this._prevTarget, D = S.dragTarget || this.areaElement;
    T !== D && (unset(this, "targetGesto"), unset(this, "controlGesto"), r.target = null), r.target || (r.target = this.areaElement, this.controlBox.getElement().style.display = "block"), r.target && (this.targetGesto || (this.targetGesto = getTargetAbleGesto(this, D, "Group")), this.controlGesto || (this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), "controlAbles", "GroupControl")));
    var N = !equals(r.container, S.container);
    N && (r.container = S.container);
    var B = S.targets, $ = this.differ.update(B), U = $.added, H = $.changed, V = $.removed, X = U.length || V.length;
    (N || X || H.length || B.length && !isDeepArrayEquals(this._targetGroups, S.targetGroups || [])) && (this.updateRect(), this._hasFirstTargets = !0), this._isPropTargetChanged = !!X;
  }, e._updateObserver = function() {
  }, t.defaultProps = __assign$1(__assign$1({}, MoveableManager$1.defaultProps), {
    transformOrigin: ["50%", "50%"],
    groupable: !0,
    dragArea: !0,
    keepRatio: !0,
    targets: [],
    defaultGroupRotate: 0,
    defaultGroupOrigin: "50% 50%"
  }), t;
}(MoveableManager$1), MoveableIndividualGroup = /* @__PURE__ */ function(o) {
  __extends$1(t, o);
  function t() {
    var r = o !== null && o.apply(this, arguments) || this;
    return r.moveables = [], r;
  }
  var e = t.prototype;
  return e.render = function() {
    var r = this, S, T = this.props, D = T.cspNonce, N = T.cssStyled, B = T.persistData, $ = T.targets || [], U = $.length, H = this.isUnmounted || !U, V = (S = B == null ? void 0 : B.children) !== null && S !== void 0 ? S : [];
    return H && !U && V.length ? $ = V.map(function() {
      return null;
    }) : H || (V = []), createElement(N, {
      cspNonce: D,
      ref: ref(this, "controlBox"),
      className: prefix("control-box")
    }, $.map(function(X, W) {
      return createElement(MoveableManager$1, __assign$1({
        key: "moveable" + W,
        ref: refs(r, "moveables", W)
      }, r.props, {
        target: X,
        wrapperMoveable: r,
        isWrapperMounted: r.isMoveableMounted,
        persistData: V[W]
      }));
    }));
  }, e.componentDidUpdate = function() {
  }, e.getTargets = function() {
    return this.props.targets;
  }, e.updateRect = function(r, S, T) {
    T === void 0 && (T = !0), this.moveables.forEach(function(D) {
      D.updateRect(r, S, T);
    });
  }, e.getRect = function() {
    return __assign$1(__assign$1({}, o.prototype.getRect.call(this)), {
      children: this.moveables.map(function(r) {
        return r.getRect();
      })
    });
  }, e.request = function() {
    return {
      request: function() {
        return this;
      },
      requestEnd: function() {
        return this;
      }
    };
  }, e.dragStart = function() {
    return this;
  }, e.hitTest = function() {
    return 0;
  }, e.isInside = function() {
    return !1;
  }, e.isDragging = function() {
    return !1;
  }, e.updateRenderPoses = function() {
  }, e.checkUpdate = function() {
  }, e.triggerEvent = function() {
  }, e.updateAbles = function() {
  }, e._updateEvents = function() {
  }, e._updateObserver = function() {
  }, t;
}(MoveableManager$1);
function getElementTargets(o, t) {
  var e = [];
  return o.forEach(function(r) {
    if (r) {
      if (isString$1(r)) {
        t[r] && e.push.apply(e, t[r]);
        return;
      }
      isArray(r) ? e.push.apply(e, getElementTargets(r, t)) : e.push(r);
    }
  }), e;
}
function getTargetGroups(o, t) {
  var e = [];
  return o.forEach(function(r) {
    if (r) {
      if (isString$1(r)) {
        t[r] && e.push.apply(e, t[r]);
        return;
      }
      isArray(r) ? e.push(getTargetGroups(r, t)) : e.push(r);
    }
  }), e;
}
function compareRefTargets(o, t) {
  return o.length !== t.length || o.some(function(e, r) {
    var S = t[r];
    return !e && !S ? !1 : e != S ? isArray(e) && isArray(S) ? compareRefTargets(e, S) : !0 : !1;
  });
}
var InitialMoveable = /* @__PURE__ */ function(o) {
  __extends$1(t, o);
  function t() {
    var r = o !== null && o.apply(this, arguments) || this;
    return r.refTargets = [], r.selectorMap = {}, r._differ = new ChildrenDiffer$1(), r._elementTargets = [], r._onChangeTargets = null, r;
  }
  var e = t.prototype;
  return t.makeStyled = function() {
    var r = {}, S = this.getTotalAbles();
    S.forEach(function(D) {
      var N = D.css;
      N && N.forEach(function(B) {
        r[B] = !0;
      });
    });
    var T = getKeys(r).join(`
`);
    this.defaultStyled = styled("div", prefixCSS(PREFIX, MOVEABLE_CSS + T));
  }, t.getTotalAbles = function() {
    return __spreadArray([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles, !0);
  }, e.render = function() {
    var r, S = this.constructor;
    S.defaultStyled || S.makeStyled();
    var T = this.props, D = T.ables, N = T.props, B = __rest(T, ["ables", "props"]), $ = this._updateRefs(!0), U = getElementTargets($, this.selectorMap), H = U.length > 1, V = S.getTotalAbles(), X = __spreadArray(__spreadArray([], V, !0), D || [], !0), W = __assign$1(__assign$1(__assign$1({}, B), N || {}), {
      ables: X,
      cssStyled: S.defaultStyled,
      customStyledMap: S.customStyledMap
    });
    this._elementTargets = U;
    var Y = null, q = this.moveable, K = B.persistData;
    if (K != null && K.children && (H = !0), H) {
      if (B.individualGroupable)
        return createElement(MoveableIndividualGroup, __assign$1({
          key: "individual-group",
          ref: ref(this, "moveable")
        }, W, {
          target: null,
          targets: U
        }));
      var Z = getTargetGroups($, this.selectorMap);
      if (q && !q.props.groupable && !q.props.individualGroupable) {
        var J = q.props.target;
        J && U.indexOf(J) > -1 && (Y = __assign$1({}, q.state));
      }
      return createElement(MoveableGroup, __assign$1({
        key: "group",
        ref: ref(this, "moveable")
      }, W, (r = B.groupableProps) !== null && r !== void 0 ? r : {}, {
        target: null,
        targets: U,
        targetGroups: Z,
        firstRenderState: Y
      }));
    } else {
      var Q = U[0];
      if (q && (q.props.groupable || q.props.individualGroupable)) {
        var rt = q.moveables || [], et = find$1(rt, function(nt) {
          return nt.props.target === Q;
        });
        et && (Y = __assign$1({}, et.state));
      }
      return createElement(MoveableManager$1, __assign$1({
        key: "single",
        ref: ref(this, "moveable")
      }, W, {
        target: Q,
        firstRenderState: Y
      }));
    }
  }, e.componentDidMount = function() {
    this._checkChangeTargets(), this._updateRefs();
  }, e.componentDidUpdate = function() {
    this._checkChangeTargets();
  }, e.componentWillUnmount = function() {
    this.selectorMap = {}, this.refTargets = [];
  }, e.getTargets = function() {
    var r, S;
    return (S = (r = this.moveable) === null || r === void 0 ? void 0 : r.getTargets()) !== null && S !== void 0 ? S : [];
  }, e.updateSelectors = function() {
    this.selectorMap = {}, this._updateRefs();
  }, e.waitToChangeTarget = function() {
    var r = this, S;
    return this._onChangeTargets = function() {
      r._onChangeTargets = null, S();
    }, new Promise(function(T) {
      S = T;
    });
  }, e.waitToChangeTargets = function() {
    return this.waitToChangeTarget();
  }, e.getManager = function() {
    return this.moveable;
  }, e._updateRefs = function(r) {
    var S = this.refTargets, T = getRefTargets(this.props.target || this.props.targets), D = typeof document < "u", N = compareRefTargets(S, T), B = this.selectorMap, $ = {};
    return this.refTargets.forEach(function U(H) {
      if (isString$1(H)) {
        var V = B[H];
        V ? $[H] = B[H] : D && (N = !0, $[H] = [].slice.call(document.querySelectorAll(H)));
      } else
        isArray(H) && H.forEach(U);
    }), this.refTargets = T, this.selectorMap = $, !r && N && this.forceUpdate(), T;
  }, e._checkChangeTargets = function() {
    var r, S, T, D = this._differ.update(this._elementTargets), N = D.added, B = D.removed, $ = N.length || B.length;
    $ && ((S = (r = this.props).onChangeTargets) === null || S === void 0 || S.call(r, {
      moveable: this.moveable,
      targets: this._elementTargets
    }), (T = this._onChangeTargets) === null || T === void 0 || T.call(this)), this._updateRefs();
  }, t.defaultAbles = [], t.customStyledMap = {}, t.defaultStyled = null, __decorate$1([withMethods(MOVEABLE_METHODS)], t.prototype, "moveable", void 0), t;
}(PureComponent), Moveable$1 = /* @__PURE__ */ function(o) {
  __extends$1(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  return t.defaultAbles = MOVEABLE_ABLES, t;
}(InitialMoveable), Moveable$2 = Moveable$1;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(o, t) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var S in r)
      r.hasOwnProperty(S) && (e[S] = r[S]);
  }, extendStatics(o, t);
};
function __extends(o, t) {
  extendStatics(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var e, r = 1, S = arguments.length; r < S; r++) {
      e = arguments[r];
      for (var T in e)
        Object.prototype.hasOwnProperty.call(e, T) && (t[T] = e[T]);
    }
    return t;
  }, __assign.apply(this, arguments);
};
function __decorate(o, t, e, r) {
  var S = arguments.length, T = S < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, D;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    T = Reflect.decorate(o, t, e, r);
  else
    for (var N = o.length - 1; N >= 0; N--)
      (D = o[N]) && (T = (S < 3 ? D(T) : S > 3 ? D(t, e, T) : D(t, e)) || T);
  return S > 3 && T && Object.defineProperty(t, e, T), T;
}
var InnerMoveable = /* @__PURE__ */ function(o) {
  __extends(t, o);
  function t(r) {
    var S = o.call(this, r) || this;
    return S.state = {}, S.state = S.props, S;
  }
  var e = t.prototype;
  return e.render = function() {
    return createPortal(createElement(Moveable$2, __assign({
      ref: ref(this, "moveable")
    }, this.state)), this.state.parentElement);
  }, t;
}(Component), PROPERTIES = MOVEABLE_PROPS, METHODS = MOVEABLE_METHODS, EVENTS = MOVEABLE_EVENTS, MoveableManager = /* @__PURE__ */ function(o) {
  __extends(t, o);
  function t(r, S) {
    S === void 0 && (S = {});
    var T = o.call(this) || this;
    T.tempElement = document.createElement("div");
    var D = __assign({}, S), N = {};
    EVENTS.forEach(function($) {
      N[camelize("on ".concat($))] = function(U) {
        return T.trigger($, U);
      };
    }), render(createElement(InnerMoveable, __assign({
      ref: ref(T, "innerMoveable"),
      parentElement: r
    }, D, N)), T.tempElement);
    var B = D.target;
    return isArray(B) && B.length > 1 && T.updateRect(), T;
  }
  var e = t.prototype;
  return e.setState = function(r, S) {
    this.innerMoveable.setState(r, S);
  }, e.forceUpdate = function(r) {
    this.innerMoveable.forceUpdate(r);
  }, e.dragStart = function(r) {
    var S = this.innerMoveable;
    S.$_timer && this.forceUpdate(), this.getMoveable().dragStart(r);
  }, e.destroy = function() {
    render(null, this.tempElement), this.off(), this.tempElement = null, this.innerMoveable = null;
  }, e.getMoveable = function() {
    return this.innerMoveable.moveable;
  }, t = __decorate([Properties(METHODS, function(r, S) {
    r[S] || (r[S] = function() {
      for (var T = [], D = 0; D < arguments.length; D++)
        T[D] = arguments[D];
      var N = this.getMoveable();
      if (!(!N || !N[S]))
        return N[S].apply(N, T);
    });
  }), Properties(PROPERTIES, function(r, S) {
    Object.defineProperty(r, S, {
      get: function() {
        return this.getMoveable().props[S];
      },
      set: function(T) {
        var D;
        this.setState((D = {}, D[S] = T, D));
      },
      enumerable: !0,
      configurable: !0
    });
  })], t), t;
}(EventEmitter$1), Moveable = /* @__PURE__ */ function(o) {
  __extends(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  return t;
}(MoveableManager), $r, $s, Gs, Us, js, Co, gn, mn, Po, tf;
const jt = class {
  constructor(t, e = !1) {
    // divでmovを更新
    tt(this, Po);
    Pt(this, "hArg", {});
    Pt(this, "id_tag", "");
    Pt(this, "hDesignArg", {
      rotation: 0,
      pivot_x: 0,
      pivot_y: 0,
      left: 0,
      center: 0,
      right: 0,
      s_right: 0,
      top: 0,
      middle: 0,
      bottom: 0,
      s_bottom: 0,
      width: 0,
      height: 0
    });
    Pt(this, "child");
    Pt(this, "parent");
    Pt(this, "fncLay", () => {
    });
    Pt(this, "mov");
    Pt(this, "div");
    Pt(this, "lx", 0);
    // これ以後の this変数スケールは SKYNovel スクリプト値
    Pt(this, "ly", 0);
    Pt(this, "rect", Rectangle.EMPTY);
    // cvsResizeBaseやhint座標など計算用
    Pt(this, "pivot", new Point(0, 0));
    Pt(this, "scale", new Point(1, 1));
    Pt(this, "rotation", 0);
    Pt(this, "oldFn", () => "");
    Pt(this, "rotatable", !0);
    this.bg_col = t, this.isLay = e;
  }
  static init(t, e, r, S, T, D, N) {
    jt.sys = e, at(jt, $s, r), jt.prpPrs = S, at(jt, Gs, T), at(jt, Us, D), jt.hPages = N, Main.cvs.insertAdjacentHTML("beforebegin", `<div id="${z(jt, js)}" style="width: ${CmnLib.stageW * e.cvsScale}px; height: ${CmnLib.stageH * e.cvsScale}px; background: rgba(0,0,0,0); position: absolute; touch-action: none; user-select: none; display: none;"></div>`), at(jt, $r, document.getElementById(z(jt, js))), jt.divHint.classList.add("sn_design_hint"), t.view.parentElement.appendChild(jt.divHint), addStyle(`
.sn_design_cast {
	position: absolute; touch-action: none; user-select: none;
	opacity: 0.6; border-radius: 8px;
}

.sn_design_cast.drag_border {
	line-height: 1.8;
	border: dashed 5px #333;
}

.sn_design_hint {
	position: absolute;
	left: 0;
	top: 0;
	padding: 5px;
	border-radius: 5px;
	background: #333;
	z-index: 10;
	color: #fff;
	font-weight: bold;
	font-size: 12px;
	display: none;
}
`);
  }
  static setHint(t, e, r, S) {
    jt.divHint.innerHTML = t;
    const T = window.getComputedStyle(jt.divHint), D = parseFloat(T.width), N = parseFloat(T.height);
    jt.divHint.style.cssText = `display: block; left: ${Math.max(10, S.lx + e - D)}px;
		top: ${Math.max(10, S.ly + r - N - 10)}px;`;
  }
  static cvsResizeDesign() {
    const t = z(jt, $r).style;
    t.width = `${CmnLib.stageW * jt.sys.cvsScale}px`, t.height = `${CmnLib.stageH * jt.sys.cvsScale}px`;
  }
  destroy() {
    var t;
    this.div = void 0, (t = this.mov) == null || t.destroy(), this.mov = void 0;
  }
  gethArg() {
    return this.hArg;
  }
  sethArg(t) {
    if (!this.includeDesignArg(t))
      return;
    this.id_tag || (this.id_tag = t[":id_tag"] ?? ""), this.hArg = t;
    const e = t[":id_dc"] ?? this.id_tag;
    z(jt, gn)[e] = this;
  }
  includeDesignArg(t) {
    return Object.keys(t).some((e) => e in this.hDesignArg);
  }
  getRect() {
    return Rectangle.EMPTY;
  }
  cnvPosArg(t, e) {
    return {};
  }
  cnvSizeArg(t, e) {
    return {};
  }
  setPos(t, e) {
  }
  setSize(t, e) {
  }
  setOther(t) {
  }
  adopt(t) {
    this.child = t, t.parent = this;
  }
  static enterMode() {
    jt.leaveMode(), z(jt, $r).style.display = "inline", at(jt, Co, 0), at(jt, gn, {});
  }
  static allHide() {
    z(jt, mn).forEach((t) => t.visible = !1);
  }
  set visible(t) {
    !this.div || !this.mov || (this.div.style.display = t ? "inline" : "none", this.mov.updateTarget());
  }
  static leaveMode() {
    z(jt, $r).textContent = "", z(jt, $r).style.display = "none", z(jt, mn).forEach((t) => t.destroy()), at(jt, mn, []);
  }
  cvsResize() {
    var t;
    lt(this, Po, tf).call(this), (t = this.mov) == null || t.updateTarget();
  }
  onDragStart() {
  }
  make() {
    const t = this.hArg[":id_dc"] ?? this.id_tag;
    z(jt, gn)[t] = this;
    const e = this.div = document.createElement("div");
    e.id = z(jt, js) + "_" + ++Oe(jt, Co)._, e.classList.add("sn_design_cast"), e.dataset.id_dc = t, e.style.backgroundColor = `${this.bg_col}`, e.style.display = "none", this.rect = this.getRect(), lt(this, Po, tf).call(this), (this.parent ? document.querySelector(
      `[data-id_dc="${this.parent.id_tag}"]`
      // 親なので
    ) ?? z(jt, $r) : z(jt, $r)).appendChild(e);
    const r = {
      // movがdivを操作する際の雑用。スケールはHTML DOM
      aPos: [0, 0],
      roDeg: 0,
      trOrg: "",
      origin: [0, 0]
    }, S = () => {
      r.aPos = [NaN, NaN], r.roDeg = this.rotation;
      const B = this.pivot.x * jt.sys.cvsScale, $ = this.pivot.y * jt.sys.cvsScale;
      r.trOrg = `${B}px ${$}px`, r.origin = [B, $];
    }, T = (B) => {
      jt.sys.send2Dbg("_changeCast", {
        ...B,
        ":id_tag": this.id_tag
      }), jt.divHint.style.display = "none";
    }, D = () => {
      const [B, $] = r.aPos;
      if (isNaN(B)) {
        jt.divHint.style.display = "none";
        return;
      }
      const U = int(this.rect.x += B / jt.sys.cvsScale + this.pivot.x), H = int(this.rect.y += $ / jt.sys.cvsScale + this.pivot.y);
      this.setPos(U, H);
      const V = uint(this.rect.width), X = uint(this.rect.height);
      this.setSize(V, X), T({
        ...this.cnvPosArg(U, H),
        ...this.cnvSizeArg(V, X)
      });
    };
    let N;
    this.mov = new Moveable(document.body, {
      target: e,
      draggable: !0,
      resizable: !0,
      //	scalable	: true,
      rotatable: this.rotatable,
      originDraggable: this.rotatable,
      snappable: !0
    }).on("dragStart", (B) => {
      var U;
      S(), this.onDragStart();
      const $ = (U = this.child) == null ? void 0 : U.mov;
      $ && (N = $.target, $.isInside(B.clientX, B.clientY) && ($.target = void 0));
    }).on("drag", (B) => {
      r.aPos = B.beforeTranslate, this.procDragHint(B, B.left, B.top);
    }).on("dragEnd", () => {
      var B, $;
      D(), (B = this.child) != null && B.mov && (this.child.mov.target = N), ($ = this.parent) != null && $.mov && (this.parent.mov.target = this.parent.div);
    }).on("resizeStart", S).on("resize", (B) => {
      e.style.width = `${B.width}px`, e.style.height = `${B.height}px`, r.aPos = B.drag.beforeTranslate, this.rect.width = B.width / jt.sys.cvsScale, this.rect.height = B.height / jt.sys.cvsScale, this.procResizeHint(B, B.drag.left, B.drag.top);
    }).on("resizeEnd", D).on("rotateStart", (B) => {
      S(), B.set(r.roDeg);
    }).on("rotate", (B) => {
      r.roDeg = B.beforeRotate, jt.setHint(int(r.roDeg) + "度", B.drag.left, B.drag.top, this);
    }).on("rotateEnd", () => {
      this.rotation = r.roDeg, this.setOther({}), T({ rotation: int(r.roDeg) });
    }).on("dragOriginStart", () => S).on("dragOrigin", (B) => {
      r.trOrg = B.transformOrigin, r.origin = B.origin;
    }).on("dragOriginEnd", () => {
      const [B, $] = r.origin;
      r.trOrg = `${B}px ${$}px`;
      const U = this.pivot.x = B / jt.sys.cvsScale, H = this.pivot.y = $ / jt.sys.cvsScale;
      this.setOther({});
      const V = int(this.rect.x + U), X = int(this.rect.y + H);
      this.setPos(V, X), T({
        ...this.cnvPosArg(V, X),
        pivot_x: int(U),
        pivot_y: int(H)
      });
    }).on("render", () => {
      const { aPos: B, roDeg: $, trOrg: U } = r;
      e.style.transformOrigin = U, e.style.transform = `translate(${B[0]}px, ${B[1]}px) rotate(${$}deg)`;
    }), z(jt, mn).push(this), e.addEventListener("dragenter", () => e.classList.add("drag_border")), e.addEventListener("dragover", (B) => {
      B.stopPropagation(), B.preventDefault(), B.dataTransfer && (B.dataTransfer.dropEffect = "copy");
    }), e.addEventListener("dragleave", () => e.classList.remove("drag_border")), e.addEventListener("drop", (B) => {
      B.stopPropagation(), B.preventDefault(), e.classList.remove("drag_border");
      const $ = B.dataTransfer;
      if (!$ || $.files.length === 0)
        return;
      const U = $.files[0], H = {
        ":id_tag": this.id_tag,
        fn: getFn(U.name),
        ext: getExt(U.name),
        url: "",
        buf: new ArrayBuffer(0),
        old_fn: this.oldFn(),
        old_url: z(jt, Us).searchPath(this.oldFn(), SEARCH_PATH_ARG_EXT.SP_GSM)
      };
      U.arrayBuffer().then((V) => {
        H.buf = V;
        try {
          H.url = z(jt, $s).cnvPath4Dbg(
            z(jt, Us).searchPath(U.name, SEARCH_PATH_ARG_EXT.SP_GSM)
          );
        } catch {
        }
        jt.sys.send2Dbg("_dropFile", H);
      }).catch((V) => console.error("drop2dc %o", V));
    }), e.addEventListener("dblclick", (B) => {
      B.preventDefault(), jt.sys.send2Dbg("_focusScript", this.hArg);
    });
  }
  procDragHint(t, e, r) {
    const [S, T] = t.beforeTranslate;
    jt.setHint(
      `(${int(this.rect.x + S / jt.sys.cvsScale)}, ${int(this.rect.y + T / jt.sys.cvsScale)})`,
      e,
      r,
      this
    );
  }
  procResizeHint(t, e, r) {
    jt.setHint(
      `(${int(t.drag.left)}, ${int(t.drag.top)})<br/>${int(this.rect.width)} x ${int(this.rect.height)}`,
      e,
      r,
      this
    );
  }
  static replaceToken(t) {
    var U, H, V, X, W, Y, q, K;
    const r = t[":id_tag"], S = z(jt, gn)[r];
    if (!document.querySelector(`div[data-id_dc='${r}']`) || !S)
      return;
    const D = t[":token"];
    z(jt, $s).replace(t[":idx_tkn"], D);
    const [N, B] = tagToken2Name_Args(D);
    S.child && (S.child.hArg[":token"] = S.hArg[":token"]), z(jt, Gs).parse(B);
    const $ = z(jt, Gs).hPrm;
    if ("pivot_x" in $ || "pivot_y" in $) {
      const Z = Number(jt.prpPrs.getValAmpersand($.pivot_x.val)), J = Number(jt.prpPrs.getValAmpersand($.pivot_y.val));
      (isNaN(Z) || isNaN(J)) && DebugMng.myTrace(`pivot_xかpivot_yが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${D}`, "F"), S.pivot.set(Z, J);
    }
    if ("left" in $ || "top" in $ || "x" in $ || "y" in $) {
      const Z = int(jt.prpPrs.getValAmpersand(((U = $.left) == null ? void 0 : U.val) ?? ((H = $.x) == null ? void 0 : H.val) ?? "0")), J = int(jt.prpPrs.getValAmpersand(((V = $.top) == null ? void 0 : V.val) ?? ((X = $.y) == null ? void 0 : X.val) ?? "0"));
      (isNaN(Z) || isNaN(J)) && DebugMng.myTrace(`widthかheightが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${D}`, "F"), S.rect.x = Z - S.pivot.x, S.rect.y = J - S.pivot.y, S.setPos(Z, J);
    }
    if ("width" in $ || "height" in $) {
      const Z = int(jt.prpPrs.getValAmpersand(((W = $.width) == null ? void 0 : W.val) ?? "0")), J = int(jt.prpPrs.getValAmpersand(((Y = $.height) == null ? void 0 : Y.val) ?? "0"));
      (isNaN(Z) || isNaN(J)) && DebugMng.myTrace(`widthかheightが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${D}`, "F"), S.rect.width = Z, S.rect.height = J, S.setSize(Z, J);
    }
    if ("scale_x" in $ || "scale_y" in $) {
      const Z = Number(jt.prpPrs.getValAmpersand(((q = $.scale_x) == null ? void 0 : q.val) ?? "0")), J = Number(jt.prpPrs.getValAmpersand(((K = $.scale_y) == null ? void 0 : K.val) ?? "0"));
      (isNaN(Z) || isNaN(J)) && DebugMng.myTrace(`scale_xかscale_yが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${D}`, "F"), S.scale.set(Z, J);
    }
    if ("rotation" in $) {
      const Z = Number(jt.prpPrs.getValAmpersand($.rotation.val));
      isNaN(Z) && DebugMng.myTrace(`rotationが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${D}`, "F"), S.rotation = Z;
    }
    S.setOther($), S.cvsResize();
  }
};
let DesignCast = jt;
$r = new WeakMap(), $s = new WeakMap(), Gs = new WeakMap(), Us = new WeakMap(), js = new WeakMap(), Co = new WeakMap(), gn = new WeakMap(), mn = new WeakMap(), Po = new WeakSet(), tf = function() {
  this.fncLay(), this.div && Object.assign(this.div.style, {
    left: `${this.lx + this.rect.x * jt.sys.cvsScale}px`,
    top: `${this.ly + this.rect.y * jt.sys.cvsScale}px`,
    width: `${this.rect.width * jt.sys.cvsScale}px`,
    height: `${this.rect.height * jt.sys.cvsScale}px`,
    transformOrigin: `${this.pivot.x * jt.sys.cvsScale}px ${this.pivot.y * jt.sys.cvsScale}px`,
    transform: `scale(${this.scale.x}, ${this.scale.y}) rotate(${this.rotation}deg)`
  });
}, tt(DesignCast, $r, void 0), Pt(DesignCast, "sys"), tt(DesignCast, $s, void 0), Pt(DesignCast, "prpPrs"), tt(DesignCast, Gs, void 0), tt(DesignCast, Us, void 0), Pt(DesignCast, "hPages"), Pt(DesignCast, "divHint", document.createElement("div")), tt(DesignCast, js, "DesignMode"), tt(DesignCast, Co, 0), tt(DesignCast, gn, {}), tt(DesignCast, mn, []);
var Bi;
class GrpLayDesignCast extends DesignCast {
  constructor(e, r) {
    super("#29e", !0);
    tt(this, Bi, void 0);
    Pt(this, "oldFn", () => this.hArg.fn ?? "");
    this.spLay = e, this.gl = r;
  }
  setSp(e) {
    at(this, Bi, e);
  }
  getRect() {
    var e, r;
    return new Rectangle(this.spLay.x, this.spLay.y, ((e = z(this, Bi)) == null ? void 0 : e.width) ?? 0, ((r = z(this, Bi)) == null ? void 0 : r.height) ?? 0);
  }
  cnvPosArg(e, r) {
    return { left: e, top: r };
  }
  cnvSizeArg(e, r) {
    return { width: e, height: r };
  }
  setPos(e, r) {
    this.spLay.x = e, this.spLay.y = r;
  }
  setSize(e, r) {
    z(this, Bi).width = e, z(this, Bi).height = r;
  }
  setOther(e) {
    if ("fn" in e) {
      const r = DesignCast.prpPrs.getValAmpersand(e.fn.val);
      this.gl.lay({ fn: r });
    }
    this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;
  }
}
Bi = new WeakMap();
class TxtLayDesignCast extends DesignCast {
  constructor(e, r) {
    super("#29e", !0);
    Pt(this, "hDesignArg", {
      rotation: 0,
      pivot_x: 0,
      pivot_y: 0,
      left: 0,
      center: 0,
      right: 0,
      s_right: 0,
      top: 0,
      middle: 0,
      bottom: 0,
      s_bottom: 0,
      width: 0,
      height: 0,
      pl: 0,
      pr: 0,
      pt: 0,
      pb: 0
    });
    this.spLay = e, this.ts = r;
  }
  getRect() {
    const e = this.ts.infTL;
    return new Rectangle(this.spLay.x, this.spLay.y, e.$width, e.$height);
  }
  cnvPosArg(e, r) {
    return { left: e, top: r };
  }
  cnvSizeArg(e, r) {
    return { width: e, height: r };
  }
  setPos(e, r) {
    this.spLay.position.set(e, r), this.ts.lay(this.cnvPosArg(e, r));
  }
  setSize(e, r) {
    this.ts.lay(this.cnvSizeArg(e, r));
  }
  setOther(e) {
    var r;
    (r = this.child) == null || r.setOther(e), this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;
  }
}
var Ro, ef;
class TxtLayPadDesignCast extends DesignCast {
  constructor(e) {
    super("#9e2");
    tt(this, Ro);
    Pt(this, "rotatable", !1);
    this.ts = e;
  }
  getRect() {
    const e = this.ts.infTL;
    return new Rectangle(
      e.pad_left,
      e.pad_top,
      e.$width - e.pad_left - e.pad_right,
      e.$height - e.pad_top - e.pad_bottom
    );
  }
  cnvPosArg(e, r) {
    return { pl: e, pt: r };
  }
  cnvSizeArg(e, r) {
    const S = this.ts.infTL;
    return {
      pr: S.$width - S.pad_left - e,
      pb: S.$height - S.pad_top - r
    };
  }
  setPos(e, r) {
    this.ts.lay(this.cnvPosArg(e, r));
  }
  setSize(e, r) {
    this.ts.lay({ ...this.cnvSizeArg(e, r), ":redraw": !0 });
  }
  setOther(e) {
    var S, T, D, N;
    const r = this.ts.infTL;
    if (("pl" in e || "pt" in e) && (this.setPos(
      this.rect.x = parseFloat(DesignCast.prpPrs.getValAmpersand(
        ((S = e.pl) == null ? void 0 : S.val) ?? `${r.pad_left}`
      )),
      this.rect.y = parseFloat(DesignCast.prpPrs.getValAmpersand(
        ((T = e.pt) == null ? void 0 : T.val) ?? `${r.pad_top}`
      ))
    ), this.cvsResize()), "pr" in e || "pb" in e) {
      this.ts.lay({
        pr: parseFloat(DesignCast.prpPrs.getValAmpersand(
          ((D = e.pr) == null ? void 0 : D.val) ?? `${r.pad_right}`
        )),
        pb: parseFloat(DesignCast.prpPrs.getValAmpersand(
          ((N = e.pb) == null ? void 0 : N.val) ?? `${r.pad_bottom}`
        ))
      });
      const B = this.getRect();
      this.setSize(
        this.rect.width = B.width,
        this.rect.height = B.height
      ), this.cvsResize();
    }
  }
  procDragHint(e, r, S) {
    const [T, D] = e.beforeTranslate;
    lt(this, Ro, ef).call(this, r, S, T, D);
  }
  procResizeHint(e, r, S) {
    const [T, D] = e.drag.beforeTranslate;
    lt(this, Ro, ef).call(this, r, S, T, D);
  }
}
Ro = new WeakSet(), ef = function(e, r, S, T) {
  const D = this.rect.x, N = this.rect.y, B = this.rect.width, $ = this.rect.height, U = this.ts.infTL, H = int(D + S / DesignCast.sys.cvsScale), V = int(N + T / DesignCast.sys.cvsScale), X = int(U.$width - H - B), W = int(U.$height - V - $), Y = (q) => "&nbsp;".repeat(q);
  DesignCast.setHint(
    Y(5 + 5 + 1) + `上幅=${V}<br/>
			左幅=${H + Y(1 + 3 + 5 + 1)}右幅=${X}<br/>` + Y(5) + `内側 ${int(B)} x ${int($)}<br/>` + Y(5 + 5) + `下幅=${W}`,
    e,
    r,
    this
  );
};
class BtnDesignCast extends DesignCast {
  constructor(t, e) {
    super("#e92"), this.btn = t, this.hArg = e, this.pivot.x = argChk_Num(e, "pivot_x", this.pivot.x), this.pivot.y = argChk_Num(e, "pivot_y", this.pivot.y), this.scale.x = argChk_Num(e, "scale_x", this.scale.x), this.scale.y = argChk_Num(e, "scale_y", this.scale.y), this.rotation = argChk_Num(e, "rotation", this.rotation), this.sethArg(e);
  }
  sethArg(t) {
    super.sethArg(t);
    const e = this.hArg.layer ?? "";
    this.fncLay = !this.parent && !this.child && e ? () => {
      const r = DesignCast.hPages[e].fore;
      this.lx = r.x * DesignCast.sys.cvsScale, this.ly = r.y * DesignCast.sys.cvsScale;
    } : () => {
    };
  }
  cnvPosArg(t, e) {
    return { left: t, top: e };
  }
  cnvSizeArg(t, e) {
    return { width: t, height: e };
  }
  setPos(t, e) {
    this.btn.x = t, this.btn.y = e;
  }
  setOther(t) {
    this.btn.pivot.copyFrom(this.pivot), this.btn.scale.copyFrom(this.scale), this.btn.angle = this.rotation;
  }
  onDragStart() {
  }
}
class TxtBtnDesignCast extends BtnDesignCast {
  constructor(e, r, S) {
    super(e, r);
    Pt(this, "oldFn", () => this.hArg.b_pic ?? "");
    this.txt = S, argChk_Boolean(r, "design", !0) || (this.setPos = () => {
    }, this.setSize = () => {
    });
  }
  getRect() {
    return new Rectangle(this.btn.x, this.btn.y, this.txt.width, this.txt.height);
  }
  setSize(e, r) {
    this.txt.width = e, this.txt.height = r;
  }
  setOther(e) {
    if (super.setOther(e), "b_pic" in e) {
      const r = DesignCast.prpPrs.getValAmpersand(e.b_pic.val ?? "");
      this.btn.update_b_pic(r, this.txt);
    }
  }
}
var ii;
class PicBtnDesignCast extends BtnDesignCast {
  constructor(e, r) {
    super(e, r);
    tt(this, ii, void 0);
    Pt(this, "oldFn", () => this.hArg.pic ?? "");
  }
  setSp(e) {
    at(this, ii, e);
  }
  getRect() {
    return new Rectangle(this.btn.x, this.btn.y, z(this, ii).width, z(this, ii).height);
  }
  setSize(e, r) {
    z(this, ii).width = e, z(this, ii).height = r;
  }
  setOther(e) {
    if (super.setOther(e), "pic" in e) {
      const r = DesignCast.prpPrs.getValAmpersand(e.pic.val);
      this.btn.update_pic(r, z(this, ii));
    }
  }
}
ii = new WeakMap();
var rh, Fi, ni, _n, yn, Gr, zs, bn, Mo, Hs, Ur, si, ai, $i, Oo, Io, Do, ih, ud, nh, hd, Ao, rf, sh, cd, Vs, hu, Xs, wr, Ys, xn, No;
const Xt = class extends Layer {
  constructor() {
    super();
    tt(this, Ur, new GrpLayDesignCast(this.spLay, this));
    tt(this, si, "");
    tt(this, ai, "");
    tt(this, $i, "");
    Pt(this, "lay", (e) => this.laySub(e, (r) => {
      r && z(Xt, ni).resume();
    }));
    tt(this, Oo, 0);
    tt(this, Io, 0);
    tt(this, Xs, void 0);
    tt(this, wr, void 0);
    tt(this, Ys, () => {
    });
    Pt(this, "record", () => ({
      ...super.record(),
      sBkFn: z(this, ai),
      sBkFace: z(this, $i),
      idc_hArg: z(this, Ur).gethArg()
    }));
    //showDesignCastChildren() {}
    Pt(this, "dump", () => super.dump() + `, "pic":"${z(this, si)}"`);
    CmnLib.isDbg && (this.setSp = (e) => z(this, Ur).setSp(e), this.cvsResize = () => {
      super.cvsResize(), z(this, Ur).cvsResize();
    });
  }
  static init(e, r, S, T, D, N) {
    at(Xt, ni, e), at(Xt, _n, r), at(Xt, yn, S), at(Xt, Gr, T), at(Xt, zs, N);
    const B = () => {
      const $ = z(Xt, bn) * z(Xt, Mo);
      for (const U of Object.values(Xt.hFn2VElm))
        U.volume = $;
    };
    D.setNoticeChgVolume(
      ($) => {
        at(Xt, bn, $), B();
      },
      ($) => {
        at(Xt, Mo, $), B();
      }
    ), z(Xt, Gr).crypto && at(Xt, Do, lt(Xt, nh, hd));
  }
  static setEvtMng(e) {
    at(Xt, Hs, e);
  }
  static destroy() {
    z(Xt, rh).clear(), at(Xt, Fi, {}), Xt.hFn2ResAniSpr = {}, Xt.hFn2VElm = {};
  }
  setSp(e) {
  }
  laySub(e, r) {
    var B;
    lt(B = Xt, Vs, hu).call(B, z(this, ai));
    const { fn: S, face: T = "" } = e;
    if (z(this, Ur).sethArg(e), !S)
      return super.lay(e), this.spLay.children.length > 0 && this.setPos(e), at(this, ai, ""), at(this, si, at(this, $i, T)), r(!1), !1;
    const D = "fn" in e, N = "face" in e;
    return this.clearLay({ filter: "true" }), D && at(this, ai, S), N && at(this, $i, T), super.lay(e), e.dx = 0, e.dy = 0, Xt.csv2Sprites(
      at(this, si, S + (T ? "," + T : "")),
      this.spLay,
      ($) => {
        ("width" in e || "height" in e) && ($.width = argChk_Num(e, "width", 0), $.height = argChk_Num(e, "height", 0)), at(this, Oo, $.width), at(this, Io, $.height), Layer.setXY($, e, this.spLay, !0), this.setSp($);
      },
      ($) => {
        Layer.setBlendmode(this.spLay, e), r($);
      }
    );
  }
  get width() {
    return z(this, Oo);
  }
  get height() {
    return z(this, Io);
  }
  //	static #ldrHFn: {[name: string]: 1} = {};
  static csv2Sprites(e, r, S, T = () => {
  }) {
    let D = !1;
    if (e.slice(0, 5) === "data:") {
      const U = () => {
        const H = Sprite.from(e);
        r == null || r.addChild(H), S(H), T(D);
      };
      return e in TextureCache ? U() : (D = !0, new Loader().add(e, e).load(U)), D;
    }
    const N = [], B = new Loader();
    e.split(",").forEach((U, H) => {
      if (!U)
        throw "face属性に空要素が含まれます";
      const { dx: V, dy: X, blendmode: W, fn: Y } = z(Xt, Fi)[U] || {
        fn: U,
        dx: 0,
        dy: 0,
        blendmode: BLEND_MODES.NORMAL
      }, q = H === 0 ? S : (J) => {
        J.x = V, J.y = X, J.blendMode = W;
      };
      if (N.push({ fn: Y, fnc: q }), Y in Xt.hFn2ResAniSpr || Y in TextureCache || Y in Loader.shared.resources)
        return;
      D = !0;
      const K = z(Xt, _n).searchPath(Y, SEARCH_PATH_ARG_EXT.SP_GSM), Z = z(this, Gr).crypto ? { xhrType: K.slice(-5) === ".json" ? LoaderResource.XHR_RESPONSE_TYPE.TEXT : LoaderResource.XHR_RESPONSE_TYPE.BUFFER } : {};
      B.add({ ...Z, name: Y, url: K });
    });
    const $ = (U) => {
      var H;
      for (const { fn: V, fnc: X } of N) {
        const W = lt(H = Xt, sh, cd).call(H, V, U);
        W.name = V, r == null || r.addChild(W), X(W);
      }
      T(D);
    };
    return D ? B.use((U, H) => {
      z(this, Gr).dec(U.extension, U.data).then((V) => {
        var X;
        return z(X = Xt, Do).call(X, V, U, () => H == null ? void 0 : H());
      }).catch((V) => z(this, ni).errScript(`Graphic ロード失敗です fn:${U.name} ${V}`, !1));
    }).load((U, H) => $(H)) : $({}), D;
  }
  static wv(e) {
    var D;
    const { fn: r } = e;
    if (!r)
      throw "fnは必須です";
    const S = Xt.hFn2VElm[r];
    if (!S || S.loop)
      return !1;
    if (z(this, zs).getVal("tmp:sn.skip.enabled") || z(this, Hs).isSkippingByKeyDown() || S.ended)
      return lt(D = Xt, Vs, hu).call(D, r), !1;
    const T = () => {
      var N;
      lt(N = Xt, Vs, hu).call(N, r), z(this, ni).resume();
    };
    return S.addEventListener("ended", T, { once: !0, passive: !0 }), z(Xt, Hs).waitEvent(
      () => {
        S.removeEventListener("ended", T), T();
      },
      argChk_Boolean(e, "canskip", !0),
      argChk_Boolean(e, "global", !1)
    );
  }
  renderStart() {
    at(this, Xs, RenderTexture.create({
      width: CmnLib.stageW,
      height: CmnLib.stageH
    })), at(this, wr, new Sprite(z(this, Xs))), z(this, wr).visible = !1, this.spLay.addChildAt(z(this, wr), 0), z(this, wr).position.set(-this.spLay.x, -this.spLay.y);
    let e = () => {
      const r = this.spLay.alpha;
      this.spLay.alpha = 1;
      for (const S of this.spLay.children)
        S.visible = !0;
      z(this, wr).visible = !1, z(Xt, yn).renderer.render(this.spLay, { renderTexture: z(this, Xs) }), this.spLay.alpha = r;
      for (const S of this.spLay.children)
        S.visible = !1;
    };
    if (!this.containMovement) {
      let r = e;
      e = () => {
        e = () => {
        }, r();
      };
    }
    at(this, Ys, () => {
      e(), z(this, wr).visible = !0;
    }), z(Xt, yn).ticker.add(z(this, Ys));
  }
  renderEnd() {
    z(Xt, yn).ticker.remove(z(this, Ys)), this.spLay.removeChild(z(this, wr));
    for (const e of this.spLay.children)
      e.visible = !0;
    z(this, wr).destroy(!0);
  }
  static loadPic2Img(e, r, S) {
    const T = z(this, No)[e];
    if (T) {
      r.src = T;
      return;
    }
    const D = z(this, xn)[e];
    if (D) {
      D.push(r);
      return;
    }
    z(this, xn)[e] = [r];
    const N = z(Xt, _n).searchPath(e, SEARCH_PATH_ARG_EXT.SP_GSM), B = new Loader().add({ name: e, url: N, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER });
    z(Xt, Gr).crypto && getExt(N) === "bin" && B.use(($, U) => {
      z(Xt, Gr).dec($.extension, $.data).then((H) => {
        if ($.extension !== "bin") {
          U == null || U();
          return;
        }
        $.data = H, H instanceof HTMLImageElement && ($.type = LoaderResource.TYPE.IMAGE), U == null || U();
      }).catch((H) => z(Xt, ni).errScript(`GrpLayer loadPic ロード失敗です fn:${$.name} ${H}`, !1));
    }), B.load(($, U) => {
      for (const [H, { data: { src: V } }] of Object.entries(U)) {
        const X = z(this, No)[H] = V;
        for (const W of z(this, xn)[H])
          W.src = X, S && (W.onload = () => S(W));
        delete z(this, xn)[H];
      }
    });
  }
  setPos(e) {
    Layer.setXY(
      this.spLay.children.length === 0 ? this.spLay : this.spLay.children[0],
      e,
      this.spLay,
      !0
    );
  }
  static add_face(e) {
    const { name: r } = e;
    if (!r)
      throw "nameは必須です";
    if (r in z(Xt, Fi))
      throw "一つのname（" + r + "）に対して同じ画像を複数割り当てられません";
    const { fn: S = r } = e;
    return z(Xt, Fi)[r] = {
      fn: S,
      dx: argChk_Num(e, "dx", 0),
      dy: argChk_Num(e, "dy", 0),
      blendmode: Layer.getBlendmodeNum(e.blendmode || "")
    }, !1;
  }
  static clearFace2Name() {
    at(Xt, Fi, {});
  }
  // アニメ・動画を含むか
  get containMovement() {
    if (z(this, si) === "")
      return !1;
    const e = this.spLay.children;
    return z(this, si).split(",").some(
      (r, S) => e[S] instanceof AnimatedSprite || Xt.hFn2VElm[r]
    );
  }
  clearLay(e) {
    super.clearLay(e);
    for (const r of this.spLay.removeChildren())
      r.destroy();
    at(this, ai, ""), at(this, $i, ""), at(this, si, "");
  }
  playback(e, r) {
    if (super.playback(e, r), e.sBkFn === "" && e.sBkFace === "") {
      at(this, ai, e.sBkFn), at(this, $i, e.sBkFace), z(this, Ur).sethArg(e.idc_hArg);
      return;
    }
    r.push(new Promise((S) => this.laySub(
      { fn: e.sBkFn, face: e.sBkFace, left: e.x, top: e.y, alpha: e.alpha, blendmode: Layer.getNum2Blendmode(e.blendMode), rotation: e.rotation, scale_x: e.scale_x, scale_y: e.scale_y },
      (T) => {
        this.spLay.position.set(e.x, e.y), S();
      }
      // Layer.setXY()の後に再度移動
    )));
  }
  makeDesignCast(e) {
    this.spLay.visible && e(z(this, Ur));
  }
  //makeDesignCastChildren(_gdc: IMakeDesignCast) {}
  cvsResize() {
    super.cvsResize();
  }
  showDesignCast() {
    z(this, Ur).visible = !0;
  }
};
let GrpLayer = Xt;
rh = new WeakMap(), Fi = new WeakMap(), ni = new WeakMap(), _n = new WeakMap(), yn = new WeakMap(), Gr = new WeakMap(), zs = new WeakMap(), bn = new WeakMap(), Mo = new WeakMap(), Hs = new WeakMap(), Ur = new WeakMap(), si = new WeakMap(), ai = new WeakMap(), $i = new WeakMap(), Oo = new WeakMap(), Io = new WeakMap(), Do = new WeakMap(), ih = new WeakSet(), ud = function(e) {
  const r = /([^\d]+)\d+\.(\w+)/.exec(e[0]);
  if (!r)
    return [];
  const S = r[1].length, T = -r[2].length - 1;
  return e.sort(
    (D, N) => int(D.slice(S, T)) > int(N.slice(S, T)) ? 1 : -1
  );
}, nh = new WeakSet(), hd = function(e, r, S) {
  var $;
  if (r.data = e, r.extension === "bin" && (e instanceof HTMLImageElement ? (r.texture = Texture.fromLoader(e, r.url, r.name), r.type = LoaderResource.TYPE.IMAGE) : e instanceof HTMLVideoElement && (e.volume = z(Xt, bn), Xt.hFn2VElm[r.name] = lt($ = Xt, Ao, rf).call($, e), r.type = LoaderResource.TYPE.VIDEO)), r.extension !== "json") {
    S();
    return;
  }
  if (typeof e != "string") {
    S();
    return;
  }
  const { meta: T, frames: D } = r.data = JSON.parse(e);
  if (r.type = LoaderResource.TYPE.JSON, !(T != null && T.image)) {
    S();
    return;
  }
  const N = getFn(T.image), B = z(Xt, _n).searchPath(N, SEARCH_PATH_ARG_EXT.SP_GSM);
  new Loader().use((U, H) => {
    z(this, Gr).dec(U.extension, U.data).then((V) => {
      U.data = V, V instanceof HTMLImageElement && (U.type = LoaderResource.TYPE.IMAGE, URL.revokeObjectURL(V.src)), H == null || H();
    }).catch((V) => z(this, ni).errScript(`Graphic ロード失敗です dec2res4Cripto fn:${U.name} ${V}`, !1));
  }).add({ name: N, url: B, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).load((U, H) => {
    for (const { data: V } of Object.values(U.resources)) {
      const { baseTexture: X } = Texture.from(V), W = Object.values(D);
      Xt.hFn2ResAniSpr[r.name] = {
        aTex: W.map(({ frame: { x: Y, y: q, w: K, h: Z } }) => new Texture(
          X,
          new Rectangle(Y, q, K, Z)
        )),
        meta: T
      };
    }
    S();
  });
}, Ao = new WeakSet(), rf = function(e) {
  return z(Xt, zs).getVal("const.sn.needClick2Play") && (DebugMng.trace_beforeNew(`[lay系] ${DebugMng.strPos()}未クリック状態で動画を自動再生します。音声はミュートされます`, "W"), e.muted = !0), e.setAttribute("playsinline", ""), e;
}, sh = new WeakSet(), cd = function(e, r) {
  const S = Xt.hFn2ResAniSpr[e];
  if (S) {
    const T = new AnimatedSprite(S.aTex);
    return T.animationSpeed = S.meta.animationSpeed ?? 1, T.play(), T;
  }
  return e in TextureCache ? Sprite.from(e) : e in Xt.hFn2VElm ? Sprite.from(Xt.hFn2VElm[e]) : e in r ? new Sprite(r[e].texture) : new Sprite();
}, Vs = new WeakSet(), hu = function(e) {
  const r = Xt.hFn2VElm[e];
  r && (delete Xt.hFn2VElm[e], r.pause(), r.currentTime = r.duration);
}, Xs = new WeakMap(), wr = new WeakMap(), Ys = new WeakMap(), xn = new WeakMap(), No = new WeakMap(), tt(GrpLayer, ih), tt(GrpLayer, nh), tt(GrpLayer, Ao), tt(GrpLayer, sh), tt(GrpLayer, Vs), tt(GrpLayer, rh, new EventListenerCtn()), tt(GrpLayer, Fi, {}), tt(GrpLayer, ni, void 0), tt(GrpLayer, _n, void 0), tt(GrpLayer, yn, void 0), tt(GrpLayer, Gr, void 0), tt(GrpLayer, zs, void 0), tt(GrpLayer, bn, 1), tt(GrpLayer, Mo, 1), tt(GrpLayer, Hs, void 0), Pt(GrpLayer, "hFn2ResAniSpr", {}), tt(GrpLayer, Do, (e, r, S) => {
  var T, D;
  switch (r.type) {
    case LoaderResource.TYPE.JSON:
      const N = r.spritesheet._frameKeys;
      lt(T = Xt, ih, ud).call(T, N), Xt.hFn2ResAniSpr[r.name] = {
        aTex: N.map(($) => Texture.from($)),
        meta: r.data.meta
      };
      break;
    case LoaderResource.TYPE.VIDEO:
      const B = r.data;
      B.volume = z(Xt, bn), Xt.hFn2VElm[r.name] = lt(D = Xt, Ao, rf).call(D, B);
  }
  S();
}), Pt(GrpLayer, "hFn2VElm", {}), tt(GrpLayer, xn, {}), tt(GrpLayer, No, {});
var Ws, Lo, Sn, ne, jr, oi, ah, sr, Gi, Yt, li, ar, or, qs, cu, Cr, Ui, ko, Ks, oh, fd, En, Zs, ui, Tn, wn, Cn, Js, Bo, hi, Fo, nf, ci, $o, fi, zr, Qs, Go, sf, ji, Pn, Uo, af, We;
const Qt = class extends Container {
  constructor(e, r, S) {
    super();
    tt(this, qs);
    tt(this, oh);
    tt(this, Fo);
    // 「g」などで下が欠ける問題対策
    tt(this, Go);
    tt(this, Uo);
    tt(this, ne, document.createElement("span"));
    // サンプリング元
    tt(this, jr, new Container());
    // サンプリング先
    tt(this, oi, new Graphics());
    tt(this, sr, new TxtLayDesignCast(this.spLay, this));
    tt(this, Gi, new TxtLayPadDesignCast(this));
    tt(this, Yt, {
      fontsize: 24,
      $width: 0,
      // レイヤサイズであり、背景色（画像）サイズ
      $height: 0,
      pad_left: 0,
      // paddingLeft（レイヤサイズの内側のスペーサー）
      pad_right: 0,
      // paddingRight
      pad_top: 0,
      // paddingTop
      pad_bottom: 0
      // paddingBottom
    });
    tt(this, li, !1);
    tt(this, ar, 0);
    tt(this, or, 0);
    tt(this, Cr, 0);
    tt(this, Ui, !1);
    tt(this, ko, 0);
    tt(this, Ks, 0);
    tt(this, En, void 0);
    // 文字にかけるフィルター
    tt(this, Zs, []);
    tt(this, ui, []);
    tt(this, Tn, 0);
    tt(this, hi, () => !1);
    tt(this, Qs, 0);
    tt(this, ji, "Quadratic.Out");
    tt(this, Pn, "Quadratic.Out");
    tt(this, We, void 0);
    this.spLay = e, this.canFocus = r, this.sys = S, z(this, ne).classList.add("sn_tx"), z(this, ne).style.position = "absolute", z(Qt, Lo).view.parentElement.appendChild(z(this, ne)), this.addChild(z(this, jr)), this.addChild(z(this, oi)), z(this, oi).name = "grpDbgMasume", z(this, sr).adopt(z(this, Gi));
  }
  static init(e, r) {
    at(Qt, Ws, e), at(Qt, Lo, r), at(Qt, wn, /[、。，．）］｝〉」』】〕”〟ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ！？!?‼⁉・ーゝゞヽヾ々]/), at(Qt, Cn, /[［（｛〈「『【〔“〝]/), at(Qt, Js, /[─‥…]/);
  }
  static setEvtMng(e) {
    at(Qt, Sn, e);
  }
  static destroy() {
    at(Qt, ci, /* @__PURE__ */ Object.create(null)), at(Qt, fi, /* @__PURE__ */ Object.create(null)), at(Qt, zr, new Container());
  }
  lay(e) {
    const r = z(this, ne).style;
    if ("style" in e)
      if (e.style) {
        const S = document.createElement("span");
        S.style.cssText = e.style;
        const T = S.style.length;
        for (let D = 0; D < T; ++D) {
          const N = S.style[D];
          if (N in z(Qt, ah)) {
            DebugMng.myTrace(`${N}は指定できません`, "W");
            continue;
          }
          r[N] = S.style[N];
        }
        !S.style.opacity && "alpha" in e && (r.opacity = String(this.spLay.alpha));
      } else
        z(this, ne).style.cssText = "";
    else
      "alpha" in e && (r.opacity = String(this.spLay.alpha));
    if ("width" in e && (r.width = (e.width ?? "0") + "px"), "height" in e && (r.height = (e.height ?? "0") + "px"), "pl" in e && (r.paddingLeft = (e.pl ?? "0") + "px"), "pr" in e && (r.paddingRight = (e.pr ?? "0") + "px"), "pt" in e && (r.paddingTop = (e.pt ?? "0") + "px"), "pb" in e && (r.paddingBottom = (e.pb ?? "0") + "px"), "kinsoku_sol" in e && at(Qt, wn, new RegExp(`[${e.kinsoku_sol}]`)), "kinsoku_eol" in e && at(Qt, Cn, new RegExp(`[${e.kinsoku_eol}]`)), "kinsoku_dns" in e && at(Qt, Js, new RegExp(`[${e.kinsoku_dns}]`)), lt(this, qs, cu).call(this), z(this, sr).sethArg(e), at(this, Cr, this.spLay.position.x), r.transformOrigin = `${this.spLay.pivot.x}px ${this.spLay.pivot.y}px`, this.cvsResize(), r.display = this.spLay.visible ? "inline" : "none", r.textShadow = e.filter ?? r.textShadow ?? "", at(this, li, argChk_Boolean(e, "break_fixed", z(this, li))), at(this, ar, argChk_Num(e, "break_fixed_left", z(this, ar))), at(this, or, argChk_Num(e, "break_fixed_top", z(this, or))), ":redraw" in e && z(this, Tn) > 0) {
      const S = [
        z(this, ne).innerHTML.replaceAll(/(animation-delay: )\d+ms/g, "$10ms"),
        `<span class='sn_ch' data-add='{"ch_in_style":"default"}'>　</span>`
      ];
      lt(this, Uo, af).call(this), this.goTxt(S, !0);
    }
  }
  cvsResize() {
    const e = z(this, ne).style, r = this.sys.cvsScale;
    e.left = `${this.sys.ofsLeft4elm + z(this, Cr) * r}px`, e.top = `${this.sys.ofsTop4elm + this.spLay.position.y * r}px`, e.transform = `rotate(${this.spLay.angle}deg) scale(${this.spLay.scale.x * r}, ${this.spLay.scale.y * r})`, z(this, sr).cvsResize(), z(this, Gi).cvsResize();
  }
  get tategaki() {
    return z(this, Ui);
  }
  get infTL() {
    return z(this, Yt);
  }
  get getWidth() {
    return z(this, Yt).$width;
  }
  get getHeight() {
    return z(this, Yt).$height;
  }
  setSize(e, r) {
    z(this, Yt).$width = e, z(this, Yt).$height = r, z(this, ne).style.width = z(this, Yt).$width + "px", z(this, ne).style.height = z(this, Yt).$height + "px";
  }
  goTxt(e, r) {
    var et, nt, st;
    z(Qt, zr).visible = !1;
    let S = z(this, ui).length, T = "";
    S === 0 ? (z(Qt, Ws).oCfg.debug.masume && (CmnLib.debugLog && console.log(`🍌 masume ${this.name} v:${this.visible} l:${this.x} t:${this.y} a:${this.alpha} pl:${z(this, Yt).pad_left} pr:${z(this, Yt).pad_right} pt:${z(this, Yt).pad_top} pb:${z(this, Yt).pad_bottom} w:${z(this, Yt).$width} h:${z(this, Yt).$height}`), z(this, oi).clear().beginFill(3407616, 0.2).lineStyle(1, 3407616, 1).drawRect(-z(this, Yt).pad_left, -z(this, Yt).pad_top, z(this, Yt).$width, z(this, Yt).$height).endFill().beginFill(13311, 0.2).lineStyle(2, 13311, 1).drawRect(
      0,
      0,
      z(this, Yt).$width - z(this, Yt).pad_left - z(this, Yt).pad_right,
      z(this, Yt).$height - z(this, Yt).pad_top - z(this, Yt).pad_bottom
    ).endFill()), z(this, ne).innerHTML = [...e].join("").replaceAll(/[\n\t]/g, "") + z(Qt, Bo)) : (T = z(this, ne).innerHTML, z(this, ne).querySelectorAll(":scope > br").forEach((it) => z(this, ne).removeChild(it)), z(this, ne).insertAdjacentHTML(
      "beforeend",
      e.slice(z(this, Tn)).join("").replaceAll(/[\n\t]/g, "") + z(Qt, Bo)
      // 末尾改行削除挙動対策
    ), --S, (et = z(this, ne).querySelector(".sn_ch_last")) == null || et.remove()), at(this, Tn, e.length);
    const D = this.sys.cvsScale, N = z(this, ne).getBoundingClientRect(), B = N.left + z(this, Yt).pad_left, $ = N.top + z(this, Yt).pad_top;
    let U;
    if (D === 1)
      U = (it, ot) => new Rectangle(
        it.left - B,
        it.top - $,
        it.width,
        it.height + ("gjqy".includes(ot) ? z(this, Qs) : 0)
      );
    else {
      const it = this.sys.ofsPadLeft_Dom2PIXI + N.left * (1 - D), ot = this.sys.ofsPadTop_Dom2PIXI + N.top * (1 - D);
      U = (ht, ct) => new Rectangle(
        (ht.left - it) / D - B,
        (ht.top - ot) / D - $,
        ht.width / D,
        (ht.height + ("gjqy".includes(ct) ? z(this, Qs) : 0)) / D
      );
    }
    let H = 0, V = 2, X = !1;
    do {
      const it = at(this, ui, lt(this, Go, sf).call(this, z(this, ne), U));
      if (H = it.length, !X && (H < 2 || S === H)) {
        S > 0 && S === H && (z(this, ne).innerHTML = T.replaceAll('class="sn_ch"', 'class="sn_ch sn_ch_in_default"'));
        break;
      }
      X = !0;
      let ot = -1 / 0;
      for (; V < H; ++V) {
        const ht = it[V];
        if (ht.elm.tagName === "RT")
          continue;
        const ct = this.tategaki ? ht.rect.y : ht.rect.x;
        if (ot <= ct || ((st = (nt = ht.elm.previousElementSibling) == null ? void 0 : nt.children[0]) == null ? void 0 : st.tagName) === "BR") {
          ot = ct;
          continue;
        }
        let vt = V - 1;
        for (; it[vt].elm.tagName === "RT"; )
          --vt;
        const _t = it[vt].ch;
        ot = -1 / 0;
        const gt = V;
        if (z(Qt, Js).test(_t) && _t === ht.ch)
          V = vt;
        else {
          if (z(Qt, Cn).test(_t))
            V = vt;
          else if (z(Qt, wn).test(ht.ch))
            for (V = vt + 1; V > 0 && z(Qt, wn).test(it[--V].ch); )
              ;
          else {
            ++V;
            continue;
          }
          for (V = vt + 1; V > 0 && z(Qt, Cn).test(it[--V].ch); )
            ;
        }
        const mt = it[V].elm.parentElement, Et = document.createElement("br");
        if (mt.classList.contains("sn_tx"))
          mt.insertBefore(Et, it[V].elm);
        else {
          const wt = mt.parentElement;
          wt.classList.contains("sn_ch") ? wt.parentElement.insertBefore(Et, wt) : wt.insertBefore(Et, mt);
        }
        V += 2, V < gt && (V = gt), H = -1;
        break;
      }
    } while (H < 0);
    const W = CmnLib.debugLog ? (it, ot) => console.log(`🍌 masume ch:${it.ch} x:${ot.x} y:${ot.y} w:${ot.width} h:${ot.height}`) : () => {
    }, Y = z(Qt, Ws).oCfg.debug.masume ? (it, ot) => {
      W(it, ot), z(this, oi).beginFill(6737151, 0.5).lineStyle(2, 16724736, 1).drawRect(ot.x, ot.y, ot.width, ot.height).endFill();
    } : () => {
    }, q = CmnTween.ease(z(this, ji));
    for (let it = S; it < H; ++it) {
      const ot = z(this, ui)[it], ht = ot.rect, ct = JSON.parse(ot.elm.dataset.arg ?? '{"delay": 0}'), vt = JSON.parse(ot.elm.dataset.add ?? "{}"), _t = z(Qt, ci)[vt.ch_in_style];
      if (Y(ot, ht), ot.elm.dataset.cmd === "grp") {
        const gt = new Container();
        z(this, jr).addChild(gt), GrpLayer.csv2Sprites(ct.pic, gt, (mt) => {
          lt(this, Fo, nf).call(this, gt, ct, vt, ht, q, _t ?? {}), gt.parent || gt.removeChild(mt);
        });
      }
      if (ot.elm.dataset.lnk) {
        const gt = ot.elm.parentElement.closest("[data-arg]"), mt = JSON.parse(gt.dataset.arg ?? "{}");
        mt.key = `lnk=[${it}] ` + this.name;
        const Et = new Sprite();
        lt(this, Fo, nf).call(this, Et, mt, vt, ht, q, _t ?? {});
        const wt = mt.style ?? "", xt = wt + (mt.style_hover ?? ""), pt = wt + (mt.style_clicked ?? ""), yt = mt.r_style ?? "", Dt = yt + (mt.r_style_hover ?? ""), At = yt + (mt.r_style_clicked ?? ""), It = gt.querySelectorAll("rt");
        It.forEach((Mt) => Mt.dataset.st_r_bk = Mt.style.cssText);
        const Ot = gt.style.cssText, ft = (Mt, zt) => {
          gt.style.cssText = Ot + Mt, It.forEach((Nt) => Nt.style.cssText = Nt.dataset.st_r_bk + zt);
        };
        argChk_Boolean(mt, "enabled", !0) ? z(Qt, Sn).button(
          mt,
          Et,
          () => ft(wt, yt),
          () => this.canFocus() ? (ft(xt, Dt), !0) : !1,
          () => ft(pt, At)
        ) : ft(
          wt + (mt.style_disable ?? "color: gray;"),
          yt + (mt.r_style_disable ?? "color: gray;")
        ), z(this, jr).addChild(Et);
      }
    }
    const K = z(this, ne).querySelectorAll("span.sn_ch");
    if (at(this, hi, () => (at(this, hi, () => !1), K.forEach((it) => it.className = it.className.replaceAll(/ go_ch_in_[^\s"]+/g, "")), z(Qt, zr).position.set(
      // len_chs === 0 かもなのでここ
      z(this, ar),
      z(this, or)
    ), z(Qt, zr).visible = !0, z(Qt, Sn).noticeCompTxt(), !0)), K.length === 0) {
      const it = globalThis.getComputedStyle(z(this, ne)), ot = parseFloat(it.fontSize);
      z(this, Ui) ? (at(this, ar, (z(this, Yt).$width - z(this, Yt).pad_left - z(this, Yt).pad_right - ot * 1.5) * this.sys.cvsScale), at(this, or, 0)) : (at(this, ar, 0), at(this, or, ot / 2 * this.sys.cvsScale)), z(this, hi).call(this);
      return;
    }
    K.forEach((it) => it.className = it.className.replaceAll(/sn_ch_in_([^\s"]+)/g, "go_ch_in_$1"));
    const { x: J, y: Q } = z(this, ui)[H - 1].rect;
    at(this, ar, J), at(this, or, Q), S > 0 && ++S;
    let rt;
    for (let it = H - 2; it >= 0; --it) {
      const ot = z(this, ui)[it];
      if (ot.elm.tagName === "SPAN") {
        rt = ot.elm;
        break;
      }
    }
    if (!rt || r || S === H) {
      z(this, hi).call(this);
      return;
    }
    rt.addEventListener("animationend", z(this, hi), { once: !0, passive: !0 });
  }
  skipChIn() {
    let e = z(this, hi).call(this);
    for (const r of z(this, Zs))
      r.tw && (r.tw.stop().end(), e = !0);
    return at(this, Zs, []), e;
  }
  static initChStyle() {
    at(Qt, ci, /* @__PURE__ */ Object.create(null)), at(Qt, fi, /* @__PURE__ */ Object.create(null));
  }
  static getChInStyle(e) {
    return z(Qt, ci)[e];
  }
  static ch_in_style(e) {
    const { name: r } = e;
    if (!r)
      throw "nameは必須です";
    if (z(Qt, $o).test(r))
      throw `name【${r}】に使えない文字が含まれます`;
    if (r in z(Qt, ci))
      throw `name【${r}】はすでにあります`;
    const S = String(e.x ?? "=0"), T = String(e.y ?? "=0");
    return z(Qt, ci)[r] = {
      wait: argChk_Num(e, "wait", 500),
      // アニメ・FI時間
      alpha: argChk_Num(e, "alpha", 0),
      x: S,
      // 初期x値
      y: T,
      // [tsy]と同様に絶対・相対指定可能
      // {x:500}			X位置を500に
      // {x:'=500'}		現在のX位置に+500加算した位置
      // {x:'=-500'}		現在のX位置に-500加算した位置
      // {x:'250,500'}	+250から＋500までの間でランダムな値をX位置に
      // {x:'=250,500'}	+250から＋500までの間でランダムな値を現在のX位置に加算
      nx: parseFloat(S.at(0) === "=" ? S.slice(1) : S),
      ny: parseFloat(T.at(0) === "=" ? T.slice(1) : T),
      scale_x: argChk_Num(e, "scale_x", 1),
      scale_y: argChk_Num(e, "scale_y", 1),
      rotate: argChk_Num(e, "rotate", 0),
      join: argChk_Boolean(e, "join", !0),
      // 文字を順番に出すか（true）同時か（false）
      ease: e.ease ?? "ease-out"
    };
  }
  static getChOutStyle(e) {
    return z(Qt, fi)[e];
  }
  static ch_out_style(e) {
    const { name: r } = e;
    if (!r)
      throw "nameは必須です";
    if (z(Qt, $o).test(r))
      throw `name【${r}】に使えない文字が含まれます`;
    if (r in z(Qt, fi))
      throw `name【${r}】はすでにあります`;
    const S = String(e.x ?? "=0"), T = String(e.y ?? "=0");
    return z(Qt, fi)[r] = {
      wait: argChk_Num(e, "wait", 500),
      // アニメ・FI時間
      alpha: argChk_Num(e, "alpha", 0),
      x: S,
      // 初期x値
      y: T,
      // [tsy]と同様に絶対・相対指定可能
      // {x:500}			X位置を500に
      // {x:'=500'}		現在のX位置に+500加算した位置
      // {x:'=-500'}		現在のX位置に-500加算した位置
      // {x:'250,500'}	+250から＋500までの間でランダムな値をX位置に
      // {x:'=250,500'}	+250から＋500までの間でランダムな値を現在のX位置に加算
      nx: parseFloat(S.at(0) === "=" ? S.slice(1) : S),
      ny: parseFloat(T.at(0) === "=" ? T.slice(1) : T),
      scale_x: argChk_Num(e, "scale_x", 1),
      scale_y: argChk_Num(e, "scale_y", 1),
      rotate: argChk_Num(e, "rotate", 0),
      join: argChk_Boolean(e, "join", !1),
      // 文字を順番に出すか（true）同時か（false）
      ease: e.ease ?? "ease-out"
    };
  }
  dispBreak(e) {
    const r = z(Qt, zr);
    r.visible = !1, this.addChild(r), GrpLayer.csv2Sprites(e, r, (S) => {
      r.parent || r.removeChild(S);
    });
  }
  static delBreak() {
    const e = z(Qt, zr);
    e.parent && (e.parent.removeChild(e), e.removeChildren()), at(Qt, zr, new Container());
  }
  reNew() {
    var r;
    lt(this, Uo, af).call(this);
    const e = new Qt(this.spLay, () => this.canFocus(), this.sys);
    return at(e, Yt, z(this, Yt)), z(e, ne).style.cssText = z(this, ne).style.cssText, at(e, Cr, z(this, Cr)), e.name = this.name, lt(r = e, qs, cu).call(r), z(e, sr).sethArg(z(this, sr).gethArg()), at(e, En, z(this, En)), at(e, ji, z(this, ji)), at(e, Pn, z(this, Pn)), at(e, li, z(this, li)), at(e, ar, z(this, ar)), at(e, or, z(this, or)), this.destroy(), e;
  }
  record() {
    return {
      infTL: z(this, Yt),
      cssText: z(this, ne).style.cssText,
      left: z(this, Cr),
      idc_hArg: z(this, sr).gethArg(),
      ch_filter: z(this, En),
      fi_easing: z(this, ji),
      fo_easing: z(this, Pn),
      break_fixed: z(this, li),
      break_fixed_left: z(this, ar),
      break_fixed_top: z(this, or)
    };
  }
  playback(e) {
    at(this, Yt, e.infTL), this.position.set(z(this, Yt).pad_left, z(this, Yt).pad_top), z(this, ne).style.cssText = e.cssText, at(this, Cr, e.left), lt(this, qs, cu).call(this), z(this, sr).sethArg(e.idc_hArg), at(this, En, e.ch_filter), at(this, ji, e.fi_easing), at(this, Pn, e.fo_easing), at(this, li, e.break_fixed ?? !1), at(this, ar, e.break_fixed_left ?? 0), at(this, or, e.break_fixed_top ?? 0);
  }
  snapshot(e, r) {
    lt(this, oh, fd).call(this, (S) => {
      at(this, We, new Sprite(S)), z(this, Ui) && (z(this, We).x += CmnLib.stageW - (z(this, Cr) + z(this, Yt).$width)), z(this, We).y -= z(this, Ks), z(this, We).texture.frame = new Rectangle(
        0,
        0,
        Math.min(z(this, We).width, z(this, Yt).$width - z(this, Cr)),
        Math.min(z(this, We).height, z(this, Yt).$height)
      ), z(this, jr).addChild(z(this, We)), e.render(z(this, We), { clear: !1 }), r();
    }, !1);
  }
  snapshot_end() {
    z(this, We) && (z(this, jr).removeChild(z(this, We)), at(this, We, void 0));
  }
  makeDesignCast(e) {
    e(z(this, sr));
    const r = z(this, sr).gethArg();
    z(this, Gi).sethArg({ ...r, ":id_dc": r[":id_tag"] + "_pad" }), e(z(this, Gi));
  }
  showDesignCast() {
    z(this, sr).visible = !0, z(this, Gi).visible = !0;
  }
  dump() {
    const e = [], r = z(this, ne).style, S = r.length;
    for (let T = 0; T < S; ++T) {
      const D = r[T];
      e.push(`"${D}":"${r[D].replaceAll(/(["\\])/g, "\\$1")}"`);
    }
    return `"txt":"${z(this, ne).textContent.replaceAll(/(["\\])/g, "\\$1")}", "style":{${e.join(",")}}`;
  }
  destroy() {
    Qt.delBreak(), z(this, ne).parentElement.removeChild(z(this, ne)), this.removeChild(z(this, jr)), this.removeChild(z(this, oi)), super.destroy();
  }
};
let TxtStage = Qt;
Ws = new WeakMap(), Lo = new WeakMap(), Sn = new WeakMap(), ne = new WeakMap(), jr = new WeakMap(), oi = new WeakMap(), ah = new WeakMap(), sr = new WeakMap(), Gi = new WeakMap(), Yt = new WeakMap(), li = new WeakMap(), ar = new WeakMap(), or = new WeakMap(), qs = new WeakSet(), cu = function() {
  const e = z(this, ne).style, r = parseFloat(e.fontSize || "0");
  z(this, Yt).fontsize = r, z(this, Yt).pad_left = parseFloat(e.paddingLeft || "0"), z(this, Yt).pad_right = parseFloat(e.paddingRight || "0"), z(this, Yt).pad_top = parseFloat(e.paddingTop || "0"), z(this, Yt).pad_bottom = parseFloat(e.paddingBottom || "0"), z(this, Yt).$width = parseFloat(e.width || "0"), z(this, Yt).$height = parseFloat(e.height || "0"), this.position.set(z(this, Yt).pad_left, z(this, Yt).pad_top), at(this, Ui, e.writingMode === "vertical-rl"), at(this, ko, 0), at(this, Ks, 0);
  const S = e.lineHeight ?? "0";
  at(this, Qs, z(this, Ui) ? 0 : (S.slice(-2) === "px" ? parseFloat(S) : r * parseFloat(S) - r) / 2);
}, Cr = new WeakMap(), Ui = new WeakMap(), ko = new WeakMap(), Ks = new WeakMap(), oh = new WeakSet(), fd = function(e, r = !0) {
  const S = {
    escape: (q) => q.replaceAll(/([.*+?^${}()|\[\]\/\\])/g, "\\$1"),
    mimeType: (q) => {
      const K = $(q).toLowerCase();
      return T()[K] || "";
    },
    dataAsUrl: X,
    isDataUrl: U,
    resolveUrl: H,
    getAndEncode: V,
    asArray: (q) => {
      const K = [], Z = q.length;
      for (let J = 0; J < Z; ++J)
        K.push(q[J]);
      return K;
    }
  };
  function T() {
    const q = "application/font-woff", K = "image/jpeg";
    return {
      woff: q,
      woff2: q,
      ttf: "application/font-truetype",
      eot: "application/vnd.ms-fontobject",
      png: "image/png",
      jpg: K,
      jpeg: K,
      gif: "image/gif",
      tiff: "image/tiff",
      svg: "image/svg+xml"
    };
  }
  const D = W(), N = Y();
  function B(q) {
    return N.resolveAll().then((K) => {
      const Z = document.createElement("style");
      return q.appendChild(Z), Z.appendChild(document.createTextNode(K)), q;
    });
  }
  function $(q) {
    const K = /\.([^\.\/]*?)$/g.exec(q);
    return (K == null ? void 0 : K[1]) ?? "";
  }
  function U(q) {
    return q.search(/^(data:)/) !== -1;
  }
  function H(q, K) {
    const Z = document.implementation.createHTMLDocument(), J = Z.createElement("base");
    Z.head.appendChild(J);
    const Q = Z.createElement("a");
    return Z.body.appendChild(Q), J.href = K, Q.href = q, Q.href;
  }
  function V(q) {
    let K = 3e4;
    return new Promise(function(Z) {
      const J = new XMLHttpRequest();
      J.onreadystatechange = Q, J.ontimeout = rt, J.responseType = "blob", J.timeout = K, J.open("GET", q, !0), J.send();
      function Q() {
        if (J.readyState !== 4)
          return;
        if (J.status !== 200) {
          et("cannot fetch resource: " + q + ", status: " + J.status);
          return;
        }
        const nt = new FileReader();
        nt.onloadend = function() {
          const st = nt.result.toString().split(/,/)[1];
          Z(st);
        }, nt.readAsDataURL(J.response);
      }
      function rt() {
        et("timeout of " + K + "ms occured while fetching resource: " + q);
      }
      function et(nt) {
        console.error(nt), Z("");
      }
    });
  }
  function X(q, K) {
    return "data:" + K + ";base64," + q;
  }
  function W() {
    const q = /url\(['"]?([^'"]+?)['"]?\)/g;
    return {
      inlineAll: Q,
      shouldProcess: K
    };
    function K(rt) {
      return rt.search(q) !== -1;
    }
    function Z(rt) {
      const et = [];
      let nt;
      for (; nt = q.exec(rt); )
        et.push(nt[1]);
      return et.filter(function(st) {
        return !S.isDataUrl(st);
      });
    }
    function J(rt, et, nt, st) {
      return Promise.resolve(et).then((ot) => nt ? S.resolveUrl(ot, nt) : ot).then(st || S.getAndEncode).then((ot) => S.dataAsUrl(ot, S.mimeType(et))).then((ot) => rt.replace(it(et), "$1" + ot + "$3"));
      function it(ot) {
        return new RegExp(`(url\\(['"]?)(` + S.escape(ot) + `)(['"]?\\))`, "g");
      }
    }
    function Q(rt, et, nt) {
      if (st())
        return Promise.resolve(rt);
      return Promise.resolve(rt).then(Z).then((it) => {
        let ot = Promise.resolve(rt);
        for (const ht of it)
          ot = ot.then((ct) => J(ct, ht, et, nt));
        return ot;
      });
      function st() {
        return !K(rt);
      }
    }
  }
  function Y() {
    return {
      resolveAll: q,
      impl: { readAll: K }
    };
    function q() {
      return K().then((Z) => Promise.allSettled(
        Z.map((J) => J.resolve())
      )).then((Z) => Z.join(`
`));
    }
    function K() {
      return Promise.resolve(S.asArray(document.styleSheets)).then(J).then(Z).then((rt) => rt.map(Q));
      function Z(rt) {
        return rt.filter((et) => et.type === CSSRule.FONT_FACE_RULE).filter((et) => D.shouldProcess(et.style.getPropertyValue("src")));
      }
      function J(rt) {
        const et = [];
        for (const nt of rt)
          try {
            if (nt.href)
              continue;
            S.asArray(nt.cssRules || []).forEach(et.push.bind(et));
          } catch (st) {
            console.error("Error while reading CSS rules from " + nt.href, st.toString());
          }
        return et;
      }
      function Q(rt) {
        return {
          resolve: function() {
            const nt = (rt.parentStyleSheet || {}).href;
            return D.inlineAll(rt.cssText, nt);
          },
          src: function() {
            return rt.style.getPropertyValue("src");
          }
        };
      }
    }
  }
  Promise.resolve(z(this, ne)).then((q) => {
    const K = q.cloneNode(!0);
    return K.style.padding = "0px", K.style.paddingRight = z(this, ko) + "px", K.style.paddingTop = z(this, Ks) + "px", K.style.left = "0px", K.style.top = "0px", K.style.width = z(this, Yt).$width - z(this, Yt).pad_left - z(this, Yt).pad_right + "px", K.style.height = z(this, Yt).$height - z(this, Yt).pad_top - z(this, Yt).pad_bottom + "px", z(this, ne).hidden = r, K;
  }).then(B).then((q) => {
    q.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
    const K = new Image();
    return K.src = `data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="${z(this, Yt).$width}px" height="${z(this, Yt).$height}px"><foreignObject x="0" y="0" width="100%" height="100%">${new XMLSerializer().serializeToString(q).replaceAll("#", "%23").replaceAll(`
`, "%0A")}</foreignObject></svg>`, new Promise((Z) => K.onload = () => Z(K));
  }).then((q) => new Promise((K) => setTimeout(() => K(q), 100))).then((q) => {
    const K = document.createElement("canvas");
    K.width = z(this, Yt).$width, K.height = z(this, Yt).$height, K.getContext("2d").drawImage(q, 0, 0), K.toBlob((Z) => {
      if (!Z)
        return;
      const J = URL.createObjectURL(Z);
      Texture.from(J).once("update", (Q) => {
        e(Q), URL.revokeObjectURL(J);
      });
    });
  }).catch((q) => DebugMng.myTrace(`goTxt() = ${q}`));
}, En = new WeakMap(), Zs = new WeakMap(), ui = new WeakMap(), Tn = new WeakMap(), wn = new WeakMap(), Cn = new WeakMap(), Js = new WeakMap(), Bo = new WeakMap(), hi = new WeakMap(), Fo = new WeakSet(), nf = function(e, r, S, T, D, N) {
  e.alpha = 0, r.x && (T.x = r.x.at(0) === "=" ? T.x + parseInt(r.x.slice(1)) : parseInt(r.x)), r.y && (T.y = r.y.at(0) === "=" ? T.y + parseInt(r.y.slice(1)) : parseInt(r.y)), r.width && (T.width = parseInt(r.width)), r.height && (T.height = parseInt(r.height)), r.wait && (N.wait = parseInt(r.wait)), e.width = T.width, e.height = T.height, N.x ? e.position.set(
    N.x.at(0) === "=" ? T.x + e.width * N.nx : N.nx,
    N.y.at(0) === "=" ? T.y + e.height * N.ny : N.ny
  ) : e.position.set(T.x, T.y);
  const B = {
    sp: e,
    tw: new Tween(e).to({ alpha: 1, x: T.x, y: T.y, width: T.width, height: T.height, angle: 0 }, N.wait ?? 0).easing(D).delay((S.wait ?? 0) + (r.delay ?? 0)).onComplete(() => {
      B.tw = void 0;
    }).start()
  };
  z(this, Zs).push(B);
}, ci = new WeakMap(), $o = new WeakMap(), fi = new WeakMap(), zr = new WeakMap(), Qs = new WeakMap(), Go = new WeakSet(), sf = function(e, r) {
  const S = [];
  if (e.nodeType !== e.TEXT_NODE)
    return Array.from(e.childNodes).map((B) => lt(this, Go, sf).call(this, B, r)).flat();
  const T = e.ownerDocument.createRange();
  T.selectNodeContents(e);
  let D = 0;
  const N = T.endOffset;
  for (; D < N; ) {
    T.setStart(e, D), T.setEnd(e, ++D);
    const B = T.toString();
    S.push({
      ch: B,
      rect: r(T.getBoundingClientRect(), B),
      elm: T.startContainer.parentElement
    });
  }
  return T.detach(), S;
}, ji = new WeakMap(), Pn = new WeakMap(), Uo = new WeakSet(), af = function() {
  var D;
  z(this, oi).clear(), at(this, ui, []), at(this, Tn, 0), this.skipChIn();
  const e = z(this, ne).cloneNode(!0);
  e.textContent = "";
  const r = z(this, ne);
  r.parentElement.insertBefore(e, r);
  let S = 0;
  r.querySelectorAll("span.sn_ch").forEach((N) => {
    var U, H, V;
    const B = JSON.parse(
      (N == null ? void 0 : N.dataset.add) ?? // 通常文字
      ((U = N == null ? void 0 : N.children[0]) == null ? void 0 : U.getAttribute("data-add")) ?? // ルビ
      ((V = (H = N == null ? void 0 : N.children[0]) == null ? void 0 : H.children[0]) == null ? void 0 : V.getAttribute("data-add")) ?? "{}"
      // 縦中横
    );
    if (!B.ch_out_style)
      return;
    const $ = z(Qt, fi)[B.ch_out_style];
    if ($) {
      if ($.wait === 0) {
        N.style.display = "none";
        return;
      }
      S += $.wait, $.join || (N.style.animationDelay = "0ms"), N.classList.add(`go_ch_out_${B.ch_out_style}`);
    }
  });
  const T = () => {
    r.parentElement.removeChild(r);
    for (const N of z(this, jr).removeChildren())
      N instanceof Container && z(Qt, Sn).unButton(N), N.destroy();
  };
  S === 0 ? (z(this, ne).textContent = "", T()) : (D = r.lastElementChild) == null || D.addEventListener("animationend", T, { once: !0, passive: !0 }), at(this, ne, e);
}, We = new WeakMap(), tt(TxtStage, Ws, void 0), tt(TxtStage, Lo, void 0), tt(TxtStage, Sn, void 0), tt(TxtStage, ah, {
  "background-color": 0,
  "border-bottom-width": 0,
  "border-left-width": 0,
  "border-right-width": 0,
  "border-top-width": 0,
  "margin-bottom": 0,
  "margin-left": 0,
  "margin-right": 0,
  "margin-top": 0
}), tt(TxtStage, wn, void 0), tt(TxtStage, Cn, void 0), tt(TxtStage, Js, void 0), tt(TxtStage, Bo, "<span class='sn_ch sn_ch_last'>　</span>"), tt(TxtStage, ci, /* @__PURE__ */ Object.create(null)), tt(TxtStage, $o, /[\s\.,]/), tt(TxtStage, fi, /* @__PURE__ */ Object.create(null)), tt(TxtStage, zr, new Container());
var Rn, Hr, jo;
const Ii = class {
  constructor() {
    tt(this, Hr, () => {
    });
  }
  static setting(t) {
    t.sesame && at(Ii, Rn, t.sesame);
  }
  static getSesame() {
    return z(Ii, Rn);
  }
  static destroy() {
    at(Ii, Rn, "ヽ");
  }
  init(t) {
    at(this, Hr, t);
  }
  static setEscape(t) {
    at(Ii, jo, new RegExp(
      `${t ? `(?<ce>\\${t}\\S)|` : ""}｜(?<str>[^《\\n]+)《(?<ruby>[^》\\n]+)》|(?:(?<kan>[⺀-⿟々〇〻㐀-鿿豈-﫿]+[ぁ-ヿ]*|[^　｜《》\\n])《(?<kan_ruby>[^》\\n]+)》)|(?<txt>[\uD800-\uDBFF][\uDC00-\uDFFF]|[^｜《》]+?|.)`,
      "gs"
    ));
  }
  putTxt(t) {
    for (const { groups: e } of t.matchAll(z(Ii, jo))) {
      const { ruby: r, kan_ruby: S, kan: T, ce: D, txt: N = "", str: B } = e;
      if (r) {
        this.putTxtRb(decodeURIComponent(B), r);
        continue;
      }
      if (S) {
        this.putTxtRb(T, S);
        continue;
      }
      if (D) {
        z(this, Hr).call(this, D.slice(1), "");
        continue;
      }
      for (const $ of Array.from(N))
        z(this, Hr).call(this, $, "");
    }
  }
  putTxtRb(t, e) {
    if (/^\w+｜{"/.test(e)) {
      z(this, Hr).call(this, t, e);
      return;
    }
    const r = Array.from(t), S = r.length;
    if (/^\*.?$/.test(e)) {
      const B = "center｜" + (e === "*" ? z(Ii, Rn) : e.charAt(1));
      for (let $ = 0; $ < S; ++$)
        z(this, Hr).call(this, r[$], B);
      return;
    }
    if (S === 1 || e.indexOf(" ") === -1) {
      z(this, Hr).call(this, t, decodeURIComponent(e));
      return;
    }
    const T = e.split(" "), D = T.length, N = D > S ? D : S;
    for (let B = 0; B < N; ++B)
      z(this, Hr).call(this, B < S ? r[B] : "", B < D ? decodeURIComponent(T[B]) : "");
  }
};
let RubySpliter = Ii;
Rn = new WeakMap(), Hr = new WeakMap(), jo = new WeakMap(), tt(RubySpliter, Rn, "ヽ"), /*
		★Unicodeで「漢字」の正規表現 – ものかの http://tama-san.com/kanji-regex/
		2E80..2FDF CJK部首補助＋康熙部首
		3005 々（漢字の踊り字）
		3007 〇（漢数字のゼロ）
		303B 〻（漢字の踊り字）
		3400..4DBF CJK統合漢字拡張A
		4E00..9FFF CJK統合漢字
		F900..FAFF CJK互換漢字
		20000..2FFFF CJK統合漢字拡張B〜F＋CJK互換漢字追加＋念のためU+2FFFFまで

		[\x{2E80}-\x{2FDF}々〇〻\x{3400}-\x{4DBF}\x{4E00}-\x{9FFF}\x{F900}-\x{FAFF}\x{20000}-\x{2FFFF}]
		[\u2E80-\u2FDF々〇〻\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\u20000-\u2FFFF]
		[⺀-⿟々〇〻㐀-䶿一-鿿豈-﫿\u20000-\u2FFFF]		// 含まれない文字がある
		[⺀-⿟々〇〻㐀-鿿豈-﫿\u20000-\u2FFFF]			// ヽ--30FD が変に引っかかる。多分\u2000-\u2FFF解釈
		\\u{20000}-\\u{2FFFF}	// 五桁だとエラー

		【2022/10/03】ruby正規表現のUnicode プロパティ(とPOSIX文字クラス) - Qiita https://qiita.com/Takayuki_Nakano/items/8d38beaddb84b488d683
			> このHiraganaプロパティ、長音記号は含まれていません。
			> \p{Han}…簡体字や繁体字、韓国語の漢字…ベトナム語の漢字にもマッチ
		
		・Unicode文字一覧表 - instant tools https://tools.m-bsys.com/ex/unicode_table.php
*/
tt(RubySpliter, jo, void 0);
var zo, Ho, Pr, di, ta, ea, Vo, of, ra, ia, Xo, lf;
const an = class extends Container {
  constructor(e, r, S, T) {
    var W;
    super();
    tt(this, Vo);
    tt(this, Xo);
    Pt(this, "getBtnBounds", () => z(this, Pr));
    // 文字ボタンは背景画像を含まない位置指定なので、その当たり判定用
    tt(this, Pr, new Rectangle());
    tt(this, di, void 0);
    tt(this, ta, void 0);
    tt(this, ea, void 0);
    Pt(this, "normal", () => {
    });
    tt(this, ra, () => !1);
    tt(this, ia, () => {
    });
    this.hArg = e, this.evtMng = r, this.resolve = S, this.canFocus = T, CmnLib.isDbg && (this.makeDesignCast = (Y) => Y(z(this, di)), this.cvsResize = () => z(this, di).cvsResize());
    let D = {
      x: this.x = uint(e.left ?? 0),
      y: this.y = uint(e.top ?? 0),
      rotation: this.angle = argChk_Num(e, "rotation", this.angle),
      // flash : rotation is in degrees.
      // pixijs: rotation is in radians, angle is in degrees.
      pivot_x: this.pivot.x = argChk_Num(e, "pivot_x", this.pivot.x),
      pivot_y: this.pivot.y = argChk_Num(e, "pivot_y", this.pivot.y),
      scale_x: this.scale.x = argChk_Num(e, "scale_x", this.scale.x),
      scale_y: this.scale.y = argChk_Num(e, "scale_y", this.scale.y),
      width: 0,
      height: 0
    };
    this.getBtnBounds = () => (z(this, Pr).x = D.x, z(this, Pr).y = D.y, z(this, Pr));
    const N = D.enabled = argChk_Boolean(e, "enabled", !0);
    if (N && r.button(this.hArg, this, () => this.normal(), () => z(this, ra).call(this), () => z(this, ia).call(this)), e.pic) {
      D.type = "pic", at(this, di, new PicBtnDesignCast(this, e)), GrpLayer.csv2Sprites(
        e.pic,
        this,
        (Y) => {
          lt(this, Xo, lf).call(this, Y, D), z(this, Pr).width = Y.width * D.scale_x, z(this, Pr).height = Y.height * D.scale_y;
        },
        (Y) => S
      );
      return;
    }
    if (!e.text)
      throw "textまたはpic属性は必須です";
    const B = argChk_Num(e, "height", 30), $ = new TextStyle({
      align: "center",
      dropShadow: !0,
      dropShadowAlpha: 0.7,
      dropShadowColor: "white",
      dropShadowBlur: 7,
      dropShadowDistance: 0,
      fill: N ? "black" : "gray",
      fontFamily: an.fontFamily,
      fontSize: B,
      padding: 5
    });
    if (e.style)
      try {
        const Y = JSON.parse(e.style);
        for (const [q, K] of Object.entries(Y))
          $[q] = K;
      } catch (Y) {
        throw new Error(mesErrJSON(e, "style", Y.message));
      }
    const U = new Text(e.text ?? "", $);
    U.alpha = argChk_Num(e, "alpha", U.alpha), U.width = argChk_Num(e, "width", 100), U.height = e.height = B, this.setText = (Y) => U.text = Y, D.type = "text", D = { ...D, ...$ }, D.alpha = U.alpha, D.text = U.text, D.width = U.width, D.height = U.height, at(this, di, new TxtBtnDesignCast(this, e, U));
    let H = !1;
    if (D.width = this.width, D.height = this.height, e.b_pic && (D.b_pic = e.b_pic, H = GrpLayer.csv2Sprites(
      e.b_pic,
      this,
      (Y) => {
        lt(this, Vo, of).call(this, Y, U), D.width = this.width, D.height = this.height;
      },
      (Y) => {
        Layer.setBlendmode(this, e), Y && S();
      }
    )), U.name = JSON.stringify(D), this.addChild(U), z(this, Pr).width = U.width, z(this, Pr).height = U.height, e.b_pic || Layer.setBlendmode(this, e), z(W = an, zo).call(W, this, U), !N) {
      H || S();
      return;
    }
    const V = $.clone();
    if (e.style_hover)
      try {
        const Y = JSON.parse(e.style_hover);
        for (const [q, K] of Object.entries(Y))
          V[q] = K;
      } catch (Y) {
        throw new Error(mesErrJSON(e, "style_hover", Y.message));
      }
    else
      V.fill = "white";
    const X = V.clone();
    if (e.style_clicked)
      try {
        const Y = JSON.parse(e.style_clicked);
        for (const [q, K] of Object.entries(Y))
          X[q] = K;
      } catch (Y) {
        throw new Error(mesErrJSON(e, "style_clicked", Y.message));
      }
    else
      X.dropShadow = !1;
    this.normal = () => U.style = $, at(this, ra, () => T() ? (U.style = V, !0) : !1), at(this, ia, () => U.style = X), H || S();
  }
  static init(e) {
    e.oCfg.debug.masume && (at(an, zo, (r, S) => r.addChild(
      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(S.x, S.y, S.width, S.height).endFill()
    )), at(an, Ho, (r, S, T, D) => r.addChild(
      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(S.x, S.y, T, D).endFill()
    )));
  }
  setText(e) {
  }
  destroy(e) {
    this.evtMng.unButton(this), super.destroy();
  }
  makeDesignCast(e) {
  }
  showDesignCast() {
    z(this, di).visible = !0;
  }
  cvsResize() {
  }
  update_b_pic(e, r) {
    const S = JSON.parse(r.name ?? "{}");
    z(this, ta) && this.removeChild(z(this, ta)), this.hArg.b_pic = S.b_pic = e, r.name = JSON.stringify(S), e && GrpLayer.csv2Sprites(
      e,
      this,
      (T) => lt(this, Vo, of).call(this, T, r),
      () => Layer.setBlendmode(this, this.hArg)
    );
  }
  update_pic(e, r) {
    const S = JSON.parse(r.name ?? "{}");
    z(this, ea) && this.removeChild(z(this, ea)), this.hArg.pic = S.pic = e, r.name = JSON.stringify(S), e && GrpLayer.csv2Sprites(
      e,
      this,
      (T) => lt(this, Xo, lf).call(this, T, S),
      () => Layer.setBlendmode(this, this.hArg)
    );
  }
};
let Button = an;
zo = new WeakMap(), Ho = new WeakMap(), Pr = new WeakMap(), di = new WeakMap(), ta = new WeakMap(), ea = new WeakMap(), Vo = new WeakSet(), of = function(e, r) {
  at(this, ta, e), this.setChildIndex(e, 0), e.alpha = r.alpha, e.setTransform(
    r.x,
    r.y,
    1,
    1,
    r.rotation,
    0,
    0,
    (e.width - r.width) / 2,
    (e.height - r.height) / 2
  ), e.name = r.name;
}, ra = new WeakMap(), ia = new WeakMap(), Xo = new WeakSet(), lf = function(e, r) {
  var H;
  at(this, ea, e), r.alpha = e.alpha = argChk_Num(this.hArg, "alpha", e.alpha), z(this, di).setSp(e);
  const S = e.width / 3, T = e.height, D = e.texture.baseTexture, N = new Texture(D, new Rectangle(0, 0, S, T)), B = new Texture(D, new Rectangle(S, 0, S, T)), $ = new Texture(D, new Rectangle(S * 2, 0, S, T)), U = () => e.texture = N;
  U(), this.normal = U, at(this, ra, () => this.canFocus() ? (e.texture = $, !0) : !1), at(this, ia, () => e.texture = B), "width" in this.hArg ? (r.width = uint(this.hArg.width), this.scale.x *= r.width / S) : r.width = S, "height" in this.hArg ? (r.height = uint(this.hArg.height), this.scale.y *= r.height / T) : r.height = T, e.name = JSON.stringify(r), z(H = an, Ho).call(H, this, e, S, T);
}, Pt(Button, "fontFamily", "'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif"), tt(Button, zo, (e, r) => {
}), tt(Button, Ho, (e, r, S, T) => {
});
var na, Rr, Yo, sa, Wo, uf, qo, hf, Ko, Mn, Zo, pi, On, lh, dd, vi, vr, Mr, ve, Vr, he, Jo, Xr, uh, qe, In, za, Dn, aa, An, Ha, oa, Qo, cf, tl, ff, Nn, Ln, la, el, ua, zi, Ke, hh, pd, lr, rl, ha, fu, gi, rn, Yr, Or, gr, mr, il, df, ca, du, nl, pf, kn;
const ee = class extends Layer {
  constructor() {
    super();
    tt(this, In);
    tt(this, An);
    tt(this, Qo);
    tt(this, tl);
    tt(this, hh);
    tt(this, ha);
    tt(this, gi);
    tt(this, il);
    tt(this, ca);
    tt(this, nl);
    // バック
    tt(this, vi, 0);
    tt(this, vr, 0);
    tt(this, Mr, !1);
    tt(this, ve, void 0);
    tt(this, Vr, "");
    // 背景画像無し（＝単色塗り）
    // 文字表示
    tt(this, he, new TxtStage(this.spLay, () => this.canFocus(), z(ee, Zo)));
    tt(this, Jo, new RubySpliter());
    tt(this, Xr, document.createElement("span"));
    tt(this, qe, new Container());
    tt(this, Dn, "");
    tt(this, aa, !0);
    tt(this, oa, "");
    tt(this, Nn, "");
    tt(this, Ln, (e) => "");
    tt(this, la, "");
    tt(this, el, new RegExp("[　]"));
    Pt(this, "isCur", !1);
    tt(this, zi, () => "");
    tt(this, Ke, "");
    tt(this, lr, !1);
    tt(this, rl, (e, r) => {
      var $, U, H;
      z(ee, na).oCfg.debug.putCh && console.log(`🖊 文字表示 text:\`${e}\` ruby:\`${r}\` name:\`${this.name_}\``);
      const S = r.split("｜");
      let T = "";
      const [D, ...N] = S, B = N.join("｜");
      switch (S.length) {
        case 1:
          if (at(this, lr, !0), e === `
`) {
            z(this, Or) ? (at(this, Or, !1), T = "<ruby>　<rt>　</rt></ruby><br/>") : T = "<br/>";
            break;
          }
          z(this, Or) && (at(this, Or, !1), r === "" && (r = "　")), T = lt(this, ha, fu).call(this, e, r, z(this, Ke));
          break;
        default:
          switch (D) {
            case "start":
            case "left":
            case "center":
            case "right":
            case "justify":
            case "121":
            case "even":
            case "1ruby":
              at(this, Or, !1), at(this, lr, !0), T = lt(this, ha, fu).call(this, e, B, D);
              break;
            case "gotxt":
              lt(this, ca, du).call(this), z(this, lr) ? (this.isCur && z(ee, sa).recText(
                z(this, gr).join("").replace(/^<ruby>　<rt>　<\/rt><\/ruby>(<br\/>)+/, "").replaceAll(/style='(anim\S+ \S+?;\s*)+/g, "style='").replaceAll(/( style=''| data-(add|arg|cmd)='.+?'|\n+|\t+)/g, "").replaceAll(/class='sn_ch .+?'/g, "class='sn_ch'").replaceAll("display: none;", "").replaceAll("class='offrec'", "style='display: none;'")
                // 囲んだ領域は履歴で非表示
              ), z(this, he).goTxt(z(this, gr), z(this, Yr) === 0), at(this, lr, !1), at(this, Yr, 0)) : this.isCur && z(ee, Mn).noticeCompTxt();
              return;
            case "add":
              {
                const V = JSON.parse(B), { style: X = "", wait: W = null } = V, { cl: Y, sty: q } = lt(this, gi, rn).call(this, !0, W);
                z(this, gr).push(`<span${Y} style='${q} display: inline; ${X}'>`), delete V.style, lt(this, il, df).call(this, V);
              }
              return;
            case "add_close":
              z(this, gr).push("</span>"), lt(this, ca, du).call(this);
              return;
            case "grp":
              at(this, lr, !0);
              {
                const V = JSON.parse(B);
                if (V.id ?? (V.id = z(this, gr).length), V.id === "break") {
                  z(this, he).dispBreak(V.pic);
                  return;
                }
                at(this, Or, !1), V.delay = z(this, Yr), V.r ?? (V.r = ""), V.style ?? (V.style = ""), V.r_style ?? (V.r_style = "");
                const { cl: X, sty: W, lnk: Y } = lt(this, gi, rn).call(this, !0, V.wait);
                T = `<span${X} style='${W} ${V.style}'><ruby><span data-cmd='grp' data-arg='${JSON.stringify(V)}'${Y} style='${W} display: inline;'>　</span><rt${Y}${this.mkStyle_r_align(
                  "　",
                  V.r,
                  z(this, Ke),
                  z(this, Xr).style.cssText + ((($ = z(this, mr).at(-1)) == null ? void 0 : $.o.r_style) ?? "") + V.r_style
                )}>${V.r}</rt></ruby></span>`;
              }
              break;
            case "tcy":
              at(this, Or, !1), at(this, lr, !0);
              {
                z(ee, Rr).doRecLog() && at(this, kn, z(this, kn) + (e + (r ? `《${r}》` : "")));
                const { t: V, r: X = "", wait: W = null, style: Y = "", r_style: q = "" } = JSON.parse(B), K = CmnLib.isSafari ? X.replaceAll(/[A-Za-z0-9]/g, (rt) => String.fromCharCode(rt.charCodeAt(0) + 65248)) : X, { cl: Z, sty: J, lnk: Q } = lt(this, gi, rn).call(this, !0, W);
                T = `<span${Z} style='${J}${z(this, Ln).call(this, V)} ${Y}'><ruby><span${Q} style='${J} display: inline;
text-combine-upright: all;
-webkit-text-combine: horizontal;'>${V}</span><rt${Q}${this.mkStyle_r_align(
                  V,
                  K,
                  z(this, Ke),
                  z(this, Xr).style.cssText + (((U = z(this, mr).at(-1)) == null ? void 0 : U.o.r_style) ?? "") + q
                )}>${K}</rt></ruby></span>`;
              }
              break;
            case "del":
              TxtStage.delBreak();
              return;
            case "span":
              at(this, lr, !0), lt(this, nl, pf).call(this, JSON.parse(B));
              return;
            case "link":
              at(this, lr, !0);
              {
                const V = JSON.parse(B);
                V[":link"] = " data-lnk='@'";
                const { cl: X, sty: W, curpos: Y } = lt(this, gi, rn).call(this, !1, V.wait);
                z(this, gr).push(`<span${X} style='${W} display: inline; ${V.style ?? ""}' ${Y} data-arg='${B}'>`), delete V.style, lt(this, nl, pf).call(this, V);
              }
              return;
            case "endlink":
              at(this, lr, !0), z(this, gr).push("</span>"), lt(this, ca, du).call(this);
              return;
            default:
              at(this, lr, !0), T = lt(this, ha, fu).call(this, e, r, z(this, Ke));
          }
          break;
      }
      z(this, gr).push(z(H = ee, ua).call(H, T));
    });
    tt(this, Yr, 0);
    tt(this, Or, !0);
    tt(this, gr, []);
    tt(this, mr, []);
    Pt(this, "click", () => !this.spLay.interactiveChildren || !this.spLay.visible ? !1 : z(this, he).skipChIn());
    tt(this, kn, "");
    Pt(this, "addButton", (e) => new Promise((r) => {
      e.key = `btn=[${z(this, qe).children.length}] ` + this.name_, e[":id_tag"] = e.key.slice(0, -7), argChk_Boolean(e, "hint_tate", z(this, he).tategaki);
      const S = new Button(e, z(ee, Mn), () => r(), () => this.canFocus());
      S.name = JSON.stringify(e).replaceAll('"', "'"), z(this, qe).addChild(S);
    }));
    Pt(this, "record", () => ({
      ...super.record(),
      enabled: this.enabled,
      r_cssText: z(this, Xr).style.cssText,
      r_align: z(this, Ke),
      // バック
      b_do: z(this, ve) === void 0 ? void 0 : z(this, ve) instanceof Sprite ? "Sprite" : "Graphics",
      b_pic: z(this, Vr),
      b_color: z(this, vi),
      b_alpha: z(this, vr),
      b_alpha_isfixed: z(this, Mr),
      ffs: z(this, Nn),
      txs: z(this, he).record(),
      strNoFFS: z(this, la),
      btns: z(this, qe).children.map((e) => e.name)
    }));
    this.spLay.addChild(z(this, he)), z(this, Jo).init(z(this, rl)), this.spLay.addChild(z(this, qe)), z(this, qe).name = "cntBtn";
    const e = 16;
    this.lay({ style: `width: ${CmnLib.stageW}px; height: ${CmnLib.stageH}px; font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif; color: white; font-size: 24px; line-height: 1.5; padding: ${e}px;`, in_style: "default", out_style: "default", back_clear: "true" });
  }
  static init(e, r, S, T, D, N) {
    var B, $;
    at(ee, na, e), TxtStage.init(e, N), at(ee, Rr, S), at(ee, sa, T), at(ee, Yo, D), S.setDoRecProc(ee.chgDoRec), r.autowc = (U) => {
      var H;
      return lt(H = ee, lh, dd).call(H, U);
    }, r.autowc({ enabled: !1, text: "", time: 0 }), r.ch_in_style = (U) => {
      var H;
      return lt(H = ee, Wo, uf).call(H, U);
    }, r.ch_out_style = (U) => {
      var H;
      return lt(H = ee, qo, hf).call(H, U);
    }, TxtStage.initChStyle(), initStyle(), addStyle(
      e.matchPath(".+", SEARCH_PATH_ARG_EXT.FONT).flatMap((U) => Object.values(U).map((H) => `
@font-face {
	font-family: '${H}';
	src: url('${z(this, na).searchPath(H, SEARCH_PATH_ARG_EXT.FONT)}');
}
`)).join("") + `
.sn_tx {
	pointer-events: none;
	user-select: none;
	-webkit-touch-callout: none;
	box-sizing: border-box;
}
.sn_ch {
	position: relative;
	display: inline-block;
}
`
      // 「sn_ch」と「sn_ch_in_〜」の中身が重複しているが、これは必須
    ), lt(B = ee, Wo, uf).call(B, {
      name: "default",
      wait: 500,
      alpha: 0,
      x: "=0.3",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: !0,
      ease: "ease-out"
    }), lt($ = ee, qo, hf).call($, {
      name: "default",
      wait: 0,
      alpha: 0,
      x: "=0",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: !1,
      ease: "ease-out"
    });
  }
  static setEvtMng(e, r, S) {
    at(ee, Ko, e), at(ee, Mn, r), at(ee, Zo, S), TxtStage.setEvtMng(r);
  }
  destroy() {
    z(this, ve) && (this.spLay.removeChild(z(this, ve)).destroy(), at(this, ve, void 0)), this.clearText(), z(this, he).destroy();
  }
  static destroy() {
    at(ee, pi, !1), at(ee, On, {}), at(ee, ua, (e) => e);
  }
  set name(e) {
    this.name_ = e, z(this, he).name = e;
  }
  get name() {
    return this.name_;
  }
  // getは継承しないらしい
  cvsResize() {
    z(this, he).cvsResize();
  }
  cvsResizeChildren() {
    for (const e of z(this, qe).children)
      e.cvsResize();
  }
  lay(e) {
    if (super.lay(e), Layer.setXY(this.spLay, e, this.spLay), e[":id_tag"] = this.name_.slice(0, -7), RubySpliter.setting(e), lt(this, tl, ff).call(this, e), z(this, he).lay(e), "r_align" in e && at(this, Ke, e.r_align ?? ""), at(this, zi, CmnLib.isSafari ? z(this, he).tategaki ? (r, S) => `text-align: start; height: ${S}em; padding-top: ${r}; padding-bottom: ${r};` : (r, S) => `text-align: start; width: ${S}em; padding-left: ${r}; padding-right: ${r};` : z(this, he).tategaki ? (r) => `text-align: justify; text-align-last: justify; padding-top: ${r}; padding-bottom: ${r};` : (r) => `text-align: justify; text-align-last: justify; padding-left: ${r}; padding-right: ${r};`), CmnLib.isFirefox && (this.mkStyle_r_align = lt(this, hh, pd)), "r_style" in e)
      if (e.r_style) {
        const r = document.createElement("span");
        r.style.cssText = e.r_style;
        const S = r.style.length, T = z(this, Xr).style;
        for (let D = 0; D < S; ++D) {
          const N = r.style[D];
          if (N in z(ee, uh)) {
            DebugMng.myTrace(`${N}は指定できません`, "W");
            continue;
          }
          T[N] = r.style[N];
        }
      } else
        z(this, Xr).style.cssText = "";
    if ("alpha" in e)
      for (const r of z(this, qe).children)
        r.alpha = this.spLay.alpha;
    return lt(this, In, za).call(this, e), lt(this, An, Ha).call(this, e), lt(this, Qo, cf).call(this, e, (r) => {
      r && z(ee, Ko).resume();
    });
  }
  get width() {
    return z(this, he).getWidth;
  }
  get height() {
    return z(this, he).getHeight;
  }
  chgBackAlpha(e) {
    const r = z(this, Mr) ? z(this, vr) : e * z(this, vr);
    z(this, ve) instanceof Graphics && (z(this, ve) && (this.spLay.removeChild(z(this, ve)), z(this, ve).destroy()), this.spLay.addChildAt(
      at(this, ve, new Graphics()).beginFill(z(this, vi)).lineStyle(void 0).drawRect(0, 0, z(this, he).getWidth, z(this, he).getHeight).endFill(),
      0
    ), z(this, ve).name = "back(color)"), z(this, ve) && (z(this, ve).visible = r > 0, z(this, ve).alpha = r);
  }
  // Safariが全体に「font-feature-settings」した後、特定文字の「font-feature-settings: initial;」を受け付けてくれないのでわざわざ一つずつ指定
  static chgDoRec(e) {
    at(ee, ua, e ? (r) => r : (r) => `<span class='offrec'>${r}</span>`);
  }
  mkStyle_r_align(e, r, S, T = "") {
    if (!S)
      return ` style='${T}'`;
    const D = e.length * 2;
    if (D - r.length < 0)
      return ` style='text-align: ${S}; ${T}'`;
    let N = "";
    switch (S) {
      case "justify":
        N = z(this, zi).call(this, "0", D);
        break;
      case "121":
        N = z(this, zi).call(this, `calc(${(D - r.length) / (r.length * 2)}em)`, D);
        break;
      case "even":
        N = z(this, zi).call(this, `calc(${(D - r.length) / (r.length + 1)}em)`, D);
        break;
      case "1ruby":
        N = z(this, zi).call(this, "1em", D);
        break;
      default:
        N = `text-align: ${S};`;
    }
    return ` style='${N} ${T}'`;
  }
  tagCh(e) {
    z(this, Jo).putTxt(e);
  }
  clearText() {
    this.spLay.addChild(at(this, he, z(this, he).reNew())), at(this, Yr, 0), at(this, Or, !0), at(this, gr, []), at(this, kn, ""), z(ee, sa).recPagebreak();
  }
  get pageText() {
    return z(this, kn).replace("《　》", "");
  }
  get enabled() {
    return this.spLay.interactiveChildren;
  }
  set enabled(e) {
    this.spLay.interactiveChildren = e;
  }
  canFocus() {
    var e;
    return (this.spLay.interactiveChildren ?? !1) && this.spLay.visible && z(e = ee, Yo).call(e, this);
  }
  clearLay(e) {
    super.clearLay(e), this.clearText();
    for (const r of z(this, qe).removeChildren())
      r.destroy();
  }
  playback(e, r) {
    super.playback(e, r), this.enabled = e.enabled, z(this, Xr).style.cssText = e.r_cssText, at(this, Ke, e.r_align), this.cvsResize(), lt(this, tl, ff).call(this, e), z(this, he).playback(e.txs), at(this, vr, e.b_alpha), at(this, Mr, e.b_alpha_isfixed), r.push(new Promise((T) => {
      const D = e.b_do ? e.b_do === "Sprite" ? { b_pic: e.b_pic } : { b_color: e.b_color } : { b_pic: "" };
      D.b_alpha = e.b_alpha, D.b_alpha_isfixed = e.b_alpha_isfixed, lt(this, Qo, cf).call(this, D, (N) => {
        N && T();
      }) || T();
    }));
    const S = e.btns;
    r = r.concat(S.map((T) => this.addButton(JSON.parse(T.replaceAll("'", '"')))));
  }
  snapshot(e, r) {
    e.render(this.spLay, { clear: !1 }), z(this, he).snapshot(e, r);
  }
  snapshot_end() {
    z(this, he).snapshot_end();
  }
  makeDesignCast(e) {
    this.spLay.visible && z(this, he).makeDesignCast(e);
  }
  makeDesignCastChildren(e) {
    if (this.spLay.visible)
      for (const r of z(this, qe).children)
        r.makeDesignCast(e);
  }
  showDesignCast() {
    z(this, he).showDesignCast();
  }
  showDesignCastChildren() {
    for (const e of z(this, qe).children)
      e.showDesignCast();
  }
  dump() {
    return z(this, rl).call(this, "", "gotxt｜"), super.dump() + `, "enabled":"${this.enabled}", ${z(this, he).dump()}, "b_pic":"${z(this, Vr)}", "b_color":"${z(this, vi)}", "b_alpha":${z(this, vr)}, "b_alpha_isfixed":"${z(this, Mr)}", "width":${z(this, he).getWidth}, "height":${z(this, he).getHeight}, "pixi_obj":[${this.spLay.children.map((e) => `{"class":"${e instanceof Sprite ? "Sprite" : e instanceof Graphics ? "Graphics" : e instanceof Container ? "Container" : "?"}", "name":"${e.name}", "alpha":${e.alpha}, "x":${e.x}, "y":${e.y}, "visible":"${e.visible}"}`).join(",")}], "button":[${z(this, qe).children.map((e) => e.children[0].name ?? "{}").join(",")}]`;
  }
};
let TxtLayer = ee;
na = new WeakMap(), Rr = new WeakMap(), Yo = new WeakMap(), sa = new WeakMap(), Wo = new WeakSet(), uf = function(e) {
  const r = TxtStage.ch_in_style(e), S = r.x.at(0) === "=" ? `${r.nx * 100}%` : `${r.nx}px`, T = r.y.at(0) === "=" ? `${r.ny * 100}%` : `${r.ny}px`, { name: D } = e;
  return addStyle(`
.sn_ch_in_${D} {
	position: relative;
	display: inline-block;
}
.go_ch_in_${D} {
	opacity: ${r.alpha};
	position: relative;
	display: inline-block;
	animation: sn_ch_in_${D} ${r.wait}ms ${r.ease} 0s both;
}
@keyframes sn_ch_in_${D} {
	from {transform: rotate(${r.rotate}deg) scale(${r.scale_x}, ${r.scale_y}) translate(${S}, ${T});}
	to {opacity: 1; transform: none;}
}
`), !1;
}, qo = new WeakSet(), hf = function(e) {
  const r = TxtStage.ch_out_style(e), S = r.x.at(0) === "=" ? `${r.nx * 100}%` : `${r.nx}px`, T = r.y.at(0) === "=" ? `${r.ny * 100}%` : `${r.ny}px`, { name: D } = e;
  return addStyle(`
.go_ch_out_${D} {
	position: relative;
	display: inline-block;
	animation: go_ch_out_${D} ${r.wait}ms ${r.ease} 0s both;
}
@keyframes go_ch_out_${D} {
	to {
		opacity: ${r.alpha};
		transform: rotate(${r.rotate}deg) scale(${r.scale_x}, ${r.scale_y}) translate(${S}, ${T});
	}
`), !1;
}, Ko = new WeakMap(), Mn = new WeakMap(), Zo = new WeakMap(), pi = new WeakMap(), On = new WeakMap(), lh = new WeakSet(), dd = function(e) {
  at(ee, pi, argChk_Boolean(e, "enabled", z(ee, pi))), z(ee, Rr).setVal_Nochk("save", "const.sn.autowc.enabled", z(ee, pi));
  const { text: r } = e;
  if ("text" in e != "time" in e)
    throw "[autowc] textとtimeは同時指定必須です";
  if (z(ee, Rr).setVal_Nochk("save", "const.sn.autowc.text", r), !r)
    return z(ee, Rr).setVal_Nochk("save", "const.sn.autowc.time", ""), !1;
  const S = r.length;
  if (z(ee, pi) && S === 0)
    throw '[autowc] enabled === false かつ text === "" は許されません';
  const T = String(e.time).split(",");
  if (T.length !== S)
    throw "[autowc] text文字数とtimeに記述された待ち時間（コンマ区切り）は同数にして下さい";
  return at(ee, On, {}), T.forEach((D, N) => z(ee, On)[r[N]] = uint(D)), z(ee, Rr).setVal_Nochk("save", "const.sn.autowc.time", e.time), !1;
}, vi = new WeakMap(), vr = new WeakMap(), Mr = new WeakMap(), ve = new WeakMap(), Vr = new WeakMap(), he = new WeakMap(), Jo = new WeakMap(), Xr = new WeakMap(), uh = new WeakMap(), qe = new WeakMap(), In = new WeakSet(), za = function(e) {
  const { in_style: r } = e;
  if (!r)
    return;
  const S = TxtStage.getChInStyle(r);
  if (!S)
    throw `存在しないin_style【${r}】です`;
  at(this, Dn, r), at(this, aa, S.join);
}, Dn = new WeakMap(), aa = new WeakMap(), An = new WeakSet(), Ha = function(e) {
  const { out_style: r } = e;
  if (!r)
    return;
  if (!TxtStage.getChOutStyle(r))
    throw `存在しないout_style【${r}】です`;
  at(this, oa, r);
}, oa = new WeakMap(), Qo = new WeakSet(), cf = function(e, r) {
  if ("back_clear" in e)
    return argChk_Boolean(e, "back_clear", !1) && (at(this, vi, 0), at(this, vr, 0), at(this, Mr, !1), at(this, Vr, "")), r(!1), !1;
  at(this, vr, argChk_Num(e, "b_alpha", z(this, vr))), at(this, Mr, argChk_Boolean(e, "b_alpha_isfixed", z(this, Mr)));
  const S = (z(this, Mr) ? 1 : Number(z(ee, Rr).getVal("sys:TextLayer.Back.Alpha"))) * z(this, vr);
  if (e.b_pic) {
    if (z(this, Vr) !== e.b_pic)
      return at(this, Vr, e.b_pic), z(this, ve) && (this.spLay.removeChild(z(this, ve)), z(this, ve).destroy()), GrpLayer.csv2Sprites(z(this, Vr), this.spLay, (T) => {
        at(this, ve, T), T.name = "back(pic)", T.visible = S > 0, T.alpha = S, z(this, he).setSize(T.width, T.height), this.spLay.setChildIndex(T, 0), r(!0);
      });
  } else
    "b_color" in e && (at(this, vi, argChk_Color(e, "b_color", 0)), z(this, ve) && (this.spLay.removeChild(z(this, ve)), z(this, ve).destroy()), at(this, Vr, ""), this.spLay.addChildAt(
      at(this, ve, new Graphics()).beginFill(z(this, vi)).lineStyle(void 0).drawRect(0, 0, z(this, he).getWidth, z(this, he).getHeight).endFill(),
      0
    ), z(this, ve).name = "back(color)");
  return z(this, ve) && (z(this, ve).visible = S > 0, z(this, ve).alpha = S), r(!1), !1;
}, tl = new WeakSet(), ff = function(e) {
  "noffs" in e && (at(this, la, e.noffs ?? ""), at(this, el, new RegExp(`[　${z(this, la)}]`))), "ffs" in e && (z(this, Nn) ?? at(this, Nn, ""), at(this, Ln, z(this, Nn) === "" ? () => "" : (r) => z(this, el).test(r) ? "" : ` font-feature-settings: ${z(this, Nn)};`));
}, Nn = new WeakMap(), Ln = new WeakMap(), la = new WeakMap(), el = new WeakMap(), ua = new WeakMap(), zi = new WeakMap(), Ke = new WeakMap(), hh = new WeakSet(), pd = function(e, r, S, T = "") {
  if (!S)
    return ` style='${T}'`;
  const D = e.length * 2;
  if (D - r.length < 0)
    return ` style='text-align: ${S}; ${T}'`;
  let N = "";
  switch (S) {
    case "left":
      N = "ruby-align: start;";
      break;
    case "center":
      N = "ruby-align: center;";
      break;
    case "right":
      N = "ruby-align: start;";
      break;
    case "justify":
      N = "ruby-align: space-between;";
      break;
    case "121":
      N = "ruby-align: space-around;";
      break;
    case "even":
      const B = (D - r.length) / (r.length + 1);
      N = "ruby-align: space-between; " + (z(this, he).tategaki ? `padding-top: ${B}em; padding-bottom: ${B}em;` : `padding-left: ${B}em; padding-right: ${B}em;`);
      break;
    case "1ruby":
      N = "ruby-align: space-between; " + (z(this, he).tategaki ? "padding-top: 1em; padding-bottom: 1em;" : "padding-left: 1em; padding-right: 1em;");
      break;
    default:
      N = `text-align: ${S};`;
  }
  return ` style='${N} ${T}'`;
}, lr = new WeakMap(), rl = new WeakMap(), ha = new WeakSet(), fu = function(e, r, S) {
  var $;
  const T = e === " " ? "&nbsp;" : e;
  z(ee, Rr).doRecLog() && at(this, kn, z(this, kn) + (T + (r ? `《${r}》` : "")));
  const { cl: D, sty: N, lnk: B } = lt(this, gi, rn).call(this, !0, null, e);
  return r ? `<span${D} style='${N} ${z(this, Ln).call(this, e)}'><ruby>${// 文字個別に出現させるため以下にも ${cl} が必要
  Array.from(e).map((U, H) => `<span${D}${B} style='${H > 0 ? lt(this, gi, rn).call(this, !0, null, e).sty : N} display: inline;'>${U === " " ? "&nbsp;" : U}</span>`).join("")}<rt${B}${this.mkStyle_r_align(
    e,
    r,
    S,
    z(this, Xr).style.cssText + ((($ = z(this, mr).at(-1)) == null ? void 0 : $.o.r_style) ?? "")
  )}>${r}</rt></ruby></span>` : `<span${D} style='${N} ${z(this, Ln).call(this, e)}'${B}>${T}</span>`;
}, gi = new WeakSet(), rn = function(e, r, S = `
`) {
  var N, B, $;
  const T = z(this, aa) ? r ?? ((N = z(this, mr).at(0)) == null ? void 0 : N.o.wait) ?? (z(ee, pi) ? z(ee, On)[S.at(0) ?? ""] ?? 0 : LayerMng.msecChWait) : 0;
  z(ee, Mn).isSkippingByKeyDown() ? at(this, Yr, 0) : e && z(this, aa) && at(this, Yr, z(this, Yr) + Number(T));
  const D = `data-add='{"ch_in_style":"${z(this, Dn)}", "ch_out_style":"${z(this, oa)}"}'`;
  return {
    cl: ` class='sn_ch${T > 0 ? ` sn_ch_in_${z(this, Dn)}` : ""}'`,
    // TxtStage.goTxt()はこれ単位で文字出現させる
    sty: `animation-delay: ${z(this, Yr)}ms;${((B = z(this, mr).at(-1)) == null ? void 0 : B.o.style) ?? ""}`,
    // TxtStage.goTxt()はこれ単位で文字出現させる
    lnk: ((($ = z(this, mr).at(0)) == null ? void 0 : $.o[":link"]) ?? "") + " " + D,
    curpos: D
  };
}, Yr = new WeakMap(), Or = new WeakMap(), gr = new WeakMap(), mr = new WeakMap(), il = new WeakSet(), df = function(e) {
  z(this, mr).push({
    o: e,
    r_align: z(this, Ke),
    ch_in_style: z(this, Dn),
    ch_out_style: z(this, oa)
  }), "r_align" in e && at(this, Ke, e.r_align), lt(this, In, za).call(this, e), lt(this, An, Ha).call(this, e);
}, ca = new WeakSet(), du = function() {
  const e = z(this, mr).pop();
  e && (at(this, Ke, e.r_align), lt(this, In, za).call(this, { in_style: e.ch_in_style }), lt(this, An, Ha).call(this, { out_style: e.ch_out_style }));
}, nl = new WeakSet(), pf = function(e) {
  const r = z(this, mr).at(-1);
  if (!r) {
    lt(this, il, df).call(this, e);
    return;
  }
  r.o = { ...r.o, ...e }, !e.style && !e.r_style && (r.o.style = "", r.o.r_style = ""), "r_align" in e && at(this, Ke, e.r_align), lt(this, In, za).call(this, e), lt(this, An, Ha).call(this, e);
}, kn = new WeakMap(), // 文字出現演出
tt(TxtLayer, Wo), // 文字消去演出
tt(TxtLayer, qo), tt(TxtLayer, lh), tt(TxtLayer, na, void 0), tt(TxtLayer, Rr, void 0), tt(TxtLayer, Yo, void 0), tt(TxtLayer, sa, void 0), tt(TxtLayer, Ko, void 0), tt(TxtLayer, Mn, void 0), tt(TxtLayer, Zo, void 0), // 文字ごとのウェイト
tt(TxtLayer, pi, !1), tt(TxtLayer, On, {}), // cssチェック・保存用
tt(TxtLayer, uh, {
  "text-align": 0,
  "text-align-last": 0,
  height: 0,
  width: 0,
  "padding-left": 0,
  "padding-right": 0,
  "padding-top": 0,
  "padding-bottom": 0
}), tt(TxtLayer, ua, (e) => e);
var fa, Bn, ch, vd, da, pa, pu, fh, gd, dh, md, sl, ph, _d, vh, yd;
class FrameMng {
  constructor(t, e, r, S, T, D, N) {
    //	HTMLフレーム
    // フレーム追加
    tt(this, ch);
    tt(this, pa);
    // フレーム変数を取得
    tt(this, fh);
    // フレーム変数に設定
    tt(this, dh);
    tt(this, ph);
    // フレームをトゥイーン開始
    tt(this, vh);
    tt(this, fa, void 0);
    tt(this, Bn, /* @__PURE__ */ Object.create(null));
    tt(this, da, {});
    // フレームに設定
    tt(this, sl, 1);
    this.cfg = t, this.appPixi = r, this.val = S, this.main = T, this.sys = D, this.hTwInf = N, e.add_frame = (B) => lt(this, ch, vd).call(this, B), e.let_frame = (B) => lt(this, fh, gd).call(this, B), e.set_frame = (B) => lt(this, dh, md).call(this, B), e.frame = (B) => lt(this, ph, _d).call(this, B), e.tsy_frame = (B) => lt(this, vh, yd).call(this, B);
  }
  setEvtMng(t) {
    at(this, fa, t);
  }
  destroy() {
    for (const t of Object.values(z(this, Bn)))
      t.parentElement.removeChild(t);
    at(this, Bn, /* @__PURE__ */ Object.create(null));
  }
  getFrmDisabled(t) {
    return z(this, da)[t];
  }
  cvsResize() {
    for (const [t, e] of Object.entries(z(this, Bn))) {
      const r = "const.sn.frm." + t, S = Number(this.val.getVal(r + ".x")), T = Number(this.val.getVal(r + ".y")), D = Number(this.val.getVal(r + ".width")), N = Number(this.val.getVal(r + ".height"));
      e.style.left = `${this.sys.ofsLeft4elm + S * this.sys.cvsScale}px`, e.style.top = `${this.sys.ofsTop4elm + T * this.sys.cvsScale}px`, e.width = String(D * this.sys.cvsScale), e.height = String(N * this.sys.cvsScale);
    }
  }
}
fa = new WeakMap(), Bn = new WeakMap(), ch = new WeakSet(), vd = function(t) {
  const { id: e, src: r, alpha: S = 1, scale_x: T = 1, scale_y: D = 1, rotate: N = 0 } = t;
  if (!e)
    throw "idは必須です";
  if (!r)
    throw "srcは必須です";
  const B = "const.sn.frm." + e;
  if (this.val.getVal(`tmp:${B}`))
    throw `frame【${e}】はすでにあります`;
  const $ = argChk_Boolean(t, "visible", !0), U = t.b_color ? ` background-color: ${t.b_color};` : "", H = lt(this, pa, pu).call(this, t);
  Main.cvs.insertAdjacentHTML("beforebegin", `<iframe id="${e}" sandbox="allow-scripts allow-same-origin" style="opacity: ${S}; position: absolute; left:${this.sys.ofsLeft4elm + H.x * this.sys.cvsScale}px; top: ${this.sys.ofsTop4elm + H.y * this.sys.cvsScale}px; z-index: 1; ${U} border: 0px; overflow: hidden; display: ${$ ? "inline" : "none"}; transform: scale(${T}, ${D}) rotate(${N}deg);" width="${H.width * this.sys.cvsScale}" height="${H.height * this.sys.cvsScale}"></iframe>`);
  const V = this.cfg.searchPath(r, SEARCH_PATH_ARG_EXT.HTML), X = new Loader().add({ name: r, url: V, xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT });
  return this.sys.crypto && X.use((W, Y) => {
    try {
      W.data = this.sys.decStr(W.extension, W.data);
    } catch (q) {
      this.main.errScript(`[add_frame]Html ロード失敗です src:${W.name} ${q}`, !1);
    }
    Y == null || Y();
  }), X.load((W, Y) => {
    var K;
    const q = document.getElementById(e);
    z(this, Bn)[e] = q, z(this, da)[e] = !1, q.srcdoc = String((K = Y[r]) == null ? void 0 : K.data).replace("sn_repRes();", "").replaceAll(
      /\s(?:src|href)=(["'])(\S+)\1/g,
      (Z, J, Q) => Q.slice(0, 3) === "../" ? this.sys.cur + Q.slice(4) : Z.replace(J, J + V.slice(0, V.lastIndexOf("/") + 1))
    ), q.onload = () => {
      var J;
      this.val.setVal_Nochk("tmp", B, !0), this.val.setVal_Nochk("tmp", B + ".alpha", S), this.val.setVal_Nochk("tmp", B + ".x", H.x), this.val.setVal_Nochk("tmp", B + ".y", H.y), this.val.setVal_Nochk("tmp", B + ".scale_x", T), this.val.setVal_Nochk("tmp", B + ".scale_y", D), this.val.setVal_Nochk("tmp", B + ".rotate", N), this.val.setVal_Nochk("tmp", B + ".width", H.width), this.val.setVal_Nochk("tmp", B + ".height", H.height), this.val.setVal_Nochk("tmp", B + ".visible", $);
      const Z = q.contentWindow;
      z(this, fa).resvFlameEvent(Z), (J = Z.sn_repRes) == null || J.call(Z, (Q) => GrpLayer.loadPic2Img(Q.dataset.src ?? "", Q)), this.main.resume();
    };
  }), !0;
}, da = new WeakMap(), pa = new WeakSet(), pu = function(t) {
  const e = { ...t }, r = this.sys.resolution;
  return new DOMRect(
    argChk_Num(e, "x", 0) * r,
    argChk_Num(e, "y", 0) * r,
    argChk_Num(e, "width", CmnLib.stageW) * r,
    argChk_Num(e, "height", CmnLib.stageH) * r
  );
}, fh = new WeakSet(), gd = function(t) {
  const { id: e, var_name: r } = t;
  if (!e)
    throw "idは必須です";
  const S = document.getElementById(e);
  if (!S)
    throw `id【${e}】はフレームではありません`;
  const T = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${T}`))
    throw `frame【${e}】が読み込まれていません`;
  if (!r)
    throw "var_nameは必須です";
  const D = S.contentWindow;
  if (!D.hasOwnProperty(r))
    throw `frame【${e}】に変数/関数【${r}】がありません。変数は var付きにして下さい`;
  const N = D[r];
  return this.val.setVal_Nochk(
    "tmp",
    T + "." + r,
    argChk_Boolean(t, "function", !1) ? N() : N
  ), !1;
}, dh = new WeakSet(), md = function(t) {
  const { id: e, var_name: r, text: S } = t;
  if (!e)
    throw "idは必須です";
  const T = document.getElementById(e);
  if (!T)
    throw `id【${e}】はフレームではありません`;
  const D = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${D}`))
    throw `frame【${e}】が読み込まれていません`;
  if (!r)
    throw "var_nameは必須です";
  if (!S)
    throw "textは必須です";
  this.val.setVal_Nochk("tmp", D + "." + r, S);
  const N = T.contentWindow;
  return N[r] = S, !1;
}, sl = new WeakMap(), ph = new WeakSet(), _d = function(t) {
  const { id: e } = t;
  if (!e)
    throw "idは必須です";
  const r = document.getElementById(e);
  if (!r)
    throw `id【${e}】はフレームではありません`;
  const S = "const.sn.frm." + e;
  if (!this.val.getVal("tmp:" + S))
    throw `frame【${e}】が読み込まれていません`;
  const T = r.style;
  if (argChk_Boolean(t, "float", !1) ? T.zIndex = `${++Oe(this, sl)._}` : "index" in t ? T.zIndex = `${argChk_Num(t, "index", 0)}` : t.dive && (T.zIndex = `-${++Oe(this, sl)._}`), "alpha" in t) {
    const N = T.opacity = String(t.alpha);
    this.val.setVal_Nochk("tmp", S + ".alpha", N);
  }
  const D = lt(this, pa, pu).call(this, t);
  if (("x" in t || "y" in t) && (T.left = `${this.sys.ofsLeft4elm + D.x * this.sys.cvsScale}px`, T.top = `${this.sys.ofsTop4elm + D.y * this.sys.cvsScale}px`, this.val.setVal_Nochk("tmp", S + ".x", D.x), this.val.setVal_Nochk("tmp", S + ".y", D.y)), "scale_x" in t || "scale_y" in t || "rotate" in t) {
    const N = argChk_Num(t, "scale_x", 1), B = argChk_Num(t, "scale_y", 1), $ = argChk_Num(t, "rotate", 0);
    T.transform = `scale(${N}, ${B}) rotate(${$}deg)`, this.val.setVal_Nochk("tmp", S + ".scale_x", N), this.val.setVal_Nochk("tmp", S + ".scale_y", B), this.val.setVal_Nochk("tmp", S + ".rotate", $);
  }
  if ("width" in t && (r.width = String(D.width * this.sys.cvsScale), this.val.setVal_Nochk("tmp", S + ".width", D.width)), "height" in t && (r.height = String(D.height * this.sys.cvsScale), this.val.setVal_Nochk("tmp", S + ".height", D.height)), "visible" in t) {
    const N = argChk_Boolean(t, "visible", !0);
    T.display = N ? "inline" : "none", this.val.setVal_Nochk("tmp", S + ".visible", N);
  }
  if ("b_color" in t && (T.backgroundColor = t.b_color), "disabled" in t) {
    const N = z(this, da)[e] = argChk_Boolean(t, "disabled", !0);
    r.contentDocument.body.querySelectorAll("input,select").forEach(($) => $.disabled = N);
  }
  return !1;
}, vh = new WeakSet(), yd = function(t) {
  const { id: e, alpha: r, x: S, y: T, scale_x: D, scale_y: N, rotate: B, width: $, height: U, ease: H, path: V, chain: X } = t;
  if (!e)
    throw "idは必須です";
  const W = document.getElementById(e);
  if (!W)
    throw `id【${e}】はフレームではありません`;
  const Y = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${Y}`, 0))
    throw `frame【${e}】が読み込まれていません`;
  const q = {};
  r && (q.a = W.style.opacity), (S || T || D || N || B) && (q.x = Number(this.val.getVal(`tmp:${Y}.x`)), q.y = Number(this.val.getVal(`tmp:${Y}.y`)), q.sx = Number(this.val.getVal(`tmp:${Y}.scale_x`)), q.sy = Number(this.val.getVal(`tmp:${Y}.scale_y`)), q.r = Number(this.val.getVal(`tmp:${Y}.rotate`))), $ && (q.w = this.val.getVal(`tmp:${Y}.width`)), U && (q.h = this.val.getVal(`tmp:${Y}.height`));
  const K = cnvTweenArg(t, q), Z = {};
  let J = () => {
  };
  r && (Z.a = argChk_Num(K, "alpha", 0), J = () => {
    W.style.opacity = q.a, this.val.setVal_Nochk("tmp", "alpha", q.a);
  });
  let Q = () => {
  };
  const rt = lt(this, pa, pu).call(this, K);
  (S || T || D || N || B) && (Z.x = rt.x, Z.y = rt.y, Z.sx = argChk_Num(K, "scale_x", 1), Z.sy = argChk_Num(K, "scale_y", 1), Z.r = argChk_Num(K, "rotate", 0), Q = () => {
    W.style.left = this.sys.ofsLeft4elm + q.x * this.sys.cvsScale + "px", W.style.top = this.sys.ofsTop4elm + q.y * this.sys.cvsScale + "px", W.style.transform = `scale(${q.sx}, ${q.sy}) rotate(${q.r}deg)`, this.val.setVal_Nochk("tmp", Y + ".x", q.x), this.val.setVal_Nochk("tmp", Y + ".y", q.y), this.val.setVal_Nochk("tmp", Y + ".scale_x", q.sx), this.val.setVal_Nochk("tmp", Y + ".scale_y", q.sy), this.val.setVal_Nochk("tmp", Y + ".rotate", q.r);
  });
  let et = () => {
  };
  $ && (Z.w = rt.width, et = () => {
    W.width = q.w * this.sys.cvsScale + "px", this.val.setVal_Nochk("tmp", Y + ".width", q.w);
  });
  let nt = () => {
  };
  U && (Z.h = rt.height, nt = () => {
    W.height = q.h * this.sys.cvsScale + "px", this.val.setVal_Nochk("tmp", Y + ".height", q.h);
  }), this.appPixi.stage.interactive = !1;
  const st = `frm
${e}`, it = () => {
    var xt, pt;
    this.appPixi.stage.interactive = !0;
    const wt = this.hTwInf[st];
    wt && (delete this.hTwInf[st], (xt = wt.tw) == null || xt.stop(), wt.resume && this.main.resume(), (pt = wt.onEnd) == null || pt.call(wt));
  }, ot = argChk_Num(t, "time", NaN) * (Boolean(this.val.getVal("tmp:sn.skip.enabled") || z(this, fa).isSkippingByKeyDown()) ? 0 : 1), ht = CmnTween.ease(H), ct = argChk_Num(t, "repeat", 1), vt = ct === 0 ? 1 / 0 : ct - 1, _t = argChk_Boolean(t, "yoyo", !1), gt = argChk_Num(t, "delay", 0), mt = new Tween(q).to(Z, ot).easing(ht).repeat(vt).yoyo(_t).delay(gt).onUpdate(() => {
    J(), Q(), et(), nt();
  });
  let Et = mt;
  if (V) {
    CmnLib.debugLog && console.group(`🍝 [tsy_frame] path=${V}= start(${q.x},${q.y},${q.alpha})`);
    for (const { groups: wt } of V.matchAll(LayerMng.REG_TSY_PATH)) {
      const { x: xt, x2: pt, y: yt, y2: Dt, o: At, o2: It, json: Ot } = wt;
      let ft = {};
      if (Ot)
        try {
          ft = JSON.parse(Ot);
        } catch (zt) {
          console.error(`🍝 json=${Ot} ` + zt);
          continue;
        }
      else
        (xt ?? pt) && (ft.x = xt ?? pt), (yt ?? Dt) && (ft.y = yt ?? Dt), (At ?? It) && (ft.alpha = At ?? It);
      const Ft = cnvTweenArg(ft, q);
      CmnLib.debugLog && console.info(`🍝 {x:${xt} y:${yt} o:${At}} => hTo:${JSON.stringify(Ft)}`);
      const Mt = new Tween(q).to(Ft, ot).easing(ht).repeat(vt).yoyo(_t);
      Et.chain(Mt), Et = Mt;
    }
    CmnLib.debugLog && console.groupEnd();
  }
  if (Et.onComplete(it), X) {
    const wt = this.hTwInf[X ?? ""];
    if (!wt || !wt.tw)
      throw `${X}は存在しない・または終了したトゥイーンです`;
    delete wt.onEnd, wt.tw.chain(mt);
  } else
    mt.start();
  return this.hTwInf[st] = { tw: Et, resume: !1 }, !1;
};
var _r, le, Ee, Hi, Fn, va, al, ol, ll, ga, ul, vf, Vi, Ir, gh, bd, Ze, mh, xd, _h, Sd, yh, Ed, se, Wr, qr, hl, bh, Td, ma, vu, xh, wd, Sh, cl, Eh, $n, Gn, mi, De, Un, Th, Cd, Ae, Xe, rr, wh, Pd, Ch, Rd, Ph, Md, jn, Va, Rh, Od, ur, Mh, Id, Oh, Dd, Ih, Ad, Dh, Nd, Ah, Ld, Xi, zn, Xa, hr, Nh, kd, fl, Lh, Bd, Kr, Hn, Yi, xs, Dr, Zr, kh, Fd, Bh, $d, Fh, Gd, $h, Ud, Gh, jd, Uh, zd, jh, Hd, dl, gf, zh, Vd, Hh, Xd, Vh, Yd, Xh, Wd, Yh, qd, Wh, Kd, qh, Zd;
const Di = class {
  constructor(t, e, r, S, T, D, N, B, $, U) {
    tt(this, ul);
    // 既存の全文字レイヤの実際のバック不透明度、を再計算
    tt(this, gh);
    //	//	システム
    // スナップショット
    tt(this, mh);
    // プラグインの読み込み
    tt(this, _h);
    //	//	レイヤ共通
    // レイヤを追加する
    tt(this, yh);
    tt(this, bh);
    tt(this, ma);
    // レイヤ設定の消去
    tt(this, xh);
    // ページ裏表を交換
    tt(this, Th);
    tt(this, Xe);
    tt(this, wh);
    tt(this, Ch);
    // トランス終了待ち
    tt(this, Ph);
    // レイヤのトランジションの停止
    tt(this, jn);
    // 画面を揺らす
    tt(this, Rh);
    tt(this, Mh);
    // トゥイーン終了待ち
    tt(this, Oh);
    // トゥイーン中断
    tt(this, Ih);
    // 一時停止
    tt(this, Dh);
    // 一時停止再開
    tt(this, Ah);
    // 文字を追加する
    tt(this, zn);
    tt(this, Nh);
    tt(this, Lh);
    tt(this, Yi);
    tt(this, kh);
    // ハイパーリンクの終了
    tt(this, Bh);
    // ページ両面の文字消去
    tt(this, Fh);
    // インライン画像表示
    tt(this, $h);
    // ハイパーリンク
    tt(this, Gh);
    // 改行
    tt(this, Uh);
    // 履歴改行
    tt(this, jh);
    // 履歴書き込み
    tt(this, dl);
    // 履歴リセット
    tt(this, zh);
    // 文字列と複数ルビの追加
    tt(this, Hh);
    // インラインスタイル設定
    tt(this, Vh);
    // tcy縦中横を表示する
    tt(this, Xh);
    // レイヤのダンプ
    tt(this, Yh);
    // イベント有無の切替
    tt(this, Wh);
    // ボタンを表示
    tt(this, qh);
    tt(this, _r, void 0);
    tt(this, le, new Container());
    tt(this, Ee, new Container());
    tt(this, Hi, void 0);
    tt(this, Fn, void 0);
    tt(this, va, new EventListenerCtn());
    tt(this, al, () => update());
    tt(this, ol, {
      attach: (t) => (DesignCast.leaveMode(), !1),
      continue: (t) => (DesignCast.leaveMode(), !1),
      disconnect: (t) => (DesignCast.leaveMode(), !1),
      _enterDesign: (t) => {
        DesignCast.enterMode();
        for (const e of z(this, Wr)) {
          const r = z(this, se)[e].fore;
          r.makeDesignCastChildren((S) => S.make()), r.makeDesignCast((S) => S.make());
        }
        return lt(this, ul, vf).call(this, z(this, qr)), !1;
      },
      _replaceToken: (t, e) => (DesignCast.replaceToken(e), !1),
      _selectNode: (t, e) => (lt(this, ul, vf).call(this, e.node), !1)
    });
    tt(this, ll, "");
    tt(this, ga, "");
    Pt(this, "getFrmDisabled", (t) => z(this, Hi).getFrmDisabled(t));
    tt(this, Vi, void 0);
    tt(this, Ir, void 0);
    tt(this, Ze, (t, e = this.currentTxtlayForeNeedErr, r = !0) => e.tagCh("｜　《" + t + "》"));
    Pt(this, "goTxt", () => {
    });
    Pt(this, "breakLine", () => {
    });
    Pt(this, "breakPage", () => {
    });
    tt(this, se, {});
    // しおりLoad時再読込
    tt(this, Wr, []);
    // 最適化用
    tt(this, qr, "");
    tt(this, hl, "");
    tt(this, Sh, `
precision mediump float;

varying vec2 vTextureCoord;
uniform sampler2D uSampler;

uniform sampler2D rule;
uniform float vague;
uniform float tick;

uniform vec4 inputPixel;
uniform highp vec4 outputFrame;
vec2 getUV(vec2 coord) {
	return coord * inputPixel.xy / outputFrame.zw;
}

void main(void) {
	vec4 fg = texture2D(uSampler, vTextureCoord);
	vec4 ru = texture2D(rule, getUV(vTextureCoord));

	float v = ru.r - tick;
	if (abs(v) < vague) {
		float f_a = fg.a *(0.5 +v /vague *0.5);

		gl_FragColor.rgb = fg.rgb *f_a;
		gl_FragColor.a = f_a;
	}
	else {
		gl_FragColor = (v >= 0.0)? fg : vec4(0);
	}
}`);
    tt(this, cl, {
      rule: Texture.EMPTY,
      vague: 0,
      tick: 0
    });
    tt(this, Eh, new Filter(void 0, z(this, Sh), z(this, cl)));
    tt(this, $n, RenderTexture.create({
      width: CmnLib.stageW,
      height: CmnLib.stageH
    }));
    tt(this, Gn, new Sprite(z(this, $n)));
    tt(this, mi, RenderTexture.create({
      width: CmnLib.stageW,
      height: CmnLib.stageH
    }));
    tt(this, De, new Sprite(z(this, mi)));
    tt(this, Un, []);
    tt(this, Ae, { tw: void 0, resume: !1 });
    // トゥイーン開始
    tt(this, ur, {});
    tt(this, hr, (t) => {
      throw z(this, Hn).call(this), 0;
    });
    // 操作対象のメッセージレイヤの指定
    tt(this, fl, (t) => {
      throw z(this, Hn).call(this), 0;
    });
    tt(this, Kr, void 0);
    // カレントテキストレイヤ
    tt(this, Hn, () => {
      throw "文字レイヤーがありません。文字表示や操作する前に、[add_lay layer=（レイヤ名） class=txt]で文字レイヤを追加して下さい";
    });
    tt(this, Dr, "");
    tt(this, Zr, []);
    this.cfg = t, this.hTag = e, this.appPixi = r, this.val = S, this.main = T, this.scrItr = D, this.sys = N, this.sndMng = B, this.alzTagArg = $, this.prpPrs = U;
    const H = () => {
      if (N.cvsResize(), this.cvsResizeDesign(), z(this, ga))
        for (const Y of z(this, Wr))
          z(this, se)[Y].fore.cvsResizeChildren();
      else
        for (const Y of z(this, Wr))
          z(this, se)[Y].fore.cvsResize();
      z(this, Hi).cvsResize(), z(this, Ir).cvsResize();
    };
    if (CmnLib.isMobile)
      z(this, va).add(globalThis, "orientationchange", H, { passive: !0 });
    else {
      let Y;
      z(this, va).add(globalThis, "resize", () => {
        Y || (Y = setTimeout(() => {
          Y = void 0, H();
        }, 1e3 / 60 * 10));
      }, { passive: !0 });
    }
    N.cvsResize(), TxtLayer.init(t, e, S, this, (Y) => z(this, se)[Y.layname].fore === Y, r), GrpLayer.init(T, t, r, N, B, S), Button.init(t), at(this, Hi, new FrameMng(t, e, r, S, T, N, z(this, ur))), N.hFactoryCls.grp = () => new GrpLayer(), N.hFactoryCls.txt = () => new TxtLayer(), e.loadplugin = (Y) => lt(this, _h, Sd).call(this, Y), e.snapshot = (Y) => lt(this, mh, xd).call(this, Y), e.add_lay = (Y) => lt(this, yh, Ed).call(this, Y), e.clear_lay = (Y) => lt(this, xh, wd).call(this, Y), e.finish_trans = () => lt(this, jn, Va).call(this), e.lay = (Y) => lt(this, bh, Td).call(this, Y), e.trans = (Y) => lt(this, Th, Cd).call(this, Y), e.wt = (Y) => lt(this, Ph, Md).call(this, Y), e.quake = (Y) => lt(this, Rh, Od).call(this, Y), e.stop_quake = (Y) => e.finish_trans(Y), e.wq = (Y) => e.wt(Y), e.pause_tsy = (Y) => lt(this, Dh, Nd).call(this, Y), e.resume_tsy = (Y) => lt(this, Ah, Ld).call(this, Y), e.stop_tsy = (Y) => lt(this, Ih, Ad).call(this, Y), e.tsy = (Y) => lt(this, Mh, Id).call(this, Y), e.wait_tsy = (Y) => lt(this, Oh, Dd).call(this, Y), e.ch = (Y) => lt(this, zn, Xa).call(this, Y), e.clear_text = (Y) => lt(this, kh, Fd).call(this, Y), e.current = (Y) => z(this, fl).call(this, Y), e.endlink = (Y) => lt(this, Bh, $d).call(this, Y), e.er = (Y) => lt(this, Fh, Gd).call(this, Y), e.graph = (Y) => lt(this, $h, Ud).call(this, Y), e.link = (Y) => lt(this, Gh, jd).call(this, Y), e.r = (Y) => lt(this, Uh, zd).call(this, Y), e.rec_ch = (Y) => lt(this, dl, gf).call(this, Y), e.rec_r = (Y) => lt(this, jh, Hd).call(this, Y), e.reset_rec = (Y) => lt(this, zh, Vd).call(this, Y), e.ruby2 = (Y) => lt(this, Hh, Xd).call(this, Y), e.span = (Y) => lt(this, Vh, Yd).call(this, Y), e.tcy = (Y) => lt(this, Xh, Wd).call(this, Y), e.add_face = (Y) => GrpLayer.add_face(Y), e.wv = (Y) => GrpLayer.wv(Y), e.dump_lay = (Y) => lt(this, Yh, qd).call(this, Y), e.enable_event = (Y) => lt(this, Wh, Kd).call(this, Y), e.button = (Y) => lt(this, qh, Zd).call(this, Y), t.existsBreakline && (this.breakLine = () => z(this, Ze).call(this, 'grp｜{"id":"break","pic":"breakline"}')), t.existsBreakpage && (this.breakPage = () => z(this, Ze).call(this, 'grp｜{"id":"break","pic":"breakpage"}')), at(this, Fn, parseColor(String(t.oCfg.init.bg_color)));
    const V = new Graphics();
    V.beginFill(z(this, Fn), 1).lineStyle(0, z(this, Fn)).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill(), z(this, le).addChild(V.clone()), z(this, Ee).addChild(V), z(this, Ee).visible = !1, z(this, le).name = "page:A", z(this, Ee).name = "page:B", at(this, _r, r.stage), z(this, _r).addChild(z(this, Ee)), z(this, _r).addChild(z(this, le)), z(this, _r).addChild(z(this, Gn)), z(this, _r).addChild(z(this, De)), z(this, _r).name = "stage", r.ticker.add(z(this, al));
    const X = (Y, q) => {
      lt(this, gh, bd).call(this, Number(q));
    };
    X("", S.getVal("sys:TextLayer.Back.Alpha", 1)), S.defValTrg("sys:TextLayer.Back.Alpha", X);
    const W = (Y, q) => Button.fontFamily = q;
    W("", S.getVal("tmp:sn.button.fontFamily", Button.fontFamily)), S.defValTrg("tmp:sn.button.fontFamily", W), S.defTmp("const.sn.log.json", () => JSON.stringify(
      z(this, Dr) ? [...z(this, Zr), { text: z(this, Dr).replaceAll("</span><span class='sn_ch'>", "") }] : z(this, Zr)
    )), S.defTmp("const.sn.last_page_text", () => {
      var Y;
      return ((Y = this.currentTxtlayFore) == null ? void 0 : Y.pageText) ?? "";
    }), CmnLib.isDbg && (DesignCast.init(r, N, D, U, $, t, z(this, se)), this.cvsResizeDesign = () => DesignCast.cvsResizeDesign(), N.addHook((Y, q) => {
      var K, Z;
      (Z = (K = z(this, ol))[Y]) != null && Z.call(K, Y, q) && delete z(this, ol)[Y];
    }));
  }
  cvsResizeDesign() {
  }
  cover(t, e = 0) {
    z(this, Vi) && (z(this, _r).removeChild(z(this, Vi)), z(this, Vi).destroy(), at(this, Vi, void 0)), t && z(this, _r).addChild(
      at(this, Vi, new Graphics()).beginFill(e).lineStyle(0, e).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill()
    );
  }
  setEvtMng(t) {
    at(this, Ir, t), z(this, Hi).setEvtMng(t), GrpLayer.setEvtMng(t);
  }
  before_destroy() {
    for (const t of Object.values(z(this, se)))
      t.destroy();
  }
  destroy() {
    z(this, va).clear(), GrpLayer.destroy(), RubySpliter.destroy(), TxtStage.destroy(), TxtLayer.destroy(), z(this, Hi).destroy(), this.stopAllTw(), this.appPixi.ticker.remove(z(this, al)), at(Di, Xi, 10);
  }
  // トゥイーン全停止
  stopAllTw() {
    at(this, ur, {}), removeAll();
  }
  clearBreak() {
    this.currentTxtlayFore && (this.clearBreak = () => z(this, Ze).call(this, "del｜break"), this.clearBreak());
  }
  clickTxtLay() {
    return this.currentTxtlayFore ? lt(this, Xe, rr).call(this).some((t) => {
      const e = z(this, se)[t].fore;
      return e instanceof TxtLayer && e.click();
    }) : !1;
  }
  static get msecChWait() {
    return z(Di, Xi);
  }
  static set msecChWait(t) {
    at(Di, Xi, t);
  }
  setNormalChWait() {
    at(Di, Xi, this.scrItr.normalWait);
  }
  get currentTxtlayForeNeedErr() {
    return z(this, Hn).call(this), this.currentTxtlayFore;
  }
  get currentTxtlayFore() {
    return z(this, Kr) ? z(this, Kr).fore : null;
  }
  recText(t) {
    at(this, Dr, t), this.val.setVal_Nochk(
      "save",
      "const.sn.sLog",
      String(this.val.getVal("const.sn.log.json"))
      // これを起動したい
    );
  }
  recPagebreak() {
    if (!z(this, Dr))
      return;
    const t = z(this, Dr).replaceAll("</span><span class='sn_ch'>", "");
    z(this, Zr).push({ text: t }) > this.cfg.oCfg.log.max_len && at(this, Zr, z(this, Zr).slice(-this.cfg.oCfg.log.max_len)), at(this, Dr, "");
  }
  record() {
    const t = {};
    for (const e of z(this, Wr)) {
      const r = z(this, se)[e];
      t[e] = {
        cls: r.cls,
        fore: r.fore.record(),
        back: r.back.record()
      };
    }
    return t;
  }
  playback(t, e) {
    var D;
    at(this, Zr, JSON.parse(String(this.val.getVal("save:const.sn.sLog")))), at(this, Dr, "");
    const r = [], S = [];
    for (const [N, { fore: B, fore: { idx: $ }, back: U, cls: H }] of Object.entries(t)) {
      S.push({ layer: N, idx: $ });
      const V = (D = z(this, se))[N] ?? (D[N] = new Pages(N, H, z(this, le), z(this, Ee), {}, this.sys, this.val, { isWait: !1 }));
      V.fore.playback(B, r), V.back.playback(U, r);
    }
    const T = z(this, le).children.length;
    Promise.allSettled(r).then(() => {
      for (const { layer: N, idx: B } of S.sort(({ idx: $ }, { idx: U }) => $ === U ? 0 : $ < U ? -1 : 1)) {
        const { fore: $, back: U } = z(this, se)[N];
        if (!$)
          return;
        const H = T > B ? B : T - 1;
        z(this, le).setChildIndex($.spLay, H), z(this, Ee).setChildIndex(U.spLay, H);
      }
      e();
    }).catch((N) => console.error("fn:LayerMng.ts playback e:%o", N));
  }
};
let LayerMng = Di;
_r = new WeakMap(), le = new WeakMap(), Ee = new WeakMap(), Hi = new WeakMap(), Fn = new WeakMap(), va = new WeakMap(), al = new WeakMap(), ol = new WeakMap(), ll = new WeakMap(), ga = new WeakMap(), ul = new WeakSet(), vf = function(t) {
  [Oe(this, ll)._, this.ga = ""] = t.split("/");
  const e = z(this, se)[z(this, ll)];
  e && (DesignCast.allHide(), z(this, ga) ? e.fore.showDesignCastChildren() : e.fore.showDesignCast());
}, Vi = new WeakMap(), Ir = new WeakMap(), gh = new WeakSet(), bd = function(t) {
  for (const e of lt(this, Xe, rr).call(this)) {
    const r = z(this, se)[e];
    r.fore instanceof TxtLayer && (r.fore.chgBackAlpha(t), r.back.chgBackAlpha(t));
  }
}, Ze = new WeakMap(), mh = new WeakSet(), xd = function(t) {
  const e = t.fn ? t.fn.slice(0, 10) === "userdata:/" ? t.fn : `downloads:/${t.fn + getDateStr("-", "_", "", "_")}.png` : `downloads:/snapshot${getDateStr("-", "_", "", "_")}.png`, r = this.cfg.searchPath(e);
  if (this.sys.canCapturePage(r))
    return !1;
  const S = getExt(r), T = argChk_Color(t, "b_color", z(this, Fn)), D = autoDetectRenderer({
    width: argChk_Num(t, "width", CmnLib.stageW),
    height: argChk_Num(t, "height", CmnLib.stageH),
    backgroundAlpha: T > 16777216 && S === "png" ? 0 : 1,
    antialias: argChk_Boolean(t, "smoothing", !1),
    preserveDrawingBuffer: !0,
    backgroundColor: T & 16777215,
    autoDensity: !0
  }), N = [], B = t.page !== "back" ? "fore" : "back";
  if (z(this, Ae).tw)
    N.push(new Promise(($) => {
      z(this, Ee).visible = !0;
      for (const U of z(this, Un))
        D.render(U, { clear: !1 });
      z(this, Ee).visible = !1, z(this, Gn).visible = !0, z(this, le).filters = z(this, De).filters, z(this, le).visible = !0, D.render(z(this, le), { clear: !1 }), z(this, le).visible = !1, z(this, le).filters = [], $();
    }));
  else
    for (const $ of lt(this, Xe, rr).call(this, t.layer))
      N.push(
        new Promise((U) => z(this, se)[$][B].snapshot(D, () => U()))
      );
  return Promise.allSettled(N).then(async () => {
    const $ = RenderTexture.create({ width: D.width, height: D.height, transform: !0 });
    if (D.render(z(this, _r), { renderTexture: $ }), await this.sys.savePic(
      r,
      D.plugins.extract.base64(Sprite.from($))
    ), !z(this, Ae).tw)
      for (const U of lt(this, Xe, rr).call(this, t.layer))
        z(this, se)[U][B].snapshot_end();
    D.destroy(!0);
  }), !1;
}, _h = new WeakSet(), Sd = function(t) {
  const { fn: e } = t;
  if (!e)
    throw "fnは必須です";
  const r = argChk_Boolean(t, "join", !0);
  switch (getExt(e)) {
    case "css":
      (async () => {
        const S = await fetch(e);
        if (!S.ok)
          throw new Error("Network response was not ok.");
        addStyle(await S.text()), r && this.main.resume();
      })();
      break;
    default:
      throw "サポートされない拡張子です";
  }
  return r;
}, yh = new WeakSet(), Ed = function(t) {
  const { layer: e, class: r } = t;
  if (!e)
    throw "layerは必須です";
  if (e.includes(","))
    throw "layer名に「,」は使えません";
  if (e in z(this, se))
    throw `layer【${e}】はすでにあります`;
  if (!r)
    throw "clsは必須です";
  const S = { isWait: !1 };
  switch (z(this, se)[e] = new Pages(e, r, z(this, le), z(this, Ee), t, this.sys, this.val, S), z(this, Wr).push(e), r) {
    case "txt":
      z(this, qr) || (at(this, Hn, () => {
      }), at(this, hr, lt(this, Nh, kd)), at(this, fl, lt(this, Lh, Bd)), this.hTag.current({ layer: e }), this.goTxt = () => {
        this.val.getVal("sn.skip.enabled") ? at(Di, Xi, 0) : this.setNormalChWait();
        for (const T of lt(this, Xe, rr).call(this)) {
          const D = z(this, se)[T].fore;
          D instanceof TxtLayer && z(this, Ze).call(this, "gotxt｜", D, !1);
        }
      }), this.val.setVal_Nochk(
        "save",
        "const.sn.layer." + (e ?? z(this, qr)) + ".enabled",
        !0
      );
      break;
    case "grp":
      if (z(this, hl))
        break;
      at(this, hl, e);
      break;
  }
  return this.scrItr.recodeDesign(t), S.isWait;
}, se = new WeakMap(), Wr = new WeakMap(), qr = new WeakMap(), hl = new WeakMap(), bh = new WeakSet(), Td = function(t) {
  const e = lt(this, Yi, xs).call(this, t), r = z(this, se)[e], S = r.back.spLay, T = r.fore.spLay;
  if (argChk_Boolean(t, "float", !1))
    z(this, Ee).setChildIndex(S, z(this, Ee).children.length - 1), z(this, le).setChildIndex(T, z(this, le).children.length - 1), lt(this, ma, vu).call(this);
  else if (t.index)
    argChk_Num(t, "index", 0) && (z(this, Ee).setChildIndex(S, t.index), z(this, le).setChildIndex(T, t.index), lt(this, ma, vu).call(this));
  else if (t.dive) {
    const { dive: D } = t;
    let N = 0;
    if (e === D)
      throw "[lay] 属性 layerとdiveが同じ【" + D + "】です";
    const B = z(this, se)[D];
    if (!B)
      throw "[lay] 属性 dive【" + D + "】が不正です。レイヤーがありません";
    const $ = B.back, U = B.fore, H = z(this, Ee).getChildIndex($.spLay), V = z(this, le).getChildIndex(U.spLay);
    N = H < V ? H : V, N > z(this, Ee).getChildIndex(S) && --N, z(this, le).setChildIndex(T, N), z(this, Ee).setChildIndex(S, N), lt(this, ma, vu).call(this);
  }
  return t[":id_tag"] = r.fore.name.slice(0, -7), this.scrItr.recodeDesign(t), r.lay(t);
}, ma = new WeakSet(), vu = function() {
  at(this, Wr, lt(this, Ch, Rd).call(this));
}, xh = new WeakSet(), wd = function(t) {
  return lt(this, wh, Pd).call(this, t, (e) => {
    const r = z(this, se)[lt(this, Yi, xs).call(this, { layer: e })];
    t.page === "both" ? (r.fore.clearLay(t), r.back.clearLay(t)) : r.getPage(t).clearLay(t);
  }), !1;
}, Sh = new WeakMap(), cl = new WeakMap(), Eh = new WeakMap(), $n = new WeakMap(), Gn = new WeakMap(), mi = new WeakMap(), De = new WeakMap(), Un = new WeakMap(), Th = new WeakSet(), Cd = function(t) {
  lt(this, jn, Va).call(this), z(this, Ir).hideHint();
  const { layer: e } = t;
  at(this, Un, []);
  const r = {}, S = [];
  for (const q of lt(this, Xe, rr).call(this, e))
    r[q] = !0, S.push(z(this, se)[q].fore);
  const T = [];
  for (const q of lt(this, Xe, rr).call(this)) {
    const K = z(this, se)[q][r[q] ? "back" : "fore"];
    z(this, Un).push(K.spLay), T.push(K);
  }
  z(this, $n).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(z(this, Ee), { renderTexture: z(this, $n) });
  let D = () => {
    z(this, Ee).visible = !0;
    for (const q of z(this, Un))
      this.appPixi.renderer.render(q, { renderTexture: z(this, $n), clear: !1 });
    z(this, Ee).visible = !1;
  };
  if (!T.some((q) => q.containMovement)) {
    let q = D;
    D = () => {
      D = () => {
      }, q();
    };
  }
  z(this, mi).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(z(this, le), { renderTexture: z(this, mi) });
  let N = () => {
    z(this, le).visible = !0, this.appPixi.renderer.render(z(this, le), { renderTexture: z(this, mi) }), z(this, le).visible = !1;
  };
  if (!S.some((q) => q.containMovement)) {
    let q = N;
    N = () => {
      N = () => {
      }, q();
    };
  }
  const B = () => {
    D(), z(this, Gn).visible = !0, N(), z(this, De).visible = !0;
  };
  z(this, De).alpha = 1;
  const $ = () => {
    var K;
    this.appPixi.ticker && this.appPixi.ticker.remove(B), [Oe(this, le)._, Oe(this, Ee)._] = [z(this, Ee), z(this, le)];
    const q = [];
    for (const [Z, J] of Object.entries(z(this, se))) {
      if (r[Z]) {
        J.transPage(q);
        continue;
      }
      const { fore: { spLay: Q }, back: { spLay: rt } } = J, et = z(this, le).getChildIndex(rt);
      z(this, le).removeChild(rt), z(this, Ee).removeChild(Q), z(this, le).addChildAt(Q, et), z(this, Ee).addChildAt(rt, et);
    }
    Promise.allSettled(q), z(this, le).visible = !0, z(this, Ee).visible = !1, z(this, Gn).visible = !1, z(this, De).visible = !1, (K = z(this, Ae).tw) == null || K.stop(), z(this, Ae).resume && this.main.resume(), at(this, Ae, { tw: void 0, resume: !1 });
  };
  at(this, Ae, { tw: void 0, resume: !1 });
  const U = argChk_Num(t, "time", 0);
  if (U === 0 || z(this, Ir).isSkippingByKeyDown())
    return $(), !1;
  const { ease: H, glsl: V, rule: X } = t, W = CmnTween.ease(H);
  if (!V && !X)
    return z(this, De).filters = [], z(this, Ae).tw = new Tween(z(this, De)).to({ alpha: 0 }, U).delay(argChk_Num(t, "delay", 0)).easing(W).onComplete($).start(), this.appPixi.ticker.add(B), !1;
  const Y = V ? new Filter(void 0, V, z(this, cl)) : z(this, Eh);
  if (Y.uniforms.vague = argChk_Num(t, "vague", 0.04), Y.uniforms.tick = 0, z(this, Ae).tw = new Tween(Y.uniforms).to({ tick: 1 }, U).delay(argChk_Num(t, "delay", 0)).easing(W).onComplete($), z(this, De).filters = [Y], V)
    return z(this, Ae).tw.start(), this.appPixi.ticker.add(B), !1;
  if (!X)
    throw "ruleが指定されていません";
  return GrpLayer.csv2Sprites(X, void 0, (q) => {
    var K;
    Y.uniforms.rule = q.texture, q.destroy(), (K = z(this, Ae).tw) == null || K.start(), this.appPixi.ticker.add(B);
  }), !1;
}, Ae = new WeakMap(), Xe = new WeakSet(), rr = function(t = "") {
  return t ? t.split(",") : z(this, Wr);
}, wh = new WeakSet(), Pd = function(t, e) {
  const r = lt(this, Xe, rr).call(this, t.layer);
  for (const S of r) {
    if (!S)
      continue;
    const T = z(this, se)[S];
    if (!T)
      throw "存在しないlayer【" + S + "】です";
    e(S, T);
  }
  return r;
}, Ch = new WeakSet(), Rd = function(t = "") {
  return lt(this, Xe, rr).call(this, t).sort((e, r) => {
    const S = z(this, le).getChildIndex(z(this, se)[e].fore.spLay), T = z(this, le).getChildIndex(z(this, se)[r].fore.spLay);
    return S < T ? -1 : S > T ? 1 : 0;
  });
}, Ph = new WeakSet(), Md = function(t) {
  return z(this, Ae).tw ? (z(this, Ae).resume = !0, z(this, Ir).waitLimitedEvent(t, () => lt(this, jn, Va).call(this))) : !1;
}, jn = new WeakSet(), Va = function() {
  var t;
  return (t = z(this, Ae).tw) == null || t.end(), !1;
}, Rh = new WeakSet(), Od = function(t) {
  lt(this, jn, Va).call(this);
  const e = argChk_Num(t, "time", NaN);
  if (e === 0 || this.val.getVal("tmp:sn.skip.enabled") || z(this, Ir).isSkippingByKeyDown())
    return !1;
  const { layer: r, ease: S } = t, T = [];
  for (const X of lt(this, Xe, rr).call(this, r))
    T.push(z(this, se)[X].fore.spLay);
  z(this, mi).resize(CmnLib.stageW, CmnLib.stageH);
  const D = () => {
    z(this, le).visible = !0;
    for (const X of T)
      this.appPixi.renderer.render(
        X,
        { renderTexture: z(this, mi), clear: !1 }
      );
    z(this, le).visible = !1;
  };
  z(this, De).visible = !0, z(this, De).alpha = 1;
  const N = uint(argChk_Num(t, "hmax", 10)), B = uint(argChk_Num(t, "vmax", 10)), $ = N === 0 ? () => {
  } : () => z(this, De).x = Math.round(Math.random() * N * 2) - N, U = B === 0 ? () => {
  } : () => z(this, De).y = Math.round(Math.random() * B * 2) - B;
  z(this, De).filters = [];
  const H = argChk_Num(t, "repeat", 1), V = new Tween(z(this, De)).to({ x: 0, y: 0 }, e).delay(argChk_Num(t, "delay", 0)).easing(CmnTween.ease(S)).onUpdate(() => {
    $(), U();
  }).repeat(H === 0 ? 1 / 0 : H - 1).yoyo(argChk_Boolean(t, "yoyo", !1)).onComplete(() => {
    var X, W;
    (X = this.appPixi.ticker) == null || X.remove(D), z(this, le).visible = !0, z(this, De).visible = !1, z(this, De).x = 0, z(this, De).y = 0, (W = z(this, Ae).tw) == null || W.stop(), z(this, Ae).resume && this.main.resume(), at(this, Ae, { tw: void 0, resume: !1 });
  }).start();
  return at(this, Ae, { tw: V, resume: !1 }), this.appPixi.ticker.add(D), !1;
}, ur = new WeakMap(), Mh = new WeakSet(), Id = function(t) {
  const { layer: e, render: r, path: S, name: T, ease: D, chain: N } = t;
  if (!e)
    throw "layerは必須です";
  const B = lt(this, Yi, xs).call(this, t);
  let $ = z(this, se)[B].fore, U = () => {
  };
  const H = z(this, Ir).isSkippingByKeyDown();
  !H && r && ($.renderStart(), U = () => $.renderEnd());
  const V = T ?? e, X = () => {
    var ot, ht;
    const it = z(this, ur)[V];
    it && (U(), delete z(this, ur)[V], (ot = it.tw) == null || ot.stop(), it.resume && this.main.resume(), (ht = it.onEnd) == null || ht.call(it));
  }, W = cnvTweenArg(t, $), Y = argChk_Num(t, "time", NaN) * (Boolean(this.val.getVal("tmp:sn.skip.enabled") || H) ? 0 : 1), q = CmnTween.ease(D), K = argChk_Num(t, "repeat", 1), Z = K === 0 ? 1 / 0 : K - 1, J = argChk_Boolean(t, "yoyo", !1), Q = argChk_Num(t, "delay", 0), rt = new Tween($).to(W, Y).easing(q).repeat(Z).yoyo(J).delay(Q);
  let et = rt;
  if (S) {
    CmnLib.debugLog && console.group(`🍝 [tsy] path=${S}= start(${$.x},${$.y},${$.alpha})`);
    for (const { groups: it } of S.matchAll(Di.REG_TSY_PATH)) {
      const { x: ot, x2: ht, y: ct, y2: vt, o: _t, o2: gt, json: mt } = it;
      let Et = {};
      if (mt)
        try {
          Et = JSON.parse(mt);
        } catch (pt) {
          console.error(`🍝 json=${mt} ` + pt);
          continue;
        }
      else
        (ot ?? ht) && (Et.x = ot ?? ht), (ct ?? vt) && (Et.y = ct ?? vt), (_t ?? gt) && (Et.alpha = _t ?? gt);
      const wt = cnvTweenArg(Et, $);
      CmnLib.debugLog && console.info(`🍝 ${mt ?? `{x:${ot} y:${ct} o:${_t}}`} => hTo:${JSON.stringify(wt)}`);
      const xt = new Tween($).to(wt, Y).easing(q).repeat(Z).yoyo(J);
      et.chain(xt), et = xt;
    }
    CmnLib.debugLog && console.groupEnd();
  }
  if (et.onComplete(X), N) {
    const it = z(this, ur)[N ?? ""];
    if (!(it != null && it.tw))
      throw `${N}は存在しない・または終了したトゥイーンです`;
    delete it.onEnd, it.tw.chain(rt);
  } else
    rt.start();
  const nt = argChk_Boolean(t, "arrive", !1), st = argChk_Boolean(t, "backlay", !1);
  return z(this, ur)[V] = { tw: et, resume: !1, onEnd: () => {
    if (nt && Object.assign($, W), st) {
      const it = z(this, se)[B].back.spLay;
      for (const ot of Object.keys(hMemberCnt))
        it[ot] = $[ot];
    }
  } }, !1;
}, Oh = new WeakSet(), Dd = function(t) {
  const { layer: e = "", id: r, name: S } = t, T = r ? `frm
${r}` : S ?? e;
  if (!T)
    throw "トゥイーンが指定されていません";
  const D = z(this, ur)[T];
  return D != null && D.tw ? D.resume = z(this, Ir).waitEvent(
    () => {
      var N;
      return (N = D.tw) == null ? void 0 : N.end();
    },
    // stop()とend()は別
    argChk_Boolean(t, "canskip", !0),
    argChk_Boolean(t, "global", !1)
  ) : !1;
}, Ih = new WeakSet(), Ad = function(t) {
  var D, N;
  const { layer: e = "", id: r, name: S } = t, T = r ? `frm
${r}` : S ?? e;
  if (!T)
    throw "トゥイーンが指定されていません";
  return (N = (D = z(this, ur)[T]) == null ? void 0 : D.tw) == null || N.end(), !1;
}, Dh = new WeakSet(), Nd = function(t) {
  var D, N;
  const { layer: e = "", id: r, name: S } = t, T = r ? `frm
${r}` : S ?? e;
  if (!T)
    throw "トゥイーンが指定されていません";
  return (N = (D = z(this, ur)[T]) == null ? void 0 : D.tw) == null || N.pause(), !1;
}, Ah = new WeakSet(), Ld = function(t) {
  var D, N;
  const { layer: e = "", id: r, name: S } = t, T = r ? `frm
${r}` : S ?? e;
  if (!T)
    throw "トゥイーンが指定されていません";
  return (N = (D = z(this, ur)[T]) == null ? void 0 : D.tw) == null || N.resume(), !1;
}, Xi = new WeakMap(), zn = new WeakSet(), Xa = function(t) {
  const { text: e } = t;
  if (!e)
    throw "textは必須です";
  const r = z(this, hr).call(this, t);
  delete t.text, this.val.getVal("tmp:sn.skip.enabled") ? t.wait = 0 : "wait" in t && argChk_Num(t, "wait", NaN);
  const S = encodeURIComponent(JSON.stringify(t));
  z(this, Ze).call(this, "add｜" + S, r);
  const T = argChk_Boolean(t, "record", !0), D = this.val.doRecLog();
  return T || this.val.setVal_Nochk("save", "sn.doRecLog", T), r.tagCh(e.replaceAll("[r]", `
`)), this.val.setVal_Nochk("save", "sn.doRecLog", D), z(this, Ze).call(this, "add_close｜", r), !1;
}, hr = new WeakMap(), Nh = new WeakSet(), kd = function(t) {
  const e = lt(this, Yi, xs).call(this, t, z(this, qr)), S = z(this, se)[e].getPage(t);
  if (!(S instanceof TxtLayer))
    throw e + "はTxtLayerではありません";
  return S;
}, fl = new WeakMap(), Lh = new WeakSet(), Bd = function(t) {
  const { layer: e } = t;
  if (!e)
    throw "[current] layerは必須です";
  if (at(this, Kr, z(this, se)[e]), !(z(this, Kr).getPage(t) instanceof TxtLayer))
    throw `${e}はTxtLayerではありません`;
  this.recPagebreak(), at(this, qr, e), this.val.setVal_Nochk("save", "const.sn.mesLayer", e);
  for (const r of lt(this, Xe, rr).call(this)) {
    const S = z(this, se)[r];
    S.fore instanceof TxtLayer && (S.fore.isCur = S.back.isCur = r === e);
  }
  return !1;
}, Kr = new WeakMap(), Hn = new WeakMap(), Yi = new WeakSet(), xs = function(t, e = "") {
  const r = t.layer ?? e;
  if (r.includes(","))
    throw "layer名に「,」は使えません";
  if (!(r in z(this, se)))
    throw "属性 layer【" + r + "】が不正です。レイヤーがありません";
  return t.layer = r;
}, Dr = new WeakMap(), Zr = new WeakMap(), kh = new WeakSet(), Fd = function(t) {
  const e = z(this, hr).call(this, t);
  return t.layer === z(this, qr) && t.page === "fore" && this.recPagebreak(), e.clearText(), !1;
}, Bh = new WeakSet(), $d = function(t) {
  return z(this, Ze).call(this, "endlink｜", z(this, hr).call(this, t)), !1;
}, Fh = new WeakSet(), Gd = function(t) {
  return argChk_Boolean(t, "rec_page_break", !0) && this.recPagebreak(), z(this, Kr) && (z(this, Kr).fore.clearLay(t), z(this, Kr).back.clearLay(t)), !1;
}, $h = new WeakSet(), Ud = function(t) {
  if (!t.pic)
    throw "[graph] picは必須です";
  const e = encodeURIComponent(JSON.stringify(t));
  return z(this, Ze).call(this, "grp｜" + e, z(this, hr).call(this, t)), !1;
}, Gh = new WeakSet(), jd = function(t) {
  t.style ?? (t.style = "background-color: rgba(255,0,0,0.5);"), t.style_hover ?? (t.style_hover = "background-color: rgba(255,0,0,0.9);"), t.style_clicked ?? (t.style_clicked = t.style);
  const e = encodeURIComponent(JSON.stringify(t));
  return z(this, Ze).call(this, "link｜" + e, z(this, hr).call(this, t)), !1;
}, Uh = new WeakSet(), zd = function(t) {
  return t.text = `
`, lt(this, zn, Xa).call(this, t);
}, jh = new WeakSet(), Hd = function(t) {
  return lt(this, dl, gf).call(this, { ...t, text: "[r]" });
}, dl = new WeakSet(), gf = function(t) {
  return t.text ? (t.record = !0, t.style ?? (t.style = ""), t.style += "display: none;", t.wait = 0, lt(this, zn, Xa).call(this, t)) : !1;
}, zh = new WeakSet(), Vd = function(t) {
  return at(this, Zr, []), at(this, Dr, t.text ?? ""), this.val.setVal_Nochk(
    "save",
    "const.sn.sLog",
    t.text ? `[{text:"${t.text}"}]` : "[]"
  ), !1;
}, Hh = new WeakSet(), Xd = function(t) {
  const { t: e, r } = t;
  if (!e)
    throw "[ruby2] tは必須です";
  if (!r)
    throw "[ruby2] rは必須です";
  return t.text = "｜" + encodeURIComponent(e) + "《" + encodeURIComponent(r) + "》", delete t.t, delete t.r, lt(this, zn, Xa).call(this, t);
}, Vh = new WeakSet(), Yd = function(t) {
  const e = encodeURIComponent(JSON.stringify(t));
  return z(this, Ze).call(this, "span｜" + e, z(this, hr).call(this, t)), !1;
}, Xh = new WeakSet(), Wd = function(t) {
  if (!t.t)
    throw "[tcy] tは必須です";
  const e = encodeURIComponent(JSON.stringify(t));
  return z(this, Ze).call(this, "tcy｜" + e, z(this, hr).call(this, t)), !1;
}, Yh = new WeakSet(), qd = function(t) {
  console.group("🥟 [dump_lay]");
  for (const e of lt(this, Xe, rr).call(this, t.layer)) {
    const r = z(this, se)[e];
    try {
      console.info(
        `%c${r.fore.name.slice(0, -7)} %o`,
        `color:#${CmnLib.isDarkMode ? "49F" : "05A"};`,
        JSON.parse(`{"back":{${r.back.dump()}}, "fore":{${r.fore.dump()}}}`)
      );
    } catch (S) {
      console.error("dump_lay err:%o", S), console.error(`   back:${r.back.dump()}`), console.error(`   fore:${r.fore.dump()}`);
    }
  }
  return console.groupEnd(), !1;
}, Wh = new WeakSet(), Kd = function(t) {
  const e = lt(this, Yi, xs).call(this, t, z(this, qr)), r = argChk_Boolean(t, "enabled", !0);
  return z(this, hr).call(this, t).enabled = r, this.val.setVal_Nochk("save", "const.sn.layer." + e + ".enabled", r), !1;
}, qh = new WeakSet(), Zd = function(t) {
  return Pages.argChk_page(t, "back"), t.clicksebuf ?? (t.clicksebuf = "SYS"), t.entersebuf ?? (t.entersebuf = "SYS"), t.leavesebuf ?? (t.leavesebuf = "SYS"), t.fn || (t.fn = this.scrItr.scriptFn), z(this, hr).call(this, t).addButton(t), this.scrItr.recodeDesign(t), !1;
}, // 11 match 301 step (0.1ms) PCRE2 https://regex101.com/r/reinpq/1
// List ${x}${x2}/${y}${y2}/${o}${o2}=${json}\n
/*
\(\s*
(?:	(?<x>[-=\d\.]+)	|	(['"])	(?<x2>.*?)	\2	)?
(?:
	\s*,\s*
	(?:	(?<y>[-=\d\.]+)	|	(['"])	(?<y2>.*?)	\5	)?
	(?:
		\s*,\s*
		(?:	(?<o>[-=\d\.]+)	|	(['"])	(?<o2>.*?)	\8	)

	)?
)?
|
(?<json>\{[^{}]*})
*/
Pt(LayerMng, "REG_TSY_PATH", /\(\s*(?:(?<x>[-=\d\.]+)|(['"])(?<x2>.*?)\2)?(?:\s*,\s*(?:(?<y>[-=\d\.]+)|(['"])(?<y2>.*?)\5)?(?:\s*,\s*(?:(?<o>[-=\d\.]+)|(['"])(?<o2>.*?)\8))?)?|(?<json>\{[^{}]*})/g), //	// 文字・文字レイヤ
tt(LayerMng, Xi, 10);
var we, ye, ya, Kh, Jd, pl, Vn, Ya;
class FocusMng {
  constructor() {
    tt(this, Kh);
    tt(this, Vn);
    tt(this, we, []);
    tt(this, ye, -1);
    tt(this, ya, new EventListenerCtn());
    tt(this, pl, CmnLib.debugLog ? (t) => console.log(`👾 <FocusMng idx:${t} btn:%o`, z(this, we)[t].btn) : () => {
    });
  }
  destroy() {
    at(this, we, []), at(this, ye, -1), z(this, ya).clear();
  }
  add(t, e, r) {
    if (z(this, we).findIndex((N) => N.btn === t) >= 0)
      return;
    if (t instanceof Container) {
      t.on("pointerdown", () => {
        for (let N = z(this, we).length - 1; N >= 0; --N)
          if (z(this, we)[N].btn === t) {
            at(this, ye, N);
            return;
          }
        at(this, ye, -1);
      }), z(this, we).push({ btn: t, on: e, off: r });
      return;
    }
    z(this, ya).add(t, "focus", () => {
      for (let N = z(this, we).length - 1; N >= 0; --N)
        if (z(this, we)[N].btn === t) {
          at(this, ye, N);
          return;
        }
      at(this, ye, -1);
    });
    let S = (N) => {
    }, T = t.localName === "button" || t.localName === "a" ? (N) => !N.isTrusted && N.key === "Enter" : (N) => N.key === "Enter";
    const D = t;
    switch (D.type ?? "") {
      case "checkbox":
        S = () => D.checked = !D.checked;
        break;
      case "":
        t.querySelectorAll("input[type]").length > 0 && (S = (N) => lt(this, Kh, Jd).call(this, t, N.key), T = () => !1);
        break;
      case "range":
        S = (N) => {
          N.isTrusted || (N.key === "ArrowUp" ? D.stepUp() : D.stepDown());
        };
        break;
      case "text":
      case "textarea":
        S = (N) => {
          if (N.isTrusted)
            return;
          let B = (D.selectionStart ?? 0) + (N.key === "ArrowUp" ? -1 : 1);
          B < 0 && (B = 0), D.setSelectionRange(B, B);
        };
        break;
    }
    z(this, ya).add(t, "keydown", (N) => {
      if (!(N.key !== "ArrowUp" && N.key !== "ArrowDown" && N.key !== "Enter")) {
        if (N.stopPropagation(), N.stopImmediatePropagation(), T(N)) {
          t.dispatchEvent(new MouseEvent("click"));
          return;
        }
        S(N);
      }
    }, { passive: !0 }), t.hasAttribute("tabindex") || (t.tabIndex = 0), z(this, we).push({ btn: t, on: e, off: r });
  }
  remove(t) {
    const e = z(this, we).findIndex((r) => r.btn === t);
    e < 0 || (z(this, we).splice(e, 1), z(this, we).length === 0 ? at(this, ye, -1) : e <= z(this, ye) && --Oe(this, ye)._);
  }
  isFocus(t) {
    return z(this, ye) < 0 ? !1 : z(this, we)[z(this, ye)].btn === t;
  }
  prev() {
    lt(this, Vn, Ya).call(this);
    const t = z(this, we).length;
    if (t !== 0) {
      --Oe(this, ye)._ < 0 && at(this, ye, t - 1);
      for (let e = t; e >= 1; --e) {
        const r = (z(this, ye) + e) % t;
        if (z(this, we)[r].on()) {
          at(this, ye, r), z(this, pl).call(this, r);
          return;
        }
      }
      at(this, ye, -1);
    }
  }
  next() {
    lt(this, Vn, Ya).call(this);
    const t = z(this, we).length;
    if (t !== 0) {
      ++Oe(this, ye)._ >= t && at(this, ye, 0);
      for (let e = 0; e < t; ++e) {
        const r = (z(this, ye) + e) % t;
        if (z(this, we)[r].on()) {
          at(this, ye, r), z(this, pl).call(this, r);
          return;
        }
      }
      at(this, ye, -1);
    }
  }
  getFocus() {
    if (z(this, ye) < 0)
      return null;
    lt(this, Vn, Ya).call(this), z(this, ye) >= z(this, we).length && at(this, ye, 0);
    const t = z(this, we)[z(this, ye)];
    return t.on() ? t.btn : null;
  }
  blur() {
    lt(this, Vn, Ya).call(this), at(this, ye, -1), globalThis.focus();
  }
}
we = new WeakMap(), ye = new WeakMap(), ya = new WeakMap(), Kh = new WeakSet(), Jd = function(t, e) {
  const r = t.querySelectorAll("input[type]"), S = r.length;
  for (let T = 0; T < S; ++T)
    if (r[T].checked) {
      r[(T + S + (e === "ArrowUp" ? -1 : 1)) % S].checked = !0;
      break;
    }
}, pl = new WeakMap(), Vn = new WeakSet(), Ya = function() {
  for (let t = z(this, we).length - 1; t >= 0; --t) {
    const e = z(this, we)[t];
    !(e.btn instanceof Container) || e.btn.parent ? e.off() : z(this, we).splice(t, 1);
  }
};
var top = "top", bottom = "bottom", right = "right", left = "left", auto = "auto", basePlacements = [top, bottom, right, left], start = "start", end = "end", clippingParents = "clippingParents", viewport = "viewport", popper = "popper", reference = "reference", variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(o, t) {
  return o.concat([t + "-" + start, t + "-" + end]);
}, []), placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(o, t) {
  return o.concat([t, t + "-" + start, t + "-" + end]);
}, []), beforeRead = "beforeRead", read$6 = "read", afterRead = "afterRead", beforeMain = "beforeMain", main$1 = "main", afterMain = "afterMain", beforeWrite = "beforeWrite", write$6 = "write", afterWrite = "afterWrite", modifierPhases = [beforeRead, read$6, afterRead, beforeMain, main$1, afterMain, beforeWrite, write$6, afterWrite];
function getNodeName(o) {
  return o ? (o.nodeName || "").toLowerCase() : null;
}
function getWindow(o) {
  if (o == null)
    return window;
  if (o.toString() !== "[object Window]") {
    var t = o.ownerDocument;
    return t && t.defaultView || window;
  }
  return o;
}
function isElement(o) {
  var t = getWindow(o).Element;
  return o instanceof t || o instanceof Element;
}
function isHTMLElement(o) {
  var t = getWindow(o).HTMLElement;
  return o instanceof t || o instanceof HTMLElement;
}
function isShadowRoot(o) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = getWindow(o).ShadowRoot;
  return o instanceof t || o instanceof ShadowRoot;
}
function applyStyles(o) {
  var t = o.state;
  Object.keys(t.elements).forEach(function(e) {
    var r = t.styles[e] || {}, S = t.attributes[e] || {}, T = t.elements[e];
    !isHTMLElement(T) || !getNodeName(T) || (Object.assign(T.style, r), Object.keys(S).forEach(function(D) {
      var N = S[D];
      N === !1 ? T.removeAttribute(D) : T.setAttribute(D, N === !0 ? "" : N);
    }));
  });
}
function effect$2(o) {
  var t = o.state, e = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
    Object.keys(t.elements).forEach(function(r) {
      var S = t.elements[r], T = t.attributes[r] || {}, D = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : e[r]), N = D.reduce(function(B, $) {
        return B[$] = "", B;
      }, {});
      !isHTMLElement(S) || !getNodeName(S) || (Object.assign(S.style, N), Object.keys(T).forEach(function(B) {
        S.removeAttribute(B);
      }));
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(o) {
  return o.split("-")[0];
}
var max = Math.max, min = Math.min, round = Math.round;
function getUAString() {
  var o = navigator.userAgentData;
  return o != null && o.brands ? o.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(o, t, e) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  var r = o.getBoundingClientRect(), S = 1, T = 1;
  t && isHTMLElement(o) && (S = o.offsetWidth > 0 && round(r.width) / o.offsetWidth || 1, T = o.offsetHeight > 0 && round(r.height) / o.offsetHeight || 1);
  var D = isElement(o) ? getWindow(o) : window, N = D.visualViewport, B = !isLayoutViewport() && e, $ = (r.left + (B && N ? N.offsetLeft : 0)) / S, U = (r.top + (B && N ? N.offsetTop : 0)) / T, H = r.width / S, V = r.height / T;
  return {
    width: H,
    height: V,
    top: U,
    right: $ + H,
    bottom: U + V,
    left: $,
    x: $,
    y: U
  };
}
function getLayoutRect(o) {
  var t = getBoundingClientRect(o), e = o.offsetWidth, r = o.offsetHeight;
  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
    x: o.offsetLeft,
    y: o.offsetTop,
    width: e,
    height: r
  };
}
function contains(o, t) {
  var e = t.getRootNode && t.getRootNode();
  if (o.contains(t))
    return !0;
  if (e && isShadowRoot(e)) {
    var r = t;
    do {
      if (r && o.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function getComputedStyle$1(o) {
  return getWindow(o).getComputedStyle(o);
}
function isTableElement(o) {
  return ["table", "td", "th"].indexOf(getNodeName(o)) >= 0;
}
function getDocumentElement(o) {
  return ((isElement(o) ? o.ownerDocument : (
    // $FlowFixMe[prop-missing]
    o.document
  )) || window.document).documentElement;
}
function getParentNode(o) {
  return getNodeName(o) === "html" ? o : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    o.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    o.parentNode || // DOM Element detected
    (isShadowRoot(o) ? o.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(o)
  );
}
function getTrueOffsetParent(o) {
  return !isHTMLElement(o) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(o).position === "fixed" ? null : o.offsetParent;
}
function getContainingBlock(o) {
  var t = /firefox/i.test(getUAString()), e = /Trident/i.test(getUAString());
  if (e && isHTMLElement(o)) {
    var r = getComputedStyle$1(o);
    if (r.position === "fixed")
      return null;
  }
  var S = getParentNode(o);
  for (isShadowRoot(S) && (S = S.host); isHTMLElement(S) && ["html", "body"].indexOf(getNodeName(S)) < 0; ) {
    var T = getComputedStyle$1(S);
    if (T.transform !== "none" || T.perspective !== "none" || T.contain === "paint" || ["transform", "perspective"].indexOf(T.willChange) !== -1 || t && T.willChange === "filter" || t && T.filter && T.filter !== "none")
      return S;
    S = S.parentNode;
  }
  return null;
}
function getOffsetParent(o) {
  for (var t = getWindow(o), e = getTrueOffsetParent(o); e && isTableElement(e) && getComputedStyle$1(e).position === "static"; )
    e = getTrueOffsetParent(e);
  return e && (getNodeName(e) === "html" || getNodeName(e) === "body" && getComputedStyle$1(e).position === "static") ? t : e || getContainingBlock(o) || t;
}
function getMainAxisFromPlacement(o) {
  return ["top", "bottom"].indexOf(o) >= 0 ? "x" : "y";
}
function within(o, t, e) {
  return max(o, min(t, e));
}
function withinMaxClamp(o, t, e) {
  var r = within(o, t, e);
  return r > e ? e : r;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(o) {
  return Object.assign({}, getFreshSideObject(), o);
}
function expandToHashMap(o, t) {
  return t.reduce(function(e, r) {
    return e[r] = o, e;
  }, {});
}
var toPaddingObject = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, mergePaddingObject(typeof t != "number" ? t : expandToHashMap(t, basePlacements));
};
function arrow(o) {
  var t, e = o.state, r = o.name, S = o.options, T = e.elements.arrow, D = e.modifiersData.popperOffsets, N = getBasePlacement(e.placement), B = getMainAxisFromPlacement(N), $ = [left, right].indexOf(N) >= 0, U = $ ? "height" : "width";
  if (!(!T || !D)) {
    var H = toPaddingObject(S.padding, e), V = getLayoutRect(T), X = B === "y" ? top : left, W = B === "y" ? bottom : right, Y = e.rects.reference[U] + e.rects.reference[B] - D[B] - e.rects.popper[U], q = D[B] - e.rects.reference[B], K = getOffsetParent(T), Z = K ? B === "y" ? K.clientHeight || 0 : K.clientWidth || 0 : 0, J = Y / 2 - q / 2, Q = H[X], rt = Z - V[U] - H[W], et = Z / 2 - V[U] / 2 + J, nt = within(Q, et, rt), st = B;
    e.modifiersData[r] = (t = {}, t[st] = nt, t.centerOffset = nt - et, t);
  }
}
function effect$1(o) {
  var t = o.state, e = o.options, r = e.element, S = r === void 0 ? "[data-popper-arrow]" : r;
  if (S != null && !(typeof S == "string" && (S = t.elements.popper.querySelector(S), !S))) {
    if (process.env.NODE_ENV !== "production" && (isHTMLElement(S) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !contains(t.elements.popper, S)) {
      process.env.NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    t.elements.arrow = S;
  }
}
const arrow$1 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(o) {
  return o.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(o) {
  var t = o.x, e = o.y, r = window, S = r.devicePixelRatio || 1;
  return {
    x: round(t * S) / S || 0,
    y: round(e * S) / S || 0
  };
}
function mapToStyles(o) {
  var t, e = o.popper, r = o.popperRect, S = o.placement, T = o.variation, D = o.offsets, N = o.position, B = o.gpuAcceleration, $ = o.adaptive, U = o.roundOffsets, H = o.isFixed, V = D.x, X = V === void 0 ? 0 : V, W = D.y, Y = W === void 0 ? 0 : W, q = typeof U == "function" ? U({
    x: X,
    y: Y
  }) : {
    x: X,
    y: Y
  };
  X = q.x, Y = q.y;
  var K = D.hasOwnProperty("x"), Z = D.hasOwnProperty("y"), J = left, Q = top, rt = window;
  if ($) {
    var et = getOffsetParent(e), nt = "clientHeight", st = "clientWidth";
    if (et === getWindow(e) && (et = getDocumentElement(e), getComputedStyle$1(et).position !== "static" && N === "absolute" && (nt = "scrollHeight", st = "scrollWidth")), et = et, S === top || (S === left || S === right) && T === end) {
      Q = bottom;
      var it = H && et === rt && rt.visualViewport ? rt.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        et[nt]
      );
      Y -= it - r.height, Y *= B ? 1 : -1;
    }
    if (S === left || (S === top || S === bottom) && T === end) {
      J = right;
      var ot = H && et === rt && rt.visualViewport ? rt.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        et[st]
      );
      X -= ot - r.width, X *= B ? 1 : -1;
    }
  }
  var ht = Object.assign({
    position: N
  }, $ && unsetSides), ct = U === !0 ? roundOffsetsByDPR({
    x: X,
    y: Y
  }) : {
    x: X,
    y: Y
  };
  if (X = ct.x, Y = ct.y, B) {
    var vt;
    return Object.assign({}, ht, (vt = {}, vt[Q] = Z ? "0" : "", vt[J] = K ? "0" : "", vt.transform = (rt.devicePixelRatio || 1) <= 1 ? "translate(" + X + "px, " + Y + "px)" : "translate3d(" + X + "px, " + Y + "px, 0)", vt));
  }
  return Object.assign({}, ht, (t = {}, t[Q] = Z ? Y + "px" : "", t[J] = K ? X + "px" : "", t.transform = "", t));
}
function computeStyles(o) {
  var t = o.state, e = o.options, r = e.gpuAcceleration, S = r === void 0 ? !0 : r, T = e.adaptive, D = T === void 0 ? !0 : T, N = e.roundOffsets, B = N === void 0 ? !0 : N;
  if (process.env.NODE_ENV !== "production") {
    var $ = getComputedStyle$1(t.elements.popper).transitionProperty || "";
    D && ["transform", "top", "right", "bottom", "left"].some(function(H) {
      return $.indexOf(H) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var U = {
    placement: getBasePlacement(t.placement),
    variation: getVariation(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: S,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, mapToStyles(Object.assign({}, U, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: D,
    roundOffsets: B
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, mapToStyles(Object.assign({}, U, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: B
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: !0
};
function effect(o) {
  var t = o.state, e = o.instance, r = o.options, S = r.scroll, T = S === void 0 ? !0 : S, D = r.resize, N = D === void 0 ? !0 : D, B = getWindow(t.elements.popper), $ = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return T && $.forEach(function(U) {
    U.addEventListener("scroll", e.update, passive);
  }), N && B.addEventListener("resize", e.update, passive), function() {
    T && $.forEach(function(U) {
      U.removeEventListener("scroll", e.update, passive);
    }), N && B.removeEventListener("resize", e.update, passive);
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(o) {
  return o.replace(/left|right|bottom|top/g, function(t) {
    return hash$1[t];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(o) {
  return o.replace(/start|end/g, function(t) {
    return hash[t];
  });
}
function getWindowScroll(o) {
  var t = getWindow(o), e = t.pageXOffset, r = t.pageYOffset;
  return {
    scrollLeft: e,
    scrollTop: r
  };
}
function getWindowScrollBarX(o) {
  return getBoundingClientRect(getDocumentElement(o)).left + getWindowScroll(o).scrollLeft;
}
function getViewportRect(o, t) {
  var e = getWindow(o), r = getDocumentElement(o), S = e.visualViewport, T = r.clientWidth, D = r.clientHeight, N = 0, B = 0;
  if (S) {
    T = S.width, D = S.height;
    var $ = isLayoutViewport();
    ($ || !$ && t === "fixed") && (N = S.offsetLeft, B = S.offsetTop);
  }
  return {
    width: T,
    height: D,
    x: N + getWindowScrollBarX(o),
    y: B
  };
}
function getDocumentRect(o) {
  var t, e = getDocumentElement(o), r = getWindowScroll(o), S = (t = o.ownerDocument) == null ? void 0 : t.body, T = max(e.scrollWidth, e.clientWidth, S ? S.scrollWidth : 0, S ? S.clientWidth : 0), D = max(e.scrollHeight, e.clientHeight, S ? S.scrollHeight : 0, S ? S.clientHeight : 0), N = -r.scrollLeft + getWindowScrollBarX(o), B = -r.scrollTop;
  return getComputedStyle$1(S || e).direction === "rtl" && (N += max(e.clientWidth, S ? S.clientWidth : 0) - T), {
    width: T,
    height: D,
    x: N,
    y: B
  };
}
function isScrollParent(o) {
  var t = getComputedStyle$1(o), e = t.overflow, r = t.overflowX, S = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + S + r);
}
function getScrollParent(o) {
  return ["html", "body", "#document"].indexOf(getNodeName(o)) >= 0 ? o.ownerDocument.body : isHTMLElement(o) && isScrollParent(o) ? o : getScrollParent(getParentNode(o));
}
function listScrollParents(o, t) {
  var e;
  t === void 0 && (t = []);
  var r = getScrollParent(o), S = r === ((e = o.ownerDocument) == null ? void 0 : e.body), T = getWindow(r), D = S ? [T].concat(T.visualViewport || [], isScrollParent(r) ? r : []) : r, N = t.concat(D);
  return S ? N : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    N.concat(listScrollParents(getParentNode(D)))
  );
}
function rectToClientRect(o) {
  return Object.assign({}, o, {
    left: o.x,
    top: o.y,
    right: o.x + o.width,
    bottom: o.y + o.height
  });
}
function getInnerBoundingClientRect(o, t) {
  var e = getBoundingClientRect(o, !1, t === "fixed");
  return e.top = e.top + o.clientTop, e.left = e.left + o.clientLeft, e.bottom = e.top + o.clientHeight, e.right = e.left + o.clientWidth, e.width = o.clientWidth, e.height = o.clientHeight, e.x = e.left, e.y = e.top, e;
}
function getClientRectFromMixedType(o, t, e) {
  return t === viewport ? rectToClientRect(getViewportRect(o, e)) : isElement(t) ? getInnerBoundingClientRect(t, e) : rectToClientRect(getDocumentRect(getDocumentElement(o)));
}
function getClippingParents(o) {
  var t = listScrollParents(getParentNode(o)), e = ["absolute", "fixed"].indexOf(getComputedStyle$1(o).position) >= 0, r = e && isHTMLElement(o) ? getOffsetParent(o) : o;
  return isElement(r) ? t.filter(function(S) {
    return isElement(S) && contains(S, r) && getNodeName(S) !== "body";
  }) : [];
}
function getClippingRect(o, t, e, r) {
  var S = t === "clippingParents" ? getClippingParents(o) : [].concat(t), T = [].concat(S, [e]), D = T[0], N = T.reduce(function(B, $) {
    var U = getClientRectFromMixedType(o, $, r);
    return B.top = max(U.top, B.top), B.right = min(U.right, B.right), B.bottom = min(U.bottom, B.bottom), B.left = max(U.left, B.left), B;
  }, getClientRectFromMixedType(o, D, r));
  return N.width = N.right - N.left, N.height = N.bottom - N.top, N.x = N.left, N.y = N.top, N;
}
function computeOffsets(o) {
  var t = o.reference, e = o.element, r = o.placement, S = r ? getBasePlacement(r) : null, T = r ? getVariation(r) : null, D = t.x + t.width / 2 - e.width / 2, N = t.y + t.height / 2 - e.height / 2, B;
  switch (S) {
    case top:
      B = {
        x: D,
        y: t.y - e.height
      };
      break;
    case bottom:
      B = {
        x: D,
        y: t.y + t.height
      };
      break;
    case right:
      B = {
        x: t.x + t.width,
        y: N
      };
      break;
    case left:
      B = {
        x: t.x - e.width,
        y: N
      };
      break;
    default:
      B = {
        x: t.x,
        y: t.y
      };
  }
  var $ = S ? getMainAxisFromPlacement(S) : null;
  if ($ != null) {
    var U = $ === "y" ? "height" : "width";
    switch (T) {
      case start:
        B[$] = B[$] - (t[U] / 2 - e[U] / 2);
        break;
      case end:
        B[$] = B[$] + (t[U] / 2 - e[U] / 2);
        break;
    }
  }
  return B;
}
function detectOverflow(o, t) {
  t === void 0 && (t = {});
  var e = t, r = e.placement, S = r === void 0 ? o.placement : r, T = e.strategy, D = T === void 0 ? o.strategy : T, N = e.boundary, B = N === void 0 ? clippingParents : N, $ = e.rootBoundary, U = $ === void 0 ? viewport : $, H = e.elementContext, V = H === void 0 ? popper : H, X = e.altBoundary, W = X === void 0 ? !1 : X, Y = e.padding, q = Y === void 0 ? 0 : Y, K = mergePaddingObject(typeof q != "number" ? q : expandToHashMap(q, basePlacements)), Z = V === popper ? reference : popper, J = o.rects.popper, Q = o.elements[W ? Z : V], rt = getClippingRect(isElement(Q) ? Q : Q.contextElement || getDocumentElement(o.elements.popper), B, U, D), et = getBoundingClientRect(o.elements.reference), nt = computeOffsets({
    reference: et,
    element: J,
    strategy: "absolute",
    placement: S
  }), st = rectToClientRect(Object.assign({}, J, nt)), it = V === popper ? st : et, ot = {
    top: rt.top - it.top + K.top,
    bottom: it.bottom - rt.bottom + K.bottom,
    left: rt.left - it.left + K.left,
    right: it.right - rt.right + K.right
  }, ht = o.modifiersData.offset;
  if (V === popper && ht) {
    var ct = ht[S];
    Object.keys(ot).forEach(function(vt) {
      var _t = [right, bottom].indexOf(vt) >= 0 ? 1 : -1, gt = [top, bottom].indexOf(vt) >= 0 ? "y" : "x";
      ot[vt] += ct[gt] * _t;
    });
  }
  return ot;
}
function computeAutoPlacement(o, t) {
  t === void 0 && (t = {});
  var e = t, r = e.placement, S = e.boundary, T = e.rootBoundary, D = e.padding, N = e.flipVariations, B = e.allowedAutoPlacements, $ = B === void 0 ? placements : B, U = getVariation(r), H = U ? N ? variationPlacements : variationPlacements.filter(function(W) {
    return getVariation(W) === U;
  }) : basePlacements, V = H.filter(function(W) {
    return $.indexOf(W) >= 0;
  });
  V.length === 0 && (V = H, process.env.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var X = V.reduce(function(W, Y) {
    return W[Y] = detectOverflow(o, {
      placement: Y,
      boundary: S,
      rootBoundary: T,
      padding: D
    })[getBasePlacement(Y)], W;
  }, {});
  return Object.keys(X).sort(function(W, Y) {
    return X[W] - X[Y];
  });
}
function getExpandedFallbackPlacements(o) {
  if (getBasePlacement(o) === auto)
    return [];
  var t = getOppositePlacement(o);
  return [getOppositeVariationPlacement(o), t, getOppositeVariationPlacement(t)];
}
function flip(o) {
  var t = o.state, e = o.options, r = o.name;
  if (!t.modifiersData[r]._skip) {
    for (var S = e.mainAxis, T = S === void 0 ? !0 : S, D = e.altAxis, N = D === void 0 ? !0 : D, B = e.fallbackPlacements, $ = e.padding, U = e.boundary, H = e.rootBoundary, V = e.altBoundary, X = e.flipVariations, W = X === void 0 ? !0 : X, Y = e.allowedAutoPlacements, q = t.options.placement, K = getBasePlacement(q), Z = K === q, J = B || (Z || !W ? [getOppositePlacement(q)] : getExpandedFallbackPlacements(q)), Q = [q].concat(J).reduce(function(It, Ot) {
      return It.concat(getBasePlacement(Ot) === auto ? computeAutoPlacement(t, {
        placement: Ot,
        boundary: U,
        rootBoundary: H,
        padding: $,
        flipVariations: W,
        allowedAutoPlacements: Y
      }) : Ot);
    }, []), rt = t.rects.reference, et = t.rects.popper, nt = /* @__PURE__ */ new Map(), st = !0, it = Q[0], ot = 0; ot < Q.length; ot++) {
      var ht = Q[ot], ct = getBasePlacement(ht), vt = getVariation(ht) === start, _t = [top, bottom].indexOf(ct) >= 0, gt = _t ? "width" : "height", mt = detectOverflow(t, {
        placement: ht,
        boundary: U,
        rootBoundary: H,
        altBoundary: V,
        padding: $
      }), Et = _t ? vt ? right : left : vt ? bottom : top;
      rt[gt] > et[gt] && (Et = getOppositePlacement(Et));
      var wt = getOppositePlacement(Et), xt = [];
      if (T && xt.push(mt[ct] <= 0), N && xt.push(mt[Et] <= 0, mt[wt] <= 0), xt.every(function(It) {
        return It;
      })) {
        it = ht, st = !1;
        break;
      }
      nt.set(ht, xt);
    }
    if (st)
      for (var pt = W ? 3 : 1, yt = function(Ot) {
        var ft = Q.find(function(Ft) {
          var Mt = nt.get(Ft);
          if (Mt)
            return Mt.slice(0, Ot).every(function(zt) {
              return zt;
            });
        });
        if (ft)
          return it = ft, "break";
      }, Dt = pt; Dt > 0; Dt--) {
        var At = yt(Dt);
        if (At === "break")
          break;
      }
    t.placement !== it && (t.modifiersData[r]._skip = !0, t.placement = it, t.reset = !0);
  }
}
const flip$1 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function getSideOffsets(o, t, e) {
  return e === void 0 && (e = {
    x: 0,
    y: 0
  }), {
    top: o.top - t.height - e.y,
    right: o.right - t.width + e.x,
    bottom: o.bottom - t.height + e.y,
    left: o.left - t.width - e.x
  };
}
function isAnySideFullyClipped(o) {
  return [top, right, bottom, left].some(function(t) {
    return o[t] >= 0;
  });
}
function hide(o) {
  var t = o.state, e = o.name, r = t.rects.reference, S = t.rects.popper, T = t.modifiersData.preventOverflow, D = detectOverflow(t, {
    elementContext: "reference"
  }), N = detectOverflow(t, {
    altBoundary: !0
  }), B = getSideOffsets(D, r), $ = getSideOffsets(N, S, T), U = isAnySideFullyClipped(B), H = isAnySideFullyClipped($);
  t.modifiersData[e] = {
    referenceClippingOffsets: B,
    popperEscapeOffsets: $,
    isReferenceHidden: U,
    hasPopperEscaped: H
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": U,
    "data-popper-escaped": H
  });
}
const hide$1 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(o, t, e) {
  var r = getBasePlacement(o), S = [left, top].indexOf(r) >= 0 ? -1 : 1, T = typeof e == "function" ? e(Object.assign({}, t, {
    placement: o
  })) : e, D = T[0], N = T[1];
  return D = D || 0, N = (N || 0) * S, [left, right].indexOf(r) >= 0 ? {
    x: N,
    y: D
  } : {
    x: D,
    y: N
  };
}
function offset(o) {
  var t = o.state, e = o.options, r = o.name, S = e.offset, T = S === void 0 ? [0, 0] : S, D = placements.reduce(function(U, H) {
    return U[H] = distanceAndSkiddingToXY(H, t.rects, T), U;
  }, {}), N = D[t.placement], B = N.x, $ = N.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += B, t.modifiersData.popperOffsets.y += $), t.modifiersData[r] = D;
}
const offset$1 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(o) {
  var t = o.state, e = o.name;
  t.modifiersData[e] = computeOffsets({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(o) {
  return o === "x" ? "y" : "x";
}
function preventOverflow(o) {
  var t = o.state, e = o.options, r = o.name, S = e.mainAxis, T = S === void 0 ? !0 : S, D = e.altAxis, N = D === void 0 ? !1 : D, B = e.boundary, $ = e.rootBoundary, U = e.altBoundary, H = e.padding, V = e.tether, X = V === void 0 ? !0 : V, W = e.tetherOffset, Y = W === void 0 ? 0 : W, q = detectOverflow(t, {
    boundary: B,
    rootBoundary: $,
    padding: H,
    altBoundary: U
  }), K = getBasePlacement(t.placement), Z = getVariation(t.placement), J = !Z, Q = getMainAxisFromPlacement(K), rt = getAltAxis(Q), et = t.modifiersData.popperOffsets, nt = t.rects.reference, st = t.rects.popper, it = typeof Y == "function" ? Y(Object.assign({}, t.rects, {
    placement: t.placement
  })) : Y, ot = typeof it == "number" ? {
    mainAxis: it,
    altAxis: it
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, it), ht = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, ct = {
    x: 0,
    y: 0
  };
  if (et) {
    if (T) {
      var vt, _t = Q === "y" ? top : left, gt = Q === "y" ? bottom : right, mt = Q === "y" ? "height" : "width", Et = et[Q], wt = Et + q[_t], xt = Et - q[gt], pt = X ? -st[mt] / 2 : 0, yt = Z === start ? nt[mt] : st[mt], Dt = Z === start ? -st[mt] : -nt[mt], At = t.elements.arrow, It = X && At ? getLayoutRect(At) : {
        width: 0,
        height: 0
      }, Ot = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : getFreshSideObject(), ft = Ot[_t], Ft = Ot[gt], Mt = within(0, nt[mt], It[mt]), zt = J ? nt[mt] / 2 - pt - Mt - ft - ot.mainAxis : yt - Mt - ft - ot.mainAxis, Nt = J ? -nt[mt] / 2 + pt + Mt + Ft + ot.mainAxis : Dt + Mt + Ft + ot.mainAxis, St = t.elements.arrow && getOffsetParent(t.elements.arrow), Ht = St ? Q === "y" ? St.clientTop || 0 : St.clientLeft || 0 : 0, Lt = (vt = ht == null ? void 0 : ht[Q]) != null ? vt : 0, Tt = Et + zt - Lt - Ht, kt = Et + Nt - Lt, Ut = within(X ? min(wt, Tt) : wt, Et, X ? max(xt, kt) : xt);
      et[Q] = Ut, ct[Q] = Ut - Et;
    }
    if (N) {
      var Ct, Wt = Q === "x" ? top : left, Jt = Q === "x" ? bottom : right, qt = et[rt], xe = rt === "y" ? "height" : "width", Me = qt + q[Wt], ue = qt - q[Jt], me = [top, left].indexOf(K) !== -1, pe = (Ct = ht == null ? void 0 : ht[rt]) != null ? Ct : 0, fe = me ? Me : qt - nt[xe] - st[xe] - pe + ot.altAxis, ce = me ? qt + nt[xe] + st[xe] - pe - ot.altAxis : ue, ie = X && me ? withinMaxClamp(fe, qt, ce) : within(X ? fe : Me, qt, X ? ce : ue);
      et[rt] = ie, ct[rt] = ie - qt;
    }
    t.modifiersData[r] = ct;
  }
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(o) {
  return {
    scrollLeft: o.scrollLeft,
    scrollTop: o.scrollTop
  };
}
function getNodeScroll(o) {
  return o === getWindow(o) || !isHTMLElement(o) ? getWindowScroll(o) : getHTMLElementScroll(o);
}
function isElementScaled(o) {
  var t = o.getBoundingClientRect(), e = round(t.width) / o.offsetWidth || 1, r = round(t.height) / o.offsetHeight || 1;
  return e !== 1 || r !== 1;
}
function getCompositeRect(o, t, e) {
  e === void 0 && (e = !1);
  var r = isHTMLElement(t), S = isHTMLElement(t) && isElementScaled(t), T = getDocumentElement(t), D = getBoundingClientRect(o, S, e), N = {
    scrollLeft: 0,
    scrollTop: 0
  }, B = {
    x: 0,
    y: 0
  };
  return (r || !r && !e) && ((getNodeName(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  isScrollParent(T)) && (N = getNodeScroll(t)), isHTMLElement(t) ? (B = getBoundingClientRect(t, !0), B.x += t.clientLeft, B.y += t.clientTop) : T && (B.x = getWindowScrollBarX(T))), {
    x: D.left + N.scrollLeft - B.x,
    y: D.top + N.scrollTop - B.y,
    width: D.width,
    height: D.height
  };
}
function order(o) {
  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), r = [];
  o.forEach(function(T) {
    t.set(T.name, T);
  });
  function S(T) {
    e.add(T.name);
    var D = [].concat(T.requires || [], T.requiresIfExists || []);
    D.forEach(function(N) {
      if (!e.has(N)) {
        var B = t.get(N);
        B && S(B);
      }
    }), r.push(T);
  }
  return o.forEach(function(T) {
    e.has(T.name) || S(T);
  }), r;
}
function orderModifiers(o) {
  var t = order(o);
  return modifierPhases.reduce(function(e, r) {
    return e.concat(t.filter(function(S) {
      return S.phase === r;
    }));
  }, []);
}
function debounce(o) {
  var t;
  return function() {
    return t || (t = new Promise(function(e) {
      Promise.resolve().then(function() {
        t = void 0, e(o());
      });
    })), t;
  };
}
function format(o) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    e[r - 1] = arguments[r];
  return [].concat(e).reduce(function(S, T) {
    return S.replace(/%s/, T);
  }, o);
}
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(o) {
  o.forEach(function(t) {
    [].concat(Object.keys(t), VALID_PROPERTIES).filter(function(e, r, S) {
      return S.indexOf(e) === r;
    }).forEach(function(e) {
      switch (e) {
        case "name":
          typeof t.name != "string" && console.error(format(INVALID_MODIFIER_ERROR, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"'));
          break;
        case "enabled":
          typeof t.enabled != "boolean" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"'));
          break;
        case "phase":
          modifierPhases.indexOf(t.phase) < 0 && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(t.phase) + '"'));
          break;
        case "fn":
          typeof t.fn != "function" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "effect":
          t.effect != null && typeof t.effect != "function" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "requires":
          t.requires != null && !Array.isArray(t.requires) && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(t.requiresIfExists) || console.error(format(INVALID_MODIFIER_ERROR, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(r) {
            return '"' + r + '"';
          }).join(", ") + '; but "' + e + '" was provided.');
      }
      t.requires && t.requires.forEach(function(r) {
        o.find(function(S) {
          return S.name === r;
        }) == null && console.error(format(MISSING_DEPENDENCY_ERROR, String(t.name), r, r));
      });
    });
  });
}
function uniqueBy(o, t) {
  var e = /* @__PURE__ */ new Set();
  return o.filter(function(r) {
    var S = t(r);
    if (!e.has(S))
      return e.add(S), !0;
  });
}
function mergeByName(o) {
  var t = o.reduce(function(e, r) {
    var S = e[r.name];
    return e[r.name] = S ? Object.assign({}, S, r, {
      options: Object.assign({}, S.options, r.options),
      data: Object.assign({}, S.data, r.data)
    }) : r, e;
  }, {});
  return Object.keys(t).map(function(e) {
    return t[e];
  });
}
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var o = arguments.length, t = new Array(o), e = 0; e < o; e++)
    t[e] = arguments[e];
  return !t.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function popperGenerator(o) {
  o === void 0 && (o = {});
  var t = o, e = t.defaultModifiers, r = e === void 0 ? [] : e, S = t.defaultOptions, T = S === void 0 ? DEFAULT_OPTIONS : S;
  return function(N, B, $) {
    $ === void 0 && ($ = T);
    var U = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, T),
      modifiersData: {},
      elements: {
        reference: N,
        popper: B
      },
      attributes: {},
      styles: {}
    }, H = [], V = !1, X = {
      state: U,
      setOptions: function(K) {
        var Z = typeof K == "function" ? K(U.options) : K;
        Y(), U.options = Object.assign({}, T, U.options, Z), U.scrollParents = {
          reference: isElement(N) ? listScrollParents(N) : N.contextElement ? listScrollParents(N.contextElement) : [],
          popper: listScrollParents(B)
        };
        var J = orderModifiers(mergeByName([].concat(r, U.options.modifiers)));
        if (U.orderedModifiers = J.filter(function(ht) {
          return ht.enabled;
        }), process.env.NODE_ENV !== "production") {
          var Q = uniqueBy([].concat(J, U.options.modifiers), function(ht) {
            var ct = ht.name;
            return ct;
          });
          if (validateModifiers(Q), getBasePlacement(U.options.placement) === auto) {
            var rt = U.orderedModifiers.find(function(ht) {
              var ct = ht.name;
              return ct === "flip";
            });
            rt || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var et = getComputedStyle$1(B), nt = et.marginTop, st = et.marginRight, it = et.marginBottom, ot = et.marginLeft;
          [nt, st, it, ot].some(function(ht) {
            return parseFloat(ht);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return W(), X.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!V) {
          var K = U.elements, Z = K.reference, J = K.popper;
          if (!areValidElements(Z, J)) {
            process.env.NODE_ENV !== "production" && console.error(INVALID_ELEMENT_ERROR);
            return;
          }
          U.rects = {
            reference: getCompositeRect(Z, getOffsetParent(J), U.options.strategy === "fixed"),
            popper: getLayoutRect(J)
          }, U.reset = !1, U.placement = U.options.placement, U.orderedModifiers.forEach(function(ht) {
            return U.modifiersData[ht.name] = Object.assign({}, ht.data);
          });
          for (var Q = 0, rt = 0; rt < U.orderedModifiers.length; rt++) {
            if (process.env.NODE_ENV !== "production" && (Q += 1, Q > 100)) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
            if (U.reset === !0) {
              U.reset = !1, rt = -1;
              continue;
            }
            var et = U.orderedModifiers[rt], nt = et.fn, st = et.options, it = st === void 0 ? {} : st, ot = et.name;
            typeof nt == "function" && (U = nt({
              state: U,
              options: it,
              name: ot,
              instance: X
            }) || U);
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(q) {
          X.forceUpdate(), q(U);
        });
      }),
      destroy: function() {
        Y(), V = !0;
      }
    };
    if (!areValidElements(N, B))
      return process.env.NODE_ENV !== "production" && console.error(INVALID_ELEMENT_ERROR), X;
    X.setOptions($).then(function(q) {
      !V && $.onFirstUpdate && $.onFirstUpdate(q);
    });
    function W() {
      U.orderedModifiers.forEach(function(q) {
        var K = q.name, Z = q.options, J = Z === void 0 ? {} : Z, Q = q.effect;
        if (typeof Q == "function") {
          var rt = Q({
            state: U,
            name: K,
            instance: X,
            options: J
          }), et = function() {
          };
          H.push(rt || et);
        }
      });
    }
    function Y() {
      H.forEach(function(q) {
        return q();
      }), H = [];
    }
    return X;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1], createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
const { GamepadListener } = require("gamepad.js");
var Je, Wi, ke, vl, gl, mf, ml, _f, _l, yf, ba, xa, yl, bf, Pe, yr, _i, yi, bl, qi, Ss, xl, Sl, Ue, Sa, Ea, El, Zh, Qd, Tl, Xn, Jh, tp, wl, xf, Qh, ep, Cl, Sf, Yn, Wa, Wn, tc, rp, ec, ip, br, rc, np, ic, sp, Ta, gu, bi, qn, Kn, nc, ap, Ye;
class EventMng {
  constructor(t, e, r, S, T, D, N, B, $) {
    tt(this, gl);
    tt(this, ml);
    tt(this, _l);
    tt(this, yl);
    tt(this, qi);
    tt(this, Zh);
    // イベントを全消去
    tt(this, Jh);
    tt(this, wl);
    // イベントを予約
    tt(this, Qh);
    tt(this, Cl);
    tt(this, Yn);
    // 行末クリック待ち
    tt(this, tc);
    // 改ページクリック待ち
    tt(this, ec);
    tt(this, rc);
    // フォーカス移動
    tt(this, ic);
    // ウェイトを入れる
    tt(this, Ta);
    // クリックを待つ
    tt(this, nc);
    tt(this, Je, new EventListenerCtn());
    tt(this, Wi, new GamepadListener({
      analog: !1,
      deadZone: 0.3
    }));
    tt(this, ke, new FocusMng());
    tt(this, vl, (t) => {
    });
    tt(this, ba, !1);
    tt(this, xa, !1);
    tt(this, Pe, {});
    tt(this, yr, {});
    tt(this, _i, !1);
    tt(this, yi, !1);
    // 予約イベントの発生待ち中か
    tt(this, bl, (t) => z(this, Pe)[t] ?? z(this, yr)[t]);
    tt(this, xl, () => {
      at(this, xl, () => {
      }), this.scrItr.firstWait();
    });
    tt(this, Sl, {
      getBoundingClientRect: (t = 0, e = 0) => DOMRect.fromRect({ x: t, y: e, width: 0, height: 0 })
    });
    tt(this, Ue, void 0);
    tt(this, Sa, void 0);
    tt(this, Ea, void 0);
    tt(this, El, {
      placement: "bottom",
      fallbackPlacements: ["top", "bottom"]
    });
    tt(this, Tl, (t, e) => {
    });
    tt(this, Xn, new EventListenerCtn());
    tt(this, Wn, () => this.layMng.goTxt());
    // スキップ中断予約
    tt(this, br, () => !1);
    tt(this, bi, () => {
    });
    tt(this, qn, new eventemitter3Exports());
    tt(this, Kn, "sn:notice_comp_txt");
    // 0:no push  1:one push  2:push repeating
    tt(this, Ye, {
      Alt: 0,
      Meta: 0,
      // COMMANDキー
      Control: 0,
      ArrowDown: 0,
      End: 0,
      Enter: 0,
      Escape: 0,
      " ": 0,
      GoBack: 0
      // AndroidのBackキーだと思う
    });
    var W, Y;
    if (this.cfg = t, this.hTag = e, this.appPixi = r, this.main = S, this.layMng = T, this.val = D, this.sndMng = N, this.scrItr = B, this.sys = $, e.clear_event = (q) => lt(this, Jh, tp).call(this, q), e.event = (q) => lt(this, Qh, ep).call(this, q), e.l = (q) => lt(this, tc, rp).call(this, q), e.p = (q) => lt(this, ec, ip).call(this, q), e.s = () => (this.scrItr.recodePage(), lt(this, qi, Ss).call(this, () => {
    }, !1, !0)), e.set_cancel_skip = () => lt(this, rc, np).call(this), e.set_focus = (q) => lt(this, ic, sp).call(this, q), e.wait = (q) => lt(this, Ta, gu).call(this, q), e.waitclick = () => lt(this, nc, ap).call(this), N.setEvtMng(this), B.setOtherObj(this, T), TxtLayer.setEvtMng(S, this, $), T.setEvtMng(this), $.setFire((q, K) => this.fire(q, K)), CmnLib.isDbg) {
      const q = {
        pause: () => {
          if (at(this, _i, !0), !z(this, yi))
            return;
          const K = {};
          this.scrItr.recodeDesign(K), this.sys.callHook("_enterDesign", K), this.sys.send2Dbg("_enterDesign", K);
        },
        stopOnBreakpoint: () => at(this, _i, !0),
        stopOnDataBreakpoint: () => at(this, _i, !0),
        continue: () => at(this, _i, !1),
        disconnect: () => at(this, _i, !1)
      };
      q.attach = q.stopOnEntry = q.stopOnStep = q.stopOnStepIn = q.stopOnStepOut = q.stopOnBackstep = q.pause, $.addHook((K) => {
        var Z;
        return (Z = q[K]) == null ? void 0 : Z.call(q);
      });
    }
    addStyle(`
.sn_hint {
	background-color: #3c3225;
	color: white;
	padding: 4px 8px;
	border-radius: 4px;
	font-size: 1.2em;
	z-index: 10000;
	pointer-events: none;
	user-select: none;
}

.sn_hint_ar,
.sn_hint_ar::before {
	position: absolute;
	width: 8px;
	height: 8px;
	background: inherit;
}
.sn_hint_ar {
	visibility: hidden;
}
.sn_hint_ar::before {
	visibility: visible;
	content: '';
	transform: rotate(45deg);
}

.sn_hint[data-popper-placement^='top']		> .sn_hint_ar {bottom: -4px;}
.sn_hint[data-popper-placement^='bottom']	> .sn_hint_ar {top: -4px;}
.sn_hint[data-popper-placement^='left']		> .sn_hint_ar {right: -4px;}
.sn_hint[data-popper-placement^='right']	> .sn_hint_ar {left: -4px;}
`);
    for (const q of Array.from(document.getElementsByClassName("sn_hint")))
      (W = q.parentElement) == null || W.removeChild(q);
    (Y = Main.cvs.parentElement) == null || Y.insertAdjacentHTML("beforeend", `
<div class="sn_hint" role="tooltip">
	<span>Dummy</span>
	<div class="sn_hint_ar" data-popper-arrow></div>
</div>`), at(this, Ue, document.querySelector(".sn_hint")), at(this, Sa, z(this, Ue).querySelector("span")), at(this, Ea, createPopper(z(this, Sl), z(this, Ue))), z(this, Ue).hidden = !0, r.stage.interactive = !0, CmnLib.isMobile ? r.stage.on("pointerdown", (q) => this.fire("click", q)) : z(this, Je).add(r.stage, "pointerdown", (q) => {
      switch (q.data.button) {
        case 0:
          this.fire("click", q);
          break;
        case 1:
          this.fire("middleclick", q);
          break;
      }
    }), z(this, Je).add(window, "keydown", (q) => lt(this, gl, mf).call(this, q)), z(this, Je).add(Main.cvs, "contextmenu", (q) => lt(this, ml, _f).call(this, q));
    const U = (q) => {
      CmnLib.isDarkMode = q.matches, D.setVal_Nochk("tmp", "const.sn.isDarkMode", CmnLib.isDarkMode);
    }, H = globalThis.matchMedia("(prefers-color-scheme: dark)");
    U(H), z(this, Je).add(H, "change", (q) => {
      U(q), this.fire("sn:chgDarkMode", q);
    }), "WheelEvent" in window && (z(this, Je).add(Main.cvs, "wheel", (q) => lt(this, _l, yf).call(this, q), { passive: !0 }), at(this, vl, (q) => z(this, Je).add(q, "wheel", (K) => lt(this, _l, yf).call(this, K), { passive: !0 })), at(this, Tl, (q, K) => q.add(Main.cvs, "wheel", (Z) => {
      Z.isComposing || Z.deltaY <= 0 || (Z.stopPropagation(), K());
    }))), CmnLib.debugLog && (z(this, Wi).on("gamepad:connected", (q) => console.log(`👺<'gamepad:connected' index:${q.detail.index} id:${q.detail.gamepad.id}`)), z(this, Wi).on("gamepad:disconnected", (q) => console.log(`👺<'gamepad:disconnected' index:${q.detail.index} id:${q.detail.gamepad.id}`)));
    const V = [
      "",
      "ArrowUp",
      "",
      // '7', '8', '9',
      "ArrowLeft",
      "",
      "ArrowRight",
      // '4', '5', '6',
      "",
      "ArrowDown",
      ""
      // '1', '2', '3',
    ], X = [0, 0];
    z(this, Wi).on("gamepad:axis", (q) => {
      if (!document.hasFocus() || q.detail.stick !== 0)
        return;
      X[q.detail.axis] = q.detail.value;
      const K = (X[1] + 1) * 3 + (X[0] + 1), Z = V[K];
      if (!Z)
        return;
      const J = z(this, ke).getFocus();
      (!J || J instanceof Container ? globalThis : J).dispatchEvent(new KeyboardEvent("keydown", { key: Z, bubbles: !0 })), !(!J || J instanceof Container) && J.getAttribute("type") === "range" && J.dispatchEvent(new InputEvent("input", { bubbles: !0 }));
    }), z(this, Wi).on("gamepad:button", (q) => {
      if (!(!document.hasFocus() || q.detail.value === 0))
        if (q.detail.button % 2 === 0) {
          const K = z(this, ke).getFocus();
          (!K || K instanceof Container ? globalThis : K).dispatchEvent(new KeyboardEvent("keydown", { key: "Enter", bubbles: !0 }));
        } else
          Main.cvs.dispatchEvent(new Event("contextmenu"));
    }), z(this, Wi).start(), z(this, Je).add(window, "keyup", (q) => {
      q.isComposing || q.key in z(this, Ye) && (z(this, Ye)[q.key] = 0);
    }), D.defTmp("const.sn.key.alternate", () => z(this, Ye).Alt > 0), D.defTmp("const.sn.key.command", () => z(this, Ye).Meta > 0), D.defTmp("const.sn.key.control", () => z(this, Ye).Control > 0), D.defTmp("const.sn.key.end", () => z(this, Ye).End > 0), D.defTmp("const.sn.key.escape", () => z(this, Ye).Escape > 0), D.defTmp("const.sn.key.back", () => z(this, Ye).GoBack > 0);
  }
  resvFlameEvent(t) {
    z(this, Je).add(t, "keydown", (e) => lt(this, gl, mf).call(this, e)), z(this, Je).add(t, "contextmenu", (e) => lt(this, ml, _f).call(this, e)), z(this, vl).call(this, t);
  }
  destroy() {
    z(this, ke).destroy(), z(this, Je).clear();
  }
  fire(t, e) {
    var T;
    if (z(this, br).call(this) || !z(this, yi) || z(this, _i))
      return;
    const r = t.toLowerCase();
    if (CmnLib.debugLog && console.log(`👺 fire<(key:\`${r}\` type:${e.type} e:%o)`, { ...e }), r === "enter") {
      const D = z(this, ke).getFocus();
      if (D instanceof Container) {
        D.emit("pointerdown", new Event("pointerdown"));
        return;
      }
    }
    const S = z(this, bl).call(this, r);
    if (!S) {
      r.slice(0, 5) === "swipe" && globalThis.scrollBy(
        -e.deltaX,
        -e.deltaY
      );
      return;
    }
    r.slice(-5) !== "wheel" && ((T = e.preventDefault) == null || T.call(e)), e.stopPropagation(), !(r.slice(0, 4) !== "dom=" && this.layMng.clickTxtLay()) && (at(this, yi, !1), S(e));
  }
  popLocalEvts() {
    const t = z(this, Pe);
    return at(this, Pe, {}), t;
  }
  pushLocalEvts(t) {
    at(this, Pe, t);
  }
  waitEvent(t, e = !0, r = !1) {
    if (e && r)
      throw "canskipとglobalを同時にtrue指定できません";
    if (this.val.getVal("tmp:sn.skip.enabled")) {
      if (this.val.getVal("tmp:sn.skip.all") || this.scrItr.isNextKidoku)
        return t(), !1;
      z(this, br).call(this);
    }
    return lt(this, qi, Ss).call(this, t, e, r);
  }
  unButton(t) {
    z(this, ke).remove(t);
  }
  button(t, e, r, S, T) {
    var H;
    !t.fn && !t.label && this.main.errScript("fnまたはlabelは必須です"), e.interactive = e.buttonMode = !0;
    const D = ((H = t.key) == null ? void 0 : H.toLowerCase()) ?? " ";
    t.fn || (t.fn = this.scrItr.scriptFn);
    const N = argChk_Boolean(t, "global", !1);
    N ? z(this, yr)[D] = () => this.main.resumeByJumpOrCall(t) : z(this, Pe)[D] = () => this.main.resumeByJumpOrCall(t), e.on("pointerdown", (V) => this.fire(D, V));
    const B = t.hint ? () => lt(this, Zh, Qd).call(this, t, e) : () => {
    }, $ = () => {
      r(), z(this, Ue).hidden = !0;
    }, U = () => (B(), S());
    if (e.on("pointerover", U), e.on("pointerout", () => {
      z(this, ke).isFocus(e) ? U() : $();
    }), e.on("pointerdown", () => {
      z(this, Ue).hidden = !0;
      const V = z(this, ke).getFocus();
      T(), V instanceof Button && V.normal();
    }), e.on(
      "pointerup",
      CmnLib.isMobile ? $ : () => {
        z(this, ke).isFocus(e) ? U() : $();
      }
    ), z(this, ke).add(e, U, $), t.clickse && (this.cfg.searchPath(t.clickse, SEARCH_PATH_ARG_EXT.SOUND), e.on("pointerdown", () => {
      const V = { fn: t.clickse, join: !1 };
      t.clicksebuf && (V.buf = t.clicksebuf), this.hTag.playse(V);
    })), t.enterse && (this.cfg.searchPath(t.enterse, SEARCH_PATH_ARG_EXT.SOUND), e.on("pointerover", () => {
      const V = { fn: t.enterse, join: !1 };
      t.entersebuf && (V.buf = t.entersebuf), this.hTag.playse(V);
    })), t.leavese && (this.cfg.searchPath(t.leavese, SEARCH_PATH_ARG_EXT.SOUND), e.on("pointerout", () => {
      const V = { fn: t.leavese, join: !1 };
      t.leavesebuf && (V.buf = t.leavesebuf), this.hTag.playse(V);
    })), t.onenter) {
      const V = D + t.onenter.toLowerCase(), X = { fn: t.fn, label: t.onenter, call: !0, key: V };
      N ? z(this, yr)[V] = () => this.main.resumeByJumpOrCall(X) : z(this, Pe)[V] = () => this.main.resumeByJumpOrCall(X), e.on("pointerover", (W) => this.fire(V, W));
    }
    if (t.onleave) {
      const V = D + t.onleave.toLowerCase(), X = { fn: t.fn, label: t.onleave, call: !0, key: V };
      N ? z(this, yr)[V] = () => this.main.resumeByJumpOrCall(X) : z(this, Pe)[V] = () => this.main.resumeByJumpOrCall(X), e.on("pointerout", (W) => this.fire(V, W));
    }
  }
  hideHint() {
    z(this, Ue).hidden = !0;
  }
  cvsResize() {
    z(this, Ue).hidden = !0;
  }
  // 予約イベントの発生待ちしない waitEvent()
  waitLimitedEvent(t, e) {
    z(this, Wn).call(this), this.val.saveKidoku();
    const r = () => {
      z(this, Xn).clear(), e();
    };
    if (this.val.getVal("tmp:sn.skip.enabled"))
      if (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
      !this.scrItr.isNextKidoku)
        z(this, br).call(this);
      else
        return r(), !1;
    return argChk_Boolean(t, "canskip", !0) && (z(this, Xn).add(window, "pointerdown", (S) => {
      S.stopPropagation(), r();
    }), z(this, Xn).add(window, "keydown", (S) => {
      S.isComposing || (S.stopPropagation(), r());
    }), z(this, Tl).call(this, z(this, Xn), r)), !0;
  }
  noticeCompTxt() {
    z(this, qn).emit(z(this, Kn));
  }
  // キー押下によるスキップ中か
  isSkippingByKeyDown() {
    return this.scrItr.skip4page ? !0 : Object.keys(z(this, Ye)).some((t) => z(this, Ye)[t] === 2);
  }
}
Je = new WeakMap(), Wi = new WeakMap(), ke = new WeakMap(), vl = new WeakMap(), gl = new WeakSet(), mf = function(t) {
  if (t.isComposing)
    return;
  t.key in z(this, Ye) && (z(this, Ye)[t.key] = t.repeat ? 2 : 1);
  const e = (t.altKey ? t.key === "Alt" ? "" : "alt+" : "") + (t.ctrlKey ? t.key === "Control" ? "" : "ctrl+" : "") + (t.shiftKey ? t.key === "Shift" ? "" : "shift+" : "") + t.key;
  this.fire(e, t);
}, ml = new WeakSet(), _f = function(t) {
  const e = (t.altKey ? t.key === "Alt" ? "" : "alt+" : "") + (t.ctrlKey ? t.key === "Control" ? "" : "ctrl+" : "") + (t.shiftKey ? t.key === "Shift" ? "" : "shift+" : "") + "rightclick";
  this.fire(e, t), t.preventDefault();
}, _l = new WeakSet(), yf = function(t) {
  if (t.isComposing)
    return;
  if (z(this, ba)) {
    at(this, xa, !0);
    return;
  }
  at(this, ba, !0), lt(this, yl, bf).call(this);
  const e = (t.altKey ? "alt+" : "") + (t.ctrlKey ? "ctrl+" : "") + (t.shiftKey ? "shift+" : "") + (t.deltaY > 0 ? "downwheel" : "upwheel");
  this.fire(e, t);
}, ba = new WeakMap(), xa = new WeakMap(), yl = new WeakSet(), bf = function() {
  setTimeout(() => {
    if (z(this, xa)) {
      at(this, xa, !1), lt(this, yl, bf).call(this);
      return;
    }
    at(this, ba, !1);
  }, 250);
}, Pe = new WeakMap(), yr = new WeakMap(), _i = new WeakMap(), yi = new WeakMap(), bl = new WeakMap(), qi = new WeakSet(), Ss = function(t, e = !0, r = !0) {
  if (z(this, Wn).call(this), this.val.saveKidoku(), e ? z(this, Pe).click = //this.hTag.event({key:'enter', breakout: fnc});
  //hTag.event({key:'down', breakout: fnc});
  //	hTag.event()は内部で使わず、こうする
  z(this, Pe).enter = z(this, Pe).arrowdown = // hTag.event({key:'downwheel', breakout: fnc});
  //	hTag.event()は内部で使わず、こうする
  z(this, Pe)["wheel.y>0"] = t : (delete z(this, Pe).click, delete z(this, Pe).enter, delete z(this, Pe).arrowdown, delete z(this, Pe)["wheel.y>0"]), at(this, bl, r ? (S) => z(this, Pe)[S] ?? z(this, yr)[S] : (S) => z(this, Pe)[S]), at(this, yi, !0), z(this, xl).call(this), CmnLib.debugLog) {
    const S = /* @__PURE__ */ Object.create(null);
    S.local = Object.keys(z(this, Pe)), S.global = Object.keys(z(this, yr)), console.log("🎍 wait event... %o", S);
  }
  return !0;
}, xl = new WeakMap(), Sl = new WeakMap(), Ue = new WeakMap(), Sa = new WeakMap(), Ea = new WeakMap(), El = new WeakMap(), Zh = new WeakSet(), Qd = function(t, e) {
  const r = e instanceof Button ? e.getBtnBounds() : e.getBounds();
  if (!(t[":タグ名"] === "link")) {
    const T = e.parent.parent;
    r.x += T.x, r.y += T.y;
  }
  if (!t.hint) {
    z(this, Ue).hidden = !0;
    return;
  }
  z(this, Ue).style.cssText = `position:${z(this, Ue).style.position}; transform:${z(this, Ue).style.transform};` + (t.hint_style ?? ""), z(this, Sa).style.cssText = "", z(this, Sa).textContent = t.hint ?? "";
  try {
    const T = t.hint_opt ? { ...z(this, El), ...JSON.parse(t.hint_opt) } : z(this, El);
    z(this, Ea).setOptions(T);
  } catch (T) {
    console.error(mesErrJSON(t, "hint_opt", T.message));
  }
  z(this, Sl).getBoundingClientRect = () => DOMRect.fromRect({
    x: this.sys.ofsLeft4elm + r.x * this.sys.cvsScale,
    y: this.sys.ofsTop4elm + r.y * this.sys.cvsScale,
    width: r.width,
    height: r.height
  }), z(this, Ea).update(), z(this, Ue).hidden = !1;
}, Tl = new WeakMap(), Xn = new WeakMap(), Jh = new WeakSet(), tp = function(t) {
  const e = argChk_Boolean(t, "global", !1), r = e ? z(this, yr) : z(this, Pe);
  for (const [S, T] of Object.entries(r))
    lt(this, wl, xf).call(this, S, T);
  return e ? at(this, yr, {}) : at(this, Pe, {}), at(this, yi, !1), !1;
}, wl = new WeakSet(), xf = function(t, e) {
  t.slice(0, 4) === "dom=" && lt(this, Yn, Wa).call(this, t).el.forEach((r) => r.removeEventListener("click", e));
}, Qh = new WeakSet(), ep = function(t) {
  const e = t.key;
  if (!e)
    throw "keyは必須です";
  const r = e.toLowerCase(), S = argChk_Boolean(t, "call", !1), T = argChk_Boolean(t, "global", !1) ? z(this, yr) : z(this, Pe);
  if (argChk_Boolean(t, "del", !1)) {
    if (t.fn || t.label || S)
      throw "fn/label/callとdelは同時指定できません";
    return lt(this, wl, xf).call(this, e, T[r]), delete T[r], !1;
  }
  if (t.fn ?? (t.fn = this.scrItr.scriptFn), e.slice(0, 4) === "dom=") {
    const D = lt(this, Yn, Wa).call(this, e);
    if (D.el.length === 0) {
      if (argChk_Boolean(t, "need_err", !0))
        throw `HTML内にセレクタ（${D.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;
      return !1;
    }
    let N = ["click", "keydown"];
    switch (D.el[0].type ?? "") {
      case "checkbox":
        N = ["input"];
        break;
      case "range":
        N = ["input"];
        break;
      case "text":
      case "textarea":
        N = ["input", "change"];
        break;
    }
    N.forEach(($, U) => D.el.forEach((H) => {
      z(this, Je).add(H, $, (V) => {
        if (!z(this, yi) || this.layMng.getFrmDisabled(D.id) || $ === "keydown" && V.key !== "Enter")
          return;
        const X = H.dataset;
        for (const [W, Y] of Object.entries(X))
          this.val.setVal_Nochk("tmp", `sn.event.domdata.${W}`, Y);
        this.fire(e, V);
      }), U === 0 && z(this, ke).add(
        H,
        () => lt(this, Cl, Sf).call(this, H) ? (H.focus(), !0) : !1,
        () => {
        }
      );
    }));
  }
  return T[r] = () => this.main.resumeByJumpOrCall(t), !1;
}, Cl = new WeakSet(), Sf = function(t) {
  if (t.offsetParent === null)
    return !1;
  let e = t;
  do {
    if (getComputedStyle(e).display === "none" || e.dataset.focus === "false" || e != null && e.disabled)
      return !1;
    e = e.parentElement;
  } while (e !== null);
  return !0;
}, Yn = new WeakSet(), Wa = function(t) {
  const e = t.indexOf(":");
  let r = "";
  if (e >= 0) {
    const S = t.slice(4, e), T = `const.sn.frm.${S}`;
    if (!this.val.getVal(`tmp:${T}`, 0))
      throw `HTML【${S}】が読み込まれていません`;
    const N = document.getElementById(S).contentWindow;
    return r = t.slice(e + 1), { el: N.document.querySelectorAll(r), id: S, sel: r };
  }
  return r = t.slice(4), { el: document.querySelectorAll(r), id: "", sel: r };
}, Wn = new WeakMap(), tc = new WeakSet(), rp = function(t) {
  if (this.scrItr.skip4page)
    return !1;
  if (!this.val.getVal("tmp:sn.tagL.enabled"))
    return z(this, Wn).call(this), !1;
  if (this.val.getVal("tmp:sn.skip.enabled")) {
    if (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
    !this.scrItr.isNextKidoku)
      z(this, br).call(this);
    else if ("ps".includes(this.val.getVal("sys:sn.skip.mode")))
      return !1;
  }
  return this.val.getVal("tmp:sn.auto.enabled") ? lt(this, Ta, gu).call(this, {
    time: Number(this.scrItr.isKidoku ? this.val.getVal("sys:sn.auto.msecLineWait_Kidoku") : this.val.getVal("sys:sn.auto.msecLineWait"))
  }) : (argChk_Boolean(t, "visible", !0) && this.layMng.breakLine(), lt(this, qi, Ss).call(this, () => this.main.resume()));
}, ec = new WeakSet(), ip = function(t) {
  if (this.scrItr.recodePage(), this.val.getVal("tmp:sn.skip.enabled")) {
    if (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
    !this.scrItr.isNextKidoku)
      z(this, br).call(this);
    else if (this.val.getVal("sys:sn.skip.mode") == "s")
      return z(this, Wn).call(this), !1;
  }
  if (this.val.getVal("tmp:sn.auto.enabled"))
    return lt(this, Ta, gu).call(this, {
      time: Number(this.scrItr.isKidoku ? this.val.getVal("sys:sn.auto.msecPageWait_Kidoku") : this.val.getVal("sys:sn.auto.msecPageWait"))
    });
  argChk_Boolean(t, "visible", !0) && this.layMng.breakPage();
  const e = () => {
    this.sndMng.clearCache(), this.main.resume();
  };
  return lt(this, qi, Ss).call(this, argChk_Boolean(t, "er", !1) && this.layMng.currentTxtlayFore ? () => {
    this.hTag.er(t), e();
  } : e);
}, br = new WeakMap(), rc = new WeakSet(), np = function() {
  return at(this, br, () => (at(this, br, () => !1), this.val.setVal_Nochk("tmp", "sn.tagL.enabled", !0), this.val.setVal_Nochk("tmp", "sn.skip.enabled", !1), this.val.setVal_Nochk("tmp", "sn.auto.enabled", !1), this.layMng.setNormalChWait(), z(this, bi).call(this), !0)), !1;
}, ic = new WeakSet(), sp = function(t) {
  const { add: e, del: r, to: S } = t;
  if ((e == null ? void 0 : e.slice(0, 4)) === "dom=") {
    const T = lt(this, Yn, Wa).call(this, e);
    if (T.el.length === 0 && argChk_Boolean(t, "need_err", !0))
      throw `HTML内にセレクタ（${T.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;
    return T.el.forEach((D) => z(this, ke).add(
      D,
      () => lt(this, Cl, Sf).call(this, D) ? (D.focus(), !0) : !1,
      () => {
      }
    )), !1;
  }
  if ((r == null ? void 0 : r.slice(0, 4)) === "dom=") {
    const T = lt(this, Yn, Wa).call(this, r);
    if (T.el.length === 0 && argChk_Boolean(t, "need_err", !0))
      throw `HTML内にセレクタ（${T.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;
    return T.el.forEach((D) => z(this, ke).remove(D)), !1;
  }
  if (!S)
    throw "[set_focus] add か to は必須です";
  switch (S) {
    case "null":
      z(this, ke).blur();
      break;
    case "next":
      z(this, ke).next();
      break;
    case "prev":
      z(this, ke).prev();
      break;
  }
  return !1;
}, Ta = new WeakSet(), gu = function(t) {
  const e = argChk_Num(t, "time", NaN);
  return this.scrItr.skip4page ? !1 : this.val.getVal("tmp:sn.skip.enabled") ? (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
  !this.scrItr.isNextKidoku && z(this, br).call(this), !1) : (z(this, qn).once(z(this, Kn), () => {
    z(this, qn).off(z(this, Kn));
    const r = new Tween({}).to({}, e).onComplete(() => {
      at(this, bi, () => {
      }), r.stop(), this.main.resume();
    }).start();
    at(this, bi, () => r.end());
  }), at(this, bi, () => {
    at(this, bi, () => {
    }), z(this, qn).off(z(this, Kn));
  }), this.waitEvent(
    () => z(this, bi).call(this),
    argChk_Boolean(t, "canskip", !0),
    // スキップ中は利かない
    argChk_Boolean(t, "global", !1)
  ));
}, bi = new WeakMap(), qn = new WeakMap(), Kn = new WeakMap(), nc = new WeakSet(), ap = function() {
  return this.scrItr.skip4page ? !1 : ((this.val.getVal("tmp:sn.skip.enabled") || this.val.getVal("tmp:sn.auto.enabled")) && z(this, br).call(this), lt(this, qi, Ss).call(this, () => this.main.resume()));
}, Ye = new WeakMap();
class CallStack {
  constructor(t = "", e = 0, r = { ":hEvt1Time": {}, ":hMp": {} }) {
    Pt(this, "toString", () => `[fn:${this.fn}, idx:${this.idx}, csArg:${this.csArg}]`);
    this.fn = t, this.idx = e, this.csArg = r;
  }
}
var ae, oe, Vt, be, ge, xi, Pl, Ef, Zn, wa, sc, Ki, Rl, Tf, Ml, wf, Ol, Zi, Es, Jn, qa, Qn, Si, Re, ac, op, ts, Ka, oc, lp, Il, Ca, cr, lc, up, uc, hp, Ei, nn, hc, cp, es, rs, Dl, Al, Nl, fr, cc, fp, fc, dp, dc, pp, Ll, Cf, pc, vp, vc, gp, gc, mp, kl, Pf, Bl, is, Za, ns, Ti, sn, Fl, Rf, $l, Gl, Mf, mc, yc, Ul, bc, _p, Qe, xc, yp, jl, Of, Sc, Ec, Tc, bp, wc, xp, wi, zl, If, Cc, Sp, Pc, Ep, Rc, Mc, Tp, Hl, Pa, Oc, wp, Ra, mu, Ma, Ic, Cp, Ar, Dc, Pp, Oa, _u, Ac, Rp, Nr, $e;
const ir = class {
  constructor(t, e, r, S, T, D, N, B, $) {
    tt(this, Pl);
    tt(this, Rl);
    tt(this, Ml);
    tt(this, Zi);
    tt(this, Jn);
    tt(this, ac);
    tt(this, ts);
    tt(this, oc);
    //	//	変数操作
    // インラインテキスト代入
    tt(this, lc);
    //	// デバッグ・その他
    // スタックのダンプ
    tt(this, uc);
    tt(this, Ei);
    // 外部へスクリプトを表示
    tt(this, hc);
    // FIFOバッファ（push/unshift）
    tt(this, cc);
    tt(this, fc);
    //	// ラベル・ジャンプ
    // サブルーチンコール
    tt(this, dc);
    tt(this, Ll);
    // シナリオジャンプ
    tt(this, pc);
    // ページ移動
    tt(this, vc);
    // コールスタック破棄
    tt(this, gc);
    // サブルーチンから戻る
    tt(this, kl);
    tt(this, is);
    tt(this, Ti);
    // 初期化前に終了した場合向け
    tt(this, Fl);
    tt(this, Gl);
    tt(this, bc);
    //{} シナリオキャッシュ
    tt(this, xc);
    tt(this, jl);
    tt(this, Tc);
    tt(this, wc);
    tt(this, zl);
    //	// マクロ
    // 括弧マクロの定義
    tt(this, Cc);
    // 一文字マクロの定義
    tt(this, Pc);
    tt(this, Mc);
    // https://regex101.com/r/Lk9ASK/1
    //	// しおり
    // しおりの読込
    tt(this, Oc);
    tt(this, Ra);
    // スクリプト再読込
    tt(this, Ic);
    tt(this, Dc);
    tt(this, Oa);
    // しおりの保存
    tt(this, Ac);
    tt(this, ae, { aToken: [""], len: 1, aLNum: [1] });
    tt(this, oe, "");
    tt(this, Vt, 0);
    tt(this, be, 0);
    Pt(this, "addLineNum", (t) => at(this, be, z(this, be) + t));
    tt(this, ge, []);
    // FILOバッファ（push/pop）
    tt(this, xi, new Grammar());
    Pt(this, "firstWait", () => {
    });
    tt(this, Zn, {
      //auth: // constructorで
      //launch:	// ここでは冒頭停止に間に合わないのでanalyzeInit()で
      disconnect: () => {
        at(ir, Qn, {}), at(ir, Si, {}), this.isBreak = () => !1, z(this, Zn).continue({}), at(this, Re, 0);
      },
      restart: () => this.isBreak = () => !1,
      // ブレークポイント登録
      add_break: (t) => lt(this, Pl, Ef).call(this, t.fn, t.o),
      data_break: (t) => {
        z(this, Re) === 0 && (at(this, Re, 1), this.main.setLoop(!1, `変数 ${t.dataId}【${t.old_v}】→【${t.new_v}】データブレーク`), this.sys.callHook("stopOnDataBreakpoint", {}), this.sys.send2Dbg("stopOnDataBreakpoint", {}));
      },
      set_func_break: (t) => {
        at(ir, Si, {});
        for (const e of t.a)
          z(ir, Si)[e.name] = 1;
        this.sys.send2Dbg(t.ri, {});
      },
      // 情報問い合わせ系
      stack: (t) => this.sys.send2Dbg(t.ri, { a: lt(this, oc, lp).call(this) }),
      eval: (t) => {
        this.sys.send2Dbg(t.ri, { v: this.prpPrs.parse(t.txt) });
      },
      // デバッガからの操作系
      continue: () => {
        lt(this, Jn, qa).call(this) || (at(this, Vt, z(this, Vt) - z(this, Zi, Es)), at(this, Re, 3), this.main.setLoop(!0), this.main.resume());
      },
      stepover: (t) => lt(this, Rl, Tf).call(this, t),
      stepin: () => {
        if (lt(this, Jn, qa).call(this))
          return;
        const t = z(this, ae).aToken[z(this, Vt) - z(this, Zi, Es)];
        this.sys.callHook(`stopOnStep${z(this, Pa).test(t) ? "In" : ""}`, {}), at(this, Vt, z(this, Vt) - z(this, Zi, Es)), at(this, Re, z(this, Re) === 1 ? 4 : 5), this.main.setLoop(!0), this.main.resume();
      },
      stepout: (t) => {
        lt(this, Jn, qa).call(this) || (z(this, ge).length > 0 ? lt(this, Ml, wf).call(this, !0) : lt(this, Rl, Tf).call(this, t));
      },
      pause: () => {
        at(this, Re, 4), this.main.setLoop(!1, "一時停止"), this.sys.send2Dbg("stopOnStep", {});
      },
      stopOnEntry: () => {
        at(this, Re, 4), this.main.setLoop(!1, "一時停止"), this.sys.send2Dbg("stopOnEntry", {});
      }
    });
    tt(this, wa, (t) => this.cfg.searchPath(t, SEARCH_PATH_ARG_EXT.SCRIPT));
    // https://regex101.com/r/Km54EK/1 141 steps (~0ms)
    tt(this, Ki, (t) => (this.sys.pathBaseCnvSnPath4Dbg + z(this, wa).call(this, t)).replace(z(ir, sc), `$1/prj/$2/${z(this, oe)}$3`));
    Pt(this, "cnvPath4Dbg", (t) => this.sys.pathBaseCnvSnPath4Dbg + t.replace("/crypto_prj/", "/prj/"));
    tt(this, Ol, 0);
    tt(this, Re, 0);
    // https://raw.githubusercontent.com/famibee/SKYNovel-vscode-extension/master/src/doc/BreakStateSMD.pu
    Pt(this, "isBreak", (t) => !1);
    // result = true : waitする  resume()で再開
    tt(this, Il, (t) => {
    });
    tt(this, Ca, void 0);
    tt(this, cr, void 0);
    tt(this, es, () => {
    });
    tt(this, rs, () => {
    });
    tt(this, Dl, "");
    tt(this, Al, {});
    Pt(this, "noticeBreak", (t) => {
    });
    tt(this, Nl, 5);
    //	// 条件分岐
    tt(this, fr, [-1]);
    tt(this, Bl, "");
    tt(this, ns, "");
    // シナリオ解析処理ループ・冒頭処理
    Pt(this, "nextToken", () => "");
    tt(this, $l, (t) => {
    });
    tt(this, mc, /(\*{2,})([^\|]*)/);
    tt(this, yc, /\[macro\s/);
    tt(this, Ul, /\[endmacro[\s\]]/);
    tt(this, Qe, /* @__PURE__ */ Object.create(null));
    tt(this, Sc, /^\[(call|loadplugin)\s/);
    tt(this, Ec, /\bfn\s*=\s*[^\s\]]+/);
    tt(this, wi, !1);
    // マクロ定義の開始
    tt(this, Rc, new RegExp(`["'#;\\]　]+`));
    tt(this, Hl, "call");
    tt(this, Pa, /\[(call)\b/);
    tt(this, Ma, !1);
    // セーブポイント指定
    tt(this, Ar, {
      hSave: {},
      hPages: {},
      aIfStk: [-1]
    });
    tt(this, Nr, []);
    tt(this, $e, -1);
    this.cfg = t, this.hTag = e, this.main = r, this.val = S, this.alzTagArg = T, this.runAnalyze = D, this.prpPrs = N, this.sndMng = B, this.sys = $, e.let_ml = (H) => lt(this, lc, up).call(this, H), e.dump_stack = () => lt(this, uc, hp).call(this), e.dump_script = (H) => lt(this, hc, cp).call(this, H), e.else = // その他ifブロック開始
    e.elsif = // 別条件のifブロック開始
    e.endif = () => lt(this, cc, fp).call(this), e.if = (H) => lt(this, fc, dp).call(this, H), e.call = (H) => lt(this, dc, pp).call(this, H), e.jump = (H) => lt(this, pc, vp).call(this, H), e.page = (H) => lt(this, vc, gp).call(this, H), e.pop_stack = (H) => lt(this, gc, mp).call(this, H), e.return = (H) => lt(this, kl, Pf).call(this, H), e.bracket2macro = (H) => lt(this, Cc, Sp).call(this, H), e.char2macro = (H) => lt(this, Pc, Ep).call(this, H), e.endmacro = (H) => lt(this, kl, Pf).call(this, H), e.macro = (H) => lt(this, Mc, Tp).call(this, H), e.load = (H) => lt(this, Oc, wp).call(this, H), e.reload_script = (H) => lt(this, Ic, Cp).call(this, H), e.record_place = () => lt(this, Dc, Pp).call(this), e.save = (H) => lt(this, Ac, Rp).call(this, H), t.oCfg.debug.token && at(this, $l, (H) => console.log(`🌱 トークン fn:${z(this, oe)} idx:${z(this, Vt)} ln:${z(this, be)} token【${H}】`)), S.defTmp("const.sn.vctCallStk.length", () => z(this, ge).length);
    const U = t.oCfg.init.escape;
    if (z(this, xi).setEscape(U), RubySpliter.setEscape(U), CmnLib.isDbg) {
      $.addHook((V, X) => {
        var W, Y;
        return (Y = (W = z(this, Zn))[V]) == null ? void 0 : Y.call(W, X);
      }), this.isBreak = lt(this, ac, op);
      const H = this.analyzeInit;
      this.analyzeInit = () => {
        this.analyzeInit = () => {
        }, this.sys.send2Dbg("hi", {});
      }, z(this, Zn).auth = (V) => {
        const X = V.hBreakpoint.hFn2hLineBP;
        for (const [W, Y] of Object.entries(X))
          lt(this, Pl, Ef).call(this, W, Y);
        at(ir, Si, {});
        for (const W of V.hBreakpoint.aFunc)
          z(ir, Si)[W.name] = 1;
        if (V.stopOnEntry) {
          for (; ; ) {
            let W = this.nextToken();
            if (!W)
              break;
            const Y = W.charCodeAt(0);
            if (Y === 91 || Y === 38 || Y === 42 && W.length === 1)
              break;
            Y === 10 && at(this, be, z(this, be) + W.length);
          }
          this.sys.callHook("stopOnEntry", {}), this.analyzeInit = H, this.analyzeInit();
        } else
          this.firstWait = () => {
            this.sys.callHook("stopOnEntry", {});
          }, this.analyzeInit = H, this.analyzeInit();
      };
    } else
      this.recodeDesign = () => {
      };
    t.oCfg.debug.tag && at(this, Il, (H) => console.log(`🌲 タグ解析 fn:${z(this, oe)} idx:${z(this, Vt)} ln:${z(this, be)} [${H} %o]`, this.alzTagArg.hPrm));
  }
  get scriptFn() {
    return z(this, oe);
  }
  subIdxToken() {
    --Oe(this, Vt)._;
  }
  get lineNum() {
    return z(this, be);
  }
  destroy() {
    this.isBreak = () => !1;
  }
  タグ解析(t) {
    const [e, r] = tagToken2Name_Args(t), S = this.hTag[e];
    if (!S)
      throw `未定義のタグ【${e}】です`;
    this.alzTagArg.parse(r), z(this, Il).call(this, e);
    const T = this.alzTagArg.hPrm;
    if (T.cond) {
      const B = T.cond.val;
      if (!B || B.at(0) === "&")
        throw "属性condは「&」が不要です";
      const $ = this.prpPrs.parse(B), U = String($);
      if (U === "null" || U === "undefined" || !$)
        return !1;
    }
    let D = {};
    const N = z(this, ge).length;
    if (this.alzTagArg.isKomeParam) {
      if (N === 0)
        throw "属性「*」はマクロのみ有効です";
      D = { ...z(this, ge)[z(this, ge).length - 1].csArg };
    }
    D[":タグ名"] = e;
    for (const [B, { val: $, def: U }] of Object.entries(T)) {
      let H = $;
      if ((H == null ? void 0 : H.at(0)) === "%") {
        if (N === 0)
          throw "属性「%」はマクロ定義内でのみ使用できます（そのマクロの引数を示す簡略文法であるため）";
        const V = z(this, ge)[z(this, ge).length - 1].csArg[H.slice(1)];
        if (V) {
          D[B] = V;
          continue;
        }
        if (U === void 0 || U === "null")
          continue;
        H = U;
      }
      if (H = this.prpPrs.getValAmpersand(H ?? ""), H !== "undefined") {
        D[B] = H;
        continue;
      }
      U !== void 0 && (H = this.prpPrs.getValAmpersand(U), H !== "undefined" && (D[B] = H));
    }
    return S(D);
  }
  setOtherObj(t, e) {
    at(this, Ca, t), at(this, cr, e);
  }
  dumpErrForeLine() {
    if (z(this, Vt) === 0) {
      console.group(`🥟 Error line (from 0 rows before) fn:${z(this, oe)}`), console.groupEnd();
      return;
    }
    let t = "";
    for (let D = z(this, Vt) - 1; D >= 0 && (t = z(this, ae).aToken[D] + t, !((t.match(/\n/g) ?? []).length >= z(this, Nl))); --D)
      ;
    const e = t.split(`
`).slice(-z(this, Nl)), r = e.length;
    console.group(`🥟 Error line (from ${r} rows before) fn:${z(this, oe)}`);
    const S = String(z(this, be)).length, T = lt(this, Ei, nn).call(this, z(this, ae), z(this, Vt));
    for (let D = 0; D < r; ++D) {
      const N = z(this, be) - r + D + 1, B = `${String(N).padStart(S, " ")}: %c`, $ = e[D], U = $.length > 75 ? $.slice(0, 75) + "…" : $;
      D === r - 1 ? console.info(
        B + U.slice(0, T.col_s) + "%c" + U.slice(T.col_s),
        "color: black; background-color: skyblue;",
        "color: black; background-color: pink;"
      ) : console.info(B + U, "color: black; background-color: skyblue;");
    }
    console.groupEnd();
  }
  analyzeInit() {
    const t = lt(this, bc, _p).call(this, z(this, ae), Boolean(this.val.getVal("mp:const.sn.macro.name")), z(this, be), z(this, ns), z(this, Vt));
    at(this, Vt, t.idx), at(this, be, t.ln), this.runAnalyze();
  }
  get isKidoku() {
    return z(this, wi);
  }
  get isNextKidoku() {
    let t = z(this, oe), e = z(this, Vt), r = z(this, ae).len;
    if (z(this, ge).length > 0) {
      const T = z(this, ge)[0];
      t = T.fn, e = T.idx;
      const D = z(this, Qe)[t];
      D && (r = D.len);
    }
    const S = this.val.getAreaKidoku(t);
    return !S || e === r ? !1 : S.search(e);
  }
  get normalWait() {
    return z(this, wi) ? this.val.getVal("sys:sn.tagCh.doWait_Kidoku") ? uint(this.val.getVal("sys:sn.tagCh.msecWait_Kidoku")) : 0 : this.val.getVal("sys:sn.tagCh.doWait") ? uint(this.val.getVal("sys:sn.tagCh.msecWait")) : 0;
  }
  get skip4page() {
    return z(this, Ma);
  }
  recodePage() {
    if (at(this, Ma, !1), !this.val.getVal("save:sn.doRecLog"))
      return;
    const { fn: t, idx: e } = lt(this, Oa, _u).call(this), r = e - 1, S = r + ":" + t, T = z(this, Nr).findIndex((N) => N.key === S);
    if (T > -1) {
      at(this, $e, T);
      return;
    }
    const D = {
      key: S,
      fn: t,
      idx: r,
      retFn: t,
      retIdx: 0,
      retMark: { ...z(this, Ar) }
    };
    if (z(this, $e) >= 0) {
      const N = z(this, Nr)[z(this, $e)];
      D.retFn = N.fn, D.retIdx = N.idx + 1;
    }
    ++Oe(this, $e)._ === z(this, Nr).length ? z(this, Nr).push(D) : z(this, Nr)[z(this, $e)] = D;
  }
  recodeDesign(t) {
    let e = "", r = 0;
    const S = z(this, ge).length;
    if (t.design_unit && S > 0) {
      const N = z(this, ge)[0];
      e = N.fn, r = N.idx;
    } else
      e = z(this, oe), r = z(this, Vt);
    t[":path"] = z(this, Ki).call(this, e);
    const T = lt(this, Ei, nn).call(this, z(this, Qe)[e], r);
    t[":ln"] = T.ln, t[":col_s"] = T.col_s, t[":col_e"] = T.col_e;
    const D = r - 1;
    t[":idx_tkn"] = D, t[":token"] = z(this, Qe)[e].aToken[D], this.sys.send2Dbg("_recodeDesign", t);
  }
  replace(t, e) {
    z(this, ae).aToken[t] = e;
  }
};
let ScriptIterator = ir;
ae = new WeakMap(), oe = new WeakMap(), Vt = new WeakMap(), be = new WeakMap(), ge = new WeakMap(), xi = new WeakMap(), Pl = new WeakSet(), Ef = function(t, e) {
  z(ir, Qn)[z(this, Ki).call(this, t)] = e;
}, Zn = new WeakMap(), wa = new WeakMap(), sc = new WeakMap(), Ki = new WeakMap(), Rl = new WeakSet(), Tf = function(t) {
  if (lt(this, Jn, qa).call(this))
    return;
  const e = z(this, ae).aToken[z(this, Vt) - z(this, Zi, Es)];
  z(this, Pa).test(e) ? lt(this, Ml, wf).call(this, !1) : (this.sys.callHook("stopOnStep", {}), z(this, Zn).stepin(t));
}, Ml = new WeakSet(), wf = function(t) {
  this.sys.callHook(`stopOnStep${t ? "Out" : ""}`, {}), at(this, Ol, z(this, ge).length - (t ? 1 : 0)), at(this, Vt, z(this, Vt) - z(this, Zi, Es)), at(this, Re, t ? 7 : 6), this.main.setLoop(!0), this.main.resume();
}, Ol = new WeakMap(), Zi = new WeakSet(), Es = function() {
  return z(this, Re) === 2 || z(this, Re) === 4 ? 1 : 0;
}, Jn = new WeakSet(), qa = function() {
  return z(this, Vt) < z(this, ae).len ? !1 : (this.sys.callHook("stopOnEntry", {}), this.main.setLoop(!1, "スクリプト終端です"), !0);
}, Qn = new WeakMap(), Si = new WeakMap(), Re = new WeakMap(), ac = new WeakSet(), op = function(t) {
  switch (z(this, Re)) {
    case 6:
      lt(this, ts, Ka).call(this), at(this, Re, 7);
      break;
    case 7:
      if (z(this, ge).length !== z(this, Ol))
        break;
      return at(this, Re, 4), this.main.setLoop(!1, "ステップ実行"), this.sys.send2Dbg("stopOnStep", {}), !0;
    case 5:
      lt(this, ts, Ka).call(this), at(this, Re, 4);
      break;
    case 4:
      return lt(this, ts, Ka).call(this), this.main.setLoop(!1, "ステップ実行"), this.sys.send2Dbg("stopOnStep", {}), !0;
    case 3:
      lt(this, ts, Ka).call(this), at(this, Re, 0);
      break;
    default:
      if (tagToken2Name(t) in z(ir, Si))
        return at(this, Re, 2), this.main.setLoop(!1, `関数 ${t} ブレーク`), this.sys.callHook("stopOnBreakpoint", {}), this.sys.send2Dbg("stopOnBreakpoint", {}), !0;
      {
        const e = z(ir, Qn)[z(this, Ki).call(this, z(this, oe))];
        if (!e)
          break;
        const r = e[z(this, be)];
        if (!r)
          break;
        if (r.condition) {
          if (!this.prpPrs.parse(r.condition))
            break;
        } else if ("hitCondition" in r && --r.hitCondition > 0)
          break;
        const S = z(this, Re) === 0;
        at(this, Re, 2), this.main.setLoop(!1, S ? (r.condition ? "条件" : "ヒットカウント") + "ブレーク" : "ステップ実行");
        const T = S ? "stopOnBreakpoint" : "stopOnStep";
        this.sys.callHook(T, {}), this.sys.send2Dbg(T, {});
      }
      return !0;
  }
  return !1;
}, ts = new WeakSet(), Ka = function() {
  var e;
  const t = (e = z(ir, Qn)[getFn(z(this, oe))]) == null ? void 0 : e[z(this, be)];
  t != null && t.hitCondition && --t.hitCondition;
}, oc = new WeakSet(), lp = function() {
  const t = z(this, Re) === 3 ? 1 : 0, e = z(this, ae).aToken[z(this, Vt) - 1 + t], r = z(this, Ki).call(this, z(this, oe)), S = tagToken2Name(e), T = S ? `[${S}]` : e, D = this.val.getVal("mp:const.sn.macro") ?? "{}";
  if (z(this, Vt) === 0)
    return [{ fn: r, ln: 1, col: 1, nm: T, ma: D }];
  const N = lt(this, Ei, nn).call(this, z(this, ae), z(this, Vt)), B = [{ fn: r, ln: N.ln, col: N.col_s + 1, nm: T, ma: D }], $ = z(this, ge).length;
  if ($ === 0)
    return B;
  for (let U = $ - 1; U >= 0; --U) {
    const H = z(this, ge)[U], V = z(this, Qe)[H.fn], X = V.aToken[H.idx - 1], W = lt(this, Ei, nn).call(this, V, H.idx), Y = tagToken2Name(X);
    B.push({
      fn: z(this, Ki).call(this, H.fn),
      ln: W.ln,
      col: W.col_s + 1,
      nm: Y ? `[${Y}]` : X,
      ma: H.csArg[":hMp"]["const.sn.macro"] ?? "{}"
    });
  }
  return B;
}, Il = new WeakMap(), Ca = new WeakMap(), cr = new WeakMap(), lc = new WeakSet(), up = function(t) {
  const { name: e } = t;
  if (!e)
    throw "nameは必須です";
  let r = "";
  const S = z(this, ae).len;
  for (; z(this, Vt) < S && (r = z(this, ae).aToken[z(this, Vt)], r === ""); ++Oe(this, Vt)._)
    ;
  return t.text = r, t.cast = "str", this.hTag.let(t), at(this, Vt, z(this, Vt) + 2), at(this, be, z(this, be) + (r.match(/\n/g) ?? []).length), !1;
}, uc = new WeakSet(), hp = function() {
  if (z(this, Vt) === 0)
    return console.group(`🥟 [dump_stack] スクリプト現在地 fn:${z(this, oe)} line:${1} col:${0}`), console.groupEnd(), !1;
  const t = lt(this, Ei, nn).call(this, z(this, ae), z(this, Vt)), e = `スクリプト現在地 fn:${z(this, oe)} line:${t.ln} col:${t.col_s + 1}`;
  console.group(`🥟 [dump_stack] ${e}`);
  const r = z(this, ge).length;
  if (r > 0) {
    console.info(e);
    for (let S = r - 1; S >= 0; --S) {
      const T = z(this, ge)[S], D = T.csArg[":hMp"], N = D ? D[":タグ名"] : void 0, B = T.csArg[":タグ名"] ?? "", $ = lt(this, Ei, nn).call(this, z(this, Qe)[T.fn], T.idx);
      console.info(
        `${r - S}つ前のコール元 fn:${T.fn} line:${$.ln} col:${$.col_s + 1}` + (N ? "（[" + N + "]マクロ内）" : " ") + `で [${B} ...]をコール`
      );
    }
  }
  return console.groupEnd(), !1;
}, Ei = new WeakSet(), nn = function(t, e) {
  const r = { ln: 1, col_s: 0, col_e: 0 };
  if (!t)
    return r;
  let S = e - 1;
  const T = r.ln = t.aLNum[S];
  for (; t.aLNum[S] === T; ) {
    if (t.aToken[S].at(0) !== `
`) {
      const D = t.aToken[S].length;
      r.col_e > 0 && (r.col_s += D), r.col_e += D;
    }
    if (--S < 0)
      break;
  }
  return r;
}, hc = new WeakSet(), cp = function(t) {
  const { set_fnc: e, break_fnc: r } = t;
  if (!e)
    throw "set_fncは必須です";
  if (at(this, es, globalThis[e]), !z(this, es)) {
    if (argChk_Boolean(t, "need_err", !0))
      throw `HTML内に関数${e}が見つかりません`;
    return at(this, es, () => {
    }), !1;
  }
  if (this.noticeBreak = (S) => {
    z(this, Dl) !== z(this, oe) && (at(this, Dl, z(this, oe)), z(this, es).call(this, z(this, Al)[z(this, oe)] = z(this, Al)[z(this, oe)] ?? z(this, ae).aToken.join(""))), z(this, rs).call(this, z(this, be), S);
  }, this.noticeBreak(!0), !r)
    return !1;
  if (at(this, rs, globalThis[r]), !z(this, rs)) {
    if (argChk_Boolean(t, "need_err", !0))
      throw `HTML内に関数${r}が見つかりません`;
    at(this, rs, () => {
    });
  }
  return !1;
}, es = new WeakMap(), rs = new WeakMap(), Dl = new WeakMap(), Al = new WeakMap(), Nl = new WeakMap(), fr = new WeakMap(), cc = new WeakSet(), fp = function() {
  if (z(this, fr)[0] === -1)
    throw "ifブロック内ではありません";
  return at(this, Vt, z(this, fr)[0]), z(this, fr).shift(), !1;
}, fc = new WeakSet(), dp = function(t) {
  const { exp: e } = t;
  if (!e)
    throw "expは必須です";
  if (e.at(0) === "&")
    throw "属性expは「&」が不要です";
  let r = 0, S = this.prpPrs.parse(e) ? z(this, Vt) : -1;
  const T = z(this, ae).aLNum[z(this, Vt)];
  let D = z(this, be) - (T || 0);
  const N = z(this, ae).len;
  for (; z(this, Vt) < N; ++Oe(this, Vt)._) {
    const B = z(this, ae).aLNum[z(this, Vt)];
    z(this, ae).aLNum[z(this, Vt)] = (B || 0) + D;
    const $ = z(this, ae).aToken[z(this, Vt)];
    if (!$)
      continue;
    const U = $.charCodeAt(0);
    if (U === 10) {
      at(this, be, z(this, be) + $.length);
      continue;
    }
    if (U !== 91)
      continue;
    const [H, V] = tagToken2Name_Args($);
    if (!(H in this.hTag))
      throw `未定義のタグ[${H}]です`;
    switch (this.alzTagArg.parse(V), H) {
      case "if":
        ++r;
        break;
      case "elsif":
        if (r > 0 || S > -1)
          break;
        const X = this.alzTagArg.hPrm.exp.val;
        if (X.at(0) === "&")
          throw "属性expは「&」が不要です";
        this.prpPrs.parse(X) && (S = z(this, Vt) + 1);
        break;
      case "else":
        if (r > 0)
          break;
        S === -1 && (S = z(this, Vt) + 1);
        break;
      case "endif":
        if (r > 0) {
          --r;
          break;
        }
        return S === -1 ? (++Oe(this, Vt)._, z(this, ae).aLNum[z(this, Vt)] += D) : (z(this, fr).unshift(z(this, Vt) + 1), at(this, Vt, S), at(this, be, z(this, ae).aLNum[z(this, Vt)])), !1;
    }
  }
  throw "[endif]がないままスクリプト終端です";
}, dc = new WeakSet(), pp = function(t) {
  argChk_Boolean(t, "count", !1) || lt(this, zl, If).call(this);
  const { fn: e } = t;
  return e && z(this, wa).call(this, e), lt(this, Ll, Cf).call(this, { ":hEvt1Time": z(this, Ca).popLocalEvts(), ":hMp": this.val.cloneMp() }), argChk_Boolean(t, "clear_local_event", !1) && this.hTag.clear_event({}), lt(this, Ti, sn).call(this, e, t.label), !0;
}, Ll = new WeakSet(), Cf = function(t) {
  z(this, ae).aLNum[z(this, Vt)] = z(this, be), z(this, Bl) || (t[":resvToken"] = "", lt(this, is, Za).call(this)), z(this, ge).push(new CallStack(z(this, oe), z(this, Vt), t)), z(this, fr).unshift(-1);
}, pc = new WeakSet(), vp = function(t) {
  return argChk_Boolean(t, "count", !0) || lt(this, zl, If).call(this), z(this, fr)[0] = -1, lt(this, Ti, sn).call(this, t.fn, t.label), !0;
}, vc = new WeakSet(), gp = function(t) {
  if (z(this, $e) === -1)
    return !1;
  if (argChk_Boolean(t, "clear", !1))
    return at(this, Nr, []), at(this, $e, -1), !1;
  const { to: e } = t;
  if (!e)
    throw "clearかtoは必須です";
  const r = z(this, $e);
  switch (e) {
    case "prev":
      z(this, $e) > 0 && --Oe(this, $e)._;
      break;
    case "next":
      const N = z(this, Nr).length;
      z(this, $e) < N - 1 && ++Oe(this, $e)._;
      break;
    default:
      throw `属性to「${e}」は異常です`;
  }
  if (r === z(this, $e))
    return !1;
  const S = z(this, Nr)[z(this, $e)], { fn: T, idx: D } = lt(this, Oa, _u).call(this);
  return S.key === D + ":" + T ? !1 : lt(this, Ra, mu).call(this, { fn: S.retFn, index: S.retIdx }, S.retMark);
}, gc = new WeakSet(), mp = function(t) {
  if (argChk_Boolean(t, "clear", !1))
    at(this, ge, []);
  else if (!z(this, ge).pop())
    throw "[pop_stack] スタックが空です";
  return lt(this, is, Za).call(this), at(this, fr, [-1]), this.val.setMp({}), !1;
}, kl = new WeakSet(), Pf = function(t) {
  const e = z(this, ge).pop();
  if (!e)
    throw "[return] スタックが空です";
  const r = e.csArg;
  z(this, fr).shift();
  const S = r[":hMp"];
  S && this.val.setMp(S);
  const T = r[":resvToken"];
  T ? this.nextToken = () => (lt(this, is, Za).call(this), T) : lt(this, is, Za).call(this), r[":hEvt1Time"] && z(this, Ca).pushLocalEvts(r[":hEvt1Time"]);
  const { fn: D, label: N } = t;
  return D || N ? (lt(this, Ti, sn).call(this, D, N), !0) : e.fn in z(this, Qe) ? (lt(this, jl, Of).call(this, e), !1) : (lt(this, Ti, sn).call(this, e.fn, "", e.idx), !0);
}, Bl = new WeakMap(), is = new WeakSet(), Za = function() {
  at(this, Bl, ""), this.nextToken = lt(this, Fl, Rf);
}, ns = new WeakMap(), Ti = new WeakSet(), sn = function(t = "", e = "", r = 0) {
  if (!t && !e && this.main.errScript("[jump系] fnまたはlabelは必須です"), e ? (e.at(0) !== "*" && this.main.errScript("[jump系] labelは*で始まります"), at(this, ns, e), z(this, ns).slice(0, 2) !== "**" && at(this, Vt, r)) : (at(this, ns, ""), at(this, Vt, r)), !t) {
    this.analyzeInit();
    return;
  }
  const S = z(this, wa).call(this, t);
  if (t === z(this, oe)) {
    this.analyzeInit();
    return;
  }
  at(this, oe, t);
  const T = z(this, Qe)[z(this, oe)];
  if (T) {
    at(this, ae, T), this.analyzeInit();
    return;
  }
  new Loader().add({ name: z(this, oe), url: S }).use((D, N) => {
    try {
      D.data = this.sys.decStr(D.extension, D.data);
    } catch (B) {
      this.main.errScript(`[jump系]snロード失敗です fn:${D.name} ${B}`, !1);
    }
    N == null || N();
  }).load((D, N) => {
    this.nextToken = lt(this, Fl, Rf), at(this, be, 1), lt(this, xc, yp).call(this, N[t].data), this.hTag.record_place({}), this.main.resume(() => this.analyzeInit());
  }), this.main.stop();
}, Fl = new WeakSet(), Rf = function() {
  var e, r;
  if (lt(this, Gl, Mf).call(this))
    return "";
  lt(this, wc, xp).call(this), (e = z(this, ae).aLNum)[r = z(this, Vt)] || (e[r] = z(this, be));
  const t = z(this, ae).aToken[z(this, Vt)];
  return z(this, $l).call(this, t), ++Oe(this, Vt)._, t;
}, $l = new WeakMap(), Gl = new WeakSet(), Mf = function() {
  return z(this, Vt) < z(this, ae).len ? !1 : (this.main.errScript("スクリプト終端です"), !0);
}, mc = new WeakMap(), yc = new WeakMap(), Ul = new WeakMap(), bc = new WeakSet(), _p = function(t, e, r, S, T) {
  var U, H;
  const D = t.aToken.length;
  if (!S) {
    if (lt(this, Gl, Mf).call(this))
      return { idx: T, ln: r };
    if (t.aLNum[T])
      r = t.aLNum[T];
    else {
      r = 1;
      for (let V = 0; V < T; ++V) {
        (U = t.aLNum)[V] || (U[V] = r);
        const X = t.aToken[V];
        X.charCodeAt(0) === 10 ? r += X.length : r += (X.match(/\n/g) ?? []).length;
      }
      t.aLNum[T] = r;
    }
    return { idx: T, ln: r };
  }
  t.aLNum[0] = 1;
  const N = S.match(z(this, mc));
  if (N) {
    S = N[1];
    let V = T;
    switch (N[2]) {
      case "before":
        for (; t.aToken[--V] !== S; )
          V === 0 && DebugMng.myTrace("[jump系 無名ラベルbefore] " + r + "行目以前で" + (e ? "マクロ内に" : "") + "ラベル【" + S + "】がありません", "ET"), e && t.aToken[V].search(z(this, yc)) > -1 && DebugMng.myTrace("[jump系 無名ラベルbefore] マクロ内にラベル【" + S + "】がありません", "ET");
        return { idx: V + 1, ln: t.aLNum[V] };
      case "after":
        for (; t.aToken[++V] !== S; )
          V === D && DebugMng.myTrace("[jump系 無名ラベルafter] " + r + "行目以後でマクロ内にラベル【" + S + "】がありません", "ET"), t.aToken[V].search(z(this, Ul)) > -1 && DebugMng.myTrace("[jump系 無名ラベルafter] " + r + "行目以後でマクロ内にラベル【" + S + "】がありません", "ET");
        return { idx: V + 1, ln: t.aLNum[V] };
      default:
        DebugMng.myTrace("[jump系] 無名ラベル指定【label=" + S + "】が間違っています", "ET");
    }
  }
  r = 1;
  const B = new RegExp(
    "^" + S.replaceAll("*", "\\*") + "(?=\\s|;|\\[|\\||$)"
  );
  let $ = !1;
  for (let V = 0; V < D; ++V) {
    (H = t.aLNum)[V] || (H[V] = r);
    const X = t.aToken[V];
    if ($) {
      z(this, xi).testTagEndLetml(X) ? $ = !1 : r += (X.match(/\n/g) ?? []).length;
      continue;
    }
    const W = X.charCodeAt(0);
    if (W === 10) {
      r += X.length;
      continue;
    }
    if (W === 42) {
      if (X.search(B) > -1)
        return { idx: V + 1, ln: r };
      continue;
    }
    W === 91 && (r += (X.match(/\n/g) ?? []).length, z(this, xi).testTagLetml(X) && ($ = !0));
  }
  throw $ ? "[let_ml]の終端・[endlet_ml]がありません" : (DebugMng.myTrace(`[jump系] ラベル【${S}】がありません`, "ET"), "Dummy");
}, Qe = new WeakMap(), xc = new WeakSet(), yp = function(t) {
  let e = "";
  try {
    e = "ScriptIterator.resolveScript";
    const r = z(this, xi).resolveScript(t);
    e = "ScriptIterator.replaceScript_Wildcard", lt(this, Tc, bp).call(this, r), z(this, Qe)[z(this, oe)] = at(this, ae, r);
  } catch (r) {
    r instanceof Error ? e += `例外 mes=${r.message}(${r.name})` : e = r, this.main.errScript(e, !1);
  }
  this.val.loadScrWork(z(this, oe));
}, jl = new WeakSet(), Of = function(t) {
  at(this, oe, t.fn), at(this, Vt, t.idx);
  const e = z(this, Qe)[z(this, oe)];
  e && at(this, ae, e), at(this, be, z(this, ae).aLNum[t.idx]);
}, Sc = new WeakMap(), Ec = new WeakMap(), Tc = new WeakSet(), bp = function(t) {
  for (let e = t.len - 1; e >= 0; --e) {
    const r = t.aToken[e];
    if (!z(this, Sc).test(r))
      continue;
    const [S, T] = tagToken2Name_Args(r);
    this.alzTagArg.parse(T);
    const D = this.alzTagArg.hPrm.fn;
    if (!D)
      continue;
    const { val: N } = D;
    if (!N || N.slice(-1) !== "*")
      continue;
    t.aToken.splice(e, 1, "	", "; " + r), t.aLNum.splice(e, 1, NaN, NaN);
    const B = S === "loadplugin" ? SEARCH_PATH_ARG_EXT.CSS : SEARCH_PATH_ARG_EXT.SN, $ = this.cfg.matchPath("^" + N.slice(0, -1) + ".*", B);
    for (const U of $) {
      const H = r.replace(
        z(this, Ec),
        "fn=" + decodeURIComponent(getFn(U[B]))
      );
      t.aToken.splice(e, 0, H), t.aLNum.splice(e, 0, NaN);
    }
  }
  t.len = t.aToken.length;
}, wc = new WeakSet(), xp = function() {
  const t = this.val.getAreaKidoku(z(this, oe));
  if (!t)
    throw `recordKidoku fn:'${z(this, oe)}' (areas === null)`;
  if (z(this, ge).length > 0) {
    t.record(z(this, Vt));
    return;
  }
  at(this, wi, t.search(z(this, Vt))), this.val.setVal_Nochk("tmp", "const.sn.isKidoku", z(this, wi)), !z(this, wi) && t.record(z(this, Vt));
}, wi = new WeakMap(), zl = new WeakSet(), If = function() {
  var t;
  (t = this.val.getAreaKidoku(z(this, oe))) == null || t.erase(z(this, Vt)), at(this, wi, !1);
}, Cc = new WeakSet(), Sp = function(t) {
  return z(this, xi).bracket2macro(t, this.hTag, z(this, ae), z(this, Vt)), !1;
}, Pc = new WeakSet(), Ep = function(t) {
  return z(this, xi).char2macro(t, this.hTag, z(this, ae), z(this, Vt)), !1;
}, Rc = new WeakMap(), Mc = new WeakSet(), Tp = function(t) {
  var T, D;
  const { name: e } = t;
  if (!e)
    throw "nameは必須です";
  if (e in this.hTag)
    throw `[${e}]はタグかすでに定義済みのマクロです`;
  if (z(this, Rc).test(e))
    throw `[${e}]はマクロ名として異常です`;
  const r = z(this, be), S = new CallStack(z(this, oe), z(this, Vt));
  for (at(this, Hl, z(this, Hl) + ("|" + e)), at(this, Pa, new RegExp(`\\[(${z(this, Hl)})\\b`)), this.hTag[e] = (N) => (N.design_unit = t.design_unit, lt(this, Ll, Cf).call(this, { ...N, ":hMp": this.val.cloneMp() }), this.val.setMp(N), this.val.setVal_Nochk("mp", "const.sn.macro", JSON.stringify(t)), this.val.setVal_Nochk("mp", "const.sn.me_call_scriptFn", z(this, oe)), at(this, be, r), lt(this, jl, Of).call(this, S), !1); z(this, Vt) < z(this, ae).len; ++Oe(this, Vt)._) {
    (T = z(this, ae).aLNum)[D = z(this, Vt)] || (T[D] = z(this, be));
    const N = z(this, ae).aToken[z(this, Vt)];
    if (N.search(z(this, Ul)) > -1)
      return ++Oe(this, Vt)._, !1;
    const B = N.charCodeAt(0);
    B === 10 ? at(this, be, z(this, be) + N.length) : B === 91 && at(this, be, z(this, be) + (N.match(/\n/g) ?? []).length);
  }
  throw `マクロ[${e}]定義の終端・[endmacro]がありません`;
}, Hl = new WeakMap(), Pa = new WeakMap(), Oc = new WeakSet(), wp = function(t) {
  if (!("place" in t))
    throw "placeは必須です";
  const e = Number(t.place);
  if ("fn" in t != "label" in t)
    throw "fnとlabelはセットで指定して下さい";
  const r = this.val.getMark(e);
  if (!r)
    throw `place【${e}】は存在しません`;
  return lt(this, Ra, mu).call(this, t, r);
}, Ra = new WeakSet(), mu = function(t, e, r = !0) {
  this.hTag.clear_event({}), this.val.mark2save(e), this.val.setMp({}), z(this, cr).recPagebreak(), r && this.sndMng.playLoopFromSaveObj(), argChk_Boolean(t, "do_rec", !0) && at(this, Ar, {
    hSave: this.val.cloneSave(),
    hPages: { ...e.hPages },
    aIfStk: [...e.aIfStk]
  });
  const S = {
    enabled: this.val.getVal("save:const.sn.autowc.enabled"),
    text: this.val.getVal("save:const.sn.autowc.text"),
    time: Number(this.val.getVal("save:const.sn.autowc.time"))
  };
  this.hTag.autowc(S);
  const T = String(this.val.getVal("save:const.sn.scriptFn")), D = Number(this.val.getVal("save:const.sn.scriptIdx"));
  return at(this, fr, [...z(this, Ar).aIfStk]), at(this, ge, []), z(this, cr).cover(!0), z(this, cr).stopAllTw(), "index" in t ? (z(this, cr).playback(z(this, Ar).hPages, () => {
    z(this, cr).cover(!1), at(this, Ma, !0), lt(this, Ti, sn).call(this, t.fn ?? T, "", t.index ?? D);
  }), !0) : (delete z(this, Qe)[T], z(this, cr).playback(
    z(this, Ar).hPages,
    "label" in t ? () => {
      z(this, cr).cover(!1), at(this, oe, T), at(this, Vt, D), this.hTag.call({ fn: t.fn, label: t.label });
    } : () => {
      z(this, cr).cover(!1), lt(this, Ti, sn).call(this, T, "", D);
    }
  ), !0);
}, Ma = new WeakMap(), Ic = new WeakSet(), Cp = function(t) {
  const e = this.val.getMark(0);
  return delete z(this, Qe)[getFn(e.hSave["const.sn.scriptFn"])], t.do_rec = !1, lt(this, Ra, mu).call(this, t, e, !1);
}, Ar = new WeakMap(), Dc = new WeakSet(), Pp = function() {
  if (this.main.isDestroyed())
    return !1;
  const { fn: t, idx: e } = lt(this, Oa, _u).call(this);
  return this.val.setVal_Nochk("save", "const.sn.scriptFn", t), this.val.setVal_Nochk("save", "const.sn.scriptIdx", e), at(this, Ar, {
    hSave: this.val.cloneSave(),
    hPages: z(this, cr).record(),
    aIfStk: z(this, fr).slice(z(this, ge).length)
  }), !1;
}, Oa = new WeakSet(), _u = function() {
  if (z(this, ge).length === 0)
    return {
      fn: z(this, oe),
      idx: z(this, Vt)
    };
  const e = z(this, ge)[0];
  return {
    fn: e.fn,
    idx: e.idx
  };
}, Ac = new WeakSet(), Rp = function(t) {
  if (!("place" in t))
    throw "placeは必須です";
  const e = Number(t.place);
  delete t[":タグ名"], delete t.place, t.text = (t.text ?? "").replace(/^(<br\/>)+/, ""), z(this, Ar).json = t, this.val.setMark(e, z(this, Ar));
  const r = Number(this.val.getVal("sys:const.sn.save.place"));
  return e === r && this.val.setVal_Nochk("sys", "const.sn.save.place", r + 1), !1;
}, Nr = new WeakMap(), $e = new WeakMap(), tt(ScriptIterator, sc, /(.+)\/crypto_prj\/([^\/]+)\/[^\.]+(\.\w+)/), // reload 再生成 Main に受け渡すため static
tt(ScriptIterator, Qn, {}), tt(ScriptIterator, Si, {});
var tr, xr, je, Sr, Ci, ss, Ge, Vl, Pi, Ia, as, Xl, Yl, Da, Nc, Mp, Wl, ql, Aa, Na, yu, os, ls;
const ws = class {
  constructor(t) {
    tt(this, Nc);
    tt(this, Na);
    tt(this, tr, void 0);
    tt(this, xr, void 0);
    tt(this, je, /* @__PURE__ */ Object.create(null));
    // タグ処理辞書
    tt(this, Sr, void 0);
    tt(this, Ci, void 0);
    tt(this, ss, void 0);
    tt(this, Ge, void 0);
    tt(this, Vl, void 0);
    tt(this, Pi, void 0);
    tt(this, Ia, void 0);
    tt(this, as, () => {
    });
    tt(this, Xl, new AnalyzeTagArg());
    tt(this, Yl, !1);
    tt(this, Da, "skynovel");
    tt(this, Wl, () => z(this, as).call(this));
    // メイン処理（シナリオ解析）
    tt(this, ql, (t = lt(this, Na, yu)) => {
      z(this, os) || (z(this, Pi).clearBreak(), at(this, as, t), this.resume = (e = lt(this, Na, yu)) => {
        at(this, as, e);
      }, z(this, Ge).noticeBreak(!1));
    });
    Pt(this, "resume", z(this, ql));
    Pt(this, "stop", () => {
      at(this, as, () => {
      }), this.resume = z(this, ql), z(this, Ge).noticeBreak(!0);
    });
    tt(this, Aa, !0);
    tt(this, os, !1);
    Pt(this, "isDestroyed", () => z(this, os));
    tt(this, ls, void 0);
    this.sys = t, skipHello(), Config.generate(t).then((e) => at(this, tr, e)).then(() => lt(this, Nc, Mp).call(this)).catch((e) => console.error("load err fn:prj.json e:%o", e));
  }
  // thisの扱いによりメソッド代入はダメ
  errScript(t, e = !0) {
    if (this.stop(), DebugMng.myTrace(t), CmnLib.debugLog && console.log("🍜 SKYNovel err!"), e)
      throw t;
  }
  resumeByJumpOrCall(t) {
    if (t.url) {
      globalThis.open(t.url);
      return;
    }
    z(this, Sr).setVal_Nochk("tmp", "sn.eventArg", t.arg ?? ""), z(this, Sr).setVal_Nochk("tmp", "sn.eventLabel", t.label ?? ""), argChk_Boolean(t, "call", !1) ? (z(this, Ge).subIdxToken(), this.resume(() => z(this, je).call(t))) : (z(this, je).clear_event({}), this.resume(() => z(this, je).jump(t)));
  }
  setLoop(t, e = "") {
    at(this, Aa, t) ? this.resume() : this.stop(), this.sys.setTitleInfo(e ? ` -- ${e}中` : "");
  }
  fire(t, e) {
    z(this, Ia).fire(t, e);
  }
  async destroy(t = 0) {
    z(this, os) || (at(this, os, !0), z(this, Yl) && (this.stop(), at(this, Aa, !1), z(this, Pi).before_destroy(), t > 0 && await new Promise((e) => setTimeout(e, t)), at(this, je, {}), z(this, Ia).destroy(), z(this, Ge).destroy(), z(this, Pi).destroy(), z(this, Vl).destroy(), z(this, xr).ticker.remove(z(this, Wl)), z(this, ls) && z(this, xr) && ws.cvs.parentNode.appendChild(z(this, ls)), clearTextureCache(), z(this, xr).destroy(!0), this.sys.destroy()));
  }
};
let Main = ws;
tr = new WeakMap(), xr = new WeakMap(), je = new WeakMap(), Sr = new WeakMap(), Ci = new WeakMap(), ss = new WeakMap(), Ge = new WeakMap(), Vl = new WeakMap(), Pi = new WeakMap(), Ia = new WeakMap(), as = new WeakMap(), Xl = new WeakMap(), Yl = new WeakMap(), Da = new WeakMap(), Nc = new WeakSet(), Mp = async function() {
  var S;
  const t = (S = document.createElement("canvas")) == null ? void 0 : S.getContext("2d");
  if (!t)
    throw "argChk_Color err";
  CmnLib.cc4ColorName = t;
  const e = {
    width: z(this, tr).oCfg.window.width,
    height: z(this, tr).oCfg.window.height,
    backgroundColor: parseColor(String(z(this, tr).oCfg.init.bg_color)),
    // このString()は後方互換性のため必須
    //	resolution		: sys.resolution,
    resolution: globalThis.devicePixelRatio ?? 1,
    // 理想
    autoResize: !0
  }, r = document.getElementById(z(this, Da));
  r && (at(this, ls, r.cloneNode(!0)), z(this, ls).id = z(this, Da), e.view = r), at(this, xr, new Application(e)), ws.cvs = z(this, xr).view, r || (document.body.appendChild(ws.cvs), ws.cvs.id = z(this, Da)), at(this, Sr, new Variable(z(this, tr), z(this, je))), at(this, Ci, new PropParser(z(this, Sr), z(this, tr).oCfg.init.escape ?? "\\")), await Promise.allSettled(this.sys.init(z(this, je), z(this, xr), z(this, Sr), this)), z(this, je).title({ text: z(this, tr).oCfg.book.title || "SKYNovel" }), at(this, ss, new SoundMng(z(this, tr), z(this, je), z(this, Sr), this, this.sys)), at(this, Ge, new ScriptIterator(z(this, tr), z(this, je), this, z(this, Sr), z(this, Xl), () => lt(this, Na, yu).call(this), z(this, Ci), z(this, ss), this.sys)), at(this, Vl, new DebugMng(this.sys, z(this, je), z(this, Ge))), at(this, Pi, new LayerMng(z(this, tr), z(this, je), z(this, xr), z(this, Sr), this, z(this, Ge), this.sys, z(this, ss), z(this, Xl), z(this, Ci))), at(this, Ia, new EventMng(z(this, tr), z(this, je), z(this, xr), this, z(this, Pi), z(this, Sr), z(this, ss), z(this, Ge), this.sys)), z(this, xr).ticker.add(z(this, Wl)), this.resumeByJumpOrCall({ fn: "main" }), at(this, Yl, !0);
}, Wl = new WeakMap(), ql = new WeakMap(), Aa = new WeakMap(), Na = new WeakSet(), yu = function() {
  for (; z(this, Aa); ) {
    let t = z(this, Ge).nextToken();
    if (!t)
      break;
    const e = t.charCodeAt(0);
    if (e !== 9) {
      if (e === 10) {
        z(this, Ge).addLineNum(t.length);
        continue;
      }
      if (e === 91) {
        if (z(this, Ge).isBreak(t))
          return;
        try {
          const r = (t.match(/\n/g) ?? []).length;
          if (r > 0 && z(this, Ge).addLineNum(r), z(this, Ge).タグ解析(t)) {
            this.stop();
            break;
          }
          continue;
        } catch (r) {
          r instanceof Error ? this.errScript(`[${tagToken2Name(t)}]タグ解析中例外 mes=${r.message}(${r.name})`, !1) : this.errScript(String(r), !1);
          return;
        }
      }
      if (e === 38)
        try {
          if (t.slice(-1) !== "&") {
            if (z(this, Ge).isBreak(t))
              return;
            const r = splitAmpersand(t.slice(1));
            r.name = z(this, Ci).getValAmpersand(r.name), r.text = String(z(this, Ci).parse(r.text)), z(this, je).let(r);
            continue;
          }
          if (t.charAt(1) === "&")
            throw new Error("「&表示&」書式では「&」指定が不要です");
          t = String(z(this, Ci).parse(t.slice(1, -1)));
        } catch (r) {
          this.errScript(
            r instanceof Error ? `& 変数操作・表示 mes=${r.message}(${r.name})` : r,
            !1
          );
          return;
        }
      else {
        if (e === 59)
          continue;
        if (e === 42 && t.length > 1)
          continue;
      }
      try {
        z(this, Pi).currentTxtlayForeNeedErr.tagCh(t);
      } catch (r) {
        this.errScript(
          r instanceof Error ? `文字表示 mes=${r.message}(${r.name})` : r,
          !1
        );
        return;
      }
    }
  }
}, os = new WeakMap(), ls = new WeakMap(), Pt(Main, "cvs");
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES.open = "0";
PACKET_TYPES.close = "1";
PACKET_TYPES.ping = "2";
PACKET_TYPES.pong = "3";
PACKET_TYPES.message = "4";
PACKET_TYPES.upgrade = "5";
PACKET_TYPES.noop = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((o) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[o]] = o;
});
const ERROR_PACKET = { type: "error", data: "parser error" }, withNativeBlob$1 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", withNativeArrayBuffer$2 = typeof ArrayBuffer == "function", isView$1 = (o) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(o) : o && o.buffer instanceof ArrayBuffer, encodePacket = ({ type: o, data: t }, e, r) => withNativeBlob$1 && t instanceof Blob ? e ? r(t) : encodeBlobAsBase64(t, r) : withNativeArrayBuffer$2 && (t instanceof ArrayBuffer || isView$1(t)) ? e ? r(t) : encodeBlobAsBase64(new Blob([t]), r) : r(PACKET_TYPES[o] + (t || "")), encodeBlobAsBase64 = (o, t) => {
  const e = new FileReader();
  return e.onload = function() {
    const r = e.result.split(",")[1];
    t("b" + r);
  }, e.readAsDataURL(o);
}, chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup$1 = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let o = 0; o < chars.length; o++)
  lookup$1[chars.charCodeAt(o)] = o;
const decode$1 = (o) => {
  let t = o.length * 0.75, e = o.length, r, S = 0, T, D, N, B;
  o[o.length - 1] === "=" && (t--, o[o.length - 2] === "=" && t--);
  const $ = new ArrayBuffer(t), U = new Uint8Array($);
  for (r = 0; r < e; r += 4)
    T = lookup$1[o.charCodeAt(r)], D = lookup$1[o.charCodeAt(r + 1)], N = lookup$1[o.charCodeAt(r + 2)], B = lookup$1[o.charCodeAt(r + 3)], U[S++] = T << 2 | D >> 4, U[S++] = (D & 15) << 4 | N >> 2, U[S++] = (N & 3) << 6 | B & 63;
  return $;
}, withNativeArrayBuffer$1 = typeof ArrayBuffer == "function", decodePacket = (o, t) => {
  if (typeof o != "string")
    return {
      type: "message",
      data: mapBinary(o, t)
    };
  const e = o.charAt(0);
  return e === "b" ? {
    type: "message",
    data: decodeBase64Packet(o.substring(1), t)
  } : PACKET_TYPES_REVERSE[e] ? o.length > 1 ? {
    type: PACKET_TYPES_REVERSE[e],
    data: o.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[e]
  } : ERROR_PACKET;
}, decodeBase64Packet = (o, t) => {
  if (withNativeArrayBuffer$1) {
    const e = decode$1(o);
    return mapBinary(e, t);
  } else
    return { base64: !0, data: o };
}, mapBinary = (o, t) => {
  switch (t) {
    case "blob":
      return o instanceof ArrayBuffer ? new Blob([o]) : o;
    case "arraybuffer":
    default:
      return o;
  }
}, SEPARATOR = String.fromCharCode(30), encodePayload = (o, t) => {
  const e = o.length, r = new Array(e);
  let S = 0;
  o.forEach((T, D) => {
    encodePacket(T, !1, (N) => {
      r[D] = N, ++S === e && t(r.join(SEPARATOR));
    });
  });
}, decodePayload = (o, t) => {
  const e = o.split(SEPARATOR), r = [];
  for (let S = 0; S < e.length; S++) {
    const T = decodePacket(e[S], t);
    if (r.push(T), T.type === "error")
      break;
  }
  return r;
}, protocol$1 = 4;
function Emitter(o) {
  if (o)
    return mixin(o);
}
function mixin(o) {
  for (var t in Emitter.prototype)
    o[t] = Emitter.prototype[t];
  return o;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(o, t) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + o] = this._callbacks["$" + o] || []).push(t), this;
};
Emitter.prototype.once = function(o, t) {
  function e() {
    this.off(o, e), t.apply(this, arguments);
  }
  return e.fn = t, this.on(o, e), this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(o, t) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var e = this._callbacks["$" + o];
  if (!e)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + o], this;
  for (var r, S = 0; S < e.length; S++)
    if (r = e[S], r === t || r.fn === t) {
      e.splice(S, 1);
      break;
    }
  return e.length === 0 && delete this._callbacks["$" + o], this;
};
Emitter.prototype.emit = function(o) {
  this._callbacks = this._callbacks || {};
  for (var t = new Array(arguments.length - 1), e = this._callbacks["$" + o], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  if (e) {
    e = e.slice(0);
    for (var r = 0, S = e.length; r < S; ++r)
      e[r].apply(this, t);
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(o) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + o] || [];
};
Emitter.prototype.hasListeners = function(o) {
  return !!this.listeners(o).length;
};
const globalThisShim = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
function pick(o, ...t) {
  return t.reduce((e, r) => (o.hasOwnProperty(r) && (e[r] = o[r]), e), {});
}
const NATIVE_SET_TIMEOUT = setTimeout, NATIVE_CLEAR_TIMEOUT = clearTimeout;
function installTimerFunctions(o, t) {
  t.useNativeTimers ? (o.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim), o.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim)) : (o.setTimeoutFn = setTimeout.bind(globalThisShim), o.clearTimeoutFn = clearTimeout.bind(globalThisShim));
}
const BASE64_OVERHEAD = 1.33;
function byteLength(o) {
  return typeof o == "string" ? utf8Length(o) : Math.ceil((o.byteLength || o.size) * BASE64_OVERHEAD);
}
function utf8Length(o) {
  let t = 0, e = 0;
  for (let r = 0, S = o.length; r < S; r++)
    t = o.charCodeAt(r), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (r++, e += 4);
  return e;
}
class TransportError extends Error {
  constructor(t, e, r) {
    super(t), this.description = e, this.context = r, this.type = "TransportError";
  }
}
class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} options.
   * @api private
   */
  constructor(t) {
    super(), this.writable = !1, installTimerFunctions(this, t), this.opts = t, this.query = t.query, this.readyState = "", this.socket = t.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @api protected
   */
  onError(t, e, r) {
    return super.emitReserved("error", new TransportError(t, e, r)), this;
  }
  /**
   * Opens the transport.
   *
   * @api public
   */
  open() {
    return (this.readyState === "closed" || this.readyState === "") && (this.readyState = "opening", this.doOpen()), this;
  }
  /**
   * Closes the transport.
   *
   * @api public
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   * @api public
   */
  send(t) {
    this.readyState === "open" && this.write(t);
  }
  /**
   * Called upon open
   *
   * @api protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @api protected
   */
  onData(t) {
    const e = decodePacket(t, this.socket.binaryType);
    this.onPacket(e);
  }
  /**
   * Called with a decoded packet.
   *
   * @api protected
   */
  onPacket(t) {
    super.emitReserved("packet", t);
  }
  /**
   * Called upon close.
   *
   * @api protected
   */
  onClose(t) {
    this.readyState = "closed", super.emitReserved("close", t);
  }
}
const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map$1 = {};
let seed = 0, i = 0, prev;
function encode$1(o) {
  let t = "";
  do
    t = alphabet[o % length] + t, o = Math.floor(o / length);
  while (o > 0);
  return t;
}
function yeast() {
  const o = encode$1(+new Date());
  return o !== prev ? (seed = 0, prev = o) : o + "." + encode$1(seed++);
}
for (; i < length; i++)
  map$1[alphabet[i]] = i;
function encode(o) {
  let t = "";
  for (let e in o)
    o.hasOwnProperty(e) && (t.length && (t += "&"), t += encodeURIComponent(e) + "=" + encodeURIComponent(o[e]));
  return t;
}
function decode(o) {
  let t = {}, e = o.split("&");
  for (let r = 0, S = e.length; r < S; r++) {
    let T = e[r].split("=");
    t[decodeURIComponent(T[0])] = decodeURIComponent(T[1]);
  }
  return t;
}
let value = !1;
try {
  value = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const hasCORS = value;
function XHR(o) {
  const t = o.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!t || hasCORS))
      return new XMLHttpRequest();
  } catch {
  }
  if (!t)
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
function empty() {
}
const hasXHR2 = function() {
  return new XHR({
    xdomain: !1
  }).responseType != null;
}();
class Polling extends Transport {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @api public
   */
  constructor(t) {
    if (super(t), this.polling = !1, typeof location < "u") {
      const r = location.protocol === "https:";
      let S = location.port;
      S || (S = r ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || S !== t.port, this.xs = t.secure !== r;
    }
    const e = t && t.forceBase64;
    this.supportsBinary = hasXHR2 && !e;
  }
  /**
   * Transport name.
   */
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @api private
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} callback upon buffers are flushed and transport is paused
   * @api private
   */
  pause(t) {
    this.readyState = "pausing";
    const e = () => {
      this.readyState = "paused", t();
    };
    if (this.polling || !this.writable) {
      let r = 0;
      this.polling && (r++, this.once("pollComplete", function() {
        --r || e();
      })), this.writable || (r++, this.once("drain", function() {
        --r || e();
      }));
    } else
      e();
  }
  /**
   * Starts polling cycle.
   *
   * @api public
   */
  poll() {
    this.polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @api private
   */
  onData(t) {
    const e = (r) => {
      if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(r);
    };
    decodePayload(t, this.socket.binaryType).forEach(e), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @api private
   */
  doClose() {
    const t = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? t() : this.once("open", t);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} data packets
   * @param {Function} drain callback
   * @api private
   */
  write(t) {
    this.writable = !1, encodePayload(t, (e) => {
      this.doWrite(e, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @api private
   */
  uri() {
    let t = this.query || {};
    const e = this.opts.secure ? "https" : "http";
    let r = "";
    this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = yeast()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.opts.port && (e === "https" && Number(this.opts.port) !== 443 || e === "http" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port);
    const S = encode(t), T = this.opts.hostname.indexOf(":") !== -1;
    return e + "://" + (T ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (S.length ? "?" + S : "");
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @api private
   */
  request(t = {}) {
    return Object.assign(t, { xd: this.xd, xs: this.xs }, this.opts), new Request(this.uri(), t);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @api private
   */
  doWrite(t, e) {
    const r = this.request({
      method: "POST",
      data: t
    });
    r.on("success", e), r.on("error", (S, T) => {
      this.onError("xhr post error", S, T);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @api private
   */
  doPoll() {
    const t = this.request();
    t.on("data", this.onData.bind(this)), t.on("error", (e, r) => {
      this.onError("xhr poll error", e, r);
    }), this.pollXhr = t;
  }
}
class Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @api public
   */
  constructor(t, e) {
    super(), installTimerFunctions(this, e), this.opts = e, this.method = e.method || "GET", this.uri = t, this.async = e.async !== !1, this.data = e.data !== void 0 ? e.data : null, this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @api private
   */
  create() {
    const t = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    t.xdomain = !!this.opts.xd, t.xscheme = !!this.opts.xs;
    const e = this.xhr = new XHR(t);
    try {
      e.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0);
          for (let r in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(r) && e.setRequestHeader(r, this.opts.extraHeaders[r]);
        }
      } catch {
      }
      if (this.method === "POST")
        try {
          e.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        e.setRequestHeader("Accept", "*/*");
      } catch {
      }
      "withCredentials" in e && (e.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (e.timeout = this.opts.requestTimeout), e.onreadystatechange = () => {
        e.readyState === 4 && (e.status === 200 || e.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
          this.onError(typeof e.status == "number" ? e.status : 0);
        }, 0));
      }, e.send(this.data);
    } catch (r) {
      this.setTimeoutFn(() => {
        this.onError(r);
      }, 0);
      return;
    }
    typeof document < "u" && (this.index = Request.requestsCount++, Request.requests[this.index] = this);
  }
  /**
   * Called upon error.
   *
   * @api private
   */
  onError(t) {
    this.emitReserved("error", t, this.xhr), this.cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @api private
   */
  cleanup(t) {
    if (!(typeof this.xhr > "u" || this.xhr === null)) {
      if (this.xhr.onreadystatechange = empty, t)
        try {
          this.xhr.abort();
        } catch {
        }
      typeof document < "u" && delete Request.requests[this.index], this.xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @api private
   */
  onLoad() {
    const t = this.xhr.responseText;
    t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this.cleanup());
  }
  /**
   * Aborts the request.
   *
   * @api public
   */
  abort() {
    this.cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", unloadHandler);
  else if (typeof addEventListener == "function") {
    const o = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(o, unloadHandler, !1);
  }
}
function unloadHandler() {
  for (let o in Request.requests)
    Request.requests.hasOwnProperty(o) && Request.requests[o].abort();
}
const nextTick = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0))(), WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket, usingBrowserWebSocket = !0, defaultBinaryType = "arraybuffer", isReactNative = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class WS extends Transport {
  /**
   * WebSocket transport constructor.
   *
   * @api {Object} connection options
   * @api public
   */
  constructor(t) {
    super(t), this.supportsBinary = !t.forceBase64;
  }
  /**
   * Transport name.
   *
   * @api public
   */
  get name() {
    return "websocket";
  }
  /**
   * Opens socket.
   *
   * @api private
   */
  doOpen() {
    if (!this.check())
      return;
    const t = this.uri(), e = this.opts.protocols, r = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? e ? new WebSocket(t, e) : new WebSocket(t) : new WebSocket(t, e, r);
    } catch (S) {
      return this.emitReserved("error", S);
    }
    this.ws.binaryType = this.socket.binaryType || defaultBinaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @api private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  /**
   * Writes data to socket.
   *
   * @param {Array} array of packets.
   * @api private
   */
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const r = t[e], S = e === t.length - 1;
      encodePacket(r, this.supportsBinary, (T) => {
        const D = {};
        try {
          usingBrowserWebSocket && this.ws.send(T);
        } catch {
        }
        S && nextTick(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  /**
   * Closes socket.
   *
   * @api private
   */
  doClose() {
    typeof this.ws < "u" && (this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @api private
   */
  uri() {
    let t = this.query || {};
    const e = this.opts.secure ? "wss" : "ws";
    let r = "";
    this.opts.port && (e === "wss" && Number(this.opts.port) !== 443 || e === "ws" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port), this.opts.timestampRequests && (t[this.opts.timestampParam] = yeast()), this.supportsBinary || (t.b64 = 1);
    const S = encode(t), T = this.opts.hostname.indexOf(":") !== -1;
    return e + "://" + (T ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (S.length ? "?" + S : "");
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @api public
   */
  check() {
    return !!WebSocket;
  }
}
const transports = {
  websocket: WS,
  polling: Polling
}, re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse(o) {
  const t = o, e = o.indexOf("["), r = o.indexOf("]");
  e != -1 && r != -1 && (o = o.substring(0, e) + o.substring(e, r).replace(/:/g, ";") + o.substring(r, o.length));
  let S = re.exec(o || ""), T = {}, D = 14;
  for (; D--; )
    T[parts[D]] = S[D] || "";
  return e != -1 && r != -1 && (T.source = t, T.host = T.host.substring(1, T.host.length - 1).replace(/;/g, ":"), T.authority = T.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), T.ipv6uri = !0), T.pathNames = pathNames(T, T.path), T.queryKey = queryKey(T, T.query), T;
}
function pathNames(o, t) {
  const e = /\/{2,9}/g, r = t.replace(e, "/").split("/");
  return (t.slice(0, 1) == "/" || t.length === 0) && r.splice(0, 1), t.slice(-1) == "/" && r.splice(r.length - 1, 1), r;
}
function queryKey(o, t) {
  const e = {};
  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, S, T) {
    S && (e[S] = T);
  }), e;
}
let Socket$1 = class extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri or options
   * @param {Object} opts - options
   * @api public
   */
  constructor(t, e = {}) {
    super(), t && typeof t == "object" && (e = t, t = null), t ? (t = parse(t), e.hostname = t.host, e.secure = t.protocol === "https" || t.protocol === "wss", e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = parse(e.host).host), installTimerFunctions(this, e), this.secure = e.secure != null ? e.secure : typeof location < "u" && location.protocol === "https:", e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.hostname = e.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = e.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = e.transports || ["polling", "websocket"], this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !0
    }, e), this.opts.path = this.opts.path.replace(/\/$/, "") + "/", typeof this.opts.query == "string" && (this.opts.query = decode(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this.offlineEventListener = () => {
      this.onClose("transport close", {
        description: "network connection lost"
      });
    }, addEventListener("offline", this.offlineEventListener, !1))), this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} transport name
   * @return {Transport}
   * @api private
   */
  createTransport(t) {
    const e = Object.assign({}, this.opts.query);
    e.EIO = protocol$1, e.transport = t, this.id && (e.sid = this.id);
    const r = Object.assign({}, this.opts.transportOptions[t], this.opts, {
      query: e,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    });
    return new transports[t](r);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @api private
   */
  open() {
    let t;
    if (this.opts.rememberUpgrade && Socket$1.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
      t = "websocket";
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else
      t = this.transports[0];
    this.readyState = "opening";
    try {
      t = this.createTransport(t);
    } catch {
      this.transports.shift(), this.open();
      return;
    }
    t.open(), this.setTransport(t);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @api private
   */
  setTransport(t) {
    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (e) => this.onClose("transport close", e));
  }
  /**
   * Probes a transport.
   *
   * @param {String} transport name
   * @api private
   */
  probe(t) {
    let e = this.createTransport(t), r = !1;
    Socket$1.priorWebsocketSuccess = !1;
    const S = () => {
      r || (e.send([{ type: "ping", data: "probe" }]), e.once("packet", (H) => {
        if (!r)
          if (H.type === "pong" && H.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", e), !e)
              return;
            Socket$1.priorWebsocketSuccess = e.name === "websocket", this.transport.pause(() => {
              r || this.readyState !== "closed" && (U(), this.setTransport(e), e.send([{ type: "upgrade" }]), this.emitReserved("upgrade", e), e = null, this.upgrading = !1, this.flush());
            });
          } else {
            const V = new Error("probe error");
            V.transport = e.name, this.emitReserved("upgradeError", V);
          }
      }));
    };
    function T() {
      r || (r = !0, U(), e.close(), e = null);
    }
    const D = (H) => {
      const V = new Error("probe error: " + H);
      V.transport = e.name, T(), this.emitReserved("upgradeError", V);
    };
    function N() {
      D("transport closed");
    }
    function B() {
      D("socket closed");
    }
    function $(H) {
      e && H.name !== e.name && T();
    }
    const U = () => {
      e.removeListener("open", S), e.removeListener("error", D), e.removeListener("close", N), this.off("close", B), this.off("upgrading", $);
    };
    e.once("open", S), e.once("error", D), e.once("close", N), this.once("close", B), this.once("upgrading", $), e.open();
  }
  /**
   * Called when connection is deemed open.
   *
   * @api private
   */
  onOpen() {
    if (this.readyState = "open", Socket$1.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade && this.transport.pause) {
      let t = 0;
      const e = this.upgrades.length;
      for (; t < e; t++)
        this.probe(this.upgrades[t]);
    }
  }
  /**
   * Handles a packet.
   *
   * @api private
   */
  onPacket(t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;
        case "ping":
          this.resetPingTimeout(), this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
          break;
        case "error":
          const e = new Error("server error");
          e.code = t.data, this.onError(e);
          break;
        case "message":
          this.emitReserved("data", t.data), this.emitReserved("message", t.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @api private
   */
  onHandshake(t) {
    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @api private
   */
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @api private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @api private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const t = this.getWritablePackets();
      this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  getWritablePackets() {
    if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let e = 1;
    for (let r = 0; r < this.writeBuffer.length; r++) {
      const S = this.writeBuffer[r].data;
      if (S && (e += byteLength(S)), r > 0 && e > this.maxPayload)
        return this.writeBuffer.slice(0, r);
      e += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Sends a message.
   *
   * @param {String} message.
   * @param {Function} callback function.
   * @param {Object} options.
   * @return {Socket} for chaining.
   * @api public
   */
  write(t, e, r) {
    return this.sendPacket("message", t, e, r), this;
  }
  send(t, e, r) {
    return this.sendPacket("message", t, e, r), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} callback function.
   * @api private
   */
  sendPacket(t, e, r, S) {
    if (typeof e == "function" && (S = e, e = void 0), typeof r == "function" && (S = r, r = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    r = r || {}, r.compress = r.compress !== !1;
    const T = {
      type: t,
      data: e,
      options: r
    };
    this.emitReserved("packetCreate", T), this.writeBuffer.push(T), S && this.once("flush", S), this.flush();
  }
  /**
   * Closes the connection.
   *
   * @api public
   */
  close() {
    const t = () => {
      this.onClose("forced close"), this.transport.close();
    }, e = () => {
      this.off("upgrade", e), this.off("upgradeError", e), t();
    }, r = () => {
      this.once("upgrade", e), this.once("upgradeError", e);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? r() : t();
    }) : this.upgrading ? r() : t()), this;
  }
  /**
   * Called upon transport error
   *
   * @api private
   */
  onError(t) {
    Socket$1.priorWebsocketSuccess = !1, this.emitReserved("error", t), this.onClose("transport error", t);
  }
  /**
   * Called upon transport close.
   *
   * @api private
   */
  onClose(t, e) {
    (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", t, e), this.writeBuffer = [], this.prevBufferLen = 0);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} server upgrades
   * @api private
   *
   */
  filterUpgrades(t) {
    const e = [];
    let r = 0;
    const S = t.length;
    for (; r < S; r++)
      ~this.transports.indexOf(t[r]) && e.push(t[r]);
    return e;
  }
};
Socket$1.protocol = protocol$1;
function url(o, t = "", e) {
  let r = o;
  e = e || typeof location < "u" && location, o == null && (o = e.protocol + "//" + e.host), typeof o == "string" && (o.charAt(0) === "/" && (o.charAt(1) === "/" ? o = e.protocol + o : o = e.host + o), /^(https?|wss?):\/\//.test(o) || (typeof e < "u" ? o = e.protocol + "//" + o : o = "https://" + o), r = parse(o)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/";
  const T = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
  return r.id = r.protocol + "://" + T + ":" + r.port + t, r.href = r.protocol + "://" + T + (e && e.port === r.port ? "" : ":" + r.port), r;
}
const withNativeArrayBuffer = typeof ArrayBuffer == "function", isView = (o) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(o) : o.buffer instanceof ArrayBuffer, toString = Object.prototype.toString, withNativeBlob = typeof Blob == "function" || typeof Blob < "u" && toString.call(Blob) === "[object BlobConstructor]", withNativeFile = typeof File == "function" || typeof File < "u" && toString.call(File) === "[object FileConstructor]";
function isBinary(o) {
  return withNativeArrayBuffer && (o instanceof ArrayBuffer || isView(o)) || withNativeBlob && o instanceof Blob || withNativeFile && o instanceof File;
}
function hasBinary(o, t) {
  if (!o || typeof o != "object")
    return !1;
  if (Array.isArray(o)) {
    for (let e = 0, r = o.length; e < r; e++)
      if (hasBinary(o[e]))
        return !0;
    return !1;
  }
  if (isBinary(o))
    return !0;
  if (o.toJSON && typeof o.toJSON == "function" && arguments.length === 1)
    return hasBinary(o.toJSON(), !0);
  for (const e in o)
    if (Object.prototype.hasOwnProperty.call(o, e) && hasBinary(o[e]))
      return !0;
  return !1;
}
function deconstructPacket(o) {
  const t = [], e = o.data, r = o;
  return r.data = _deconstructPacket(e, t), r.attachments = t.length, { packet: r, buffers: t };
}
function _deconstructPacket(o, t) {
  if (!o)
    return o;
  if (isBinary(o)) {
    const e = { _placeholder: !0, num: t.length };
    return t.push(o), e;
  } else if (Array.isArray(o)) {
    const e = new Array(o.length);
    for (let r = 0; r < o.length; r++)
      e[r] = _deconstructPacket(o[r], t);
    return e;
  } else if (typeof o == "object" && !(o instanceof Date)) {
    const e = {};
    for (const r in o)
      Object.prototype.hasOwnProperty.call(o, r) && (e[r] = _deconstructPacket(o[r], t));
    return e;
  }
  return o;
}
function reconstructPacket(o, t) {
  return o.data = _reconstructPacket(o.data, t), o.attachments = void 0, o;
}
function _reconstructPacket(o, t) {
  if (!o)
    return o;
  if (o && o._placeholder === !0) {
    if (typeof o.num == "number" && o.num >= 0 && o.num < t.length)
      return t[o.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(o))
    for (let e = 0; e < o.length; e++)
      o[e] = _reconstructPacket(o[e], t);
  else if (typeof o == "object")
    for (const e in o)
      Object.prototype.hasOwnProperty.call(o, e) && (o[e] = _reconstructPacket(o[e], t));
  return o;
}
const protocol = 5;
var PacketType;
(function(o) {
  o[o.CONNECT = 0] = "CONNECT", o[o.DISCONNECT = 1] = "DISCONNECT", o[o.EVENT = 2] = "EVENT", o[o.ACK = 3] = "ACK", o[o.CONNECT_ERROR = 4] = "CONNECT_ERROR", o[o.BINARY_EVENT = 5] = "BINARY_EVENT", o[o.BINARY_ACK = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(t) {
    this.replacer = t;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(t) {
    return (t.type === PacketType.EVENT || t.type === PacketType.ACK) && hasBinary(t) ? (t.type = t.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK, this.encodeAsBinary(t)) : [this.encodeAsString(t)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(t) {
    let e = "" + t.type;
    return (t.type === PacketType.BINARY_EVENT || t.type === PacketType.BINARY_ACK) && (e += t.attachments + "-"), t.nsp && t.nsp !== "/" && (e += t.nsp + ","), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(t) {
    const e = deconstructPacket(t), r = this.encodeAsString(e.packet), S = e.buffers;
    return S.unshift(r), S;
  }
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(t) {
    super(), this.reviver = t;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(t) {
    let e;
    if (typeof t == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      e = this.decodeString(t), e.type === PacketType.BINARY_EVENT || e.type === PacketType.BINARY_ACK ? (this.reconstructor = new BinaryReconstructor(e), e.attachments === 0 && super.emitReserved("decoded", e)) : super.emitReserved("decoded", e);
    } else if (isBinary(t) || t.base64)
      if (this.reconstructor)
        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved("decoded", e));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + t);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(t) {
    let e = 0;
    const r = {
      type: Number(t.charAt(0))
    };
    if (PacketType[r.type] === void 0)
      throw new Error("unknown packet type " + r.type);
    if (r.type === PacketType.BINARY_EVENT || r.type === PacketType.BINARY_ACK) {
      const T = e + 1;
      for (; t.charAt(++e) !== "-" && e != t.length; )
        ;
      const D = t.substring(T, e);
      if (D != Number(D) || t.charAt(e) !== "-")
        throw new Error("Illegal attachments");
      r.attachments = Number(D);
    }
    if (t.charAt(e + 1) === "/") {
      const T = e + 1;
      for (; ++e && !(t.charAt(e) === "," || e === t.length); )
        ;
      r.nsp = t.substring(T, e);
    } else
      r.nsp = "/";
    const S = t.charAt(e + 1);
    if (S !== "" && Number(S) == S) {
      const T = e + 1;
      for (; ++e; ) {
        const D = t.charAt(e);
        if (D == null || Number(D) != D) {
          --e;
          break;
        }
        if (e === t.length)
          break;
      }
      r.id = Number(t.substring(T, e + 1));
    }
    if (t.charAt(++e)) {
      const T = this.tryParse(t.substr(e));
      if (Decoder.isPayloadValid(r.type, T))
        r.data = T;
      else
        throw new Error("invalid payload");
    }
    return r;
  }
  tryParse(t) {
    try {
      return JSON.parse(t, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(t, e) {
    switch (t) {
      case PacketType.CONNECT:
        return typeof e == "object";
      case PacketType.DISCONNECT:
        return e === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof e == "string" || typeof e == "object";
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(e) && e.length > 0;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(e);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && this.reconstructor.finishedReconstruction();
  }
}
class BinaryReconstructor {
  constructor(t) {
    this.packet = t, this.buffers = [], this.reconPack = t;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(t) {
    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
      const e = reconstructPacket(this.reconPack, this.buffers);
      return this.finishedReconstruction(), e;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on(o, t, e) {
  return o.on(t, e), function() {
    o.off(t, e);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(t, e, r) {
    super(), this.connected = !1, this.receiveBuffer = [], this.sendBuffer = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, r && r.auth && (this.auth = r.auth), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const t = this.io;
    this.subs = [
      on(t, "open", this.onopen.bind(this)),
      on(t, "packet", this.onpacket.bind(this)),
      on(t, "error", this.onerror.bind(this)),
      on(t, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...t) {
    return t.unshift("message"), this.emit.apply(this, t), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(t, ...e) {
    if (RESERVED_EVENTS.hasOwnProperty(t))
      throw new Error('"' + t.toString() + '" is a reserved event name');
    e.unshift(t);
    const r = {
      type: PacketType.EVENT,
      data: e
    };
    if (r.options = {}, r.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == "function") {
      const D = this.ids++, N = e.pop();
      this._registerAckCallback(D, N), r.id = D;
    }
    const S = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    return this.flags.volatile && (!S || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(t, e) {
    const r = this.flags.timeout;
    if (r === void 0) {
      this.acks[t] = e;
      return;
    }
    const S = this.io.setTimeoutFn(() => {
      delete this.acks[t];
      for (let T = 0; T < this.sendBuffer.length; T++)
        this.sendBuffer[T].id === t && this.sendBuffer.splice(T, 1);
      e.call(this, new Error("operation has timed out"));
    }, r);
    this.acks[t] = (...T) => {
      this.io.clearTimeoutFn(S), e.apply(this, [null, ...T]);
    };
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(t) {
    t.nsp = this.nsp, this.io._packet(t);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((t) => {
      this.packet({ type: PacketType.CONNECT, data: t });
    }) : this.packet({ type: PacketType.CONNECT, data: this.auth });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(t) {
    this.connected || this.emitReserved("connect_error", t);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(t, e) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", t, e);
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case PacketType.CONNECT:
          if (t.data && t.data.sid) {
            const S = t.data.sid;
            this.onconnect(S);
          } else
            this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          this.onevent(t);
          break;
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          this.onack(t);
          break;
        case PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case PacketType.CONNECT_ERROR:
          this.destroy();
          const r = new Error(t.data.message);
          r.data = t.data.data, this.emitReserved("connect_error", r);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(t) {
    const e = t.data || [];
    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const e = this._anyListeners.slice();
      for (const r of e)
        r.apply(this, t);
    }
    super.emit.apply(this, t);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(t) {
    const e = this;
    let r = !1;
    return function(...S) {
      r || (r = !0, e.packet({
        type: PacketType.ACK,
        id: t,
        data: S
      }));
    };
  }
  /**
   * Called upon a server acknowlegement.
   *
   * @param packet
   * @private
   */
  onack(t) {
    const e = this.acks[t.id];
    typeof e == "function" && (e.apply(this, t.data), delete this.acks[t.id]);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(t) {
    this.id = t, this.connected = !0, this.emitBuffered(), this.emitReserved("connect");
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {
      this.notifyOutgoingListeners(t), this.packet(t);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: PacketType.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(t) {
    return this.flags.compress = t, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(t) {
    return this.flags.timeout = t, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(t) {
    if (!this._anyListeners)
      return this;
    if (t) {
      const e = this._anyListeners;
      for (let r = 0; r < e.length; r++)
        if (t === e[r])
          return e.splice(r, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners)
      return this;
    if (t) {
      const e = this._anyOutgoingListeners;
      for (let r = 0; r < e.length; r++)
        if (t === e[r])
          return e.splice(r, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const e = this._anyOutgoingListeners.slice();
      for (const r of e)
        r.apply(this, t.data);
    }
  }
}
function Backoff(o) {
  o = o || {}, this.ms = o.min || 100, this.max = o.max || 1e4, this.factor = o.factor || 2, this.jitter = o.jitter > 0 && o.jitter <= 1 ? o.jitter : 0, this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var o = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t = Math.random(), e = Math.floor(t * this.jitter * o);
    o = Math.floor(t * 10) & 1 ? o + e : o - e;
  }
  return Math.min(o, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(o) {
  this.ms = o;
};
Backoff.prototype.setMax = function(o) {
  this.max = o;
};
Backoff.prototype.setJitter = function(o) {
  this.jitter = o;
};
class Manager extends Emitter {
  constructor(t, e) {
    var r;
    super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (e = t, t = void 0), e = e || {}, e.path = e.path || "/socket.io", this.opts = e, installTimerFunctions(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((r = e.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = "closed", this.uri = t;
    const S = e.parser || parser;
    this.encoder = new S.Encoder(), this.decoder = new S.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(t) {
    return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);
  }
  reconnectionDelay(t) {
    var e;
    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);
  }
  randomizationFactor(t) {
    var e;
    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);
  }
  reconnectionDelayMax(t) {
    var e;
    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);
  }
  timeout(t) {
    return arguments.length ? (this._timeout = t, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(t) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const e = this.engine, r = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const S = on(e, "open", function() {
      r.onopen(), t && t();
    }), T = on(e, "error", (D) => {
      r.cleanup(), r._readyState = "closed", this.emitReserved("error", D), t ? t(D) : r.maybeReconnectOnOpen();
    });
    if (this._timeout !== !1) {
      const D = this._timeout;
      D === 0 && S();
      const N = this.setTimeoutFn(() => {
        S(), e.close(), e.emit("error", new Error("timeout"));
      }, D);
      this.opts.autoUnref && N.unref(), this.subs.push(function() {
        clearTimeout(N);
      });
    }
    return this.subs.push(S), this.subs.push(T), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(t) {
    return this.open(t);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const t = this.engine;
    this.subs.push(on(t, "ping", this.onping.bind(this)), on(t, "data", this.ondata.bind(this)), on(t, "error", this.onerror.bind(this)), on(t, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(t) {
    try {
      this.decoder.add(t);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(t) {
    nextTick(() => {
      this.emitReserved("packet", t);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(t) {
    this.emitReserved("error", t);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(t, e) {
    let r = this.nsps[t];
    return r || (r = new Socket(this, t, e), this.nsps[t] = r), r;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(t) {
    const e = Object.keys(this.nsps);
    for (const r of e)
      if (this.nsps[r].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(t) {
    const e = this.encoder.encode(t);
    for (let r = 0; r < e.length; r++)
      this.engine.write(e[r], t.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(t, e) {
    this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, e), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const t = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const e = this.backoff.duration();
      this._reconnecting = !0;
      const r = this.setTimeoutFn(() => {
        t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open((S) => {
          S ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", S)) : t.onreconnect();
        }));
      }, e);
      this.opts.autoUnref && r.unref(), this.subs.push(function() {
        clearTimeout(r);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const t = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t);
  }
}
const cache = {};
function lookup(o, t) {
  typeof o == "object" && (t = o, o = void 0), t = t || {};
  const e = url(o, t.path || "/socket.io"), r = e.source, S = e.id, T = e.path, D = cache[S] && T in cache[S].nsps, N = t.forceNew || t["force new connection"] || t.multiplex === !1 || D;
  let B;
  return N ? B = new Manager(r, t) : (cache[S] || (cache[S] = new Manager(r, t)), B = cache[S]), e.query && !t.query && (t.query = e.queryKey), B.socket(e.path, t);
}
Object.assign(lookup, {
  Manager,
  Socket,
  io: lookup,
  connect: lookup
});
var Lr, Jr, Qr, us, hs, Ji, Qi, tn, Lc, kc, Kl, La, Bc, ka, cs, Fc, fs, Ba;
const $c = class {
  constructor(t = {}, e) {
    Pt(this, "hFactoryCls", {});
    Pt(this, "elc", new EventListenerCtn());
    Pt(this, "fetch", (t) => fetch(t));
    Pt(this, "resolution", 1);
    Pt(this, "cfg");
    Pt(this, "data", { sys: {}, mark: {}, kidoku: {} });
    Pt(this, "val");
    Pt(this, "appPixi");
    tt(this, Lr, 0);
    tt(this, Jr, 0);
    tt(this, Qr, 1);
    tt(this, us, 0);
    tt(this, hs, 0);
    tt(this, Ji, 0);
    tt(this, Qi, 0);
    Pt(this, "isFullScr", !1);
    Pt(this, "extPort", 3776);
    tt(this, tn, void 0);
    tt(this, Lc, {
      auth: (t) => {
        if (t.t !== this.cfg.oCfg.debuger_token) {
          this.end();
          return;
        }
        this.toast("接続");
      },
      continue: () => this.toast("再生"),
      disconnect: () => this.toast("切断"),
      restart: (t) => {
        this.send2Dbg((t == null ? void 0 : t.ri) ?? "", {}), this.end(), this.run();
      },
      pause: () => this.toast("一時停止"),
      stopOnEntry: () => this.toast("一時停止"),
      stopOnDataBreakpoint: () => this.toast("注意"),
      stopOnBreakpoint: () => this.toast("注意"),
      stopOnStep: () => this.toast("一歩進む"),
      stopOnStepIn: () => this.toast("ステップイン"),
      stopOnStepOut: () => this.toast("ステップアウト"),
      stopOnBackstep: () => this.toast("一歩戻る"),
      _addPath: (t) => this.cfg.addPath(t.fn, t.o)
    });
    Pt(this, "pathBaseCnvSnPath4Dbg", "");
    Pt(this, "fire");
    tt(this, Kl, []);
    Pt(this, "callHook", (t, e) => {
    });
    Pt(this, "send2Dbg", (t, e) => {
      var r;
      (r = z(this, tn)) == null || r.emit("data", t, e);
    });
    Pt(this, "copyBMFolder", (t, e) => {
    });
    Pt(this, "eraseBMFolder", (t) => {
    });
    Pt(this, "close", () => !1);
    Pt(this, "_export", () => !1);
    Pt(this, "_import", () => !1);
    Pt(this, "navigate_to", () => !1);
    Pt(this, "title", (t) => {
      const { text: e } = t;
      if (!e)
        throw "[title] textは必須です";
      return at(this, La, e), this.titleSub(z(this, La) + z(this, ka)), !1;
    });
    tt(this, La, "");
    tt(this, Bc, (t) => {
      if (!t.key)
        return this.tglFlscr_sub(), !1;
      const e = t.key.toLowerCase();
      return this.elc.add(document, "keydown", (r) => {
        (r.altKey ? r.key === "Alt" ? "" : "alt+" : "") + (r.ctrlKey ? r.key === "Control" ? "" : "ctrl+" : "") + (r.shiftKey ? r.key === "Shift" ? "" : "shift+" : "") + r.key.toLowerCase() === e && (r.stopPropagation(), this.tglFlscr_sub());
      }, { passive: !0 }), !1;
    });
    Pt(this, "update_check", () => !1);
    Pt(this, "window", () => !1);
    tt(this, ka, "");
    tt(this, cs, (t, e) => ({ ret: e.toString(), ext_num: 0 }));
    tt(this, Fc, {
      1: { ext: "jpeg", fnc: (t) => z(this, fs).call(this, t), mime: "image/jpeg" },
      2: { ext: "png", fnc: (t) => z(this, fs).call(this, t), mime: "image/png" },
      3: { ext: "svg", fnc: (t) => z(this, fs).call(this, t), mime: "image/svg+xml" },
      4: { ext: "webp", fnc: (t) => z(this, fs).call(this, t), mime: "image/webp" },
      10: { ext: "mp3", fnc: (t) => t.arrayBuffer(), mime: "audio/mpeg" },
      11: { ext: "m4a", fnc: (t) => t.arrayBuffer(), mime: "audio/aac" },
      12: { ext: "ogg", fnc: (t) => t.arrayBuffer(), mime: "audio/ogg" },
      13: { ext: "aac", fnc: (t) => t.arrayBuffer(), mime: "audio/aac" },
      14: { ext: "flac", fnc: (t) => t.arrayBuffer(), mime: "audio/flac" },
      15: { ext: "wav", fnc: (t) => t.arrayBuffer(), mime: "audio/wav" },
      20: { ext: "mp4", fnc: (t) => z(this, Ba).call(this, t), mime: "video/mp4" },
      21: { ext: "webm", fnc: (t) => z(this, Ba).call(this, t), mime: "video/webm" },
      22: { ext: "ogv", fnc: (t) => z(this, Ba).call(this, t), mime: "video/ogv" }
    });
    tt(this, fs, (t) => new Promise((e, r) => {
      const S = new Image();
      S.onload = () => e(S), S.onerror = (T) => r(T), S.src = URL.createObjectURL(t);
    }));
    tt(this, Ba, (t) => new Promise((e, r) => {
      const S = document.createElement("video");
      this.elc.add(S, "error", () => {
        var T;
        return r(((T = S == null ? void 0 : S.error) == null ? void 0 : T.message) ?? "");
      }), this.elc.add(S, "canplay", () => e(S)), S.src = URL.createObjectURL(t);
    }));
    Pt(this, "enc", (t) => t);
    Pt(this, "stk", () => "");
    Pt(this, "hash", (t) => "");
    Pt(this, "isApp", !1);
    Pt(this, "$path_downloads", "");
    Pt(this, "$path_userdata", "");
    Pt(this, "canCapturePage", (t) => !1);
    this.hPlg = t, this.arg = e;
  }
  async loaded(t, e) {
    const r = t.snsys_pre;
    return delete t.snsys_pre, r == null ? void 0 : r.init({
      addTag: () => {
      },
      addLayCls: () => {
      },
      searchPath: () => "",
      getVal: () => ({}),
      resume: () => {
      },
      render: () => {
      },
      setDec: (S) => at(this, cs, S),
      setEnc: (S) => this.enc = S,
      getStK: (S) => this.stk = S,
      getHash: (S) => this.hash = S
    });
  }
  get cur() {
    return this.arg.cur;
  }
  get crypto() {
    return this.arg.crypto;
  }
  destroy() {
    this.elc.clear();
  }
  async loadPath(t, e) {
    this.cfg = e;
  }
  initVal(t, e, r) {
  }
  flush() {
  }
  async run() {
  }
  init(t, e, r, S) {
    this.val = r, this.appPixi = e;
    let T = "";
    try {
      this.val.setSys(this), T = "sys", T += Number(this.val.getVal("sys:TextLayer.Back.Alpha", 1)), T = "kidoku", this.val.saveKidoku();
    } catch (D) {
      console.error(`セーブデータ（${T}）が壊れています。一度クリアする必要があります %o`, D);
    }
    return t.close = (D) => this.close(D), t.export = (D) => this._export(D), t.import = (D) => this._import(D), t.navigate_to = (D) => this.navigate_to(D), t.title = (D) => this.title(D), t.toggle_full_screen = (D) => z(this, Bc).call(this, D), t.update_check = (D) => this.update_check(D), t.window = (D) => this.window(D), r.setVal_Nochk("tmp", "const.sn.isApp", () => this.isApp), r.setVal_Nochk("tmp", "const.sn.isDbg", () => CmnLib.isDbg), r.setVal_Nochk("tmp", "const.sn.isPackaged", () => CmnLib.isPackaged), this.val.defTmp("const.sn.displayState", () => this.isFullScr), r.setVal_Nochk("sys", $c.VALNM_CFG_NS, this.cfg.oCfg.save_ns), r.flush(), CmnLib.isDbg && this.attach_debug(S), this.hFactoryCls = {}, Object.values(this.hPlg).map((D) => D.init({
      addTag: (N, B) => {
        if (t[N])
          throw `すでに定義済みのタグ[${N}]です`;
        t[N] = B;
      },
      addLayCls: (N, B) => {
        if (this.hFactoryCls[N])
          throw `すでに定義済みのレイヤcls【${N}】です`;
        this.hFactoryCls[N] = B;
      },
      searchPath: (N, B = "") => this.cfg.searchPath(N, B),
      getVal: r.getVal,
      resume: () => S.resume(),
      render: (N, B, $ = !1) => this.appPixi.renderer.render(N, { renderTexture: B, clear: $ }),
      setDec: (N) => at(this, cs, N),
      setEnc: (N) => this.enc = N,
      getStK: (N) => this.stk = N,
      getHash: (N) => this.hash = N
    }));
  }
  get cvsWidth() {
    return z(this, Lr);
  }
  get cvsHeight() {
    return z(this, Jr);
  }
  get cvsScale() {
    return z(this, Qr);
  }
  get ofsLeft4elm() {
    return z(this, us);
  }
  get ofsTop4elm() {
    return z(this, hs);
  }
  get ofsPadLeft_Dom2PIXI() {
    return z(this, Ji);
  }
  get ofsPadTop_Dom2PIXI() {
    return z(this, Qi);
  }
  cvsResize() {
    var B;
    let t = globalThis.innerWidth, e = globalThis.innerHeight;
    const r = Main.cvs, S = r.parentElement !== document.body;
    if (S) {
      const $ = globalThis.getComputedStyle(r);
      t = parseFloat($.width), e = parseFloat($.height);
    }
    if (CmnLib.isMobile) {
      const U = (((B = screen.orientation) == null ? void 0 : B.angle) ?? 0) % 180 === 0;
      (U && t > e || !U && t < e) && ([t, e] = [e, t]);
    }
    const T = r.getBoundingClientRect();
    if (argChk_Boolean(CmnLib.hDip, "expanding", !0) || S || CmnLib.stageW > t || CmnLib.stageH > e)
      if (CmnLib.stageW / CmnLib.stageH <= t / e ? (at(this, Jr, e), at(this, Lr, CmnLib.stageW / CmnLib.stageH * e)) : (at(this, Lr, t), at(this, Jr, CmnLib.stageH / CmnLib.stageW * t)), at(this, Qr, z(this, Lr) / CmnLib.stageW), S)
        at(this, Ji, 0), at(this, Qi, 0);
      else {
        const $ = 1 - z(this, Qr);
        CmnLib.isMobile ? (at(this, Ji, (t - z(this, Lr)) / 2 * $), at(this, Qi, (e - z(this, Jr)) / 2 * $)) : (at(this, Ji, T.left * $), at(this, Qi, T.top * $));
      }
    else
      at(this, Lr, CmnLib.stageW), at(this, Jr, CmnLib.stageH), at(this, Qr, 1), at(this, Ji, 0), at(this, Qi, 0);
    const D = r.parentElement.style;
    S || (D.position = "relative", D.width = `${z(this, Lr)}px`, D.height = `${z(this, Jr)}px`);
    const N = r.style;
    N.width = D.width, N.height = D.height, S ? (at(this, us, T.left), at(this, hs, T.top)) : (at(this, us, 0), at(this, hs, 0)), this.isFullScr && (at(this, us, z(this, us) + (t - z(this, Lr)) / 2), at(this, hs, z(this, hs) + (e - z(this, Jr)) / 2));
  }
  // デバッガ接続
  attach_debug(t) {
    this.attach_debug = () => {
    };
    const e = document.createElement("style");
    e.innerHTML = `/* SKYNovel Dbg */
.sn_BounceInOut { animation: sn_kfBounceInOut linear 1.5s; }
@keyframes sn_kfBounceInOut{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
10%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
20%	{				transform: scaleX(0.95) scaleY(0.95);}
30%	{				transform: scaleX(1.00) scaleY(1.00);}
70%	{opacity: 1;}
100%{opacity: 0;}
}
.sn_BounceIn { animation: sn_kfBounceIn linear 0.3s; }
@keyframes sn_kfBounceIn{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
50%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
100%{				transform: scaleX(0.95) scaleY(0.95);}
}
.sn_HopIn { animation: sn_kfHopIn linear 0.8s; }
@keyframes sn_kfHopIn{
0%	{transform:	translate(0px,   0px);}
15% {transform:	translate(0px, -25px);}
30% {transform:	translate(0px,   0px);}
45% {transform:	translate(0px, -15px);}
60% {transform:	translate(0px,   0px);}
75% {transform:	translate(0px,  -5px);}
100%{transform:	translate(0px,   0px);}
}`, document.getElementsByTagName("head")[0].appendChild(e), this.addHook((r, S) => {
      var T, D;
      return (D = (T = z(this, Lc))[r]) == null ? void 0 : D.call(T, S);
    }), at(this, tn, lookup(`http://localhost:${this.extPort}`)), z(this, tn).on("data", (r, S) => {
      this.callHook(r, S);
    }).on("disconnect", () => t.setLoop(!0)), this.callHook = (r, S) => {
      for (const T of z(this, Kl))
        T(r, S);
    };
  }
  end() {
    var t;
    (t = z(this, tn)) == null || t.disconnect(), at(this, tn, void 0);
  }
  toast(t) {
    const e = document.body;
    e.querySelectorAll(".sn_BounceIn, .sn_HopIn").forEach((D) => e.removeChild(D));
    const r = document.createElement("img"), S = z($c, kc)[t];
    r.src = `data:image/svg+xml;base64,${S.dat}`;
    const T = Math.min(CmnLib.stageW, CmnLib.stageH) / 4 * z(this, Qr);
    r.width = r.height = T, r.style.cssText = `position: absolute;
left: ${(CmnLib.stageW - T) / 2 * z(this, Qr) + T * (S.dx ?? 0)}px;
top: ${(CmnLib.stageH - T) / 2 * z(this, Qr) + T * (S.dy ?? 0)}px;`, r.classList.add("sn_toast", S.ease ?? "sn_BounceInOut"), S.ease || r.addEventListener("animationend", () => e.removeChild(r), { once: !0, passive: !0 }), e.insertBefore(r, Main.cvs);
  }
  setFire(t) {
    this.fire = t;
  }
  addHook(t) {
    z(this, Kl).push(t);
  }
  titleSub(t) {
  }
  tglFlscr_sub() {
  }
  setTitleInfo(t) {
    at(this, ka, t), this.titleSub(z(this, La) + z(this, ka));
  }
  decStr(t, e) {
    return z(this, cs).call(this, t, e).ret;
  }
  async dec(t, e) {
    const { ret: r, ext_num: S } = z(this, cs).call(this, t, e), T = z(this, Fc)[S];
    return T != null && T.fnc ? await T.fnc(new Blob([r], { type: T.mime })) : r;
  }
  get path_downloads() {
    return this.$path_downloads;
  }
  get path_userdata() {
    return this.$path_userdata;
  }
  async savePic(t, e) {
  }
  async appendFile(t, e, r) {
  }
  async ensureFileSync(t) {
  }
};
let SysBase = $c;
Lr = new WeakMap(), Jr = new WeakMap(), Qr = new WeakMap(), us = new WeakMap(), hs = new WeakMap(), Ji = new WeakMap(), Qi = new WeakMap(), tn = new WeakMap(), Lc = new WeakMap(), kc = new WeakMap(), Kl = new WeakMap(), La = new WeakMap(), Bc = new WeakMap(), ka = new WeakMap(), cs = new WeakMap(), Fc = new WeakMap(), fs = new WeakMap(), Ba = new WeakMap(), Pt(SysBase, "VALNM_CFG_NS", "const.sn.cfg.ns"), tt(SysBase, kc, {
  // Thanks ICOOON MONO https://icooon-mono.com/ 、 https://vectr.com/ で 640x640化、ImageOptim経由、Base64エンコーダー https://lab.syncer.jp/Tool/Base64-encode/ 
  接続: { dx: -1, dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMCAyOTJ2NTUuODhoMTI3LjEzYzEyLjM3IDQ2IDU0LjEyIDc5Ljg3IDEwNCA3OS44N2g3Ny44N3YtMjE1LjYyYy00Ni43MyAwLTcyLjY4IDAtNzcuODggMC00OS43NCAwLTkxLjYyIDMzLjg3LTEwMy45OSA3OS44Ny0xNi45NSAwLTU5LjMzIDAtMTI3LjEzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im01MTIuODggMjkyYy0xMi4zOC00Ni01NC4xMy03OS44Ny0xMDQtNzkuODctNS4yMSAwLTMxLjIxIDAtNzggMHYyMTUuNzRoNzcuODdjNDkuODggMCA5MS43NS0zMy44NyAxMDQtNzkuODdoMTI3LjI1di01NmMtNzYuMjcgMC0xMTguNjUgMC0xMjcuMTIgMHoiLz48L2RlZnM+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9IiMzYWFiZDIiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYiIvPjx1c2UgZmlsbD0iIzNhYWJkMiIgeGxpbms6aHJlZj0iI2MiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNjIi8+PC9zdmc+" },
  切断: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMTkxLjUzIDIyMS4yNGMtNDUuNjggMC04NC4wMSAzMS4wNC05NS4zIDczLjE2LTYuNDEgMC0zOC40OSAwLTk2LjIzIDB2NTEuMjFoOTYuMjNjMTEuMyA0Mi4xMSA0OS42MyA3My4xNiA5NS4zIDczLjE2aDcxLjMzdi00OC4yNGg1My43OHYtMTAxLjA1aC01My43OHYtNDguMjRjLTQyLjggMC02Ni41NyAwLTcxLjMzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im00NDguNDcgMjIxLjIzYy00Ljc2IDAtMjguNTMgMC03MS4zMyAwdjE5Ny41M2g3MS4zM2M0NS42OCAwIDgzLjk5LTMxLjA0IDk1LjI5LTczLjE1aDk2LjI0di01MS4yMWgtOTYuMjRjLTMzLjA4LTQ4Ljc4LTY0Ljg0LTczLjE3LTk1LjI5LTczLjE3eiIvPjwvZGVmcz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0iI2RmNTY1NiIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSIjZGY1NjU2IiB4bGluazpocmVmPSIjYyIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2MiLz48L3N2Zz4=" },
  再生: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yNTguODMgMTExLjA1Yy0xLjI5Ljc5LTIuOTMuODMtNC4yNi4wNC0xLjI5LS43NC0yLjExLTIuMTItMi4xMS0zLjY3IDAtNy4xNiAwLTQyLjk3IDAtMTA3LjQzczAtMTAwLjI3IDAtMTA3LjQzYzAtMS41My44Mi0yLjkzIDIuMTEtMy42OCAxLjMzLS43NiAyLjk3LS43MiA0LjI2LjA0IDE4IDEwLjc1IDE2MiA5Ni43MSAxODAgMTA3LjQ2IDEuMjkuNzMgMi4wNSAyLjE0IDIuMDUgMy42MSAwIDEuNDktLjc2IDIuODgtMi4wNSAzLjYzLTM2IDIxLjQ5LTE2MiA5Ni42OS0xODAgMTA3LjQzeiIvPjwvZGVmcz48cGF0aCBkPSJtMTU0LjU3IDE3MC4xOWgzNDYuMTV2MzA3LjY5aC0zNDYuMTV6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
  一時停止: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yMDAgMTAwdi0yMDBoODB2MjAwem0xNjAgMHYtMjAwaDgwdjIwMHoiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxODAuNDFoMzUyLjR2MjgyLjY5aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
  注意: { ease: "sn_HopIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMzQzLjM0IDI5LjJjLTEwLjM3LTE3Ljk3LTM2LjMxLTE3Ljk3LTQ2LjY5IDAtMjkuMyA1MC43NS0yNjMuNyA0NTYuNzQtMjkzIDUwNy40OS0xMC4zNyAxNy45NyAyLjU5IDQwLjQ0IDIzLjM0IDQwLjQ0aDU4Ni4wMWMyMC43NSAwIDMzLjcyLTIyLjQ2IDIzLjM1LTQwLjQ0LTU4LjYtMTAxLjUtMjYzLjctNDU2Ljc0LTI5My4wMS01MDcuNDl6bS0yMy4zNCA0ODIuODNjLTE0LjUyIDAtMjYuMjktMi43MS0yNi4yOS02LjA2IDAtNC4yMSAwLTM3Ljg2IDAtNDIuMDcgMC0zLjM1IDExLjc3LTYuMDcgMjYuMjktNi4wN3MyNi4yOSAyLjcyIDI2LjI5IDYuMDd2NDIuMDdjLTcuODQgNC4wNC0xNi42MSA2LjA2LTI2LjI5IDYuMDZ6bTIxLjk5LTEwMy44NGMwIDUuNDMtOS44NSA5LjgzLTIxLjk5IDkuODMtMTIuMTUgMC0yMS45OS00LjQtMjEuOTktOS44MyAwLS4xMy4wNy0uMjUuMDgtLjM4LTEuMzctMTcuNTYtMTIuMy0xNTguMDYtMTMuNjctMTc1LjYyIDAtNS40MyAxNS45My05Ljg0IDM1LjU4LTkuODRzMzUuNTggNC40MSAzNS41OCA5Ljg0Yy0uOTEgMTEuNy01LjQ3IDcwLjI1LTEzLjY3IDE3NS42Mi4wNi4xNi4wOC4yOS4wOC4zOHoiLz48L2RlZnM+PHBhdGggZD0ibTI0MS4yOSAxOTEuNDRoMTQ1LjQ5djM1MS42NmgtMTQ1LjQ5eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iI2QyYmYzYSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
  一歩進む: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0zNzYuOTMgOTEuOTdjMC01My41MSAwLTgzLjI0IDAtODkuMTktLjE1LjE0LS4yNS4zNC0uNDQuNDUtMTYuMTEgOS42Mi0xNDQuOTUgODYuNTQtMTYxLjA2IDk2LjE1LTEuMTUuNjktMi42Mi43My0zLjgxLjAyLTEuMTUtLjY0LTEuODktMS44OS0xLjg5LTMuMjggMC02LjQxIDAtMzguNDQgMC05Ni4xMSAwLTU3LjY5IDAtODkuNzQgMC05Ni4xNSAwLTEuMzUuNzQtMi42MiAxLjg5LTMuMjkgMS4xOS0uNjggMi42Ni0uNjQgMy44MS4wNCAxNi4xMSA5LjYyIDE0NC45NSA4Ni41NCAxNjEuMDYgOTYuMTYuMTkuMS4yOS4zMS40NC40NSAwLTYuMTMgMC0zNi43NyAwLTkxLjkyaDUzLjMydjE4Ni42N3oiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxNTQuMmgzNTIuNHYzMDguOWgtMzUyLjR6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
  一歩戻る: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem00MzAuMjcgOTYuMTRjMCAxLjM1LS43NCAyLjYyLTEuODkgMy4yOC0xLjE5LjY5LTIuNjYuNjUtMy44MS0uMDMtMTYuMTEtOS42Mi0xNDQuOTUtODYuNTQtMTYxLjA1LTk2LjE2LS4yLS4xLS4yOS0uMzEtLjQ1LS40NXY5MS45MmgtNTMuMzJ2LTE4Ni42N2g1My4zMnY4OS4xOWMuMTYtLjE0LjI1LS4zNC40NS0uNDUgMTYuMS05LjYyIDE0NC45NC04Ni41NCAxNjEuMDUtOTYuMTYgMS4xNS0uNjggMi42Mi0uNzIgMy44MS0uMDEgMS4xNS42NCAxLjg5IDEuODkgMS44OSAzLjI4djk2LjExeiIvPjwvZGVmcz48cGF0aCBkPSJtMTQ3LjQ5IDE1NC4yaDM1Mi40djMwOC45aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
  ステップイン: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMTkuOTljMCAxNzYuNzQgMTQzLjI3IDMyMC4wMSAzMjAuMDEgMzIwLjAxIDE3Ni43MiAwIDMxOS45OS0xNDMuMjcgMzE5Ljk5LTMyMC4wMSAwLTE3Ni43Mi0xNDMuMjctMzE5Ljk5LTMxOS45OS0zMTkuOTktMTc2Ljc0IDAtMzIwLjAxIDE0My4yNy0zMjAuMDEgMzE5Ljk5em0xNTMuMDUtMjkuNzIgNTUuMTItNTUuMTMgMTExLjg0IDExMS44MiAxMTEuODItMTExLjgyIDU1LjEyIDU1LjEyLTE2Ni45NCAxNjYuOTd6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
  ステップアウト: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjAuMDFjMCAxNzYuNzIgMTQzLjI3IDMxOS45OSAzMTkuOTkgMzE5Ljk5IDE3Ni43NCAwIDMyMC4wMS0xNDMuMjcgMzIwLjAxLTMxOS45OSAwLTE3Ni43NC0xNDMuMjctMzIwLjAxLTMyMC4wMS0zMjAuMDEtMTc2LjcyIDAtMzE5Ljk5IDE0My4yNy0zMTkuOTkgMzIwLjAxem0zMTkuOTktMjYuOTgtMTExLjgyIDExMS44My01NS4xMi01NS4xMyAxNjYuOTQtMTY2Ljk2IDE2Ni45NiAxNjYuOTYtNTUuMTIgNTUuMTN6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" }
});
var assign = make_assign(), create$1 = make_create(), trim$1 = make_trim(), Global$5 = typeof window < "u" ? window : commonjsGlobal, util$6 = {
  assign,
  create: create$1,
  trim: trim$1,
  bind: bind$1,
  slice: slice$1,
  each: each$7,
  map,
  pluck: pluck$1,
  isList: isList$1,
  isFunction: isFunction$1,
  isObject: isObject$1,
  Global: Global$5
};
function make_assign() {
  return Object.assign ? Object.assign : function(t, e, r, S) {
    for (var T = 1; T < arguments.length; T++)
      each$7(Object(arguments[T]), function(D, N) {
        t[N] = D;
      });
    return t;
  };
}
function make_create() {
  if (Object.create)
    return function(t, e, r, S) {
      var T = slice$1(arguments, 1);
      return assign.apply(this, [Object.create(t)].concat(T));
    };
  {
    let o = function() {
    };
    return function(e, r, S, T) {
      var D = slice$1(arguments, 1);
      return o.prototype = e, assign.apply(this, [new o()].concat(D));
    };
  }
}
function make_trim() {
  return String.prototype.trim ? function(t) {
    return String.prototype.trim.call(t);
  } : function(t) {
    return t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  };
}
function bind$1(o, t) {
  return function() {
    return t.apply(o, Array.prototype.slice.call(arguments, 0));
  };
}
function slice$1(o, t) {
  return Array.prototype.slice.call(o, t || 0);
}
function each$7(o, t) {
  pluck$1(o, function(e, r) {
    return t(e, r), !1;
  });
}
function map(o, t) {
  var e = isList$1(o) ? [] : {};
  return pluck$1(o, function(r, S) {
    return e[S] = t(r, S), !1;
  }), e;
}
function pluck$1(o, t) {
  if (isList$1(o)) {
    for (var e = 0; e < o.length; e++)
      if (t(o[e], e))
        return o[e];
  } else
    for (var r in o)
      if (o.hasOwnProperty(r) && t(o[r], r))
        return o[r];
}
function isList$1(o) {
  return o != null && typeof o != "function" && typeof o.length == "number";
}
function isFunction$1(o) {
  return o && {}.toString.call(o) === "[object Function]";
}
function isObject$1(o) {
  return o && {}.toString.call(o) === "[object Object]";
}
var util$5 = util$6, slice = util$5.slice, pluck = util$5.pluck, each$6 = util$5.each, bind = util$5.bind, create = util$5.create, isList = util$5.isList, isFunction = util$5.isFunction, isObject = util$5.isObject, storeEngine = {
  createStore
}, storeAPI = {
  version: "2.0.12",
  enabled: !1,
  // get returns the value of the given key. If that value
  // is undefined, it returns optionalDefaultValue instead.
  get: function(o, t) {
    var e = this.storage.read(this._namespacePrefix + o);
    return this._deserialize(e, t);
  },
  // set will store the given value at key and returns value.
  // Calling set with value === undefined is equivalent to calling remove.
  set: function(o, t) {
    return t === void 0 ? this.remove(o) : (this.storage.write(this._namespacePrefix + o, this._serialize(t)), t);
  },
  // remove deletes the key and value stored at the given key.
  remove: function(o) {
    this.storage.remove(this._namespacePrefix + o);
  },
  // each will call the given callback once for each key-value pair
  // in this store.
  each: function(o) {
    var t = this;
    this.storage.each(function(e, r) {
      o.call(t, t._deserialize(e), (r || "").replace(t._namespaceRegexp, ""));
    });
  },
  // clearAll will remove all the stored key-value pairs in this store.
  clearAll: function() {
    this.storage.clearAll();
  },
  // additional functionality that can't live in plugins
  // ---------------------------------------------------
  // hasNamespace returns true if this store instance has the given namespace.
  hasNamespace: function(o) {
    return this._namespacePrefix == "__storejs_" + o + "_";
  },
  // createStore creates a store.js instance with the first
  // functioning storage in the list of storage candidates,
  // and applies the the given mixins to the instance.
  createStore: function() {
    return createStore.apply(this, arguments);
  },
  addPlugin: function(o) {
    this._addPlugin(o);
  },
  namespace: function(o) {
    return createStore(this.storage, this.plugins, o);
  }
};
function _warn() {
  var o = typeof console > "u" ? null : console;
  if (o) {
    var t = o.warn ? o.warn : o.log;
    t.apply(o, arguments);
  }
}
function createStore(o, t, e) {
  e || (e = ""), o && !isList(o) && (o = [o]), t && !isList(t) && (t = [t]);
  var r = e ? "__storejs_" + e + "_" : "", S = e ? new RegExp("^" + r) : null, T = /^[a-zA-Z0-9_\-]*$/;
  if (!T.test(e))
    throw new Error("store.js namespaces can only have alphanumerics + underscores and dashes");
  var D = {
    _namespacePrefix: r,
    _namespaceRegexp: S,
    _testStorage: function(B) {
      try {
        var $ = "__storejs__test__";
        B.write($, $);
        var U = B.read($) === $;
        return B.remove($), U;
      } catch {
        return !1;
      }
    },
    _assignPluginFnProp: function(B, $) {
      var U = this[$];
      this[$] = function() {
        var V = slice(arguments, 0), X = this;
        function W() {
          if (U)
            return each$6(arguments, function(q, K) {
              V[K] = q;
            }), U.apply(X, V);
        }
        var Y = [W].concat(V);
        return B.apply(X, Y);
      };
    },
    _serialize: function(B) {
      return JSON.stringify(B);
    },
    _deserialize: function(B, $) {
      if (!B)
        return $;
      var U = "";
      try {
        U = JSON.parse(B);
      } catch {
        U = B;
      }
      return U !== void 0 ? U : $;
    },
    _addStorage: function(B) {
      this.enabled || this._testStorage(B) && (this.storage = B, this.enabled = !0);
    },
    _addPlugin: function(B) {
      var $ = this;
      if (isList(B)) {
        each$6(B, function(V) {
          $._addPlugin(V);
        });
        return;
      }
      var U = pluck(this.plugins, function(V) {
        return B === V;
      });
      if (!U) {
        if (this.plugins.push(B), !isFunction(B))
          throw new Error("Plugins must be function values that return objects");
        var H = B.call(this);
        if (!isObject(H))
          throw new Error("Plugins must return an object of function properties");
        each$6(H, function(V, X) {
          if (!isFunction(V))
            throw new Error("Bad plugin property: " + X + " from plugin " + B.name + ". Plugins should only return functions.");
          $._assignPluginFnProp(V, X);
        });
      }
    },
    // Put deprecated properties in the private API, so as to not expose it to accidential
    // discovery through inspection of the store object.
    // Deprecated: addStorage
    addStorage: function(B) {
      _warn("store.addStorage(storage) is deprecated. Use createStore([storages])"), this._addStorage(B);
    }
  }, N = create(D, storeAPI, {
    plugins: []
  });
  return N.raw = {}, each$6(N, function(B, $) {
    isFunction(B) && (N.raw[$] = bind(N, B));
  }), each$6(o, function(B) {
    N._addStorage(B);
  }), each$6(t, function(B) {
    N._addPlugin(B);
  }), N;
}
var util$4 = util$6, Global$4 = util$4.Global, localStorage_1 = {
  name: "localStorage",
  read: read$5,
  write: write$5,
  each: each$5,
  remove: remove$5,
  clearAll: clearAll$5
};
function localStorage() {
  return Global$4.localStorage;
}
function read$5(o) {
  return localStorage().getItem(o);
}
function write$5(o, t) {
  return localStorage().setItem(o, t);
}
function each$5(o) {
  for (var t = localStorage().length - 1; t >= 0; t--) {
    var e = localStorage().key(t);
    o(read$5(e), e);
  }
}
function remove$5(o) {
  return localStorage().removeItem(o);
}
function clearAll$5() {
  return localStorage().clear();
}
var util$3 = util$6, Global$3 = util$3.Global, oldFFGlobalStorage = {
  name: "oldFF-globalStorage",
  read: read$4,
  write: write$4,
  each: each$4,
  remove: remove$4,
  clearAll: clearAll$4
}, globalStorage = Global$3.globalStorage;
function read$4(o) {
  return globalStorage[o];
}
function write$4(o, t) {
  globalStorage[o] = t;
}
function each$4(o) {
  for (var t = globalStorage.length - 1; t >= 0; t--) {
    var e = globalStorage.key(t);
    o(globalStorage[e], e);
  }
}
function remove$4(o) {
  return globalStorage.removeItem(o);
}
function clearAll$4() {
  each$4(function(o, t) {
    delete globalStorage[o];
  });
}
var util$2 = util$6, Global$2 = util$2.Global, oldIEUserDataStorage = {
  name: "oldIE-userDataStorage",
  write: write$3,
  read: read$3,
  each: each$3,
  remove: remove$3,
  clearAll: clearAll$3
}, storageName = "storejs", doc$1 = Global$2.document, _withStorageEl = _makeIEStorageElFunction(), disable = (Global$2.navigator ? Global$2.navigator.userAgent : "").match(/ (MSIE 8|MSIE 9|MSIE 10)\./);
function write$3(o, t) {
  if (!disable) {
    var e = fixKey(o);
    _withStorageEl(function(r) {
      r.setAttribute(e, t), r.save(storageName);
    });
  }
}
function read$3(o) {
  if (!disable) {
    var t = fixKey(o), e = null;
    return _withStorageEl(function(r) {
      e = r.getAttribute(t);
    }), e;
  }
}
function each$3(o) {
  _withStorageEl(function(t) {
    for (var e = t.XMLDocument.documentElement.attributes, r = e.length - 1; r >= 0; r--) {
      var S = e[r];
      o(t.getAttribute(S.name), S.name);
    }
  });
}
function remove$3(o) {
  var t = fixKey(o);
  _withStorageEl(function(e) {
    e.removeAttribute(t), e.save(storageName);
  });
}
function clearAll$3() {
  _withStorageEl(function(o) {
    var t = o.XMLDocument.documentElement.attributes;
    o.load(storageName);
    for (var e = t.length - 1; e >= 0; e--)
      o.removeAttribute(t[e].name);
    o.save(storageName);
  });
}
var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g");
function fixKey(o) {
  return o.replace(/^\d/, "___$&").replace(forbiddenCharsRegex, "___");
}
function _makeIEStorageElFunction() {
  if (!doc$1 || !doc$1.documentElement || !doc$1.documentElement.addBehavior)
    return null;
  var o = "script", t, e, r;
  try {
    e = new ActiveXObject("htmlfile"), e.open(), e.write("<" + o + ">document.w=window</" + o + '><iframe src="/favicon.ico"></iframe>'), e.close(), t = e.w.frames[0].document, r = t.createElement("div");
  } catch {
    r = doc$1.createElement("div"), t = doc$1.body;
  }
  return function(S) {
    var T = [].slice.call(arguments, 0);
    T.unshift(r), t.appendChild(r), r.addBehavior("#default#userData"), r.load(storageName), S.apply(this, T), t.removeChild(r);
  };
}
var util$1 = util$6, Global$1 = util$1.Global, trim = util$1.trim, cookieStorage = {
  name: "cookieStorage",
  read: read$2,
  write: write$2,
  each: each$2,
  remove: remove$2,
  clearAll: clearAll$2
}, doc = Global$1.document;
function read$2(o) {
  if (!o || !_has(o))
    return null;
  var t = "(?:^|.*;\\s*)" + escape(o).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*";
  return unescape(doc.cookie.replace(new RegExp(t), "$1"));
}
function each$2(o) {
  for (var t = doc.cookie.split(/; ?/g), e = t.length - 1; e >= 0; e--)
    if (trim(t[e])) {
      var r = t[e].split("="), S = unescape(r[0]), T = unescape(r[1]);
      o(T, S);
    }
}
function write$2(o, t) {
  o && (doc.cookie = escape(o) + "=" + escape(t) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/");
}
function remove$2(o) {
  !o || !_has(o) || (doc.cookie = escape(o) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/");
}
function clearAll$2() {
  each$2(function(o, t) {
    remove$2(t);
  });
}
function _has(o) {
  return new RegExp("(?:^|;\\s*)" + escape(o).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=").test(doc.cookie);
}
var util = util$6, Global = util.Global, sessionStorage_1 = {
  name: "sessionStorage",
  read: read$1,
  write: write$1,
  each: each$1,
  remove: remove$1,
  clearAll: clearAll$1
};
function sessionStorage$1() {
  return Global.sessionStorage;
}
function read$1(o) {
  return sessionStorage$1().getItem(o);
}
function write$1(o, t) {
  return sessionStorage$1().setItem(o, t);
}
function each$1(o) {
  for (var t = sessionStorage$1().length - 1; t >= 0; t--) {
    var e = sessionStorage$1().key(t);
    o(read$1(e), e);
  }
}
function remove$1(o) {
  return sessionStorage$1().removeItem(o);
}
function clearAll$1() {
  return sessionStorage$1().clear();
}
var memoryStorage_1 = {
  name: "memoryStorage",
  read,
  write,
  each,
  remove,
  clearAll
}, memoryStorage = {};
function read(o) {
  return memoryStorage[o];
}
function write(o, t) {
  memoryStorage[o] = t;
}
function each(o) {
  for (var t in memoryStorage)
    memoryStorage.hasOwnProperty(t) && o(memoryStorage[t], t);
}
function remove(o) {
  delete memoryStorage[o];
}
function clearAll(o) {
  memoryStorage = {};
}
var all = [
  // Listed in order of usage preference
  localStorage_1,
  oldFFGlobalStorage,
  oldIEUserDataStorage,
  cookieStorage,
  sessionStorage_1,
  memoryStorage_1
], json2$1 = {}, hasRequiredJson2;
function requireJson2() {
  return hasRequiredJson2 || (hasRequiredJson2 = 1, typeof JSON != "object" && (JSON = {}), function() {
    var rx_one = /^[\],:{}\s]*$/, rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, rx_four = /(?:^|:|,)(?:\s*\[)+/g, rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    function f(o) {
      return o < 10 ? "0" + o : o;
    }
    function this_value() {
      return this.valueOf();
    }
    typeof Date.prototype.toJSON != "function" && (Date.prototype.toJSON = function() {
      return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null;
    }, Boolean.prototype.toJSON = this_value, Number.prototype.toJSON = this_value, String.prototype.toJSON = this_value);
    var gap, indent, meta, rep;
    function quote(o) {
      return rx_escapable.lastIndex = 0, rx_escapable.test(o) ? '"' + o.replace(rx_escapable, function(t) {
        var e = meta[t];
        return typeof e == "string" ? e : "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + o + '"';
    }
    function str(o, t) {
      var e, r, S, T, D = gap, N, B = t[o];
      switch (B && typeof B == "object" && typeof B.toJSON == "function" && (B = B.toJSON(o)), typeof rep == "function" && (B = rep.call(t, o, B)), typeof B) {
        case "string":
          return quote(B);
        case "number":
          return isFinite(B) ? String(B) : "null";
        case "boolean":
        case "null":
          return String(B);
        case "object":
          if (!B)
            return "null";
          if (gap += indent, N = [], Object.prototype.toString.apply(B) === "[object Array]") {
            for (T = B.length, e = 0; e < T; e += 1)
              N[e] = str(e, B) || "null";
            return S = N.length === 0 ? "[]" : gap ? `[
` + gap + N.join(`,
` + gap) + `
` + D + "]" : "[" + N.join(",") + "]", gap = D, S;
          }
          if (rep && typeof rep == "object")
            for (T = rep.length, e = 0; e < T; e += 1)
              typeof rep[e] == "string" && (r = rep[e], S = str(r, B), S && N.push(quote(r) + (gap ? ": " : ":") + S));
          else
            for (r in B)
              Object.prototype.hasOwnProperty.call(B, r) && (S = str(r, B), S && N.push(quote(r) + (gap ? ": " : ":") + S));
          return S = N.length === 0 ? "{}" : gap ? `{
` + gap + N.join(`,
` + gap) + `
` + D + "}" : "{" + N.join(",") + "}", gap = D, S;
      }
    }
    typeof JSON.stringify != "function" && (meta = {
      // table of character substitutions
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    }, JSON.stringify = function(o, t, e) {
      var r;
      if (gap = "", indent = "", typeof e == "number")
        for (r = 0; r < e; r += 1)
          indent += " ";
      else
        typeof e == "string" && (indent = e);
      if (rep = t, t && typeof t != "function" && (typeof t != "object" || typeof t.length != "number"))
        throw new Error("JSON.stringify");
      return str("", { "": o });
    }), typeof JSON.parse != "function" && (JSON.parse = function(text, reviver) {
      var j;
      function walk(o, t) {
        var e, r, S = o[t];
        if (S && typeof S == "object")
          for (e in S)
            Object.prototype.hasOwnProperty.call(S, e) && (r = walk(S, e), r !== void 0 ? S[e] = r : delete S[e]);
        return reviver.call(o, t, S);
      }
      if (text = String(text), rx_dangerous.lastIndex = 0, rx_dangerous.test(text) && (text = text.replace(rx_dangerous, function(o) {
        return "\\u" + ("0000" + o.charCodeAt(0).toString(16)).slice(-4);
      })), rx_one.test(
        text.replace(rx_two, "@").replace(rx_three, "]").replace(rx_four, "")
      ))
        return j = eval("(" + text + ")"), typeof reviver == "function" ? walk({ "": j }, "") : j;
      throw new SyntaxError("JSON.parse");
    });
  }()), json2$1;
}
var json2 = json2Plugin;
function json2Plugin() {
  return requireJson2(), {};
}
var engine = storeEngine, storages = all, plugins = [json2], store_legacy = engine.createStore(storages, plugins);
/*!
devtools-detect
https://github.com/sindresorhus/devtools-detect
By Sindre Sorhus
MIT License
*/
const devtools = {
  isOpen: !1,
  orientation: void 0
}, threshold = 170, emitEvent = (o, t) => {
  globalThis.dispatchEvent(new globalThis.CustomEvent("devtoolschange", {
    detail: {
      isOpen: o,
      orientation: t
    }
  }));
}, main = ({ emitEvents: o = !0 } = {}) => {
  const t = globalThis.outerWidth - globalThis.innerWidth > threshold, e = globalThis.outerHeight - globalThis.innerHeight > threshold, r = t ? "vertical" : "horizontal";
  !(e && t) && (globalThis.Firebug && globalThis.Firebug.chrome && globalThis.Firebug.chrome.isInitialized || t || e) ? ((!devtools.isOpen || devtools.orientation !== r) && o && emitEvent(!0, r), devtools.isOpen = !0, devtools.orientation = r) : (devtools.isOpen && o && emitEvent(!1, void 0), devtools.isOpen = !1, devtools.orientation = void 0);
};
main({ emitEvents: !1 });
setInterval(main, 500);
var Fa, Zl, Ri, Jl;
class SysWeb extends SysBase {
  constructor(e = {}, r = { cur: "prj/", crypto: !1, dip: "" }) {
    super(e, r);
    tt(this, Fa, "");
    tt(this, Zl, ":");
    Pt(this, "run", async () => {
      z(this, Ri) && (z(this, Ri).destroy(10), await new Promise((r) => setTimeout(r, 10))), at(this, Ri, new Main(this));
    });
    tt(this, Ri, void 0);
    Pt(this, "pathBaseCnvSnPath4Dbg", "${pathbase}/");
    // プレイデータをエクスポート
    Pt(this, "_export", () => ((async () => {
      const e = JSON.stringify({
        sys: this.data.sys,
        mark: this.data.mark,
        kidoku: this.data.kidoku
      }), r = this.crypto ? await this.enc(e) : e, S = new Blob([r], { type: "text/json" }), T = document.createElement("a");
      T.href = URL.createObjectURL(S), T.download = (this.crypto ? "" : "no_crypto_") + this.cfg.getNs() + getDateStr("-", "_", "") + ".swpd", T.click(), CmnLib.debugLog && console.log("プレイデータをエクスポートしました"), setTimeout(() => this.fire("sn:exported", new Event("click")), 10);
    })(), !1));
    // プレイデータをインポート
    Pt(this, "_import", () => (new Promise((e, r) => {
      const S = document.createElement("input");
      S.type = "file", S.accept = ".swpd, text/plain", S.onchange = () => {
        S.files ? e(S.files[0]) : r();
      }, S.click();
    }).then((e) => new Promise((r) => {
      const S = new FileReader();
      S.readAsText(e), S.onload = () => r(S.result);
    })).then(async (e) => {
      const r = JSON.parse(this.crypto ? this.decStr("json", e) : e);
      if (!r.sys || !r.mark || !r.kidoku)
        throw new Error("異常なプレイデータです");
      if (r.sys[SysBase.VALNM_CFG_NS] !== this.cfg.oCfg.save_ns) {
        console.error(`別のゲーム【プロジェクト名=${r.sys[SysBase.VALNM_CFG_NS]}】のプレイデータです`);
        return;
      }
      this.data.sys = r.sys, this.data.mark = r.mark, this.data.kidoku = r.kidoku, this.flush(), this.val.updateData(r), CmnLib.debugLog && console.log("プレイデータをインポートしました"), this.fire("sn:imported", new Event("click"));
    }).catch((e) => console.error(`異常なプレイデータです ${e.message}`)), !1));
    // ＵＲＬを開く
    Pt(this, "navigate_to", (e) => {
      const { url: r } = e;
      if (!r)
        throw "[navigate_to] urlは必須です";
      return globalThis.open(r, "_blank"), !1;
    });
    tt(this, Jl, {});
    const S = r.cur.split("/");
    at(this, Fa, S.length > 2 ? S.slice(0, -2).join("/") + "/" : ""), globalThis.onload = async () => this.loaded(e, r);
  }
  async loaded(e, r) {
    await super.loaded(e, r), document.querySelectorAll("[data-prj]").forEach((N) => {
      const B = N.attributes.getNamedItem("data-prj");
      B && N.addEventListener("click", () => this.runSN(B.value), { passive: !0 });
    }), document.querySelectorAll("[data-reload]").forEach(
      (N) => N.addEventListener("click", () => this.run(), { passive: !0 })
      //this.elc.add(v, 'click', ()=> this.run(), {passive: true})
      // ギャラリーであっても、ここには一度しか来ないので
    ), r.dip && (CmnLib.hDip = JSON.parse(r.dip));
    const S = new URLSearchParams(location.search), T = S.get("dip");
    if (T && (CmnLib.hDip = { ...CmnLib.hDip, ...JSON.parse(T.replaceAll("%2C", ",")) }), !argChk_Boolean(CmnLib.hDip, "oninit_run", !0))
      return;
    argChk_Boolean(CmnLib.hDip, "dbg", !1) && (CmnLib.isDbg = !0, this.fetch = (N) => fetch(N, { mode: "cors" })), this.extPort = argChk_Num(CmnLib.hDip, "port", this.extPort);
    const D = S.get("cur");
    D && (r.cur = z(this, Fa) + D + "/"), this.run();
  }
  runSN(e) {
    this.arg.cur = z(this, Fa) + e + "/", z(this, Zl) !== this.arg.cur && (at(this, Zl, this.arg.cur), this.run());
  }
  stop() {
    z(this, Ri) && (z(this, Ri).destroy(), at(this, Ri, void 0));
  }
  async loadPath(e, r) {
    await super.loadPath(e, r);
    const S = this.arg.cur + "path.json", T = await fetch(S);
    if (!T.ok)
      throw Error(T.statusText);
    const D = await T.text(), N = JSON.parse(this.decStr(S, D));
    for (const [B, $] of Object.entries(N)) {
      const U = e[B] = $;
      for (const [H, V] of Object.entries(U))
        H !== ":cnt" && (U[H] = this.arg.cur + V);
    }
  }
  initVal(e, r, S) {
    const T = encodeURIComponent(document.location.hostname);
    r["const.sn.isDebugger"] = T === "localhost" || T === "127.0.0.1";
    const D = this.cfg.getNs();
    this.flush = this.crypto ? async () => {
      store_legacy.set(D + "sys_", this.enc(JSON.stringify(this.data.sys))), store_legacy.set(D + "mark_", this.enc(JSON.stringify(this.data.mark))), store_legacy.set(D + "kidoku_", this.enc(JSON.stringify(this.data.kidoku)));
    } : () => {
      store_legacy.set(D + "sys", this.data.sys), store_legacy.set(D + "mark", this.data.mark), store_legacy.set(D + "kidoku", this.data.kidoku);
    };
    const N = D + (this.arg.crypto ? "sys_" : "sys");
    if (r["const.sn.isFirstBoot"] = store_legacy.get(N) === void 0) {
      this.data.sys = e.sys, this.data.mark = e.mark, this.data.kidoku = e.kidoku, this.flush(), S(this.data);
      return;
    }
    if (!this.crypto) {
      this.data.sys = store_legacy.get(D + "sys"), this.data.mark = store_legacy.get(D + "mark"), this.data.kidoku = store_legacy.get(D + "kidoku"), S(this.data);
      return;
    }
    let B = "";
    try {
      B = "sys", this.data.sys = JSON.parse(this.decStr("json", store_legacy.get(D + "sys_"))), B += Number(this.val.getVal("sys:TextLayer.Back.Alpha", 1)), B = "mark", this.data.mark = JSON.parse(this.decStr("json", store_legacy.get(D + "mark_"))), B = "kidoku", this.data.kidoku = JSON.parse(this.decStr("json", store_legacy.get(D + "kidoku_")));
    } catch ($) {
      console.error(`セーブデータ（${B}）が壊れています。一度クリアする必要があります %o`, $);
    }
    S(this.data);
  }
  init(e, r, S, T) {
    super.init(e, r, S, T);
    const D = r.view.parentElement;
    if ("requestFullscreen" in document.body)
      this.tglFlscr_sub = () => this.isFullScr ? document.exitFullscreen() : D.requestFullscreen(), this.elc.add(document, "fullscreenchange", () => this.isFullScr = Boolean(document.fullscreenElement));
    else {
      const N = document;
      this.tglFlscr_sub = () => this.isFullScr ? N.webkitCancelFullScreen() : D.webkitRequestFullscreen(), this.elc.add(document, "fullscreenchange", () => this.isFullScr = Boolean(N.webkitFullscreenElement));
    }
    return this.cfg.oCfg.debug.devtool || this.elc.add(window, "devtoolschange", (N) => {
      N.detail.isOpen && (console.error("DevToolは禁止されています。許可する場合は【プロジェクト設定】の【devtool】をONに。"), T.destroy());
    }, { once: !0, passive: !0 }), [];
  }
  cvsResize() {
    if (super.cvsResize(), this.isFullScr) {
      const e = Main.cvs.style;
      e.width = e.height = "";
    }
  }
  // タイトル指定
  titleSub(e) {
    document.title = e, document.querySelectorAll("[data-title]").forEach((r) => r.textContent = e);
  }
  async savePic(e, r) {
    const S = document.createElement("a");
    S.href = r, S.download = e, S.click(), CmnLib.debugLog && console.log("画像ファイルをダウンロードします");
  }
  async appendFile(e, r, S) {
    const T = (z(this, Jl)[e] ?? "") + r;
    z(this, Jl)[e] = T;
    const D = new Blob([T], { type: "text/json" }), N = document.createElement("a");
    N.href = URL.createObjectURL(D), N.download = e, N.click();
  }
}
Fa = new WeakMap(), Zl = new WeakMap(), Ri = new WeakMap(), Jl = new WeakMap();
export {
  CmnLib,
  Layer,
  SysWeb,
  argChk_Boolean,
  argChk_Num
};
//# sourceMappingURL=web.js.map
