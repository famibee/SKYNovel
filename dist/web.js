var ah = (o, t, e) => {
  if (!t.has(o))
    throw TypeError("Cannot " + e);
};
var V = (o, t, e) => (ah(o, t, "read from private field"), e ? e.call(o) : t.get(o)), nt = (o, t, e) => {
  if (t.has(o))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(o) : t.set(o, e);
}, it = (o, t, e, R) => (ah(o, t, "write to private field"), R ? R.call(o, e) : t.set(o, e), e), Ae = (o, t, e, R) => ({
  set _(N) {
    it(o, t, N, e);
  },
  get _() {
    return V(o, t, R);
  }
}), ot = (o, t, e) => (ah(o, t, "access private method"), e);
var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, platform$1 = { exports: {} };
/*!
 * Platform.js v1.3.6
 * Copyright 2014-2020 Benjamin Tan
 * Copyright 2011-2013 John-David Dalton
 * Available under MIT license
 */
(function(o, t) {
  (function() {
    var e = {
      function: !0,
      object: !0
    }, R = e[typeof window] && window || this, N = t, M = o && !o.nodeType && o, D = N && M && typeof commonjsGlobal$1 == "object" && commonjsGlobal$1;
    D && (D.global === D || D.window === D || D.self === D) && (R = D);
    var L = Math.pow(2, 53) - 1, B = /\bOpera/, $ = Object.prototype, U = $.hasOwnProperty, H = $.toString;
    function z(rt) {
      return rt = String(rt), rt.charAt(0).toUpperCase() + rt.slice(1);
    }
    function X(rt, at, ut) {
      var dt = {
        "10.0": "10",
        "6.4": "10 Technical Preview",
        "6.3": "8.1",
        "6.2": "8",
        "6.1": "Server 2008 R2 / 7",
        "6.0": "Server 2008 / Vista",
        "5.2": "Server 2003 / XP 64-bit",
        "5.1": "XP",
        "5.01": "2000 SP1",
        "5.0": "2000",
        "4.0": "NT",
        "4.90": "ME"
      };
      return at && ut && /^Win/i.test(rt) && !/^Windows Phone /i.test(rt) && (dt = dt[/[\d.]+$/.exec(rt)]) && (rt = "Windows " + dt), rt = String(rt), at && ut && (rt = rt.replace(RegExp(at, "i"), ut)), rt = W(
        rt.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]
      ), rt;
    }
    function Y(rt, at) {
      var ut = -1, dt = rt ? rt.length : 0;
      if (typeof dt == "number" && dt > -1 && dt <= L)
        for (; ++ut < dt; )
          at(rt[ut], ut, rt);
      else
        q(rt, at);
    }
    function W(rt) {
      return rt = et(rt), /^(?:webOS|i(?:OS|P))/.test(rt) ? rt : z(rt);
    }
    function q(rt, at) {
      for (var ut in rt)
        U.call(rt, ut) && at(rt[ut], ut, rt);
    }
    function Z(rt) {
      return rt == null ? z(rt) : H.call(rt).slice(8, -1);
    }
    function K(rt, at) {
      var ut = rt != null ? typeof rt[at] : "number";
      return !/^(?:boolean|number|string|undefined)$/.test(ut) && (ut == "object" ? !!rt[at] : !0);
    }
    function J(rt) {
      return String(rt).replace(/([ -])(?!$)/g, "$1?");
    }
    function Q(rt, at) {
      var ut = null;
      return Y(rt, function(dt, ct) {
        ut = at(ut, dt, ct, rt);
      }), ut;
    }
    function et(rt) {
      return String(rt).replace(/^ +| +$/g, "");
    }
    function tt(rt) {
      var at = R, ut = rt && typeof rt == "object" && Z(rt) != "String";
      ut && (at = rt, rt = null);
      var dt = at.navigator || {}, ct = dt.userAgent || "";
      rt || (rt = ct);
      var pt = ut ? !!dt.likeChrome : /\bChrome\b/.test(rt) && !/internal|\n/i.test(H.toString()), mt = "Object", vt = ut ? mt : "ScriptBridgingProxyObject", _t = ut ? mt : "Environment", xt = ut && at.java ? "JavaPackage" : Z(at.java), At = ut ? mt : "RuntimeObject", yt = /\bJava/.test(xt) && at.java, ht = yt && Z(at.environment) == _t, bt = yt ? "a" : "\u03B1", Ct = yt ? "b" : "\u03B2", Mt = at.document || {}, wt = at.operamini || at.opera, Lt = B.test(Lt = ut && wt ? wt["[[Class]]"] : Z(wt)) ? Lt : wt = null, ft, Gt = rt, Dt = [], Bt = null, Ot = rt == ct, Et = Ot && wt && typeof wt.version == "function" && wt.version(), Ht, It = Jt([
        { label: "EdgeHTML", pattern: "Edge" },
        "Trident",
        { label: "WebKit", pattern: "AppleWebKit" },
        "iCab",
        "Presto",
        "NetFront",
        "Tasman",
        "KHTML",
        "Gecko"
      ]), St = ae([
        "Adobe AIR",
        "Arora",
        "Avant Browser",
        "Breach",
        "Camino",
        "Electron",
        "Epiphany",
        "Fennec",
        "Flock",
        "Galeon",
        "GreenBrowser",
        "iCab",
        "Iceweasel",
        "K-Meleon",
        "Konqueror",
        "Lunascape",
        "Maxthon",
        { label: "Microsoft Edge", pattern: "(?:Edge|Edg|EdgA|EdgiOS)" },
        "Midori",
        "Nook Browser",
        "PaleMoon",
        "PhantomJS",
        "Raven",
        "Rekonq",
        "RockMelt",
        { label: "Samsung Internet", pattern: "SamsungBrowser" },
        "SeaMonkey",
        { label: "Silk", pattern: "(?:Cloud9|Silk-Accelerated)" },
        "Sleipnir",
        "SlimBrowser",
        { label: "SRWare Iron", pattern: "Iron" },
        "Sunrise",
        "Swiftfox",
        "Vivaldi",
        "Waterfox",
        "WebPositive",
        { label: "Yandex Browser", pattern: "YaBrowser" },
        { label: "UC Browser", pattern: "UCBrowser" },
        "Opera Mini",
        { label: "Opera Mini", pattern: "OPiOS" },
        "Opera",
        { label: "Opera", pattern: "OPR" },
        "Chromium",
        "Chrome",
        { label: "Chrome", pattern: "(?:HeadlessChrome)" },
        { label: "Chrome Mobile", pattern: "(?:CriOS|CrMo)" },
        { label: "Firefox", pattern: "(?:Firefox|Minefield)" },
        { label: "Firefox for iOS", pattern: "FxiOS" },
        { label: "IE", pattern: "IEMobile" },
        { label: "IE", pattern: "MSIE" },
        "Safari"
      ]), Nt = De([
        { label: "BlackBerry", pattern: "BB10" },
        "BlackBerry",
        { label: "Galaxy S", pattern: "GT-I9000" },
        { label: "Galaxy S2", pattern: "GT-I9100" },
        { label: "Galaxy S3", pattern: "GT-I9300" },
        { label: "Galaxy S4", pattern: "GT-I9500" },
        { label: "Galaxy S5", pattern: "SM-G900" },
        { label: "Galaxy S6", pattern: "SM-G920" },
        { label: "Galaxy S6 Edge", pattern: "SM-G925" },
        { label: "Galaxy S7", pattern: "SM-G930" },
        { label: "Galaxy S7 Edge", pattern: "SM-G935" },
        "Google TV",
        "Lumia",
        "iPad",
        "iPod",
        "iPhone",
        "Kindle",
        { label: "Kindle Fire", pattern: "(?:Cloud9|Silk-Accelerated)" },
        "Nexus",
        "Nook",
        "PlayBook",
        "PlayStation Vita",
        "PlayStation",
        "TouchPad",
        "Transformer",
        { label: "Wii U", pattern: "WiiU" },
        "Wii",
        "Xbox One",
        { label: "Xbox 360", pattern: "Xbox" },
        "Xoom"
      ]), $t = Kt({
        Apple: { iPad: 1, iPhone: 1, iPod: 1 },
        Alcatel: {},
        Archos: {},
        Amazon: { Kindle: 1, "Kindle Fire": 1 },
        Asus: { Transformer: 1 },
        "Barnes & Noble": { Nook: 1 },
        BlackBerry: { PlayBook: 1 },
        Google: { "Google TV": 1, Nexus: 1 },
        HP: { TouchPad: 1 },
        HTC: {},
        Huawei: {},
        Lenovo: {},
        LG: {},
        Microsoft: { Xbox: 1, "Xbox One": 1 },
        Motorola: { Xoom: 1 },
        Nintendo: { "Wii U": 1, Wii: 1 },
        Nokia: { Lumia: 1 },
        Oppo: {},
        Samsung: { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 },
        Sony: { PlayStation: 1, "PlayStation Vita": 1 },
        Xiaomi: { Mi: 1, Redmi: 1 }
      }), Rt = Se([
        "Windows Phone",
        "KaiOS",
        "Android",
        "CentOS",
        { label: "Chrome OS", pattern: "CrOS" },
        "Debian",
        { label: "DragonFly BSD", pattern: "DragonFly" },
        "Fedora",
        "FreeBSD",
        "Gentoo",
        "Haiku",
        "Kubuntu",
        "Linux Mint",
        "OpenBSD",
        "Red Hat",
        "SuSE",
        "Ubuntu",
        "Xubuntu",
        "Cygwin",
        "Symbian OS",
        "hpwOS",
        "webOS ",
        "webOS",
        "Tablet OS",
        "Tizen",
        "Linux",
        "Mac OS X",
        "Macintosh",
        "Mac",
        "Windows 98;",
        "Windows "
      ]);
      function Jt(he) {
        return Q(he, function(oe, te) {
          return oe || RegExp("\\b" + (te.pattern || J(te)) + "\\b", "i").exec(rt) && (te.label || te);
        });
      }
      function Kt(he) {
        return Q(he, function(oe, te, Oe) {
          return oe || (te[Nt] || te[/^[a-z]+(?: +[a-z]+\b)*/i.exec(Nt)] || RegExp("\\b" + J(Oe) + "(?:\\b|\\w*\\d)", "i").exec(rt)) && Oe;
        });
      }
      function ae(he) {
        return Q(he, function(oe, te) {
          return oe || RegExp("\\b" + (te.pattern || J(te)) + "\\b", "i").exec(rt) && (te.label || te);
        });
      }
      function Se(he) {
        return Q(he, function(oe, te) {
          var Oe = te.pattern || J(te);
          return !oe && (oe = RegExp("\\b" + Oe + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(rt)) && (oe = X(oe, Oe, te.label || te)), oe;
        });
      }
      function De(he) {
        return Q(he, function(oe, te) {
          var Oe = te.pattern || J(te);
          return !oe && (oe = RegExp("\\b" + Oe + " *\\d+[.\\w_]*", "i").exec(rt) || RegExp("\\b" + Oe + " *\\w+-[\\w]*", "i").exec(rt) || RegExp("\\b" + Oe + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(rt)) && ((oe = String(te.label && !RegExp(Oe, "i").test(te.label) ? te.label : oe).split("/"))[1] && !/[\d.]+/.test(oe[0]) && (oe[0] += " " + oe[1]), te = te.label || te, oe = W(oe[0].replace(RegExp(Oe, "i"), te).replace(RegExp("; *(?:" + te + "[_-])?", "i"), " ").replace(RegExp("(" + te + ")[-_.]?(\\w)", "i"), "$1 $2"))), oe;
        });
      }
      function ee(he) {
        return Q(he, function(oe, te) {
          return oe || (RegExp(te + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(rt) || 0)[1] || null;
        });
      }
      function Re() {
        return this.description || "";
      }
      if (It && (It = [It]), /\bAndroid\b/.test(Rt) && !Nt && (ft = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(rt)) && (Nt = et(ft[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null), $t && !Nt ? Nt = De([$t]) : $t && Nt && (Nt = Nt.replace(RegExp("^(" + J($t) + ")[-_.\\s]", "i"), $t + " ").replace(RegExp("^(" + J($t) + ")[-_.]?(\\w)", "i"), $t + " $2")), (ft = /\bGoogle TV\b/.exec(Nt)) && (Nt = ft[0]), /\bSimulator\b/i.test(rt) && (Nt = (Nt ? Nt + " " : "") + "Simulator"), St == "Opera Mini" && /\bOPiOS\b/.test(rt) && Dt.push("running in Turbo/Uncompressed mode"), St == "IE" && /\blike iPhone OS\b/.test(rt) ? (ft = tt(rt.replace(/like iPhone OS/, "")), $t = ft.manufacturer, Nt = ft.product) : /^iP/.test(Nt) ? (St || (St = "Safari"), Rt = "iOS" + ((ft = / OS ([\d_]+)/i.exec(rt)) ? " " + ft[1].replace(/_/g, ".") : "")) : St == "Konqueror" && /^Linux\b/i.test(Rt) ? Rt = "Kubuntu" : $t && $t != "Google" && (/Chrome/.test(St) && !/\bMobile Safari\b/i.test(rt) || /\bVita\b/.test(Nt)) || /\bAndroid\b/.test(Rt) && /^Chrome/.test(St) && /\bVersion\//i.test(rt) ? (St = "Android Browser", Rt = /\bAndroid\b/.test(Rt) ? Rt : "Android") : St == "Silk" ? (/\bMobi/i.test(rt) || (Rt = "Android", Dt.unshift("desktop mode")), /Accelerated *= *true/i.test(rt) && Dt.unshift("accelerated")) : St == "UC Browser" && /\bUCWEB\b/.test(rt) ? Dt.push("speed mode") : St == "PaleMoon" && (ft = /\bFirefox\/([\d.]+)\b/.exec(rt)) ? Dt.push("identifying as Firefox " + ft[1]) : St == "Firefox" && (ft = /\b(Mobile|Tablet|TV)\b/i.exec(rt)) ? (Rt || (Rt = "Firefox OS"), Nt || (Nt = ft[1])) : !St || (ft = !/\bMinefield\b/i.test(rt) && /\b(?:Firefox|Safari)\b/.exec(St)) ? (St && !Nt && /[\/,]|^[^(]+?\)/.test(rt.slice(rt.indexOf(ft + "/") + 8)) && (St = null), (ft = Nt || $t || Rt) && (Nt || $t || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(Rt)) && (St = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(Rt) ? Rt : ft) + " Browser")) : St == "Electron" && (ft = (/\bChrome\/([\d.]+)\b/.exec(rt) || 0)[1]) && Dt.push("Chromium " + ft), Et || (Et = ee([
        "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
        "Version",
        J(St),
        "(?:Firefox|Minefield|NetFront)"
      ])), (ft = It == "iCab" && parseFloat(Et) > 3 && "WebKit" || /\bOpera\b/.test(St) && (/\bOPR\b/.test(rt) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(rt) && !/^(?:Trident|EdgeHTML)$/.test(It) && "WebKit" || !It && /\bMSIE\b/i.test(rt) && (Rt == "Mac OS" ? "Tasman" : "Trident") || It == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(St) && "NetFront") && (It = [ft]), St == "IE" && (ft = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(rt) || 0)[1]) ? (St += " Mobile", Rt = "Windows Phone " + (/\+$/.test(ft) ? ft : ft + ".x"), Dt.unshift("desktop mode")) : /\bWPDesktop\b/i.test(rt) ? (St = "IE Mobile", Rt = "Windows Phone 8.x", Dt.unshift("desktop mode"), Et || (Et = (/\brv:([\d.]+)/.exec(rt) || 0)[1])) : St != "IE" && It == "Trident" && (ft = /\brv:([\d.]+)/.exec(rt)) && (St && Dt.push("identifying as " + St + (Et ? " " + Et : "")), St = "IE", Et = ft[1]), Ot) {
        if (K(at, "global"))
          if (yt && (ft = yt.lang.System, Gt = ft.getProperty("os.arch"), Rt = Rt || ft.getProperty("os.name") + " " + ft.getProperty("os.version")), ht) {
            try {
              Et = at.require("ringo/engine").version.join("."), St = "RingoJS";
            } catch {
              (ft = at.system) && ft.global.system == at.system && (St = "Narwhal", Rt || (Rt = ft[0].os || null));
            }
            St || (St = "Rhino");
          } else
            typeof at.process == "object" && !at.process.browser && (ft = at.process) && (typeof ft.versions == "object" && (typeof ft.versions.electron == "string" ? (Dt.push("Node " + ft.versions.node), St = "Electron", Et = ft.versions.electron) : typeof ft.versions.nw == "string" && (Dt.push("Chromium " + Et, "Node " + ft.versions.node), St = "NW.js", Et = ft.versions.nw)), St || (St = "Node.js", Gt = ft.arch, Rt = ft.platform, Et = /[\d.]+/.exec(ft.version), Et = Et ? Et[0] : null));
        else
          Z(ft = at.runtime) == vt ? (St = "Adobe AIR", Rt = ft.flash.system.Capabilities.os) : Z(ft = at.phantom) == At ? (St = "PhantomJS", Et = (ft = ft.version || null) && ft.major + "." + ft.minor + "." + ft.patch) : typeof Mt.documentMode == "number" && (ft = /\bTrident\/(\d+)/i.exec(rt)) ? (Et = [Et, Mt.documentMode], (ft = +ft[1] + 4) != Et[1] && (Dt.push("IE " + Et[1] + " mode"), It && (It[1] = ""), Et[1] = ft), Et = St == "IE" ? String(Et[1].toFixed(1)) : Et[0]) : typeof Mt.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(St) && (Dt.push("masking as " + St + " " + Et), St = "IE", Et = "11.0", It = ["Trident"], Rt = "Windows");
        Rt = Rt && W(Rt);
      }
      if (Et && (ft = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(Et) || /(?:alpha|beta)(?: ?\d)?/i.exec(rt + ";" + (Ot && dt.appMinorVersion)) || /\bMinefield\b/i.test(rt) && "a") && (Bt = /b/i.test(ft) ? "beta" : "alpha", Et = Et.replace(RegExp(ft + "\\+?$"), "") + (Bt == "beta" ? Ct : bt) + (/\d+\+?/.exec(ft) || "")), St == "Fennec" || St == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(Rt))
        St = "Firefox Mobile";
      else if (St == "Maxthon" && Et)
        Et = Et.replace(/\.[\d.]+/, ".x");
      else if (/\bXbox\b/i.test(Nt))
        Nt == "Xbox 360" && (Rt = null), Nt == "Xbox 360" && /\bIEMobile\b/.test(rt) && Dt.unshift("mobile mode");
      else if ((/^(?:Chrome|IE|Opera)$/.test(St) || St && !Nt && !/Browser|Mobi/.test(St)) && (Rt == "Windows CE" || /Mobi/i.test(rt)))
        St += " Mobile";
      else if (St == "IE" && Ot)
        try {
          at.external === null && Dt.unshift("platform preview");
        } catch {
          Dt.unshift("embedded");
        }
      else
        (/\bBlackBerry\b/.test(Nt) || /\bBB10\b/.test(rt)) && (ft = (RegExp(Nt.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(rt) || 0)[1] || Et) ? (ft = [ft, /BB10/.test(rt)], Rt = (ft[1] ? (Nt = null, $t = "BlackBerry") : "Device Software") + " " + ft[0], Et = null) : this != q && Nt != "Wii" && (Ot && wt || /Opera/.test(St) && /\b(?:MSIE|Firefox)\b/i.test(rt) || St == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(Rt) || St == "IE" && (Rt && !/^Win/.test(Rt) && Et > 5.5 || /\bWindows XP\b/.test(Rt) && Et > 8 || Et == 8 && !/\bTrident\b/.test(rt))) && !B.test(ft = tt.call(q, rt.replace(B, "") + ";")) && ft.name && (ft = "ing as " + ft.name + ((ft = ft.version) ? " " + ft : ""), B.test(St) ? (/\bIE\b/.test(ft) && Rt == "Mac OS" && (Rt = null), ft = "identify" + ft) : (ft = "mask" + ft, Lt ? St = W(Lt.replace(/([a-z])([A-Z])/g, "$1 $2")) : St = "Opera", /\bIE\b/.test(ft) && (Rt = null), Ot || (Et = null)), It = ["Presto"], Dt.push(ft));
      (ft = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(rt) || 0)[1]) && (ft = [parseFloat(ft.replace(/\.(\d)$/, ".0$1")), ft], St == "Safari" && ft[1].slice(-1) == "+" ? (St = "WebKit Nightly", Bt = "alpha", Et = ft[1].slice(0, -1)) : (Et == ft[1] || Et == (ft[2] = (/\bSafari\/([\d.]+\+?)/i.exec(rt) || 0)[1])) && (Et = null), ft[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(rt) || 0)[1], ft[0] == 537.36 && ft[2] == 537.36 && parseFloat(ft[1]) >= 28 && It == "WebKit" && (It = ["Blink"]), !Ot || !pt && !ft[1] ? (It && (It[1] = "like Safari"), ft = (ft = ft[0], ft < 400 ? 1 : ft < 500 ? 2 : ft < 526 ? 3 : ft < 533 ? 4 : ft < 534 ? "4+" : ft < 535 ? 5 : ft < 537 ? 6 : ft < 538 ? 7 : ft < 601 ? 8 : ft < 602 ? 9 : ft < 604 ? 10 : ft < 606 ? 11 : ft < 608 ? 12 : "12")) : (It && (It[1] = "like Chrome"), ft = ft[1] || (ft = ft[0], ft < 530 ? 1 : ft < 532 ? 2 : ft < 532.05 ? 3 : ft < 533 ? 4 : ft < 534.03 ? 5 : ft < 534.07 ? 6 : ft < 534.1 ? 7 : ft < 534.13 ? 8 : ft < 534.16 ? 9 : ft < 534.24 ? 10 : ft < 534.3 ? 11 : ft < 535.01 ? 12 : ft < 535.02 ? "13+" : ft < 535.07 ? 15 : ft < 535.11 ? 16 : ft < 535.19 ? 17 : ft < 536.05 ? 18 : ft < 536.1 ? 19 : ft < 537.01 ? 20 : ft < 537.11 ? "21+" : ft < 537.13 ? 23 : ft < 537.18 ? 24 : ft < 537.24 ? 25 : ft < 537.36 ? 26 : It != "Blink" ? "27" : "28")), It && (It[1] += " " + (ft += typeof ft == "number" ? ".x" : /[.+]/.test(ft) ? "" : "+")), St == "Safari" && (!Et || parseInt(Et) > 45) ? Et = ft : St == "Chrome" && /\bHeadlessChrome/i.test(rt) && Dt.unshift("headless")), St == "Opera" && (ft = /\bzbov|zvav$/.exec(Rt)) ? (St += " ", Dt.unshift("desktop mode"), ft == "zvav" ? (St += "Mini", Et = null) : St += "Mobile", Rt = Rt.replace(RegExp(" *" + ft + "$"), "")) : St == "Safari" && /\bChrome\b/.exec(It && It[1]) ? (Dt.unshift("desktop mode"), St = "Chrome Mobile", Et = null, /\bOS X\b/.test(Rt) ? ($t = "Apple", Rt = "iOS 4.3+") : Rt = null) : /\bSRWare Iron\b/.test(St) && !Et && (Et = ee("Chrome")), Et && Et.indexOf(ft = /[\d.]+$/.exec(Rt)) == 0 && rt.indexOf("/" + ft + "-") > -1 && (Rt = et(Rt.replace(ft, ""))), Rt && Rt.indexOf(St) != -1 && !RegExp(St + " OS").test(Rt) && (Rt = Rt.replace(RegExp(" *" + J(St) + " *"), "")), It && !/\b(?:Avant|Nook)\b/.test(St) && (/Browser|Lunascape|Maxthon/.test(St) || St != "Safari" && /^iOS/.test(Rt) && /\bSafari\b/.test(It[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(St) && It[1]) && (ft = It[It.length - 1]) && Dt.push(ft), Dt.length && (Dt = ["(" + Dt.join("; ") + ")"]), $t && Nt && Nt.indexOf($t) < 0 && Dt.push("on " + $t), Nt && Dt.push((/^on /.test(Dt[Dt.length - 1]) ? "" : "on ") + Nt), Rt && (ft = / ([\d.+]+)$/.exec(Rt), Ht = ft && Rt.charAt(Rt.length - ft[0].length - 1) == "/", Rt = {
        architecture: 32,
        family: ft && !Ht ? Rt.replace(ft[0], "") : Rt,
        version: ft ? ft[1] : null,
        toString: function() {
          var he = this.version;
          return this.family + (he && !Ht ? " " + he : "") + (this.architecture == 64 ? " 64-bit" : "");
        }
      }), (ft = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(Gt)) && !/\bi686\b/i.test(Gt) ? (Rt && (Rt.architecture = 64, Rt.family = Rt.family.replace(RegExp(" *" + ft), "")), St && (/\bWOW64\b/i.test(rt) || Ot && /\w(?:86|32)$/.test(dt.cpuClass || dt.platform) && !/\bWin64; x64\b/i.test(rt)) && Dt.unshift("32-bit")) : Rt && /^OS X/.test(Rt.family) && St == "Chrome" && parseFloat(Et) >= 39 && (Rt.architecture = 64), rt || (rt = null);
      var ve = {};
      return ve.description = rt, ve.layout = It && It[0], ve.manufacturer = $t, ve.name = St, ve.prerelease = Bt, ve.product = Nt, ve.ua = rt, ve.version = St && Et, ve.os = Rt || {
        architecture: null,
        family: null,
        version: null,
        toString: function() {
          return "null";
        }
      }, ve.parse = tt, ve.toString = Re, ve.version && Dt.unshift(Et), ve.name && Dt.unshift(St), Rt && St && !(Rt == String(Rt).split(" ")[0] && (Rt == St.split(" ")[0] || Nt)) && Dt.push(Nt ? "(" + Rt + ")" : "on " + Rt), Dt.length && (ve.description = Dt.join(" ")), ve;
    }
    var st = tt();
    N && M ? q(st, function(rt, at) {
      N[at] = rt;
    }) : R.platform = st;
  }).call(commonjsGlobal$1);
})(platform$1, platform$1.exports);
const platform = platform$1.exports;
function int(o) {
  return parseInt(String(o), 10);
}
function uint(o) {
  const t = parseInt(String(o), 10);
  return t < 0 ? -t : t;
}
"toInt" in String.prototype || (String.prototype.toInt = function() {
  return int(this);
});
"toUint" in String.prototype || (String.prototype.toUint = function() {
  const o = int(this);
  return o < 0 ? -o : o;
});
function getDateStr(o = "/", t = " ", e = ":", R = "") {
  const N = new Date();
  return N.getFullYear() + o + String(100 + N.getMonth() + 1).slice(1, 3) + o + String(100 + N.getDate()).slice(1, 3) + t + String(100 + N.getHours()).slice(1, 3) + e + String(100 + N.getMinutes()).slice(1, 3) + (R === "" ? "" : R + String(N.getMilliseconds()));
}
const hMemberCnt = {
  alpha: 0,
  height: 0,
  rotation: 0,
  scale_x: 0,
  scale_y: 0,
  pivot_x: 0,
  pivot_y: 0,
  width: 0,
  x: 0,
  y: 0
};
function cnvTweenArg(o, t) {
  const e = {};
  for (const R in hMemberCnt) {
    if (!(R in o))
      continue;
    const N = String(o[R]), M = (N.charAt(0) === "=" ? N.slice(1) : N).split(","), D = e[R] = parseFloat(M[0]);
    M.length > 1 && (e[R] += Math.round(Math.random() * (parseFloat(M[1]) - D + 1))), N.charAt(0) === "=" && (e[R] += parseFloat(t[R]));
  }
  return e;
}
const css_key4del = "/* SKYNovel */";
function initStyle() {
  const o = document.getElementsByTagName("head")[0], t = o.children.length;
  for (let e = t - 1; e >= 0; --e) {
    const R = o.children[e];
    R instanceof HTMLStyleElement && R.innerText.slice(0, 14) === css_key4del && o.removeChild(R);
  }
}
function addStyle(o) {
  const t = document.createElement("style");
  t.innerHTML = css_key4del + o, document.getElementsByTagName("head")[0].appendChild(t);
}
function argChk_Num(o, t, e) {
  const R = o[t];
  if (!(t in o)) {
    if (isNaN(e))
      throw `[${o[":\u30BF\u30B0\u540D"]}]\u5C5E\u6027 ${t} \u306F\u5FC5\u9808\u3067\u3059`;
    return o[t] = e, e;
  }
  const N = String(R).slice(0, 2) === "0x" ? parseInt(R) : parseFloat(R);
  if (isNaN(N))
    throw `[${o[":\u30BF\u30B0\u540D"]}]\u5C5E\u6027 ${t} \u306E\u5024\u3010${R}\u3011\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  return o[t] = N;
}
function argChk_Boolean(o, t, e) {
  if (!(t in o))
    return o[t] = e;
  const R = o[t];
  if (R === null)
    return !1;
  const N = String(R);
  return o[t] = N === "false" ? !1 : Boolean(N);
}
function parseColor(o) {
  if (o.charAt(0) === "#")
    return parseInt(o.slice(1), 16);
  const t = Number(o);
  if (!isNaN(t))
    return t;
  if (o === "black")
    return 0;
  CmnLib.cc4ColorName.fillStyle = o;
  const e = CmnLib.cc4ColorName.fillStyle;
  if (e === "#000000")
    throw `\u8272\u540D\u524D ${o} \u304C\u7570\u5E38\u3067\u3059`;
  return parseInt(e.slice(1), 16);
}
function argChk_Color(o, t, e) {
  const R = o[t];
  return R ? o[t] = parseColor(String(R)) : o[t] = e;
}
const REG_ERRMES_JSON = /JSON at position (\d+)$/;
function mesErrJSON(o, t = "", e = "") {
  var N;
  const R = ((N = e.match(REG_ERRMES_JSON)) != null ? N : ["", ""])[1];
  return `[${o[":\u30BF\u30B0\u540D"]}] ${t} \u5C5E\u6027\u306E\u89E3\u6790\u30A8\u30E9\u30FC : ${e}
${o[t]}${R ? `
${"^".padStart(Number(R))}` : ""}`;
}
const REG_FN = /^[^\/\.]+$|[^\/]+(?=\.)/;
function getFn(o) {
  var t;
  return ((t = o.match(REG_FN)) != null ? t : [""])[0];
}
const REG_EXT = /\.([^\.]+)$/;
function getExt(o) {
  var t;
  return ((t = o.match(REG_EXT)) != null ? t : ["", ""])[1];
}
class CmnLib {
}
CmnLib.stageW = 0;
CmnLib.stageH = 0;
CmnLib.debugLog = !1;
CmnLib.isSafari = platform$1.exports.name === "Safari";
CmnLib.isFirefox = platform$1.exports.name === "Firefox";
var Vh, Xh;
CmnLib.isMac = new RegExp("OS X").test((Xh = (Vh = platform$1.exports.os) == null ? void 0 : Vh.family) != null ? Xh : "");
var Wh, Yh;
CmnLib.isMobile = !new RegExp("(Windows|OS X)").test((Yh = (Wh = platform$1.exports.os) == null ? void 0 : Wh.family) != null ? Yh : "");
CmnLib.hDip = {};
CmnLib.isDbg = !1;
CmnLib.isPackaged = !1;
CmnLib.isDarkMode = !1;
function finallyConstructor(o) {
  var t = this.constructor;
  return this.then(
    function(e) {
      return t.resolve(o()).then(function() {
        return e;
      });
    },
    function(e) {
      return t.resolve(o()).then(function() {
        return t.reject(e);
      });
    }
  );
}
function allSettled(o) {
  var t = this;
  return new t(function(e, R) {
    if (!(o && typeof o.length < "u"))
      return R(
        new TypeError(
          typeof o + " " + o + " is not iterable(cannot read property Symbol(Symbol.iterator))"
        )
      );
    var N = Array.prototype.slice.call(o);
    if (N.length === 0)
      return e([]);
    var M = N.length;
    function D(B, $) {
      if ($ && (typeof $ == "object" || typeof $ == "function")) {
        var U = $.then;
        if (typeof U == "function") {
          U.call(
            $,
            function(H) {
              D(B, H);
            },
            function(H) {
              N[B] = { status: "rejected", reason: H }, --M === 0 && e(N);
            }
          );
          return;
        }
      }
      N[B] = { status: "fulfilled", value: $ }, --M === 0 && e(N);
    }
    for (var L = 0; L < N.length; L++)
      D(L, N[L]);
  });
}
var setTimeoutFunc = setTimeout;
function isArray$1(o) {
  return Boolean(o && typeof o.length < "u");
}
function noop() {
}
function bind$2(o, t) {
  return function() {
    o.apply(t, arguments);
  };
}
function Promise$1(o) {
  if (!(this instanceof Promise$1))
    throw new TypeError("Promises must be constructed via new");
  if (typeof o != "function")
    throw new TypeError("not a function");
  this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], doResolve(o, this);
}
function handle(o, t) {
  for (; o._state === 3; )
    o = o._value;
  if (o._state === 0) {
    o._deferreds.push(t);
    return;
  }
  o._handled = !0, Promise$1._immediateFn(function() {
    var e = o._state === 1 ? t.onFulfilled : t.onRejected;
    if (e === null) {
      (o._state === 1 ? resolve$1 : reject)(t.promise, o._value);
      return;
    }
    var R;
    try {
      R = e(o._value);
    } catch (N) {
      reject(t.promise, N);
      return;
    }
    resolve$1(t.promise, R);
  });
}
function resolve$1(o, t) {
  try {
    if (t === o)
      throw new TypeError("A promise cannot be resolved with itself.");
    if (t && (typeof t == "object" || typeof t == "function")) {
      var e = t.then;
      if (t instanceof Promise$1) {
        o._state = 3, o._value = t, finale(o);
        return;
      } else if (typeof e == "function") {
        doResolve(bind$2(e, t), o);
        return;
      }
    }
    o._state = 1, o._value = t, finale(o);
  } catch (R) {
    reject(o, R);
  }
}
function reject(o, t) {
  o._state = 2, o._value = t, finale(o);
}
function finale(o) {
  o._state === 2 && o._deferreds.length === 0 && Promise$1._immediateFn(function() {
    o._handled || Promise$1._unhandledRejectionFn(o._value);
  });
  for (var t = 0, e = o._deferreds.length; t < e; t++)
    handle(o, o._deferreds[t]);
  o._deferreds = null;
}
function Handler(o, t, e) {
  this.onFulfilled = typeof o == "function" ? o : null, this.onRejected = typeof t == "function" ? t : null, this.promise = e;
}
function doResolve(o, t) {
  var e = !1;
  try {
    o(
      function(R) {
        e || (e = !0, resolve$1(t, R));
      },
      function(R) {
        e || (e = !0, reject(t, R));
      }
    );
  } catch (R) {
    if (e)
      return;
    e = !0, reject(t, R);
  }
}
Promise$1.prototype.catch = function(o) {
  return this.then(null, o);
};
Promise$1.prototype.then = function(o, t) {
  var e = new this.constructor(noop);
  return handle(this, new Handler(o, t, e)), e;
};
Promise$1.prototype.finally = finallyConstructor;
Promise$1.all = function(o) {
  return new Promise$1(function(t, e) {
    if (!isArray$1(o))
      return e(new TypeError("Promise.all accepts an array"));
    var R = Array.prototype.slice.call(o);
    if (R.length === 0)
      return t([]);
    var N = R.length;
    function M(L, B) {
      try {
        if (B && (typeof B == "object" || typeof B == "function")) {
          var $ = B.then;
          if (typeof $ == "function") {
            $.call(
              B,
              function(U) {
                M(L, U);
              },
              e
            );
            return;
          }
        }
        R[L] = B, --N === 0 && t(R);
      } catch (U) {
        e(U);
      }
    }
    for (var D = 0; D < R.length; D++)
      M(D, R[D]);
  });
};
Promise$1.allSettled = allSettled;
Promise$1.resolve = function(o) {
  return o && typeof o == "object" && o.constructor === Promise$1 ? o : new Promise$1(function(t) {
    t(o);
  });
};
Promise$1.reject = function(o) {
  return new Promise$1(function(t, e) {
    e(o);
  });
};
Promise$1.race = function(o) {
  return new Promise$1(function(t, e) {
    if (!isArray$1(o))
      return e(new TypeError("Promise.race accepts an array"));
    for (var R = 0, N = o.length; R < N; R++)
      Promise$1.resolve(o[R]).then(t, e);
  });
};
Promise$1._immediateFn = typeof setImmediate == "function" && function(o) {
  setImmediate(o);
} || function(o) {
  setTimeoutFunc(o, 0);
};
Promise$1._unhandledRejectionFn = function(t) {
  typeof console < "u" && console && console.warn("Possible Unhandled Promise Rejection:", t);
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty$2 = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(o) {
  if (o == null)
    throw new TypeError("Object.assign cannot be called with null or undefined");
  return Object(o);
}
function shouldUseNative() {
  try {
    if (!Object.assign)
      return !1;
    var o = new String("abc");
    if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
      return !1;
    for (var t = {}, e = 0; e < 10; e++)
      t["_" + String.fromCharCode(e)] = e;
    var R = Object.getOwnPropertyNames(t).map(function(M) {
      return t[M];
    });
    if (R.join("") !== "0123456789")
      return !1;
    var N = {};
    return "abcdefghijklmnopqrst".split("").forEach(function(M) {
      N[M] = M;
    }), Object.keys(Object.assign({}, N)).join("") === "abcdefghijklmnopqrst";
  } catch {
    return !1;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(o, t) {
  for (var e, R = toObject(o), N, M = 1; M < arguments.length; M++) {
    e = Object(arguments[M]);
    for (var D in e)
      hasOwnProperty$2.call(e, D) && (R[D] = e[D]);
    if (getOwnPropertySymbols) {
      N = getOwnPropertySymbols(e);
      for (var L = 0; L < N.length; L++)
        propIsEnumerable.call(e, N[L]) && (R[N[L]] = e[N[L]]);
    }
  }
  return R;
};
/*!
 * @pixi/polyfill - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/polyfill is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
typeof globalThis > "u" && (typeof self < "u" ? self.globalThis = self : typeof global < "u" && (global.globalThis = global));
globalThis.Promise || (globalThis.Promise = Promise$1);
Object.assign || (Object.assign = objectAssign);
var ONE_FRAME_TIME = 16;
Date.now && Date.prototype.getTime || (Date.now = function() {
  return new Date().getTime();
});
if (!(globalThis.performance && globalThis.performance.now)) {
  var startTime_1 = Date.now();
  globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {
    return Date.now() - startTime_1;
  };
}
var lastTime = Date.now(), vendors = ["ms", "moz", "webkit", "o"];
for (var x$1 = 0; x$1 < vendors.length && !globalThis.requestAnimationFrame; ++x$1) {
  var p$1 = vendors[x$1];
  globalThis.requestAnimationFrame = globalThis[p$1 + "RequestAnimationFrame"], globalThis.cancelAnimationFrame = globalThis[p$1 + "CancelAnimationFrame"] || globalThis[p$1 + "CancelRequestAnimationFrame"];
}
globalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(o) {
  if (typeof o != "function")
    throw new TypeError(o + "is not a function");
  var t = Date.now(), e = ONE_FRAME_TIME + lastTime - t;
  return e < 0 && (e = 0), lastTime = t, globalThis.self.setTimeout(function() {
    lastTime = Date.now(), o(performance.now());
  }, e);
});
globalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(o) {
  return clearTimeout(o);
});
Math.sign || (Math.sign = function(t) {
  return t = Number(t), t === 0 || isNaN(t) ? t : t > 0 ? 1 : -1;
});
Number.isInteger || (Number.isInteger = function(t) {
  return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
});
globalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array);
globalThis.Float32Array || (globalThis.Float32Array = Array);
globalThis.Uint32Array || (globalThis.Uint32Array = Array);
globalThis.Uint16Array || (globalThis.Uint16Array = Array);
globalThis.Uint8Array || (globalThis.Uint8Array = Array);
globalThis.Int32Array || (globalThis.Int32Array = Array);
/*!
 * @pixi/settings - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*!
 * @pixi/constants - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$6;
(function(o) {
  o[o.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", o[o.WEBGL = 1] = "WEBGL", o[o.WEBGL2 = 2] = "WEBGL2";
})(ENV$6 || (ENV$6 = {}));
var RENDERER_TYPE$6;
(function(o) {
  o[o.UNKNOWN = 0] = "UNKNOWN", o[o.WEBGL = 1] = "WEBGL", o[o.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE$6 || (RENDERER_TYPE$6 = {}));
var BUFFER_BITS$6;
(function(o) {
  o[o.COLOR = 16384] = "COLOR", o[o.DEPTH = 256] = "DEPTH", o[o.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS$6 || (BUFFER_BITS$6 = {}));
var BLEND_MODES$6;
(function(o) {
  o[o.NORMAL = 0] = "NORMAL", o[o.ADD = 1] = "ADD", o[o.MULTIPLY = 2] = "MULTIPLY", o[o.SCREEN = 3] = "SCREEN", o[o.OVERLAY = 4] = "OVERLAY", o[o.DARKEN = 5] = "DARKEN", o[o.LIGHTEN = 6] = "LIGHTEN", o[o.COLOR_DODGE = 7] = "COLOR_DODGE", o[o.COLOR_BURN = 8] = "COLOR_BURN", o[o.HARD_LIGHT = 9] = "HARD_LIGHT", o[o.SOFT_LIGHT = 10] = "SOFT_LIGHT", o[o.DIFFERENCE = 11] = "DIFFERENCE", o[o.EXCLUSION = 12] = "EXCLUSION", o[o.HUE = 13] = "HUE", o[o.SATURATION = 14] = "SATURATION", o[o.COLOR = 15] = "COLOR", o[o.LUMINOSITY = 16] = "LUMINOSITY", o[o.NORMAL_NPM = 17] = "NORMAL_NPM", o[o.ADD_NPM = 18] = "ADD_NPM", o[o.SCREEN_NPM = 19] = "SCREEN_NPM", o[o.NONE = 20] = "NONE", o[o.SRC_OVER = 0] = "SRC_OVER", o[o.SRC_IN = 21] = "SRC_IN", o[o.SRC_OUT = 22] = "SRC_OUT", o[o.SRC_ATOP = 23] = "SRC_ATOP", o[o.DST_OVER = 24] = "DST_OVER", o[o.DST_IN = 25] = "DST_IN", o[o.DST_OUT = 26] = "DST_OUT", o[o.DST_ATOP = 27] = "DST_ATOP", o[o.ERASE = 26] = "ERASE", o[o.SUBTRACT = 28] = "SUBTRACT", o[o.XOR = 29] = "XOR";
})(BLEND_MODES$6 || (BLEND_MODES$6 = {}));
var DRAW_MODES$6;
(function(o) {
  o[o.POINTS = 0] = "POINTS", o[o.LINES = 1] = "LINES", o[o.LINE_LOOP = 2] = "LINE_LOOP", o[o.LINE_STRIP = 3] = "LINE_STRIP", o[o.TRIANGLES = 4] = "TRIANGLES", o[o.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", o[o.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$6 || (DRAW_MODES$6 = {}));
var FORMATS$6;
(function(o) {
  o[o.RGBA = 6408] = "RGBA", o[o.RGB = 6407] = "RGB", o[o.RG = 33319] = "RG", o[o.RED = 6403] = "RED", o[o.RGBA_INTEGER = 36249] = "RGBA_INTEGER", o[o.RGB_INTEGER = 36248] = "RGB_INTEGER", o[o.RG_INTEGER = 33320] = "RG_INTEGER", o[o.RED_INTEGER = 36244] = "RED_INTEGER", o[o.ALPHA = 6406] = "ALPHA", o[o.LUMINANCE = 6409] = "LUMINANCE", o[o.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", o[o.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", o[o.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS$6 || (FORMATS$6 = {}));
var TARGETS$6;
(function(o) {
  o[o.TEXTURE_2D = 3553] = "TEXTURE_2D", o[o.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", o[o.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", o[o.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", o[o.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", o[o.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", o[o.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$6 || (TARGETS$6 = {}));
var TYPES$6;
(function(o) {
  o[o.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", o[o.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", o[o.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", o[o.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", o[o.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", o[o.UNSIGNED_INT = 5125] = "UNSIGNED_INT", o[o.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", o[o.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", o[o.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", o[o.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", o[o.BYTE = 5120] = "BYTE", o[o.SHORT = 5122] = "SHORT", o[o.INT = 5124] = "INT", o[o.FLOAT = 5126] = "FLOAT", o[o.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", o[o.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES$6 || (TYPES$6 = {}));
var SAMPLER_TYPES$6;
(function(o) {
  o[o.FLOAT = 0] = "FLOAT", o[o.INT = 1] = "INT", o[o.UINT = 2] = "UINT";
})(SAMPLER_TYPES$6 || (SAMPLER_TYPES$6 = {}));
var SCALE_MODES$6;
(function(o) {
  o[o.NEAREST = 0] = "NEAREST", o[o.LINEAR = 1] = "LINEAR";
})(SCALE_MODES$6 || (SCALE_MODES$6 = {}));
var WRAP_MODES$6;
(function(o) {
  o[o.CLAMP = 33071] = "CLAMP", o[o.REPEAT = 10497] = "REPEAT", o[o.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$6 || (WRAP_MODES$6 = {}));
var MIPMAP_MODES$6;
(function(o) {
  o[o.OFF = 0] = "OFF", o[o.POW2 = 1] = "POW2", o[o.ON = 2] = "ON", o[o.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES$6 || (MIPMAP_MODES$6 = {}));
var ALPHA_MODES$6;
(function(o) {
  o[o.NPM = 0] = "NPM", o[o.UNPACK = 1] = "UNPACK", o[o.PMA = 2] = "PMA", o[o.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", o[o.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", o[o.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", o[o.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$6 || (ALPHA_MODES$6 = {}));
var CLEAR_MODES$6;
(function(o) {
  o[o.NO = 0] = "NO", o[o.YES = 1] = "YES", o[o.AUTO = 2] = "AUTO", o[o.BLEND = 0] = "BLEND", o[o.CLEAR = 1] = "CLEAR", o[o.BLIT = 2] = "BLIT";
})(CLEAR_MODES$6 || (CLEAR_MODES$6 = {}));
var GC_MODES$6;
(function(o) {
  o[o.AUTO = 0] = "AUTO", o[o.MANUAL = 1] = "MANUAL";
})(GC_MODES$6 || (GC_MODES$6 = {}));
var PRECISION$6;
(function(o) {
  o.LOW = "lowp", o.MEDIUM = "mediump", o.HIGH = "highp";
})(PRECISION$6 || (PRECISION$6 = {}));
var MASK_TYPES$6;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.SCISSOR = 1] = "SCISSOR", o[o.STENCIL = 2] = "STENCIL", o[o.SPRITE = 3] = "SPRITE", o[o.COLOR = 4] = "COLOR";
})(MASK_TYPES$6 || (MASK_TYPES$6 = {}));
var COLOR_MASK_BITS$6;
(function(o) {
  o[o.RED = 1] = "RED", o[o.GREEN = 2] = "GREEN", o[o.BLUE = 4] = "BLUE", o[o.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS$6 || (COLOR_MASK_BITS$6 = {}));
var MSAA_QUALITY$6;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.LOW = 2] = "LOW", o[o.MEDIUM = 4] = "MEDIUM", o[o.HIGH = 8] = "HIGH";
})(MSAA_QUALITY$6 || (MSAA_QUALITY$6 = {}));
var BUFFER_TYPE$6;
(function(o) {
  o[o.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", o[o.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", o[o.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$6 || (BUFFER_TYPE$6 = {}));
var BrowserAdapter$1 = {
  createCanvas: function(o, t) {
    var e = document.createElement("canvas");
    return e.width = o, e.height = t, e;
  },
  getWebGLRenderingContext: function() {
    return WebGLRenderingContext;
  },
  getNavigator: function() {
    return navigator;
  },
  getBaseUrl: function() {
    var o;
    return (o = document.baseURI) !== null && o !== void 0 ? o : window.location.href;
  },
  fetch: function(o, t) {
    return fetch(o, t);
  }
}, appleIphone$1 = /iPhone/i, appleIpod$1 = /iPod/i, appleTablet$1 = /iPad/i, appleUniversal$1 = /\biOS-universal(?:.+)Mac\b/i, androidPhone$1 = /\bAndroid(?:.+)Mobile\b/i, androidTablet$1 = /Android/i, amazonPhone$1 = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, amazonTablet$1 = /Silk/i, windowsPhone$1 = /Windows Phone/i, windowsTablet$1 = /\bWindows(?:.+)ARM\b/i, otherBlackBerry$1 = /BlackBerry/i, otherBlackBerry10$1 = /BB10/i, otherOpera$1 = /Opera Mini/i, otherChrome$1 = /\b(CriOS|Chrome)(?:.+)Mobile/i, otherFirefox$1 = /Mobile(?:.+)Firefox\b/i, isAppleTabletOnIos13$1 = function(o) {
  return typeof o < "u" && o.platform === "MacIntel" && typeof o.maxTouchPoints == "number" && o.maxTouchPoints > 1 && typeof MSStream > "u";
};
function createMatch$1(o) {
  return function(t) {
    return t.test(o);
  };
}
function isMobile$1$1(o) {
  var t = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  !o && typeof navigator < "u" ? t = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    maxTouchPoints: navigator.maxTouchPoints || 0
  } : typeof o == "string" ? t.userAgent = o : o && o.userAgent && (t = {
    userAgent: o.userAgent,
    platform: o.platform,
    maxTouchPoints: o.maxTouchPoints || 0
  });
  var e = t.userAgent, R = e.split("[FBAN");
  typeof R[1] < "u" && (e = R[0]), R = e.split("Twitter"), typeof R[1] < "u" && (e = R[0]);
  var N = createMatch$1(e), M = {
    apple: {
      phone: N(appleIphone$1) && !N(windowsPhone$1),
      ipod: N(appleIpod$1),
      tablet: !N(appleIphone$1) && (N(appleTablet$1) || isAppleTabletOnIos13$1(t)) && !N(windowsPhone$1),
      universal: N(appleUniversal$1),
      device: (N(appleIphone$1) || N(appleIpod$1) || N(appleTablet$1) || N(appleUniversal$1) || isAppleTabletOnIos13$1(t)) && !N(windowsPhone$1)
    },
    amazon: {
      phone: N(amazonPhone$1),
      tablet: !N(amazonPhone$1) && N(amazonTablet$1),
      device: N(amazonPhone$1) || N(amazonTablet$1)
    },
    android: {
      phone: !N(windowsPhone$1) && N(amazonPhone$1) || !N(windowsPhone$1) && N(androidPhone$1),
      tablet: !N(windowsPhone$1) && !N(amazonPhone$1) && !N(androidPhone$1) && (N(amazonTablet$1) || N(androidTablet$1)),
      device: !N(windowsPhone$1) && (N(amazonPhone$1) || N(amazonTablet$1) || N(androidPhone$1) || N(androidTablet$1)) || N(/\bokhttp\b/i)
    },
    windows: {
      phone: N(windowsPhone$1),
      tablet: N(windowsTablet$1),
      device: N(windowsPhone$1) || N(windowsTablet$1)
    },
    other: {
      blackberry: N(otherBlackBerry$1),
      blackberry10: N(otherBlackBerry10$1),
      opera: N(otherOpera$1),
      firefox: N(otherFirefox$1),
      chrome: N(otherChrome$1),
      device: N(otherBlackBerry$1) || N(otherBlackBerry10$1) || N(otherOpera$1) || N(otherFirefox$1) || N(otherChrome$1)
    },
    any: !1,
    phone: !1,
    tablet: !1
  };
  return M.any = M.apple.device || M.android.device || M.windows.device || M.other.device, M.phone = M.apple.phone || M.android.phone || M.windows.phone, M.tablet = M.apple.tablet || M.android.tablet || M.windows.tablet, M;
}
var isMobile$2 = isMobile$1$1(globalThis.navigator);
function canUploadSameBuffer$1() {
  return !isMobile$2.apple.device;
}
function maxRecommendedTextures$1(o) {
  var t = !0;
  if (isMobile$2.tablet || isMobile$2.phone) {
    if (isMobile$2.apple.device) {
      var e = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (e) {
        var R = parseInt(e[1], 10);
        R < 11 && (t = !1);
      }
    }
    if (isMobile$2.android.device) {
      var e = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (e) {
        var R = parseInt(e[1], 10);
        R < 7 && (t = !1);
      }
    }
  }
  return t ? o : 4;
}
var settings$1 = {
  ADAPTER: BrowserAdapter$1,
  MIPMAP_TEXTURES: MIPMAP_MODES$6.POW2,
  ANISOTROPIC_LEVEL: 0,
  RESOLUTION: 1,
  FILTER_RESOLUTION: 1,
  FILTER_MULTISAMPLE: MSAA_QUALITY$6.NONE,
  SPRITE_MAX_TEXTURES: maxRecommendedTextures$1(32),
  SPRITE_BATCH_SIZE: 4096,
  RENDER_OPTIONS: {
    view: null,
    antialias: !1,
    autoDensity: !1,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: !0,
    clearBeforeRender: !0,
    preserveDrawingBuffer: !1,
    width: 800,
    height: 600,
    legacy: !1
  },
  GC_MODE: GC_MODES$6.AUTO,
  GC_MAX_IDLE: 60 * 60,
  GC_MAX_CHECK_COUNT: 60 * 10,
  WRAP_MODE: WRAP_MODES$6.CLAMP,
  SCALE_MODE: SCALE_MODES$6.LINEAR,
  PRECISION_VERTEX: PRECISION$6.HIGH,
  PRECISION_FRAGMENT: isMobile$2.apple.device ? PRECISION$6.HIGH : PRECISION$6.MEDIUM,
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer$1(),
  CREATE_IMAGE_BITMAP: !1,
  ROUND_PIXELS: !1
}, eventemitter3 = { exports: {} };
(function(o) {
  var t = Object.prototype.hasOwnProperty, e = "~";
  function R() {
  }
  Object.create && (R.prototype = /* @__PURE__ */ Object.create(null), new R().__proto__ || (e = !1));
  function N(B, $, U) {
    this.fn = B, this.context = $, this.once = U || !1;
  }
  function M(B, $, U, H, z) {
    if (typeof U != "function")
      throw new TypeError("The listener must be a function");
    var X = new N(U, H || B, z), Y = e ? e + $ : $;
    return B._events[Y] ? B._events[Y].fn ? B._events[Y] = [B._events[Y], X] : B._events[Y].push(X) : (B._events[Y] = X, B._eventsCount++), B;
  }
  function D(B, $) {
    --B._eventsCount === 0 ? B._events = new R() : delete B._events[$];
  }
  function L() {
    this._events = new R(), this._eventsCount = 0;
  }
  L.prototype.eventNames = function() {
    var $ = [], U, H;
    if (this._eventsCount === 0)
      return $;
    for (H in U = this._events)
      t.call(U, H) && $.push(e ? H.slice(1) : H);
    return Object.getOwnPropertySymbols ? $.concat(Object.getOwnPropertySymbols(U)) : $;
  }, L.prototype.listeners = function($) {
    var U = e ? e + $ : $, H = this._events[U];
    if (!H)
      return [];
    if (H.fn)
      return [H.fn];
    for (var z = 0, X = H.length, Y = new Array(X); z < X; z++)
      Y[z] = H[z].fn;
    return Y;
  }, L.prototype.listenerCount = function($) {
    var U = e ? e + $ : $, H = this._events[U];
    return H ? H.fn ? 1 : H.length : 0;
  }, L.prototype.emit = function($, U, H, z, X, Y) {
    var W = e ? e + $ : $;
    if (!this._events[W])
      return !1;
    var q = this._events[W], Z = arguments.length, K, J;
    if (q.fn) {
      switch (q.once && this.removeListener($, q.fn, void 0, !0), Z) {
        case 1:
          return q.fn.call(q.context), !0;
        case 2:
          return q.fn.call(q.context, U), !0;
        case 3:
          return q.fn.call(q.context, U, H), !0;
        case 4:
          return q.fn.call(q.context, U, H, z), !0;
        case 5:
          return q.fn.call(q.context, U, H, z, X), !0;
        case 6:
          return q.fn.call(q.context, U, H, z, X, Y), !0;
      }
      for (J = 1, K = new Array(Z - 1); J < Z; J++)
        K[J - 1] = arguments[J];
      q.fn.apply(q.context, K);
    } else {
      var Q = q.length, et;
      for (J = 0; J < Q; J++)
        switch (q[J].once && this.removeListener($, q[J].fn, void 0, !0), Z) {
          case 1:
            q[J].fn.call(q[J].context);
            break;
          case 2:
            q[J].fn.call(q[J].context, U);
            break;
          case 3:
            q[J].fn.call(q[J].context, U, H);
            break;
          case 4:
            q[J].fn.call(q[J].context, U, H, z);
            break;
          default:
            if (!K)
              for (et = 1, K = new Array(Z - 1); et < Z; et++)
                K[et - 1] = arguments[et];
            q[J].fn.apply(q[J].context, K);
        }
    }
    return !0;
  }, L.prototype.on = function($, U, H) {
    return M(this, $, U, H, !1);
  }, L.prototype.once = function($, U, H) {
    return M(this, $, U, H, !0);
  }, L.prototype.removeListener = function($, U, H, z) {
    var X = e ? e + $ : $;
    if (!this._events[X])
      return this;
    if (!U)
      return D(this, X), this;
    var Y = this._events[X];
    if (Y.fn)
      Y.fn === U && (!z || Y.once) && (!H || Y.context === H) && D(this, X);
    else {
      for (var W = 0, q = [], Z = Y.length; W < Z; W++)
        (Y[W].fn !== U || z && !Y[W].once || H && Y[W].context !== H) && q.push(Y[W]);
      q.length ? this._events[X] = q.length === 1 ? q[0] : q : D(this, X);
    }
    return this;
  }, L.prototype.removeAllListeners = function($) {
    var U;
    return $ ? (U = e ? e + $ : $, this._events[U] && D(this, U)) : (this._events = new R(), this._eventsCount = 0), this;
  }, L.prototype.off = L.prototype.removeListener, L.prototype.addListener = L.prototype.on, L.prefixed = e, L.EventEmitter = L, o.exports = L;
})(eventemitter3);
const n = eventemitter3.exports;
var earcut$1 = { exports: {} };
earcut$1.exports = earcut;
earcut$1.exports.default = earcut;
function earcut(o, t, e) {
  e = e || 2;
  var R = t && t.length, N = R ? t[0] * e : o.length, M = linkedList(o, 0, N, e, !0), D = [];
  if (!M || M.next === M.prev)
    return D;
  var L, B, $, U, H, z, X;
  if (R && (M = eliminateHoles(o, t, M, e)), o.length > 80 * e) {
    L = $ = o[0], B = U = o[1];
    for (var Y = e; Y < N; Y += e)
      H = o[Y], z = o[Y + 1], H < L && (L = H), z < B && (B = z), H > $ && ($ = H), z > U && (U = z);
    X = Math.max($ - L, U - B), X = X !== 0 ? 32767 / X : 0;
  }
  return earcutLinked(M, D, e, L, B, X, 0), D;
}
function linkedList(o, t, e, R, N) {
  var M, D;
  if (N === signedArea(o, t, e, R) > 0)
    for (M = t; M < e; M += R)
      D = insertNode(M, o[M], o[M + 1], D);
  else
    for (M = e - R; M >= t; M -= R)
      D = insertNode(M, o[M], o[M + 1], D);
  return D && equals$1(D, D.next) && (removeNode(D), D = D.next), D;
}
function filterPoints(o, t) {
  if (!o)
    return o;
  t || (t = o);
  var e = o, R;
  do
    if (R = !1, !e.steiner && (equals$1(e, e.next) || area(e.prev, e, e.next) === 0)) {
      if (removeNode(e), e = t = e.prev, e === e.next)
        break;
      R = !0;
    } else
      e = e.next;
  while (R || e !== t);
  return t;
}
function earcutLinked(o, t, e, R, N, M, D) {
  if (!!o) {
    !D && M && indexCurve(o, R, N, M);
    for (var L = o, B, $; o.prev !== o.next; ) {
      if (B = o.prev, $ = o.next, M ? isEarHashed(o, R, N, M) : isEar(o)) {
        t.push(B.i / e | 0), t.push(o.i / e | 0), t.push($.i / e | 0), removeNode(o), o = $.next, L = $.next;
        continue;
      }
      if (o = $, o === L) {
        D ? D === 1 ? (o = cureLocalIntersections(filterPoints(o), t, e), earcutLinked(o, t, e, R, N, M, 2)) : D === 2 && splitEarcut(o, t, e, R, N, M) : earcutLinked(filterPoints(o), t, e, R, N, M, 1);
        break;
      }
    }
  }
}
function isEar(o) {
  var t = o.prev, e = o, R = o.next;
  if (area(t, e, R) >= 0)
    return !1;
  for (var N = t.x, M = e.x, D = R.x, L = t.y, B = e.y, $ = R.y, U = N < M ? N < D ? N : D : M < D ? M : D, H = L < B ? L < $ ? L : $ : B < $ ? B : $, z = N > M ? N > D ? N : D : M > D ? M : D, X = L > B ? L > $ ? L : $ : B > $ ? B : $, Y = R.next; Y !== t; ) {
    if (Y.x >= U && Y.x <= z && Y.y >= H && Y.y <= X && pointInTriangle(N, L, M, B, D, $, Y.x, Y.y) && area(Y.prev, Y, Y.next) >= 0)
      return !1;
    Y = Y.next;
  }
  return !0;
}
function isEarHashed(o, t, e, R) {
  var N = o.prev, M = o, D = o.next;
  if (area(N, M, D) >= 0)
    return !1;
  for (var L = N.x, B = M.x, $ = D.x, U = N.y, H = M.y, z = D.y, X = L < B ? L < $ ? L : $ : B < $ ? B : $, Y = U < H ? U < z ? U : z : H < z ? H : z, W = L > B ? L > $ ? L : $ : B > $ ? B : $, q = U > H ? U > z ? U : z : H > z ? H : z, Z = zOrder(X, Y, t, e, R), K = zOrder(W, q, t, e, R), J = o.prevZ, Q = o.nextZ; J && J.z >= Z && Q && Q.z <= K; ) {
    if (J.x >= X && J.x <= W && J.y >= Y && J.y <= q && J !== N && J !== D && pointInTriangle(L, U, B, H, $, z, J.x, J.y) && area(J.prev, J, J.next) >= 0 || (J = J.prevZ, Q.x >= X && Q.x <= W && Q.y >= Y && Q.y <= q && Q !== N && Q !== D && pointInTriangle(L, U, B, H, $, z, Q.x, Q.y) && area(Q.prev, Q, Q.next) >= 0))
      return !1;
    Q = Q.nextZ;
  }
  for (; J && J.z >= Z; ) {
    if (J.x >= X && J.x <= W && J.y >= Y && J.y <= q && J !== N && J !== D && pointInTriangle(L, U, B, H, $, z, J.x, J.y) && area(J.prev, J, J.next) >= 0)
      return !1;
    J = J.prevZ;
  }
  for (; Q && Q.z <= K; ) {
    if (Q.x >= X && Q.x <= W && Q.y >= Y && Q.y <= q && Q !== N && Q !== D && pointInTriangle(L, U, B, H, $, z, Q.x, Q.y) && area(Q.prev, Q, Q.next) >= 0)
      return !1;
    Q = Q.nextZ;
  }
  return !0;
}
function cureLocalIntersections(o, t, e) {
  var R = o;
  do {
    var N = R.prev, M = R.next.next;
    !equals$1(N, M) && intersects(N, R, R.next, M) && locallyInside(N, M) && locallyInside(M, N) && (t.push(N.i / e | 0), t.push(R.i / e | 0), t.push(M.i / e | 0), removeNode(R), removeNode(R.next), R = o = M), R = R.next;
  } while (R !== o);
  return filterPoints(R);
}
function splitEarcut(o, t, e, R, N, M) {
  var D = o;
  do {
    for (var L = D.next.next; L !== D.prev; ) {
      if (D.i !== L.i && isValidDiagonal(D, L)) {
        var B = splitPolygon(D, L);
        D = filterPoints(D, D.next), B = filterPoints(B, B.next), earcutLinked(D, t, e, R, N, M, 0), earcutLinked(B, t, e, R, N, M, 0);
        return;
      }
      L = L.next;
    }
    D = D.next;
  } while (D !== o);
}
function eliminateHoles(o, t, e, R) {
  var N = [], M, D, L, B, $;
  for (M = 0, D = t.length; M < D; M++)
    L = t[M] * R, B = M < D - 1 ? t[M + 1] * R : o.length, $ = linkedList(o, L, B, R, !1), $ === $.next && ($.steiner = !0), N.push(getLeftmost($));
  for (N.sort(compareX), M = 0; M < N.length; M++)
    e = eliminateHole(N[M], e);
  return e;
}
function compareX(o, t) {
  return o.x - t.x;
}
function eliminateHole(o, t) {
  var e = findHoleBridge(o, t);
  if (!e)
    return t;
  var R = splitPolygon(e, o);
  return filterPoints(R, R.next), filterPoints(e, e.next);
}
function findHoleBridge(o, t) {
  var e = t, R = o.x, N = o.y, M = -1 / 0, D;
  do {
    if (N <= e.y && N >= e.next.y && e.next.y !== e.y) {
      var L = e.x + (N - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (L <= R && L > M && (M = L, D = e.x < e.next.x ? e : e.next, L === R))
        return D;
    }
    e = e.next;
  } while (e !== t);
  if (!D)
    return null;
  var B = D, $ = D.x, U = D.y, H = 1 / 0, z;
  e = D;
  do
    R >= e.x && e.x >= $ && R !== e.x && pointInTriangle(N < U ? R : M, N, $, U, N < U ? M : R, N, e.x, e.y) && (z = Math.abs(N - e.y) / (R - e.x), locallyInside(e, o) && (z < H || z === H && (e.x > D.x || e.x === D.x && sectorContainsSector(D, e))) && (D = e, H = z)), e = e.next;
  while (e !== B);
  return D;
}
function sectorContainsSector(o, t) {
  return area(o.prev, o, t.prev) < 0 && area(t.next, o, o.next) < 0;
}
function indexCurve(o, t, e, R) {
  var N = o;
  do
    N.z === 0 && (N.z = zOrder(N.x, N.y, t, e, R)), N.prevZ = N.prev, N.nextZ = N.next, N = N.next;
  while (N !== o);
  N.prevZ.nextZ = null, N.prevZ = null, sortLinked(N);
}
function sortLinked(o) {
  var t, e, R, N, M, D, L, B, $ = 1;
  do {
    for (e = o, o = null, M = null, D = 0; e; ) {
      for (D++, R = e, L = 0, t = 0; t < $ && (L++, R = R.nextZ, !!R); t++)
        ;
      for (B = $; L > 0 || B > 0 && R; )
        L !== 0 && (B === 0 || !R || e.z <= R.z) ? (N = e, e = e.nextZ, L--) : (N = R, R = R.nextZ, B--), M ? M.nextZ = N : o = N, N.prevZ = M, M = N;
      e = R;
    }
    M.nextZ = null, $ *= 2;
  } while (D > 1);
  return o;
}
function zOrder(o, t, e, R, N) {
  return o = (o - e) * N | 0, t = (t - R) * N | 0, o = (o | o << 8) & 16711935, o = (o | o << 4) & 252645135, o = (o | o << 2) & 858993459, o = (o | o << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, o | t << 1;
}
function getLeftmost(o) {
  var t = o, e = o;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== o);
  return e;
}
function pointInTriangle(o, t, e, R, N, M, D, L) {
  return (N - D) * (t - L) >= (o - D) * (M - L) && (o - D) * (R - L) >= (e - D) * (t - L) && (e - D) * (M - L) >= (N - D) * (R - L);
}
function isValidDiagonal(o, t) {
  return o.next.i !== t.i && o.prev.i !== t.i && !intersectsPolygon(o, t) && (locallyInside(o, t) && locallyInside(t, o) && middleInside(o, t) && (area(o.prev, o, t.prev) || area(o, t.prev, t)) || equals$1(o, t) && area(o.prev, o, o.next) > 0 && area(t.prev, t, t.next) > 0);
}
function area(o, t, e) {
  return (t.y - o.y) * (e.x - t.x) - (t.x - o.x) * (e.y - t.y);
}
function equals$1(o, t) {
  return o.x === t.x && o.y === t.y;
}
function intersects(o, t, e, R) {
  var N = sign$1(area(o, t, e)), M = sign$1(area(o, t, R)), D = sign$1(area(e, R, o)), L = sign$1(area(e, R, t));
  return !!(N !== M && D !== L || N === 0 && onSegment(o, e, t) || M === 0 && onSegment(o, R, t) || D === 0 && onSegment(e, o, R) || L === 0 && onSegment(e, t, R));
}
function onSegment(o, t, e) {
  return t.x <= Math.max(o.x, e.x) && t.x >= Math.min(o.x, e.x) && t.y <= Math.max(o.y, e.y) && t.y >= Math.min(o.y, e.y);
}
function sign$1(o) {
  return o > 0 ? 1 : o < 0 ? -1 : 0;
}
function intersectsPolygon(o, t) {
  var e = o;
  do {
    if (e.i !== o.i && e.next.i !== o.i && e.i !== t.i && e.next.i !== t.i && intersects(e, e.next, o, t))
      return !0;
    e = e.next;
  } while (e !== o);
  return !1;
}
function locallyInside(o, t) {
  return area(o.prev, o, o.next) < 0 ? area(o, t, o.next) >= 0 && area(o, o.prev, t) >= 0 : area(o, t, o.prev) < 0 || area(o, o.next, t) < 0;
}
function middleInside(o, t) {
  var e = o, R = !1, N = (o.x + t.x) / 2, M = (o.y + t.y) / 2;
  do
    e.y > M != e.next.y > M && e.next.y !== e.y && N < (e.next.x - e.x) * (M - e.y) / (e.next.y - e.y) + e.x && (R = !R), e = e.next;
  while (e !== o);
  return R;
}
function splitPolygon(o, t) {
  var e = new Node$1(o.i, o.x, o.y), R = new Node$1(t.i, t.x, t.y), N = o.next, M = t.prev;
  return o.next = t, t.prev = o, e.next = N, N.prev = e, R.next = e, e.prev = R, M.next = R, R.prev = M, R;
}
function insertNode(o, t, e, R) {
  var N = new Node$1(o, t, e);
  return R ? (N.next = R.next, N.prev = R, R.next.prev = N, R.next = N) : (N.prev = N, N.next = N), N;
}
function removeNode(o) {
  o.next.prev = o.prev, o.prev.next = o.next, o.prevZ && (o.prevZ.nextZ = o.nextZ), o.nextZ && (o.nextZ.prevZ = o.prevZ);
}
function Node$1(o, t, e) {
  this.i = o, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
earcut.deviation = function(o, t, e, R) {
  var N = t && t.length, M = N ? t[0] * e : o.length, D = Math.abs(signedArea(o, 0, M, e));
  if (N)
    for (var L = 0, B = t.length; L < B; L++) {
      var $ = t[L] * e, U = L < B - 1 ? t[L + 1] * e : o.length;
      D -= Math.abs(signedArea(o, $, U, e));
    }
  var H = 0;
  for (L = 0; L < R.length; L += 3) {
    var z = R[L] * e, X = R[L + 1] * e, Y = R[L + 2] * e;
    H += Math.abs(
      (o[z] - o[Y]) * (o[X + 1] - o[z + 1]) - (o[z] - o[X]) * (o[Y + 1] - o[z + 1])
    );
  }
  return D === 0 && H === 0 ? 0 : Math.abs((H - D) / D);
};
function signedArea(o, t, e, R) {
  for (var N = 0, M = t, D = e - R; M < e; M += R)
    N += (o[D] - o[M]) * (o[M + 1] + o[D + 1]), D = M;
  return N;
}
earcut.flatten = function(o) {
  for (var t = o[0][0].length, e = { vertices: [], holes: [], dimensions: t }, R = 0, N = 0; N < o.length; N++) {
    for (var M = 0; M < o[N].length; M++)
      for (var D = 0; D < t; D++)
        e.vertices.push(o[N][M][D]);
    N > 0 && (R += o[N - 1].length, e.holes.push(R));
  }
  return e;
};
var punycode$1 = { exports: {} };
/*! https://mths.be/punycode v1.3.2 by @mathias */
(function(o, t) {
  (function(e) {
    var R = t && !t.nodeType && t, N = o && !o.nodeType && o, M = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1;
    (M.global === M || M.window === M || M.self === M) && (e = M);
    var D, L = 2147483647, B = 36, $ = 1, U = 26, H = 38, z = 700, X = 72, Y = 128, W = "-", q = /^xn--/, Z = /[^\x20-\x7E]/, K = /[\x2E\u3002\uFF0E\uFF61]/g, J = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, Q = B - $, et = Math.floor, tt = String.fromCharCode, st;
    function rt(ht) {
      throw RangeError(J[ht]);
    }
    function at(ht, bt) {
      for (var Ct = ht.length, Mt = []; Ct--; )
        Mt[Ct] = bt(ht[Ct]);
      return Mt;
    }
    function ut(ht, bt) {
      var Ct = ht.split("@"), Mt = "";
      Ct.length > 1 && (Mt = Ct[0] + "@", ht = Ct[1]), ht = ht.replace(K, ".");
      var wt = ht.split("."), Lt = at(wt, bt).join(".");
      return Mt + Lt;
    }
    function dt(ht) {
      for (var bt = [], Ct = 0, Mt = ht.length, wt, Lt; Ct < Mt; )
        wt = ht.charCodeAt(Ct++), wt >= 55296 && wt <= 56319 && Ct < Mt ? (Lt = ht.charCodeAt(Ct++), (Lt & 64512) == 56320 ? bt.push(((wt & 1023) << 10) + (Lt & 1023) + 65536) : (bt.push(wt), Ct--)) : bt.push(wt);
      return bt;
    }
    function ct(ht) {
      return at(ht, function(bt) {
        var Ct = "";
        return bt > 65535 && (bt -= 65536, Ct += tt(bt >>> 10 & 1023 | 55296), bt = 56320 | bt & 1023), Ct += tt(bt), Ct;
      }).join("");
    }
    function pt(ht) {
      return ht - 48 < 10 ? ht - 22 : ht - 65 < 26 ? ht - 65 : ht - 97 < 26 ? ht - 97 : B;
    }
    function mt(ht, bt) {
      return ht + 22 + 75 * (ht < 26) - ((bt != 0) << 5);
    }
    function vt(ht, bt, Ct) {
      var Mt = 0;
      for (ht = Ct ? et(ht / z) : ht >> 1, ht += et(ht / bt); ht > Q * U >> 1; Mt += B)
        ht = et(ht / Q);
      return et(Mt + (Q + 1) * ht / (ht + H));
    }
    function _t(ht) {
      var bt = [], Ct = ht.length, Mt, wt = 0, Lt = Y, ft = X, Gt, Dt, Bt, Ot, Et, Ht, It, St, Nt;
      for (Gt = ht.lastIndexOf(W), Gt < 0 && (Gt = 0), Dt = 0; Dt < Gt; ++Dt)
        ht.charCodeAt(Dt) >= 128 && rt("not-basic"), bt.push(ht.charCodeAt(Dt));
      for (Bt = Gt > 0 ? Gt + 1 : 0; Bt < Ct; ) {
        for (Ot = wt, Et = 1, Ht = B; Bt >= Ct && rt("invalid-input"), It = pt(ht.charCodeAt(Bt++)), (It >= B || It > et((L - wt) / Et)) && rt("overflow"), wt += It * Et, St = Ht <= ft ? $ : Ht >= ft + U ? U : Ht - ft, !(It < St); Ht += B)
          Nt = B - St, Et > et(L / Nt) && rt("overflow"), Et *= Nt;
        Mt = bt.length + 1, ft = vt(wt - Ot, Mt, Ot == 0), et(wt / Mt) > L - Lt && rt("overflow"), Lt += et(wt / Mt), wt %= Mt, bt.splice(wt++, 0, Lt);
      }
      return ct(bt);
    }
    function xt(ht) {
      var bt, Ct, Mt, wt, Lt, ft, Gt, Dt, Bt, Ot, Et, Ht = [], It, St, Nt, $t;
      for (ht = dt(ht), It = ht.length, bt = Y, Ct = 0, Lt = X, ft = 0; ft < It; ++ft)
        Et = ht[ft], Et < 128 && Ht.push(tt(Et));
      for (Mt = wt = Ht.length, wt && Ht.push(W); Mt < It; ) {
        for (Gt = L, ft = 0; ft < It; ++ft)
          Et = ht[ft], Et >= bt && Et < Gt && (Gt = Et);
        for (St = Mt + 1, Gt - bt > et((L - Ct) / St) && rt("overflow"), Ct += (Gt - bt) * St, bt = Gt, ft = 0; ft < It; ++ft)
          if (Et = ht[ft], Et < bt && ++Ct > L && rt("overflow"), Et == bt) {
            for (Dt = Ct, Bt = B; Ot = Bt <= Lt ? $ : Bt >= Lt + U ? U : Bt - Lt, !(Dt < Ot); Bt += B)
              $t = Dt - Ot, Nt = B - Ot, Ht.push(
                tt(mt(Ot + $t % Nt, 0))
              ), Dt = et($t / Nt);
            Ht.push(tt(mt(Dt, 0))), Lt = vt(Ct, St, Mt == wt), Ct = 0, ++Mt;
          }
        ++Ct, ++bt;
      }
      return Ht.join("");
    }
    function At(ht) {
      return ut(ht, function(bt) {
        return q.test(bt) ? _t(bt.slice(4).toLowerCase()) : bt;
      });
    }
    function yt(ht) {
      return ut(ht, function(bt) {
        return Z.test(bt) ? "xn--" + xt(bt) : bt;
      });
    }
    if (D = {
      version: "1.3.2",
      ucs2: {
        decode: dt,
        encode: ct
      },
      decode: _t,
      encode: xt,
      toASCII: yt,
      toUnicode: At
    }, R && N)
      if (o.exports == R)
        N.exports = D;
      else
        for (st in D)
          D.hasOwnProperty(st) && (R[st] = D[st]);
    else
      e.punycode = D;
  })(commonjsGlobal$1);
})(punycode$1, punycode$1.exports);
var util$8 = {
  isString: function(o) {
    return typeof o == "string";
  },
  isObject: function(o) {
    return typeof o == "object" && o !== null;
  },
  isNull: function(o) {
    return o === null;
  },
  isNullOrUndefined: function(o) {
    return o == null;
  }
}, querystring$1 = {};
function hasOwnProperty$1(o, t) {
  return Object.prototype.hasOwnProperty.call(o, t);
}
var decode$3 = function(o, t, e, R) {
  t = t || "&", e = e || "=";
  var N = {};
  if (typeof o != "string" || o.length === 0)
    return N;
  var M = /\+/g;
  o = o.split(t);
  var D = 1e3;
  R && typeof R.maxKeys == "number" && (D = R.maxKeys);
  var L = o.length;
  D > 0 && L > D && (L = D);
  for (var B = 0; B < L; ++B) {
    var $ = o[B].replace(M, "%20"), U = $.indexOf(e), H, z, X, Y;
    U >= 0 ? (H = $.substr(0, U), z = $.substr(U + 1)) : (H = $, z = ""), X = decodeURIComponent(H), Y = decodeURIComponent(z), hasOwnProperty$1(N, X) ? Array.isArray(N[X]) ? N[X].push(Y) : N[X] = [N[X], Y] : N[X] = Y;
  }
  return N;
}, stringifyPrimitive$1 = function(o) {
  switch (typeof o) {
    case "string":
      return o;
    case "boolean":
      return o ? "true" : "false";
    case "number":
      return isFinite(o) ? o : "";
    default:
      return "";
  }
}, encode$3 = function(o, t, e, R) {
  return t = t || "&", e = e || "=", o === null && (o = void 0), typeof o == "object" ? Object.keys(o).map(function(N) {
    var M = encodeURIComponent(stringifyPrimitive$1(N)) + e;
    return Array.isArray(o[N]) ? o[N].map(function(D) {
      return M + encodeURIComponent(stringifyPrimitive$1(D));
    }).join(t) : M + encodeURIComponent(stringifyPrimitive$1(o[N]));
  }).join(t) : R ? encodeURIComponent(stringifyPrimitive$1(R)) + e + encodeURIComponent(stringifyPrimitive$1(o)) : "";
};
querystring$1.decode = querystring$1.parse = decode$3;
querystring$1.encode = querystring$1.stringify = encode$3;
var punycode = punycode$1.exports, util$7 = util$8, parse$2 = urlParse, resolve = urlResolve, format$1 = urlFormat;
function Url() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", `
`, "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  javascript: !0,
  "javascript:": !0
}, hostlessProtocol = {
  javascript: !0,
  "javascript:": !0
}, slashedProtocol = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
}, querystring = querystring$1;
function urlParse(o, t, e) {
  if (o && util$7.isObject(o) && o instanceof Url)
    return o;
  var R = new Url();
  return R.parse(o, t, e), R;
}
Url.prototype.parse = function(o, t, e) {
  if (!util$7.isString(o))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof o);
  var R = o.indexOf("?"), N = R !== -1 && R < o.indexOf("#") ? "?" : "#", M = o.split(N), D = /\\/g;
  M[0] = M[0].replace(D, "/"), o = M.join(N);
  var L = o;
  if (L = L.trim(), !e && o.split("#").length === 1) {
    var B = simplePathPattern.exec(L);
    if (B)
      return this.path = L, this.href = L, this.pathname = B[1], B[2] ? (this.search = B[2], t ? this.query = querystring.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
  }
  var $ = protocolPattern.exec(L);
  if ($) {
    $ = $[0];
    var U = $.toLowerCase();
    this.protocol = U, L = L.substr($.length);
  }
  if (e || $ || L.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var H = L.substr(0, 2) === "//";
    H && !($ && hostlessProtocol[$]) && (L = L.substr(2), this.slashes = !0);
  }
  if (!hostlessProtocol[$] && (H || $ && !slashedProtocol[$])) {
    for (var z = -1, X = 0; X < hostEndingChars.length; X++) {
      var Y = L.indexOf(hostEndingChars[X]);
      Y !== -1 && (z === -1 || Y < z) && (z = Y);
    }
    var W, q;
    z === -1 ? q = L.lastIndexOf("@") : q = L.lastIndexOf("@", z), q !== -1 && (W = L.slice(0, q), L = L.slice(q + 1), this.auth = decodeURIComponent(W)), z = -1;
    for (var X = 0; X < nonHostChars.length; X++) {
      var Y = L.indexOf(nonHostChars[X]);
      Y !== -1 && (z === -1 || Y < z) && (z = Y);
    }
    z === -1 && (z = L.length), this.host = L.slice(0, z), L = L.slice(z), this.parseHost(), this.hostname = this.hostname || "";
    var Z = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!Z)
      for (var K = this.hostname.split(/\./), X = 0, J = K.length; X < J; X++) {
        var Q = K[X];
        if (!!Q && !Q.match(hostnamePartPattern)) {
          for (var et = "", tt = 0, st = Q.length; tt < st; tt++)
            Q.charCodeAt(tt) > 127 ? et += "x" : et += Q[tt];
          if (!et.match(hostnamePartPattern)) {
            var rt = K.slice(0, X), at = K.slice(X + 1), ut = Q.match(hostnamePartStart);
            ut && (rt.push(ut[1]), at.unshift(ut[2])), at.length && (L = "/" + at.join(".") + L), this.hostname = rt.join(".");
            break;
          }
        }
      }
    this.hostname.length > hostnameMaxLen ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), Z || (this.hostname = punycode.toASCII(this.hostname));
    var dt = this.port ? ":" + this.port : "", ct = this.hostname || "";
    this.host = ct + dt, this.href += this.host, Z && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), L[0] !== "/" && (L = "/" + L));
  }
  if (!unsafeProtocol[U])
    for (var X = 0, J = autoEscape.length; X < J; X++) {
      var pt = autoEscape[X];
      if (L.indexOf(pt) !== -1) {
        var mt = encodeURIComponent(pt);
        mt === pt && (mt = escape(pt)), L = L.split(pt).join(mt);
      }
    }
  var vt = L.indexOf("#");
  vt !== -1 && (this.hash = L.substr(vt), L = L.slice(0, vt));
  var _t = L.indexOf("?");
  if (_t !== -1 ? (this.search = L.substr(_t), this.query = L.substr(_t + 1), t && (this.query = querystring.parse(this.query)), L = L.slice(0, _t)) : t && (this.search = "", this.query = {}), L && (this.pathname = L), slashedProtocol[U] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var dt = this.pathname || "", xt = this.search || "";
    this.path = dt + xt;
  }
  return this.href = this.format(), this;
};
function urlFormat(o) {
  return util$7.isString(o) && (o = urlParse(o)), o instanceof Url ? o.format() : Url.prototype.format.call(o);
}
Url.prototype.format = function() {
  var o = this.auth || "";
  o && (o = encodeURIComponent(o), o = o.replace(/%3A/i, ":"), o += "@");
  var t = this.protocol || "", e = this.pathname || "", R = this.hash || "", N = !1, M = "";
  this.host ? N = o + this.host : this.hostname && (N = o + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (N += ":" + this.port)), this.query && util$7.isObject(this.query) && Object.keys(this.query).length && (M = querystring.stringify(this.query));
  var D = this.search || M && "?" + M || "";
  return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || slashedProtocol[t]) && N !== !1 ? (N = "//" + (N || ""), e && e.charAt(0) !== "/" && (e = "/" + e)) : N || (N = ""), R && R.charAt(0) !== "#" && (R = "#" + R), D && D.charAt(0) !== "?" && (D = "?" + D), e = e.replace(/[?#]/g, function(L) {
    return encodeURIComponent(L);
  }), D = D.replace("#", "%23"), t + N + e + D + R;
};
function urlResolve(o, t) {
  return urlParse(o, !1, !0).resolve(t);
}
Url.prototype.resolve = function(o) {
  return this.resolveObject(urlParse(o, !1, !0)).format();
};
Url.prototype.resolveObject = function(o) {
  if (util$7.isString(o)) {
    var t = new Url();
    t.parse(o, !1, !0), o = t;
  }
  for (var e = new Url(), R = Object.keys(this), N = 0; N < R.length; N++) {
    var M = R[N];
    e[M] = this[M];
  }
  if (e.hash = o.hash, o.href === "")
    return e.href = e.format(), e;
  if (o.slashes && !o.protocol) {
    for (var D = Object.keys(o), L = 0; L < D.length; L++) {
      var B = D[L];
      B !== "protocol" && (e[B] = o[B]);
    }
    return slashedProtocol[e.protocol] && e.hostname && !e.pathname && (e.path = e.pathname = "/"), e.href = e.format(), e;
  }
  if (o.protocol && o.protocol !== e.protocol) {
    if (!slashedProtocol[o.protocol]) {
      for (var $ = Object.keys(o), U = 0; U < $.length; U++) {
        var H = $[U];
        e[H] = o[H];
      }
      return e.href = e.format(), e;
    }
    if (e.protocol = o.protocol, !o.host && !hostlessProtocol[o.protocol]) {
      for (var J = (o.pathname || "").split("/"); J.length && !(o.host = J.shift()); )
        ;
      o.host || (o.host = ""), o.hostname || (o.hostname = ""), J[0] !== "" && J.unshift(""), J.length < 2 && J.unshift(""), e.pathname = J.join("/");
    } else
      e.pathname = o.pathname;
    if (e.search = o.search, e.query = o.query, e.host = o.host || "", e.auth = o.auth, e.hostname = o.hostname || o.host, e.port = o.port, e.pathname || e.search) {
      var z = e.pathname || "", X = e.search || "";
      e.path = z + X;
    }
    return e.slashes = e.slashes || o.slashes, e.href = e.format(), e;
  }
  var Y = e.pathname && e.pathname.charAt(0) === "/", W = o.host || o.pathname && o.pathname.charAt(0) === "/", q = W || Y || e.host && o.pathname, Z = q, K = e.pathname && e.pathname.split("/") || [], J = o.pathname && o.pathname.split("/") || [], Q = e.protocol && !slashedProtocol[e.protocol];
  if (Q && (e.hostname = "", e.port = null, e.host && (K[0] === "" ? K[0] = e.host : K.unshift(e.host)), e.host = "", o.protocol && (o.hostname = null, o.port = null, o.host && (J[0] === "" ? J[0] = o.host : J.unshift(o.host)), o.host = null), q = q && (J[0] === "" || K[0] === "")), W)
    e.host = o.host || o.host === "" ? o.host : e.host, e.hostname = o.hostname || o.hostname === "" ? o.hostname : e.hostname, e.search = o.search, e.query = o.query, K = J;
  else if (J.length)
    K || (K = []), K.pop(), K = K.concat(J), e.search = o.search, e.query = o.query;
  else if (!util$7.isNullOrUndefined(o.search)) {
    if (Q) {
      e.hostname = e.host = K.shift();
      var et = e.host && e.host.indexOf("@") > 0 ? e.host.split("@") : !1;
      et && (e.auth = et.shift(), e.host = e.hostname = et.shift());
    }
    return e.search = o.search, e.query = o.query, (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : "") + (e.search ? e.search : "")), e.href = e.format(), e;
  }
  if (!K.length)
    return e.pathname = null, e.search ? e.path = "/" + e.search : e.path = null, e.href = e.format(), e;
  for (var tt = K.slice(-1)[0], st = (e.host || o.host || K.length > 1) && (tt === "." || tt === "..") || tt === "", rt = 0, at = K.length; at >= 0; at--)
    tt = K[at], tt === "." ? K.splice(at, 1) : tt === ".." ? (K.splice(at, 1), rt++) : rt && (K.splice(at, 1), rt--);
  if (!q && !Z)
    for (; rt--; rt)
      K.unshift("..");
  q && K[0] !== "" && (!K[0] || K[0].charAt(0) !== "/") && K.unshift(""), st && K.join("/").substr(-1) !== "/" && K.push("");
  var ut = K[0] === "" || K[0] && K[0].charAt(0) === "/";
  if (Q) {
    e.hostname = e.host = ut ? "" : K.length ? K.shift() : "";
    var et = e.host && e.host.indexOf("@") > 0 ? e.host.split("@") : !1;
    et && (e.auth = et.shift(), e.host = e.hostname = et.shift());
  }
  return q = q || e.host && K.length, q && !ut && K.unshift(""), K.length ? e.pathname = K.join("/") : (e.pathname = null, e.path = null), (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : "") + (e.search ? e.search : "")), e.auth = o.auth || e.auth, e.slashes = e.slashes || o.slashes, e.href = e.format(), e;
};
Url.prototype.parseHost = function() {
  var o = this.host, t = portPattern.exec(o);
  t && (t = t[0], t !== ":" && (this.port = t.substr(1)), o = o.substr(0, o.length - t.length)), o && (this.hostname = o);
};
/*!
 * @pixi/constants - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$5;
(function(o) {
  o[o.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", o[o.WEBGL = 1] = "WEBGL", o[o.WEBGL2 = 2] = "WEBGL2";
})(ENV$5 || (ENV$5 = {}));
var RENDERER_TYPE$5;
(function(o) {
  o[o.UNKNOWN = 0] = "UNKNOWN", o[o.WEBGL = 1] = "WEBGL", o[o.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE$5 || (RENDERER_TYPE$5 = {}));
var BUFFER_BITS$5;
(function(o) {
  o[o.COLOR = 16384] = "COLOR", o[o.DEPTH = 256] = "DEPTH", o[o.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS$5 || (BUFFER_BITS$5 = {}));
var BLEND_MODES$5;
(function(o) {
  o[o.NORMAL = 0] = "NORMAL", o[o.ADD = 1] = "ADD", o[o.MULTIPLY = 2] = "MULTIPLY", o[o.SCREEN = 3] = "SCREEN", o[o.OVERLAY = 4] = "OVERLAY", o[o.DARKEN = 5] = "DARKEN", o[o.LIGHTEN = 6] = "LIGHTEN", o[o.COLOR_DODGE = 7] = "COLOR_DODGE", o[o.COLOR_BURN = 8] = "COLOR_BURN", o[o.HARD_LIGHT = 9] = "HARD_LIGHT", o[o.SOFT_LIGHT = 10] = "SOFT_LIGHT", o[o.DIFFERENCE = 11] = "DIFFERENCE", o[o.EXCLUSION = 12] = "EXCLUSION", o[o.HUE = 13] = "HUE", o[o.SATURATION = 14] = "SATURATION", o[o.COLOR = 15] = "COLOR", o[o.LUMINOSITY = 16] = "LUMINOSITY", o[o.NORMAL_NPM = 17] = "NORMAL_NPM", o[o.ADD_NPM = 18] = "ADD_NPM", o[o.SCREEN_NPM = 19] = "SCREEN_NPM", o[o.NONE = 20] = "NONE", o[o.SRC_OVER = 0] = "SRC_OVER", o[o.SRC_IN = 21] = "SRC_IN", o[o.SRC_OUT = 22] = "SRC_OUT", o[o.SRC_ATOP = 23] = "SRC_ATOP", o[o.DST_OVER = 24] = "DST_OVER", o[o.DST_IN = 25] = "DST_IN", o[o.DST_OUT = 26] = "DST_OUT", o[o.DST_ATOP = 27] = "DST_ATOP", o[o.ERASE = 26] = "ERASE", o[o.SUBTRACT = 28] = "SUBTRACT", o[o.XOR = 29] = "XOR";
})(BLEND_MODES$5 || (BLEND_MODES$5 = {}));
var DRAW_MODES$5;
(function(o) {
  o[o.POINTS = 0] = "POINTS", o[o.LINES = 1] = "LINES", o[o.LINE_LOOP = 2] = "LINE_LOOP", o[o.LINE_STRIP = 3] = "LINE_STRIP", o[o.TRIANGLES = 4] = "TRIANGLES", o[o.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", o[o.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$5 || (DRAW_MODES$5 = {}));
var FORMATS$5;
(function(o) {
  o[o.RGBA = 6408] = "RGBA", o[o.RGB = 6407] = "RGB", o[o.RG = 33319] = "RG", o[o.RED = 6403] = "RED", o[o.RGBA_INTEGER = 36249] = "RGBA_INTEGER", o[o.RGB_INTEGER = 36248] = "RGB_INTEGER", o[o.RG_INTEGER = 33320] = "RG_INTEGER", o[o.RED_INTEGER = 36244] = "RED_INTEGER", o[o.ALPHA = 6406] = "ALPHA", o[o.LUMINANCE = 6409] = "LUMINANCE", o[o.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", o[o.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", o[o.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS$5 || (FORMATS$5 = {}));
var TARGETS$5;
(function(o) {
  o[o.TEXTURE_2D = 3553] = "TEXTURE_2D", o[o.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", o[o.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", o[o.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", o[o.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", o[o.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", o[o.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$5 || (TARGETS$5 = {}));
var TYPES$5;
(function(o) {
  o[o.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", o[o.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", o[o.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", o[o.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", o[o.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", o[o.UNSIGNED_INT = 5125] = "UNSIGNED_INT", o[o.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", o[o.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", o[o.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", o[o.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", o[o.BYTE = 5120] = "BYTE", o[o.SHORT = 5122] = "SHORT", o[o.INT = 5124] = "INT", o[o.FLOAT = 5126] = "FLOAT", o[o.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", o[o.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES$5 || (TYPES$5 = {}));
var SAMPLER_TYPES$5;
(function(o) {
  o[o.FLOAT = 0] = "FLOAT", o[o.INT = 1] = "INT", o[o.UINT = 2] = "UINT";
})(SAMPLER_TYPES$5 || (SAMPLER_TYPES$5 = {}));
var SCALE_MODES$5;
(function(o) {
  o[o.NEAREST = 0] = "NEAREST", o[o.LINEAR = 1] = "LINEAR";
})(SCALE_MODES$5 || (SCALE_MODES$5 = {}));
var WRAP_MODES$5;
(function(o) {
  o[o.CLAMP = 33071] = "CLAMP", o[o.REPEAT = 10497] = "REPEAT", o[o.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$5 || (WRAP_MODES$5 = {}));
var MIPMAP_MODES$5;
(function(o) {
  o[o.OFF = 0] = "OFF", o[o.POW2 = 1] = "POW2", o[o.ON = 2] = "ON", o[o.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES$5 || (MIPMAP_MODES$5 = {}));
var ALPHA_MODES$5;
(function(o) {
  o[o.NPM = 0] = "NPM", o[o.UNPACK = 1] = "UNPACK", o[o.PMA = 2] = "PMA", o[o.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", o[o.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", o[o.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", o[o.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$5 || (ALPHA_MODES$5 = {}));
var CLEAR_MODES$5;
(function(o) {
  o[o.NO = 0] = "NO", o[o.YES = 1] = "YES", o[o.AUTO = 2] = "AUTO", o[o.BLEND = 0] = "BLEND", o[o.CLEAR = 1] = "CLEAR", o[o.BLIT = 2] = "BLIT";
})(CLEAR_MODES$5 || (CLEAR_MODES$5 = {}));
var GC_MODES$5;
(function(o) {
  o[o.AUTO = 0] = "AUTO", o[o.MANUAL = 1] = "MANUAL";
})(GC_MODES$5 || (GC_MODES$5 = {}));
var PRECISION$5;
(function(o) {
  o.LOW = "lowp", o.MEDIUM = "mediump", o.HIGH = "highp";
})(PRECISION$5 || (PRECISION$5 = {}));
var MASK_TYPES$5;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.SCISSOR = 1] = "SCISSOR", o[o.STENCIL = 2] = "STENCIL", o[o.SPRITE = 3] = "SPRITE", o[o.COLOR = 4] = "COLOR";
})(MASK_TYPES$5 || (MASK_TYPES$5 = {}));
var COLOR_MASK_BITS$5;
(function(o) {
  o[o.RED = 1] = "RED", o[o.GREEN = 2] = "GREEN", o[o.BLUE = 4] = "BLUE", o[o.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS$5 || (COLOR_MASK_BITS$5 = {}));
var MSAA_QUALITY$5;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.LOW = 2] = "LOW", o[o.MEDIUM = 4] = "MEDIUM", o[o.HIGH = 8] = "HIGH";
})(MSAA_QUALITY$5 || (MSAA_QUALITY$5 = {}));
var BUFFER_TYPE$5;
(function(o) {
  o[o.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", o[o.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", o[o.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$5 || (BUFFER_TYPE$5 = {}));
/*!
 * @pixi/utils - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var url$1 = {
  parse: parse$2,
  format: format$1,
  resolve
};
settings$1.RETINA_PREFIX = /@([0-9\.]+)x/;
settings$1.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var saidHello = !1, VERSION = "6.5.3";
function skipHello() {
  saidHello = !0;
}
function sayHello(o) {
  var t;
  if (!saidHello) {
    if (settings$1.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      var e = [
        `
 %c %c %c PixiJS ` + VERSION + " - \u2730 " + o + ` \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 

`,
        "background: #ff66a5; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff66a5; background: #030307; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "background: #ffc3dc; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;"
      ];
      (t = globalThis.console).log.apply(t, e);
    } else
      globalThis.console && globalThis.console.log("PixiJS " + VERSION + " - " + o + " - http://www.pixijs.com/");
    saidHello = !0;
  }
}
var supported;
function isWebGLSupported() {
  return typeof supported > "u" && (supported = function() {
    var t = {
      stencil: !0,
      failIfMajorPerformanceCaveat: settings$1.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
    };
    try {
      if (!settings$1.ADAPTER.getWebGLRenderingContext())
        return !1;
      var e = settings$1.ADAPTER.createCanvas(), R = e.getContext("webgl", t) || e.getContext("experimental-webgl", t), N = !!(R && R.getContextAttributes().stencil);
      if (R) {
        var M = R.getExtension("WEBGL_lose_context");
        M && M.loseContext();
      }
      return R = null, N;
    } catch {
      return !1;
    }
  }()), supported;
}
var aliceblue = "#f0f8ff", antiquewhite = "#faebd7", aqua = "#00ffff", aquamarine = "#7fffd4", azure = "#f0ffff", beige = "#f5f5dc", bisque = "#ffe4c4", black = "#000000", blanchedalmond = "#ffebcd", blue = "#0000ff", blueviolet = "#8a2be2", brown = "#a52a2a", burlywood = "#deb887", cadetblue = "#5f9ea0", chartreuse = "#7fff00", chocolate = "#d2691e", coral = "#ff7f50", cornflowerblue = "#6495ed", cornsilk = "#fff8dc", crimson = "#dc143c", cyan = "#00ffff", darkblue = "#00008b", darkcyan = "#008b8b", darkgoldenrod = "#b8860b", darkgray = "#a9a9a9", darkgreen = "#006400", darkgrey = "#a9a9a9", darkkhaki = "#bdb76b", darkmagenta = "#8b008b", darkolivegreen = "#556b2f", darkorange = "#ff8c00", darkorchid = "#9932cc", darkred = "#8b0000", darksalmon = "#e9967a", darkseagreen = "#8fbc8f", darkslateblue = "#483d8b", darkslategray = "#2f4f4f", darkslategrey = "#2f4f4f", darkturquoise = "#00ced1", darkviolet = "#9400d3", deeppink = "#ff1493", deepskyblue = "#00bfff", dimgray = "#696969", dimgrey = "#696969", dodgerblue = "#1e90ff", firebrick = "#b22222", floralwhite = "#fffaf0", forestgreen = "#228b22", fuchsia = "#ff00ff", gainsboro = "#dcdcdc", ghostwhite = "#f8f8ff", goldenrod = "#daa520", gold = "#ffd700", gray = "#808080", green = "#008000", greenyellow = "#adff2f", grey = "#808080", honeydew = "#f0fff0", hotpink = "#ff69b4", indianred = "#cd5c5c", indigo = "#4b0082", ivory = "#fffff0", khaki = "#f0e68c", lavenderblush = "#fff0f5", lavender = "#e6e6fa", lawngreen = "#7cfc00", lemonchiffon = "#fffacd", lightblue = "#add8e6", lightcoral = "#f08080", lightcyan = "#e0ffff", lightgoldenrodyellow = "#fafad2", lightgray = "#d3d3d3", lightgreen = "#90ee90", lightgrey = "#d3d3d3", lightpink = "#ffb6c1", lightsalmon = "#ffa07a", lightseagreen = "#20b2aa", lightskyblue = "#87cefa", lightslategray = "#778899", lightslategrey = "#778899", lightsteelblue = "#b0c4de", lightyellow = "#ffffe0", lime = "#00ff00", limegreen = "#32cd32", linen = "#faf0e6", magenta = "#ff00ff", maroon = "#800000", mediumaquamarine = "#66cdaa", mediumblue = "#0000cd", mediumorchid = "#ba55d3", mediumpurple = "#9370db", mediumseagreen = "#3cb371", mediumslateblue = "#7b68ee", mediumspringgreen = "#00fa9a", mediumturquoise = "#48d1cc", mediumvioletred = "#c71585", midnightblue = "#191970", mintcream = "#f5fffa", mistyrose = "#ffe4e1", moccasin = "#ffe4b5", navajowhite = "#ffdead", navy = "#000080", oldlace = "#fdf5e6", olive = "#808000", olivedrab = "#6b8e23", orange = "#ffa500", orangered = "#ff4500", orchid = "#da70d6", palegoldenrod = "#eee8aa", palegreen = "#98fb98", paleturquoise = "#afeeee", palevioletred = "#db7093", papayawhip = "#ffefd5", peachpuff = "#ffdab9", peru = "#cd853f", pink = "#ffc0cb", plum = "#dda0dd", powderblue = "#b0e0e6", purple = "#800080", rebeccapurple = "#663399", red = "#ff0000", rosybrown = "#bc8f8f", royalblue = "#4169e1", saddlebrown = "#8b4513", salmon = "#fa8072", sandybrown = "#f4a460", seagreen = "#2e8b57", seashell = "#fff5ee", sienna = "#a0522d", silver = "#c0c0c0", skyblue = "#87ceeb", slateblue = "#6a5acd", slategray = "#708090", slategrey = "#708090", snow = "#fffafa", springgreen = "#00ff7f", steelblue = "#4682b4", tan = "#d2b48c", teal = "#008080", thistle = "#d8bfd8", tomato = "#ff6347", turquoise = "#40e0d0", violet = "#ee82ee", wheat = "#f5deb3", white = "#ffffff", whitesmoke = "#f5f5f5", yellow = "#ffff00", yellowgreen = "#9acd32", cssColorNames = {
  aliceblue,
  antiquewhite,
  aqua,
  aquamarine,
  azure,
  beige,
  bisque,
  black,
  blanchedalmond,
  blue,
  blueviolet,
  brown,
  burlywood,
  cadetblue,
  chartreuse,
  chocolate,
  coral,
  cornflowerblue,
  cornsilk,
  crimson,
  cyan,
  darkblue,
  darkcyan,
  darkgoldenrod,
  darkgray,
  darkgreen,
  darkgrey,
  darkkhaki,
  darkmagenta,
  darkolivegreen,
  darkorange,
  darkorchid,
  darkred,
  darksalmon,
  darkseagreen,
  darkslateblue,
  darkslategray,
  darkslategrey,
  darkturquoise,
  darkviolet,
  deeppink,
  deepskyblue,
  dimgray,
  dimgrey,
  dodgerblue,
  firebrick,
  floralwhite,
  forestgreen,
  fuchsia,
  gainsboro,
  ghostwhite,
  goldenrod,
  gold,
  gray,
  green,
  greenyellow,
  grey,
  honeydew,
  hotpink,
  indianred,
  indigo,
  ivory,
  khaki,
  lavenderblush,
  lavender,
  lawngreen,
  lemonchiffon,
  lightblue,
  lightcoral,
  lightcyan,
  lightgoldenrodyellow,
  lightgray,
  lightgreen,
  lightgrey,
  lightpink,
  lightsalmon,
  lightseagreen,
  lightskyblue,
  lightslategray,
  lightslategrey,
  lightsteelblue,
  lightyellow,
  lime,
  limegreen,
  linen,
  magenta,
  maroon,
  mediumaquamarine,
  mediumblue,
  mediumorchid,
  mediumpurple,
  mediumseagreen,
  mediumslateblue,
  mediumspringgreen,
  mediumturquoise,
  mediumvioletred,
  midnightblue,
  mintcream,
  mistyrose,
  moccasin,
  navajowhite,
  navy,
  oldlace,
  olive,
  olivedrab,
  orange,
  orangered,
  orchid,
  palegoldenrod,
  palegreen,
  paleturquoise,
  palevioletred,
  papayawhip,
  peachpuff,
  peru,
  pink,
  plum,
  powderblue,
  purple,
  rebeccapurple,
  red,
  rosybrown,
  royalblue,
  saddlebrown,
  salmon,
  sandybrown,
  seagreen,
  seashell,
  sienna,
  silver,
  skyblue,
  slateblue,
  slategray,
  slategrey,
  snow,
  springgreen,
  steelblue,
  tan,
  teal,
  thistle,
  tomato,
  turquoise,
  violet,
  wheat,
  white,
  whitesmoke,
  yellow,
  yellowgreen
};
function hex2rgb(o, t) {
  return t === void 0 && (t = []), t[0] = (o >> 16 & 255) / 255, t[1] = (o >> 8 & 255) / 255, t[2] = (o & 255) / 255, t;
}
function hex2string(o) {
  var t = o.toString(16);
  return t = "000000".substring(0, 6 - t.length) + t, "#" + t;
}
function string2hex(o) {
  return typeof o == "string" && (o = cssColorNames[o.toLowerCase()] || o, o[0] === "#" && (o = o.slice(1))), parseInt(o, 16);
}
function mapPremultipliedBlendModes$1() {
  for (var o = [], t = [], e = 0; e < 32; e++)
    o[e] = e, t[e] = e;
  o[BLEND_MODES$5.NORMAL_NPM] = BLEND_MODES$5.NORMAL, o[BLEND_MODES$5.ADD_NPM] = BLEND_MODES$5.ADD, o[BLEND_MODES$5.SCREEN_NPM] = BLEND_MODES$5.SCREEN, t[BLEND_MODES$5.NORMAL] = BLEND_MODES$5.NORMAL_NPM, t[BLEND_MODES$5.ADD] = BLEND_MODES$5.ADD_NPM, t[BLEND_MODES$5.SCREEN] = BLEND_MODES$5.SCREEN_NPM;
  var R = [];
  return R.push(t), R.push(o), R;
}
var premultiplyBlendMode = mapPremultipliedBlendModes$1();
function correctBlendMode(o, t) {
  return premultiplyBlendMode[t ? 1 : 0][o];
}
function premultiplyRgba(o, t, e, R) {
  return e = e || new Float32Array(4), R || R === void 0 ? (e[0] = o[0] * t, e[1] = o[1] * t, e[2] = o[2] * t) : (e[0] = o[0], e[1] = o[1], e[2] = o[2]), e[3] = t, e;
}
function premultiplyTint(o, t) {
  if (t === 1)
    return (t * 255 << 24) + o;
  if (t === 0)
    return 0;
  var e = o >> 16 & 255, R = o >> 8 & 255, N = o & 255;
  return e = e * t + 0.5 | 0, R = R * t + 0.5 | 0, N = N * t + 0.5 | 0, (t * 255 << 24) + (e << 16) + (R << 8) + N;
}
function premultiplyTintToRgba(o, t, e, R) {
  return e = e || new Float32Array(4), e[0] = (o >> 16 & 255) / 255, e[1] = (o >> 8 & 255) / 255, e[2] = (o & 255) / 255, (R || R === void 0) && (e[0] *= t, e[1] *= t, e[2] *= t), e[3] = t, e;
}
function createIndicesForQuads(o, t) {
  t === void 0 && (t = null);
  var e = o * 6;
  if (t = t || new Uint16Array(e), t.length !== e)
    throw new Error("Out buffer length is incorrect, got " + t.length + " and expected " + e);
  for (var R = 0, N = 0; R < e; R += 6, N += 4)
    t[R + 0] = N + 0, t[R + 1] = N + 1, t[R + 2] = N + 2, t[R + 3] = N + 0, t[R + 4] = N + 2, t[R + 5] = N + 3;
  return t;
}
function getBufferType(o) {
  if (o.BYTES_PER_ELEMENT === 4)
    return o instanceof Float32Array ? "Float32Array" : o instanceof Uint32Array ? "Uint32Array" : "Int32Array";
  if (o.BYTES_PER_ELEMENT === 2) {
    if (o instanceof Uint16Array)
      return "Uint16Array";
  } else if (o.BYTES_PER_ELEMENT === 1 && o instanceof Uint8Array)
    return "Uint8Array";
  return null;
}
function nextPow2(o) {
  return o += o === 0 ? 1 : 0, --o, o |= o >>> 1, o |= o >>> 2, o |= o >>> 4, o |= o >>> 8, o |= o >>> 16, o + 1;
}
function isPow2(o) {
  return !(o & o - 1) && !!o;
}
function log2(o) {
  var t = (o > 65535 ? 1 : 0) << 4;
  o >>>= t;
  var e = (o > 255 ? 1 : 0) << 3;
  return o >>>= e, t |= e, e = (o > 15 ? 1 : 0) << 2, o >>>= e, t |= e, e = (o > 3 ? 1 : 0) << 1, o >>>= e, t |= e, t | o >> 1;
}
function removeItems(o, t, e) {
  var R = o.length, N;
  if (!(t >= R || e === 0)) {
    e = t + e > R ? R - t : e;
    var M = R - e;
    for (N = t; N < M; ++N)
      o[N] = o[N + e];
    o.length = M;
  }
}
function sign(o) {
  return o === 0 ? 0 : o < 0 ? -1 : 1;
}
var nextUid = 0;
function uid() {
  return ++nextUid;
}
var warnings$1 = {};
function deprecation$1(o, t, e) {
  if (e === void 0 && (e = 3), !warnings$1[t]) {
    var R = new Error().stack;
    typeof R > "u" ? console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + o) : (R = R.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", t + `
Deprecated since v` + o), console.warn(R), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + o), console.warn(R))), warnings$1[t] = !0;
  }
}
var ProgramCache = {}, TextureCache = /* @__PURE__ */ Object.create(null), BaseTextureCache = /* @__PURE__ */ Object.create(null);
function clearTextureCache() {
  var o;
  for (o in TextureCache)
    delete TextureCache[o];
  for (o in BaseTextureCache)
    delete BaseTextureCache[o];
}
var CanvasRenderTarget = function() {
  function o(t, e, R) {
    this.canvas = settings$1.ADAPTER.createCanvas(), this.context = this.canvas.getContext("2d"), this.resolution = R || settings$1.RESOLUTION, this.resize(t, e);
  }
  return o.prototype.clear = function() {
    this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }, o.prototype.resize = function(t, e) {
    this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);
  }, o.prototype.destroy = function() {
    this.context = null, this.canvas = null;
  }, Object.defineProperty(o.prototype, "width", {
    get: function() {
      return this.canvas.width;
    },
    set: function(t) {
      this.canvas.width = Math.round(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "height", {
    get: function() {
      return this.canvas.height;
    },
    set: function(t) {
      this.canvas.height = Math.round(t);
    },
    enumerable: !1,
    configurable: !0
  }), o;
}();
function trimCanvas(o) {
  var t = o.width, e = o.height, R = o.getContext("2d"), N = R.getImageData(0, 0, t, e), M = N.data, D = M.length, L = {
    top: null,
    left: null,
    right: null,
    bottom: null
  }, B = null, $, U, H;
  for ($ = 0; $ < D; $ += 4)
    M[$ + 3] !== 0 && (U = $ / 4 % t, H = ~~($ / 4 / t), L.top === null && (L.top = H), (L.left === null || U < L.left) && (L.left = U), (L.right === null || L.right < U) && (L.right = U + 1), (L.bottom === null || L.bottom < H) && (L.bottom = H));
  return L.top !== null && (t = L.right - L.left, e = L.bottom - L.top + 1, B = R.getImageData(L.left, L.top, t, e)), {
    height: e,
    width: t,
    data: B
  };
}
var tempAnchor$1;
function determineCrossOrigin(o, t) {
  if (t === void 0 && (t = globalThis.location), o.indexOf("data:") === 0)
    return "";
  t = t || globalThis.location, tempAnchor$1 || (tempAnchor$1 = document.createElement("a")), tempAnchor$1.href = o;
  var e = url$1.parse(tempAnchor$1.href), R = !e.port && t.port === "" || e.port === t.port;
  return e.hostname !== t.hostname || !R || e.protocol !== t.protocol ? "anonymous" : "";
}
function getResolutionOfUrl(o, t) {
  var e = settings$1.RETINA_PREFIX.exec(o);
  return e ? parseFloat(e[1]) : t !== void 0 ? t : 1;
}
/*!
 * @pixi/math - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var PI_2 = Math.PI * 2, RAD_TO_DEG = 180 / Math.PI, DEG_TO_RAD = Math.PI / 180, SHAPES;
(function(o) {
  o[o.POLY = 0] = "POLY", o[o.RECT = 1] = "RECT", o[o.CIRC = 2] = "CIRC", o[o.ELIP = 3] = "ELIP", o[o.RREC = 4] = "RREC";
})(SHAPES || (SHAPES = {}));
var Point = function() {
  function o(t, e) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e;
  }
  return o.prototype.clone = function() {
    return new o(this.x, this.y);
  }, o.prototype.copyFrom = function(t) {
    return this.set(t.x, t.y), this;
  }, o.prototype.copyTo = function(t) {
    return t.set(this.x, this.y), t;
  }, o.prototype.equals = function(t) {
    return t.x === this.x && t.y === this.y;
  }, o.prototype.set = function(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = t), this.x = t, this.y = e, this;
  }, o.prototype.toString = function() {
    return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
  }, o;
}(), tempPoints$1 = [new Point(), new Point(), new Point(), new Point()], Rectangle = function() {
  function o(t, e, R, N) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), R === void 0 && (R = 0), N === void 0 && (N = 0), this.x = Number(t), this.y = Number(e), this.width = Number(R), this.height = Number(N), this.type = SHAPES.RECT;
  }
  return Object.defineProperty(o.prototype, "left", {
    get: function() {
      return this.x;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "right", {
    get: function() {
      return this.x + this.width;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "top", {
    get: function() {
      return this.y;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "bottom", {
    get: function() {
      return this.y + this.height;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "EMPTY", {
    get: function() {
      return new o(0, 0, 0, 0);
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.clone = function() {
    return new o(this.x, this.y, this.width, this.height);
  }, o.prototype.copyFrom = function(t) {
    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
  }, o.prototype.copyTo = function(t) {
    return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
  }, o.prototype.contains = function(t, e) {
    return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
  }, o.prototype.intersects = function(t, e) {
    if (!e) {
      var R = this.x < t.x ? t.x : this.x, N = this.right > t.right ? t.right : this.right;
      if (N <= R)
        return !1;
      var M = this.y < t.y ? t.y : this.y, D = this.bottom > t.bottom ? t.bottom : this.bottom;
      return D > M;
    }
    var L = this.left, B = this.right, $ = this.top, U = this.bottom;
    if (B <= L || U <= $)
      return !1;
    var H = tempPoints$1[0].set(t.left, t.top), z = tempPoints$1[1].set(t.left, t.bottom), X = tempPoints$1[2].set(t.right, t.top), Y = tempPoints$1[3].set(t.right, t.bottom);
    if (X.x <= H.x || z.y <= H.y)
      return !1;
    var W = Math.sign(e.a * e.d - e.b * e.c);
    if (W === 0 || (e.apply(H, H), e.apply(z, z), e.apply(X, X), e.apply(Y, Y), Math.max(H.x, z.x, X.x, Y.x) <= L || Math.min(H.x, z.x, X.x, Y.x) >= B || Math.max(H.y, z.y, X.y, Y.y) <= $ || Math.min(H.y, z.y, X.y, Y.y) >= U))
      return !1;
    var q = W * (z.y - H.y), Z = W * (H.x - z.x), K = q * L + Z * $, J = q * B + Z * $, Q = q * L + Z * U, et = q * B + Z * U;
    if (Math.max(K, J, Q, et) <= q * H.x + Z * H.y || Math.min(K, J, Q, et) >= q * Y.x + Z * Y.y)
      return !1;
    var tt = W * (H.y - X.y), st = W * (X.x - H.x), rt = tt * L + st * $, at = tt * B + st * $, ut = tt * L + st * U, dt = tt * B + st * U;
    return !(Math.max(rt, at, ut, dt) <= tt * H.x + st * H.y || Math.min(rt, at, ut, dt) >= tt * Y.x + st * Y.y);
  }, o.prototype.pad = function(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = t), this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
  }, o.prototype.fit = function(t) {
    var e = Math.max(this.x, t.x), R = Math.min(this.x + this.width, t.x + t.width), N = Math.max(this.y, t.y), M = Math.min(this.y + this.height, t.y + t.height);
    return this.x = e, this.width = Math.max(R - e, 0), this.y = N, this.height = Math.max(M - N, 0), this;
  }, o.prototype.ceil = function(t, e) {
    t === void 0 && (t = 1), e === void 0 && (e = 1e-3);
    var R = Math.ceil((this.x + this.width - e) * t) / t, N = Math.ceil((this.y + this.height - e) * t) / t;
    return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = R - this.x, this.height = N - this.y, this;
  }, o.prototype.enlarge = function(t) {
    var e = Math.min(this.x, t.x), R = Math.max(this.x + this.width, t.x + t.width), N = Math.min(this.y, t.y), M = Math.max(this.y + this.height, t.y + t.height);
    return this.x = e, this.width = R - e, this.y = N, this.height = M - N, this;
  }, o.prototype.toString = function() {
    return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
  }, o;
}(), Circle = function() {
  function o(t, e, R) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), R === void 0 && (R = 0), this.x = t, this.y = e, this.radius = R, this.type = SHAPES.CIRC;
  }
  return o.prototype.clone = function() {
    return new o(this.x, this.y, this.radius);
  }, o.prototype.contains = function(t, e) {
    if (this.radius <= 0)
      return !1;
    var R = this.radius * this.radius, N = this.x - t, M = this.y - e;
    return N *= N, M *= M, N + M <= R;
  }, o.prototype.getBounds = function() {
    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }, o.prototype.toString = function() {
    return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
  }, o;
}(), Ellipse = function() {
  function o(t, e, R, N) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), R === void 0 && (R = 0), N === void 0 && (N = 0), this.x = t, this.y = e, this.width = R, this.height = N, this.type = SHAPES.ELIP;
  }
  return o.prototype.clone = function() {
    return new o(this.x, this.y, this.width, this.height);
  }, o.prototype.contains = function(t, e) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    var R = (t - this.x) / this.width, N = (e - this.y) / this.height;
    return R *= R, N *= N, R + N <= 1;
  }, o.prototype.getBounds = function() {
    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
  }, o.prototype.toString = function() {
    return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
  }, o;
}(), Polygon = function() {
  function o() {
    for (var t = arguments, e = [], R = 0; R < arguments.length; R++)
      e[R] = t[R];
    var N = Array.isArray(e[0]) ? e[0] : e;
    if (typeof N[0] != "number") {
      for (var M = [], D = 0, L = N.length; D < L; D++)
        M.push(N[D].x, N[D].y);
      N = M;
    }
    this.points = N, this.type = SHAPES.POLY, this.closeStroke = !0;
  }
  return o.prototype.clone = function() {
    var t = this.points.slice(), e = new o(t);
    return e.closeStroke = this.closeStroke, e;
  }, o.prototype.contains = function(t, e) {
    for (var R = !1, N = this.points.length / 2, M = 0, D = N - 1; M < N; D = M++) {
      var L = this.points[M * 2], B = this.points[M * 2 + 1], $ = this.points[D * 2], U = this.points[D * 2 + 1], H = B > e != U > e && t < ($ - L) * ((e - B) / (U - B)) + L;
      H && (R = !R);
    }
    return R;
  }, o.prototype.toString = function() {
    return "[@pixi/math:Polygon" + ("closeStroke=" + this.closeStroke) + ("points=" + this.points.reduce(function(t, e) {
      return t + ", " + e;
    }, "") + "]");
  }, o;
}(), RoundedRectangle = function() {
  function o(t, e, R, N, M) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), R === void 0 && (R = 0), N === void 0 && (N = 0), M === void 0 && (M = 20), this.x = t, this.y = e, this.width = R, this.height = N, this.radius = M, this.type = SHAPES.RREC;
  }
  return o.prototype.clone = function() {
    return new o(this.x, this.y, this.width, this.height, this.radius);
  }, o.prototype.contains = function(t, e) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
      var R = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
      if (e >= this.y + R && e <= this.y + this.height - R || t >= this.x + R && t <= this.x + this.width - R)
        return !0;
      var N = t - (this.x + R), M = e - (this.y + R), D = R * R;
      if (N * N + M * M <= D || (N = t - (this.x + this.width - R), N * N + M * M <= D) || (M = e - (this.y + this.height - R), N * N + M * M <= D) || (N = t - (this.x + R), N * N + M * M <= D))
        return !0;
    }
    return !1;
  }, o.prototype.toString = function() {
    return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + ("width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]");
  }, o;
}(), ObservablePoint = function() {
  function o(t, e, R, N) {
    R === void 0 && (R = 0), N === void 0 && (N = 0), this._x = R, this._y = N, this.cb = t, this.scope = e;
  }
  return o.prototype.clone = function(t, e) {
    return t === void 0 && (t = this.cb), e === void 0 && (e = this.scope), new o(t, e, this._x, this._y);
  }, o.prototype.set = function(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = t), (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this.cb.call(this.scope)), this;
  }, o.prototype.copyFrom = function(t) {
    return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this;
  }, o.prototype.copyTo = function(t) {
    return t.set(this._x, this._y), t;
  }, o.prototype.equals = function(t) {
    return t.x === this._x && t.y === this._y;
  }, o.prototype.toString = function() {
    return "[@pixi/math:ObservablePoint x=" + 0 + " y=" + 0 + " scope=" + this.scope + "]";
  }, Object.defineProperty(o.prototype, "x", {
    get: function() {
      return this._x;
    },
    set: function(t) {
      this._x !== t && (this._x = t, this.cb.call(this.scope));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "y", {
    get: function() {
      return this._y;
    },
    set: function(t) {
      this._y !== t && (this._y = t, this.cb.call(this.scope));
    },
    enumerable: !1,
    configurable: !0
  }), o;
}(), Matrix = function() {
  function o(t, e, R, N, M, D) {
    t === void 0 && (t = 1), e === void 0 && (e = 0), R === void 0 && (R = 0), N === void 0 && (N = 1), M === void 0 && (M = 0), D === void 0 && (D = 0), this.array = null, this.a = t, this.b = e, this.c = R, this.d = N, this.tx = M, this.ty = D;
  }
  return o.prototype.fromArray = function(t) {
    this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
  }, o.prototype.set = function(t, e, R, N, M, D) {
    return this.a = t, this.b = e, this.c = R, this.d = N, this.tx = M, this.ty = D, this;
  }, o.prototype.toArray = function(t, e) {
    this.array || (this.array = new Float32Array(9));
    var R = e || this.array;
    return t ? (R[0] = this.a, R[1] = this.b, R[2] = 0, R[3] = this.c, R[4] = this.d, R[5] = 0, R[6] = this.tx, R[7] = this.ty, R[8] = 1) : (R[0] = this.a, R[1] = this.c, R[2] = this.tx, R[3] = this.b, R[4] = this.d, R[5] = this.ty, R[6] = 0, R[7] = 0, R[8] = 1), R;
  }, o.prototype.apply = function(t, e) {
    e = e || new Point();
    var R = t.x, N = t.y;
    return e.x = this.a * R + this.c * N + this.tx, e.y = this.b * R + this.d * N + this.ty, e;
  }, o.prototype.applyInverse = function(t, e) {
    e = e || new Point();
    var R = 1 / (this.a * this.d + this.c * -this.b), N = t.x, M = t.y;
    return e.x = this.d * R * N + -this.c * R * M + (this.ty * this.c - this.tx * this.d) * R, e.y = this.a * R * M + -this.b * R * N + (-this.ty * this.a + this.tx * this.b) * R, e;
  }, o.prototype.translate = function(t, e) {
    return this.tx += t, this.ty += e, this;
  }, o.prototype.scale = function(t, e) {
    return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
  }, o.prototype.rotate = function(t) {
    var e = Math.cos(t), R = Math.sin(t), N = this.a, M = this.c, D = this.tx;
    return this.a = N * e - this.b * R, this.b = N * R + this.b * e, this.c = M * e - this.d * R, this.d = M * R + this.d * e, this.tx = D * e - this.ty * R, this.ty = D * R + this.ty * e, this;
  }, o.prototype.append = function(t) {
    var e = this.a, R = this.b, N = this.c, M = this.d;
    return this.a = t.a * e + t.b * N, this.b = t.a * R + t.b * M, this.c = t.c * e + t.d * N, this.d = t.c * R + t.d * M, this.tx = t.tx * e + t.ty * N + this.tx, this.ty = t.tx * R + t.ty * M + this.ty, this;
  }, o.prototype.setTransform = function(t, e, R, N, M, D, L, B, $) {
    return this.a = Math.cos(L + $) * M, this.b = Math.sin(L + $) * M, this.c = -Math.sin(L - B) * D, this.d = Math.cos(L - B) * D, this.tx = t - (R * this.a + N * this.c), this.ty = e - (R * this.b + N * this.d), this;
  }, o.prototype.prepend = function(t) {
    var e = this.tx;
    if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
      var R = this.a, N = this.c;
      this.a = R * t.a + this.b * t.c, this.b = R * t.b + this.b * t.d, this.c = N * t.a + this.d * t.c, this.d = N * t.b + this.d * t.d;
    }
    return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
  }, o.prototype.decompose = function(t) {
    var e = this.a, R = this.b, N = this.c, M = this.d, D = t.pivot, L = -Math.atan2(-N, M), B = Math.atan2(R, e), $ = Math.abs(L + B);
    return $ < 1e-5 || Math.abs(PI_2 - $) < 1e-5 ? (t.rotation = B, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = L, t.skew.y = B), t.scale.x = Math.sqrt(e * e + R * R), t.scale.y = Math.sqrt(N * N + M * M), t.position.x = this.tx + (D.x * e + D.y * N), t.position.y = this.ty + (D.x * R + D.y * M), t;
  }, o.prototype.invert = function() {
    var t = this.a, e = this.b, R = this.c, N = this.d, M = this.tx, D = t * N - e * R;
    return this.a = N / D, this.b = -e / D, this.c = -R / D, this.d = t / D, this.tx = (R * this.ty - N * M) / D, this.ty = -(t * this.ty - e * M) / D, this;
  }, o.prototype.identity = function() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  }, o.prototype.clone = function() {
    var t = new o();
    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
  }, o.prototype.copyTo = function(t) {
    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
  }, o.prototype.copyFrom = function(t) {
    return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
  }, o.prototype.toString = function() {
    return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
  }, Object.defineProperty(o, "IDENTITY", {
    get: function() {
      return new o();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "TEMP_MATRIX", {
    get: function() {
      return new o();
    },
    enumerable: !1,
    configurable: !0
  }), o;
}(), ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], rotationCayley = [], rotationMatrices = [], signum = Math.sign;
function init() {
  for (var o = 0; o < 16; o++) {
    var t = [];
    rotationCayley.push(t);
    for (var e = 0; e < 16; e++)
      for (var R = signum(ux[o] * ux[e] + vx[o] * uy[e]), N = signum(uy[o] * ux[e] + vy[o] * uy[e]), M = signum(ux[o] * vx[e] + vx[o] * vy[e]), D = signum(uy[o] * vx[e] + vy[o] * vy[e]), L = 0; L < 16; L++)
        if (ux[L] === R && uy[L] === N && vx[L] === M && vy[L] === D) {
          t.push(L);
          break;
        }
  }
  for (var o = 0; o < 16; o++) {
    var B = new Matrix();
    B.set(ux[o], uy[o], vx[o], vy[o], 0, 0), rotationMatrices.push(B);
  }
}
init();
var groupD8 = {
  E: 0,
  SE: 1,
  S: 2,
  SW: 3,
  W: 4,
  NW: 5,
  N: 6,
  NE: 7,
  MIRROR_VERTICAL: 8,
  MAIN_DIAGONAL: 10,
  MIRROR_HORIZONTAL: 12,
  REVERSE_DIAGONAL: 14,
  uX: function(o) {
    return ux[o];
  },
  uY: function(o) {
    return uy[o];
  },
  vX: function(o) {
    return vx[o];
  },
  vY: function(o) {
    return vy[o];
  },
  inv: function(o) {
    return o & 8 ? o & 15 : -o & 7;
  },
  add: function(o, t) {
    return rotationCayley[o][t];
  },
  sub: function(o, t) {
    return rotationCayley[o][groupD8.inv(t)];
  },
  rotate180: function(o) {
    return o ^ 4;
  },
  isVertical: function(o) {
    return (o & 3) === 2;
  },
  byDirection: function(o, t) {
    return Math.abs(o) * 2 <= Math.abs(t) ? t >= 0 ? groupD8.S : groupD8.N : Math.abs(t) * 2 <= Math.abs(o) ? o > 0 ? groupD8.E : groupD8.W : t > 0 ? o > 0 ? groupD8.SE : groupD8.SW : o > 0 ? groupD8.NE : groupD8.NW;
  },
  matrixAppendRotationInv: function(o, t, e, R) {
    e === void 0 && (e = 0), R === void 0 && (R = 0);
    var N = rotationMatrices[groupD8.inv(t)];
    N.tx = e, N.ty = R, o.append(N);
  }
}, Transform = function() {
  function o() {
    this.worldTransform = new Matrix(), this.localTransform = new Matrix(), this.position = new ObservablePoint(this.onChange, this, 0, 0), this.scale = new ObservablePoint(this.onChange, this, 1, 1), this.pivot = new ObservablePoint(this.onChange, this, 0, 0), this.skew = new ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
  }
  return o.prototype.onChange = function() {
    this._localID++;
  }, o.prototype.updateSkew = function() {
    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
  }, o.prototype.toString = function() {
    return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
  }, o.prototype.updateLocalTransform = function() {
    var t = this.localTransform;
    this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1);
  }, o.prototype.updateTransform = function(t) {
    var e = this.localTransform;
    if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {
      var R = t.worldTransform, N = this.worldTransform;
      N.a = e.a * R.a + e.b * R.c, N.b = e.a * R.b + e.b * R.d, N.c = e.c * R.a + e.d * R.c, N.d = e.c * R.b + e.d * R.d, N.tx = e.tx * R.a + e.ty * R.c + R.tx, N.ty = e.tx * R.b + e.ty * R.d + R.ty, this._parentID = t._worldID, this._worldID++;
    }
  }, o.prototype.setFromMatrix = function(t) {
    t.decompose(this), this._localID++;
  }, Object.defineProperty(o.prototype, "rotation", {
    get: function() {
      return this._rotation;
    },
    set: function(t) {
      this._rotation !== t && (this._rotation = t, this.updateSkew());
    },
    enumerable: !1,
    configurable: !0
  }), o.IDENTITY = new o(), o;
}();
/*!
 * @pixi/display - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$1.SORTABLE_CHILDREN = !1;
var Bounds = function() {
  function o() {
    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
  }
  return o.prototype.isEmpty = function() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }, o.prototype.clear = function() {
    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
  }, o.prototype.getRectangle = function(t) {
    return this.minX > this.maxX || this.minY > this.maxY ? Rectangle.EMPTY : (t = t || new Rectangle(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t);
  }, o.prototype.addPoint = function(t) {
    this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y);
  }, o.prototype.addPointMatrix = function(t, e) {
    var R = t.a, N = t.b, M = t.c, D = t.d, L = t.tx, B = t.ty, $ = R * e.x + M * e.y + L, U = N * e.x + D * e.y + B;
    this.minX = Math.min(this.minX, $), this.maxX = Math.max(this.maxX, $), this.minY = Math.min(this.minY, U), this.maxY = Math.max(this.maxY, U);
  }, o.prototype.addQuad = function(t) {
    var e = this.minX, R = this.minY, N = this.maxX, M = this.maxY, D = t[0], L = t[1];
    e = D < e ? D : e, R = L < R ? L : R, N = D > N ? D : N, M = L > M ? L : M, D = t[2], L = t[3], e = D < e ? D : e, R = L < R ? L : R, N = D > N ? D : N, M = L > M ? L : M, D = t[4], L = t[5], e = D < e ? D : e, R = L < R ? L : R, N = D > N ? D : N, M = L > M ? L : M, D = t[6], L = t[7], e = D < e ? D : e, R = L < R ? L : R, N = D > N ? D : N, M = L > M ? L : M, this.minX = e, this.minY = R, this.maxX = N, this.maxY = M;
  }, o.prototype.addFrame = function(t, e, R, N, M) {
    this.addFrameMatrix(t.worldTransform, e, R, N, M);
  }, o.prototype.addFrameMatrix = function(t, e, R, N, M) {
    var D = t.a, L = t.b, B = t.c, $ = t.d, U = t.tx, H = t.ty, z = this.minX, X = this.minY, Y = this.maxX, W = this.maxY, q = D * e + B * R + U, Z = L * e + $ * R + H;
    z = q < z ? q : z, X = Z < X ? Z : X, Y = q > Y ? q : Y, W = Z > W ? Z : W, q = D * N + B * R + U, Z = L * N + $ * R + H, z = q < z ? q : z, X = Z < X ? Z : X, Y = q > Y ? q : Y, W = Z > W ? Z : W, q = D * e + B * M + U, Z = L * e + $ * M + H, z = q < z ? q : z, X = Z < X ? Z : X, Y = q > Y ? q : Y, W = Z > W ? Z : W, q = D * N + B * M + U, Z = L * N + $ * M + H, z = q < z ? q : z, X = Z < X ? Z : X, Y = q > Y ? q : Y, W = Z > W ? Z : W, this.minX = z, this.minY = X, this.maxX = Y, this.maxY = W;
  }, o.prototype.addVertexData = function(t, e, R) {
    for (var N = this.minX, M = this.minY, D = this.maxX, L = this.maxY, B = e; B < R; B += 2) {
      var $ = t[B], U = t[B + 1];
      N = $ < N ? $ : N, M = U < M ? U : M, D = $ > D ? $ : D, L = U > L ? U : L;
    }
    this.minX = N, this.minY = M, this.maxX = D, this.maxY = L;
  }, o.prototype.addVertices = function(t, e, R, N) {
    this.addVerticesMatrix(t.worldTransform, e, R, N);
  }, o.prototype.addVerticesMatrix = function(t, e, R, N, M, D) {
    M === void 0 && (M = 0), D === void 0 && (D = M);
    for (var L = t.a, B = t.b, $ = t.c, U = t.d, H = t.tx, z = t.ty, X = this.minX, Y = this.minY, W = this.maxX, q = this.maxY, Z = R; Z < N; Z += 2) {
      var K = e[Z], J = e[Z + 1], Q = L * K + $ * J + H, et = U * J + B * K + z;
      X = Math.min(X, Q - M), W = Math.max(W, Q + M), Y = Math.min(Y, et - D), q = Math.max(q, et + D);
    }
    this.minX = X, this.minY = Y, this.maxX = W, this.maxY = q;
  }, o.prototype.addBounds = function(t) {
    var e = this.minX, R = this.minY, N = this.maxX, M = this.maxY;
    this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < R ? t.minY : R, this.maxX = t.maxX > N ? t.maxX : N, this.maxY = t.maxY > M ? t.maxY : M;
  }, o.prototype.addBoundsMask = function(t, e) {
    var R = t.minX > e.minX ? t.minX : e.minX, N = t.minY > e.minY ? t.minY : e.minY, M = t.maxX < e.maxX ? t.maxX : e.maxX, D = t.maxY < e.maxY ? t.maxY : e.maxY;
    if (R <= M && N <= D) {
      var L = this.minX, B = this.minY, $ = this.maxX, U = this.maxY;
      this.minX = R < L ? R : L, this.minY = N < B ? N : B, this.maxX = M > $ ? M : $, this.maxY = D > U ? D : U;
    }
  }, o.prototype.addBoundsMatrix = function(t, e) {
    this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);
  }, o.prototype.addBoundsArea = function(t, e) {
    var R = t.minX > e.x ? t.minX : e.x, N = t.minY > e.y ? t.minY : e.y, M = t.maxX < e.x + e.width ? t.maxX : e.x + e.width, D = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
    if (R <= M && N <= D) {
      var L = this.minX, B = this.minY, $ = this.maxX, U = this.maxY;
      this.minX = R < L ? R : L, this.minY = N < B ? N : B, this.maxX = M > $ ? M : $, this.maxY = D > U ? D : U;
    }
  }, o.prototype.pad = function(t, e) {
    t === void 0 && (t = 0), e === void 0 && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e);
  }, o.prototype.addFramePad = function(t, e, R, N, M, D) {
    t -= M, e -= D, R += M, N += D, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > R ? this.maxX : R, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > N ? this.maxY : N;
  }, o;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$q = function(o, t) {
  return extendStatics$q = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$q(o, t);
};
function __extends$q(o, t) {
  extendStatics$q(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var DisplayObject = function(o) {
  __extends$q(t, o);
  function t() {
    var e = o.call(this) || this;
    return e.tempDisplayObjectParent = null, e.transform = new Transform(), e.alpha = 1, e.visible = !0, e.renderable = !0, e.cullable = !1, e.cullArea = null, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new Bounds(), e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._maskRefCount = 0, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e;
  }
  return t.mixin = function(e) {
    for (var R = Object.keys(e), N = 0; N < R.length; ++N) {
      var M = R[N];
      Object.defineProperty(t.prototype, M, Object.getOwnPropertyDescriptor(e, M));
    }
  }, Object.defineProperty(t.prototype, "destroyed", {
    get: function() {
      return this._destroyed;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._recursivePostUpdateTransform = function() {
    this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
  }, t.prototype.updateTransform = function() {
    this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
  }, t.prototype.getBounds = function(e, R) {
    return e || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), R || (this._boundsRect || (this._boundsRect = new Rectangle()), R = this._boundsRect), this._bounds.getRectangle(R);
  }, t.prototype.getLocalBounds = function(e) {
    e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds || (this._localBounds = new Bounds());
    var R = this.transform, N = this.parent;
    this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
    var M = this._bounds, D = this._boundsID;
    this._bounds = this._localBounds;
    var L = this.getBounds(!1, e);
    return this.parent = N, this.transform = R, this._bounds = M, this._bounds.updateID += this._boundsID - D, L;
  }, t.prototype.toGlobal = function(e, R, N) {
    return N === void 0 && (N = !1), N || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(e, R);
  }, t.prototype.toLocal = function(e, R, N, M) {
    return R && (e = R.toGlobal(e, N, M)), M || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(e, N);
  }, t.prototype.setParent = function(e) {
    if (!e || !e.addChild)
      throw new Error("setParent: Argument must be a Container");
    return e.addChild(this), e;
  }, t.prototype.setTransform = function(e, R, N, M, D, L, B, $, U) {
    return e === void 0 && (e = 0), R === void 0 && (R = 0), N === void 0 && (N = 1), M === void 0 && (M = 1), D === void 0 && (D = 0), L === void 0 && (L = 0), B === void 0 && (B = 0), $ === void 0 && ($ = 0), U === void 0 && (U = 0), this.position.x = e, this.position.y = R, this.scale.x = N || 1, this.scale.y = M || 1, this.rotation = D, this.skew.x = L, this.skew.y = B, this.pivot.x = $, this.pivot.y = U, this;
  }, t.prototype.destroy = function(e) {
    this.parent && this.parent.removeChild(this), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners();
  }, Object.defineProperty(t.prototype, "_tempDisplayObjectParent", {
    get: function() {
      return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new TemporaryDisplayObject()), this.tempDisplayObjectParent;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.enableTempParent = function() {
    var e = this.parent;
    return this.parent = this._tempDisplayObjectParent, e;
  }, t.prototype.disableTempParent = function(e) {
    this.parent = e;
  }, Object.defineProperty(t.prototype, "x", {
    get: function() {
      return this.position.x;
    },
    set: function(e) {
      this.transform.position.x = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "y", {
    get: function() {
      return this.position.y;
    },
    set: function(e) {
      this.transform.position.y = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "worldTransform", {
    get: function() {
      return this.transform.worldTransform;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "localTransform", {
    get: function() {
      return this.transform.localTransform;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "position", {
    get: function() {
      return this.transform.position;
    },
    set: function(e) {
      this.transform.position.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "scale", {
    get: function() {
      return this.transform.scale;
    },
    set: function(e) {
      this.transform.scale.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "pivot", {
    get: function() {
      return this.transform.pivot;
    },
    set: function(e) {
      this.transform.pivot.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "skew", {
    get: function() {
      return this.transform.skew;
    },
    set: function(e) {
      this.transform.skew.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "rotation", {
    get: function() {
      return this.transform.rotation;
    },
    set: function(e) {
      this.transform.rotation = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "angle", {
    get: function() {
      return this.transform.rotation * RAD_TO_DEG;
    },
    set: function(e) {
      this.transform.rotation = e * DEG_TO_RAD;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "zIndex", {
    get: function() {
      return this._zIndex;
    },
    set: function(e) {
      this._zIndex = e, this.parent && (this.parent.sortDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "worldVisible", {
    get: function() {
      var e = this;
      do {
        if (!e.visible)
          return !1;
        e = e.parent;
      } while (e);
      return !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "mask", {
    get: function() {
      return this._mask;
    },
    set: function(e) {
      if (this._mask !== e) {
        if (this._mask) {
          var R = this._mask.isMaskData ? this._mask.maskObject : this._mask;
          R && (R._maskRefCount--, R._maskRefCount === 0 && (R.renderable = !0, R.isMask = !1));
        }
        if (this._mask = e, this._mask) {
          var R = this._mask.isMaskData ? this._mask.maskObject : this._mask;
          R && (R._maskRefCount === 0 && (R.renderable = !1, R.isMask = !0), R._maskRefCount++);
        }
      }
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(n), TemporaryDisplayObject = function(o) {
  __extends$q(t, o);
  function t() {
    var e = o !== null && o.apply(this, arguments) || this;
    return e.sortDirty = null, e;
  }
  return t;
}(DisplayObject);
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
/*!
 * @pixi/constants - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$4;
(function(o) {
  o[o.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", o[o.WEBGL = 1] = "WEBGL", o[o.WEBGL2 = 2] = "WEBGL2";
})(ENV$4 || (ENV$4 = {}));
var RENDERER_TYPE$4;
(function(o) {
  o[o.UNKNOWN = 0] = "UNKNOWN", o[o.WEBGL = 1] = "WEBGL", o[o.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE$4 || (RENDERER_TYPE$4 = {}));
var BUFFER_BITS$4;
(function(o) {
  o[o.COLOR = 16384] = "COLOR", o[o.DEPTH = 256] = "DEPTH", o[o.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS$4 || (BUFFER_BITS$4 = {}));
var BLEND_MODES$4;
(function(o) {
  o[o.NORMAL = 0] = "NORMAL", o[o.ADD = 1] = "ADD", o[o.MULTIPLY = 2] = "MULTIPLY", o[o.SCREEN = 3] = "SCREEN", o[o.OVERLAY = 4] = "OVERLAY", o[o.DARKEN = 5] = "DARKEN", o[o.LIGHTEN = 6] = "LIGHTEN", o[o.COLOR_DODGE = 7] = "COLOR_DODGE", o[o.COLOR_BURN = 8] = "COLOR_BURN", o[o.HARD_LIGHT = 9] = "HARD_LIGHT", o[o.SOFT_LIGHT = 10] = "SOFT_LIGHT", o[o.DIFFERENCE = 11] = "DIFFERENCE", o[o.EXCLUSION = 12] = "EXCLUSION", o[o.HUE = 13] = "HUE", o[o.SATURATION = 14] = "SATURATION", o[o.COLOR = 15] = "COLOR", o[o.LUMINOSITY = 16] = "LUMINOSITY", o[o.NORMAL_NPM = 17] = "NORMAL_NPM", o[o.ADD_NPM = 18] = "ADD_NPM", o[o.SCREEN_NPM = 19] = "SCREEN_NPM", o[o.NONE = 20] = "NONE", o[o.SRC_OVER = 0] = "SRC_OVER", o[o.SRC_IN = 21] = "SRC_IN", o[o.SRC_OUT = 22] = "SRC_OUT", o[o.SRC_ATOP = 23] = "SRC_ATOP", o[o.DST_OVER = 24] = "DST_OVER", o[o.DST_IN = 25] = "DST_IN", o[o.DST_OUT = 26] = "DST_OUT", o[o.DST_ATOP = 27] = "DST_ATOP", o[o.ERASE = 26] = "ERASE", o[o.SUBTRACT = 28] = "SUBTRACT", o[o.XOR = 29] = "XOR";
})(BLEND_MODES$4 || (BLEND_MODES$4 = {}));
var DRAW_MODES$4;
(function(o) {
  o[o.POINTS = 0] = "POINTS", o[o.LINES = 1] = "LINES", o[o.LINE_LOOP = 2] = "LINE_LOOP", o[o.LINE_STRIP = 3] = "LINE_STRIP", o[o.TRIANGLES = 4] = "TRIANGLES", o[o.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", o[o.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$4 || (DRAW_MODES$4 = {}));
var FORMATS$4;
(function(o) {
  o[o.RGBA = 6408] = "RGBA", o[o.RGB = 6407] = "RGB", o[o.RG = 33319] = "RG", o[o.RED = 6403] = "RED", o[o.RGBA_INTEGER = 36249] = "RGBA_INTEGER", o[o.RGB_INTEGER = 36248] = "RGB_INTEGER", o[o.RG_INTEGER = 33320] = "RG_INTEGER", o[o.RED_INTEGER = 36244] = "RED_INTEGER", o[o.ALPHA = 6406] = "ALPHA", o[o.LUMINANCE = 6409] = "LUMINANCE", o[o.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", o[o.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", o[o.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS$4 || (FORMATS$4 = {}));
var TARGETS$4;
(function(o) {
  o[o.TEXTURE_2D = 3553] = "TEXTURE_2D", o[o.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", o[o.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", o[o.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", o[o.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", o[o.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", o[o.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$4 || (TARGETS$4 = {}));
var TYPES$4;
(function(o) {
  o[o.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", o[o.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", o[o.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", o[o.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", o[o.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", o[o.UNSIGNED_INT = 5125] = "UNSIGNED_INT", o[o.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", o[o.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", o[o.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", o[o.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", o[o.BYTE = 5120] = "BYTE", o[o.SHORT = 5122] = "SHORT", o[o.INT = 5124] = "INT", o[o.FLOAT = 5126] = "FLOAT", o[o.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", o[o.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES$4 || (TYPES$4 = {}));
var SAMPLER_TYPES$4;
(function(o) {
  o[o.FLOAT = 0] = "FLOAT", o[o.INT = 1] = "INT", o[o.UINT = 2] = "UINT";
})(SAMPLER_TYPES$4 || (SAMPLER_TYPES$4 = {}));
var SCALE_MODES$4;
(function(o) {
  o[o.NEAREST = 0] = "NEAREST", o[o.LINEAR = 1] = "LINEAR";
})(SCALE_MODES$4 || (SCALE_MODES$4 = {}));
var WRAP_MODES$4;
(function(o) {
  o[o.CLAMP = 33071] = "CLAMP", o[o.REPEAT = 10497] = "REPEAT", o[o.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$4 || (WRAP_MODES$4 = {}));
var MIPMAP_MODES$4;
(function(o) {
  o[o.OFF = 0] = "OFF", o[o.POW2 = 1] = "POW2", o[o.ON = 2] = "ON", o[o.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES$4 || (MIPMAP_MODES$4 = {}));
var ALPHA_MODES$4;
(function(o) {
  o[o.NPM = 0] = "NPM", o[o.UNPACK = 1] = "UNPACK", o[o.PMA = 2] = "PMA", o[o.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", o[o.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", o[o.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", o[o.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$4 || (ALPHA_MODES$4 = {}));
var CLEAR_MODES$4;
(function(o) {
  o[o.NO = 0] = "NO", o[o.YES = 1] = "YES", o[o.AUTO = 2] = "AUTO", o[o.BLEND = 0] = "BLEND", o[o.CLEAR = 1] = "CLEAR", o[o.BLIT = 2] = "BLIT";
})(CLEAR_MODES$4 || (CLEAR_MODES$4 = {}));
var GC_MODES$4;
(function(o) {
  o[o.AUTO = 0] = "AUTO", o[o.MANUAL = 1] = "MANUAL";
})(GC_MODES$4 || (GC_MODES$4 = {}));
var PRECISION$4;
(function(o) {
  o.LOW = "lowp", o.MEDIUM = "mediump", o.HIGH = "highp";
})(PRECISION$4 || (PRECISION$4 = {}));
var MASK_TYPES$4;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.SCISSOR = 1] = "SCISSOR", o[o.STENCIL = 2] = "STENCIL", o[o.SPRITE = 3] = "SPRITE", o[o.COLOR = 4] = "COLOR";
})(MASK_TYPES$4 || (MASK_TYPES$4 = {}));
var COLOR_MASK_BITS$4;
(function(o) {
  o[o.RED = 1] = "RED", o[o.GREEN = 2] = "GREEN", o[o.BLUE = 4] = "BLUE", o[o.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS$4 || (COLOR_MASK_BITS$4 = {}));
var MSAA_QUALITY$4;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.LOW = 2] = "LOW", o[o.MEDIUM = 4] = "MEDIUM", o[o.HIGH = 8] = "HIGH";
})(MSAA_QUALITY$4 || (MSAA_QUALITY$4 = {}));
var BUFFER_TYPE$4;
(function(o) {
  o[o.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", o[o.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", o[o.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$4 || (BUFFER_TYPE$4 = {}));
function sortChildren(o, t) {
  return o.zIndex === t.zIndex ? o._lastSortedIndex - t._lastSortedIndex : o.zIndex - t.zIndex;
}
var Container = function(o) {
  __extends$q(t, o);
  function t() {
    var e = o.call(this) || this;
    return e.children = [], e.sortableChildren = settings$1.SORTABLE_CHILDREN, e.sortDirty = !1, e;
  }
  return t.prototype.onChildrenChange = function(e) {
  }, t.prototype.addChild = function() {
    for (var e = arguments, R = [], N = 0; N < arguments.length; N++)
      R[N] = e[N];
    if (R.length > 1)
      for (var M = 0; M < R.length; M++)
        this.addChild(R[M]);
    else {
      var D = R[0];
      D.parent && D.parent.removeChild(D), D.parent = this, this.sortDirty = !0, D.transform._parentID = -1, this.children.push(D), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", D, this, this.children.length - 1), D.emit("added", this);
    }
    return R[0];
  }, t.prototype.addChildAt = function(e, R) {
    if (R < 0 || R > this.children.length)
      throw new Error(e + "addChildAt: The index " + R + " supplied is out of bounds " + this.children.length);
    return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(R, 0, e), this._boundsID++, this.onChildrenChange(R), e.emit("added", this), this.emit("childAdded", e, this, R), e;
  }, t.prototype.swapChildren = function(e, R) {
    if (e !== R) {
      var N = this.getChildIndex(e), M = this.getChildIndex(R);
      this.children[N] = R, this.children[M] = e, this.onChildrenChange(N < M ? N : M);
    }
  }, t.prototype.getChildIndex = function(e) {
    var R = this.children.indexOf(e);
    if (R === -1)
      throw new Error("The supplied DisplayObject must be a child of the caller");
    return R;
  }, t.prototype.setChildIndex = function(e, R) {
    if (R < 0 || R >= this.children.length)
      throw new Error("The index " + R + " supplied is out of bounds " + this.children.length);
    var N = this.getChildIndex(e);
    removeItems(this.children, N, 1), this.children.splice(R, 0, e), this.onChildrenChange(R);
  }, t.prototype.getChildAt = function(e) {
    if (e < 0 || e >= this.children.length)
      throw new Error("getChildAt: Index (" + e + ") does not exist.");
    return this.children[e];
  }, t.prototype.removeChild = function() {
    for (var e = arguments, R = [], N = 0; N < arguments.length; N++)
      R[N] = e[N];
    if (R.length > 1)
      for (var M = 0; M < R.length; M++)
        this.removeChild(R[M]);
    else {
      var D = R[0], L = this.children.indexOf(D);
      if (L === -1)
        return null;
      D.parent = null, D.transform._parentID = -1, removeItems(this.children, L, 1), this._boundsID++, this.onChildrenChange(L), D.emit("removed", this), this.emit("childRemoved", D, this, L);
    }
    return R[0];
  }, t.prototype.removeChildAt = function(e) {
    var R = this.getChildAt(e);
    return R.parent = null, R.transform._parentID = -1, removeItems(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), R.emit("removed", this), this.emit("childRemoved", R, this, e), R;
  }, t.prototype.removeChildren = function(e, R) {
    e === void 0 && (e = 0), R === void 0 && (R = this.children.length);
    var N = e, M = R, D = M - N, L;
    if (D > 0 && D <= M) {
      L = this.children.splice(N, D);
      for (var B = 0; B < L.length; ++B)
        L[B].parent = null, L[B].transform && (L[B].transform._parentID = -1);
      this._boundsID++, this.onChildrenChange(e);
      for (var B = 0; B < L.length; ++B)
        L[B].emit("removed", this), this.emit("childRemoved", L[B], this, B);
      return L;
    } else if (D === 0 && this.children.length === 0)
      return [];
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  }, t.prototype.sortChildren = function() {
    for (var e = !1, R = 0, N = this.children.length; R < N; ++R) {
      var M = this.children[R];
      M._lastSortedIndex = R, !e && M.zIndex !== 0 && (e = !0);
    }
    e && this.children.length > 1 && this.children.sort(sortChildren), this.sortDirty = !1;
  }, t.prototype.updateTransform = function() {
    this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
    for (var e = 0, R = this.children.length; e < R; ++e) {
      var N = this.children[e];
      N.visible && N.updateTransform();
    }
  }, t.prototype.calculateBounds = function() {
    this._bounds.clear(), this._calculateBounds();
    for (var e = 0; e < this.children.length; e++) {
      var R = this.children[e];
      if (!(!R.visible || !R.renderable))
        if (R.calculateBounds(), R._mask) {
          var N = R._mask.isMaskData ? R._mask.maskObject : R._mask;
          N ? (N.calculateBounds(), this._bounds.addBoundsMask(R._bounds, N._bounds)) : this._bounds.addBounds(R._bounds);
        } else
          R.filterArea ? this._bounds.addBoundsArea(R._bounds, R.filterArea) : this._bounds.addBounds(R._bounds);
    }
    this._bounds.updateID = this._boundsID;
  }, t.prototype.getLocalBounds = function(e, R) {
    R === void 0 && (R = !1);
    var N = o.prototype.getLocalBounds.call(this, e);
    if (!R)
      for (var M = 0, D = this.children.length; M < D; ++M) {
        var L = this.children[M];
        L.visible && L.updateTransform();
      }
    return N;
  }, t.prototype._calculateBounds = function() {
  }, t.prototype._renderWithCulling = function(e) {
    var R = e.renderTexture.sourceFrame;
    if (R.width > 0 && R.height > 0) {
      var N, M;
      if (this.cullArea ? (N = this.cullArea, M = this.worldTransform) : this._render !== t.prototype._render && (N = this.getBounds(!0)), N && R.intersects(N, M))
        this._render(e);
      else if (this.cullArea)
        return;
      for (var D = 0, L = this.children.length; D < L; ++D) {
        var B = this.children[D], $ = B.cullable;
        B.cullable = $ || !this.cullArea, B.render(e), B.cullable = $;
      }
    }
  }, t.prototype.render = function(e) {
    if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
      if (this._mask || this.filters && this.filters.length)
        this.renderAdvanced(e);
      else if (this.cullable)
        this._renderWithCulling(e);
      else {
        this._render(e);
        for (var R = 0, N = this.children.length; R < N; ++R)
          this.children[R].render(e);
      }
  }, t.prototype.renderAdvanced = function(e) {
    var R = this.filters, N = this._mask;
    if (R) {
      this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
      for (var M = 0; M < R.length; M++)
        R[M].enabled && this._enabledFilters.push(R[M]);
    }
    var D = R && this._enabledFilters && this._enabledFilters.length || N && (!N.isMaskData || N.enabled && (N.autoDetect || N.type !== MASK_TYPES$4.NONE));
    if (D && e.batch.flush(), R && this._enabledFilters && this._enabledFilters.length && e.filter.push(this, this._enabledFilters), N && e.mask.push(this, this._mask), this.cullable)
      this._renderWithCulling(e);
    else {
      this._render(e);
      for (var M = 0, L = this.children.length; M < L; ++M)
        this.children[M].render(e);
    }
    D && e.batch.flush(), N && e.mask.pop(this), R && this._enabledFilters && this._enabledFilters.length && e.filter.pop();
  }, t.prototype._render = function(e) {
  }, t.prototype.destroy = function(e) {
    o.prototype.destroy.call(this), this.sortDirty = !1;
    var R = typeof e == "boolean" ? e : e && e.children, N = this.removeChildren(0, this.children.length);
    if (R)
      for (var M = 0; M < N.length; ++M)
        N[M].destroy(e);
  }, Object.defineProperty(t.prototype, "width", {
    get: function() {
      return this.scale.x * this.getLocalBounds().width;
    },
    set: function(e) {
      var R = this.getLocalBounds().width;
      R !== 0 ? this.scale.x = e / R : this.scale.x = 1, this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    get: function() {
      return this.scale.y * this.getLocalBounds().height;
    },
    set: function(e) {
      var R = this.getLocalBounds().height;
      R !== 0 ? this.scale.y = e / R : this.scale.y = 1, this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(DisplayObject);
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
/*!
 * @pixi/extensions - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/extensions is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$9 = function() {
  return __assign$9 = Object.assign || function(t) {
    for (var e = arguments, R, N = 1, M = arguments.length; N < M; N++) {
      R = e[N];
      for (var D in R)
        Object.prototype.hasOwnProperty.call(R, D) && (t[D] = R[D]);
    }
    return t;
  }, __assign$9.apply(this, arguments);
}, ExtensionType;
(function(o) {
  o.Application = "application", o.RendererPlugin = "renderer-webgl-plugin", o.CanvasRendererPlugin = "renderer-canvas-plugin", o.Loader = "loader", o.LoadParser = "load-parser", o.ResolveParser = "resolve-parser", o.CacheParser = "cache-parser", o.DetectionParser = "detection-parser";
})(ExtensionType || (ExtensionType = {}));
var normalizeExtension = function(o) {
  if (typeof o == "function" || typeof o == "object" && o.extension) {
    if (!o.extension)
      throw new Error("Extension class must have an extension object");
    var t = typeof o.extension != "object" ? { type: o.extension } : o.extension;
    o = __assign$9(__assign$9({}, t), { ref: o });
  }
  if (typeof o == "object")
    o = __assign$9({}, o);
  else
    throw new Error("Invalid extension type");
  return typeof o.type == "string" && (o.type = [o.type]), o;
}, extensions = {
  _addHandlers: null,
  _removeHandlers: null,
  _queue: {},
  remove: function() {
    for (var o = arguments, t = this, e = [], R = 0; R < arguments.length; R++)
      e[R] = o[R];
    return e.map(normalizeExtension).forEach(function(N) {
      N.type.forEach(function(M) {
        var D, L;
        return (L = (D = t._removeHandlers)[M]) === null || L === void 0 ? void 0 : L.call(D, N);
      });
    }), this;
  },
  add: function() {
    for (var o = arguments, t = this, e = [], R = 0; R < arguments.length; R++)
      e[R] = o[R];
    return e.map(normalizeExtension).forEach(function(N) {
      N.type.forEach(function(M) {
        var D = t._addHandlers, L = t._queue;
        D[M] ? D[M](N) : (L[M] = L[M] || [], L[M].push(N));
      });
    }), this;
  },
  handle: function(o, t, e) {
    var R = this._addHandlers = this._addHandlers || {}, N = this._removeHandlers = this._removeHandlers || {};
    if (R[o] || N[o])
      throw new Error("Extension type " + o + " already has a handler");
    R[o] = t, N[o] = e;
    var M = this._queue;
    return M[o] && (M[o].forEach(function(D) {
      return t(D);
    }), delete M[o]), this;
  },
  handleByMap: function(o, t) {
    return this.handle(o, function(e) {
      t[e.name] = e.ref;
    }, function(e) {
      delete t[e.name];
    });
  },
  handleByList: function(o, t) {
    return this.handle(o, function(e) {
      var R, N;
      t.push(e.ref), o === ExtensionType.Loader && ((N = (R = e.ref).add) === null || N === void 0 || N.call(R));
    }, function(e) {
      var R = t.indexOf(e.ref);
      R !== -1 && t.splice(R, 1);
    });
  }
};
/*!
 * @pixi/runner - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Runner = function() {
  function o(t) {
    this.items = [], this._name = t, this._aliasCount = 0;
  }
  return o.prototype.emit = function(t, e, R, N, M, D, L, B) {
    if (arguments.length > 8)
      throw new Error("max arguments reached");
    var $ = this, U = $.name, H = $.items;
    this._aliasCount++;
    for (var z = 0, X = H.length; z < X; z++)
      H[z][U](t, e, R, N, M, D, L, B);
    return H === this.items && this._aliasCount--, this;
  }, o.prototype.ensureNonAliasedItems = function() {
    this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
  }, o.prototype.add = function(t) {
    return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this;
  }, o.prototype.remove = function(t) {
    var e = this.items.indexOf(t);
    return e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this;
  }, o.prototype.contains = function(t) {
    return this.items.indexOf(t) !== -1;
  }, o.prototype.removeAll = function() {
    return this.ensureNonAliasedItems(), this.items.length = 0, this;
  }, o.prototype.destroy = function() {
    this.removeAll(), this.items = null, this._name = null;
  }, Object.defineProperty(o.prototype, "empty", {
    get: function() {
      return this.items.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "name", {
    get: function() {
      return this._name;
    },
    enumerable: !1,
    configurable: !0
  }), o;
}();
Object.defineProperties(Runner.prototype, {
  dispatch: { value: Runner.prototype.emit },
  run: { value: Runner.prototype.emit }
});
/*!
 * @pixi/ticker - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/ticker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$1.TARGET_FPMS = 0.06;
var UPDATE_PRIORITY;
(function(o) {
  o[o.INTERACTION = 50] = "INTERACTION", o[o.HIGH = 25] = "HIGH", o[o.NORMAL = 0] = "NORMAL", o[o.LOW = -25] = "LOW", o[o.UTILITY = -50] = "UTILITY";
})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
var TickerListener = function() {
  function o(t, e, R, N) {
    e === void 0 && (e = null), R === void 0 && (R = 0), N === void 0 && (N = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = R, this.once = N;
  }
  return o.prototype.match = function(t, e) {
    return e === void 0 && (e = null), this.fn === t && this.context === e;
  }, o.prototype.emit = function(t) {
    this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
    var e = this.next;
    return this.once && this.destroy(!0), this._destroyed && (this.next = null), e;
  }, o.prototype.connect = function(t) {
    this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
  }, o.prototype.destroy = function(t) {
    t === void 0 && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
    var e = this.next;
    return this.next = t ? null : e, this.previous = null, e;
  }, o;
}(), Ticker = function() {
  function o() {
    var t = this;
    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new TickerListener(null, null, 1 / 0), this.deltaMS = 1 / settings$1.TARGET_FPMS, this.elapsedMS = 1 / settings$1.TARGET_FPMS, this._tick = function(e) {
      t._requestId = null, t.started && (t.update(e), t.started && t._requestId === null && t._head.next && (t._requestId = requestAnimationFrame(t._tick)));
    };
  }
  return o.prototype._requestIfNeeded = function() {
    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
  }, o.prototype._cancelIfNeeded = function() {
    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
  }, o.prototype._startIfPossible = function() {
    this.started ? this._requestIfNeeded() : this.autoStart && this.start();
  }, o.prototype.add = function(t, e, R) {
    return R === void 0 && (R = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, R));
  }, o.prototype.addOnce = function(t, e, R) {
    return R === void 0 && (R = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, R, !0));
  }, o.prototype._addListener = function(t) {
    var e = this._head.next, R = this._head;
    if (!e)
      t.connect(R);
    else {
      for (; e; ) {
        if (t.priority > e.priority) {
          t.connect(R);
          break;
        }
        R = e, e = e.next;
      }
      t.previous || t.connect(R);
    }
    return this._startIfPossible(), this;
  }, o.prototype.remove = function(t, e) {
    for (var R = this._head.next; R; )
      R.match(t, e) ? R = R.destroy() : R = R.next;
    return this._head.next || this._cancelIfNeeded(), this;
  }, Object.defineProperty(o.prototype, "count", {
    get: function() {
      if (!this._head)
        return 0;
      for (var t = 0, e = this._head; e = e.next; )
        t++;
      return t;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.start = function() {
    this.started || (this.started = !0, this._requestIfNeeded());
  }, o.prototype.stop = function() {
    this.started && (this.started = !1, this._cancelIfNeeded());
  }, o.prototype.destroy = function() {
    if (!this._protected) {
      this.stop();
      for (var t = this._head.next; t; )
        t = t.destroy(!0);
      this._head.destroy(), this._head = null;
    }
  }, o.prototype.update = function(t) {
    t === void 0 && (t = performance.now());
    var e;
    if (t > this.lastTime) {
      if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
        var R = t - this._lastFrame | 0;
        if (R < this._minElapsedMS)
          return;
        this._lastFrame = t - R % this._minElapsedMS;
      }
      this.deltaMS = e, this.deltaTime = this.deltaMS * settings$1.TARGET_FPMS;
      for (var N = this._head, M = N.next; M; )
        M = M.emit(this.deltaTime);
      N.next || this._cancelIfNeeded();
    } else
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    this.lastTime = t;
  }, Object.defineProperty(o.prototype, "FPS", {
    get: function() {
      return 1e3 / this.elapsedMS;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "minFPS", {
    get: function() {
      return 1e3 / this._maxElapsedMS;
    },
    set: function(t) {
      var e = Math.min(this.maxFPS, t), R = Math.min(Math.max(0, e) / 1e3, settings$1.TARGET_FPMS);
      this._maxElapsedMS = 1 / R;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "maxFPS", {
    get: function() {
      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
    },
    set: function(t) {
      if (t === 0)
        this._minElapsedMS = 0;
      else {
        var e = Math.max(this.minFPS, t);
        this._minElapsedMS = 1 / (e / 1e3);
      }
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "shared", {
    get: function() {
      if (!o._shared) {
        var t = o._shared = new o();
        t.autoStart = !0, t._protected = !0;
      }
      return o._shared;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "system", {
    get: function() {
      if (!o._system) {
        var t = o._system = new o();
        t.autoStart = !0, t._protected = !0;
      }
      return o._system;
    },
    enumerable: !1,
    configurable: !0
  }), o;
}(), TickerPlugin = function() {
  function o() {
  }
  return o.init = function(t) {
    var e = this;
    t = Object.assign({
      autoStart: !0,
      sharedTicker: !1
    }, t), Object.defineProperty(this, "ticker", {
      set: function(R) {
        this._ticker && this._ticker.remove(this.render, this), this._ticker = R, R && R.add(this.render, this, UPDATE_PRIORITY.LOW);
      },
      get: function() {
        return this._ticker;
      }
    }), this.stop = function() {
      e._ticker.stop();
    }, this.start = function() {
      e._ticker.start();
    }, this._ticker = null, this.ticker = t.sharedTicker ? Ticker.shared : new Ticker(), t.autoStart && this.start();
  }, o.destroy = function() {
    if (this._ticker) {
      var t = this._ticker;
      this.ticker = null, t.destroy();
    }
  }, o.extension = ExtensionType.Application, o;
}();
/*!
 * @pixi/core - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$1.PREFER_ENV = isMobile$2.any ? ENV$5.WEBGL : ENV$5.WEBGL2;
settings$1.STRICT_TEXTURE_CACHE = !1;
var INSTALLED = [];
function autoDetectResource(o, t) {
  if (!o)
    return null;
  var e = "";
  if (typeof o == "string") {
    var R = /\.(\w{3,4})(?:$|\?|#)/i.exec(o);
    R && (e = R[1].toLowerCase());
  }
  for (var N = INSTALLED.length - 1; N >= 0; --N) {
    var M = INSTALLED[N];
    if (M.test && M.test(o, e))
      return new M(o, t);
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$p = function(o, t) {
  return extendStatics$p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$p(o, t);
};
function __extends$p(o, t) {
  extendStatics$p(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$8 = function() {
  return __assign$8 = Object.assign || function(t) {
    for (var e = arguments, R, N = 1, M = arguments.length; N < M; N++) {
      R = e[N];
      for (var D in R)
        Object.prototype.hasOwnProperty.call(R, D) && (t[D] = R[D]);
    }
    return t;
  }, __assign$8.apply(this, arguments);
};
function __rest$3(o, t) {
  var e = {};
  for (var R in o)
    Object.prototype.hasOwnProperty.call(o, R) && t.indexOf(R) < 0 && (e[R] = o[R]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var N = 0, R = Object.getOwnPropertySymbols(o); N < R.length; N++)
      t.indexOf(R[N]) < 0 && Object.prototype.propertyIsEnumerable.call(o, R[N]) && (e[R[N]] = o[R[N]]);
  return e;
}
var Resource = function() {
  function o(t, e) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new Runner("setRealSize"), this.onUpdate = new Runner("update"), this.onError = new Runner("onError");
  }
  return o.prototype.bind = function(t) {
    this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height);
  }, o.prototype.unbind = function(t) {
    this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t);
  }, o.prototype.resize = function(t, e) {
    (t !== this._width || e !== this._height) && (this._width = t, this._height = e, this.onResize.emit(t, e));
  }, Object.defineProperty(o.prototype, "valid", {
    get: function() {
      return !!this._width && !!this._height;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.update = function() {
    this.destroyed || this.onUpdate.emit();
  }, o.prototype.load = function() {
    return Promise.resolve(this);
  }, Object.defineProperty(o.prototype, "width", {
    get: function() {
      return this._width;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "height", {
    get: function() {
      return this._height;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.style = function(t, e, R) {
    return !1;
  }, o.prototype.dispose = function() {
  }, o.prototype.destroy = function() {
    this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
  }, o.test = function(t, e) {
    return !1;
  }, o;
}(), BufferResource = function(o) {
  __extends$p(t, o);
  function t(e, R) {
    var N = this, M = R || {}, D = M.width, L = M.height;
    if (!D || !L)
      throw new Error("BufferResource width or height invalid");
    return N = o.call(this, D, L) || this, N.data = e, N;
  }
  return t.prototype.upload = function(e, R, N) {
    var M = e.gl;
    M.pixelStorei(M.UNPACK_PREMULTIPLY_ALPHA_WEBGL, R.alphaMode === ALPHA_MODES$5.UNPACK);
    var D = R.realWidth, L = R.realHeight;
    return N.width === D && N.height === L ? M.texSubImage2D(R.target, 0, 0, 0, D, L, R.format, N.type, this.data) : (N.width = D, N.height = L, M.texImage2D(R.target, 0, N.internalFormat, D, L, 0, R.format, N.type, this.data)), !0;
  }, t.prototype.dispose = function() {
    this.data = null;
  }, t.test = function(e) {
    return e instanceof Float32Array || e instanceof Uint8Array || e instanceof Uint32Array;
  }, t;
}(Resource), defaultBufferOptions = {
  scaleMode: SCALE_MODES$5.NEAREST,
  format: FORMATS$5.RGBA,
  alphaMode: ALPHA_MODES$5.NPM
}, BaseTexture = function(o) {
  __extends$p(t, o);
  function t(e, R) {
    e === void 0 && (e = null), R === void 0 && (R = null);
    var N = o.call(this) || this;
    R = R || {};
    var M = R.alphaMode, D = R.mipmap, L = R.anisotropicLevel, B = R.scaleMode, $ = R.width, U = R.height, H = R.wrapMode, z = R.format, X = R.type, Y = R.target, W = R.resolution, q = R.resourceOptions;
    return e && !(e instanceof Resource) && (e = autoDetectResource(e, q), e.internal = !0), N.resolution = W || settings$1.RESOLUTION, N.width = Math.round(($ || 0) * N.resolution) / N.resolution, N.height = Math.round((U || 0) * N.resolution) / N.resolution, N._mipmap = D !== void 0 ? D : settings$1.MIPMAP_TEXTURES, N.anisotropicLevel = L !== void 0 ? L : settings$1.ANISOTROPIC_LEVEL, N._wrapMode = H || settings$1.WRAP_MODE, N._scaleMode = B !== void 0 ? B : settings$1.SCALE_MODE, N.format = z || FORMATS$5.RGBA, N.type = X || TYPES$5.UNSIGNED_BYTE, N.target = Y || TARGETS$5.TEXTURE_2D, N.alphaMode = M !== void 0 ? M : ALPHA_MODES$5.UNPACK, N.uid = uid(), N.touched = 0, N.isPowerOfTwo = !1, N._refreshPOT(), N._glTextures = {}, N.dirtyId = 0, N.dirtyStyleId = 0, N.cacheId = null, N.valid = $ > 0 && U > 0, N.textureCacheIds = [], N.destroyed = !1, N.resource = null, N._batchEnabled = 0, N._batchLocation = 0, N.parentTextureArray = null, N.setResource(e), N;
  }
  return Object.defineProperty(t.prototype, "realWidth", {
    get: function() {
      return Math.round(this.width * this.resolution);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "realHeight", {
    get: function() {
      return Math.round(this.height * this.resolution);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "mipmap", {
    get: function() {
      return this._mipmap;
    },
    set: function(e) {
      this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "scaleMode", {
    get: function() {
      return this._scaleMode;
    },
    set: function(e) {
      this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "wrapMode", {
    get: function() {
      return this._wrapMode;
    },
    set: function(e) {
      this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.setStyle = function(e, R) {
    var N;
    return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e, N = !0), R !== void 0 && R !== this.mipmap && (this.mipmap = R, N = !0), N && this.dirtyStyleId++, this;
  }, t.prototype.setSize = function(e, R, N) {
    return N = N || this.resolution, this.setRealSize(e * N, R * N, N);
  }, t.prototype.setRealSize = function(e, R, N) {
    return this.resolution = N || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(R) / this.resolution, this._refreshPOT(), this.update(), this;
  }, t.prototype._refreshPOT = function() {
    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
  }, t.prototype.setResolution = function(e) {
    var R = this.resolution;
    return R === e ? this : (this.resolution = e, this.valid && (this.width = Math.round(this.width * R) / e, this.height = Math.round(this.height * R) / e, this.emit("update", this)), this._refreshPOT(), this);
  }, t.prototype.setResource = function(e) {
    if (this.resource === e)
      return this;
    if (this.resource)
      throw new Error("Resource can be set only once");
    return e.bind(this), this.resource = e, this;
  }, t.prototype.update = function() {
    this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this));
  }, t.prototype.onError = function(e) {
    this.emit("error", this, e);
  }, t.prototype.destroy = function() {
    this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete BaseTextureCache[this.cacheId], delete TextureCache[this.cacheId], this.cacheId = null), this.dispose(), t.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0;
  }, t.prototype.dispose = function() {
    this.emit("dispose", this);
  }, t.prototype.castToBaseTexture = function() {
    return this;
  }, t.from = function(e, R, N) {
    N === void 0 && (N = settings$1.STRICT_TEXTURE_CACHE);
    var M = typeof e == "string", D = null;
    if (M)
      D = e;
    else {
      if (!e._pixiId) {
        var L = R && R.pixiIdPrefix || "pixiid";
        e._pixiId = L + "_" + uid();
      }
      D = e._pixiId;
    }
    var B = BaseTextureCache[D];
    if (M && N && !B)
      throw new Error('The cacheId "' + D + '" does not exist in BaseTextureCache.');
    return B || (B = new t(e, R), B.cacheId = D, t.addToCache(B, D)), B;
  }, t.fromBuffer = function(e, R, N, M) {
    e = e || new Float32Array(R * N * 4);
    var D = new BufferResource(e, { width: R, height: N }), L = e instanceof Float32Array ? TYPES$5.FLOAT : TYPES$5.UNSIGNED_BYTE;
    return new t(D, Object.assign(defaultBufferOptions, M || { width: R, height: N, type: L }));
  }, t.addToCache = function(e, R) {
    R && (e.textureCacheIds.indexOf(R) === -1 && e.textureCacheIds.push(R), BaseTextureCache[R] && console.warn("BaseTexture added to the cache with an id [" + R + "] that already had an entry"), BaseTextureCache[R] = e);
  }, t.removeFromCache = function(e) {
    if (typeof e == "string") {
      var R = BaseTextureCache[e];
      if (R) {
        var N = R.textureCacheIds.indexOf(e);
        return N > -1 && R.textureCacheIds.splice(N, 1), delete BaseTextureCache[e], R;
      }
    } else if (e && e.textureCacheIds) {
      for (var M = 0; M < e.textureCacheIds.length; ++M)
        delete BaseTextureCache[e.textureCacheIds[M]];
      return e.textureCacheIds.length = 0, e;
    }
    return null;
  }, t._globalBatch = 0, t;
}(n), AbstractMultiResource = function(o) {
  __extends$p(t, o);
  function t(e, R) {
    var N = this, M = R || {}, D = M.width, L = M.height;
    N = o.call(this, D, L) || this, N.items = [], N.itemDirtyIds = [];
    for (var B = 0; B < e; B++) {
      var $ = new BaseTexture();
      N.items.push($), N.itemDirtyIds.push(-2);
    }
    return N.length = e, N._load = null, N.baseTexture = null, N;
  }
  return t.prototype.initFromArray = function(e, R) {
    for (var N = 0; N < this.length; N++)
      !e[N] || (e[N].castToBaseTexture ? this.addBaseTextureAt(e[N].castToBaseTexture(), N) : e[N] instanceof Resource ? this.addResourceAt(e[N], N) : this.addResourceAt(autoDetectResource(e[N], R), N));
  }, t.prototype.dispose = function() {
    for (var e = 0, R = this.length; e < R; e++)
      this.items[e].destroy();
    this.items = null, this.itemDirtyIds = null, this._load = null;
  }, t.prototype.addResourceAt = function(e, R) {
    if (!this.items[R])
      throw new Error("Index " + R + " is out of bounds");
    return e.valid && !this.valid && this.resize(e.width, e.height), this.items[R].setResource(e), this;
  }, t.prototype.bind = function(e) {
    if (this.baseTexture !== null)
      throw new Error("Only one base texture per TextureArray is allowed");
    o.prototype.bind.call(this, e);
    for (var R = 0; R < this.length; R++)
      this.items[R].parentTextureArray = e, this.items[R].on("update", e.update, e);
  }, t.prototype.unbind = function(e) {
    o.prototype.unbind.call(this, e);
    for (var R = 0; R < this.length; R++)
      this.items[R].parentTextureArray = null, this.items[R].off("update", e.update, e);
  }, t.prototype.load = function() {
    var e = this;
    if (this._load)
      return this._load;
    var R = this.items.map(function(M) {
      return M.resource;
    }).filter(function(M) {
      return M;
    }), N = R.map(function(M) {
      return M.load();
    });
    return this._load = Promise.all(N).then(function() {
      var M = e.items[0], D = M.realWidth, L = M.realHeight;
      return e.resize(D, L), Promise.resolve(e);
    }), this._load;
  }, t;
}(Resource), ArrayResource = function(o) {
  __extends$p(t, o);
  function t(e, R) {
    var N = this, M = R || {}, D = M.width, L = M.height, B, $;
    return Array.isArray(e) ? (B = e, $ = e.length) : $ = e, N = o.call(this, $, { width: D, height: L }) || this, B && N.initFromArray(B, R), N;
  }
  return t.prototype.addBaseTextureAt = function(e, R) {
    if (e.resource)
      this.addResourceAt(e.resource, R);
    else
      throw new Error("ArrayResource does not support RenderTexture");
    return this;
  }, t.prototype.bind = function(e) {
    o.prototype.bind.call(this, e), e.target = TARGETS$5.TEXTURE_2D_ARRAY;
  }, t.prototype.upload = function(e, R, N) {
    var M = this, D = M.length, L = M.itemDirtyIds, B = M.items, $ = e.gl;
    N.dirtyId < 0 && $.texImage3D($.TEXTURE_2D_ARRAY, 0, N.internalFormat, this._width, this._height, D, 0, R.format, N.type, null);
    for (var U = 0; U < D; U++) {
      var H = B[U];
      L[U] < H.dirtyId && (L[U] = H.dirtyId, H.valid && $.texSubImage3D(
        $.TEXTURE_2D_ARRAY,
        0,
        0,
        0,
        U,
        H.resource.width,
        H.resource.height,
        1,
        R.format,
        N.type,
        H.resource.source
      ));
    }
    return !0;
  }, t;
}(AbstractMultiResource), BaseImageResource = function(o) {
  __extends$p(t, o);
  function t(e) {
    var R = this, N = e, M = N.naturalWidth || N.videoWidth || N.width, D = N.naturalHeight || N.videoHeight || N.height;
    return R = o.call(this, M, D) || this, R.source = e, R.noSubImage = !1, R;
  }
  return t.crossOrigin = function(e, R, N) {
    N === void 0 && R.indexOf("data:") !== 0 ? e.crossOrigin = determineCrossOrigin(R) : N !== !1 && (e.crossOrigin = typeof N == "string" ? N : "anonymous");
  }, t.prototype.upload = function(e, R, N, M) {
    var D = e.gl, L = R.realWidth, B = R.realHeight;
    if (M = M || this.source, M instanceof HTMLImageElement) {
      if (!M.complete || M.naturalWidth === 0)
        return !1;
    } else if (M instanceof HTMLVideoElement && M.readyState <= 1)
      return !1;
    return D.pixelStorei(D.UNPACK_PREMULTIPLY_ALPHA_WEBGL, R.alphaMode === ALPHA_MODES$5.UNPACK), !this.noSubImage && R.target === D.TEXTURE_2D && N.width === L && N.height === B ? D.texSubImage2D(D.TEXTURE_2D, 0, 0, 0, R.format, N.type, M) : (N.width = L, N.height = B, D.texImage2D(R.target, 0, N.internalFormat, R.format, N.type, M)), !0;
  }, t.prototype.update = function() {
    if (!this.destroyed) {
      var e = this.source, R = e.naturalWidth || e.videoWidth || e.width, N = e.naturalHeight || e.videoHeight || e.height;
      this.resize(R, N), o.prototype.update.call(this);
    }
  }, t.prototype.dispose = function() {
    this.source = null;
  }, t;
}(Resource), CanvasResource = function(o) {
  __extends$p(t, o);
  function t(e) {
    return o.call(this, e) || this;
  }
  return t.test = function(e) {
    var R = globalThis.OffscreenCanvas;
    return R && e instanceof R ? !0 : globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement;
  }, t;
}(BaseImageResource), CubeResource = function(o) {
  __extends$p(t, o);
  function t(e, R) {
    var N = this, M = R || {}, D = M.width, L = M.height, B = M.autoLoad, $ = M.linkBaseTexture;
    if (e && e.length !== t.SIDES)
      throw new Error("Invalid length. Got " + e.length + ", expected 6");
    N = o.call(this, 6, { width: D, height: L }) || this;
    for (var U = 0; U < t.SIDES; U++)
      N.items[U].target = TARGETS$5.TEXTURE_CUBE_MAP_POSITIVE_X + U;
    return N.linkBaseTexture = $ !== !1, e && N.initFromArray(e, R), B !== !1 && N.load(), N;
  }
  return t.prototype.bind = function(e) {
    o.prototype.bind.call(this, e), e.target = TARGETS$5.TEXTURE_CUBE_MAP;
  }, t.prototype.addBaseTextureAt = function(e, R, N) {
    if (!this.items[R])
      throw new Error("Index " + R + " is out of bounds");
    if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)
      if (e.resource)
        this.addResourceAt(e.resource, R);
      else
        throw new Error("CubeResource does not support copying of renderTexture.");
    else
      e.target = TARGETS$5.TEXTURE_CUBE_MAP_POSITIVE_X + R, e.parentTextureArray = this.baseTexture, this.items[R] = e;
    return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[R] = e, this;
  }, t.prototype.upload = function(e, R, N) {
    for (var M = this.itemDirtyIds, D = 0; D < t.SIDES; D++) {
      var L = this.items[D];
      (M[D] < L.dirtyId || N.dirtyId < R.dirtyId) && (L.valid && L.resource ? (L.resource.upload(e, L, N), M[D] = L.dirtyId) : M[D] < -1 && (e.gl.texImage2D(L.target, 0, N.internalFormat, R.realWidth, R.realHeight, 0, R.format, N.type, null), M[D] = -1));
    }
    return !0;
  }, t.test = function(e) {
    return Array.isArray(e) && e.length === t.SIDES;
  }, t.SIDES = 6, t;
}(AbstractMultiResource), ImageResource = function(o) {
  __extends$p(t, o);
  function t(e, R) {
    var N = this;
    if (R = R || {}, !(e instanceof HTMLImageElement)) {
      var M = new Image();
      BaseImageResource.crossOrigin(M, e, R.crossorigin), M.src = e, e = M;
    }
    return N = o.call(this, e) || this, !e.complete && !!N._width && !!N._height && (N._width = 0, N._height = 0), N.url = e.src, N._process = null, N.preserveBitmap = !1, N.createBitmap = (R.createBitmap !== void 0 ? R.createBitmap : settings$1.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, N.alphaMode = typeof R.alphaMode == "number" ? R.alphaMode : null, N.bitmap = null, N._load = null, R.autoLoad !== !1 && N.load(), N;
  }
  return t.prototype.load = function(e) {
    var R = this;
    return this._load ? this._load : (e !== void 0 && (this.createBitmap = e), this._load = new Promise(function(N, M) {
      var D = R.source;
      R.url = D.src;
      var L = function() {
        R.destroyed || (D.onload = null, D.onerror = null, R.resize(D.width, D.height), R._load = null, R.createBitmap ? N(R.process()) : N(R));
      };
      D.complete && D.src ? L() : (D.onload = L, D.onerror = function(B) {
        M(B), R.onError.emit(B);
      });
    }), this._load);
  }, t.prototype.process = function() {
    var e = this, R = this.source;
    if (this._process !== null)
      return this._process;
    if (this.bitmap !== null || !globalThis.createImageBitmap)
      return Promise.resolve(this);
    var N = globalThis.createImageBitmap, M = !R.crossOrigin || R.crossOrigin === "anonymous";
    return this._process = fetch(R.src, {
      mode: M ? "cors" : "no-cors"
    }).then(function(D) {
      return D.blob();
    }).then(function(D) {
      return N(D, 0, 0, R.width, R.height, {
        premultiplyAlpha: e.alphaMode === ALPHA_MODES$5.UNPACK ? "premultiply" : "none"
      });
    }).then(function(D) {
      return e.destroyed ? Promise.reject() : (e.bitmap = D, e.update(), e._process = null, Promise.resolve(e));
    }), this._process;
  }, t.prototype.upload = function(e, R, N) {
    if (typeof this.alphaMode == "number" && (R.alphaMode = this.alphaMode), !this.createBitmap)
      return o.prototype.upload.call(this, e, R, N);
    if (!this.bitmap && (this.process(), !this.bitmap))
      return !1;
    if (o.prototype.upload.call(this, e, R, N, this.bitmap), !this.preserveBitmap) {
      var M = !0, D = R._glTextures;
      for (var L in D) {
        var B = D[L];
        if (B !== N && B.dirtyId !== R.dirtyId) {
          M = !1;
          break;
        }
      }
      M && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
    }
    return !0;
  }, t.prototype.dispose = function() {
    this.source.onload = null, this.source.onerror = null, o.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
  }, t.test = function(e) {
    return typeof e == "string" || e instanceof HTMLImageElement;
  }, t;
}(BaseImageResource), SVGResource = function(o) {
  __extends$p(t, o);
  function t(e, R) {
    var N = this;
    return R = R || {}, N = o.call(this, settings$1.ADAPTER.createCanvas()) || this, N._width = 0, N._height = 0, N.svg = e, N.scale = R.scale || 1, N._overrideWidth = R.width, N._overrideHeight = R.height, N._resolve = null, N._crossorigin = R.crossorigin, N._load = null, R.autoLoad !== !1 && N.load(), N;
  }
  return t.prototype.load = function() {
    var e = this;
    return this._load ? this._load : (this._load = new Promise(function(R) {
      if (e._resolve = function() {
        e.resize(e.source.width, e.source.height), R(e);
      }, t.SVG_XML.test(e.svg.trim())) {
        if (!btoa)
          throw new Error("Your browser doesn't support base64 conversions.");
        e.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(e.svg)));
      }
      e._loadSvg();
    }), this._load);
  }, t.prototype._loadSvg = function() {
    var e = this, R = new Image();
    BaseImageResource.crossOrigin(R, this.svg, this._crossorigin), R.src = this.svg, R.onerror = function(N) {
      !e._resolve || (R.onerror = null, e.onError.emit(N));
    }, R.onload = function() {
      if (!!e._resolve) {
        var N = R.width, M = R.height;
        if (!N || !M)
          throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
        var D = N * e.scale, L = M * e.scale;
        (e._overrideWidth || e._overrideHeight) && (D = e._overrideWidth || e._overrideHeight / M * N, L = e._overrideHeight || e._overrideWidth / N * M), D = Math.round(D), L = Math.round(L);
        var B = e.source;
        B.width = D, B.height = L, B._pixiId = "canvas_" + uid(), B.getContext("2d").drawImage(R, 0, 0, N, M, 0, 0, D, L), e._resolve(), e._resolve = null;
      }
    };
  }, t.getSize = function(e) {
    var R = t.SVG_SIZE.exec(e), N = {};
    return R && (N[R[1]] = Math.round(parseFloat(R[3])), N[R[5]] = Math.round(parseFloat(R[7]))), N;
  }, t.prototype.dispose = function() {
    o.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;
  }, t.test = function(e, R) {
    return R === "svg" || typeof e == "string" && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(e) || typeof e == "string" && t.SVG_XML.test(e);
  }, t.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, t.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, t;
}(BaseImageResource), VideoResource = function(o) {
  __extends$p(t, o);
  function t(e, R) {
    var N = this;
    if (R = R || {}, !(e instanceof HTMLVideoElement)) {
      var M = document.createElement("video");
      M.setAttribute("preload", "auto"), M.setAttribute("webkit-playsinline", ""), M.setAttribute("playsinline", ""), typeof e == "string" && (e = [e]);
      var D = e[0].src || e[0];
      BaseImageResource.crossOrigin(M, D, R.crossorigin);
      for (var L = 0; L < e.length; ++L) {
        var B = document.createElement("source"), $ = e[L], U = $.src, H = $.mime;
        U = U || e[L];
        var z = U.split("?").shift().toLowerCase(), X = z.slice(z.lastIndexOf(".") + 1);
        H = H || t.MIME_TYPES[X] || "video/" + X, B.src = U, B.type = H, M.appendChild(B);
      }
      e = M;
    }
    return N = o.call(this, e) || this, N.noSubImage = !0, N._autoUpdate = !0, N._isConnectedToTicker = !1, N._updateFPS = R.updateFPS || 0, N._msToNextUpdate = 0, N.autoPlay = R.autoPlay !== !1, N._load = null, N._resolve = null, N._onCanPlay = N._onCanPlay.bind(N), N._onError = N._onError.bind(N), R.autoLoad !== !1 && N.load(), N;
  }
  return t.prototype.update = function(e) {
    if (!this.destroyed) {
      var R = Ticker.shared.elapsedMS * this.source.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - R), (!this._updateFPS || this._msToNextUpdate <= 0) && (o.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
    }
  }, t.prototype.load = function() {
    var e = this;
    if (this._load)
      return this._load;
    var R = this.source;
    return (R.readyState === R.HAVE_ENOUGH_DATA || R.readyState === R.HAVE_FUTURE_DATA) && R.width && R.height && (R.complete = !0), R.addEventListener("play", this._onPlayStart.bind(this)), R.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (R.addEventListener("canplay", this._onCanPlay), R.addEventListener("canplaythrough", this._onCanPlay), R.addEventListener("error", this._onError, !0)), this._load = new Promise(function(N) {
      e.valid ? N(e) : (e._resolve = N, R.load());
    }), this._load;
  }, t.prototype._onError = function(e) {
    this.source.removeEventListener("error", this._onError, !0), this.onError.emit(e);
  }, t.prototype._isSourcePlaying = function() {
    var e = this.source;
    return e.currentTime > 0 && e.paused === !1 && e.ended === !1 && e.readyState > 2;
  }, t.prototype._isSourceReady = function() {
    var e = this.source;
    return e.readyState === 3 || e.readyState === 4;
  }, t.prototype._onPlayStart = function() {
    this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0);
  }, t.prototype._onPlayStop = function() {
    this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);
  }, t.prototype._onCanPlay = function() {
    var e = this.source;
    e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlay);
    var R = this.valid;
    this.resize(e.videoWidth, e.videoHeight), !R && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play();
  }, t.prototype.dispose = function() {
    this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);
    var e = this.source;
    e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), o.prototype.dispose.call(this);
  }, Object.defineProperty(t.prototype, "autoUpdate", {
    get: function() {
      return this._autoUpdate;
    },
    set: function(e) {
      e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "updateFPS", {
    get: function() {
      return this._updateFPS;
    },
    set: function(e) {
      e !== this._updateFPS && (this._updateFPS = e);
    },
    enumerable: !1,
    configurable: !0
  }), t.test = function(e, R) {
    return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || t.TYPES.indexOf(R) > -1;
  }, t.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], t.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  }, t;
}(BaseImageResource), ImageBitmapResource = function(o) {
  __extends$p(t, o);
  function t(e) {
    return o.call(this, e) || this;
  }
  return t.test = function(e) {
    return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && e instanceof ImageBitmap;
  }, t;
}(BaseImageResource);
INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
var DepthResource = function(o) {
  __extends$p(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  return t.prototype.upload = function(e, R, N) {
    var M = e.gl;
    M.pixelStorei(M.UNPACK_PREMULTIPLY_ALPHA_WEBGL, R.alphaMode === ALPHA_MODES$5.UNPACK);
    var D = R.realWidth, L = R.realHeight;
    return N.width === D && N.height === L ? M.texSubImage2D(R.target, 0, 0, 0, D, L, R.format, N.type, this.data) : (N.width = D, N.height = L, M.texImage2D(R.target, 0, N.internalFormat, D, L, 0, R.format, N.type, this.data)), !0;
  }, t;
}(BufferResource), Framebuffer = function() {
  function o(t, e) {
    this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Runner("disposeFramebuffer"), this.multisample = MSAA_QUALITY$5.NONE;
  }
  return Object.defineProperty(o.prototype, "colorTexture", {
    get: function() {
      return this.colorTextures[0];
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.addColorTexture = function(t, e) {
    return t === void 0 && (t = 0), this.colorTextures[t] = e || new BaseTexture(null, {
      scaleMode: SCALE_MODES$5.NEAREST,
      resolution: 1,
      mipmap: MIPMAP_MODES$5.OFF,
      width: this.width,
      height: this.height
    }), this.dirtyId++, this.dirtyFormat++, this;
  }, o.prototype.addDepthTexture = function(t) {
    return this.depthTexture = t || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
      scaleMode: SCALE_MODES$5.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: MIPMAP_MODES$5.OFF,
      format: FORMATS$5.DEPTH_COMPONENT,
      type: TYPES$5.UNSIGNED_SHORT
    }), this.dirtyId++, this.dirtyFormat++, this;
  }, o.prototype.enableDepth = function() {
    return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;
  }, o.prototype.enableStencil = function() {
    return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;
  }, o.prototype.resize = function(t, e) {
    if (t = Math.round(t), e = Math.round(e), !(t === this.width && e === this.height)) {
      this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;
      for (var R = 0; R < this.colorTextures.length; R++) {
        var N = this.colorTextures[R], M = N.resolution;
        N.setSize(t / M, e / M);
      }
      if (this.depthTexture) {
        var M = this.depthTexture.resolution;
        this.depthTexture.setSize(t / M, e / M);
      }
    }
  }, o.prototype.dispose = function() {
    this.disposeRunner.emit(this, !1);
  }, o.prototype.destroyDepthTexture = function() {
    this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
  }, o;
}(), BaseRenderTexture = function(o) {
  __extends$p(t, o);
  function t(e) {
    e === void 0 && (e = {});
    var R = this;
    if (typeof e == "number") {
      var N = arguments[0], M = arguments[1], D = arguments[2], L = arguments[3];
      e = { width: N, height: M, scaleMode: D, resolution: L };
    }
    return e.width = e.width || 100, e.height = e.height || 100, e.multisample = e.multisample !== void 0 ? e.multisample : MSAA_QUALITY$5.NONE, R = o.call(this, null, e) || this, R.mipmap = MIPMAP_MODES$5.OFF, R.valid = !0, R.clearColor = [0, 0, 0, 0], R.framebuffer = new Framebuffer(R.realWidth, R.realHeight).addColorTexture(0, R), R.framebuffer.multisample = e.multisample, R.maskStack = [], R.filterStack = [{}], R;
  }
  return t.prototype.resize = function(e, R) {
    this.framebuffer.resize(e * this.resolution, R * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  }, t.prototype.dispose = function() {
    this.framebuffer.dispose(), o.prototype.dispose.call(this);
  }, t.prototype.destroy = function() {
    o.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
  }, t;
}(BaseTexture), TextureUvs = function() {
  function o() {
    this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
  }
  return o.prototype.set = function(t, e, R) {
    var N = e.width, M = e.height;
    if (R) {
      var D = t.width / 2 / N, L = t.height / 2 / M, B = t.x / N + D, $ = t.y / M + L;
      R = groupD8.add(R, groupD8.NW), this.x0 = B + D * groupD8.uX(R), this.y0 = $ + L * groupD8.uY(R), R = groupD8.add(R, 2), this.x1 = B + D * groupD8.uX(R), this.y1 = $ + L * groupD8.uY(R), R = groupD8.add(R, 2), this.x2 = B + D * groupD8.uX(R), this.y2 = $ + L * groupD8.uY(R), R = groupD8.add(R, 2), this.x3 = B + D * groupD8.uX(R), this.y3 = $ + L * groupD8.uY(R);
    } else
      this.x0 = t.x / N, this.y0 = t.y / M, this.x1 = (t.x + t.width) / N, this.y1 = t.y / M, this.x2 = (t.x + t.width) / N, this.y2 = (t.y + t.height) / M, this.x3 = t.x / N, this.y3 = (t.y + t.height) / M;
    this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
  }, o.prototype.toString = function() {
    return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
  }, o;
}(), DEFAULT_UVS = new TextureUvs();
function removeAllHandlers(o) {
  o.destroy = function() {
  }, o.on = function() {
  }, o.once = function() {
  }, o.emit = function() {
  };
}
var Texture = function(o) {
  __extends$p(t, o);
  function t(e, R, N, M, D, L) {
    var B = o.call(this) || this;
    if (B.noFrame = !1, R || (B.noFrame = !0, R = new Rectangle(0, 0, 1, 1)), e instanceof t && (e = e.baseTexture), B.baseTexture = e, B._frame = R, B.trim = M, B.valid = !1, B._uvs = DEFAULT_UVS, B.uvMatrix = null, B.orig = N || R, B._rotate = Number(D || 0), D === !0)
      B._rotate = 2;
    else if (B._rotate % 2 !== 0)
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    return B.defaultAnchor = L ? new Point(L.x, L.y) : new Point(0, 0), B._updateID = 0, B.textureCacheIds = [], e.valid ? B.noFrame ? e.valid && B.onBaseTextureUpdated(e) : B.frame = R : e.once("loaded", B.onBaseTextureUpdated, B), B.noFrame && e.on("update", B.onBaseTextureUpdated, B), B;
  }
  return t.prototype.update = function() {
    this.baseTexture.resource && this.baseTexture.resource.update();
  }, t.prototype.onBaseTextureUpdated = function(e) {
    if (this.noFrame) {
      if (!this.baseTexture.valid)
        return;
      this._frame.width = e.width, this._frame.height = e.height, this.valid = !0, this.updateUvs();
    } else
      this.frame = this._frame;
    this.emit("update", this);
  }, t.prototype.destroy = function(e) {
    if (this.baseTexture) {
      if (e) {
        var R = this.baseTexture.resource;
        R && R.url && TextureCache[R.url] && t.removeFromCache(R.url), this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
    }
    this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, t.removeFromCache(this), this.textureCacheIds = null;
  }, t.prototype.clone = function() {
    var e = this._frame.clone(), R = this._frame === this.orig ? e : this.orig.clone(), N = new t(this.baseTexture, !this.noFrame && e, R, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
    return this.noFrame && (N._frame = e), N;
  }, t.prototype.updateUvs = function() {
    this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
  }, t.from = function(e, R, N) {
    R === void 0 && (R = {}), N === void 0 && (N = settings$1.STRICT_TEXTURE_CACHE);
    var M = typeof e == "string", D = null;
    if (M)
      D = e;
    else if (e instanceof BaseTexture) {
      if (!e.cacheId) {
        var L = R && R.pixiIdPrefix || "pixiid";
        e.cacheId = L + "-" + uid(), BaseTexture.addToCache(e, e.cacheId);
      }
      D = e.cacheId;
    } else {
      if (!e._pixiId) {
        var L = R && R.pixiIdPrefix || "pixiid";
        e._pixiId = L + "_" + uid();
      }
      D = e._pixiId;
    }
    var B = TextureCache[D];
    if (M && N && !B)
      throw new Error('The cacheId "' + D + '" does not exist in TextureCache.');
    return !B && !(e instanceof BaseTexture) ? (R.resolution || (R.resolution = getResolutionOfUrl(e)), B = new t(new BaseTexture(e, R)), B.baseTexture.cacheId = D, BaseTexture.addToCache(B.baseTexture, D), t.addToCache(B, D)) : !B && e instanceof BaseTexture && (B = new t(e), t.addToCache(B, D)), B;
  }, t.fromURL = function(e, R) {
    var N = Object.assign({ autoLoad: !1 }, R == null ? void 0 : R.resourceOptions), M = t.from(e, Object.assign({ resourceOptions: N }, R), !1), D = M.baseTexture.resource;
    return M.baseTexture.valid ? Promise.resolve(M) : D.load().then(function() {
      return Promise.resolve(M);
    });
  }, t.fromBuffer = function(e, R, N, M) {
    return new t(BaseTexture.fromBuffer(e, R, N, M));
  }, t.fromLoader = function(e, R, N, M) {
    var D = new BaseTexture(e, Object.assign({
      scaleMode: settings$1.SCALE_MODE,
      resolution: getResolutionOfUrl(R)
    }, M)), L = D.resource;
    L instanceof ImageResource && (L.url = R);
    var B = new t(D);
    return N || (N = R), BaseTexture.addToCache(B.baseTexture, N), t.addToCache(B, N), N !== R && (BaseTexture.addToCache(B.baseTexture, R), t.addToCache(B, R)), B.baseTexture.valid ? Promise.resolve(B) : new Promise(function($) {
      B.baseTexture.once("loaded", function() {
        return $(B);
      });
    });
  }, t.addToCache = function(e, R) {
    R && (e.textureCacheIds.indexOf(R) === -1 && e.textureCacheIds.push(R), TextureCache[R] && console.warn("Texture added to the cache with an id [" + R + "] that already had an entry"), TextureCache[R] = e);
  }, t.removeFromCache = function(e) {
    if (typeof e == "string") {
      var R = TextureCache[e];
      if (R) {
        var N = R.textureCacheIds.indexOf(e);
        return N > -1 && R.textureCacheIds.splice(N, 1), delete TextureCache[e], R;
      }
    } else if (e && e.textureCacheIds) {
      for (var M = 0; M < e.textureCacheIds.length; ++M)
        TextureCache[e.textureCacheIds[M]] === e && delete TextureCache[e.textureCacheIds[M]];
      return e.textureCacheIds.length = 0, e;
    }
    return null;
  }, Object.defineProperty(t.prototype, "resolution", {
    get: function() {
      return this.baseTexture.resolution;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "frame", {
    get: function() {
      return this._frame;
    },
    set: function(e) {
      this._frame = e, this.noFrame = !1;
      var R = e.x, N = e.y, M = e.width, D = e.height, L = R + M > this.baseTexture.width, B = N + D > this.baseTexture.height;
      if (L || B) {
        var $ = L && B ? "and" : "or", U = "X: " + R + " + " + M + " = " + (R + M) + " > " + this.baseTexture.width, H = "Y: " + N + " + " + D + " = " + (N + D) + " > " + this.baseTexture.height;
        throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (U + " " + $ + " " + H));
      }
      this.valid = M && D && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = e), this.valid && this.updateUvs();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "rotate", {
    get: function() {
      return this._rotate;
    },
    set: function(e) {
      this._rotate = e, this.valid && this.updateUvs();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "width", {
    get: function() {
      return this.orig.width;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    get: function() {
      return this.orig.height;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.castToBaseTexture = function() {
    return this.baseTexture;
  }, Object.defineProperty(t, "EMPTY", {
    get: function() {
      return t._EMPTY || (t._EMPTY = new t(new BaseTexture()), removeAllHandlers(t._EMPTY), removeAllHandlers(t._EMPTY.baseTexture)), t._EMPTY;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t, "WHITE", {
    get: function() {
      if (!t._WHITE) {
        var e = settings$1.ADAPTER.createCanvas(16, 16), R = e.getContext("2d");
        e.width = 16, e.height = 16, R.fillStyle = "white", R.fillRect(0, 0, 16, 16), t._WHITE = new t(BaseTexture.from(e)), removeAllHandlers(t._WHITE), removeAllHandlers(t._WHITE.baseTexture);
      }
      return t._WHITE;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(n), RenderTexture = function(o) {
  __extends$p(t, o);
  function t(e, R) {
    var N = o.call(this, e, R) || this;
    return N.valid = !0, N.filterFrame = null, N.filterPoolKey = null, N.updateUvs(), N;
  }
  return Object.defineProperty(t.prototype, "framebuffer", {
    get: function() {
      return this.baseTexture.framebuffer;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "multisample", {
    get: function() {
      return this.framebuffer.multisample;
    },
    set: function(e) {
      this.framebuffer.multisample = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.resize = function(e, R, N) {
    N === void 0 && (N = !0);
    var M = this.baseTexture.resolution, D = Math.round(e * M) / M, L = Math.round(R * M) / M;
    this.valid = D > 0 && L > 0, this._frame.width = this.orig.width = D, this._frame.height = this.orig.height = L, N && this.baseTexture.resize(D, L), this.updateUvs();
  }, t.prototype.setResolution = function(e) {
    var R = this.baseTexture;
    R.resolution !== e && (R.setResolution(e), this.resize(R.width, R.height, !1));
  }, t.create = function(e) {
    for (var R = arguments, N = [], M = 1; M < arguments.length; M++)
      N[M - 1] = R[M];
    return typeof e == "number" && (deprecation$1("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), e = {
      width: e,
      height: N[0],
      scaleMode: N[1],
      resolution: N[2]
    }), new t(new BaseRenderTexture(e));
  }, t;
}(Texture), RenderTexturePool = function() {
  function o(t) {
    this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;
  }
  return o.prototype.createTexture = function(t, e, R) {
    R === void 0 && (R = MSAA_QUALITY$5.NONE);
    var N = new BaseRenderTexture(Object.assign({
      width: t,
      height: e,
      resolution: 1,
      multisample: R
    }, this.textureOptions));
    return new RenderTexture(N);
  }, o.prototype.getOptimalTexture = function(t, e, R, N) {
    R === void 0 && (R = 1), N === void 0 && (N = MSAA_QUALITY$5.NONE);
    var M;
    t = Math.ceil(t * R - 1e-6), e = Math.ceil(e * R - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || e !== this._pixelsHeight ? (t = nextPow2(t), e = nextPow2(e), M = ((t & 65535) << 16 | e & 65535) >>> 0, N > 1 && (M += N * 4294967296)) : M = N > 1 ? -N : -1, this.texturePool[M] || (this.texturePool[M] = []);
    var D = this.texturePool[M].pop();
    return D || (D = this.createTexture(t, e, N)), D.filterPoolKey = M, D.setResolution(R), D;
  }, o.prototype.getFilterTexture = function(t, e, R) {
    var N = this.getOptimalTexture(t.width, t.height, e || t.resolution, R || MSAA_QUALITY$5.NONE);
    return N.filterFrame = t.filterFrame, N;
  }, o.prototype.returnTexture = function(t) {
    var e = t.filterPoolKey;
    t.filterFrame = null, this.texturePool[e].push(t);
  }, o.prototype.returnFilterTexture = function(t) {
    this.returnTexture(t);
  }, o.prototype.clear = function(t) {
    if (t = t !== !1, t)
      for (var e in this.texturePool) {
        var R = this.texturePool[e];
        if (R)
          for (var N = 0; N < R.length; N++)
            R[N].destroy(!0);
      }
    this.texturePool = {};
  }, o.prototype.setScreenSize = function(t) {
    if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {
      this.enableFullScreen = t.width > 0 && t.height > 0;
      for (var e in this.texturePool)
        if (Number(e) < 0) {
          var R = this.texturePool[e];
          if (R)
            for (var N = 0; N < R.length; N++)
              R[N].destroy(!0);
          this.texturePool[e] = [];
        }
      this._pixelsWidth = t.width, this._pixelsHeight = t.height;
    }
  }, o.SCREEN_KEY = -1, o;
}(), Attribute = function() {
  function o(t, e, R, N, M, D, L) {
    e === void 0 && (e = 0), R === void 0 && (R = !1), N === void 0 && (N = TYPES$5.FLOAT), this.buffer = t, this.size = e, this.normalized = R, this.type = N, this.stride = M, this.start = D, this.instance = L;
  }
  return o.prototype.destroy = function() {
    this.buffer = null;
  }, o.from = function(t, e, R, N, M) {
    return new o(t, e, R, N, M);
  }, o;
}(), UID$4 = 0, Buffer$1 = function() {
  function o(t, e, R) {
    e === void 0 && (e = !0), R === void 0 && (R = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = R, this.static = e, this.id = UID$4++, this.disposeRunner = new Runner("disposeBuffer");
  }
  return o.prototype.update = function(t) {
    t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++;
  }, o.prototype.dispose = function() {
    this.disposeRunner.emit(this, !1);
  }, o.prototype.destroy = function() {
    this.dispose(), this.data = null;
  }, Object.defineProperty(o.prototype, "index", {
    get: function() {
      return this.type === BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER;
    },
    set: function(t) {
      this.type = t ? BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE$5.ARRAY_BUFFER;
    },
    enumerable: !1,
    configurable: !0
  }), o.from = function(t) {
    return t instanceof Array && (t = new Float32Array(t)), new o(t);
  }, o;
}(), map$1$1 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(o, t) {
  for (var e = 0, R = 0, N = {}, M = 0; M < o.length; M++)
    R += t[M], e += o[M].length;
  for (var D = new ArrayBuffer(e * 4), L = null, B = 0, M = 0; M < o.length; M++) {
    var $ = t[M], U = o[M], H = getBufferType(U);
    N[H] || (N[H] = new map$1$1[H](D)), L = N[H];
    for (var z = 0; z < U.length; z++) {
      var X = (z / $ | 0) * R + B, Y = z % $;
      L[X + Y] = U[z];
    }
    B += $;
  }
  return new Float32Array(D);
}
var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 }, UID$3 = 0, map$2 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
}, Geometry = function() {
  function o(t, e) {
    t === void 0 && (t = []), e === void 0 && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = UID$3++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new Runner("disposeGeometry"), this.refCount = 0;
  }
  return o.prototype.addAttribute = function(t, e, R, N, M, D, L, B) {
    if (R === void 0 && (R = 0), N === void 0 && (N = !1), B === void 0 && (B = !1), !e)
      throw new Error("You must pass a buffer when creating an attribute");
    e instanceof Buffer$1 || (e instanceof Array && (e = new Float32Array(e)), e = new Buffer$1(e));
    var $ = t.split("|");
    if ($.length > 1) {
      for (var U = 0; U < $.length; U++)
        this.addAttribute($[U], e, R, N, M);
      return this;
    }
    var H = this.buffers.indexOf(e);
    return H === -1 && (this.buffers.push(e), H = this.buffers.length - 1), this.attributes[t] = new Attribute(H, R, N, M, D, L, B), this.instanced = this.instanced || B, this;
  }, o.prototype.getAttribute = function(t) {
    return this.attributes[t];
  }, o.prototype.getBuffer = function(t) {
    return this.buffers[this.getAttribute(t).buffer];
  }, o.prototype.addIndex = function(t) {
    return t instanceof Buffer$1 || (t instanceof Array && (t = new Uint16Array(t)), t = new Buffer$1(t)), t.type = BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.indexOf(t) === -1 && this.buffers.push(t), this;
  }, o.prototype.getIndex = function() {
    return this.indexBuffer;
  }, o.prototype.interleave = function() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
      return this;
    var t = [], e = [], R = new Buffer$1(), N;
    for (N in this.attributes) {
      var M = this.attributes[N], D = this.buffers[M.buffer];
      t.push(D.data), e.push(M.size * byteSizeMap$1[M.type] / 4), M.buffer = 0;
    }
    for (R.data = interleaveTypedArrays(t, e), N = 0; N < this.buffers.length; N++)
      this.buffers[N] !== this.indexBuffer && this.buffers[N].destroy();
    return this.buffers = [R], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
  }, o.prototype.getSize = function() {
    for (var t in this.attributes) {
      var e = this.attributes[t], R = this.buffers[e.buffer];
      return R.data.length / (e.stride / 4 || e.size);
    }
    return 0;
  }, o.prototype.dispose = function() {
    this.disposeRunner.emit(this, !1);
  }, o.prototype.destroy = function() {
    this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
  }, o.prototype.clone = function() {
    for (var t = new o(), e = 0; e < this.buffers.length; e++)
      t.buffers[e] = new Buffer$1(this.buffers[e].data.slice(0));
    for (var e in this.attributes) {
      var R = this.attributes[e];
      t.attributes[e] = new Attribute(R.buffer, R.size, R.normalized, R.type, R.stride, R.start, R.instance);
    }
    return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER), t;
  }, o.merge = function(t) {
    for (var e = new o(), R = [], N = [], M = [], D, L = 0; L < t.length; L++) {
      D = t[L];
      for (var B = 0; B < D.buffers.length; B++)
        N[B] = N[B] || 0, N[B] += D.buffers[B].data.length, M[B] = 0;
    }
    for (var L = 0; L < D.buffers.length; L++)
      R[L] = new map$2[getBufferType(D.buffers[L].data)](N[L]), e.buffers[L] = new Buffer$1(R[L]);
    for (var L = 0; L < t.length; L++) {
      D = t[L];
      for (var B = 0; B < D.buffers.length; B++)
        R[B].set(D.buffers[B].data, M[B]), M[B] += D.buffers[B].data.length;
    }
    if (e.attributes = D.attributes, D.indexBuffer) {
      e.indexBuffer = e.buffers[D.buffers.indexOf(D.indexBuffer)], e.indexBuffer.type = BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER;
      for (var $ = 0, U = 0, H = 0, z = 0, L = 0; L < D.buffers.length; L++)
        if (D.buffers[L] !== D.indexBuffer) {
          z = L;
          break;
        }
      for (var L in D.attributes) {
        var X = D.attributes[L];
        (X.buffer | 0) === z && (U += X.size * byteSizeMap$1[X.type] / 4);
      }
      for (var L = 0; L < t.length; L++) {
        for (var Y = t[L].indexBuffer.data, B = 0; B < Y.length; B++)
          e.indexBuffer.data[B + H] += $;
        $ += t[L].buffers[z].data.length / U, H += Y.length;
      }
    }
    return e;
  }, o;
}(), Quad = function(o) {
  __extends$p(t, o);
  function t() {
    var e = o.call(this) || this;
    return e.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]), e;
  }
  return t;
}(Geometry), QuadUv = function(o) {
  __extends$p(t, o);
  function t() {
    var e = o.call(this) || this;
    return e.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]), e.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]), e.vertexBuffer = new Buffer$1(e.vertices), e.uvBuffer = new Buffer$1(e.uvs), e.addAttribute("aVertexPosition", e.vertexBuffer).addAttribute("aTextureCoord", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e;
  }
  return t.prototype.map = function(e, R) {
    var N = 0, M = 0;
    return this.uvs[0] = N, this.uvs[1] = M, this.uvs[2] = N + R.width / e.width, this.uvs[3] = M, this.uvs[4] = N + R.width / e.width, this.uvs[5] = M + R.height / e.height, this.uvs[6] = N, this.uvs[7] = M + R.height / e.height, N = R.x, M = R.y, this.vertices[0] = N, this.vertices[1] = M, this.vertices[2] = N + R.width, this.vertices[3] = M, this.vertices[4] = N + R.width, this.vertices[5] = M + R.height, this.vertices[6] = N, this.vertices[7] = M + R.height, this.invalidate(), this;
  }, t.prototype.invalidate = function() {
    return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
  }, t;
}(Geometry), UID$2 = 0, UniformGroup = function() {
  function o(t, e, R) {
    this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = UID$2++, this.static = !!e, this.ubo = !!R, t instanceof Buffer$1 ? (this.buffer = t, this.buffer.type = BUFFER_TYPE$5.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Buffer$1(new Float32Array(1)), this.buffer.type = BUFFER_TYPE$5.UNIFORM_BUFFER, this.autoManage = !0));
  }
  return o.prototype.update = function() {
    this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
  }, o.prototype.add = function(t, e, R) {
    if (!this.ubo)
      this.uniforms[t] = new o(e, R);
    else
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
  }, o.from = function(t, e, R) {
    return new o(t, e, R);
  }, o.uboFrom = function(t, e) {
    return new o(t, e != null ? e : !0, !0);
  }, o;
}(), FilterState = function() {
  function o() {
    this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = MSAA_QUALITY$5.NONE, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.bindingSourceFrame = new Rectangle(), this.bindingDestinationFrame = new Rectangle(), this.filters = [], this.transform = null;
  }
  return o.prototype.clear = function() {
    this.target = null, this.filters = null, this.renderTexture = null;
  }, o;
}(), tempPoints = [new Point(), new Point(), new Point(), new Point()], tempMatrix$2 = new Matrix(), FilterSystem = function() {
  function o(t) {
    this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool(), this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new Quad(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup({
      outputFrame: new Rectangle(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, !0), this.forceClear = !1, this.useMaxPadding = !1;
  }
  return o.prototype.push = function(t, e) {
    for (var R, N, M = this.renderer, D = this.defaultFilterStack, L = this.statePool.pop() || new FilterState(), B = this.renderer.renderTexture, $ = e[0].resolution, U = e[0].multisample, H = e[0].padding, z = e[0].autoFit, X = (R = e[0].legacy) !== null && R !== void 0 ? R : !0, Y = 1; Y < e.length; Y++) {
      var W = e[Y];
      $ = Math.min($, W.resolution), U = Math.min(U, W.multisample), H = this.useMaxPadding ? Math.max(H, W.padding) : H + W.padding, z = z && W.autoFit, X = X || ((N = W.legacy) !== null && N !== void 0 ? N : !0);
    }
    D.length === 1 && (this.defaultFilterStack[0].renderTexture = B.current), D.push(L), L.resolution = $, L.multisample = U, L.legacy = X, L.target = t, L.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), L.sourceFrame.pad(H);
    var q = this.tempRect.copyFrom(B.sourceFrame);
    M.projection.transform && this.transformAABB(tempMatrix$2.copyFrom(M.projection.transform).invert(), q), z ? (L.sourceFrame.fit(q), (L.sourceFrame.width <= 0 || L.sourceFrame.height <= 0) && (L.sourceFrame.width = 0, L.sourceFrame.height = 0)) : L.sourceFrame.intersects(q) || (L.sourceFrame.width = 0, L.sourceFrame.height = 0), this.roundFrame(L.sourceFrame, B.current ? B.current.resolution : M.resolution, B.sourceFrame, B.destinationFrame, M.projection.transform), L.renderTexture = this.getOptimalFilterTexture(L.sourceFrame.width, L.sourceFrame.height, $, U), L.filters = e, L.destinationFrame.width = L.renderTexture.width, L.destinationFrame.height = L.renderTexture.height;
    var Z = this.tempRect;
    Z.x = 0, Z.y = 0, Z.width = L.sourceFrame.width, Z.height = L.sourceFrame.height, L.renderTexture.filterFrame = L.sourceFrame, L.bindingSourceFrame.copyFrom(B.sourceFrame), L.bindingDestinationFrame.copyFrom(B.destinationFrame), L.transform = M.projection.transform, M.projection.transform = null, B.bind(L.renderTexture, L.sourceFrame, Z), M.framebuffer.clear(0, 0, 0, 0);
  }, o.prototype.pop = function() {
    var t = this.defaultFilterStack, e = t.pop(), R = e.filters;
    this.activeState = e;
    var N = this.globalUniforms.uniforms;
    N.outputFrame = e.sourceFrame, N.resolution = e.resolution;
    var M = N.inputSize, D = N.inputPixel, L = N.inputClamp;
    if (M[0] = e.destinationFrame.width, M[1] = e.destinationFrame.height, M[2] = 1 / M[0], M[3] = 1 / M[1], D[0] = Math.round(M[0] * e.resolution), D[1] = Math.round(M[1] * e.resolution), D[2] = 1 / D[0], D[3] = 1 / D[1], L[0] = 0.5 * D[2], L[1] = 0.5 * D[3], L[2] = e.sourceFrame.width * M[2] - 0.5 * D[2], L[3] = e.sourceFrame.height * M[3] - 0.5 * D[3], e.legacy) {
      var B = N.filterArea;
      B[0] = e.destinationFrame.width, B[1] = e.destinationFrame.height, B[2] = e.sourceFrame.x, B[3] = e.sourceFrame.y, N.filterClamp = N.inputClamp;
    }
    this.globalUniforms.update();
    var $ = t[t.length - 1];
    if (this.renderer.framebuffer.blit(), R.length === 1)
      R[0].apply(this, e.renderTexture, $.renderTexture, CLEAR_MODES$5.BLEND, e), this.returnFilterTexture(e.renderTexture);
    else {
      var U = e.renderTexture, H = this.getOptimalFilterTexture(U.width, U.height, e.resolution);
      H.filterFrame = U.filterFrame;
      var z = 0;
      for (z = 0; z < R.length - 1; ++z) {
        z === 1 && e.multisample > 1 && (H = this.getOptimalFilterTexture(U.width, U.height, e.resolution), H.filterFrame = U.filterFrame), R[z].apply(this, U, H, CLEAR_MODES$5.CLEAR, e);
        var X = U;
        U = H, H = X;
      }
      R[z].apply(this, U, $.renderTexture, CLEAR_MODES$5.BLEND, e), z > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture(U), this.returnFilterTexture(H);
    }
    e.clear(), this.statePool.push(e);
  }, o.prototype.bindAndClear = function(t, e) {
    e === void 0 && (e = CLEAR_MODES$5.CLEAR);
    var R = this.renderer, N = R.renderTexture, M = R.state;
    if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) {
      var D = this.tempRect;
      D.x = 0, D.y = 0, D.width = t.filterFrame.width, D.height = t.filterFrame.height, N.bind(t, t.filterFrame, D);
    } else
      t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? N.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
    var L = M.stateId & 1 || this.forceClear;
    (e === CLEAR_MODES$5.CLEAR || e === CLEAR_MODES$5.BLIT && L) && this.renderer.framebuffer.clear(0, 0, 0, 0);
  }, o.prototype.applyFilter = function(t, e, R, N) {
    var M = this.renderer;
    M.state.set(t.state), this.bindAndClear(R, N), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, M.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), M.geometry.bind(this.quadUv), M.geometry.draw(DRAW_MODES$5.TRIANGLES)) : (M.geometry.bind(this.quad), M.geometry.draw(DRAW_MODES$5.TRIANGLE_STRIP));
  }, o.prototype.calculateSpriteMatrix = function(t, e) {
    var R = this.activeState, N = R.sourceFrame, M = R.destinationFrame, D = e._texture.orig, L = t.set(M.width, 0, 0, M.height, N.x, N.y), B = e.worldTransform.copyTo(Matrix.TEMP_MATRIX);
    return B.invert(), L.prepend(B), L.scale(1 / D.width, 1 / D.height), L.translate(e.anchor.x, e.anchor.y), L;
  }, o.prototype.destroy = function() {
    this.renderer = null, this.texturePool.clear(!1);
  }, o.prototype.getOptimalFilterTexture = function(t, e, R, N) {
    return R === void 0 && (R = 1), N === void 0 && (N = MSAA_QUALITY$5.NONE), this.texturePool.getOptimalTexture(t, e, R, N);
  }, o.prototype.getFilterTexture = function(t, e, R) {
    if (typeof t == "number") {
      var N = t;
      t = e, e = N;
    }
    t = t || this.activeState.renderTexture;
    var M = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, R || MSAA_QUALITY$5.NONE);
    return M.filterFrame = t.filterFrame, M;
  }, o.prototype.returnFilterTexture = function(t) {
    this.texturePool.returnTexture(t);
  }, o.prototype.emptyPool = function() {
    this.texturePool.clear(!0);
  }, o.prototype.resize = function() {
    this.texturePool.setScreenSize(this.renderer.view);
  }, o.prototype.transformAABB = function(t, e) {
    var R = tempPoints[0], N = tempPoints[1], M = tempPoints[2], D = tempPoints[3];
    R.set(e.left, e.top), N.set(e.left, e.bottom), M.set(e.right, e.top), D.set(e.right, e.bottom), t.apply(R, R), t.apply(N, N), t.apply(M, M), t.apply(D, D);
    var L = Math.min(R.x, N.x, M.x, D.x), B = Math.min(R.y, N.y, M.y, D.y), $ = Math.max(R.x, N.x, M.x, D.x), U = Math.max(R.y, N.y, M.y, D.y);
    e.x = L, e.y = B, e.width = $ - L, e.height = U - B;
  }, o.prototype.roundFrame = function(t, e, R, N, M) {
    if (!(t.width <= 0 || t.height <= 0 || R.width <= 0 || R.height <= 0)) {
      if (M) {
        var D = M.a, L = M.b, B = M.c, $ = M.d;
        if ((Math.abs(L) > 1e-4 || Math.abs(B) > 1e-4) && (Math.abs(D) > 1e-4 || Math.abs($) > 1e-4))
          return;
      }
      M = M ? tempMatrix$2.copyFrom(M) : tempMatrix$2.identity(), M.translate(-R.x, -R.y).scale(N.width / R.width, N.height / R.height).translate(N.x, N.y), this.transformAABB(M, t), t.ceil(e), this.transformAABB(M.invert(), t);
    }
  }, o;
}(), ObjectRenderer = function() {
  function o(t) {
    this.renderer = t;
  }
  return o.prototype.flush = function() {
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o.prototype.start = function() {
  }, o.prototype.stop = function() {
    this.flush();
  }, o.prototype.render = function(t) {
  }, o;
}(), BatchSystem = function() {
  function o(t) {
    this.renderer = t, this.emptyRenderer = new ObjectRenderer(t), this.currentRenderer = this.emptyRenderer;
  }
  return o.prototype.setObjectRenderer = function(t) {
    this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start());
  }, o.prototype.flush = function() {
    this.setObjectRenderer(this.emptyRenderer);
  }, o.prototype.reset = function() {
    this.setObjectRenderer(this.emptyRenderer);
  }, o.prototype.copyBoundTextures = function(t, e) {
    for (var R = this.renderer.texture.boundTextures, N = e - 1; N >= 0; --N)
      t[N] = R[N] || null, t[N] && (t[N]._batchLocation = N);
  }, o.prototype.boundArray = function(t, e, R, N) {
    for (var M = t.elements, D = t.ids, L = t.count, B = 0, $ = 0; $ < L; $++) {
      var U = M[$], H = U._batchLocation;
      if (H >= 0 && H < N && e[H] === U) {
        D[$] = H;
        continue;
      }
      for (; B < N; ) {
        var z = e[B];
        if (z && z._batchEnabled === R && z._batchLocation === B) {
          B++;
          continue;
        }
        D[$] = B, U._batchLocation = B, e[B] = U;
        break;
      }
    }
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}(), CONTEXT_UID_COUNTER = 0, ContextSystem = function() {
  function o(t) {
    this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {
      uint32Indices: !1
    }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener("webglcontextlost", this.handleContextLost, !1), t.view.addEventListener("webglcontextrestored", this.handleContextRestored, !1);
  }
  return Object.defineProperty(o.prototype, "isLost", {
    get: function() {
      return !this.gl || this.gl.isContextLost();
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.contextChange = function(t) {
    this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, t.isContextLost() && t.getExtension("WEBGL_lose_context") && t.getExtension("WEBGL_lose_context").restoreContext();
  }, o.prototype.initFromContext = function(t) {
    this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, this.renderer.runners.contextChange.emit(t);
  }, o.prototype.initFromOptions = function(t) {
    var e = this.createContext(this.renderer.view, t);
    this.initFromContext(e);
  }, o.prototype.createContext = function(t, e) {
    var R;
    if (settings$1.PREFER_ENV >= ENV$5.WEBGL2 && (R = t.getContext("webgl2", e)), R)
      this.webGLVersion = 2;
    else if (this.webGLVersion = 1, R = t.getContext("webgl", e) || t.getContext("experimental-webgl", e), !R)
      throw new Error("This browser does not support WebGL. Try using the canvas renderer");
    return this.gl = R, this.getExtensions(), this.gl;
  }, o.prototype.getExtensions = function() {
    var t = this.gl, e = {
      anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: t.getExtension("OES_texture_float_linear"),
      s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: t.getExtension("WEBGL_compressed_texture_etc"),
      etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: t.getExtension("WEBGL_compressed_texture_atc"),
      astc: t.getExtension("WEBGL_compressed_texture_astc")
    };
    this.webGLVersion === 1 ? Object.assign(this.extensions, e, {
      drawBuffers: t.getExtension("WEBGL_draw_buffers"),
      depthTexture: t.getExtension("WEBGL_depth_texture"),
      loseContext: t.getExtension("WEBGL_lose_context"),
      vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
      uint32ElementIndex: t.getExtension("OES_element_index_uint"),
      floatTexture: t.getExtension("OES_texture_float"),
      floatTextureLinear: t.getExtension("OES_texture_float_linear"),
      textureHalfFloat: t.getExtension("OES_texture_half_float"),
      textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
    }) : this.webGLVersion === 2 && Object.assign(this.extensions, e, {
      colorBufferFloat: t.getExtension("EXT_color_buffer_float")
    });
  }, o.prototype.handleContextLost = function(t) {
    t.preventDefault();
  }, o.prototype.handleContextRestored = function() {
    this.renderer.runners.contextChange.emit(this.gl);
  }, o.prototype.destroy = function() {
    var t = this.renderer.view;
    this.renderer = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
  }, o.prototype.postrender = function() {
    this.renderer.renderingToScreen && this.gl.flush();
  }, o.prototype.validateContext = function(t) {
    var e = t.getContextAttributes(), R = "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext;
    R && (this.webGLVersion = 2), e && !e.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    var N = R || !!t.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = N, N || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
  }, o;
}(), GLFramebuffer = function() {
  function o(t) {
    this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = MSAA_QUALITY$5.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
  }
  return o;
}(), tempRectangle = new Rectangle(), FramebufferSystem = function() {
  function o(t) {
    this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer(10, 10), this.msaaSamples = null;
  }
  return o.prototype.contextChange = function() {
    var t = this.gl = this.renderer.gl;
    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Rectangle(), this.hasMRT = !0, this.writeDepthTexture = !0, this.disposeAll(!0), this.renderer.context.webGLVersion === 1) {
      var e = this.renderer.context.extensions.drawBuffers, R = this.renderer.context.extensions.depthTexture;
      settings$1.PREFER_ENV === ENV$5.WEBGL_LEGACY && (e = null, R = null), e ? t.drawBuffers = function(N) {
        return e.drawBuffersWEBGL(N);
      } : (this.hasMRT = !1, t.drawBuffers = function() {
      }), R || (this.writeDepthTexture = !1);
    } else
      this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES);
  }, o.prototype.bind = function(t, e, R) {
    R === void 0 && (R = 0);
    var N = this.gl;
    if (t) {
      var M = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
      this.current !== t && (this.current = t, N.bindFramebuffer(N.FRAMEBUFFER, M.framebuffer)), M.mipLevel !== R && (t.dirtyId++, t.dirtyFormat++, M.mipLevel = R), M.dirtyId !== t.dirtyId && (M.dirtyId = t.dirtyId, M.dirtyFormat !== t.dirtyFormat ? (M.dirtyFormat = t.dirtyFormat, M.dirtySize = t.dirtySize, this.updateFramebuffer(t, R)) : M.dirtySize !== t.dirtySize && (M.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));
      for (var D = 0; D < t.colorTextures.length; D++) {
        var L = t.colorTextures[D];
        this.renderer.texture.unbind(L.parentTextureArray || L);
      }
      if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {
        var B = e.width >> R, $ = e.height >> R, U = B / e.width;
        this.setViewport(e.x * U, e.y * U, B, $);
      } else {
        var B = t.width >> R, $ = t.height >> R;
        this.setViewport(0, 0, B, $);
      }
    } else
      this.current && (this.current = null, N.bindFramebuffer(N.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
  }, o.prototype.setViewport = function(t, e, R, N) {
    var M = this.viewport;
    t = Math.round(t), e = Math.round(e), R = Math.round(R), N = Math.round(N), (M.width !== R || M.height !== N || M.x !== t || M.y !== e) && (M.x = t, M.y = e, M.width = R, M.height = N, this.gl.viewport(t, e, R, N));
  }, Object.defineProperty(o.prototype, "size", {
    get: function() {
      return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.clear = function(t, e, R, N, M) {
    M === void 0 && (M = BUFFER_BITS$5.COLOR | BUFFER_BITS$5.DEPTH);
    var D = this.gl;
    D.clearColor(t, e, R, N), D.clear(M);
  }, o.prototype.initFramebuffer = function(t) {
    var e = this.gl, R = new GLFramebuffer(e.createFramebuffer());
    return R.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = R, this.managedFramebuffers.push(t), t.disposeRunner.add(this), R;
  }, o.prototype.resizeFramebuffer = function(t) {
    var e = this.gl, R = t.glFramebuffers[this.CONTEXT_UID];
    R.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, R.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, R.multisample, e.RGBA8, t.width, t.height)), R.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, R.stencil), R.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, R.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));
    var N = t.colorTextures, M = N.length;
    e.drawBuffers || (M = Math.min(M, 1));
    for (var D = 0; D < M; D++) {
      var L = N[D], B = L.parentTextureArray || L;
      this.renderer.texture.bind(B, 0);
    }
    t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0);
  }, o.prototype.updateFramebuffer = function(t, e) {
    var R = this.gl, N = t.glFramebuffers[this.CONTEXT_UID], M = t.colorTextures, D = M.length;
    R.drawBuffers || (D = Math.min(D, 1)), N.multisample > 1 && this.canMultisampleFramebuffer(t) ? (N.msaaBuffer = N.msaaBuffer || R.createRenderbuffer(), R.bindRenderbuffer(R.RENDERBUFFER, N.msaaBuffer), R.renderbufferStorageMultisample(R.RENDERBUFFER, N.multisample, R.RGBA8, t.width, t.height), R.framebufferRenderbuffer(R.FRAMEBUFFER, R.COLOR_ATTACHMENT0, R.RENDERBUFFER, N.msaaBuffer)) : N.msaaBuffer && (R.deleteRenderbuffer(N.msaaBuffer), N.msaaBuffer = null, N.blitFramebuffer && (N.blitFramebuffer.dispose(), N.blitFramebuffer = null));
    for (var L = [], B = 0; B < D; B++) {
      var $ = M[B], U = $.parentTextureArray || $;
      this.renderer.texture.bind(U, 0), !(B === 0 && N.msaaBuffer) && (R.framebufferTexture2D(R.FRAMEBUFFER, R.COLOR_ATTACHMENT0 + B, $.target, U._glTextures[this.CONTEXT_UID].texture, e), L.push(R.COLOR_ATTACHMENT0 + B));
    }
    if (L.length > 1 && R.drawBuffers(L), t.depthTexture) {
      var H = this.writeDepthTexture;
      if (H) {
        var z = t.depthTexture;
        this.renderer.texture.bind(z, 0), R.framebufferTexture2D(R.FRAMEBUFFER, R.DEPTH_ATTACHMENT, R.TEXTURE_2D, z._glTextures[this.CONTEXT_UID].texture, e);
      }
    }
    (t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (N.stencil = N.stencil || R.createRenderbuffer(), R.bindRenderbuffer(R.RENDERBUFFER, N.stencil), N.msaaBuffer ? R.renderbufferStorageMultisample(R.RENDERBUFFER, N.multisample, R.DEPTH24_STENCIL8, t.width, t.height) : R.renderbufferStorage(R.RENDERBUFFER, R.DEPTH_STENCIL, t.width, t.height), R.framebufferRenderbuffer(R.FRAMEBUFFER, R.DEPTH_STENCIL_ATTACHMENT, R.RENDERBUFFER, N.stencil)) : N.stencil && (R.deleteRenderbuffer(N.stencil), N.stencil = null);
  }, o.prototype.canMultisampleFramebuffer = function(t) {
    return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture;
  }, o.prototype.detectSamples = function(t) {
    var e = this.msaaSamples, R = MSAA_QUALITY$5.NONE;
    if (t <= 1 || e === null)
      return R;
    for (var N = 0; N < e.length; N++)
      if (e[N] <= t) {
        R = e[N];
        break;
      }
    return R === 1 && (R = MSAA_QUALITY$5.NONE), R;
  }, o.prototype.blit = function(t, e, R) {
    var N = this, M = N.current, D = N.renderer, L = N.gl, B = N.CONTEXT_UID;
    if (D.context.webGLVersion === 2 && !!M) {
      var $ = M.glFramebuffers[B];
      if (!!$) {
        if (!t) {
          if (!$.msaaBuffer)
            return;
          var U = M.colorTextures[0];
          if (!U)
            return;
          $.blitFramebuffer || ($.blitFramebuffer = new Framebuffer(M.width, M.height), $.blitFramebuffer.addColorTexture(0, U)), t = $.blitFramebuffer, t.colorTextures[0] !== U && (t.colorTextures[0] = U, t.dirtyId++, t.dirtyFormat++), (t.width !== M.width || t.height !== M.height) && (t.width = M.width, t.height = M.height, t.dirtyId++, t.dirtySize++);
        }
        e || (e = tempRectangle, e.width = M.width, e.height = M.height), R || (R = e);
        var H = e.width === R.width && e.height === R.height;
        this.bind(t), L.bindFramebuffer(L.READ_FRAMEBUFFER, $.framebuffer), L.blitFramebuffer(e.left, e.top, e.right, e.bottom, R.left, R.top, R.right, R.bottom, L.COLOR_BUFFER_BIT, H ? L.NEAREST : L.LINEAR);
      }
    }
  }, o.prototype.disposeFramebuffer = function(t, e) {
    var R = t.glFramebuffers[this.CONTEXT_UID], N = this.gl;
    if (!!R) {
      delete t.glFramebuffers[this.CONTEXT_UID];
      var M = this.managedFramebuffers.indexOf(t);
      M >= 0 && this.managedFramebuffers.splice(M, 1), t.disposeRunner.remove(this), e || (N.deleteFramebuffer(R.framebuffer), R.msaaBuffer && N.deleteRenderbuffer(R.msaaBuffer), R.stencil && N.deleteRenderbuffer(R.stencil)), R.blitFramebuffer && R.blitFramebuffer.dispose();
    }
  }, o.prototype.disposeAll = function(t) {
    var e = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (var R = 0; R < e.length; R++)
      this.disposeFramebuffer(e[R], t);
  }, o.prototype.forceStencil = function() {
    var t = this.current;
    if (!!t) {
      var e = t.glFramebuffers[this.CONTEXT_UID];
      if (!(!e || e.stencil)) {
        t.stencil = !0;
        var R = t.width, N = t.height, M = this.gl, D = M.createRenderbuffer();
        M.bindRenderbuffer(M.RENDERBUFFER, D), e.msaaBuffer ? M.renderbufferStorageMultisample(M.RENDERBUFFER, e.multisample, M.DEPTH24_STENCIL8, R, N) : M.renderbufferStorage(M.RENDERBUFFER, M.DEPTH_STENCIL, R, N), e.stencil = D, M.framebufferRenderbuffer(M.FRAMEBUFFER, M.DEPTH_STENCIL_ATTACHMENT, M.RENDERBUFFER, D);
      }
    }
  }, o.prototype.reset = function() {
    this.current = this.unknownFramebuffer, this.viewport = new Rectangle();
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}(), byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 }, GeometrySystem = function() {
  function o(t) {
    this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};
  }
  return o.prototype.contextChange = function() {
    this.disposeAll(!0);
    var t = this.gl = this.renderer.gl, e = this.renderer.context;
    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e.webGLVersion !== 2) {
      var R = this.renderer.context.extensions.vertexArrayObject;
      settings$1.PREFER_ENV === ENV$5.WEBGL_LEGACY && (R = null), R ? (t.createVertexArray = function() {
        return R.createVertexArrayOES();
      }, t.bindVertexArray = function(M) {
        return R.bindVertexArrayOES(M);
      }, t.deleteVertexArray = function(M) {
        return R.deleteVertexArrayOES(M);
      }) : (this.hasVao = !1, t.createVertexArray = function() {
        return null;
      }, t.bindVertexArray = function() {
        return null;
      }, t.deleteVertexArray = function() {
        return null;
      });
    }
    if (e.webGLVersion !== 2) {
      var N = t.getExtension("ANGLE_instanced_arrays");
      N ? (t.vertexAttribDivisor = function(M, D) {
        return N.vertexAttribDivisorANGLE(M, D);
      }, t.drawElementsInstanced = function(M, D, L, B, $) {
        return N.drawElementsInstancedANGLE(M, D, L, B, $);
      }, t.drawArraysInstanced = function(M, D, L, B) {
        return N.drawArraysInstancedANGLE(M, D, L, B);
      }) : this.hasInstance = !1;
    }
    this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex;
  }, o.prototype.bind = function(t, e) {
    e = e || this.renderer.shader.shader;
    var R = this.gl, N = t.glVertexArrayObjects[this.CONTEXT_UID], M = !1;
    N || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = N = {}, M = !0);
    var D = N[e.program.id] || this.initGeometryVao(t, e, M);
    this._activeGeometry = t, this._activeVao !== D && (this._activeVao = D, this.hasVao ? R.bindVertexArray(D) : this.activateVao(t, e.program)), this.updateBuffers();
  }, o.prototype.reset = function() {
    this.unbind();
  }, o.prototype.updateBuffers = function() {
    for (var t = this._activeGeometry, e = this.renderer.buffer, R = 0; R < t.buffers.length; R++) {
      var N = t.buffers[R];
      e.update(N);
    }
  }, o.prototype.checkCompatibility = function(t, e) {
    var R = t.attributes, N = e.attributeData;
    for (var M in N)
      if (!R[M])
        throw new Error('shader and geometry incompatible, geometry missing the "' + M + '" attribute');
  }, o.prototype.getSignature = function(t, e) {
    var R = t.attributes, N = e.attributeData, M = ["g", t.id];
    for (var D in R)
      N[D] && M.push(D, N[D].location);
    return M.join("-");
  }, o.prototype.initGeometryVao = function(t, e, R) {
    R === void 0 && (R = !0);
    var N = this.gl, M = this.CONTEXT_UID, D = this.renderer.buffer, L = e.program;
    L.glPrograms[M] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, L);
    var B = this.getSignature(t, L), $ = t.glVertexArrayObjects[this.CONTEXT_UID], U = $[B];
    if (U)
      return $[L.id] = U, U;
    var H = t.buffers, z = t.attributes, X = {}, Y = {};
    for (var W in H)
      X[W] = 0, Y[W] = 0;
    for (var W in z)
      !z[W].size && L.attributeData[W] ? z[W].size = L.attributeData[W].size : z[W].size || console.warn("PIXI Geometry attribute '" + W + "' size cannot be determined (likely the bound shader does not have the attribute)"), X[z[W].buffer] += z[W].size * byteSizeMap[z[W].type];
    for (var W in z) {
      var q = z[W], Z = q.size;
      q.stride === void 0 && (X[q.buffer] === Z * byteSizeMap[q.type] ? q.stride = 0 : q.stride = X[q.buffer]), q.start === void 0 && (q.start = Y[q.buffer], Y[q.buffer] += Z * byteSizeMap[q.type]);
    }
    U = N.createVertexArray(), N.bindVertexArray(U);
    for (var K = 0; K < H.length; K++) {
      var J = H[K];
      D.bind(J), R && J._glBuffers[M].refCount++;
    }
    return this.activateVao(t, L), this._activeVao = U, $[L.id] = U, $[B] = U, U;
  }, o.prototype.disposeGeometry = function(t, e) {
    var R;
    if (!!this.managedGeometries[t.id]) {
      delete this.managedGeometries[t.id];
      var N = t.glVertexArrayObjects[this.CONTEXT_UID], M = this.gl, D = t.buffers, L = (R = this.renderer) === null || R === void 0 ? void 0 : R.buffer;
      if (t.disposeRunner.remove(this), !!N) {
        if (L)
          for (var B = 0; B < D.length; B++) {
            var $ = D[B]._glBuffers[this.CONTEXT_UID];
            $ && ($.refCount--, $.refCount === 0 && !e && L.dispose(D[B], e));
          }
        if (!e) {
          for (var U in N)
            if (U[0] === "g") {
              var H = N[U];
              this._activeVao === H && this.unbind(), M.deleteVertexArray(H);
            }
        }
        delete t.glVertexArrayObjects[this.CONTEXT_UID];
      }
    }
  }, o.prototype.disposeAll = function(t) {
    for (var e = Object.keys(this.managedGeometries), R = 0; R < e.length; R++)
      this.disposeGeometry(this.managedGeometries[e[R]], t);
  }, o.prototype.activateVao = function(t, e) {
    var R = this.gl, N = this.CONTEXT_UID, M = this.renderer.buffer, D = t.buffers, L = t.attributes;
    t.indexBuffer && M.bind(t.indexBuffer);
    var B = null;
    for (var $ in L) {
      var U = L[$], H = D[U.buffer], z = H._glBuffers[N];
      if (e.attributeData[$]) {
        B !== z && (M.bind(H), B = z);
        var X = e.attributeData[$].location;
        if (R.enableVertexAttribArray(X), R.vertexAttribPointer(X, U.size, U.type || R.FLOAT, U.normalized, U.stride, U.start), U.instance)
          if (this.hasInstance)
            R.vertexAttribDivisor(X, 1);
          else
            throw new Error("geometry error, GPU Instancing is not supported on this device");
      }
    }
  }, o.prototype.draw = function(t, e, R, N) {
    var M = this.gl, D = this._activeGeometry;
    if (D.indexBuffer) {
      var L = D.indexBuffer.data.BYTES_PER_ELEMENT, B = L === 2 ? M.UNSIGNED_SHORT : M.UNSIGNED_INT;
      L === 2 || L === 4 && this.canUseUInt32ElementIndex ? D.instanced ? M.drawElementsInstanced(t, e || D.indexBuffer.data.length, B, (R || 0) * L, N || 1) : M.drawElements(t, e || D.indexBuffer.data.length, B, (R || 0) * L) : console.warn("unsupported index buffer type: uint32");
    } else
      D.instanced ? M.drawArraysInstanced(t, R, e || D.getSize(), N || 1) : M.drawArrays(t, R, e || D.getSize());
    return this;
  }, o.prototype.unbind = function() {
    this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}(), MaskData = function() {
  function o(t) {
    t === void 0 && (t = null), this.type = MASK_TYPES$5.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = settings$1.FILTER_MULTISAMPLE, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;
  }
  return Object.defineProperty(o.prototype, "filter", {
    get: function() {
      return this._filters ? this._filters[0] : null;
    },
    set: function(t) {
      t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.reset = function() {
    this.pooled && (this.maskObject = null, this.type = MASK_TYPES$5.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;
  }, o.prototype.copyCountersOrReset = function(t) {
    t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
  }, o;
}();
function compileShader(o, t, e) {
  var R = o.createShader(t);
  return o.shaderSource(R, e), o.compileShader(R), R;
}
function logPrettyShaderError(o, t) {
  var e = o.getShaderSource(t).split(`
`).map(function($, U) {
    return U + ": " + $;
  }), R = o.getShaderInfoLog(t), N = R.split(`
`), M = {}, D = N.map(function($) {
    return parseFloat($.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
  }).filter(function($) {
    return $ && !M[$] ? (M[$] = !0, !0) : !1;
  }), L = [""];
  D.forEach(function($) {
    e[$ - 1] = "%c" + e[$ - 1] + "%c", L.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  var B = e.join(`
`);
  L[0] = B, console.error(R), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, L), console.groupEnd();
}
function logProgramError(o, t, e, R) {
  o.getProgramParameter(t, o.LINK_STATUS) || (o.getShaderParameter(e, o.COMPILE_STATUS) || logPrettyShaderError(o, e), o.getShaderParameter(R, o.COMPILE_STATUS) || logPrettyShaderError(o, R), console.error("PixiJS Error: Could not initialize shader."), o.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", o.getProgramInfoLog(t)));
}
function booleanArray(o) {
  for (var t = new Array(o), e = 0; e < t.length; e++)
    t[e] = !1;
  return t;
}
function defaultValue(o, t) {
  switch (o) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * t);
    case "vec3":
      return new Float32Array(3 * t);
    case "vec4":
      return new Float32Array(4 * t);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * t);
    case "ivec3":
      return new Int32Array(3 * t);
    case "ivec4":
      return new Int32Array(4 * t);
    case "uvec2":
      return new Uint32Array(2 * t);
    case "uvec3":
      return new Uint32Array(3 * t);
    case "uvec4":
      return new Uint32Array(4 * t);
    case "bool":
      return !1;
    case "bvec2":
      return booleanArray(2 * t);
    case "bvec3":
      return booleanArray(3 * t);
    case "bvec4":
      return booleanArray(4 * t);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var unknownContext = {}, context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context && context.isContextLost()) {
    var o = settings$1.ADAPTER.createCanvas(), t = void 0;
    settings$1.PREFER_ENV >= ENV$5.WEBGL2 && (t = o.getContext("webgl2", {})), t || (t = o.getContext("webgl", {}) || o.getContext("experimental-webgl", {}), t ? t.getExtension("WEBGL_draw_buffers") : t = null), context = t;
  }
  return context;
}
var maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION$5.MEDIUM;
    var o = getTestContext();
    if (o && o.getShaderPrecisionFormat) {
      var t = o.getShaderPrecisionFormat(o.FRAGMENT_SHADER, o.HIGH_FLOAT);
      maxFragmentPrecision = t.precision ? PRECISION$5.HIGH : PRECISION$5.MEDIUM;
    }
  }
  return maxFragmentPrecision;
}
function setPrecision(o, t, e) {
  if (o.substring(0, 9) !== "precision") {
    var R = t;
    return t === PRECISION$5.HIGH && e !== PRECISION$5.HIGH && (R = PRECISION$5.MEDIUM), "precision " + R + ` float;
` + o;
  } else if (e !== PRECISION$5.HIGH && o.substring(0, 15) === "precision highp")
    return o.replace("precision highp", "precision mediump");
  return o;
}
var GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(o) {
  return GLSL_TO_SIZE[o];
}
var GL_TABLE = null, GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(o, t) {
  if (!GL_TABLE) {
    var e = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (var R = 0; R < e.length; ++R) {
      var N = e[R];
      GL_TABLE[o[N]] = GL_TO_GLSL_TYPES[N];
    }
  }
  return GL_TABLE[t];
}
var uniformParsers = [
  {
    test: function(o) {
      return o.type === "float" && o.size === 1;
    },
    code: function(o) {
      return `
            if(uv["` + o + '"] !== ud["' + o + `"].value)
            {
                ud["` + o + '"].value = uv["' + o + `"]
                gl.uniform1f(ud["` + o + '"].location, uv["' + o + `"])
            }
            `;
    }
  },
  {
    test: function(o, t) {
      return (o.type === "sampler2D" || o.type === "samplerCube" || o.type === "sampler2DArray") && o.size === 1 && !o.isArray && (t == null || t.castToBaseTexture !== void 0);
    },
    code: function(o) {
      return `t = syncData.textureCount++;

            renderer.texture.bind(uv["` + o + `"], t);

            if(ud["` + o + `"].value !== t)
            {
                ud["` + o + `"].value = t;
                gl.uniform1i(ud["` + o + `"].location, t);
; // eslint-disable-line max-len
            }`;
    }
  },
  {
    test: function(o, t) {
      return o.type === "mat3" && o.size === 1 && t.a !== void 0;
    },
    code: function(o) {
      return `
            gl.uniformMatrix3fv(ud["` + o + '"].location, false, uv["' + o + `"].toArray(true));
            `;
    },
    codeUbo: function(o) {
      return `
                var ` + o + "_matrix = uv." + o + `.toArray(true);

                data[offset] = ` + o + `_matrix[0];
                data[offset+1] = ` + o + `_matrix[1];
                data[offset+2] = ` + o + `_matrix[2];
        
                data[offset + 4] = ` + o + `_matrix[3];
                data[offset + 5] = ` + o + `_matrix[4];
                data[offset + 6] = ` + o + `_matrix[5];
        
                data[offset + 8] = ` + o + `_matrix[6];
                data[offset + 9] = ` + o + `_matrix[7];
                data[offset + 10] = ` + o + `_matrix[8];
            `;
    }
  },
  {
    test: function(o, t) {
      return o.type === "vec2" && o.size === 1 && t.x !== void 0;
    },
    code: function(o) {
      return `
                cv = ud["` + o + `"].value;
                v = uv["` + o + `"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["` + o + `"].location, v.x, v.y);
                }`;
    },
    codeUbo: function(o) {
      return `
                v = uv.` + o + `;

                data[offset] = v.x;
                data[offset+1] = v.y;
            `;
    }
  },
  {
    test: function(o) {
      return o.type === "vec2" && o.size === 1;
    },
    code: function(o) {
      return `
                cv = ud["` + o + `"].value;
                v = uv["` + o + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["` + o + `"].location, v[0], v[1]);
                }
            `;
    }
  },
  {
    test: function(o, t) {
      return o.type === "vec4" && o.size === 1 && t.width !== void 0;
    },
    code: function(o) {
      return `
                cv = ud["` + o + `"].value;
                v = uv["` + o + `"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["` + o + `"].location, v.x, v.y, v.width, v.height)
                }`;
    },
    codeUbo: function(o) {
      return `
                    v = uv.` + o + `;

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `;
    }
  },
  {
    test: function(o) {
      return o.type === "vec4" && o.size === 1;
    },
    code: function(o) {
      return `
                cv = ud["` + o + `"].value;
                v = uv["` + o + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["` + o + `"].location, v[0], v[1], v[2], v[3])
                }`;
    }
  }
], GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
}, GLSL_TO_ARRAY_SETTERS = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(o, t) {
  var e, R = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (var N in o.uniforms) {
    var M = t[N];
    if (!M) {
      !((e = o.uniforms[N]) === null || e === void 0) && e.group && (o.uniforms[N].ubo ? R.push(`
                        renderer.shader.syncUniformBufferGroup(uv.` + N + ", '" + N + `');
                    `) : R.push(`
                        renderer.shader.syncUniformGroup(uv.` + N + `, syncData);
                    `));
      continue;
    }
    for (var D = o.uniforms[N], L = !1, B = 0; B < uniformParsers.length; B++)
      if (uniformParsers[B].test(M, D)) {
        R.push(uniformParsers[B].code(N, D)), L = !0;
        break;
      }
    if (!L) {
      var $ = M.size === 1 ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS, U = $[M.type].replace("location", 'ud["' + N + '"].location');
      R.push(`
            cu = ud["` + N + `"];
            cv = cu.value;
            v = uv["` + N + `"];
            ` + U + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", R.join(`
`));
}
var fragTemplate$1 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function generateIfTestSrc(o) {
  for (var t = "", e = 0; e < o; ++e)
    e > 0 && (t += `
else `), e < o - 1 && (t += "if(test == " + e + ".0){}");
  return t;
}
function checkMaxIfStatementsInShader(o, t) {
  if (o === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  for (var e = t.createShader(t.FRAGMENT_SHADER); ; ) {
    var R = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(o));
    if (t.shaderSource(e, R), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))
      o = o / 2 | 0;
    else
      break;
  }
  return o;
}
var unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval == "boolean")
    return unsafeEval;
  try {
    var o = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = o({ a: "b" }, "a", "b") === !0;
  } catch {
    unsafeEval = !1;
  }
  return unsafeEval;
}
var defaultFragment$2 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`, defaultVertex$3 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`, UID$1 = 0, nameCache = {}, Program = function() {
  function o(t, e, R) {
    R === void 0 && (R = "pixi-shader"), this.id = UID$1++, this.vertexSrc = t || o.defaultVertexSrc, this.fragmentSrc = e || o.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== "#version" && (R = R.replace(/\s+/g, "-"), nameCache[R] ? (nameCache[R]++, R += "-" + nameCache[R]) : nameCache[R] = 1, this.vertexSrc = "#define SHADER_NAME " + R + `
` + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + R + `
` + this.fragmentSrc, this.vertexSrc = setPrecision(this.vertexSrc, settings$1.PRECISION_VERTEX, PRECISION$5.HIGH), this.fragmentSrc = setPrecision(this.fragmentSrc, settings$1.PRECISION_FRAGMENT, getMaxFragmentPrecision())), this.glPrograms = {}, this.syncUniforms = null;
  }
  return Object.defineProperty(o, "defaultVertexSrc", {
    get: function() {
      return defaultVertex$3;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "defaultFragmentSrc", {
    get: function() {
      return defaultFragment$2;
    },
    enumerable: !1,
    configurable: !0
  }), o.from = function(t, e, R) {
    var N = t + e, M = ProgramCache[N];
    return M || (ProgramCache[N] = M = new o(t, e, R)), M;
  }, o;
}(), Shader = function() {
  function o(t, e) {
    this.uniformBindCount = 0, this.program = t, e ? e instanceof UniformGroup ? this.uniformGroup = e : this.uniformGroup = new UniformGroup(e) : this.uniformGroup = new UniformGroup({});
  }
  return o.prototype.checkUniformExists = function(t, e) {
    if (e.uniforms[t])
      return !0;
    for (var R in e.uniforms) {
      var N = e.uniforms[R];
      if (N.group && this.checkUniformExists(t, N))
        return !0;
    }
    return !1;
  }, o.prototype.destroy = function() {
    this.uniformGroup = null;
  }, Object.defineProperty(o.prototype, "uniforms", {
    get: function() {
      return this.uniformGroup.uniforms;
    },
    enumerable: !1,
    configurable: !0
  }), o.from = function(t, e, R) {
    var N = Program.from(t, e);
    return new o(N, R);
  }, o;
}(), BLEND$1 = 0, OFFSET$1 = 1, CULLING$1 = 2, DEPTH_TEST$1 = 3, WINDING$1 = 4, DEPTH_MASK$1 = 5, State = function() {
  function o() {
    this.data = 0, this.blendMode = BLEND_MODES$5.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;
  }
  return Object.defineProperty(o.prototype, "blend", {
    get: function() {
      return !!(this.data & 1 << BLEND$1);
    },
    set: function(t) {
      !!(this.data & 1 << BLEND$1) !== t && (this.data ^= 1 << BLEND$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "offsets", {
    get: function() {
      return !!(this.data & 1 << OFFSET$1);
    },
    set: function(t) {
      !!(this.data & 1 << OFFSET$1) !== t && (this.data ^= 1 << OFFSET$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "culling", {
    get: function() {
      return !!(this.data & 1 << CULLING$1);
    },
    set: function(t) {
      !!(this.data & 1 << CULLING$1) !== t && (this.data ^= 1 << CULLING$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "depthTest", {
    get: function() {
      return !!(this.data & 1 << DEPTH_TEST$1);
    },
    set: function(t) {
      !!(this.data & 1 << DEPTH_TEST$1) !== t && (this.data ^= 1 << DEPTH_TEST$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "depthMask", {
    get: function() {
      return !!(this.data & 1 << DEPTH_MASK$1);
    },
    set: function(t) {
      !!(this.data & 1 << DEPTH_MASK$1) !== t && (this.data ^= 1 << DEPTH_MASK$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "clockwiseFrontFace", {
    get: function() {
      return !!(this.data & 1 << WINDING$1);
    },
    set: function(t) {
      !!(this.data & 1 << WINDING$1) !== t && (this.data ^= 1 << WINDING$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "blendMode", {
    get: function() {
      return this._blendMode;
    },
    set: function(t) {
      this.blend = t !== BLEND_MODES$5.NONE, this._blendMode = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "polygonOffset", {
    get: function() {
      return this._polygonOffset;
    },
    set: function(t) {
      this.offsets = !!t, this._polygonOffset = t;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.toString = function() {
    return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
  }, o.for2d = function() {
    var t = new o();
    return t.depthTest = !1, t.blend = !0, t;
  }, o;
}(), defaultFragment$1 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`, defaultVertex$2 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, Filter = function(o) {
  __extends$p(t, o);
  function t(e, R, N) {
    var M = this, D = Program.from(e || t.defaultVertexSrc, R || t.defaultFragmentSrc);
    return M = o.call(this, D, N) || this, M.padding = 0, M.resolution = settings$1.FILTER_RESOLUTION, M.multisample = settings$1.FILTER_MULTISAMPLE, M.enabled = !0, M.autoFit = !0, M.state = new State(), M;
  }
  return t.prototype.apply = function(e, R, N, M, D) {
    e.applyFilter(this, R, N, M);
  }, Object.defineProperty(t.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(e) {
      this.state.blendMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "resolution", {
    get: function() {
      return this._resolution;
    },
    set: function(e) {
      this._resolution = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t, "defaultVertexSrc", {
    get: function() {
      return defaultVertex$2;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t, "defaultFragmentSrc", {
    get: function() {
      return defaultFragment$1;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Shader), vertex$4 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`, fragment$7 = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`, tempMat$1 = new Matrix(), TextureMatrix = function() {
  function o(t, e) {
    this._texture = t, this.mapCoord = new Matrix(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof e > "u" ? 0.5 : e, this.isSimple = !1;
  }
  return Object.defineProperty(o.prototype, "texture", {
    get: function() {
      return this._texture;
    },
    set: function(t) {
      this._texture = t, this._textureID = -1;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.multiplyUvs = function(t, e) {
    e === void 0 && (e = t);
    for (var R = this.mapCoord, N = 0; N < t.length; N += 2) {
      var M = t[N], D = t[N + 1];
      e[N] = M * R.a + D * R.c + R.tx, e[N + 1] = M * R.b + D * R.d + R.ty;
    }
    return e;
  }, o.prototype.update = function(t) {
    var e = this._texture;
    if (!e || !e.valid || !t && this._textureID === e._updateID)
      return !1;
    this._textureID = e._updateID, this._updateID++;
    var R = e._uvs;
    this.mapCoord.set(R.x1 - R.x0, R.y1 - R.y0, R.x3 - R.x0, R.y3 - R.y0, R.x0, R.y0);
    var N = e.orig, M = e.trim;
    M && (tempMat$1.set(N.width / M.width, 0, 0, N.height / M.height, -M.x / M.width, -M.y / M.height), this.mapCoord.append(tempMat$1));
    var D = e.baseTexture, L = this.uClampFrame, B = this.clampMargin / D.resolution, $ = this.clampOffset;
    return L[0] = (e._frame.x + B + $) / D.width, L[1] = (e._frame.y + B + $) / D.height, L[2] = (e._frame.x + e._frame.width - B + $) / D.width, L[3] = (e._frame.y + e._frame.height - B + $) / D.height, this.uClampOffset[0] = $ / D.realWidth, this.uClampOffset[1] = $ / D.realHeight, this.isSimple = e._frame.width === D.width && e._frame.height === D.height && e.rotate === 0, !0;
  }, o;
}(), SpriteMaskFilter = function(o) {
  __extends$p(t, o);
  function t(e, R, N) {
    var M = this, D = null;
    return typeof e != "string" && R === void 0 && N === void 0 && (D = e, e = void 0, R = void 0, N = void 0), M = o.call(this, e || vertex$4, R || fragment$7, N) || this, M.maskSprite = D, M.maskMatrix = new Matrix(), M;
  }
  return Object.defineProperty(t.prototype, "maskSprite", {
    get: function() {
      return this._maskSprite;
    },
    set: function(e) {
      this._maskSprite = e, this._maskSprite && (this._maskSprite.renderable = !1);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.apply = function(e, R, N, M) {
    var D = this._maskSprite, L = D._texture;
    !L.valid || (L.uvMatrix || (L.uvMatrix = new TextureMatrix(L, 0)), L.uvMatrix.update(), this.uniforms.npmAlpha = L.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = L, this.uniforms.otherMatrix = e.calculateSpriteMatrix(this.maskMatrix, D).prepend(L.uvMatrix.mapCoord), this.uniforms.alpha = D.worldAlpha, this.uniforms.maskClamp = L.uvMatrix.uClampFrame, e.applyFilter(this, R, N, M));
  }, t;
}(Filter), MaskSystem = function() {
  function o(t) {
    this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
  }
  return o.prototype.setMaskStack = function(t) {
    this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t);
  }, o.prototype.push = function(t, e) {
    var R = e;
    if (!R.isMaskData) {
      var N = this.maskDataPool.pop() || new MaskData();
      N.pooled = !0, N.maskObject = e, R = N;
    }
    var M = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    if (R.copyCountersOrReset(M), R._colorMask = M ? M._colorMask : 15, R.autoDetect && this.detect(R), R._target = t, R.type !== MASK_TYPES$5.SPRITE && this.maskStack.push(R), R.enabled)
      switch (R.type) {
        case MASK_TYPES$5.SCISSOR:
          this.renderer.scissor.push(R);
          break;
        case MASK_TYPES$5.STENCIL:
          this.renderer.stencil.push(R);
          break;
        case MASK_TYPES$5.SPRITE:
          R.copyCountersOrReset(null), this.pushSpriteMask(R);
          break;
        case MASK_TYPES$5.COLOR:
          this.pushColorMask(R);
          break;
      }
    R.type === MASK_TYPES$5.SPRITE && this.maskStack.push(R);
  }, o.prototype.pop = function(t) {
    var e = this.maskStack.pop();
    if (!(!e || e._target !== t)) {
      if (e.enabled)
        switch (e.type) {
          case MASK_TYPES$5.SCISSOR:
            this.renderer.scissor.pop(e);
            break;
          case MASK_TYPES$5.STENCIL:
            this.renderer.stencil.pop(e.maskObject);
            break;
          case MASK_TYPES$5.SPRITE:
            this.popSpriteMask(e);
            break;
          case MASK_TYPES$5.COLOR:
            this.popColorMask(e);
            break;
        }
      if (e.reset(), e.pooled && this.maskDataPool.push(e), this.maskStack.length !== 0) {
        var R = this.maskStack[this.maskStack.length - 1];
        R.type === MASK_TYPES$5.SPRITE && R._filters && (R._filters[0].maskSprite = R.maskObject);
      }
    }
  }, o.prototype.detect = function(t) {
    var e = t.maskObject;
    e ? e.isSprite ? t.type = MASK_TYPES$5.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = MASK_TYPES$5.SCISSOR : t.type = MASK_TYPES$5.STENCIL : t.type = MASK_TYPES$5.COLOR;
  }, o.prototype.pushSpriteMask = function(t) {
    var e, R, N = t.maskObject, M = t._target, D = t._filters;
    D || (D = this.alphaMaskPool[this.alphaMaskIndex], D || (D = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()]));
    var L = this.renderer, B = L.renderTexture, $, U;
    if (B.current) {
      var H = B.current;
      $ = t.resolution || H.resolution, U = (e = t.multisample) !== null && e !== void 0 ? e : H.multisample;
    } else
      $ = t.resolution || L.resolution, U = (R = t.multisample) !== null && R !== void 0 ? R : L.multisample;
    D[0].resolution = $, D[0].multisample = U, D[0].maskSprite = N;
    var z = M.filterArea;
    M.filterArea = N.getBounds(!0), L.filter.push(M, D), M.filterArea = z, t._filters || this.alphaMaskIndex++;
  }, o.prototype.popSpriteMask = function(t) {
    this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
  }, o.prototype.pushColorMask = function(t) {
    var e = t._colorMask, R = t._colorMask = e & t.colorMask;
    R !== e && this.renderer.gl.colorMask((R & 1) !== 0, (R & 2) !== 0, (R & 4) !== 0, (R & 8) !== 0);
  }, o.prototype.popColorMask = function(t) {
    var e = t._colorMask, R = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
    R !== e && this.renderer.gl.colorMask((R & 1) !== 0, (R & 2) !== 0, (R & 4) !== 0, (R & 8) !== 0);
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}(), AbstractMaskSystem = function() {
  function o(t) {
    this.renderer = t, this.maskStack = [], this.glConst = 0;
  }
  return o.prototype.getStackLength = function() {
    return this.maskStack.length;
  }, o.prototype.setMaskStack = function(t) {
    var e = this.renderer.gl, R = this.getStackLength();
    this.maskStack = t;
    var N = this.getStackLength();
    N !== R && (N === 0 ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()));
  }, o.prototype._useCurrent = function() {
  }, o.prototype.destroy = function() {
    this.renderer = null, this.maskStack = null;
  }, o;
}(), tempMatrix$1 = new Matrix(), rectPool = [], ScissorSystem = function(o) {
  __extends$p(t, o);
  function t(e) {
    var R = o.call(this, e) || this;
    return R.glConst = settings$1.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST, R;
  }
  return t.prototype.getStackLength = function() {
    var e = this.maskStack[this.maskStack.length - 1];
    return e ? e._scissorCounter : 0;
  }, t.prototype.calcScissorRect = function(e) {
    var R;
    if (!e._scissorRectLocal) {
      var N = e._scissorRect, M = e.maskObject, D = this.renderer, L = D.renderTexture, B = M.getBounds(!0, (R = rectPool.pop()) !== null && R !== void 0 ? R : new Rectangle());
      this.roundFrameToPixels(B, L.current ? L.current.resolution : D.resolution, L.sourceFrame, L.destinationFrame, D.projection.transform), N && B.fit(N), e._scissorRectLocal = B;
    }
  }, t.isMatrixRotated = function(e) {
    if (!e)
      return !1;
    var R = e.a, N = e.b, M = e.c, D = e.d;
    return (Math.abs(N) > 1e-4 || Math.abs(M) > 1e-4) && (Math.abs(R) > 1e-4 || Math.abs(D) > 1e-4);
  }, t.prototype.testScissor = function(e) {
    var R = e.maskObject;
    if (!R.isFastRect || !R.isFastRect() || t.isMatrixRotated(R.worldTransform) || t.isMatrixRotated(this.renderer.projection.transform))
      return !1;
    this.calcScissorRect(e);
    var N = e._scissorRectLocal;
    return N.width > 0 && N.height > 0;
  }, t.prototype.roundFrameToPixels = function(e, R, N, M, D) {
    t.isMatrixRotated(D) || (D = D ? tempMatrix$1.copyFrom(D) : tempMatrix$1.identity(), D.translate(-N.x, -N.y).scale(M.width / N.width, M.height / N.height).translate(M.x, M.y), this.renderer.filter.transformAABB(D, e), e.fit(M), e.x = Math.round(e.x * R), e.y = Math.round(e.y * R), e.width = Math.round(e.width * R), e.height = Math.round(e.height * R));
  }, t.prototype.push = function(e) {
    e._scissorRectLocal || this.calcScissorRect(e);
    var R = this.renderer.gl;
    e._scissorRect || R.enable(R.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent();
  }, t.prototype.pop = function(e) {
    var R = this.renderer.gl;
    e && rectPool.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : R.disable(R.SCISSOR_TEST);
  }, t.prototype._useCurrent = function() {
    var e = this.maskStack[this.maskStack.length - 1]._scissorRect, R;
    this.renderer.renderTexture.current ? R = e.y : R = this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, R, e.width, e.height);
  }, t;
}(AbstractMaskSystem), StencilSystem = function(o) {
  __extends$p(t, o);
  function t(e) {
    var R = o.call(this, e) || this;
    return R.glConst = settings$1.ADAPTER.getWebGLRenderingContext().STENCIL_TEST, R;
  }
  return t.prototype.getStackLength = function() {
    var e = this.maskStack[this.maskStack.length - 1];
    return e ? e._stencilCounter : 0;
  }, t.prototype.push = function(e) {
    var R = e.maskObject, N = this.renderer.gl, M = e._stencilCounter;
    M === 0 && (this.renderer.framebuffer.forceStencil(), N.clearStencil(0), N.clear(N.STENCIL_BUFFER_BIT), N.enable(N.STENCIL_TEST)), e._stencilCounter++;
    var D = e._colorMask;
    D !== 0 && (e._colorMask = 0, N.colorMask(!1, !1, !1, !1)), N.stencilFunc(N.EQUAL, M, 4294967295), N.stencilOp(N.KEEP, N.KEEP, N.INCR), R.renderable = !0, R.render(this.renderer), this.renderer.batch.flush(), R.renderable = !1, D !== 0 && (e._colorMask = D, N.colorMask((D & 1) !== 0, (D & 2) !== 0, (D & 4) !== 0, (D & 8) !== 0)), this._useCurrent();
  }, t.prototype.pop = function(e) {
    var R = this.renderer.gl;
    if (this.getStackLength() === 0)
      R.disable(R.STENCIL_TEST);
    else {
      var N = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, M = N ? N._colorMask : 15;
      M !== 0 && (N._colorMask = 0, R.colorMask(!1, !1, !1, !1)), R.stencilOp(R.KEEP, R.KEEP, R.DECR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, M !== 0 && (N._colorMask = M, R.colorMask((M & 1) !== 0, (M & 2) !== 0, (M & 4) !== 0, (M & 8) !== 0)), this._useCurrent();
    }
  }, t.prototype._useCurrent = function() {
    var e = this.renderer.gl;
    e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP);
  }, t;
}(AbstractMaskSystem), ProjectionSystem = function() {
  function o(t) {
    this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Matrix(), this.transform = null;
  }
  return o.prototype.update = function(t, e, R, N) {
    this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, R, N), this.transform && this.projectionMatrix.append(this.transform);
    var M = this.renderer;
    M.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, M.globalUniforms.update(), M.shader.shader && M.shader.syncUniformGroup(M.shader.shader.uniforms.globals);
  }, o.prototype.calculateProjection = function(t, e, R, N) {
    var M = this.projectionMatrix, D = N ? -1 : 1;
    M.identity(), M.a = 1 / e.width * 2, M.d = D * (1 / e.height * 2), M.tx = -1 - e.x * M.a, M.ty = -D - e.y * M.d;
  }, o.prototype.setTransform = function(t) {
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}(), tempRect = new Rectangle(), tempRect2 = new Rectangle(), RenderTextureSystem = function() {
  function o(t) {
    this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.viewportFrame = new Rectangle();
  }
  return o.prototype.bind = function(t, e, R) {
    t === void 0 && (t = null);
    var N = this.renderer;
    this.current = t;
    var M, D, L;
    t ? (M = t.baseTexture, L = M.resolution, e || (tempRect.width = t.frame.width, tempRect.height = t.frame.height, e = tempRect), R || (tempRect2.x = t.frame.x, tempRect2.y = t.frame.y, tempRect2.width = e.width, tempRect2.height = e.height, R = tempRect2), D = M.framebuffer) : (L = N.resolution, e || (tempRect.width = N.screen.width, tempRect.height = N.screen.height, e = tempRect), R || (R = tempRect, R.width = e.width, R.height = e.height));
    var B = this.viewportFrame;
    B.x = R.x * L, B.y = R.y * L, B.width = R.width * L, B.height = R.height * L, t || (B.y = N.view.height - (B.y + B.height)), B.ceil(), this.renderer.framebuffer.bind(D, B), this.renderer.projection.update(R, e, L, !D), t ? this.renderer.mask.setMaskStack(M.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(R);
  }, o.prototype.clear = function(t, e) {
    this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.clearColor;
    var R = this.destinationFrame, N = this.current ? this.current.baseTexture : this.renderer.screen, M = R.width !== N.width || R.height !== N.height;
    if (M) {
      var D = this.viewportFrame, L = D.x, B = D.y, $ = D.width, U = D.height;
      L = Math.round(L), B = Math.round(B), $ = Math.round($), U = Math.round(U), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(L, B, $, U);
    }
    this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), M && this.renderer.scissor.pop();
  }, o.prototype.resize = function() {
    this.bind(null);
  }, o.prototype.reset = function() {
    this.bind(null);
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}();
function uboUpdate(o, t, e, R, N) {
  e.buffer.update(N);
}
var UBO_TO_SINGLE_SETTERS = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}, GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(o) {
  for (var t = o.map(function(B) {
    return {
      data: B,
      offset: 0,
      dataLen: 0,
      dirty: 0
    };
  }), e = 0, R = 0, N = 0, M = 0; M < t.length; M++) {
    var D = t[M];
    if (e = GLSL_TO_STD40_SIZE[D.data.type], D.data.size > 1 && (e = Math.max(e, 16) * D.data.size), D.dataLen = e, R % e !== 0 && R < 16) {
      var L = R % e % 16;
      R += L, N += L;
    }
    R + e > 16 ? (N = Math.ceil(N / 16) * 16, D.offset = N, N += e, R = e) : (D.offset = N, R += e, N += e);
  }
  return N = Math.ceil(N / 16) * 16, { uboElements: t, size: N };
}
function getUBOData(o, t) {
  var e = [];
  for (var R in o)
    t[R] && e.push(t[R]);
  return e.sort(function(N, M) {
    return N.index - M.index;
  }), e;
}
function generateUniformBufferSync(o, t) {
  if (!o.autoManage)
    return { size: 0, syncFunc: uboUpdate };
  for (var e = getUBOData(o.uniforms, t), R = createUBOElements(e), N = R.uboElements, M = R.size, D = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `], L = 0; L < N.length; L++) {
    for (var B = N[L], $ = o.uniforms[B.data.name], U = B.data.name, H = !1, z = 0; z < uniformParsers.length; z++) {
      var X = uniformParsers[z];
      if (X.codeUbo && X.test(B.data, $)) {
        D.push("offset = " + B.offset / 4 + ";", uniformParsers[z].codeUbo(B.data.name, $)), H = !0;
        break;
      }
    }
    if (!H)
      if (B.data.size > 1) {
        var Y = mapSize(B.data.type), W = Math.max(GLSL_TO_STD40_SIZE[B.data.type] / 16, 1), q = Y / W, Z = (4 - q % 4) % 4;
        D.push(`
                cv = ud.` + U + `.value;
                v = uv.` + U + `;
                offset = ` + B.offset / 4 + `;

                t = 0;

                for(var i=0; i < ` + B.data.size * W + `; i++)
                {
                    for(var j = 0; j < ` + q + `; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ` + Z + `;
                }

                `);
      } else {
        var K = UBO_TO_SINGLE_SETTERS[B.data.type];
        D.push(`
                cv = ud.` + U + `.value;
                v = uv.` + U + `;
                offset = ` + B.offset / 4 + `;
                ` + K + `;
                `);
      }
  }
  return D.push(`
       renderer.buffer.update(buffer);
    `), {
    size: M,
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", D.join(`
`))
  };
}
var GLProgram = function() {
  function o(t, e) {
    this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
  }
  return o.prototype.destroy = function() {
    this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
  }, o;
}();
function getAttributeData(o, t) {
  for (var e = {}, R = t.getProgramParameter(o, t.ACTIVE_ATTRIBUTES), N = 0; N < R; N++) {
    var M = t.getActiveAttrib(o, N);
    if (M.name.indexOf("gl_") !== 0) {
      var D = mapType(t, M.type), L = {
        type: D,
        name: M.name,
        size: mapSize(D),
        location: t.getAttribLocation(o, M.name)
      };
      e[M.name] = L;
    }
  }
  return e;
}
function getUniformData(o, t) {
  for (var e = {}, R = t.getProgramParameter(o, t.ACTIVE_UNIFORMS), N = 0; N < R; N++) {
    var M = t.getActiveUniform(o, N), D = M.name.replace(/\[.*?\]$/, ""), L = !!M.name.match(/\[.*?\]$/), B = mapType(t, M.type);
    e[D] = {
      name: D,
      index: N,
      type: B,
      size: M.size,
      isArray: L,
      value: defaultValue(B, M.size)
    };
  }
  return e;
}
function generateProgram(o, t) {
  var e = compileShader(o, o.VERTEX_SHADER, t.vertexSrc), R = compileShader(o, o.FRAGMENT_SHADER, t.fragmentSrc), N = o.createProgram();
  if (o.attachShader(N, e), o.attachShader(N, R), o.linkProgram(N), o.getProgramParameter(N, o.LINK_STATUS) || logProgramError(o, N, e, R), t.attributeData = getAttributeData(N, o), t.uniformData = getUniformData(N, o), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc)) {
    var M = Object.keys(t.attributeData);
    M.sort(function(U, H) {
      return U > H ? 1 : -1;
    });
    for (var D = 0; D < M.length; D++)
      t.attributeData[M[D]].location = D, o.bindAttribLocation(N, D, M[D]);
    o.linkProgram(N);
  }
  o.deleteShader(e), o.deleteShader(R);
  var L = {};
  for (var D in t.uniformData) {
    var B = t.uniformData[D];
    L[D] = {
      location: o.getUniformLocation(N, D),
      value: defaultValue(B.type, B.size)
    };
  }
  var $ = new GLProgram(N, L);
  return $;
}
var UID = 0, defaultSyncData = { textureCount: 0, uboCount: 0 }, ShaderSystem = function() {
  function o(t) {
    this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = UID++;
  }
  return o.prototype.systemCheck = function() {
    if (!unsafeEvalSupported())
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
  }, o.prototype.contextChange = function(t) {
    this.gl = t, this.reset();
  }, o.prototype.bind = function(t, e) {
    t.uniforms.globals = this.renderer.globalUniforms;
    var R = t.program, N = R.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
    return this.shader = t, this.program !== R && (this.program = R, this.gl.useProgram(N.program)), e || (defaultSyncData.textureCount = 0, defaultSyncData.uboCount = 0, this.syncUniformGroup(t.uniformGroup, defaultSyncData)), N;
  }, o.prototype.setUniforms = function(t) {
    var e = this.shader.program, R = e.glPrograms[this.renderer.CONTEXT_UID];
    e.syncUniforms(R.uniformData, t, this.renderer);
  }, o.prototype.syncUniformGroup = function(t, e) {
    var R = this.getGlProgram();
    (!t.static || t.dirtyId !== R.uniformDirtyGroups[t.id]) && (R.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, R, e));
  }, o.prototype.syncUniforms = function(t, e, R) {
    var N = t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t);
    N(e.uniformData, t.uniforms, this.renderer, R);
  }, o.prototype.createSyncGroups = function(t) {
    var e = this.getSignature(t, this.shader.program.uniformData, "u");
    return this.cache[e] || (this.cache[e] = generateUniformsSync(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id];
  }, o.prototype.syncUniformBufferGroup = function(t, e) {
    var R = this.getGlProgram();
    if (!t.static || t.dirtyId !== 0 || !R.uniformGroups[t.id]) {
      t.dirtyId = 0;
      var N = R.uniformGroups[t.id] || this.createSyncBufferGroup(t, R, e);
      t.buffer.update(), N(R.uniformData, t.uniforms, this.renderer, defaultSyncData, t.buffer);
    }
    this.renderer.buffer.bindBufferBase(t.buffer, R.uniformBufferBindings[e]);
  }, o.prototype.createSyncBufferGroup = function(t, e, R) {
    var N = this.renderer.gl;
    this.renderer.buffer.bind(t.buffer);
    var M = this.gl.getUniformBlockIndex(e.program, R);
    e.uniformBufferBindings[R] = this.shader.uniformBindCount, N.uniformBlockBinding(e.program, M, this.shader.uniformBindCount), this.shader.uniformBindCount++;
    var D = this.getSignature(t, this.shader.program.uniformData, "ubo"), L = this._uboCache[D];
    if (L || (L = this._uboCache[D] = generateUniformBufferSync(t, this.shader.program.uniformData)), t.autoManage) {
      var B = new Float32Array(L.size / 4);
      t.buffer.update(B);
    }
    return e.uniformGroups[t.id] = L.syncFunc, e.uniformGroups[t.id];
  }, o.prototype.getSignature = function(t, e, R) {
    var N = t.uniforms, M = [R + "-"];
    for (var D in N)
      M.push(D), e[D] && M.push(e[D].type);
    return M.join("-");
  }, o.prototype.getGlProgram = function() {
    return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
  }, o.prototype.generateProgram = function(t) {
    var e = this.gl, R = t.program, N = generateProgram(e, R);
    return R.glPrograms[this.renderer.CONTEXT_UID] = N, N;
  }, o.prototype.reset = function() {
    this.program = null, this.shader = null;
  }, o.prototype.destroy = function() {
    this.renderer = null, this.destroyed = !0;
  }, o;
}();
function mapWebGLBlendModesToPixi(o, t) {
  return t === void 0 && (t = []), t[BLEND_MODES$5.NORMAL] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.ADD] = [o.ONE, o.ONE], t[BLEND_MODES$5.MULTIPLY] = [o.DST_COLOR, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SCREEN] = [o.ONE, o.ONE_MINUS_SRC_COLOR, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.OVERLAY] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DARKEN] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.LIGHTEN] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.COLOR_DODGE] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.COLOR_BURN] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.HARD_LIGHT] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SOFT_LIGHT] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DIFFERENCE] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.EXCLUSION] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.HUE] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SATURATION] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.COLOR] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.LUMINOSITY] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.NONE] = [0, 0], t[BLEND_MODES$5.NORMAL_NPM] = [o.SRC_ALPHA, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.ADD_NPM] = [o.SRC_ALPHA, o.ONE, o.ONE, o.ONE], t[BLEND_MODES$5.SCREEN_NPM] = [o.SRC_ALPHA, o.ONE_MINUS_SRC_COLOR, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SRC_IN] = [o.DST_ALPHA, o.ZERO], t[BLEND_MODES$5.SRC_OUT] = [o.ONE_MINUS_DST_ALPHA, o.ZERO], t[BLEND_MODES$5.SRC_ATOP] = [o.DST_ALPHA, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DST_OVER] = [o.ONE_MINUS_DST_ALPHA, o.ONE], t[BLEND_MODES$5.DST_IN] = [o.ZERO, o.SRC_ALPHA], t[BLEND_MODES$5.DST_OUT] = [o.ZERO, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DST_ATOP] = [o.ONE_MINUS_DST_ALPHA, o.SRC_ALPHA], t[BLEND_MODES$5.XOR] = [o.ONE_MINUS_DST_ALPHA, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SUBTRACT] = [o.ONE, o.ONE, o.ONE, o.ONE, o.FUNC_REVERSE_SUBTRACT, o.FUNC_ADD], t;
}
var BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5, StateSystem = function() {
  function o() {
    this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = BLEND_MODES$5.NONE, this._blendEq = !1, this.map = [], this.map[BLEND] = this.setBlend, this.map[OFFSET] = this.setOffset, this.map[CULLING] = this.setCullFace, this.map[DEPTH_TEST] = this.setDepthTest, this.map[WINDING] = this.setFrontFace, this.map[DEPTH_MASK] = this.setDepthMask, this.checks = [], this.defaultState = new State(), this.defaultState.blend = !0;
  }
  return o.prototype.contextChange = function(t) {
    this.gl = t, this.blendModes = mapWebGLBlendModesToPixi(t), this.set(this.defaultState), this.reset();
  }, o.prototype.set = function(t) {
    if (t = t || this.defaultState, this.stateId !== t.data) {
      for (var e = this.stateId ^ t.data, R = 0; e; )
        e & 1 && this.map[R].call(this, !!(t.data & 1 << R)), e = e >> 1, R++;
      this.stateId = t.data;
    }
    for (var R = 0; R < this.checks.length; R++)
      this.checks[R](this, t);
  }, o.prototype.forceState = function(t) {
    t = t || this.defaultState;
    for (var e = 0; e < this.map.length; e++)
      this.map[e].call(this, !!(t.data & 1 << e));
    for (var e = 0; e < this.checks.length; e++)
      this.checks[e](this, t);
    this.stateId = t.data;
  }, o.prototype.setBlend = function(t) {
    this.updateCheck(o.checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND);
  }, o.prototype.setOffset = function(t) {
    this.updateCheck(o.checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }, o.prototype.setDepthTest = function(t) {
    this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }, o.prototype.setDepthMask = function(t) {
    this.gl.depthMask(t);
  }, o.prototype.setCullFace = function(t) {
    this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE);
  }, o.prototype.setFrontFace = function(t) {
    this.gl.frontFace(this.gl[t ? "CW" : "CCW"]);
  }, o.prototype.setBlendMode = function(t) {
    if (t !== this.blendMode) {
      this.blendMode = t;
      var e = this.blendModes[t], R = this.gl;
      e.length === 2 ? R.blendFunc(e[0], e[1]) : R.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, R.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, R.blendEquationSeparate(R.FUNC_ADD, R.FUNC_ADD));
    }
  }, o.prototype.setPolygonOffset = function(t, e) {
    this.gl.polygonOffset(t, e);
  }, o.prototype.reset = function() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);
  }, o.prototype.updateCheck = function(t, e) {
    var R = this.checks.indexOf(t);
    e && R === -1 ? this.checks.push(t) : !e && R !== -1 && this.checks.splice(R, 1);
  }, o.checkBlendMode = function(t, e) {
    t.setBlendMode(e.blendMode);
  }, o.checkPolygonOffset = function(t, e) {
    t.setPolygonOffset(1, e.polygonOffset);
  }, o.prototype.destroy = function() {
    this.gl = null;
  }, o;
}(), TextureGCSystem = function() {
  function o(t) {
    this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = settings$1.GC_MAX_IDLE, this.checkCountMax = settings$1.GC_MAX_CHECK_COUNT, this.mode = settings$1.GC_MODE;
  }
  return o.prototype.postrender = function() {
    !this.renderer.renderingToScreen || (this.count++, this.mode !== GC_MODES$5.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
  }, o.prototype.run = function() {
    for (var t = this.renderer.texture, e = t.managedTextures, R = !1, N = 0; N < e.length; N++) {
      var M = e[N];
      !M.framebuffer && this.count - M.touched > this.maxIdle && (t.destroyTexture(M, !0), e[N] = null, R = !0);
    }
    if (R) {
      for (var D = 0, N = 0; N < e.length; N++)
        e[N] !== null && (e[D++] = e[N]);
      e.length = D;
    }
  }, o.prototype.unload = function(t) {
    var e = this.renderer.texture, R = t._texture;
    R && !R.framebuffer && e.destroyTexture(R);
    for (var N = t.children.length - 1; N >= 0; N--)
      this.unload(t.children[N]);
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}();
function mapTypeAndFormatToInternalFormat(o) {
  var t, e, R, N, M, D, L, B, $, U, H, z, X, Y, W, q, Z, K, J, Q, et, tt, st;
  return "WebGL2RenderingContext" in globalThis && o instanceof globalThis.WebGL2RenderingContext ? st = (t = {}, t[TYPES$5.UNSIGNED_BYTE] = (e = {}, e[FORMATS$5.RGBA] = o.RGBA8, e[FORMATS$5.RGB] = o.RGB8, e[FORMATS$5.RG] = o.RG8, e[FORMATS$5.RED] = o.R8, e[FORMATS$5.RGBA_INTEGER] = o.RGBA8UI, e[FORMATS$5.RGB_INTEGER] = o.RGB8UI, e[FORMATS$5.RG_INTEGER] = o.RG8UI, e[FORMATS$5.RED_INTEGER] = o.R8UI, e[FORMATS$5.ALPHA] = o.ALPHA, e[FORMATS$5.LUMINANCE] = o.LUMINANCE, e[FORMATS$5.LUMINANCE_ALPHA] = o.LUMINANCE_ALPHA, e), t[TYPES$5.BYTE] = (R = {}, R[FORMATS$5.RGBA] = o.RGBA8_SNORM, R[FORMATS$5.RGB] = o.RGB8_SNORM, R[FORMATS$5.RG] = o.RG8_SNORM, R[FORMATS$5.RED] = o.R8_SNORM, R[FORMATS$5.RGBA_INTEGER] = o.RGBA8I, R[FORMATS$5.RGB_INTEGER] = o.RGB8I, R[FORMATS$5.RG_INTEGER] = o.RG8I, R[FORMATS$5.RED_INTEGER] = o.R8I, R), t[TYPES$5.UNSIGNED_SHORT] = (N = {}, N[FORMATS$5.RGBA_INTEGER] = o.RGBA16UI, N[FORMATS$5.RGB_INTEGER] = o.RGB16UI, N[FORMATS$5.RG_INTEGER] = o.RG16UI, N[FORMATS$5.RED_INTEGER] = o.R16UI, N[FORMATS$5.DEPTH_COMPONENT] = o.DEPTH_COMPONENT16, N), t[TYPES$5.SHORT] = (M = {}, M[FORMATS$5.RGBA_INTEGER] = o.RGBA16I, M[FORMATS$5.RGB_INTEGER] = o.RGB16I, M[FORMATS$5.RG_INTEGER] = o.RG16I, M[FORMATS$5.RED_INTEGER] = o.R16I, M), t[TYPES$5.UNSIGNED_INT] = (D = {}, D[FORMATS$5.RGBA_INTEGER] = o.RGBA32UI, D[FORMATS$5.RGB_INTEGER] = o.RGB32UI, D[FORMATS$5.RG_INTEGER] = o.RG32UI, D[FORMATS$5.RED_INTEGER] = o.R32UI, D[FORMATS$5.DEPTH_COMPONENT] = o.DEPTH_COMPONENT24, D), t[TYPES$5.INT] = (L = {}, L[FORMATS$5.RGBA_INTEGER] = o.RGBA32I, L[FORMATS$5.RGB_INTEGER] = o.RGB32I, L[FORMATS$5.RG_INTEGER] = o.RG32I, L[FORMATS$5.RED_INTEGER] = o.R32I, L), t[TYPES$5.FLOAT] = (B = {}, B[FORMATS$5.RGBA] = o.RGBA32F, B[FORMATS$5.RGB] = o.RGB32F, B[FORMATS$5.RG] = o.RG32F, B[FORMATS$5.RED] = o.R32F, B[FORMATS$5.DEPTH_COMPONENT] = o.DEPTH_COMPONENT32F, B), t[TYPES$5.HALF_FLOAT] = ($ = {}, $[FORMATS$5.RGBA] = o.RGBA16F, $[FORMATS$5.RGB] = o.RGB16F, $[FORMATS$5.RG] = o.RG16F, $[FORMATS$5.RED] = o.R16F, $), t[TYPES$5.UNSIGNED_SHORT_5_6_5] = (U = {}, U[FORMATS$5.RGB] = o.RGB565, U), t[TYPES$5.UNSIGNED_SHORT_4_4_4_4] = (H = {}, H[FORMATS$5.RGBA] = o.RGBA4, H), t[TYPES$5.UNSIGNED_SHORT_5_5_5_1] = (z = {}, z[FORMATS$5.RGBA] = o.RGB5_A1, z), t[TYPES$5.UNSIGNED_INT_2_10_10_10_REV] = (X = {}, X[FORMATS$5.RGBA] = o.RGB10_A2, X[FORMATS$5.RGBA_INTEGER] = o.RGB10_A2UI, X), t[TYPES$5.UNSIGNED_INT_10F_11F_11F_REV] = (Y = {}, Y[FORMATS$5.RGB] = o.R11F_G11F_B10F, Y), t[TYPES$5.UNSIGNED_INT_5_9_9_9_REV] = (W = {}, W[FORMATS$5.RGB] = o.RGB9_E5, W), t[TYPES$5.UNSIGNED_INT_24_8] = (q = {}, q[FORMATS$5.DEPTH_STENCIL] = o.DEPTH24_STENCIL8, q), t[TYPES$5.FLOAT_32_UNSIGNED_INT_24_8_REV] = (Z = {}, Z[FORMATS$5.DEPTH_STENCIL] = o.DEPTH32F_STENCIL8, Z), t) : st = (K = {}, K[TYPES$5.UNSIGNED_BYTE] = (J = {}, J[FORMATS$5.RGBA] = o.RGBA, J[FORMATS$5.RGB] = o.RGB, J[FORMATS$5.ALPHA] = o.ALPHA, J[FORMATS$5.LUMINANCE] = o.LUMINANCE, J[FORMATS$5.LUMINANCE_ALPHA] = o.LUMINANCE_ALPHA, J), K[TYPES$5.UNSIGNED_SHORT_5_6_5] = (Q = {}, Q[FORMATS$5.RGB] = o.RGB, Q), K[TYPES$5.UNSIGNED_SHORT_4_4_4_4] = (et = {}, et[FORMATS$5.RGBA] = o.RGBA, et), K[TYPES$5.UNSIGNED_SHORT_5_5_5_1] = (tt = {}, tt[FORMATS$5.RGBA] = o.RGBA, tt), K), st;
}
var GLTexture = function() {
  function o(t) {
    this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = TYPES$5.UNSIGNED_BYTE, this.internalFormat = FORMATS$5.RGBA, this.samplerType = 0;
  }
  return o;
}(), TextureSystem = function() {
  function o(t) {
    this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new BaseTexture(), this.hasIntegerTextures = !1;
  }
  return o.prototype.contextChange = function() {
    var t = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat(t);
    var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = e;
    for (var R = 0; R < e; R++)
      this.boundTextures[R] = null;
    this.emptyTextures = {};
    var N = new GLTexture(t.createTexture());
    t.bindTexture(t.TEXTURE_2D, N.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = N, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new GLTexture(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
    for (var R = 0; R < 6; R++)
      t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + R, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
    t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
    for (var R = 0; R < this.boundTextures.length; R++)
      this.bind(null, R);
  }, o.prototype.bind = function(t, e) {
    e === void 0 && (e = 0);
    var R = this.gl;
    if (t = t == null ? void 0 : t.castToBaseTexture(), t && t.valid && !t.parentTextureArray) {
      t.touched = this.renderer.textureGC.count;
      var N = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
      this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, R.activeTexture(R.TEXTURE0 + e)), R.bindTexture(t.target, N.texture)), N.dirtyId !== t.dirtyId && (this.currentLocation !== e && (this.currentLocation = e, R.activeTexture(R.TEXTURE0 + e)), this.updateTexture(t)), this.boundTextures[e] = t;
    } else
      this.currentLocation !== e && (this.currentLocation = e, R.activeTexture(R.TEXTURE0 + e)), R.bindTexture(R.TEXTURE_2D, this.emptyTextures[R.TEXTURE_2D].texture), this.boundTextures[e] = null;
  }, o.prototype.reset = function() {
    this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;
    for (var t = 0; t < this.boundTextures.length; t++)
      this.boundTextures[t] = this.unknownTexture;
  }, o.prototype.unbind = function(t) {
    var e = this, R = e.gl, N = e.boundTextures;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = !1;
      for (var M = 0; M < N.length; M++)
        N[M] === this.unknownTexture && this.bind(null, M);
    }
    for (var M = 0; M < N.length; M++)
      N[M] === t && (this.currentLocation !== M && (R.activeTexture(R.TEXTURE0 + M), this.currentLocation = M), R.bindTexture(t.target, this.emptyTextures[t.target].texture), N[M] = null);
  }, o.prototype.ensureSamplerType = function(t) {
    var e = this, R = e.boundTextures, N = e.hasIntegerTextures, M = e.CONTEXT_UID;
    if (!!N)
      for (var D = t - 1; D >= 0; --D) {
        var L = R[D];
        if (L) {
          var B = L._glTextures[M];
          B.samplerType !== SAMPLER_TYPES$5.FLOAT && this.renderer.texture.unbind(L);
        }
      }
  }, o.prototype.initTexture = function(t) {
    var e = new GLTexture(this.gl.createTexture());
    return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), e;
  }, o.prototype.initTextureType = function(t, e) {
    var R, N;
    e.internalFormat = (N = (R = this.internalFormats[t.type]) === null || R === void 0 ? void 0 : R[t.format]) !== null && N !== void 0 ? N : t.format, this.webGLVersion === 2 && t.type === TYPES$5.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type;
  }, o.prototype.updateTexture = function(t) {
    var e = t._glTextures[this.CONTEXT_UID];
    if (!!e) {
      var R = this.renderer;
      if (this.initTextureType(t, e), t.resource && t.resource.upload(R, t, e))
        e.samplerType !== SAMPLER_TYPES$5.FLOAT && (this.hasIntegerTextures = !0);
      else {
        var N = t.realWidth, M = t.realHeight, D = R.gl;
        (e.width !== N || e.height !== M || e.dirtyId < 0) && (e.width = N, e.height = M, D.texImage2D(t.target, 0, e.internalFormat, N, M, 0, t.format, e.type, null));
      }
      t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId;
    }
  }, o.prototype.destroyTexture = function(t, e) {
    var R = this.gl;
    if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), R.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {
      var N = this.managedTextures.indexOf(t);
      N !== -1 && removeItems(this.managedTextures, N, 1);
    }
  }, o.prototype.updateTextureStyle = function(t) {
    var e = t._glTextures[this.CONTEXT_UID];
    !e || ((t.mipmap === MIPMAP_MODES$5.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? e.mipmap = !1 : e.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? e.wrapMode = WRAP_MODES$5.CLAMP : e.wrapMode = t.wrapMode, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId);
  }, o.prototype.setStyle = function(t, e) {
    var R = this.gl;
    if (e.mipmap && t.mipmap !== MIPMAP_MODES$5.ON_MANUAL && R.generateMipmap(t.target), R.texParameteri(t.target, R.TEXTURE_WRAP_S, e.wrapMode), R.texParameteri(t.target, R.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {
      R.texParameteri(t.target, R.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES$5.LINEAR ? R.LINEAR_MIPMAP_LINEAR : R.NEAREST_MIPMAP_NEAREST);
      var N = this.renderer.context.extensions.anisotropicFiltering;
      if (N && t.anisotropicLevel > 0 && t.scaleMode === SCALE_MODES$5.LINEAR) {
        var M = Math.min(t.anisotropicLevel, R.getParameter(N.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        R.texParameterf(t.target, N.TEXTURE_MAX_ANISOTROPY_EXT, M);
      }
    } else
      R.texParameteri(t.target, R.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES$5.LINEAR ? R.LINEAR : R.NEAREST);
    R.texParameteri(t.target, R.TEXTURE_MAG_FILTER, t.scaleMode === SCALE_MODES$5.LINEAR ? R.LINEAR : R.NEAREST);
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o;
}(), tempMatrix = new Matrix(), AbstractRenderer = function(o) {
  __extends$p(t, o);
  function t(e, R) {
    e === void 0 && (e = RENDERER_TYPE$5.UNKNOWN);
    var N = o.call(this) || this;
    return R = Object.assign({}, settings$1.RENDER_OPTIONS, R), N.options = R, N.type = e, N.screen = new Rectangle(0, 0, R.width, R.height), N.view = R.view || settings$1.ADAPTER.createCanvas(), N.resolution = R.resolution || settings$1.RESOLUTION, N.useContextAlpha = R.useContextAlpha, N.autoDensity = !!R.autoDensity, N.preserveDrawingBuffer = R.preserveDrawingBuffer, N.clearBeforeRender = R.clearBeforeRender, N._backgroundColor = 0, N._backgroundColorRgba = [0, 0, 0, 1], N._backgroundColorString = "#000000", N.backgroundColor = R.backgroundColor || N._backgroundColor, N.backgroundAlpha = R.backgroundAlpha, R.transparent !== void 0 && (deprecation$1("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), N.useContextAlpha = R.transparent, N.backgroundAlpha = R.transparent ? 0 : 1), N._lastObjectRendered = null, N.plugins = {}, N;
  }
  return t.prototype.initPlugins = function(e) {
    for (var R in e)
      this.plugins[R] = new e[R](this);
  }, Object.defineProperty(t.prototype, "width", {
    get: function() {
      return this.view.width;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    get: function() {
      return this.view.height;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.resize = function(e, R) {
    this.view.width = Math.round(e * this.resolution), this.view.height = Math.round(R * this.resolution);
    var N = this.view.width / this.resolution, M = this.view.height / this.resolution;
    this.screen.width = N, this.screen.height = M, this.autoDensity && (this.view.style.width = N + "px", this.view.style.height = M + "px"), this.emit("resize", N, M);
  }, t.prototype.generateTexture = function(e, R, N, M) {
    R === void 0 && (R = {}), typeof R == "number" && (deprecation$1("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), R = { scaleMode: R, resolution: N, region: M });
    var D = R.region, L = __rest$3(R, ["region"]);
    M = D || e.getLocalBounds(null, !0), M.width === 0 && (M.width = 1), M.height === 0 && (M.height = 1);
    var B = RenderTexture.create(__assign$8({ width: M.width, height: M.height }, L));
    return tempMatrix.tx = -M.x, tempMatrix.ty = -M.y, this.render(e, {
      renderTexture: B,
      clear: !1,
      transform: tempMatrix,
      skipUpdateTransform: !!e.parent
    }), B;
  }, t.prototype.destroy = function(e) {
    for (var R in this.plugins)
      this.plugins[R].destroy(), this.plugins[R] = null;
    e && this.view.parentNode && this.view.parentNode.removeChild(this.view);
    var N = this;
    N.plugins = null, N.type = RENDERER_TYPE$5.UNKNOWN, N.view = null, N.screen = null, N._tempDisplayObjectParent = null, N.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;
  }, Object.defineProperty(t.prototype, "backgroundColor", {
    get: function() {
      return this._backgroundColor;
    },
    set: function(e) {
      this._backgroundColor = e, this._backgroundColorString = hex2string(e), hex2rgb(e, this._backgroundColorRgba);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "backgroundAlpha", {
    get: function() {
      return this._backgroundColorRgba[3];
    },
    set: function(e) {
      this._backgroundColorRgba[3] = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(n), GLBuffer = function() {
  function o(t) {
    this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
  }
  return o;
}(), BufferSystem = function() {
  function o(t) {
    this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {};
  }
  return o.prototype.destroy = function() {
    this.renderer = null;
  }, o.prototype.contextChange = function() {
    this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }, o.prototype.bind = function(t) {
    var e = this, R = e.gl, N = e.CONTEXT_UID, M = t._glBuffers[N] || this.createGLBuffer(t);
    R.bindBuffer(t.type, M.buffer);
  }, o.prototype.bindBufferBase = function(t, e) {
    var R = this, N = R.gl, M = R.CONTEXT_UID;
    if (this.boundBufferBases[e] !== t) {
      var D = t._glBuffers[M] || this.createGLBuffer(t);
      this.boundBufferBases[e] = t, N.bindBufferBase(N.UNIFORM_BUFFER, e, D.buffer);
    }
  }, o.prototype.bindBufferRange = function(t, e, R) {
    var N = this, M = N.gl, D = N.CONTEXT_UID;
    R = R || 0;
    var L = t._glBuffers[D] || this.createGLBuffer(t);
    M.bindBufferRange(M.UNIFORM_BUFFER, e || 0, L.buffer, R * 256, 256);
  }, o.prototype.update = function(t) {
    var e = this, R = e.gl, N = e.CONTEXT_UID, M = t._glBuffers[N];
    if (t._updateID !== M.updateID)
      if (M.updateID = t._updateID, R.bindBuffer(t.type, M.buffer), M.byteLength >= t.data.byteLength)
        R.bufferSubData(t.type, 0, t.data);
      else {
        var D = t.static ? R.STATIC_DRAW : R.DYNAMIC_DRAW;
        M.byteLength = t.data.byteLength, R.bufferData(t.type, t.data, D);
      }
  }, o.prototype.dispose = function(t, e) {
    if (!!this.managedBuffers[t.id]) {
      delete this.managedBuffers[t.id];
      var R = t._glBuffers[this.CONTEXT_UID], N = this.gl;
      t.disposeRunner.remove(this), R && (e || N.deleteBuffer(R.buffer), delete t._glBuffers[this.CONTEXT_UID]);
    }
  }, o.prototype.disposeAll = function(t) {
    for (var e = Object.keys(this.managedBuffers), R = 0; R < e.length; R++)
      this.dispose(this.managedBuffers[e[R]], t);
  }, o.prototype.createGLBuffer = function(t) {
    var e = this, R = e.CONTEXT_UID, N = e.gl;
    return t._glBuffers[R] = new GLBuffer(N.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[R];
  }, o;
}(), Renderer = function(o) {
  __extends$p(t, o);
  function t(e) {
    var R = o.call(this, RENDERER_TYPE$5.WEBGL, e) || this;
    return e = R.options, R.gl = null, R.CONTEXT_UID = 0, R.runners = {
      destroy: new Runner("destroy"),
      contextChange: new Runner("contextChange"),
      reset: new Runner("reset"),
      update: new Runner("update"),
      postrender: new Runner("postrender"),
      prerender: new Runner("prerender"),
      resize: new Runner("resize")
    }, R.runners.contextChange.add(R), R.globalUniforms = new UniformGroup({
      projectionMatrix: new Matrix()
    }, !0), R.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(BufferSystem, "buffer").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch"), R.initPlugins(t.__plugins), R.multisample = void 0, e.context ? R.context.initFromContext(e.context) : R.context.initFromOptions({
      alpha: !!R.useContextAlpha,
      antialias: e.antialias,
      premultipliedAlpha: R.useContextAlpha && R.useContextAlpha !== "notMultiplied",
      stencil: !0,
      preserveDrawingBuffer: e.preserveDrawingBuffer,
      powerPreference: R.options.powerPreference
    }), R.renderingToScreen = !0, sayHello(R.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1"), R.resize(R.options.width, R.options.height), R;
  }
  return t.create = function(e) {
    if (isWebGLSupported())
      return new t(e);
    throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
  }, t.prototype.contextChange = function() {
    var e = this.gl, R;
    if (this.context.webGLVersion === 1) {
      var N = e.getParameter(e.FRAMEBUFFER_BINDING);
      e.bindFramebuffer(e.FRAMEBUFFER, null), R = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, N);
    } else {
      var N = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);
      e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), R = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, N);
    }
    R >= MSAA_QUALITY$5.HIGH ? this.multisample = MSAA_QUALITY$5.HIGH : R >= MSAA_QUALITY$5.MEDIUM ? this.multisample = MSAA_QUALITY$5.MEDIUM : R >= MSAA_QUALITY$5.LOW ? this.multisample = MSAA_QUALITY$5.LOW : this.multisample = MSAA_QUALITY$5.NONE;
  }, t.prototype.addSystem = function(e, R) {
    var N = new e(this);
    if (this[R])
      throw new Error('Whoops! The name "' + R + '" is already in use');
    this[R] = N;
    for (var M in this.runners)
      this.runners[M].add(N);
    return this;
  }, t.prototype.render = function(e, R) {
    var N, M, D, L;
    if (R && (R instanceof RenderTexture ? (deprecation$1("6.0.0", "Renderer#render arguments changed, use options instead."), N = R, M = arguments[2], D = arguments[3], L = arguments[4]) : (N = R.renderTexture, M = R.clear, D = R.transform, L = R.skipUpdateTransform)), this.renderingToScreen = !N, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = D, !this.context.isLost) {
      if (N || (this._lastObjectRendered = e), !L) {
        var B = e.enableTempParent();
        e.updateTransform(), e.disableTempParent(B);
      }
      this.renderTexture.bind(N), this.batch.currentRenderer.start(), (M !== void 0 ? M : this.clearBeforeRender) && this.renderTexture.clear(), e.render(this), this.batch.currentRenderer.flush(), N && N.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender");
    }
  }, t.prototype.generateTexture = function(e, R, N, M) {
    R === void 0 && (R = {});
    var D = o.prototype.generateTexture.call(this, e, R, N, M);
    return this.framebuffer.blit(), D;
  }, t.prototype.resize = function(e, R) {
    o.prototype.resize.call(this, e, R), this.runners.resize.emit(this.screen.height, this.screen.width);
  }, t.prototype.reset = function() {
    return this.runners.reset.emit(), this;
  }, t.prototype.clear = function() {
    this.renderTexture.bind(), this.renderTexture.clear();
  }, t.prototype.destroy = function(e) {
    this.runners.destroy.emit();
    for (var R in this.runners)
      this.runners[R].destroy();
    o.prototype.destroy.call(this, e), this.gl = null;
  }, Object.defineProperty(t.prototype, "extract", {
    get: function() {
      return deprecation$1("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract;
    },
    enumerable: !1,
    configurable: !0
  }), t.registerPlugin = function(e, R) {
    deprecation$1("6.5.0", "Renderer.registerPlugin() has been deprecated, please use extensions.add() instead."), extensions.add({
      name: e,
      type: ExtensionType.RendererPlugin,
      ref: R
    });
  }, t.__plugins = {}, t;
}(AbstractRenderer);
extensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
function autoDetectRenderer(o) {
  return Renderer.create(o);
}
var $defaultVertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`, $defaultFilterVertex = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, defaultVertex$1 = $defaultVertex, defaultFilterVertex = $defaultFilterVertex, BatchDrawCall = function() {
  function o() {
    this.texArray = null, this.blend = 0, this.type = DRAW_MODES$5.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
  }
  return o;
}(), BatchTextureArray = function() {
  function o() {
    this.elements = [], this.ids = [], this.count = 0;
  }
  return o.prototype.clear = function() {
    for (var t = 0; t < this.count; t++)
      this.elements[t] = null;
    this.count = 0;
  }, o;
}(), ViewableBuffer = function() {
  function o(t) {
    typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
  }
  return Object.defineProperty(o.prototype, "int8View", {
    get: function() {
      return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "uint8View", {
    get: function() {
      return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "int16View", {
    get: function() {
      return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "uint16View", {
    get: function() {
      return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "int32View", {
    get: function() {
      return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.view = function(t) {
    return this[t + "View"];
  }, o.prototype.destroy = function() {
    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
  }, o.sizeOf = function(t) {
    switch (t) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(t + " isn't a valid view type");
    }
  }, o;
}(), AbstractBatchRenderer = function(o) {
  __extends$p(t, o);
  function t(e) {
    var R = o.call(this, e) || this;
    return R.shaderGenerator = null, R.geometryClass = null, R.vertexSize = null, R.state = State.for2d(), R.size = settings$1.SPRITE_BATCH_SIZE * 4, R._vertexCount = 0, R._indexCount = 0, R._bufferedElements = [], R._bufferedTextures = [], R._bufferSize = 0, R._shader = null, R._packedGeometries = [], R._packedGeometryPoolSize = 2, R._flushId = 0, R._aBuffers = {}, R._iBuffers = {}, R.MAX_TEXTURES = 1, R.renderer.on("prerender", R.onPrerender, R), e.runners.contextChange.add(R), R._dcIndex = 0, R._aIndex = 0, R._iIndex = 0, R._attributeBuffer = null, R._indexBuffer = null, R._tempBoundTextures = [], R;
  }
  return t.prototype.contextChange = function() {
    var e = this.renderer.gl;
    settings$1.PREFER_ENV === ENV$5.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), settings$1.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, e)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
    for (var R = 0; R < this._packedGeometryPoolSize; R++)
      this._packedGeometries[R] = new this.geometryClass();
    this.initFlushBuffers();
  }, t.prototype.initFlushBuffers = function() {
    for (var e = t._drawCallPool, R = t._textureArrayPool, N = this.size / 4, M = Math.floor(N / this.MAX_TEXTURES) + 1; e.length < N; )
      e.push(new BatchDrawCall());
    for (; R.length < M; )
      R.push(new BatchTextureArray());
    for (var D = 0; D < this.MAX_TEXTURES; D++)
      this._tempBoundTextures[D] = null;
  }, t.prototype.onPrerender = function() {
    this._flushId = 0;
  }, t.prototype.render = function(e) {
    !e._texture.valid || (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e);
  }, t.prototype.buildTexturesAndDrawCalls = function() {
    var e = this, R = e._bufferedTextures, N = e.MAX_TEXTURES, M = t._textureArrayPool, D = this.renderer.batch, L = this._tempBoundTextures, B = this.renderer.textureGC.count, $ = ++BaseTexture._globalBatch, U = 0, H = M[0], z = 0;
    D.copyBoundTextures(L, N);
    for (var X = 0; X < this._bufferSize; ++X) {
      var Y = R[X];
      R[X] = null, Y._batchEnabled !== $ && (H.count >= N && (D.boundArray(H, L, $, N), this.buildDrawCalls(H, z, X), z = X, H = M[++U], ++$), Y._batchEnabled = $, Y.touched = B, H.elements[H.count++] = Y);
    }
    H.count > 0 && (D.boundArray(H, L, $, N), this.buildDrawCalls(H, z, this._bufferSize), ++U, ++$);
    for (var X = 0; X < L.length; X++)
      L[X] = null;
    BaseTexture._globalBatch = $;
  }, t.prototype.buildDrawCalls = function(e, R, N) {
    var M = this, D = M._bufferedElements, L = M._attributeBuffer, B = M._indexBuffer, $ = M.vertexSize, U = t._drawCallPool, H = this._dcIndex, z = this._aIndex, X = this._iIndex, Y = U[H];
    Y.start = this._iIndex, Y.texArray = e;
    for (var W = R; W < N; ++W) {
      var q = D[W], Z = q._texture.baseTexture, K = premultiplyBlendMode[Z.alphaMode ? 1 : 0][q.blendMode];
      D[W] = null, R < W && Y.blend !== K && (Y.size = X - Y.start, R = W, Y = U[++H], Y.texArray = e, Y.start = X), this.packInterleavedGeometry(q, L, B, z, X), z += q.vertexData.length / 2 * $, X += q.indices.length, Y.blend = K;
    }
    R < N && (Y.size = X - Y.start, ++H), this._dcIndex = H, this._aIndex = z, this._iIndex = X;
  }, t.prototype.bindAndClearTexArray = function(e) {
    for (var R = this.renderer.texture, N = 0; N < e.count; N++)
      R.bind(e.elements[N], e.ids[N]), e.elements[N] = null;
    e.count = 0;
  }, t.prototype.updateGeometry = function() {
    var e = this, R = e._packedGeometries, N = e._attributeBuffer, M = e._indexBuffer;
    settings$1.CAN_UPLOAD_SAME_BUFFER ? (R[this._flushId]._buffer.update(N.rawBinaryData), R[this._flushId]._indexBuffer.update(M), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, R[this._flushId] = new this.geometryClass()), R[this._flushId]._buffer.update(N.rawBinaryData), R[this._flushId]._indexBuffer.update(M), this.renderer.geometry.bind(R[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
  }, t.prototype.drawBatches = function() {
    for (var e = this._dcIndex, R = this.renderer, N = R.gl, M = R.state, D = t._drawCallPool, L = null, B = 0; B < e; B++) {
      var $ = D[B], U = $.texArray, H = $.type, z = $.size, X = $.start, Y = $.blend;
      L !== U && (L = U, this.bindAndClearTexArray(U)), this.state.blendMode = Y, M.set(this.state), N.drawElements(H, z, N.UNSIGNED_SHORT, X * 2);
    }
  }, t.prototype.flush = function() {
    this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
  }, t.prototype.start = function() {
    this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), settings$1.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
  }, t.prototype.stop = function() {
    this.flush();
  }, t.prototype.destroy = function() {
    for (var e = 0; e < this._packedGeometryPoolSize; e++)
      this._packedGeometries[e] && this._packedGeometries[e].destroy();
    this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), o.prototype.destroy.call(this);
  }, t.prototype.getAttributeBuffer = function(e) {
    var R = nextPow2(Math.ceil(e / 8)), N = log2(R), M = R * 8;
    this._aBuffers.length <= N && (this._iBuffers.length = N + 1);
    var D = this._aBuffers[M];
    return D || (this._aBuffers[M] = D = new ViewableBuffer(M * this.vertexSize * 4)), D;
  }, t.prototype.getIndexBuffer = function(e) {
    var R = nextPow2(Math.ceil(e / 12)), N = log2(R), M = R * 12;
    this._iBuffers.length <= N && (this._iBuffers.length = N + 1);
    var D = this._iBuffers[N];
    return D || (this._iBuffers[N] = D = new Uint16Array(M)), D;
  }, t.prototype.packInterleavedGeometry = function(e, R, N, M, D) {
    for (var L = R.uint32View, B = R.float32View, $ = M / this.vertexSize, U = e.uvs, H = e.indices, z = e.vertexData, X = e._texture.baseTexture._batchLocation, Y = Math.min(e.worldAlpha, 1), W = Y < 1 && e._texture.baseTexture.alphaMode ? premultiplyTint(e._tintRGB, Y) : e._tintRGB + (Y * 255 << 24), q = 0; q < z.length; q += 2)
      B[M++] = z[q], B[M++] = z[q + 1], B[M++] = U[q], B[M++] = U[q + 1], L[M++] = W, B[M++] = X;
    for (var q = 0; q < H.length; q++)
      N[D++] = $ + H[q];
  }, t._drawCallPool = [], t._textureArrayPool = [], t;
}(ObjectRenderer), BatchShaderGenerator = function() {
  function o(t, e) {
    if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf("%count%") < 0)
      throw new Error('Fragment template must contain "%count%".');
    if (e.indexOf("%forloop%") < 0)
      throw new Error('Fragment template must contain "%forloop%".');
  }
  return o.prototype.generateShader = function(t) {
    if (!this.programCache[t]) {
      for (var e = new Int32Array(t), R = 0; R < t; R++)
        e[R] = R;
      this.defaultGroupCache[t] = UniformGroup.from({ uSamplers: e }, !0);
      var N = this.fragTemplate;
      N = N.replace(/%count%/gi, "" + t), N = N.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new Program(this.vertexSrc, N);
    }
    var M = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new Matrix(),
      default: this.defaultGroupCache[t]
    };
    return new Shader(this.programCache[t], M);
  }, o.prototype.generateSampleSrc = function(t) {
    var e = "";
    e += `
`, e += `
`;
    for (var R = 0; R < t; R++)
      R > 0 && (e += `
else `), R < t - 1 && (e += "if(vTextureId < " + R + ".5)"), e += `
{`, e += `
	color = texture2D(uSamplers[` + R + "], vTextureCoord);", e += `
}`;
    return e += `
`, e += `
`, e;
  }, o;
}(), BatchGeometry = function(o) {
  __extends$p(t, o);
  function t(e) {
    e === void 0 && (e = !1);
    var R = o.call(this) || this;
    return R._buffer = new Buffer$1(null, e, !1), R._indexBuffer = new Buffer$1(null, e, !0), R.addAttribute("aVertexPosition", R._buffer, 2, !1, TYPES$5.FLOAT).addAttribute("aTextureCoord", R._buffer, 2, !1, TYPES$5.FLOAT).addAttribute("aColor", R._buffer, 4, !0, TYPES$5.UNSIGNED_BYTE).addAttribute("aTextureId", R._buffer, 1, !0, TYPES$5.FLOAT).addIndex(R._indexBuffer), R;
  }
  return t;
}(Geometry), defaultVertex = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`, defaultFragment = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`, BatchPluginFactory = function() {
  function o() {
  }
  return o.create = function(t) {
    var e = Object.assign({
      vertex: defaultVertex,
      fragment: defaultFragment,
      geometryClass: BatchGeometry,
      vertexSize: 6
    }, t), R = e.vertex, N = e.fragment, M = e.vertexSize, D = e.geometryClass;
    return function(L) {
      __extends$p(B, L);
      function B($) {
        var U = L.call(this, $) || this;
        return U.shaderGenerator = new BatchShaderGenerator(R, N), U.geometryClass = D, U.vertexSize = M, U;
      }
      return B;
    }(AbstractBatchRenderer);
  }, Object.defineProperty(o, "defaultVertexSrc", {
    get: function() {
      return defaultVertex;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "defaultFragmentTemplate", {
    get: function() {
      return defaultFragment;
    },
    enumerable: !1,
    configurable: !0
  }), o;
}(), BatchRenderer = BatchPluginFactory.create();
Object.assign(BatchRenderer, {
  extension: {
    name: "batch",
    type: ExtensionType.RendererPlugin
  }
});
/*!
 * @pixi/accessibility - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/accessibility is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var accessibleTarget = {
  accessible: !1,
  accessibleTitle: null,
  accessibleHint: null,
  tabIndex: 0,
  _accessibleActive: !1,
  _accessibleDiv: null,
  accessibleType: "button",
  accessiblePointerEvents: "auto",
  accessibleChildren: !0,
  renderId: -1
};
DisplayObject.mixin(accessibleTarget);
var KEY_CODE_TAB = 9, DIV_TOUCH_SIZE = 100, DIV_TOUCH_POS_X = 0, DIV_TOUCH_POS_Y = 0, DIV_TOUCH_ZINDEX = 2, DIV_HOOK_SIZE = 1, DIV_HOOK_POS_X = -1e3, DIV_HOOK_POS_Y = -1e3, DIV_HOOK_ZINDEX = 2, AccessibilityManager = function() {
  function o(t) {
    this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (isMobile$2.tablet || isMobile$2.phone) && this.createTouchHook();
    var e = document.createElement("div");
    e.style.width = DIV_TOUCH_SIZE + "px", e.style.height = DIV_TOUCH_SIZE + "px", e.style.position = "absolute", e.style.top = DIV_TOUCH_POS_X + "px", e.style.left = DIV_TOUCH_POS_Y + "px", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1);
  }
  return Object.defineProperty(o.prototype, "isActive", {
    get: function() {
      return this._isActive;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "isMobileAccessibility", {
    get: function() {
      return this._isMobileAccessibility;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.createTouchHook = function() {
    var t = this, e = document.createElement("button");
    e.style.width = DIV_HOOK_SIZE + "px", e.style.height = DIV_HOOK_SIZE + "px", e.style.position = "absolute", e.style.top = DIV_HOOK_POS_X + "px", e.style.left = DIV_HOOK_POS_Y + "px", e.style.zIndex = DIV_HOOK_ZINDEX.toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessibility for this content", e.addEventListener("focus", function() {
      t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook();
    }), document.body.appendChild(e), this._hookDiv = e;
  }, o.prototype.destroyTouchHook = function() {
    !this._hookDiv || (document.body.removeChild(this._hookDiv), this._hookDiv = null);
  }, o.prototype.activate = function() {
    var t;
    this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), (t = this.renderer.view.parentNode) === null || t === void 0 || t.appendChild(this.div));
  }, o.prototype.deactivate = function() {
    var t;
    !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), (t = this.div.parentNode) === null || t === void 0 || t.removeChild(this.div));
  }, o.prototype.updateAccessibleObjects = function(t) {
    if (!(!t.visible || !t.accessibleChildren)) {
      t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);
      var e = t.children;
      if (e)
        for (var R = 0; R < e.length; R++)
          this.updateAccessibleObjects(e[R]);
    }
  }, o.prototype.update = function() {
    var t = performance.now();
    if (!(isMobile$2.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, !!this.renderer.renderingToScreen)) {
      this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);
      var e = this.renderer.view.getBoundingClientRect(), R = e.left, N = e.top, M = e.width, D = e.height, L = this.renderer, B = L.width, $ = L.height, U = L.resolution, H = M / B * U, z = D / $ * U, X = this.div;
      X.style.left = R + "px", X.style.top = N + "px", X.style.width = B + "px", X.style.height = $ + "px";
      for (var Y = 0; Y < this.children.length; Y++) {
        var W = this.children[Y];
        if (W.renderId !== this.renderId)
          W._accessibleActive = !1, removeItems(this.children, Y, 1), this.div.removeChild(W._accessibleDiv), this.pool.push(W._accessibleDiv), W._accessibleDiv = null, Y--;
        else {
          X = W._accessibleDiv;
          var q = W.hitArea, Z = W.worldTransform;
          W.hitArea ? (X.style.left = (Z.tx + q.x * Z.a) * H + "px", X.style.top = (Z.ty + q.y * Z.d) * z + "px", X.style.width = q.width * Z.a * H + "px", X.style.height = q.height * Z.d * z + "px") : (q = W.getBounds(), this.capHitArea(q), X.style.left = q.x * H + "px", X.style.top = q.y * z + "px", X.style.width = q.width * H + "px", X.style.height = q.height * z + "px", X.title !== W.accessibleTitle && W.accessibleTitle !== null && (X.title = W.accessibleTitle), X.getAttribute("aria-label") !== W.accessibleHint && W.accessibleHint !== null && X.setAttribute("aria-label", W.accessibleHint)), (W.accessibleTitle !== X.title || W.tabIndex !== X.tabIndex) && (X.title = W.accessibleTitle, X.tabIndex = W.tabIndex, this.debug && this.updateDebugHTML(X));
        }
      }
      this.renderId++;
    }
  }, o.prototype.updateDebugHTML = function(t) {
    t.innerHTML = "type: " + t.type + "</br> title : " + t.title + "</br> tabIndex: " + t.tabIndex;
  }, o.prototype.capHitArea = function(t) {
    t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
    var e = this.renderer, R = e.width, N = e.height;
    t.x + t.width > R && (t.width = R - t.x), t.y + t.height > N && (t.height = N - t.y);
  }, o.prototype.addChild = function(t) {
    var e = this.pool.pop();
    e || (e = document.createElement("button"), e.style.width = DIV_TOUCH_SIZE + "px", e.style.height = DIV_TOUCH_SIZE + "px", e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = "displayObject " + t.tabIndex), t.accessibleHint && t.accessibleHint !== null && e.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex;
  }, o.prototype._onClick = function(t) {
    var e = this.renderer.plugins.interaction, R = t.target.displayObject, N = e.eventData;
    e.dispatchEvent(R, "click", N), e.dispatchEvent(R, "pointertap", N), e.dispatchEvent(R, "tap", N);
  }, o.prototype._onFocus = function(t) {
    t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive");
    var e = this.renderer.plugins.interaction, R = t.target.displayObject, N = e.eventData;
    e.dispatchEvent(R, "mouseover", N);
  }, o.prototype._onFocusOut = function(t) {
    t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite");
    var e = this.renderer.plugins.interaction, R = t.target.displayObject, N = e.eventData;
    e.dispatchEvent(R, "mouseout", N);
  }, o.prototype._onKeyDown = function(t) {
    t.keyCode === KEY_CODE_TAB && this.activate();
  }, o.prototype._onMouseMove = function(t) {
    t.movementX === 0 && t.movementY === 0 || this.deactivate();
  }, o.prototype.destroy = function() {
    this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;
  }, o.extension = {
    name: "accessibility",
    type: [
      ExtensionType.RendererPlugin,
      ExtensionType.CanvasRendererPlugin
    ]
  }, o;
}();
/*!
 * @pixi/interaction - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var InteractionData = function() {
  function o() {
    this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new Point(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;
  }
  return Object.defineProperty(o.prototype, "pointerId", {
    get: function() {
      return this.identifier;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.getLocalPosition = function(t, e, R) {
    return t.worldTransform.applyInverse(R || this.global, e);
  }, o.prototype.copyEvent = function(t) {
    "isPrimary" in t && t.isPrimary && (this.isPrimary = !0), this.button = "button" in t && t.button;
    var e = "buttons" in t && t.buttons;
    this.buttons = Number.isInteger(e) ? e : "which" in t && t.which, this.width = "width" in t && t.width, this.height = "height" in t && t.height, this.tiltX = "tiltX" in t && t.tiltX, this.tiltY = "tiltY" in t && t.tiltY, this.pointerType = "pointerType" in t && t.pointerType, this.pressure = "pressure" in t && t.pressure, this.rotationAngle = "rotationAngle" in t && t.rotationAngle, this.twist = "twist" in t && t.twist || 0, this.tangentialPressure = "tangentialPressure" in t && t.tangentialPressure || 0;
  }, o.prototype.reset = function() {
    this.isPrimary = !1;
  }, o;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$o = function(o, t) {
  return extendStatics$o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$o(o, t);
};
function __extends$o(o, t) {
  extendStatics$o(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var InteractionEvent = function() {
  function o() {
    this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null;
  }
  return o.prototype.stopPropagation = function() {
    this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget;
  }, o.prototype.reset = function() {
    this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null;
  }, o;
}(), InteractionTrackingData = function() {
  function o(t) {
    this._pointerId = t, this._flags = o.FLAGS.NONE;
  }
  return o.prototype._doSet = function(t, e) {
    e ? this._flags = this._flags | t : this._flags = this._flags & ~t;
  }, Object.defineProperty(o.prototype, "pointerId", {
    get: function() {
      return this._pointerId;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "flags", {
    get: function() {
      return this._flags;
    },
    set: function(t) {
      this._flags = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "none", {
    get: function() {
      return this._flags === o.FLAGS.NONE;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "over", {
    get: function() {
      return (this._flags & o.FLAGS.OVER) !== 0;
    },
    set: function(t) {
      this._doSet(o.FLAGS.OVER, t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "rightDown", {
    get: function() {
      return (this._flags & o.FLAGS.RIGHT_DOWN) !== 0;
    },
    set: function(t) {
      this._doSet(o.FLAGS.RIGHT_DOWN, t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "leftDown", {
    get: function() {
      return (this._flags & o.FLAGS.LEFT_DOWN) !== 0;
    },
    set: function(t) {
      this._doSet(o.FLAGS.LEFT_DOWN, t);
    },
    enumerable: !1,
    configurable: !0
  }), o.FLAGS = Object.freeze({
    NONE: 0,
    OVER: 1 << 0,
    LEFT_DOWN: 1 << 1,
    RIGHT_DOWN: 1 << 2
  }), o;
}(), TreeSearch = function() {
  function o() {
    this._tempPoint = new Point();
  }
  return o.prototype.recursiveFindHit = function(t, e, R, N, M) {
    var D;
    if (!e || !e.visible)
      return !1;
    var L = t.data.global;
    M = e.interactive || M;
    var B = !1, $ = M, U = !0;
    if (e.hitArea)
      N && (e.worldTransform.applyInverse(L, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? B = !0 : (N = !1, U = !1)), $ = !1;
    else if (e._mask && N) {
      var H = e._mask.isMaskData ? e._mask.maskObject : e._mask;
      H && !(!((D = H.containsPoint) === null || D === void 0) && D.call(H, L)) && (N = !1);
    }
    if (U && e.interactiveChildren && e.children)
      for (var z = e.children, X = z.length - 1; X >= 0; X--) {
        var Y = z[X], W = this.recursiveFindHit(t, Y, R, N, $);
        if (W) {
          if (!Y.parent)
            continue;
          $ = !1, W && (t.target && (N = !1), B = !0);
        }
      }
    return M && (N && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(L) && (B = !0), e.interactive && (B && !t.target && (t.target = e), R && R(t, e, !!B))), B;
  }, o.prototype.findHit = function(t, e, R, N) {
    this.recursiveFindHit(t, e, R, N, !1);
  }, o;
}(), interactiveTarget = {
  interactive: !1,
  interactiveChildren: !0,
  hitArea: null,
  get buttonMode() {
    return this.cursor === "pointer";
  },
  set buttonMode(o) {
    o ? this.cursor = "pointer" : this.cursor === "pointer" && (this.cursor = null);
  },
  cursor: null,
  get trackedPointers() {
    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;
  },
  _trackedPointers: void 0
};
DisplayObject.mixin(interactiveTarget);
var MOUSE_POINTER_ID = 1, hitTestEvent = {
  target: null,
  data: {
    global: null
  }
}, InteractionManager = function(o) {
  __extends$o(t, o);
  function t(e, R) {
    var N = o.call(this) || this;
    return R = R || {}, N.renderer = e, N.autoPreventDefault = R.autoPreventDefault !== void 0 ? R.autoPreventDefault : !0, N.interactionFrequency = R.interactionFrequency || 10, N.mouse = new InteractionData(), N.mouse.identifier = MOUSE_POINTER_ID, N.mouse.global.set(-999999), N.activeInteractionData = {}, N.activeInteractionData[MOUSE_POINTER_ID] = N.mouse, N.interactionDataPool = [], N.eventData = new InteractionEvent(), N.interactionDOMElement = null, N.moveWhenInside = !1, N.eventsAdded = !1, N.tickerAdded = !1, N.mouseOverRenderer = !("PointerEvent" in globalThis), N.supportsTouchEvents = "ontouchstart" in globalThis, N.supportsPointerEvents = !!globalThis.PointerEvent, N.onPointerUp = N.onPointerUp.bind(N), N.processPointerUp = N.processPointerUp.bind(N), N.onPointerCancel = N.onPointerCancel.bind(N), N.processPointerCancel = N.processPointerCancel.bind(N), N.onPointerDown = N.onPointerDown.bind(N), N.processPointerDown = N.processPointerDown.bind(N), N.onPointerMove = N.onPointerMove.bind(N), N.processPointerMove = N.processPointerMove.bind(N), N.onPointerOut = N.onPointerOut.bind(N), N.processPointerOverOut = N.processPointerOverOut.bind(N), N.onPointerOver = N.onPointerOver.bind(N), N.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    }, N.currentCursorMode = null, N.cursor = null, N.resolution = 1, N.delayedEvents = [], N.search = new TreeSearch(), N._tempDisplayObject = new TemporaryDisplayObject(), N._eventListenerOptions = { capture: !0, passive: !1 }, N._useSystemTicker = R.useSystemTicker !== void 0 ? R.useSystemTicker : !0, N.setTargetElement(N.renderer.view, N.renderer.resolution), N;
  }
  return Object.defineProperty(t.prototype, "useSystemTicker", {
    get: function() {
      return this._useSystemTicker;
    },
    set: function(e) {
      this._useSystemTicker = e, e ? this.addTickerListener() : this.removeTickerListener();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "lastObjectRendered", {
    get: function() {
      return this.renderer._lastObjectRendered || this._tempDisplayObject;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.hitTest = function(e, R) {
    return hitTestEvent.target = null, hitTestEvent.data.global = e, R || (R = this.lastObjectRendered), this.processInteractive(hitTestEvent, R, null, !0), hitTestEvent.target;
  }, t.prototype.setTargetElement = function(e, R) {
    R === void 0 && (R = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = e, this.resolution = R, this.addEvents(), this.addTickerListener();
  }, t.prototype.addTickerListener = function() {
    this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker || (Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION), this.tickerAdded = !0);
  }, t.prototype.removeTickerListener = function() {
    !this.tickerAdded || (Ticker.system.remove(this.tickerUpdate, this), this.tickerAdded = !1);
  }, t.prototype.addEvents = function() {
    if (!(this.eventsAdded || !this.interactionDOMElement)) {
      var e = this.interactionDOMElement.style;
      globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "none", e.msTouchAction = "none") : this.supportsPointerEvents && (e.touchAction = "none"), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0;
    }
  }, t.prototype.removeEvents = function() {
    if (!(!this.eventsAdded || !this.interactionDOMElement)) {
      var e = this.interactionDOMElement.style;
      globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "", e.msTouchAction = "") : this.supportsPointerEvents && (e.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1;
    }
  }, t.prototype.tickerUpdate = function(e) {
    this._deltaTime += e, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());
  }, t.prototype.update = function() {
    if (!!this.interactionDOMElement) {
      if (this._didMove) {
        this._didMove = !1;
        return;
      }
      this.cursor = null;
      for (var e in this.activeInteractionData)
        if (this.activeInteractionData.hasOwnProperty(e)) {
          var R = this.activeInteractionData[e];
          if (R.originalEvent && R.pointerType !== "touch") {
            var N = this.configureInteractionEventForDOMEvent(this.eventData, R.originalEvent, R);
            this.processInteractive(N, this.lastObjectRendered, this.processPointerOverOut, !0);
          }
        }
      this.setCursorMode(this.cursor);
    }
  }, t.prototype.setCursorMode = function(e) {
    e = e || "default";
    var R = !0;
    if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (R = !1), this.currentCursorMode !== e) {
      this.currentCursorMode = e;
      var N = this.cursorStyles[e];
      if (N)
        switch (typeof N) {
          case "string":
            R && (this.interactionDOMElement.style.cursor = N);
            break;
          case "function":
            N(e);
            break;
          case "object":
            R && Object.assign(this.interactionDOMElement.style, N);
            break;
        }
      else
        R && typeof e == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.interactionDOMElement.style.cursor = e);
    }
  }, t.prototype.dispatchEvent = function(e, R, N) {
    (!N.stopPropagationHint || e === N.stopsPropagatingAt) && (N.currentTarget = e, N.type = R, e.emit(R, N), e[R] && e[R](N));
  }, t.prototype.delayDispatchEvent = function(e, R, N) {
    this.delayedEvents.push({ displayObject: e, eventString: R, eventData: N });
  }, t.prototype.mapPositionToPoint = function(e, R, N) {
    var M;
    this.interactionDOMElement.parentElement ? M = this.interactionDOMElement.getBoundingClientRect() : M = {
      x: 0,
      y: 0,
      width: this.interactionDOMElement.width,
      height: this.interactionDOMElement.height,
      left: 0,
      top: 0
    };
    var D = 1 / this.resolution;
    e.x = (R - M.left) * (this.interactionDOMElement.width / M.width) * D, e.y = (N - M.top) * (this.interactionDOMElement.height / M.height) * D;
  }, t.prototype.processInteractive = function(e, R, N, M) {
    var D = this.search.findHit(e, R, N, M), L = this.delayedEvents;
    if (!L.length)
      return D;
    e.stopPropagationHint = !1;
    var B = L.length;
    this.delayedEvents = [];
    for (var $ = 0; $ < B; $++) {
      var U = L[$], H = U.displayObject, z = U.eventString, X = U.eventData;
      X.stopsPropagatingAt === H && (X.stopPropagationHint = !0), this.dispatchEvent(H, z, X);
    }
    return D;
  }, t.prototype.onPointerDown = function(e) {
    if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
      var R = this.normalizeToPointerData(e);
      if (this.autoPreventDefault && R[0].isNormalized) {
        var N = e.cancelable || !("cancelable" in e);
        N && e.preventDefault();
      }
      for (var M = R.length, D = 0; D < M; D++) {
        var L = R[D], B = this.getInteractionDataForPointerId(L), $ = this.configureInteractionEventForDOMEvent(this.eventData, L, B);
        if ($.data.originalEvent = e, this.processInteractive($, this.lastObjectRendered, this.processPointerDown, !0), this.emit("pointerdown", $), L.pointerType === "touch")
          this.emit("touchstart", $);
        else if (L.pointerType === "mouse" || L.pointerType === "pen") {
          var U = L.button === 2;
          this.emit(U ? "rightdown" : "mousedown", this.eventData);
        }
      }
    }
  }, t.prototype.processPointerDown = function(e, R, N) {
    var M = e.data, D = e.data.identifier;
    if (N) {
      if (R.trackedPointers[D] || (R.trackedPointers[D] = new InteractionTrackingData(D)), this.dispatchEvent(R, "pointerdown", e), M.pointerType === "touch")
        this.dispatchEvent(R, "touchstart", e);
      else if (M.pointerType === "mouse" || M.pointerType === "pen") {
        var L = M.button === 2;
        L ? R.trackedPointers[D].rightDown = !0 : R.trackedPointers[D].leftDown = !0, this.dispatchEvent(R, L ? "rightdown" : "mousedown", e);
      }
    }
  }, t.prototype.onPointerComplete = function(e, R, N) {
    var M = this.normalizeToPointerData(e), D = M.length, L = e.target;
    e.composedPath && e.composedPath().length > 0 && (L = e.composedPath()[0]);
    for (var B = L !== this.interactionDOMElement ? "outside" : "", $ = 0; $ < D; $++) {
      var U = M[$], H = this.getInteractionDataForPointerId(U), z = this.configureInteractionEventForDOMEvent(this.eventData, U, H);
      if (z.data.originalEvent = e, this.processInteractive(z, this.lastObjectRendered, N, R || !B), this.emit(R ? "pointercancel" : "pointerup" + B, z), U.pointerType === "mouse" || U.pointerType === "pen") {
        var X = U.button === 2;
        this.emit(X ? "rightup" + B : "mouseup" + B, z);
      } else
        U.pointerType === "touch" && (this.emit(R ? "touchcancel" : "touchend" + B, z), this.releaseInteractionDataForPointerId(U.pointerId));
    }
  }, t.prototype.onPointerCancel = function(e) {
    this.supportsTouchEvents && e.pointerType === "touch" || this.onPointerComplete(e, !0, this.processPointerCancel);
  }, t.prototype.processPointerCancel = function(e, R) {
    var N = e.data, M = e.data.identifier;
    R.trackedPointers[M] !== void 0 && (delete R.trackedPointers[M], this.dispatchEvent(R, "pointercancel", e), N.pointerType === "touch" && this.dispatchEvent(R, "touchcancel", e));
  }, t.prototype.onPointerUp = function(e) {
    this.supportsTouchEvents && e.pointerType === "touch" || this.onPointerComplete(e, !1, this.processPointerUp);
  }, t.prototype.processPointerUp = function(e, R, N) {
    var M = e.data, D = e.data.identifier, L = R.trackedPointers[D], B = M.pointerType === "touch", $ = M.pointerType === "mouse" || M.pointerType === "pen", U = !1;
    if ($) {
      var H = M.button === 2, z = InteractionTrackingData.FLAGS, X = H ? z.RIGHT_DOWN : z.LEFT_DOWN, Y = L !== void 0 && L.flags & X;
      N ? (this.dispatchEvent(R, H ? "rightup" : "mouseup", e), Y && (this.dispatchEvent(R, H ? "rightclick" : "click", e), U = !0)) : Y && this.dispatchEvent(R, H ? "rightupoutside" : "mouseupoutside", e), L && (H ? L.rightDown = !1 : L.leftDown = !1);
    }
    N ? (this.dispatchEvent(R, "pointerup", e), B && this.dispatchEvent(R, "touchend", e), L && ((!$ || U) && this.dispatchEvent(R, "pointertap", e), B && (this.dispatchEvent(R, "tap", e), L.over = !1))) : L && (this.dispatchEvent(R, "pointerupoutside", e), B && this.dispatchEvent(R, "touchendoutside", e)), L && L.none && delete R.trackedPointers[D];
  }, t.prototype.onPointerMove = function(e) {
    if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
      var R = this.normalizeToPointerData(e);
      (R[0].pointerType === "mouse" || R[0].pointerType === "pen") && (this._didMove = !0, this.cursor = null);
      for (var N = R.length, M = 0; M < N; M++) {
        var D = R[M], L = this.getInteractionDataForPointerId(D), B = this.configureInteractionEventForDOMEvent(this.eventData, D, L);
        B.data.originalEvent = e, this.processInteractive(B, this.lastObjectRendered, this.processPointerMove, !0), this.emit("pointermove", B), D.pointerType === "touch" && this.emit("touchmove", B), (D.pointerType === "mouse" || D.pointerType === "pen") && this.emit("mousemove", B);
      }
      R[0].pointerType === "mouse" && this.setCursorMode(this.cursor);
    }
  }, t.prototype.processPointerMove = function(e, R, N) {
    var M = e.data, D = M.pointerType === "touch", L = M.pointerType === "mouse" || M.pointerType === "pen";
    L && this.processPointerOverOut(e, R, N), (!this.moveWhenInside || N) && (this.dispatchEvent(R, "pointermove", e), D && this.dispatchEvent(R, "touchmove", e), L && this.dispatchEvent(R, "mousemove", e));
  }, t.prototype.onPointerOut = function(e) {
    if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
      var R = this.normalizeToPointerData(e), N = R[0];
      N.pointerType === "mouse" && (this.mouseOverRenderer = !1, this.setCursorMode(null));
      var M = this.getInteractionDataForPointerId(N), D = this.configureInteractionEventForDOMEvent(this.eventData, N, M);
      D.data.originalEvent = N, this.processInteractive(D, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit("pointerout", D), N.pointerType === "mouse" || N.pointerType === "pen" ? this.emit("mouseout", D) : this.releaseInteractionDataForPointerId(M.identifier);
    }
  }, t.prototype.processPointerOverOut = function(e, R, N) {
    var M = e.data, D = e.data.identifier, L = M.pointerType === "mouse" || M.pointerType === "pen", B = R.trackedPointers[D];
    N && !B && (B = R.trackedPointers[D] = new InteractionTrackingData(D)), B !== void 0 && (N && this.mouseOverRenderer ? (B.over || (B.over = !0, this.delayDispatchEvent(R, "pointerover", e), L && this.delayDispatchEvent(R, "mouseover", e)), L && this.cursor === null && (this.cursor = R.cursor)) : B.over && (B.over = !1, this.dispatchEvent(R, "pointerout", this.eventData), L && this.dispatchEvent(R, "mouseout", e), B.none && delete R.trackedPointers[D]));
  }, t.prototype.onPointerOver = function(e) {
    var R = this.normalizeToPointerData(e), N = R[0], M = this.getInteractionDataForPointerId(N), D = this.configureInteractionEventForDOMEvent(this.eventData, N, M);
    D.data.originalEvent = N, N.pointerType === "mouse" && (this.mouseOverRenderer = !0), this.emit("pointerover", D), (N.pointerType === "mouse" || N.pointerType === "pen") && this.emit("mouseover", D);
  }, t.prototype.getInteractionDataForPointerId = function(e) {
    var R = e.pointerId, N;
    return R === MOUSE_POINTER_ID || e.pointerType === "mouse" ? N = this.mouse : this.activeInteractionData[R] ? N = this.activeInteractionData[R] : (N = this.interactionDataPool.pop() || new InteractionData(), N.identifier = R, this.activeInteractionData[R] = N), N.copyEvent(e), N;
  }, t.prototype.releaseInteractionDataForPointerId = function(e) {
    var R = this.activeInteractionData[e];
    R && (delete this.activeInteractionData[e], R.reset(), this.interactionDataPool.push(R));
  }, t.prototype.configureInteractionEventForDOMEvent = function(e, R, N) {
    return e.data = N, this.mapPositionToPoint(N.global, R.clientX, R.clientY), R.pointerType === "touch" && (R.globalX = N.global.x, R.globalY = N.global.y), N.originalEvent = R, e.reset(), e;
  }, t.prototype.normalizeToPointerData = function(e) {
    var R = [];
    if (this.supportsTouchEvents && e instanceof TouchEvent)
      for (var N = 0, M = e.changedTouches.length; N < M; N++) {
        var D = e.changedTouches[N];
        typeof D.button > "u" && (D.button = e.touches.length ? 1 : 0), typeof D.buttons > "u" && (D.buttons = e.touches.length ? 1 : 0), typeof D.isPrimary > "u" && (D.isPrimary = e.touches.length === 1 && e.type === "touchstart"), typeof D.width > "u" && (D.width = D.radiusX || 1), typeof D.height > "u" && (D.height = D.radiusY || 1), typeof D.tiltX > "u" && (D.tiltX = 0), typeof D.tiltY > "u" && (D.tiltY = 0), typeof D.pointerType > "u" && (D.pointerType = "touch"), typeof D.pointerId > "u" && (D.pointerId = D.identifier || 0), typeof D.pressure > "u" && (D.pressure = D.force || 0.5), typeof D.twist > "u" && (D.twist = 0), typeof D.tangentialPressure > "u" && (D.tangentialPressure = 0), typeof D.layerX > "u" && (D.layerX = D.offsetX = D.clientX), typeof D.layerY > "u" && (D.layerY = D.offsetY = D.clientY), D.isNormalized = !0, R.push(D);
      }
    else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {
      var L = e;
      typeof L.isPrimary > "u" && (L.isPrimary = !0), typeof L.width > "u" && (L.width = 1), typeof L.height > "u" && (L.height = 1), typeof L.tiltX > "u" && (L.tiltX = 0), typeof L.tiltY > "u" && (L.tiltY = 0), typeof L.pointerType > "u" && (L.pointerType = "mouse"), typeof L.pointerId > "u" && (L.pointerId = MOUSE_POINTER_ID), typeof L.pressure > "u" && (L.pressure = 0.5), typeof L.twist > "u" && (L.twist = 0), typeof L.tangentialPressure > "u" && (L.tangentialPressure = 0), L.isNormalized = !0, R.push(L);
    } else
      R.push(e);
    return R;
  }, t.prototype.destroy = function() {
    this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;
  }, t.extension = {
    name: "interaction",
    type: [
      ExtensionType.RendererPlugin,
      ExtensionType.CanvasRendererPlugin
    ]
  }, t;
}(n);
/*!
 * @pixi/extract - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var TEMP_RECT = new Rectangle(), BYTES_PER_PIXEL = 4, Extract = function() {
  function o(t) {
    this.renderer = t;
  }
  return o.prototype.image = function(t, e, R) {
    var N = new Image();
    return N.src = this.base64(t, e, R), N;
  }, o.prototype.base64 = function(t, e, R) {
    return this.canvas(t).toDataURL(e, R);
  }, o.prototype.canvas = function(t, e) {
    var R = this.renderer, N, M = !1, D, L = !1;
    t && (t instanceof RenderTexture ? D = t : (D = this.renderer.generateTexture(t), L = !0)), D ? (N = D.baseTexture.resolution, e = e != null ? e : D.frame, M = !1, R.renderTexture.bind(D)) : (N = R.resolution, e || (e = TEMP_RECT, e.width = R.width, e.height = R.height), M = !0, R.renderTexture.bind(null));
    var B = Math.round(e.width * N), $ = Math.round(e.height * N), U = new CanvasRenderTarget(B, $, 1), H = new Uint8Array(BYTES_PER_PIXEL * B * $), z = R.gl;
    z.readPixels(Math.round(e.x * N), Math.round(e.y * N), B, $, z.RGBA, z.UNSIGNED_BYTE, H);
    var X = U.context.getImageData(0, 0, B, $);
    if (o.arrayPostDivide(H, X.data), U.context.putImageData(X, 0, 0), M) {
      var Y = new CanvasRenderTarget(U.width, U.height, 1);
      Y.context.scale(1, -1), Y.context.drawImage(U.canvas, 0, -$), U.destroy(), U = Y;
    }
    return L && D.destroy(!0), U.canvas;
  }, o.prototype.pixels = function(t, e) {
    var R = this.renderer, N, M, D = !1;
    t && (t instanceof RenderTexture ? M = t : (M = this.renderer.generateTexture(t), D = !0)), M ? (N = M.baseTexture.resolution, e = e != null ? e : M.frame, R.renderTexture.bind(M)) : (N = R.resolution, e || (e = TEMP_RECT, e.width = R.width, e.height = R.height), R.renderTexture.bind(null));
    var L = Math.round(e.width * N), B = Math.round(e.height * N), $ = new Uint8Array(BYTES_PER_PIXEL * L * B), U = R.gl;
    return U.readPixels(Math.round(e.x * N), Math.round(e.y * N), L, B, U.RGBA, U.UNSIGNED_BYTE, $), D && M.destroy(!0), o.arrayPostDivide($, $), $;
  }, o.prototype.destroy = function() {
    this.renderer = null;
  }, o.arrayPostDivide = function(t, e) {
    for (var R = 0; R < t.length; R += 4) {
      var N = e[R + 3] = t[R + 3];
      N !== 0 ? (e[R] = Math.round(Math.min(t[R] * 255 / N, 255)), e[R + 1] = Math.round(Math.min(t[R + 1] * 255 / N, 255)), e[R + 2] = Math.round(Math.min(t[R + 2] * 255 / N, 255))) : (e[R] = t[R], e[R + 1] = t[R + 1], e[R + 2] = t[R + 2]);
    }
  }, o.extension = {
    name: "extract",
    type: ExtensionType.RendererPlugin
  }, o;
}();
/*!
 * @pixi/loaders - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var SignalBinding = function() {
  function o(t, e, R) {
    e === void 0 && (e = !1), this._fn = t, this._once = e, this._thisArg = R, this._next = this._prev = this._owner = null;
  }
  return o.prototype.detach = function() {
    return this._owner === null ? !1 : (this._owner.detach(this), !0);
  }, o;
}();
function _addSignalBinding(o, t) {
  return o._head ? (o._tail._next = t, t._prev = o._tail, o._tail = t) : (o._head = t, o._tail = t), t._owner = o, t;
}
var Signal = function() {
  function o() {
    this._head = this._tail = void 0;
  }
  return o.prototype.handlers = function(t) {
    t === void 0 && (t = !1);
    var e = this._head;
    if (t)
      return !!e;
    for (var R = []; e; )
      R.push(e), e = e._next;
    return R;
  }, o.prototype.has = function(t) {
    if (!(t instanceof SignalBinding))
      throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
    return t._owner === this;
  }, o.prototype.dispatch = function() {
    for (var t = arguments, e = [], R = 0; R < arguments.length; R++)
      e[R] = t[R];
    var N = this._head;
    if (!N)
      return !1;
    for (; N; )
      N._once && this.detach(N), N._fn.apply(N._thisArg, e), N = N._next;
    return !0;
  }, o.prototype.add = function(t, e) {
    if (e === void 0 && (e = null), typeof t != "function")
      throw new Error("MiniSignal#add(): First arg must be a Function.");
    return _addSignalBinding(this, new SignalBinding(t, !1, e));
  }, o.prototype.once = function(t, e) {
    if (e === void 0 && (e = null), typeof t != "function")
      throw new Error("MiniSignal#once(): First arg must be a Function.");
    return _addSignalBinding(this, new SignalBinding(t, !0, e));
  }, o.prototype.detach = function(t) {
    if (!(t instanceof SignalBinding))
      throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
    return t._owner !== this ? this : (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, t._next === null && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null, this);
  }, o.prototype.detachAll = function() {
    var t = this._head;
    if (!t)
      return this;
    for (this._head = this._tail = null; t; )
      t._owner = null, t = t._next;
    return this;
  }, o;
}();
function parseUri(o, t) {
  t = t || {};
  for (var e = {
    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
    q: {
      name: "queryKey",
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  }, R = e.parser[t.strictMode ? "strict" : "loose"].exec(o), N = {}, M = 14; M--; )
    N[e.key[M]] = R[M] || "";
  return N[e.q.name] = {}, N[e.key[12]].replace(e.q.parser, function(D, L, B) {
    L && (N[e.q.name][L] = B);
  }), N;
}
var useXdr, tempAnchor = null, STATUS_NONE = 0, STATUS_OK = 200, STATUS_EMPTY = 204, STATUS_IE_BUG_EMPTY = 1223, STATUS_TYPE_OK = 2;
function _noop$1() {
}
function setExtMap(o, t, e) {
  t && t.indexOf(".") === 0 && (t = t.substring(1)), t && (o[t] = e);
}
function reqType(o) {
  return o.toString().replace("object ", "");
}
var LoaderResource = function() {
  function o(t, e, R) {
    if (this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof t != "string" || typeof e != "string")
      throw new Error("Both name and url are required for constructing a resource.");
    R = R || {}, this._flags = 0, this._setFlag(o.STATUS_FLAGS.DATA_URL, e.indexOf("data:") === 0), this.name = t, this.url = e, this.extension = this._getExtension(), this.data = null, this.crossOrigin = R.crossOrigin === !0 ? "anonymous" : R.crossOrigin, this.timeout = R.timeout || 0, this.loadType = R.loadType || this._determineLoadType(), this.xhrType = R.xhrType, this.metadata = R.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = o.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new Signal(), this.onProgress = new Signal(), this.onComplete = new Signal(), this.onAfterMiddleware = new Signal();
  }
  return o.setExtensionLoadType = function(t, e) {
    setExtMap(o._loadTypeMap, t, e);
  }, o.setExtensionXhrType = function(t, e) {
    setExtMap(o._xhrTypeMap, t, e);
  }, Object.defineProperty(o.prototype, "isDataUrl", {
    get: function() {
      return this._hasFlag(o.STATUS_FLAGS.DATA_URL);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "isComplete", {
    get: function() {
      return this._hasFlag(o.STATUS_FLAGS.COMPLETE);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "isLoading", {
    get: function() {
      return this._hasFlag(o.STATUS_FLAGS.LOADING);
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.complete = function() {
    this._clearEvents(), this._finish();
  }, o.prototype.abort = function(t) {
    if (!this.error) {
      if (this.error = new Error(t), this._clearEvents(), this.xhr)
        this.xhr.abort();
      else if (this.xdr)
        this.xdr.abort();
      else if (this.data)
        if (this.data.src)
          this.data.src = o.EMPTY_GIF;
        else
          for (; this.data.firstChild; )
            this.data.removeChild(this.data.firstChild);
      this._finish();
    }
  }, o.prototype.load = function(t) {
    var e = this;
    if (!this.isLoading) {
      if (this.isComplete) {
        t && setTimeout(function() {
          return t(e);
        }, 1);
        return;
      } else
        t && this.onComplete.once(t);
      switch (this._setFlag(o.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), (this.crossOrigin === !1 || typeof this.crossOrigin != "string") && (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
        case o.LOAD_TYPE.IMAGE:
          this.type = o.TYPE.IMAGE, this._loadElement("image");
          break;
        case o.LOAD_TYPE.AUDIO:
          this.type = o.TYPE.AUDIO, this._loadSourceElement("audio");
          break;
        case o.LOAD_TYPE.VIDEO:
          this.type = o.TYPE.VIDEO, this._loadSourceElement("video");
          break;
        case o.LOAD_TYPE.XHR:
        default:
          typeof useXdr > "u" && (useXdr = !!(globalThis.XDomainRequest && !("withCredentials" in new XMLHttpRequest()))), useXdr && this.crossOrigin ? this._loadXdr() : this._loadXhr();
          break;
      }
    }
  }, o.prototype._hasFlag = function(t) {
    return (this._flags & t) !== 0;
  }, o.prototype._setFlag = function(t, e) {
    this._flags = e ? this._flags | t : this._flags & ~t;
  }, o.prototype._clearEvents = function() {
    clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));
  }, o.prototype._finish = function() {
    if (this.isComplete)
      throw new Error("Complete called again for an already completed resource.");
    this._setFlag(o.STATUS_FLAGS.COMPLETE, !0), this._setFlag(o.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this);
  }, o.prototype._loadElement = function(t) {
    this.metadata.loadElement ? this.data = this.metadata.loadElement : t === "image" && typeof globalThis.Image < "u" ? this.data = new Image() : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
  }, o.prototype._loadSourceElement = function(t) {
    if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t === "audio" && typeof globalThis.Audio < "u" ? this.data = new Audio() : this.data = document.createElement(t), this.data === null) {
      this.abort("Unsupported element: " + t);
      return;
    }
    if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)
      if (navigator.isCocoonJS)
        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
      else if (Array.isArray(this.url))
        for (var e = this.metadata.mimeType, R = 0; R < this.url.length; ++R)
          this.data.appendChild(this._createSource(t, this.url[R], Array.isArray(e) ? e[R] : e));
      else {
        var e = this.metadata.mimeType;
        this.data.appendChild(this._createSource(t, this.url, Array.isArray(e) ? e[0] : e));
      }
    this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
  }, o.prototype._loadXhr = function() {
    typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
    var t = this.xhr = new XMLHttpRequest();
    this.crossOrigin === "use-credentials" && (t.withCredentials = !0), t.open("GET", this.url, !0), t.timeout = this.timeout, this.xhrType === o.XHR_RESPONSE_TYPE.JSON || this.xhrType === o.XHR_RESPONSE_TYPE.DOCUMENT ? t.responseType = o.XHR_RESPONSE_TYPE.TEXT : t.responseType = this.xhrType, t.addEventListener("error", this._boundXhrOnError, !1), t.addEventListener("timeout", this._boundXhrOnTimeout, !1), t.addEventListener("abort", this._boundXhrOnAbort, !1), t.addEventListener("progress", this._boundOnProgress, !1), t.addEventListener("load", this._boundXhrOnLoad, !1), t.send();
  }, o.prototype._loadXdr = function() {
    typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
    var t = this.xhr = new globalThis.XDomainRequest();
    t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open("GET", this.url, !0), setTimeout(function() {
      return t.send();
    }, 1);
  }, o.prototype._createSource = function(t, e, R) {
    R || (R = t + "/" + this._getExtension(e));
    var N = document.createElement("source");
    return N.src = e, N.type = R, N;
  }, o.prototype._onError = function(t) {
    this.abort("Failed to load element using: " + t.target.nodeName);
  }, o.prototype._onProgress = function(t) {
    t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total);
  }, o.prototype._onTimeout = function() {
    this.abort("Load timed out.");
  }, o.prototype._xhrOnError = function() {
    var t = this.xhr;
    this.abort(reqType(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"');
  }, o.prototype._xhrOnTimeout = function() {
    var t = this.xhr;
    this.abort(reqType(t) + " Request timed out.");
  }, o.prototype._xhrOnAbort = function() {
    var t = this.xhr;
    this.abort(reqType(t) + " Request was aborted by the user.");
  }, o.prototype._xhrOnLoad = function() {
    var t = this.xhr, e = "", R = typeof t.status > "u" ? STATUS_OK : t.status;
    (t.responseType === "" || t.responseType === "text" || typeof t.responseType > "u") && (e = t.responseText), R === STATUS_NONE && (e.length > 0 || t.responseType === o.XHR_RESPONSE_TYPE.BUFFER) ? R = STATUS_OK : R === STATUS_IE_BUG_EMPTY && (R = STATUS_EMPTY);
    var N = R / 100 | 0;
    if (N === STATUS_TYPE_OK)
      if (this.xhrType === o.XHR_RESPONSE_TYPE.TEXT)
        this.data = e, this.type = o.TYPE.TEXT;
      else if (this.xhrType === o.XHR_RESPONSE_TYPE.JSON)
        try {
          this.data = JSON.parse(e), this.type = o.TYPE.JSON;
        } catch (L) {
          this.abort("Error trying to parse loaded json: " + L);
          return;
        }
      else if (this.xhrType === o.XHR_RESPONSE_TYPE.DOCUMENT)
        try {
          if (globalThis.DOMParser) {
            var M = new DOMParser();
            this.data = M.parseFromString(e, "text/xml");
          } else {
            var D = document.createElement("div");
            D.innerHTML = e, this.data = D;
          }
          this.type = o.TYPE.XML;
        } catch (L) {
          this.abort("Error trying to parse loaded xml: " + L);
          return;
        }
      else
        this.data = t.response || e;
    else {
      this.abort("[" + t.status + "] " + t.statusText + ": " + t.responseURL);
      return;
    }
    this.complete();
  }, o.prototype._determineCrossOrigin = function(t, e) {
    if (t.indexOf("data:") === 0)
      return "";
    if (globalThis.origin !== globalThis.location.origin)
      return "anonymous";
    e = e || globalThis.location, tempAnchor || (tempAnchor = document.createElement("a")), tempAnchor.href = t;
    var R = parseUri(tempAnchor.href, { strictMode: !0 }), N = !R.port && e.port === "" || R.port === e.port, M = R.protocol ? R.protocol + ":" : "";
    return R.host !== e.hostname || !N || M !== e.protocol ? "anonymous" : "";
  }, o.prototype._determineXhrType = function() {
    return o._xhrTypeMap[this.extension] || o.XHR_RESPONSE_TYPE.TEXT;
  }, o.prototype._determineLoadType = function() {
    return o._loadTypeMap[this.extension] || o.LOAD_TYPE.XHR;
  }, o.prototype._getExtension = function(t) {
    t === void 0 && (t = this.url);
    var e = "";
    if (this.isDataUrl) {
      var R = t.indexOf("/");
      e = t.substring(R + 1, t.indexOf(";", R));
    } else {
      var N = t.indexOf("?"), M = t.indexOf("#"), D = Math.min(N > -1 ? N : t.length, M > -1 ? M : t.length);
      t = t.substring(0, D), e = t.substring(t.lastIndexOf(".") + 1);
    }
    return e.toLowerCase();
  }, o.prototype._getMimeFromXhrType = function(t) {
    switch (t) {
      case o.XHR_RESPONSE_TYPE.BUFFER:
        return "application/octet-binary";
      case o.XHR_RESPONSE_TYPE.BLOB:
        return "application/blob";
      case o.XHR_RESPONSE_TYPE.DOCUMENT:
        return "application/xml";
      case o.XHR_RESPONSE_TYPE.JSON:
        return "application/json";
      case o.XHR_RESPONSE_TYPE.DEFAULT:
      case o.XHR_RESPONSE_TYPE.TEXT:
      default:
        return "text/plain";
    }
  }, o;
}();
(function(o) {
  (function(t) {
    t[t.NONE = 0] = "NONE", t[t.DATA_URL = 1] = "DATA_URL", t[t.COMPLETE = 2] = "COMPLETE", t[t.LOADING = 4] = "LOADING";
  })(o.STATUS_FLAGS || (o.STATUS_FLAGS = {})), function(t) {
    t[t.UNKNOWN = 0] = "UNKNOWN", t[t.JSON = 1] = "JSON", t[t.XML = 2] = "XML", t[t.IMAGE = 3] = "IMAGE", t[t.AUDIO = 4] = "AUDIO", t[t.VIDEO = 5] = "VIDEO", t[t.TEXT = 6] = "TEXT";
  }(o.TYPE || (o.TYPE = {})), function(t) {
    t[t.XHR = 1] = "XHR", t[t.IMAGE = 2] = "IMAGE", t[t.AUDIO = 3] = "AUDIO", t[t.VIDEO = 4] = "VIDEO";
  }(o.LOAD_TYPE || (o.LOAD_TYPE = {})), function(t) {
    t.DEFAULT = "text", t.BUFFER = "arraybuffer", t.BLOB = "blob", t.DOCUMENT = "document", t.JSON = "json", t.TEXT = "text";
  }(o.XHR_RESPONSE_TYPE || (o.XHR_RESPONSE_TYPE = {})), o._loadTypeMap = {
    gif: o.LOAD_TYPE.IMAGE,
    png: o.LOAD_TYPE.IMAGE,
    bmp: o.LOAD_TYPE.IMAGE,
    jpg: o.LOAD_TYPE.IMAGE,
    jpeg: o.LOAD_TYPE.IMAGE,
    tif: o.LOAD_TYPE.IMAGE,
    tiff: o.LOAD_TYPE.IMAGE,
    webp: o.LOAD_TYPE.IMAGE,
    tga: o.LOAD_TYPE.IMAGE,
    svg: o.LOAD_TYPE.IMAGE,
    "svg+xml": o.LOAD_TYPE.IMAGE,
    mp3: o.LOAD_TYPE.AUDIO,
    ogg: o.LOAD_TYPE.AUDIO,
    wav: o.LOAD_TYPE.AUDIO,
    mp4: o.LOAD_TYPE.VIDEO,
    webm: o.LOAD_TYPE.VIDEO
  }, o._xhrTypeMap = {
    xhtml: o.XHR_RESPONSE_TYPE.DOCUMENT,
    html: o.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: o.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: o.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: o.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: o.XHR_RESPONSE_TYPE.DOCUMENT,
    tsx: o.XHR_RESPONSE_TYPE.DOCUMENT,
    gif: o.XHR_RESPONSE_TYPE.BLOB,
    png: o.XHR_RESPONSE_TYPE.BLOB,
    bmp: o.XHR_RESPONSE_TYPE.BLOB,
    jpg: o.XHR_RESPONSE_TYPE.BLOB,
    jpeg: o.XHR_RESPONSE_TYPE.BLOB,
    tif: o.XHR_RESPONSE_TYPE.BLOB,
    tiff: o.XHR_RESPONSE_TYPE.BLOB,
    webp: o.XHR_RESPONSE_TYPE.BLOB,
    tga: o.XHR_RESPONSE_TYPE.BLOB,
    json: o.XHR_RESPONSE_TYPE.JSON,
    text: o.XHR_RESPONSE_TYPE.TEXT,
    txt: o.XHR_RESPONSE_TYPE.TEXT,
    ttf: o.XHR_RESPONSE_TYPE.BUFFER,
    otf: o.XHR_RESPONSE_TYPE.BUFFER
  }, o.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
})(LoaderResource || (LoaderResource = {}));
function _noop() {
}
function onlyOnce(o) {
  return function() {
    for (var e = arguments, R = [], N = 0; N < arguments.length; N++)
      R[N] = e[N];
    if (o === null)
      throw new Error("Callback was already called.");
    var M = o;
    o = null, M.apply(this, R);
  };
}
var AsyncQueueItem = function() {
  function o(t, e) {
    this.data = t, this.callback = e;
  }
  return o;
}(), AsyncQueue = function() {
  function o(t, e) {
    var R = this;
    if (e === void 0 && (e = 1), this.workers = 0, this.saturated = _noop, this.unsaturated = _noop, this.empty = _noop, this.drain = _noop, this.error = _noop, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function(N, M, D) {
      if (D && typeof D != "function")
        throw new Error("task callback must be a function");
      if (R.started = !0, N == null && R.idle()) {
        setTimeout(function() {
          return R.drain();
        }, 1);
        return;
      }
      var L = new AsyncQueueItem(N, typeof D == "function" ? D : _noop);
      M ? R._tasks.unshift(L) : R._tasks.push(L), setTimeout(R.process, 1);
    }, this.process = function() {
      for (; !R.paused && R.workers < R.concurrency && R._tasks.length; ) {
        var N = R._tasks.shift();
        R._tasks.length === 0 && R.empty(), R.workers += 1, R.workers === R.concurrency && R.saturated(), R._worker(N.data, onlyOnce(R._next(N)));
      }
    }, this._worker = t, e === 0)
      throw new Error("Concurrency must not be zero");
    this.concurrency = e, this.buffer = e / 4;
  }
  return o.prototype._next = function(t) {
    var e = this;
    return function() {
      for (var R = arguments, N = [], M = 0; M < arguments.length; M++)
        N[M] = R[M];
      e.workers -= 1, t.callback.apply(t, N), N[0] != null && e.error(N[0], t.data), e.workers <= e.concurrency - e.buffer && e.unsaturated(), e.idle() && e.drain(), e.process();
    };
  }, o.prototype.push = function(t, e) {
    this._insert(t, !1, e);
  }, o.prototype.kill = function() {
    this.workers = 0, this.drain = _noop, this.started = !1, this._tasks = [];
  }, o.prototype.unshift = function(t, e) {
    this._insert(t, !0, e);
  }, o.prototype.length = function() {
    return this._tasks.length;
  }, o.prototype.running = function() {
    return this.workers;
  }, o.prototype.idle = function() {
    return this._tasks.length + this.workers === 0;
  }, o.prototype.pause = function() {
    this.paused !== !0 && (this.paused = !0);
  }, o.prototype.resume = function() {
    if (this.paused !== !1) {
      this.paused = !1;
      for (var t = 1; t <= this.concurrency; t++)
        this.process();
    }
  }, o.eachSeries = function(t, e, R, N) {
    var M = 0, D = t.length;
    function L(B) {
      if (B || M === D) {
        R && R(B);
        return;
      }
      N ? setTimeout(function() {
        e(t[M++], L);
      }, 1) : e(t[M++], L);
    }
    L();
  }, o.queue = function(t, e) {
    return new o(t, e);
  }, o;
}(), MAX_PROGRESS = 100, rgxExtractUrlHash = /(#[\w-]+)?$/, Loader = function() {
  function o(t, e) {
    var R = this;
    t === void 0 && (t = ""), e === void 0 && (e = 10), this.progress = 0, this.loading = !1, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(B, $) {
      return R._loadResource(B, $);
    }, this.resources = {}, this.baseUrl = t, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(B, $) {
      return R._loadResource(B, $);
    }, this._queue = AsyncQueue.queue(this._boundLoadResource, e), this._queue.pause(), this.resources = {}, this.onProgress = new Signal(), this.onError = new Signal(), this.onLoad = new Signal(), this.onStart = new Signal(), this.onComplete = new Signal();
    for (var N = 0; N < o._plugins.length; ++N) {
      var M = o._plugins[N], D = M.pre, L = M.use;
      D && this.pre(D), L && this.use(L);
    }
    this._protected = !1;
  }
  return o.prototype._add = function(t, e, R, N) {
    if (this.loading && (!R || !R.parentResource))
      throw new Error("Cannot add resources while the loader is running.");
    if (this.resources[t])
      throw new Error('Resource named "' + t + '" already exists.');
    if (e = this._prepareUrl(e), this.resources[t] = new LoaderResource(t, e, R), typeof N == "function" && this.resources[t].onAfterMiddleware.once(N), this.loading) {
      for (var M = R.parentResource, D = [], L = 0; L < M.children.length; ++L)
        M.children[L].isComplete || D.push(M.children[L]);
      var B = M.progressChunk * (D.length + 1), $ = B / (D.length + 2);
      M.children.push(this.resources[t]), M.progressChunk = $;
      for (var L = 0; L < D.length; ++L)
        D[L].progressChunk = $;
      this.resources[t].progressChunk = $;
    }
    return this._queue.push(this.resources[t]), this;
  }, o.prototype.pre = function(t) {
    return this._beforeMiddleware.push(t), this;
  }, o.prototype.use = function(t) {
    return this._afterMiddleware.push(t), this;
  }, o.prototype.reset = function() {
    this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause();
    for (var t in this.resources) {
      var e = this.resources[t];
      e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort("loader reset");
    }
    return this.resources = {}, this;
  }, o.prototype.load = function(t) {
    if (deprecation$1("6.5.0", "@pixi/loaders is being replaced with @pixi/assets in the next major release."), typeof t == "function" && this.onComplete.once(t), this.loading)
      return this;
    if (this._queue.idle())
      this._onStart(), this._onComplete();
    else {
      for (var e = this._queue._tasks.length, R = MAX_PROGRESS / e, N = 0; N < this._queue._tasks.length; ++N)
        this._queue._tasks[N].data.progressChunk = R;
      this._onStart(), this._queue.resume();
    }
    return this;
  }, Object.defineProperty(o.prototype, "concurrency", {
    get: function() {
      return this._queue.concurrency;
    },
    set: function(t) {
      this._queue.concurrency = t;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype._prepareUrl = function(t) {
    var e = parseUri(t, { strictMode: !0 }), R;
    if (e.protocol || !e.path || t.indexOf("//") === 0 ? R = t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && t.charAt(0) !== "/" ? R = this.baseUrl + "/" + t : R = this.baseUrl + t, this.defaultQueryString) {
      var N = rgxExtractUrlHash.exec(R)[0];
      R = R.slice(0, R.length - N.length), R.indexOf("?") !== -1 ? R += "&" + this.defaultQueryString : R += "?" + this.defaultQueryString, R += N;
    }
    return R;
  }, o.prototype._loadResource = function(t, e) {
    var R = this;
    t._dequeue = e, AsyncQueue.eachSeries(this._beforeMiddleware, function(N, M) {
      N.call(R, t, function() {
        M(t.isComplete ? {} : null);
      });
    }, function() {
      t.isComplete ? R._onLoad(t) : (t._onLoadBinding = t.onComplete.once(R._onLoad, R), t.load());
    }, !0);
  }, o.prototype._onStart = function() {
    this.progress = 0, this.loading = !0, this.onStart.dispatch(this);
  }, o.prototype._onComplete = function() {
    this.progress = MAX_PROGRESS, this.loading = !1, this.onComplete.dispatch(this, this.resources);
  }, o.prototype._onLoad = function(t) {
    var e = this;
    t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), AsyncQueue.eachSeries(this._afterMiddleware, function(R, N) {
      R.call(e, t, N);
    }, function() {
      t.onAfterMiddleware.dispatch(t), e.progress = Math.min(MAX_PROGRESS, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && e._resourcesParsing.length === 0 && e._onComplete();
    }, !0);
  }, o.prototype.destroy = function() {
    this._protected || this.reset();
  }, Object.defineProperty(o, "shared", {
    get: function() {
      var t = o._shared;
      return t || (t = new o(), t._protected = !0, o._shared = t), t;
    },
    enumerable: !1,
    configurable: !0
  }), o.registerPlugin = function(t) {
    return deprecation$1("6.5.0", "Loader.registerPlugin() is deprecated, use extensions.add() instead."), extensions.add({
      type: ExtensionType.Loader,
      ref: t
    }), o;
  }, o._plugins = [], o;
}();
extensions.handleByList(ExtensionType.Loader, Loader._plugins);
Loader.prototype.add = function(t, e, R, N) {
  if (Array.isArray(t)) {
    for (var M = 0; M < t.length; ++M)
      this.add(t[M]);
    return this;
  }
  if (typeof t == "object" && (R = t, N = e || R.callback || R.onComplete, e = R.url, t = R.name || R.key || R.url), typeof e != "string" && (N = R, R = e, e = t), typeof e != "string")
    throw new Error("No url passed to add resource to loader.");
  return typeof R == "function" && (N = R, R = null), this._add(t, e, R, N);
};
var AppLoaderPlugin = function() {
  function o() {
  }
  return o.init = function(t) {
    t = Object.assign({
      sharedLoader: !1
    }, t), this.loader = t.sharedLoader ? Loader.shared : new Loader();
  }, o.destroy = function() {
    this.loader && (this.loader.destroy(), this.loader = null);
  }, o.extension = ExtensionType.Application, o;
}(), TextureLoader = function() {
  function o() {
  }
  return o.add = function() {
    LoaderResource.setExtensionLoadType("svg", LoaderResource.LOAD_TYPE.XHR), LoaderResource.setExtensionXhrType("svg", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
  }, o.use = function(t, e) {
    if (t.data && (t.type === LoaderResource.TYPE.IMAGE || t.extension === "svg")) {
      var R = t.data, N = t.url, M = t.name, D = t.metadata;
      Texture.fromLoader(R, N, M, D).then(function(L) {
        t.texture = L, e();
      }).catch(e);
    } else
      e();
  }, o.extension = ExtensionType.Loader, o;
}(), _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encodeBinary(o) {
  for (var t = "", e = 0; e < o.length; ) {
    for (var R = [0, 0, 0], N = [0, 0, 0, 0], M = 0; M < R.length; ++M)
      e < o.length ? R[M] = o.charCodeAt(e++) & 255 : R[M] = 0;
    N[0] = R[0] >> 2, N[1] = (R[0] & 3) << 4 | R[1] >> 4, N[2] = (R[1] & 15) << 2 | R[2] >> 6, N[3] = R[2] & 63;
    var D = e - (o.length - 1);
    switch (D) {
      case 2:
        N[3] = 64, N[2] = 64;
        break;
      case 1:
        N[3] = 64;
        break;
    }
    for (var M = 0; M < N.length; ++M)
      t += _keyStr.charAt(N[M]);
  }
  return t;
}
function parsing(o, t) {
  if (!o.data) {
    t();
    return;
  }
  if (o.xhr && o.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {
    if (!self.Blob || typeof o.data == "string") {
      var e = o.xhr.getResponseHeader("content-type");
      if (e && e.indexOf("image") === 0) {
        o.data = new Image(), o.data.src = "data:" + e + ";base64," + encodeBinary(o.xhr.responseText), o.type = LoaderResource.TYPE.IMAGE, o.data.onload = function() {
          o.data.onload = null, t();
        };
        return;
      }
    } else if (o.data.type.indexOf("image") === 0) {
      var R = globalThis.URL || globalThis.webkitURL, N = R.createObjectURL(o.data);
      o.blob = o.data, o.data = new Image(), o.data.src = N, o.type = LoaderResource.TYPE.IMAGE, o.data.onload = function() {
        R.revokeObjectURL(N), o.data.onload = null, t();
      };
      return;
    }
  }
  t();
}
var ParsingLoader = function() {
  function o() {
  }
  return o.extension = ExtensionType.Loader, o.use = parsing, o;
}();
extensions.add(TextureLoader, ParsingLoader);
/*!
 * @pixi/compressed-textures - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/compressed-textures is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var _a$2, INTERNAL_FORMATS;
(function(o) {
  o[o.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", o[o.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", o[o.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", o[o.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", o[o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", o[o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", o[o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", o[o.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", o[o.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", o[o.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", o[o.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", o[o.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", o[o.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", o[o.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", o[o.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", o[o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", o[o.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", o[o.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", o[o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", o[o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", o[o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", o[o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", o[o.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", o[o.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", o[o.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", o[o.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
})(INTERNAL_FORMATS || (INTERNAL_FORMATS = {}));
var INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = (_a$2 = {}, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, _a$2);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$n = function(o, t) {
  return extendStatics$n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$n(o, t);
};
function __extends$n(o, t) {
  extendStatics$n(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function __awaiter(o, t, e, R) {
  function N(M) {
    return M instanceof e ? M : new e(function(D) {
      D(M);
    });
  }
  return new (e || (e = Promise))(function(M, D) {
    function L(U) {
      try {
        $(R.next(U));
      } catch (H) {
        D(H);
      }
    }
    function B(U) {
      try {
        $(R.throw(U));
      } catch (H) {
        D(H);
      }
    }
    function $(U) {
      U.done ? M(U.value) : N(U.value).then(L, B);
    }
    $((R = R.apply(o, t || [])).next());
  });
}
function __generator(o, t) {
  var e = { label: 0, sent: function() {
    if (M[0] & 1)
      throw M[1];
    return M[1];
  }, trys: [], ops: [] }, R, N, M, D;
  return D = { next: L(0), throw: L(1), return: L(2) }, typeof Symbol == "function" && (D[Symbol.iterator] = function() {
    return this;
  }), D;
  function L($) {
    return function(U) {
      return B([$, U]);
    };
  }
  function B($) {
    if (R)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (R = 1, N && (M = $[0] & 2 ? N.return : $[0] ? N.throw || ((M = N.return) && M.call(N), 0) : N.next) && !(M = M.call(N, $[1])).done)
          return M;
        switch (N = 0, M && ($ = [$[0] & 2, M.value]), $[0]) {
          case 0:
          case 1:
            M = $;
            break;
          case 4:
            return e.label++, { value: $[1], done: !1 };
          case 5:
            e.label++, N = $[1], $ = [0];
            continue;
          case 7:
            $ = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (M = e.trys, !(M = M.length > 0 && M[M.length - 1]) && ($[0] === 6 || $[0] === 2)) {
              e = 0;
              continue;
            }
            if ($[0] === 3 && (!M || $[1] > M[0] && $[1] < M[3])) {
              e.label = $[1];
              break;
            }
            if ($[0] === 6 && e.label < M[1]) {
              e.label = M[1], M = $;
              break;
            }
            if (M && e.label < M[2]) {
              e.label = M[2], e.ops.push($);
              break;
            }
            M[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        $ = t.call(o, e);
      } catch (U) {
        $ = [6, U], N = 0;
      } finally {
        R = M = 0;
      }
    if ($[0] & 5)
      throw $[1];
    return { value: $[0] ? $[1] : void 0, done: !0 };
  }
}
var BlobResource = function(o) {
  __extends$n(t, o);
  function t(e, R) {
    R === void 0 && (R = { width: 1, height: 1, autoLoad: !0 });
    var N = this, M, D;
    return typeof e == "string" ? (M = e, D = new Uint8Array()) : (M = null, D = e), N = o.call(this, D, R) || this, N.origin = M, N.buffer = D ? new ViewableBuffer(D) : null, N.origin && R.autoLoad !== !1 && N.load(), D && D.length && (N.loaded = !0, N.onBlobLoaded(N.buffer.rawBinaryData)), N;
  }
  return t.prototype.onBlobLoaded = function(e) {
  }, t.prototype.load = function() {
    return __awaiter(this, void 0, Promise, function() {
      var e, R, N;
      return __generator(this, function(M) {
        switch (M.label) {
          case 0:
            return [4, fetch(this.origin)];
          case 1:
            return e = M.sent(), [4, e.blob()];
          case 2:
            return R = M.sent(), [4, R.arrayBuffer()];
          case 3:
            return N = M.sent(), this.data = new Uint32Array(N), this.buffer = new ViewableBuffer(N), this.loaded = !0, this.onBlobLoaded(N), this.update(), [2, this];
        }
      });
    });
  }, t;
}(BufferResource), CompressedTextureResource = function(o) {
  __extends$n(t, o);
  function t(e, R) {
    var N = o.call(this, e, R) || this;
    return N.format = R.format, N.levels = R.levels || 1, N._width = R.width, N._height = R.height, N._extension = t._formatToExtension(N.format), (R.levelBuffers || N.buffer) && (N._levelBuffers = R.levelBuffers || t._createLevelBuffers(
      e instanceof Uint8Array ? e : N.buffer.uint8View,
      N.format,
      N.levels,
      4,
      4,
      N.width,
      N.height
    )), N;
  }
  return t.prototype.upload = function(e, R, N) {
    var M = e.gl, D = e.context.extensions[this._extension];
    if (!D)
      throw new Error(this._extension + " textures are not supported on the current machine");
    if (!this._levelBuffers)
      return !1;
    for (var L = 0, B = this.levels; L < B; L++) {
      var $ = this._levelBuffers[L], U = $.levelID, H = $.levelWidth, z = $.levelHeight, X = $.levelBuffer;
      M.compressedTexImage2D(M.TEXTURE_2D, U, this.format, H, z, 0, X);
    }
    return !0;
  }, t.prototype.onBlobLoaded = function() {
    this._levelBuffers = t._createLevelBuffers(
      this.buffer.uint8View,
      this.format,
      this.levels,
      4,
      4,
      this.width,
      this.height
    );
  }, t._formatToExtension = function(e) {
    if (e >= 33776 && e <= 33779)
      return "s3tc";
    if (e >= 37488 && e <= 37497)
      return "etc";
    if (e >= 35840 && e <= 35843)
      return "pvrtc";
    if (e >= 36196)
      return "etc1";
    if (e >= 35986 && e <= 34798)
      return "atc";
    throw new Error("Invalid (compressed) texture format given!");
  }, t._createLevelBuffers = function(e, R, N, M, D, L, B) {
    for (var $ = new Array(N), U = e.byteOffset, H = L, z = B, X = H + M - 1 & ~(M - 1), Y = z + D - 1 & ~(D - 1), W = X * Y * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[R], q = 0; q < N; q++)
      $[q] = {
        levelID: q,
        levelWidth: N > 1 ? H : X,
        levelHeight: N > 1 ? z : Y,
        levelBuffer: new Uint8Array(e.buffer, U, W)
      }, U += W, H = H >> 1 || 1, z = z >> 1 || 1, X = H + M - 1 & ~(M - 1), Y = z + D - 1 & ~(D - 1), W = X * Y * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[R];
    return $;
  }, t;
}(BlobResource), CompressedTextureLoader = function() {
  function o() {
  }
  return o.use = function(t, e) {
    var R = t.data, N = this;
    if (t.type === LoaderResource.TYPE.JSON && R && R.cacheID && R.textures) {
      for (var M = R.textures, D = void 0, L = void 0, B = 0, $ = M.length; B < $; B++) {
        var U = M[B], H = U.src, z = U.format;
        if (z || (L = H), o.textureFormats[z]) {
          D = H;
          break;
        }
      }
      if (D = D || L, !D) {
        e(new Error("Cannot load compressed-textures in " + t.url + ", make sure you provide a fallback"));
        return;
      }
      if (D === t.url) {
        e(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
        return;
      }
      var X = {
        crossOrigin: t.crossOrigin,
        metadata: t.metadata.imageMetadata,
        parentResource: t
      }, Y = url$1.resolve(t.url.replace(N.baseUrl, ""), D), W = R.cacheID;
      N.add(W, Y, X, function(q) {
        if (q.error) {
          e(q.error);
          return;
        }
        var Z = q.texture, K = Z === void 0 ? null : Z, J = q.textures, Q = J === void 0 ? {} : J;
        Object.assign(t, { texture: K, textures: Q }), e();
      });
    } else
      e();
  }, Object.defineProperty(o, "textureExtensions", {
    get: function() {
      if (!o._textureExtensions) {
        var t = settings$1.ADAPTER.createCanvas(), e = t.getContext("webgl");
        if (!e)
          return console.warn("WebGL not available for compressed textures. Silently failing."), {};
        var R = {
          s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          etc: e.getExtension("WEBGL_compressed_texture_etc"),
          etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: e.getExtension("WEBGL_compressed_texture_atc"),
          astc: e.getExtension("WEBGL_compressed_texture_astc")
        };
        o._textureExtensions = R;
      }
      return o._textureExtensions;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "textureFormats", {
    get: function() {
      if (!o._textureFormats) {
        var t = o.textureExtensions;
        o._textureFormats = {};
        for (var e in t) {
          var R = t[e];
          !R || Object.assign(o._textureFormats, Object.getPrototypeOf(R));
        }
      }
      return o._textureFormats;
    },
    enumerable: !1,
    configurable: !0
  }), o.extension = ExtensionType.Loader, o;
}();
function registerCompressedTextures(o, t, e) {
  var R = {
    textures: {},
    texture: null
  };
  if (!t)
    return R;
  var N = t.map(function(M) {
    return new Texture(new BaseTexture(M, Object.assign({
      mipmap: MIPMAP_MODES$5.OFF,
      alphaMode: ALPHA_MODES$5.NO_PREMULTIPLIED_ALPHA
    }, e)));
  });
  return N.forEach(function(M, D) {
    var L = M.baseTexture, B = o + "-" + (D + 1);
    BaseTexture.addToCache(L, B), Texture.addToCache(M, B), D === 0 && (BaseTexture.addToCache(L, o), Texture.addToCache(M, o), R.texture = M), R.textures[B] = M;
  }), R;
}
var _a$1, _b$1, DDS_MAGIC_SIZE = 4, DDS_HEADER_SIZE = 124, DDS_HEADER_PF_SIZE = 32, DDS_HEADER_DX10_SIZE = 20, DDS_MAGIC = 542327876, DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
}, DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
}, DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
}, DXGI_FORMAT;
(function(o) {
  o[o.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", o[o.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", o[o.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", o[o.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", o[o.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", o[o.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", o[o.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", o[o.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", o[o.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", o[o.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", o[o.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", o[o.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", o[o.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", o[o.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", o[o.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", o[o.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", o[o.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", o[o.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", o[o.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", o[o.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", o[o.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", o[o.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", o[o.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", o[o.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", o[o.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", o[o.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", o[o.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", o[o.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", o[o.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", o[o.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", o[o.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", o[o.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", o[o.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", o[o.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", o[o.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", o[o.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", o[o.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", o[o.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", o[o.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", o[o.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", o[o.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", o[o.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", o[o.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", o[o.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", o[o.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", o[o.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", o[o.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", o[o.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", o[o.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", o[o.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", o[o.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", o[o.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", o[o.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", o[o.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", o[o.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", o[o.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", o[o.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", o[o.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", o[o.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", o[o.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", o[o.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", o[o.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", o[o.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", o[o.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", o[o.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", o[o.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", o[o.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", o[o.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", o[o.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", o[o.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", o[o.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", o[o.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", o[o.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", o[o.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", o[o.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", o[o.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", o[o.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", o[o.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", o[o.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", o[o.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", o[o.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", o[o.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", o[o.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", o[o.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", o[o.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", o[o.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", o[o.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", o[o.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", o[o.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", o[o.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", o[o.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", o[o.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", o[o.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", o[o.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", o[o.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", o[o.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", o[o.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", o[o.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", o[o.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", o[o.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", o[o.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV", o[o.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410", o[o.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416", o[o.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12", o[o.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010", o[o.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016", o[o.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE", o[o.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2", o[o.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210", o[o.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216", o[o.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11", o[o.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44", o[o.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44", o[o.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8", o[o.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8", o[o.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", o[o.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208", o[o.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208", o[o.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408", o[o.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", o[o.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", o[o.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT";
})(DXGI_FORMAT || (DXGI_FORMAT = {}));
var D3D10_RESOURCE_DIMENSION;
(function(o) {
  o[o.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", o[o.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", o[o.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D";
})(D3D10_RESOURCE_DIMENSION || (D3D10_RESOURCE_DIMENSION = {}));
var PF_FLAGS = 1, DDPF_ALPHA = 2, DDPF_FOURCC = 4, DDPF_RGB = 64, DDPF_YUV = 512, DDPF_LUMINANCE = 131072, FOURCC_DXT1 = 827611204, FOURCC_DXT3 = 861165636, FOURCC_DXT5 = 894720068, FOURCC_DX10 = 808540228, DDS_RESOURCE_MISC_TEXTURECUBE = 4, FOURCC_TO_FORMAT = (_a$1 = {}, _a$1[FOURCC_DXT1] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _a$1[FOURCC_DXT3] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _a$1[FOURCC_DXT5] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _a$1), DXGI_TO_FORMAT = (_b$1 = {}, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _b$1);
function parseDDS(o) {
  var t = new Uint32Array(o), e = t[0];
  if (e !== DDS_MAGIC)
    throw new Error("Invalid DDS file magic word");
  var R = new Uint32Array(o, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT), N = R[DDS_FIELDS.HEIGHT], M = R[DDS_FIELDS.WIDTH], D = R[DDS_FIELDS.MIPMAP_COUNT], L = new Uint32Array(o, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT), B = L[PF_FLAGS];
  if (B & DDPF_FOURCC) {
    var $ = L[DDS_PF_FIELDS.FOURCC];
    if ($ !== FOURCC_DX10) {
      var U = FOURCC_TO_FORMAT[$], H = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, z = new Uint8Array(o, H), X = new CompressedTextureResource(z, {
        format: U,
        width: M,
        height: N,
        levels: D
      });
      return [X];
    }
    var Y = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, W = new Uint32Array(t.buffer, Y, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT), q = W[DDS_DX10_FIELDS.DXGI_FORMAT], Z = W[DDS_DX10_FIELDS.RESOURCE_DIMENSION], K = W[DDS_DX10_FIELDS.MISC_FLAG], J = W[DDS_DX10_FIELDS.ARRAY_SIZE], Q = DXGI_TO_FORMAT[q];
    if (Q === void 0)
      throw new Error("DDSParser cannot parse texture data with DXGI format " + q);
    if (K === DDS_RESOURCE_MISC_TEXTURECUBE)
      throw new Error("DDSParser does not support cubemap textures");
    if (Z === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D)
      throw new Error("DDSParser does not supported 3D texture data");
    var et = new Array(), tt = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
    if (J === 1)
      et.push(new Uint8Array(o, tt));
    else {
      for (var st = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[Q], rt = 0, at = M, ut = N, dt = 0; dt < D; dt++) {
        var ct = Math.max(1, at + 3 & -4), pt = Math.max(1, ut + 3 & -4), mt = ct * pt * st;
        rt += mt, at = at >>> 1, ut = ut >>> 1;
      }
      for (var vt = tt, dt = 0; dt < J; dt++)
        et.push(new Uint8Array(o, vt, rt)), vt += rt;
    }
    return et.map(function(_t) {
      return new CompressedTextureResource(_t, {
        format: Q,
        width: M,
        height: N,
        levels: D
      });
    });
  }
  throw B & DDPF_RGB ? new Error("DDSParser does not support uncompressed texture data.") : B & DDPF_YUV ? new Error("DDSParser does not supported YUV uncompressed texture data.") : B & DDPF_LUMINANCE ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : B & DDPF_ALPHA ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
var _a$3, _b, _c, FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], ENDIANNESS = 67305985, KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
}, FILE_HEADER_SIZE = 64, TYPES_TO_BYTES_PER_COMPONENT = (_a$3 = {}, _a$3[TYPES$5.UNSIGNED_BYTE] = 1, _a$3[TYPES$5.UNSIGNED_SHORT] = 2, _a$3[TYPES$5.INT] = 4, _a$3[TYPES$5.UNSIGNED_INT] = 4, _a$3[TYPES$5.FLOAT] = 4, _a$3[TYPES$5.HALF_FLOAT] = 8, _a$3), FORMATS_TO_COMPONENTS = (_b = {}, _b[FORMATS$5.RGBA] = 4, _b[FORMATS$5.RGB] = 3, _b[FORMATS$5.RG] = 2, _b[FORMATS$5.RED] = 1, _b[FORMATS$5.LUMINANCE] = 1, _b[FORMATS$5.LUMINANCE_ALPHA] = 2, _b[FORMATS$5.ALPHA] = 1, _b), TYPES_TO_BYTES_PER_PIXEL = (_c = {}, _c[TYPES$5.UNSIGNED_SHORT_4_4_4_4] = 2, _c[TYPES$5.UNSIGNED_SHORT_5_5_5_1] = 2, _c[TYPES$5.UNSIGNED_SHORT_5_6_5] = 2, _c);
function parseKTX(o, t, e) {
  e === void 0 && (e = !1);
  var R = new DataView(t);
  if (!validate(o, R))
    return null;
  var N = R.getUint32(KTX_FIELDS.ENDIANNESS, !0) === ENDIANNESS, M = R.getUint32(KTX_FIELDS.GL_TYPE, N), D = R.getUint32(KTX_FIELDS.GL_FORMAT, N), L = R.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, N), B = R.getUint32(KTX_FIELDS.PIXEL_WIDTH, N), $ = R.getUint32(KTX_FIELDS.PIXEL_HEIGHT, N) || 1, U = R.getUint32(KTX_FIELDS.PIXEL_DEPTH, N) || 1, H = R.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, N) || 1, z = R.getUint32(KTX_FIELDS.NUMBER_OF_FACES, N), X = R.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, N), Y = R.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, N);
  if ($ === 0 || U !== 1)
    throw new Error("Only 2D textures are supported");
  if (z !== 1)
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  if (H !== 1)
    throw new Error("WebGL does not support array textures");
  var W = 4, q = 4, Z = B + 3 & -4, K = $ + 3 & -4, J = new Array(H), Q = B * $;
  M === 0 && (Q = Z * K);
  var et;
  if (M !== 0 ? TYPES_TO_BYTES_PER_COMPONENT[M] ? et = TYPES_TO_BYTES_PER_COMPONENT[M] * FORMATS_TO_COMPONENTS[D] : et = TYPES_TO_BYTES_PER_PIXEL[M] : et = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[L], et === void 0)
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  for (var tt = e ? parseKvData(R, Y, N) : null, st = Q * et, rt = st, at = B, ut = $, dt = Z, ct = K, pt = FILE_HEADER_SIZE + Y, mt = 0; mt < X; mt++) {
    for (var vt = R.getUint32(pt, N), _t = pt + 4, xt = 0; xt < H; xt++) {
      var At = J[xt];
      At || (At = J[xt] = new Array(X)), At[mt] = {
        levelID: mt,
        levelWidth: X > 1 || M !== 0 ? at : dt,
        levelHeight: X > 1 || M !== 0 ? ut : ct,
        levelBuffer: new Uint8Array(t, _t, rt)
      }, _t += rt;
    }
    pt += vt + 4, pt = pt % 4 !== 0 ? pt + 4 - pt % 4 : pt, at = at >> 1 || 1, ut = ut >> 1 || 1, dt = at + W - 1 & ~(W - 1), ct = ut + q - 1 & ~(q - 1), rt = dt * ct * et;
  }
  return M !== 0 ? {
    uncompressed: J.map(function(yt) {
      var ht = yt[0].levelBuffer, bt = !1;
      return M === TYPES$5.FLOAT ? ht = new Float32Array(yt[0].levelBuffer.buffer, yt[0].levelBuffer.byteOffset, yt[0].levelBuffer.byteLength / 4) : M === TYPES$5.UNSIGNED_INT ? (bt = !0, ht = new Uint32Array(yt[0].levelBuffer.buffer, yt[0].levelBuffer.byteOffset, yt[0].levelBuffer.byteLength / 4)) : M === TYPES$5.INT && (bt = !0, ht = new Int32Array(yt[0].levelBuffer.buffer, yt[0].levelBuffer.byteOffset, yt[0].levelBuffer.byteLength / 4)), {
        resource: new BufferResource(ht, {
          width: yt[0].levelWidth,
          height: yt[0].levelHeight
        }),
        type: M,
        format: bt ? convertFormatToInteger(D) : D
      };
    }),
    kvData: tt
  } : {
    compressed: J.map(function(yt) {
      return new CompressedTextureResource(null, {
        format: L,
        width: B,
        height: $,
        levels: X,
        levelBuffers: yt
      });
    }),
    kvData: tt
  };
}
function validate(o, t) {
  for (var e = 0; e < FILE_IDENTIFIER.length; e++)
    if (t.getUint8(e) !== FILE_IDENTIFIER[e])
      return console.error(o + " is not a valid *.ktx file!"), !1;
  return !0;
}
function convertFormatToInteger(o) {
  switch (o) {
    case FORMATS$5.RGBA:
      return FORMATS$5.RGBA_INTEGER;
    case FORMATS$5.RGB:
      return FORMATS$5.RGB_INTEGER;
    case FORMATS$5.RG:
      return FORMATS$5.RG_INTEGER;
    case FORMATS$5.RED:
      return FORMATS$5.RED_INTEGER;
    default:
      return o;
  }
}
function parseKvData(o, t, e) {
  for (var R = /* @__PURE__ */ new Map(), N = 0; N < t; ) {
    var M = o.getUint32(FILE_HEADER_SIZE + N, e), D = FILE_HEADER_SIZE + N + 4, L = 3 - (M + 3) % 4;
    if (M === 0 || M > t - N) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    for (var B = 0; B < M && o.getUint8(D + B) !== 0; B++)
      ;
    if (B === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    var $ = new TextDecoder().decode(new Uint8Array(o.buffer, D, B)), U = new DataView(o.buffer, D + B + 1, M - B - 1);
    R.set($, U), N += 4 + M + L;
  }
  return R;
}
LoaderResource.setExtensionXhrType("dds", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var DDSLoader = function() {
  function o() {
  }
  return o.use = function(t, e) {
    if (t.extension === "dds" && t.data)
      try {
        Object.assign(t, registerCompressedTextures(t.name || t.url, parseDDS(t.data), t.metadata));
      } catch (R) {
        e(R);
        return;
      }
    e();
  }, o.extension = ExtensionType.Loader, o;
}();
LoaderResource.setExtensionXhrType("ktx", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var KTXLoader = function() {
  function o() {
  }
  return o.use = function(t, e) {
    if (t.extension === "ktx" && t.data)
      try {
        var R = t.name || t.url, N = parseKTX(R, t.data, this.loadKeyValueData), M = N.compressed, D = N.uncompressed, L = N.kvData;
        if (M) {
          var B = registerCompressedTextures(R, M, t.metadata);
          if (L && B.textures)
            for (var $ in B.textures)
              B.textures[$].baseTexture.ktxKeyValueData = L;
          Object.assign(t, B);
        } else if (D) {
          var U = {};
          D.forEach(function(H, z) {
            var X = new Texture(new BaseTexture(H.resource, {
              mipmap: MIPMAP_MODES$5.OFF,
              alphaMode: ALPHA_MODES$5.NO_PREMULTIPLIED_ALPHA,
              type: H.type,
              format: H.format
            })), Y = R + "-" + (z + 1);
            L && (X.baseTexture.ktxKeyValueData = L), BaseTexture.addToCache(X.baseTexture, Y), Texture.addToCache(X, Y), z === 0 && (U[R] = X, BaseTexture.addToCache(X.baseTexture, R), Texture.addToCache(X, R)), U[Y] = X;
          }), Object.assign(t, { textures: U });
        }
      } catch (H) {
        e(H);
        return;
      }
    e();
  }, o.extension = ExtensionType.Loader, o.loadKeyValueData = !1, o;
}();
/*!
 * @pixi/particle-container - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/particle-container is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$m = function(o, t) {
  return extendStatics$m = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$m(o, t);
};
function __extends$m(o, t) {
  extendStatics$m(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
(function(o) {
  __extends$m(t, o);
  function t(e, R, N, M) {
    e === void 0 && (e = 1500), N === void 0 && (N = 16384), M === void 0 && (M = !1);
    var D = o.call(this) || this, L = 16384;
    return N > L && (N = L), D._properties = [!1, !0, !1, !1, !1], D._maxSize = e, D._batchSize = N, D._buffers = null, D._bufferUpdateIDs = [], D._updateID = 0, D.interactiveChildren = !1, D.blendMode = BLEND_MODES$5.NORMAL, D.autoResize = M, D.roundPixels = !0, D.baseTexture = null, D.setProperties(R), D._tint = 0, D.tintRgb = new Float32Array(4), D.tint = 16777215, D;
  }
  return t.prototype.setProperties = function(e) {
    e && (this._properties[0] = "vertices" in e || "scale" in e ? !!e.vertices || !!e.scale : this._properties[0], this._properties[1] = "position" in e ? !!e.position : this._properties[1], this._properties[2] = "rotation" in e ? !!e.rotation : this._properties[2], this._properties[3] = "uvs" in e ? !!e.uvs : this._properties[3], this._properties[4] = "tint" in e || "alpha" in e ? !!e.tint || !!e.alpha : this._properties[4]);
  }, t.prototype.updateTransform = function() {
    this.displayObjectUpdateTransform();
  }, Object.defineProperty(t.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(e) {
      this._tint = e, hex2rgb(e, this.tintRgb);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.render = function(e) {
    var R = this;
    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", function() {
      return R.onChildrenChange(0);
    })), e.batch.setObjectRenderer(e.plugins.particle), e.plugins.particle.render(this));
  }, t.prototype.onChildrenChange = function(e) {
    for (var R = Math.floor(e / this._batchSize); this._bufferUpdateIDs.length < R; )
      this._bufferUpdateIDs.push(0);
    this._bufferUpdateIDs[R] = ++this._updateID;
  }, t.prototype.dispose = function() {
    if (this._buffers) {
      for (var e = 0; e < this._buffers.length; ++e)
        this._buffers[e].destroy();
      this._buffers = null;
    }
  }, t.prototype.destroy = function(e) {
    o.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;
  }, t;
})(Container);
var ParticleBuffer = function() {
  function o(t, e, R) {
    this.geometry = new Geometry(), this.indexBuffer = null, this.size = R, this.dynamicProperties = [], this.staticProperties = [];
    for (var N = 0; N < t.length; ++N) {
      var M = t[N];
      M = {
        attributeName: M.attributeName,
        size: M.size,
        uploadFunction: M.uploadFunction,
        type: M.type || TYPES$5.FLOAT,
        offset: M.offset
      }, e[N] ? this.dynamicProperties.push(M) : this.staticProperties.push(M);
    }
    this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();
  }
  return o.prototype.initBuffers = function() {
    var t = this.geometry, e = 0;
    this.indexBuffer = new Buffer$1(createIndicesForQuads(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;
    for (var R = 0; R < this.dynamicProperties.length; ++R) {
      var N = this.dynamicProperties[R];
      N.offset = e, e += N.size, this.dynamicStride += N.size;
    }
    var M = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(M), this.dynamicDataUint32 = new Uint32Array(M), this.dynamicBuffer = new Buffer$1(this.dynamicData, !1, !1);
    var D = 0;
    this.staticStride = 0;
    for (var R = 0; R < this.staticProperties.length; ++R) {
      var N = this.staticProperties[R];
      N.offset = D, D += N.size, this.staticStride += N.size;
    }
    var L = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(L), this.staticDataUint32 = new Uint32Array(L), this.staticBuffer = new Buffer$1(this.staticData, !0, !1);
    for (var R = 0; R < this.dynamicProperties.length; ++R) {
      var N = this.dynamicProperties[R];
      t.addAttribute(N.attributeName, this.dynamicBuffer, 0, N.type === TYPES$5.UNSIGNED_BYTE, N.type, this.dynamicStride * 4, N.offset * 4);
    }
    for (var R = 0; R < this.staticProperties.length; ++R) {
      var N = this.staticProperties[R];
      t.addAttribute(N.attributeName, this.staticBuffer, 0, N.type === TYPES$5.UNSIGNED_BYTE, N.type, this.staticStride * 4, N.offset * 4);
    }
  }, o.prototype.uploadDynamic = function(t, e, R) {
    for (var N = 0; N < this.dynamicProperties.length; N++) {
      var M = this.dynamicProperties[N];
      M.uploadFunction(t, e, R, M.type === TYPES$5.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, M.offset);
    }
    this.dynamicBuffer._updateID++;
  }, o.prototype.uploadStatic = function(t, e, R) {
    for (var N = 0; N < this.staticProperties.length; N++) {
      var M = this.staticProperties[N];
      M.uploadFunction(t, e, R, M.type === TYPES$5.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, M.offset);
    }
    this.staticBuffer._updateID++;
  }, o.prototype.destroy = function() {
    this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();
  }, o;
}(), fragment$6 = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`, vertex$3 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`, ParticleRenderer = function(o) {
  __extends$m(t, o);
  function t(e) {
    var R = o.call(this, e) || this;
    return R.shader = null, R.properties = null, R.tempMatrix = new Matrix(), R.properties = [
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: R.uploadVertices,
        offset: 0
      },
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: R.uploadPosition,
        offset: 0
      },
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: R.uploadRotation,
        offset: 0
      },
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: R.uploadUvs,
        offset: 0
      },
      {
        attributeName: "aColor",
        size: 1,
        type: TYPES$5.UNSIGNED_BYTE,
        uploadFunction: R.uploadTint,
        offset: 0
      }
    ], R.shader = Shader.from(vertex$3, fragment$6, {}), R.state = State.for2d(), R;
  }
  return t.prototype.render = function(e) {
    var R = e.children, N = e._maxSize, M = e._batchSize, D = this.renderer, L = R.length;
    if (L !== 0) {
      L > N && !e.autoResize && (L = N);
      var B = e._buffers;
      B || (B = e._buffers = this.generateBuffers(e));
      var $ = R[0]._texture.baseTexture, U = $.alphaMode > 0;
      this.state.blendMode = correctBlendMode(e.blendMode, U), D.state.set(this.state);
      var H = D.gl, z = e.worldTransform.copyTo(this.tempMatrix);
      z.prepend(D.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = z.toArray(!0), this.shader.uniforms.uColor = premultiplyRgba(e.tintRgb, e.worldAlpha, this.shader.uniforms.uColor, U), this.shader.uniforms.uSampler = $, this.renderer.shader.bind(this.shader);
      for (var X = !1, Y = 0, W = 0; Y < L; Y += M, W += 1) {
        var q = L - Y;
        q > M && (q = M), W >= B.length && B.push(this._generateOneMoreBuffer(e));
        var Z = B[W];
        Z.uploadDynamic(R, Y, q);
        var K = e._bufferUpdateIDs[W] || 0;
        X = X || Z._updateID < K, X && (Z._updateID = e._updateID, Z.uploadStatic(R, Y, q)), D.geometry.bind(Z.geometry), H.drawElements(H.TRIANGLES, q * 6, H.UNSIGNED_SHORT, 0);
      }
    }
  }, t.prototype.generateBuffers = function(e) {
    for (var R = [], N = e._maxSize, M = e._batchSize, D = e._properties, L = 0; L < N; L += M)
      R.push(new ParticleBuffer(this.properties, D, M));
    return R;
  }, t.prototype._generateOneMoreBuffer = function(e) {
    var R = e._batchSize, N = e._properties;
    return new ParticleBuffer(this.properties, N, R);
  }, t.prototype.uploadVertices = function(e, R, N, M, D, L) {
    for (var B = 0, $ = 0, U = 0, H = 0, z = 0; z < N; ++z) {
      var X = e[R + z], Y = X._texture, W = X.scale.x, q = X.scale.y, Z = Y.trim, K = Y.orig;
      Z ? ($ = Z.x - X.anchor.x * K.width, B = $ + Z.width, H = Z.y - X.anchor.y * K.height, U = H + Z.height) : (B = K.width * (1 - X.anchor.x), $ = K.width * -X.anchor.x, U = K.height * (1 - X.anchor.y), H = K.height * -X.anchor.y), M[L] = $ * W, M[L + 1] = H * q, M[L + D] = B * W, M[L + D + 1] = H * q, M[L + D * 2] = B * W, M[L + D * 2 + 1] = U * q, M[L + D * 3] = $ * W, M[L + D * 3 + 1] = U * q, L += D * 4;
    }
  }, t.prototype.uploadPosition = function(e, R, N, M, D, L) {
    for (var B = 0; B < N; B++) {
      var $ = e[R + B].position;
      M[L] = $.x, M[L + 1] = $.y, M[L + D] = $.x, M[L + D + 1] = $.y, M[L + D * 2] = $.x, M[L + D * 2 + 1] = $.y, M[L + D * 3] = $.x, M[L + D * 3 + 1] = $.y, L += D * 4;
    }
  }, t.prototype.uploadRotation = function(e, R, N, M, D, L) {
    for (var B = 0; B < N; B++) {
      var $ = e[R + B].rotation;
      M[L] = $, M[L + D] = $, M[L + D * 2] = $, M[L + D * 3] = $, L += D * 4;
    }
  }, t.prototype.uploadUvs = function(e, R, N, M, D, L) {
    for (var B = 0; B < N; ++B) {
      var $ = e[R + B]._texture._uvs;
      $ ? (M[L] = $.x0, M[L + 1] = $.y0, M[L + D] = $.x1, M[L + D + 1] = $.y1, M[L + D * 2] = $.x2, M[L + D * 2 + 1] = $.y2, M[L + D * 3] = $.x3, M[L + D * 3 + 1] = $.y3, L += D * 4) : (M[L] = 0, M[L + 1] = 0, M[L + D] = 0, M[L + D + 1] = 0, M[L + D * 2] = 0, M[L + D * 2 + 1] = 0, M[L + D * 3] = 0, M[L + D * 3 + 1] = 0, L += D * 4);
    }
  }, t.prototype.uploadTint = function(e, R, N, M, D, L) {
    for (var B = 0; B < N; ++B) {
      var $ = e[R + B], U = $._texture.baseTexture.alphaMode > 0, H = $.alpha, z = H < 1 && U ? premultiplyTint($._tintRGB, H) : $._tintRGB + (H * 255 << 24);
      M[L] = z, M[L + D] = z, M[L + D * 2] = z, M[L + D * 3] = z, L += D * 4;
    }
  }, t.prototype.destroy = function() {
    o.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;
  }, t.extension = {
    name: "particle",
    type: ExtensionType.RendererPlugin
  }, t;
}(ObjectRenderer);
/*!
 * @pixi/graphics - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/graphics is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var LINE_JOIN;
(function(o) {
  o.MITER = "miter", o.BEVEL = "bevel", o.ROUND = "round";
})(LINE_JOIN || (LINE_JOIN = {}));
var LINE_CAP;
(function(o) {
  o.BUTT = "butt", o.ROUND = "round", o.SQUARE = "square";
})(LINE_CAP || (LINE_CAP = {}));
var GRAPHICS_CURVES = {
  adaptive: !0,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount: function(o, t) {
    if (t === void 0 && (t = 20), !this.adaptive || !o || isNaN(o))
      return t;
    var e = Math.ceil(o / this.maxLength);
    return e < this.minSegments ? e = this.minSegments : e > this.maxSegments && (e = this.maxSegments), e;
  }
}, FillStyle = function() {
  function o() {
    this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1, this.reset();
  }
  return o.prototype.clone = function() {
    var t = new o();
    return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t;
  }, o.prototype.reset = function() {
    this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1;
  }, o.prototype.destroy = function() {
    this.texture = null, this.matrix = null;
  }, o;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$l = function(o, t) {
  return extendStatics$l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$l(o, t);
};
function __extends$l(o, t) {
  extendStatics$l(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function fixOrientation(o, t) {
  var e, R;
  t === void 0 && (t = !1);
  var N = o.length;
  if (!(N < 6)) {
    for (var M = 0, D = 0, L = o[N - 2], B = o[N - 1]; D < N; D += 2) {
      var $ = o[D], U = o[D + 1];
      M += ($ - L) * (U + B), L = $, B = U;
    }
    if (!t && M > 0 || t && M <= 0)
      for (var H = N / 2, D = H + H % 2; D < N; D += 2) {
        var z = N - D - 2, X = N - D - 1, Y = D, W = D + 1;
        e = [o[Y], o[z]], o[z] = e[0], o[Y] = e[1], R = [o[W], o[X]], o[X] = R[0], o[W] = R[1];
      }
  }
}
var buildPoly = {
  build: function(o) {
    o.points = o.shape.points.slice();
  },
  triangulate: function(o, t) {
    var e = o.points, R = o.holes, N = t.points, M = t.indices;
    if (e.length >= 6) {
      fixOrientation(e, !1);
      for (var D = [], L = 0; L < R.length; L++) {
        var B = R[L];
        fixOrientation(B.points, !0), D.push(e.length / 2), e = e.concat(B.points);
      }
      var $ = earcut$1.exports(e, D, 2);
      if (!$)
        return;
      for (var U = N.length / 2, L = 0; L < $.length; L += 3)
        M.push($[L] + U), M.push($[L + 1] + U), M.push($[L + 2] + U);
      for (var L = 0; L < e.length; L++)
        N.push(e[L]);
    }
  }
}, buildCircle = {
  build: function(o) {
    var t = o.points, e, R, N, M, D, L;
    if (o.type === SHAPES.CIRC) {
      var B = o.shape;
      e = B.x, R = B.y, D = L = B.radius, N = M = 0;
    } else if (o.type === SHAPES.ELIP) {
      var $ = o.shape;
      e = $.x, R = $.y, D = $.width, L = $.height, N = M = 0;
    } else {
      var U = o.shape, H = U.width / 2, z = U.height / 2;
      e = U.x + H, R = U.y + z, D = L = Math.max(0, Math.min(U.radius, Math.min(H, z))), N = H - D, M = z - L;
    }
    if (!(D >= 0 && L >= 0 && N >= 0 && M >= 0)) {
      t.length = 0;
      return;
    }
    var X = Math.ceil(2.3 * Math.sqrt(D + L)), Y = X * 8 + (N ? 4 : 0) + (M ? 4 : 0);
    if (t.length = Y, Y !== 0) {
      if (X === 0) {
        t.length = 8, t[0] = t[6] = e + N, t[1] = t[3] = R + M, t[2] = t[4] = e - N, t[5] = t[7] = R - M;
        return;
      }
      var W = 0, q = X * 4 + (N ? 2 : 0) + 2, Z = q, K = Y;
      {
        var J = N + D, Q = M, et = e + J, tt = e - J, st = R + Q;
        if (t[W++] = et, t[W++] = st, t[--q] = st, t[--q] = tt, M) {
          var rt = R - Q;
          t[Z++] = tt, t[Z++] = rt, t[--K] = rt, t[--K] = et;
        }
      }
      for (var at = 1; at < X; at++) {
        var ut = Math.PI / 2 * (at / X), J = N + Math.cos(ut) * D, Q = M + Math.sin(ut) * L, et = e + J, tt = e - J, st = R + Q, rt = R - Q;
        t[W++] = et, t[W++] = st, t[--q] = st, t[--q] = tt, t[Z++] = tt, t[Z++] = rt, t[--K] = rt, t[--K] = et;
      }
      {
        var J = N, Q = M + L, et = e + J, tt = e - J, st = R + Q, rt = R - Q;
        t[W++] = et, t[W++] = st, t[--K] = rt, t[--K] = et, N && (t[W++] = tt, t[W++] = st, t[--K] = rt, t[--K] = tt);
      }
    }
  },
  triangulate: function(o, t) {
    var e = o.points, R = t.points, N = t.indices;
    if (e.length !== 0) {
      var M = R.length / 2, D = M, L, B;
      if (o.type !== SHAPES.RREC) {
        var $ = o.shape;
        L = $.x, B = $.y;
      } else {
        var U = o.shape;
        L = U.x + U.width / 2, B = U.y + U.height / 2;
      }
      var H = o.matrix;
      R.push(o.matrix ? H.a * L + H.c * B + H.tx : L, o.matrix ? H.b * L + H.d * B + H.ty : B), M++, R.push(e[0], e[1]);
      for (var z = 2; z < e.length; z += 2)
        R.push(e[z], e[z + 1]), N.push(M++, D, M);
      N.push(D + 1, D, M);
    }
  }
}, buildRectangle = {
  build: function(o) {
    var t = o.shape, e = t.x, R = t.y, N = t.width, M = t.height, D = o.points;
    D.length = 0, D.push(e, R, e + N, R, e + N, R + M, e, R + M);
  },
  triangulate: function(o, t) {
    var e = o.points, R = t.points, N = R.length / 2;
    R.push(e[0], e[1], e[2], e[3], e[6], e[7], e[4], e[5]), t.indices.push(N, N + 1, N + 2, N + 1, N + 2, N + 3);
  }
};
function getPt(o, t, e) {
  var R = t - o;
  return o + R * e;
}
function quadraticBezierCurve(o, t, e, R, N, M, D) {
  D === void 0 && (D = []);
  for (var L = 20, B = D, $ = 0, U = 0, H = 0, z = 0, X = 0, Y = 0, W = 0, q = 0; W <= L; ++W)
    q = W / L, $ = getPt(o, e, q), U = getPt(t, R, q), H = getPt(e, N, q), z = getPt(R, M, q), X = getPt($, H, q), Y = getPt(U, z, q), !(W === 0 && B[B.length - 2] === X && B[B.length - 1] === Y) && B.push(X, Y);
  return B;
}
var buildRoundedRectangle = {
  build: function(o) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.build(o);
      return;
    }
    var t = o.shape, e = o.points, R = t.x, N = t.y, M = t.width, D = t.height, L = Math.max(0, Math.min(t.radius, Math.min(M, D) / 2));
    e.length = 0, L ? (quadraticBezierCurve(R, N + L, R, N, R + L, N, e), quadraticBezierCurve(R + M - L, N, R + M, N, R + M, N + L, e), quadraticBezierCurve(R + M, N + D - L, R + M, N + D, R + M - L, N + D, e), quadraticBezierCurve(R + L, N + D, R, N + D, R, N + D - L, e)) : e.push(R, N, R + M, N, R + M, N + D, R, N + D);
  },
  triangulate: function(o, t) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.triangulate(o, t);
      return;
    }
    for (var e = o.points, R = t.points, N = t.indices, M = R.length / 2, D = earcut$1.exports(e, null, 2), L = 0, B = D.length; L < B; L += 3)
      N.push(D[L] + M), N.push(D[L + 1] + M), N.push(D[L + 2] + M);
    for (var L = 0, B = e.length; L < B; L++)
      R.push(e[L], e[++L]);
  }
};
function square(o, t, e, R, N, M, D, L) {
  var B = o - e * N, $ = t - R * N, U = o + e * M, H = t + R * M, z, X;
  D ? (z = R, X = -e) : (z = -R, X = e);
  var Y = B + z, W = $ + X, q = U + z, Z = H + X;
  return L.push(Y, W), L.push(q, Z), 2;
}
function round$1(o, t, e, R, N, M, D, L) {
  var B = e - o, $ = R - t, U = Math.atan2(B, $), H = Math.atan2(N - o, M - t);
  L && U < H ? U += Math.PI * 2 : !L && U > H && (H += Math.PI * 2);
  var z = U, X = H - U, Y = Math.abs(X), W = Math.sqrt(B * B + $ * $), q = (15 * Y * Math.sqrt(W) / Math.PI >> 0) + 1, Z = X / q;
  if (z += Z, L) {
    D.push(o, t), D.push(e, R);
    for (var K = 1, J = z; K < q; K++, J += Z)
      D.push(o, t), D.push(o + Math.sin(J) * W, t + Math.cos(J) * W);
    D.push(o, t), D.push(N, M);
  } else {
    D.push(e, R), D.push(o, t);
    for (var K = 1, J = z; K < q; K++, J += Z)
      D.push(o + Math.sin(J) * W, t + Math.cos(J) * W), D.push(o, t);
    D.push(N, M), D.push(o, t);
  }
  return q * 2;
}
function buildNonNativeLine(o, t) {
  var e = o.shape, R = o.points || e.points.slice(), N = t.closePointEps;
  if (R.length !== 0) {
    var M = o.lineStyle, D = new Point(R[0], R[1]), L = new Point(R[R.length - 2], R[R.length - 1]), B = e.type !== SHAPES.POLY || e.closeStroke, $ = Math.abs(D.x - L.x) < N && Math.abs(D.y - L.y) < N;
    if (B) {
      R = R.slice(), $ && (R.pop(), R.pop(), L.set(R[R.length - 2], R[R.length - 1]));
      var U = (D.x + L.x) * 0.5, H = (L.y + D.y) * 0.5;
      R.unshift(U, H), R.push(U, H);
    }
    var z = t.points, X = R.length / 2, Y = R.length, W = z.length / 2, q = M.width / 2, Z = q * q, K = M.miterLimit * M.miterLimit, J = R[0], Q = R[1], et = R[2], tt = R[3], st = 0, rt = 0, at = -(Q - tt), ut = J - et, dt = 0, ct = 0, pt = Math.sqrt(at * at + ut * ut);
    at /= pt, ut /= pt, at *= q, ut *= q;
    var mt = M.alignment, vt = (1 - mt) * 2, _t = mt * 2;
    B || (M.cap === LINE_CAP.ROUND ? Y += round$1(J - at * (vt - _t) * 0.5, Q - ut * (vt - _t) * 0.5, J - at * vt, Q - ut * vt, J + at * _t, Q + ut * _t, z, !0) + 2 : M.cap === LINE_CAP.SQUARE && (Y += square(J, Q, at, ut, vt, _t, !0, z))), z.push(J - at * vt, Q - ut * vt), z.push(J + at * _t, Q + ut * _t);
    for (var xt = 1; xt < X - 1; ++xt) {
      J = R[(xt - 1) * 2], Q = R[(xt - 1) * 2 + 1], et = R[xt * 2], tt = R[xt * 2 + 1], st = R[(xt + 1) * 2], rt = R[(xt + 1) * 2 + 1], at = -(Q - tt), ut = J - et, pt = Math.sqrt(at * at + ut * ut), at /= pt, ut /= pt, at *= q, ut *= q, dt = -(tt - rt), ct = et - st, pt = Math.sqrt(dt * dt + ct * ct), dt /= pt, ct /= pt, dt *= q, ct *= q;
      var At = et - J, yt = Q - tt, ht = et - st, bt = rt - tt, Ct = yt * ht - bt * At, Mt = Ct < 0;
      if (Math.abs(Ct) < 0.1) {
        z.push(et - at * vt, tt - ut * vt), z.push(et + at * _t, tt + ut * _t);
        continue;
      }
      var wt = (-at + J) * (-ut + tt) - (-at + et) * (-ut + Q), Lt = (-dt + st) * (-ct + tt) - (-dt + et) * (-ct + rt), ft = (At * Lt - ht * wt) / Ct, Gt = (bt * wt - yt * Lt) / Ct, Dt = (ft - et) * (ft - et) + (Gt - tt) * (Gt - tt), Bt = et + (ft - et) * vt, Ot = tt + (Gt - tt) * vt, Et = et - (ft - et) * _t, Ht = tt - (Gt - tt) * _t, It = Math.min(At * At + yt * yt, ht * ht + bt * bt), St = Mt ? vt : _t, Nt = It + St * St * Z, $t = Dt <= Nt;
      $t ? M.join === LINE_JOIN.BEVEL || Dt / Z > K ? (Mt ? (z.push(Bt, Ot), z.push(et + at * _t, tt + ut * _t), z.push(Bt, Ot), z.push(et + dt * _t, tt + ct * _t)) : (z.push(et - at * vt, tt - ut * vt), z.push(Et, Ht), z.push(et - dt * vt, tt - ct * vt), z.push(Et, Ht)), Y += 2) : M.join === LINE_JOIN.ROUND ? Mt ? (z.push(Bt, Ot), z.push(et + at * _t, tt + ut * _t), Y += round$1(et, tt, et + at * _t, tt + ut * _t, et + dt * _t, tt + ct * _t, z, !0) + 4, z.push(Bt, Ot), z.push(et + dt * _t, tt + ct * _t)) : (z.push(et - at * vt, tt - ut * vt), z.push(Et, Ht), Y += round$1(et, tt, et - at * vt, tt - ut * vt, et - dt * vt, tt - ct * vt, z, !1) + 4, z.push(et - dt * vt, tt - ct * vt), z.push(Et, Ht)) : (z.push(Bt, Ot), z.push(Et, Ht)) : (z.push(et - at * vt, tt - ut * vt), z.push(et + at * _t, tt + ut * _t), M.join === LINE_JOIN.ROUND ? Mt ? Y += round$1(et, tt, et + at * _t, tt + ut * _t, et + dt * _t, tt + ct * _t, z, !0) + 2 : Y += round$1(et, tt, et - at * vt, tt - ut * vt, et - dt * vt, tt - ct * vt, z, !1) + 2 : M.join === LINE_JOIN.MITER && Dt / Z <= K && (Mt ? (z.push(Et, Ht), z.push(Et, Ht)) : (z.push(Bt, Ot), z.push(Bt, Ot)), Y += 2), z.push(et - dt * vt, tt - ct * vt), z.push(et + dt * _t, tt + ct * _t), Y += 2);
    }
    J = R[(X - 2) * 2], Q = R[(X - 2) * 2 + 1], et = R[(X - 1) * 2], tt = R[(X - 1) * 2 + 1], at = -(Q - tt), ut = J - et, pt = Math.sqrt(at * at + ut * ut), at /= pt, ut /= pt, at *= q, ut *= q, z.push(et - at * vt, tt - ut * vt), z.push(et + at * _t, tt + ut * _t), B || (M.cap === LINE_CAP.ROUND ? Y += round$1(et - at * (vt - _t) * 0.5, tt - ut * (vt - _t) * 0.5, et - at * vt, tt - ut * vt, et + at * _t, tt + ut * _t, z, !1) + 2 : M.cap === LINE_CAP.SQUARE && (Y += square(et, tt, at, ut, vt, _t, !1, z)));
    for (var Rt = t.indices, Jt = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon, xt = W; xt < Y + W - 2; ++xt)
      J = z[xt * 2], Q = z[xt * 2 + 1], et = z[(xt + 1) * 2], tt = z[(xt + 1) * 2 + 1], st = z[(xt + 2) * 2], rt = z[(xt + 2) * 2 + 1], !(Math.abs(J * (tt - rt) + et * (rt - Q) + st * (Q - tt)) < Jt) && Rt.push(xt, xt + 1, xt + 2);
  }
}
function buildNativeLine(o, t) {
  var e = 0, R = o.shape, N = o.points || R.points, M = R.type !== SHAPES.POLY || R.closeStroke;
  if (N.length !== 0) {
    var D = t.points, L = t.indices, B = N.length / 2, $ = D.length / 2, U = $;
    for (D.push(N[0], N[1]), e = 1; e < B; e++)
      D.push(N[e * 2], N[e * 2 + 1]), L.push(U, U + 1), U++;
    M && L.push(U, $);
  }
}
function buildLine(o, t) {
  o.lineStyle.native ? buildNativeLine(o, t) : buildNonNativeLine(o, t);
}
var ArcUtils = function() {
  function o() {
  }
  return o.curveTo = function(t, e, R, N, M, D) {
    var L = D[D.length - 2], B = D[D.length - 1], $ = B - e, U = L - t, H = N - e, z = R - t, X = Math.abs($ * z - U * H);
    if (X < 1e-8 || M === 0)
      return (D[D.length - 2] !== t || D[D.length - 1] !== e) && D.push(t, e), null;
    var Y = $ * $ + U * U, W = H * H + z * z, q = $ * H + U * z, Z = M * Math.sqrt(Y) / X, K = M * Math.sqrt(W) / X, J = Z * q / Y, Q = K * q / W, et = Z * z + K * U, tt = Z * H + K * $, st = U * (K + J), rt = $ * (K + J), at = z * (Z + Q), ut = H * (Z + Q), dt = Math.atan2(rt - tt, st - et), ct = Math.atan2(ut - tt, at - et);
    return {
      cx: et + t,
      cy: tt + e,
      radius: M,
      startAngle: dt,
      endAngle: ct,
      anticlockwise: U * H > z * $
    };
  }, o.arc = function(t, e, R, N, M, D, L, B, $) {
    for (var U = L - D, H = GRAPHICS_CURVES._segmentsCount(Math.abs(U) * M, Math.ceil(Math.abs(U) / PI_2) * 40), z = U / (H * 2), X = z * 2, Y = Math.cos(z), W = Math.sin(z), q = H - 1, Z = q % 1 / q, K = 0; K <= q; ++K) {
      var J = K + Z * K, Q = z + D + X * J, et = Math.cos(Q), tt = -Math.sin(Q);
      $.push((Y * et + W * tt) * M + R, (Y * -tt + W * et) * M + N);
    }
  }, o;
}(), BezierUtils = function() {
  function o() {
  }
  return o.curveLength = function(t, e, R, N, M, D, L, B) {
    for (var $ = 10, U = 0, H = 0, z = 0, X = 0, Y = 0, W = 0, q = 0, Z = 0, K = 0, J = 0, Q = 0, et = t, tt = e, st = 1; st <= $; ++st)
      H = st / $, z = H * H, X = z * H, Y = 1 - H, W = Y * Y, q = W * Y, Z = q * t + 3 * W * H * R + 3 * Y * z * M + X * L, K = q * e + 3 * W * H * N + 3 * Y * z * D + X * B, J = et - Z, Q = tt - K, et = Z, tt = K, U += Math.sqrt(J * J + Q * Q);
    return U;
  }, o.curveTo = function(t, e, R, N, M, D, L) {
    var B = L[L.length - 2], $ = L[L.length - 1];
    L.length -= 2;
    var U = GRAPHICS_CURVES._segmentsCount(o.curveLength(B, $, t, e, R, N, M, D)), H = 0, z = 0, X = 0, Y = 0, W = 0;
    L.push(B, $);
    for (var q = 1, Z = 0; q <= U; ++q)
      Z = q / U, H = 1 - Z, z = H * H, X = z * H, Y = Z * Z, W = Y * Z, L.push(X * B + 3 * z * Z * t + 3 * H * Y * R + W * M, X * $ + 3 * z * Z * e + 3 * H * Y * N + W * D);
  }, o;
}(), QuadraticUtils = function() {
  function o() {
  }
  return o.curveLength = function(t, e, R, N, M, D) {
    var L = t - 2 * R + M, B = e - 2 * N + D, $ = 2 * R - 2 * t, U = 2 * N - 2 * e, H = 4 * (L * L + B * B), z = 4 * (L * $ + B * U), X = $ * $ + U * U, Y = 2 * Math.sqrt(H + z + X), W = Math.sqrt(H), q = 2 * H * W, Z = 2 * Math.sqrt(X), K = z / W;
    return (q * Y + W * z * (Y - Z) + (4 * X * H - z * z) * Math.log((2 * W + K + Y) / (K + Z))) / (4 * q);
  }, o.curveTo = function(t, e, R, N, M) {
    for (var D = M[M.length - 2], L = M[M.length - 1], B = GRAPHICS_CURVES._segmentsCount(o.curveLength(D, L, t, e, R, N)), $ = 0, U = 0, H = 1; H <= B; ++H) {
      var z = H / B;
      $ = D + (t - D) * z, U = L + (e - L) * z, M.push($ + (t + (R - t) * z - $) * z, U + (e + (N - e) * z - U) * z);
    }
  }, o;
}(), BatchPart = function() {
  function o() {
    this.reset();
  }
  return o.prototype.begin = function(t, e, R) {
    this.reset(), this.style = t, this.start = e, this.attribStart = R;
  }, o.prototype.end = function(t, e) {
    this.attribSize = e - this.attribStart, this.size = t - this.start;
  }, o.prototype.reset = function() {
    this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;
  }, o;
}(), _a, FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a), BATCH_POOL = [], DRAW_CALL_POOL = [], GraphicsData = function() {
  function o(t, e, R, N) {
    e === void 0 && (e = null), R === void 0 && (R = null), N === void 0 && (N = null), this.points = [], this.holes = [], this.shape = t, this.lineStyle = R, this.fillStyle = e, this.matrix = N, this.type = t.type;
  }
  return o.prototype.clone = function() {
    return new o(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  }, o.prototype.destroy = function() {
    this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;
  }, o;
}(), tmpPoint = new Point(), GraphicsGeometry = function(o) {
  __extends$l(t, o);
  function t() {
    var e = o.call(this) || this;
    return e.closePointEps = 1e-4, e.boundsPadding = 0, e.uvsFloat32 = null, e.indicesUint16 = null, e.batchable = !1, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.drawCalls = [], e.batchDirty = -1, e.batches = [], e.dirty = 0, e.cacheDirty = -1, e.clearDirty = 0, e.shapeIndex = 0, e._bounds = new Bounds(), e.boundsDirty = -1, e;
  }
  return Object.defineProperty(t.prototype, "bounds", {
    get: function() {
      return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.invalidate = function() {
    this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
    for (var e = 0; e < this.drawCalls.length; e++)
      this.drawCalls[e].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[e]);
    this.drawCalls.length = 0;
    for (var e = 0; e < this.batches.length; e++) {
      var R = this.batches[e];
      R.reset(), BATCH_POOL.push(R);
    }
    this.batches.length = 0;
  }, t.prototype.clear = function() {
    return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;
  }, t.prototype.drawShape = function(e, R, N, M) {
    R === void 0 && (R = null), N === void 0 && (N = null), M === void 0 && (M = null);
    var D = new GraphicsData(e, R, N, M);
    return this.graphicsData.push(D), this.dirty++, this;
  }, t.prototype.drawHole = function(e, R) {
    if (R === void 0 && (R = null), !this.graphicsData.length)
      return null;
    var N = new GraphicsData(e, null, null, R), M = this.graphicsData[this.graphicsData.length - 1];
    return N.lineStyle = M.lineStyle, M.holes.push(N), this.dirty++, this;
  }, t.prototype.destroy = function() {
    o.prototype.destroy.call(this);
    for (var e = 0; e < this.graphicsData.length; ++e)
      this.graphicsData[e].destroy();
    this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;
  }, t.prototype.containsPoint = function(e) {
    for (var R = this.graphicsData, N = 0; N < R.length; ++N) {
      var M = R[N];
      if (!!M.fillStyle.visible && M.shape && (M.matrix ? M.matrix.applyInverse(e, tmpPoint) : tmpPoint.copyFrom(e), M.shape.contains(tmpPoint.x, tmpPoint.y))) {
        var D = !1;
        if (M.holes)
          for (var L = 0; L < M.holes.length; L++) {
            var B = M.holes[L];
            if (B.shape.contains(tmpPoint.x, tmpPoint.y)) {
              D = !0;
              break;
            }
          }
        if (!D)
          return !0;
      }
    }
    return !1;
  }, t.prototype.updateBatches = function() {
    if (!this.graphicsData.length) {
      this.batchable = !0;
      return;
    }
    if (!!this.validateBatching()) {
      this.cacheDirty = this.dirty;
      var e = this.uvs, R = this.graphicsData, N = null, M = null;
      this.batches.length > 0 && (N = this.batches[this.batches.length - 1], M = N.style);
      for (var D = this.shapeIndex; D < R.length; D++) {
        this.shapeIndex++;
        var L = R[D], B = L.fillStyle, $ = L.lineStyle, U = FILL_COMMANDS[L.type];
        U.build(L), L.matrix && this.transformPoints(L.points, L.matrix), (B.visible || $.visible) && this.processHoles(L.holes);
        for (var H = 0; H < 2; H++) {
          var z = H === 0 ? B : $;
          if (!!z.visible) {
            var X = z.texture.baseTexture, Y = this.indices.length, W = this.points.length / 2;
            X.wrapMode = WRAP_MODES$5.REPEAT, H === 0 ? this.processFill(L) : this.processLine(L);
            var q = this.points.length / 2 - W;
            q !== 0 && (N && !this._compareStyles(M, z) && (N.end(Y, W), N = null), N || (N = BATCH_POOL.pop() || new BatchPart(), N.begin(z, Y, W), this.batches.push(N), M = z), this.addUvs(this.points, e, z.texture, W, q, z.matrix));
          }
        }
      }
      var Z = this.indices.length, K = this.points.length / 2;
      if (N && N.end(Z, K), this.batches.length === 0) {
        this.batchable = !0;
        return;
      }
      var J = K > 65535;
      this.indicesUint16 && this.indices.length === this.indicesUint16.length && J === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = J ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();
    }
  }, t.prototype._compareStyles = function(e, R) {
    return !(!e || !R || e.texture.baseTexture !== R.texture.baseTexture || e.color + e.alpha !== R.color + R.alpha || !!e.native != !!R.native);
  }, t.prototype.validateBatching = function() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length)
      return !1;
    for (var e = 0, R = this.graphicsData.length; e < R; e++) {
      var N = this.graphicsData[e], M = N.fillStyle, D = N.lineStyle;
      if (M && !M.texture.baseTexture.valid || D && !D.texture.baseTexture.valid)
        return !1;
    }
    return !0;
  }, t.prototype.packBatches = function() {
    this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
    for (var e = this.batches, R = 0, N = e.length; R < N; R++)
      for (var M = e[R], D = 0; D < M.size; D++) {
        var L = M.start + D;
        this.indicesUint16[L] = this.indicesUint16[L] - M.attribStart;
      }
  }, t.prototype.isBatchable = function() {
    if (this.points.length > 65535 * 2)
      return !1;
    for (var e = this.batches, R = 0; R < e.length; R++)
      if (e[R].style.native)
        return !1;
    return this.points.length < t.BATCHABLE_SIZE * 2;
  }, t.prototype.buildDrawCalls = function() {
    for (var e = ++BaseTexture._globalBatch, R = 0; R < this.drawCalls.length; R++)
      this.drawCalls[R].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[R]);
    this.drawCalls.length = 0;
    var N = this.colors, M = this.textureIds, D = DRAW_CALL_POOL.pop();
    D || (D = new BatchDrawCall(), D.texArray = new BatchTextureArray()), D.texArray.count = 0, D.start = 0, D.size = 0, D.type = DRAW_MODES$5.TRIANGLES;
    var L = 0, B = null, $ = 0, U = !1, H = DRAW_MODES$5.TRIANGLES, z = 0;
    this.drawCalls.push(D);
    for (var R = 0; R < this.batches.length; R++) {
      var X = this.batches[R], Y = 8, W = X.style, q = W.texture.baseTexture;
      U !== !!W.native && (U = !!W.native, H = U ? DRAW_MODES$5.LINES : DRAW_MODES$5.TRIANGLES, B = null, L = Y, e++), B !== q && (B = q, q._batchEnabled !== e && (L === Y && (e++, L = 0, D.size > 0 && (D = DRAW_CALL_POOL.pop(), D || (D = new BatchDrawCall(), D.texArray = new BatchTextureArray()), this.drawCalls.push(D)), D.start = z, D.size = 0, D.texArray.count = 0, D.type = H), q.touched = 1, q._batchEnabled = e, q._batchLocation = L, q.wrapMode = WRAP_MODES$5.REPEAT, D.texArray.elements[D.texArray.count++] = q, L++)), D.size += X.size, z += X.size, $ = q._batchLocation, this.addColors(N, W.color, W.alpha, X.attribSize, X.attribStart), this.addTextureIds(M, $, X.attribSize, X.attribStart);
    }
    BaseTexture._globalBatch = e, this.packAttributes();
  }, t.prototype.packAttributes = function() {
    for (var e = this.points, R = this.uvs, N = this.colors, M = this.textureIds, D = new ArrayBuffer(e.length * 3 * 4), L = new Float32Array(D), B = new Uint32Array(D), $ = 0, U = 0; U < e.length / 2; U++)
      L[$++] = e[U * 2], L[$++] = e[U * 2 + 1], L[$++] = R[U * 2], L[$++] = R[U * 2 + 1], B[$++] = N[U], L[$++] = M[U];
    this._buffer.update(D), this._indexBuffer.update(this.indicesUint16);
  }, t.prototype.processFill = function(e) {
    if (e.holes.length)
      buildPoly.triangulate(e, this);
    else {
      var R = FILL_COMMANDS[e.type];
      R.triangulate(e, this);
    }
  }, t.prototype.processLine = function(e) {
    buildLine(e, this);
    for (var R = 0; R < e.holes.length; R++)
      buildLine(e.holes[R], this);
  }, t.prototype.processHoles = function(e) {
    for (var R = 0; R < e.length; R++) {
      var N = e[R], M = FILL_COMMANDS[N.type];
      M.build(N), N.matrix && this.transformPoints(N.points, N.matrix);
    }
  }, t.prototype.calculateBounds = function() {
    var e = this._bounds;
    e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding);
  }, t.prototype.transformPoints = function(e, R) {
    for (var N = 0; N < e.length / 2; N++) {
      var M = e[N * 2], D = e[N * 2 + 1];
      e[N * 2] = R.a * M + R.c * D + R.tx, e[N * 2 + 1] = R.b * M + R.d * D + R.ty;
    }
  }, t.prototype.addColors = function(e, R, N, M, D) {
    D === void 0 && (D = 0);
    var L = (R >> 16) + (R & 65280) + ((R & 255) << 16), B = premultiplyTint(L, N);
    e.length = Math.max(e.length, D + M);
    for (var $ = 0; $ < M; $++)
      e[D + $] = B;
  }, t.prototype.addTextureIds = function(e, R, N, M) {
    M === void 0 && (M = 0), e.length = Math.max(e.length, M + N);
    for (var D = 0; D < N; D++)
      e[M + D] = R;
  }, t.prototype.addUvs = function(e, R, N, M, D, L) {
    L === void 0 && (L = null);
    for (var B = 0, $ = R.length, U = N.frame; B < D; ) {
      var H = e[(M + B) * 2], z = e[(M + B) * 2 + 1];
      if (L) {
        var X = L.a * H + L.c * z + L.tx;
        z = L.b * H + L.d * z + L.ty, H = X;
      }
      B++, R.push(H / U.width, z / U.height);
    }
    var Y = N.baseTexture;
    (U.width < Y.width || U.height < Y.height) && this.adjustUvs(R, N, $, D);
  }, t.prototype.adjustUvs = function(e, R, N, M) {
    for (var D = R.baseTexture, L = 1e-6, B = N + M * 2, $ = R.frame, U = $.width / D.width, H = $.height / D.height, z = $.x / $.width, X = $.y / $.height, Y = Math.floor(e[N] + L), W = Math.floor(e[N + 1] + L), q = N + 2; q < B; q += 2)
      Y = Math.min(Y, Math.floor(e[q] + L)), W = Math.min(W, Math.floor(e[q + 1] + L));
    z -= Y, X -= W;
    for (var q = N; q < B; q += 2)
      e[q] = (e[q] + z) * U, e[q + 1] = (e[q + 1] + X) * H;
  }, t.BATCHABLE_SIZE = 100, t;
}(BatchGeometry), LineStyle = function(o) {
  __extends$l(t, o);
  function t() {
    var e = o !== null && o.apply(this, arguments) || this;
    return e.width = 0, e.alignment = 0.5, e.native = !1, e.cap = LINE_CAP.BUTT, e.join = LINE_JOIN.MITER, e.miterLimit = 10, e;
  }
  return t.prototype.clone = function() {
    var e = new t();
    return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e.width = this.width, e.alignment = this.alignment, e.native = this.native, e.cap = this.cap, e.join = this.join, e.miterLimit = this.miterLimit, e;
  }, t.prototype.reset = function() {
    o.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1;
  }, t;
}(FillStyle), temp = new Float32Array(3), DEFAULT_SHADERS = {}, Graphics = function(o) {
  __extends$l(t, o);
  function t(e) {
    e === void 0 && (e = null);
    var R = o.call(this) || this;
    return R.shader = null, R.pluginName = "batch", R.currentPath = null, R.batches = [], R.batchTint = -1, R.batchDirty = -1, R.vertexData = null, R._fillStyle = new FillStyle(), R._lineStyle = new LineStyle(), R._matrix = null, R._holeMode = !1, R.state = State.for2d(), R._geometry = e || new GraphicsGeometry(), R._geometry.refCount++, R._transformID = -1, R.tint = 16777215, R.blendMode = BLEND_MODES$5.NORMAL, R;
  }
  return Object.defineProperty(t.prototype, "geometry", {
    get: function() {
      return this._geometry;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.clone = function() {
    return this.finishPoly(), new t(this._geometry);
  }, Object.defineProperty(t.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(e) {
      this.state.blendMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(e) {
      this._tint = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fill", {
    get: function() {
      return this._fillStyle;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "line", {
    get: function() {
      return this._lineStyle;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.lineStyle = function(e, R, N, M, D) {
    return e === void 0 && (e = null), R === void 0 && (R = 0), N === void 0 && (N = 1), M === void 0 && (M = 0.5), D === void 0 && (D = !1), typeof e == "number" && (e = { width: e, color: R, alpha: N, alignment: M, native: D }), this.lineTextureStyle(e);
  }, t.prototype.lineTextureStyle = function(e) {
    e = Object.assign({
      width: 0,
      texture: Texture.WHITE,
      color: e && e.texture ? 16777215 : 0,
      alpha: 1,
      matrix: null,
      alignment: 0.5,
      native: !1,
      cap: LINE_CAP.BUTT,
      join: LINE_JOIN.MITER,
      miterLimit: 10
    }, e), this.currentPath && this.startPoly();
    var R = e.width > 0 && e.alpha > 0;
    return R ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, { visible: R }, e)) : this._lineStyle.reset(), this;
  }, t.prototype.startPoly = function() {
    if (this.currentPath) {
      var e = this.currentPath.points, R = this.currentPath.points.length;
      R > 2 && (this.drawShape(this.currentPath), this.currentPath = new Polygon(), this.currentPath.closeStroke = !1, this.currentPath.points.push(e[R - 2], e[R - 1]));
    } else
      this.currentPath = new Polygon(), this.currentPath.closeStroke = !1;
  }, t.prototype.finishPoly = function() {
    this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);
  }, t.prototype.moveTo = function(e, R) {
    return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = R, this;
  }, t.prototype.lineTo = function(e, R) {
    this.currentPath || this.moveTo(0, 0);
    var N = this.currentPath.points, M = N[N.length - 2], D = N[N.length - 1];
    return (M !== e || D !== R) && N.push(e, R), this;
  }, t.prototype._initCurve = function(e, R) {
    e === void 0 && (e = 0), R === void 0 && (R = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, R]) : this.moveTo(e, R);
  }, t.prototype.quadraticCurveTo = function(e, R, N, M) {
    this._initCurve();
    var D = this.currentPath.points;
    return D.length === 0 && this.moveTo(0, 0), QuadraticUtils.curveTo(e, R, N, M, D), this;
  }, t.prototype.bezierCurveTo = function(e, R, N, M, D, L) {
    return this._initCurve(), BezierUtils.curveTo(e, R, N, M, D, L, this.currentPath.points), this;
  }, t.prototype.arcTo = function(e, R, N, M, D) {
    this._initCurve(e, R);
    var L = this.currentPath.points, B = ArcUtils.curveTo(e, R, N, M, D, L);
    if (B) {
      var $ = B.cx, U = B.cy, H = B.radius, z = B.startAngle, X = B.endAngle, Y = B.anticlockwise;
      this.arc($, U, H, z, X, Y);
    }
    return this;
  }, t.prototype.arc = function(e, R, N, M, D, L) {
    if (L === void 0 && (L = !1), M === D)
      return this;
    !L && D <= M ? D += PI_2 : L && M <= D && (M += PI_2);
    var B = D - M;
    if (B === 0)
      return this;
    var $ = e + Math.cos(M) * N, U = R + Math.sin(M) * N, H = this._geometry.closePointEps, z = this.currentPath ? this.currentPath.points : null;
    if (z) {
      var X = Math.abs(z[z.length - 2] - $), Y = Math.abs(z[z.length - 1] - U);
      X < H && Y < H || z.push($, U);
    } else
      this.moveTo($, U), z = this.currentPath.points;
    return ArcUtils.arc($, U, e, R, N, M, D, L, z), this;
  }, t.prototype.beginFill = function(e, R) {
    return e === void 0 && (e = 0), R === void 0 && (R = 1), this.beginTextureFill({ texture: Texture.WHITE, color: e, alpha: R });
  }, t.prototype.beginTextureFill = function(e) {
    e = Object.assign({
      texture: Texture.WHITE,
      color: 16777215,
      alpha: 1,
      matrix: null
    }, e), this.currentPath && this.startPoly();
    var R = e.alpha > 0;
    return R ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, { visible: R }, e)) : this._fillStyle.reset(), this;
  }, t.prototype.endFill = function() {
    return this.finishPoly(), this._fillStyle.reset(), this;
  }, t.prototype.drawRect = function(e, R, N, M) {
    return this.drawShape(new Rectangle(e, R, N, M));
  }, t.prototype.drawRoundedRect = function(e, R, N, M, D) {
    return this.drawShape(new RoundedRectangle(e, R, N, M, D));
  }, t.prototype.drawCircle = function(e, R, N) {
    return this.drawShape(new Circle(e, R, N));
  }, t.prototype.drawEllipse = function(e, R, N, M) {
    return this.drawShape(new Ellipse(e, R, N, M));
  }, t.prototype.drawPolygon = function() {
    for (var e = arguments, R = [], N = 0; N < arguments.length; N++)
      R[N] = e[N];
    var M, D = !0, L = R[0];
    L.points ? (D = L.closeStroke, M = L.points) : Array.isArray(R[0]) ? M = R[0] : M = R;
    var B = new Polygon(M);
    return B.closeStroke = D, this.drawShape(B), this;
  }, t.prototype.drawShape = function(e) {
    return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;
  }, t.prototype.clear = function() {
    return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;
  }, t.prototype.isFastRect = function() {
    var e = this._geometry.graphicsData;
    return e.length === 1 && e[0].shape.type === SHAPES.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width);
  }, t.prototype._render = function(e) {
    this.finishPoly();
    var R = this._geometry;
    R.updateBatches(), R.batchable ? (this.batchDirty !== R.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e));
  }, t.prototype._populateBatches = function() {
    var e = this._geometry, R = this.blendMode, N = e.batches.length;
    this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = N, this.vertexData = new Float32Array(e.points);
    for (var M = 0; M < N; M++) {
      var D = e.batches[M], L = D.style.color, B = new Float32Array(this.vertexData.buffer, D.attribStart * 4 * 2, D.attribSize * 2), $ = new Float32Array(e.uvsFloat32.buffer, D.attribStart * 4 * 2, D.attribSize * 2), U = new Uint16Array(e.indicesUint16.buffer, D.start * 2, D.size), H = {
        vertexData: B,
        blendMode: R,
        indices: U,
        uvs: $,
        _batchRGB: hex2rgb(L),
        _tintRGB: L,
        _texture: D.style.texture,
        alpha: D.style.alpha,
        worldAlpha: 1
      };
      this.batches[M] = H;
    }
  }, t.prototype._renderBatched = function(e) {
    if (!!this.batches.length) {
      e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
      for (var R = 0, N = this.batches.length; R < N; R++) {
        var M = this.batches[R];
        M.worldAlpha = this.worldAlpha * M.alpha, e.plugins[this.pluginName].render(M);
      }
    }
  }, t.prototype._renderDirect = function(e) {
    var R = this._resolveDirectShader(e), N = this._geometry, M = this.tint, D = this.worldAlpha, L = R.uniforms, B = N.drawCalls;
    L.translationMatrix = this.transform.worldTransform, L.tint[0] = (M >> 16 & 255) / 255 * D, L.tint[1] = (M >> 8 & 255) / 255 * D, L.tint[2] = (M & 255) / 255 * D, L.tint[3] = D, e.shader.bind(R), e.geometry.bind(N, R), e.state.set(this.state);
    for (var $ = 0, U = B.length; $ < U; $++)
      this._renderDrawCallDirect(e, N.drawCalls[$]);
  }, t.prototype._renderDrawCallDirect = function(e, R) {
    for (var N = R.texArray, M = R.type, D = R.size, L = R.start, B = N.count, $ = 0; $ < B; $++)
      e.texture.bind(N.elements[$], $);
    e.geometry.draw(M, D, L);
  }, t.prototype._resolveDirectShader = function(e) {
    var R = this.shader, N = this.pluginName;
    if (!R) {
      if (!DEFAULT_SHADERS[N]) {
        for (var M = e.plugins[N].MAX_TEXTURES, D = new Int32Array(M), L = 0; L < M; L++)
          D[L] = L;
        var B = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix(),
          default: UniformGroup.from({ uSamplers: D }, !0)
        }, $ = e.plugins[N]._shader.program;
        DEFAULT_SHADERS[N] = new Shader($, B);
      }
      R = DEFAULT_SHADERS[N];
    }
    return R;
  }, t.prototype._calculateBounds = function() {
    this.finishPoly();
    var e = this._geometry;
    if (!!e.graphicsData.length) {
      var R = e.bounds, N = R.minX, M = R.minY, D = R.maxX, L = R.maxY;
      this._bounds.addFrame(this.transform, N, M, D, L);
    }
  }, t.prototype.containsPoint = function(e) {
    return this.worldTransform.applyInverse(e, t._TEMP_POINT), this._geometry.containsPoint(t._TEMP_POINT);
  }, t.prototype.calculateTints = function() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this.tint;
      for (var e = hex2rgb(this.tint, temp), R = 0; R < this.batches.length; R++) {
        var N = this.batches[R], M = N._batchRGB, D = e[0] * M[0] * 255, L = e[1] * M[1] * 255, B = e[2] * M[2] * 255, $ = (D << 16) + (L << 8) + (B | 0);
        N._tintRGB = ($ >> 16) + ($ & 65280) + (($ & 255) << 16);
      }
    }
  }, t.prototype.calculateVertices = function() {
    var e = this.transform._worldID;
    if (this._transformID !== e) {
      this._transformID = e;
      for (var R = this.transform.worldTransform, N = R.a, M = R.b, D = R.c, L = R.d, B = R.tx, $ = R.ty, U = this._geometry.points, H = this.vertexData, z = 0, X = 0; X < U.length; X += 2) {
        var Y = U[X], W = U[X + 1];
        H[z++] = N * Y + D * W + B, H[z++] = L * W + M * Y + $;
      }
    }
  }, t.prototype.closePath = function() {
    var e = this.currentPath;
    return e && (e.closeStroke = !0, this.finishPoly()), this;
  }, t.prototype.setMatrix = function(e) {
    return this._matrix = e, this;
  }, t.prototype.beginHole = function() {
    return this.finishPoly(), this._holeMode = !0, this;
  }, t.prototype.endHole = function() {
    return this.finishPoly(), this._holeMode = !1, this;
  }, t.prototype.destroy = function(e) {
    this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, o.prototype.destroy.call(this, e);
  }, t.nextRoundedRectBehavior = !1, t._TEMP_POINT = new Point(), t;
}(Container);
/*!
 * @pixi/sprite - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/sprite is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$k = function(o, t) {
  return extendStatics$k = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$k(o, t);
};
function __extends$k(o, t) {
  extendStatics$k(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var tempPoint$2 = new Point(), indices = new Uint16Array([0, 1, 2, 0, 2, 3]), Sprite = function(o) {
  __extends$k(t, o);
  function t(e) {
    var R = o.call(this) || this;
    return R._anchor = new ObservablePoint(R._onAnchorUpdate, R, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), R._texture = null, R._width = 0, R._height = 0, R._tint = null, R._tintRGB = null, R.tint = 16777215, R.blendMode = BLEND_MODES$5.NORMAL, R._cachedTint = 16777215, R.uvs = null, R.texture = e || Texture.EMPTY, R.vertexData = new Float32Array(8), R.vertexTrimmedData = null, R._transformID = -1, R._textureID = -1, R._transformTrimmedID = -1, R._textureTrimmedID = -1, R.indices = indices, R.pluginName = "batch", R.isSprite = !0, R._roundPixels = settings$1.ROUND_PIXELS, R;
  }
  return t.prototype._onTextureUpdate = function() {
    this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height);
  }, t.prototype._onAnchorUpdate = function() {
    this._transformID = -1, this._transformTrimmedID = -1;
  }, t.prototype.calculateVertices = function() {
    var e = this._texture;
    if (!(this._transformID === this.transform._worldID && this._textureID === e._updateID)) {
      this._textureID !== e._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = e._updateID;
      var R = this.transform.worldTransform, N = R.a, M = R.b, D = R.c, L = R.d, B = R.tx, $ = R.ty, U = this.vertexData, H = e.trim, z = e.orig, X = this._anchor, Y = 0, W = 0, q = 0, Z = 0;
      if (H ? (W = H.x - X._x * z.width, Y = W + H.width, Z = H.y - X._y * z.height, q = Z + H.height) : (W = -X._x * z.width, Y = W + z.width, Z = -X._y * z.height, q = Z + z.height), U[0] = N * W + D * Z + B, U[1] = L * Z + M * W + $, U[2] = N * Y + D * Z + B, U[3] = L * Z + M * Y + $, U[4] = N * Y + D * q + B, U[5] = L * q + M * Y + $, U[6] = N * W + D * q + B, U[7] = L * q + M * W + $, this._roundPixels)
        for (var K = settings$1.RESOLUTION, J = 0; J < U.length; ++J)
          U[J] = Math.round((U[J] * K | 0) / K);
    }
  }, t.prototype.calculateTrimmedVertices = function() {
    if (!this.vertexTrimmedData)
      this.vertexTrimmedData = new Float32Array(8);
    else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
      return;
    this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
    var e = this._texture, R = this.vertexTrimmedData, N = e.orig, M = this._anchor, D = this.transform.worldTransform, L = D.a, B = D.b, $ = D.c, U = D.d, H = D.tx, z = D.ty, X = -M._x * N.width, Y = X + N.width, W = -M._y * N.height, q = W + N.height;
    R[0] = L * X + $ * W + H, R[1] = U * W + B * X + z, R[2] = L * Y + $ * W + H, R[3] = U * W + B * Y + z, R[4] = L * Y + $ * q + H, R[5] = U * q + B * Y + z, R[6] = L * X + $ * q + H, R[7] = U * q + B * X + z;
  }, t.prototype._render = function(e) {
    this.calculateVertices(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this);
  }, t.prototype._calculateBounds = function() {
    var e = this._texture.trim, R = this._texture.orig;
    !e || e.width === R.width && e.height === R.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
  }, t.prototype.getLocalBounds = function(e) {
    return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Bounds()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds.getRectangle(e)) : o.prototype.getLocalBounds.call(this, e);
  }, t.prototype.containsPoint = function(e) {
    this.worldTransform.applyInverse(e, tempPoint$2);
    var R = this._texture.orig.width, N = this._texture.orig.height, M = -R * this.anchor.x, D = 0;
    return tempPoint$2.x >= M && tempPoint$2.x < M + R && (D = -N * this.anchor.y, tempPoint$2.y >= D && tempPoint$2.y < D + N);
  }, t.prototype.destroy = function(e) {
    o.prototype.destroy.call(this, e), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null;
    var R = typeof e == "boolean" ? e : e && e.texture;
    if (R) {
      var N = typeof e == "boolean" ? e : e && e.baseTexture;
      this._texture.destroy(!!N);
    }
    this._texture = null;
  }, t.from = function(e, R) {
    var N = e instanceof Texture ? e : Texture.from(e, R);
    return new t(N);
  }, Object.defineProperty(t.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    set: function(e) {
      this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "width", {
    get: function() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    },
    set: function(e) {
      var R = sign(this.scale.x) || 1;
      this.scale.x = R * e / this._texture.orig.width, this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    get: function() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    },
    set: function(e) {
      var R = sign(this.scale.y) || 1;
      this.scale.y = R * e / this._texture.orig.height, this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "anchor", {
    get: function() {
      return this._anchor;
    },
    set: function(e) {
      this._anchor.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(e) {
      this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "texture", {
    get: function() {
      return this._texture;
    },
    set: function(e) {
      this._texture !== e && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = e || Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, e && (e.baseTexture.valid ? this._onTextureUpdate() : e.once("update", this._onTextureUpdate, this)));
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Container);
/*!
 * @pixi/text - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/text is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$j = function(o, t) {
  return extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$j(o, t);
};
function __extends$j(o, t) {
  extendStatics$j(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var TEXT_GRADIENT;
(function(o) {
  o[o.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", o[o.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL";
})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));
var defaultStyle = {
  align: "left",
  breakWords: !1,
  dropShadow: !1,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: !1,
  whiteSpace: "pre",
  wordWrap: !1,
  wordWrapWidth: 100,
  leading: 0
}, genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
], TextStyle = function() {
  function o(t) {
    this.styleID = 0, this.reset(), deepCopyProperties(this, t, t);
  }
  return o.prototype.clone = function() {
    var t = {};
    return deepCopyProperties(t, this, defaultStyle), new o(t);
  }, o.prototype.reset = function() {
    deepCopyProperties(this, defaultStyle, defaultStyle);
  }, Object.defineProperty(o.prototype, "align", {
    get: function() {
      return this._align;
    },
    set: function(t) {
      this._align !== t && (this._align = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "breakWords", {
    get: function() {
      return this._breakWords;
    },
    set: function(t) {
      this._breakWords !== t && (this._breakWords = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "dropShadow", {
    get: function() {
      return this._dropShadow;
    },
    set: function(t) {
      this._dropShadow !== t && (this._dropShadow = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "dropShadowAlpha", {
    get: function() {
      return this._dropShadowAlpha;
    },
    set: function(t) {
      this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "dropShadowAngle", {
    get: function() {
      return this._dropShadowAngle;
    },
    set: function(t) {
      this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "dropShadowBlur", {
    get: function() {
      return this._dropShadowBlur;
    },
    set: function(t) {
      this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "dropShadowColor", {
    get: function() {
      return this._dropShadowColor;
    },
    set: function(t) {
      var e = getColor(t);
      this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "dropShadowDistance", {
    get: function() {
      return this._dropShadowDistance;
    },
    set: function(t) {
      this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fill", {
    get: function() {
      return this._fill;
    },
    set: function(t) {
      var e = getColor(t);
      this._fill !== e && (this._fill = e, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fillGradientType", {
    get: function() {
      return this._fillGradientType;
    },
    set: function(t) {
      this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fillGradientStops", {
    get: function() {
      return this._fillGradientStops;
    },
    set: function(t) {
      areArraysEqual(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fontFamily", {
    get: function() {
      return this._fontFamily;
    },
    set: function(t) {
      this.fontFamily !== t && (this._fontFamily = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fontSize", {
    get: function() {
      return this._fontSize;
    },
    set: function(t) {
      this._fontSize !== t && (this._fontSize = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fontStyle", {
    get: function() {
      return this._fontStyle;
    },
    set: function(t) {
      this._fontStyle !== t && (this._fontStyle = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fontVariant", {
    get: function() {
      return this._fontVariant;
    },
    set: function(t) {
      this._fontVariant !== t && (this._fontVariant = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "fontWeight", {
    get: function() {
      return this._fontWeight;
    },
    set: function(t) {
      this._fontWeight !== t && (this._fontWeight = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "letterSpacing", {
    get: function() {
      return this._letterSpacing;
    },
    set: function(t) {
      this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "lineHeight", {
    get: function() {
      return this._lineHeight;
    },
    set: function(t) {
      this._lineHeight !== t && (this._lineHeight = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "leading", {
    get: function() {
      return this._leading;
    },
    set: function(t) {
      this._leading !== t && (this._leading = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "lineJoin", {
    get: function() {
      return this._lineJoin;
    },
    set: function(t) {
      this._lineJoin !== t && (this._lineJoin = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "miterLimit", {
    get: function() {
      return this._miterLimit;
    },
    set: function(t) {
      this._miterLimit !== t && (this._miterLimit = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "padding", {
    get: function() {
      return this._padding;
    },
    set: function(t) {
      this._padding !== t && (this._padding = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "stroke", {
    get: function() {
      return this._stroke;
    },
    set: function(t) {
      var e = getColor(t);
      this._stroke !== e && (this._stroke = e, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "strokeThickness", {
    get: function() {
      return this._strokeThickness;
    },
    set: function(t) {
      this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "textBaseline", {
    get: function() {
      return this._textBaseline;
    },
    set: function(t) {
      this._textBaseline !== t && (this._textBaseline = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "trim", {
    get: function() {
      return this._trim;
    },
    set: function(t) {
      this._trim !== t && (this._trim = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "whiteSpace", {
    get: function() {
      return this._whiteSpace;
    },
    set: function(t) {
      this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "wordWrap", {
    get: function() {
      return this._wordWrap;
    },
    set: function(t) {
      this._wordWrap !== t && (this._wordWrap = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "wordWrapWidth", {
    get: function() {
      return this._wordWrapWidth;
    },
    set: function(t) {
      this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.toFontString = function() {
    var t = typeof this.fontSize == "number" ? this.fontSize + "px" : this.fontSize, e = this.fontFamily;
    Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
    for (var R = e.length - 1; R >= 0; R--) {
      var N = e[R].trim();
      !/([\"\'])[^\'\"]+\1/.test(N) && genericFontFamilies.indexOf(N) < 0 && (N = '"' + N + '"'), e[R] = N;
    }
    return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t + " " + e.join(",");
  }, o;
}();
function getSingleColor(o) {
  return typeof o == "number" ? hex2string(o) : (typeof o == "string" && o.indexOf("0x") === 0 && (o = o.replace("0x", "#")), o);
}
function getColor(o) {
  if (Array.isArray(o)) {
    for (var t = 0; t < o.length; ++t)
      o[t] = getSingleColor(o[t]);
    return o;
  } else
    return getSingleColor(o);
}
function areArraysEqual(o, t) {
  if (!Array.isArray(o) || !Array.isArray(t) || o.length !== t.length)
    return !1;
  for (var e = 0; e < o.length; ++e)
    if (o[e] !== t[e])
      return !1;
  return !0;
}
function deepCopyProperties(o, t, e) {
  for (var R in e)
    Array.isArray(t[R]) ? o[R] = t[R].slice() : o[R] = t[R];
}
var TextMetrics = function() {
  function o(t, e, R, N, M, D, L, B, $) {
    this.text = t, this.style = e, this.width = R, this.height = N, this.lines = M, this.lineWidths = D, this.lineHeight = L, this.maxLineWidth = B, this.fontProperties = $;
  }
  return o.measureText = function(t, e, R, N) {
    N === void 0 && (N = o._canvas), R = R == null ? e.wordWrap : R;
    var M = e.toFontString(), D = o.measureFont(M);
    D.fontSize === 0 && (D.fontSize = e.fontSize, D.ascent = e.fontSize);
    var L = N.getContext("2d");
    L.font = M;
    for (var B = R ? o.wordWrap(t, e, N) : t, $ = B.split(/(?:\r\n|\r|\n)/), U = new Array($.length), H = 0, z = 0; z < $.length; z++) {
      var X = L.measureText($[z]).width + ($[z].length - 1) * e.letterSpacing;
      U[z] = X, H = Math.max(H, X);
    }
    var Y = H + e.strokeThickness;
    e.dropShadow && (Y += e.dropShadowDistance);
    var W = e.lineHeight || D.fontSize + e.strokeThickness, q = Math.max(W, D.fontSize + e.strokeThickness) + ($.length - 1) * (W + e.leading);
    return e.dropShadow && (q += e.dropShadowDistance), new o(t, e, Y, q, $, U, W + e.leading, H, D);
  }, o.wordWrap = function(t, e, R) {
    R === void 0 && (R = o._canvas);
    for (var N = R.getContext("2d"), M = 0, D = "", L = "", B = /* @__PURE__ */ Object.create(null), $ = e.letterSpacing, U = e.whiteSpace, H = o.collapseSpaces(U), z = o.collapseNewlines(U), X = !H, Y = e.wordWrapWidth + $, W = o.tokenize(t), q = 0; q < W.length; q++) {
      var Z = W[q];
      if (o.isNewline(Z)) {
        if (!z) {
          L += o.addLine(D), X = !H, D = "", M = 0;
          continue;
        }
        Z = " ";
      }
      if (H) {
        var K = o.isBreakingSpace(Z), J = o.isBreakingSpace(D[D.length - 1]);
        if (K && J)
          continue;
      }
      var Q = o.getFromCache(Z, $, B, N);
      if (Q > Y)
        if (D !== "" && (L += o.addLine(D), D = "", M = 0), o.canBreakWords(Z, e.breakWords))
          for (var et = o.wordWrapSplit(Z), tt = 0; tt < et.length; tt++) {
            for (var st = et[tt], rt = 1; et[tt + rt]; ) {
              var at = et[tt + rt], ut = st[st.length - 1];
              if (!o.canBreakChars(ut, at, Z, tt, e.breakWords))
                st += at;
              else
                break;
              rt++;
            }
            tt += st.length - 1;
            var dt = o.getFromCache(st, $, B, N);
            dt + M > Y && (L += o.addLine(D), X = !1, D = "", M = 0), D += st, M += dt;
          }
        else {
          D.length > 0 && (L += o.addLine(D), D = "", M = 0);
          var ct = q === W.length - 1;
          L += o.addLine(Z, !ct), X = !1, D = "", M = 0;
        }
      else
        Q + M > Y && (X = !1, L += o.addLine(D), D = "", M = 0), (D.length > 0 || !o.isBreakingSpace(Z) || X) && (D += Z, M += Q);
    }
    return L += o.addLine(D, !1), L;
  }, o.addLine = function(t, e) {
    return e === void 0 && (e = !0), t = o.trimRight(t), t = e ? t + `
` : t, t;
  }, o.getFromCache = function(t, e, R, N) {
    var M = R[t];
    if (typeof M != "number") {
      var D = t.length * e;
      M = N.measureText(t).width + D, R[t] = M;
    }
    return M;
  }, o.collapseSpaces = function(t) {
    return t === "normal" || t === "pre-line";
  }, o.collapseNewlines = function(t) {
    return t === "normal";
  }, o.trimRight = function(t) {
    if (typeof t != "string")
      return "";
    for (var e = t.length - 1; e >= 0; e--) {
      var R = t[e];
      if (!o.isBreakingSpace(R))
        break;
      t = t.slice(0, -1);
    }
    return t;
  }, o.isNewline = function(t) {
    return typeof t != "string" ? !1 : o._newlines.indexOf(t.charCodeAt(0)) >= 0;
  }, o.isBreakingSpace = function(t, e) {
    return typeof t != "string" ? !1 : o._breakingSpaces.indexOf(t.charCodeAt(0)) >= 0;
  }, o.tokenize = function(t) {
    var e = [], R = "";
    if (typeof t != "string")
      return e;
    for (var N = 0; N < t.length; N++) {
      var M = t[N], D = t[N + 1];
      if (o.isBreakingSpace(M, D) || o.isNewline(M)) {
        R !== "" && (e.push(R), R = ""), e.push(M);
        continue;
      }
      R += M;
    }
    return R !== "" && e.push(R), e;
  }, o.canBreakWords = function(t, e) {
    return e;
  }, o.canBreakChars = function(t, e, R, N, M) {
    return !0;
  }, o.wordWrapSplit = function(t) {
    return t.split("");
  }, o.measureFont = function(t) {
    if (o._fonts[t])
      return o._fonts[t];
    var e = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    }, R = o._canvas, N = o._context;
    N.font = t;
    var M = o.METRICS_STRING + o.BASELINE_SYMBOL, D = Math.ceil(N.measureText(M).width), L = Math.ceil(N.measureText(o.BASELINE_SYMBOL).width), B = Math.ceil(o.HEIGHT_MULTIPLIER * L);
    L = L * o.BASELINE_MULTIPLIER | 0, R.width = D, R.height = B, N.fillStyle = "#f00", N.fillRect(0, 0, D, B), N.font = t, N.textBaseline = "alphabetic", N.fillStyle = "#000", N.fillText(M, 0, L);
    var $ = N.getImageData(0, 0, D, B).data, U = $.length, H = D * 4, z = 0, X = 0, Y = !1;
    for (z = 0; z < L; ++z) {
      for (var W = 0; W < H; W += 4)
        if ($[X + W] !== 255) {
          Y = !0;
          break;
        }
      if (!Y)
        X += H;
      else
        break;
    }
    for (e.ascent = L - z, X = U - H, Y = !1, z = B; z > L; --z) {
      for (var W = 0; W < H; W += 4)
        if ($[X + W] !== 255) {
          Y = !0;
          break;
        }
      if (!Y)
        X -= H;
      else
        break;
    }
    return e.descent = z - L, e.fontSize = e.ascent + e.descent, o._fonts[t] = e, e;
  }, o.clearMetrics = function(t) {
    t === void 0 && (t = ""), t ? delete o._fonts[t] : o._fonts = {};
  }, Object.defineProperty(o, "_canvas", {
    get: function() {
      if (!o.__canvas) {
        var t = void 0;
        try {
          var e = new OffscreenCanvas(0, 0), R = e.getContext("2d");
          if (R && R.measureText)
            return o.__canvas = e, e;
          t = settings$1.ADAPTER.createCanvas();
        } catch {
          t = settings$1.ADAPTER.createCanvas();
        }
        t.width = t.height = 10, o.__canvas = t;
      }
      return o.__canvas;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o, "_context", {
    get: function() {
      return o.__context || (o.__context = o._canvas.getContext("2d")), o.__context;
    },
    enumerable: !1,
    configurable: !0
  }), o;
}();
TextMetrics._fonts = {};
TextMetrics.METRICS_STRING = "|\xC9q\xC5";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
var defaultDestroyOptions = {
  texture: !0,
  children: !1,
  baseTexture: !0
}, Text = function(o) {
  __extends$j(t, o);
  function t(e, R, N) {
    var M = this, D = !1;
    N || (N = settings$1.ADAPTER.createCanvas(), D = !0), N.width = 3, N.height = 3;
    var L = Texture.from(N);
    return L.orig = new Rectangle(), L.trim = new Rectangle(), M = o.call(this, L) || this, M._ownCanvas = D, M.canvas = N, M.context = N.getContext("2d"), M._resolution = settings$1.RESOLUTION, M._autoResolution = !0, M._text = null, M._style = null, M._styleListener = null, M._font = "", M.text = e, M.style = R, M.localStyleID = -1, M;
  }
  return t.prototype.updateText = function(e) {
    var R = this._style;
    if (this.localStyleID !== R.styleID && (this.dirty = !0, this.localStyleID = R.styleID), !(!this.dirty && e)) {
      this._font = this._style.toFontString();
      var N = this.context, M = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), D = M.width, L = M.height, B = M.lines, $ = M.lineHeight, U = M.lineWidths, H = M.maxLineWidth, z = M.fontProperties;
      this.canvas.width = Math.ceil(Math.ceil(Math.max(1, D) + R.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, L) + R.padding * 2) * this._resolution), N.scale(this._resolution, this._resolution), N.clearRect(0, 0, this.canvas.width, this.canvas.height), N.font = this._font, N.lineWidth = R.strokeThickness, N.textBaseline = R.textBaseline, N.lineJoin = R.lineJoin, N.miterLimit = R.miterLimit;
      for (var X, Y, W = R.dropShadow ? 2 : 1, q = 0; q < W; ++q) {
        var Z = R.dropShadow && q === 0, K = Z ? Math.ceil(Math.max(1, L) + R.padding * 2) : 0, J = K * this._resolution;
        if (Z) {
          N.fillStyle = "black", N.strokeStyle = "black";
          var Q = R.dropShadowColor, et = hex2rgb(typeof Q == "number" ? Q : string2hex(Q)), tt = R.dropShadowBlur * this._resolution, st = R.dropShadowDistance * this._resolution;
          N.shadowColor = "rgba(" + et[0] * 255 + "," + et[1] * 255 + "," + et[2] * 255 + "," + R.dropShadowAlpha + ")", N.shadowBlur = tt, N.shadowOffsetX = Math.cos(R.dropShadowAngle) * st, N.shadowOffsetY = Math.sin(R.dropShadowAngle) * st + J;
        } else
          N.fillStyle = this._generateFillStyle(R, B, M), N.strokeStyle = R.stroke, N.shadowColor = "black", N.shadowBlur = 0, N.shadowOffsetX = 0, N.shadowOffsetY = 0;
        var rt = ($ - z.fontSize) / 2;
        (!t.nextLineHeightBehavior || $ - z.fontSize < 0) && (rt = 0);
        for (var at = 0; at < B.length; at++)
          X = R.strokeThickness / 2, Y = R.strokeThickness / 2 + at * $ + z.ascent + rt, R.align === "right" ? X += H - U[at] : R.align === "center" && (X += (H - U[at]) / 2), R.stroke && R.strokeThickness && this.drawLetterSpacing(B[at], X + R.padding, Y + R.padding - K, !0), R.fill && this.drawLetterSpacing(B[at], X + R.padding, Y + R.padding - K);
      }
      this.updateTexture();
    }
  }, t.prototype.drawLetterSpacing = function(e, R, N, M) {
    M === void 0 && (M = !1);
    var D = this._style, L = D.letterSpacing, B = t.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
    if (L === 0 || B) {
      B && (this.context.letterSpacing = L, this.context.textLetterSpacing = L), M ? this.context.strokeText(e, R, N) : this.context.fillText(e, R, N);
      return;
    }
    for (var $ = R, U = Array.from ? Array.from(e) : e.split(""), H = this.context.measureText(e).width, z = 0, X = 0; X < U.length; ++X) {
      var Y = U[X];
      M ? this.context.strokeText(Y, $, N) : this.context.fillText(Y, $, N);
      for (var W = "", q = X + 1; q < U.length; ++q)
        W += U[q];
      z = this.context.measureText(W).width, $ += H - z + L, H = z;
    }
  }, t.prototype.updateTexture = function() {
    var e = this.canvas;
    if (this._style.trim) {
      var R = trimCanvas(e);
      R.data && (e.width = R.width, e.height = R.height, this.context.putImageData(R.data, 0, 0));
    }
    var N = this._texture, M = this._style, D = M.trim ? 0 : M.padding, L = N.baseTexture;
    N.trim.width = N._frame.width = e.width / this._resolution, N.trim.height = N._frame.height = e.height / this._resolution, N.trim.x = -D, N.trim.y = -D, N.orig.width = N._frame.width - D * 2, N.orig.height = N._frame.height - D * 2, this._onTextureUpdate(), L.setRealSize(e.width, e.height, this._resolution), N.updateUvs(), this.dirty = !1;
  }, t.prototype._render = function(e) {
    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), o.prototype._render.call(this, e);
  }, t.prototype.updateTransform = function() {
    this.updateText(!0), o.prototype.updateTransform.call(this);
  }, t.prototype.getBounds = function(e, R) {
    return this.updateText(!0), this._textureID === -1 && (e = !1), o.prototype.getBounds.call(this, e, R);
  }, t.prototype.getLocalBounds = function(e) {
    return this.updateText(!0), o.prototype.getLocalBounds.call(this, e);
  }, t.prototype._calculateBounds = function() {
    this.calculateVertices(), this._bounds.addQuad(this.vertexData);
  }, t.prototype._generateFillStyle = function(e, R, N) {
    var M = e.fill;
    if (Array.isArray(M)) {
      if (M.length === 1)
        return M[0];
    } else
      return M;
    var D, L = e.dropShadow ? e.dropShadowDistance : 0, B = e.padding || 0, $ = this.canvas.width / this._resolution - L - B * 2, U = this.canvas.height / this._resolution - L - B * 2, H = M.slice(), z = e.fillGradientStops.slice();
    if (!z.length)
      for (var X = H.length + 1, Y = 1; Y < X; ++Y)
        z.push(Y / X);
    if (H.unshift(M[0]), z.unshift(0), H.push(M[M.length - 1]), z.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      D = this.context.createLinearGradient($ / 2, B, $ / 2, U + B);
      for (var W = N.fontProperties.fontSize + e.strokeThickness, Y = 0; Y < R.length; Y++) {
        var q = N.lineHeight * (Y - 1) + W, Z = N.lineHeight * Y, K = Z;
        Y > 0 && q > Z && (K = (Z + q) / 2);
        var J = Z + W, Q = N.lineHeight * (Y + 1), et = J;
        Y + 1 < R.length && Q < J && (et = (J + Q) / 2);
        for (var tt = (et - K) / U, st = 0; st < H.length; st++) {
          var rt = 0;
          typeof z[st] == "number" ? rt = z[st] : rt = st / H.length;
          var at = Math.min(1, Math.max(0, K / U + rt * tt));
          at = Number(at.toFixed(5)), D.addColorStop(at, H[st]);
        }
      }
    } else {
      D = this.context.createLinearGradient(B, U / 2, $ + B, U / 2);
      for (var ut = H.length + 1, dt = 1, Y = 0; Y < H.length; Y++) {
        var ct = void 0;
        typeof z[Y] == "number" ? ct = z[Y] : ct = dt / ut, D.addColorStop(ct, H[Y]), dt++;
      }
    }
    return D;
  }, t.prototype.destroy = function(e) {
    typeof e == "boolean" && (e = { children: e }), e = Object.assign({}, defaultDestroyOptions, e), o.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;
  }, Object.defineProperty(t.prototype, "width", {
    get: function() {
      return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;
    },
    set: function(e) {
      this.updateText(!0);
      var R = sign(this.scale.x) || 1;
      this.scale.x = R * e / this._texture.orig.width, this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    get: function() {
      return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;
    },
    set: function(e) {
      this.updateText(!0);
      var R = sign(this.scale.y) || 1;
      this.scale.y = R * e / this._texture.orig.height, this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "style", {
    get: function() {
      return this._style;
    },
    set: function(e) {
      e = e || {}, e instanceof TextStyle ? this._style = e : this._style = new TextStyle(e), this.localStyleID = -1, this.dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "text", {
    get: function() {
      return this._text;
    },
    set: function(e) {
      e = String(e == null ? "" : e), this._text !== e && (this._text = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "resolution", {
    get: function() {
      return this._resolution;
    },
    set: function(e) {
      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), t.nextLineHeightBehavior = !1, t.experimentalLetterSpacing = !1, t;
}(Sprite);
/*!
 * @pixi/prepare - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/prepare is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$1.UPLOADS_PER_FRAME = 4;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$i = function(o, t) {
  return extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$i(o, t);
};
function __extends$i(o, t) {
  extendStatics$i(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var CountLimiter = function() {
  function o(t) {
    this.maxItemsPerFrame = t, this.itemsLeft = 0;
  }
  return o.prototype.beginFrame = function() {
    this.itemsLeft = this.maxItemsPerFrame;
  }, o.prototype.allowedToUpload = function() {
    return this.itemsLeft-- > 0;
  }, o;
}();
function findMultipleBaseTextures(o, t) {
  var e = !1;
  if (o && o._textures && o._textures.length) {
    for (var R = 0; R < o._textures.length; R++)
      if (o._textures[R] instanceof Texture) {
        var N = o._textures[R].baseTexture;
        t.indexOf(N) === -1 && (t.push(N), e = !0);
      }
  }
  return e;
}
function findBaseTexture(o, t) {
  if (o.baseTexture instanceof BaseTexture) {
    var e = o.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function findTexture(o, t) {
  if (o._texture && o._texture instanceof Texture) {
    var e = o._texture.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function drawText(o, t) {
  return t instanceof Text ? (t.updateText(!0), !0) : !1;
}
function calculateTextStyle(o, t) {
  if (t instanceof TextStyle) {
    var e = t.toFontString();
    return TextMetrics.measureFont(e), !0;
  }
  return !1;
}
function findText(o, t) {
  if (o instanceof Text) {
    t.indexOf(o.style) === -1 && t.push(o.style), t.indexOf(o) === -1 && t.push(o);
    var e = o._texture.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function findTextStyle(o, t) {
  return o instanceof TextStyle ? (t.indexOf(o) === -1 && t.push(o), !0) : !1;
}
var BasePrepare = function() {
  function o(t) {
    var e = this;
    this.limiter = new CountLimiter(settings$1.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function() {
      !e.queue || e.prepareItems();
    }, this.registerFindHook(findText), this.registerFindHook(findTextStyle), this.registerFindHook(findMultipleBaseTextures), this.registerFindHook(findBaseTexture), this.registerFindHook(findTexture), this.registerUploadHook(drawText), this.registerUploadHook(calculateTextStyle);
  }
  return o.prototype.upload = function(t, e) {
    var R = this;
    return typeof t == "function" && (e = t, t = null), e && deprecation$1("6.5.0", "BasePrepare.upload callback is deprecated, use the return Promise instead."), new Promise(function(N) {
      t && R.add(t);
      var M = function() {
        e == null || e(), N();
      };
      R.queue.length ? (R.completes.push(M), R.ticking || (R.ticking = !0, Ticker.system.addOnce(R.tick, R, UPDATE_PRIORITY.UTILITY))) : M();
    });
  }, o.prototype.tick = function() {
    setTimeout(this.delayedTick, 0);
  }, o.prototype.prepareItems = function() {
    for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
      var t = this.queue[0], e = !1;
      if (t && !t._destroyed) {
        for (var R = 0, N = this.uploadHooks.length; R < N; R++)
          if (this.uploadHooks[R](this.uploadHookHelper, t)) {
            this.queue.shift(), e = !0;
            break;
          }
      }
      e || this.queue.shift();
    }
    if (this.queue.length)
      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
    else {
      this.ticking = !1;
      var M = this.completes.slice(0);
      this.completes.length = 0;
      for (var R = 0, N = M.length; R < N; R++)
        M[R]();
    }
  }, o.prototype.registerFindHook = function(t) {
    return t && this.addHooks.push(t), this;
  }, o.prototype.registerUploadHook = function(t) {
    return t && this.uploadHooks.push(t), this;
  }, o.prototype.add = function(t) {
    for (var e = 0, R = this.addHooks.length; e < R && !this.addHooks[e](t, this.queue); e++)
      ;
    if (t instanceof Container)
      for (var e = t.children.length - 1; e >= 0; e--)
        this.add(t.children[e]);
    return this;
  }, o.prototype.destroy = function() {
    this.ticking && Ticker.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;
  }, o;
}();
function uploadBaseTextures(o, t) {
  return t instanceof BaseTexture ? (t._glTextures[o.CONTEXT_UID] || o.texture.bind(t), !0) : !1;
}
function uploadGraphics(o, t) {
  if (!(t instanceof Graphics))
    return !1;
  var e = t.geometry;
  t.finishPoly(), e.updateBatches();
  for (var R = e.batches, N = 0; N < R.length; N++) {
    var M = R[N].style.texture;
    M && uploadBaseTextures(o, M.baseTexture);
  }
  return e.batchable || o.geometry.bind(e, t._resolveDirectShader(o)), !0;
}
function findGraphics(o, t) {
  return o instanceof Graphics ? (t.push(o), !0) : !1;
}
var Prepare = function(o) {
  __extends$i(t, o);
  function t(e) {
    var R = o.call(this, e) || this;
    return R.uploadHookHelper = R.renderer, R.registerFindHook(findGraphics), R.registerUploadHook(uploadBaseTextures), R.registerUploadHook(uploadGraphics), R;
  }
  return t.extension = {
    name: "prepare",
    type: ExtensionType.RendererPlugin
  }, t;
}(BasePrepare);
/*!
 * @pixi/spritesheet - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/spritesheet is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Spritesheet = function() {
  function o(t, e, R) {
    R === void 0 && (R = null), this.linkedSheets = [], this._texture = t instanceof Texture ? t : null, this.baseTexture = t instanceof BaseTexture ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;
    var N = this.baseTexture.resource;
    this.resolution = this._updateResolution(R || (N ? N.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
  }
  return o.prototype._updateResolution = function(t) {
    t === void 0 && (t = null);
    var e = this.data.meta.scale, R = getResolutionOfUrl(t, null);
    return R === null && (R = e !== void 0 ? parseFloat(e) : 1), R !== 1 && this.baseTexture.setResolution(R), R;
  }, o.prototype.parse = function(t) {
    var e = this;
    return t && deprecation$1("6.5.0", "Spritesheet.parse callback is deprecated, use the return Promise instead."), new Promise(function(R) {
      e._callback = function(N) {
        t == null || t(N), R(N);
      }, e._batchIndex = 0, e._frameKeys.length <= o.BATCH_SIZE ? (e._processFrames(0), e._processAnimations(), e._parseComplete()) : e._nextBatch();
    });
  }, o.prototype._processFrames = function(t) {
    for (var e = t, R = o.BATCH_SIZE; e - t < R && e < this._frameKeys.length; ) {
      var N = this._frameKeys[e], M = this._frames[N], D = M.frame;
      if (D) {
        var L = null, B = null, $ = M.trimmed !== !1 && M.sourceSize ? M.sourceSize : M.frame, U = new Rectangle(0, 0, Math.floor($.w) / this.resolution, Math.floor($.h) / this.resolution);
        M.rotated ? L = new Rectangle(Math.floor(D.x) / this.resolution, Math.floor(D.y) / this.resolution, Math.floor(D.h) / this.resolution, Math.floor(D.w) / this.resolution) : L = new Rectangle(Math.floor(D.x) / this.resolution, Math.floor(D.y) / this.resolution, Math.floor(D.w) / this.resolution, Math.floor(D.h) / this.resolution), M.trimmed !== !1 && M.spriteSourceSize && (B = new Rectangle(Math.floor(M.spriteSourceSize.x) / this.resolution, Math.floor(M.spriteSourceSize.y) / this.resolution, Math.floor(D.w) / this.resolution, Math.floor(D.h) / this.resolution)), this.textures[N] = new Texture(this.baseTexture, L, U, B, M.rotated ? 2 : 0, M.anchor), Texture.addToCache(this.textures[N], N);
      }
      e++;
    }
  }, o.prototype._processAnimations = function() {
    var t = this.data.animations || {};
    for (var e in t) {
      this.animations[e] = [];
      for (var R = 0; R < t[e].length; R++) {
        var N = t[e][R];
        this.animations[e].push(this.textures[N]);
      }
    }
  }, o.prototype._parseComplete = function() {
    var t = this._callback;
    this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
  }, o.prototype._nextBatch = function() {
    var t = this;
    this._processFrames(this._batchIndex * o.BATCH_SIZE), this._batchIndex++, setTimeout(function() {
      t._batchIndex * o.BATCH_SIZE < t._frameKeys.length ? t._nextBatch() : (t._processAnimations(), t._parseComplete());
    }, 0);
  }, o.prototype.destroy = function(t) {
    var e;
    t === void 0 && (t = !1);
    for (var R in this.textures)
      this.textures[R].destroy();
    this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) === null || e === void 0 || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];
  }, o.BATCH_SIZE = 1e3, o;
}(), SpritesheetLoader = function() {
  function o() {
  }
  return o.use = function(t, e) {
    var R, N, M = this, D = t.name + "_image";
    if (!t.data || t.type !== LoaderResource.TYPE.JSON || !t.data.frames || M.resources[D]) {
      e();
      return;
    }
    var L = (N = (R = t.data) === null || R === void 0 ? void 0 : R.meta) === null || N === void 0 ? void 0 : N.related_multi_packs;
    if (Array.isArray(L))
      for (var B = function(Y) {
        if (typeof Y != "string")
          return "continue";
        var W = Y.replace(".json", ""), q = url$1.resolve(t.url.replace(M.baseUrl, ""), Y);
        if (M.resources[W] || Object.values(M.resources).some(function(K) {
          return url$1.format(url$1.parse(K.url)) === q;
        }))
          return "continue";
        var Z = {
          crossOrigin: t.crossOrigin,
          loadType: LoaderResource.LOAD_TYPE.XHR,
          xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,
          parentResource: t,
          metadata: t.metadata
        };
        M.add(W, q, Z);
      }, $ = 0, U = L; $ < U.length; $++) {
        var H = U[$];
        B(H);
      }
    var z = {
      crossOrigin: t.crossOrigin,
      metadata: t.metadata.imageMetadata,
      parentResource: t
    }, X = o.getResourcePath(t, M.baseUrl);
    M.add(D, X, z, function(W) {
      if (W.error) {
        e(W.error);
        return;
      }
      var q = new Spritesheet(W.texture, t.data, t.url);
      q.parse().then(function() {
        t.spritesheet = q, t.textures = q.textures, e();
      });
    });
  }, o.getResourcePath = function(t, e) {
    return t.isDataUrl ? t.data.meta.image : url$1.resolve(t.url.replace(e, ""), t.data.meta.image);
  }, o.extension = ExtensionType.Loader, o;
}();
/*!
 * @pixi/sprite-tiling - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$h = function(o, t) {
  return extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$h(o, t);
};
function __extends$h(o, t) {
  extendStatics$h(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var tempPoint$1 = new Point();
(function(o) {
  __extends$h(t, o);
  function t(e, R, N) {
    R === void 0 && (R = 100), N === void 0 && (N = 100);
    var M = o.call(this, e) || this;
    return M.tileTransform = new Transform(), M._width = R, M._height = N, M.uvMatrix = M.texture.uvMatrix || new TextureMatrix(e), M.pluginName = "tilingSprite", M.uvRespectAnchor = !1, M;
  }
  return Object.defineProperty(t.prototype, "clampMargin", {
    get: function() {
      return this.uvMatrix.clampMargin;
    },
    set: function(e) {
      this.uvMatrix.clampMargin = e, this.uvMatrix.update(!0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tileScale", {
    get: function() {
      return this.tileTransform.scale;
    },
    set: function(e) {
      this.tileTransform.scale.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tilePosition", {
    get: function() {
      return this.tileTransform.position;
    },
    set: function(e) {
      this.tileTransform.position.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._onTextureUpdate = function() {
    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;
  }, t.prototype._render = function(e) {
    var R = this._texture;
    !R || !R.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this));
  }, t.prototype._calculateBounds = function() {
    var e = this._width * -this._anchor._x, R = this._height * -this._anchor._y, N = this._width * (1 - this._anchor._x), M = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, e, R, N, M);
  }, t.prototype.getLocalBounds = function(e) {
    return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._bounds.getRectangle(e)) : o.prototype.getLocalBounds.call(this, e);
  }, t.prototype.containsPoint = function(e) {
    this.worldTransform.applyInverse(e, tempPoint$1);
    var R = this._width, N = this._height, M = -R * this.anchor._x;
    if (tempPoint$1.x >= M && tempPoint$1.x < M + R) {
      var D = -N * this.anchor._y;
      if (tempPoint$1.y >= D && tempPoint$1.y < D + N)
        return !0;
    }
    return !1;
  }, t.prototype.destroy = function(e) {
    o.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null;
  }, t.from = function(e, R) {
    var N = e instanceof Texture ? e : Texture.from(e, R);
    return new t(N, R.width, R.height);
  }, Object.defineProperty(t.prototype, "width", {
    get: function() {
      return this._width;
    },
    set: function(e) {
      this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    get: function() {
      return this._height;
    },
    set: function(e) {
      this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Sprite);
var fragmentSimpleSrc = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`, gl1VertexSrc = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, gl1FragmentSrc = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`, gl2VertexSrc = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, gl2FragmentSrc = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`, tempMat = new Matrix(), TilingSpriteRenderer = function(o) {
  __extends$h(t, o);
  function t(e) {
    var R = o.call(this, e) || this;
    return e.runners.contextChange.add(R), R.quad = new QuadUv(), R.state = State.for2d(), R;
  }
  return t.prototype.contextChange = function() {
    var e = this.renderer, R = { globals: e.globalUniforms };
    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, R), this.shader = e.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, R) : Shader.from(gl1VertexSrc, gl1FragmentSrc, R);
  }, t.prototype.render = function(e) {
    var R = this.renderer, N = this.quad, M = N.vertices;
    M[0] = M[6] = e._width * -e.anchor.x, M[1] = M[3] = e._height * -e.anchor.y, M[2] = M[4] = e._width * (1 - e.anchor.x), M[5] = M[7] = e._height * (1 - e.anchor.y);
    var D = e.uvRespectAnchor ? e.anchor.x : 0, L = e.uvRespectAnchor ? e.anchor.y : 0;
    M = N.uvs, M[0] = M[6] = -D, M[1] = M[3] = -L, M[2] = M[4] = 1 - D, M[5] = M[7] = 1 - L, N.invalidate();
    var B = e._texture, $ = B.baseTexture, U = $.alphaMode > 0, H = e.tileTransform.localTransform, z = e.uvMatrix, X = $.isPowerOfTwo && B.frame.width === $.width && B.frame.height === $.height;
    X && ($._glTextures[R.CONTEXT_UID] ? X = $.wrapMode !== WRAP_MODES$5.CLAMP : $.wrapMode === WRAP_MODES$5.CLAMP && ($.wrapMode = WRAP_MODES$5.REPEAT));
    var Y = X ? this.simpleShader : this.shader, W = B.width, q = B.height, Z = e._width, K = e._height;
    tempMat.set(H.a * W / Z, H.b * W / K, H.c * q / Z, H.d * q / K, H.tx / Z, H.ty / K), tempMat.invert(), X ? tempMat.prepend(z.mapCoord) : (Y.uniforms.uMapCoord = z.mapCoord.toArray(!0), Y.uniforms.uClampFrame = z.uClampFrame, Y.uniforms.uClampOffset = z.uClampOffset), Y.uniforms.uTransform = tempMat.toArray(!0), Y.uniforms.uColor = premultiplyTintToRgba(e.tint, e.worldAlpha, Y.uniforms.uColor, U), Y.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0), Y.uniforms.uSampler = B, R.shader.bind(Y), R.geometry.bind(N), this.state.blendMode = correctBlendMode(e.blendMode, U), R.state.set(this.state), R.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
  }, t.extension = {
    name: "tilingSprite",
    type: ExtensionType.RendererPlugin
  }, t;
}(ObjectRenderer);
/*!
 * @pixi/mesh - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/mesh is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$g = function(o, t) {
  return extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$g(o, t);
};
function __extends$g(o, t) {
  extendStatics$g(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var MeshBatchUvs = function() {
  function o(t, e) {
    this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;
  }
  return o.prototype.update = function(t) {
    if (!(!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)) {
      this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
      var e = this.uvBuffer.data;
      (!this.data || this.data.length !== e.length) && (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++;
    }
  }, o;
}(), tempPoint = new Point(), tempPolygon = new Polygon(), Mesh = function(o) {
  __extends$g(t, o);
  function t(e, R, N, M) {
    M === void 0 && (M = DRAW_MODES$5.TRIANGLES);
    var D = o.call(this) || this;
    return D.geometry = e, D.shader = R, D.state = N || State.for2d(), D.drawMode = M, D.start = 0, D.size = 0, D.uvs = null, D.indices = null, D.vertexData = new Float32Array(1), D.vertexDirty = -1, D._transformID = -1, D._roundPixels = settings$1.ROUND_PIXELS, D.batchUvs = null, D;
  }
  return Object.defineProperty(t.prototype, "geometry", {
    get: function() {
      return this._geometry;
    },
    set: function(e) {
      this._geometry !== e && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "uvBuffer", {
    get: function() {
      return this.geometry.buffers[1];
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "verticesBuffer", {
    get: function() {
      return this.geometry.buffers[0];
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "material", {
    get: function() {
      return this.shader;
    },
    set: function(e) {
      this.shader = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(e) {
      this.state.blendMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    set: function(e) {
      this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tint", {
    get: function() {
      return "tint" in this.shader ? this.shader.tint : null;
    },
    set: function(e) {
      this.shader.tint = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "texture", {
    get: function() {
      return "texture" in this.shader ? this.shader.texture : null;
    },
    set: function(e) {
      this.shader.texture = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._render = function(e) {
    var R = this.geometry.buffers[0].data, N = this.shader;
    N.batchable && this.drawMode === DRAW_MODES$5.TRIANGLES && R.length < t.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e);
  }, t.prototype._renderDefault = function(e) {
    var R = this.shader;
    R.alpha = this.worldAlpha, R.update && R.update(), e.batch.flush(), R.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(R), e.state.set(this.state), e.geometry.bind(this.geometry, R), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  }, t.prototype._renderToBatch = function(e) {
    var R = this.geometry, N = this.shader;
    N.uvMatrix && (N.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = R.indexBuffer.data, this._tintRGB = N._tintRGB, this._texture = N.texture;
    var M = this.material.pluginName;
    e.batch.setObjectRenderer(e.plugins[M]), e.plugins[M].render(this);
  }, t.prototype.calculateVertices = function() {
    var e = this.geometry, R = e.buffers[0], N = R.data, M = R._updateID;
    if (!(M === this.vertexDirty && this._transformID === this.transform._worldID)) {
      this._transformID = this.transform._worldID, this.vertexData.length !== N.length && (this.vertexData = new Float32Array(N.length));
      for (var D = this.transform.worldTransform, L = D.a, B = D.b, $ = D.c, U = D.d, H = D.tx, z = D.ty, X = this.vertexData, Y = 0; Y < X.length / 2; Y++) {
        var W = N[Y * 2], q = N[Y * 2 + 1];
        X[Y * 2] = L * W + $ * q + H, X[Y * 2 + 1] = B * W + U * q + z;
      }
      if (this._roundPixels)
        for (var Z = settings$1.RESOLUTION, Y = 0; Y < X.length; ++Y)
          X[Y] = Math.round((X[Y] * Z | 0) / Z);
      this.vertexDirty = M;
    }
  }, t.prototype.calculateUvs = function() {
    var e = this.geometry.buffers[1], R = this.shader;
    R.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs(e, R.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);
  }, t.prototype._calculateBounds = function() {
    this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  }, t.prototype.containsPoint = function(e) {
    if (!this.getBounds().contains(e.x, e.y))
      return !1;
    this.worldTransform.applyInverse(e, tempPoint);
    for (var R = this.geometry.getBuffer("aVertexPosition").data, N = tempPolygon.points, M = this.geometry.getIndex().data, D = M.length, L = this.drawMode === 4 ? 3 : 1, B = 0; B + 2 < D; B += L) {
      var $ = M[B] * 2, U = M[B + 1] * 2, H = M[B + 2] * 2;
      if (N[0] = R[$], N[1] = R[$ + 1], N[2] = R[U], N[3] = R[U + 1], N[4] = R[H], N[5] = R[H + 1], tempPolygon.contains(tempPoint.x, tempPoint.y))
        return !0;
    }
    return !1;
  }, t.prototype.destroy = function(e) {
    o.prototype.destroy.call(this, e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;
  }, t.BATCHABLE_SIZE = 100, t;
}(Container), fragment$5 = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`, vertex$2 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`, MeshMaterial = function(o) {
  __extends$g(t, o);
  function t(e, R) {
    var N = this, M = {
      uSampler: e,
      alpha: 1,
      uTextureMatrix: Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    return R = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, R), R.uniforms && Object.assign(M, R.uniforms), N = o.call(this, R.program || Program.from(vertex$2, fragment$5), M) || this, N._colorDirty = !1, N.uvMatrix = new TextureMatrix(e), N.batchable = R.program === void 0, N.pluginName = R.pluginName, N.tint = R.tint, N.alpha = R.alpha, N;
  }
  return Object.defineProperty(t.prototype, "texture", {
    get: function() {
      return this.uniforms.uSampler;
    },
    set: function(e) {
      this.uniforms.uSampler !== e && (!this.uniforms.uSampler.baseTexture.alphaMode != !e.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = e, this.uvMatrix.texture = e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "alpha", {
    get: function() {
      return this._alpha;
    },
    set: function(e) {
      e !== this._alpha && (this._alpha = e, this._colorDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(e) {
      e !== this._tint && (this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16), this._colorDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.update = function() {
    if (this._colorDirty) {
      this._colorDirty = !1;
      var e = this.texture.baseTexture;
      premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, e.alphaMode);
    }
    this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
  }, t;
}(Shader), MeshGeometry = function(o) {
  __extends$g(t, o);
  function t(e, R, N) {
    var M = o.call(this) || this, D = new Buffer$1(e), L = new Buffer$1(R, !0), B = new Buffer$1(N, !0, !0);
    return M.addAttribute("aVertexPosition", D, 2, !1, TYPES$5.FLOAT).addAttribute("aTextureCoord", L, 2, !1, TYPES$5.FLOAT).addIndex(B), M._updateId = -1, M;
  }
  return Object.defineProperty(t.prototype, "vertexDirtyId", {
    get: function() {
      return this.buffers[0]._updateID;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Geometry);
/*!
 * @pixi/text-bitmap - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/text-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$f = function(o, t) {
  return extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$f(o, t);
};
function __extends$f(o, t) {
  extendStatics$f(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var BitmapFontData = function() {
  function o() {
    this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];
  }
  return o;
}(), TextFormat = function() {
  function o() {
  }
  return o.test = function(t) {
    return typeof t == "string" && t.indexOf("info face=") === 0;
  }, o.parse = function(t) {
    var e = t.match(/^[a-z]+\s+.+$/gm), R = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (var N in e) {
      var M = e[N].match(/^[a-z]+/gm)[0], D = e[N].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), L = {};
      for (var B in D) {
        var $ = D[B].split("="), U = $[0], H = $[1].replace(/"/gm, ""), z = parseFloat(H), X = isNaN(z) ? H : z;
        L[U] = X;
      }
      R[M].push(L);
    }
    var Y = new BitmapFontData();
    return R.info.forEach(function(W) {
      return Y.info.push({
        face: W.face,
        size: parseInt(W.size, 10)
      });
    }), R.common.forEach(function(W) {
      return Y.common.push({
        lineHeight: parseInt(W.lineHeight, 10)
      });
    }), R.page.forEach(function(W) {
      return Y.page.push({
        id: parseInt(W.id, 10),
        file: W.file
      });
    }), R.char.forEach(function(W) {
      return Y.char.push({
        id: parseInt(W.id, 10),
        page: parseInt(W.page, 10),
        x: parseInt(W.x, 10),
        y: parseInt(W.y, 10),
        width: parseInt(W.width, 10),
        height: parseInt(W.height, 10),
        xoffset: parseInt(W.xoffset, 10),
        yoffset: parseInt(W.yoffset, 10),
        xadvance: parseInt(W.xadvance, 10)
      });
    }), R.kerning.forEach(function(W) {
      return Y.kerning.push({
        first: parseInt(W.first, 10),
        second: parseInt(W.second, 10),
        amount: parseInt(W.amount, 10)
      });
    }), R.distanceField.forEach(function(W) {
      return Y.distanceField.push({
        distanceRange: parseInt(W.distanceRange, 10),
        fieldType: W.fieldType
      });
    }), Y;
  }, o;
}(), XMLFormat = function() {
  function o() {
  }
  return o.test = function(t) {
    return t instanceof XMLDocument && t.getElementsByTagName("page").length && t.getElementsByTagName("info")[0].getAttribute("face") !== null;
  }, o.parse = function(t) {
    for (var e = new BitmapFontData(), R = t.getElementsByTagName("info"), N = t.getElementsByTagName("common"), M = t.getElementsByTagName("page"), D = t.getElementsByTagName("char"), L = t.getElementsByTagName("kerning"), B = t.getElementsByTagName("distanceField"), $ = 0; $ < R.length; $++)
      e.info.push({
        face: R[$].getAttribute("face"),
        size: parseInt(R[$].getAttribute("size"), 10)
      });
    for (var $ = 0; $ < N.length; $++)
      e.common.push({
        lineHeight: parseInt(N[$].getAttribute("lineHeight"), 10)
      });
    for (var $ = 0; $ < M.length; $++)
      e.page.push({
        id: parseInt(M[$].getAttribute("id"), 10) || 0,
        file: M[$].getAttribute("file")
      });
    for (var $ = 0; $ < D.length; $++) {
      var U = D[$];
      e.char.push({
        id: parseInt(U.getAttribute("id"), 10),
        page: parseInt(U.getAttribute("page"), 10) || 0,
        x: parseInt(U.getAttribute("x"), 10),
        y: parseInt(U.getAttribute("y"), 10),
        width: parseInt(U.getAttribute("width"), 10),
        height: parseInt(U.getAttribute("height"), 10),
        xoffset: parseInt(U.getAttribute("xoffset"), 10),
        yoffset: parseInt(U.getAttribute("yoffset"), 10),
        xadvance: parseInt(U.getAttribute("xadvance"), 10)
      });
    }
    for (var $ = 0; $ < L.length; $++)
      e.kerning.push({
        first: parseInt(L[$].getAttribute("first"), 10),
        second: parseInt(L[$].getAttribute("second"), 10),
        amount: parseInt(L[$].getAttribute("amount"), 10)
      });
    for (var $ = 0; $ < B.length; $++)
      e.distanceField.push({
        fieldType: B[$].getAttribute("fieldType"),
        distanceRange: parseInt(B[$].getAttribute("distanceRange"), 10)
      });
    return e;
  }, o;
}(), XMLStringFormat = function() {
  function o() {
  }
  return o.test = function(t) {
    if (typeof t == "string" && t.indexOf("<font>") > -1) {
      var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
      return XMLFormat.test(e);
    }
    return !1;
  }, o.parse = function(t) {
    var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
    return XMLFormat.parse(e);
  }, o;
}(), formats = [
  TextFormat,
  XMLFormat,
  XMLStringFormat
];
function autoDetectFormat(o) {
  for (var t = 0; t < formats.length; t++)
    if (formats[t].test(o))
      return formats[t];
  return null;
}
function generateFillStyle(o, t, e, R, N, M) {
  var D = e.fill;
  if (Array.isArray(D)) {
    if (D.length === 1)
      return D[0];
  } else
    return D;
  var L, B = e.dropShadow ? e.dropShadowDistance : 0, $ = e.padding || 0, U = o.width / R - B - $ * 2, H = o.height / R - B - $ * 2, z = D.slice(), X = e.fillGradientStops.slice();
  if (!X.length)
    for (var Y = z.length + 1, W = 1; W < Y; ++W)
      X.push(W / Y);
  if (z.unshift(D[0]), X.unshift(0), z.push(D[D.length - 1]), X.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    L = t.createLinearGradient(U / 2, $, U / 2, H + $);
    for (var q = 0, Z = M.fontProperties.fontSize + e.strokeThickness, K = Z / H, W = 0; W < N.length; W++)
      for (var J = M.lineHeight * W, Q = 0; Q < z.length; Q++) {
        var et = 0;
        typeof X[Q] == "number" ? et = X[Q] : et = Q / z.length;
        var tt = J / H + et * K, st = Math.max(q, tt);
        st = Math.min(st, 1), L.addColorStop(st, z[Q]), q = st;
      }
  } else {
    L = t.createLinearGradient($, H / 2, U + $, H / 2);
    for (var rt = z.length + 1, at = 1, W = 0; W < z.length; W++) {
      var ut = void 0;
      typeof X[W] == "number" ? ut = X[W] : ut = at / rt, L.addColorStop(ut, z[W]), at++;
    }
  }
  return L;
}
function drawGlyph(o, t, e, R, N, M, D) {
  var L = e.text, B = e.fontProperties;
  t.translate(R, N), t.scale(M, M);
  var $ = D.strokeThickness / 2, U = -(D.strokeThickness / 2);
  if (t.font = D.toFontString(), t.lineWidth = D.strokeThickness, t.textBaseline = D.textBaseline, t.lineJoin = D.lineJoin, t.miterLimit = D.miterLimit, t.fillStyle = generateFillStyle(o, t, D, M, [L], e), t.strokeStyle = D.stroke, D.dropShadow) {
    var H = D.dropShadowColor, z = hex2rgb(typeof H == "number" ? H : string2hex(H)), X = D.dropShadowBlur * M, Y = D.dropShadowDistance * M;
    t.shadowColor = "rgba(" + z[0] * 255 + "," + z[1] * 255 + "," + z[2] * 255 + "," + D.dropShadowAlpha + ")", t.shadowBlur = X, t.shadowOffsetX = Math.cos(D.dropShadowAngle) * Y, t.shadowOffsetY = Math.sin(D.dropShadowAngle) * Y;
  } else
    t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
  D.stroke && D.strokeThickness && t.strokeText(L, $, U + e.lineHeight - B.descent), D.fill && t.fillText(L, $, U + e.lineHeight - B.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = "rgba(0, 0, 0, 0)";
}
function splitTextToCharacters(o) {
  return Array.from ? Array.from(o) : o.split("");
}
function resolveCharacters(o) {
  typeof o == "string" && (o = [o]);
  for (var t = [], e = 0, R = o.length; e < R; e++) {
    var N = o[e];
    if (Array.isArray(N)) {
      if (N.length !== 2)
        throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + N.length + ".");
      var M = N[0].charCodeAt(0), D = N[1].charCodeAt(0);
      if (D < M)
        throw new Error("[BitmapFont]: Invalid character range.");
      for (var L = M, B = D; L <= B; L++)
        t.push(String.fromCharCode(L));
    } else
      t.push.apply(t, splitTextToCharacters(N));
  }
  if (t.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return t;
}
function extractCharCode(o) {
  return o.codePointAt ? o.codePointAt(0) : o.charCodeAt(0);
}
var BitmapFont = function() {
  function o(t, e, R) {
    var N, M, D = t.info[0], L = t.common[0], B = t.page[0], $ = t.distanceField[0], U = getResolutionOfUrl(B.file), H = {};
    this._ownsTextures = R, this.font = D.face, this.size = D.size, this.lineHeight = L.lineHeight / U, this.chars = {}, this.pageTextures = H;
    for (var z = 0; z < t.page.length; z++) {
      var X = t.page[z], Y = X.id, W = X.file;
      H[Y] = e instanceof Array ? e[z] : e[W], ($ == null ? void 0 : $.fieldType) && $.fieldType !== "none" && (H[Y].baseTexture.alphaMode = ALPHA_MODES$5.NO_PREMULTIPLIED_ALPHA);
    }
    for (var z = 0; z < t.char.length; z++) {
      var q = t.char[z], Y = q.id, Z = q.page, K = t.char[z], J = K.x, Q = K.y, et = K.width, tt = K.height, st = K.xoffset, rt = K.yoffset, at = K.xadvance;
      J /= U, Q /= U, et /= U, tt /= U, st /= U, rt /= U, at /= U;
      var ut = new Rectangle(J + H[Z].frame.x / U, Q + H[Z].frame.y / U, et, tt);
      this.chars[Y] = {
        xOffset: st,
        yOffset: rt,
        xAdvance: at,
        kerning: {},
        texture: new Texture(H[Z].baseTexture, ut),
        page: Z
      };
    }
    for (var z = 0; z < t.kerning.length; z++) {
      var dt = t.kerning[z], ct = dt.first, pt = dt.second, mt = dt.amount;
      ct /= U, pt /= U, mt /= U, this.chars[pt] && (this.chars[pt].kerning[ct] = mt);
    }
    this.distanceFieldRange = $ == null ? void 0 : $.distanceRange, this.distanceFieldType = (M = (N = $ == null ? void 0 : $.fieldType) === null || N === void 0 ? void 0 : N.toLowerCase()) !== null && M !== void 0 ? M : "none";
  }
  return o.prototype.destroy = function() {
    for (var t in this.chars)
      this.chars[t].texture.destroy(), this.chars[t].texture = null;
    for (var t in this.pageTextures)
      this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;
    this.chars = null, this.pageTextures = null;
  }, o.install = function(t, e, R) {
    var N;
    if (t instanceof BitmapFontData)
      N = t;
    else {
      var M = autoDetectFormat(t);
      if (!M)
        throw new Error("Unrecognized data format for font.");
      N = M.parse(t);
    }
    e instanceof Texture && (e = [e]);
    var D = new o(N, e, R);
    return o.available[D.font] = D, D;
  }, o.uninstall = function(t) {
    var e = o.available[t];
    if (!e)
      throw new Error("No font found named '" + t + "'");
    e.destroy(), delete o.available[t];
  }, o.from = function(t, e, R) {
    if (!t)
      throw new Error("[BitmapFont] Property `name` is required.");
    var N = Object.assign({}, o.defaultOptions, R), M = N.chars, D = N.padding, L = N.resolution, B = N.textureWidth, $ = N.textureHeight, U = resolveCharacters(M), H = e instanceof TextStyle ? e : new TextStyle(e), z = B, X = new BitmapFontData();
    X.info[0] = {
      face: H.fontFamily,
      size: H.fontSize
    }, X.common[0] = {
      lineHeight: H.fontSize
    };
    for (var Y = 0, W = 0, q, Z, K, J = 0, Q = [], et = 0; et < U.length; et++) {
      q || (q = settings$1.ADAPTER.createCanvas(), q.width = B, q.height = $, Z = q.getContext("2d"), K = new BaseTexture(q, { resolution: L }), Q.push(new Texture(K)), X.page.push({
        id: Q.length - 1,
        file: ""
      }));
      var tt = TextMetrics.measureText(U[et], H, !1, q), st = tt.width, rt = Math.ceil(tt.height), at = Math.ceil((H.fontStyle === "italic" ? 2 : 1) * st);
      if (W >= $ - rt * L) {
        if (W === 0)
          throw new Error("[BitmapFont] textureHeight " + $ + "px is " + ("too small for " + H.fontSize + "px fonts"));
        --et, q = null, Z = null, K = null, W = 0, Y = 0, J = 0;
        continue;
      }
      if (J = Math.max(rt + tt.fontProperties.descent, J), at * L + Y >= z) {
        --et, W += J * L, W = Math.ceil(W), Y = 0, J = 0;
        continue;
      }
      drawGlyph(q, Z, tt, Y, W, L, H);
      var ut = extractCharCode(tt.text);
      X.char.push({
        id: ut,
        page: Q.length - 1,
        x: Y / L,
        y: W / L,
        width: at,
        height: rt,
        xoffset: 0,
        yoffset: 0,
        xadvance: Math.ceil(st - (H.dropShadow ? H.dropShadowDistance : 0) - (H.stroke ? H.strokeThickness : 0))
      }), Y += (at + 2 * D) * L, Y = Math.ceil(Y);
    }
    for (var et = 0, dt = U.length; et < dt; et++)
      for (var ct = U[et], pt = 0; pt < dt; pt++) {
        var mt = U[pt], vt = Z.measureText(ct).width, _t = Z.measureText(mt).width, xt = Z.measureText(ct + mt).width, At = xt - (vt + _t);
        At && X.kerning.push({
          first: extractCharCode(ct),
          second: extractCharCode(mt),
          amount: At
        });
      }
    var yt = new o(X, Q, !0);
    return o.available[t] !== void 0 && o.uninstall(t), o.available[t] = yt, yt;
  }, o.ALPHA = [["a", "z"], ["A", "Z"], " "], o.NUMERIC = [["0", "9"]], o.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], o.ASCII = [[" ", "~"]], o.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: o.ALPHANUMERIC
  }, o.available = {}, o;
}(), msdfFrag = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r
\r
}\r
`, msdfVert = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`, pageMeshDataDefaultPageMeshData = [], pageMeshDataMSDFPageMeshData = [], charRenderDataPool = [];
(function(o) {
  __extends$f(t, o);
  function t(e, R) {
    R === void 0 && (R = {});
    var N = o.call(this) || this;
    N._tint = 16777215;
    var M = Object.assign({}, t.styleDefaults, R), D = M.align, L = M.tint, B = M.maxWidth, $ = M.letterSpacing, U = M.fontName, H = M.fontSize;
    if (!BitmapFont.available[U])
      throw new Error('Missing BitmapFont "' + U + '"');
    return N._activePagesMeshData = [], N._textWidth = 0, N._textHeight = 0, N._align = D, N._tint = L, N._fontName = U, N._fontSize = H || BitmapFont.available[U].size, N.text = e, N._maxWidth = B, N._maxLineHeight = 0, N._letterSpacing = $, N._anchor = new ObservablePoint(function() {
      N.dirty = !0;
    }, N, 0, 0), N._roundPixels = settings$1.ROUND_PIXELS, N.dirty = !0, N._resolution = settings$1.RESOLUTION, N._autoResolution = !0, N._textureCache = {}, N;
  }
  return t.prototype.updateText = function() {
    for (var e, R = BitmapFont.available[this._fontName], N = this._fontSize / R.size, M = new Point(), D = [], L = [], B = [], $ = this._text.replace(/(?:\r\n|\r)/g, `
`) || " ", U = splitTextToCharacters($), H = this._maxWidth * R.size / this._fontSize, z = R.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData, X = null, Y = 0, W = 0, q = 0, Z = -1, K = 0, J = 0, Q = 0, et = 0, tt = 0; tt < U.length; tt++) {
      var st = U[tt], rt = extractCharCode(st);
      if (/(?:\s)/.test(st) && (Z = tt, K = Y, et++), st === "\r" || st === `
`) {
        L.push(Y), B.push(-1), W = Math.max(W, Y), ++q, ++J, M.x = 0, M.y += R.lineHeight, X = null, et = 0;
        continue;
      }
      var at = R.chars[rt];
      if (!!at) {
        X && at.kerning[X] && (M.x += at.kerning[X]);
        var ut = charRenderDataPool.pop() || {
          texture: Texture.EMPTY,
          line: 0,
          charCode: 0,
          prevSpaces: 0,
          position: new Point()
        };
        ut.texture = at.texture, ut.line = q, ut.charCode = rt, ut.position.x = M.x + at.xOffset + this._letterSpacing / 2, ut.position.y = M.y + at.yOffset, ut.prevSpaces = et, D.push(ut), Y = ut.position.x + Math.max(at.xAdvance - at.xOffset, at.texture.orig.width), M.x += at.xAdvance + this._letterSpacing, Q = Math.max(Q, at.yOffset + at.texture.height), X = rt, Z !== -1 && H > 0 && M.x > H && (++J, removeItems(D, 1 + Z - J, 1 + tt - Z), tt = Z, Z = -1, L.push(K), B.push(D.length > 0 ? D[D.length - 1].prevSpaces : 0), W = Math.max(W, K), q++, M.x = 0, M.y += R.lineHeight, X = null, et = 0);
      }
    }
    var dt = U[U.length - 1];
    dt !== "\r" && dt !== `
` && (/(?:\s)/.test(dt) && (Y = K), L.push(Y), W = Math.max(W, Y), B.push(-1));
    for (var ct = [], tt = 0; tt <= q; tt++) {
      var pt = 0;
      this._align === "right" ? pt = W - L[tt] : this._align === "center" ? pt = (W - L[tt]) / 2 : this._align === "justify" && (pt = B[tt] < 0 ? 0 : (W - L[tt]) / B[tt]), ct.push(pt);
    }
    for (var mt = D.length, vt = {}, _t = [], xt = this._activePagesMeshData, tt = 0; tt < xt.length; tt++)
      z.push(xt[tt]);
    for (var tt = 0; tt < mt; tt++) {
      var At = D[tt].texture, yt = At.baseTexture.uid;
      if (!vt[yt]) {
        var ht = z.pop();
        if (!ht) {
          var bt = new MeshGeometry(), Ct = void 0, Mt = void 0;
          R.distanceFieldType === "none" ? (Ct = new MeshMaterial(Texture.EMPTY), Mt = BLEND_MODES$5.NORMAL) : (Ct = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } }), Mt = BLEND_MODES$5.NORMAL_NPM);
          var wt = new Mesh(bt, Ct);
          wt.blendMode = Mt, ht = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh: wt,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        ht.index = 0, ht.indexCount = 0, ht.vertexCount = 0, ht.uvsCount = 0, ht.total = 0;
        var Lt = this._textureCache;
        Lt[yt] = Lt[yt] || new Texture(At.baseTexture), ht.mesh.texture = Lt[yt], ht.mesh.tint = this._tint, _t.push(ht), vt[yt] = ht;
      }
      vt[yt].total++;
    }
    for (var tt = 0; tt < xt.length; tt++)
      _t.indexOf(xt[tt]) === -1 && this.removeChild(xt[tt].mesh);
    for (var tt = 0; tt < _t.length; tt++)
      _t[tt].mesh.parent !== this && this.addChild(_t[tt].mesh);
    this._activePagesMeshData = _t;
    for (var tt in vt) {
      var ht = vt[tt], ft = ht.total;
      if (!(((e = ht.indices) === null || e === void 0 ? void 0 : e.length) > 6 * ft) || ht.vertices.length < Mesh.BATCHABLE_SIZE * 2)
        ht.vertices = new Float32Array(4 * 2 * ft), ht.uvs = new Float32Array(4 * 2 * ft), ht.indices = new Uint16Array(6 * ft);
      else
        for (var Gt = ht.total, Dt = ht.vertices, Bt = Gt * 4 * 2; Bt < Dt.length; Bt++)
          Dt[Bt] = 0;
      ht.mesh.size = 6 * ft;
    }
    for (var tt = 0; tt < mt; tt++) {
      var st = D[tt], Ot = st.position.x + ct[st.line] * (this._align === "justify" ? st.prevSpaces : 1);
      this._roundPixels && (Ot = Math.round(Ot));
      var Et = Ot * N, Ht = st.position.y * N, At = st.texture, It = vt[At.baseTexture.uid], St = At.frame, Nt = At._uvs, $t = It.index++;
      It.indices[$t * 6 + 0] = 0 + $t * 4, It.indices[$t * 6 + 1] = 1 + $t * 4, It.indices[$t * 6 + 2] = 2 + $t * 4, It.indices[$t * 6 + 3] = 0 + $t * 4, It.indices[$t * 6 + 4] = 2 + $t * 4, It.indices[$t * 6 + 5] = 3 + $t * 4, It.vertices[$t * 8 + 0] = Et, It.vertices[$t * 8 + 1] = Ht, It.vertices[$t * 8 + 2] = Et + St.width * N, It.vertices[$t * 8 + 3] = Ht, It.vertices[$t * 8 + 4] = Et + St.width * N, It.vertices[$t * 8 + 5] = Ht + St.height * N, It.vertices[$t * 8 + 6] = Et, It.vertices[$t * 8 + 7] = Ht + St.height * N, It.uvs[$t * 8 + 0] = Nt.x0, It.uvs[$t * 8 + 1] = Nt.y0, It.uvs[$t * 8 + 2] = Nt.x1, It.uvs[$t * 8 + 3] = Nt.y1, It.uvs[$t * 8 + 4] = Nt.x2, It.uvs[$t * 8 + 5] = Nt.y2, It.uvs[$t * 8 + 6] = Nt.x3, It.uvs[$t * 8 + 7] = Nt.y3;
    }
    this._textWidth = W * N, this._textHeight = (M.y + R.lineHeight) * N;
    for (var tt in vt) {
      var ht = vt[tt];
      if (this.anchor.x !== 0 || this.anchor.y !== 0)
        for (var Rt = 0, Jt = this._textWidth * this.anchor.x, Kt = this._textHeight * this.anchor.y, ae = 0; ae < ht.total; ae++)
          ht.vertices[Rt++] -= Jt, ht.vertices[Rt++] -= Kt, ht.vertices[Rt++] -= Jt, ht.vertices[Rt++] -= Kt, ht.vertices[Rt++] -= Jt, ht.vertices[Rt++] -= Kt, ht.vertices[Rt++] -= Jt, ht.vertices[Rt++] -= Kt;
      this._maxLineHeight = Q * N;
      var Se = ht.mesh.geometry.getBuffer("aVertexPosition"), De = ht.mesh.geometry.getBuffer("aTextureCoord"), ee = ht.mesh.geometry.getIndex();
      Se.data = ht.vertices, De.data = ht.uvs, ee.data = ht.indices, Se.update(), De.update(), ee.update();
    }
    for (var tt = 0; tt < D.length; tt++)
      charRenderDataPool.push(D[tt]);
  }, t.prototype.updateTransform = function() {
    this.validate(), this.containerUpdateTransform();
  }, t.prototype._render = function(e) {
    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);
    var R = BitmapFont.available[this._fontName], N = R.distanceFieldRange, M = R.distanceFieldType, D = R.size;
    if (M !== "none")
      for (var L = this.worldTransform, B = L.a, $ = L.b, U = L.c, H = L.d, z = Math.sqrt(B * B + $ * $), X = Math.sqrt(U * U + H * H), Y = (Math.abs(z) + Math.abs(X)) / 2, W = this._fontSize / D, q = 0, Z = this._activePagesMeshData; q < Z.length; q++) {
        var K = Z[q];
        K.mesh.shader.uniforms.uFWidth = Y * N * W * this._resolution;
      }
    o.prototype._render.call(this, e);
  }, t.prototype.getLocalBounds = function() {
    return this.validate(), o.prototype.getLocalBounds.call(this);
  }, t.prototype.validate = function() {
    this.dirty && (this.updateText(), this.dirty = !1);
  }, Object.defineProperty(t.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(e) {
      if (this._tint !== e) {
        this._tint = e;
        for (var R = 0; R < this._activePagesMeshData.length; R++)
          this._activePagesMeshData[R].mesh.tint = e;
      }
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "align", {
    get: function() {
      return this._align;
    },
    set: function(e) {
      this._align !== e && (this._align = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fontName", {
    get: function() {
      return this._fontName;
    },
    set: function(e) {
      if (!BitmapFont.available[e])
        throw new Error('Missing BitmapFont "' + e + '"');
      this._fontName !== e && (this._fontName = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fontSize", {
    get: function() {
      return this._fontSize;
    },
    set: function(e) {
      this._fontSize !== e && (this._fontSize = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "anchor", {
    get: function() {
      return this._anchor;
    },
    set: function(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "text", {
    get: function() {
      return this._text;
    },
    set: function(e) {
      e = String(e == null ? "" : e), this._text !== e && (this._text = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "maxWidth", {
    get: function() {
      return this._maxWidth;
    },
    set: function(e) {
      this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "maxLineHeight", {
    get: function() {
      return this.validate(), this._maxLineHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textWidth", {
    get: function() {
      return this.validate(), this._textWidth;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "letterSpacing", {
    get: function() {
      return this._letterSpacing;
    },
    set: function(e) {
      this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    set: function(e) {
      e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textHeight", {
    get: function() {
      return this.validate(), this._textHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "resolution", {
    get: function() {
      return this._resolution;
    },
    set: function(e) {
      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.destroy = function(e) {
    var R = this._textureCache;
    for (var N in R) {
      var M = R[N];
      M.destroy(), delete R[N];
    }
    this._textureCache = null, o.prototype.destroy.call(this, e);
  }, t.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
  }, t;
})(Container);
var BitmapFontLoader = function() {
  function o() {
  }
  return o.add = function() {
    LoaderResource.setExtensionXhrType("fnt", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
  }, o.use = function(t, e) {
    var R = autoDetectFormat(t.data);
    if (!R) {
      e();
      return;
    }
    for (var N = o.getBaseUrl(this, t), M = R.parse(t.data), D = {}, L = function(W) {
      D[W.metadata.pageFile] = W.texture, Object.keys(D).length === M.page.length && (t.bitmapFont = BitmapFont.install(M, D, !0), e());
    }, B = 0; B < M.page.length; ++B) {
      var $ = M.page[B].file, U = N + $, H = !1;
      for (var z in this.resources) {
        var X = this.resources[z];
        if (X.url === U) {
          X.metadata.pageFile = $, X.texture ? L(X) : X.onAfterMiddleware.add(L), H = !0;
          break;
        }
      }
      if (!H) {
        var Y = {
          crossOrigin: t.crossOrigin,
          loadType: LoaderResource.LOAD_TYPE.IMAGE,
          metadata: Object.assign({ pageFile: $ }, t.metadata.imageMetadata),
          parentResource: t
        };
        this.add(U, Y, L);
      }
    }
  }, o.getBaseUrl = function(t, e) {
    var R = e.isDataUrl ? "" : o.dirname(e.url);
    return e.isDataUrl && (R === "." && (R = ""), t.baseUrl && R && t.baseUrl.charAt(t.baseUrl.length - 1) === "/" && (R += "/")), R = R.replace(t.baseUrl, ""), R && R.charAt(R.length - 1) !== "/" && (R += "/"), R;
  }, o.dirname = function(t) {
    var e = t.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
    return e === t ? "." : e === "" ? "/" : e;
  }, o.extension = ExtensionType.Loader, o;
}();
/*!
 * @pixi/filter-alpha - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/filter-alpha is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$e = function(o, t) {
  return extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$e(o, t);
};
function __extends$e(o, t) {
  extendStatics$e(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment$4 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
(function(o) {
  __extends$e(t, o);
  function t(e) {
    e === void 0 && (e = 1);
    var R = o.call(this, defaultVertex$1, fragment$4, { uAlpha: 1 }) || this;
    return R.alpha = e, R;
  }
  return Object.defineProperty(t.prototype, "alpha", {
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(e) {
      this.uniforms.uAlpha = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/filter-blur - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/filter-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$d = function(o, t) {
  return extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$d(o, t);
};
function __extends$d(o, t) {
  extendStatics$d(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function generateBlurVertSource(o, t) {
  var e = Math.ceil(o / 2), R = vertTemplate, N = "", M;
  t ? M = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : M = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  for (var D = 0; D < o; D++) {
    var L = M.replace("%index%", D.toString());
    L = L.replace("%sampleIndex%", D - (e - 1) + ".0"), N += L, N += `
`;
  }
  return R = R.replace("%blur%", N), R = R.replace("%size%", o.toString()), R;
}
var GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
}, fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join(`
`);
function generateBlurFragSource(o) {
  for (var t = GAUSSIAN_VALUES[o], e = t.length, R = fragTemplate, N = "", M = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;", D, L = 0; L < o; L++) {
    var B = M.replace("%index%", L.toString());
    D = L, L >= e && (D = o - L - 1), B = B.replace("%value%", t[D].toString()), N += B, N += `
`;
  }
  return R = R.replace("%blur%", N), R = R.replace("%size%", o.toString()), R;
}
/*!
 * @pixi/constants - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$3;
(function(o) {
  o[o.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", o[o.WEBGL = 1] = "WEBGL", o[o.WEBGL2 = 2] = "WEBGL2";
})(ENV$3 || (ENV$3 = {}));
var RENDERER_TYPE$3;
(function(o) {
  o[o.UNKNOWN = 0] = "UNKNOWN", o[o.WEBGL = 1] = "WEBGL", o[o.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE$3 || (RENDERER_TYPE$3 = {}));
var BUFFER_BITS$3;
(function(o) {
  o[o.COLOR = 16384] = "COLOR", o[o.DEPTH = 256] = "DEPTH", o[o.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS$3 || (BUFFER_BITS$3 = {}));
var BLEND_MODES$3;
(function(o) {
  o[o.NORMAL = 0] = "NORMAL", o[o.ADD = 1] = "ADD", o[o.MULTIPLY = 2] = "MULTIPLY", o[o.SCREEN = 3] = "SCREEN", o[o.OVERLAY = 4] = "OVERLAY", o[o.DARKEN = 5] = "DARKEN", o[o.LIGHTEN = 6] = "LIGHTEN", o[o.COLOR_DODGE = 7] = "COLOR_DODGE", o[o.COLOR_BURN = 8] = "COLOR_BURN", o[o.HARD_LIGHT = 9] = "HARD_LIGHT", o[o.SOFT_LIGHT = 10] = "SOFT_LIGHT", o[o.DIFFERENCE = 11] = "DIFFERENCE", o[o.EXCLUSION = 12] = "EXCLUSION", o[o.HUE = 13] = "HUE", o[o.SATURATION = 14] = "SATURATION", o[o.COLOR = 15] = "COLOR", o[o.LUMINOSITY = 16] = "LUMINOSITY", o[o.NORMAL_NPM = 17] = "NORMAL_NPM", o[o.ADD_NPM = 18] = "ADD_NPM", o[o.SCREEN_NPM = 19] = "SCREEN_NPM", o[o.NONE = 20] = "NONE", o[o.SRC_OVER = 0] = "SRC_OVER", o[o.SRC_IN = 21] = "SRC_IN", o[o.SRC_OUT = 22] = "SRC_OUT", o[o.SRC_ATOP = 23] = "SRC_ATOP", o[o.DST_OVER = 24] = "DST_OVER", o[o.DST_IN = 25] = "DST_IN", o[o.DST_OUT = 26] = "DST_OUT", o[o.DST_ATOP = 27] = "DST_ATOP", o[o.ERASE = 26] = "ERASE", o[o.SUBTRACT = 28] = "SUBTRACT", o[o.XOR = 29] = "XOR";
})(BLEND_MODES$3 || (BLEND_MODES$3 = {}));
var DRAW_MODES$3;
(function(o) {
  o[o.POINTS = 0] = "POINTS", o[o.LINES = 1] = "LINES", o[o.LINE_LOOP = 2] = "LINE_LOOP", o[o.LINE_STRIP = 3] = "LINE_STRIP", o[o.TRIANGLES = 4] = "TRIANGLES", o[o.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", o[o.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$3 || (DRAW_MODES$3 = {}));
var FORMATS$3;
(function(o) {
  o[o.RGBA = 6408] = "RGBA", o[o.RGB = 6407] = "RGB", o[o.RG = 33319] = "RG", o[o.RED = 6403] = "RED", o[o.RGBA_INTEGER = 36249] = "RGBA_INTEGER", o[o.RGB_INTEGER = 36248] = "RGB_INTEGER", o[o.RG_INTEGER = 33320] = "RG_INTEGER", o[o.RED_INTEGER = 36244] = "RED_INTEGER", o[o.ALPHA = 6406] = "ALPHA", o[o.LUMINANCE = 6409] = "LUMINANCE", o[o.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", o[o.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", o[o.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS$3 || (FORMATS$3 = {}));
var TARGETS$3;
(function(o) {
  o[o.TEXTURE_2D = 3553] = "TEXTURE_2D", o[o.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", o[o.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", o[o.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", o[o.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", o[o.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", o[o.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$3 || (TARGETS$3 = {}));
var TYPES$3;
(function(o) {
  o[o.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", o[o.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", o[o.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", o[o.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", o[o.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", o[o.UNSIGNED_INT = 5125] = "UNSIGNED_INT", o[o.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", o[o.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", o[o.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", o[o.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", o[o.BYTE = 5120] = "BYTE", o[o.SHORT = 5122] = "SHORT", o[o.INT = 5124] = "INT", o[o.FLOAT = 5126] = "FLOAT", o[o.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", o[o.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES$3 || (TYPES$3 = {}));
var SAMPLER_TYPES$3;
(function(o) {
  o[o.FLOAT = 0] = "FLOAT", o[o.INT = 1] = "INT", o[o.UINT = 2] = "UINT";
})(SAMPLER_TYPES$3 || (SAMPLER_TYPES$3 = {}));
var SCALE_MODES$3;
(function(o) {
  o[o.NEAREST = 0] = "NEAREST", o[o.LINEAR = 1] = "LINEAR";
})(SCALE_MODES$3 || (SCALE_MODES$3 = {}));
var WRAP_MODES$3;
(function(o) {
  o[o.CLAMP = 33071] = "CLAMP", o[o.REPEAT = 10497] = "REPEAT", o[o.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$3 || (WRAP_MODES$3 = {}));
var MIPMAP_MODES$3;
(function(o) {
  o[o.OFF = 0] = "OFF", o[o.POW2 = 1] = "POW2", o[o.ON = 2] = "ON", o[o.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES$3 || (MIPMAP_MODES$3 = {}));
var ALPHA_MODES$3;
(function(o) {
  o[o.NPM = 0] = "NPM", o[o.UNPACK = 1] = "UNPACK", o[o.PMA = 2] = "PMA", o[o.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", o[o.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", o[o.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", o[o.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$3 || (ALPHA_MODES$3 = {}));
var CLEAR_MODES$3;
(function(o) {
  o[o.NO = 0] = "NO", o[o.YES = 1] = "YES", o[o.AUTO = 2] = "AUTO", o[o.BLEND = 0] = "BLEND", o[o.CLEAR = 1] = "CLEAR", o[o.BLIT = 2] = "BLIT";
})(CLEAR_MODES$3 || (CLEAR_MODES$3 = {}));
var GC_MODES$3;
(function(o) {
  o[o.AUTO = 0] = "AUTO", o[o.MANUAL = 1] = "MANUAL";
})(GC_MODES$3 || (GC_MODES$3 = {}));
var PRECISION$3;
(function(o) {
  o.LOW = "lowp", o.MEDIUM = "mediump", o.HIGH = "highp";
})(PRECISION$3 || (PRECISION$3 = {}));
var MASK_TYPES$3;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.SCISSOR = 1] = "SCISSOR", o[o.STENCIL = 2] = "STENCIL", o[o.SPRITE = 3] = "SPRITE", o[o.COLOR = 4] = "COLOR";
})(MASK_TYPES$3 || (MASK_TYPES$3 = {}));
var COLOR_MASK_BITS$3;
(function(o) {
  o[o.RED = 1] = "RED", o[o.GREEN = 2] = "GREEN", o[o.BLUE = 4] = "BLUE", o[o.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS$3 || (COLOR_MASK_BITS$3 = {}));
var MSAA_QUALITY$3;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.LOW = 2] = "LOW", o[o.MEDIUM = 4] = "MEDIUM", o[o.HIGH = 8] = "HIGH";
})(MSAA_QUALITY$3 || (MSAA_QUALITY$3 = {}));
var BUFFER_TYPE$3;
(function(o) {
  o[o.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", o[o.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", o[o.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$3 || (BUFFER_TYPE$3 = {}));
var BlurFilterPass = function(o) {
  __extends$d(t, o);
  function t(e, R, N, M, D) {
    R === void 0 && (R = 8), N === void 0 && (N = 4), M === void 0 && (M = settings$1.FILTER_RESOLUTION), D === void 0 && (D = 5);
    var L = this, B = generateBlurVertSource(D, e), $ = generateBlurFragSource(D);
    return L = o.call(
      this,
      B,
      $
    ) || this, L.horizontal = e, L.resolution = M, L._quality = 0, L.quality = N, L.blur = R, L;
  }
  return t.prototype.apply = function(e, R, N, M) {
    if (N ? this.horizontal ? this.uniforms.strength = 1 / N.width * (N.width / R.width) : this.uniforms.strength = 1 / N.height * (N.height / R.height) : this.horizontal ? this.uniforms.strength = 1 / e.renderer.width * (e.renderer.width / R.width) : this.uniforms.strength = 1 / e.renderer.height * (e.renderer.height / R.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)
      e.applyFilter(this, R, N, M);
    else {
      var D = e.getFilterTexture(), L = e.renderer, B = R, $ = D;
      this.state.blend = !1, e.applyFilter(this, B, $, CLEAR_MODES$3.CLEAR);
      for (var U = 1; U < this.passes - 1; U++) {
        e.bindAndClear(B, CLEAR_MODES$3.BLIT), this.uniforms.uSampler = $;
        var H = $;
        $ = B, B = H, L.shader.bind(this), L.geometry.draw(5);
      }
      this.state.blend = !0, e.applyFilter(this, $, N, M), e.returnFilterTexture(D);
    }
  }, Object.defineProperty(t.prototype, "blur", {
    get: function() {
      return this.strength;
    },
    set: function(e) {
      this.padding = 1 + Math.abs(e) * 2, this.strength = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "quality", {
    get: function() {
      return this._quality;
    },
    set: function(e) {
      this._quality = e, this.passes = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Filter);
(function(o) {
  __extends$d(t, o);
  function t(e, R, N, M) {
    e === void 0 && (e = 8), R === void 0 && (R = 4), N === void 0 && (N = settings$1.FILTER_RESOLUTION), M === void 0 && (M = 5);
    var D = o.call(this) || this;
    return D.blurXFilter = new BlurFilterPass(!0, e, R, N, M), D.blurYFilter = new BlurFilterPass(!1, e, R, N, M), D.resolution = N, D.quality = R, D.blur = e, D.repeatEdgePixels = !1, D;
  }
  return t.prototype.apply = function(e, R, N, M) {
    var D = Math.abs(this.blurXFilter.strength), L = Math.abs(this.blurYFilter.strength);
    if (D && L) {
      var B = e.getFilterTexture();
      this.blurXFilter.apply(e, R, B, CLEAR_MODES$3.CLEAR), this.blurYFilter.apply(e, B, N, M), e.returnFilterTexture(B);
    } else
      L ? this.blurYFilter.apply(e, R, N, M) : this.blurXFilter.apply(e, R, N, M);
  }, t.prototype.updatePadding = function() {
    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
  }, Object.defineProperty(t.prototype, "blur", {
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(e) {
      this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "quality", {
    get: function() {
      return this.blurXFilter.quality;
    },
    set: function(e) {
      this.blurXFilter.quality = this.blurYFilter.quality = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blurX", {
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(e) {
      this.blurXFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blurY", {
    get: function() {
      return this.blurYFilter.blur;
    },
    set: function(e) {
      this.blurYFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blendMode", {
    get: function() {
      return this.blurYFilter.blendMode;
    },
    set: function(e) {
      this.blurYFilter.blendMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "repeatEdgePixels", {
    get: function() {
      return this._repeatEdgePixels;
    },
    set: function(e) {
      this._repeatEdgePixels = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/filter-color-matrix - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/filter-color-matrix is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$c = function(o, t) {
  return extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$c(o, t);
};
function __extends$c(o, t) {
  extendStatics$c(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment$3 = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`, ColorMatrixFilter = function(o) {
  __extends$c(t, o);
  function t() {
    var e = this, R = {
      m: new Float32Array([
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]),
      uAlpha: 1
    };
    return e = o.call(this, defaultFilterVertex, fragment$3, R) || this, e.alpha = 1, e;
  }
  return t.prototype._loadMatrix = function(e, R) {
    R === void 0 && (R = !1);
    var N = e;
    R && (this._multiply(N, this.uniforms.m, e), N = this._colorMatrix(N)), this.uniforms.m = N;
  }, t.prototype._multiply = function(e, R, N) {
    return e[0] = R[0] * N[0] + R[1] * N[5] + R[2] * N[10] + R[3] * N[15], e[1] = R[0] * N[1] + R[1] * N[6] + R[2] * N[11] + R[3] * N[16], e[2] = R[0] * N[2] + R[1] * N[7] + R[2] * N[12] + R[3] * N[17], e[3] = R[0] * N[3] + R[1] * N[8] + R[2] * N[13] + R[3] * N[18], e[4] = R[0] * N[4] + R[1] * N[9] + R[2] * N[14] + R[3] * N[19] + R[4], e[5] = R[5] * N[0] + R[6] * N[5] + R[7] * N[10] + R[8] * N[15], e[6] = R[5] * N[1] + R[6] * N[6] + R[7] * N[11] + R[8] * N[16], e[7] = R[5] * N[2] + R[6] * N[7] + R[7] * N[12] + R[8] * N[17], e[8] = R[5] * N[3] + R[6] * N[8] + R[7] * N[13] + R[8] * N[18], e[9] = R[5] * N[4] + R[6] * N[9] + R[7] * N[14] + R[8] * N[19] + R[9], e[10] = R[10] * N[0] + R[11] * N[5] + R[12] * N[10] + R[13] * N[15], e[11] = R[10] * N[1] + R[11] * N[6] + R[12] * N[11] + R[13] * N[16], e[12] = R[10] * N[2] + R[11] * N[7] + R[12] * N[12] + R[13] * N[17], e[13] = R[10] * N[3] + R[11] * N[8] + R[12] * N[13] + R[13] * N[18], e[14] = R[10] * N[4] + R[11] * N[9] + R[12] * N[14] + R[13] * N[19] + R[14], e[15] = R[15] * N[0] + R[16] * N[5] + R[17] * N[10] + R[18] * N[15], e[16] = R[15] * N[1] + R[16] * N[6] + R[17] * N[11] + R[18] * N[16], e[17] = R[15] * N[2] + R[16] * N[7] + R[17] * N[12] + R[18] * N[17], e[18] = R[15] * N[3] + R[16] * N[8] + R[17] * N[13] + R[18] * N[18], e[19] = R[15] * N[4] + R[16] * N[9] + R[17] * N[14] + R[18] * N[19] + R[19], e;
  }, t.prototype._colorMatrix = function(e) {
    var R = new Float32Array(e);
    return R[4] /= 255, R[9] /= 255, R[14] /= 255, R[19] /= 255, R;
  }, t.prototype.brightness = function(e, R) {
    var N = [
      e,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(N, R);
  }, t.prototype.tint = function(e, R) {
    var N = e >> 16 & 255, M = e >> 8 & 255, D = e & 255, L = [
      N / 255,
      0,
      0,
      0,
      0,
      0,
      M / 255,
      0,
      0,
      0,
      0,
      0,
      D / 255,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(L, R);
  }, t.prototype.greyscale = function(e, R) {
    var N = [
      e,
      e,
      e,
      0,
      0,
      e,
      e,
      e,
      0,
      0,
      e,
      e,
      e,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(N, R);
  }, t.prototype.blackAndWhite = function(e) {
    var R = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(R, e);
  }, t.prototype.hue = function(e, R) {
    e = (e || 0) / 180 * Math.PI;
    var N = Math.cos(e), M = Math.sin(e), D = Math.sqrt, L = 1 / 3, B = D(L), $ = N + (1 - N) * L, U = L * (1 - N) - B * M, H = L * (1 - N) + B * M, z = L * (1 - N) + B * M, X = N + L * (1 - N), Y = L * (1 - N) - B * M, W = L * (1 - N) - B * M, q = L * (1 - N) + B * M, Z = N + L * (1 - N), K = [
      $,
      U,
      H,
      0,
      0,
      z,
      X,
      Y,
      0,
      0,
      W,
      q,
      Z,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(K, R);
  }, t.prototype.contrast = function(e, R) {
    var N = (e || 0) + 1, M = -0.5 * (N - 1), D = [
      N,
      0,
      0,
      0,
      M,
      0,
      N,
      0,
      0,
      M,
      0,
      0,
      N,
      0,
      M,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(D, R);
  }, t.prototype.saturate = function(e, R) {
    e === void 0 && (e = 0);
    var N = e * 2 / 3 + 1, M = (N - 1) * -0.5, D = [
      N,
      M,
      M,
      0,
      0,
      M,
      N,
      M,
      0,
      0,
      M,
      M,
      N,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(D, R);
  }, t.prototype.desaturate = function() {
    this.saturate(-1);
  }, t.prototype.negative = function(e) {
    var R = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(R, e);
  }, t.prototype.sepia = function(e) {
    var R = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(R, e);
  }, t.prototype.technicolor = function(e) {
    var R = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(R, e);
  }, t.prototype.polaroid = function(e) {
    var R = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(R, e);
  }, t.prototype.toBGR = function(e) {
    var R = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(R, e);
  }, t.prototype.kodachrome = function(e) {
    var R = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(R, e);
  }, t.prototype.browni = function(e) {
    var R = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(R, e);
  }, t.prototype.vintage = function(e) {
    var R = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(R, e);
  }, t.prototype.colorTone = function(e, R, N, M, D) {
    e = e || 0.2, R = R || 0.15, N = N || 16770432, M = M || 3375104;
    var L = (N >> 16 & 255) / 255, B = (N >> 8 & 255) / 255, $ = (N & 255) / 255, U = (M >> 16 & 255) / 255, H = (M >> 8 & 255) / 255, z = (M & 255) / 255, X = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      L,
      B,
      $,
      e,
      0,
      U,
      H,
      z,
      R,
      0,
      L - U,
      B - H,
      $ - z,
      0,
      0
    ];
    this._loadMatrix(X, D);
  }, t.prototype.night = function(e, R) {
    e = e || 0.1;
    var N = [
      e * -2,
      -e,
      0,
      0,
      0,
      -e,
      0,
      e,
      0,
      0,
      0,
      e,
      e * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(N, R);
  }, t.prototype.predator = function(e, R) {
    var N = [
      11.224130630493164 * e,
      -4.794486999511719 * e,
      -2.8746118545532227 * e,
      0 * e,
      0.40342438220977783 * e,
      -3.6330697536468506 * e,
      9.193157196044922 * e,
      -2.951810836791992 * e,
      0 * e,
      -1.316135048866272 * e,
      -3.2184197902679443 * e,
      -4.2375030517578125 * e,
      7.476448059082031 * e,
      0 * e,
      0.8044459223747253 * e,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(N, R);
  }, t.prototype.lsd = function(e) {
    var R = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(R, e);
  }, t.prototype.reset = function() {
    var e = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(e, !1);
  }, Object.defineProperty(t.prototype, "matrix", {
    get: function() {
      return this.uniforms.m;
    },
    set: function(e) {
      this.uniforms.m = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "alpha", {
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(e) {
      this.uniforms.uAlpha = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Filter);
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
/*!
 * @pixi/filter-displacement - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/filter-displacement is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$b = function(o, t) {
  return extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$b(o, t);
};
function __extends$b(o, t) {
  extendStatics$b(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment$2 = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`, vertex$1 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
(function(o) {
  __extends$b(t, o);
  function t(e, R) {
    var N = this, M = new Matrix();
    return e.renderable = !1, N = o.call(this, vertex$1, fragment$2, {
      mapSampler: e._texture,
      filterMatrix: M,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    }) || this, N.maskSprite = e, N.maskMatrix = M, R == null && (R = 20), N.scale = new Point(R, R), N;
  }
  return t.prototype.apply = function(e, R, N, M) {
    this.uniforms.filterMatrix = e.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
    var D = this.maskSprite.worldTransform, L = Math.sqrt(D.a * D.a + D.b * D.b), B = Math.sqrt(D.c * D.c + D.d * D.d);
    L !== 0 && B !== 0 && (this.uniforms.rotation[0] = D.a / L, this.uniforms.rotation[1] = D.b / L, this.uniforms.rotation[2] = D.c / B, this.uniforms.rotation[3] = D.d / B), e.applyFilter(this, R, N, M);
  }, Object.defineProperty(t.prototype, "map", {
    get: function() {
      return this.uniforms.mapSampler;
    },
    set: function(e) {
      this.uniforms.mapSampler = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/filter-fxaa - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/filter-fxaa is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$a = function(o, t) {
  return extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$a(o, t);
};
function __extends$a(o, t) {
  extendStatics$a(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var vertex = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`, fragment$1 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
(function(o) {
  __extends$a(t, o);
  function t() {
    return o.call(this, vertex, fragment$1) || this;
  }
  return t;
})(Filter);
/*!
 * @pixi/filter-noise - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/filter-noise is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$9 = function(o, t) {
  return extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$9(o, t);
};
function __extends$9(o, t) {
  extendStatics$9(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
(function(o) {
  __extends$9(t, o);
  function t(e, R) {
    e === void 0 && (e = 0.5), R === void 0 && (R = Math.random());
    var N = o.call(this, defaultFilterVertex, fragment, {
      uNoise: 0,
      uSeed: 0
    }) || this;
    return N.noise = e, N.seed = R, N;
  }
  return Object.defineProperty(t.prototype, "noise", {
    get: function() {
      return this.uniforms.uNoise;
    },
    set: function(e) {
      this.uniforms.uNoise = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "seed", {
    get: function() {
      return this.uniforms.uSeed;
    },
    set: function(e) {
      this.uniforms.uSeed = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/mixin-cache-as-bitmap - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*!
 * @pixi/constants - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$2;
(function(o) {
  o[o.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", o[o.WEBGL = 1] = "WEBGL", o[o.WEBGL2 = 2] = "WEBGL2";
})(ENV$2 || (ENV$2 = {}));
var RENDERER_TYPE$2;
(function(o) {
  o[o.UNKNOWN = 0] = "UNKNOWN", o[o.WEBGL = 1] = "WEBGL", o[o.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE$2 || (RENDERER_TYPE$2 = {}));
var BUFFER_BITS$2;
(function(o) {
  o[o.COLOR = 16384] = "COLOR", o[o.DEPTH = 256] = "DEPTH", o[o.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS$2 || (BUFFER_BITS$2 = {}));
var BLEND_MODES$2;
(function(o) {
  o[o.NORMAL = 0] = "NORMAL", o[o.ADD = 1] = "ADD", o[o.MULTIPLY = 2] = "MULTIPLY", o[o.SCREEN = 3] = "SCREEN", o[o.OVERLAY = 4] = "OVERLAY", o[o.DARKEN = 5] = "DARKEN", o[o.LIGHTEN = 6] = "LIGHTEN", o[o.COLOR_DODGE = 7] = "COLOR_DODGE", o[o.COLOR_BURN = 8] = "COLOR_BURN", o[o.HARD_LIGHT = 9] = "HARD_LIGHT", o[o.SOFT_LIGHT = 10] = "SOFT_LIGHT", o[o.DIFFERENCE = 11] = "DIFFERENCE", o[o.EXCLUSION = 12] = "EXCLUSION", o[o.HUE = 13] = "HUE", o[o.SATURATION = 14] = "SATURATION", o[o.COLOR = 15] = "COLOR", o[o.LUMINOSITY = 16] = "LUMINOSITY", o[o.NORMAL_NPM = 17] = "NORMAL_NPM", o[o.ADD_NPM = 18] = "ADD_NPM", o[o.SCREEN_NPM = 19] = "SCREEN_NPM", o[o.NONE = 20] = "NONE", o[o.SRC_OVER = 0] = "SRC_OVER", o[o.SRC_IN = 21] = "SRC_IN", o[o.SRC_OUT = 22] = "SRC_OUT", o[o.SRC_ATOP = 23] = "SRC_ATOP", o[o.DST_OVER = 24] = "DST_OVER", o[o.DST_IN = 25] = "DST_IN", o[o.DST_OUT = 26] = "DST_OUT", o[o.DST_ATOP = 27] = "DST_ATOP", o[o.ERASE = 26] = "ERASE", o[o.SUBTRACT = 28] = "SUBTRACT", o[o.XOR = 29] = "XOR";
})(BLEND_MODES$2 || (BLEND_MODES$2 = {}));
var DRAW_MODES$2;
(function(o) {
  o[o.POINTS = 0] = "POINTS", o[o.LINES = 1] = "LINES", o[o.LINE_LOOP = 2] = "LINE_LOOP", o[o.LINE_STRIP = 3] = "LINE_STRIP", o[o.TRIANGLES = 4] = "TRIANGLES", o[o.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", o[o.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$2 || (DRAW_MODES$2 = {}));
var FORMATS$2;
(function(o) {
  o[o.RGBA = 6408] = "RGBA", o[o.RGB = 6407] = "RGB", o[o.RG = 33319] = "RG", o[o.RED = 6403] = "RED", o[o.RGBA_INTEGER = 36249] = "RGBA_INTEGER", o[o.RGB_INTEGER = 36248] = "RGB_INTEGER", o[o.RG_INTEGER = 33320] = "RG_INTEGER", o[o.RED_INTEGER = 36244] = "RED_INTEGER", o[o.ALPHA = 6406] = "ALPHA", o[o.LUMINANCE = 6409] = "LUMINANCE", o[o.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", o[o.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", o[o.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS$2 || (FORMATS$2 = {}));
var TARGETS$2;
(function(o) {
  o[o.TEXTURE_2D = 3553] = "TEXTURE_2D", o[o.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", o[o.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", o[o.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", o[o.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", o[o.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", o[o.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$2 || (TARGETS$2 = {}));
var TYPES$2;
(function(o) {
  o[o.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", o[o.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", o[o.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", o[o.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", o[o.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", o[o.UNSIGNED_INT = 5125] = "UNSIGNED_INT", o[o.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", o[o.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", o[o.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", o[o.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", o[o.BYTE = 5120] = "BYTE", o[o.SHORT = 5122] = "SHORT", o[o.INT = 5124] = "INT", o[o.FLOAT = 5126] = "FLOAT", o[o.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", o[o.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES$2 || (TYPES$2 = {}));
var SAMPLER_TYPES$2;
(function(o) {
  o[o.FLOAT = 0] = "FLOAT", o[o.INT = 1] = "INT", o[o.UINT = 2] = "UINT";
})(SAMPLER_TYPES$2 || (SAMPLER_TYPES$2 = {}));
var SCALE_MODES$2;
(function(o) {
  o[o.NEAREST = 0] = "NEAREST", o[o.LINEAR = 1] = "LINEAR";
})(SCALE_MODES$2 || (SCALE_MODES$2 = {}));
var WRAP_MODES$2;
(function(o) {
  o[o.CLAMP = 33071] = "CLAMP", o[o.REPEAT = 10497] = "REPEAT", o[o.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$2 || (WRAP_MODES$2 = {}));
var MIPMAP_MODES$2;
(function(o) {
  o[o.OFF = 0] = "OFF", o[o.POW2 = 1] = "POW2", o[o.ON = 2] = "ON", o[o.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES$2 || (MIPMAP_MODES$2 = {}));
var ALPHA_MODES$2;
(function(o) {
  o[o.NPM = 0] = "NPM", o[o.UNPACK = 1] = "UNPACK", o[o.PMA = 2] = "PMA", o[o.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", o[o.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", o[o.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", o[o.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$2 || (ALPHA_MODES$2 = {}));
var CLEAR_MODES$2;
(function(o) {
  o[o.NO = 0] = "NO", o[o.YES = 1] = "YES", o[o.AUTO = 2] = "AUTO", o[o.BLEND = 0] = "BLEND", o[o.CLEAR = 1] = "CLEAR", o[o.BLIT = 2] = "BLIT";
})(CLEAR_MODES$2 || (CLEAR_MODES$2 = {}));
var GC_MODES$2;
(function(o) {
  o[o.AUTO = 0] = "AUTO", o[o.MANUAL = 1] = "MANUAL";
})(GC_MODES$2 || (GC_MODES$2 = {}));
var PRECISION$2;
(function(o) {
  o.LOW = "lowp", o.MEDIUM = "mediump", o.HIGH = "highp";
})(PRECISION$2 || (PRECISION$2 = {}));
var MASK_TYPES$2;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.SCISSOR = 1] = "SCISSOR", o[o.STENCIL = 2] = "STENCIL", o[o.SPRITE = 3] = "SPRITE", o[o.COLOR = 4] = "COLOR";
})(MASK_TYPES$2 || (MASK_TYPES$2 = {}));
var COLOR_MASK_BITS$2;
(function(o) {
  o[o.RED = 1] = "RED", o[o.GREEN = 2] = "GREEN", o[o.BLUE = 4] = "BLUE", o[o.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS$2 || (COLOR_MASK_BITS$2 = {}));
var MSAA_QUALITY$2;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.LOW = 2] = "LOW", o[o.MEDIUM = 4] = "MEDIUM", o[o.HIGH = 8] = "HIGH";
})(MSAA_QUALITY$2 || (MSAA_QUALITY$2 = {}));
var BUFFER_TYPE$2;
(function(o) {
  o[o.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", o[o.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", o[o.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$2 || (BUFFER_TYPE$2 = {}));
var _tempMatrix = new Matrix();
DisplayObject.prototype._cacheAsBitmap = !1;
DisplayObject.prototype._cacheData = null;
DisplayObject.prototype._cacheAsBitmapResolution = null;
DisplayObject.prototype._cacheAsBitmapMultisample = MSAA_QUALITY$2.NONE;
var CacheData = function() {
  function o() {
    this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;
  }
  return o;
}();
Object.defineProperties(DisplayObject.prototype, {
  cacheAsBitmapResolution: {
    get: function() {
      return this._cacheAsBitmapResolution;
    },
    set: function(o) {
      o !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = o, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  cacheAsBitmapMultisample: {
    get: function() {
      return this._cacheAsBitmapMultisample;
    },
    set: function(o) {
      o !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = o, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  cacheAsBitmap: {
    get: function() {
      return this._cacheAsBitmap;
    },
    set: function(o) {
      if (this._cacheAsBitmap !== o) {
        this._cacheAsBitmap = o;
        var t;
        o ? (this._cacheData || (this._cacheData = new CacheData()), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea);
      }
    }
  }
});
DisplayObject.prototype._renderCached = function(t) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t));
};
DisplayObject.prototype._initCachedDisplayObject = function(t) {
  var e;
  if (!(this._cacheData && this._cacheData.sprite)) {
    var R = this.alpha;
    this.alpha = 1, t.batch.flush();
    var N = this.getLocalBounds(null, !0).clone();
    if (this.filters && this.filters.length) {
      var M = this.filters[0].padding;
      N.pad(M);
    }
    N.ceil(settings$1.RESOLUTION);
    var D = t.renderTexture.current, L = t.renderTexture.sourceFrame.clone(), B = t.renderTexture.destinationFrame.clone(), $ = t.projection.transform, U = RenderTexture.create({
      width: N.width,
      height: N.height,
      resolution: this.cacheAsBitmapResolution || t.resolution,
      multisample: (e = this.cacheAsBitmapMultisample) !== null && e !== void 0 ? e : t.multisample
    }), H = "cacheAsBitmap_" + uid();
    this._cacheData.textureCacheId = H, BaseTexture.addToCache(U.baseTexture, H), Texture.addToCache(U, H);
    var z = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-N.x, -N.y);
    this.render = this._cacheData.originalRender, t.render(this, { renderTexture: U, clear: !0, transform: z, skipUpdateTransform: !1 }), t.framebuffer.blit(), t.projection.transform = $, t.renderTexture.bind(D, L, B), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = R;
    var X = new Sprite(U);
    X.transform.worldTransform = this.transform.worldTransform, X.anchor.x = -(N.x / N.width), X.anchor.y = -(N.y / N.height), X.alpha = R, X._bounds = this._bounds, this._cacheData.sprite = X, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = X.containsPoint.bind(X);
  }
};
DisplayObject.prototype._renderCachedCanvas = function(t) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t));
};
DisplayObject.prototype._initCachedDisplayObjectCanvas = function(t) {
  if (!(this._cacheData && this._cacheData.sprite)) {
    var e = this.getLocalBounds(null, !0), R = this.alpha;
    this.alpha = 1;
    var N = t.context, M = t._projTransform;
    e.ceil(settings$1.RESOLUTION);
    var D = RenderTexture.create({ width: e.width, height: e.height }), L = "cacheAsBitmap_" + uid();
    this._cacheData.textureCacheId = L, BaseTexture.addToCache(D.baseTexture, L), Texture.addToCache(D, L);
    var B = _tempMatrix;
    this.transform.localTransform.copyTo(B), B.invert(), B.tx -= e.x, B.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, { renderTexture: D, clear: !0, transform: B, skipUpdateTransform: !1 }), t.context = N, t._projTransform = M, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = R;
    var $ = new Sprite(D);
    $.transform.worldTransform = this.transform.worldTransform, $.anchor.x = -(e.x / e.width), $.anchor.y = -(e.y / e.height), $.alpha = R, $._bounds = this._bounds, this._cacheData.sprite = $, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = $.containsPoint.bind($);
  }
};
DisplayObject.prototype._calculateCachedBounds = function() {
  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;
};
DisplayObject.prototype._getCachedLocalBounds = function() {
  return this._cacheData.sprite.getLocalBounds(null);
};
DisplayObject.prototype._destroyCachedDisplayObject = function() {
  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, BaseTexture.removeFromCache(this._cacheData.textureCacheId), Texture.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;
};
DisplayObject.prototype._cacheAsBitmapDestroy = function(t) {
  this.cacheAsBitmap = !1, this.destroy(t);
};
/*!
 * @pixi/mixin-get-child-by-name - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.name = null;
Container.prototype.getChildByName = function(t, e) {
  for (var R = 0, N = this.children.length; R < N; R++)
    if (this.children[R].name === t)
      return this.children[R];
  if (e)
    for (var R = 0, N = this.children.length; R < N; R++) {
      var M = this.children[R];
      if (!!M.getChildByName) {
        var D = M.getChildByName(t, !0);
        if (D)
          return D;
      }
    }
  return null;
};
/*!
 * @pixi/mixin-get-global-position - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.getGlobalPosition = function(t, e) {
  return t === void 0 && (t = new Point()), e === void 0 && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t;
};
/*!
 * @pixi/app - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/app is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ResizePlugin = function() {
  function o() {
  }
  return o.init = function(t) {
    var e = this;
    Object.defineProperty(
      this,
      "resizeTo",
      {
        set: function(R) {
          globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = R, R && (globalThis.addEventListener("resize", this.queueResize), this.resize());
        },
        get: function() {
          return this._resizeTo;
        }
      }
    ), this.queueResize = function() {
      !e._resizeTo || (e.cancelResize(), e._resizeId = requestAnimationFrame(function() {
        return e.resize();
      }));
    }, this.cancelResize = function() {
      e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null);
    }, this.resize = function() {
      if (!!e._resizeTo) {
        e.cancelResize();
        var R, N;
        if (e._resizeTo === globalThis.window)
          R = globalThis.innerWidth, N = globalThis.innerHeight;
        else {
          var M = e._resizeTo, D = M.clientWidth, L = M.clientHeight;
          R = D, N = L;
        }
        e.renderer.resize(R, N);
      }
    }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;
  }, o.destroy = function() {
    globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
  }, o.extension = ExtensionType.Application, o;
}();
/*!
 * @pixi/settings - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*!
 * @pixi/constants - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$1;
(function(o) {
  o[o.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", o[o.WEBGL = 1] = "WEBGL", o[o.WEBGL2 = 2] = "WEBGL2";
})(ENV$1 || (ENV$1 = {}));
var RENDERER_TYPE$1;
(function(o) {
  o[o.UNKNOWN = 0] = "UNKNOWN", o[o.WEBGL = 1] = "WEBGL", o[o.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE$1 || (RENDERER_TYPE$1 = {}));
var BUFFER_BITS$1;
(function(o) {
  o[o.COLOR = 16384] = "COLOR", o[o.DEPTH = 256] = "DEPTH", o[o.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS$1 || (BUFFER_BITS$1 = {}));
var BLEND_MODES$1;
(function(o) {
  o[o.NORMAL = 0] = "NORMAL", o[o.ADD = 1] = "ADD", o[o.MULTIPLY = 2] = "MULTIPLY", o[o.SCREEN = 3] = "SCREEN", o[o.OVERLAY = 4] = "OVERLAY", o[o.DARKEN = 5] = "DARKEN", o[o.LIGHTEN = 6] = "LIGHTEN", o[o.COLOR_DODGE = 7] = "COLOR_DODGE", o[o.COLOR_BURN = 8] = "COLOR_BURN", o[o.HARD_LIGHT = 9] = "HARD_LIGHT", o[o.SOFT_LIGHT = 10] = "SOFT_LIGHT", o[o.DIFFERENCE = 11] = "DIFFERENCE", o[o.EXCLUSION = 12] = "EXCLUSION", o[o.HUE = 13] = "HUE", o[o.SATURATION = 14] = "SATURATION", o[o.COLOR = 15] = "COLOR", o[o.LUMINOSITY = 16] = "LUMINOSITY", o[o.NORMAL_NPM = 17] = "NORMAL_NPM", o[o.ADD_NPM = 18] = "ADD_NPM", o[o.SCREEN_NPM = 19] = "SCREEN_NPM", o[o.NONE = 20] = "NONE", o[o.SRC_OVER = 0] = "SRC_OVER", o[o.SRC_IN = 21] = "SRC_IN", o[o.SRC_OUT = 22] = "SRC_OUT", o[o.SRC_ATOP = 23] = "SRC_ATOP", o[o.DST_OVER = 24] = "DST_OVER", o[o.DST_IN = 25] = "DST_IN", o[o.DST_OUT = 26] = "DST_OUT", o[o.DST_ATOP = 27] = "DST_ATOP", o[o.ERASE = 26] = "ERASE", o[o.SUBTRACT = 28] = "SUBTRACT", o[o.XOR = 29] = "XOR";
})(BLEND_MODES$1 || (BLEND_MODES$1 = {}));
var DRAW_MODES$1;
(function(o) {
  o[o.POINTS = 0] = "POINTS", o[o.LINES = 1] = "LINES", o[o.LINE_LOOP = 2] = "LINE_LOOP", o[o.LINE_STRIP = 3] = "LINE_STRIP", o[o.TRIANGLES = 4] = "TRIANGLES", o[o.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", o[o.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$1 || (DRAW_MODES$1 = {}));
var FORMATS$1;
(function(o) {
  o[o.RGBA = 6408] = "RGBA", o[o.RGB = 6407] = "RGB", o[o.RG = 33319] = "RG", o[o.RED = 6403] = "RED", o[o.RGBA_INTEGER = 36249] = "RGBA_INTEGER", o[o.RGB_INTEGER = 36248] = "RGB_INTEGER", o[o.RG_INTEGER = 33320] = "RG_INTEGER", o[o.RED_INTEGER = 36244] = "RED_INTEGER", o[o.ALPHA = 6406] = "ALPHA", o[o.LUMINANCE = 6409] = "LUMINANCE", o[o.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", o[o.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", o[o.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS$1 || (FORMATS$1 = {}));
var TARGETS$1;
(function(o) {
  o[o.TEXTURE_2D = 3553] = "TEXTURE_2D", o[o.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", o[o.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", o[o.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", o[o.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", o[o.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", o[o.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$1 || (TARGETS$1 = {}));
var TYPES$1;
(function(o) {
  o[o.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", o[o.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", o[o.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", o[o.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", o[o.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", o[o.UNSIGNED_INT = 5125] = "UNSIGNED_INT", o[o.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", o[o.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", o[o.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", o[o.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", o[o.BYTE = 5120] = "BYTE", o[o.SHORT = 5122] = "SHORT", o[o.INT = 5124] = "INT", o[o.FLOAT = 5126] = "FLOAT", o[o.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", o[o.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES$1 || (TYPES$1 = {}));
var SAMPLER_TYPES$1;
(function(o) {
  o[o.FLOAT = 0] = "FLOAT", o[o.INT = 1] = "INT", o[o.UINT = 2] = "UINT";
})(SAMPLER_TYPES$1 || (SAMPLER_TYPES$1 = {}));
var SCALE_MODES$1;
(function(o) {
  o[o.NEAREST = 0] = "NEAREST", o[o.LINEAR = 1] = "LINEAR";
})(SCALE_MODES$1 || (SCALE_MODES$1 = {}));
var WRAP_MODES$1;
(function(o) {
  o[o.CLAMP = 33071] = "CLAMP", o[o.REPEAT = 10497] = "REPEAT", o[o.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$1 || (WRAP_MODES$1 = {}));
var MIPMAP_MODES$1;
(function(o) {
  o[o.OFF = 0] = "OFF", o[o.POW2 = 1] = "POW2", o[o.ON = 2] = "ON", o[o.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES$1 || (MIPMAP_MODES$1 = {}));
var ALPHA_MODES$1;
(function(o) {
  o[o.NPM = 0] = "NPM", o[o.UNPACK = 1] = "UNPACK", o[o.PMA = 2] = "PMA", o[o.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", o[o.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", o[o.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", o[o.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$1 || (ALPHA_MODES$1 = {}));
var CLEAR_MODES$1;
(function(o) {
  o[o.NO = 0] = "NO", o[o.YES = 1] = "YES", o[o.AUTO = 2] = "AUTO", o[o.BLEND = 0] = "BLEND", o[o.CLEAR = 1] = "CLEAR", o[o.BLIT = 2] = "BLIT";
})(CLEAR_MODES$1 || (CLEAR_MODES$1 = {}));
var GC_MODES$1;
(function(o) {
  o[o.AUTO = 0] = "AUTO", o[o.MANUAL = 1] = "MANUAL";
})(GC_MODES$1 || (GC_MODES$1 = {}));
var PRECISION$1;
(function(o) {
  o.LOW = "lowp", o.MEDIUM = "mediump", o.HIGH = "highp";
})(PRECISION$1 || (PRECISION$1 = {}));
var MASK_TYPES$1;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.SCISSOR = 1] = "SCISSOR", o[o.STENCIL = 2] = "STENCIL", o[o.SPRITE = 3] = "SPRITE", o[o.COLOR = 4] = "COLOR";
})(MASK_TYPES$1 || (MASK_TYPES$1 = {}));
var COLOR_MASK_BITS$1;
(function(o) {
  o[o.RED = 1] = "RED", o[o.GREEN = 2] = "GREEN", o[o.BLUE = 4] = "BLUE", o[o.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS$1 || (COLOR_MASK_BITS$1 = {}));
var MSAA_QUALITY$1;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.LOW = 2] = "LOW", o[o.MEDIUM = 4] = "MEDIUM", o[o.HIGH = 8] = "HIGH";
})(MSAA_QUALITY$1 || (MSAA_QUALITY$1 = {}));
var BUFFER_TYPE$1;
(function(o) {
  o[o.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", o[o.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", o[o.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$1 || (BUFFER_TYPE$1 = {}));
var BrowserAdapter = {
  createCanvas: function(o, t) {
    var e = document.createElement("canvas");
    return e.width = o, e.height = t, e;
  },
  getWebGLRenderingContext: function() {
    return WebGLRenderingContext;
  },
  getNavigator: function() {
    return navigator;
  },
  getBaseUrl: function() {
    var o;
    return (o = document.baseURI) !== null && o !== void 0 ? o : window.location.href;
  },
  fetch: function(o, t) {
    return fetch(o, t);
  }
}, appleIphone = /iPhone/i, appleIpod = /iPod/i, appleTablet = /iPad/i, appleUniversal = /\biOS-universal(?:.+)Mac\b/i, androidPhone = /\bAndroid(?:.+)Mobile\b/i, androidTablet = /Android/i, amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, amazonTablet = /Silk/i, windowsPhone = /Windows Phone/i, windowsTablet = /\bWindows(?:.+)ARM\b/i, otherBlackBerry = /BlackBerry/i, otherBlackBerry10 = /BB10/i, otherOpera = /Opera Mini/i, otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i, otherFirefox = /Mobile(?:.+)Firefox\b/i, isAppleTabletOnIos13 = function(o) {
  return typeof o < "u" && o.platform === "MacIntel" && typeof o.maxTouchPoints == "number" && o.maxTouchPoints > 1 && typeof MSStream > "u";
};
function createMatch(o) {
  return function(t) {
    return t.test(o);
  };
}
function isMobile$1(o) {
  var t = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  !o && typeof navigator < "u" ? t = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    maxTouchPoints: navigator.maxTouchPoints || 0
  } : typeof o == "string" ? t.userAgent = o : o && o.userAgent && (t = {
    userAgent: o.userAgent,
    platform: o.platform,
    maxTouchPoints: o.maxTouchPoints || 0
  });
  var e = t.userAgent, R = e.split("[FBAN");
  typeof R[1] < "u" && (e = R[0]), R = e.split("Twitter"), typeof R[1] < "u" && (e = R[0]);
  var N = createMatch(e), M = {
    apple: {
      phone: N(appleIphone) && !N(windowsPhone),
      ipod: N(appleIpod),
      tablet: !N(appleIphone) && (N(appleTablet) || isAppleTabletOnIos13(t)) && !N(windowsPhone),
      universal: N(appleUniversal),
      device: (N(appleIphone) || N(appleIpod) || N(appleTablet) || N(appleUniversal) || isAppleTabletOnIos13(t)) && !N(windowsPhone)
    },
    amazon: {
      phone: N(amazonPhone),
      tablet: !N(amazonPhone) && N(amazonTablet),
      device: N(amazonPhone) || N(amazonTablet)
    },
    android: {
      phone: !N(windowsPhone) && N(amazonPhone) || !N(windowsPhone) && N(androidPhone),
      tablet: !N(windowsPhone) && !N(amazonPhone) && !N(androidPhone) && (N(amazonTablet) || N(androidTablet)),
      device: !N(windowsPhone) && (N(amazonPhone) || N(amazonTablet) || N(androidPhone) || N(androidTablet)) || N(/\bokhttp\b/i)
    },
    windows: {
      phone: N(windowsPhone),
      tablet: N(windowsTablet),
      device: N(windowsPhone) || N(windowsTablet)
    },
    other: {
      blackberry: N(otherBlackBerry),
      blackberry10: N(otherBlackBerry10),
      opera: N(otherOpera),
      firefox: N(otherFirefox),
      chrome: N(otherChrome),
      device: N(otherBlackBerry) || N(otherBlackBerry10) || N(otherOpera) || N(otherFirefox) || N(otherChrome)
    },
    any: !1,
    phone: !1,
    tablet: !1
  };
  return M.any = M.apple.device || M.android.device || M.windows.device || M.other.device, M.phone = M.apple.phone || M.android.phone || M.windows.phone, M.tablet = M.apple.tablet || M.android.tablet || M.windows.tablet, M;
}
var isMobile = isMobile$1(globalThis.navigator);
function canUploadSameBuffer() {
  return !isMobile.apple.device;
}
function maxRecommendedTextures(o) {
  var t = !0;
  if (isMobile.tablet || isMobile.phone) {
    if (isMobile.apple.device) {
      var e = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (e) {
        var R = parseInt(e[1], 10);
        R < 11 && (t = !1);
      }
    }
    if (isMobile.android.device) {
      var e = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (e) {
        var R = parseInt(e[1], 10);
        R < 7 && (t = !1);
      }
    }
  }
  return t ? o : 4;
}
var settings = {
  ADAPTER: BrowserAdapter,
  MIPMAP_TEXTURES: MIPMAP_MODES$1.POW2,
  ANISOTROPIC_LEVEL: 0,
  RESOLUTION: 1,
  FILTER_RESOLUTION: 1,
  FILTER_MULTISAMPLE: MSAA_QUALITY$1.NONE,
  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
  SPRITE_BATCH_SIZE: 4096,
  RENDER_OPTIONS: {
    view: null,
    antialias: !1,
    autoDensity: !1,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: !0,
    clearBeforeRender: !0,
    preserveDrawingBuffer: !1,
    width: 800,
    height: 600,
    legacy: !1
  },
  GC_MODE: GC_MODES$1.AUTO,
  GC_MAX_IDLE: 60 * 60,
  GC_MAX_CHECK_COUNT: 60 * 10,
  WRAP_MODE: WRAP_MODES$1.CLAMP,
  SCALE_MODE: SCALE_MODES$1.LINEAR,
  PRECISION_VERTEX: PRECISION$1.HIGH,
  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION$1.HIGH : PRECISION$1.MEDIUM,
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
  CREATE_IMAGE_BITMAP: !1,
  ROUND_PIXELS: !1
}, commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function createCommonjsModule(o, t, e) {
  return e = {
    path: t,
    exports: {},
    require: function(R, N) {
      return commonjsRequire(R, N == null ? e.path : N);
    }
  }, o(e, e.exports), e.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
createCommonjsModule(function(o) {
  var t = Object.prototype.hasOwnProperty, e = "~";
  function R() {
  }
  Object.create && (R.prototype = /* @__PURE__ */ Object.create(null), new R().__proto__ || (e = !1));
  function N(B, $, U) {
    this.fn = B, this.context = $, this.once = U || !1;
  }
  function M(B, $, U, H, z) {
    if (typeof U != "function")
      throw new TypeError("The listener must be a function");
    var X = new N(U, H || B, z), Y = e ? e + $ : $;
    return B._events[Y] ? B._events[Y].fn ? B._events[Y] = [B._events[Y], X] : B._events[Y].push(X) : (B._events[Y] = X, B._eventsCount++), B;
  }
  function D(B, $) {
    --B._eventsCount === 0 ? B._events = new R() : delete B._events[$];
  }
  function L() {
    this._events = new R(), this._eventsCount = 0;
  }
  L.prototype.eventNames = function() {
    var $ = [], U, H;
    if (this._eventsCount === 0)
      return $;
    for (H in U = this._events)
      t.call(U, H) && $.push(e ? H.slice(1) : H);
    return Object.getOwnPropertySymbols ? $.concat(Object.getOwnPropertySymbols(U)) : $;
  }, L.prototype.listeners = function($) {
    var U = e ? e + $ : $, H = this._events[U];
    if (!H)
      return [];
    if (H.fn)
      return [H.fn];
    for (var z = 0, X = H.length, Y = new Array(X); z < X; z++)
      Y[z] = H[z].fn;
    return Y;
  }, L.prototype.listenerCount = function($) {
    var U = e ? e + $ : $, H = this._events[U];
    return H ? H.fn ? 1 : H.length : 0;
  }, L.prototype.emit = function($, U, H, z, X, Y) {
    var W = arguments, q = e ? e + $ : $;
    if (!this._events[q])
      return !1;
    var Z = this._events[q], K = arguments.length, J, Q;
    if (Z.fn) {
      switch (Z.once && this.removeListener($, Z.fn, void 0, !0), K) {
        case 1:
          return Z.fn.call(Z.context), !0;
        case 2:
          return Z.fn.call(Z.context, U), !0;
        case 3:
          return Z.fn.call(Z.context, U, H), !0;
        case 4:
          return Z.fn.call(Z.context, U, H, z), !0;
        case 5:
          return Z.fn.call(Z.context, U, H, z, X), !0;
        case 6:
          return Z.fn.call(Z.context, U, H, z, X, Y), !0;
      }
      for (Q = 1, J = new Array(K - 1); Q < K; Q++)
        J[Q - 1] = W[Q];
      Z.fn.apply(Z.context, J);
    } else {
      var et = Z.length, tt;
      for (Q = 0; Q < et; Q++)
        switch (Z[Q].once && this.removeListener($, Z[Q].fn, void 0, !0), K) {
          case 1:
            Z[Q].fn.call(Z[Q].context);
            break;
          case 2:
            Z[Q].fn.call(Z[Q].context, U);
            break;
          case 3:
            Z[Q].fn.call(Z[Q].context, U, H);
            break;
          case 4:
            Z[Q].fn.call(Z[Q].context, U, H, z);
            break;
          default:
            if (!J)
              for (tt = 1, J = new Array(K - 1); tt < K; tt++)
                J[tt - 1] = W[tt];
            Z[Q].fn.apply(Z[Q].context, J);
        }
    }
    return !0;
  }, L.prototype.on = function($, U, H) {
    return M(this, $, U, H, !1);
  }, L.prototype.once = function($, U, H) {
    return M(this, $, U, H, !0);
  }, L.prototype.removeListener = function($, U, H, z) {
    var X = e ? e + $ : $;
    if (!this._events[X])
      return this;
    if (!U)
      return D(this, X), this;
    var Y = this._events[X];
    if (Y.fn)
      Y.fn === U && (!z || Y.once) && (!H || Y.context === H) && D(this, X);
    else {
      for (var W = 0, q = [], Z = Y.length; W < Z; W++)
        (Y[W].fn !== U || z && !Y[W].once || H && Y[W].context !== H) && q.push(Y[W]);
      q.length ? this._events[X] = q.length === 1 ? q[0] : q : D(this, X);
    }
    return this;
  }, L.prototype.removeAllListeners = function($) {
    var U;
    return $ ? (U = e ? e + $ : $, this._events[U] && D(this, U)) : (this._events = new R(), this._eventsCount = 0), this;
  }, L.prototype.off = L.prototype.removeListener, L.prototype.addListener = L.prototype.on, L.prefixed = e, L.EventEmitter = L, o.exports = L;
});
createCommonjsModule(function(o, t) {
  (function(e) {
    var R = t && !t.nodeType && t, N = o && !o.nodeType && o, M = typeof commonjsGlobal == "object" && commonjsGlobal;
    (M.global === M || M.window === M || M.self === M) && (e = M);
    var D, L = 2147483647, B = 36, $ = 1, U = 26, H = 38, z = 700, X = 72, Y = 128, W = "-", q = /^xn--/, Z = /[^\x20-\x7E]/, K = /[\x2E\u3002\uFF0E\uFF61]/g, J = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, Q = B - $, et = Math.floor, tt = String.fromCharCode, st;
    function rt(ht) {
      throw RangeError(J[ht]);
    }
    function at(ht, bt) {
      for (var Ct = ht.length, Mt = []; Ct--; )
        Mt[Ct] = bt(ht[Ct]);
      return Mt;
    }
    function ut(ht, bt) {
      var Ct = ht.split("@"), Mt = "";
      Ct.length > 1 && (Mt = Ct[0] + "@", ht = Ct[1]), ht = ht.replace(K, ".");
      var wt = ht.split("."), Lt = at(wt, bt).join(".");
      return Mt + Lt;
    }
    function dt(ht) {
      for (var bt = [], Ct = 0, Mt = ht.length, wt, Lt; Ct < Mt; )
        wt = ht.charCodeAt(Ct++), wt >= 55296 && wt <= 56319 && Ct < Mt ? (Lt = ht.charCodeAt(Ct++), (Lt & 64512) == 56320 ? bt.push(((wt & 1023) << 10) + (Lt & 1023) + 65536) : (bt.push(wt), Ct--)) : bt.push(wt);
      return bt;
    }
    function ct(ht) {
      return at(ht, function(bt) {
        var Ct = "";
        return bt > 65535 && (bt -= 65536, Ct += tt(bt >>> 10 & 1023 | 55296), bt = 56320 | bt & 1023), Ct += tt(bt), Ct;
      }).join("");
    }
    function pt(ht) {
      return ht - 48 < 10 ? ht - 22 : ht - 65 < 26 ? ht - 65 : ht - 97 < 26 ? ht - 97 : B;
    }
    function mt(ht, bt) {
      return ht + 22 + 75 * (ht < 26) - ((bt != 0) << 5);
    }
    function vt(ht, bt, Ct) {
      var Mt = 0;
      for (ht = Ct ? et(ht / z) : ht >> 1, ht += et(ht / bt); ht > Q * U >> 1; Mt += B)
        ht = et(ht / Q);
      return et(Mt + (Q + 1) * ht / (ht + H));
    }
    function _t(ht) {
      var bt = [], Ct = ht.length, Mt, wt = 0, Lt = Y, ft = X, Gt, Dt, Bt, Ot, Et, Ht, It, St, Nt;
      for (Gt = ht.lastIndexOf(W), Gt < 0 && (Gt = 0), Dt = 0; Dt < Gt; ++Dt)
        ht.charCodeAt(Dt) >= 128 && rt("not-basic"), bt.push(ht.charCodeAt(Dt));
      for (Bt = Gt > 0 ? Gt + 1 : 0; Bt < Ct; ) {
        for (Ot = wt, Et = 1, Ht = B; Bt >= Ct && rt("invalid-input"), It = pt(ht.charCodeAt(Bt++)), (It >= B || It > et((L - wt) / Et)) && rt("overflow"), wt += It * Et, St = Ht <= ft ? $ : Ht >= ft + U ? U : Ht - ft, !(It < St); Ht += B)
          Nt = B - St, Et > et(L / Nt) && rt("overflow"), Et *= Nt;
        Mt = bt.length + 1, ft = vt(wt - Ot, Mt, Ot == 0), et(wt / Mt) > L - Lt && rt("overflow"), Lt += et(wt / Mt), wt %= Mt, bt.splice(wt++, 0, Lt);
      }
      return ct(bt);
    }
    function xt(ht) {
      var bt, Ct, Mt, wt, Lt, ft, Gt, Dt, Bt, Ot, Et, Ht = [], It, St, Nt, $t;
      for (ht = dt(ht), It = ht.length, bt = Y, Ct = 0, Lt = X, ft = 0; ft < It; ++ft)
        Et = ht[ft], Et < 128 && Ht.push(tt(Et));
      for (Mt = wt = Ht.length, wt && Ht.push(W); Mt < It; ) {
        for (Gt = L, ft = 0; ft < It; ++ft)
          Et = ht[ft], Et >= bt && Et < Gt && (Gt = Et);
        for (St = Mt + 1, Gt - bt > et((L - Ct) / St) && rt("overflow"), Ct += (Gt - bt) * St, bt = Gt, ft = 0; ft < It; ++ft)
          if (Et = ht[ft], Et < bt && ++Ct > L && rt("overflow"), Et == bt) {
            for (Dt = Ct, Bt = B; Ot = Bt <= Lt ? $ : Bt >= Lt + U ? U : Bt - Lt, !(Dt < Ot); Bt += B)
              $t = Dt - Ot, Nt = B - Ot, Ht.push(
                tt(mt(Ot + $t % Nt, 0))
              ), Dt = et($t / Nt);
            Ht.push(tt(mt(Dt, 0))), Lt = vt(Ct, St, Mt == wt), Ct = 0, ++Mt;
          }
        ++Ct, ++bt;
      }
      return Ht.join("");
    }
    function At(ht) {
      return ut(ht, function(bt) {
        return q.test(bt) ? _t(bt.slice(4).toLowerCase()) : bt;
      });
    }
    function yt(ht) {
      return ut(ht, function(bt) {
        return Z.test(bt) ? "xn--" + xt(bt) : bt;
      });
    }
    if (D = {
      version: "1.3.2",
      ucs2: {
        decode: dt,
        encode: ct
      },
      decode: _t,
      encode: xt,
      toASCII: yt,
      toUnicode: At
    }, R && N)
      if (o.exports == R)
        N.exports = D;
      else
        for (st in D)
          D.hasOwnProperty(st) && (R[st] = D[st]);
    else
      e.punycode = D;
  })(commonjsGlobal);
});
function hasOwnProperty(o, t) {
  return Object.prototype.hasOwnProperty.call(o, t);
}
var decode$2 = function(o, t, e, R) {
  t = t || "&", e = e || "=";
  var N = {};
  if (typeof o != "string" || o.length === 0)
    return N;
  var M = /\+/g;
  o = o.split(t);
  var D = 1e3;
  R && typeof R.maxKeys == "number" && (D = R.maxKeys);
  var L = o.length;
  D > 0 && L > D && (L = D);
  for (var B = 0; B < L; ++B) {
    var $ = o[B].replace(M, "%20"), U = $.indexOf(e), H, z, X, Y;
    U >= 0 ? (H = $.substr(0, U), z = $.substr(U + 1)) : (H = $, z = ""), X = decodeURIComponent(H), Y = decodeURIComponent(z), hasOwnProperty(N, X) ? Array.isArray(N[X]) ? N[X].push(Y) : N[X] = [N[X], Y] : N[X] = Y;
  }
  return N;
}, stringifyPrimitive = function(o) {
  switch (typeof o) {
    case "string":
      return o;
    case "boolean":
      return o ? "true" : "false";
    case "number":
      return isFinite(o) ? o : "";
    default:
      return "";
  }
}, encode$2 = function(o, t, e, R) {
  return t = t || "&", e = e || "=", o === null && (o = void 0), typeof o == "object" ? Object.keys(o).map(function(N) {
    var M = encodeURIComponent(stringifyPrimitive(N)) + e;
    return Array.isArray(o[N]) ? o[N].map(function(D) {
      return M + encodeURIComponent(stringifyPrimitive(D));
    }).join(t) : M + encodeURIComponent(stringifyPrimitive(o[N]));
  }).join(t) : R ? encodeURIComponent(stringifyPrimitive(R)) + e + encodeURIComponent(stringifyPrimitive(o)) : "";
};
createCommonjsModule(function(o, t) {
  t.decode = t.parse = decode$2, t.encode = t.stringify = encode$2;
});
/*!
 * @pixi/constants - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV;
(function(o) {
  o[o.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", o[o.WEBGL = 1] = "WEBGL", o[o.WEBGL2 = 2] = "WEBGL2";
})(ENV || (ENV = {}));
var RENDERER_TYPE;
(function(o) {
  o[o.UNKNOWN = 0] = "UNKNOWN", o[o.WEBGL = 1] = "WEBGL", o[o.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE || (RENDERER_TYPE = {}));
var BUFFER_BITS;
(function(o) {
  o[o.COLOR = 16384] = "COLOR", o[o.DEPTH = 256] = "DEPTH", o[o.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS || (BUFFER_BITS = {}));
var BLEND_MODES;
(function(o) {
  o[o.NORMAL = 0] = "NORMAL", o[o.ADD = 1] = "ADD", o[o.MULTIPLY = 2] = "MULTIPLY", o[o.SCREEN = 3] = "SCREEN", o[o.OVERLAY = 4] = "OVERLAY", o[o.DARKEN = 5] = "DARKEN", o[o.LIGHTEN = 6] = "LIGHTEN", o[o.COLOR_DODGE = 7] = "COLOR_DODGE", o[o.COLOR_BURN = 8] = "COLOR_BURN", o[o.HARD_LIGHT = 9] = "HARD_LIGHT", o[o.SOFT_LIGHT = 10] = "SOFT_LIGHT", o[o.DIFFERENCE = 11] = "DIFFERENCE", o[o.EXCLUSION = 12] = "EXCLUSION", o[o.HUE = 13] = "HUE", o[o.SATURATION = 14] = "SATURATION", o[o.COLOR = 15] = "COLOR", o[o.LUMINOSITY = 16] = "LUMINOSITY", o[o.NORMAL_NPM = 17] = "NORMAL_NPM", o[o.ADD_NPM = 18] = "ADD_NPM", o[o.SCREEN_NPM = 19] = "SCREEN_NPM", o[o.NONE = 20] = "NONE", o[o.SRC_OVER = 0] = "SRC_OVER", o[o.SRC_IN = 21] = "SRC_IN", o[o.SRC_OUT = 22] = "SRC_OUT", o[o.SRC_ATOP = 23] = "SRC_ATOP", o[o.DST_OVER = 24] = "DST_OVER", o[o.DST_IN = 25] = "DST_IN", o[o.DST_OUT = 26] = "DST_OUT", o[o.DST_ATOP = 27] = "DST_ATOP", o[o.ERASE = 26] = "ERASE", o[o.SUBTRACT = 28] = "SUBTRACT", o[o.XOR = 29] = "XOR";
})(BLEND_MODES || (BLEND_MODES = {}));
var DRAW_MODES;
(function(o) {
  o[o.POINTS = 0] = "POINTS", o[o.LINES = 1] = "LINES", o[o.LINE_LOOP = 2] = "LINE_LOOP", o[o.LINE_STRIP = 3] = "LINE_STRIP", o[o.TRIANGLES = 4] = "TRIANGLES", o[o.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", o[o.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES || (DRAW_MODES = {}));
var FORMATS;
(function(o) {
  o[o.RGBA = 6408] = "RGBA", o[o.RGB = 6407] = "RGB", o[o.RG = 33319] = "RG", o[o.RED = 6403] = "RED", o[o.RGBA_INTEGER = 36249] = "RGBA_INTEGER", o[o.RGB_INTEGER = 36248] = "RGB_INTEGER", o[o.RG_INTEGER = 33320] = "RG_INTEGER", o[o.RED_INTEGER = 36244] = "RED_INTEGER", o[o.ALPHA = 6406] = "ALPHA", o[o.LUMINANCE = 6409] = "LUMINANCE", o[o.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", o[o.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", o[o.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS || (FORMATS = {}));
var TARGETS;
(function(o) {
  o[o.TEXTURE_2D = 3553] = "TEXTURE_2D", o[o.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", o[o.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", o[o.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", o[o.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", o[o.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", o[o.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS || (TARGETS = {}));
var TYPES;
(function(o) {
  o[o.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", o[o.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", o[o.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", o[o.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", o[o.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", o[o.UNSIGNED_INT = 5125] = "UNSIGNED_INT", o[o.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", o[o.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", o[o.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", o[o.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", o[o.BYTE = 5120] = "BYTE", o[o.SHORT = 5122] = "SHORT", o[o.INT = 5124] = "INT", o[o.FLOAT = 5126] = "FLOAT", o[o.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", o[o.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES || (TYPES = {}));
var SAMPLER_TYPES;
(function(o) {
  o[o.FLOAT = 0] = "FLOAT", o[o.INT = 1] = "INT", o[o.UINT = 2] = "UINT";
})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));
var SCALE_MODES;
(function(o) {
  o[o.NEAREST = 0] = "NEAREST", o[o.LINEAR = 1] = "LINEAR";
})(SCALE_MODES || (SCALE_MODES = {}));
var WRAP_MODES;
(function(o) {
  o[o.CLAMP = 33071] = "CLAMP", o[o.REPEAT = 10497] = "REPEAT", o[o.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES || (WRAP_MODES = {}));
var MIPMAP_MODES;
(function(o) {
  o[o.OFF = 0] = "OFF", o[o.POW2 = 1] = "POW2", o[o.ON = 2] = "ON", o[o.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES || (MIPMAP_MODES = {}));
var ALPHA_MODES;
(function(o) {
  o[o.NPM = 0] = "NPM", o[o.UNPACK = 1] = "UNPACK", o[o.PMA = 2] = "PMA", o[o.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", o[o.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", o[o.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", o[o.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES || (ALPHA_MODES = {}));
var CLEAR_MODES;
(function(o) {
  o[o.NO = 0] = "NO", o[o.YES = 1] = "YES", o[o.AUTO = 2] = "AUTO", o[o.BLEND = 0] = "BLEND", o[o.CLEAR = 1] = "CLEAR", o[o.BLIT = 2] = "BLIT";
})(CLEAR_MODES || (CLEAR_MODES = {}));
var GC_MODES;
(function(o) {
  o[o.AUTO = 0] = "AUTO", o[o.MANUAL = 1] = "MANUAL";
})(GC_MODES || (GC_MODES = {}));
var PRECISION;
(function(o) {
  o.LOW = "lowp", o.MEDIUM = "mediump", o.HIGH = "highp";
})(PRECISION || (PRECISION = {}));
var MASK_TYPES;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.SCISSOR = 1] = "SCISSOR", o[o.STENCIL = 2] = "STENCIL", o[o.SPRITE = 3] = "SPRITE", o[o.COLOR = 4] = "COLOR";
})(MASK_TYPES || (MASK_TYPES = {}));
var COLOR_MASK_BITS;
(function(o) {
  o[o.RED = 1] = "RED", o[o.GREEN = 2] = "GREEN", o[o.BLUE = 4] = "BLUE", o[o.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS || (COLOR_MASK_BITS = {}));
var MSAA_QUALITY;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.LOW = 2] = "LOW", o[o.MEDIUM = 4] = "MEDIUM", o[o.HIGH = 8] = "HIGH";
})(MSAA_QUALITY || (MSAA_QUALITY = {}));
var BUFFER_TYPE;
(function(o) {
  o[o.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", o[o.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", o[o.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE || (BUFFER_TYPE = {}));
/*!
 * @pixi/utils - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
function mapPremultipliedBlendModes() {
  for (var o = [], t = [], e = 0; e < 32; e++)
    o[e] = e, t[e] = e;
  o[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL, o[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD, o[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN, t[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM, t[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM, t[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
  var R = [];
  return R.push(t), R.push(o), R;
}
mapPremultipliedBlendModes();
var warnings = {};
function deprecation(o, t, e) {
  if (e === void 0 && (e = 3), !warnings[t]) {
    var R = new Error().stack;
    typeof R > "u" ? console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + o) : (R = R.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", t + `
Deprecated since v` + o), console.warn(R), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + o), console.warn(R))), warnings[t] = !0;
  }
}
(function() {
  function o(t, e, R) {
    this.canvas = settings.ADAPTER.createCanvas(), this.context = this.canvas.getContext("2d"), this.resolution = R || settings.RESOLUTION, this.resize(t, e);
  }
  return o.prototype.clear = function() {
    this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }, o.prototype.resize = function(t, e) {
    this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);
  }, o.prototype.destroy = function() {
    this.context = null, this.canvas = null;
  }, Object.defineProperty(o.prototype, "width", {
    get: function() {
      return this.canvas.width;
    },
    set: function(t) {
      this.canvas.width = Math.round(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "height", {
    get: function() {
      return this.canvas.height;
    },
    set: function(t) {
      this.canvas.height = Math.round(t);
    },
    enumerable: !1,
    configurable: !0
  }), o;
})();
var Application = function() {
  function o(t) {
    var e = this;
    this.stage = new Container(), t = Object.assign({
      forceCanvas: !1
    }, t), this.renderer = autoDetectRenderer(t), o._plugins.forEach(function(R) {
      R.init.call(e, t);
    });
  }
  return o.registerPlugin = function(t) {
    deprecation("6.5.0", "Application.registerPlugin() is deprecated, use extensions.add()"), extensions.add({
      type: ExtensionType.Application,
      ref: t
    });
  }, o.prototype.render = function() {
    this.renderer.render(this.stage);
  }, Object.defineProperty(o.prototype, "view", {
    get: function() {
      return this.renderer.view;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(o.prototype, "screen", {
    get: function() {
      return this.renderer.screen;
    },
    enumerable: !1,
    configurable: !0
  }), o.prototype.destroy = function(t, e) {
    var R = this, N = o._plugins.slice(0);
    N.reverse(), N.forEach(function(M) {
      M.destroy.call(R);
    }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;
  }, o._plugins = [], o;
}();
extensions.handleByList(ExtensionType.Application, Application._plugins);
extensions.add(ResizePlugin);
/*!
 * @pixi/mesh-extras - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/mesh-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$8 = function(o, t) {
  return extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$8(o, t);
};
function __extends$8(o, t) {
  extendStatics$8(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var PlaneGeometry = function(o) {
  __extends$8(t, o);
  function t(e, R, N, M) {
    e === void 0 && (e = 100), R === void 0 && (R = 100), N === void 0 && (N = 10), M === void 0 && (M = 10);
    var D = o.call(this) || this;
    return D.segWidth = N, D.segHeight = M, D.width = e, D.height = R, D.build(), D;
  }
  return t.prototype.build = function() {
    for (var e = this.segWidth * this.segHeight, R = [], N = [], M = [], D = this.segWidth - 1, L = this.segHeight - 1, B = this.width / D, $ = this.height / L, U = 0; U < e; U++) {
      var H = U % this.segWidth, z = U / this.segWidth | 0;
      R.push(H * B, z * $), N.push(H / D, z / L);
    }
    for (var X = D * L, U = 0; U < X; U++) {
      var Y = U % D, W = U / D | 0, q = W * this.segWidth + Y, Z = W * this.segWidth + Y + 1, K = (W + 1) * this.segWidth + Y, J = (W + 1) * this.segWidth + Y + 1;
      M.push(q, Z, K, Z, J, K);
    }
    this.buffers[0].data = new Float32Array(R), this.buffers[1].data = new Float32Array(N), this.indexBuffer.data = new Uint16Array(M), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
  }, t;
}(MeshGeometry), RopeGeometry = function(o) {
  __extends$8(t, o);
  function t(e, R, N) {
    e === void 0 && (e = 200), N === void 0 && (N = 0);
    var M = o.call(this, new Float32Array(R.length * 4), new Float32Array(R.length * 4), new Uint16Array((R.length - 1) * 6)) || this;
    return M.points = R, M._width = e, M.textureScale = N, M.build(), M;
  }
  return Object.defineProperty(t.prototype, "width", {
    get: function() {
      return this._width;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.build = function() {
    var e = this.points;
    if (!!e) {
      var R = this.getBuffer("aVertexPosition"), N = this.getBuffer("aTextureCoord"), M = this.getIndex();
      if (!(e.length < 1)) {
        R.data.length / 4 !== e.length && (R.data = new Float32Array(e.length * 4), N.data = new Float32Array(e.length * 4), M.data = new Uint16Array((e.length - 1) * 6));
        var D = N.data, L = M.data;
        D[0] = 0, D[1] = 0, D[2] = 0, D[3] = 1;
        for (var B = 0, $ = e[0], U = this._width * this.textureScale, H = e.length, z = 0; z < H; z++) {
          var X = z * 4;
          if (this.textureScale > 0) {
            var Y = $.x - e[z].x, W = $.y - e[z].y, q = Math.sqrt(Y * Y + W * W);
            $ = e[z], B += q / U;
          } else
            B = z / (H - 1);
          D[X] = B, D[X + 1] = 0, D[X + 2] = B, D[X + 3] = 1;
        }
        for (var Z = 0, z = 0; z < H - 1; z++) {
          var X = z * 2;
          L[Z++] = X, L[Z++] = X + 1, L[Z++] = X + 2, L[Z++] = X + 2, L[Z++] = X + 1, L[Z++] = X + 3;
        }
        N.update(), M.update(), this.updateVertices();
      }
    }
  }, t.prototype.updateVertices = function() {
    var e = this.points;
    if (!(e.length < 1)) {
      for (var R = e[0], N, M = 0, D = 0, L = this.buffers[0].data, B = e.length, $ = 0; $ < B; $++) {
        var U = e[$], H = $ * 4;
        $ < e.length - 1 ? N = e[$ + 1] : N = U, D = -(N.x - R.x), M = N.y - R.y;
        var z = Math.sqrt(M * M + D * D), X = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
        M /= z, D /= z, M *= X, D *= X, L[H] = U.x + M, L[H + 1] = U.y + D, L[H + 2] = U.x - M, L[H + 3] = U.y - D, R = U;
      }
      this.buffers[0].update();
    }
  }, t.prototype.update = function() {
    this.textureScale > 0 ? this.build() : this.updateVertices();
  }, t;
}(MeshGeometry);
(function(o) {
  __extends$8(t, o);
  function t(e, R, N) {
    N === void 0 && (N = 0);
    var M = this, D = new RopeGeometry(e.height, R, N), L = new MeshMaterial(e);
    return N > 0 && (e.baseTexture.wrapMode = WRAP_MODES$5.REPEAT), M = o.call(this, D, L) || this, M.autoUpdate = !0, M;
  }
  return t.prototype._render = function(e) {
    var R = this.geometry;
    (this.autoUpdate || R._width !== this.shader.texture.height) && (R._width = this.shader.texture.height, R.update()), o.prototype._render.call(this, e);
  }, t;
})(Mesh);
var SimplePlane = function(o) {
  __extends$8(t, o);
  function t(e, R, N) {
    var M = this, D = new PlaneGeometry(e.width, e.height, R, N), L = new MeshMaterial(Texture.WHITE);
    return M = o.call(this, D, L) || this, M.texture = e, M.autoResize = !0, M;
  }
  return t.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID;
    var e = this.geometry, R = this.shader.texture, N = R.width, M = R.height;
    this.autoResize && (e.width !== N || e.height !== M) && (e.width = this.shader.texture.width, e.height = this.shader.texture.height, e.build());
  }, Object.defineProperty(t.prototype, "texture", {
    get: function() {
      return this.shader.texture;
    },
    set: function(e) {
      this.shader.texture !== e && (this.shader.texture = e, this._textureID = -1, e.baseTexture.valid ? this.textureUpdated() : e.once("update", this.textureUpdated, this));
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._render = function(e) {
    this._textureID !== this.shader.texture._updateID && this.textureUpdated(), o.prototype._render.call(this, e);
  }, t.prototype.destroy = function(e) {
    this.shader.texture.off("update", this.textureUpdated, this), o.prototype.destroy.call(this, e);
  }, t;
}(Mesh);
(function(o) {
  __extends$8(t, o);
  function t(e, R, N, M, D) {
    e === void 0 && (e = Texture.EMPTY);
    var L = this, B = new MeshGeometry(R, N, M);
    B.getBuffer("aVertexPosition").static = !1;
    var $ = new MeshMaterial(e);
    return L = o.call(this, B, $, null, D) || this, L.autoUpdate = !0, L;
  }
  return Object.defineProperty(t.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(e) {
      this.geometry.getBuffer("aVertexPosition").data = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._render = function(e) {
    this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), o.prototype._render.call(this, e);
  }, t;
})(Mesh);
var DEFAULT_BORDER_SIZE = 10;
(function(o) {
  __extends$8(t, o);
  function t(e, R, N, M, D) {
    R === void 0 && (R = DEFAULT_BORDER_SIZE), N === void 0 && (N = DEFAULT_BORDER_SIZE), M === void 0 && (M = DEFAULT_BORDER_SIZE), D === void 0 && (D = DEFAULT_BORDER_SIZE);
    var L = o.call(this, Texture.WHITE, 4, 4) || this;
    return L._origWidth = e.orig.width, L._origHeight = e.orig.height, L._width = L._origWidth, L._height = L._origHeight, L._leftWidth = R, L._rightWidth = M, L._topHeight = N, L._bottomHeight = D, L.texture = e, L;
  }
  return t.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID, this._refresh();
  }, Object.defineProperty(t.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(e) {
      this.geometry.getBuffer("aVertexPosition").data = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.updateHorizontalVertices = function() {
    var e = this.vertices, R = this._getMinScale();
    e[9] = e[11] = e[13] = e[15] = this._topHeight * R, e[17] = e[19] = e[21] = e[23] = this._height - this._bottomHeight * R, e[25] = e[27] = e[29] = e[31] = this._height;
  }, t.prototype.updateVerticalVertices = function() {
    var e = this.vertices, R = this._getMinScale();
    e[2] = e[10] = e[18] = e[26] = this._leftWidth * R, e[4] = e[12] = e[20] = e[28] = this._width - this._rightWidth * R, e[6] = e[14] = e[22] = e[30] = this._width;
  }, t.prototype._getMinScale = function() {
    var e = this._leftWidth + this._rightWidth, R = this._width > e ? 1 : this._width / e, N = this._topHeight + this._bottomHeight, M = this._height > N ? 1 : this._height / N, D = Math.min(R, M);
    return D;
  }, Object.defineProperty(t.prototype, "width", {
    get: function() {
      return this._width;
    },
    set: function(e) {
      this._width = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    get: function() {
      return this._height;
    },
    set: function(e) {
      this._height = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "leftWidth", {
    get: function() {
      return this._leftWidth;
    },
    set: function(e) {
      this._leftWidth = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "rightWidth", {
    get: function() {
      return this._rightWidth;
    },
    set: function(e) {
      this._rightWidth = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "topHeight", {
    get: function() {
      return this._topHeight;
    },
    set: function(e) {
      this._topHeight = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "bottomHeight", {
    get: function() {
      return this._bottomHeight;
    },
    set: function(e) {
      this._bottomHeight = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._refresh = function() {
    var e = this.texture, R = this.geometry.buffers[1].data;
    this._origWidth = e.orig.width, this._origHeight = e.orig.height;
    var N = 1 / this._origWidth, M = 1 / this._origHeight;
    R[0] = R[8] = R[16] = R[24] = 0, R[1] = R[3] = R[5] = R[7] = 0, R[6] = R[14] = R[22] = R[30] = 1, R[25] = R[27] = R[29] = R[31] = 1, R[2] = R[10] = R[18] = R[26] = N * this._leftWidth, R[4] = R[12] = R[20] = R[28] = 1 - N * this._rightWidth, R[9] = R[11] = R[13] = R[15] = M * this._topHeight, R[17] = R[19] = R[21] = R[23] = 1 - M * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();
  }, t;
})(SimplePlane);
/*!
 * @pixi/sprite-animated - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * @pixi/sprite-animated is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$7 = function(o, t) {
  return extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$7(o, t);
};
function __extends$7(o, t) {
  extendStatics$7(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var AnimatedSprite = function(o) {
  __extends$7(t, o);
  function t(e, R) {
    R === void 0 && (R = !0);
    var N = o.call(this, e[0] instanceof Texture ? e[0] : e[0].texture) || this;
    return N._textures = null, N._durations = null, N._autoUpdate = R, N._isConnectedToTicker = !1, N.animationSpeed = 1, N.loop = !0, N.updateAnchor = !1, N.onComplete = null, N.onFrameChange = null, N.onLoop = null, N._currentTime = 0, N._playing = !1, N._previousFrame = null, N.textures = e, N;
  }
  return t.prototype.stop = function() {
    !this._playing || (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1));
  }, t.prototype.play = function() {
    this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH), this._isConnectedToTicker = !0));
  }, t.prototype.gotoAndStop = function(e) {
    this.stop();
    var R = this.currentFrame;
    this._currentTime = e, R !== this.currentFrame && this.updateTexture();
  }, t.prototype.gotoAndPlay = function(e) {
    var R = this.currentFrame;
    this._currentTime = e, R !== this.currentFrame && this.updateTexture(), this.play();
  }, t.prototype.update = function(e) {
    if (!!this._playing) {
      var R = this.animationSpeed * e, N = this.currentFrame;
      if (this._durations !== null) {
        var M = this._currentTime % 1 * this._durations[this.currentFrame];
        for (M += R / 60 * 1e3; M < 0; )
          this._currentTime--, M += this._durations[this.currentFrame];
        var D = Math.sign(this.animationSpeed * e);
        for (this._currentTime = Math.floor(this._currentTime); M >= this._durations[this.currentFrame]; )
          M -= this._durations[this.currentFrame] * D, this._currentTime += D;
        this._currentTime += M / this._durations[this.currentFrame];
      } else
        this._currentTime += R;
      this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : N !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < N ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > N && this.onLoop()), this.updateTexture());
    }
  }, t.prototype.updateTexture = function() {
    var e = this.currentFrame;
    this._previousFrame !== e && (this._previousFrame = e, this._texture = this._textures[e], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));
  }, t.prototype.destroy = function(e) {
    this.stop(), o.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;
  }, t.fromFrames = function(e) {
    for (var R = [], N = 0; N < e.length; ++N)
      R.push(Texture.from(e[N]));
    return new t(R);
  }, t.fromImages = function(e) {
    for (var R = [], N = 0; N < e.length; ++N)
      R.push(Texture.from(e[N]));
    return new t(R);
  }, Object.defineProperty(t.prototype, "totalFrames", {
    get: function() {
      return this._textures.length;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textures", {
    get: function() {
      return this._textures;
    },
    set: function(e) {
      if (e[0] instanceof Texture)
        this._textures = e, this._durations = null;
      else {
        this._textures = [], this._durations = [];
        for (var R = 0; R < e.length; R++)
          this._textures.push(e[R].texture), this._durations.push(e[R].time);
      }
      this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "currentFrame", {
    get: function() {
      var e = Math.floor(this._currentTime) % this._textures.length;
      return e < 0 && (e += this._textures.length), e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "playing", {
    get: function() {
      return this._playing;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "autoUpdate", {
    get: function() {
      return this._autoUpdate;
    },
    set: function(e) {
      e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Sprite);
/*!
 * pixi.js - v6.5.3
 * Compiled Fri, 09 Sep 2022 13:55:20 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
extensions.add(
  AccessibilityManager,
  Extract,
  InteractionManager,
  ParticleRenderer,
  Prepare,
  BatchRenderer,
  TilingSpriteRenderer,
  BitmapFontLoader,
  CompressedTextureLoader,
  DDSLoader,
  KTXLoader,
  SpritesheetLoader,
  TickerPlugin,
  AppLoaderPlugin
);
var bi;
class EventListenerCtn {
  constructor() {
    nt(this, bi, []);
  }
  add(t, e, R, N = {}) {
    if (t instanceof BaseTexture) {
      switch (e) {
        case "loaded":
        case "update":
        case "error":
        case "dispose":
          t.on(e, R, N), V(this, bi).push(() => t.off(e, R, N));
          break;
      }
      return;
    }
    if (t instanceof n) {
      t.on(e, R, N), V(this, bi).push(() => t.off(e, R, N));
      return;
    }
    t.addEventListener(e, R, N), V(this, bi).push(() => {
      var M;
      return t.removeEventListener(e, R, { capture: (M = N.capture) != null ? M : !1 });
    });
  }
  clear() {
    V(this, bi).forEach((t) => t()), it(this, bi, []);
  }
}
bi = new WeakMap();
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES.open = "0";
PACKET_TYPES.close = "1";
PACKET_TYPES.ping = "2";
PACKET_TYPES.pong = "3";
PACKET_TYPES.message = "4";
PACKET_TYPES.upgrade = "5";
PACKET_TYPES.noop = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((o) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[o]] = o;
});
const ERROR_PACKET = { type: "error", data: "parser error" }, withNativeBlob$1 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", withNativeArrayBuffer$2 = typeof ArrayBuffer == "function", isView$1 = (o) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(o) : o && o.buffer instanceof ArrayBuffer, encodePacket = ({ type: o, data: t }, e, R) => withNativeBlob$1 && t instanceof Blob ? e ? R(t) : encodeBlobAsBase64(t, R) : withNativeArrayBuffer$2 && (t instanceof ArrayBuffer || isView$1(t)) ? e ? R(t) : encodeBlobAsBase64(new Blob([t]), R) : R(PACKET_TYPES[o] + (t || "")), encodeBlobAsBase64 = (o, t) => {
  const e = new FileReader();
  return e.onload = function() {
    const R = e.result.split(",")[1];
    t("b" + R);
  }, e.readAsDataURL(o);
}, chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup$1 = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let o = 0; o < chars.length; o++)
  lookup$1[chars.charCodeAt(o)] = o;
const decode$1 = (o) => {
  let t = o.length * 0.75, e = o.length, R, N = 0, M, D, L, B;
  o[o.length - 1] === "=" && (t--, o[o.length - 2] === "=" && t--);
  const $ = new ArrayBuffer(t), U = new Uint8Array($);
  for (R = 0; R < e; R += 4)
    M = lookup$1[o.charCodeAt(R)], D = lookup$1[o.charCodeAt(R + 1)], L = lookup$1[o.charCodeAt(R + 2)], B = lookup$1[o.charCodeAt(R + 3)], U[N++] = M << 2 | D >> 4, U[N++] = (D & 15) << 4 | L >> 2, U[N++] = (L & 3) << 6 | B & 63;
  return $;
}, withNativeArrayBuffer$1 = typeof ArrayBuffer == "function", decodePacket = (o, t) => {
  if (typeof o != "string")
    return {
      type: "message",
      data: mapBinary(o, t)
    };
  const e = o.charAt(0);
  return e === "b" ? {
    type: "message",
    data: decodeBase64Packet(o.substring(1), t)
  } : PACKET_TYPES_REVERSE[e] ? o.length > 1 ? {
    type: PACKET_TYPES_REVERSE[e],
    data: o.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[e]
  } : ERROR_PACKET;
}, decodeBase64Packet = (o, t) => {
  if (withNativeArrayBuffer$1) {
    const e = decode$1(o);
    return mapBinary(e, t);
  } else
    return { base64: !0, data: o };
}, mapBinary = (o, t) => {
  switch (t) {
    case "blob":
      return o instanceof ArrayBuffer ? new Blob([o]) : o;
    case "arraybuffer":
    default:
      return o;
  }
}, SEPARATOR = String.fromCharCode(30), encodePayload = (o, t) => {
  const e = o.length, R = new Array(e);
  let N = 0;
  o.forEach((M, D) => {
    encodePacket(M, !1, (L) => {
      R[D] = L, ++N === e && t(R.join(SEPARATOR));
    });
  });
}, decodePayload = (o, t) => {
  const e = o.split(SEPARATOR), R = [];
  for (let N = 0; N < e.length; N++) {
    const M = decodePacket(e[N], t);
    if (R.push(M), M.type === "error")
      break;
  }
  return R;
}, protocol$1 = 4;
function Emitter(o) {
  if (o)
    return mixin(o);
}
function mixin(o) {
  for (var t in Emitter.prototype)
    o[t] = Emitter.prototype[t];
  return o;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(o, t) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + o] = this._callbacks["$" + o] || []).push(t), this;
};
Emitter.prototype.once = function(o, t) {
  function e() {
    this.off(o, e), t.apply(this, arguments);
  }
  return e.fn = t, this.on(o, e), this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(o, t) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var e = this._callbacks["$" + o];
  if (!e)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + o], this;
  for (var R, N = 0; N < e.length; N++)
    if (R = e[N], R === t || R.fn === t) {
      e.splice(N, 1);
      break;
    }
  return e.length === 0 && delete this._callbacks["$" + o], this;
};
Emitter.prototype.emit = function(o) {
  this._callbacks = this._callbacks || {};
  for (var t = new Array(arguments.length - 1), e = this._callbacks["$" + o], R = 1; R < arguments.length; R++)
    t[R - 1] = arguments[R];
  if (e) {
    e = e.slice(0);
    for (var R = 0, N = e.length; R < N; ++R)
      e[R].apply(this, t);
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(o) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + o] || [];
};
Emitter.prototype.hasListeners = function(o) {
  return !!this.listeners(o).length;
};
const globalThisShim = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
function pick(o, ...t) {
  return t.reduce((e, R) => (o.hasOwnProperty(R) && (e[R] = o[R]), e), {});
}
const NATIVE_SET_TIMEOUT = setTimeout, NATIVE_CLEAR_TIMEOUT = clearTimeout;
function installTimerFunctions(o, t) {
  t.useNativeTimers ? (o.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim), o.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim)) : (o.setTimeoutFn = setTimeout.bind(globalThisShim), o.clearTimeoutFn = clearTimeout.bind(globalThisShim));
}
const BASE64_OVERHEAD = 1.33;
function byteLength(o) {
  return typeof o == "string" ? utf8Length(o) : Math.ceil((o.byteLength || o.size) * BASE64_OVERHEAD);
}
function utf8Length(o) {
  let t = 0, e = 0;
  for (let R = 0, N = o.length; R < N; R++)
    t = o.charCodeAt(R), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (R++, e += 4);
  return e;
}
class TransportError extends Error {
  constructor(t, e, R) {
    super(t), this.description = e, this.context = R, this.type = "TransportError";
  }
}
class Transport extends Emitter {
  constructor(t) {
    super(), this.writable = !1, installTimerFunctions(this, t), this.opts = t, this.query = t.query, this.readyState = "", this.socket = t.socket;
  }
  onError(t, e, R) {
    return super.emitReserved("error", new TransportError(t, e, R)), this;
  }
  open() {
    return (this.readyState === "closed" || this.readyState === "") && (this.readyState = "opening", this.doOpen()), this;
  }
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  send(t) {
    this.readyState === "open" && this.write(t);
  }
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  onData(t) {
    const e = decodePacket(t, this.socket.binaryType);
    this.onPacket(e);
  }
  onPacket(t) {
    super.emitReserved("packet", t);
  }
  onClose(t) {
    this.readyState = "closed", super.emitReserved("close", t);
  }
}
const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map$1 = {};
let seed = 0, i = 0, prev;
function encode$1(o) {
  let t = "";
  do
    t = alphabet[o % length] + t, o = Math.floor(o / length);
  while (o > 0);
  return t;
}
function yeast() {
  const o = encode$1(+new Date());
  return o !== prev ? (seed = 0, prev = o) : o + "." + encode$1(seed++);
}
for (; i < length; i++)
  map$1[alphabet[i]] = i;
function encode(o) {
  let t = "";
  for (let e in o)
    o.hasOwnProperty(e) && (t.length && (t += "&"), t += encodeURIComponent(e) + "=" + encodeURIComponent(o[e]));
  return t;
}
function decode(o) {
  let t = {}, e = o.split("&");
  for (let R = 0, N = e.length; R < N; R++) {
    let M = e[R].split("=");
    t[decodeURIComponent(M[0])] = decodeURIComponent(M[1]);
  }
  return t;
}
let value = !1;
try {
  value = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const hasCORS = value;
function XHR(o) {
  const t = o.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!t || hasCORS))
      return new XMLHttpRequest();
  } catch {
  }
  if (!t)
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
function empty() {
}
const hasXHR2 = function() {
  return new XHR({
    xdomain: !1
  }).responseType != null;
}();
class Polling extends Transport {
  constructor(t) {
    if (super(t), this.polling = !1, typeof location < "u") {
      const R = location.protocol === "https:";
      let N = location.port;
      N || (N = R ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || N !== t.port, this.xs = t.secure !== R;
    }
    const e = t && t.forceBase64;
    this.supportsBinary = hasXHR2 && !e;
  }
  get name() {
    return "polling";
  }
  doOpen() {
    this.poll();
  }
  pause(t) {
    this.readyState = "pausing";
    const e = () => {
      this.readyState = "paused", t();
    };
    if (this.polling || !this.writable) {
      let R = 0;
      this.polling && (R++, this.once("pollComplete", function() {
        --R || e();
      })), this.writable || (R++, this.once("drain", function() {
        --R || e();
      }));
    } else
      e();
  }
  poll() {
    this.polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  onData(t) {
    const e = (R) => {
      if (this.readyState === "opening" && R.type === "open" && this.onOpen(), R.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(R);
    };
    decodePayload(t, this.socket.binaryType).forEach(e), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll());
  }
  doClose() {
    const t = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? t() : this.once("open", t);
  }
  write(t) {
    this.writable = !1, encodePayload(t, (e) => {
      this.doWrite(e, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  uri() {
    let t = this.query || {};
    const e = this.opts.secure ? "https" : "http";
    let R = "";
    this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = yeast()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.opts.port && (e === "https" && Number(this.opts.port) !== 443 || e === "http" && Number(this.opts.port) !== 80) && (R = ":" + this.opts.port);
    const N = encode(t), M = this.opts.hostname.indexOf(":") !== -1;
    return e + "://" + (M ? "[" + this.opts.hostname + "]" : this.opts.hostname) + R + this.opts.path + (N.length ? "?" + N : "");
  }
  request(t = {}) {
    return Object.assign(t, { xd: this.xd, xs: this.xs }, this.opts), new Request(this.uri(), t);
  }
  doWrite(t, e) {
    const R = this.request({
      method: "POST",
      data: t
    });
    R.on("success", e), R.on("error", (N, M) => {
      this.onError("xhr post error", N, M);
    });
  }
  doPoll() {
    const t = this.request();
    t.on("data", this.onData.bind(this)), t.on("error", (e, R) => {
      this.onError("xhr poll error", e, R);
    }), this.pollXhr = t;
  }
}
class Request extends Emitter {
  constructor(t, e) {
    super(), installTimerFunctions(this, e), this.opts = e, this.method = e.method || "GET", this.uri = t, this.async = e.async !== !1, this.data = e.data !== void 0 ? e.data : null, this.create();
  }
  create() {
    const t = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    t.xdomain = !!this.opts.xd, t.xscheme = !!this.opts.xs;
    const e = this.xhr = new XHR(t);
    try {
      e.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0);
          for (let R in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(R) && e.setRequestHeader(R, this.opts.extraHeaders[R]);
        }
      } catch {
      }
      if (this.method === "POST")
        try {
          e.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        e.setRequestHeader("Accept", "*/*");
      } catch {
      }
      "withCredentials" in e && (e.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (e.timeout = this.opts.requestTimeout), e.onreadystatechange = () => {
        e.readyState === 4 && (e.status === 200 || e.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
          this.onError(typeof e.status == "number" ? e.status : 0);
        }, 0));
      }, e.send(this.data);
    } catch (R) {
      this.setTimeoutFn(() => {
        this.onError(R);
      }, 0);
      return;
    }
    typeof document < "u" && (this.index = Request.requestsCount++, Request.requests[this.index] = this);
  }
  onError(t) {
    this.emitReserved("error", t, this.xhr), this.cleanup(!0);
  }
  cleanup(t) {
    if (!(typeof this.xhr > "u" || this.xhr === null)) {
      if (this.xhr.onreadystatechange = empty, t)
        try {
          this.xhr.abort();
        } catch {
        }
      typeof document < "u" && delete Request.requests[this.index], this.xhr = null;
    }
  }
  onLoad() {
    const t = this.xhr.responseText;
    t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this.cleanup());
  }
  abort() {
    this.cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", unloadHandler);
  else if (typeof addEventListener == "function") {
    const o = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(o, unloadHandler, !1);
  }
}
function unloadHandler() {
  for (let o in Request.requests)
    Request.requests.hasOwnProperty(o) && Request.requests[o].abort();
}
const nextTick = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0))(), WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket, usingBrowserWebSocket = !0, defaultBinaryType = "arraybuffer", isReactNative = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class WS extends Transport {
  constructor(t) {
    super(t), this.supportsBinary = !t.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check())
      return;
    const t = this.uri(), e = this.opts.protocols, R = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (R.headers = this.opts.extraHeaders);
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? e ? new WebSocket(t, e) : new WebSocket(t) : new WebSocket(t, e, R);
    } catch (N) {
      return this.emitReserved("error", N);
    }
    this.ws.binaryType = this.socket.binaryType || defaultBinaryType, this.addEventListeners();
  }
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const R = t[e], N = e === t.length - 1;
      encodePacket(R, this.supportsBinary, (M) => {
        const D = {};
        try {
          usingBrowserWebSocket && this.ws.send(M);
        } catch {
        }
        N && nextTick(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.close(), this.ws = null);
  }
  uri() {
    let t = this.query || {};
    const e = this.opts.secure ? "wss" : "ws";
    let R = "";
    this.opts.port && (e === "wss" && Number(this.opts.port) !== 443 || e === "ws" && Number(this.opts.port) !== 80) && (R = ":" + this.opts.port), this.opts.timestampRequests && (t[this.opts.timestampParam] = yeast()), this.supportsBinary || (t.b64 = 1);
    const N = encode(t), M = this.opts.hostname.indexOf(":") !== -1;
    return e + "://" + (M ? "[" + this.opts.hostname + "]" : this.opts.hostname) + R + this.opts.path + (N.length ? "?" + N : "");
  }
  check() {
    return !!WebSocket;
  }
}
const transports = {
  websocket: WS,
  polling: Polling
}, re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse$1(o) {
  const t = o, e = o.indexOf("["), R = o.indexOf("]");
  e != -1 && R != -1 && (o = o.substring(0, e) + o.substring(e, R).replace(/:/g, ";") + o.substring(R, o.length));
  let N = re.exec(o || ""), M = {}, D = 14;
  for (; D--; )
    M[parts[D]] = N[D] || "";
  return e != -1 && R != -1 && (M.source = t, M.host = M.host.substring(1, M.host.length - 1).replace(/;/g, ":"), M.authority = M.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), M.ipv6uri = !0), M.pathNames = pathNames(M, M.path), M.queryKey = queryKey(M, M.query), M;
}
function pathNames(o, t) {
  const e = /\/{2,9}/g, R = t.replace(e, "/").split("/");
  return (t.substr(0, 1) == "/" || t.length === 0) && R.splice(0, 1), t.substr(t.length - 1, 1) == "/" && R.splice(R.length - 1, 1), R;
}
function queryKey(o, t) {
  const e = {};
  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(R, N, M) {
    N && (e[N] = M);
  }), e;
}
class Socket$1 extends Emitter {
  constructor(t, e = {}) {
    super(), t && typeof t == "object" && (e = t, t = null), t ? (t = parse$1(t), e.hostname = t.host, e.secure = t.protocol === "https" || t.protocol === "wss", e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = parse$1(e.host).host), installTimerFunctions(this, e), this.secure = e.secure != null ? e.secure : typeof location < "u" && location.protocol === "https:", e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.hostname = e.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = e.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = e.transports || ["polling", "websocket"], this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !0
    }, e), this.opts.path = this.opts.path.replace(/\/$/, "") + "/", typeof this.opts.query == "string" && (this.opts.query = decode(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && addEventListener("beforeunload", () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, !1), this.hostname !== "localhost" && (this.offlineEventListener = () => {
      this.onClose("transport close", {
        description: "network connection lost"
      });
    }, addEventListener("offline", this.offlineEventListener, !1))), this.open();
  }
  createTransport(t) {
    const e = Object.assign({}, this.opts.query);
    e.EIO = protocol$1, e.transport = t, this.id && (e.sid = this.id);
    const R = Object.assign({}, this.opts.transportOptions[t], this.opts, {
      query: e,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    });
    return new transports[t](R);
  }
  open() {
    let t;
    if (this.opts.rememberUpgrade && Socket$1.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
      t = "websocket";
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else
      t = this.transports[0];
    this.readyState = "opening";
    try {
      t = this.createTransport(t);
    } catch {
      this.transports.shift(), this.open();
      return;
    }
    t.open(), this.setTransport(t);
  }
  setTransport(t) {
    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (e) => this.onClose("transport close", e));
  }
  probe(t) {
    let e = this.createTransport(t), R = !1;
    Socket$1.priorWebsocketSuccess = !1;
    const N = () => {
      R || (e.send([{ type: "ping", data: "probe" }]), e.once("packet", (H) => {
        if (!R)
          if (H.type === "pong" && H.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", e), !e)
              return;
            Socket$1.priorWebsocketSuccess = e.name === "websocket", this.transport.pause(() => {
              R || this.readyState !== "closed" && (U(), this.setTransport(e), e.send([{ type: "upgrade" }]), this.emitReserved("upgrade", e), e = null, this.upgrading = !1, this.flush());
            });
          } else {
            const z = new Error("probe error");
            z.transport = e.name, this.emitReserved("upgradeError", z);
          }
      }));
    };
    function M() {
      R || (R = !0, U(), e.close(), e = null);
    }
    const D = (H) => {
      const z = new Error("probe error: " + H);
      z.transport = e.name, M(), this.emitReserved("upgradeError", z);
    };
    function L() {
      D("transport closed");
    }
    function B() {
      D("socket closed");
    }
    function $(H) {
      e && H.name !== e.name && M();
    }
    const U = () => {
      e.removeListener("open", N), e.removeListener("error", D), e.removeListener("close", L), this.off("close", B), this.off("upgrading", $);
    };
    e.once("open", N), e.once("error", D), e.once("close", L), this.once("close", B), this.once("upgrading", $), e.open();
  }
  onOpen() {
    if (this.readyState = "open", Socket$1.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade && this.transport.pause) {
      let t = 0;
      const e = this.upgrades.length;
      for (; t < e; t++)
        this.probe(this.upgrades[t]);
    }
  }
  onPacket(t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;
        case "ping":
          this.resetPingTimeout(), this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
          break;
        case "error":
          const e = new Error("server error");
          e.code = t.data, this.onError(e);
          break;
        case "message":
          this.emitReserved("data", t.data), this.emitReserved("message", t.data);
          break;
      }
  }
  onHandshake(t) {
    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout();
  }
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
  }
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const t = this.getWritablePackets();
      this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved("flush");
    }
  }
  getWritablePackets() {
    if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let e = 1;
    for (let R = 0; R < this.writeBuffer.length; R++) {
      const N = this.writeBuffer[R].data;
      if (N && (e += byteLength(N)), R > 0 && e > this.maxPayload)
        return this.writeBuffer.slice(0, R);
      e += 2;
    }
    return this.writeBuffer;
  }
  write(t, e, R) {
    return this.sendPacket("message", t, e, R), this;
  }
  send(t, e, R) {
    return this.sendPacket("message", t, e, R), this;
  }
  sendPacket(t, e, R, N) {
    if (typeof e == "function" && (N = e, e = void 0), typeof R == "function" && (N = R, R = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    R = R || {}, R.compress = R.compress !== !1;
    const M = {
      type: t,
      data: e,
      options: R
    };
    this.emitReserved("packetCreate", M), this.writeBuffer.push(M), N && this.once("flush", N), this.flush();
  }
  close() {
    const t = () => {
      this.onClose("forced close"), this.transport.close();
    }, e = () => {
      this.off("upgrade", e), this.off("upgradeError", e), t();
    }, R = () => {
      this.once("upgrade", e), this.once("upgradeError", e);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? R() : t();
    }) : this.upgrading ? R() : t()), this;
  }
  onError(t) {
    Socket$1.priorWebsocketSuccess = !1, this.emitReserved("error", t), this.onClose("transport error", t);
  }
  onClose(t, e) {
    (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && removeEventListener("offline", this.offlineEventListener, !1), this.readyState = "closed", this.id = null, this.emitReserved("close", t, e), this.writeBuffer = [], this.prevBufferLen = 0);
  }
  filterUpgrades(t) {
    const e = [];
    let R = 0;
    const N = t.length;
    for (; R < N; R++)
      ~this.transports.indexOf(t[R]) && e.push(t[R]);
    return e;
  }
}
Socket$1.protocol = protocol$1;
function url(o, t = "", e) {
  let R = o;
  e = e || typeof location < "u" && location, o == null && (o = e.protocol + "//" + e.host), typeof o == "string" && (o.charAt(0) === "/" && (o.charAt(1) === "/" ? o = e.protocol + o : o = e.host + o), /^(https?|wss?):\/\//.test(o) || (typeof e < "u" ? o = e.protocol + "//" + o : o = "https://" + o), R = parse$1(o)), R.port || (/^(http|ws)$/.test(R.protocol) ? R.port = "80" : /^(http|ws)s$/.test(R.protocol) && (R.port = "443")), R.path = R.path || "/";
  const M = R.host.indexOf(":") !== -1 ? "[" + R.host + "]" : R.host;
  return R.id = R.protocol + "://" + M + ":" + R.port + t, R.href = R.protocol + "://" + M + (e && e.port === R.port ? "" : ":" + R.port), R;
}
const withNativeArrayBuffer = typeof ArrayBuffer == "function", isView = (o) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(o) : o.buffer instanceof ArrayBuffer, toString = Object.prototype.toString, withNativeBlob = typeof Blob == "function" || typeof Blob < "u" && toString.call(Blob) === "[object BlobConstructor]", withNativeFile = typeof File == "function" || typeof File < "u" && toString.call(File) === "[object FileConstructor]";
function isBinary(o) {
  return withNativeArrayBuffer && (o instanceof ArrayBuffer || isView(o)) || withNativeBlob && o instanceof Blob || withNativeFile && o instanceof File;
}
function hasBinary(o, t) {
  if (!o || typeof o != "object")
    return !1;
  if (Array.isArray(o)) {
    for (let e = 0, R = o.length; e < R; e++)
      if (hasBinary(o[e]))
        return !0;
    return !1;
  }
  if (isBinary(o))
    return !0;
  if (o.toJSON && typeof o.toJSON == "function" && arguments.length === 1)
    return hasBinary(o.toJSON(), !0);
  for (const e in o)
    if (Object.prototype.hasOwnProperty.call(o, e) && hasBinary(o[e]))
      return !0;
  return !1;
}
function deconstructPacket(o) {
  const t = [], e = o.data, R = o;
  return R.data = _deconstructPacket(e, t), R.attachments = t.length, { packet: R, buffers: t };
}
function _deconstructPacket(o, t) {
  if (!o)
    return o;
  if (isBinary(o)) {
    const e = { _placeholder: !0, num: t.length };
    return t.push(o), e;
  } else if (Array.isArray(o)) {
    const e = new Array(o.length);
    for (let R = 0; R < o.length; R++)
      e[R] = _deconstructPacket(o[R], t);
    return e;
  } else if (typeof o == "object" && !(o instanceof Date)) {
    const e = {};
    for (const R in o)
      Object.prototype.hasOwnProperty.call(o, R) && (e[R] = _deconstructPacket(o[R], t));
    return e;
  }
  return o;
}
function reconstructPacket(o, t) {
  return o.data = _reconstructPacket(o.data, t), o.attachments = void 0, o;
}
function _reconstructPacket(o, t) {
  if (!o)
    return o;
  if (o && o._placeholder === !0) {
    if (typeof o.num == "number" && o.num >= 0 && o.num < t.length)
      return t[o.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(o))
    for (let e = 0; e < o.length; e++)
      o[e] = _reconstructPacket(o[e], t);
  else if (typeof o == "object")
    for (const e in o)
      Object.prototype.hasOwnProperty.call(o, e) && (o[e] = _reconstructPacket(o[e], t));
  return o;
}
const protocol = 5;
var PacketType;
(function(o) {
  o[o.CONNECT = 0] = "CONNECT", o[o.DISCONNECT = 1] = "DISCONNECT", o[o.EVENT = 2] = "EVENT", o[o.ACK = 3] = "ACK", o[o.CONNECT_ERROR = 4] = "CONNECT_ERROR", o[o.BINARY_EVENT = 5] = "BINARY_EVENT", o[o.BINARY_ACK = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  constructor(t) {
    this.replacer = t;
  }
  encode(t) {
    return (t.type === PacketType.EVENT || t.type === PacketType.ACK) && hasBinary(t) ? (t.type = t.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK, this.encodeAsBinary(t)) : [this.encodeAsString(t)];
  }
  encodeAsString(t) {
    let e = "" + t.type;
    return (t.type === PacketType.BINARY_EVENT || t.type === PacketType.BINARY_ACK) && (e += t.attachments + "-"), t.nsp && t.nsp !== "/" && (e += t.nsp + ","), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;
  }
  encodeAsBinary(t) {
    const e = deconstructPacket(t), R = this.encodeAsString(e.packet), N = e.buffers;
    return N.unshift(R), N;
  }
}
class Decoder extends Emitter {
  constructor(t) {
    super(), this.reviver = t;
  }
  add(t) {
    let e;
    if (typeof t == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      e = this.decodeString(t), e.type === PacketType.BINARY_EVENT || e.type === PacketType.BINARY_ACK ? (this.reconstructor = new BinaryReconstructor(e), e.attachments === 0 && super.emitReserved("decoded", e)) : super.emitReserved("decoded", e);
    } else if (isBinary(t) || t.base64)
      if (this.reconstructor)
        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved("decoded", e));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + t);
  }
  decodeString(t) {
    let e = 0;
    const R = {
      type: Number(t.charAt(0))
    };
    if (PacketType[R.type] === void 0)
      throw new Error("unknown packet type " + R.type);
    if (R.type === PacketType.BINARY_EVENT || R.type === PacketType.BINARY_ACK) {
      const M = e + 1;
      for (; t.charAt(++e) !== "-" && e != t.length; )
        ;
      const D = t.substring(M, e);
      if (D != Number(D) || t.charAt(e) !== "-")
        throw new Error("Illegal attachments");
      R.attachments = Number(D);
    }
    if (t.charAt(e + 1) === "/") {
      const M = e + 1;
      for (; ++e && !(t.charAt(e) === "," || e === t.length); )
        ;
      R.nsp = t.substring(M, e);
    } else
      R.nsp = "/";
    const N = t.charAt(e + 1);
    if (N !== "" && Number(N) == N) {
      const M = e + 1;
      for (; ++e; ) {
        const D = t.charAt(e);
        if (D == null || Number(D) != D) {
          --e;
          break;
        }
        if (e === t.length)
          break;
      }
      R.id = Number(t.substring(M, e + 1));
    }
    if (t.charAt(++e)) {
      const M = this.tryParse(t.substr(e));
      if (Decoder.isPayloadValid(R.type, M))
        R.data = M;
      else
        throw new Error("invalid payload");
    }
    return R;
  }
  tryParse(t) {
    try {
      return JSON.parse(t, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(t, e) {
    switch (t) {
      case PacketType.CONNECT:
        return typeof e == "object";
      case PacketType.DISCONNECT:
        return e === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof e == "string" || typeof e == "object";
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(e) && e.length > 0;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(e);
    }
  }
  destroy() {
    this.reconstructor && this.reconstructor.finishedReconstruction();
  }
}
class BinaryReconstructor {
  constructor(t) {
    this.packet = t, this.buffers = [], this.reconPack = t;
  }
  takeBinaryData(t) {
    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
      const e = reconstructPacket(this.reconPack, this.buffers);
      return this.finishedReconstruction(), e;
    }
    return null;
  }
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  protocol,
  get PacketType() {
    return PacketType;
  },
  Encoder,
  Decoder
}, Symbol.toStringTag, { value: "Module" }));
function on(o, t, e) {
  return o.on(t, e), function() {
    o.off(t, e);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  newListener: 1,
  removeListener: 1
});
class Socket extends Emitter {
  constructor(t, e, R) {
    super(), this.connected = !1, this.receiveBuffer = [], this.sendBuffer = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, R && R.auth && (this.auth = R.auth), this.io._autoConnect && this.open();
  }
  get disconnected() {
    return !this.connected;
  }
  subEvents() {
    if (this.subs)
      return;
    const t = this.io;
    this.subs = [
      on(t, "open", this.onopen.bind(this)),
      on(t, "packet", this.onpacket.bind(this)),
      on(t, "error", this.onerror.bind(this)),
      on(t, "close", this.onclose.bind(this))
    ];
  }
  get active() {
    return !!this.subs;
  }
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  open() {
    return this.connect();
  }
  send(...t) {
    return t.unshift("message"), this.emit.apply(this, t), this;
  }
  emit(t, ...e) {
    if (RESERVED_EVENTS.hasOwnProperty(t))
      throw new Error('"' + t.toString() + '" is a reserved event name');
    e.unshift(t);
    const R = {
      type: PacketType.EVENT,
      data: e
    };
    if (R.options = {}, R.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == "function") {
      const D = this.ids++, L = e.pop();
      this._registerAckCallback(D, L), R.id = D;
    }
    const N = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    return this.flags.volatile && (!N || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(R), this.packet(R)) : this.sendBuffer.push(R)), this.flags = {}, this;
  }
  _registerAckCallback(t, e) {
    const R = this.flags.timeout;
    if (R === void 0) {
      this.acks[t] = e;
      return;
    }
    const N = this.io.setTimeoutFn(() => {
      delete this.acks[t];
      for (let M = 0; M < this.sendBuffer.length; M++)
        this.sendBuffer[M].id === t && this.sendBuffer.splice(M, 1);
      e.call(this, new Error("operation has timed out"));
    }, R);
    this.acks[t] = (...M) => {
      this.io.clearTimeoutFn(N), e.apply(this, [null, ...M]);
    };
  }
  packet(t) {
    t.nsp = this.nsp, this.io._packet(t);
  }
  onopen() {
    typeof this.auth == "function" ? this.auth((t) => {
      this.packet({ type: PacketType.CONNECT, data: t });
    }) : this.packet({ type: PacketType.CONNECT, data: this.auth });
  }
  onerror(t) {
    this.connected || this.emitReserved("connect_error", t);
  }
  onclose(t, e) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", t, e);
  }
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case PacketType.CONNECT:
          if (t.data && t.data.sid) {
            const N = t.data.sid;
            this.onconnect(N);
          } else
            this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          this.onevent(t);
          break;
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          this.onack(t);
          break;
        case PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case PacketType.CONNECT_ERROR:
          this.destroy();
          const R = new Error(t.data.message);
          R.data = t.data.data, this.emitReserved("connect_error", R);
          break;
      }
  }
  onevent(t) {
    const e = t.data || [];
    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const e = this._anyListeners.slice();
      for (const R of e)
        R.apply(this, t);
    }
    super.emit.apply(this, t);
  }
  ack(t) {
    const e = this;
    let R = !1;
    return function(...N) {
      R || (R = !0, e.packet({
        type: PacketType.ACK,
        id: t,
        data: N
      }));
    };
  }
  onack(t) {
    const e = this.acks[t.id];
    typeof e == "function" && (e.apply(this, t.data), delete this.acks[t.id]);
  }
  onconnect(t) {
    this.id = t, this.connected = !0, this.emitBuffered(), this.emitReserved("connect");
  }
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {
      this.notifyOutgoingListeners(t), this.packet(t);
    }), this.sendBuffer = [];
  }
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);
  }
  disconnect() {
    return this.connected && this.packet({ type: PacketType.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  close() {
    return this.disconnect();
  }
  compress(t) {
    return this.flags.compress = t, this;
  }
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  timeout(t) {
    return this.flags.timeout = t, this;
  }
  onAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;
  }
  prependAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;
  }
  offAny(t) {
    if (!this._anyListeners)
      return this;
    if (t) {
      const e = this._anyListeners;
      for (let R = 0; R < e.length; R++)
        if (t === e[R])
          return e.splice(R, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  listenersAny() {
    return this._anyListeners || [];
  }
  onAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;
  }
  prependAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;
  }
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners)
      return this;
    if (t) {
      const e = this._anyOutgoingListeners;
      for (let R = 0; R < e.length; R++)
        if (t === e[R])
          return e.splice(R, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const e = this._anyOutgoingListeners.slice();
      for (const R of e)
        R.apply(this, t.data);
    }
  }
}
function Backoff(o) {
  o = o || {}, this.ms = o.min || 100, this.max = o.max || 1e4, this.factor = o.factor || 2, this.jitter = o.jitter > 0 && o.jitter <= 1 ? o.jitter : 0, this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var o = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t = Math.random(), e = Math.floor(t * this.jitter * o);
    o = (Math.floor(t * 10) & 1) == 0 ? o - e : o + e;
  }
  return Math.min(o, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(o) {
  this.ms = o;
};
Backoff.prototype.setMax = function(o) {
  this.max = o;
};
Backoff.prototype.setJitter = function(o) {
  this.jitter = o;
};
class Manager extends Emitter {
  constructor(t, e) {
    var R;
    super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (e = t, t = void 0), e = e || {}, e.path = e.path || "/socket.io", this.opts = e, installTimerFunctions(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((R = e.randomizationFactor) !== null && R !== void 0 ? R : 0.5), this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = "closed", this.uri = t;
    const N = e.parser || parser;
    this.encoder = new N.Encoder(), this.decoder = new N.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(t) {
    return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);
  }
  reconnectionDelay(t) {
    var e;
    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);
  }
  randomizationFactor(t) {
    var e;
    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);
  }
  reconnectionDelayMax(t) {
    var e;
    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);
  }
  timeout(t) {
    return arguments.length ? (this._timeout = t, this) : this._timeout;
  }
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  open(t) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const e = this.engine, R = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const N = on(e, "open", function() {
      R.onopen(), t && t();
    }), M = on(e, "error", (D) => {
      R.cleanup(), R._readyState = "closed", this.emitReserved("error", D), t ? t(D) : R.maybeReconnectOnOpen();
    });
    if (this._timeout !== !1) {
      const D = this._timeout;
      D === 0 && N();
      const L = this.setTimeoutFn(() => {
        N(), e.close(), e.emit("error", new Error("timeout"));
      }, D);
      this.opts.autoUnref && L.unref(), this.subs.push(function() {
        clearTimeout(L);
      });
    }
    return this.subs.push(N), this.subs.push(M), this;
  }
  connect(t) {
    return this.open(t);
  }
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const t = this.engine;
    this.subs.push(on(t, "ping", this.onping.bind(this)), on(t, "data", this.ondata.bind(this)), on(t, "error", this.onerror.bind(this)), on(t, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  onping() {
    this.emitReserved("ping");
  }
  ondata(t) {
    try {
      this.decoder.add(t);
    } catch {
      this.onclose("parse error");
    }
  }
  ondecoded(t) {
    this.emitReserved("packet", t);
  }
  onerror(t) {
    this.emitReserved("error", t);
  }
  socket(t, e) {
    let R = this.nsps[t];
    return R || (R = new Socket(this, t, e), this.nsps[t] = R), R;
  }
  _destroy(t) {
    const e = Object.keys(this.nsps);
    for (const R of e)
      if (this.nsps[R].active)
        return;
    this._close();
  }
  _packet(t) {
    const e = this.encoder.encode(t);
    for (let R = 0; R < e.length; R++)
      this.engine.write(e[R], t.options);
  }
  cleanup() {
    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();
  }
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close();
  }
  disconnect() {
    return this._close();
  }
  onclose(t, e) {
    this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, e), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const t = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const e = this.backoff.duration();
      this._reconnecting = !0;
      const R = this.setTimeoutFn(() => {
        t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open((N) => {
          N ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", N)) : t.onreconnect();
        }));
      }, e);
      this.opts.autoUnref && R.unref(), this.subs.push(function() {
        clearTimeout(R);
      });
    }
  }
  onreconnect() {
    const t = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t);
  }
}
const cache = {};
function lookup(o, t) {
  typeof o == "object" && (t = o, o = void 0), t = t || {};
  const e = url(o, t.path || "/socket.io"), R = e.source, N = e.id, M = e.path, D = cache[N] && M in cache[N].nsps, L = t.forceNew || t["force new connection"] || t.multiplex === !1 || D;
  let B;
  return L ? B = new Manager(R, t) : (cache[N] || (cache[N] = new Manager(R, t)), B = cache[N]), e.query && !t.query && (t.query = e.queryKey), B.socket(e.path, t);
}
Object.assign(lookup, {
  Manager,
  Socket,
  io: lookup,
  connect: lookup
});
var __accessCheck$5 = (o, t, e) => {
  if (!t.has(o))
    throw TypeError("Cannot " + e);
}, __privateGet$5 = (o, t, e) => (__accessCheck$5(o, t, "read from private field"), e ? e.call(o) : t.get(o)), __privateAdd$5 = (o, t, e) => {
  if (t.has(o))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(o) : t.set(o, e);
}, __privateSet$5 = (o, t, e, R) => (__accessCheck$5(o, t, "write to private field"), R ? R.call(o, e) : t.set(o, e), e), _cvsWidth, _cvsHeight, _cvsScale, _ofsLeft4elm, _ofsTop4elm, _ofsPadLeft_Dom2PIXI, _ofsPadTop_Dom2PIXI, _sk, _hHook, _hToastDat, _aFncHook, _main_title, _tglFlscr, _info_title, _preFromPlg, _hN2Ext, _genImage, _genVideo;
const _SysBase = class {
  constructor(o = {}, t) {
    this.hPlg = o, this.arg = t, this.hFactoryCls = {}, this.elc = new EventListenerCtn(), this.fetch = (e) => fetch(e), this.resolution = 1, this.data = { sys: {}, mark: {}, kidoku: {} }, __privateAdd$5(this, _cvsWidth, 0), __privateAdd$5(this, _cvsHeight, 0), __privateAdd$5(this, _cvsScale, 1), __privateAdd$5(this, _ofsLeft4elm, 0), __privateAdd$5(this, _ofsTop4elm, 0), __privateAdd$5(this, _ofsPadLeft_Dom2PIXI, 0), __privateAdd$5(this, _ofsPadTop_Dom2PIXI, 0), this.isFullScr = !1, this.extPort = 3776, __privateAdd$5(this, _sk, void 0), __privateAdd$5(this, _hHook, {
      auth: (e) => {
        if (e.t !== this.cfg.oCfg.debuger_token) {
          this.end();
          return;
        }
        this.toast("\u63A5\u7D9A");
      },
      continue: () => this.toast("\u518D\u751F"),
      disconnect: () => this.toast("\u5207\u65AD"),
      restart: (e) => {
        var R;
        this.send2Dbg((R = e == null ? void 0 : e.ri) != null ? R : "", {}), this.end(), this.run();
      },
      pause: () => this.toast("\u4E00\u6642\u505C\u6B62"),
      stopOnEntry: () => this.toast("\u4E00\u6642\u505C\u6B62"),
      stopOnDataBreakpoint: () => this.toast("\u6CE8\u610F"),
      stopOnBreakpoint: () => this.toast("\u6CE8\u610F"),
      stopOnStep: () => this.toast("\u4E00\u6B69\u9032\u3080"),
      stopOnStepIn: () => this.toast("\u30B9\u30C6\u30C3\u30D5\u309A\u30A4\u30F3"),
      stopOnStepOut: () => this.toast("\u30B9\u30C6\u30C3\u30D5\u309A\u30A2\u30A6\u30C8"),
      stopOnBackstep: () => this.toast("\u4E00\u6B69\u623B\u308B"),
      _addPath: (e) => this.cfg.addPath(e.fn, e.o)
    }), this.pathBaseCnvSnPath4Dbg = "", __privateAdd$5(this, _aFncHook, []), this.callHook = (e, R) => {
    }, this.send2Dbg = (e, R) => {
      var N;
      (N = __privateGet$5(this, _sk)) == null || N.emit("data", e, R);
    }, this.copyBMFolder = (e, R) => {
    }, this.eraseBMFolder = (e) => {
    }, this.close = () => !1, this._export = () => !1, this._import = () => !1, this.navigate_to = () => !1, this.title = (e) => {
      const { text: R } = e;
      if (!R)
        throw "[title] text\u306F\u5FC5\u9808\u3067\u3059";
      return __privateSet$5(this, _main_title, R), this.titleSub(__privateGet$5(this, _main_title) + __privateGet$5(this, _info_title)), !1;
    }, __privateAdd$5(this, _main_title, ""), __privateAdd$5(this, _tglFlscr, (e) => {
      if (!e.key)
        return this.tglFlscr_sub(), !1;
      const R = e.key.toLowerCase();
      return this.elc.add(document, "keydown", (N) => {
        (N.altKey ? N.key === "Alt" ? "" : "alt+" : "") + (N.ctrlKey ? N.key === "Control" ? "" : "ctrl+" : "") + (N.shiftKey ? N.key === "Shift" ? "" : "shift+" : "") + N.key.toLowerCase() === R && (N.stopPropagation(), this.tglFlscr_sub());
      }, { passive: !0 }), !1;
    }), this.update_check = () => !1, this.window = () => !1, __privateAdd$5(this, _info_title, ""), __privateAdd$5(this, _preFromPlg, (e, R) => ({ ret: R.toString(), ext_num: 0 })), __privateAdd$5(this, _hN2Ext, {
      1: { ext: "jpeg", fnc: (e) => __privateGet$5(this, _genImage).call(this, e), mime: "image/jpeg" },
      2: { ext: "png", fnc: (e) => __privateGet$5(this, _genImage).call(this, e), mime: "image/png" },
      3: { ext: "svg", fnc: (e) => __privateGet$5(this, _genImage).call(this, e), mime: "image/svg+xml" },
      4: { ext: "webp", fnc: (e) => __privateGet$5(this, _genImage).call(this, e), mime: "image/webp" },
      10: { ext: "mp3", fnc: (e) => e.arrayBuffer(), mime: "audio/mpeg" },
      11: { ext: "m4a", fnc: (e) => e.arrayBuffer(), mime: "audio/aac" },
      12: { ext: "ogg", fnc: (e) => e.arrayBuffer(), mime: "audio/ogg" },
      13: { ext: "aac", fnc: (e) => e.arrayBuffer(), mime: "audio/aac" },
      14: { ext: "flac", fnc: (e) => e.arrayBuffer(), mime: "audio/flac" },
      15: { ext: "wav", fnc: (e) => e.arrayBuffer(), mime: "audio/wav" },
      20: { ext: "mp4", fnc: (e) => __privateGet$5(this, _genVideo).call(this, e), mime: "video/mp4" },
      21: { ext: "webm", fnc: (e) => __privateGet$5(this, _genVideo).call(this, e), mime: "video/webm" },
      22: { ext: "ogv", fnc: (e) => __privateGet$5(this, _genVideo).call(this, e), mime: "video/ogv" }
    }), __privateAdd$5(this, _genImage, (e) => new Promise((R, N) => {
      const M = new Image();
      M.onload = () => R(M), M.onerror = (D) => N(D), M.src = URL.createObjectURL(e);
    })), __privateAdd$5(this, _genVideo, (e) => new Promise((R, N) => {
      const M = document.createElement("video");
      this.elc.add(M, "error", () => {
        var D, L;
        return N((L = (D = M == null ? void 0 : M.error) == null ? void 0 : D.message) != null ? L : "");
      }), this.elc.add(M, "canplay", () => R(M)), M.src = URL.createObjectURL(e);
    })), this.enc = (e) => e, this.stk = () => "", this.hash = (e) => "", this.isApp = !1, this.$path_downloads = "", this.$path_userdata = "", this.canCapturePage = (e) => !1;
  }
  async loaded(o, t) {
    const e = o.snsys_pre;
    return delete o.snsys_pre, e == null ? void 0 : e.init({
      addTag: () => {
      },
      addLayCls: () => {
      },
      searchPath: () => "",
      getVal: () => ({}),
      resume: () => {
      },
      render: () => {
      },
      setDec: (R) => __privateSet$5(this, _preFromPlg, R),
      setEnc: (R) => this.enc = R,
      getStK: (R) => this.stk = R,
      getHash: (R) => this.hash = R
    });
  }
  get cur() {
    return this.arg.cur;
  }
  get crypto() {
    return this.arg.crypto;
  }
  destroy() {
    this.elc.clear();
  }
  async loadPath(o, t) {
    this.cfg = t;
  }
  initVal(o, t, e) {
  }
  flush() {
  }
  async run() {
  }
  init(o, t, e, R) {
    this.val = e, this.appPixi = t;
    let N = "";
    try {
      this.val.setSys(this), N = "sys", N += Number(this.val.getVal("sys:TextLayer.Back.Alpha", 1)), N = "kidoku", this.val.saveKidoku();
    } catch (D) {
      console.error(`\u30BB\u30FC\u30D6\u30C7\u30FC\u30BF\uFF08${N}\uFF09\u304C\u58CA\u308C\u3066\u3044\u307E\u3059\u3002\u4E00\u5EA6\u30AF\u30EA\u30A2\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059 %o`, D);
    }
    o.close = (D) => this.close(D), o.export = (D) => this._export(D), o.import = (D) => this._import(D), o.navigate_to = (D) => this.navigate_to(D), o.title = (D) => this.title(D), o.toggle_full_screen = (D) => __privateGet$5(this, _tglFlscr).call(this, D), o.update_check = (D) => this.update_check(D), o.window = (D) => this.window(D), e.setVal_Nochk("tmp", "const.sn.isApp", () => this.isApp), e.setVal_Nochk("tmp", "const.sn.isDbg", () => CmnLib.isDbg), e.setVal_Nochk("tmp", "const.sn.isPackaged", () => CmnLib.isPackaged), this.val.defTmp("const.sn.displayState", () => this.isFullScr), e.setVal_Nochk("sys", _SysBase.VALNM_CFG_NS, this.cfg.oCfg.save_ns), e.flush(), CmnLib.isDbg && this.attach_debug(R), this.hFactoryCls = {};
    const M = [];
    for (const D in this.hPlg)
      M.push(this.hPlg[D].init({
        addTag: (L, B) => {
          if (o[L])
            throw `\u3059\u3067\u306B\u5B9A\u7FA9\u6E08\u307F\u306E\u30BF\u30B0[${L}]\u3067\u3059`;
          o[L] = B;
        },
        addLayCls: (L, B) => {
          if (this.hFactoryCls[L])
            throw `\u3059\u3067\u306B\u5B9A\u7FA9\u6E08\u307F\u306E\u30EC\u30A4\u30E4cls\u3010${L}\u3011\u3067\u3059`;
          this.hFactoryCls[L] = B;
        },
        searchPath: (L, B = "") => this.cfg.searchPath(L, B),
        getVal: e.getVal,
        resume: () => R.resume(),
        render: (L, B, $ = !1) => this.appPixi.renderer.render(L, { renderTexture: B, clear: $ }),
        setDec: (L) => __privateSet$5(this, _preFromPlg, L),
        setEnc: (L) => this.enc = L,
        getStK: (L) => this.stk = L,
        getHash: (L) => this.hash = L
      }));
    return M;
  }
  get cvsWidth() {
    return __privateGet$5(this, _cvsWidth);
  }
  get cvsHeight() {
    return __privateGet$5(this, _cvsHeight);
  }
  get cvsScale() {
    return __privateGet$5(this, _cvsScale);
  }
  get ofsLeft4elm() {
    return __privateGet$5(this, _ofsLeft4elm);
  }
  get ofsTop4elm() {
    return __privateGet$5(this, _ofsTop4elm);
  }
  get ofsPadLeft_Dom2PIXI() {
    return __privateGet$5(this, _ofsPadLeft_Dom2PIXI);
  }
  get ofsPadTop_Dom2PIXI() {
    return __privateGet$5(this, _ofsPadTop_Dom2PIXI);
  }
  cvsResize() {
    var L, B;
    let o = globalThis.innerWidth, t = globalThis.innerHeight;
    const e = this.appPixi.view, R = e.parentElement !== document.body;
    if (R) {
      const $ = globalThis.getComputedStyle(e);
      o = parseFloat($.width), t = parseFloat($.height);
    }
    if (CmnLib.isMobile) {
      const U = ((B = (L = screen.orientation) == null ? void 0 : L.angle) != null ? B : 0) % 180 === 0;
      (U && o > t || !U && o < t) && ([o, t] = [t, o]);
    }
    const N = e.getBoundingClientRect();
    if (argChk_Boolean(CmnLib.hDip, "expanding", !0) || R || CmnLib.stageW > o || CmnLib.stageH > t)
      if (CmnLib.stageW / CmnLib.stageH <= o / t ? (__privateSet$5(this, _cvsHeight, t), __privateSet$5(this, _cvsWidth, CmnLib.stageW / CmnLib.stageH * t)) : (__privateSet$5(this, _cvsWidth, o), __privateSet$5(this, _cvsHeight, CmnLib.stageH / CmnLib.stageW * o)), __privateSet$5(this, _cvsScale, __privateGet$5(this, _cvsWidth) / CmnLib.stageW), R)
        __privateSet$5(this, _ofsPadLeft_Dom2PIXI, 0), __privateSet$5(this, _ofsPadTop_Dom2PIXI, 0);
      else {
        const $ = 1 - __privateGet$5(this, _cvsScale);
        CmnLib.isMobile ? (__privateSet$5(this, _ofsPadLeft_Dom2PIXI, (o - __privateGet$5(this, _cvsWidth)) / 2 * $), __privateSet$5(this, _ofsPadTop_Dom2PIXI, (t - __privateGet$5(this, _cvsHeight)) / 2 * $)) : (__privateSet$5(this, _ofsPadLeft_Dom2PIXI, N.left * $), __privateSet$5(this, _ofsPadTop_Dom2PIXI, N.top * $));
      }
    else
      __privateSet$5(this, _cvsWidth, CmnLib.stageW), __privateSet$5(this, _cvsHeight, CmnLib.stageH), __privateSet$5(this, _cvsScale, 1), __privateSet$5(this, _ofsPadLeft_Dom2PIXI, 0), __privateSet$5(this, _ofsPadTop_Dom2PIXI, 0);
    const M = e.parentElement.style;
    R || (M.position = "relative", M.width = `${__privateGet$5(this, _cvsWidth)}px`, M.height = `${__privateGet$5(this, _cvsHeight)}px`);
    const D = e.style;
    D.width = M.width, D.height = M.height, R ? (__privateSet$5(this, _ofsLeft4elm, N.left), __privateSet$5(this, _ofsTop4elm, N.top)) : (__privateSet$5(this, _ofsLeft4elm, 0), __privateSet$5(this, _ofsTop4elm, 0)), this.isFullScr && (__privateSet$5(this, _ofsLeft4elm, __privateGet$5(this, _ofsLeft4elm) + (o - __privateGet$5(this, _cvsWidth)) / 2), __privateSet$5(this, _ofsTop4elm, __privateGet$5(this, _ofsTop4elm) + (t - __privateGet$5(this, _cvsHeight)) / 2));
  }
  attach_debug(o) {
    this.attach_debug = () => {
    };
    const t = document.createElement("style");
    t.innerHTML = `/* SKYNovel Dbg */
.sn_BounceInOut { animation: sn_kfBounceInOut linear 1.5s; }
@keyframes sn_kfBounceInOut{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
10%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
20%	{				transform: scaleX(0.95) scaleY(0.95);}
30%	{				transform: scaleX(1.00) scaleY(1.00);}
70%	{opacity: 1;}
100%{opacity: 0;}
}
.sn_BounceIn { animation: sn_kfBounceIn linear 0.3s; }
@keyframes sn_kfBounceIn{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
50%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
100%{				transform: scaleX(0.95) scaleY(0.95);}
}
.sn_HopIn { animation: sn_kfHopIn linear 0.8s; }
@keyframes sn_kfHopIn{
0%	{transform:	translate(0px,   0px);}
15% {transform:	translate(0px, -25px);}
30% {transform:	translate(0px,   0px);}
45% {transform:	translate(0px, -15px);}
60% {transform:	translate(0px,   0px);}
75% {transform:	translate(0px,  -5px);}
100%{transform:	translate(0px,   0px);}
}`, document.getElementsByTagName("head")[0].appendChild(t), this.addHook((e, R) => {
      var N, M;
      return (M = (N = __privateGet$5(this, _hHook))[e]) == null ? void 0 : M.call(N, R);
    }), __privateSet$5(this, _sk, lookup(`http://localhost:${this.extPort}`)), __privateGet$5(this, _sk).on("data", (e, R) => {
      this.callHook(e, R);
    }).on("disconnect", () => o.setLoop(!0)), this.callHook = (e, R) => __privateGet$5(this, _aFncHook).forEach((N) => N(e, R));
  }
  end() {
    var o;
    (o = __privateGet$5(this, _sk)) == null || o.disconnect(), __privateSet$5(this, _sk, void 0);
  }
  toast(o) {
    var M, D, L;
    const t = document.body;
    t.querySelectorAll(".sn_BounceIn, .sn_HopIn").forEach((B) => t.removeChild(B));
    const e = document.createElement("img"), R = __privateGet$5(_SysBase, _hToastDat)[o];
    e.src = `data:image/svg+xml;base64,${R.dat}`;
    const N = Math.min(CmnLib.stageW, CmnLib.stageH) / 4 * __privateGet$5(this, _cvsScale);
    e.width = e.height = N, e.style.cssText = `position: absolute;
left: ${(CmnLib.stageW - N) / 2 * __privateGet$5(this, _cvsScale) + N * ((M = R.dx) != null ? M : 0)}px;
top: ${(CmnLib.stageH - N) / 2 * __privateGet$5(this, _cvsScale) + N * ((D = R.dy) != null ? D : 0)}px;`, e.classList.add("sn_toast", (L = R.ease) != null ? L : "sn_BounceInOut"), R.ease || e.addEventListener("animationend", () => t.removeChild(e), { once: !0, passive: !0 }), t.insertBefore(e, this.appPixi.view);
  }
  setFire(o) {
    this.fire = o;
  }
  addHook(o) {
    __privateGet$5(this, _aFncHook).push(o);
  }
  titleSub(o) {
  }
  tglFlscr_sub() {
  }
  setTitleInfo(o) {
    __privateSet$5(this, _info_title, o), this.titleSub(__privateGet$5(this, _main_title) + __privateGet$5(this, _info_title));
  }
  decStr(o, t) {
    return __privateGet$5(this, _preFromPlg).call(this, o, t).ret;
  }
  async dec(o, t) {
    const { ret: e, ext_num: R } = __privateGet$5(this, _preFromPlg).call(this, o, t), N = __privateGet$5(this, _hN2Ext)[R];
    return N != null && N.fnc ? await N.fnc(new Blob([e], { type: N.mime })) : e;
  }
  get path_downloads() {
    return this.$path_downloads;
  }
  get path_userdata() {
    return this.$path_userdata;
  }
  async savePic(o, t) {
  }
  async appendFile(o, t, e) {
  }
  async ensureFileSync(o) {
  }
};
let SysBase = _SysBase;
_cvsWidth = /* @__PURE__ */ new WeakMap();
_cvsHeight = /* @__PURE__ */ new WeakMap();
_cvsScale = /* @__PURE__ */ new WeakMap();
_ofsLeft4elm = /* @__PURE__ */ new WeakMap();
_ofsTop4elm = /* @__PURE__ */ new WeakMap();
_ofsPadLeft_Dom2PIXI = /* @__PURE__ */ new WeakMap();
_ofsPadTop_Dom2PIXI = /* @__PURE__ */ new WeakMap();
_sk = /* @__PURE__ */ new WeakMap();
_hHook = /* @__PURE__ */ new WeakMap();
_hToastDat = /* @__PURE__ */ new WeakMap();
_aFncHook = /* @__PURE__ */ new WeakMap();
_main_title = /* @__PURE__ */ new WeakMap();
_tglFlscr = /* @__PURE__ */ new WeakMap();
_info_title = /* @__PURE__ */ new WeakMap();
_preFromPlg = /* @__PURE__ */ new WeakMap();
_hN2Ext = /* @__PURE__ */ new WeakMap();
_genImage = /* @__PURE__ */ new WeakMap();
_genVideo = /* @__PURE__ */ new WeakMap();
SysBase.VALNM_CFG_NS = "const.sn.cfg.ns";
__privateAdd$5(SysBase, _hToastDat, {
  \u63A5\u7D9A: { dx: -1, dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMCAyOTJ2NTUuODhoMTI3LjEzYzEyLjM3IDQ2IDU0LjEyIDc5Ljg3IDEwNCA3OS44N2g3Ny44N3YtMjE1LjYyYy00Ni43MyAwLTcyLjY4IDAtNzcuODggMC00OS43NCAwLTkxLjYyIDMzLjg3LTEwMy45OSA3OS44Ny0xNi45NSAwLTU5LjMzIDAtMTI3LjEzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im01MTIuODggMjkyYy0xMi4zOC00Ni01NC4xMy03OS44Ny0xMDQtNzkuODctNS4yMSAwLTMxLjIxIDAtNzggMHYyMTUuNzRoNzcuODdjNDkuODggMCA5MS43NS0zMy44NyAxMDQtNzkuODdoMTI3LjI1di01NmMtNzYuMjcgMC0xMTguNjUgMC0xMjcuMTIgMHoiLz48L2RlZnM+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9IiMzYWFiZDIiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYiIvPjx1c2UgZmlsbD0iIzNhYWJkMiIgeGxpbms6aHJlZj0iI2MiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNjIi8+PC9zdmc+" },
  \u5207\u65AD: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMTkxLjUzIDIyMS4yNGMtNDUuNjggMC04NC4wMSAzMS4wNC05NS4zIDczLjE2LTYuNDEgMC0zOC40OSAwLTk2LjIzIDB2NTEuMjFoOTYuMjNjMTEuMyA0Mi4xMSA0OS42MyA3My4xNiA5NS4zIDczLjE2aDcxLjMzdi00OC4yNGg1My43OHYtMTAxLjA1aC01My43OHYtNDguMjRjLTQyLjggMC02Ni41NyAwLTcxLjMzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im00NDguNDcgMjIxLjIzYy00Ljc2IDAtMjguNTMgMC03MS4zMyAwdjE5Ny41M2g3MS4zM2M0NS42OCAwIDgzLjk5LTMxLjA0IDk1LjI5LTczLjE1aDk2LjI0di01MS4yMWgtOTYuMjRjLTMzLjA4LTQ4Ljc4LTY0Ljg0LTczLjE3LTk1LjI5LTczLjE3eiIvPjwvZGVmcz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0iI2RmNTY1NiIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSIjZGY1NjU2IiB4bGluazpocmVmPSIjYyIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2MiLz48L3N2Zz4=" },
  \u518D\u751F: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yNTguODMgMTExLjA1Yy0xLjI5Ljc5LTIuOTMuODMtNC4yNi4wNC0xLjI5LS43NC0yLjExLTIuMTItMi4xMS0zLjY3IDAtNy4xNiAwLTQyLjk3IDAtMTA3LjQzczAtMTAwLjI3IDAtMTA3LjQzYzAtMS41My44Mi0yLjkzIDIuMTEtMy42OCAxLjMzLS43NiAyLjk3LS43MiA0LjI2LjA0IDE4IDEwLjc1IDE2MiA5Ni43MSAxODAgMTA3LjQ2IDEuMjkuNzMgMi4wNSAyLjE0IDIuMDUgMy42MSAwIDEuNDktLjc2IDIuODgtMi4wNSAzLjYzLTM2IDIxLjQ5LTE2MiA5Ni42OS0xODAgMTA3LjQzeiIvPjwvZGVmcz48cGF0aCBkPSJtMTU0LjU3IDE3MC4xOWgzNDYuMTV2MzA3LjY5aC0zNDYuMTV6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
  \u4E00\u6642\u505C\u6B62: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yMDAgMTAwdi0yMDBoODB2MjAwem0xNjAgMHYtMjAwaDgwdjIwMHoiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxODAuNDFoMzUyLjR2MjgyLjY5aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
  \u6CE8\u610F: { ease: "sn_HopIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMzQzLjM0IDI5LjJjLTEwLjM3LTE3Ljk3LTM2LjMxLTE3Ljk3LTQ2LjY5IDAtMjkuMyA1MC43NS0yNjMuNyA0NTYuNzQtMjkzIDUwNy40OS0xMC4zNyAxNy45NyAyLjU5IDQwLjQ0IDIzLjM0IDQwLjQ0aDU4Ni4wMWMyMC43NSAwIDMzLjcyLTIyLjQ2IDIzLjM1LTQwLjQ0LTU4LjYtMTAxLjUtMjYzLjctNDU2Ljc0LTI5My4wMS01MDcuNDl6bS0yMy4zNCA0ODIuODNjLTE0LjUyIDAtMjYuMjktMi43MS0yNi4yOS02LjA2IDAtNC4yMSAwLTM3Ljg2IDAtNDIuMDcgMC0zLjM1IDExLjc3LTYuMDcgMjYuMjktNi4wN3MyNi4yOSAyLjcyIDI2LjI5IDYuMDd2NDIuMDdjLTcuODQgNC4wNC0xNi42MSA2LjA2LTI2LjI5IDYuMDZ6bTIxLjk5LTEwMy44NGMwIDUuNDMtOS44NSA5LjgzLTIxLjk5IDkuODMtMTIuMTUgMC0yMS45OS00LjQtMjEuOTktOS44MyAwLS4xMy4wNy0uMjUuMDgtLjM4LTEuMzctMTcuNTYtMTIuMy0xNTguMDYtMTMuNjctMTc1LjYyIDAtNS40MyAxNS45My05Ljg0IDM1LjU4LTkuODRzMzUuNTggNC40MSAzNS41OCA5Ljg0Yy0uOTEgMTEuNy01LjQ3IDcwLjI1LTEzLjY3IDE3NS42Mi4wNi4xNi4wOC4yOS4wOC4zOHoiLz48L2RlZnM+PHBhdGggZD0ibTI0MS4yOSAxOTEuNDRoMTQ1LjQ5djM1MS42NmgtMTQ1LjQ5eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iI2QyYmYzYSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
  \u4E00\u6B69\u9032\u3080: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0zNzYuOTMgOTEuOTdjMC01My41MSAwLTgzLjI0IDAtODkuMTktLjE1LjE0LS4yNS4zNC0uNDQuNDUtMTYuMTEgOS42Mi0xNDQuOTUgODYuNTQtMTYxLjA2IDk2LjE1LTEuMTUuNjktMi42Mi43My0zLjgxLjAyLTEuMTUtLjY0LTEuODktMS44OS0xLjg5LTMuMjggMC02LjQxIDAtMzguNDQgMC05Ni4xMSAwLTU3LjY5IDAtODkuNzQgMC05Ni4xNSAwLTEuMzUuNzQtMi42MiAxLjg5LTMuMjkgMS4xOS0uNjggMi42Ni0uNjQgMy44MS4wNCAxNi4xMSA5LjYyIDE0NC45NSA4Ni41NCAxNjEuMDYgOTYuMTYuMTkuMS4yOS4zMS40NC40NSAwLTYuMTMgMC0zNi43NyAwLTkxLjkyaDUzLjMydjE4Ni42N3oiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxNTQuMmgzNTIuNHYzMDguOWgtMzUyLjR6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
  \u4E00\u6B69\u623B\u308B: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem00MzAuMjcgOTYuMTRjMCAxLjM1LS43NCAyLjYyLTEuODkgMy4yOC0xLjE5LjY5LTIuNjYuNjUtMy44MS0uMDMtMTYuMTEtOS42Mi0xNDQuOTUtODYuNTQtMTYxLjA1LTk2LjE2LS4yLS4xLS4yOS0uMzEtLjQ1LS40NXY5MS45MmgtNTMuMzJ2LTE4Ni42N2g1My4zMnY4OS4xOWMuMTYtLjE0LjI1LS4zNC40NS0uNDUgMTYuMS05LjYyIDE0NC45NC04Ni41NCAxNjEuMDUtOTYuMTYgMS4xNS0uNjggMi42Mi0uNzIgMy44MS0uMDEgMS4xNS42NCAxLjg5IDEuODkgMS44OSAzLjI4djk2LjExeiIvPjwvZGVmcz48cGF0aCBkPSJtMTQ3LjQ5IDE1NC4yaDM1Mi40djMwOC45aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
  \u30B9\u30C6\u30C3\u30D5\u309A\u30A4\u30F3: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMTkuOTljMCAxNzYuNzQgMTQzLjI3IDMyMC4wMSAzMjAuMDEgMzIwLjAxIDE3Ni43MiAwIDMxOS45OS0xNDMuMjcgMzE5Ljk5LTMyMC4wMSAwLTE3Ni43Mi0xNDMuMjctMzE5Ljk5LTMxOS45OS0zMTkuOTktMTc2Ljc0IDAtMzIwLjAxIDE0My4yNy0zMjAuMDEgMzE5Ljk5em0xNTMuMDUtMjkuNzIgNTUuMTItNTUuMTMgMTExLjg0IDExMS44MiAxMTEuODItMTExLjgyIDU1LjEyIDU1LjEyLTE2Ni45NCAxNjYuOTd6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
  \u30B9\u30C6\u30C3\u30D5\u309A\u30A2\u30A6\u30C8: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjAuMDFjMCAxNzYuNzIgMTQzLjI3IDMxOS45OSAzMTkuOTkgMzE5Ljk5IDE3Ni43NCAwIDMyMC4wMS0xNDMuMjcgMzIwLjAxLTMxOS45OSAwLTE3Ni43NC0xNDMuMjctMzIwLjAxLTMyMC4wMS0zMjAuMDEtMTc2LjcyIDAtMzE5Ljk5IDE0My4yNy0zMTkuOTkgMzIwLjAxem0zMTkuOTktMjYuOTgtMTExLjgyIDExMS44My01NS4xMi01NS4xMyAxNjYuOTQtMTY2Ljk2IDE2Ni45NiAxNjYuOTYtNTUuMTIgNTUuMTN6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" }
});
var __accessCheck$4 = (o, t, e) => {
  if (!t.has(o))
    throw TypeError("Cannot " + e);
}, __privateGet$4 = (o, t, e) => (__accessCheck$4(o, t, "read from private field"), e ? e.call(o) : t.get(o)), __privateAdd$4 = (o, t, e) => {
  if (t.has(o))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(o) : t.set(o, e);
}, __privateSet$4 = (o, t, e, R) => (__accessCheck$4(o, t, "write to private field"), R ? R.call(o, e) : t.set(o, e), e), _existsBreakline, _existsBreakpage, _REG_PATH;
const _Config = class {
  constructor(o) {
    this.sys = o, this.oCfg = {
      save_ns: "",
      window: {
        width: 300,
        height: 300
      },
      book: {
        title: "",
        creator: "",
        cre_url: "",
        publisher: "",
        pub_url: "",
        detail: "",
        version: "1.0"
      },
      log: { max_len: 1024 },
      init: {
        bg_color: "#000000",
        tagch_msecwait: 10,
        auto_msecpagewait: 3500,
        escape: ""
      },
      debug: {
        devtool: !1,
        token: !1,
        tag: !1,
        putCh: !1,
        debugLog: !1,
        baseTx: !1,
        masume: !1,
        variable: !1
      },
      code: {},
      debuger_token: ""
    }, this.userFnTail = "", this.hPathFn2Exts = {}, __privateAdd$4(this, _existsBreakline, !1), __privateAdd$4(this, _existsBreakpage, !1), __privateAdd$4(this, _REG_PATH, /([^\/\s]+)\.([^\d]\w+)/);
  }
  static async generate(o) {
    const t = new _Config(o), e = o.cur + "prj.json", R = await (await o.fetch(e)).text(), N = JSON.parse(o.decStr(e, R));
    return await t.load(N), t;
  }
  async load(o) {
    var t, e, R, N, M, D, L, B;
    if (this.oCfg.save_ns = (t = o == null ? void 0 : o.save_ns) != null ? t : this.oCfg.save_ns, CmnLib.stageW = this.oCfg.window.width = Number((R = (e = o == null ? void 0 : o.window) == null ? void 0 : e.width) != null ? R : this.oCfg.window.width), CmnLib.stageH = this.oCfg.window.height = Number((M = (N = o == null ? void 0 : o.window) == null ? void 0 : N.height) != null ? M : this.oCfg.window.height), this.oCfg.book = { ...this.oCfg.book, ...o.book }, this.oCfg.log.max_len = (B = (L = (D = o.log) == null ? void 0 : D.max_len) == null ? void 0 : L.max_len) != null ? B : this.oCfg.log.max_len, this.oCfg.init = { ...this.oCfg.init, ...o.init }, this.oCfg.debug = { ...this.oCfg.debug, ...o.debug }, CmnLib.debugLog = this.oCfg.debug.debugLog, this.oCfg.debuger_token = o.debuger_token, await this.sys.loadPath(this.hPathFn2Exts, this), __privateSet$4(this, _existsBreakline, this.matchPath("^breakline$", _Config.EXT_SPRITE).length > 0), __privateSet$4(this, _existsBreakpage, this.matchPath("^breakpage$", _Config.EXT_SPRITE).length > 0), this.sys.crypto)
      for (const $ in this.hPathFn2Exts) {
        const U = this.hPathFn2Exts[$];
        for (const H in U) {
          if (H.slice(-10) !== ":RIPEMD160")
            continue;
          const z = U[H].slice(U[H].lastIndexOf("/") + 1), X = U[H.slice(0, -10)], W = await (await this.sys.fetch(X)).text(), q = this.sys.hash(W);
          if (z !== q)
            throw `\u30D5\u30A1\u30A4\u30EB\u6539\u7AC4\u30A8\u30E9\u30FC\u3067\u3059 fn:${X}`;
        }
      }
  }
  get existsBreakline() {
    return __privateGet$4(this, _existsBreakline);
  }
  get existsBreakpage() {
    return __privateGet$4(this, _existsBreakpage);
  }
  getNs() {
    return `skynovel.${this.oCfg.save_ns} - `;
  }
  searchPath(o, t = "") {
    if (!o)
      throw "[searchPath] fn\u304C\u7A7A\u3067\u3059";
    if (o.slice(0, 7) === "http://")
      return o;
    if (o.slice(0, 11) === "downloads:/") {
      const L = this.sys.path_downloads + o.slice(11);
      return this.sys.ensureFileSync(L), L;
    }
    if (o.slice(0, 10) === "userdata:/") {
      const L = this.sys.path_userdata + "storage/" + o.slice(10);
      return this.sys.ensureFileSync(L), L;
    }
    const e = o.match(__privateGet$4(this, _REG_PATH));
    let R = e ? e[1] : o;
    const N = e ? e[2] : "";
    if (this.userFnTail) {
      const L = R + "@@" + this.userFnTail;
      if (L in this.hPathFn2Exts) {
        if (t === "")
          R = L;
        else
          for (let B in this.hPathFn2Exts[L])
            if (`|${t}|`.indexOf(`|${B}|`) !== -1) {
              R = L;
              break;
            }
      }
    }
    const M = this.hPathFn2Exts[R];
    if (!M)
      throw `\u30B5\u30FC\u30C1\u30D1\u30B9\u306B\u5B58\u5728\u3057\u306A\u3044\u30D5\u30A1\u30A4\u30EB\u3010${o}\u3011\u3067\u3059`;
    let D = "";
    if (!N) {
      const L = int(M[":cnt"]);
      if (t === "") {
        if (L > 1)
          throw `\u6307\u5B9A\u30D5\u30A1\u30A4\u30EB\u3010${o}\u3011\u304C\u8907\u6570\u30DE\u30C3\u30C1\u3057\u307E\u3059\u3002\u30B5\u30FC\u30C1\u5BFE\u8C61\u62E1\u5F35\u5B50\u7FA4\u3010${t}\u3011\u3067\u7D5E\u308A\u8FBC\u3080\u304B\u3001\u30D5\u30A1\u30A4\u30EB\u540D\u3092\u500B\u5225\u306B\u3057\u3066\u4E0B\u3055\u3044\u3002`;
        return o;
      }
      const B = `|${t}|`;
      if (L > 1) {
        let $ = 0;
        for (const U in M)
          if (B.indexOf(`|${U}|`) !== -1 && ++$ > 1)
            throw `\u6307\u5B9A\u30D5\u30A1\u30A4\u30EB\u3010${o}\u3011\u304C\u8907\u6570\u30DE\u30C3\u30C1\u3057\u307E\u3059\u3002\u30B5\u30FC\u30C1\u5BFE\u8C61\u62E1\u5F35\u5B50\u7FA4\u3010${t}\u3011\u3067\u7D5E\u308A\u8FBC\u3080\u304B\u3001\u30D5\u30A1\u30A4\u30EB\u540D\u3092\u500B\u5225\u306B\u3057\u3066\u4E0B\u3055\u3044\u3002`;
      }
      for (let $ in M)
        if (B.indexOf(`|${$}|`) > -1)
          return M[$];
      throw `\u30B5\u30FC\u30C1\u5BFE\u8C61\u62E1\u5F35\u5B50\u7FA4\u3010${t}\u3011\u306B\u30DE\u30C3\u30C1\u3059\u308B\u30D5\u30A1\u30A4\u30EB\u304C\u30B5\u30FC\u30C1\u30D1\u30B9\u306B\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\u63A2\u7D22\u30D5\u30A1\u30A4\u30EB\u540D=\u3010${o}\u3011`;
    }
    if (t !== "" && `|${t}|`.indexOf(`|${N}|`) === -1)
      throw `\u6307\u5B9A\u30D5\u30A1\u30A4\u30EB\u306E\u62E1\u5F35\u5B50\u3010${N}\u3011\u306F\u3001\u30B5\u30FC\u30C1\u5BFE\u8C61\u62E1\u5F35\u5B50\u7FA4\u3010${t}\u3011\u306B\u30DE\u30C3\u30C1\u3057\u307E\u305B\u3093\u3002\u63A2\u7D22\u30D5\u30A1\u30A4\u30EB\u540D=\u3010${o}\u3011`;
    if (D = M[N], !D)
      throw `\u30B5\u30FC\u30C1\u30D1\u30B9\u306B\u5B58\u5728\u3057\u306A\u3044\u62E1\u5F35\u5B50\u3010${N}\u3011\u3067\u3059\u3002\u63A2\u7D22\u30D5\u30A1\u30A4\u30EB\u540D=\u3010${o}\u3011\u3001\u30B5\u30FC\u30C1\u5BFE\u8C61\u62E1\u5F35\u5B50\u7FA4\u3010${t}\u3011`;
    return D;
  }
  matchPath(o, t = "") {
    const e = [], R = new RegExp(o), N = new RegExp(t);
    for (let M in this.hPathFn2Exts) {
      if (M.search(R) === -1)
        continue;
      const D = this.hPathFn2Exts[M];
      if (t === "") {
        e.push(D);
        continue;
      }
      const L = {};
      let B = !1;
      for (const $ in D)
        $.search(N) !== -1 && (L[$] = M, B = !0);
      B && e.push(L);
    }
    return e;
  }
  addPath(o, t) {
    const e = {};
    for (const R in t)
      e[R] = (R.charAt(0) === ":" ? "" : this.sys.cur) + t[R];
    this.hPathFn2Exts[o] = e;
  }
};
let Config = _Config;
_existsBreakline = /* @__PURE__ */ new WeakMap();
_existsBreakpage = /* @__PURE__ */ new WeakMap();
_REG_PATH = /* @__PURE__ */ new WeakMap();
Config.EXT_SPRITE = "png|jpg|jpeg|json|svg|webp|mp4|webm";
Config.EXT_SCRIPT = "sn|ssn";
Config.EXT_FONT = "woff2|woff|otf|ttf";
Config.EXT_SOUND = "mp3|m4a|ogg|aac|flac|wav";
Config.EXT_HTML = "htm|html";
var Qi, Mr, Aa;
const mi = class {
  constructor() {
    nt(this, Mr, () => {
    });
  }
  static setting(t) {
    t.sesame && it(mi, Qi, t.sesame);
  }
  static getSesame() {
    return V(mi, Qi);
  }
  static destroy() {
    it(mi, Qi, "\u30FD");
  }
  init(t) {
    it(this, Mr, t);
  }
  static setEscape(t) {
    it(mi, Aa, new RegExp(
      `${t ? `(?<ce>\\${t}\\S)|` : ""}\uFF5C(?<str>[^\u300A\\n]+)\u300A(?<ruby>[^\u300B\\n]+)\u300B|(?:(?<kan>[\u2E80-\u2FDF\u3005\u3007\u303B\u3400-\u9FFF\u8C48-\uFAFF]+[\u3041-\u30FF]*|[^\u3000\uFF5C\u300A\u300B\\n])\u300A(?<kan_ruby>[^\u300B\\n]+)\u300B)|(?<txt>[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\u3000\uFF5C\u300A\u300B]+(?=\uFF5C)|[^\u3000\uFF5C\u300A\u300B]*[\u3041-\u30FF](?=[\u2E80-\u2FDF\u3005\u3007\u303B\u3400-\u9FFF\u8C48-\uFAFF]+\u300A)|.)`,
      "gs"
    ));
  }
  putTxt(t) {
    var R;
    let e = null;
    for (; e = V(mi, Aa).exec(t); ) {
      const N = e == null ? void 0 : e.groups;
      if (!N)
        continue;
      const M = N.ruby;
      if (M) {
        this.putTxtRb(decodeURIComponent(N.str), M);
        continue;
      }
      const D = N.kan_ruby;
      if (D) {
        this.putTxtRb(N.kan, D);
        continue;
      }
      if (N.ce) {
        V(this, Mr).call(this, N.ce.slice(1), "");
        continue;
      }
      Array.from((R = N.txt) != null ? R : "").forEach((L) => V(this, Mr).call(this, L, ""));
    }
  }
  putTxtRb(t, e) {
    if (/^\w+｜{"/.test(e)) {
      V(this, Mr).call(this, t, e);
      return;
    }
    const R = Array.from(t), N = R.length;
    if (/^\*.?$/.test(e)) {
      const B = "center\uFF5C" + (e === "*" ? V(mi, Qi) : e.charAt(1));
      for (let $ = 0; $ < N; ++$)
        V(this, Mr).call(this, R[$], B);
      return;
    }
    if (N === 1 || e.indexOf(" ") === -1) {
      V(this, Mr).call(this, t, decodeURIComponent(e));
      return;
    }
    const M = e.split(" "), D = M.length, L = D > N ? D : N;
    for (let B = 0; B < L; ++B)
      V(this, Mr).call(this, B < N ? R[B] : "", B < D ? decodeURIComponent(M[B]) : "");
  }
};
let RubySpliter = mi;
Qi = new WeakMap(), Mr = new WeakMap(), Aa = new WeakMap(), nt(RubySpliter, Qi, "\u30FD"), nt(RubySpliter, Aa, void 0);
const REG_TAG = /(?<name>[^\s;\]]+)/;
function tagToken2Name_Args(o) {
  const t = REG_TAG.exec(o.slice(1, -1)), e = t == null ? void 0 : t.groups;
  if (!e)
    throw `\u30BF\u30B0\u8A18\u8FF0\u3010${o}\u3011\u7570\u5E38\u3067\u3059(\u30BF\u30B0\u89E3\u6790)`;
  const R = e.name;
  return [R, o.slice(1 + R.length, -1)];
}
function tagToken2Name(o) {
  const t = REG_TAG.exec(o.slice(1)), e = t == null ? void 0 : t.groups;
  if (!e)
    throw `\u30BF\u30B0\u8A18\u8FF0\u3010${o}\u3011\u7570\u5E38\u3067\u3059(\u30BF\u30B0\u89E3\u6790)`;
  return e.name;
}
function splitAmpersand(o) {
  const t = o.replaceAll("==", "\uFF1D").replaceAll("!=", "\u2260").split("="), e = t.length;
  if (e < 2 || e > 3)
    throw "\u300C&\u8A08\u7B97\u300D\u66F8\u5F0F\u3067\u306F\u300C=\u300D\u6307\u5B9A\u304C\u4E00\u3064\u304B\u4E8C\u3064\u5FC5\u8981\u3067\u3059";
  if (t[1].charAt(0) === "&")
    throw "\u300C&\u8A08\u7B97\u300D\u66F8\u5F0F\u3067\u306F\u300C&\u300D\u6307\u5B9A\u304C\u4E0D\u8981\u3067\u3059";
  return {
    name: t[0].replaceAll("\uFF1D", "==").replaceAll("\u2260", "!="),
    text: t[1].replaceAll("\uFF1D", "==").replaceAll("\u2260", "!="),
    cast: e === 3 ? t[2].trim() : void 0
  };
}
var tn, ts, es, rs, Ue;
class Grammar {
  constructor() {
    nt(this, tn, void 0);
    nt(this, ts, void 0);
    nt(this, es, void 0);
    nt(this, rs, void 0);
    nt(this, Ue, void 0);
    it(this, ts, new RegExp("")), it(this, es, ""), it(this, rs, ""), this.replaceScr_C2M_And_let_ml = (t, e = 0) => {
      if (!!V(this, Ue)) {
        for (let R = t.len - 1; R >= e; --R) {
          const N = t.aToken[R];
          if (this.REG_TOKEN_NOTXT.test(N.charAt(0)))
            continue;
          const M = t.aLNum[R], D = N.match(V(this, ts));
          if (!D)
            continue;
          let L = 1;
          for (let B = D.length - 1; B >= 0; --B) {
            let $ = D[B];
            const U = V(this, Ue)[$.charAt(0)];
            U && ($ = U + (U.slice(-1) === "]" ? "" : `'${$.slice(1, -1)}']`)), t.aToken.splice(R, L, $), t.aLNum.splice(R, L, M), L = 0;
          }
        }
        t.len = t.aToken.length;
      }
    }, this.setEscape("");
  }
  setEscape(t) {
    if (V(this, Ue) && t in V(this, Ue))
      throw "[\u30A8\u30B9\u30B1\u30FC\u30D7\u6587\u5B57] char\u3010" + t + "\u3011\u304C\u767B\u9332\u6E08\u307F\u306E\u62EC\u5F27\u30DE\u30AF\u30ED\u307E\u305F\u306F\u4E00\u6587\u5B57\u30DE\u30AF\u30ED\u3067\u3059";
    const e = t != null ? t : "\\";
    this.REG_TOKEN = new RegExp(
      (t ? `\\${t}\\S|` : "") + `\\n+|\\t+|\\[let_ml\\s+[^\\]]+\\].+?(?=\\[endlet_ml[\\]\\s])|\\[(?:[^"'#;\\]]+|` + (e ? `(?:"(?:\\${e}["'#\\n]|[^"])*"|'(?:\\${e}["'#\\n]|[^'])*'|\\#(?:\\${e}["'#\\n]|[^#])*\\#)` : `(["'#]).*?\\1`) + `|;[^\\n]*)*?]|;[^\\n]*|&[^&\\n]+&|&&?[^;\\n\\t&]+|^\\*\\w+|[^\\n\\t\\[;${t ? `\\${t}` : ""}]+`,
      "gs"
    ), RubySpliter.setEscape(t), it(this, tn, new RegExp(`[\\w\\s;[\\]*=&\uFF5C\u300A\u300B${t ? `\\${t}` : ""}]`)), this.REG_TOKEN_NOTXT = new RegExp(`[\\n\\t;\\[*&${t ? `\\${t}` : ""}]`);
  }
  matchToken(t) {
    var e;
    return (e = t.match(this.REG_TOKEN)) != null ? e : [];
  }
  bracket2macro(t, e, R) {
    var B;
    const { name: N, text: M } = t;
    if (!N)
      throw "[bracket2macro] name\u306F\u5FC5\u9808\u3067\u3059";
    if (!M)
      throw "[bracket2macro] text\u306F\u5FC5\u9808\u3067\u3059";
    if (M.length !== 2)
      throw "[bracket2macro] text\u306F\u62EC\u5F27\u306E\u524D\u5F8C\u3092\u793A\u3059\u4E8C\u6587\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044";
    (B = V(this, Ue)) != null || it(this, Ue, {});
    const D = M.charAt(0), L = M.charAt(1);
    if (D in V(this, Ue))
      throw "[bracket2macro] text\u3010" + D + "\u3011\u304C\u767B\u9332\u6E08\u307F\u306E\u62EC\u5F27\u30DE\u30AF\u30ED\u307E\u305F\u306F\u4E00\u6587\u5B57\u30DE\u30AF\u30ED\u3067\u3059";
    if (L in V(this, Ue))
      throw "[bracket2macro] text\u3010" + L + "\u3011\u304C\u767B\u9332\u6E08\u307F\u306E\u62EC\u5F27\u30DE\u30AF\u30ED\u307E\u305F\u306F\u4E00\u6587\u5B57\u30DE\u30AF\u30ED\u3067\u3059";
    if (V(this, tn).test(D))
      throw "[bracket2macro] text\u3010" + D + "\u3011\u306F\u62EC\u5F27\u30DE\u30AF\u30ED\u306B\u4F7F\u7528\u3067\u304D\u306A\u3044\u6587\u5B57\u3067\u3059";
    if (V(this, tn).test(L))
      throw "[bracket2macro] text\u3010" + L + "\u3011\u306F\u62EC\u5F27\u30DE\u30AF\u30ED\u306B\u4F7F\u7528\u3067\u304D\u306A\u3044\u6587\u5B57\u3067\u3059";
    V(this, Ue)[L] = "0", V(this, Ue)[D] = `[${N} text=`, this.addC2M(`\\${D}[^\\${L}]*\\${L}`, `\\${D}\\${L}`), this.replaceScr_C2M_And_let_ml(e, R);
  }
  char2macro(t, e, R, N) {
    var L;
    const { char: M, name: D } = t;
    if (!M)
      throw "[char2macro] char\u306F\u5FC5\u9808\u3067\u3059";
    if ((L = V(this, Ue)) != null || it(this, Ue, {}), M in V(this, Ue))
      throw "[char2macro] char\u3010" + M + "\u3011\u304C\u767B\u9332\u6E08\u307F\u306E\u62EC\u5F27\u30DE\u30AF\u30ED\u307E\u305F\u306F\u4E00\u6587\u5B57\u30DE\u30AF\u30ED\u3067\u3059";
    if (V(this, tn).test(M))
      throw "[char2macro] char\u3010" + M + "\u3011\u306F\u4E00\u6587\u5B57\u30DE\u30AF\u30ED\u306B\u4F7F\u7528\u3067\u304D\u306A\u3044\u6587\u5B57\u3067\u3059";
    if (!D)
      throw "[char2macro] name\u306F\u5FC5\u9808\u3067\u3059";
    if (!(D in e))
      throw `[char2macro] \u672A\u5B9A\u7FA9\u306E\u30BF\u30B0\u53C8\u306F\u30DE\u30AF\u30ED[${D}]\u3067\u3059`;
    V(this, Ue)[M] = `[${D}]`, this.addC2M(`\\${M}`, `\\${M}`), this.replaceScr_C2M_And_let_ml(R, N);
  }
  addC2M(t, e) {
    it(this, es, V(this, es) + `${t}|`), it(this, rs, V(this, rs) + `${e}`), it(this, ts, new RegExp(
      `(${V(this, es)}[^${V(this, rs)}]+)`,
      "g"
    ));
  }
}
tn = new WeakMap(), ts = new WeakMap(), es = new WeakMap(), rs = new WeakMap(), Ue = new WeakMap();
var hu, en, is;
class AnalyzeTagArg {
  constructor() {
    nt(this, hu, /;[^\n]*|(?<key>\w+)(?:\s|;[^\n]*\n)*=(?:\s|;[^\n]*\n)*(?:(?<val>[^\s"'#|;]+)|(["'#])(?<val2>.*?)\3)(?:\|(?:(?<def>[^\s"'#;]+)|(["'#])(?<def2>.*?)\6))?|(?<literal>[^\s;]+)/g);
    nt(this, en, {});
    nt(this, is, !1);
  }
  go(t) {
    var R, N;
    if (it(this, en, {}), it(this, is, !1), !t)
      return;
    let e = null;
    for (; e = V(this, hu).exec(t); ) {
      const M = e == null ? void 0 : e.groups;
      !M || (M.key ? V(this, en)[M.key] = {
        val: (R = M.val) != null ? R : M.val2,
        def: (N = M.def) != null ? N : M.def2
      } : M.literal && (M.literal === "*" ? it(this, is, !0) : V(this, en)[M.literal] = { val: "1" }));
    }
  }
  get hPrm() {
    return V(this, en);
  }
  get isKomeParam() {
    return V(this, is);
  }
}
hu = new WeakMap(), en = new WeakMap(), is = new WeakMap();
var parsimmon_umd_min = { exports: {} };
(function(o, t) {
  (function(e, R) {
    o.exports = R();
  })(typeof self < "u" ? self : commonjsGlobal$1, function() {
    return function(e) {
      var R = {};
      function N(M) {
        if (R[M])
          return R[M].exports;
        var D = R[M] = { i: M, l: !1, exports: {} };
        return e[M].call(D.exports, D, D.exports, N), D.l = !0, D.exports;
      }
      return N.m = e, N.c = R, N.d = function(M, D, L) {
        N.o(M, D) || Object.defineProperty(M, D, { configurable: !1, enumerable: !0, get: L });
      }, N.r = function(M) {
        Object.defineProperty(M, "__esModule", { value: !0 });
      }, N.n = function(M) {
        var D = M && M.__esModule ? function() {
          return M.default;
        } : function() {
          return M;
        };
        return N.d(D, "a", D), D;
      }, N.o = function(M, D) {
        return Object.prototype.hasOwnProperty.call(M, D);
      }, N.p = "", N(N.s = 0);
    }([function(e, R, N) {
      function M(lt) {
        if (!(this instanceof M))
          return new M(lt);
        this._ = lt;
      }
      var D = M.prototype;
      function L(lt, gt) {
        for (var Tt = 0; Tt < lt; Tt++)
          gt(Tt);
      }
      function B(lt, gt, Tt) {
        return function(Pt, Ft) {
          L(Ft.length, function(kt) {
            Pt(Ft[kt], kt, Ft);
          });
        }(function(Pt, Ft, kt) {
          gt = lt(gt, Pt, Ft, kt);
        }, Tt), gt;
      }
      function $(lt, gt) {
        return B(function(Tt, Pt, Ft, kt) {
          return Tt.concat([lt(Pt, Ft, kt)]);
        }, [], gt);
      }
      function U(lt, gt) {
        var Tt = { v: 0, buf: gt };
        return L(lt, function() {
          var Pt;
          Tt = { v: Tt.v << 1 | (Pt = Tt.buf, Pt[0] >> 7), buf: function(Ft) {
            var kt = B(function(Ut, qt, _e, Ge) {
              return Ut.concat(_e === Ge.length - 1 ? Buffer.from([qt, 0]).readUInt16BE(0) : Ge.readUInt16BE(_e));
            }, [], Ft);
            return Buffer.from($(function(Ut) {
              return (Ut << 1 & 65535) >> 8;
            }, kt));
          }(Tt.buf) };
        }), Tt;
      }
      function H() {
        return typeof Buffer < "u";
      }
      function z() {
        if (!H())
          throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
      }
      function X(lt) {
        z();
        var gt = B(function(kt, Ut) {
          return kt + Ut;
        }, 0, lt);
        if (gt % 8 != 0)
          throw new Error("The bits [" + lt.join(", ") + "] add up to " + gt + " which is not an even number of bytes; the total should be divisible by 8");
        var Tt, Pt = gt / 8, Ft = (Tt = function(kt) {
          return kt > 48;
        }, B(function(kt, Ut) {
          return kt || (Tt(Ut) ? Ut : kt);
        }, null, lt));
        if (Ft)
          throw new Error(Ft + " bit range requested exceeds 48 bit (6 byte) Number max.");
        return new M(function(kt, Ut) {
          var qt = Pt + Ut;
          return qt > kt.length ? rt(Ut, Pt.toString() + " bytes") : st(qt, B(function(_e, Ge) {
            var Le = U(Ge, _e.buf);
            return { coll: _e.coll.concat(Le.v), buf: Le.buf };
          }, { coll: [], buf: kt.slice(Ut, qt) }, lt).coll);
        });
      }
      function Y(lt, gt) {
        return new M(function(Tt, Pt) {
          return z(), Pt + gt > Tt.length ? rt(Pt, gt + " bytes for " + lt) : st(Pt + gt, Tt.slice(Pt, Pt + gt));
        });
      }
      function W(lt, gt) {
        if (typeof (Tt = gt) != "number" || Math.floor(Tt) !== Tt || gt < 0 || gt > 6)
          throw new Error(lt + " requires integer length in range [0, 6].");
        var Tt;
      }
      function q(lt) {
        return W("uintBE", lt), Y("uintBE(" + lt + ")", lt).map(function(gt) {
          return gt.readUIntBE(0, lt);
        });
      }
      function Z(lt) {
        return W("uintLE", lt), Y("uintLE(" + lt + ")", lt).map(function(gt) {
          return gt.readUIntLE(0, lt);
        });
      }
      function K(lt) {
        return W("intBE", lt), Y("intBE(" + lt + ")", lt).map(function(gt) {
          return gt.readIntBE(0, lt);
        });
      }
      function J(lt) {
        return W("intLE", lt), Y("intLE(" + lt + ")", lt).map(function(gt) {
          return gt.readIntLE(0, lt);
        });
      }
      function Q(lt) {
        return lt instanceof M;
      }
      function et(lt) {
        return {}.toString.call(lt) === "[object Array]";
      }
      function tt(lt) {
        return H() && Buffer.isBuffer(lt);
      }
      function st(lt, gt) {
        return { status: !0, index: lt, value: gt, furthest: -1, expected: [] };
      }
      function rt(lt, gt) {
        return et(gt) || (gt = [gt]), { status: !1, index: -1, value: null, furthest: lt, expected: gt };
      }
      function at(lt, gt) {
        if (!gt || lt.furthest > gt.furthest)
          return lt;
        var Tt = lt.furthest === gt.furthest ? function(Pt, Ft) {
          if (function() {
            if (M._supportsSet !== void 0)
              return M._supportsSet;
            var Xr = typeof Set < "u";
            return M._supportsSet = Xr, Xr;
          }() && Array.from) {
            for (var kt = new Set(Pt), Ut = 0; Ut < Ft.length; Ut++)
              kt.add(Ft[Ut]);
            var qt = Array.from(kt);
            return qt.sort(), qt;
          }
          for (var _e = {}, Ge = 0; Ge < Pt.length; Ge++)
            _e[Pt[Ge]] = !0;
          for (var Le = 0; Le < Ft.length; Le++)
            _e[Ft[Le]] = !0;
          var Vr = [];
          for (var ir in _e)
            ({}).hasOwnProperty.call(_e, ir) && Vr.push(ir);
          return Vr.sort(), Vr;
        }(lt.expected, gt.expected) : gt.expected;
        return { status: lt.status, index: lt.index, value: lt.value, furthest: gt.furthest, expected: Tt };
      }
      var ut = {};
      function dt(lt, gt) {
        if (tt(lt))
          return { offset: gt, line: -1, column: -1 };
        lt in ut || (ut[lt] = {});
        for (var Tt = ut[lt], Pt = 0, Ft = 0, kt = 0, Ut = gt; Ut >= 0; ) {
          if (Ut in Tt) {
            Pt = Tt[Ut].line, kt === 0 && (kt = Tt[Ut].lineStart);
            break;
          }
          (lt.charAt(Ut) === `
` || lt.charAt(Ut) === "\r" && lt.charAt(Ut + 1) !== `
`) && (Ft++, kt === 0 && (kt = Ut + 1)), Ut--;
        }
        var qt = Pt + Ft, _e = gt - kt;
        return Tt[gt] = { line: qt, lineStart: kt }, { offset: gt, line: qt + 1, column: _e + 1 };
      }
      function ct(lt) {
        if (!Q(lt))
          throw new Error("not a parser: " + lt);
      }
      function pt(lt, gt) {
        return typeof lt == "string" ? lt.charAt(gt) : lt[gt];
      }
      function mt(lt) {
        if (typeof lt != "number")
          throw new Error("not a number: " + lt);
      }
      function vt(lt) {
        if (typeof lt != "function")
          throw new Error("not a function: " + lt);
      }
      function _t(lt) {
        if (typeof lt != "string")
          throw new Error("not a string: " + lt);
      }
      var xt = 2, At = 3, yt = 8, ht = 5 * yt, bt = 4 * yt, Ct = "  ";
      function Mt(lt, gt) {
        return new Array(gt + 1).join(lt);
      }
      function wt(lt, gt, Tt) {
        var Pt = gt - lt.length;
        return Pt <= 0 ? lt : Mt(Tt, Pt) + lt;
      }
      function Lt(lt, gt, Tt, Pt) {
        return { from: lt - gt > 0 ? lt - gt : 0, to: lt + Tt > Pt ? Pt : lt + Tt };
      }
      function ft(lt, gt) {
        var Tt, Pt, Ft, kt, Ut, qt = gt.index, _e = qt.offset, Ge = 1;
        if (_e === lt.length)
          return "Got the end of the input";
        if (tt(lt)) {
          var Le = _e - _e % yt, Vr = _e - Le, ir = Lt(Le, ht, bt + yt, lt.length), Xr = $(function(Pe) {
            return $(function(Vn) {
              return wt(Vn.toString(16), 2, "0");
            }, Pe);
          }, function(Pe, Vn) {
            var Xn = Pe.length, Yi = [], Wn = 0;
            if (Xn <= Vn)
              return [Pe.slice()];
            for (var Yn = 0; Yn < Xn; Yn++)
              Yi[Wn] || Yi.push([]), Yi[Wn].push(Pe[Yn]), (Yn + 1) % Vn == 0 && Wn++;
            return Yi;
          }(lt.slice(ir.from, ir.to).toJSON().data, yt));
          kt = function(Pe) {
            return Pe.from === 0 && Pe.to === 1 ? { from: Pe.from, to: Pe.to } : { from: Pe.from / yt, to: Math.floor(Pe.to / yt) };
          }(ir), Pt = Le / yt, Tt = 3 * Vr, Vr >= 4 && (Tt += 1), Ge = 2, Ft = $(function(Pe) {
            return Pe.length <= 4 ? Pe.join(" ") : Pe.slice(0, 4).join(" ") + "  " + Pe.slice(4).join(" ");
          }, Xr), (Ut = (8 * (kt.to > 0 ? kt.to - 1 : kt.to)).toString(16).length) < 2 && (Ut = 2);
        } else {
          var jn = lt.split(/\r\n|[\n\r\u2028\u2029]/);
          Tt = qt.column - 1, Pt = qt.line - 1, kt = Lt(Pt, xt, At, jn.length), Ft = jn.slice(kt.from, kt.to), Ut = kt.to.toString().length;
        }
        var $f = Pt - kt.from;
        return tt(lt) && (Ut = (8 * (kt.to > 0 ? kt.to - 1 : kt.to)).toString(16).length) < 2 && (Ut = 2), B(function(Pe, Vn, Xn) {
          var Yi, Wn = Xn === $f, Yn = Wn ? "> " : Ct;
          return Yi = tt(lt) ? wt((8 * (kt.from + Xn)).toString(16), Ut, "0") : wt((kt.from + Xn + 1).toString(), Ut, " "), [].concat(Pe, [Yn + Yi + " | " + Vn], Wn ? [Ct + Mt(" ", Ut) + " | " + wt("", Tt, " ") + Mt("^", Ge)] : []);
        }, [], Ft).join(`
`);
      }
      function Gt(lt, gt) {
        return [`
`, "-- PARSING FAILED " + Mt("-", 50), `

`, ft(lt, gt), `

`, (Tt = gt.expected, Tt.length === 1 ? `Expected:

` + Tt[0] : `Expected one of the following: 

` + Tt.join(", ")), `
`].join("");
        var Tt;
      }
      function Dt(lt) {
        return lt.flags !== void 0 ? lt.flags : [lt.global ? "g" : "", lt.ignoreCase ? "i" : "", lt.multiline ? "m" : "", lt.unicode ? "u" : "", lt.sticky ? "y" : ""].join("");
      }
      function Bt() {
        for (var lt = [].slice.call(arguments), gt = lt.length, Tt = 0; Tt < gt; Tt += 1)
          ct(lt[Tt]);
        return M(function(Pt, Ft) {
          for (var kt, Ut = new Array(gt), qt = 0; qt < gt; qt += 1) {
            if (!(kt = at(lt[qt]._(Pt, Ft), kt)).status)
              return kt;
            Ut[qt] = kt.value, Ft = kt.index;
          }
          return at(st(Ft, Ut), kt);
        });
      }
      function Ot() {
        var lt = [].slice.call(arguments);
        if (lt.length === 0)
          throw new Error("seqMap needs at least one argument");
        var gt = lt.pop();
        return vt(gt), Bt.apply(null, lt).map(function(Tt) {
          return gt.apply(null, Tt);
        });
      }
      function Et() {
        var lt = [].slice.call(arguments), gt = lt.length;
        if (gt === 0)
          return Rt("zero alternates");
        for (var Tt = 0; Tt < gt; Tt += 1)
          ct(lt[Tt]);
        return M(function(Pt, Ft) {
          for (var kt, Ut = 0; Ut < lt.length; Ut += 1)
            if ((kt = at(lt[Ut]._(Pt, Ft), kt)).status)
              return kt;
          return kt;
        });
      }
      function Ht(lt, gt) {
        return It(lt, gt).or($t([]));
      }
      function It(lt, gt) {
        return ct(lt), ct(gt), Ot(lt, gt.then(lt).many(), function(Tt, Pt) {
          return [Tt].concat(Pt);
        });
      }
      function St(lt) {
        _t(lt);
        var gt = "'" + lt + "'";
        return M(function(Tt, Pt) {
          var Ft = Pt + lt.length, kt = Tt.slice(Pt, Ft);
          return kt === lt ? st(Ft, kt) : rt(Pt, gt);
        });
      }
      function Nt(lt, gt) {
        (function(Ft) {
          if (!(Ft instanceof RegExp))
            throw new Error("not a regexp: " + Ft);
          for (var kt = Dt(Ft), Ut = 0; Ut < kt.length; Ut++) {
            var qt = kt.charAt(Ut);
            if (qt !== "i" && qt !== "m" && qt !== "u" && qt !== "s")
              throw new Error('unsupported regexp flag "' + qt + '": ' + Ft);
          }
        })(lt), arguments.length >= 2 ? mt(gt) : gt = 0;
        var Tt = function(Ft) {
          return RegExp("^(?:" + Ft.source + ")", Dt(Ft));
        }(lt), Pt = "" + lt;
        return M(function(Ft, kt) {
          var Ut = Tt.exec(Ft.slice(kt));
          if (Ut) {
            if (0 <= gt && gt <= Ut.length) {
              var qt = Ut[0], _e = Ut[gt];
              return st(kt + qt.length, _e);
            }
            return rt(kt, "valid match group (0 to " + Ut.length + ") in " + Pt);
          }
          return rt(kt, Pt);
        });
      }
      function $t(lt) {
        return M(function(gt, Tt) {
          return st(Tt, lt);
        });
      }
      function Rt(lt) {
        return M(function(gt, Tt) {
          return rt(Tt, lt);
        });
      }
      function Jt(lt) {
        if (Q(lt))
          return M(function(gt, Tt) {
            var Pt = lt._(gt, Tt);
            return Pt.index = Tt, Pt.value = "", Pt;
          });
        if (typeof lt == "string")
          return Jt(St(lt));
        if (lt instanceof RegExp)
          return Jt(Nt(lt));
        throw new Error("not a string, regexp, or parser: " + lt);
      }
      function Kt(lt) {
        return ct(lt), M(function(gt, Tt) {
          var Pt = lt._(gt, Tt), Ft = gt.slice(Tt, Pt.index);
          return Pt.status ? rt(Tt, 'not "' + Ft + '"') : st(Tt, null);
        });
      }
      function ae(lt) {
        return vt(lt), M(function(gt, Tt) {
          var Pt = pt(gt, Tt);
          return Tt < gt.length && lt(Pt) ? st(Tt + 1, Pt) : rt(Tt, "a character/byte matching " + lt);
        });
      }
      function Se(lt, gt) {
        arguments.length < 2 && (gt = lt, lt = void 0);
        var Tt = M(function(Pt, Ft) {
          return Tt._ = gt()._, Tt._(Pt, Ft);
        });
        return lt ? Tt.desc(lt) : Tt;
      }
      function De() {
        return Rt("fantasy-land/empty");
      }
      D.parse = function(lt) {
        if (typeof lt != "string" && !tt(lt))
          throw new Error(".parse must be called with a string or Buffer as its argument");
        var gt, Tt = this.skip(he)._(lt, 0);
        return gt = Tt.status ? { status: !0, value: Tt.value } : { status: !1, index: dt(lt, Tt.furthest), expected: Tt.expected }, delete ut[lt], gt;
      }, D.tryParse = function(lt) {
        var gt = this.parse(lt);
        if (gt.status)
          return gt.value;
        var Tt = Gt(lt, gt), Pt = new Error(Tt);
        throw Pt.type = "ParsimmonError", Pt.result = gt, Pt;
      }, D.assert = function(lt, gt) {
        return this.chain(function(Tt) {
          return lt(Tt) ? $t(Tt) : Rt(gt);
        });
      }, D.or = function(lt) {
        return Et(this, lt);
      }, D.trim = function(lt) {
        return this.wrap(lt, lt);
      }, D.wrap = function(lt, gt) {
        return Ot(lt, this, gt, function(Tt, Pt) {
          return Pt;
        });
      }, D.thru = function(lt) {
        return lt(this);
      }, D.then = function(lt) {
        return ct(lt), Bt(this, lt).map(function(gt) {
          return gt[1];
        });
      }, D.many = function() {
        var lt = this;
        return M(function(gt, Tt) {
          for (var Pt = [], Ft = void 0; ; ) {
            if (!(Ft = at(lt._(gt, Tt), Ft)).status)
              return at(st(Tt, Pt), Ft);
            if (Tt === Ft.index)
              throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
            Tt = Ft.index, Pt.push(Ft.value);
          }
        });
      }, D.tieWith = function(lt) {
        return _t(lt), this.map(function(gt) {
          if (function(Ft) {
            if (!et(Ft))
              throw new Error("not an array: " + Ft);
          }(gt), gt.length) {
            _t(gt[0]);
            for (var Tt = gt[0], Pt = 1; Pt < gt.length; Pt++)
              _t(gt[Pt]), Tt += lt + gt[Pt];
            return Tt;
          }
          return "";
        });
      }, D.tie = function() {
        return this.tieWith("");
      }, D.times = function(lt, gt) {
        var Tt = this;
        return arguments.length < 2 && (gt = lt), mt(lt), mt(gt), M(function(Pt, Ft) {
          for (var kt = [], Ut = void 0, qt = void 0, _e = 0; _e < lt; _e += 1) {
            if (qt = at(Ut = Tt._(Pt, Ft), qt), !Ut.status)
              return qt;
            Ft = Ut.index, kt.push(Ut.value);
          }
          for (; _e < gt && (qt = at(Ut = Tt._(Pt, Ft), qt), Ut.status); _e += 1)
            Ft = Ut.index, kt.push(Ut.value);
          return at(st(Ft, kt), qt);
        });
      }, D.result = function(lt) {
        return this.map(function() {
          return lt;
        });
      }, D.atMost = function(lt) {
        return this.times(0, lt);
      }, D.atLeast = function(lt) {
        return Ot(this.times(lt), this.many(), function(gt, Tt) {
          return gt.concat(Tt);
        });
      }, D.map = function(lt) {
        vt(lt);
        var gt = this;
        return M(function(Tt, Pt) {
          var Ft = gt._(Tt, Pt);
          return Ft.status ? at(st(Ft.index, lt(Ft.value)), Ft) : Ft;
        });
      }, D.contramap = function(lt) {
        vt(lt);
        var gt = this;
        return M(function(Tt, Pt) {
          var Ft = gt.parse(lt(Tt.slice(Pt)));
          return Ft.status ? st(Pt + Tt.length, Ft.value) : Ft;
        });
      }, D.promap = function(lt, gt) {
        return vt(lt), vt(gt), this.contramap(lt).map(gt);
      }, D.skip = function(lt) {
        return Bt(this, lt).map(function(gt) {
          return gt[0];
        });
      }, D.mark = function() {
        return Ot(ee, this, ee, function(lt, gt, Tt) {
          return { start: lt, value: gt, end: Tt };
        });
      }, D.node = function(lt) {
        return Ot(ee, this, ee, function(gt, Tt, Pt) {
          return { name: lt, value: Tt, start: gt, end: Pt };
        });
      }, D.sepBy = function(lt) {
        return Ht(this, lt);
      }, D.sepBy1 = function(lt) {
        return It(this, lt);
      }, D.lookahead = function(lt) {
        return this.skip(Jt(lt));
      }, D.notFollowedBy = function(lt) {
        return this.skip(Kt(lt));
      }, D.desc = function(lt) {
        et(lt) || (lt = [lt]);
        var gt = this;
        return M(function(Tt, Pt) {
          var Ft = gt._(Tt, Pt);
          return Ft.status || (Ft.expected = lt), Ft;
        });
      }, D.fallback = function(lt) {
        return this.or($t(lt));
      }, D.ap = function(lt) {
        return Ot(lt, this, function(gt, Tt) {
          return gt(Tt);
        });
      }, D.chain = function(lt) {
        var gt = this;
        return M(function(Tt, Pt) {
          var Ft = gt._(Tt, Pt);
          return Ft.status ? at(lt(Ft.value)._(Tt, Ft.index), Ft) : Ft;
        });
      }, D.concat = D.or, D.empty = De, D.of = $t, D["fantasy-land/ap"] = D.ap, D["fantasy-land/chain"] = D.chain, D["fantasy-land/concat"] = D.concat, D["fantasy-land/empty"] = D.empty, D["fantasy-land/of"] = D.of, D["fantasy-land/map"] = D.map;
      var ee = M(function(lt, gt) {
        return st(gt, dt(lt, gt));
      }), Re = M(function(lt, gt) {
        return gt >= lt.length ? rt(gt, "any character/byte") : st(gt + 1, pt(lt, gt));
      }), ve = M(function(lt, gt) {
        return st(lt.length, lt.slice(gt));
      }), he = M(function(lt, gt) {
        return gt < lt.length ? rt(gt, "EOF") : st(gt, null);
      }), oe = Nt(/[0-9]/).desc("a digit"), te = Nt(/[0-9]*/).desc("optional digits"), Oe = Nt(/[a-z]/i).desc("a letter"), pa = Nt(/[a-z]*/i).desc("optional letters"), sh = Nt(/\s*/).desc("optional whitespace"), zo = Nt(/\s+/).desc("whitespace"), va = St("\r"), jo = St(`
`), Vo = St(`\r
`), Xo = Et(Vo, jo, va).desc("newline"), ga = Et(Xo, he);
      M.all = ve, M.alt = Et, M.any = Re, M.cr = va, M.createLanguage = function(lt) {
        var gt = {};
        for (var Tt in lt)
          ({}).hasOwnProperty.call(lt, Tt) && function(Pt) {
            gt[Pt] = Se(function() {
              return lt[Pt](gt);
            });
          }(Tt);
        return gt;
      }, M.crlf = Vo, M.custom = function(lt) {
        return M(lt(st, rt));
      }, M.digit = oe, M.digits = te, M.empty = De, M.end = ga, M.eof = he, M.fail = Rt, M.formatError = Gt, M.index = ee, M.isParser = Q, M.lazy = Se, M.letter = Oe, M.letters = pa, M.lf = jo, M.lookahead = Jt, M.makeFailure = rt, M.makeSuccess = st, M.newline = Xo, M.noneOf = function(lt) {
        return ae(function(gt) {
          return lt.indexOf(gt) < 0;
        }).desc("none of '" + lt + "'");
      }, M.notFollowedBy = Kt, M.of = $t, M.oneOf = function(lt) {
        for (var gt = lt.split(""), Tt = 0; Tt < gt.length; Tt++)
          gt[Tt] = "'" + gt[Tt] + "'";
        return ae(function(Pt) {
          return lt.indexOf(Pt) >= 0;
        }).desc(gt);
      }, M.optWhitespace = sh, M.Parser = M, M.range = function(lt, gt) {
        return ae(function(Tt) {
          return lt <= Tt && Tt <= gt;
        }).desc(lt + "-" + gt);
      }, M.regex = Nt, M.regexp = Nt, M.sepBy = Ht, M.sepBy1 = It, M.seq = Bt, M.seqMap = Ot, M.seqObj = function() {
        for (var lt, gt = {}, Tt = 0, Pt = (lt = arguments, Array.prototype.slice.call(lt)), Ft = Pt.length, kt = 0; kt < Ft; kt += 1) {
          var Ut = Pt[kt];
          if (!Q(Ut)) {
            if (et(Ut) && Ut.length === 2 && typeof Ut[0] == "string" && Q(Ut[1])) {
              var qt = Ut[0];
              if (Object.prototype.hasOwnProperty.call(gt, qt))
                throw new Error("seqObj: duplicate key " + qt);
              gt[qt] = !0, Tt++;
              continue;
            }
            throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
          }
        }
        if (Tt === 0)
          throw new Error("seqObj expects at least one named parser, found zero");
        return M(function(_e, Ge) {
          for (var Le, Vr = {}, ir = 0; ir < Ft; ir += 1) {
            var Xr, jn;
            if (et(Pt[ir]) ? (Xr = Pt[ir][0], jn = Pt[ir][1]) : (Xr = null, jn = Pt[ir]), !(Le = at(jn._(_e, Ge), Le)).status)
              return Le;
            Xr && (Vr[Xr] = Le.value), Ge = Le.index;
          }
          return at(st(Ge, Vr), Le);
        });
      }, M.string = St, M.succeed = $t, M.takeWhile = function(lt) {
        return vt(lt), M(function(gt, Tt) {
          for (var Pt = Tt; Pt < gt.length && lt(pt(gt, Pt)); )
            Pt++;
          return st(Pt, gt.slice(Tt, Pt));
        });
      }, M.test = ae, M.whitespace = zo, M["fantasy-land/empty"] = De, M["fantasy-land/of"] = $t, M.Binary = { bitSeq: X, bitSeqObj: function(lt) {
        z();
        var gt = {}, Tt = 0, Pt = $(function(kt) {
          if (et(kt)) {
            var Ut = kt;
            if (Ut.length !== 2)
              throw new Error("[" + Ut.join(", ") + "] should be length 2, got length " + Ut.length);
            if (_t(Ut[0]), mt(Ut[1]), Object.prototype.hasOwnProperty.call(gt, Ut[0]))
              throw new Error("duplicate key in bitSeqObj: " + Ut[0]);
            return gt[Ut[0]] = !0, Tt++, Ut;
          }
          return mt(kt), [null, kt];
        }, lt);
        if (Tt < 1)
          throw new Error("bitSeqObj expects at least one named pair, got [" + lt.join(", ") + "]");
        var Ft = $(function(kt) {
          return kt[0];
        }, Pt);
        return X($(function(kt) {
          return kt[1];
        }, Pt)).map(function(kt) {
          return B(function(Ut, qt) {
            return qt[0] !== null && (Ut[qt[0]] = qt[1]), Ut;
          }, {}, $(function(Ut, qt) {
            return [Ut, kt[qt]];
          }, Ft));
        });
      }, byte: function(lt) {
        if (z(), mt(lt), lt > 255)
          throw new Error("Value specified to byte constructor (" + lt + "=0x" + lt.toString(16) + ") is larger in value than a single byte.");
        var gt = (lt > 15 ? "0x" : "0x0") + lt.toString(16);
        return M(function(Tt, Pt) {
          var Ft = pt(Tt, Pt);
          return Ft === lt ? st(Pt + 1, Ft) : rt(Pt, gt);
        });
      }, buffer: function(lt) {
        return Y("buffer", lt).map(function(gt) {
          return Buffer.from(gt);
        });
      }, encodedString: function(lt, gt) {
        return Y("string", gt).map(function(Tt) {
          return Tt.toString(lt);
        });
      }, uintBE: q, uint8BE: q(1), uint16BE: q(2), uint32BE: q(4), uintLE: Z, uint8LE: Z(1), uint16LE: Z(2), uint32LE: Z(4), intBE: K, int8BE: K(1), int16BE: K(2), int32BE: K(4), intLE: J, int8LE: J(1), int16LE: J(2), int32LE: J(4), floatBE: Y("floatBE", 4).map(function(lt) {
        return lt.readFloatBE(0);
      }), floatLE: Y("floatLE", 4).map(function(lt) {
        return lt.readFloatLE(0);
      }), doubleBE: Y("doubleBE", 8).map(function(lt) {
        return lt.readDoubleBE(0);
      }), doubleLE: Y("doubleLE", 8).map(function(lt) {
        return lt.readDoubleLE(0);
      }) }, e.exports = M;
    }]);
  });
})(parsimmon_umd_min);
var Ei, Vt, Xt, Wr, xi, qn, Oa, Na, oh, cu, fu, qh;
const zh = class {
  constructor(t, e = "\\") {
    nt(this, Vt);
    nt(this, xi);
    nt(this, Na);
    nt(this, Ei, void 0);
    nt(this, Wr, void 0);
    nt(this, Oa, void 0);
    this.val = t, it(this, Ei, null), it(this, Wr, {
      "!num!": (q) => q.shift(),
      "!str!": (q) => ot(this, Na, oh).call(this, q.shift()),
      "!bool!": (q) => q.shift(),
      "!": (q) => {
        const Z = q.shift();
        return Z[0] === "!bool!" ? !Boolean(Z[1]) : String(ot(this, Vt, Xt).call(this, Z)) !== "true";
      },
      "~": (q) => ~Number(ot(this, Vt, Xt).call(this, q.shift())),
      "**": (q) => Number(ot(this, Vt, Xt).call(this, q.shift())) ** Number(ot(this, Vt, Xt).call(this, q.shift())),
      "*": (q) => Number(ot(this, Vt, Xt).call(this, q.shift())) * Number(ot(this, Vt, Xt).call(this, q.shift())),
      "/": (q) => Number(ot(this, Vt, Xt).call(this, q.shift())) / Number(ot(this, Vt, Xt).call(this, q.shift())),
      "\xA5": (q) => Math.floor(V(this, Wr)["/"](q)),
      "%": (q) => Number(ot(this, Vt, Xt).call(this, q.shift())) % Number(ot(this, Vt, Xt).call(this, q.shift())),
      "+": (q) => {
        const Z = ot(this, Vt, Xt).call(this, q.shift()), K = ot(this, Vt, Xt).call(this, q.shift());
        return Object.prototype.toString.call(Z) === "[object String]" || Object.prototype.toString.call(K) === "[object String]" ? String(Z) + String(K) : Number(Z) + Number(K);
      },
      "-": (q) => Number(ot(this, Vt, Xt).call(this, q.shift())) - Number(ot(this, Vt, Xt).call(this, q.shift())),
      int: (q) => int(ot(this, xi, qn).call(this, q.shift())),
      parseInt: (q) => int(V(this, Wr).Number(q)),
      Number: (q) => {
        const Z = ot(this, Vt, Xt).call(this, q.shift());
        return Object.prototype.toString.call(Z) !== "[object String]" ? Number(Z) : ot(this, xi, qn).call(this, V(this, Ei).parse(String(Z)).value);
      },
      ceil: (q) => Math.ceil(ot(this, xi, qn).call(this, q.shift())),
      floor: (q) => Math.floor(ot(this, xi, qn).call(this, q.shift())),
      round: (q) => Math.round(ot(this, xi, qn).call(this, q.shift())),
      isNaN: (q) => isNaN(Number(ot(this, Vt, Xt).call(this, q.shift()))),
      "<<": (q) => Number(ot(this, Vt, Xt).call(this, q.shift())) << Number(ot(this, Vt, Xt).call(this, q.shift())),
      ">>": (q) => Number(ot(this, Vt, Xt).call(this, q.shift())) >> Number(ot(this, Vt, Xt).call(this, q.shift())),
      ">>>": (q) => Number(ot(this, Vt, Xt).call(this, q.shift())) >>> Number(ot(this, Vt, Xt).call(this, q.shift())),
      "<": (q) => Number(ot(this, Vt, Xt).call(this, q.shift())) < Number(ot(this, Vt, Xt).call(this, q.shift())),
      "<=": (q) => Number(ot(this, Vt, Xt).call(this, q.shift())) <= Number(ot(this, Vt, Xt).call(this, q.shift())),
      ">": (q) => Number(ot(this, Vt, Xt).call(this, q.shift())) > Number(ot(this, Vt, Xt).call(this, q.shift())),
      ">=": (q) => Number(ot(this, Vt, Xt).call(this, q.shift())) >= Number(ot(this, Vt, Xt).call(this, q.shift())),
      "==": (q) => {
        const Z = ot(this, Vt, Xt).call(this, q.shift()), K = ot(this, Vt, Xt).call(this, q.shift());
        return Z == null && K == null && (!Z || !K) ? Z == K : String(Z) === String(K);
      },
      "!=": (q) => !V(this, Wr)["=="](q),
      "===": (q) => {
        const Z = ot(this, Vt, Xt).call(this, q.shift()), K = ot(this, Vt, Xt).call(this, q.shift());
        return Object.prototype.toString.call(Z) != Object.prototype.toString.call(K) ? !1 : String(Z) === String(K);
      },
      "!==": (q) => !V(this, Wr)["==="](q),
      "&": (q) => Number(ot(this, Vt, Xt).call(this, q.shift())) & Number(ot(this, Vt, Xt).call(this, q.shift())),
      "^": (q) => Number(ot(this, Vt, Xt).call(this, q.shift())) ^ Number(ot(this, Vt, Xt).call(this, q.shift())),
      "|": (q) => Number(ot(this, Vt, Xt).call(this, q.shift())) | Number(ot(this, Vt, Xt).call(this, q.shift())),
      "&&": (q) => String(ot(this, Vt, Xt).call(this, q.shift())) === "true" && String(ot(this, Vt, Xt).call(this, q.shift())) === "true",
      "||": (q) => String(ot(this, Vt, Xt).call(this, q.shift())) === "true" || String(ot(this, Vt, Xt).call(this, q.shift())) === "true",
      "?": (q) => {
        const Z = q.shift();
        let K = !1;
        if (Z[0] === "!bool!")
          K = Boolean(Z[1]);
        else {
          const Q = String(ot(this, Vt, Xt).call(this, Z));
          K = Q !== "true" && Q !== "false" ? int(Q) !== 0 : Q === "true";
        }
        const J = q.shift();
        if (J[0] !== ":")
          throw Error("(PropParser)\u4E09\u9805\u6F14\u7B97\u5B50\u306E\u6587\u6CD5\u30A8\u30E9\u30FC\u3067\u3059\u3002: \u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093");
        return ot(this, Vt, Xt).call(this, J[K ? 1 : 2]);
      },
      ":": () => {
        throw Error("(PropParser)\u4E09\u9805\u6F14\u7B97\u5B50\u306E\u6587\u6CD5\u30A8\u30E9\u30FC\u3067\u3059\u3002? \u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093");
      }
    }), it(this, Oa, /(\$((tmp|sys|save|mp):)?[^\s!--\/:-@[-^`{-~]+|\#\{[^\}]+})/g), this.getValAmpersand = (q) => q.charAt(0) === "&" ? String(this.parse(q.slice(1))) : q;
    function R(q) {
      const Z = [];
      return q.forEach((K) => Z.push(
        (K instanceof RegExp ? parsimmon_umd_min.exports.regex(K) : parsimmon_umd_min.exports.string(K)).trim(parsimmon_umd_min.exports.optWhitespace)
      )), parsimmon_umd_min.exports.alt.apply(null, Z);
    }
    function N(q, Z) {
      const K = parsimmon_umd_min.exports.lazy(() => parsimmon_umd_min.exports.seq(q, K).or(Z));
      return K;
    }
    function M(q, Z) {
      let K = parsimmon_umd_min.exports.lazy(
        () => Z.chain(
          (J) => parsimmon_umd_min.exports.seq(
            q,
            parsimmon_umd_min.exports.of(J),
            K
          ).or(parsimmon_umd_min.exports.of(J))
        )
      );
      return K;
    }
    function D(q, Z) {
      return parsimmon_umd_min.exports.seqMap(
        Z,
        parsimmon_umd_min.exports.seq(q, Z).many(),
        (K, J) => J.reduce((Q, et) => [et[0], Q, et[1]], K)
      );
    }
    const L = parsimmon_umd_min.exports.alt(
      parsimmon_umd_min.exports.alt(
        parsimmon_umd_min.exports.regex(/-?(0|[1-9][0-9]*)\.[0-9]+/),
        parsimmon_umd_min.exports.regex(/0x[0-9a-fA-F]+/)
      ).map(Number),
      parsimmon_umd_min.exports.alt(
        parsimmon_umd_min.exports.regex(/-?(0|[1-9][0-9]*)/)
      ).map((q) => int(q))
    ).map((q) => ["!num!", q]).desc("number"), B = parsimmon_umd_min.exports.string("null").map(() => ["!str!", null]), $ = parsimmon_umd_min.exports.regex(/(true|false)/).map((q) => ["!bool!", q === "true"]).desc("boolean"), U = parsimmon_umd_min.exports.regex(new RegExp(`(?:"(?:\\${e}["'#\\n]|[^"])*"|'(?:\\${e}["'#\\n]|[^'])*'|\\#(?:\\${e}["'#\\n]|[^#])*\\#)`)).map((q) => ["!str!", q.slice(1, -1).replaceAll(e, "")]).desc("string"), H = /\[[^\]]+\]/g, z = parsimmon_umd_min.exports.regex(/-?(?:(?:tmp|sys|save|mp):)?[^\s!-\/:-@[-^`{-~]+(?:\.[^\s!-\/:-@[-^`{-~]+|\[[^\]]+\])*(?:@str)?/).map((q) => {
      const Z = String(q).replace(
        H,
        (J) => "." + this.parse(J.slice(1, -1))
      );
      if (Z.charAt(0) === "-") {
        const J = this.val.getVal(Z.slice(1));
        if (J == null || String(J) === "null")
          throw Error("(PropParser)\u6570\u5024\u4EE5\u5916\u306B-\u7B26\u53F7\u304C\u3064\u3044\u3066\u3044\u307E\u3059");
        return ["!num!", -Number(J)];
      }
      const K = this.val.getVal(Z);
      return K == null ? ["!str!", K] : typeof K == "boolean" ? ["!bool!", K] : Object.prototype.toString.call(K) === "[object String]" ? ["!str!", String(K)] : ["!num!", Number(K)];
    }).desc("string"), X = parsimmon_umd_min.exports.lazy(
      () => parsimmon_umd_min.exports.string("(").then(V(this, Ei)).skip(parsimmon_umd_min.exports.string(")")).or(L).or(B).or($).or(U).or(z)
    ), W = [
      { type: N, ops: R([/[A-Za-z_][A-Za-z0-9_]*(?=\()/]) },
      { type: N, ops: R([/(!(?!=)|~)/]) },
      { type: M, ops: R(["**"]) },
      { type: D, ops: R(["*", "/", "\xA5", "%"]) },
      { type: D, ops: R(["+", "-"]) },
      { type: D, ops: R([/(>>>|<<|>>)/]) },
      { type: D, ops: R([/(<=|<|>=|>)/]) },
      { type: D, ops: R([/(===|!==|==|!=)/]) },
      { type: D, ops: R([/&(?!&)/]) },
      { type: D, ops: R(["^"]) },
      { type: D, ops: R([/\|(?!\|)/]) },
      { type: D, ops: R(["&&"]) },
      { type: D, ops: R(["||"]) },
      { type: M, ops: R([":"]) },
      { type: M, ops: R(["?"]) }
    ].reduce(
      (q, Z) => Z.type(Z.ops, q),
      X
    );
    it(this, Ei, W.trim(parsimmon_umd_min.exports.optWhitespace));
  }
  parse(t) {
    const e = V(this, Ei).parse(t);
    if (!e.status)
      throw Error("(PropParser)\u6587\u6CD5\u30A8\u30E9\u30FC\u3010" + t + "\u3011");
    const R = e.value;
    return R[0] === "!str!" ? ot(this, Na, oh).call(this, R[1]) : ot(this, Vt, Xt).call(this, R);
  }
  static getValName(t) {
    var N, M;
    const e = V(this, cu).exec(t.trim()), R = e == null ? void 0 : e.groups;
    if (!!R)
      return {
        scope: R.scope || "tmp",
        name: ot(N = zh, fu, qh).call(N, R.name),
        at: (M = R.at) != null ? M : ""
      };
  }
};
let PropParser = zh;
Ei = new WeakMap(), Vt = new WeakSet(), Xt = function(t) {
  const e = t.shift();
  if (e instanceof Array)
    return ot(this, Vt, Xt).call(this, e);
  const R = V(this, Wr)[e];
  return R ? R(t) : Object(null);
}, Wr = new WeakMap(), xi = new WeakSet(), qn = function(t) {
  const e = ot(this, Vt, Xt).call(this, t);
  if (Object.prototype.toString.call(e) !== "[object Number]")
    throw Error("(PropParser)\u5F15\u6570\u3010" + e + "\u3011\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093");
  return Number(e);
}, Oa = new WeakMap(), Na = new WeakSet(), oh = function(t) {
  return t == null ? t : String(t).replace(V(this, Oa), (e) => e.charAt(0) === "$" ? this.val.getVal(e.slice(1)) : this.parse(e.slice(2, -1)));
}, cu = new WeakMap(), fu = new WeakSet(), qh = function(t) {
  let e = 0, R = 0;
  for (; ; ) {
    if (e = t.indexOf('["'), e < 0) {
      if (e = t.indexOf("['"), e < 0)
        break;
      R = t.indexOf("']", e + 2);
    } else
      R = t.indexOf('"]', e + 2);
    if (R < 0)
      break;
    t = t.slice(0, e) + "." + t.slice(e + 2, R) + t.slice(R + 2), e = R - 2;
  }
  return t;
}, nt(PropParser, fu), nt(PropParser, cu, /^((?<scope>\w+?):)?(?<name>[^\s :@]+)(?<at>\@str)?$/);
var __accessCheck$3 = (o, t, e) => {
  if (!t.has(o))
    throw TypeError("Cannot " + e);
}, __privateGet$3 = (o, t, e) => (__accessCheck$3(o, t, "read from private field"), e ? e.call(o) : t.get(o)), __privateAdd$3 = (o, t, e) => {
  if (t.has(o))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(o) : t.set(o, e);
}, __privateSet$3 = (o, t, e, R) => (__accessCheck$3(o, t, "write to private field"), R ? R.call(o, e) : t.set(o, e), e), __privateMethod$3 = (o, t, e) => (__accessCheck$3(o, t, "access private method"), e), _scrItr$1, _hTag, _title, _spnDbg, _first, _log, log_fn, _trace, trace_fn, _st_trace, st_trace_fn, _dspDbg, dspDbg_fn;
const _DebugMng = class {
  constructor(o, t, e) {
    this.sys = o, __privateAdd$3(this, _log), __privateAdd$3(this, _trace), __privateAdd$3(this, _first, !0), __privateSet$3(_DebugMng, _scrItr$1, e), __privateSet$3(_DebugMng, _hTag, t), __privateSet$3(_DebugMng, _title, t.title), _DebugMng.myTrace = __privateMethod$3(_DebugMng, _st_trace, st_trace_fn), t.log = (R) => __privateMethod$3(this, _log, log_fn).call(this, R), t.trace = (R) => __privateMethod$3(this, _trace, trace_fn).call(this, R), __privateSet$3(_DebugMng, _spnDbg, document.createElement("span")), __privateGet$3(_DebugMng, _spnDbg).hidden = !0, __privateGet$3(_DebugMng, _spnDbg).textContent = "", __privateGet$3(_DebugMng, _spnDbg).style.cssText = `	z-index: ${Number.MAX_SAFE_INTEGER};
			position: absolute; left: 0; top: 0;
			color: black;
			background-color: rgba(255, 255, 255, 0.7);`, document.body.appendChild(__privateGet$3(_DebugMng, _spnDbg));
  }
  destroy() {
    __privateSet$3(_DebugMng, _title, () => !1), document.body.removeChild(__privateGet$3(_DebugMng, _spnDbg)), _DebugMng.myTrace = _DebugMng.trace_beforeNew;
  }
  static trace_beforeNew(o, t = "E") {
    let e = `{${t}} ` + o, R = "";
    switch (t) {
      case "D":
        R = `color:#${CmnLib.isDarkMode ? "49F" : "05A"};`;
        break;
      case "W":
        R = "color:#FF8800;";
        break;
      case "F":
        R = "color:#BB0000;";
        break;
      case "ET":
        throw e;
      case "E":
        console.error("%c" + e, "color:#FF3300;");
        return;
      default:
        R = "color:black;", e = " " + e;
    }
    console.info("%c" + e, R);
  }
};
let DebugMng = _DebugMng;
_scrItr$1 = /* @__PURE__ */ new WeakMap();
_hTag = /* @__PURE__ */ new WeakMap();
_title = /* @__PURE__ */ new WeakMap();
_spnDbg = /* @__PURE__ */ new WeakMap();
_first = /* @__PURE__ */ new WeakMap();
_log = /* @__PURE__ */ new WeakSet();
log_fn = function(o) {
  let t = "";
  return __privateGet$3(this, _first) && (__privateSet$3(this, _first, !1), t = `== ${platform.description} ==
`), this.sys.appendFile(
    this.sys.path_downloads + "log.txt",
    `${t}--- ${getDateStr("-", "_", "")} [fn:${__privateGet$3(_DebugMng, _scrItr$1).scriptFn} line:${__privateGet$3(_DebugMng, _scrItr$1).lineNum}] prj:${this.sys.cur}
${o.text || `(text is ${o.text})`}
`,
    (e) => {
      e && console.log(e);
    }
  ), !1;
};
_trace = /* @__PURE__ */ new WeakSet();
trace_fn = function(o) {
  return _DebugMng.myTrace(o.text || `(text is ${o.text})`, "I"), !1;
};
_st_trace = /* @__PURE__ */ new WeakSet();
st_trace_fn = function(o, t = "E") {
  var e, R;
  let N = `{${t}} ` + _DebugMng.strPos() + o;
  __privateMethod$3(e = _DebugMng, _dspDbg, dspDbg_fn).call(e, N, t);
  let M = "";
  switch (t) {
    case "D":
      M = `color:#${CmnLib.isDarkMode ? "49F" : "05A"};`;
      break;
    case "W":
      M = "color:#F80;";
      break;
    case "F":
      M = "color:#B00;";
      break;
    case "ET":
    case "E":
      if (__privateGet$3(R = _DebugMng, _title).call(R, { text: o }), __privateGet$3(this, _hTag).dump_lay({}), __privateGet$3(this, _hTag).dump_val({}), __privateGet$3(_DebugMng, _scrItr$1).dumpErrForeLine(), __privateGet$3(this, _hTag).dump_stack({}), t === "ET")
        throw N;
      console.error("%c" + N, "color:#F30;");
      return;
    default:
      M = "", N = " " + N;
  }
  console.info("%c" + N, M);
};
_dspDbg = /* @__PURE__ */ new WeakSet();
dspDbg_fn = function(o, t) {
  let e = "";
  switch (t) {
    case "D":
      e = "color:#05A;";
      break;
    case "W":
      e = "color:#F80;";
      break;
    case "F":
      e = "color:#B00;";
      break;
    case "ET":
    case "E":
      e = "color:#F30;";
      break;
    default:
      e = "";
  }
  __privateGet$3(_DebugMng, _spnDbg).innerHTML += `<span style='${e}'>${o}</span><br/>`, __privateGet$3(_DebugMng, _spnDbg).hidden = !1;
};
__privateAdd$3(DebugMng, _st_trace);
__privateAdd$3(DebugMng, _dspDbg);
__privateAdd$3(DebugMng, _scrItr$1, void 0);
__privateAdd$3(DebugMng, _hTag, void 0);
__privateAdd$3(DebugMng, _title, void 0);
__privateAdd$3(DebugMng, _spnDbg, void 0);
DebugMng.myTrace = _DebugMng.trace_beforeNew;
DebugMng.strPos = () => __privateGet$3(_DebugMng, _scrItr$1) && __privateGet$3(_DebugMng, _scrItr$1).lineNum > 0 ? `(fn:${__privateGet$3(_DebugMng, _scrItr$1).scriptFn} line:${__privateGet$3(_DebugMng, _scrItr$1).lineNum}) ` : "";
class Areas {
  constructor() {
    this.hAreas = {};
  }
  clear() {
    this.hAreas = {};
  }
  search(t) {
    for (const e in this.hAreas)
      if (!(t < parseInt(e)) && t <= this.hAreas[e])
        return !0;
    return !1;
  }
  record(t) {
    if (!this.search(t)) {
      for (const e in this.hAreas)
        if (this.hAreas[e] + 1 === t) {
          t + 1 in this.hAreas ? (this.hAreas[e] = this.hAreas[t + 1], delete this.hAreas[t + 1]) : this.hAreas[e] = t;
          return;
        }
      if (t + 1 in this.hAreas) {
        this.hAreas[t] = this.hAreas[t + 1], delete this.hAreas[t + 1];
        return;
      }
      this.hAreas[t] = t;
    }
  }
  erase(t) {
    if (!!this.search(t)) {
      if (t in this.hAreas) {
        this.hAreas[t] > t && (this.hAreas[t + 1] = this.hAreas[t]), delete this.hAreas[t];
        return;
      }
      for (const e in this.hAreas)
        if (!(t < parseInt(e)) && !(this.hAreas[e] < t)) {
          if (this.hAreas[e] === t) {
            this.hAreas[e] = t - 1;
            return;
          }
          this.hAreas[t + 1] = this.hAreas[e], this.hAreas[e] = t - 1;
          return;
        }
    }
  }
  get count() {
    return Object.keys(this.hAreas).length;
  }
  toString() {
    let t = "";
    const e = [];
    for (const R in this.hAreas)
      e.push(parseInt(R));
    return e.sort(function(R, N) {
      return R - N;
    }), e.forEach((R) => {
      t += "," + R + (R === this.hAreas[R]) ? "" : "~" + this.hAreas[R];
    }), t !== "" && (t = t.slice(1)), t;
  }
}
var Ce, Ye, ge, Yr, ye, qe, dr, Ma, Da, La, uh, ns, ss, du, Zh, pu, Kh, pr, Nr, vu, Jh, gu, Qh, _u, tc, mu, ec, yu, rc, bu, ic, Eu, nc, xu, sc, as, Wo, Fa, lh, os, rn, Ba, hh, $a, ka, nn, us, ls, Yo, Tu, ac, Su, oc, Ga, ch, Ua, fh, Cu, uc, Iu, lc, hs, qo;
const Qn = class {
  constructor(t, e) {
    nt(this, La);
    nt(this, du);
    nt(this, pu);
    nt(this, pr);
    nt(this, vu);
    nt(this, gu);
    nt(this, _u);
    nt(this, mu);
    nt(this, yu);
    nt(this, bu);
    nt(this, Eu);
    nt(this, xu);
    nt(this, as);
    nt(this, Fa);
    nt(this, Ba);
    nt(this, ls);
    nt(this, Tu);
    nt(this, Su);
    nt(this, Ga);
    nt(this, Ua);
    nt(this, Cu);
    nt(this, Iu);
    nt(this, hs);
    nt(this, Ce, void 0);
    nt(this, Ye, void 0);
    nt(this, ge, void 0);
    nt(this, Yr, void 0);
    nt(this, ye, void 0);
    nt(this, qe, void 0);
    nt(this, dr, void 0);
    nt(this, Ma, void 0);
    nt(this, Da, void 0);
    nt(this, ns, void 0);
    nt(this, ss, void 0);
    nt(this, os, void 0);
    nt(this, $a, void 0);
    nt(this, ka, void 0);
    nt(this, nn, void 0);
    nt(this, us, void 0);
    var M;
    if (this.cfg = t, it(this, Ce, { sys: {}, save: {}, tmp: {}, mp: {} }), it(this, Ye, V(this, Ce).save), it(this, ge, V(this, Ce).tmp), it(this, ye, { sys: {}, mark: {}, kidoku: {} }), it(this, dr, {}), it(this, Da, {
      auth: (D, L) => ot(this, La, uh).call(this, L.hBreakpoint.aData),
      var: (D, L) => {
        var B;
        return V(this, Yr).send2Dbg(L.ri, { v: (B = V(this, Ce)[L.scope]) != null ? B : {} });
      },
      set_var: (D, L) => {
        try {
          V(this, os).call(this, L.nm, L.val), V(this, Yr).send2Dbg(L.ri, {});
        } catch {
        }
      },
      set_data_break: (D, L) => {
        ot(this, La, uh).call(this, L.a), V(this, Yr).send2Dbg(L.ri, {});
      },
      disconnect: (D) => it(Qn, rn, {})
    }), it(this, ns, () => {
    }), it(this, ss, (D) => {
    }), this.getMark = (D) => V(this, ye).mark[D], this.getAreaKidoku = (D) => V(this, dr)[D], it(this, os, (D, L, B = !0) => {
      if (!D)
        throw "[\u5909\u6570\u306B\u5024\u30BB\u30C3\u30C8] name\u306F\u5FC5\u9808\u3067\u3059";
      if (L == null)
        throw "[\u5909\u6570\u306B\u5024\u30BB\u30C3\u30C8] text\u306F\u5FC5\u9808\u3067\u3059\uFF08\u7A7A\u6587\u5B57\u306FOK\uFF09";
      const $ = PropParser.getValName(D);
      if ($ === void 0)
        throw "[\u5909\u6570\u53C2\u7167] name(" + D + ")\u304C\u5909\u6570\u540D\u3068\u3057\u3066\u7570\u5E38\u3067\u3059";
      const U = V(this, Ce)[$.scope];
      if (!U)
        throw "[\u5909\u6570\u306B\u5024\u30BB\u30C3\u30C8] scope\u304C\u7570\u5E38\u3010" + $.scope + "\u3011\u3067\u3059";
      const H = $.name;
      if (H.slice(0, 6) === "const." && H in U)
        throw "[\u5909\u6570\u306B\u5024\u30BB\u30C3\u30C8] \u5909\u6570\u3010" + H + "\u3011\u306F\u66F8\u304D\u63DB\u3048\u4E0D\u53EF\u3067\u3059";
      this.setVal_Nochk($.scope, H, L, B);
    }), this.getVal = (D, L) => {
      if (!D)
        throw "[\u5909\u6570\u53C2\u7167] name\u306F\u5FC5\u9808\u3067\u3059";
      const B = PropParser.getValName(D);
      if (B === void 0)
        throw "[\u5909\u6570\u53C2\u7167] name(" + D + ")\u304C\u5909\u6570\u540D\u3068\u3057\u3066\u7570\u5E38\u3067\u3059";
      const $ = V(this, Ce)[B.scope];
      if (!$)
        throw "[\u5909\u6570\u53C2\u7167] scope\u304C\u7570\u5E38\u3010" + B.scope + "\u3011\u3067\u3059";
      const U = B.name;
      let H = $[U];
      if (!(U in $)) {
        H = L;
        let z = "";
        const X = U.split("."), Y = X.length;
        for (let W = 0; W < Y; ++W, z += ".") {
          if (z += X[W], !(z in $))
            continue;
          let q = JSON.parse($[z]);
          if (Object.prototype.toString.call(q) !== "[object Object]") {
            if (W + 1 === Y) {
              H = q;
              break;
            }
            continue;
          }
          let Z = W;
          for (; ++Z < Y; ) {
            if (!(X[Z] in q)) {
              H = L;
              break;
            }
            if (q = q[X[Z]], Object.prototype.toString.call(q) !== "[object Object]" || Z + 1 === Y) {
              H = q;
              break;
            }
          }
          H instanceof Object && (H = JSON.stringify(H));
          break;
        }
      }
      return H instanceof Function && (H = H()), B.at === "@str" ? H : ot(this, Ba, hh).call(this, H);
    }, it(this, $a, /^-?[\d\.]+$/), it(this, ka, () => {
      const D = { tmp: {}, sys: {}, save: {}, mp: {} };
      for (let L in D) {
        const B = V(this, Ce)[L], $ = D[L];
        for (let U in B) {
          const H = B[U];
          Object.prototype.toString.call(H) === "[object Function]" ? $[U] = H() : $[U] = H;
        }
      }
      return console.info("\u{1F95F} [dump_val]", D), !1;
    }), it(this, nn, !1), it(this, us, {
      "sys:sn.tagCh.doWait": (D) => ot(this, ls, Yo).call(this, D),
      "sys:sn.tagCh.doWait_Kidoku": (D) => ot(this, ls, Yo).call(this, D),
      "sys:sn.tagCh.msecWait": (D) => ot(this, Tu, ac).call(this, D),
      "sys:sn.tagCh.msecWait_Kidoku": (D) => ot(this, Su, oc).call(this, D),
      "sys:sn.tagCh.canskip": (D) => ot(this, ls, Yo).call(this, D),
      "sys:sn.auto.msecPageWait": (D) => ot(this, Ga, ch).call(this, D),
      "sys:sn.auto.msecPageWait_Kidoku": (D) => ot(this, Ga, ch).call(this, D),
      "sys:sn.auto.msecLineWait": (D) => ot(this, Ua, fh).call(this, D),
      "sys:sn.auto.msecLineWait_Kidoku": (D) => ot(this, Ua, fh).call(this, D),
      "save:sn.doRecLog": (D) => {
        V(this, ss).call(this, it(this, nn, ot(this, Cu, uc).call(this, D)));
      },
      "save:sn.userFnTail": (D, L) => this.cfg.userFnTail = L,
      "tmp:sn.tagL.enabled": (D) => ot(this, Iu, lc).call(this, D),
      "tmp:sn.skip.all": (D) => ot(this, hs, qo).call(this, D),
      "tmp:sn.skip.enabled": (D) => ot(this, hs, qo).call(this, D),
      "tmp:sn.auto.enabled": (D) => ot(this, hs, qo).call(this, D),
      "tmp:flash.desktop.NativeApplication.nativeApplication.systemIdleMode": () => {
      }
    }), e.let = (D) => ot(this, pr, Nr).call(this, D), e.let_abs = (D) => ot(this, vu, Jh).call(this, D), e.let_char_at = (D) => ot(this, gu, Qh).call(this, D), e.let_index_of = (D) => ot(this, _u, tc).call(this, D), e.let_length = (D) => ot(this, mu, ec).call(this, D), e.let_replace = (D) => ot(this, yu, rc).call(this, D), e.let_round = (D) => ot(this, bu, ic).call(this, D), e.let_search = (D) => ot(this, Eu, nc).call(this, D), e.let_substr = (D) => ot(this, xu, sc).call(this, D), e.clearsysvar = () => ot(this, as, Wo).call(this), e.clearvar = () => ot(this, Fa, lh).call(this), e.dump_val = () => V(this, ka).call(this), e.copybookmark = (D) => ot(this, du, Zh).call(this, D), e.erasebookmark = (D) => ot(this, pu, Kh).call(this, D), V(this, Ye)["sn.userFnTail"] = "", this.defTmp("const.sn.bookmark.json", () => {
      const D = [];
      return Object.keys(V(this, ye).mark).sort().forEach((L) => {
        const B = { ...V(this, ye).mark[L].json };
        B.place = L, D.push(B);
      }), JSON.stringify(D);
    }), V(this, ge)["const.sn.isFirstBoot"] = !0, V(this, ge)["sn.tagL.enabled"] = !0, V(this, ge)["sn.skip.all"] = !1, V(this, ge)["sn.skip.enabled"] = !1, V(this, ge)["sn.auto.enabled"] = !1, V(this, ge)["const.sn.last_page_text"] = "", V(this, ge)["const.sn.displayState"] = !1, V(this, ge)["const.Date.getTime"] = () => new Date().getTime(), V(this, ge)["const.Date.getDateStr"] = () => getDateStr(), V(this, ge)["const.sn.platform"] = JSON.stringify(platform), ot(this, as, Wo).call(this), ot(this, Fa, lh).call(this), V(this, ge)["const.sn.config.window.width"] = t.oCfg.window.width, V(this, ge)["const.sn.config.window.height"] = t.oCfg.window.height, V(this, ge)["const.sn.config.book.title"] = t.oCfg.book.title, V(this, ge)["const.sn.config.book.version"] = t.oCfg.book.version, V(this, ge)["const.sn.Math.PI"] = Math.PI, typeof window > "u")
      return;
    const R = window, N = (M = R.AudioContext) != null ? M : R.webkitAudioContext;
    V(this, ge)["const.sn.needClick2Play"] = () => new N().state === "suspended";
  }
  setSys(t) {
    it(this, Yr, t), t.initVal(V(this, ye), V(this, ge), (e) => {
      this.updateData(e), sessionStorage.clear();
      const R = this.cfg.getNs();
      it(this, ns, this.cfg.oCfg.debug.variable ? () => {
        const M = {};
        Object.keys(V(this, qe)).forEach((H) => {
          const z = V(this, qe)[H];
          M["sys:" + H] = z instanceof Function ? z() : z;
        }), sessionStorage[R + "sys"] = JSON.stringify(M);
        const D = {};
        Object.keys(V(this, Ye)).forEach((H) => {
          const z = V(this, Ye)[H];
          D["save:" + H] = z instanceof Function ? z() : z;
        }), sessionStorage[R + "save"] = JSON.stringify(D);
        const L = {};
        Object.keys(V(this, ge)).forEach((H) => {
          const z = V(this, ge)[H];
          L[H] = z instanceof Function ? z() : z;
        }), sessionStorage[R + "tmp"] = JSON.stringify(L);
        const B = {};
        Object.keys(V(this, Ce).mp).forEach((H) => {
          const z = V(this, Ce).mp[H];
          B[H] = z instanceof Function ? z() : z;
        }), sessionStorage[R + "mp"] = JSON.stringify(B);
        const $ = {};
        Object.keys(V(this, ye).mark).forEach((H) => {
          const z = V(this, ye).mark[H];
          $[H] = z instanceof Function ? z() : z;
        }), sessionStorage[R + "mark"] = JSON.stringify($);
        const U = {};
        Object.keys(V(this, ye).kidoku).forEach((H) => {
          const z = V(this, ye).kidoku[H];
          U[H] = z instanceof Function ? z() : z;
        }), sessionStorage[R + "kidoku"] = JSON.stringify(U), t.flush();
      } : () => t.flush()), it(this, Ma, (M, D) => t.callHook(M, D)), t.addHook((M, D) => {
        var L, B;
        return (B = (L = V(this, Da))[M]) == null ? void 0 : B.call(L, M, D);
      });
      const N = this.getVal("sys:sn.tagCh.msecWait", -1);
      (V(this, ge)["const.sn.isFirstBoot"] || N === -1) && ot(this, as, Wo).call(this);
    });
  }
  updateData(t) {
    it(this, ye, t), it(this, qe, V(this, Ce).sys = V(this, ye).sys), it(this, dr, {});
    for (const e in V(this, ye).kidoku) {
      const R = new Areas();
      R.hAreas = { ...V(this, ye).kidoku[e] }, V(this, dr)[e] = R;
    }
  }
  flush() {
    V(this, ns).call(this);
  }
  setDoRecProc(t) {
    it(this, ss, t);
  }
  defTmp(t, e) {
    V(this, ge)[t] = e;
  }
  cloneMp() {
    return { ...V(this, Ce).mp };
  }
  setMp(t) {
    V(this, Ce).mp = t;
  }
  setMark(t, e) {
    V(this, ye).mark[t] = e, this.flush();
  }
  cloneSave() {
    return { ...V(this, Ce).save };
  }
  mark2save(t) {
    var e;
    it(this, Ye, V(this, Ce).save = { ...t.hSave }), it(this, nn, (e = V(this, Ye)["sn.doRecLog"]) != null ? e : !1);
  }
  loadScrWork(t) {
    t in V(this, dr) || (V(this, dr)[t] = new Areas());
  }
  saveKidoku() {
    for (const t in V(this, dr))
      V(this, ye).kidoku[t] = { ...V(this, dr)[t].hAreas };
    this.flush();
  }
  setVal_Nochk(t, e, R, N = !1) {
    var L, B;
    const M = V(this, Ce)[t];
    N && (R = ot(this, Ba, hh).call(this, R));
    const D = t + ":" + e;
    if (D in V(Qn, rn)) {
      const $ = M[e], U = R;
      $ != U && V(this, Ma).call(this, "data_break", {
        dataId: D,
        old_v: $,
        new_v: U
      });
    }
    M[e] = R, (B = (L = V(this, us))[D]) == null || B.call(L, e, R);
  }
  doRecLog() {
    return V(this, nn);
  }
  defValTrg(t, e) {
    V(this, us)[t] = e;
  }
};
let Variable = Qn;
Ce = new WeakMap(), Ye = new WeakMap(), ge = new WeakMap(), Yr = new WeakMap(), ye = new WeakMap(), qe = new WeakMap(), dr = new WeakMap(), Ma = new WeakMap(), Da = new WeakMap(), La = new WeakSet(), uh = function(t) {
  it(Qn, rn, {}), t.forEach((e) => V(Qn, rn)[e.dataId] = 1);
}, ns = new WeakMap(), ss = new WeakMap(), du = new WeakSet(), Zh = function(t) {
  if (!("from" in t))
    throw "from\u306F\u5FC5\u9808\u3067\u3059";
  if (!("to" in t))
    throw "to\u306F\u5FC5\u9808\u3067\u3059";
  const e = Number(t.from), R = Number(t.to);
  if (e === R)
    return !1;
  if (!(e in V(this, ye).mark))
    throw `from:${e} \u306E\u30BB\u30FC\u30D6\u30C7\u30FC\u30BF\u306F\u5B58\u5728\u3057\u307E\u305B\u3093`;
  return this.setMark(R, { ...V(this, ye).mark[e] }), V(this, Yr).copyBMFolder(e, R), !1;
}, pu = new WeakSet(), Kh = function(t) {
  const { place: e } = t;
  if (!e)
    throw "place\u306F\u5FC5\u9808\u3067\u3059";
  return delete V(this, ye).mark[e], this.flush(), V(this, Yr).eraseBMFolder(e), !1;
}, pr = new WeakSet(), Nr = function(t) {
  if (!t.name)
    throw "name\u306F\u5FC5\u9808\u3067\u3059";
  let e = !0;
  if (t.cast)
    switch (t.cast) {
      case "num":
        argChk_Num(t, "text", NaN);
        break;
      case "int":
        t.text = String(int(argChk_Num(t, "text", NaN)));
        break;
      case "uint":
        t.text = String(uint(argChk_Num(t, "text", NaN)));
        break;
      case "bool":
        argChk_Boolean(t, "text", !1);
        break;
      case "str":
        e = !1;
        break;
      default:
        throw "cast\u3010" + t.cast + "\u3011\u306F\u672A\u5B9A\u7FA9\u3067\u3059";
    }
  return V(this, os).call(this, t.name, t.text, e), !1;
}, vu = new WeakSet(), Jh = function(t) {
  const e = argChk_Num(t, "text", 0);
  return t.text = String(e < 0 ? -e : e), ot(this, pr, Nr).call(this, t), !1;
}, gu = new WeakSet(), Qh = function(t) {
  var e;
  return t.text = ((e = t.text) != null ? e : "").charAt(argChk_Num(t, "pos", 0)), ot(this, pr, Nr).call(this, t), !1;
}, _u = new WeakSet(), tc = function(t) {
  var N;
  const { val: e } = t;
  if (!e)
    throw "val\u306F\u5FC5\u9808\u3067\u3059";
  const R = argChk_Num(t, "start", 0);
  return t.text = String(((N = t.text) != null ? N : "").indexOf(e, R)), ot(this, pr, Nr).call(this, t), !1;
}, mu = new WeakSet(), ec = function(t) {
  var e;
  return t.text = String(((e = t.text) != null ? e : "").length), ot(this, pr, Nr).call(this, t), !1;
}, yu = new WeakSet(), rc = function(t) {
  var N;
  if (!t.reg)
    throw "reg\u306F\u5FC5\u9808\u3067\u3059";
  const { flags: e } = t, R = e ? new RegExp(t.reg, e) : new RegExp(t.reg);
  return t.text = String((N = t.text) != null ? N : "").replace(R, String(t.val)), ot(this, pr, Nr).call(this, t), !1;
}, bu = new WeakSet(), ic = function(t) {
  const e = argChk_Num(t, "text", 0);
  return t.text = String(Math.round(e)), ot(this, pr, Nr).call(this, t), !1;
}, Eu = new WeakSet(), nc = function(t) {
  var N;
  if (!t.reg)
    throw "reg\u306F\u5FC5\u9808\u3067\u3059";
  const { flags: e } = t, R = e ? new RegExp(t.reg, e) : new RegExp(t.reg);
  return t.text = String(((N = t.text) != null ? N : "").search(R)), ot(this, pr, Nr).call(this, t), !1;
}, xu = new WeakSet(), sc = function(t) {
  var R, N;
  const e = argChk_Num(t, "pos", 0);
  return t.text = t.len !== "all" ? ((R = t.text) != null ? R : "").slice(e, e + int(argChk_Num(t, "len", 1))) : ((N = t.text) != null ? N : "").slice(e), ot(this, pr, Nr).call(this, t), !1;
}, as = new WeakSet(), Wo = function() {
  var R, N;
  const t = it(this, qe, V(this, Ce).sys = V(this, ye).sys = {});
  typeof process < "u" || (this.setVal_Nochk("sys", "const.sn.window.x", 0), this.setVal_Nochk("sys", "const.sn.window.y", 0)), this.setVal_Nochk("sys", "sn.tagCh.doWait", !0), this.setVal_Nochk("sys", "sn.tagCh.doWait_Kidoku", !0), this.setVal_Nochk("sys", "sn.tagCh.msecWait", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk("sys", "sn.tagCh.msecWait_Kidoku", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk("sys", "sn.tagCh.canskip", !0), this.setVal_Nochk("sys", "sn.skip.mode", "s"), this.setVal_Nochk("sys", "sn.auto.msecPageWait", argChk_Num(t, "sn.auto.msecPageWait", (R = this.cfg.oCfg.init.auto_msecpagewait) != null ? R : 3500)), this.setVal_Nochk("sys", "sn.auto.msecPageWait_Kidoku", argChk_Num(t, "sn.auto.msecPageWait", (N = this.cfg.oCfg.init.auto_msecpagewait) != null ? N : 3500)), this.setVal_Nochk("sys", "sn.auto.msecLineWait", 500), this.setVal_Nochk("sys", "sn.auto.msecLineWait_Kidoku", 500), this.setVal_Nochk("sys", "const.sn.sound.BGM.volume", 1), this.setVal_Nochk("sys", "const.sn.sound.SE.volume", 1), this.setVal_Nochk("sys", "const.sn.sound.SYS.volume", 1);
  for (const M in V(this, ye).kidoku)
    V(this, ye).kidoku[M].hAreas = {}, V(this, dr)[M].clear();
  return this.setVal_Nochk("sys", "TextLayer.Back.Alpha", 0.5), V(this, Ce).mark = V(this, ye).mark = {}, this.setVal_Nochk("sys", "const.sn.save.place", 1), this.flush(), !1;
}, Fa = new WeakSet(), lh = function() {
  var N, M, D;
  const t = (N = V(this, Ye)["const.sn.mesLayer"]) != null ? N : "", e = (M = V(this, Ye)["sn.doRecLog"]) != null ? M : !1, R = (D = V(this, Ye)["const.sn.sLog"]) != null ? D : "[]";
  return it(this, Ye, V(this, Ce).save = {}), this.setVal_Nochk("save", "const.sn.mesLayer", t), this.setVal_Nochk("save", "sn.doRecLog", e), this.setVal_Nochk("save", "const.sn.sLog", R), !1;
}, os = new WeakMap(), rn = new WeakMap(), Ba = new WeakSet(), hh = function(t) {
  const e = t;
  if (e === "true")
    return !0;
  if (e === "false")
    return !1;
  if (e === "null")
    return null;
  if (e !== "undefined")
    return V(this, $a).test(e) ? parseFloat(e) : t;
}, $a = new WeakMap(), ka = new WeakMap(), nn = new WeakMap(), us = new WeakMap(), ls = new WeakSet(), Yo = function(t) {
  argChk_Boolean(V(this, qe), t, !0);
}, Tu = new WeakSet(), ac = function(t) {
  argChk_Num(V(this, qe), t, 10), V(this, qe)["sn.tagCh.doWait"];
}, Su = new WeakSet(), oc = function(t) {
  argChk_Num(
    V(this, qe),
    t,
    this.cfg.oCfg.init.tagch_msecwait === void 0 ? 10 : this.cfg.oCfg.init.tagch_msecwait
  ), V(this, qe)["sn.tagCh.doWait_Kidoku"];
}, Ga = new WeakSet(), ch = function(t) {
  argChk_Num(
    V(this, qe),
    t,
    this.cfg.oCfg.init.auto_msecpagewait === void 0 ? 3500 : this.cfg.oCfg.init.auto_msecpagewait
  );
}, Ua = new WeakSet(), fh = function(t) {
  argChk_Num(V(this, qe), t, 500);
}, Cu = new WeakSet(), uc = function(t) {
  return argChk_Boolean(V(this, Ye), t, !0);
}, Iu = new WeakSet(), lc = function(t) {
  argChk_Boolean(V(this, ge), t, !0);
}, hs = new WeakSet(), qo = function(t) {
  argChk_Boolean(V(this, ge), t, !1);
}, nt(Variable, rn, {});
var Easing = {
  Linear: {
    None: function(o) {
      return o;
    }
  },
  Quadratic: {
    In: function(o) {
      return o * o;
    },
    Out: function(o) {
      return o * (2 - o);
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o : -0.5 * (--o * (o - 2) - 1);
    }
  },
  Cubic: {
    In: function(o) {
      return o * o * o;
    },
    Out: function(o) {
      return --o * o * o + 1;
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o * o : 0.5 * ((o -= 2) * o * o + 2);
    }
  },
  Quartic: {
    In: function(o) {
      return o * o * o * o;
    },
    Out: function(o) {
      return 1 - --o * o * o * o;
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o * o * o : -0.5 * ((o -= 2) * o * o * o - 2);
    }
  },
  Quintic: {
    In: function(o) {
      return o * o * o * o * o;
    },
    Out: function(o) {
      return --o * o * o * o * o + 1;
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o * o * o * o : 0.5 * ((o -= 2) * o * o * o * o + 2);
    }
  },
  Sinusoidal: {
    In: function(o) {
      return 1 - Math.cos(o * Math.PI / 2);
    },
    Out: function(o) {
      return Math.sin(o * Math.PI / 2);
    },
    InOut: function(o) {
      return 0.5 * (1 - Math.cos(Math.PI * o));
    }
  },
  Exponential: {
    In: function(o) {
      return o === 0 ? 0 : Math.pow(1024, o - 1);
    },
    Out: function(o) {
      return o === 1 ? 1 : 1 - Math.pow(2, -10 * o);
    },
    InOut: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : (o *= 2) < 1 ? 0.5 * Math.pow(1024, o - 1) : 0.5 * (-Math.pow(2, -10 * (o - 1)) + 2);
    }
  },
  Circular: {
    In: function(o) {
      return 1 - Math.sqrt(1 - o * o);
    },
    Out: function(o) {
      return Math.sqrt(1 - --o * o);
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? -0.5 * (Math.sqrt(1 - o * o) - 1) : 0.5 * (Math.sqrt(1 - (o -= 2) * o) + 1);
    }
  },
  Elastic: {
    In: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : -Math.pow(2, 10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI);
    },
    Out: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : Math.pow(2, -10 * o) * Math.sin((o - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : (o *= 2, o < 1 ? -0.5 * Math.pow(2, 10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI) + 1);
    }
  },
  Back: {
    In: function(o) {
      var t = 1.70158;
      return o * o * ((t + 1) * o - t);
    },
    Out: function(o) {
      var t = 1.70158;
      return --o * o * ((t + 1) * o + t) + 1;
    },
    InOut: function(o) {
      var t = 2.5949095;
      return (o *= 2) < 1 ? 0.5 * (o * o * ((t + 1) * o - t)) : 0.5 * ((o -= 2) * o * ((t + 1) * o + t) + 2);
    }
  },
  Bounce: {
    In: function(o) {
      return 1 - Easing.Bounce.Out(1 - o);
    },
    Out: function(o) {
      return o < 1 / 2.75 ? 7.5625 * o * o : o < 2 / 2.75 ? 7.5625 * (o -= 1.5 / 2.75) * o + 0.75 : o < 2.5 / 2.75 ? 7.5625 * (o -= 2.25 / 2.75) * o + 0.9375 : 7.5625 * (o -= 2.625 / 2.75) * o + 0.984375;
    },
    InOut: function(o) {
      return o < 0.5 ? Easing.Bounce.In(o * 2) * 0.5 : Easing.Bounce.Out(o * 2 - 1) * 0.5 + 0.5;
    }
  }
}, now$2;
typeof self > "u" && typeof process < "u" && process.hrtime ? now$2 = function() {
  var o = process.hrtime();
  return o[0] * 1e3 + o[1] / 1e6;
} : typeof self < "u" && self.performance !== void 0 && self.performance.now !== void 0 ? now$2 = self.performance.now.bind(self.performance) : Date.now !== void 0 ? now$2 = Date.now : now$2 = function() {
  return new Date().getTime();
};
var now$1$1 = now$2, Group = function() {
  function o() {
    this._tweens = {}, this._tweensAddedDuringUpdate = {};
  }
  return o.prototype.getAll = function() {
    var t = this;
    return Object.keys(this._tweens).map(function(e) {
      return t._tweens[e];
    });
  }, o.prototype.removeAll = function() {
    this._tweens = {};
  }, o.prototype.add = function(t) {
    this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t;
  }, o.prototype.remove = function(t) {
    delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()];
  }, o.prototype.update = function(t, e) {
    t === void 0 && (t = now$1$1()), e === void 0 && (e = !1);
    var R = Object.keys(this._tweens);
    if (R.length === 0)
      return !1;
    for (; R.length > 0; ) {
      this._tweensAddedDuringUpdate = {};
      for (var N = 0; N < R.length; N++) {
        var M = this._tweens[R[N]], D = !e;
        M && M.update(t, D) === !1 && !e && delete this._tweens[R[N]];
      }
      R = Object.keys(this._tweensAddedDuringUpdate);
    }
    return !0;
  }, o;
}(), Interpolation = {
  Linear: function(o, t) {
    var e = o.length - 1, R = e * t, N = Math.floor(R), M = Interpolation.Utils.Linear;
    return t < 0 ? M(o[0], o[1], R) : t > 1 ? M(o[e], o[e - 1], e - R) : M(o[N], o[N + 1 > e ? e : N + 1], R - N);
  },
  Bezier: function(o, t) {
    for (var e = 0, R = o.length - 1, N = Math.pow, M = Interpolation.Utils.Bernstein, D = 0; D <= R; D++)
      e += N(1 - t, R - D) * N(t, D) * o[D] * M(R, D);
    return e;
  },
  CatmullRom: function(o, t) {
    var e = o.length - 1, R = e * t, N = Math.floor(R), M = Interpolation.Utils.CatmullRom;
    return o[0] === o[e] ? (t < 0 && (N = Math.floor(R = e * (1 + t))), M(o[(N - 1 + e) % e], o[N], o[(N + 1) % e], o[(N + 2) % e], R - N)) : t < 0 ? o[0] - (M(o[0], o[0], o[1], o[1], -R) - o[0]) : t > 1 ? o[e] - (M(o[e], o[e], o[e - 1], o[e - 1], R - e) - o[e]) : M(o[N ? N - 1 : 0], o[N], o[e < N + 1 ? e : N + 1], o[e < N + 2 ? e : N + 2], R - N);
  },
  Utils: {
    Linear: function(o, t, e) {
      return (t - o) * e + o;
    },
    Bernstein: function(o, t) {
      var e = Interpolation.Utils.Factorial;
      return e(o) / e(t) / e(o - t);
    },
    Factorial: function() {
      var o = [1];
      return function(t) {
        var e = 1;
        if (o[t])
          return o[t];
        for (var R = t; R > 1; R--)
          e *= R;
        return o[t] = e, e;
      };
    }(),
    CatmullRom: function(o, t, e, R, N) {
      var M = (e - o) * 0.5, D = (R - t) * 0.5, L = N * N, B = N * L;
      return (2 * t - 2 * e + M + D) * B + (-3 * t + 3 * e - 2 * M - D) * L + M * N + t;
    }
  }
}, Sequence = function() {
  function o() {
  }
  return o.nextId = function() {
    return o._nextId++;
  }, o._nextId = 0, o;
}(), mainGroup = new Group(), Tween = function() {
  function o(t, e) {
    e === void 0 && (e = mainGroup), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = Easing.Linear.None, this._interpolationFunction = Interpolation.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._id = Sequence.nextId(), this._isChainStopped = !1, this._goToEnd = !1;
  }
  return o.prototype.getId = function() {
    return this._id;
  }, o.prototype.isPlaying = function() {
    return this._isPlaying;
  }, o.prototype.isPaused = function() {
    return this._isPaused;
  }, o.prototype.to = function(t, e) {
    return this._valuesEnd = Object.create(t), e !== void 0 && (this._duration = e), this;
  }, o.prototype.duration = function(t) {
    return this._duration = t, this;
  }, o.prototype.start = function(t) {
    if (this._isPlaying)
      return this;
    if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {
      this._reversed = !1;
      for (var e in this._valuesStartRepeat)
        this._swapEndStartRepeatValues(e), this._valuesStart[e] = this._valuesStartRepeat[e];
    }
    return this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t !== void 0 ? typeof t == "string" ? now$1$1() + parseFloat(t) : t : now$1$1(), this._startTime += this._delayTime, this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat), this;
  }, o.prototype._setupProperties = function(t, e, R, N) {
    for (var M in R) {
      var D = t[M], L = Array.isArray(D), B = L ? "array" : typeof D, $ = !L && Array.isArray(R[M]);
      if (!(B === "undefined" || B === "function")) {
        if ($) {
          var U = R[M];
          if (U.length === 0)
            continue;
          U = U.map(this._handleRelativeValue.bind(this, D)), R[M] = [D].concat(U);
        }
        if ((B === "object" || L) && D && !$) {
          e[M] = L ? [] : {};
          for (var H in D)
            e[M][H] = D[H];
          N[M] = L ? [] : {}, this._setupProperties(D, e[M], R[M], N[M]);
        } else
          typeof e[M] > "u" && (e[M] = D), L || (e[M] *= 1), $ ? N[M] = R[M].slice().reverse() : N[M] = e[M] || 0;
      }
    }
  }, o.prototype.stop = function() {
    return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
  }, o.prototype.end = function() {
    return this._goToEnd = !0, this.update(1 / 0), this;
  }, o.prototype.pause = function(t) {
    return t === void 0 && (t = now$1$1()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this), this);
  }, o.prototype.resume = function(t) {
    return t === void 0 && (t = now$1$1()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);
  }, o.prototype.stopChainedTweens = function() {
    for (var t = 0, e = this._chainedTweens.length; t < e; t++)
      this._chainedTweens[t].stop();
    return this;
  }, o.prototype.group = function(t) {
    return this._group = t, this;
  }, o.prototype.delay = function(t) {
    return this._delayTime = t, this;
  }, o.prototype.repeat = function(t) {
    return this._initialRepeat = t, this._repeat = t, this;
  }, o.prototype.repeatDelay = function(t) {
    return this._repeatDelayTime = t, this;
  }, o.prototype.yoyo = function(t) {
    return this._yoyo = t, this;
  }, o.prototype.easing = function(t) {
    return this._easingFunction = t, this;
  }, o.prototype.interpolation = function(t) {
    return this._interpolationFunction = t, this;
  }, o.prototype.chain = function() {
    for (var t = [], e = 0; e < arguments.length; e++)
      t[e] = arguments[e];
    return this._chainedTweens = t, this;
  }, o.prototype.onStart = function(t) {
    return this._onStartCallback = t, this;
  }, o.prototype.onUpdate = function(t) {
    return this._onUpdateCallback = t, this;
  }, o.prototype.onRepeat = function(t) {
    return this._onRepeatCallback = t, this;
  }, o.prototype.onComplete = function(t) {
    return this._onCompleteCallback = t, this;
  }, o.prototype.onStop = function(t) {
    return this._onStopCallback = t, this;
  }, o.prototype.update = function(t, e) {
    if (t === void 0 && (t = now$1$1()), e === void 0 && (e = !0), this._isPaused)
      return !0;
    var R, N, M = this._startTime + this._duration;
    if (!this._goToEnd && !this._isPlaying) {
      if (t > M)
        return !1;
      e && this.start(t);
    }
    if (this._goToEnd = !1, t < this._startTime)
      return !0;
    this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), N = (t - this._startTime) / this._duration, N = this._duration === 0 || N > 1 ? 1 : N;
    var D = this._easingFunction(N);
    if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, D), this._onUpdateCallback && this._onUpdateCallback(this._object, N), N === 1)
      if (this._repeat > 0) {
        isFinite(this._repeat) && this._repeat--;
        for (R in this._valuesStartRepeat)
          !this._yoyo && typeof this._valuesEnd[R] == "string" && (this._valuesStartRepeat[R] = this._valuesStartRepeat[R] + parseFloat(this._valuesEnd[R])), this._yoyo && this._swapEndStartRepeatValues(R), this._valuesStart[R] = this._valuesStartRepeat[R];
        return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), !0;
      } else {
        this._onCompleteCallback && this._onCompleteCallback(this._object);
        for (var L = 0, B = this._chainedTweens.length; L < B; L++)
          this._chainedTweens[L].start(this._startTime + this._duration);
        return this._isPlaying = !1, !1;
      }
    return !0;
  }, o.prototype._updateProperties = function(t, e, R, N) {
    for (var M in R)
      if (e[M] !== void 0) {
        var D = e[M] || 0, L = R[M], B = Array.isArray(t[M]), $ = Array.isArray(L), U = !B && $;
        U ? t[M] = this._interpolationFunction(L, N) : typeof L == "object" && L ? this._updateProperties(t[M], D, L, N) : (L = this._handleRelativeValue(D, L), typeof L == "number" && (t[M] = D + (L - D) * N));
      }
  }, o.prototype._handleRelativeValue = function(t, e) {
    return typeof e != "string" ? e : e.charAt(0) === "+" || e.charAt(0) === "-" ? t + parseFloat(e) : parseFloat(e);
  }, o.prototype._swapEndStartRepeatValues = function(t) {
    var e = this._valuesStartRepeat[t], R = this._valuesEnd[t];
    typeof R == "string" ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(R) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = e;
  }, o;
}();
Sequence.nextId;
var TWEEN = mainGroup;
TWEEN.getAll.bind(TWEEN);
var removeAll = TWEEN.removeAll.bind(TWEEN);
TWEEN.add.bind(TWEEN);
TWEEN.remove.bind(TWEEN);
var update = TWEEN.update.bind(TWEEN), Ha;
const wu = class {
  static ease(t) {
    if (!t)
      return (e) => Easing.Linear.None(e);
    if (!(t in V(wu, Ha)))
      throw "\u7570\u5E38\u306Aease\u6307\u5B9A\u3067\u3059";
    return V(wu, Ha)[t];
  }
};
let CmnTween = wu;
Ha = new WeakMap(), nt(CmnTween, Ha, {
  "Back.In": (t) => Easing.Back.In(t),
  "Back.InOut": (t) => Easing.Back.InOut(t),
  "Back.Out": (t) => Easing.Back.Out(t),
  "Bounce.In": (t) => Easing.Bounce.In(t),
  "Bounce.InOut": (t) => Easing.Bounce.InOut(t),
  "Bounce.Out": (t) => Easing.Bounce.Out(t),
  "Circular.In": (t) => Easing.Circular.In(t),
  "Circular.InOut": (t) => Easing.Circular.InOut(t),
  "Circular.Out": (t) => Easing.Circular.Out(t),
  "Cubic.In": (t) => Easing.Cubic.In(t),
  "Cubic.InOut": (t) => Easing.Cubic.InOut(t),
  "Cubic.Out": (t) => Easing.Cubic.Out(t),
  "Elastic.In": (t) => Easing.Elastic.In(t),
  "Elastic.InOut": (t) => Easing.Elastic.InOut(t),
  "Elastic.Out": (t) => Easing.Elastic.Out(t),
  "Exponential.In": (t) => Easing.Exponential.In(t),
  "Exponential.InOut": (t) => Easing.Exponential.InOut(t),
  "Exponential.Out": (t) => Easing.Exponential.Out(t),
  "Linear.None": (t) => Easing.Linear.None(t),
  "Quadratic.In": (t) => Easing.Quadratic.In(t),
  "Quadratic.InOut": (t) => Easing.Quadratic.InOut(t),
  "Quadratic.Out": (t) => Easing.Quadratic.Out(t),
  "Quartic.In": (t) => Easing.Quartic.In(t),
  "Quartic.InOut": (t) => Easing.Quartic.InOut(t),
  "Quartic.Out": (t) => Easing.Quartic.Out(t),
  "Quintic.In": (t) => Easing.Quintic.In(t),
  "Quintic.InOut": (t) => Easing.Quintic.InOut(t),
  "Quintic.Out": (t) => Easing.Quintic.Out(t),
  "Sinusoidal.In": (t) => Easing.Sinusoidal.In(t),
  "Sinusoidal.InOut": (t) => Easing.Sinusoidal.InOut(t),
  "Sinusoidal.Out": (t) => Easing.Sinusoidal.Out(t)
});
/*!
 * @pixi/sound - v4.3.0
 * https://github.com/pixijs/pixi-sound
 * Compiled Fri, 05 Aug 2022 20:12:47 UTC
 *
 * @pixi/sound is licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license
 */
var r;
function s() {
  return r;
}
var u = function(o, t) {
  return (u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      Object.prototype.hasOwnProperty.call(R, N) && (e[N] = R[N]);
  })(o, t);
};
function a(o, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function e() {
    this.constructor = o;
  }
  u(o, t), o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var c = function() {
  return (c = Object.assign || function(o) {
    for (var t, e = 1, R = arguments.length; e < R; e++)
      for (var N in t = arguments[e])
        Object.prototype.hasOwnProperty.call(t, N) && (o[N] = t[N]);
    return o;
  }).apply(this, arguments);
}, l = ["mp3", "ogg", "oga", "opus", "mpeg", "wav", "m4a", "aiff", "wma", "mid", "caf"], p = {};
function h(o) {
  var t = c({ m4a: "audio/mp4", oga: "audio/ogg", opus: 'audio/ogg; codecs="opus"', caf: 'audio/x-caf; codecs="opus"' }, o || {}), e = document.createElement("audio"), R = {}, N = /^no$/;
  l.forEach(function(M) {
    var D = e.canPlayType("audio/".concat(M)).replace(N, ""), L = t[M] ? e.canPlayType(t[M]).replace(N, "") : "";
    R[M] = !!D || !!L;
  }), Object.assign(p, R);
}
h();
var f = /\.(\{([^\}]+)\})(\?.*)?$/;
function d(o) {
  var t = f, e = typeof o == "string" ? o : o.url;
  if (!t.test(e))
    return e;
  for (var R = t.exec(e), N = R[2].split(","), M = N[N.length - 1], D = 0, L = N.length; D < L; D++) {
    var B = N[D];
    if (p[B]) {
      M = B;
      break;
    }
  }
  var $ = e.replace(R[1], M);
  if (typeof o != "string") {
    var U = o;
    U.extension = M, U.url = $;
  }
  return $;
}
var _ = function() {
  function o() {
  }
  return o.add = function() {
    o.setLegacy(s().useLegacy);
  }, o.setLegacy = function(t) {
    var e = l;
    t ? e.forEach(function(R) {
      LoaderResource.setExtensionXhrType(R, LoaderResource.XHR_RESPONSE_TYPE.DEFAULT), LoaderResource.setExtensionLoadType(R, LoaderResource.LOAD_TYPE.AUDIO);
    }) : e.forEach(function(R) {
      LoaderResource.setExtensionXhrType(R, LoaderResource.XHR_RESPONSE_TYPE.BUFFER), LoaderResource.setExtensionLoadType(R, LoaderResource.LOAD_TYPE.XHR);
    });
  }, o.pre = function(t, e) {
    d(t), e();
  }, o.use = function(t, e) {
    t.data && l.indexOf(t.extension) > -1 ? t.sound = s().add(t.name, { loaded: e, preload: !0, url: t.url, source: t.data }) : e();
  }, o;
}(), y = 0, m = function(o) {
  function t(e) {
    var R = o.call(this) || this;
    return R.id = y++, R.init(e), R;
  }
  return a(t, o), t.prototype.set = function(e, R) {
    if (this[e] === void 0)
      throw new Error("Property with name ".concat(e, " does not exist."));
    switch (e) {
      case "speed":
        this.speed = R;
        break;
      case "volume":
        this.volume = R;
        break;
      case "paused":
        this.paused = R;
        break;
      case "loop":
        this.loop = R;
        break;
      case "muted":
        this.muted = R;
    }
    return this;
  }, Object.defineProperty(t.prototype, "progress", { get: function() {
    return this._source.currentTime / this._duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    this._paused = e, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), t.prototype._onPlay = function() {
    this._playing = !0;
  }, t.prototype._onPause = function() {
    this._playing = !1;
  }, t.prototype.init = function(e) {
    this._playing = !1, this._duration = e.source.duration;
    var R = this._source = e.source.cloneNode(!1);
    R.src = e.parent.url, R.onplay = this._onPlay.bind(this), R.onpause = this._onPause.bind(this), e.context.on("refresh", this.refresh, this), e.context.on("refreshPaused", this.refreshPaused, this), this._media = e;
  }, t.prototype._internalStop = function() {
    this._source && this._playing && (this._source.onended = null, this._source.pause());
  }, t.prototype.stop = function() {
    this._internalStop(), this._source && this.emit("stop");
  }, Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(e) {
    this._speed = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(e) {
    this._volume = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(e) {
    this._loop = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(e) {
    this._muted = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    var e = this._media.context, R = this._media.parent;
    this._source.loop = this._loop || R.loop;
    var N = e.volume * (e.muted ? 0 : 1), M = R.volume * (R.muted ? 0 : 1), D = this._volume * (this._muted ? 0 : 1);
    this._source.volume = D * N * M, this._source.playbackRate = this._speed * e.speed * R.speed;
  }, t.prototype.refreshPaused = function() {
    var e = this._media.context, R = this._media.parent, N = this._paused || R.paused || e.paused;
    N !== this._pausedReal && (this._pausedReal = N, N ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop })), this.emit("pause", N));
  }, t.prototype.play = function(e) {
    var R = this, N = e.start, M = e.end, D = e.speed, L = e.loop, B = e.volume, $ = e.muted;
    this._speed = D, this._volume = B, this._loop = !!L, this._muted = $, this.refresh(), this.loop && M !== null && (this.loop = !1), this._start = N, this._end = M || this._duration, this._start = Math.max(0, this._start - t.PADDING), this._end = Math.min(this._end + t.PADDING, this._duration), this._source.onloadedmetadata = function() {
      R._source && (R._source.currentTime = N, R._source.onloadedmetadata = null, R.emit("progress", N, R._duration), Ticker.shared.add(R._onUpdate, R));
    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit("start");
  }, t.prototype._onUpdate = function() {
    this.emit("progress", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();
  }, t.prototype._onComplete = function() {
    Ticker.shared.remove(this._onUpdate, this), this._internalStop(), this.emit("progress", 1, this._duration), this.emit("end", this);
  }, t.prototype.destroy = function() {
    Ticker.shared.remove(this._onUpdate, this), this.removeAllListeners();
    var e = this._source;
    e && (e.onended = null, e.onplay = null, e.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = !1, this._end = null, this._start = 0, this._duration = 0, this._playing = !1, this._pausedReal = !1, this._paused = !1, this._muted = !1, this._media && (this._media.context.off("refresh", this.refresh, this), this._media.context.off("refreshPaused", this.refreshPaused, this), this._media = null);
  }, t.prototype.toString = function() {
    return "[HTMLAudioInstance id=".concat(this.id, "]");
  }, t.PADDING = 0.1, t;
}(n), g = function(o) {
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  return a(t, o), t.prototype.init = function(e) {
    this.parent = e, this._source = e.options.source || new Audio(), e.url && (this._source.src = e.url);
  }, t.prototype.create = function() {
    return new m(this);
  }, Object.defineProperty(t.prototype, "isPlayable", { get: function() {
    return !!this._source && this._source.readyState === 4;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "duration", { get: function() {
    return this._source.duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = "", this._source.load(), this._source = null);
  }, Object.defineProperty(t.prototype, "source", { get: function() {
    return this._source;
  }, enumerable: !1, configurable: !0 }), t.prototype.load = function(e) {
    var R = this._source, N = this.parent;
    if (R.readyState !== 4)
      if (N.url) {
        R.src = N.url;
        var M = function() {
          B(), N.isLoaded = !0;
          var U = N.autoPlayStart();
          e && e(null, N, U);
        }, D = function() {
          B(), e && e(new Error("Sound loading has been aborted"));
        }, L = function() {
          B();
          var U = "Failed to load audio element (code: ".concat(R.error.code, ")");
          e && e(new Error(U));
        }, B = function() {
          R.removeEventListener("canplaythrough", M), R.removeEventListener("load", M), R.removeEventListener("abort", D), R.removeEventListener("error", L);
        };
        R.addEventListener("canplaythrough", M, !1), R.addEventListener("load", M, !1), R.addEventListener("abort", D, !1), R.addEventListener("error", L, !1), R.load();
      } else
        e(new Error("sound.url or sound.source must be set"));
    else {
      N.isLoaded = !0;
      var $ = N.autoPlayStart();
      e && setTimeout(function() {
        e(null, N, $);
      }, 0);
    }
  }, t;
}(n), b = function() {
  function o(t, e) {
    this.parent = t, Object.assign(this, e), this.duration = this.end - this.start;
  }
  return o.prototype.play = function(t) {
    return this.parent.play({ complete: t, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop });
  }, o.prototype.destroy = function() {
    this.parent = null;
  }, o;
}(), v = function() {
  function o() {
  }
  return o.setParamValue = function(t, e) {
    if (t.setValueAtTime) {
      var R = s().context;
      t.setValueAtTime(e, R.audioContext.currentTime);
    } else
      t.value = e;
    return e;
  }, o;
}(), P = 0, x = function(o) {
  function t(e) {
    var R = o.call(this) || this;
    return R.id = P++, R._media = null, R._paused = !1, R._muted = !1, R._elapsed = 0, R.init(e), R;
  }
  return a(t, o), t.prototype.set = function(e, R) {
    if (this[e] === void 0)
      throw new Error("Property with name ".concat(e, " does not exist."));
    switch (e) {
      case "speed":
        this.speed = R;
        break;
      case "volume":
        this.volume = R;
        break;
      case "muted":
        this.muted = R;
        break;
      case "loop":
        this.loop = R;
        break;
      case "paused":
        this.paused = R;
    }
    return this;
  }, t.prototype.stop = function() {
    this._source && (this._internalStop(), this.emit("stop"));
  }, Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(e) {
    this._speed = e, this.refresh(), this._update(!0);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(e) {
    this._volume = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(e) {
    this._muted = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(e) {
    this._loop = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(e) {
    var R;
    this._filters && ((R = this._filters) === null || R === void 0 || R.filter(function(N) {
      return N;
    }).forEach(function(N) {
      return N.disconnect();
    }), this._filters = null, this._source.connect(this._gain)), this._filters = e != null && e.length ? e.slice(0) : null, this.refresh();
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    if (this._source) {
      var e = this._media.context, R = this._media.parent;
      this._source.loop = this._loop || R.loop;
      var N = e.volume * (e.muted ? 0 : 1), M = R.volume * (R.muted ? 0 : 1), D = this._volume * (this._muted ? 0 : 1);
      v.setParamValue(this._gain.gain, D * M * N), v.setParamValue(this._source.playbackRate, this._speed * R.speed * e.speed), this.applyFilters();
    }
  }, t.prototype.applyFilters = function() {
    var e;
    if (!((e = this._filters) === null || e === void 0) && e.length) {
      this._source.disconnect();
      var R = this._source;
      this._filters.forEach(function(N) {
        R.connect(N.destination), R = N;
      }), R.connect(this._gain);
    }
  }, t.prototype.refreshPaused = function() {
    var e = this._media.context, R = this._media.parent, N = this._paused || R.paused || e.paused;
    N !== this._pausedReal && (this._pausedReal = N, N ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume })), this.emit("pause", N));
  }, t.prototype.play = function(e) {
    var R = e.start, N = e.end, M = e.speed, D = e.loop, L = e.volume, B = e.muted, $ = e.filters;
    this._paused = !1;
    var U = this._media.nodes.cloneBufferSource(), H = U.source, z = U.gain;
    this._source = H, this._gain = z, this._speed = M, this._volume = L, this._loop = !!D, this._muted = B, this._filters = $, this.refresh();
    var X = this._source.buffer.duration;
    this._duration = X, this._end = N, this._lastUpdate = this._now(), this._elapsed = R, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = N, this._source.loopStart = R, this._source.start(0, R)) : N ? this._source.start(0, R, N - R) : this._source.start(0, R), this.emit("start"), this._update(!0), this.enableTicker(!0);
  }, t.prototype.enableTicker = function(e) {
    Ticker.shared.remove(this._updateListener, this), e && Ticker.shared.add(this._updateListener, this);
  }, Object.defineProperty(t.prototype, "progress", { get: function() {
    return this._progress;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    this._paused = e, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    var e;
    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off("refresh", this.refresh, this), this._media.context.events.off("refreshPaused", this.refreshPaused, this), this._media = null), (e = this._filters) === null || e === void 0 || e.forEach(function(R) {
      return R.disconnect();
    }), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = !1, this._elapsed = 0, this._duration = 0, this._paused = !1, this._muted = !1, this._pausedReal = !1;
  }, t.prototype.toString = function() {
    return "[WebAudioInstance id=".concat(this.id, "]");
  }, t.prototype._now = function() {
    return this._media.context.audioContext.currentTime;
  }, t.prototype._updateListener = function() {
    this._update();
  }, t.prototype._update = function(e) {
    if (e === void 0 && (e = !1), this._source) {
      var R = this._now(), N = R - this._lastUpdate;
      if (N > 0 || e) {
        var M = this._source.playbackRate.value;
        this._elapsed += N * M, this._lastUpdate = R;
        var D = this._duration, L = void 0;
        if (this._source.loopStart) {
          var B = this._source.loopEnd - this._source.loopStart;
          L = (this._source.loopStart + this._elapsed % B) / D;
        } else
          L = this._elapsed % D / D;
        this._progress = L, this.emit("progress", this._progress, D);
      }
    }
  }, t.prototype.init = function(e) {
    this._media = e, e.context.events.on("refresh", this.refresh, this), e.context.events.on("refreshPaused", this.refreshPaused, this);
  }, t.prototype._internalStop = function() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.stop(0), this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch {
      }
      this._source = null;
    }
  }, t.prototype._onComplete = function() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch {
      }
    }
    this._source = null, this._progress = 1, this.emit("progress", 1, this._duration), this.emit("end", this);
  }, t;
}(n), O = function() {
  function o(t, e) {
    this._output = e, this._input = t;
  }
  return Object.defineProperty(o.prototype, "destination", { get: function() {
    return this._input;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(t) {
    var e = this;
    if (this._filters && (this._filters.forEach(function(N) {
      N && N.disconnect();
    }), this._filters = null, this._input.connect(this._output)), t && t.length) {
      this._filters = t.slice(0), this._input.disconnect();
      var R = null;
      t.forEach(function(N) {
        R === null ? e._input.connect(N.destination) : R.connect(N.destination), R = N;
      }), R.connect(this._output);
    }
  }, enumerable: !1, configurable: !0 }), o.prototype.destroy = function() {
    this.filters = null, this._input = null, this._output = null;
  }, o;
}(), j = function(o) {
  function t(e) {
    var R = this, N = e.audioContext, M = N.createBufferSource(), D = N.createGain(), L = N.createAnalyser();
    return M.connect(L), L.connect(D), D.connect(e.destination), (R = o.call(this, L, D) || this).context = e, R.bufferSource = M, R.gain = D, R.analyser = L, R;
  }
  return a(t, o), Object.defineProperty(t.prototype, "script", { get: function() {
    return this._script || (this._script = this.context.audioContext.createScriptProcessor(t.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    o.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;
  }, t.prototype.cloneBufferSource = function() {
    var e = this.bufferSource, R = this.context.audioContext.createBufferSource();
    R.buffer = e.buffer, v.setParamValue(R.playbackRate, e.playbackRate.value), R.loop = e.loop;
    var N = this.context.audioContext.createGain();
    return R.connect(N), N.connect(this.destination), { source: R, gain: N };
  }, Object.defineProperty(t.prototype, "bufferSize", { get: function() {
    return this.script.bufferSize;
  }, enumerable: !1, configurable: !0 }), t.BUFFER_SIZE = 0, t;
}(O), w = function() {
  function o() {
  }
  return o.prototype.init = function(t) {
    this.parent = t, this._nodes = new j(this.context), this._source = this._nodes.bufferSource, this.source = t.options.source;
  }, o.prototype.destroy = function() {
    this.parent = null, this._nodes.destroy(), this._nodes = null;
    try {
      this._source.buffer = null;
    } catch {
    }
    this._source = null, this.source = null;
  }, o.prototype.create = function() {
    return new x(this);
  }, Object.defineProperty(o.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "isPlayable", { get: function() {
    return !!this._source && !!this._source.buffer;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "filters", { get: function() {
    return this._nodes.filters;
  }, set: function(t) {
    this._nodes.filters = t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "duration", { get: function() {
    return this._source.buffer.duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "buffer", { get: function() {
    return this._source.buffer;
  }, set: function(t) {
    this._source.buffer = t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "nodes", { get: function() {
    return this._nodes;
  }, enumerable: !1, configurable: !0 }), o.prototype.load = function(t) {
    this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t && t(new Error("sound.url or sound.source must be set"));
  }, o.prototype._loadUrl = function(t) {
    var e = this, R = new XMLHttpRequest(), N = this.parent.url;
    R.open("GET", N, !0), R.responseType = "arraybuffer", R.onload = function() {
      e.source = R.response, e._decode(R.response, t);
    }, R.send();
  }, o.prototype._decode = function(t, e) {
    var R = this, N = function(M, D) {
      if (M)
        e && e(M);
      else {
        R.parent.isLoaded = !0, R.buffer = D;
        var L = R.parent.autoPlayStart();
        e && e(null, R.parent, L);
      }
    };
    t instanceof AudioBuffer ? N(null, t) : this.parent.context.decode(t, N);
  }, o;
}(), A = function() {
  function o(t, e) {
    this.media = t, this.options = e, this._instances = [], this._sprites = {}, this.media.init(this);
    var R = e.complete;
    this._autoPlayOptions = R ? { complete: R } : null, this.isLoaded = !1, this.isPlaying = !1, this.autoPlay = e.autoPlay, this.singleInstance = e.singleInstance, this.preload = e.preload || this.autoPlay, this.url = e.url, this.speed = e.speed, this.volume = e.volume, this.loop = e.loop, e.sprites && this.addSprites(e.sprites), this.preload && this._preload(e.loaded);
  }
  return o.from = function(t) {
    var e = {};
    return typeof t == "string" ? e.url = t : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? e.source = t : e = t, (e = c({ autoPlay: !1, singleInstance: !1, url: null, source: null, preload: !1, volume: 1, speed: 1, complete: null, loaded: null, loop: !1 }, e)).url && (e.url = d(e.url)), Object.freeze(e), new o(s().useLegacy ? new g() : new w(), e);
  }, Object.defineProperty(o.prototype, "context", { get: function() {
    return s().context;
  }, enumerable: !1, configurable: !0 }), o.prototype.pause = function() {
    return this.isPlaying = !1, this.paused = !0, this;
  }, o.prototype.resume = function() {
    return this.isPlaying = this._instances.length > 0, this.paused = !1, this;
  }, Object.defineProperty(o.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(t) {
    this._paused = t, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(t) {
    this._speed = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "filters", { get: function() {
    return this.media.filters;
  }, set: function(t) {
    this.media.filters = t;
  }, enumerable: !1, configurable: !0 }), o.prototype.addSprites = function(t, e) {
    if (typeof t == "object") {
      var R = {};
      for (var N in t)
        R[N] = this.addSprites(N, t[N]);
      return R;
    }
    var M = new b(this, e);
    return this._sprites[t] = M, M;
  }, o.prototype.destroy = function() {
    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;
  }, o.prototype.removeSprites = function(t) {
    if (t) {
      var e = this._sprites[t];
      e !== void 0 && (e.destroy(), delete this._sprites[t]);
    } else
      for (var R in this._sprites)
        this.removeSprites(R);
    return this;
  }, Object.defineProperty(o.prototype, "isPlayable", { get: function() {
    return this.isLoaded && this.media && this.media.isPlayable;
  }, enumerable: !1, configurable: !0 }), o.prototype.stop = function() {
    if (!this.isPlayable)
      return this.autoPlay = !1, this._autoPlayOptions = null, this;
    this.isPlaying = !1;
    for (var t = this._instances.length - 1; t >= 0; t--)
      this._instances[t].stop();
    return this;
  }, o.prototype.play = function(t, e) {
    var R, N = this;
    if (typeof t == "string" ? R = { sprite: D = t, loop: this.loop, complete: e } : typeof t == "function" ? (R = {}).complete = t : R = t, (R = c({ complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: !1, loop: !1 }, R || {})).sprite) {
      var M = R.sprite, D = this._sprites[M];
      R.start = D.start + (R.start || 0), R.end = D.end, R.speed = D.speed || 1, R.loop = D.loop || R.loop, delete R.sprite;
    }
    if (R.offset && (R.start = R.offset), !this.isLoaded)
      return new Promise(function(B, $) {
        N.autoPlay = !0, N._autoPlayOptions = R, N._preload(function(U, H, z) {
          U ? $(U) : (R.loaded && R.loaded(U, H, z), B(z));
        });
      });
    (this.singleInstance || R.singleInstance) && this._removeInstances();
    var L = this._createInstance();
    return this._instances.push(L), this.isPlaying = !0, L.once("end", function() {
      R.complete && R.complete(N), N._onComplete(L);
    }), L.once("stop", function() {
      N._onComplete(L);
    }), L.play(R), L;
  }, o.prototype.refresh = function() {
    for (var t = this._instances.length, e = 0; e < t; e++)
      this._instances[e].refresh();
  }, o.prototype.refreshPaused = function() {
    for (var t = this._instances.length, e = 0; e < t; e++)
      this._instances[e].refreshPaused();
  }, Object.defineProperty(o.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(t) {
    this._volume = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(t) {
    this._muted = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(t) {
    this._loop = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), o.prototype._preload = function(t) {
    this.media.load(t);
  }, Object.defineProperty(o.prototype, "instances", { get: function() {
    return this._instances;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "sprites", { get: function() {
    return this._sprites;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "duration", { get: function() {
    return this.media.duration;
  }, enumerable: !1, configurable: !0 }), o.prototype.autoPlayStart = function() {
    var t;
    return this.autoPlay && (t = this.play(this._autoPlayOptions)), t;
  }, o.prototype._removeInstances = function() {
    for (var t = this._instances.length - 1; t >= 0; t--)
      this._poolInstance(this._instances[t]);
    this._instances.length = 0;
  }, o.prototype._onComplete = function(t) {
    if (this._instances) {
      var e = this._instances.indexOf(t);
      e > -1 && this._instances.splice(e, 1), this.isPlaying = this._instances.length > 0;
    }
    this._poolInstance(t);
  }, o.prototype._createInstance = function() {
    if (o._pool.length > 0) {
      var t = o._pool.pop();
      return t.init(this.media), t;
    }
    return this.media.create();
  }, o.prototype._poolInstance = function(t) {
    t.destroy(), o._pool.indexOf(t) < 0 && o._pool.push(t);
  }, o._pool = [], o;
}(), F = function(o) {
  function t() {
    var e = o !== null && o.apply(this, arguments) || this;
    return e.speed = 1, e.muted = !1, e.volume = 1, e.paused = !1, e;
  }
  return a(t, o), t.prototype.refresh = function() {
    this.emit("refresh");
  }, t.prototype.refreshPaused = function() {
    this.emit("refreshPaused");
  }, Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "audioContext", { get: function() {
    return null;
  }, enumerable: !1, configurable: !0 }), t.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, t.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this.paused;
  }, t.prototype.destroy = function() {
    this.removeAllListeners();
  }, t;
}(n), C = function(o) {
  function t() {
    var e = this, R = window, N = new t.AudioContext(), M = N.createDynamicsCompressor(), D = N.createAnalyser();
    return D.connect(M), M.connect(N.destination), (e = o.call(this, D, M) || this)._ctx = N, e._offlineCtx = new t.OfflineAudioContext(1, 2, R.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, N.sampleRate)) : 44100), e._unlocked = !1, e.compressor = M, e.analyser = D, e.events = new n(), e.volume = 1, e.speed = 1, e.muted = !1, e.paused = !1, N.state !== "running" && (e._unlock(), e._unlock = e._unlock.bind(e), document.addEventListener("mousedown", e._unlock, !0), document.addEventListener("touchstart", e._unlock, !0), document.addEventListener("touchend", e._unlock, !0)), e;
  }
  return a(t, o), t.prototype._unlock = function() {
    this._unlocked || (this.playEmptySound(), this._ctx.state === "running" && (document.removeEventListener("mousedown", this._unlock, !0), document.removeEventListener("touchend", this._unlock, !0), document.removeEventListener("touchstart", this._unlock, !0), this._unlocked = !0));
  }, t.prototype.playEmptySound = function() {
    var e = this._ctx.createBufferSource();
    e.buffer = this._ctx.createBuffer(1, 1, 22050), e.connect(this._ctx.destination), e.start(0, 0, 0), e.context.state === "suspended" && e.context.resume();
  }, Object.defineProperty(t, "AudioContext", { get: function() {
    var e = window;
    return e.AudioContext || e.webkitAudioContext || null;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "OfflineAudioContext", { get: function() {
    var e = window;
    return e.OfflineAudioContext || e.webkitOfflineAudioContext || null;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    o.prototype.destroy.call(this);
    var e = this._ctx;
    e.close !== void 0 && e.close(), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;
  }, Object.defineProperty(t.prototype, "audioContext", { get: function() {
    return this._ctx;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "offlineContext", { get: function() {
    return this._offlineCtx;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    e && this._ctx.state === "running" ? this._ctx.suspend() : e || this._ctx.state !== "suspended" || this._ctx.resume(), this._paused = e;
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    this.events.emit("refresh");
  }, t.prototype.refreshPaused = function() {
    this.events.emit("refreshPaused");
  }, t.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, t.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this._paused;
  }, t.prototype.decode = function(e, R) {
    var N = function(D) {
      R(new Error((D == null ? void 0 : D.message) || "Unable to decode file"));
    }, M = this._offlineCtx.decodeAudioData(e, function(D) {
      R(null, D);
    }, N);
    M && M.catch(N);
  }, t;
}(O), E = function() {
  function o() {
    this.init();
  }
  return o.prototype.init = function() {
    return this.supported && (this._webAudioContext = new C()), this._htmlAudioContext = new F(), this._sounds = {}, this.useLegacy = !this.supported, this;
  }, Object.defineProperty(o.prototype, "context", { get: function() {
    return this._context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "filtersAll", { get: function() {
    return this.useLegacy ? [] : this._context.filters;
  }, set: function(t) {
    this.useLegacy || (this._context.filters = t);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "supported", { get: function() {
    return C.AudioContext !== null;
  }, enumerable: !1, configurable: !0 }), o.prototype.add = function(t, e) {
    if (typeof t == "object") {
      var R = {};
      for (var N in t) {
        var M = this._getOptions(t[N], e);
        R[N] = this.add(N, M);
      }
      return R;
    }
    if (e instanceof A)
      return this._sounds[t] = e, e;
    var D = this._getOptions(e), L = A.from(D);
    return this._sounds[t] = L, L;
  }, o.prototype._getOptions = function(t, e) {
    var R;
    return R = typeof t == "string" ? { url: t } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? { source: t } : t, R = c(c({}, R), e || {});
  }, Object.defineProperty(o.prototype, "useLegacy", { get: function() {
    return this._useLegacy;
  }, set: function(t) {
    _.setLegacy(t), this._useLegacy = t, this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext;
  }, enumerable: !1, configurable: !0 }), o.prototype.remove = function(t) {
    return this.exists(t, !0), this._sounds[t].destroy(), delete this._sounds[t], this;
  }, Object.defineProperty(o.prototype, "volumeAll", { get: function() {
    return this._context.volume;
  }, set: function(t) {
    this._context.volume = t, this._context.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "speedAll", { get: function() {
    return this._context.speed;
  }, set: function(t) {
    this._context.speed = t, this._context.refresh();
  }, enumerable: !1, configurable: !0 }), o.prototype.togglePauseAll = function() {
    return this._context.togglePause();
  }, o.prototype.pauseAll = function() {
    return this._context.paused = !0, this._context.refreshPaused(), this;
  }, o.prototype.resumeAll = function() {
    return this._context.paused = !1, this._context.refreshPaused(), this;
  }, o.prototype.toggleMuteAll = function() {
    return this._context.toggleMute();
  }, o.prototype.muteAll = function() {
    return this._context.muted = !0, this._context.refresh(), this;
  }, o.prototype.unmuteAll = function() {
    return this._context.muted = !1, this._context.refresh(), this;
  }, o.prototype.removeAll = function() {
    for (var t in this._sounds)
      this._sounds[t].destroy(), delete this._sounds[t];
    return this;
  }, o.prototype.stopAll = function() {
    for (var t in this._sounds)
      this._sounds[t].stop();
    return this;
  }, o.prototype.exists = function(t, e) {
    return !!this._sounds[t];
  }, o.prototype.find = function(t) {
    return this.exists(t, !0), this._sounds[t];
  }, o.prototype.play = function(t, e) {
    return this.find(t).play(e);
  }, o.prototype.stop = function(t) {
    return this.find(t).stop();
  }, o.prototype.pause = function(t) {
    return this.find(t).pause();
  }, o.prototype.resume = function(t) {
    return this.find(t).resume();
  }, o.prototype.volume = function(t, e) {
    var R = this.find(t);
    return e !== void 0 && (R.volume = e), R.volume;
  }, o.prototype.speed = function(t, e) {
    var R = this.find(t);
    return e !== void 0 && (R.speed = e), R.speed;
  }, o.prototype.duration = function(t) {
    return this.find(t).duration;
  }, o.prototype.close = function() {
    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;
  }, o;
}(), S = function() {
  function o(t, e) {
    this.init(t, e);
  }
  return o.prototype.init = function(t, e) {
    this.destination = t, this.source = e || t;
  }, o.prototype.connect = function(t) {
    this.source.connect(t);
  }, o.prototype.disconnect = function() {
    this.source.disconnect();
  }, o.prototype.destroy = function() {
    this.disconnect(), this.destination = null, this.source = null;
  }, o;
}(), k = { __proto__: null, Filter: S, EqualizerFilter: function(o) {
  function t(e, R, N, M, D, L, B, $, U, H) {
    e === void 0 && (e = 0), R === void 0 && (R = 0), N === void 0 && (N = 0), M === void 0 && (M = 0), D === void 0 && (D = 0), L === void 0 && (L = 0), B === void 0 && (B = 0), $ === void 0 && ($ = 0), U === void 0 && (U = 0), H === void 0 && (H = 0);
    var z = this;
    if (!s().useLegacy) {
      var X = [{ f: t.F32, type: "lowshelf", gain: e }, { f: t.F64, type: "peaking", gain: R }, { f: t.F125, type: "peaking", gain: N }, { f: t.F250, type: "peaking", gain: M }, { f: t.F500, type: "peaking", gain: D }, { f: t.F1K, type: "peaking", gain: L }, { f: t.F2K, type: "peaking", gain: B }, { f: t.F4K, type: "peaking", gain: $ }, { f: t.F8K, type: "peaking", gain: U }, { f: t.F16K, type: "highshelf", gain: H }].map(function(q) {
        var Z = s().context.audioContext.createBiquadFilter();
        return Z.type = q.type, v.setParamValue(Z.Q, 1), Z.frequency.value = q.f, v.setParamValue(Z.gain, q.gain), Z;
      });
      (z = o.call(this, X[0], X[X.length - 1]) || this).bands = X, z.bandsMap = {};
      for (var Y = 0; Y < z.bands.length; Y++) {
        var W = z.bands[Y];
        Y > 0 && z.bands[Y - 1].connect(W), z.bandsMap[W.frequency.value] = W;
      }
      return z;
    }
    z = o.call(this, null) || this;
  }
  return a(t, o), t.prototype.setGain = function(e, R) {
    if (R === void 0 && (R = 0), !this.bandsMap[e])
      throw new Error("No band found for frequency ".concat(e));
    v.setParamValue(this.bandsMap[e].gain, R);
  }, t.prototype.getGain = function(e) {
    if (!this.bandsMap[e])
      throw new Error("No band found for frequency ".concat(e));
    return this.bandsMap[e].gain.value;
  }, Object.defineProperty(t.prototype, "f32", { get: function() {
    return this.getGain(t.F32);
  }, set: function(e) {
    this.setGain(t.F32, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f64", { get: function() {
    return this.getGain(t.F64);
  }, set: function(e) {
    this.setGain(t.F64, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f125", { get: function() {
    return this.getGain(t.F125);
  }, set: function(e) {
    this.setGain(t.F125, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f250", { get: function() {
    return this.getGain(t.F250);
  }, set: function(e) {
    this.setGain(t.F250, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f500", { get: function() {
    return this.getGain(t.F500);
  }, set: function(e) {
    this.setGain(t.F500, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f1k", { get: function() {
    return this.getGain(t.F1K);
  }, set: function(e) {
    this.setGain(t.F1K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f2k", { get: function() {
    return this.getGain(t.F2K);
  }, set: function(e) {
    this.setGain(t.F2K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f4k", { get: function() {
    return this.getGain(t.F4K);
  }, set: function(e) {
    this.setGain(t.F4K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f8k", { get: function() {
    return this.getGain(t.F8K);
  }, set: function(e) {
    this.setGain(t.F8K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f16k", { get: function() {
    return this.getGain(t.F16K);
  }, set: function(e) {
    this.setGain(t.F16K, e);
  }, enumerable: !1, configurable: !0 }), t.prototype.reset = function() {
    this.bands.forEach(function(e) {
      v.setParamValue(e.gain, 0);
    });
  }, t.prototype.destroy = function() {
    this.bands.forEach(function(e) {
      e.disconnect();
    }), this.bands = null, this.bandsMap = null;
  }, t.F32 = 32, t.F64 = 64, t.F125 = 125, t.F250 = 250, t.F500 = 500, t.F1K = 1e3, t.F2K = 2e3, t.F4K = 4e3, t.F8K = 8e3, t.F16K = 16e3, t;
}(S), DistortionFilter: function(o) {
  function t(e) {
    e === void 0 && (e = 0);
    var R = this;
    if (!s().useLegacy) {
      var N = s().context.audioContext.createWaveShaper();
      return (R = o.call(this, N) || this)._distortion = N, R.amount = e, R;
    }
    R = o.call(this, null) || this;
  }
  return a(t, o), Object.defineProperty(t.prototype, "amount", { get: function() {
    return this._amount;
  }, set: function(e) {
    this._amount = e;
    for (var R, N = 1e3 * e, M = 44100, D = new Float32Array(M), L = Math.PI / 180, B = 0; B < M; ++B)
      R = 2 * B / M - 1, D[B] = (3 + N) * R * 20 * L / (Math.PI + N * Math.abs(R));
    this._distortion.curve = D, this._distortion.oversample = "4x";
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this._distortion = null, o.prototype.destroy.call(this);
  }, t;
}(S), StereoFilter: function(o) {
  function t(e) {
    e === void 0 && (e = 0);
    var R = this;
    if (!s().useLegacy) {
      var N, M, D, L = s().context.audioContext;
      return L.createStereoPanner ? D = N = L.createStereoPanner() : ((M = L.createPanner()).panningModel = "equalpower", D = M), (R = o.call(this, D) || this)._stereo = N, R._panner = M, R.pan = e, R;
    }
    R = o.call(this, null) || this;
  }
  return a(t, o), Object.defineProperty(t.prototype, "pan", { get: function() {
    return this._pan;
  }, set: function(e) {
    this._pan = e, this._stereo ? v.setParamValue(this._stereo.pan, e) : this._panner.setPosition(e, 0, 1 - Math.abs(e));
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    o.prototype.destroy.call(this), this._stereo = null, this._panner = null;
  }, t;
}(S), ReverbFilter: function(o) {
  function t(e, R, N) {
    e === void 0 && (e = 3), R === void 0 && (R = 2), N === void 0 && (N = !1);
    var M = this;
    if (!s().useLegacy)
      return (M = o.call(this, null) || this)._seconds = M._clamp(e, 1, 50), M._decay = M._clamp(R, 0, 100), M._reverse = N, M._rebuild(), M;
    M = o.call(this, null) || this;
  }
  return a(t, o), t.prototype._clamp = function(e, R, N) {
    return Math.min(N, Math.max(R, e));
  }, Object.defineProperty(t.prototype, "seconds", { get: function() {
    return this._seconds;
  }, set: function(e) {
    this._seconds = this._clamp(e, 1, 50), this._rebuild();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "decay", { get: function() {
    return this._decay;
  }, set: function(e) {
    this._decay = this._clamp(e, 0, 100), this._rebuild();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "reverse", { get: function() {
    return this._reverse;
  }, set: function(e) {
    this._reverse = e, this._rebuild();
  }, enumerable: !1, configurable: !0 }), t.prototype._rebuild = function() {
    for (var e, R = s().context.audioContext, N = R.sampleRate, M = N * this._seconds, D = R.createBuffer(2, M, N), L = D.getChannelData(0), B = D.getChannelData(1), $ = 0; $ < M; $++)
      e = this._reverse ? M - $ : $, L[$] = (2 * Math.random() - 1) * Math.pow(1 - e / M, this._decay), B[$] = (2 * Math.random() - 1) * Math.pow(1 - e / M, this._decay);
    var U = s().context.audioContext.createConvolver();
    U.buffer = D, this.init(U);
  }, t;
}(S), MonoFilter: function(o) {
  function t() {
    var e = this;
    if (!s().useLegacy) {
      var R = s().context.audioContext, N = R.createChannelSplitter(), M = R.createChannelMerger();
      return M.connect(N), (e = o.call(this, M, N) || this)._merger = M, e;
    }
    e = o.call(this, null) || this;
  }
  return a(t, o), t.prototype.destroy = function() {
    this._merger.disconnect(), this._merger = null, o.prototype.destroy.call(this);
  }, t;
}(S), StreamFilter: function(o) {
  function t() {
    var e = this;
    if (!s().useLegacy) {
      var R = s().context.audioContext, N = R.createMediaStreamDestination(), M = R.createMediaStreamSource(N.stream);
      return (e = o.call(this, N, M) || this)._stream = N.stream, e;
    }
    e = o.call(this, null) || this;
  }
  return a(t, o), Object.defineProperty(t.prototype, "stream", { get: function() {
    return this._stream;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this._stream = null, o.prototype.destroy.call(this);
  }, t;
}(S), TelephoneFilter: function(o) {
  function t() {
    if (!s().useLegacy) {
      var e = s().context.audioContext, R = e.createBiquadFilter(), N = e.createBiquadFilter(), M = e.createBiquadFilter(), D = e.createBiquadFilter();
      return R.type = "lowpass", v.setParamValue(R.frequency, 2e3), N.type = "lowpass", v.setParamValue(N.frequency, 2e3), M.type = "highpass", v.setParamValue(M.frequency, 500), D.type = "highpass", v.setParamValue(D.frequency, 500), R.connect(N), N.connect(M), M.connect(D), o.call(this, R, D) || this;
    }
    o.call(this, null);
  }
  return a(t, o), t;
}(S) }, T = 0, G = { __proto__: null, playOnce: function(o, t) {
  var e = "alias".concat(T++);
  return s().add(e, { url: o, preload: !0, autoPlay: !0, loaded: function(R) {
    R && (s().remove(e), t && t(R));
  }, complete: function() {
    s().remove(e), t && t(null);
  } }), e;
}, get PLAY_ID() {
  return T;
}, render: function(o, t) {
  var e = document.createElement("canvas");
  t = c({ width: 512, height: 128, fill: "black" }, t || {}), e.width = t.width, e.height = t.height;
  var R = BaseTexture.from(e);
  if (!(o.media instanceof w))
    return R;
  var N = o.media, M = e.getContext("2d");
  M.fillStyle = t.fill;
  for (var D = N.buffer.getChannelData(0), L = Math.ceil(D.length / t.width), B = t.height / 2, $ = 0; $ < t.width; $++) {
    for (var U = 1, H = -1, z = 0; z < L; z++) {
      var X = D[$ * L + z];
      X < U && (U = X), X > H && (H = X);
    }
    M.fillRect($, (1 + U) * B, 1, Math.max(1, (H - U) * B));
  }
  return R;
}, resolveUrl: d, sineTone: function(o, t) {
  o === void 0 && (o = 200), t === void 0 && (t = 1);
  var e = A.from({ singleInstance: !0 });
  if (!(e.media instanceof w))
    return e;
  for (var R = e.media, N = e.context.audioContext.createBuffer(1, 48e3 * t, 48e3), M = N.getChannelData(0), D = 0; D < M.length; D++) {
    var L = o * (D / N.sampleRate) * Math.PI;
    M[D] = 2 * Math.sin(L);
  }
  return R.buffer = N, e.isLoaded = !0, e;
}, validateFormats: h, supported: p, extensions: l }, I = function(o) {
  return r = o, o;
}(new E());
Loader.registerPlugin(_);
var Ee, Fe, Ti, Ru, hc, cs, Zo, Pu, cc, Au, fc, za, dh, sn, ma, ja, ph, fs, ds, Ko, an, ya, Va, ps, Jo, Ou, dc, Dr, _i, Nu, pc, Xa, vh, un, ba, Mu, vc, Wa, gh, Du, gc, Lu, mc, vs, Qo;
const Pa = class {
  constructor(t, e, R, N, M) {
    nt(this, Ru);
    nt(this, cs);
    nt(this, Pu);
    nt(this, Au);
    nt(this, za);
    nt(this, sn);
    nt(this, ja);
    nt(this, ds);
    nt(this, an);
    nt(this, ps);
    nt(this, Ou);
    nt(this, Dr);
    nt(this, Nu);
    nt(this, Xa);
    nt(this, un);
    nt(this, Mu);
    nt(this, Wa);
    nt(this, Du);
    nt(this, Lu);
    nt(this, vs);
    nt(this, Ee, {});
    nt(this, Fe, {});
    nt(this, Ti, void 0);
    nt(this, Va, () => {
      I.volumeAll = Number(this.val.getVal("sys:sn.sound.global_volume", 1)), it(this, Va, () => {
      });
    });
    this.cfg = t, this.val = R, this.main = N, this.sys = M, e.volume = (D) => ot(this, Ru, hc).call(this, D), e.fadebgm = (D) => ot(this, za, dh).call(this, D), e.fadeoutbgm = (D) => ot(this, Pu, cc).call(this, D), e.fadeoutse = (D) => ot(this, Au, fc).call(this, D), e.fadese = (D) => ot(this, sn, ma).call(this, D), e.playbgm = (D) => ot(this, ja, ph).call(this, D), e.playse = (D) => ot(this, ds, Ko).call(this, D), e.stop_allse = () => ot(this, ps, Jo).call(this), e.stopbgm = (D) => ot(this, Ou, dc).call(this, D), e.stopse = (D) => ot(this, Dr, _i).call(this, D), e.wb = (D) => ot(this, Nu, pc).call(this, D), e.wf = (D) => ot(this, Xa, vh).call(this, D), e.stopfadese = (D) => ot(this, un, ba).call(this, D), e.wl = (D) => ot(this, Mu, vc).call(this, D), e.ws = (D) => ot(this, Wa, gh).call(this, D), e.xchgbuf = (D) => ot(this, Du, gc).call(this, D), this.val.setVal_Nochk("save", "const.sn.loopPlaying", "{}"), R.setVal_Nochk("tmp", "const.sn.sound.codecs", JSON.stringify(G.supported));
  }
  setEvtMng(t) {
    it(this, Ti, t);
  }
  setNoticeChgVolume(t, e) {
    this.val.defValTrg("sys:sn.sound.global_volume", (R, N) => t(I.volumeAll = Number(N))), this.val.defValTrg("sys:sn.sound.movie_volume", (R, N) => e(Number(N))), this.val.setVal_Nochk("sys", "sn.sound.global_volume", this.val.getVal("sys:sn.sound.global_volume", 1)), this.val.setVal_Nochk("sys", "sn.sound.movie_volume", this.val.getVal("sys:sn.sound.movie_volume", 1));
  }
  clearCache() {
    I.removeAll();
  }
  loadAheadSnd(t) {
    [t.clickse, t.enterse, t.leavese].forEach((e) => {
      !e || I.exists(e) || ot(this, an, ya).call(this, "", e, { preload: !0, autoPlay: !1 });
    });
  }
  playLoopFromSaveObj() {
    const t = String(this.val.getVal("save:const.sn.loopPlaying", "{}"));
    if (this.val.flush(), t === "{}") {
      ot(this, ps, Jo).call(this);
      return;
    }
    const e = [];
    it(this, Fe, JSON.parse(t));
    for (const R in V(this, Fe)) {
      const N = "save:const.sn.sound." + R + ".", M = {
        fn: String(this.val.getVal(N + "fn")),
        buf: R,
        join: !1,
        loop: !0,
        volume: Number(this.val.getVal(N + "volume")),
        start_ms: Number(this.val.getVal(N + "start_ms")),
        end_ms: Number(this.val.getVal(N + "end_ms")),
        ret_ms: Number(this.val.getVal(N + "ret_ms"))
      };
      e.push(() => {
        M.buf === "BGM" ? ot(this, ja, ph).call(this, M) : ot(this, ds, Ko).call(this, M);
      });
    }
    ot(this, ps, Jo).call(this), e.forEach((R) => R());
  }
};
let SoundMng = Pa;
Ee = new WeakMap(), Fe = new WeakMap(), Ti = new WeakMap(), Ru = new WeakSet(), hc = function(t) {
  const { buf: e = "SE" } = t, R = "const.sn.sound." + e + ".volume", N = ot(this, cs, Zo).call(this, t, 1);
  return Number(this.val.getVal("sys:" + R)) === N ? !1 : (this.val.setVal_Nochk("sys", R, N), this.val.flush(), t.time = 0, t.volume = Number(this.val.getVal("save:" + R)), ot(this, sn, ma).call(this, t));
}, cs = new WeakSet(), Zo = function(t, e) {
  const R = argChk_Num(t, "volume", e);
  return R < 0 ? 0 : R > 1 ? 1 : R;
}, Pu = new WeakSet(), cc = function(t) {
  return t.volume = 0, ot(this, za, dh).call(this, t);
}, Au = new WeakSet(), fc = function(t) {
  return t.volume = 0, ot(this, sn, ma).call(this, t);
}, za = new WeakSet(), dh = function(t) {
  return t.buf = "BGM", ot(this, sn, ma).call(this, t);
}, sn = new WeakSet(), ma = function(t) {
  ot(this, un, ba).call(this, t);
  const { buf: e = "SE" } = t, R = V(this, Ee)[e];
  if (!(R != null && R.playing()) || !R.snd)
    return !1;
  const N = "const.sn.sound." + e + ".volume", M = ot(this, cs, Zo).call(this, t, NaN);
  this.val.setVal_Nochk("save", N, M);
  const D = M * Number(this.val.getVal("sys:" + N, 1)), L = argChk_Boolean(t, "stop", M === 0);
  L && (ot(this, vs, Qo).call(this, e), this.val.setVal_Nochk("save", "const.sn.sound." + e + ".fn", "")), this.val.flush();
  const B = argChk_Num(t, "time", NaN), $ = argChk_Num(t, "delay", 0);
  if (B === 0 && $ === 0 || this.val.getVal("tmp:sn.skip.enabled") || V(this, Ti).isSkippingByKeyDown())
    return R.snd.volume = D, L && ot(this, Dr, _i).call(this, t), !1;
  const U = argChk_Num(t, "repeat", 1);
  return R.twFade = new Tween({ v: R.snd.volume }).to({ v: D }, B).delay($).easing(CmnTween.ease(t.ease)).repeat(U === 0 ? 1 / 0 : U - 1).yoyo(argChk_Boolean(t, "yoyo", !1)).onUpdate((H) => {
    R.playing() && (R.snd.volume = H.v);
  }).onComplete(() => {
    const H = V(this, Ee)[t.buf = R.now_buf];
    !(H != null && H.twFade) || (delete H.twFade, L && ot(this, Dr, _i).call(this, t), H.resumeFade && this.main.resume());
  }).start(), !1;
}, ja = new WeakSet(), ph = function(t) {
  return t.buf = "BGM", t.canskip = !1, argChk_Boolean(t, "loop", !0), ot(this, ds, Ko).call(this, t);
}, fs = new WeakMap(), ds = new WeakSet(), Ko = function(t) {
  var Z;
  const { buf: e = "SE", fn: R } = t;
  if (ot(this, Dr, _i).call(this, { buf: e }), !R)
    throw `[playse] fn\u306F\u5FC5\u9808\u3067\u3059 buf:${e}`;
  if (argChk_Boolean(t, "canskip", !0) && V(this, Ti).isSkippingByKeyDown())
    return !1;
  const N = argChk_Boolean(t, "loop", !1);
  ot(this, Lu, mc).call(this, e, N);
  const M = "const.sn.sound." + e + ".";
  this.val.setVal_Nochk("save", M + "fn", R);
  const D = ot(this, cs, Zo).call(this, t, 1);
  this.val.setVal_Nochk("save", M + "volume", D);
  const L = D * Number(this.val.getVal("sys:" + M + "volume", 1)), B = argChk_Num(t, "start_ms", 0), $ = argChk_Num(t, "end_ms", V(Pa, fs)), U = argChk_Num(t, "ret_ms", 0), H = argChk_Num(t, "pan", 0);
  if (B < 0)
    throw `[playse] start_ms:${B} \u304C\u8CA0\u306E\u5024\u3067\u3059`;
  if (U < 0)
    throw `[playse] ret_ms:${U} \u304C\u8CA0\u306E\u5024\u3067\u3059`;
  if ($ > 0) {
    if (B >= $)
      throw `[playse] start_ms:${B} >= end_ms:${$} \u306F\u7570\u5E38\u5024\u3067\u3059`;
    if (U >= $)
      throw `[playse] ret_ms:${U} >= end_ms:${$} \u306F\u7570\u5E38\u5024\u3067\u3059`;
  }
  this.val.setVal_Nochk("save", M + "start_ms", B), this.val.setVal_Nochk("save", M + "end_ms", $), this.val.setVal_Nochk("save", M + "ret_ms", U), this.val.flush();
  const z = I.find(R), X = V(this, Ee)[e] = {
    now_buf: e,
    snd: z,
    loop: N,
    start_ms: B,
    end_ms: $,
    ret_ms: U,
    resume: !1,
    pan: H,
    playing: () => !0,
    onend: () => {
      const K = V(this, Ee)[t.buf = X.now_buf];
      !K || (delete V(this, Ee)[t.buf], K.playing = () => !1, ot(this, un, ba).call(this, t), K.resume && this.main.resume());
    }
  }, Y = {
    loop: N,
    volume: L,
    loaded: (K, J) => {
      if (K) {
        this.main.errScript(`Sound \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059a fn:${R} ${K}`, !1);
        return;
      }
      if (!J)
        return;
      const Q = V(this, Ee)[X.now_buf];
      Q && (Q.snd = J);
    }
  };
  "speed" in t && (Y.speed = argChk_Num(t, "speed", 1));
  let W = "";
  if (B > 0 || $ < V(Pa, fs)) {
    W = `${R};${B};${$};${U}`;
    const K = ((Z = Y.sprites) != null ? Z : Y.sprites = {})[W] = {
      start: B / 1e3,
      end: $ / 1e3
    };
    Y.preload = !0;
    const J = Y.loaded;
    Y.loaded = (Q, et) => {
      if (Q) {
        this.main.errScript(`Sound \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059b fn:${R} ${Q}`, !1);
        return;
      }
      if (!et)
        return;
      const tt = et.duration;
      if (J == null || J(Q, et), K.end < 0) {
        if (K.end += tt, et.removeSprites(W), et.addSprites(W, K), K.start >= K.end)
          throw `[playse] start_ms:${B} >= end_ms:${$}(${K.end * 1e3}) \u306F\u7570\u5E38\u5024\u3067\u3059`;
        if (U >= K.end * 1e3)
          throw `[playse] ret_ms:${U} >= end_ms:${$}(${K.end * 1e3}) \u306F\u7570\u5E38\u5024\u3067\u3059`;
      }
      if (K.start >= tt)
        throw `[playse] start_ms:${B} >= \u97F3\u58F0\u30D5\u30A1\u30A4\u30EB\u518D\u751F\u6642\u9593:${tt} \u306F\u7570\u5E38\u5024\u3067\u3059`;
      if ($ !== V(Pa, fs) && K.end >= tt)
        throw `[playse] end_ms:${$} >= \u97F3\u58F0\u30D5\u30A1\u30A4\u30EB\u518D\u751F\u6642\u9593:${tt} \u306F\u7570\u5E38\u5024\u3067\u3059`;
      et.play(W, Y.complete);
    };
  } else
    Y.autoPlay = !0;
  if (N ? U !== 0 && (Y.loop = !1, Y.complete = (K) => {
    const J = K.duration, Q = `${R};loop2;${$};${U}`, et = {
      preload: !0,
      loop: !0,
      volume: L,
      speed: Y.speed,
      sprites: {},
      loaded: (st, rt) => {
        if (!rt)
          return;
        const at = V(this, Ee)[X.now_buf];
        at && (at.snd = rt), rt.play(Q);
      }
    }, tt = et.sprites[Q] = {
      start: U / 1e3,
      end: $ / 1e3
    };
    if (tt.end < 0 && (tt.end += J, K.removeSprites(Q), K.addSprites(Q, tt)), tt.start >= J)
      throw `[playse] ret_ms:${U} >= \u97F3\u58F0\u30D5\u30A1\u30A4\u30EB\u518D\u751F\u6642\u9593:${J} \u306F\u7570\u5E38\u5024\u3067\u3059`;
    ot(this, an, ya).call(this, e, R, et);
  }) : Y.complete = () => {
    var K;
    return (K = V(this, Ee)[X.now_buf]) == null ? void 0 : K.onend();
  }, V(this, Va).call(this), z) {
    if (z.volume = L, W)
      ot(this, an, ya).call(this, e, R, Y);
    else if (z.isPlayable) {
      const K = z.options.source;
      !(K instanceof ArrayBuffer) || K.byteLength === 0 ? z.play(Y) : X.snd = A.from({
        ...Y,
        url: z.options.url,
        source: K
      }), z.filters = [new k.StereoFilter(H)];
    }
    return !1;
  }
  const q = argChk_Boolean(t, "join", !0);
  if (q) {
    const K = Y.loaded;
    Y.loaded = (J, Q) => {
      K == null || K(J, Q), this.main.resume();
    };
  }
  return ot(this, an, ya).call(this, e, R, Y), q;
}, an = new WeakSet(), ya = function(t, e, R) {
  const N = this.cfg.searchPath(e, Config.EXT_SOUND);
  if (N.slice(-4) !== ".bin") {
    R.url = N;
    const M = A.from(R);
    if (t) {
      const D = V(this, Ee)[t];
      D.snd = M, D.pan !== 0 && (M.filters = [new k.StereoFilter(D.pan)]);
    }
    R.loop || I.add(e, M);
    return;
  }
  new Loader().add({ name: e, url: N, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).use((M, D) => {
    this.sys.dec(M.extension, M.data).then((L) => {
      M.data = L, D == null || D();
    }).catch((L) => this.main.errScript(`Sound \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 fn:${M.name} ${L}`, !1));
  }).load((M, D) => {
    var B;
    R.source = (B = D[e]) == null ? void 0 : B.data;
    const L = A.from(R);
    if (t) {
      const $ = V(this, Ee)[t];
      $.snd = L, $.pan !== 0 && (L.filters = [new k.StereoFilter($.pan)]);
    }
    R.loop || I.add(e, L);
  });
}, Va = new WeakMap(), ps = new WeakSet(), Jo = function() {
  for (const t in V(this, Ee))
    ot(this, Dr, _i).call(this, { buf: t });
  return it(this, Ee, {}), I.stopAll(), !1;
}, Ou = new WeakSet(), dc = function(t) {
  return t.buf = "BGM", ot(this, Dr, _i).call(this, t);
}, Dr = new WeakSet(), _i = function(t) {
  var N;
  const { buf: e = "SE" } = t;
  ot(this, vs, Qo).call(this, e);
  const R = V(this, Ee)[e];
  return R && ((N = R.snd) == null || N.stop(), R.onend()), !1;
}, Nu = new WeakSet(), pc = function(t) {
  return t.buf = "BGM", ot(this, Xa, vh).call(this, t);
}, Xa = new WeakSet(), vh = function(t) {
  const { buf: e = "SE" } = t, R = V(this, Ee)[e];
  return !(R != null && R.twFade) || !R.playing() ? !1 : R.resumeFade = V(this, Ti).waitEvent(
    () => ot(this, un, ba).call(this, t),
    argChk_Boolean(t, "canskip", !0),
    argChk_Boolean(t, "global", !1)
  );
}, un = new WeakSet(), ba = function(t) {
  var R, N;
  const { buf: e = "SE" } = t;
  return (N = (R = V(this, Ee)[e]) == null ? void 0 : R.twFade) == null || N.stop().end(), !1;
}, Mu = new WeakSet(), vc = function(t) {
  return t.buf = "BGM", ot(this, Wa, gh).call(this, t);
}, Wa = new WeakSet(), gh = function(t) {
  const { buf: e = "SE" } = t, R = V(this, Ee)[e];
  return !(R != null && R.playing()) || R.loop ? !1 : R.resume = V(this, Ti).waitEvent(
    () => {
      t.buf = R.now_buf, ot(this, Dr, _i).call(this, t);
      const N = V(this, Ee)[t.buf];
      !(N != null && N.playing()) || N.loop || N.onend();
    },
    argChk_Boolean(t, "canskip", !1),
    argChk_Boolean(t, "global", !1)
  );
}, Du = new WeakSet(), gc = function(t) {
  const { buf: e = "SE", buf2: R = "SE" } = t;
  if (e === R)
    return !1;
  const N = V(this, Ee)[e];
  N && (N.now_buf = R);
  const M = V(this, Ee)[R];
  M && (M.now_buf = e), [V(this, Ee)[e], V(this, Ee)[R]] = [M, N];
  const D = "const.sn.sound." + e + ".", L = Number(this.val.getVal("save:" + D + "volume")), B = Number(this.val.getVal("save:" + D + "fn")), $ = "const.sn.sound." + R + ".", U = Number(this.val.getVal("save:" + $ + "volume")), H = Number(this.val.getVal("save:" + $ + "fn"));
  return this.val.setVal_Nochk("save", D + "volume", U), this.val.setVal_Nochk("save", $ + "volume", L), this.val.setVal_Nochk("save", D + "fn", H), this.val.setVal_Nochk("save", $ + "fn", B), e in V(this, Fe) == R in V(this, Fe) && (e in V(this, Fe) ? (delete V(this, Fe)[e], V(this, Fe)[R] = 0) : (delete V(this, Fe)[R], V(this, Fe)[e] = 0), this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(V(this, Fe)))), this.val.flush(), !1;
}, Lu = new WeakSet(), mc = function(t, e) {
  if (!e) {
    ot(this, vs, Qo).call(this, t);
    return;
  }
  V(this, Fe)[t] = 0, this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(V(this, Fe))), this.val.flush();
}, vs = new WeakSet(), Qo = function(t) {
  delete V(this, Fe)[t], this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(V(this, Fe))), this.val.flush();
}, nt(SoundMng, fs, 999e3);
var ue;
const jh = class {
  constructor(t, e, R, N, M, D, L, B) {
    nt(this, ue, void 0);
    this.cls = e, this.hArg = M, this.sys = D, this.val = L, this.ret = B, this.lay = (z) => this.getPage(z).lay(z), this.getPage = (z) => jh.argChk_page(z, "fore") !== "back" ? V(this, ue).fore : V(this, ue).back;
    const $ = D.hFactoryCls[e];
    if (!$)
      throw `\u5C5E\u6027 class\u3010${e}\u3011\u304C\u4E0D\u6B63\u3067\u3059`;
    it(this, ue, { fore: $(), back: $() }), V(this, ue).fore.layname = V(this, ue).back.layname = t;
    const U = M[":id_tag"] = `layer:${t} cls:${e}`;
    V(this, ue).fore.name = `${U} page:A`, V(this, ue).back.name = `${U} page:B`, R.addChild(this.fore.spLay), N.addChild(this.back.spLay), argChk_Boolean(M, "visible", !0), argChk_Boolean(M, "visible", !0), B.isWait = this.fore.lay(M) || this.back.lay(M);
    const H = `const.sn.lay.${t}`;
    L.setVal_Nochk("tmp", H, !0), L.defTmp(H + ".fore.alpha", () => V(this, ue).fore.alpha), L.defTmp(H + ".back.alpha", () => V(this, ue).back.alpha), L.defTmp(H + ".fore.height", () => V(this, ue).fore.height), L.defTmp(H + ".back.height", () => V(this, ue).back.height), L.defTmp(H + ".fore.visible", () => V(this, ue).fore.spLay.visible), L.defTmp(H + ".back.visible", () => V(this, ue).back.spLay.visible), L.defTmp(H + ".fore.width", () => V(this, ue).fore.width), L.defTmp(H + ".back.width", () => V(this, ue).back.width), L.defTmp(H + ".fore.x", () => V(this, ue).fore.x), L.defTmp(H + ".back.x", () => V(this, ue).back.x), L.defTmp(H + ".fore.y", () => V(this, ue).fore.y), L.defTmp(H + ".back.y", () => V(this, ue).back.y);
  }
  destroy() {
    V(this, ue).fore.destroy(), V(this, ue).back.destroy();
  }
  static argChk_page(t, e) {
    var N;
    const R = (N = t.page) != null ? N : e;
    if (R === "fore" || R === "back")
      return t.page = R;
    throw Error("\u5C5E\u6027 page\u3010" + R + "\u3011\u304C\u4E0D\u6B63\u3067\u3059");
  }
  get fore() {
    return V(this, ue).fore;
  }
  get back() {
    return V(this, ue).back;
  }
  transPage(t) {
    [V(this, ue).back, V(this, ue).fore] = [V(this, ue).fore, V(this, ue).back], V(this, ue).back.copy(V(this, ue).fore, t);
  }
};
let Pages = jh;
ue = new WeakMap();
var Fu, Bu;
const yi = class {
  constructor() {
    this.layname = "", this.name_ = "", this.spLay = new Sprite(Texture.EMPTY);
  }
  set name(t) {
    this.name_ = t;
  }
  get name() {
    return this.name_;
  }
  get alpha() {
    return this.spLay.alpha;
  }
  set alpha(t) {
    this.spLay.alpha = t;
  }
  get height() {
    return this.spLay.height;
  }
  get rotation() {
    return this.spLay.angle;
  }
  set rotation(t) {
    this.spLay.angle = t;
  }
  get scale_x() {
    return this.spLay.scale.x;
  }
  set scale_x(t) {
    this.spLay.scale.x = t;
  }
  get scale_y() {
    return this.spLay.scale.y;
  }
  set scale_y(t) {
    this.spLay.scale.y = t;
  }
  get width() {
    return this.spLay.width;
  }
  get x() {
    return this.spLay.x;
  }
  set x(t) {
    this.spLay.x = t;
  }
  get y() {
    return this.spLay.y;
  }
  set y(t) {
    this.spLay.y = t;
  }
  destroy() {
  }
  lay(t) {
    return "alpha" in t && (this.spLay.alpha = argChk_Num(t, "alpha", 1)), yi.setBlendmode(this.spLay, t), ("pivot_x" in t || "pivot_y" in t) && this.spLay.pivot.set(
      argChk_Num(t, "pivot_x", this.spLay.pivot.x),
      argChk_Num(t, "pivot_y", this.spLay.pivot.y)
    ), "rotation" in t && (this.spLay.angle = argChk_Num(t, "rotation", 0)), ("scale_x" in t || "scale_y" in t) && this.spLay.scale.set(
      argChk_Num(t, "scale_x", this.spLay.scale.x),
      argChk_Num(t, "scale_y", this.spLay.scale.y)
    ), "visible" in t && (this.spLay.visible = argChk_Boolean(t, "visible", !0)), !1;
  }
  static setBlendmode(t, e) {
    const { blendmode: R } = e;
    if (!R)
      return;
    const N = yi.getBlendmodeNum(R);
    t instanceof Sprite && (t.blendMode = N), t.children.forEach((M) => {
      M instanceof Sprite && (M.blendMode = N);
    });
  }
  static getBlendmodeNum(t) {
    if (!t)
      return BLEND_MODES$5.NORMAL;
    const e = V(yi, Fu)[t];
    if (e !== void 0)
      return e;
    throw `${t} \u306F\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u306A\u3044 blendmode \u3067\u3059`;
  }
  static getNum2Blendmode(t) {
    var e;
    return (e = V(yi, Bu)[t]) != null ? e : "normal";
  }
  get containMovement() {
    return !1;
  }
  renderStart() {
  }
  renderEnd() {
  }
  clearLay(t) {
    this.spLay.alpha = 1, this.spLay.blendMode = BLEND_MODES$5.NORMAL, this.spLay.pivot.set(0, 0), this.spLay.angle = 0, this.spLay.scale.set(1, 1), argChk_Boolean(t, "filter", !1) && (this.spLay.filters = []);
  }
  copy(t, e) {
    const R = this.name_;
    this.playback(t.record(), e), this.name = R;
  }
  record() {
    return {
      name: this.name_,
      idx: this.spLay.parent.getChildIndex(this.spLay),
      alpha: this.spLay.alpha,
      blendMode: this.spLay.blendMode,
      rotation: this.spLay.angle,
      scale_x: this.spLay.scale.x,
      scale_y: this.spLay.scale.y,
      pivot_x: this.spLay.pivot.x,
      pivot_y: this.spLay.pivot.y,
      x: this.spLay.x,
      y: this.spLay.y,
      visible: this.spLay.visible
    };
  }
  playback(t, e) {
    this.name = t.name, this.clearLay({ filter: "true" }), this.spLay.alpha = t.alpha, this.spLay.blendMode = t.blendMode, this.spLay.angle = t.rotation, this.spLay.scale.set(t.scale_x, t.scale_y), this.spLay.pivot.set(t.pivot_x, t.pivot_y), this.spLay.position.set(t.x, t.y), this.spLay.visible = t.visible;
  }
  snapshot(t, e) {
    t.render(this.spLay, { clear: !1 }), e();
  }
  snapshot_end() {
  }
  makeDesignCast(t) {
  }
  makeDesignCastChildren(t) {
  }
  showDesignCast() {
  }
  showDesignCastChildren() {
  }
  cvsResize() {
  }
  cvsResizeChildren() {
  }
  dump() {
    return ` "idx":${this.spLay.parent.getChildIndex(this.spLay)}, "visible":"${this.spLay.visible}", "left":${this.spLay.x}, "top":${this.spLay.y}, "alpha":${this.spLay.alpha}, "rotation":${this.spLay.angle}, "name":"${this.name_}", "scale_x":${this.spLay.scale.x}, "scale_y":${this.spLay.scale.y}`;
  }
  static setXY(t, e, R, N = !1, M = !1) {
    if (e.pos) {
      yi.setXYByPos(t, e.pos, R);
      return;
    }
    const D = t.getBounds(), L = R.scale.x < 0 ? -R.scale.x : R.scale.x, B = L === 1 ? D.width : D.width * L, $ = R.scale.y < 0 ? -R.scale.y : R.scale.y, U = $ === 1 ? D.height : D.height * $;
    let H = R.x;
    "left" in e ? (H = argChk_Num(e, "left", 0), H > -1 && H < 1 && (H *= CmnLib.stageW)) : "center" in e ? (H = argChk_Num(e, "center", 0), H > -1 && H < 1 && (H *= CmnLib.stageW), H = H - (M ? B / 3 : B) / 2) : "right" in e ? (H = argChk_Num(e, "right", 0), H > -1 && H < 1 && (H *= CmnLib.stageW), H = H - (M ? B / 3 : B)) : "s_right" in e && (H = argChk_Num(e, "s_right", 0), H > -1 && H < 1 && (H *= CmnLib.stageW), H = CmnLib.stageW - H - (M ? B / 3 : B)), R.x = int(R.scale.x < 0 ? H + (M ? B / 3 : B) : H);
    let z = R.y;
    "top" in e ? (z = argChk_Num(e, "top", 0), z > -1 && z < 1 && (z *= CmnLib.stageH)) : "middle" in e ? (z = argChk_Num(e, "middle", 0), z > -1 && z < 1 && (z *= CmnLib.stageH), z = z - U / 2) : "bottom" in e ? (z = argChk_Num(e, "bottom", 0), z > -1 && z < 1 && (z *= CmnLib.stageH), z = z - U) : "s_bottom" in e && (z = argChk_Num(e, "s_bottom", 0), z > -1 && z < 1 && (z *= CmnLib.stageH), z = CmnLib.stageH - z - U), R.y = int(R.scale.y < 0 ? z + U : z), N && !("left" in e) && !("center" in e) && !("right" in e) && !("s_right" in e) && !("top" in e) && !("middle" in e) && !("bottom" in e) && !("s_bottom" in e) && yi.setXYByPos(t, "c", R);
  }
  static setXYByPos(t, e, R) {
    if (e === "stay")
      return;
    if (t === void 0)
      throw "setXYByPos base === undefined";
    if (R === void 0)
      throw "setXYByPos result === undefined";
    const N = t.getBounds(), M = R.scale.x < 0 ? -R.scale.x : R.scale.x, D = M === 1 ? N.width : N.width * M, L = R.scale.y < 0 ? -R.scale.y : R.scale.y, B = L === 1 ? N.height : N.height * L;
    let $ = 0;
    !e || e === "c" ? $ = CmnLib.stageW * 0.5 : e === "r" ? $ = CmnLib.stageW - D * 0.5 : e === "l" ? $ = D * 0.5 : $ = int(e), R.x = int($ - D * 0.5), R.y = CmnLib.stageH - B, R.scale.x < 0 && (R.x += D), R.scale.y < 0 && (R.y += B);
  }
  static setXYCenter(t) {
    const e = t.getBounds();
    t.x = (CmnLib.stageW - e.width) * 0.5, t.y = (CmnLib.stageH - e.height) * 0.5;
  }
};
let Layer = yi;
Fu = new WeakMap(), Bu = new WeakMap(), nt(Layer, Fu, {
  normal: BLEND_MODES$5.NORMAL,
  add: BLEND_MODES$5.ADD,
  multiply: BLEND_MODES$5.MULTIPLY,
  screen: BLEND_MODES$5.SCREEN
}), nt(Layer, Bu, {
  0: "normal",
  1: "add",
  2: "multiply",
  3: "screen"
});
function prefixNames(o) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  return t.map(function(R) {
    return R.split(" ").map(function(N) {
      return N ? "" + o + N : "";
    }).join(" ");
  }).join(" ");
}
function prefixCSS(o, t) {
  return t.replace(/([^}{]*){/gm, function(e, R) {
    return R.replace(/\.([^{,\s\d.]+)/g, "." + o + "$1") + "{";
  });
}
function ref(o, t) {
  return function(e) {
    e && (o[t] = e);
  };
}
function refs(o, t, e) {
  return function(R) {
    R && (o[t][e] = R);
  };
}
function Properties(o, t) {
  return function(e) {
    var R = e.prototype;
    o.forEach(function(N) {
      t(R, N);
    });
  };
}
function withMethods(o, t) {
  return t === void 0 && (t = {}), function(e, R) {
    o.forEach(function(N) {
      var M = t[N] || N;
      M in e || (e[M] = function() {
        for (var D, L = [], B = 0; B < arguments.length; B++)
          L[B] = arguments[B];
        var $ = (D = this[R])[N].apply(D, L);
        return $ === this[R] ? this : $;
      });
    });
  };
}
var PolyMap = /* @__PURE__ */ function() {
  function o() {
    this.keys = [], this.values = [];
  }
  var t = o.prototype;
  return t.get = function(e) {
    return this.values[this.keys.indexOf(e)];
  }, t.set = function(e, R) {
    var N = this.keys, M = this.values, D = N.indexOf(e), L = D === -1 ? N.length : D;
    N[L] = e, M[L] = R;
  }, o;
}(), HashMap = /* @__PURE__ */ function() {
  function o() {
    this.object = {};
  }
  var t = o.prototype;
  return t.get = function(e) {
    return this.object[e];
  }, t.set = function(e, R) {
    this.object[e] = R;
  }, o;
}(), SUPPORT_MAP = typeof Map == "function", Link = /* @__PURE__ */ function() {
  function o() {
  }
  var t = o.prototype;
  return t.connect = function(e, R) {
    this.prev = e, this.next = R, e && (e.next = this), R && (R.prev = this);
  }, t.disconnect = function() {
    var e = this.prev, R = this.next;
    e && (e.next = R), R && (R.prev = e);
  }, t.getIndex = function() {
    for (var e = this, R = -1; e; )
      e = e.prev, ++R;
    return R;
  }, o;
}();
function orderChanged(o, t) {
  var e = [], R = [];
  return o.forEach(function(N) {
    var M = N[0], D = N[1], L = new Link();
    e[M] = L, R[D] = L;
  }), e.forEach(function(N, M) {
    N.connect(e[M - 1]);
  }), o.filter(function(N, M) {
    return !t[M];
  }).map(function(N, M) {
    var D = N[0], L = N[1];
    if (D === L)
      return [0, 0];
    var B = e[D], $ = R[L - 1], U = B.getIndex();
    B.disconnect(), $ ? B.connect($, $.next) : B.connect(void 0, e[0]);
    var H = B.getIndex();
    return [U, H];
  });
}
var Result = /* @__PURE__ */ function() {
  function o(e, R, N, M, D, L, B, $) {
    this.prevList = e, this.list = R, this.added = N, this.removed = M, this.changed = D, this.maintained = L, this.changedBeforeAdded = B, this.fixed = $;
  }
  var t = o.prototype;
  return Object.defineProperty(t, "ordered", {
    get: function() {
      return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t, "pureChanged", {
    get: function() {
      return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged;
    },
    enumerable: !0,
    configurable: !0
  }), t.caculateOrdered = function() {
    var e = orderChanged(this.changedBeforeAdded, this.fixed), R = this.changed, N = [];
    this.cacheOrdered = e.filter(function(M, D) {
      var L = M[0], B = M[1], $ = R[D], U = $[0], H = $[1];
      if (L !== B)
        return N.push([U, H]), !0;
    }), this.cachePureChanged = N;
  }, o;
}();
function diff$1(o, t, e) {
  var R = SUPPORT_MAP ? Map : e ? HashMap : PolyMap, N = e || function(K) {
    return K;
  }, M = [], D = [], L = [], B = o.map(N), $ = t.map(N), U = new R(), H = new R(), z = [], X = [], Y = {}, W = [], q = 0, Z = 0;
  return B.forEach(function(K, J) {
    U.set(K, J);
  }), $.forEach(function(K, J) {
    H.set(K, J);
  }), B.forEach(function(K, J) {
    var Q = H.get(K);
    typeof Q > "u" ? (++Z, D.push(J)) : Y[Q] = Z;
  }), $.forEach(function(K, J) {
    var Q = U.get(K);
    typeof Q > "u" ? (M.push(J), ++q) : (L.push([Q, J]), Z = Y[J] || 0, z.push([Q - Z, J - q]), X.push(J === Q), Q !== J && W.push([Q, J]));
  }), D.reverse(), new Result(o, t, M, D, W, L, z, X);
}
var ListDiffer = /* @__PURE__ */ function() {
  function o(e, R) {
    e === void 0 && (e = []), this.findKeyCallback = R, this.list = [].slice.call(e);
  }
  var t = o.prototype;
  return t.update = function(e) {
    var R = [].slice.call(e), N = diff$1(this.list, R, this.findKeyCallback);
    return this.list = R, N;
  }, o;
}(), FUNCTION$1 = "function", OBJECT = "object", STRING$1 = "string", NUMBER = "number", UNDEFINED = "undefined", IS_WINDOW = typeof window !== UNDEFINED, OPEN_CLOSED_CHARACTERS = [{
  open: "(",
  close: ")"
}, {
  open: '"',
  close: '"'
}, {
  open: "'",
  close: "'"
}, {
  open: '\\"',
  close: '\\"'
}, {
  open: "\\'",
  close: "\\'"
}], TINY_NUM$1 = 1e-7, DEFAULT_UNIT_PRESETS = {
  cm: function(o) {
    return o * 96 / 2.54;
  },
  mm: function(o) {
    return o * 96 / 254;
  },
  in: function(o) {
    return o * 96;
  },
  pt: function(o) {
    return o * 96 / 72;
  },
  pc: function(o) {
    return o * 96 / 6;
  },
  "%": function(o, t) {
    return o * t / 100;
  },
  vw: function(o, t) {
    return t === void 0 && (t = window.innerWidth), o / 100 * t;
  },
  vh: function(o, t) {
    return t === void 0 && (t = window.innerHeight), o / 100 * t;
  },
  vmax: function(o, t) {
    return t === void 0 && (t = Math.max(window.innerWidth, window.innerHeight)), o / 100 * t;
  },
  vmin: function(o, t) {
    return t === void 0 && (t = Math.min(window.innerWidth, window.innerHeight)), o / 100 * t;
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __spreadArrays$4() {
  for (var o = 0, t = 0, e = arguments.length; t < e; t++)
    o += arguments[t].length;
  for (var R = Array(o), N = 0, t = 0; t < e; t++)
    for (var M = arguments[t], D = 0, L = M.length; D < L; D++, N++)
      R[N] = M[D];
  return R;
}
function dot(o, t, e, R) {
  return (o * R + t * e) / (e + R);
}
function isUndefined(o) {
  return typeof o === UNDEFINED;
}
function isObject$2(o) {
  return o && typeof o === OBJECT;
}
function isArray(o) {
  return Array.isArray(o);
}
function isString$1(o) {
  return typeof o === STRING$1;
}
function isNumber(o) {
  return typeof o === NUMBER;
}
function isFunction$3(o) {
  return typeof o === FUNCTION$1;
}
function isEqualSeparator(o, t) {
  var e = o === "" || o == " ", R = t === "" || t == " ";
  return R && e || o === t;
}
function findOpen(o, t, e, R, N) {
  var M = findIgnore(o, t, e);
  return M ? e : findClose(o, t, e + 1, R, N);
}
function findIgnore(o, t, e) {
  if (!o.ignore)
    return null;
  var R = t.slice(Math.max(e - 3, 0), e + 3).join("");
  return new RegExp(o.ignore).exec(R);
}
function findClose(o, t, e, R, N) {
  for (var M = function($) {
    var U = t[$].trim();
    if (U === o.close && !findIgnore(o, t, $))
      return {
        value: $
      };
    var H = $, z = find$1(N, function(X) {
      var Y = X.open;
      return Y === U;
    });
    if (z && (H = findOpen(z, t, $, R, N)), H === -1)
      return D = $, "break";
    $ = H, D = $;
  }, D, L = e; L < R; ++L) {
    var B = M(L);
    if (L = D, typeof B == "object")
      return B.value;
    if (B === "break")
      break;
  }
  return -1;
}
function splitText(o, t) {
  var e = isString$1(t) ? {
    separator: t
  } : t, R = e.separator, N = R === void 0 ? "," : R, M = e.isSeparateFirst, D = e.isSeparateOnlyOpenClose, L = e.isSeparateOpenClose, B = L === void 0 ? D : L, $ = e.openCloseCharacters, U = $ === void 0 ? OPEN_CLOSED_CHARACTERS : $, H = U.map(function(st) {
    var rt = st.open, at = st.close;
    return rt === at ? rt : rt + "|" + at;
  }).join("|"), z = "(\\s*" + N + "\\s*|" + H + "|\\s+)", X = new RegExp(z, "g"), Y = o.split(X).filter(Boolean), W = Y.length, q = [], Z = [];
  function K() {
    return Z.length ? (q.push(Z.join("")), Z = [], !0) : !1;
  }
  for (var J = function(st) {
    var rt = Y[st].trim(), at = st, ut = find$1(U, function(pt) {
      var mt = pt.open;
      return mt === rt;
    }), dt = find$1(U, function(pt) {
      var mt = pt.close;
      return mt === rt;
    });
    if (ut) {
      if (at = findOpen(ut, Y, st, W, U), at !== -1 && B)
        return K() && M || (q.push(Y.slice(st, at + 1).join("")), st = at, M) ? (Q = st, "break") : (Q = st, "continue");
    } else if (dt && !findIgnore(dt, Y, st)) {
      var ct = __spreadArrays$4(U);
      return ct.splice(U.indexOf(dt), 1), {
        value: splitText(o, {
          separator: N,
          isSeparateFirst: M,
          isSeparateOnlyOpenClose: D,
          isSeparateOpenClose: B,
          openCloseCharacters: ct
        })
      };
    } else if (isEqualSeparator(rt, N) && !D)
      return K(), M ? (Q = st, "break") : (Q = st, "continue");
    at === -1 && (at = W - 1), Z.push(Y.slice(st, at + 1).join("")), st = at, Q = st;
  }, Q, et = 0; et < W; ++et) {
    var tt = J(et);
    if (et = Q, typeof tt == "object")
      return tt.value;
    if (tt === "break")
      break;
  }
  return Z.length && q.push(Z.join("")), q;
}
function splitSpace(o) {
  return splitText(o, "");
}
function splitComma(o) {
  return splitText(o, ",");
}
function splitBracket(o) {
  var t = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(o);
  return !t || t.length < 4 ? {} : {
    prefix: t[1],
    value: t[2],
    suffix: t[3]
  };
}
function splitUnit(o) {
  var t = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(o);
  if (!t)
    return {
      prefix: "",
      unit: "",
      value: NaN
    };
  var e = t[1], R = t[2], N = t[3];
  return {
    prefix: e,
    unit: N,
    value: parseFloat(R)
  };
}
function camelize(o) {
  return o.replace(/[\s-_]([a-z])/g, function(t, e) {
    return e.toUpperCase();
  });
}
function decamelize(o, t) {
  return t === void 0 && (t = "-"), o.replace(/([a-z])([A-Z])/g, function(e, R, N) {
    return "" + R + t + N.toLowerCase();
  });
}
function now$1() {
  return Date.now ? Date.now() : new Date().getTime();
}
function findIndex(o, t, e) {
  e === void 0 && (e = -1);
  for (var R = o.length, N = 0; N < R; ++N)
    if (t(o[N], N, o))
      return N;
  return e;
}
function find$1(o, t, e) {
  var R = findIndex(o, t);
  return R > -1 ? o[R] : e;
}
var requestAnimationFrame$1 = /* @__PURE__ */ function() {
  var o = now$1(), t = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return t ? t.bind(window) : function(e) {
    var R = now$1(), N = window.setTimeout(function() {
      e(R - o);
    }, 1e3 / 60);
    return N;
  };
}(), cancelAnimationFrame$1 = /* @__PURE__ */ function() {
  var o = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return o ? o.bind(window) : function(t) {
    clearTimeout(t);
  };
}();
function getKeys(o) {
  return Object.keys(o);
}
function convertUnitSize(o, t) {
  var e = splitUnit(o), R = e.value, N = e.unit;
  if (isObject$2(t)) {
    var M = t[N];
    if (M) {
      if (isFunction$3(M))
        return M(R);
      if (DEFAULT_UNIT_PRESETS[N])
        return DEFAULT_UNIT_PRESETS[N](R, M);
    }
  } else if (N === "%")
    return R * t / 100;
  return DEFAULT_UNIT_PRESETS[N] ? DEFAULT_UNIT_PRESETS[N](R) : R;
}
function between(o, t, e) {
  return Math.max(t, Math.min(o, e));
}
function checkBoundSize(o, t, e, R) {
  return R === void 0 && (R = o[0] / o[1]), [[throttle(t[0], TINY_NUM$1), throttle(t[0] / R, TINY_NUM$1)], [throttle(t[1] * R, TINY_NUM$1), throttle(t[1], TINY_NUM$1)]].filter(function(N) {
    return N.every(function(M, D) {
      var L = t[D], B = throttle(L, TINY_NUM$1);
      return e ? M <= L || M <= B : M >= L || M >= B;
    });
  })[0] || o;
}
function calculateBoundSize(o, t, e, R) {
  if (!R)
    return o.map(function(X, Y) {
      return between(X, t[Y], e[Y]);
    });
  var N = o[0], M = o[1], D = R === !0 ? N / M : R, L = checkBoundSize(o, t, !1, D), B = L[0], $ = L[1], U = checkBoundSize(o, e, !0, D), H = U[0], z = U[1];
  return N < B || M < $ ? (N = B, M = $) : (N > H || M > z) && (N = H, M = z), [N, M];
}
function sum(o) {
  for (var t = o.length, e = 0, R = t - 1; R >= 0; --R)
    e += o[R];
  return e;
}
function average(o) {
  for (var t = o.length, e = 0, R = t - 1; R >= 0; --R)
    e += o[R];
  return t ? e / t : 0;
}
function getRad$1(o, t) {
  var e = t[0] - o[0], R = t[1] - o[1], N = Math.atan2(R, e);
  return N >= 0 ? N : N + Math.PI * 2;
}
function getCenterPoint(o) {
  return [0, 1].map(function(t) {
    return average(o.map(function(e) {
      return e[t];
    }));
  });
}
function getShapeDirection(o) {
  var t = getCenterPoint(o), e = getRad$1(t, o[0]), R = getRad$1(t, o[1]);
  return e < R && R - e < Math.PI || e > R && R - e < -Math.PI ? 1 : -1;
}
function getDist$2(o, t) {
  return Math.sqrt(Math.pow((t ? t[0] : 0) - o[0], 2) + Math.pow((t ? t[1] : 0) - o[1], 2));
}
function throttle(o, t) {
  if (!t)
    return o;
  var e = 1 / t;
  return Math.round(o / t) / e;
}
function throttleArray(o, t) {
  return o.forEach(function(e, R) {
    o[R] = throttle(o[R], t);
  }), o;
}
function hasClass(o, t) {
  return o.classList ? o.classList.contains(t) : !!o.className.match(new RegExp("(\\s|^)" + t + "(\\s|$)"));
}
function addClass(o, t) {
  o.classList ? o.classList.add(t) : o.className += " " + t;
}
function removeClass(o, t) {
  if (o.classList)
    o.classList.remove(t);
  else {
    var e = new RegExp("(\\s|^)" + t + "(\\s|$)");
    o.className = o.className.replace(e, " ");
  }
}
function addEvent(o, t, e, R) {
  o.addEventListener(t, e, R);
}
function removeEvent(o, t, e, R) {
  o.removeEventListener(t, e, R);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$6 = function(o, t) {
  return extendStatics$6 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$6(o, t);
};
function __extends$6(o, t) {
  extendStatics$6(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$7 = function() {
  return __assign$7 = Object.assign || function(t) {
    for (var e, R = 1, N = arguments.length; R < N; R++) {
      e = arguments[R];
      for (var M in e)
        Object.prototype.hasOwnProperty.call(e, M) && (t[M] = e[M]);
    }
    return t;
  }, __assign$7.apply(this, arguments);
};
function __rest$2(o, t) {
  var e = {};
  for (var R in o)
    Object.prototype.hasOwnProperty.call(o, R) && t.indexOf(R) < 0 && (e[R] = o[R]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var N = 0, R = Object.getOwnPropertySymbols(o); N < R.length; N++)
      t.indexOf(R[N]) < 0 && Object.prototype.propertyIsEnumerable.call(o, R[N]) && (e[R[N]] = o[R[N]]);
  return e;
}
function __spreadArrays$3() {
  for (var o = 0, t = 0, e = arguments.length; t < e; t++)
    o += arguments[t].length;
  for (var R = Array(o), N = 0, t = 0; t < e; t++)
    for (var M = arguments[t], D = 0, L = M.length; D < L; D++, N++)
      R[N] = M[D];
  return R;
}
function isDiff(o, t) {
  if (o === t)
    return !1;
  for (var e in o)
    if (!(e in t))
      return !0;
  for (var e in t)
    if (o[e] !== t[e])
      return !0;
  return !1;
}
function diffObject(o, t) {
  var e = Object.keys(o), R = Object.keys(t), N = diff$1(e, R, function(B) {
    return B;
  }), M = {}, D = {}, L = {};
  return N.added.forEach(function(B) {
    var $ = R[B];
    M[$] = t[$];
  }), N.removed.forEach(function(B) {
    var $ = e[B];
    D[$] = o[$];
  }), N.maintained.forEach(function(B) {
    var $ = B[0], U = e[$], H = [o[U], t[U]];
    o[U] !== t[U] && (L[U] = H);
  }), {
    added: M,
    removed: D,
    changed: L
  };
}
function executeHooks(o) {
  o.forEach(function(t) {
    t();
  });
}
function fillKeys(o) {
  var t = 0;
  return o.map(function(e) {
    return e == null ? "$compat" + ++t : "" + e;
  });
}
function createProvider(o, t, e, R) {
  if (isString$1(o) || isNumber(o))
    return new TextProvider("text_" + o, t, e, R, null, {});
  var N = typeof o.type == "string" ? ElementProvider : o.type.prototype.render ? ComponentProvider : FunctionProvider;
  return new N(o.type, t, e, R, o.ref, o.props);
}
function flat$1(o) {
  var t = [];
  return o.forEach(function(e) {
    t = t.concat(isArray(e) ? flat$1(e) : e);
  }), t;
}
function getAttributes(o) {
  var t = o.className, e = __rest$2(o, ["className"]);
  return t != null && (e.class = t), delete e.style, delete e.children, e;
}
function fillProps(o, t) {
  if (!t)
    return o;
  for (var e in t)
    isUndefined(o[e]) && (o[e] = t[e]);
  return o;
}
function createElement(o, t) {
  for (var e = [], R = 2; R < arguments.length; R++)
    e[R - 2] = arguments[R];
  var N = t || {}, M = N.key, D = N.ref, L = __rest$2(N, ["key", "ref"]);
  return {
    type: o,
    key: M,
    ref: D,
    props: __assign$7(__assign$7({}, L), {
      children: flat$1(e).filter(function(B) {
        return B != null && B !== !1;
      })
    })
  };
}
var Provider = /* @__PURE__ */ function() {
  function o(e, R, N, M, D, L) {
    L === void 0 && (L = {}), this.type = e, this.key = R, this.index = N, this.container = M, this.ref = D, this.props = L, this._providers = [];
  }
  var t = o.prototype;
  return t._should = function(e, R) {
    return !0;
  }, t._update = function(e, R, N, M) {
    if (this.base && !isString$1(R) && !M && !this._should(R.props, N))
      return !1;
    this.original = R, this._setState(N);
    var D = this.props;
    return isString$1(R) || (this.props = R.props, this.ref = R.ref), this._render(e, this.base ? D : {}, N), !0;
  }, t._mounted = function() {
    var e = this.ref;
    e && e(this.base);
  }, t._setState = function(e) {
  }, t._updated = function() {
    var e = this.ref;
    e && e(this.base);
  }, t._destroy = function() {
    var e = this.ref;
    e && e(null);
  }, o;
}();
function diffAttributes(o, t, e) {
  var R = diffObject(o, t), N = R.added, M = R.removed, D = R.changed;
  for (var L in N)
    e.setAttribute(L, N[L]);
  for (var L in D)
    e.setAttribute(L, D[L][1]);
  for (var L in M)
    e.removeAttribute(L);
}
function diffEvents(o, t, e) {
  var R = diffObject(o, t), N = R.added, M = R.removed, D = R.changed;
  for (var L in M)
    e.removeEventListener(L);
  for (var L in N)
    e.addEventListener(L, N[L]);
  for (var L in D)
    e.removeEventListener(L), e.addEventListener(L, D[L][1]);
  for (var L in M)
    e.removeEventListener(L);
}
function diffStyle(o, t, e) {
  var R = e.style, N = diffObject(o, t), M = N.added, D = N.removed, L = N.changed;
  for (var B in M) {
    var $ = decamelize(B, "-");
    R.setProperty ? R.setProperty($, M[B]) : R[$] = M[B];
  }
  for (var B in L) {
    var $ = decamelize(B, "-");
    R.setProperty ? R.setProperty($, L[B][1]) : R[$] = L[B][1];
  }
  for (var B in D) {
    var $ = decamelize(B, "-");
    R.removeProperty ? R.removeProperty($) : R[$] = "";
  }
}
function splitProps(o) {
  var t = {}, e = {};
  for (var R in o)
    R.indexOf("on") === 0 ? e[R.replace("on", "").toLowerCase()] = o[R] : t[R] = o[R];
  return {
    attributes: t,
    events: e
  };
}
var TextProvider = /* @__PURE__ */ function(o) {
  __extends$6(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e._render = function(R) {
    var N = this, M = !this.base;
    return M && (this.base = document.createTextNode(this.type.replace("text_", ""))), R.push(function() {
      M ? N._mounted() : N._updated();
    }), !0;
  }, e._unmount = function() {
    this.base.parentNode.removeChild(this.base);
  }, t;
}(Provider), ElementProvider = /* @__PURE__ */ function(o) {
  __extends$6(t, o);
  function t() {
    var R = o !== null && o.apply(this, arguments) || this;
    return R.events = {}, R._isSVG = !1, R;
  }
  var e = t.prototype;
  return e.addEventListener = function(R, N) {
    var M = this.events;
    M[R] = function(D) {
      D.nativeEvent = D, N(D);
    }, this.base.addEventListener(R, M[R]);
  }, e.removeEventListener = function(R) {
    var N = this.events;
    this.base.removeEventListener(R, N[R]), delete N[R];
  }, e._should = function(R) {
    return isDiff(this.props, R);
  }, e._render = function(R, N) {
    var M = this, D = !this.base;
    if (D) {
      var L = this._hasSVG();
      this._isSVG = L;
      var B = this.props.portalContainer;
      if (!B) {
        var $ = this.type;
        L ? B = document.createElementNS("http://www.w3.org/2000/svg", $) : B = document.createElement($);
      }
      this.base = B;
    }
    renderProviders(this, this._providers, this.props.children, R, null);
    var U = this.base, H = splitProps(N), z = H.attributes, X = H.events, Y = splitProps(this.props), W = Y.attributes, q = Y.events;
    return diffAttributes(getAttributes(z), getAttributes(W), U), diffEvents(X, q, this), diffStyle(N.style || {}, this.props.style || {}, U), R.push(function() {
      D ? M._mounted() : M._updated();
    }), !0;
  }, e._unmount = function() {
    var R = this.events, N = this.base;
    for (var M in R)
      N.removeEventListener(M, R[M]);
    this._providers.forEach(function(D) {
      D._unmount();
    }), this.events = {}, this.props.portalContainer || N.parentNode.removeChild(N);
  }, e._hasSVG = function() {
    if (this._isSVG || this.type === "svg")
      return !0;
    var R = findContainerNode(this.container);
    return R && "ownerSVGElement" in R;
  }, t;
}(Provider);
function findContainerNode(o) {
  if (!o)
    return null;
  var t = o.base;
  return t instanceof Node ? t : findContainerNode(o.container);
}
function findDOMNode(o) {
  if (!o)
    return null;
  if (o instanceof Node)
    return o;
  var t = o.$_provider._providers;
  return t.length ? findDOMNode(t[0].base) : null;
}
var FunctionProvider = /* @__PURE__ */ function(o) {
  __extends$6(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e._render = function(R) {
    var N = this.type(this.props);
    return renderProviders(this, this._providers, N ? [N] : [], R), !0;
  }, e._unmount = function() {
    this._providers.forEach(function(R) {
      R._unmount();
    });
  }, t;
}(Provider), ContainerProvider = /* @__PURE__ */ function(o) {
  __extends$6(t, o);
  function t(R) {
    var N = o.call(this, "container", "container", 0, null) || this;
    return N.base = R, N;
  }
  var e = t.prototype;
  return e._render = function() {
    return !0;
  }, e._unmount = function() {
  }, t;
}(Provider), ComponentProvider = /* @__PURE__ */ function(o) {
  __extends$6(t, o);
  function t(R, N, M, D, L, B) {
    return B === void 0 && (B = {}), o.call(this, R, N, M, D, L, fillProps(B, R.defaultProps)) || this;
  }
  var e = t.prototype;
  return e._should = function(R, N) {
    return this.base.shouldComponentUpdate(fillProps(R, this.type.defaultProps), N || this.base.state);
  }, e._render = function(R, N) {
    var M = this;
    this.props = fillProps(this.props, this.type.defaultProps);
    var D = !this.base;
    D ? (this.base = new this.type(this.props), this.base.$_provider = this) : this.base.props = this.props;
    var L = this.base, B = L.state, $ = L.render();
    $ && $.props && !$.props.children.length && ($.props.children = this.props.children), renderProviders(this, this._providers, $ ? [$] : [], R), R.push(function() {
      D ? (M._mounted(), L.componentDidMount()) : (M._updated(), L.componentDidUpdate(N, B));
    });
  }, e._setState = function(R) {
    var N = this.base;
    !N || !R || (N.state = R);
  }, e._unmount = function() {
    this._providers.forEach(function(R) {
      R._unmount();
    }), clearTimeout(this.base.$_timer), this.base.componentWillUnmount();
  }, t;
}(Provider), Component = /* @__PURE__ */ function() {
  function o(e) {
    e === void 0 && (e = {}), this.props = e, this.state = {}, this.$_timer = 0, this.$_state = {};
  }
  var t = o.prototype;
  return t.shouldComponentUpdate = function(e, R) {
    return !0;
  }, t.render = function() {
    return null;
  }, t.setState = function(e, R, N) {
    var M = this;
    this.$_timer || (this.$_state = {}), clearTimeout(this.$_timer), this.$_timer = 0, this.$_state = __assign$7(__assign$7({}, this.$_state), e), N ? this.$_setState(R, N) : this.$_timer = setTimeout(function() {
      M.$_timer = 0, M.$_setState(R, N);
    });
  }, t.forceUpdate = function(e) {
    this.setState({}, e, !0);
  }, t.componentDidMount = function() {
  }, t.componentDidUpdate = function(e, R) {
  }, t.componentWillUnmount = function() {
  }, t.$_setState = function(e, R) {
    var N = [], M = this.$_provider, D = renderProviders(M.container, [M], [M.original], N, __assign$7(__assign$7({}, this.state), this.$_state), R);
    D && (e && N.push(e), executeHooks(N));
  }, o;
}(), PureComponent = /* @__PURE__ */ function(o) {
  __extends$6(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.shouldComponentUpdate = function(R, N) {
    return isDiff(this.props, R) || isDiff(this.state, N);
  }, t;
}(Component), _Portal = /* @__PURE__ */ function(o) {
  __extends$6(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.componentDidMount = function() {
    var R = this.props, N = R.element, M = R.container;
    this._portalProvider = new ContainerProvider(M), renderProvider(N, M, this._portalProvider);
  }, e.componentDidUpdate = function() {
    var R = this.props, N = R.element, M = R.container;
    renderProvider(N, M, this._portalProvider);
  }, e.componentWillUnmount = function() {
    var R = this.props.container;
    renderProvider(null, R, this._portalProvider), this._portalProvider = null;
  }, t;
}(PureComponent);
function updateProvider(o, t, e) {
  var R = [];
  renderProviders(o, o._providers, t, R, e), executeHooks(R);
}
function getNextSibiling(o, t) {
  for (var e = o._providers, R = e.length, N = t.index + 1; N < R; ++N) {
    var M = findDOMNode(e[N].base);
    if (M)
      return M;
  }
  return null;
}
function diffProviders(o, t, e) {
  var R = e.map(function(B) {
    return isString$1(B) ? null : B.key;
  }), N = fillKeys(t.map(function(B) {
    return B.key;
  })), M = fillKeys(R), D = diff$1(N, M, function(B) {
    return B;
  });
  D.removed.forEach(function(B) {
    t.splice(B, 1)[0]._unmount();
  }), D.ordered.forEach(function(B) {
    var $ = B[0], U = B[1], H = t.splice($, 1)[0];
    t.splice(U, 0, H);
    var z = findDOMNode(H.base), X = findDOMNode(t[U + 1] && t[U + 1].base);
    z && z.parentNode.insertBefore(z, X);
  }), D.added.forEach(function(B) {
    t.splice(B, 0, createProvider(e[B], R[B], B, o));
  });
  var L = D.maintained.filter(function(B) {
    B[0];
    var $ = B[1], U = e[$], H = t[$], z = isString$1(U) ? "text_" + U : U.type;
    return z !== H.type ? (H._unmount(), t.splice($, 1, createProvider(U, R[$], $, o)), !0) : (H.index = $, !1);
  });
  return __spreadArrays$3(D.added, L.map(function(B) {
    B[0];
    var $ = B[1];
    return $;
  }));
}
function renderProviders(o, t, e, R, N, M) {
  var D = diffProviders(o, t, e), L = t.filter(function($, U) {
    return $._update(R, e[U], N, M);
  }), B = findContainerNode(o);
  return B && D.reverse().forEach(function($) {
    var U = t[$], H = findDOMNode(U.base);
    if (!!H && B !== H && !H.parentNode) {
      var z = getNextSibiling(o, U);
      B.insertBefore(H, z);
    }
  }), L.length > 0;
}
function renderProvider(o, t, e) {
  e === void 0 && (e = t.__REACT_COMPAT__);
  var R = !!e;
  return e || (e = new ContainerProvider(t)), updateProvider(e, o ? [o] : []), R || (t.__REACT_COMPAT__ = e), e;
}
function render(o, t, e) {
  var R = t.__REACT_COMPAT__;
  o && !R && (t.innerHTML = ""), renderProvider(o, t, R), e && e();
}
function createPortal(o, t) {
  return createElement(_Portal, {
    element: o,
    container: t
  });
}
var version = "simple-1.1.0";
function some(o, t) {
  for (var e = o.length, R = 0; R < e; ++R)
    if (t(o[R], R))
      return !0;
  return !1;
}
function find(o, t) {
  for (var e = o.length, R = 0; R < e; ++R)
    if (t(o[R], R))
      return o[R];
  return null;
}
function getUserAgentString(o) {
  var t = o;
  if (typeof t > "u") {
    if (typeof navigator > "u" || !navigator)
      return "";
    t = navigator.userAgent || "";
  }
  return t.toLowerCase();
}
function execRegExp(o, t) {
  try {
    return new RegExp(o, "g").exec(t);
  } catch {
    return null;
  }
}
function hasUserAgentData() {
  if (typeof navigator > "u" || !navigator || !navigator.userAgentData)
    return !1;
  var o = navigator.userAgentData, t = o.brands || o.uaList;
  return !!(t && t.length);
}
function findVersion(o, t) {
  var e = execRegExp("(" + o + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", t);
  return e ? e[3] : "";
}
function convertVersion(o) {
  return o.replace(/_/g, ".");
}
function findPreset(o, t) {
  var e = null, R = "-1";
  return some(o, function(N) {
    var M = execRegExp("(" + N.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", t);
    return !M || N.brand ? !1 : (e = N, R = M[3] || "-1", N.versionAlias ? R = N.versionAlias : N.versionTest && (R = findVersion(N.versionTest.toLowerCase(), t) || R), R = convertVersion(R), !0);
  }), {
    preset: e,
    version: R
  };
}
function findPresetBrand(o, t) {
  var e = {
    brand: "",
    version: "-1"
  };
  return some(o, function(R) {
    var N = findBrand(t, R);
    return N ? (e.brand = R.id, e.version = R.versionAlias || N.version, e.version !== "-1") : !1;
  }), e;
}
function findBrand(o, t) {
  return find(o, function(e) {
    var R = e.brand;
    return execRegExp("" + t.test, R.toLowerCase());
  });
}
var BROWSER_PRESETS = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}], CHROMIUM_PRESETS = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: !0
}], WEBKIT_PRESETS = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}], WEBVIEW_PRESETS = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  test: "webview",
  id: "webview"
}], OS_PRESETS = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];
function isWebView(o) {
  return !!findPreset(WEBVIEW_PRESETS, o).preset;
}
function getLegacyAgent(o) {
  var t = getUserAgentString(o), e = !!/mobi/g.exec(t), R = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: isWebView(t),
    chromium: !1,
    chromiumVersion: "-1",
    webkit: !1,
    webkitVersion: "-1"
  }, N = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  }, M = findPreset(BROWSER_PRESETS, t), D = M.preset, L = M.version, B = findPreset(OS_PRESETS, t), $ = B.preset, U = B.version, H = findPreset(CHROMIUM_PRESETS, t);
  if (R.chromium = !!H.preset, R.chromiumVersion = H.version, !R.chromium) {
    var z = findPreset(WEBKIT_PRESETS, t);
    R.webkit = !!z.preset, R.webkitVersion = z.version;
  }
  return $ && (N.name = $.id, N.version = U, N.majorVersion = parseInt(U, 10)), D && (R.name = D.id, R.version = L, R.webview && N.name === "ios" && R.name !== "safari" && (R.webview = !1)), R.majorVersion = parseInt(R.version, 10), {
    browser: R,
    os: N,
    isMobile: e,
    isHints: !1
  };
}
function getClientHintsAgent(o) {
  var t = navigator.userAgentData, e = (t.uaList || t.brands).slice(), R = o && o.fullVersionList, N = t.mobile || !1, M = e[0], D = (o && o.platform || t.platform || navigator.platform).toLowerCase(), L = {
    name: M.brand,
    version: M.version,
    majorVersion: -1,
    webkit: !1,
    webkitVersion: "-1",
    chromium: !1,
    chromiumVersion: "-1",
    webview: !!findPresetBrand(WEBVIEW_PRESETS, e).brand || isWebView(getUserAgentString())
  }, B = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  L.webkit = !L.chromium && some(WEBKIT_PRESETS, function(Y) {
    return findBrand(e, Y);
  });
  var $ = findPresetBrand(CHROMIUM_PRESETS, e);
  if (L.chromium = !!$.brand, L.chromiumVersion = $.version, !L.chromium) {
    var U = findPresetBrand(WEBKIT_PRESETS, e);
    L.webkit = !!U.brand, L.webkitVersion = U.version;
  }
  var H = find(OS_PRESETS, function(Y) {
    return new RegExp("" + Y.test, "g").exec(D);
  });
  if (B.name = H ? H.id : "", o && (B.version = o.platformVersion), R && R.length) {
    var z = findPresetBrand(BROWSER_PRESETS, R);
    L.name = z.brand || L.name, L.version = z.version || L.version;
  } else {
    var X = findPresetBrand(BROWSER_PRESETS, e);
    L.name = X.brand || L.name, L.version = X.brand && o ? o.uaFullVersion : X.version;
  }
  return L.webkit && (B.name = N ? "ios" : "mac"), B.name === "ios" && L.webview && (L.version = "-1"), B.version = convertVersion(B.version), L.version = convertVersion(L.version), B.majorVersion = parseInt(B.version, 10), L.majorVersion = parseInt(L.version, 10), {
    browser: L,
    os: B,
    isMobile: N,
    isHints: !0
  };
}
function agent$1(o) {
  return typeof o > "u" && hasUserAgentData() ? getClientHintsAgent() : getLegacyAgent(o);
}
function add(o, t, e, R, N, M) {
  for (var D = 0; D < N; ++D) {
    var L = e + D * N, B = R + D * N;
    o[L] += o[B] * M, t[L] += t[B] * M;
  }
}
function swap(o, t, e, R, N) {
  for (var M = 0; M < N; ++M) {
    var D = e + M * N, L = R + M * N, B = o[D], $ = t[D];
    o[D] = o[L], o[L] = B, t[D] = t[L], t[L] = $;
  }
}
function divide(o, t, e, R, N) {
  for (var M = 0; M < R; ++M) {
    var D = e + M * R;
    o[D] /= N, t[D] /= N;
  }
}
function ignoreDimension(o, t, e) {
  e === void 0 && (e = Math.sqrt(o.length));
  for (var R = o.slice(), N = 0; N < e; ++N)
    R[N * e + t - 1] = 0, R[(t - 1) * e + N] = 0;
  return R[(t - 1) * (e + 1)] = 1, R;
}
function invert(o, t) {
  t === void 0 && (t = Math.sqrt(o.length));
  for (var e = o.slice(), R = createIdentityMatrix(t), N = 0; N < t; ++N) {
    var M = t * N + N;
    if (!throttle(e[M], TINY_NUM$1)) {
      for (var D = N + 1; D < t; ++D)
        if (e[t * N + D]) {
          swap(e, R, N, D, t);
          break;
        }
    }
    if (!throttle(e[M], TINY_NUM$1))
      return [];
    divide(e, R, N, t, e[M]);
    for (var D = 0; D < t; ++D) {
      var L = D, B = D + N * t, $ = e[B];
      !throttle($, TINY_NUM$1) || N === D || add(e, R, L, N, t, -$);
    }
  }
  return R;
}
function transpose(o, t) {
  t === void 0 && (t = Math.sqrt(o.length));
  for (var e = [], R = 0; R < t; ++R)
    for (var N = 0; N < t; ++N)
      e[N * t + R] = o[t * R + N];
  return e;
}
function getOrigin(o, t) {
  t === void 0 && (t = Math.sqrt(o.length));
  for (var e = [], R = o[t * t - 1], N = 0; N < t - 1; ++N)
    e[N] = o[t * (t - 1) + N] / R;
  return e[t - 1] = 0, e;
}
function fromTranslation(o, t) {
  for (var e = createIdentityMatrix(t), R = 0; R < t - 1; ++R)
    e[t * (t - 1) + R] = o[R] || 0;
  return e;
}
function convertPositionMatrix(o, t) {
  for (var e = o.slice(), R = o.length; R < t - 1; ++R)
    e[R] = 0;
  return e[t - 1] = 1, e;
}
function convertDimension(o, t, e) {
  if (t === void 0 && (t = Math.sqrt(o.length)), t === e)
    return o;
  for (var R = createIdentityMatrix(e), N = Math.min(t, e), M = 0; M < N - 1; ++M) {
    for (var D = 0; D < N - 1; ++D)
      R[M * e + D] = o[M * t + D];
    R[(M + 1) * e - 1] = o[(M + 1) * t - 1], R[(e - 1) * e + M] = o[(t - 1) * t + M];
  }
  return R[e * e - 1] = o[t * t - 1], R;
}
function multiplies(o) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  var R = createIdentityMatrix(o);
  return t.forEach(function(N) {
    R = multiply(R, N, o);
  }), R;
}
function multiply(o, t, e) {
  e === void 0 && (e = Math.sqrt(o.length));
  var R = [], N = o.length / e, M = t.length / N;
  if (N) {
    if (!M)
      return o;
  } else
    return t;
  for (var D = 0; D < e; ++D)
    for (var L = 0; L < M; ++L) {
      R[L * e + D] = 0;
      for (var B = 0; B < N; ++B)
        R[L * e + D] += o[B * e + D] * t[L * N + B];
    }
  return R;
}
function plus(o, t) {
  for (var e = Math.min(o.length, t.length), R = o.slice(), N = 0; N < e; ++N)
    R[N] = R[N] + t[N];
  return R;
}
function minus(o, t) {
  for (var e = Math.min(o.length, t.length), R = o.slice(), N = 0; N < e; ++N)
    R[N] = R[N] - t[N];
  return R;
}
function convertCSStoMatrix(o, t) {
  return t === void 0 && (t = o.length === 6), t ? [o[0], o[1], 0, o[2], o[3], 0, o[4], o[5], 1] : o;
}
function convertMatrixtoCSS(o, t) {
  return t === void 0 && (t = o.length === 9), t ? [o[0], o[1], o[3], o[4], o[6], o[7]] : o;
}
function calculate(o, t, e) {
  e === void 0 && (e = t.length);
  var R = multiply(o, t, e), N = R[e - 1];
  return R.map(function(M) {
    return M / N;
  });
}
function rotateX3d(o, t) {
  return multiply(o, [1, 0, 0, 0, 0, Math.cos(t), Math.sin(t), 0, 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1], 4);
}
function rotateY3d(o, t) {
  return multiply(o, [Math.cos(t), 0, -Math.sin(t), 0, 0, 1, 0, 0, Math.sin(t), 0, Math.cos(t), 0, 0, 0, 0, 1], 4);
}
function rotateZ3d(o, t) {
  return multiply(o, createRotateMatrix(t, 4));
}
function scale3d(o, t) {
  var e = t[0], R = e === void 0 ? 1 : e, N = t[1], M = N === void 0 ? 1 : N, D = t[2], L = D === void 0 ? 1 : D;
  return multiply(o, [R, 0, 0, 0, 0, M, 0, 0, 0, 0, L, 0, 0, 0, 0, 1], 4);
}
function rotate(o, t) {
  return calculate(createRotateMatrix(t, 3), convertPositionMatrix(o, 3));
}
function translate3d(o, t) {
  var e = t[0], R = e === void 0 ? 0 : e, N = t[1], M = N === void 0 ? 0 : N, D = t[2], L = D === void 0 ? 0 : D;
  return multiply(o, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, R, M, L, 1], 4);
}
function matrix3d(o, t) {
  return multiply(o, t, 4);
}
function createRotateMatrix(o, t) {
  var e = Math.cos(o), R = Math.sin(o), N = createIdentityMatrix(t);
  return N[0] = e, N[1] = R, N[t] = -R, N[t + 1] = e, N;
}
function createIdentityMatrix(o) {
  for (var t = o * o, e = [], R = 0; R < t; ++R)
    e[R] = R % (o + 1) ? 0 : 1;
  return e;
}
function createScaleMatrix(o, t) {
  for (var e = createIdentityMatrix(t), R = Math.min(o.length, t - 1), N = 0; N < R; ++N)
    e[(t + 1) * N] = o[N];
  return e;
}
function createOriginMatrix(o, t) {
  for (var e = createIdentityMatrix(t), R = Math.min(o.length, t - 1), N = 0; N < R; ++N)
    e[t * (t - 1) + N] = o[N];
  return e;
}
function createWarpMatrix(o, t, e, R, N, M, D, L) {
  var B = o[0], $ = o[1], U = t[0], H = t[1], z = e[0], X = e[1], Y = R[0], W = R[1], q = N[0], Z = N[1], K = M[0], J = M[1], Q = D[0], et = D[1], tt = L[0], st = L[1], rt = [B, 0, U, 0, z, 0, Y, 0, $, 0, H, 0, X, 0, W, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, B, 0, U, 0, z, 0, Y, 0, $, 0, H, 0, X, 0, W, 0, 1, 0, 1, 0, 1, 0, 1, -q * B, -Z * B, -K * U, -J * U, -Q * z, -et * z, -tt * Y, -st * Y, -q * $, -Z * $, -K * H, -J * H, -Q * X, -et * X, -tt * W, -st * W], at = invert(rt, 8);
  if (!at.length)
    return [];
  var ut = multiply(at, [q, Z, K, J, Q, et, tt, st], 8);
  return ut[8] = 1, convertDimension(transpose(ut), 3, 4);
}
function createMatrix() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function parseMat(o) {
  return toMat(parse(o));
}
function calculateMatrixDist(o, t) {
  var e = calculate(o, [t[0], t[1] || 0, t[2] || 0, 1], 4), R = e[3] || 1;
  return [e[0] / R, e[1] / R, e[2] / R];
}
function toMat(o) {
  var t = createMatrix();
  return o.forEach(function(e) {
    var R = e.matrixFunction, N = e.functionValue;
    !R || (t = R(t, N));
  }), t;
}
function parse(o) {
  var t = isArray(o) ? o : splitSpace(o);
  return t.map(function(e) {
    var R = splitBracket(e), N = R.prefix, M = R.value, D = null, L = N, B = "";
    if (N === "translate" || N === "translateX" || N === "translate3d") {
      var $ = splitComma(M).map(function(ut) {
        return parseFloat(ut);
      }), U = $[0], H = $[1], z = H === void 0 ? 0 : H, X = $[2], Y = X === void 0 ? 0 : X;
      D = translate3d, B = [U, z, Y];
    } else if (N === "translateY") {
      var z = parseFloat(M);
      D = translate3d, B = [0, z, 0];
    } else if (N === "translateZ") {
      var Y = parseFloat(M);
      D = translate3d, B = [0, 0, Y];
    } else if (N === "scale" || N === "scale3d") {
      var W = splitComma(M).map(function(ut) {
        return parseFloat(ut);
      }), q = W[0], Z = W[1], K = Z === void 0 ? q : Z, J = W[2], Q = J === void 0 ? 1 : J;
      D = scale3d, B = [q, K, Q];
    } else if (N === "scaleX") {
      var q = parseFloat(M);
      D = scale3d, B = [q, 1, 1];
    } else if (N === "scaleY") {
      var K = parseFloat(M);
      D = scale3d, B = [1, K, 1];
    } else if (N === "scaleZ") {
      var Q = parseFloat(M);
      D = scale3d, B = [1, 1, Q];
    } else if (N === "rotate" || N === "rotateZ" || N === "rotateX" || N === "rotateY") {
      var et = splitUnit(M), tt = et.unit, st = et.value, rt = tt === "rad" ? st : st * Math.PI / 180;
      N === "rotate" || N === "rotateZ" ? (L = "rotateZ", D = rotateZ3d) : N === "rotateX" ? D = rotateX3d : N === "rotateY" && (D = rotateY3d), B = rt;
    } else if (N === "matrix3d")
      D = matrix3d, B = splitComma(M).map(function(ut) {
        return parseFloat(ut);
      });
    else if (N === "matrix") {
      var at = splitComma(M).map(function(ut) {
        return parseFloat(ut);
      });
      D = matrix3d, B = [at[0], at[1], 0, 0, at[2], at[3], 0, 0, 0, 0, 1, 0, at[4], at[5], 0, 1];
    } else
      L = "";
    return {
      name: N,
      functionName: L,
      value: M,
      matrixFunction: D,
      functionValue: B
    };
  });
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$5 = function(o, t) {
  return extendStatics$5 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$5(o, t);
};
function __extends$5(o, t) {
  extendStatics$5(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var findKeyCallback = typeof Map == "function" ? void 0 : function() {
  var o = 0;
  return function(t) {
    return t.__DIFF_KEY__ || (t.__DIFF_KEY__ = ++o);
  };
}(), ChildrenDiffer = /* @__PURE__ */ function(o) {
  __extends$5(t, o);
  function t(e) {
    return e === void 0 && (e = []), o.call(this, e, findKeyCallback) || this;
  }
  return t;
}(ListDiffer);
function diff(o, t) {
  return diff$1(o, t, findKeyCallback);
}
const ChildrenDiffer$1 = ChildrenDiffer;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __spreadArrays$2() {
  for (var o = 0, t = 0, e = arguments.length; t < e; t++)
    o += arguments[t].length;
  for (var R = Array(o), N = 0, t = 0; t < e; t++)
    for (var M = arguments[t], D = 0, L = M.length; D < L; D++, N++)
      R[N] = M[D];
  return R;
}
function tinyThrottle(o) {
  return throttle(o, TINY_NUM$1);
}
function isSameConstants(o, t) {
  return o.every(function(e, R) {
    return tinyThrottle(e - t[R]) === 0;
  });
}
function isSamePoint(o, t) {
  return !tinyThrottle(o[0] - t[0]) && !tinyThrottle(o[1] - t[1]);
}
function getAreaSize(o) {
  return o.length < 3 ? 0 : Math.abs(sum(o.map(function(t, e) {
    var R = o[e + 1] || o[0];
    return t[0] * R[1] - R[0] * t[1];
  }))) / 2;
}
function fitPoints(o, t) {
  var e = t.width, R = t.height, N = t.left, M = t.top, D = getMinMaxs(o), L = D.minX, B = D.minY, $ = D.maxX, U = D.maxY, H = e / ($ - L), z = R / (U - B);
  return o.map(function(X) {
    return [N + (X[0] - L) * H, M + (X[1] - B) * z];
  });
}
function getMinMaxs(o) {
  var t = o.map(function(R) {
    return R[0];
  }), e = o.map(function(R) {
    return R[1];
  });
  return {
    minX: Math.min.apply(Math, t),
    minY: Math.min.apply(Math, e),
    maxX: Math.max.apply(Math, t),
    maxY: Math.max.apply(Math, e)
  };
}
function isInside(o, t, e) {
  var R = o[0], N = o[1], M = getMinMaxs(t), D = M.minX, L = M.maxX, B = [[D, N], [L, N]], $ = getLinearConstants(B[0], B[1]), U = convertLines(t), H = [];
  if (U.forEach(function(Y) {
    var W = getLinearConstants(Y[0], Y[1]), q = Y[0];
    if (isSameConstants($, W))
      H.push({
        pos: o,
        line: Y,
        type: "line"
      });
    else {
      var Z = getPointsOnLines(getIntersectionPointsByConstants($, W), [B, Y]);
      Z.forEach(function(K) {
        Y.some(function(J) {
          return isSamePoint(J, K);
        }) ? H.push({
          pos: K,
          line: Y,
          type: "point"
        }) : tinyThrottle(q[1] - N) !== 0 && H.push({
          pos: K,
          line: Y,
          type: "intersection"
        });
      });
    }
  }), !e && find$1(H, function(Y) {
    return Y[0] === R;
  }))
    return !0;
  var z = 0, X = {};
  return H.forEach(function(Y) {
    var W = Y.pos, q = Y.type, Z = Y.line;
    if (!(W[0] > R))
      if (q === "intersection")
        ++z;
      else {
        if (q === "line")
          return;
        if (q === "point") {
          var K = find$1(Z, function(et) {
            return et[1] !== N;
          }), J = X[W[0]], Q = K[1] > N ? 1 : -1;
          J ? J !== Q && ++z : X[W[0]] = Q;
        }
      }
  }), z % 2 === 1;
}
function getLinearConstants(o, t) {
  var e = o[0], R = o[1], N = t[0], M = t[1], D = N - e, L = M - R;
  Math.abs(D) < TINY_NUM$1 && (D = 0), Math.abs(L) < TINY_NUM$1 && (L = 0);
  var B = 0, $ = 0, U = 0;
  return D ? L ? (B = -L / D, $ = 1, U = -B * e - R) : ($ = 1, U = -R) : L && (B = -1, U = e), [B, $, U];
}
function getIntersectionPointsByConstants(o, t) {
  var e = o[0], R = o[1], N = o[2], M = t[0], D = t[1], L = t[2], B = e === 0 && M === 0, $ = R === 0 && D === 0, U = [];
  if (B && $)
    return [];
  if (B) {
    var H = -N / R, z = -L / D;
    return H !== z ? [] : [[-1 / 0, H], [1 / 0, H]];
  } else if ($) {
    var X = -N / e, Y = -L / M;
    return X !== Y ? [] : [[X, -1 / 0], [X, 1 / 0]];
  } else if (e === 0) {
    var W = -N / R, q = -(D * W + L) / M;
    U = [[q, W]];
  } else if (M === 0) {
    var W = -L / D, q = -(R * W + N) / e;
    U = [[q, W]];
  } else if (R === 0) {
    var q = -N / e, W = -(M * q + L) / D;
    U = [[q, W]];
  } else if (D === 0) {
    var q = -L / M, W = -(e * q + N) / R;
    U = [[q, W]];
  } else {
    var q = (R * L - D * N) / (D * e - R * M), W = -(e * q + N) / R;
    U = [[q, W]];
  }
  return U.map(function(Z) {
    return [Z[0], Z[1]];
  });
}
function getPointsOnLines(o, t) {
  var e = t.map(function(H) {
    return [0, 1].map(function(z) {
      return [Math.min(H[0][z], H[1][z]), Math.max(H[0][z], H[1][z])];
    });
  }), R = [];
  if (o.length === 2) {
    var N = o[0], M = N[0], D = N[1];
    if (tinyThrottle(M - o[1][0])) {
      if (!tinyThrottle(D - o[1][1])) {
        var $ = Math.max.apply(Math, e.map(function(H) {
          return H[0][0];
        })), U = Math.min.apply(Math, e.map(function(H) {
          return H[0][1];
        }));
        if (tinyThrottle($ - U) > 0)
          return [];
        R = [[$, D], [U, D]];
      }
    } else {
      var L = Math.max.apply(Math, e.map(function(H) {
        return H[1][0];
      })), B = Math.min.apply(Math, e.map(function(H) {
        return H[1][1];
      }));
      if (tinyThrottle(L - B) > 0)
        return [];
      R = [[M, L], [M, B]];
    }
  }
  return R.length || (R = o.filter(function(H) {
    var z = H[0], X = H[1];
    return e.every(function(Y) {
      return 0 <= tinyThrottle(z - Y[0][0]) && 0 <= tinyThrottle(Y[0][1] - z) && 0 <= tinyThrottle(X - Y[1][0]) && 0 <= tinyThrottle(Y[1][1] - X);
    });
  })), R.map(function(H) {
    return [tinyThrottle(H[0]), tinyThrottle(H[1])];
  });
}
function convertLines(o) {
  return __spreadArrays$2(o.slice(1), [o[0]]).map(function(t, e) {
    return [o[e], t];
  });
}
function getOverlapPointInfos(o, t) {
  var e = o.slice(), R = t.slice();
  getShapeDirection(e) === -1 && e.reverse(), getShapeDirection(R) === -1 && R.reverse();
  var N = convertLines(e), M = convertLines(R), D = N.map(function(U) {
    return getLinearConstants(U[0], U[1]);
  }), L = M.map(function(U) {
    return getLinearConstants(U[0], U[1]);
  }), B = [];
  D.forEach(function(U, H) {
    var z = N[H], X = [];
    L.forEach(function(Y, W) {
      var q = getIntersectionPointsByConstants(U, Y), Z = getPointsOnLines(q, [z, M[W]]);
      X.push.apply(X, Z.map(function(K) {
        return {
          index1: H,
          index2: W,
          pos: K,
          type: "intersection"
        };
      }));
    }), X.sort(function(Y, W) {
      return getDist$2(z[0], Y.pos) - getDist$2(z[0], W.pos);
    }), B.push.apply(B, X), isInside(z[1], R) && B.push({
      index1: H,
      index2: -1,
      pos: z[1],
      type: "inside"
    });
  }), M.forEach(function(U, H) {
    if (!!isInside(U[1], e)) {
      var z = !1, X = findIndex(B, function(Y) {
        var W = Y.index2;
        return W === H ? (z = !0, !1) : !!z;
      });
      X === -1 && (z = !1, X = findIndex(B, function(Y) {
        var W = Y.index1, q = Y.index2;
        return W === -1 && q + 1 === H ? (z = !0, !1) : !!z;
      })), X === -1 ? B.push({
        index1: -1,
        index2: H,
        pos: U[1],
        type: "inside"
      }) : B.splice(X, 0, {
        index1: -1,
        index2: H,
        pos: U[1],
        type: "inside"
      });
    }
  });
  var $ = {};
  return B.filter(function(U) {
    var H = U.pos, z = H[0] + "x" + H[1];
    return $[z] ? !1 : ($[z] = !0, !0);
  });
}
function getOverlapPoints(o, t) {
  var e = getOverlapPointInfos(o, t);
  return e.map(function(R) {
    var N = R.pos;
    return N;
  });
}
function getOverlapSize(o, t) {
  var e = getOverlapPoints(o, t);
  return getAreaSize(e);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$6 = function() {
  return __assign$6 = Object.assign || function(t) {
    for (var e, R = 1, N = arguments.length; R < N; R++) {
      e = arguments[R];
      for (var M in e)
        Object.prototype.hasOwnProperty.call(e, M) && (t[M] = e[M]);
    }
    return t;
  }, __assign$6.apply(this, arguments);
};
function __spreadArrays$1() {
  for (var o = 0, t = 0, e = arguments.length; t < e; t++)
    o += arguments[t].length;
  for (var R = Array(o), N = 0, t = 0; t < e; t++)
    for (var M = arguments[t], D = 0, L = M.length; D < L; D++, N++)
      R[N] = M[D];
  return R;
}
var EventEmitter$2 = /* @__PURE__ */ function() {
  function o() {
    this._events = {};
  }
  var t = o.prototype;
  return t.on = function(e, R) {
    if (isObject$2(e))
      for (var N in e)
        this.on(N, e[N]);
    else
      this._addEvent(e, R, {});
    return this;
  }, t.off = function(e, R) {
    if (!e)
      this._events = {};
    else if (isObject$2(e))
      for (var N in e)
        this.off(N);
    else if (!R)
      this._events[e] = [];
    else {
      var M = this._events[e];
      if (M) {
        var D = findIndex(M, function(L) {
          return L.listener === R;
        });
        D > -1 && M.splice(D, 1);
      }
    }
    return this;
  }, t.once = function(e, R) {
    var N = this;
    return R && this._addEvent(e, R, {
      once: !0
    }), new Promise(function(M) {
      N._addEvent(e, M, {
        once: !0
      });
    });
  }, t.emit = function(e, R) {
    var N = this;
    R === void 0 && (R = {});
    var M = this._events[e];
    if (!e || !M)
      return !0;
    var D = !1;
    return R.eventType = e, R.stop = function() {
      D = !0;
    }, R.currentTarget = this, __spreadArrays$1(M).forEach(function(L) {
      L.listener(R), L.once && N.off(e, L.listener);
    }), !D;
  }, t.trigger = function(e, R) {
    return R === void 0 && (R = {}), this.emit(e, R);
  }, t._addEvent = function(e, R, N) {
    var M = this._events;
    M[e] = M[e] || [];
    var D = M[e];
    D.push(__assign$6({
      listener: R
    }, N));
  }, o;
}();
const EventEmitter$3 = EventEmitter$2;
var FUNCTION = "function", STRING = "string";
function isString(o) {
  return typeof o === STRING;
}
function isFunction$2(o) {
  return typeof o === FUNCTION;
}
function now() {
  return Date.now ? Date.now() : new Date().getTime();
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$4 = function(o, t) {
  return extendStatics$4 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$4(o, t);
};
function __extends$4(o, t) {
  extendStatics$4(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$5 = function() {
  return __assign$5 = Object.assign || function(t) {
    for (var e, R = 1, N = arguments.length; R < N; R++) {
      e = arguments[R];
      for (var M in e)
        Object.prototype.hasOwnProperty.call(e, M) && (t[M] = e[M]);
    }
    return t;
  }, __assign$5.apply(this, arguments);
};
function getDefaultScrollPosition$1(o) {
  var t = o.container;
  return t === document.body ? [t.scrollLeft || document.documentElement.scrollLeft, t.scrollTop || document.documentElement.scrollTop] : [t.scrollLeft, t.scrollTop];
}
function getContainerElement(o) {
  if (o) {
    if (isString(o))
      return document.querySelector(o);
  } else
    return null;
  if (isFunction$2(o))
    return o();
  if (o instanceof Element)
    return o;
  if ("current" in o)
    return o.current;
  if ("value" in o)
    return o.value;
}
var DragScroll = /* @__PURE__ */ function(o) {
  __extends$4(t, o);
  function t() {
    var R = o !== null && o.apply(this, arguments) || this;
    return R._startRect = null, R._startPos = [], R._prevTime = 0, R._timer = 0, R._prevScrollPos = [0, 0], R._isWait = !1, R._flag = !1, R;
  }
  var e = t.prototype;
  return e.dragStart = function(R, N) {
    var M = getContainerElement(N.container);
    if (!M) {
      this._flag = !1;
      return;
    }
    var D = 0, L = 0, B = 0, $ = 0;
    if (M === document.body)
      B = window.innerWidth, $ = window.innerHeight;
    else {
      var U = M.getBoundingClientRect();
      D = U.top, L = U.left, B = U.width, $ = U.height;
    }
    this._flag = !0, this._startPos = [R.clientX, R.clientY], this._startRect = {
      top: D,
      left: L,
      width: B,
      height: $
    }, this._prevScrollPos = this._getScrollPosition([0, 0], N);
  }, e.drag = function(R, N) {
    if (!!this._flag) {
      var M = R.clientX, D = R.clientY, L = N.threshold, B = L === void 0 ? 0 : L, $ = this, U = $._startRect, H = $._startPos, z = [0, 0];
      return U.top > D - B ? (H[1] > U.top || D < H[1]) && (z[1] = -1) : U.top + U.height < D + B && (H[1] < U.top + U.height || D > H[1]) && (z[1] = 1), U.left > M - B ? (H[0] > U.left || M < H[0]) && (z[0] = -1) : U.left + U.width < M + B && (H[0] < U.left + U.width || M > H[0]) && (z[0] = 1), clearTimeout(this._timer), !z[0] && !z[1] ? !1 : this._continueDrag(__assign$5(__assign$5({}, N), {
        direction: z,
        inputEvent: R,
        isDrag: !0
      }));
    }
  }, e.checkScroll = function(R) {
    var N = this;
    if (this._isWait)
      return !1;
    var M = R.prevScrollPos, D = M === void 0 ? this._prevScrollPos : M, L = R.direction, B = R.throttleTime, $ = B === void 0 ? 0 : B, U = R.inputEvent, H = R.isDrag, z = this._getScrollPosition(L || [0, 0], R), X = z[0] - D[0], Y = z[1] - D[1], W = L || [X ? Math.abs(X) / X : 0, Y ? Math.abs(Y) / Y : 0];
    return this._prevScrollPos = z, !X && !Y ? !1 : (this.trigger("move", {
      offsetX: W[0] ? X : 0,
      offsetY: W[1] ? Y : 0,
      inputEvent: U
    }), $ && H && (this._timer = window.setTimeout(function() {
      N._continueDrag(R);
    }, $)), !0);
  }, e.dragEnd = function() {
    clearTimeout(this._timer);
  }, e._getScrollPosition = function(R, N) {
    var M = N.container, D = N.getScrollPosition, L = D === void 0 ? getDefaultScrollPosition$1 : D;
    return L({
      container: getContainerElement(M),
      direction: R
    });
  }, e._continueDrag = function(R) {
    var N = this, M = R.container, D = R.direction, L = R.throttleTime, B = R.useScroll, $ = R.isDrag, U = R.inputEvent;
    if (!($ && this._isWait)) {
      var H = now(), z = Math.max(L + this._prevTime - H, 0);
      if (z > 0)
        return this._timer = window.setTimeout(function() {
          N._continueDrag(R);
        }, z), !1;
      this._prevTime = H;
      var X = this._getScrollPosition(D, R);
      return this._prevScrollPos = X, $ && (this._isWait = !0), this.trigger("scroll", {
        container: getContainerElement(M),
        direction: D,
        inputEvent: U
      }), this._isWait = !1, B || this.checkScroll(__assign$5(__assign$5({}, R), {
        prevScrollPos: X,
        direction: D,
        inputEvent: U
      }));
    }
  }, t;
}(EventEmitter$3);
const DragScroll$1 = DragScroll;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$3 = function(o, t) {
  return extendStatics$3 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$3(o, t);
};
function __extends$3(o, t) {
  extendStatics$3(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$4 = function() {
  return __assign$4 = Object.assign || function(t) {
    for (var e, R = 1, N = arguments.length; R < N; R++) {
      e = arguments[R];
      for (var M in e)
        Object.prototype.hasOwnProperty.call(e, M) && (t[M] = e[M]);
    }
    return t;
  }, __assign$4.apply(this, arguments);
};
function getRad(o, t) {
  var e = t[0] - o[0], R = t[1] - o[1], N = Math.atan2(R, e);
  return N >= 0 ? N : N + Math.PI * 2;
}
function getRotatiion(o) {
  return getRad([o[0].clientX, o[0].clientY], [o[1].clientX, o[1].clientY]) / Math.PI * 180;
}
function isMultiTouch(o) {
  return o.touches && o.touches.length >= 2;
}
function getEventClients(o) {
  return o ? o.touches ? getClients(o.touches) : [getClient(o)] : [];
}
function isMouseEvent(o) {
  return o && (o.type.indexOf("mouse") > -1 || "button" in o);
}
function getPosition(o, t, e) {
  var R = e.length, N = getAverageClient(o, R), M = N.clientX, D = N.clientY, L = N.originalClientX, B = N.originalClientY, $ = getAverageClient(t, R), U = $.clientX, H = $.clientY, z = getAverageClient(e, R), X = z.clientX, Y = z.clientY, W = M - U, q = D - H, Z = M - X, K = D - Y;
  return {
    clientX: L,
    clientY: B,
    deltaX: W,
    deltaY: q,
    distX: Z,
    distY: K
  };
}
function getDist$1(o) {
  return Math.sqrt(Math.pow(o[0].clientX - o[1].clientX, 2) + Math.pow(o[0].clientY - o[1].clientY, 2));
}
function getClients(o) {
  for (var t = Math.min(o.length, 2), e = [], R = 0; R < t; ++R)
    e.push(getClient(o[R]));
  return e;
}
function getClient(o) {
  return {
    clientX: o.clientX,
    clientY: o.clientY
  };
}
function getAverageClient(o, t) {
  t === void 0 && (t = o.length);
  for (var e = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  }, R = 0; R < t; ++R) {
    var N = o[R];
    e.originalClientX += "originalClientX" in N ? N.originalClientX : N.clientX, e.originalClientY += "originalClientY" in N ? N.originalClientY : N.clientY, e.clientX += N.clientX, e.clientY += N.clientY;
  }
  return t ? {
    clientX: e.clientX / t,
    clientY: e.clientY / t,
    originalClientX: e.originalClientX / t,
    originalClientY: e.originalClientY / t
  } : e;
}
var ClientStore = /* @__PURE__ */ function() {
  function o(e) {
    this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = e, this.prevClients = e, this.length = e.length;
  }
  var t = o.prototype;
  return t.getAngle = function(e) {
    return e === void 0 && (e = this.prevClients), getRotatiion(e);
  }, t.getRotation = function(e) {
    return e === void 0 && (e = this.prevClients), getRotatiion(e) - getRotatiion(this.startClients);
  }, t.getPosition = function(e, R) {
    e === void 0 && (e = this.prevClients);
    var N = getPosition(e || this.prevClients, this.prevClients, this.startClients), M = N.deltaX, D = N.deltaY;
    return this.movement += Math.sqrt(M * M + D * D), this.prevClients = e, N;
  }, t.getPositions = function(e) {
    e === void 0 && (e = this.prevClients);
    var R = this.prevClients;
    return this.startClients.map(function(N, M) {
      return getPosition([e[M]], [R[M]], [N]);
    });
  }, t.getMovement = function(e) {
    var R = this.movement;
    if (!e)
      return R;
    var N = getAverageClient(e, this.length), M = getAverageClient(this.prevClients, this.length), D = N.clientX - M.clientX, L = N.clientY - M.clientY;
    return Math.sqrt(D * D + L * L) + R;
  }, t.getDistance = function(e) {
    return e === void 0 && (e = this.prevClients), getDist$1(e);
  }, t.getScale = function(e) {
    return e === void 0 && (e = this.prevClients), getDist$1(e) / getDist$1(this.startClients);
  }, t.move = function(e, R) {
    this.startClients.forEach(function(N) {
      N.clientX -= e, N.clientY -= R;
    });
  }, o;
}(), INPUT_TAGNAMES = ["textarea", "input"], Gesto = /* @__PURE__ */ function(o) {
  __extends$3(t, o);
  function t(R, N) {
    N === void 0 && (N = {});
    var M = o.call(this) || this;
    M.options = {}, M.flag = !1, M.pinchFlag = !1, M.data = {}, M.isDrag = !1, M.isPinch = !1, M.isMouse = !1, M.isTouch = !1, M.clientStores = [], M.targets = [], M.prevTime = 0, M.doubleFlag = !1, M._dragFlag = !1, M._isMouseEvent = !1, M._isSecondaryButton = !1, M._preventMouseEvent = !1, M.onDragStart = function(z, X) {
      if (X === void 0 && (X = !0), !(!M.flag && z.cancelable === !1)) {
        var Y = M.options, W = Y.container, q = Y.pinchOutside, Z = Y.preventWheelClick, K = Y.preventRightClick, J = Y.preventDefault, Q = Y.checkInput, et = Y.preventClickEventOnDragStart, tt = Y.preventClickEventOnDrag, st = Y.preventClickEventByCondition, rt = M.isTouch, at = !M.flag;
        if (M._isSecondaryButton = z.which === 3 || z.button === 2, Z && (z.which === 2 || z.button === 1) || K && (z.which === 3 || z.button === 2))
          return M.stop(), !1;
        if (at) {
          var ut = document.activeElement, dt = z.target;
          if (dt) {
            var ct = dt.tagName.toLowerCase(), pt = INPUT_TAGNAMES.indexOf(ct) > -1, mt = dt.isContentEditable;
            if (pt || mt) {
              if (Q || ut === dt || ut && mt && ut.isContentEditable && ut.contains(dt))
                return !1;
            } else if ((J || z.type === "touchstart") && ut) {
              var vt = ut.tagName;
              (ut.isContentEditable || INPUT_TAGNAMES.indexOf(vt) > -1) && ut.blur();
            }
            (et || tt || st) && addEvent(window, "click", M._onClick, !0);
          }
          M.clientStores = [new ClientStore(getEventClients(z))], M.flag = !0, M.isDrag = !1, M._dragFlag = !0, M.data = {}, M.doubleFlag = now$1() - M.prevTime < 200, M._isMouseEvent = isMouseEvent(z), !M._isMouseEvent && M._preventMouseEvent && (M._preventMouseEvent = !1);
          var _t = M._preventMouseEvent || M.emit("dragStart", __assign$4(__assign$4({
            data: M.data,
            datas: M.data,
            inputEvent: z,
            isMouseEvent: M._isMouseEvent,
            isSecondaryButton: M._isSecondaryButton,
            isTrusted: X,
            isDouble: M.doubleFlag
          }, M.getCurrentStore().getPosition()), {
            preventDefault: function() {
              z.preventDefault();
            },
            preventDrag: function() {
              M._dragFlag = !1;
            }
          }));
          _t === !1 && M.stop(), M._isMouseEvent && M.flag && J && z.preventDefault();
        }
        if (!M.flag)
          return !1;
        var xt = 0;
        if (at ? (M._attchDragEvent(), rt && q && (xt = setTimeout(function() {
          addEvent(W, "touchstart", M.onDragStart, {
            passive: !1
          });
        }))) : rt && q && removeEvent(W, "touchstart", M.onDragStart), M.flag && isMultiTouch(z)) {
          if (clearTimeout(xt), at && z.touches.length !== z.changedTouches.length)
            return;
          M.pinchFlag || M.onPinchStart(z);
        }
      }
    }, M.onDrag = function(z, X) {
      if (!!M.flag) {
        var Y = M.options.preventDefault;
        !M._isMouseEvent && Y && z.preventDefault();
        var W = getEventClients(z), q = M.moveClients(W, z, !1);
        if (M._dragFlag) {
          if (M.pinchFlag || q.deltaX || q.deltaY) {
            var Z = M._preventMouseEvent || M.emit("drag", __assign$4(__assign$4({}, q), {
              isScroll: !!X,
              inputEvent: z
            }));
            if (Z === !1) {
              M.stop();
              return;
            }
          }
          M.pinchFlag && M.onPinch(z, W);
        }
        M.getCurrentStore().getPosition(W, !0);
      }
    }, M.onDragEnd = function(z) {
      if (!!M.flag) {
        var X = M.options, Y = X.pinchOutside, W = X.container, q = X.preventClickEventOnDrag, Z = X.preventClickEventOnDragStart, K = X.preventClickEventByCondition, J = M.isDrag;
        (q || Z || K) && requestAnimationFrame(function() {
          M._allowClickEvent();
        }), !K && !Z && q && !J && M._allowClickEvent(), M.isTouch && Y && removeEvent(W, "touchstart", M.onDragStart), M.pinchFlag && M.onPinchEnd(z);
        var Q = z != null && z.touches ? getEventClients(z) : [], et = Q.length;
        et === 0 || !M.options.keepDragging ? M.flag = !1 : M._addStore(new ClientStore(Q));
        var tt = M._getPosition(), st = now$1(), rt = !J && M.doubleFlag;
        M.prevTime = J || rt ? 0 : st, M.flag || (M._dettachDragEvent(), M._preventMouseEvent || M.emit("dragEnd", __assign$4({
          data: M.data,
          datas: M.data,
          isDouble: rt,
          isDrag: J,
          isClick: !J,
          isMouseEvent: M._isMouseEvent,
          isSecondaryButton: M._isSecondaryButton,
          inputEvent: z
        }, tt)), M.clientStores = [], M._isMouseEvent || (M._preventMouseEvent = !0, requestAnimationFrame(function() {
          requestAnimationFrame(function() {
            M._preventMouseEvent = !1;
          });
        })));
      }
    }, M.onBlur = function() {
      M.onDragEnd();
    }, M._allowClickEvent = function() {
      removeEvent(window, "click", M._onClick, !0);
    }, M._onClick = function(z) {
      M._preventMouseEvent = !1;
      var X = M.options.preventClickEventByCondition;
      X != null && X(z) || (z.stopPropagation(), z.preventDefault());
    }, M._onContextMenu = function(z) {
      var X = M.options;
      X.preventRightClick ? M.onDragEnd(z) : z.preventDefault();
    }, M._passCallback = function() {
    };
    var D = [].concat(R);
    M.options = __assign$4({
      checkInput: !1,
      container: D.length > 1 ? window : D[0],
      preventRightClick: !0,
      preventWheelClick: !0,
      preventClickEventOnDragStart: !1,
      preventClickEventOnDrag: !1,
      preventClickEventByCondition: null,
      preventDefault: !0,
      checkWindowBlur: !1,
      keepDragging: !1,
      pinchThreshold: 0,
      events: ["touch", "mouse"]
    }, N);
    var L = M.options, B = L.container, $ = L.events, U = L.checkWindowBlur;
    if (M.isTouch = $.indexOf("touch") > -1, M.isMouse = $.indexOf("mouse") > -1, M.targets = D, M.isMouse && (D.forEach(function(z) {
      addEvent(z, "mousedown", M.onDragStart), addEvent(z, "mousemove", M._passCallback);
    }), addEvent(B, "contextmenu", M._onContextMenu)), U && addEvent(window, "blur", M.onBlur), M.isTouch) {
      var H = {
        passive: !1
      };
      D.forEach(function(z) {
        addEvent(z, "touchstart", M.onDragStart, H), addEvent(z, "touchmove", M._passCallback, H);
      });
    }
    return M;
  }
  var e = t.prototype;
  return e.stop = function() {
    this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._allowClickEvent(), this._dettachDragEvent();
  }, e.getMovement = function(R) {
    return this.getCurrentStore().getMovement(R) + this.clientStores.slice(1).reduce(function(N, M) {
      return N + M.movement;
    }, 0);
  }, e.isDragging = function() {
    return this.isDrag;
  }, e.isFlag = function() {
    return this.flag;
  }, e.isPinchFlag = function() {
    return this.pinchFlag;
  }, e.isDoubleFlag = function() {
    return this.doubleFlag;
  }, e.isPinching = function() {
    return this.isPinch;
  }, e.scrollBy = function(R, N, M, D) {
    D === void 0 && (D = !0), this.flag && (this.clientStores[0].move(R, N), D && this.onDrag(M, !0));
  }, e.move = function(R, N) {
    var M = R[0], D = R[1], L = this.getCurrentStore(), B = L.prevClients;
    return this.moveClients(B.map(function($) {
      var U = $.clientX, H = $.clientY;
      return {
        clientX: U + M,
        clientY: H + D,
        originalClientX: U,
        originalClientY: H
      };
    }), N, !0);
  }, e.triggerDragStart = function(R) {
    this.onDragStart(R, !1);
  }, e.setEventData = function(R) {
    var N = this.data;
    for (var M in R)
      N[M] = R[M];
    return this;
  }, e.setEventDatas = function(R) {
    return this.setEventData(R);
  }, e.getCurrentEvent = function(R) {
    return __assign$4(__assign$4({
      data: this.data,
      datas: this.data
    }, this._getPosition()), {
      movement: this.getMovement(),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: !1,
      inputEvent: R
    });
  }, e.getEventData = function() {
    return this.data;
  }, e.getEventDatas = function() {
    return this.data;
  }, e.unset = function() {
    var R = this, N = this.targets, M = this.options.container;
    this.off(), removeEvent(window, "blur", this.onBlur), this.isMouse && (N.forEach(function(D) {
      removeEvent(D, "mousedown", R.onDragStart);
    }), removeEvent(M, "contextmenu", this._onContextMenu)), this.isTouch && (N.forEach(function(D) {
      removeEvent(D, "touchstart", R.onDragStart);
    }), removeEvent(M, "touchstart", this.onDragStart)), this._dettachDragEvent();
  }, e.onPinchStart = function(R) {
    var N = this.options.pinchThreshold;
    if (!(this.isDrag && this.getMovement() > N)) {
      var M = new ClientStore(getEventClients(R));
      this.pinchFlag = !0, this._addStore(M);
      var D = this.emit("pinchStart", __assign$4(__assign$4({
        data: this.data,
        datas: this.data,
        angle: M.getAngle(),
        touches: this.getCurrentStore().getPositions()
      }, M.getPosition()), {
        inputEvent: R
      }));
      D === !1 && (this.pinchFlag = !1);
    }
  }, e.onPinch = function(R, N) {
    if (!(!this.flag || !this.pinchFlag || N.length < 2)) {
      var M = this.getCurrentStore();
      this.isPinch = !0, this.emit("pinch", __assign$4(__assign$4({
        data: this.data,
        datas: this.data,
        movement: this.getMovement(N),
        angle: M.getAngle(N),
        rotation: M.getRotation(N),
        touches: M.getPositions(N),
        scale: M.getScale(N),
        distance: M.getDistance(N)
      }, M.getPosition(N)), {
        inputEvent: R
      }));
    }
  }, e.onPinchEnd = function(R) {
    if (!!this.pinchFlag) {
      var N = this.isPinch;
      this.isPinch = !1, this.pinchFlag = !1;
      var M = this.getCurrentStore();
      this.emit("pinchEnd", __assign$4(__assign$4({
        data: this.data,
        datas: this.data,
        isPinch: N,
        touches: M.getPositions()
      }, M.getPosition()), {
        inputEvent: R
      }));
    }
  }, e.getCurrentStore = function() {
    return this.clientStores[0];
  }, e.moveClients = function(R, N, M) {
    var D = this._getPosition(R, M);
    return (D.deltaX || D.deltaY) && (this.isDrag = !0), __assign$4(__assign$4({
      data: this.data,
      datas: this.data
    }, D), {
      movement: this.getMovement(R),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: !1,
      isMouseEvent: this._isMouseEvent,
      isSecondaryButton: this._isSecondaryButton,
      inputEvent: N
    });
  }, e._addStore = function(R) {
    this.clientStores.splice(0, 0, R);
  }, e._getPosition = function(R, N) {
    var M = this.getCurrentStore(), D = M.getPosition(R, N), L = this.clientStores.slice(1).reduce(function(U, H) {
      var z = H.getPosition();
      return U.distX += z.distX, U.distY += z.distY, U;
    }, D), B = L.distX, $ = L.distY;
    return __assign$4(__assign$4({}, D), {
      distX: B,
      distY: $
    });
  }, e._attchDragEvent = function() {
    var R = this.options.container, N = {
      passive: !1
    };
    this.isMouse && (addEvent(R, "mousemove", this.onDrag), addEvent(R, "mouseup", this.onDragEnd)), this.isTouch && (addEvent(R, "touchmove", this.onDrag, N), addEvent(R, "touchend", this.onDragEnd, N), addEvent(R, "touchcancel", this.onDragEnd, N));
  }, e._dettachDragEvent = function() {
    var R = this.options.container;
    this.isMouse && (removeEvent(R, "mousemove", this.onDrag), removeEvent(R, "mouseup", this.onDragEnd)), this.isTouch && (removeEvent(R, "touchstart", this.onDragStart), removeEvent(R, "touchmove", this.onDrag), removeEvent(R, "touchend", this.onDragEnd), removeEvent(R, "touchcancel", this.onDragEnd));
  }, t;
}(EventEmitter$3);
const Gesto$1 = Gesto;
function hash$2(o) {
  for (var t = 5381, e = o.length; e; )
    t = t * 33 ^ o.charCodeAt(--e);
  return t >>> 0;
}
var stringHash = hash$2;
function getHash(o) {
  return stringHash(o).toString(36);
}
function getShadowRoot$1(o) {
  if (o && o.getRootNode) {
    var t = o.getRootNode();
    if (t.nodeType === 11)
      return t;
  }
}
function replaceStyle(o, t, e) {
  return e.original ? t : t.replace(/([^};{\s}][^};{]*|^\s*){/mg, function(R, N) {
    var M = N.trim();
    return (M ? splitComma(M) : [""]).map(function(D) {
      var L = D.trim();
      return L.indexOf("@") === 0 ? L : L.indexOf(":global") > -1 ? L.replace(/\:global/g, "") : L.indexOf(":host") > -1 ? "" + L.replace(/\:host/g, "." + o) : L ? "." + o + " " + L : "." + o;
    }).join(", ") + " {";
  });
}
function injectStyle(o, t, e, R) {
  var N = document.createElement("style");
  return N.setAttribute("type", "text/css"), N.setAttribute("data-styled-id", o), e.nonce && N.setAttribute("nonce", e.nonce), N.innerHTML = replaceStyle(o, t, e), (R || document.head || document.body).appendChild(N), N;
}
function styled$1(o) {
  var t = "rCS" + getHash(o), e = 0, R;
  return {
    className: t,
    inject: function(N, M) {
      M === void 0 && (M = {});
      var D = getShadowRoot$1(N), L = e === 0, B;
      return (D || L) && (B = injectStyle(t, o, M, D)), L && (R = B), D || ++e, {
        destroy: function() {
          D ? (D.removeChild(B), B = null) : (e > 0 && --e, e === 0 && R && (R.parentNode.removeChild(R), R = null));
        }
      };
    }
  };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$2 = function(o, t) {
  return extendStatics$2 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics$2(o, t);
};
function __extends$2(o, t) {
  extendStatics$2(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$3 = function() {
  return __assign$3 = Object.assign || function(t) {
    for (var e, R = 1, N = arguments.length; R < N; R++) {
      e = arguments[R];
      for (var M in e)
        Object.prototype.hasOwnProperty.call(e, M) && (t[M] = e[M]);
    }
    return t;
  }, __assign$3.apply(this, arguments);
};
function __rest$1(o, t) {
  var e = {};
  for (var R in o)
    Object.prototype.hasOwnProperty.call(o, R) && t.indexOf(R) < 0 && (e[R] = o[R]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var N = 0, R = Object.getOwnPropertySymbols(o); N < R.length; N++)
      t.indexOf(R[N]) < 0 && Object.prototype.propertyIsEnumerable.call(o, R[N]) && (e[R[N]] = o[R[N]]);
  return e;
}
var StyledElement = /* @__PURE__ */ function(o) {
  __extends$2(t, o);
  function t() {
    var R = o !== null && o.apply(this, arguments) || this;
    return R.injectResult = null, R.tag = "div", R;
  }
  var e = t.prototype;
  return e.render = function() {
    var R = this.props, N = R.className, M = N === void 0 ? "" : N;
    R.cspNonce;
    var D = R.portalContainer, L = __rest$1(R, ["className", "cspNonce", "portalContainer"]), B = this.injector.className, $ = this.tag, U = {};
    return version.indexOf("simple") > -1 && D && (U = {
      portalContainer: D
    }), createElement($, __assign$3({
      ref: ref(this, "element"),
      "data-styled-id": B,
      className: M + " " + B
    }, U, L));
  }, e.componentDidMount = function() {
    this.injectResult = this.injector.inject(this.element, {
      nonce: this.props.cspNonce
    });
  }, e.componentWillUnmount = function() {
    this.injectResult.destroy(), this.injectResult = null;
  }, e.getElement = function() {
    return this.element;
  }, t;
}(Component);
function styled(o, t) {
  var e = styled$1(t);
  return /* @__PURE__ */ function(R) {
    __extends$2(N, R);
    function N() {
      var M = R !== null && R.apply(this, arguments) || this;
      return M.injector = e, M.tag = o, M;
    }
    return N;
  }(StyledElement);
}
var extendStatics$1 = function(o, t) {
  return extendStatics$1 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      Object.prototype.hasOwnProperty.call(R, N) && (e[N] = R[N]);
  }, extendStatics$1(o, t);
};
function __extends$1(o, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  extendStatics$1(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$2 = function() {
  return __assign$2 = Object.assign || function(t) {
    for (var e, R = 1, N = arguments.length; R < N; R++) {
      e = arguments[R];
      for (var M in e)
        Object.prototype.hasOwnProperty.call(e, M) && (t[M] = e[M]);
    }
    return t;
  }, __assign$2.apply(this, arguments);
};
function __rest(o, t) {
  var e = {};
  for (var R in o)
    Object.prototype.hasOwnProperty.call(o, R) && t.indexOf(R) < 0 && (e[R] = o[R]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var N = 0, R = Object.getOwnPropertySymbols(o); N < R.length; N++)
      t.indexOf(R[N]) < 0 && Object.prototype.propertyIsEnumerable.call(o, R[N]) && (e[R[N]] = o[R[N]]);
  return e;
}
function __decorate$1(o, t, e, R) {
  var N = arguments.length, M = N < 3 ? t : R === null ? R = Object.getOwnPropertyDescriptor(t, e) : R, D;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    M = Reflect.decorate(o, t, e, R);
  else
    for (var L = o.length - 1; L >= 0; L--)
      (D = o[L]) && (M = (N < 3 ? D(M) : N > 3 ? D(t, e, M) : D(t, e)) || M);
  return N > 3 && M && Object.defineProperty(t, e, M), M;
}
function __spreadArray(o, t, e) {
  if (e || arguments.length === 2)
    for (var R = 0, N = t.length, M; R < N; R++)
      (M || !(R in t)) && (M || (M = Array.prototype.slice.call(t, 0, R)), M[R] = t[R]);
  return o.concat(M || Array.prototype.slice.call(t));
}
function makeAble(o, t) {
  var e;
  return __assign$2({
    events: {},
    props: (e = {}, e[o] = Boolean, e),
    name: o
  }, t);
}
function getSVGCursor(o, t) {
  return 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="'.concat(32 * o, 'px" height="').concat(32 * o, 'px" viewBox="0 0 32 32" ><path d="M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z" stroke-linejoin="round" stroke-width="1.2" fill="black" stroke="white" style="transform:rotate(').concat(t, 'deg);transform-origin: 16px 16px"></path></svg>');
}
function getCursorCSS(o) {
  var t = getSVGCursor(1, o), e = Math.round(o / 45) * 45 % 180, R = "ns-resize";
  return e === 135 ? R = "nwse-resize" : e === 45 ? R = "nesw-resize" : e === 90 && (R = "ew-resize"), "cursor:".concat(R, ";cursor: url('").concat(t, "') 16 16, ").concat(R, ";");
}
var agent = agent$1(), IS_WEBKIT = agent.browser.webkit, IS_WEBKIT605 = IS_WEBKIT && function() {
  var o = typeof window > "u" ? {
    userAgent: ""
  } : window.navigator, t = /applewebkit\/([^\s]+)/g.exec(o.userAgent.toLowerCase());
  return t ? parseFloat(t[1]) < 605 : !1;
}(), IS_FIREFOX = agent.browser.name === "firefox", IS_SAFARI_ABOVE15 = parseInt(agent.browser.webkitVersion, 10) >= 612 || parseInt(agent.browser.version, 10) >= 15, PREFIX = "moveable-", MOVEABLE_CSS = `
{
	position: absolute;
	width: 1px;
	height: 1px;
	left: 0;
	top: 0;
    z-index: 3000;
    --moveable-color: #4af;
    --zoom: 1;
    --zoompx: 1px;
    will-change: transform;
}
.control-box {
    z-index: 0;
}
.line, .control {
    position: absolute;
	left: 0;
    top: 0;
    will-change: transform;
}
.control {
	width: 14px;
	height: 14px;
	border-radius: 50%;
	border: 2px solid #fff;
	box-sizing: border-box;
    background: #4af;
    background: var(--moveable-color);
	margin-top: -7px;
    margin-left: -7px;
    border: 2px solid #fff;
    z-index: 10;
}
.padding {
    position: absolute;
    top: 0px;
    left: 0px;
    width: 100px;
    height: 100px;
    transform-origin: 0 0;
}
.line {
	width: 1px;
    height: 1px;
    background: #4af;
    background: var(--moveable-color);
	transform-origin: 0px 50%;
}
.line.edge {
    z-index: 1;
    background: transparent;
}
.line.dashed {
    box-sizing: border-box;
    background: transparent;
}
.line.dashed.horizontal {
    border-top: 1px dashed #4af;
    border-top-color: #4af;
    border-top-color: var(--moveable-color);
}
.line.dashed.vertical {
    border-left: 1px dashed #4af;
    border-left-color: #4af;
    border-left-color: var(--moveable-color);
}
.line.vertical {
    transform: translateX(-50%);
}
.line.horizontal {
    transform: translateY(-50%);
}
.line.vertical.bold {
    width: 2px;
}
.line.horizontal.bold {
    height: 2px;
}

.control.origin {
	border-color: #f55;
	background: #fff;
	width: 12px;
	height: 12px;
	margin-top: -6px;
    margin-left: -6px;
	pointer-events: none;
}
`.concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function(o) {
  return `
.direction[data-rotation="`.concat(o, `"] {
	`).concat(getCursorCSS(o), `
}
`);
}).join(`
`), `
.group {
    z-index: -1;
}
.area {
    position: absolute;
}
.area-pieces {
    position: absolute;
    top: 0;
    left: 0;
    display: none;
}
.area.avoid, .area.pass {
    pointer-events: none;
}
.area.avoid+.area-pieces {
    display: block;
}
.area-piece {
    position: absolute;
}

`).concat(IS_WEBKIT605 ? `:global svg *:before {
	content:"";
	transform-origin: inherit;
}` : "", `
`), NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]], FLOAT_POINT_NUM = 1e-4, TINY_NUM = 1e-7, MIN_SCALE = 1e-9, MAX_NUM = Math.pow(10, 10), MIN_NUM = -MAX_NUM, DIRECTIONS4 = ["n", "w", "s", "e"], DIRECTIONS = ["n", "w", "s", "e", "nw", "ne", "sw", "se"], DIRECTION_REGION_TO_DIRECTION = {
  n: [0, -1],
  e: [1, 0],
  s: [0, 1],
  w: [-1, 0],
  nw: [-1, -1],
  ne: [1, -1],
  sw: [-1, 1],
  se: [1, 1]
}, DIRECTION_INDEXES = {
  n: [0, 1],
  e: [1, 3],
  s: [3, 2],
  w: [2, 0],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
}, DIRECTION_ROTATIONS = {
  n: 0,
  s: 180,
  w: 270,
  e: 90,
  nw: 315,
  ne: 45,
  sw: 225,
  se: 135
}, MOVEABLE_METHODS = ["isMoveableElement", "updateRect", "updateTarget", "destroy", "dragStart", "isInside", "hitTest", "setState", "getRect", "request", "isDragging", "getManager", "forceUpdate", "waitToChangeTarget"];
function setCustomDrag(o, t, e, R, N, M) {
  M === void 0 && (M = "draggable");
  var D = t.gestos[M].move(e, o.inputEvent), L = D.originalDatas || D.datas, B = L[M] || (L[M] = {});
  return __assign$2(__assign$2({}, N ? convertDragDist(t, D) : D), {
    isPinch: !!R,
    parentEvent: !0,
    datas: B,
    originalDatas: o.originalDatas
  });
}
var CustomGesto = /* @__PURE__ */ function() {
  function o(e) {
    var R;
    e === void 0 && (e = "draggable"), this.ableName = e, this.prevX = 0, this.prevY = 0, this.startX = 0, this.startY = 0, this.isDrag = !1, this.isFlag = !1, this.datas = {
      draggable: {}
    }, this.datas = (R = {}, R[e] = {}, R);
  }
  var t = o.prototype;
  return t.dragStart = function(e, R) {
    this.isDrag = !1, this.isFlag = !1;
    var N = R.originalDatas;
    return this.datas = N, N[this.ableName] || (N[this.ableName] = {}), __assign$2(__assign$2({}, this.move(e, R.inputEvent)), {
      type: "dragstart"
    });
  }, t.drag = function(e, R) {
    return this.move([e[0] - this.prevX, e[1] - this.prevY], R);
  }, t.move = function(e, R) {
    var N, M;
    return this.isFlag ? (N = this.prevX + e[0], M = this.prevY + e[1], (e[0] || e[1]) && (this.isDrag = !0)) : (this.prevX = e[0], this.prevY = e[1], this.startX = e[0], this.startY = e[1], N = e[0], M = e[1], this.isFlag = !0), this.prevX = N, this.prevY = M, {
      type: "drag",
      clientX: N,
      clientY: M,
      inputEvent: R,
      isDrag: this.isDrag,
      distX: N - this.startX,
      distY: M - this.startY,
      deltaX: e[0],
      deltaY: e[1],
      datas: this.datas[this.ableName],
      originalDatas: this.datas,
      parentEvent: !0,
      parentGesto: this
    };
  }, o;
}();
function calculatePointerDist(o, t) {
  var e = t.clientX, R = t.clientY, N = t.datas, M = o.state, D = M.moveableClientRect, L = M.rootMatrix, B = M.is3d, $ = M.pos1, U = D.left, H = D.top, z = B ? 4 : 3, X = minus(calculateInversePosition(L, [e - U, R - H], z), $), Y = X[0], W = X[1], q = getDragDist({
    datas: N,
    distX: Y,
    distY: W
  }), Z = q[0], K = q[1];
  return [Z, K];
}
function setDragStart(o, t) {
  var e = t.datas, R = o.state, N = R.allMatrix, M = R.beforeMatrix, D = R.is3d, L = R.left, B = R.top, $ = R.origin, U = R.offsetMatrix, H = R.targetMatrix, z = R.transformOrigin, X = D ? 4 : 3;
  e.is3d = D, e.matrix = N, e.targetMatrix = H, e.beforeMatrix = M, e.offsetMatrix = U, e.transformOrigin = z, e.inverseMatrix = invert(N, X), e.inverseBeforeMatrix = invert(M, X), e.absoluteOrigin = convertPositionMatrix(plus([L, B], $), X), e.startDragBeforeDist = calculate(e.inverseBeforeMatrix, e.absoluteOrigin, X), e.startDragDist = calculate(e.inverseMatrix, e.absoluteOrigin, X);
}
function getTransformDirection(o) {
  return calculateMoveablePosition(o.datas.beforeTransform, [50, 50], 100, 100).direction;
}
function resolveTransformEvent(o, t) {
  var e = o.datas, R = o.originalDatas.beforeRenderable, N = e.transformIndex, M = R.nextTransforms, D = M.length, L = R.nextTransformAppendedIndexes, B = 0;
  N === -1 ? (B = M.length, e.transformIndex = B) : find$1(L, function(z) {
    return z.index === N && z.functionName === t;
  }) ? B = N : B = N + L.filter(function(z) {
    return z.index < N;
  }).length;
  var $ = convertTransformInfo(M, B), U = $.targetFunction, H = t === "rotate" ? "rotateZ" : t;
  e.beforeFunctionTexts = $.beforeFunctionTexts, e.afterFunctionTexts = $.afterFunctionTexts, e.beforeTransform = $.beforeFunctionMatrix, e.beforeTransform2 = $.beforeFunctionMatrix2, e.targetTansform = $.targetFunctionMatrix, e.afterTransform = $.afterFunctionMatrix, e.afterTransform2 = $.afterFunctionMatrix2, e.targetAllTransform = $.allFunctionMatrix, U.functionName === H ? (e.afterFunctionTexts.splice(0, 1), e.isAppendTransform = !1) : D > B && (e.isAppendTransform = !0, R.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], L, !0), [{
    functionName: t,
    index: B,
    isAppend: !0
  }], !1));
}
function convertTransformFormat(o, t, e) {
  return "".concat(o.beforeFunctionTexts.join(" "), " ").concat(o.isAppendTransform ? e : t, " ").concat(o.afterFunctionTexts.join(" "));
}
function getTransformDist(o) {
  var t = o.datas, e = o.distX, R = o.distY, N = getBeforeDragDist({
    datas: t,
    distX: e,
    distY: R
  }), M = N[0], D = N[1], L = getTransfromMatrix(t, fromTranslation([M, D], 4));
  return calculate(L, convertPositionMatrix([0, 0, 0], 4), 4);
}
function getTransfromMatrix(o, t, e) {
  var R = o.beforeTransform, N = o.afterTransform, M = o.beforeTransform2, D = o.afterTransform2, L = o.targetAllTransform, B = e ? multiply(L, t, 4) : multiply(t, L, 4), $ = multiply(invert(e ? M : R, 4), B, 4), U = multiply($, invert(e ? D : N, 4), 4);
  return U;
}
function getBeforeDragDist(o) {
  var t = o.datas, e = o.distX, R = o.distY, N = t.inverseBeforeMatrix, M = t.is3d, D = t.startDragBeforeDist, L = t.absoluteOrigin, B = M ? 4 : 3;
  return minus(calculate(N, plus(L, [e, R]), B), D);
}
function getDragDist(o, t) {
  var e = o.datas, R = o.distX, N = o.distY, M = e.inverseBeforeMatrix, D = e.inverseMatrix, L = e.is3d, B = e.startDragBeforeDist, $ = e.startDragDist, U = e.absoluteOrigin, H = L ? 4 : 3;
  return minus(calculate(t ? M : D, plus(U, [R, N]), H), t ? B : $);
}
function getInverseDragDist(o, t) {
  var e = o.datas, R = o.distX, N = o.distY, M = e.beforeMatrix, D = e.matrix, L = e.is3d, B = e.startDragBeforeDist, $ = e.startDragDist, U = e.absoluteOrigin, H = L ? 4 : 3;
  return minus(calculate(t ? M : D, plus(t ? B : $, [R, N]), H), U);
}
function calculateTransformOrigin(o, t, e, R, N, M) {
  return R === void 0 && (R = t), N === void 0 && (N = e), M === void 0 && (M = [0, 0]), o ? o.map(function(D, L) {
    var B = splitUnit(D), $ = B.value, U = B.unit, H = L ? N : R, z = L ? e : t;
    if (D === "%" || isNaN($)) {
      var X = H ? M[L] / H : 0;
      return z * X;
    } else if (U !== "%")
      return $;
    return z * $ / 100;
  }) : M;
}
function getPosIndexesByDirection(o) {
  var t = [];
  return o[1] >= 0 && (o[0] >= 0 && t.push(3), o[0] <= 0 && t.push(2)), o[1] <= 0 && (o[0] >= 0 && t.push(1), o[0] <= 0 && t.push(0)), t;
}
function getPosesByDirection(o, t) {
  return getPosIndexesByDirection(t).map(function(e) {
    return o[e];
  });
}
function getPosByDirection(o, t) {
  var e = (t[0] + 1) / 2, R = (t[1] + 1) / 2, N = [dot(o[0][0], o[1][0], e, 1 - e), dot(o[0][1], o[1][1], e, 1 - e)], M = [dot(o[2][0], o[3][0], e, 1 - e), dot(o[2][1], o[3][1], e, 1 - e)];
  return [dot(N[0], M[0], R, 1 - R), dot(N[1], M[1], R, 1 - R)];
}
function getDist(o, t, e, R, N, M) {
  var D = calculatePoses(t, e, R, N), L = getPosByDirection(D, M), B = o[0] - L[0], $ = o[1] - L[1];
  return [B, $];
}
function getNextMatrix(o, t, e, R) {
  return multiply(o, getAbsoluteMatrix(t, R, e), R);
}
function getNextTransformMatrix(o, t, e) {
  var R = o.transformOrigin, N = o.offsetMatrix, M = o.is3d, D = t.beforeTransform, L = t.afterTransform, B = M ? 4 : 3, $ = parseMat([e]);
  return getNextMatrix(N, convertDimension(multiply(multiply(D, $, 4), L, 4), 4, B), R, B);
}
function scaleMatrix(o, t) {
  var e = o.transformOrigin, R = o.offsetMatrix, N = o.is3d, M = o.targetMatrix, D = N ? 4 : 3;
  return getNextMatrix(R, multiply(M, createScaleMatrix(t, D), D), e, D);
}
function fillTransformStartEvent(o) {
  var t = getBeforeRenderableDatas(o);
  return {
    setTransform: function(e, R) {
      R === void 0 && (R = -1), t.startTransforms = isArray(e) ? e : splitSpace(e), setTransformIndex(o, R);
    },
    setTransformIndex: function(e) {
      setTransformIndex(o, e);
    }
  };
}
function setDefaultTransformIndex(o, t) {
  var e = getBeforeRenderableDatas(o), R = e.startTransforms;
  setTransformIndex(o, findIndex(R, function(N) {
    return N.indexOf("".concat(t, "(")) === 0;
  }));
}
function setTransformIndex(o, t) {
  var e = getBeforeRenderableDatas(o), R = o.datas;
  if (R.transformIndex = t, t !== -1) {
    var N = e.startTransforms[t];
    if (!!N) {
      var M = parse([N]);
      R.startValue = M[0].functionValue;
    }
  }
}
function fillOriginalTransform(o, t) {
  var e = getBeforeRenderableDatas(o);
  e.nextTransforms = splitSpace(t);
}
function getBeforeRenderableDatas(o) {
  return o.originalDatas.beforeRenderable;
}
function getNextTransforms(o) {
  var t = o.originalDatas.beforeRenderable;
  return t.nextTransforms;
}
function getNextTransformText(o) {
  return getNextTransforms(o).join(" ");
}
function getNextStyle(o) {
  return getBeforeRenderableDatas(o).nextStyle;
}
function fillTransformEvent(o, t, e, R, N) {
  fillOriginalTransform(N, t);
  var M = Draggable.drag(o, setCustomDrag(N, o.state, e, R, !1)), D = M ? M.transform : t;
  return __assign$2(__assign$2({
    transform: t,
    drag: M
  }, fillCSSObject({
    transform: D
  }, N)), {
    afterTransform: D
  });
}
function getTranslateDist(o, t, e, R, N) {
  var M = o.state, D = M.left, L = M.top, B = o.props.groupable, $ = getNextTransformMatrix(o.state, N, t), U = B ? D : 0, H = B ? L : 0, z = getDirectionOffset(o, e, $), X = minus(R, z);
  return minus(X, [U, H]);
}
function getScaleDist(o, t, e, R, N) {
  var M = getTranslateDist(o, "scale(".concat(t.join(", "), ")"), e, R, N);
  return M;
}
function getOriginDirection(o) {
  var t = o.state, e = t.width, R = t.height, N = t.transformOrigin;
  return [-1 + N[0] / (e / 2), -1 + N[1] / (R / 2)];
}
function getDirectionOffset(o, t, e) {
  e === void 0 && (e = o.state.allMatrix);
  var R = o.state, N = R.width, M = R.height, D = R.is3d, L = D ? 4 : 3, B = [N / 2 * (1 + t[0]), M / 2 * (1 + t[1])];
  return calculatePosition(e, B, L);
}
function getRotateDist(o, t, e) {
  var R = e.fixedDirection, N = e.fixedPosition;
  return getTranslateDist(o, "rotate(".concat(t, "deg)"), R, N, e);
}
function getResizeDist(o, t, e, R, N, M) {
  var D = o.props.groupable, L = o.state, B = L.transformOrigin, $ = L.offsetMatrix, U = L.is3d, H = L.width, z = L.height, X = L.left, Y = L.top, W = M.fixedDirection, q = M.nextTargetMatrix || L.targetMatrix, Z = U ? 4 : 3, K = calculateTransformOrigin(N, t, e, H, z, B), J = D ? X : 0, Q = D ? Y : 0, et = getNextMatrix($, q, K, Z), tt = getDist(R, et, t, e, Z, W);
  return minus(tt, [J, Q]);
}
function getAbsolutePosition(o, t) {
  return getPosByDirection(getAbsolutePosesByState(o.state), t);
}
function multiply2(o, t) {
  return [o[0] * t[0], o[1] * t[1]];
}
function prefix() {
  for (var o = [], t = 0; t < arguments.length; t++)
    o[t] = arguments[t];
  return prefixNames.apply(void 0, __spreadArray([PREFIX], o, !1));
}
function defaultSync(o) {
  o();
}
function getTransformMatrix(o) {
  return !o || o === "none" ? [1, 0, 0, 1, 0, 0] : isObject$2(o) ? o : parseMat(o);
}
function getAbsoluteMatrix(o, t, e) {
  return multiplies(t, createOriginMatrix(e, t), o, createOriginMatrix(e.map(function(R) {
    return -R;
  }), t));
}
function measureSVGSize(o, t, e) {
  if (t === "%") {
    var R = getSVGViewBox(o.ownerSVGElement);
    return R[e ? "width" : "height"] / 100;
  }
  return 1;
}
function getBeforeTransformOrigin(o) {
  var t = getTransformOrigin(getComputedStyle$1$1(o, ":before"));
  return t.map(function(e, R) {
    var N = splitUnit(e), M = N.value, D = N.unit;
    return M * measureSVGSize(o, D, R === 0);
  });
}
function getTransformOrigin(o) {
  var t = o.transformOrigin;
  return t ? t.split(" ") : ["0", "0"];
}
function getElementTransform(o, t) {
  t === void 0 && (t = getComputedStyle$1$1(o));
  var e = t.transform;
  if (e && e !== "none")
    return t.transform;
  if ("transform" in o) {
    var R = o.transform, N = R.baseVal;
    if (!N)
      return "";
    var M = N.length;
    if (!M)
      return "";
    for (var D = [], L = function($) {
      var U = N[$].matrix;
      D.push("matrix(".concat(["a", "b", "c", "d", "e", "f"].map(function(H) {
        return U[H];
      }).join(", "), ")"));
    }, B = 0; B < M; ++B)
      L(B);
    return D.join(" ");
  }
  return "";
}
function getOffsetInfo(o, t, e) {
  var R, N, M = document.body, D = !1, L, B;
  if (!o || e)
    L = o;
  else {
    var $ = (R = o == null ? void 0 : o.assignedSlot) === null || R === void 0 ? void 0 : R.parentElement, U = o.parentElement;
    $ ? (D = !0, B = U, L = $) : L = U;
  }
  for (var H = !1, z = o === t || L === t, X = "relative"; L && L !== M; ) {
    t === L && (z = !0);
    var Y = getComputedStyle$1$1(L), W = L.tagName.toLowerCase(), q = getElementTransform(L, Y), Z = Y.willChange;
    if (X = Y.position, W === "svg" || X !== "static" || q && q !== "none" || Z === "transform")
      break;
    var K = (N = o == null ? void 0 : o.assignedSlot) === null || N === void 0 ? void 0 : N.parentNode, J = L.parentNode;
    K && (D = !0, B = J);
    var Q = K || J;
    if (Q && Q.nodeType === 11) {
      L = Q.host, H = !0;
      break;
    }
    L = Q, X = "relative";
  }
  return {
    hasSlot: D,
    parentSlotElement: B,
    isCustomElement: H,
    isStatic: X === "static",
    isEnd: z || !L || L === M,
    offsetParent: L || M
  };
}
function getOffsetPosInfo(o, t, e) {
  var R, N = o.tagName.toLowerCase(), M = o.offsetLeft, D = o.offsetTop, L = isUndefined(M), B = !L, $, U;
  return !B && N !== "svg" ? ($ = IS_WEBKIT605 ? getBeforeTransformOrigin(o) : getTransformOrigin(e).map(function(H) {
    return parseFloat(H);
  }), U = $.slice(), B = !0, R = getSVGGraphicsOffset(o, $, o === t && t.tagName.toLowerCase() === "g"), M = R[0], D = R[1], $[0] = R[2], $[1] = R[3]) : ($ = getTransformOrigin(e).map(function(H) {
    return parseFloat(H);
  }), U = $.slice()), {
    tagName: N,
    isSVG: L,
    hasOffset: B,
    offset: [M || 0, D || 0],
    origin: $,
    targetOrigin: U
  };
}
function getBodyOffset(o, t, e) {
  e === void 0 && (e = getComputedStyle$1$1(o));
  var R = getComputedStyle$1$1(document.body), N = R.position;
  if (!t && (!N || N === "static"))
    return [0, 0];
  var M = parseInt(R.marginLeft, 10), D = parseInt(R.marginTop, 10);
  return e.position === "absolute" && ((e.top !== "auto" || e.bottom !== "auto") && (D = 0), (e.left !== "auto" || e.right !== "auto") && (M = 0)), [M, D];
}
function convert3DMatrixes(o) {
  o.forEach(function(t) {
    var e = t.matrix;
    e && (t.matrix = convertDimension(e, 3, 4));
  });
}
function getBodyScrollPos() {
  return [document.documentElement.scrollLeft || document.body.scrollLeft, document.documentElement.scrollTop || document.body.scrollTop];
}
function getPositionFixedInfo(o) {
  for (var t = o.parentElement, e = !1; t; ) {
    var R = getComputedStyle$1$1(t).transform;
    if (R && R !== "none") {
      e = !0;
      break;
    }
    if (t === document.body)
      break;
    t = t.parentElement;
  }
  return {
    fixedContainer: t || document.body,
    hasTransform: e
  };
}
function makeMatrixCSS(o, t) {
  return t === void 0 && (t = o.length > 9), "".concat(t ? "matrix3d" : "matrix", "(").concat(convertMatrixtoCSS(o, !t).join(","), ")");
}
function getSVGViewBox(o) {
  var t = o.clientWidth, e = o.clientHeight;
  if (!o)
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      clientWidth: t,
      clientHeight: e
    };
  var R = o.viewBox, N = R && R.baseVal || {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  return {
    x: N.x,
    y: N.y,
    width: N.width || t,
    height: N.height || e,
    clientWidth: t,
    clientHeight: e
  };
}
function getSVGMatrix(o, t) {
  var e = getSVGViewBox(o), R = e.width, N = e.height, M = e.clientWidth, D = e.clientHeight, L = M / R, B = D / N, $ = o.preserveAspectRatio.baseVal, U = $.align, H = $.meetOrSlice, z = [0, 0], X = [L, B], Y = [0, 0];
  if (U !== 1) {
    var W = (U - 2) % 3, q = Math.floor((U - 2) / 3);
    z[0] = R * W / 2, z[1] = N * q / 2;
    var Z = H === 2 ? Math.max(B, L) : Math.min(L, B);
    X[0] = Z, X[1] = Z, Y[0] = (M - R) / 2 * W, Y[1] = (D - N) / 2 * q;
  }
  var K = createScaleMatrix(X, t);
  return K[t * (t - 1)] = Y[0], K[t * (t - 1) + 1] = Y[1], getAbsoluteMatrix(K, t, z);
}
function getSVGGraphicsOffset(o, t, e) {
  if (!o.getBBox || !e && o.tagName.toLowerCase() === "g")
    return [0, 0, 0, 0];
  var R = o.getBBox(), N = getSVGViewBox(o.ownerSVGElement), M = R.x - N.x, D = R.y - N.y;
  return [M, D, t[0] - M, t[1] - D];
}
function calculatePosition(o, t, e) {
  return calculate(o, convertPositionMatrix(t, e), e);
}
function calculatePoses(o, t, e, R) {
  return [[0, 0], [t, 0], [0, e], [t, e]].map(function(N) {
    return calculatePosition(o, N, R);
  });
}
function getRect(o) {
  var t = o.map(function($) {
    return $[0];
  }), e = o.map(function($) {
    return $[1];
  }), R = Math.min.apply(Math, t), N = Math.min.apply(Math, e), M = Math.max.apply(Math, t), D = Math.max.apply(Math, e), L = M - R, B = D - N;
  return {
    left: R,
    top: N,
    right: M,
    bottom: D,
    width: L,
    height: B
  };
}
function calculateRect(o, t, e, R) {
  var N = calculatePoses(o, t, e, R);
  return getRect(N);
}
function getSVGOffset(o, t, e, R, N) {
  var M, D = o.target, L = o.origin, B = t.matrix, $ = getSize(D), U = $.offsetWidth, H = $.offsetHeight, z = e.getBoundingClientRect(), X = [0, 0];
  e === document.body && (X = getBodyOffset(D, !0));
  for (var Y = D.getBoundingClientRect(), W = Y.left - z.left + e.scrollLeft - (e.clientLeft || 0) + X[0], q = Y.top - z.top + e.scrollTop - (e.clientTop || 0) + X[1], Z = Y.width, K = Y.height, J = multiplies(R, N, B), Q = calculateRect(J, U, H, R), et = Q.left, tt = Q.top, st = Q.width, rt = Q.height, at = calculatePosition(J, L, R), ut = minus(at, [et, tt]), dt = [W + ut[0] * Z / st, q + ut[1] * K / rt], ct = [0, 0], pt = 0; ++pt < 10; ) {
    var mt = invert(N, R);
    M = minus(calculatePosition(mt, dt, R), calculatePosition(mt, at, R)), ct[0] = M[0], ct[1] = M[1];
    var vt = multiplies(R, N, createOriginMatrix(ct, R), B), _t = calculateRect(vt, U, H, R), xt = _t.left, At = _t.top, yt = xt - W, ht = At - q;
    if (Math.abs(yt) < 2 && Math.abs(ht) < 2)
      break;
    dt[0] -= yt, dt[1] -= ht;
  }
  return ct.map(function(bt) {
    return Math.round(bt);
  });
}
function calculateMoveableClientPositions(o, t, e) {
  var R = o.length === 16, N = R ? 4 : 3, M = t.map(function(B) {
    return calculatePosition(o, B, N);
  }), D = e.left, L = e.top;
  return M.map(function(B) {
    return [B[0] + D, B[1] + L];
  });
}
function calculateMoveablePosition(o, t, e, R) {
  var N = o.length === 16, M = N ? 4 : 3, D = calculatePoses(o, e, R, M), L = D[0], B = L[0], $ = L[1], U = D[1], H = U[0], z = U[1], X = D[2], Y = X[0], W = X[1], q = D[3], Z = q[0], K = q[1], J = calculatePosition(o, t, M), Q = J[0], et = J[1], tt = Math.min(B, H, Y, Z), st = Math.min($, z, W, K), rt = Math.max(B, H, Y, Z), at = Math.max($, z, W, K);
  B = B - tt || 0, H = H - tt || 0, Y = Y - tt || 0, Z = Z - tt || 0, $ = $ - st || 0, z = z - st || 0, W = W - st || 0, K = K - st || 0, Q = Q - tt || 0, et = et - st || 0;
  var ut = getShapeDirection(D);
  return {
    left: tt,
    top: st,
    right: rt,
    bottom: at,
    origin: [Q, et],
    pos1: [B, $],
    pos2: [H, z],
    pos3: [Y, W],
    pos4: [Z, K],
    direction: ut
  };
}
function getDistSize(o) {
  return Math.sqrt(o[0] * o[0] + o[1] * o[1]);
}
function getDiagonalSize(o, t) {
  return getDistSize([t[0] - o[0], t[1] - o[1]]);
}
function getLineStyle(o, t, e, R) {
  e === void 0 && (e = 1), R === void 0 && (R = getRad$1(o, t));
  var N = getDiagonalSize(o, t);
  return {
    transform: "translateY(-50%) translate(".concat(o[0], "px, ").concat(o[1], "px) rotate(").concat(R, "rad) scaleY(").concat(e, ")"),
    width: "".concat(N, "px")
  };
}
function getControlTransform(o, t) {
  for (var e = [], R = 2; R < arguments.length; R++)
    e[R - 2] = arguments[R];
  var N = e.length, M = e.reduce(function(L, B) {
    return L + B[0];
  }, 0) / N, D = e.reduce(function(L, B) {
    return L + B[1];
  }, 0) / N;
  return {
    transform: "translateZ(0px) translate(".concat(M, "px, ").concat(D, "px) rotate(").concat(o, "rad) scale(").concat(t, ")")
  };
}
function getProps(o, t) {
  var e = o[t];
  return isObject$2(e) ? __assign$2(__assign$2({}, o), e) : o;
}
function getSize(o, t) {
  t === void 0 && (t = o ? getComputedStyle$1$1(o) : null);
  var e = o && !isUndefined(o.offsetWidth), R = 0, N = 0, M = 0, D = 0, L = 0, B = 0, $ = 0, U = 0, H = 0, z = 0, X = 0, Y = 0, W = 1 / 0, q = 1 / 0, Z = 1 / 0, K = 1 / 0, J = !1;
  if (o)
    if (!e && o.tagName.toLowerCase() !== "svg") {
      var Q = o.getBBox();
      J = !0, R = Q.width, N = Q.height, L = R, B = N, $ = R, U = N, M = R, D = N;
    } else {
      var et = o.style, tt = t.boxSizing === "border-box", st = parseFloat(t.borderLeftWidth) || 0, rt = parseFloat(t.borderRightWidth) || 0, at = parseFloat(t.borderTopWidth) || 0, ut = parseFloat(t.borderBottomWidth) || 0, dt = parseFloat(t.paddingLeft) || 0, ct = parseFloat(t.paddingRight) || 0, pt = parseFloat(t.paddingTop) || 0, mt = parseFloat(t.paddingBottom) || 0, vt = dt + ct, _t = pt + mt, xt = st + rt, At = at + ut, yt = vt + xt, ht = _t + At;
      H = Math.max(vt, convertUnitSize(t.minWidth, 0) || 0), z = Math.max(_t, convertUnitSize(t.minHeight, 0) || 0), W = convertUnitSize(t.maxWidth, 0), q = convertUnitSize(t.maxHeight, 0), isNaN(W) && (W = 1 / 0, q = 1 / 0);
      var bt = convertUnitSize(et.width, 0) || 0, Ct = convertUnitSize(et.height, 0) || 0, Mt = parseFloat(t.width) || 0, wt = parseFloat(t.height) || 0;
      L = parseFloat(t.width), B = parseFloat(t.height), $ = Math.abs(Mt - bt) < 1 ? between(H, bt || L, W) : Mt, U = Math.abs(wt - Ct) < 1 ? between(z, Ct || B, q) : wt, R = $, N = U, M = $, D = U, tt ? (Z = W, K = q, X = H, Y = z, $ = R - yt, U = N - ht) : (Z = W + yt, K = q + ht, X = H + yt, Y = z + ht, R = $ + yt, N = U + ht), M = $ + vt, D = U + _t;
    }
  return {
    svg: J,
    offsetWidth: R,
    offsetHeight: N,
    clientWidth: M,
    clientHeight: D,
    contentWidth: $,
    contentHeight: U,
    cssWidth: L,
    cssHeight: B,
    minWidth: H,
    minHeight: z,
    maxWidth: W,
    maxHeight: q,
    minOffsetWidth: X,
    minOffsetHeight: Y,
    maxOffsetWidth: Z,
    maxOffsetHeight: K
  };
}
function getRotationRad(o, t) {
  return getRad$1(t > 0 ? o[0] : o[1], t > 0 ? o[1] : o[0]);
}
function resetClientRect() {
  return {
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    right: 0,
    bottom: 0,
    clientLeft: 0,
    clientTop: 0,
    clientWidth: 0,
    clientHeight: 0,
    scrollWidth: 0,
    scrollHeight: 0
  };
}
function getClientRect(o, t) {
  var e, R = 0, N = 0, M = 0, D = 0;
  if (o)
    if (o === document.body || o === document.documentElement) {
      M = window.innerWidth, D = window.innerHeight;
      var L = getBodyScrollPos();
      e = [-L[0], -L[1]], R = e[0], N = e[1];
    } else {
      var B = o.getBoundingClientRect();
      R = B.left, N = B.top, M = B.width, D = B.height;
    }
  var $ = {
    left: R,
    top: N,
    width: M,
    height: D,
    right: R + M,
    bottom: N + D
  };
  return o && t && ($.clientLeft = o.clientLeft, $.clientTop = o.clientTop, $.clientWidth = o.clientWidth, $.clientHeight = o.clientHeight, $.scrollWidth = o.scrollWidth, $.scrollHeight = o.scrollHeight, $.overflow = getComputedStyle$1$1(o).overflow !== "visible"), $;
}
function getDirection(o) {
  if (!!o) {
    var t = o.getAttribute("data-direction");
    if (!!t) {
      var e = [0, 0];
      return t.indexOf("w") > -1 && (e[0] = -1), t.indexOf("e") > -1 && (e[0] = 1), t.indexOf("n") > -1 && (e[1] = -1), t.indexOf("s") > -1 && (e[1] = 1), e;
    }
  }
}
function getAbsolutePoses(o, t) {
  return [plus(t, o[0]), plus(t, o[1]), plus(t, o[2]), plus(t, o[3])];
}
function getAbsolutePosesByState(o) {
  var t = o.left, e = o.top, R = o.pos1, N = o.pos2, M = o.pos3, D = o.pos4;
  return getAbsolutePoses([R, N, M, D], [t, e]);
}
function roundSign(o) {
  return Math.round(o % 1 === -0.5 ? o - 1 : o);
}
function unset(o, t) {
  var e;
  (e = o[t]) === null || e === void 0 || e.unset(), o[t] = null;
}
function fillCSSObject(o, t) {
  if (t) {
    var e = getBeforeRenderableDatas(t);
    e.nextStyle = __assign$2(__assign$2({}, e.nextStyle), o);
  }
  return {
    style: o,
    cssText: getKeys(o).map(function(R) {
      return "".concat(R, ": ").concat(o[R], ";");
    }).join("")
  };
}
function fillAfterTransform(o, t, e) {
  var R = t.afterTransform || t.transform;
  return __assign$2(__assign$2({}, fillCSSObject(__assign$2(__assign$2(__assign$2({}, o.style), t.style), {
    transform: R
  }), e)), {
    afterTransform: R,
    transform: o.transform
  });
}
function fillParams(o, t, e, R) {
  var N = t.datas;
  N.datas || (N.datas = {});
  var M = __assign$2(__assign$2({}, e), {
    target: o.state.target,
    clientX: t.clientX,
    clientY: t.clientY,
    inputEvent: t.inputEvent,
    currentTarget: o,
    moveable: o,
    datas: N.datas,
    stopDrag: function() {
      var D;
      (D = t.stop) === null || D === void 0 || D.call(t);
    }
  });
  return N.isStartEvent ? R || (N.lastEvent = M) : N.isStartEvent = !0, M;
}
function fillEndParams(o, t, e) {
  var R = t.datas, N = "isDrag" in e ? e.isDrag : t.isDrag;
  return R.datas || (R.datas = {}), __assign$2(__assign$2({
    isDrag: N
  }, e), {
    moveable: o,
    target: o.state.target,
    clientX: t.clientX,
    clientY: t.clientY,
    inputEvent: t.inputEvent,
    currentTarget: o,
    lastEvent: R.lastEvent,
    isDouble: t.isDouble,
    datas: R.datas
  });
}
function catchEvent(o, t, e) {
  o._emitter.on(t, e);
}
function triggerEvent(o, t, e, R) {
  return o.triggerEvent(t, e, R);
}
function getComputedStyle$1$1(o, t) {
  return window.getComputedStyle(o, t);
}
function filterAbles(o, t, e) {
  var R = {}, N = {};
  return o.filter(function(M) {
    var D = M.name;
    if (R[D] || !t.some(function(L) {
      return M[L];
    }))
      return !1;
    if (!e && M.ableGroup) {
      if (N[M.ableGroup])
        return !1;
      N[M.ableGroup] = !0;
    }
    return R[D] = !0, !0;
  });
}
function equals(o, t) {
  return o === t || o == null && t == null;
}
function selectValue() {
  for (var o = [], t = 0; t < arguments.length; t++)
    o[t] = arguments[t];
  for (var e = o.length - 1, R = 0; R < e; ++R) {
    var N = o[R];
    if (!isUndefined(N))
      return N;
  }
  return o[e];
}
function groupBy(o, t) {
  var e = [], R = [];
  return o.forEach(function(N, M) {
    var D = t(N, M, o), L = R.indexOf(D), B = e[L] || [];
    L === -1 && (R.push(D), e.push(B)), B.push(N);
  }), e;
}
function groupByMap(o, t) {
  var e = [], R = {};
  return o.forEach(function(N, M) {
    var D = t(N, M, o), L = R[D];
    L || (L = [], R[D] = L, e.push(L)), L.push(N);
  }), e;
}
function flat(o) {
  return o.reduce(function(t, e) {
    return t.concat(e);
  }, []);
}
function maxOffset() {
  for (var o = [], t = 0; t < arguments.length; t++)
    o[t] = arguments[t];
  return o.sort(function(e, R) {
    return Math.abs(R) - Math.abs(e);
  }), o[0];
}
function calculateInversePosition(o, t, e) {
  return calculate(invert(o, e), convertPositionMatrix(t, e), e);
}
function convertDragDist(o, t) {
  var e, R = o.is3d, N = o.rootMatrix, M = R ? 4 : 3;
  return e = calculateInversePosition(N, [t.distX, t.distY], M), t.distX = e[0], t.distY = e[1], t;
}
function calculatePadding(o, t, e, R, N) {
  return minus(calculatePosition(o, plus(e, t), N), R);
}
function convertCSSSize(o, t, e) {
  return e ? "".concat(o / t * 100, "%") : "".concat(o, "px");
}
function getTinyDist(o) {
  return Math.abs(o) <= TINY_NUM ? 0 : o;
}
function getDirectionCondition(o, t) {
  return t === void 0 && (t = [o]), function(e, R) {
    if (R.isRequest)
      return t.some(function(M) {
        return R.requestAble === M;
      }) ? R.parentDirection : !1;
    var N = R.inputEvent.target;
    return hasClass(N, prefix("direction")) && (!o || hasClass(N, prefix(o)));
  };
}
function invertObject(o) {
  var t = {};
  for (var e in o)
    t[o[e]] = e;
  return t;
}
function convertTransformInfo(o, t) {
  var e = o.slice(0, t < 0 ? void 0 : t), R = o.slice(0, t < 0 ? void 0 : t + 1), N = o[t] || "", M = t < 0 ? [] : o.slice(t), D = t < 0 ? [] : o.slice(t + 1), L = parse(e), B = parse(R), $ = parse([N]), U = parse(M), H = parse(D), z = toMat(L), X = toMat(B), Y = toMat(U), W = toMat(H), q = multiply(z, Y, 4);
  return {
    transforms: o,
    beforeFunctionMatrix: z,
    beforeFunctionMatrix2: X,
    targetFunctionMatrix: toMat($),
    afterFunctionMatrix: Y,
    afterFunctionMatrix2: W,
    allFunctionMatrix: q,
    beforeFunctions: L,
    beforeFunctions2: B,
    targetFunction: $[0],
    afterFunctions: U,
    afterFunctions2: H,
    beforeFunctionTexts: e,
    beforeFunctionTexts2: R,
    targetFunctionText: N,
    afterFunctionTexts: M,
    afterFunctionTexts2: D
  };
}
function isArrayFormat(o) {
  return !o || !isObject$2(o) || o instanceof Element ? !1 : isArray(o) || "length" in o;
}
function getRefTarget(o, t) {
  return o ? o instanceof Element ? o : isString$1(o) ? t ? document.querySelector(o) : o : isFunction$3(o) ? o() : "current" in o ? o.current : o : null;
}
function getRefTargets(o, t) {
  if (!o)
    return [];
  var e = isArrayFormat(o) ? [].slice.call(o) : [o];
  return e.reduce(function(R, N) {
    return isString$1(N) && t ? __spreadArray(__spreadArray([], R, !0), [].slice.call(document.querySelectorAll(N)), !0) : (isArray(N) ? R.push(getRefTargets(N, t)) : R.push(getRefTarget(N, t)), R);
  }, []);
}
function getAbsoluteRotation(o, t, e) {
  var R = getRad$1(o, t) / Math.PI * 180;
  return R = e >= 0 ? R : 180 - R, R = R >= 0 ? R : 360 + R, R;
}
function getDragDistByState(o, t) {
  var e = o.rootMatrix, R = o.is3d, N = R ? 4 : 3, M = invert(e, N);
  return R || (M = convertDimension(M, 3, 4)), M[12] = 0, M[13] = 0, M[14] = 0, calculateMatrixDist(M, t);
}
function getSizeDistByDist(o, t, e, R, N) {
  var M = o[0], D = o[1], L = 0, B = 0;
  if (N && M && D) {
    var $ = getRad$1([0, 0], t), U = getRad$1([0, 0], R), H = getDistSize(t), z = Math.cos($ - U) * H;
    if (!R[0])
      B = z, L = B * e;
    else if (!R[1])
      L = z, B = L / e;
    else {
      var X = R[0] * 2 * M, Y = R[1] * 2 * D, W = getDistSize([X + t[0], Y + t[1]]) - getDistSize([X, Y]), q = getRad$1([0, 0], [e, 1]);
      L = Math.cos(q) * W, B = Math.sin(q) * W;
    }
  } else
    L = R[0] * t[0], B = R[1] * t[1];
  return [L, B];
}
function getOffsetSizeDist(o, t, e, R) {
  var N, M = e.ratio, D = e.startOffsetWidth, L = e.startOffsetHeight, B = 0, $ = 0, U = R.distX, H = R.distY, z = R.parentDistance, X = R.parentDist, Y = R.parentScale, W = e.fixedDirection, q = [0, 1].map(function(tt) {
    return Math.abs(o[tt] - W[tt]);
  }), Z = [0, 1].map(function(tt) {
    var st = q[tt];
    return st !== 0 && (st = 2 / st), st;
  });
  if (X)
    B = X[0], $ = X[1], t && (B ? $ || ($ = B / M) : B = $ * M);
  else if (Y)
    B = (Y[0] - 1) * D, $ = (Y[1] - 1) * L;
  else if (z) {
    var K = D * q[0], J = L * q[1], Q = getDistSize([K, J]);
    B = z / Q * K * Z[0], $ = z / Q * J * Z[1];
  } else {
    var et = getDragDist({
      datas: e,
      distX: U,
      distY: H
    });
    et = Z.map(function(tt, st) {
      return et[st] * tt;
    }), N = getSizeDistByDist([D, L], et, M, o, t), B = N[0], $ = N[1];
  }
  return {
    distWidth: B,
    distHeight: $
  };
}
var Pinchable = makeAble("pinchable", {
  events: {
    onPinchStart: "pinchStart",
    onPinch: "pinch",
    onPinchEnd: "pinchEnd",
    onPinchGroupStart: "pinchGroupStart",
    onPinchGroup: "pinchGroup",
    onPinchGroupEnd: "pinchGroupEnd"
  },
  dragStart: function() {
    return !0;
  },
  pinchStart: function(o, t) {
    var e = t.datas, R = t.targets, N = t.angle, M = t.originalDatas, D = o.props, L = D.pinchable, B = D.ables;
    if (!L)
      return !1;
    var $ = "onPinch".concat(R ? "Group" : "", "Start"), U = "drag".concat(R ? "Group" : "", "ControlStart"), H = (L === !0 ? o.controlAbles : B.filter(function(W) {
      return L.indexOf(W.name) > -1;
    })).filter(function(W) {
      return W.canPinch && W[U];
    }), z = fillParams(o, t, {});
    R && (z.targets = R);
    var X = triggerEvent(o, $, z);
    e.isPinch = X !== !1, e.ables = H;
    var Y = e.isPinch;
    return Y ? (H.forEach(function(W) {
      if (M[W.name] = M[W.name] || {}, !!W[U]) {
        var q = __assign$2(__assign$2({}, t), {
          datas: M[W.name],
          parentRotate: N,
          isPinch: !0
        });
        W[U](o, q);
      }
    }), o.state.snapRenderInfo = {
      request: t.isRequest,
      direction: [0, 0]
    }, Y) : !1;
  },
  pinch: function(o, t) {
    var e = t.datas, R = t.scale, N = t.distance, M = t.originalDatas, D = t.inputEvent, L = t.targets, B = t.angle;
    if (!!e.isPinch) {
      var $ = N * (1 - 1 / R), U = fillParams(o, t, {});
      L && (U.targets = L);
      var H = "onPinch".concat(L ? "Group" : "");
      triggerEvent(o, H, U);
      var z = e.ables, X = "drag".concat(L ? "Group" : "", "Control");
      return z.forEach(function(Y) {
        !Y[X] || Y[X](o, __assign$2(__assign$2({}, t), {
          datas: M[Y.name],
          inputEvent: D,
          parentDistance: $,
          parentRotate: B,
          isPinch: !0
        }));
      }), U;
    }
  },
  pinchEnd: function(o, t) {
    var e = t.datas, R = t.isPinch, N = t.inputEvent, M = t.targets, D = t.originalDatas;
    if (!!e.isPinch) {
      var L = "onPinch".concat(M ? "Group" : "", "End"), B = fillEndParams(o, t, {
        isDrag: R
      });
      M && (B.targets = M), triggerEvent(o, L, B);
      var $ = e.ables, U = "drag".concat(M ? "Group" : "", "ControlEnd");
      return $.forEach(function(H) {
        !H[U] || H[U](o, __assign$2(__assign$2({}, t), {
          isDrag: R,
          datas: D[H.name],
          inputEvent: N,
          isPinch: !0
        }));
      }), R;
    }
  },
  pinchGroupStart: function(o, t) {
    return this.pinchStart(o, __assign$2(__assign$2({}, t), {
      targets: o.props.targets
    }));
  },
  pinchGroup: function(o, t) {
    return this.pinch(o, __assign$2(__assign$2({}, t), {
      targets: o.props.targets
    }));
  },
  pinchGroupEnd: function(o, t) {
    return this.pinchEnd(o, __assign$2(__assign$2({}, t), {
      targets: o.props.targets
    }));
  }
});
function fillChildEvents(o, t, e) {
  var R = e.originalDatas;
  R.groupable = R.groupable || {};
  var N = R.groupable;
  N.childDatas = N.childDatas || [];
  var M = N.childDatas;
  return o.moveables.map(function(D, L) {
    return M[L] = M[L] || {}, M[L][t] = M[L][t] || {}, __assign$2(__assign$2({}, e), {
      datas: M[L][t],
      originalDatas: M[L]
    });
  });
}
function triggerChildGesto(o, t, e, R, N, M, D) {
  var L = !!e.match(/Start$/g), B = !!e.match(/End$/g), $ = N.isPinch, U = N.datas, H = fillChildEvents(o, t.name, N), z = o.moveables, X = H.map(function(Y, W) {
    var q = z[W], Z = q.state, K = Z.gestos, J = Y;
    if (L)
      J = new CustomGesto(D).dragStart(R, Y);
    else {
      if (K[D] || (K[D] = U.childGestos[W]), !K[D])
        return;
      J = setCustomDrag(Y, Z, R, $, M, D);
    }
    var Q = t[e](q, __assign$2(__assign$2({}, J), {
      parentFlag: !0
    }));
    return B && (K[D] = null), Q;
  });
  return L && (U.childGestos = z.map(function(Y) {
    return Y.state.gestos[D];
  })), X;
}
function triggerChildAbles(o, t, e, R, N, M) {
  N === void 0 && (N = function(U, H) {
    return H;
  });
  var D = !!e.match(/End$/g), L = fillChildEvents(o, t.name, R), B = o.moveables, $ = L.map(function(U, H) {
    var z = B[H], X = U;
    X = N(z, U);
    var Y = t[e](z, __assign$2(__assign$2({}, X), {
      parentFlag: !0
    }));
    return Y && M && M(z, U, Y, H), D && (z.state.gestos = {}), Y;
  });
  return $;
}
var VERTICAL_NAMES = ["left", "right", "center"], HORIZONTAL_NAMES = ["top", "bottom", "middle"], VERTICAL_NAMES_MAP = {
  start: "left",
  end: "right",
  center: "center"
}, HORIZONTAL_NAMES_MAP = {
  start: "top",
  end: "bottom",
  center: "middle"
};
function hasGuidelines(o, t) {
  var e = o.props, R = e.snappable, N = e.bounds, M = e.innerBounds, D = e.verticalGuidelines, L = e.horizontalGuidelines, B = e.snapGridWidth, $ = e.snapGridHeight, U = o.state, H = U.guidelines, z = U.enableSnap;
  return !R || !z || t && R !== !0 && R.indexOf(t) < 0 ? !1 : !!(B || $ || N || M || H && H.length || D && D.length || L && L.length);
}
function getSnapDirections(o) {
  return o === !1 ? {} : o === !0 || !o ? {
    left: !0,
    right: !0,
    top: !0,
    bottom: !0
  } : o;
}
function mapSnapDirectionPoses(o, t) {
  var e = getSnapDirections(o), R = {};
  for (var N in e)
    N in t && e[N] && (R[N] = t[N]);
  return R;
}
function splitSnapDirectionPoses(o, t) {
  var e = mapSnapDirectionPoses(o, t), R = HORIZONTAL_NAMES.filter(function(M) {
    return M in e;
  }), N = VERTICAL_NAMES.filter(function(M) {
    return M in e;
  });
  return {
    horizontal: R.map(function(M) {
      return e[M];
    }),
    vertical: N.map(function(M) {
      return e[M];
    })
  };
}
function calculateContainerPos(o, t, e) {
  var R = calculatePosition(o, [t.clientLeft, t.clientTop], e);
  return [t.left + R[0], t.top + R[1]];
}
function solveLineConstants(o) {
  var t = o[0], e = o[1], R = e[0] - t[0], N = e[1] - t[1];
  Math.abs(R) < TINY_NUM$1 && (R = 0), Math.abs(N) < TINY_NUM$1 && (N = 0);
  var M = 0, D = 0, L = 0;
  return R ? N ? (M = -N / R, D = 1, L = M * t[0] - t[1]) : (D = 1, L = -t[1]) : (M = -1, L = t[0]), [M, D, L].map(function(B) {
    return throttle(B, TINY_NUM$1);
  });
}
function checkMoveableSnapPoses(o, t, e, R) {
  var N = o.props, M = selectValue(R, N.snapThreshold, 5);
  return checkSnapPoses(o.state.guidelines, t, e, M);
}
function checkSnapPoses(o, t, e, R) {
  return {
    vertical: checkSnap(o, "vertical", t, R),
    horizontal: checkSnap(o, "horizontal", e, R)
  };
}
function checkSnapKeepRatio(o, t, e) {
  var R = e[0], N = e[1], M = t[0], D = t[1], L = minus(e, t), B = L[0], $ = L[1], U = $ > 0, H = B > 0;
  B = getTinyDist(B), $ = getTinyDist($);
  var z = {
    isSnap: !1,
    offset: 0,
    pos: 0
  }, X = {
    isSnap: !1,
    offset: 0,
    pos: 0
  };
  if (B === 0 && $ === 0)
    return {
      vertical: z,
      horizontal: X
    };
  var Y = checkMoveableSnapPoses(o, B ? [R] : [], $ ? [N] : []), W = Y.vertical, q = Y.horizontal;
  W.posInfos.filter(function(mt) {
    var vt = mt.pos;
    return H ? vt >= M : vt <= M;
  }), q.posInfos.filter(function(mt) {
    var vt = mt.pos;
    return U ? vt >= D : vt <= D;
  }), W.isSnap = W.posInfos.length > 0, q.isSnap = q.posInfos.length > 0;
  var Z = getNearestSnapGuidelineInfo(W), K = Z.isSnap, J = Z.guideline, Q = getNearestSnapGuidelineInfo(q), et = Q.isSnap, tt = Q.guideline, st = et ? tt.pos[1] : 0, rt = K ? J.pos[0] : 0;
  if (B === 0)
    et && (X.isSnap = !0, X.pos = tt.pos[1], X.offset = N - X.pos);
  else if ($ === 0)
    K && (z.isSnap = !0, z.pos = rt, z.offset = R - rt);
  else {
    var at = $ / B, ut = e[1] - at * R, dt = 0, ct = 0, pt = !1;
    K ? (ct = rt, dt = at * ct + ut, pt = !0) : et && (dt = st, ct = (dt - ut) / at, pt = !0), pt && (z.isSnap = !0, z.pos = ct, z.offset = R - ct, X.isSnap = !0, X.pos = dt, X.offset = N - dt);
  }
  return {
    vertical: z,
    horizontal: X
  };
}
function checkSnaps(o, t, e) {
  var R = splitSnapDirectionPoses(o.props.snapDirections, t);
  return checkMoveableSnapPoses(o, R.vertical, R.horizontal, e);
}
function getNearestSnapGuidelineInfo(o) {
  var t = o.isSnap;
  if (!t)
    return {
      isSnap: !1,
      offset: 0,
      dist: -1,
      pos: 0,
      guideline: null
    };
  var e = o.posInfos[0], R = e.guidelineInfos[0], N = R.offset, M = R.dist, D = R.guideline;
  return {
    isSnap: t,
    offset: N,
    dist: M,
    pos: e.pos,
    guideline: D
  };
}
function checkSnap(o, t, e, R) {
  if (!o || !o.length)
    return {
      isSnap: !1,
      index: -1,
      posInfos: []
    };
  var N = t === "vertical", M = N ? 0 : 1, D = e.map(function(B, $) {
    var U = o.map(function(H) {
      var z = H.pos, X = B - z[M];
      return {
        offset: X,
        dist: Math.abs(X),
        guideline: H
      };
    }).filter(function(H) {
      var z = H.guideline, X = H.dist, Y = z.type;
      return !(Y !== t || X > R);
    }).sort(function(H, z) {
      return H.dist - z.dist;
    });
    return {
      pos: B,
      index: $,
      guidelineInfos: U
    };
  }).filter(function(B) {
    return B.guidelineInfos.length > 0;
  }).sort(function(B, $) {
    return B.guidelineInfos[0].dist - $.guidelineInfos[0].dist;
  }), L = D.length > 0;
  return {
    isSnap: L,
    index: L ? D[0].index : -1,
    posInfos: D
  };
}
function getSnapInfosByDirection(o, t, e) {
  var R = [];
  if (e[0] && e[1])
    R = [e, [-e[0], e[1]], [e[0], -e[1]]].map(function(D) {
      return getPosByDirection(t, D);
    });
  else if (!e[0] && !e[1])
    for (var N = [t[0], t[1], t[3], t[2], t[0]], M = 0; M < 4; ++M)
      R.push(N[M]), R.push([(N[M][0] + N[M + 1][0]) / 2, (N[M][1] + N[M + 1][1]) / 2]);
  else
    o.props.keepRatio ? R = [[-1, -1], [-1, 1], [1, -1], [1, 1], e].map(function(D) {
      return getPosByDirection(t, D);
    }) : (R = getPosesByDirection(t, e), R.length > 1 && R.push([(R[0][0] + R[1][0]) / 2, (R[0][1] + R[1][1]) / 2]));
  return checkMoveableSnapPoses(o, R.map(function(D) {
    return D[0];
  }), R.map(function(D) {
    return D[1];
  }), 1);
}
function checkSnapBoundPriority(o, t) {
  var e = Math.abs(o.offset), R = Math.abs(t.offset);
  return o.isBound && t.isBound ? R - e : o.isBound ? -1 : t.isBound ? 1 : o.isSnap && t.isSnap ? R - e : o.isSnap ? -1 : t.isSnap || e < TINY_NUM ? 1 : R < TINY_NUM ? -1 : e - R;
}
function getNearOffsetInfo(o, t) {
  return o.slice().sort(function(e, R) {
    var N = e.sign[t], M = R.sign[t], D = e.offset[t], L = R.offset[t];
    if (N) {
      if (!M)
        return -1;
    } else
      return 1;
    return checkSnapBoundPriority({
      isBound: e.isBound,
      isSnap: e.isSnap,
      offset: D
    }, {
      isBound: R.isBound,
      isSnap: R.isSnap,
      offset: L
    });
  })[0];
}
function getCheckSnapDirections(o, t, e) {
  var R = [];
  if (e)
    Math.abs(t[0]) !== 1 || Math.abs(t[1]) !== 1 ? R.push([t, [-1, -1]], [t, [-1, 1]], [t, [1, -1]], [t, [1, 1]]) : R.push([t, [o[0], -o[1]]], [t, [-o[0], o[1]]]), R.push([t, o]);
  else if (o[0] && o[1] || !o[0] && !o[1]) {
    var N = o[0] ? o : [1, 1];
    [1, -1].forEach(function(D) {
      [1, -1].forEach(function(L) {
        var B = [D * N[0], L * N[1]];
        t[0] === B[0] && t[1] === B[1] || R.push([t, B]);
      });
    });
  } else if (o[0]) {
    var M = Math.abs(t[0]) === 1 ? [1] : [1, -1];
    M.forEach(function(D) {
      R.push([[t[0], -1], [D * o[0], -1]], [[t[0], 0], [D * o[0], 0]], [[t[0], 1], [D * o[0], 1]]);
    });
  } else if (o[1]) {
    var M = Math.abs(t[1]) === 1 ? [1] : [1, -1];
    M.forEach(function(L) {
      R.push([[-1, t[1]], [-1, L * o[1]]], [[0, t[1]], [0, L * o[1]]], [[1, t[1]], [1, L * o[1]]]);
    });
  }
  return R;
}
function isStartLine(o, t) {
  var e = average([t[0][0], t[1][0]]), R = average([t[0][1], t[1][1]]);
  return {
    vertical: e <= o[0],
    horizontal: R <= o[1]
  };
}
function hitTestLine(o, t) {
  var e = t[0], R = t[1], N = R[0] - e[0], M = R[1] - e[1];
  Math.abs(N) < TINY_NUM && (N = 0), Math.abs(M) < TINY_NUM && (M = 0);
  var D, L;
  if (!N)
    D = e[0], L = o[0];
  else if (!M)
    D = e[1], L = o[1];
  else {
    var B = M / N;
    D = B * (o[0] - e[0]) + e[1], L = o[1];
  }
  return D - L;
}
function isSameStartLine(o, t, e, R) {
  return R === void 0 && (R = TINY_NUM), o.every(function(N) {
    var M = hitTestLine(N, t), D = M <= 0;
    return D === e || Math.abs(M) <= R;
  });
}
function checkInnerBoundDot(o, t, e, R, N) {
  return N === void 0 && (N = 0), R && t - N <= o || !R && o <= e + N ? {
    isBound: !0,
    offset: R ? t - o : e - o
  } : {
    isBound: !1,
    offset: 0
  };
}
function checkInnerBound(o, t) {
  var e = t.line, R = t.centerSign, N = t.verticalSign, M = t.horizontalSign, D = t.lineConstants, L = o.props.innerBounds;
  if (!L)
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  var B = L.left, $ = L.top, U = L.width, H = L.height, z = [[B, $], [B, $ + H]], X = [[B, $], [B + U, $]], Y = [[B + U, $], [B + U, $ + H]], W = [[B, $ + H], [B + U, $ + H]];
  if (isSameStartLine([[B, $], [B + U, $], [B, $ + H], [B + U, $ + H]], e, R))
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  var q = checkLineBoundCollision(e, D, X, N), Z = checkLineBoundCollision(e, D, W, N), K = checkLineBoundCollision(e, D, z, M), J = checkLineBoundCollision(e, D, Y, M), Q = q.isBound && Z.isBound, et = q.isBound || Z.isBound, tt = K.isBound && J.isBound, st = K.isBound || J.isBound, rt = maxOffset(q.offset, Z.offset), at = maxOffset(K.offset, J.offset), ut = [0, 0], dt = !1, ct = !1;
  return Math.abs(at) < Math.abs(rt) ? (ut = [rt, 0], dt = et, ct = Q) : (ut = [0, at], dt = st, ct = tt), {
    isAllBound: ct,
    isVerticalBound: et,
    isHorizontalBound: st,
    isBound: dt,
    offset: ut
  };
}
function checkLineBoundCollision(o, t, e, R, N, M) {
  var D = t[0], L = t[1], B = o[0], $ = e[0], U = e[1], H = getTinyDist(U[1] - $[1]), z = getTinyDist(U[0] - $[0]), X = L, Y = D, W = -D / L;
  if (z) {
    if (!H) {
      if (M && !X)
        return {
          isBound: !1,
          offset: 0
        };
      if (Y) {
        var J = ($[1] - B[1]) / W + B[0];
        return checkInnerBoundDot(J, $[0], U[0], R, N);
      } else {
        var Z = $[1] - B[1], K = Math.abs(Z) <= (N || 0);
        return {
          isBound: K,
          offset: K ? Z : 0
        };
      }
    }
  } else {
    if (M && !Y)
      return {
        isBound: !1,
        offset: 0
      };
    if (X) {
      var q = W * ($[0] - B[0]) + B[1];
      return checkInnerBoundDot(q, $[1], U[1], R, N);
    } else {
      var Z = $[0] - B[0], K = Math.abs(Z) <= (N || 0);
      return {
        isBound: K,
        offset: K ? Z : 0
      };
    }
  }
  return {
    isBound: !1,
    offset: 0
  };
}
function getInnerBoundInfo(o, t, e) {
  return t.map(function(R) {
    var N = checkInnerBound(o, R), M = N.isBound, D = N.offset, L = N.isVerticalBound, B = N.isHorizontalBound, $ = R.multiple, U = getDragDist({
      datas: e,
      distX: D[0],
      distY: D[1]
    }).map(function(H, z) {
      return H * ($[z] ? 2 / $[z] : 0);
    });
    return {
      sign: $,
      isBound: M,
      isVerticalBound: L,
      isHorizontalBound: B,
      isSnap: !1,
      offset: U
    };
  });
}
function getInnerBoundDragInfo(o, t, e) {
  var R, N = getCheckInnerBoundLineInfos(o, t, [0, 0], !1).map(function(z) {
    return __assign$2(__assign$2({}, z), {
      multiple: z.multiple.map(function(X) {
        return Math.abs(X) * 2;
      })
    });
  }), M = getInnerBoundInfo(o, N, e), D = getNearOffsetInfo(M, 0), L = getNearOffsetInfo(M, 1), B = 0, $ = 0, U = D.isVerticalBound || L.isVerticalBound, H = D.isHorizontalBound || L.isHorizontalBound;
  return (U || H) && (R = getInverseDragDist({
    datas: e,
    distX: -D.offset[0],
    distY: -L.offset[1]
  }), B = R[0], $ = R[1]), {
    vertical: {
      isBound: U,
      offset: B
    },
    horizontal: {
      isBound: H,
      offset: $
    }
  };
}
function getCheckSnapLineDirections(o, t) {
  var e = [], R = o[0], N = o[1];
  return R && N ? e.push([[0, N * 2], o, [-R, N]], [[R * 2, 0], o, [R, -N]]) : R ? (e.push([[R * 2, 0], [R, 1], [R, -1]]), t && e.push([[0, -1], [R, -1], [-R, -1]], [[0, 1], [R, 1], [-R, 1]])) : N ? (e.push([[0, N * 2], [1, N], [-1, N]]), t && e.push([[-1, 0], [-1, N], [-1, -N]], [[1, 0], [1, N], [1, -N]])) : e.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]), e;
}
function getCheckInnerBoundLineInfos(o, t, e, R) {
  var N = o.state, M = N.allMatrix, D = N.is3d, L = calculatePoses(M, 100, 100, D ? 4 : 3), B = getPosByDirection(L, [0, 0]);
  return getCheckSnapLineDirections(e, R).map(function($) {
    var U = $[0], H = $[1], z = $[2], X = [getPosByDirection(L, H), getPosByDirection(L, z)], Y = solveLineConstants(X), W = isStartLine(B, X), q = W.vertical, Z = W.horizontal, K = hitTestLine(B, X) <= 0;
    return {
      multiple: U,
      centerSign: K,
      verticalSign: q,
      horizontalSign: Z,
      lineConstants: Y,
      line: [getPosByDirection(t, H), getPosByDirection(t, z)]
    };
  });
}
function isBoundRotate$1(o, t, e, R) {
  var N = R ? o.map(function(M) {
    return rotate(M, R);
  }) : o;
  return [[N[0], N[1]], [N[1], N[3]], [N[3], N[2]], [N[2], N[0]]].some(function(M) {
    var D = hitTestLine(e, M) <= 0;
    return !isSameStartLine(t, M, D);
  });
}
function getDistPointLine(o) {
  var t = o[0], e = o[1], R = e[0] - t[0], N = e[1] - t[1];
  if (!R)
    return Math.abs(t[0]);
  if (!N)
    return Math.abs(t[1]);
  var M = N / R;
  return Math.abs((-M * t[0] + t[1]) / Math.sqrt(Math.pow(M, 2) + 1));
}
function solveReverseLine(o) {
  var t = o[0], e = o[1], R = e[0] - t[0], N = e[1] - t[1];
  if (!R)
    return [t[0], 0];
  if (!N)
    return [0, t[1]];
  var M = N / R, D = -M * t[0] + t[1];
  return [-D / (M + 1 / M), D / (M * M + 1)];
}
function checkRotateInnerBounds(o, t, e, R, N) {
  var M = o.props.innerBounds, D = N * Math.PI / 180;
  if (!M)
    return [];
  var L = M.left, B = M.top, $ = M.width, U = M.height, H = L - R[0], z = L + $ - R[0], X = B - R[1], Y = B + U - R[1], W = [[H, X], [z, X], [H, Y], [z, Y]], q = getPosByDirection(e, [0, 0]);
  if (!isBoundRotate$1(e, W, q, 0))
    return [];
  var Z = [], K = W.map(function(J) {
    return [getDistSize(J), getRad$1([0, 0], J)];
  });
  return [[e[0], e[1]], [e[1], e[3]], [e[3], e[2]], [e[2], e[0]]].forEach(function(J) {
    var Q = getRad$1([0, 0], solveReverseLine(J)), et = getDistPointLine(J);
    Z.push.apply(Z, K.filter(function(tt) {
      var st = tt[0];
      return st && et <= st;
    }).map(function(tt) {
      var st = tt[0], rt = tt[1], at = Math.acos(st ? et / st : 0), ut = rt + at, dt = rt - at;
      return [D + ut - Q, D + dt - Q];
    }).reduce(function(tt, st) {
      return tt.push.apply(tt, st), tt;
    }, []).filter(function(tt) {
      return !isBoundRotate$1(t, W, q, tt);
    }).map(function(tt) {
      return throttle(tt * 180 / Math.PI, TINY_NUM);
    }));
  }), Z;
}
function checkInnerBoundPoses(o) {
  var t = o.props.innerBounds;
  if (!t)
    return {
      vertical: [],
      horizontal: []
    };
  var e = o.getRect(), R = e.pos1, N = e.pos2, M = e.pos3, D = e.pos4, L = [R, N, M, D], B = getPosByDirection(L, [0, 0]), $ = t.left, U = t.top, H = t.width, z = t.height, X = [[$, U], [$, U + z]], Y = [[$, U], [$ + H, U]], W = [[$ + H, U], [$ + H, U + z]], q = [[$, U + z], [$ + H, U + z]], Z = getCheckInnerBoundLineInfos(o, L, [0, 0], !1), K = [], J = [], Q = {
    top: !1,
    bottom: !1,
    left: !1,
    right: !1
  };
  return Z.forEach(function(et) {
    var tt = et.line, st = et.lineConstants, rt = isStartLine(B, tt), at = rt.horizontal, ut = rt.vertical, dt = checkLineBoundCollision(tt, st, Y, ut, 1, !0), ct = checkLineBoundCollision(tt, st, q, ut, 1, !0), pt = checkLineBoundCollision(tt, st, X, at, 1, !0), mt = checkLineBoundCollision(tt, st, W, at, 1, !0);
    dt.isBound && !Q.top && (K.push(U), Q.top = !0), ct.isBound && !Q.bottom && (K.push(U + z), Q.bottom = !0), pt.isBound && !Q.left && (J.push($), Q.left = !0), mt.isBound && !Q.right && (J.push($ + H), Q.right = !0);
  }), {
    horizontal: K,
    vertical: J
  };
}
function checkBoundPoses(o, t, e) {
  var R = o || {}, N = R.position, M = N === void 0 ? "client" : N, D = R.left, L = D === void 0 ? -1 / 0 : D, B = R.top, $ = B === void 0 ? -1 / 0 : B, U = R.right, H = U === void 0 ? 1 / 0 : U, z = R.bottom, X = z === void 0 ? 1 / 0 : z, Y = {
    position: M,
    left: L,
    top: $,
    right: H,
    bottom: X
  };
  return {
    vertical: checkBounds(Y, t, !0),
    horizontal: checkBounds(Y, e, !1)
  };
}
function getBounds(o, t) {
  var e = o.state, R = e.containerClientRect, N = R.clientHeight, M = R.clientWidth, D = R.clientLeft, L = R.clientTop, B = e.snapOffset, $ = B.left, U = B.top, H = B.right, z = B.bottom, X = t || o.props.bounds || {}, Y = X.position || "client", W = Y === "css", q = X.left, Z = q === void 0 ? -1 / 0 : q, K = X.top, J = K === void 0 ? -1 / 0 : K, Q = X.right, et = Q === void 0 ? W ? -1 / 0 : 1 / 0 : Q, tt = X.bottom, st = tt === void 0 ? W ? -1 / 0 : 1 / 0 : tt;
  return W && (et = M + H - $ - et, st = N + z - U - st), {
    left: Z + $ - D,
    right: et + $ - D,
    top: J + U - L,
    bottom: st + U - L
  };
}
function checkBoundKeepRatio(o, t, e) {
  var R = getBounds(o), N = R.left, M = R.top, D = R.right, L = R.bottom, B = e[0], $ = e[1], U = minus(e, t), H = U[0], z = U[1];
  Math.abs(H) < TINY_NUM && (H = 0), Math.abs(z) < TINY_NUM && (z = 0);
  var X = z > 0, Y = H > 0, W = {
    isBound: !1,
    offset: 0,
    pos: 0
  }, q = {
    isBound: !1,
    offset: 0,
    pos: 0
  };
  if (H === 0 && z === 0)
    return {
      vertical: W,
      horizontal: q
    };
  if (H === 0)
    X ? L < $ && (q.pos = L, q.offset = $ - L) : M > $ && (q.pos = M, q.offset = $ - M);
  else if (z === 0)
    Y ? D < B && (W.pos = D, W.offset = B - D) : N > B && (W.pos = N, W.offset = B - N);
  else {
    var Z = z / H, K = e[1] - Z * B, J = 0, Q = 0, et = !1;
    Y && D <= B ? (J = Z * D + K, Q = D, et = !0) : !Y && B <= N && (J = Z * N + K, Q = N, et = !0), et && (J < M || J > L) && (et = !1), et || (X && L <= $ ? (J = L, Q = (J - K) / Z, et = !0) : !X && $ <= M && (J = M, Q = (J - K) / Z, et = !0)), et && (W.isBound = !0, W.pos = Q, W.offset = B - Q, q.isBound = !0, q.pos = J, q.offset = $ - J);
  }
  return {
    vertical: W,
    horizontal: q
  };
}
function checkBounds(o, t, e) {
  var R = o[e ? "left" : "top"], N = o[e ? "right" : "bottom"], M = Math.min.apply(Math, t), D = Math.max.apply(Math, t), L = [];
  return R + 1 > M && L.push({
    isBound: !0,
    offset: M - R,
    pos: R
  }), N - 1 < D && L.push({
    isBound: !0,
    offset: D - N,
    pos: N
  }), L.length || L.push({
    isBound: !1,
    offset: 0,
    pos: 0
  }), L.sort(function(B, $) {
    return Math.abs($.offset) - Math.abs(B.offset);
  });
}
function isBoundRotate(o, t, e) {
  var R = e ? o.map(function(N) {
    return rotate(N, e);
  }) : o;
  return R.some(function(N) {
    return N[0] < t.left && Math.abs(N[0] - t.left) > 0.1 || N[0] > t.right && Math.abs(N[0] - t.right) > 0.1 || N[1] < t.top && Math.abs(N[1] - t.top) > 0.1 || N[1] > t.bottom && Math.abs(N[1] - t.bottom) > 0.1;
  });
}
function boundRotate(o, t, e) {
  var R = getDistSize(o), N = Math.sqrt(R * R - t * t) || 0;
  return [N, -N].sort(function(M, D) {
    return Math.abs(M - o[e ? 0 : 1]) - Math.abs(D - o[e ? 0 : 1]);
  }).map(function(M) {
    return getRad$1([0, 0], e ? [M, t] : [t, M]);
  });
}
function checkRotateBounds(o, t, e, R, N) {
  if (!o.props.bounds)
    return [];
  var M = N * Math.PI / 180, D = getBounds(o), L = D.left, B = D.top, $ = D.right, U = D.bottom, H = L - R[0], z = $ - R[0], X = B - R[1], Y = U - R[1], W = {
    left: H,
    top: X,
    right: z,
    bottom: Y
  };
  if (!isBoundRotate(e, W, 0))
    return [];
  var q = [];
  return [[H, 0], [z, 0], [X, 1], [Y, 1]].forEach(function(Z) {
    var K = Z[0], J = Z[1];
    e.forEach(function(Q) {
      var et = getRad$1([0, 0], Q);
      q.push.apply(q, boundRotate(Q, K, J).map(function(tt) {
        return M + tt - et;
      }).filter(function(tt) {
        return !isBoundRotate(t, W, tt);
      }).map(function(tt) {
        return throttle(tt * 180 / Math.PI, TINY_NUM);
      }));
    });
  }), q;
}
function renderGuideline(o, t) {
  var e, R = o.direction, N = o.classNames, M = o.size, D = o.pos, L = o.zoom, B = o.key, $ = R === "horizontal", U = $ ? "Y" : "X";
  return t.createElement("div", {
    key: B,
    className: N.join(" "),
    style: (e = {}, e[$ ? "width" : "height"] = "".concat(M), e.transform = "translate(".concat(D[0], ", ").concat(D[1], ") translate").concat(U, "(-50%) scale").concat(U, "(").concat(L, ")"), e)
  });
}
function renderInnerGuideline(o, t) {
  return renderGuideline(__assign$2(__assign$2({}, o), {
    classNames: __spreadArray([prefix("line", "guideline", o.direction)], o.classNames, !0).filter(function(e) {
      return e;
    }),
    size: o.size || "".concat(o.sizeValue, "px"),
    pos: o.pos || o.posValue.map(function(e) {
      return "".concat(throttle(e, 0.1), "px");
    })
  }), t);
}
function renderSnapPoses(o, t, e, R, N, M, D, L) {
  var B = o.props.zoom;
  return e.map(function($, U) {
    var H = $.type, z = $.pos, X = [0, 0];
    return X[D] = R, X[D ? 0 : 1] = -N + z, renderInnerGuideline({
      key: "".concat(t, "TargetGuideline").concat(U),
      classNames: [prefix("target", "bold", H)],
      posValue: X,
      sizeValue: M,
      zoom: B,
      direction: t
    }, L);
  });
}
function renderGuidelines(o, t, e, R, N, M) {
  var D = o.props, L = D.zoom, B = D.isDisplayInnerSnapDigit, $ = t === "horizontal" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, U = N[$.start], H = N[$.end];
  return e.filter(function(z) {
    var X = z.hide, Y = z.elementRect;
    if (X)
      return !1;
    if (B && Y) {
      var W = Y.rect;
      if (W[$.start] <= U && H <= W[$.end])
        return !1;
    }
    return !0;
  }).map(function(z, X) {
    var Y = z.pos, W = z.size, q = z.element, Z = z.className, K = [-R[0] + Y[0], -R[1] + Y[1]];
    return renderInnerGuideline({
      key: "".concat(t, "-default-guideline-").concat(X),
      classNames: q ? [prefix("bold"), Z] : [prefix("normal"), Z],
      direction: t,
      posValue: K,
      sizeValue: W,
      zoom: L
    }, M);
  });
}
function renderDigitLine(o, t, e, R, N, M, D, L) {
  var B, $ = o.props, U = $.snapDigit, H = U === void 0 ? 0 : U, z = $.isDisplaySnapDigit, X = z === void 0 ? !0 : z, Y = $.snapDistFormat, W = Y === void 0 ? function(et, tt) {
    return et;
  } : Y, q = $.zoom, Z = t === "horizontal" ? "X" : "Y", K = t === "vertical" ? "height" : "width", J = Math.abs(N), Q = X ? parseFloat(J.toFixed(H)) : 0;
  return L.createElement("div", {
    key: "".concat(t, "-").concat(e, "-guideline-").concat(R),
    className: prefix("guideline-group", t),
    style: (B = {
      left: "".concat(M[0], "px"),
      top: "".concat(M[1], "px")
    }, B[K] = "".concat(J, "px"), B)
  }, renderInnerGuideline({
    direction: t,
    classNames: [prefix(e), D],
    size: "100%",
    posValue: [0, 0],
    sizeValue: J,
    zoom: q
  }, L), L.createElement("div", {
    className: prefix("size-value", "gap"),
    style: {
      transform: "translate".concat(Z, "(-50%) scale(").concat(q, ")")
    }
  }, Q > 0 ? W(Q, t) : ""));
}
function groupByElementGuidelines(o, t, e, R) {
  var N = o === "vertical" ? 0 : 1, M = o === "vertical" ? 1 : 0, D = N ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, L = e[D.start], B = e[D.end];
  return groupBy(t, function($) {
    return $.pos[N];
  }).map(function($) {
    var U = [], H = [], z = [];
    return $.forEach(function(X) {
      var Y, W, q = X.element, Z = X.elementRect.rect;
      if (Z[D.end] < L)
        U.push(X);
      else if (B < Z[D.start])
        H.push(X);
      else if (Z[D.start] <= L && B <= Z[D.end] && R) {
        var K = X.pos, J = {
          element: q,
          rect: __assign$2(__assign$2({}, Z), (Y = {}, Y[D.end] = Z[D.start], Y))
        }, Q = {
          element: q,
          rect: __assign$2(__assign$2({}, Z), (W = {}, W[D.start] = Z[D.end], W))
        }, et = [0, 0], tt = [0, 0];
        et[N] = K[N], et[M] = K[M], tt[N] = K[N], tt[M] = K[M] + X.size, U.push({
          type: o,
          pos: et,
          size: 0,
          elementRect: J
        }), H.push({
          type: o,
          pos: tt,
          size: 0,
          elementRect: Q
        });
      }
    }), U.sort(function(X, Y) {
      return Y.pos[M] - X.pos[M];
    }), H.sort(function(X, Y) {
      return X.pos[M] - Y.pos[M];
    }), {
      total: $,
      start: U,
      end: H,
      inner: z
    };
  });
}
function renderDashedGuidelines(o, t, e, R, N) {
  var M = o.props.isDisplayInnerSnapDigit, D = [];
  return ["vertical", "horizontal"].forEach(function(L) {
    var B = t.filter(function(q) {
      return q.type === L;
    }), $ = L === "vertical" ? 1 : 0, U = $ ? 0 : 1, H = groupByElementGuidelines(L, B, R, M), z = $ ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, X = $ ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, Y = R[z.start], W = R[z.end];
    H.forEach(function(q) {
      var Z = q.total, K = q.start, J = q.end, Q = q.inner, et = e[U] + Z[0].pos[U] - R[X.start], tt = R;
      K.forEach(function(st) {
        var rt = st.elementRect.rect, at = tt[z.start] - rt[z.end];
        if (at > 0) {
          var ut = [0, 0];
          ut[$] = e[$] + tt[z.start] - Y - at, ut[U] = et, D.push(renderDigitLine(o, L, "dashed", D.length, at, ut, st.className, N));
        }
        tt = rt;
      }), tt = R, J.forEach(function(st) {
        var rt = st.elementRect.rect, at = rt[z.start] - tt[z.end];
        if (at > 0) {
          var ut = [0, 0];
          ut[$] = e[$] + tt[z.end] - Y, ut[U] = et, D.push(renderDigitLine(o, L, "dashed", D.length, at, ut, st.className, N));
        }
        tt = rt;
      }), Q.forEach(function(st) {
        var rt = st.elementRect.rect, at = Y - rt[z.start], ut = rt[z.end] - W, dt = [0, 0], ct = [0, 0];
        dt[$] = e[$] - at, dt[U] = et, ct[$] = e[$] + W - Y, ct[U] = et, D.push(renderDigitLine(o, L, "dashed", D.length, at, dt, st.className, N)), D.push(renderDigitLine(o, L, "dashed", D.length, ut, ct, st.className, N));
      });
    });
  }), D;
}
function renderGapGuidelines(o, t, e, R, N) {
  var M = [];
  return ["horizontal", "vertical"].forEach(function(D) {
    var L = t.filter(function(q) {
      return q.type === D;
    }).slice(0, 1), B = D === "vertical" ? 0 : 1, $ = B ? 0 : 1, U = B ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, H = B ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, z = R[U.start], X = R[U.end], Y = R[H.start], W = R[H.end];
    L.forEach(function(q) {
      var Z = q.gap, K = q.gapRects, J = Math.max.apply(Math, __spreadArray([Y], K.map(function(tt) {
        var st = tt.rect;
        return st[H.start];
      }), !1)), Q = Math.min.apply(Math, __spreadArray([W], K.map(function(tt) {
        var st = tt.rect;
        return st[H.end];
      }), !1)), et = (J + Q) / 2;
      J === Q || et === (Y + W) / 2 || K.forEach(function(tt) {
        var st = tt.rect, rt = tt.className, at = [e[0], e[1]];
        if (st[U.end] < z)
          at[B] += st[U.end] - z;
        else if (X < st[U.start])
          at[B] += st[U.start] - z - Z;
        else
          return;
        at[$] += et - Y, M.push(renderDigitLine(o, B ? "vertical" : "horizontal", "gap", M.length, Z, at, rt, N));
      });
    });
  }), M;
}
function solveEquation(o, t, e, R) {
  var N = t[0] - o[0], M = t[1] - o[1];
  if (Math.abs(N) < TINY_NUM$1 && (N = 0), Math.abs(M) < TINY_NUM$1 && (M = 0), !N)
    return R ? [0, 0] : [0, e];
  if (!M)
    return R ? [e, 0] : [0, 0];
  var D = M / N, L = o[1] - D * o[0];
  if (R) {
    var B = D * (t[0] + e) + L;
    return [e, B - t[1]];
  } else {
    var $ = (t[1] + e - L) / D;
    return [$ - t[0], e];
  }
}
function solveNextOffset(o, t, e, R, N) {
  var M = solveEquation(o, t, e, R);
  if (!M)
    return {
      isOutside: !1,
      offset: [0, 0]
    };
  var D = getDist$2(o, t), L = getDist$2(M, o), B = getDist$2(M, t), $ = L > D || B > D, U = getDragDist({
    datas: N,
    distX: M[0],
    distY: M[1]
  }), H = U[0], z = U[1];
  return {
    offset: [H, z],
    isOutside: $
  };
}
function getSnapBound(o, t) {
  return o.isBound ? o.offset : t.isSnap ? getNearestSnapGuidelineInfo(t).offset : 0;
}
function checkThrottleDragRotate(o, t, e, R, N) {
  var M = t[0], D = t[1], L = e[0], B = e[1], $ = R[0], U = R[1], H = N[0], z = N[1], X = -H, Y = -z;
  if (o && M && D) {
    X = 0, Y = 0;
    var W = [];
    if (L && B ? W.push([0, z], [H, 0]) : L ? W.push([H, 0]) : B ? W.push([0, z]) : $ && U ? W.push([0, z], [H, 0]) : $ ? W.push([H, 0]) : U && W.push([0, z]), W.length) {
      W.sort(function(J, Q) {
        return getDistSize(minus([M, D], J)) - getDistSize(minus([M, D], Q));
      });
      var q = W[0];
      if (q[0] && Math.abs(M) > TINY_NUM$1)
        X = -q[0], Y = D * Math.abs(M + X) / Math.abs(M) - D;
      else if (q[1] && Math.abs(D) > TINY_NUM$1) {
        var Z = D;
        Y = -q[1], X = M * Math.abs(D + Y) / Math.abs(Z) - M;
      }
      if (o && B && L)
        if (Math.abs(X) > TINY_NUM$1 && Math.abs(X) < Math.abs(H)) {
          var K = Math.abs(H) / Math.abs(X);
          X *= K, Y *= K;
        } else if (Math.abs(Y) > TINY_NUM$1 && Math.abs(Y) < Math.abs(z)) {
          var K = Math.abs(z) / Math.abs(Y);
          X *= K, Y *= K;
        } else
          X = maxOffset(-H, X), Y = maxOffset(-z, Y);
    }
  } else
    X = M || L ? -H : 0, Y = D || B ? -z : 0;
  return [X, Y];
}
function checkSnapBoundsDrag(o, t, e, R, N, M) {
  if (!hasGuidelines(o, "draggable"))
    return [{
      isSnap: !1,
      isBound: !1,
      offset: 0
    }, {
      isSnap: !1,
      isBound: !1,
      offset: 0
    }];
  var D = getAbsolutePoses(M.absolutePoses, [t, e]), L = getRect(D), B = L.left, $ = L.right, U = L.top, H = L.bottom, z = {
    horizontal: D.map(function(mt) {
      return mt[1];
    }),
    vertical: D.map(function(mt) {
      return mt[0];
    })
  }, X = getSnapDirections(o.props.snapDirections), Y = splitSnapDirectionPoses(X, {
    left: B,
    right: $,
    top: U,
    bottom: H,
    center: (B + $) / 2,
    middle: (U + H) / 2
  }), W = checkMoveableSnapBounds(o, N, Y, z), q = W.vertical, Z = W.horizontal, K = getInnerBoundDragInfo(o, D, M), J = K.vertical, Q = K.horizontal, et = q.isSnap, tt = Z.isSnap, st = q.isBound || J.isBound, rt = Z.isBound || Q.isBound, at = maxOffset(q.offset, J.offset), ut = maxOffset(Z.offset, Q.offset), dt = checkThrottleDragRotate(R, [t, e], [st, rt], [et, tt], [at, ut]), ct = dt[0], pt = dt[1];
  return [{
    isBound: st,
    isSnap: et,
    offset: ct
  }, {
    isBound: rt,
    isSnap: tt,
    offset: pt
  }];
}
function checkMoveableSnapBounds(o, t, e, R) {
  R === void 0 && (R = e);
  var N = checkBoundPoses(getBounds(o), R.vertical, R.horizontal), M = N.horizontal, D = N.vertical, L = t ? {
    horizontal: {
      isSnap: !1,
      index: -1
    },
    vertical: {
      isSnap: !1,
      index: -1
    }
  } : checkMoveableSnapPoses(o, e.vertical, e.horizontal), B = L.horizontal, $ = L.vertical, U = getSnapBound(M[0], B), H = getSnapBound(D[0], $), z = Math.abs(U), X = Math.abs(H);
  return {
    horizontal: {
      isBound: M[0].isBound,
      isSnap: B.isSnap,
      snapIndex: B.index,
      offset: U,
      dist: z,
      bounds: M,
      snap: B
    },
    vertical: {
      isBound: D[0].isBound,
      isSnap: $.isSnap,
      snapIndex: $.index,
      offset: H,
      dist: X,
      bounds: D,
      snap: $
    }
  };
}
function checkSnapBounds(o, t, e, R, N) {
  var M = checkBoundPoses(t, e, R), D = M.horizontal, L = M.vertical, B = checkSnapPoses(o, e, R, N), $ = B.horizontal, U = B.vertical, H = getSnapBound(D[0], $), z = getSnapBound(L[0], U), X = Math.abs(H), Y = Math.abs(z);
  return {
    horizontal: {
      isBound: D[0].isBound,
      isSnap: $.isSnap,
      snapIndex: $.index,
      offset: H,
      dist: X,
      bounds: D,
      snap: $
    },
    vertical: {
      isBound: L[0].isBound,
      isSnap: U.isSnap,
      snapIndex: U.index,
      offset: z,
      dist: Y,
      bounds: L,
      snap: U
    }
  };
}
function checkSnapRightLine(o, t, e, R) {
  var N = getRad$1(o, t) / Math.PI * 180, M = e.vertical, D = M.isBound, L = M.isSnap, B = M.dist, $ = e.horizontal, U = $.isBound, H = $.isSnap, z = $.dist, X = N % 180, Y = X < 3 || X > 177, W = X > 87 && X < 93;
  return z < B && (D || L && !W && (!R || !Y)) ? "vertical" : U || H && !Y && (!R || !W) ? "horizontal" : "";
}
function getSnapBoundInfo(o, t, e, R, N, M) {
  return e.map(function(D) {
    var L = D[0], B = D[1], $ = getPosByDirection(t, L), U = getPosByDirection(t, B), H = R ? checkSnapBoundsKeepRatio(o, $, U, N) : checkMoveableSnapBounds(o, N, {
      vertical: [U[0]],
      horizontal: [U[1]]
    }), z = H.horizontal, X = z.offset, Y = z.isBound, W = z.isSnap, q = H.vertical, Z = q.offset, K = q.isBound, J = q.isSnap, Q = minus(B, L);
    if (!Z && !X)
      return {
        isBound: K || Y,
        isSnap: J || W,
        sign: Q,
        offset: [0, 0]
      };
    var et = checkSnapRightLine($, U, H, R);
    if (!et)
      return {
        sign: Q,
        isBound: !1,
        isSnap: !1,
        offset: [0, 0]
      };
    var tt = et === "vertical", st = [0, 0];
    return !R && Math.abs(B[0]) === 1 && Math.abs(B[1]) === 1 && L[0] !== B[0] && L[1] !== B[1] ? st = getDragDist({
      datas: M,
      distX: -Z,
      distY: -X
    }) : st = solveNextOffset($, U, -(tt ? Z : X), tt, M).offset, st = st.map(function(rt, at) {
      return rt * (Q[at] ? 2 / Q[at] : 0);
    }), {
      sign: Q,
      isBound: tt ? K : Y,
      isSnap: tt ? J : W,
      offset: st
    };
  });
}
function getSnapBoundOffset(o, t) {
  return o.isBound ? o.offset : t.isSnap ? t.offset : 0;
}
function checkSnapBoundsKeepRatio(o, t, e, R) {
  var N = checkBoundKeepRatio(o, t, e), M = N.horizontal, D = N.vertical, L = R ? {
    horizontal: {
      isSnap: !1
    },
    vertical: {
      isSnap: !1
    }
  } : checkSnapKeepRatio(o, t, e), B = L.horizontal, $ = L.vertical, U = getSnapBoundOffset(M, B), H = getSnapBoundOffset(D, $), z = Math.abs(U), X = Math.abs(H);
  return {
    horizontal: {
      isBound: M.isBound,
      isSnap: B.isSnap,
      offset: U,
      dist: z
    },
    vertical: {
      isBound: D.isBound,
      isSnap: $.isSnap,
      offset: H,
      dist: X
    }
  };
}
function checkMaxBounds(o, t, e, R, N) {
  var M = [-e[0], -e[1]], D = o.state, L = D.width, B = D.height, $ = o.props.bounds, U = 1 / 0, H = 1 / 0;
  if ($) {
    var z = [[e[0], -e[1]], [-e[0], e[1]]], X = $.left, Y = X === void 0 ? -1 / 0 : X, W = $.top, q = W === void 0 ? -1 / 0 : W, Z = $.right, K = Z === void 0 ? 1 / 0 : Z, J = $.bottom, Q = J === void 0 ? 1 / 0 : J;
    z.forEach(function(et) {
      var tt = et[0] !== M[0], st = et[1] !== M[1], rt = getPosByDirection(t, et), at = getRad$1(R, rt) * 360 / Math.PI;
      if (st) {
        var ut = rt.slice();
        (Math.abs(at - 360) < 2 || Math.abs(at - 180) < 2) && (ut[1] = R[1]);
        var dt = solveNextOffset(R, ut, (R[1] < rt[1] ? Q : q) - rt[1], !1, N), ct = dt.offset, pt = ct[1], mt = dt.isOutside;
        isNaN(pt) || (H = B + (mt ? 1 : -1) * Math.abs(pt));
      }
      if (tt) {
        var ut = rt.slice();
        (Math.abs(at - 90) < 2 || Math.abs(at - 270) < 2) && (ut[0] = R[0]);
        var vt = solveNextOffset(R, ut, (R[0] < rt[0] ? K : Y) - rt[0], !0, N), _t = vt.offset[0], xt = vt.isOutside;
        isNaN(_t) || (U = L + (xt ? 1 : -1) * Math.abs(_t));
      }
    });
  }
  return {
    maxWidth: U,
    maxHeight: H
  };
}
function getTotalGuidelines(o) {
  var t = o.state, e = t.snapOffset, R = t.containerClientRect, N = R.overflow, M = R.scrollHeight, D = R.scrollWidth, L = R.clientHeight, B = R.clientWidth, $ = R.clientLeft, U = R.clientTop, H = o.props, z = H.snapGap, X = z === void 0 ? !0 : z, Y = H.verticalGuidelines, W = H.horizontalGuidelines, q = H.snapThreshold, Z = q === void 0 ? 5 : q, K = H.snapGridWidth, J = K === void 0 ? 0 : K, Q = H.snapGridHeight, et = Q === void 0 ? 0 : Q, tt = H.maxSnapElementGuidelineDistance, st = tt === void 0 ? 1 / 0 : tt, rt = getRect(getAbsolutePosesByState(o.state)), at = rt.top, ut = rt.left, dt = rt.bottom, ct = rt.right, pt = {
    top: at,
    left: ut,
    bottom: dt,
    right: ct,
    center: (ut + ct) / 2,
    middle: (at + dt) / 2
  }, mt = getElementGuidelines(o), vt = __spreadArray([], mt, !0);
  return X && vt.push.apply(vt, getGapGuidelines(o, pt, Z)), vt.push.apply(vt, getGridGuidelines(J, et, N ? D : B, N ? M : L, $, U)), vt.push.apply(vt, getDefaultGuidelines(W || !1, Y || !1, N ? D : B, N ? M : L, $, U, e)), vt = vt.filter(function(_t) {
    var xt = _t.element, At = _t.elementRect, yt = _t.type;
    if (!xt || !At)
      return !0;
    var ht = At.rect;
    return checkBetweenRects(pt, ht, yt, st);
  }), vt;
}
function getGapGuidelines(o, t, e) {
  var R = o.props, N = R.maxSnapElementGuidelineDistance, M = N === void 0 ? 1 / 0 : N, D = R.maxSnapElementGapDistance, L = D === void 0 ? 1 / 0 : D, B = o.state.elementRects, $ = [];
  return [["vertical", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP], ["horizontal", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP]].forEach(function(U) {
    var H = U[0], z = U[1], X = U[2], Y = t[z.start], W = t[z.end], q = t[z.center], Z = t[X.start], K = t[X.end];
    function J(tt) {
      var st = tt.rect;
      return st[z.end] < Y + e ? Y - st[z.end] : W - e < st[z.start] ? st[z.start] - W : -1;
    }
    var Q = B.filter(function(tt) {
      var st = tt.rect;
      return st[X.start] > K || st[X.end] < Z ? !1 : J(tt) > 0;
    }).sort(function(tt, st) {
      return J(tt) - J(st);
    }), et = [];
    Q.forEach(function(tt) {
      Q.forEach(function(st) {
        if (tt !== st) {
          var rt = tt.rect, at = st.rect, ut = rt[X.start], dt = rt[X.end], ct = at[X.start], pt = at[X.end];
          ut > pt || ct > dt || et.push([tt, st]);
        }
      });
    }), et.forEach(function(tt) {
      var st = tt[0], rt = tt[1], at = st.rect, ut = rt.rect, dt = at[z.start], ct = at[z.end], pt = ut[z.start], mt = ut[z.end], vt = 0, _t = 0, xt = !1, At = !1, yt = !1;
      if (ct <= Y && W <= pt) {
        if (At = !0, vt = (pt - ct - (W - Y)) / 2, _t = ct + vt + (W - Y) / 2, Math.abs(_t - q) > e)
          return;
      } else if (ct < pt && mt < Y + e) {
        if (xt = !0, vt = pt - ct, _t = mt + vt, Math.abs(_t - Y) > e)
          return;
      } else if (ct < pt && W - e < dt) {
        if (yt = !0, vt = pt - ct, _t = dt - vt, Math.abs(_t - W) > e)
          return;
      } else
        return;
      !vt || !checkBetweenRects(t, ut, H, M) || vt > L || $.push({
        type: H,
        pos: H === "vertical" ? [_t, 0] : [0, _t],
        element: rt.element,
        size: 0,
        className: rt.className,
        isStart: xt,
        isCenter: At,
        isEnd: yt,
        gap: vt,
        hide: !0,
        gapRects: [st, rt]
      });
    });
  }), $;
}
function getGridGuidelines(o, t, e, R, N, M) {
  N === void 0 && (N = 0), M === void 0 && (M = 0);
  var D = [];
  if (t)
    for (var L = 0; L <= R; L += t)
      D.push({
        type: "horizontal",
        pos: [0, throttle(L - M, 0.1)],
        size: e,
        hide: !0
      });
  if (o)
    for (var L = 0; L <= e; L += o)
      D.push({
        type: "vertical",
        pos: [throttle(L - N, 0.1), 0],
        size: R,
        hide: !0
      });
  return D;
}
function checkBetweenRects(o, t, e, R) {
  return e === "horizontal" ? Math.abs(o.right - t.left) <= R || Math.abs(o.left - t.right) <= R || o.left <= t.right && t.left <= o.right : e === "vertical" ? Math.abs(o.bottom - t.top) <= R || Math.abs(o.top - t.bottom) <= R || o.top <= t.bottom && t.top <= o.bottom : !0;
}
function getElementGuidelines(o) {
  var t = o.state, e = o.props.elementGuidelines, R = e === void 0 ? [] : e;
  if (!R.length)
    return t.elementRects = [], [];
  var N = (t.elementRects || []).filter(function(z) {
    return !z.refresh;
  }), M = R.map(function(z) {
    return isObject$2(z) && "element" in z ? __assign$2(__assign$2({}, z), {
      element: getRefTarget(z.element, !0)
    }) : {
      element: getRefTarget(z, !0)
    };
  }).filter(function(z) {
    return z.element;
  }), D = diff(N.map(function(z) {
    return z.element;
  }), M.map(function(z) {
    return z.element;
  })), L = D.maintained, B = D.added, $ = [];
  L.forEach(function(z) {
    var X = z[0], Y = z[1];
    $[Y] = N[X];
  }), getSnapElementRects(o, B.map(function(z) {
    return M[z];
  })).map(function(z, X) {
    $[B[X]] = z;
  }), t.elementRects = $;
  var U = getSnapDirections(o.props.elementSnapDirections), H = [];
  return $.forEach(function(z) {
    var X = z.element, Y = z.top, W = Y === void 0 ? U.top : Y, q = z.left, Z = q === void 0 ? U.left : q, K = z.right, J = K === void 0 ? U.right : K, Q = z.bottom, et = Q === void 0 ? U.bottom : Q, tt = z.center, st = tt === void 0 ? U.center : tt, rt = z.middle, at = rt === void 0 ? U.middle : rt, ut = z.className, dt = z.rect, ct = splitSnapDirectionPoses({
      top: W,
      right: J,
      left: Z,
      bottom: et,
      center: st,
      middle: at
    }, dt), pt = ct.horizontal, mt = ct.vertical, vt = dt.top, _t = dt.left, xt = dt.right - _t, At = dt.bottom - vt, yt = [xt, At];
    mt.forEach(function(ht) {
      H.push({
        type: "vertical",
        element: X,
        pos: [throttle(ht, 0.1), vt],
        size: At,
        sizes: yt,
        className: ut,
        elementRect: z
      });
    }), pt.forEach(function(ht) {
      H.push({
        type: "horizontal",
        element: X,
        pos: [_t, throttle(ht, 0.1)],
        size: xt,
        sizes: yt,
        className: ut,
        elementRect: z
      });
    });
  }), H;
}
function getDefaultGuidelines(o, t, e, R, N, M, D) {
  N === void 0 && (N = 0), M === void 0 && (M = 0), D === void 0 && (D = {
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  });
  var L = [], B = D.left, $ = D.top, U = D.bottom, H = D.right, z = e + H - B, X = R + U - $;
  return o && o.forEach(function(Y) {
    var W = isObject$2(Y) ? Y : {
      pos: Y
    };
    L.push({
      type: "horizontal",
      pos: [B, throttle(W.pos - M + $, 0.1)],
      size: z,
      className: W.className
    });
  }), t && t.forEach(function(Y) {
    var W = isObject$2(Y) ? Y : {
      pos: Y
    };
    L.push({
      type: "vertical",
      pos: [throttle(W.pos - N + B, 0.1), $],
      size: X,
      className: W.className
    });
  }), L;
}
function getSnapElementRects(o, t) {
  if (!t.length)
    return [];
  var e = o.state, R = e.containerClientRect, N = e.targetClientRect, M = N.top, D = N.left, L = e.rootMatrix, B = e.is3d, $ = B ? 4 : 3, U = calculateContainerPos(L, R, $), H = U[0], z = U[1], X = getAbsolutePosesByState(e), Y = getMinMaxs(X), W = Y.minX, q = Y.minY, Z = minus([W, q], calculateInversePosition(L, [D - H, M - z], $)).map(function(Q) {
    return roundSign(Q);
  }), K = Z[0], J = Z[1];
  return t.map(function(Q) {
    var et = Q.element.getBoundingClientRect(), tt = et.left - H, st = et.top - z, rt = st + et.height, at = tt + et.width, ut = calculateInversePosition(L, [tt, st], $), dt = ut[0], ct = ut[1], pt = calculateInversePosition(L, [at, rt], $), mt = pt[0], vt = pt[1];
    return __assign$2(__assign$2({}, Q), {
      rect: {
        left: dt + K,
        right: mt + K,
        top: ct + J,
        bottom: vt + J,
        center: (dt + mt) / 2 + K,
        middle: (ct + vt) / 2 + J
      }
    });
  });
}
function snapStart(o) {
  var t = o.state;
  if (!(t.guidelines && t.guidelines.length)) {
    var e = o.state.container, R = o.props.snapContainer || e, N = t.containerClientRect, M = {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0
    };
    if (e !== R) {
      var D = getRefTarget(R, !0);
      if (D) {
        var L = getClientRect(D), B = getDragDistByState(t, [L.left - N.left, L.top - N.top]), $ = getDragDistByState(t, [L.right - N.right, L.bottom - N.bottom]);
        M.left = throttle(B[0], 1e-5), M.top = throttle(B[1], 1e-5), M.right = throttle($[0], 1e-5), M.bottom = throttle($[1], 1e-5);
      }
    }
    t.snapOffset = M, t.guidelines = getTotalGuidelines(o), t.enableSnap = !0;
  }
}
function getNextFixedPoses(o, t, e, R, N, M) {
  var D = calculatePoses(o, t, e, M ? 4 : 3), L = getPosByDirection(D, R);
  return getAbsolutePoses(D, minus(N, L));
}
function getSizeOffsetInfo(o, t, e, R, N, M) {
  var D = M.fixedDirection, L = getCheckSnapDirections(e, D, R), B = getCheckInnerBoundLineInfos(o, t, e, R), $ = __spreadArray(__spreadArray([], getSnapBoundInfo(o, t, L, R, N, M), !0), getInnerBoundInfo(o, B, M), !0), U = getNearOffsetInfo($, 0), H = getNearOffsetInfo($, 1);
  return {
    width: {
      isBound: U.isBound,
      offset: U.offset[0]
    },
    height: {
      isBound: H.isBound,
      offset: H.offset[1]
    }
  };
}
function recheckSizeByTwoDirection(o, t, e, R, N, M, D, L, B) {
  var $ = getPosByDirection(t, D), U = checkMoveableSnapBounds(o, L, {
    vertical: [$[0]],
    horizontal: [$[1]]
  }), H = U.horizontal.offset, z = U.vertical.offset;
  if (z || H) {
    var X = getDragDist({
      datas: B,
      distX: -z,
      distY: -H
    }), Y = X[0], W = X[1], q = Math.min(N || 1 / 0, e + D[0] * Y), Z = Math.min(M || 1 / 0, R + D[1] * W);
    return [q - e, Z - R];
  }
  return [0, 0];
}
function checkSizeDist(o, t, e, R, N, M, D, L) {
  for (var B = getAbsolutePosesByState(o.state), $ = o.props.keepRatio, U = 0, H = 0, z = 0; z < 2; ++z) {
    var X = t(U, H), Y = getSizeOffsetInfo(o, X, N, $, D, L), W = Y.width, q = Y.height, Z = W.isBound, K = q.isBound, J = W.offset, Q = q.offset;
    if (z === 1 && (Z || (J = 0), K || (Q = 0)), z === 0 && D && !Z && !K)
      return [0, 0];
    if ($) {
      var et = Math.abs(J) * (e ? 1 / e : 1), tt = Math.abs(Q) * (R ? 1 / R : 1), st = Z && K ? et < tt : K || !Z && et < tt;
      st ? J = e * Q / R : Q = R * J / e;
    }
    U += J, H += Q;
  }
  if (N[0] && N[1]) {
    var rt = checkMaxBounds(o, B, N, M, L), at = rt.maxWidth, ut = rt.maxHeight, dt = recheckSizeByTwoDirection(o, t(U, H).map(function(mt) {
      return mt.map(function(vt) {
        return throttle(vt, FLOAT_POINT_NUM);
      });
    }), e + U, R + H, at, ut, N, D, L), J = dt[0], Q = dt[1];
    U += J, H += Q;
  }
  return [U, H];
}
function checkSnapRotate(o, t, e) {
  if (!hasGuidelines(o, "rotatable"))
    return {
      isSnap: !1,
      rotation: e
    };
  var R = t.pos1, N = t.pos2, M = t.pos3, D = t.pos4, L = t.origin, B = e * Math.PI / 180, $ = [R, N, M, D].map(function(X) {
    return minus(X, L);
  }), U = $.map(function(X) {
    return rotate(X, B);
  }), H = __spreadArray(__spreadArray([], checkRotateBounds(o, $, U, L, e), !0), checkRotateInnerBounds(o, $, U, L, e), !0);
  H.sort(function(X, Y) {
    return Math.abs(X - e) - Math.abs(Y - e);
  });
  var z = H.length > 0;
  return {
    isSnap: z,
    rotation: z ? H[0] : e
  };
}
function checkSnapResize(o, t, e, R, N, M, D) {
  if (!hasGuidelines(o, "resizable"))
    return [0, 0];
  var L = D.fixedDirection, B = D.nextAllMatrix, $ = o.state, U = $.allMatrix, H = $.is3d;
  return checkSizeDist(o, function(z, X) {
    return getNextFixedPoses(B || U, t + z, e + X, L, N, H);
  }, t, e, R, N, M, D);
}
function checkSnapScale(o, t, e, R, N) {
  if (!hasGuidelines(o, "scalable"))
    return [0, 0];
  var M = N.startOffsetWidth, D = N.startOffsetHeight, L = N.fixedPosition, B = N.fixedDirection, $ = N.is3d, U = checkSizeDist(o, function(H, z) {
    return getNextFixedPoses(scaleMatrix(N, plus(t, [H / M, z / D])), M, D, B, L, $);
  }, M, D, e, L, R, N);
  return [U[0] / M, U[1] / D];
}
function startCheckSnapDrag(o, t) {
  t.absolutePoses = getAbsolutePosesByState(o.state);
}
function getSnapGuidelines(o) {
  var t = [];
  return o.forEach(function(e) {
    e.guidelineInfos.forEach(function(R) {
      var N = R.guideline;
      t.indexOf(N) > -1 || t.push(N);
    });
  }), t;
}
function addBoundGuidelines(o, t, e, R, N, M) {
  var D = checkBoundPoses(getBounds(o, M), t, e), L = D.vertical, B = D.horizontal;
  L.forEach(function(z) {
    z.isBound && R.push({
      type: "bounds",
      pos: z.pos
    });
  }), B.forEach(function(z) {
    z.isBound && N.push({
      type: "bounds",
      pos: z.pos
    });
  });
  var $ = checkInnerBoundPoses(o), U = $.vertical, H = $.horizontal;
  U.forEach(function(z) {
    findIndex(R, function(X) {
      var Y = X.type, W = X.pos;
      return Y === "bounds" && W === z;
    }) >= 0 || R.push({
      type: "bounds",
      pos: z
    });
  }), H.forEach(function(z) {
    findIndex(N, function(X) {
      var Y = X.type, W = X.pos;
      return Y === "bounds" && W === z;
    }) >= 0 || N.push({
      type: "bounds",
      pos: z
    });
  });
}
var directionCondition$2 = getDirectionCondition("", ["resizable", "scalable"]), Snappable = {
  name: "snappable",
  dragRelation: "strong",
  props: {
    snappable: [Boolean, Array],
    snapContainer: Object,
    snapDirections: [Boolean, Object],
    elementSnapDirections: [Boolean, Object],
    snapGap: Boolean,
    snapGridWidth: Number,
    snapGridHeight: Number,
    isDisplaySnapDigit: Boolean,
    isDisplayInnerSnapDigit: Boolean,
    snapDigit: Number,
    snapThreshold: Number,
    horizontalGuidelines: Array,
    verticalGuidelines: Array,
    elementGuidelines: Array,
    bounds: Object,
    innerBounds: Object,
    snapDistFormat: Function,
    maxSnapElementGuidelineDistance: Number,
    maxSnapElementGapDistance: Number
  },
  events: {
    onSnap: "snap"
  },
  css: [`:host {
    --bounds-color: #d66;
}
.guideline {
    pointer-events: none;
    z-index: 2;
}
.guideline.bounds {
    background: #d66;
    background: var(--bounds-color);
}
.guideline-group {
    position: absolute;
    top: 0;
    left: 0;
}
.guideline-group .size-value {
    position: absolute;
    color: #f55;
    font-size: 12px;
    font-weight: bold;
}
.guideline-group.horizontal .size-value {
    transform-origin: 50% 100%;
    transform: translateX(-50%);
    left: 50%;
    bottom: 5px;
}
.guideline-group.vertical .size-value {
    transform-origin: 0% 50%;
    top: 50%;
    transform: translateY(-50%);
    left: 5px;
}
.guideline.gap {
    background: #f55;
}
.size-value.gap {
    color: #f55;
}
`],
  render: function(o, t) {
    var e = o.state, R = e.top, N = e.left, M = e.pos1, D = e.pos2, L = e.pos3, B = e.pos4, $ = e.snapRenderInfo;
    if (!$ || !hasGuidelines(o, ""))
      return [];
    e.guidelines = getTotalGuidelines(o);
    var U = Math.min(M[0], D[0], L[0], B[0]), H = Math.min(M[1], D[1], L[1], B[1]), z = $.externalPoses || [], X = getAbsolutePosesByState(o.state), Y = [], W = [], q = [], Z = [], K = [], J = getRect(X), Q = J.width, et = J.height, tt = J.top, st = J.left, rt = J.bottom, at = J.right, ut = {
      left: st,
      right: at,
      top: tt,
      bottom: rt,
      center: (st + at) / 2,
      middle: (tt + rt) / 2
    }, dt = z.length > 0, ct = dt ? getRect(z) : {};
    if (!$.request) {
      if ($.direction && K.push(getSnapInfosByDirection(o, X, $.direction)), $.snap) {
        var pt = getRect(X);
        $.center && (pt.middle = (pt.top + pt.bottom) / 2, pt.center = (pt.left + pt.right) / 2), K.push(checkSnaps(o, pt, 1));
      }
      dt && ($.center && (ct.middle = (ct.top + ct.bottom) / 2, ct.center = (ct.left + ct.right) / 2), K.push(checkSnaps(o, ct, 1))), K.forEach(function(xt) {
        var At = xt.vertical.posInfos, yt = xt.horizontal.posInfos;
        Y.push.apply(Y, At.filter(function(ht) {
          var bt = ht.guidelineInfos;
          return bt.some(function(Ct) {
            var Mt = Ct.guideline;
            return !Mt.hide;
          });
        }).map(function(ht) {
          return {
            type: "snap",
            pos: ht.pos
          };
        })), W.push.apply(W, yt.filter(function(ht) {
          var bt = ht.guidelineInfos;
          return bt.some(function(Ct) {
            var Mt = Ct.guideline;
            return !Mt.hide;
          });
        }).map(function(ht) {
          return {
            type: "snap",
            pos: ht.pos
          };
        })), q.push.apply(q, getSnapGuidelines(At)), Z.push.apply(Z, getSnapGuidelines(yt));
      });
    }
    addBoundGuidelines(o, [st, at], [tt, rt], Y, W), dt && addBoundGuidelines(o, [ct.left, ct.right], [ct.top, ct.bottom], Y, W, $.externalBounds);
    var mt = __spreadArray(__spreadArray([], q, !0), Z, !0), vt = mt.filter(function(xt) {
      return xt.element && !xt.gapRects;
    }), _t = mt.filter(function(xt) {
      return xt.gapRects;
    }).sort(function(xt, At) {
      return xt.gap - At.gap;
    });
    return triggerEvent(o, "onSnap", {
      guidelines: mt.filter(function(xt) {
        var At = xt.element;
        return !At;
      }),
      elements: vt,
      gaps: _t
    }, !0), __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], renderDashedGuidelines(o, vt, [U, H], ut, t), !0), renderGapGuidelines(o, _t, [U, H], ut, t), !0), renderGuidelines(o, "horizontal", Z, [N, R], ut, t), !0), renderGuidelines(o, "vertical", q, [N, R], ut, t), !0), renderSnapPoses(o, "horizontal", W, U, R, Q, 0, t), !0), renderSnapPoses(o, "vertical", Y, H, N, et, 1, t), !0);
  },
  dragStart: function(o, t) {
    o.state.snapRenderInfo = {
      request: t.isRequest,
      snap: !0,
      center: !0
    }, snapStart(o);
  },
  drag: function(o) {
    var t = o.state;
    t.guidelines = getTotalGuidelines(o);
  },
  pinchStart: function(o) {
    this.unset(o);
  },
  dragEnd: function(o) {
    this.unset(o);
  },
  dragControlCondition: function(o, t) {
    if (directionCondition$2(o, t) || dragControlCondition(o, t))
      return !0;
    if (!t.isRequest && t.inputEvent)
      return hasClass(t.inputEvent.target, prefix("snap-control"));
  },
  dragControlStart: function(o) {
    o.state.snapRenderInfo = null, snapStart(o);
  },
  dragControl: function(o) {
    this.drag(o);
  },
  dragControlEnd: function(o) {
    this.unset(o);
  },
  dragGroupStart: function(o, t) {
    this.dragStart(o, t);
  },
  dragGroup: function(o) {
    this.drag(o);
  },
  dragGroupEnd: function(o) {
    this.unset(o);
  },
  dragGroupControlStart: function(o) {
    o.state.snapRenderInfo = null, snapStart(o);
  },
  dragGroupControl: function(o) {
    this.drag(o);
  },
  dragGroupControlEnd: function(o) {
    this.unset(o);
  },
  unset: function(o) {
    var t = o.state;
    t.enableSnap = !1, t.guidelines = [], t.snapRenderInfo = null, t.elementRects = [];
  }
};
function renderDirectionControlsByInfos(o, t, e, R) {
  var N = o.state, M = N.renderPoses, D = N.rotation, L = N.direction, B = getProps(o.props, t).zoom, $ = L > 0 ? 1 : -1, U = D / Math.PI * 180, H = {}, z = o.renderState;
  z.renderDirectionMap || (z.renderDirectionMap = {});
  var X = z.renderDirectionMap;
  return e.forEach(function(Y) {
    var W = Y.dir;
    H[W] = !0;
  }), e.map(function(Y) {
    var W = Y.data, q = Y.classNames, Z = Y.dir, K = DIRECTION_INDEXES[Z];
    if (!K || !H[Z])
      return null;
    X[Z] = !0;
    var J = (throttle(U, 15) + $ * DIRECTION_ROTATIONS[Z] + 720) % 180, Q = {};
    return getKeys(W).forEach(function(et) {
      Q["data-".concat(et)] = W[et];
    }), R.createElement("div", __assign$2({
      className: prefix.apply(void 0, __spreadArray(["control", "direction", Z, t], q, !1)),
      "data-rotation": J,
      "data-direction": Z
    }, Q, {
      key: "direction-".concat(Z),
      style: getControlTransform.apply(void 0, __spreadArray([D, B], K.map(function(et) {
        return M[et];
      }), !1))
    }));
  });
}
function renderDirectionControls(o, t, e, R) {
  var N = getProps(o.props, e).renderDirections, M = N === void 0 ? t : N;
  if (!M)
    return [];
  var D = M === !0 ? DIRECTIONS : M;
  return renderDirectionControlsByInfos(o, e, D.map(function(L) {
    return {
      data: {},
      classNames: [],
      dir: L
    };
  }), R);
}
function renderAroundControls(o, t) {
  var e = o.renderState;
  e.renderDirectionMap || (e.renderDirectionMap = {});
  var R = o.state, N = R.renderPoses, M = R.rotation, D = R.direction, L = e.renderDirectionMap, B = o.props.zoom, $ = D > 0 ? 1 : -1, U = M / Math.PI * 180;
  return getKeys(L).map(function(H) {
    var z = DIRECTION_INDEXES[H];
    if (!z)
      return null;
    var X = (throttle(U, 15) + $ * DIRECTION_ROTATIONS[H] + 720) % 180;
    return t.createElement("div", {
      className: prefix("around-control"),
      "data-rotation": X,
      "data-direction": H,
      key: "direction-around-".concat(H),
      style: getControlTransform.apply(void 0, __spreadArray([M, B], z.map(function(Y) {
        return N[Y];
      }), !1))
    });
  });
}
function renderLine(o, t, e, R, N, M) {
  for (var D = [], L = 6; L < arguments.length; L++)
    D[L - 6] = arguments[L];
  var B = getRad$1(e, R), $ = t ? throttle(B / Math.PI * 180, 15) % 180 : -1;
  return o.createElement("div", {
    key: "line-".concat(M),
    className: prefix.apply(void 0, __spreadArray(["line", "direction", t ? "edge" : "", t], D, !1)),
    "data-rotation": $,
    "data-line-index": M,
    "data-direction": t,
    style: getLineStyle(e, R, N, B)
  });
}
function renderEdgeLines(o, t, e, R, N) {
  var M = e === !0 ? DIRECTIONS4 : e;
  return M.map(function(D, L) {
    var B = DIRECTION_INDEXES[D], $ = B[0], U = B[1];
    if (U != null)
      return renderLine(o, D, R[$], R[U], N, "".concat(t, "Edge").concat(L), t);
  }).filter(Boolean);
}
function getRenderDirections(o) {
  return function(t, e) {
    var R = getProps(t.props, o).edge;
    return R && (R === !0 || R.length) ? __spreadArray(__spreadArray([], renderEdgeLines(e, o, R, t.state.renderPoses, t.props.zoom), !0), renderDiagonalDirections(t, o, e), !0) : renderAllDirections(t, o, e);
  };
}
function renderAllDirections(o, t, e) {
  return renderDirectionControls(o, DIRECTIONS, t, e);
}
function renderDiagonalDirections(o, t, e) {
  return renderDirectionControls(o, ["nw", "ne", "sw", "se"], t, e);
}
var Draggable = {
  name: "draggable",
  props: {
    draggable: Boolean,
    throttleDrag: Number,
    throttleDragRotate: Number,
    startDragRotate: Number,
    edgeDraggable: Boolean
  },
  events: {
    onDragStart: "dragStart",
    onDrag: "drag",
    onDragEnd: "dragEnd",
    onDragGroupStart: "dragGroupStart",
    onDragGroup: "dragGroup",
    onDragGroupEnd: "dragGroupEnd"
  },
  render: function(o, t) {
    var e = o.props, R = e.throttleDragRotate, N = e.zoom, M = o.state, D = M.dragInfo, L = M.beforeOrigin;
    if (!R || !D)
      return [];
    var B = D.dist;
    if (!B[0] && !B[1])
      return [];
    var $ = getDistSize(B), U = getRad$1(B, [0, 0]);
    return [t.createElement("div", {
      className: prefix("line", "horizontal", "dragline", "dashed"),
      key: "dragRotateGuideline",
      style: {
        width: "".concat($, "px"),
        transform: "translate(".concat(L[0], "px, ").concat(L[1], "px) rotate(").concat(U, "rad) scaleY(").concat(N, ")")
      }
    })];
  },
  dragStart: function(o, t) {
    var e = t.datas, R = t.parentEvent, N = t.parentGesto, M = o.state, D = M.target, L = M.gestos;
    if (L.draggable)
      return !1;
    L.draggable = N || o.targetGesto;
    var B = getComputedStyle$1$1(D);
    e.datas = {}, e.left = parseFloat(B.left || "") || 0, e.top = parseFloat(B.top || "") || 0, e.bottom = parseFloat(B.bottom || "") || 0, e.right = parseFloat(B.right || "") || 0, e.startValue = [0, 0], setDragStart(o, t), setDefaultTransformIndex(t, "translate"), startCheckSnapDrag(o, e), e.prevDist = [0, 0], e.prevBeforeDist = [0, 0], e.isDrag = !1, e.deltaOffset = [0, 0];
    var $ = fillParams(o, t, __assign$2({
      set: function(H) {
        e.startValue = H;
      }
    }, fillTransformStartEvent(t))), U = R || triggerEvent(o, "onDragStart", $);
    return U !== !1 ? (e.isDrag = !0, o.state.dragInfo = {
      startRect: o.getRect(),
      dist: [0, 0]
    }) : (L.draggable = null, e.isPinch = !1), e.isDrag ? $ : !1;
  },
  drag: function(o, t) {
    if (!!t) {
      resolveTransformEvent(t, "translate");
      var e = t.datas, R = t.parentEvent, N = t.parentFlag, M = t.isPinch, D = t.isRequest, L = t.deltaOffset, B = t.distX, $ = t.distY, U = e.isDrag, H = e.prevDist, z = e.prevBeforeDist, X = e.startValue;
      if (!!U) {
        L && (B += L[0], $ += L[1]);
        var Y = o.props, W = Y.parentMoveable, q = R ? 0 : Y.throttleDrag || 0, Z = R ? 0 : Y.throttleDragRotate || 0, K = !1, J = 0;
        if (!R && Z > 0 && (B || $)) {
          var Q = Y.startDragRotate || 0, et = throttle(Q + getRad$1([0, 0], [B, $]) * 180 / Math.PI, Z) - Q, tt = $ * Math.abs(Math.cos((et - 90) / 180 * Math.PI)), st = B * Math.abs(Math.cos(et / 180 * Math.PI)), rt = getDistSize([st, tt]);
          J = et * Math.PI / 180, B = rt * Math.cos(J), $ = rt * Math.sin(J);
        }
        if (!M && !R && !N && (!Z || B || $)) {
          var at = checkSnapBoundsDrag(o, B, $, Z, D || L, e), ut = at[0], dt = at[1], ct = ut.isSnap, pt = ut.isBound, mt = ut.offset, vt = dt.isSnap, _t = dt.isBound, xt = dt.offset;
          K = ct || vt || pt || _t, B += mt, $ += xt;
        }
        var At = plus(getBeforeDragDist({
          datas: e,
          distX: B,
          distY: $
        }), X), yt = plus(getTransformDist({
          datas: e,
          distX: B,
          distY: $
        }), X);
        !Z && !K && (throttleArray(yt, q), throttleArray(At, q)), throttleArray(yt, TINY_NUM), throttleArray(At, TINY_NUM);
        var ht = minus(At, X), bt = minus(yt, X), Ct = minus(bt, H), Mt = minus(ht, z);
        e.prevDist = bt, e.prevBeforeDist = ht, e.passDelta = Ct, e.passDist = bt;
        var wt = e.left + ht[0], Lt = e.top + ht[1], ft = e.right - ht[0], Gt = e.bottom - ht[1], Dt = convertTransformFormat(e, "translate(".concat(yt[0], "px, ").concat(yt[1], "px)"), "translate(".concat(bt[0], "px, ").concat(bt[1], "px)"));
        if (fillOriginalTransform(t, Dt), o.state.dragInfo.dist = R ? [0, 0] : bt, !(!R && !W && Ct.every(function(It) {
          return !It;
        }) && Mt.some(function(It) {
          return !It;
        }))) {
          var Bt = o.state, Ot = Bt.width, Et = Bt.height, Ht = fillParams(o, t, __assign$2({
            transform: Dt,
            dist: bt,
            delta: Ct,
            translate: yt,
            beforeDist: ht,
            beforeDelta: Mt,
            beforeTranslate: At,
            left: wt,
            top: Lt,
            right: ft,
            bottom: Gt,
            width: Ot,
            height: Et,
            isPinch: M
          }, fillCSSObject({
            transform: Dt
          }, t)));
          return !R && triggerEvent(o, "onDrag", Ht), Ht;
        }
      }
    }
  },
  dragAfter: function(o, t) {
    var e = t.datas, R = e.deltaOffset;
    return R[0] || R[1] ? (e.deltaOffset = [0, 0], this.drag(o, __assign$2(__assign$2({}, t), {
      deltaOffset: R
    }))) : !1;
  },
  dragEnd: function(o, t) {
    var e = t.parentEvent, R = t.datas;
    if (o.state.dragInfo = null, !!R.isDrag) {
      R.isDrag = !1;
      var N = fillEndParams(o, t, {});
      return !e && triggerEvent(o, "onDragEnd", N), N;
    }
  },
  dragGroupStart: function(o, t) {
    var e = t.datas, R = t.clientX, N = t.clientY, M = this.dragStart(o, t);
    if (!M)
      return !1;
    var D = triggerChildGesto(o, this, "dragStart", [R || 0, N || 0], t, !1, "draggable"), L = __assign$2(__assign$2({}, M), {
      targets: o.props.targets,
      events: D
    }), B = triggerEvent(o, "onDragGroupStart", L);
    return e.isDrag = B !== !1, e.isDrag ? M : !1;
  },
  dragGroup: function(o, t) {
    var e = t.datas;
    if (!!e.isDrag) {
      var R = this.drag(o, t), N = t.datas.passDelta, M = triggerChildGesto(o, this, "drag", N, t, !1, "draggable");
      if (!!R) {
        var D = __assign$2({
          targets: o.props.targets,
          events: M
        }, R);
        return triggerEvent(o, "onDragGroup", D), D;
      }
    }
  },
  dragGroupEnd: function(o, t) {
    var e = t.isDrag, R = t.datas;
    if (!!R.isDrag) {
      this.dragEnd(o, t);
      var N = triggerChildGesto(o, this, "dragEnd", [0, 0], t, !1, "draggable");
      return triggerEvent(o, "onDragGroupEnd", fillEndParams(o, t, {
        targets: o.props.targets,
        events: N
      })), e;
    }
  },
  request: function(o) {
    var t = {}, e = o.getRect(), R = 0, N = 0;
    return {
      isControl: !1,
      requestStart: function() {
        return {
          datas: t
        };
      },
      request: function(M) {
        return "x" in M ? R = M.x - e.left : "deltaX" in M && (R += M.deltaX), "y" in M ? N = M.y - e.top : "deltaY" in M && (N += M.deltaY), {
          datas: t,
          distX: R,
          distY: N
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  },
  unset: function(o) {
    o.state.gestos.draggable = null, o.state.dragInfo = null;
  }
}, directionCondition$1 = getDirectionCondition("resizable"), Resizable = {
  name: "resizable",
  ableGroup: "size",
  canPinch: !0,
  props: {
    resizable: Boolean,
    throttleResize: Number,
    renderDirections: Array,
    keepRatio: Boolean,
    resizeFormat: Function,
    keepRatioFinally: Boolean,
    edge: Boolean
  },
  events: {
    onResizeStart: "resizeStart",
    onBeforeResize: "beforeResize",
    onResize: "resize",
    onResizeEnd: "resizeEnd",
    onResizeGroupStart: "resizeGroupStart",
    onBeforeResizeGroup: "beforeResizeGroup",
    onResizeGroup: "resizeGroup",
    onResizeGroupEnd: "resizeGroupEnd"
  },
  render: getRenderDirections("resizable"),
  dragControlCondition: directionCondition$1,
  dragControlStart: function(o, t) {
    var e, R = t.inputEvent, N = t.isPinch, M = t.isGroup, D = t.parentDirection, L = t.parentGesto, B = t.datas, $ = t.parentFixedDirection, U = t.parentEvent, H = D || (N ? [0, 0] : getDirection(R.target)), z = o.state, X = z.target, Y = z.width, W = z.height, q = z.gestos;
    if (!H || !X || q.resizable)
      return !1;
    q.resizable = L || o.controlGesto, !N && setDragStart(o, t), B.datas = {}, B.direction = H, B.startOffsetWidth = Y, B.startOffsetHeight = W, B.prevWidth = 0, B.prevHeight = 0, B.minSize = [0, 0], B.startWidth = z.cssWidth, B.startHeight = z.cssHeight, B.maxSize = [1 / 0, 1 / 0], M || (B.minSize = [z.minOffsetWidth, z.minOffsetHeight], B.maxSize = [z.maxOffsetWidth, z.maxOffsetHeight]);
    var Z = o.props.transformOrigin || "% %";
    B.transformOrigin = Z && isString$1(Z) ? Z.split(" ") : Z, B.startOffsetMatrix = z.offsetMatrix, B.startTransformOrigin = z.transformOrigin, B.isWidth = (e = t == null ? void 0 : t.parentIsWidth) !== null && e !== void 0 ? e : !H[0] && !H[1] || H[0] || !H[1];
    function K(rt) {
      B.ratio = rt && isFinite(rt) ? rt : 0;
    }
    B.startPositions = getAbsolutePosesByState(o.state);
    function J(rt) {
      B.fixedDirection = rt, B.fixedPosition = getPosByDirection(B.startPositions, rt);
    }
    function Q(rt) {
      B.minSize = [convertUnitSize("".concat(rt[0]), 0) || 0, convertUnitSize("".concat(rt[1]), 0) || 0];
    }
    function et(rt) {
      var at = [rt[0] || 1 / 0, rt[1] || 1 / 0];
      (!isNumber(at[0]) || isFinite(at[0])) && (at[0] = convertUnitSize("".concat(at[0]), 0) || 1 / 0), (!isNumber(at[1]) || isFinite(at[1])) && (at[1] = convertUnitSize("".concat(at[1]), 0) || 1 / 0), B.maxSize = at;
    }
    K(Y / W), J($ || [-H[0], -H[1]]), B.setFixedDirection = J, B.setMin = Q, B.setMax = et;
    var tt = fillParams(o, t, {
      direction: H,
      startRatio: B.ratio,
      set: function(rt) {
        var at = rt[0], ut = rt[1];
        B.startWidth = at, B.startHeight = ut;
      },
      setMin: Q,
      setMax: et,
      setRatio: K,
      setFixedDirection: J,
      setOrigin: function(rt) {
        B.transformOrigin = rt;
      },
      dragStart: Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))
    }), st = U || triggerEvent(o, "onResizeStart", tt);
    return B.startFixedDirection = B.fixedDirection, st !== !1 && (B.isResize = !0, o.state.snapRenderInfo = {
      request: t.isRequest,
      direction: H
    }), B.isResize ? tt : !1;
  },
  dragControl: function(o, t) {
    var e, R = t.datas, N = t.parentFlag, M = t.isPinch, D = t.parentKeepRatio, L = t.dragClient, B = t.parentDist, $ = t.isRequest, U = t.isGroup, H = t.parentEvent, z = t.resolveMatrix, X = R.isResize, Y = R.transformOrigin, W = R.startWidth, q = R.startHeight, Z = R.prevWidth, K = R.prevHeight, J = R.minSize, Q = R.maxSize, et = R.ratio, tt = R.startOffsetWidth, st = R.startOffsetHeight, rt = R.isWidth;
    if (!X)
      return;
    if (z) {
      var at = o.state.is3d, ut = R.startOffsetMatrix, dt = R.startTransformOrigin, ct = at ? 4 : 3, pt = parseMat(getNextTransforms(t)), mt = Math.sqrt(pt.length);
      ct !== mt && (pt = convertDimension(pt, mt, ct));
      var vt = getNextMatrix(ut, pt, dt, ct), _t = calculatePoses(vt, tt, st, ct);
      R.startPositions = _t, R.nextTargetMatrix = pt, R.nextAllMatrix = vt;
    }
    var xt = getProps(o.props, "resizable"), At = xt.resizeFormat, yt = xt.throttleResize, ht = yt === void 0 ? N ? 0 : 1 : yt, bt = xt.parentMoveable, Ct = xt.keepRatioFinally, Mt = R.direction, wt = Mt, Lt = 0, ft = 0;
    !Mt[0] && !Mt[1] && (wt = [1, 1]);
    var Gt = et && (D != null ? D : xt.keepRatio) || !1;
    function Dt() {
      var ee = R.fixedDirection, Re = getOffsetSizeDist(wt, Gt, R, t);
      Lt = Re.distWidth, ft = Re.distHeight;
      var ve = wt[0] - ee[0] || Gt ? Math.max(tt + Lt, TINY_NUM) : tt, he = wt[1] - ee[1] || Gt ? Math.max(st + ft, TINY_NUM) : st;
      return Gt && tt && st && (rt ? he = ve / et : ve = he * et), [ve, he];
    }
    var Bt = Dt(), Ot = Bt[0], Et = Bt[1];
    H || (R.setFixedDirection(R.fixedDirection), triggerEvent(o, "onBeforeResize", fillParams(o, t, {
      startFixedDirection: R.startFixedDirection,
      setFixedDirection: function(ee) {
        var Re;
        return R.setFixedDirection(ee), Re = Dt(), Ot = Re[0], Et = Re[1], [Ot, Et];
      },
      boundingWidth: Ot,
      boundingHeight: Et,
      setSize: function(ee) {
        Ot = ee[0], Et = ee[1];
      }
    }, !0)));
    var Ht = L;
    L || (!N && M ? Ht = getAbsolutePosition(o, [0, 0]) : Ht = R.fixedPosition);
    var It = [0, 0];
    M || (It = checkSnapResize(o, Ot, Et, Mt, Ht, $, R)), B && (!B[0] && (It[0] = 0), !B[1] && (It[1] = 0));
    function St() {
      var ee;
      At && (ee = At([Ot, Et]), Ot = ee[0], Et = ee[1]), Ot = throttle(Ot, ht), Et = throttle(Et, ht);
    }
    if (Gt) {
      wt[0] && wt[1] && It[0] && It[1] && (Math.abs(It[0]) > Math.abs(It[1]) ? It[1] = 0 : It[0] = 0);
      var Nt = !It[0] && !It[1];
      Nt && St(), wt[0] && !wt[1] || It[0] && !It[1] || Nt && rt ? (Ot += It[0], Et = Ot / et) : (!wt[0] && wt[1] || !It[0] && It[1] || Nt && !rt) && (Et += It[1], Ot = Et * et);
    } else
      Ot += It[0], Et += It[1], Ot = Math.max(0, Ot), Et = Math.max(0, Et);
    e = calculateBoundSize([Ot, Et], J, Q, Gt ? et : !1), Ot = e[0], Et = e[1], St(), Gt && (U || Ct) && (rt ? Et = Ot / et : Ot = Et * et), Lt = Ot - tt, ft = Et - st;
    var $t = [Lt - Z, ft - K];
    R.prevWidth = Lt, R.prevHeight = ft;
    var Rt = getResizeDist(o, Ot, Et, Ht, Y, R);
    if (!(!bt && $t.every(function(ee) {
      return !ee;
    }) && Rt.every(function(ee) {
      return !ee;
    }))) {
      var Jt = Draggable.drag(o, setCustomDrag(t, o.state, Rt, !!M, !1, "draggable")), Kt = Jt.transform, ae = W + Lt, Se = q + ft, De = fillParams(o, t, __assign$2({
        width: ae,
        height: Se,
        offsetWidth: Math.round(Ot),
        offsetHeight: Math.round(Et),
        startRatio: et,
        boundingWidth: Ot,
        boundingHeight: Et,
        direction: Mt,
        dist: [Lt, ft],
        delta: $t,
        isPinch: !!M,
        drag: Jt
      }, fillAfterTransform({
        style: {
          width: "".concat(ae, "px"),
          height: "".concat(Se, "px")
        },
        transform: Kt
      }, Jt, t)));
      return !H && triggerEvent(o, "onResize", De), De;
    }
  },
  dragControlAfter: function(o, t) {
    var e = t.datas, R = e.isResize, N = e.startOffsetWidth, M = e.startOffsetHeight, D = e.prevWidth, L = e.prevHeight;
    if (!!R) {
      var B = o.state, $ = B.width, U = B.height, H = $ - (N + D), z = U - (M + L), X = Math.abs(H) > 3, Y = Math.abs(z) > 3;
      if (X && (e.startWidth += H, e.startOffsetWidth += H, e.prevWidth += H), Y && (e.startHeight += z, e.startOffsetHeight += z, e.prevHeight += z), X || Y)
        return this.dragControl(o, t);
    }
  },
  dragControlEnd: function(o, t) {
    var e = t.datas, R = t.parentEvent;
    if (!!e.isResize) {
      e.isResize = !1;
      var N = fillEndParams(o, t, {});
      return !R && triggerEvent(o, "onResizeEnd", N), N;
    }
  },
  dragGroupControlCondition: directionCondition$1,
  dragGroupControlStart: function(o, t) {
    var e = t.datas, R = this.dragControlStart(o, __assign$2(__assign$2({}, t), {
      isGroup: !0
    }));
    if (!R)
      return !1;
    var N = fillChildEvents(o, "resizable", t);
    function M(Y, W) {
      var q = e.fixedDirection, Z = e.fixedPosition, K = W.datas.startPositions || getAbsolutePosesByState(Y.state), J = getPosByDirection(K, q), Q = calculate(createRotateMatrix(-o.rotation / 180 * Math.PI, 3), [J[0] - Z[0], J[1] - Z[1], 1], 3), et = Q[0], tt = Q[1];
      return W.datas.originalX = et, W.datas.originalY = tt, W;
    }
    var D = e.startOffsetWidth, L = e.startOffsetHeight;
    function B() {
      var Y = e.minSize;
      N.forEach(function(W) {
        var q = W.datas, Z = q.minSize, K = q.startOffsetWidth, J = q.startOffsetHeight, Q = D * (K ? Z[0] / K : 0), et = L * (J ? Z[1] / J : 0);
        Y[0] = Math.max(Y[0], Q), Y[1] = Math.max(Y[1], et);
      });
    }
    function $() {
      var Y = e.maxSize;
      N.forEach(function(W) {
        var q = W.datas, Z = q.maxSize, K = q.startOffsetWidth, J = q.startOffsetHeight, Q = D * (K ? Z[0] / K : 0), et = L * (J ? Z[1] / J : 0);
        Y[0] = Math.min(Y[0], Q), Y[1] = Math.min(Y[1], et);
      });
    }
    var U = triggerChildAbles(o, this, "dragControlStart", t, function(Y, W) {
      return M(Y, W);
    });
    B(), $();
    var H = function(Y) {
      R.setFixedDirection(Y), U.forEach(function(W, q) {
        W.setFixedDirection(Y), M(W.moveable, N[q]);
      });
    };
    e.setFixedDirection = H;
    var z = __assign$2(__assign$2({}, R), {
      targets: o.props.targets,
      events: U.map(function(Y) {
        return __assign$2(__assign$2({}, Y), {
          setMin: function(W) {
            Y.setMin(W), B();
          },
          setMax: function(W) {
            Y.setMax(W), $();
          }
        });
      }),
      setFixedDirection: H,
      setMin: function(Y) {
        R.setMin(Y), B();
      },
      setMax: function(Y) {
        R.setMax(Y), $();
      }
    }), X = triggerEvent(o, "onResizeGroupStart", z);
    return e.isResize = X !== !1, e.isResize ? R : !1;
  },
  dragGroupControl: function(o, t) {
    var e = t.datas;
    if (!!e.isResize) {
      var R = getProps(o.props, "resizable");
      catchEvent(o, "onBeforeResize", function(X) {
        triggerEvent(o, "onBeforeResizeGroup", fillParams(o, t, __assign$2(__assign$2({}, X), {
          targets: R.targets
        }), !0));
      });
      var N = this.dragControl(o, __assign$2(__assign$2({}, t), {
        isGroup: !0
      }));
      if (!!N) {
        var M = N.boundingWidth, D = N.boundingHeight, L = N.dist, B = R.keepRatio, $ = [M / (M - L[0]), D / (D - L[1])], U = e.fixedPosition, H = triggerChildAbles(o, this, "dragControl", t, function(X, Y) {
          var W = calculate(createRotateMatrix(o.rotation / 180 * Math.PI, 3), [Y.datas.originalX * $[0], Y.datas.originalY * $[1], 1], 3), q = W[0], Z = W[1];
          return __assign$2(__assign$2({}, Y), {
            parentDist: null,
            parentScale: $,
            dragClient: plus(U, [q, Z]),
            parentKeepRatio: B
          });
        }), z = __assign$2({
          targets: R.targets,
          events: H
        }, N);
        return triggerEvent(o, "onResizeGroup", z), z;
      }
    }
  },
  dragGroupControlEnd: function(o, t) {
    var e = t.isDrag, R = t.datas;
    if (!!R.isResize) {
      this.dragControlEnd(o, t);
      var N = triggerChildAbles(o, this, "dragControlEnd", t), M = fillEndParams(o, t, {
        targets: o.props.targets,
        events: N
      });
      return triggerEvent(o, "onResizeGroupEnd", M), e;
    }
  },
  request: function(o) {
    var t = {}, e = 0, R = 0, N = o.getRect();
    return {
      isControl: !0,
      requestStart: function(M) {
        var D;
        return {
          datas: t,
          parentDirection: M.direction || [1, 1],
          parentIsWidth: (D = M == null ? void 0 : M.horizontal) !== null && D !== void 0 ? D : !0
        };
      },
      request: function(M) {
        return "offsetWidth" in M ? e = M.offsetWidth - N.offsetWidth : "deltaWidth" in M && (e += M.deltaWidth), "offsetHeight" in M ? R = M.offsetHeight - N.offsetHeight : "deltaHeight" in M && (R += M.deltaHeight), {
          datas: t,
          parentDist: [e, R],
          parentKeepRatio: M.keepRatio
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  },
  unset: function(o) {
    o.state.gestos.resizable = null;
  }
};
function setRotateStartInfo(o, t, e, R, N) {
  var M = o.props.groupable, D = o.state, L = D.is3d ? 4 : 3, B = t.origin, $ = calculatePosition(
    o.state.rootMatrix,
    minus([B[0], B[1]], M ? [0, 0] : [D.left, D.top]),
    L
  ), U = plus([N.left, N.top], $);
  t.startAbsoluteOrigin = U, t.prevDeg = getRad$1(U, [e, R]) / Math.PI * 180, t.defaultDeg = t.prevDeg, t.prevSnapDeg = 0, t.loop = 0, t.startDist = getDist$2(U, [e, R]);
}
function getAbsoluteDist(o, t, e) {
  var R = e.defaultDeg, N = e.prevDeg, M = N % 360, D = Math.floor(N / 360);
  M < 0 && (M += 360), M > o && M > 270 && o < 90 ? ++D : M < o && M < 90 && o > 270 && --D;
  var L = t * (D * 360 + o - R);
  return e.prevDeg = R + L, L;
}
function getAbsoluteDistByClient(o, t, e, R) {
  return getAbsoluteDist(getRad$1(R.startAbsoluteOrigin, [o, t]) / Math.PI * 180, e, R);
}
function getRotateInfo(o, t, e, R, N, M) {
  var D = o.props.throttleRotate, L = D === void 0 ? 0 : D, B = e.prevSnapDeg, $ = 0, U = !1;
  if (M) {
    var H = checkSnapRotate(o, t, R);
    U = H.isSnap, $ = N + H.rotation;
  }
  U || ($ = throttle(N + R, L));
  var z = $ - N;
  return e.prevSnapDeg = z, [z - B, z, $];
}
function getRotationPositions(o, t, e) {
  var R = t[0], N = t[1], M = t[2], D = t[3];
  if (o !== "none") {
    var L = (o || "top").split("-"), B = L[0], $ = L[1], U = [R, N];
    B === "left" ? U = [M, R] : B === "right" ? U = [N, D] : B === "bottom" && (U = [D, M]);
    var H = [(U[0][0] + U[1][0]) / 2, (U[0][1] + U[1][1]) / 2], z = getRotationRad(U, e);
    if ($) {
      var X = $ === "top" || $ === "left", Y = B === "bottom" || B === "left";
      H = U[X && !Y || !X && Y ? 0 : 1];
    }
    return [H, z];
  }
}
function dragControlCondition(o, t) {
  if (t.isRequest)
    return t.requestAble === "rotatable";
  var e = t.inputEvent.target;
  if (hasClass(e, prefix("rotation-control")) || hasClass(e, prefix("around-control")) || hasClass(e, prefix("control")) && hasClass(e, prefix("rotatable")))
    return !0;
  var R = o.props.rotationTarget;
  return R ? getRefTargets(R, !0).some(function(N) {
    return N ? e === N || e.contains(N) : !1;
  }) : !1;
}
var directionCSS = DIRECTIONS.map(function(o) {
  var t = "", e = "", R = "center", N = "center";
  return o.indexOf("n") > -1 && (t = "top: -20px;", N = "bottom"), o.indexOf("s") > -1 && (t = "top: 0px;", N = "top"), o.indexOf("w") > -1 && (e = "left: -20px;", R = "right"), o.indexOf("e") > -1 && (e = "left: 0px;", R = "left"), '.around-control[data-direction*="'.concat(o, `"] {
        `).concat(e).concat(t, `
        transform-origin: `).concat(R, " ").concat(N, `;
    }`);
}).join(`
`), css = `.rotation {
    position: absolute;
    height: 40px;
    width: 1px;
    transform-origin: 50% 100%;
    height: calc(40px * var(--zoom));
    top: auto;
    left: 0;
    bottom: 100%;
    will-change: transform;
}
.rotation .rotation-line {
    display: block;
    width: 100%;
    height: 100%;
    transform-origin: 50% 50%;
}
.rotation .rotation-control {
    border-color: #4af;
    border-color: var(--moveable-color);
    background:#fff;
    cursor: alias;
}
.rotatable.direction.control {
    cursor: alias;
}
.around-control {
    position: absolute;
    will-change: transform;
    width: 20px;
    height: 20px;
    left: -10px;
    top: -10px;
    box-sizing: border-box;
    background: transparent;
    z-index: 8;
    cursor: alias;
    transform-origin: center center;
}
.rotatable.direction.control.move {
    cursor: move;
}
`.concat(directionCSS, `
`), Rotatable = {
  name: "rotatable",
  canPinch: !0,
  props: {
    rotatable: Boolean,
    rotationPosition: String,
    throttleRotate: Number,
    renderDirections: Object,
    rotationTarget: Object,
    rotateAroundControls: Boolean,
    edge: Boolean,
    resolveAblesWithRotatable: Object
  },
  events: {
    onRotateStart: "rotateStart",
    onBeforeRotate: "beforeRotate",
    onRotate: "rotate",
    onRotateEnd: "rotateEnd",
    onRotateGroupStart: "rotateGroupStart",
    onBeforeRotateGroup: "beforeRotateGroup",
    onRotateGroup: "rotateGroup",
    onRotateGroupEnd: "rotateGroupEnd"
  },
  css: [css],
  render: function(o, t) {
    var e = getProps(o.props, "rotatable"), R = e.rotatable, N = e.rotationPosition, M = e.zoom, D = e.renderDirections, L = e.rotateAroundControls, B = e.resolveAblesWithRotatable, $ = o.state, U = $.renderPoses, H = $.direction;
    if (!R)
      return null;
    var z = getRotationPositions(N, U, H), X = [];
    if (z) {
      var Y = z[0], W = z[1];
      X.push(t.createElement("div", {
        key: "rotation",
        className: prefix("rotation"),
        style: {
          transform: "translate(-50%) translate(".concat(Y[0], "px, ").concat(Y[1], "px) rotate(").concat(W, "rad)")
        }
      }, t.createElement("div", {
        className: prefix("line rotation-line"),
        style: {
          transform: "scaleX(".concat(M, ")")
        }
      }), t.createElement("div", {
        className: prefix("control rotation-control"),
        style: {
          transform: "translate(0.5px) scale(".concat(M, ")")
        }
      })));
    }
    if (D) {
      var q = getKeys(B || {}), Z = {};
      q.forEach(function(J) {
        B[J].forEach(function(Q) {
          Z[Q] = J;
        });
      });
      var K = [];
      isArray(D) && (K = D.map(function(J) {
        var Q = Z[J];
        return {
          data: Q ? {
            resolve: Q
          } : {},
          classNames: Q ? ["move"] : [],
          dir: J
        };
      })), X.push.apply(X, renderDirectionControlsByInfos(o, "rotatable", K, t));
    }
    return L && X.push.apply(X, renderAroundControls(o, t)), X;
  },
  dragControlCondition,
  dragControlStart: function(o, t) {
    var e, R, N = t.datas, M = t.clientX, D = t.clientY, L = t.parentRotate, B = t.parentFlag, $ = t.isPinch, U = t.isRequest, H = o.state, z = H.target, X = H.left, Y = H.top, W = H.direction, q = H.beforeDirection, Z = H.targetTransform, K = H.moveableClientRect, J = H.offsetMatrix, Q = H.targetMatrix, et = H.allMatrix, tt = H.width, st = H.height;
    if (!U && !z)
      return !1;
    var rt = o.getRect();
    N.rect = rt, N.transform = Z, N.left = X, N.top = Y;
    var at = function(wt) {
      N.fixedDirection = wt, N.fixedPosition = getDirectionOffset(o, wt), ht && ht.setFixedDirection(wt);
    }, ut = M, dt = D;
    if (U || $ || B) {
      var ct = L || 0;
      N.beforeInfo = {
        origin: rt.beforeOrigin,
        prevDeg: ct,
        defaultDeg: ct,
        prevSnapDeg: 0,
        startDist: 0
      }, N.afterInfo = __assign$2(__assign$2({}, N.beforeInfo), {
        origin: rt.origin
      }), N.absoluteInfo = __assign$2(__assign$2({}, N.beforeInfo), {
        origin: rt.origin,
        startValue: ct
      });
    } else {
      var pt = (R = t.inputEvent) === null || R === void 0 ? void 0 : R.target;
      if (pt) {
        var mt = pt.getAttribute("data-direction") || "", vt = DIRECTION_REGION_TO_DIRECTION[mt];
        if (vt) {
          N.isControl = !0, N.isAroundControl = hasClass(pt, prefix("around-control")), N.controlDirection = vt;
          var _t = pt.getAttribute("data-resolve");
          _t && (N.resolveAble = _t);
          var xt = calculateMoveableClientPositions(H.rootMatrix, H.renderPoses, K);
          e = getPosByDirection(xt, vt), ut = e[0], dt = e[1];
        }
      }
      N.beforeInfo = {
        origin: rt.beforeOrigin
      }, N.afterInfo = {
        origin: rt.origin
      }, N.absoluteInfo = {
        origin: rt.origin,
        startValue: rt.rotation
      };
      var At = at;
      at = function(wt) {
        var Lt = H.is3d ? 4 : 3, ft = getPosByDirection([[0, 0], [tt, 0], [0, st], [tt, st]], wt), Gt = plus(getOrigin(Q, Lt), ft), Dt = Gt[0], Bt = Gt[1], Ot = calculate(J, convertPositionMatrix([Dt, Bt], Lt)), Et = calculate(et, convertPositionMatrix([ft[0], ft[1]], Lt));
        At(wt), N.beforeInfo.origin = Ot, N.afterInfo.origin = Et, N.absoluteInfo.origin = Et, setRotateStartInfo(o, N.beforeInfo, ut, dt, K), setRotateStartInfo(o, N.afterInfo, ut, dt, K), setRotateStartInfo(o, N.absoluteInfo, ut, dt, K);
      };
    }
    N.startClientX = ut, N.startClientY = dt, N.direction = W, N.beforeDirection = q, N.startValue = 0, N.datas = {}, setDefaultTransformIndex(t, "rotate");
    var yt = !1, ht = !1;
    if (N.isControl && N.resolveAble) {
      var bt = N.resolveAble;
      bt === "resizable" && (ht = Resizable.dragControlStart(o, __assign$2(__assign$2({}, new CustomGesto("resizable").dragStart([0, 0], t)), {
        parentDirection: N.controlDirection,
        parentFixedDirection: N.fixedDirection
      })));
    }
    ht || (yt = Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))), at(getOriginDirection(o));
    var Ct = fillParams(o, t, __assign$2(__assign$2({
      set: function(wt) {
        N.startValue = wt * Math.PI / 180;
      },
      setFixedDirection: at
    }, fillTransformStartEvent(t)), {
      dragStart: yt,
      resizeStart: ht
    })), Mt = triggerEvent(o, "onRotateStart", Ct);
    return N.isRotate = Mt !== !1, H.snapRenderInfo = {
      request: t.isRequest
    }, N.isRotate ? Ct : !1;
  },
  dragControl: function(o, t) {
    var e, R, N, M = t.datas, D = t.distX, L = t.distY, B = t.parentRotate, $ = t.parentFlag, U = t.isPinch, H = t.groupDelta, z = M.beforeDirection, X = M.beforeInfo, Y = M.afterInfo, W = M.absoluteInfo, q = M.isRotate, Z = M.startValue, K = M.rect, J = M.startClientX, Q = M.startClientY;
    if (!!q) {
      resolveTransformEvent(t, "rotate");
      var et = getTransformDirection(t), tt = z * et, st = o.props.parentMoveable, rt = 0, at, ut, dt = 0, ct, pt, mt = 0, vt, _t, xt = 180 / Math.PI * Z, At = W.startValue, yt = !1, ht = J + D, bt = Q + L;
      if (!$ && "parentDist" in t) {
        var Ct = t.parentDist;
        at = Ct, ct = Ct, vt = Ct;
      } else
        U || $ ? (at = getAbsoluteDist(B, z, X), ct = getAbsoluteDist(B, tt, Y), vt = getAbsoluteDist(B, tt, W)) : (at = getAbsoluteDistByClient(ht, bt, z, X), ct = getAbsoluteDistByClient(ht, bt, tt, Y), vt = getAbsoluteDistByClient(ht, bt, tt, W), yt = !0);
      if (ut = xt + at, pt = xt + ct, _t = At + vt, triggerEvent(o, "onBeforeRotate", fillParams(o, t, {
        beforeRotation: ut,
        rotation: pt,
        absoluteRotation: _t,
        setRotation: function(Ht) {
          ct = Ht - xt, at = ct, vt = ct;
        }
      }, !0)), e = getRotateInfo(o, K, X, at, xt, yt), rt = e[0], at = e[1], ut = e[2], R = getRotateInfo(o, K, Y, ct, xt, yt), dt = R[0], ct = R[1], pt = R[2], N = getRotateInfo(o, K, W, vt, At, yt), mt = N[0], vt = N[1], _t = N[2], !(!mt && !dt && !rt && !st)) {
        var Mt = convertTransformFormat(M, "rotate(".concat(pt, "deg)"), "rotate(".concat(ct, "deg)")), wt = getRotateDist(o, ct, M), Lt = minus(plus(H || [0, 0], wt), M.prevInverseDist || [0, 0]);
        M.prevInverseDist = wt, M.requestValue = null;
        var ft = fillTransformEvent(o, Mt, Lt, U, t), Gt = ft, Dt = getDist$2([ht, bt], W.startAbsoluteOrigin) - W.startDist, Bt = void 0;
        if (M.resolveAble === "resizable") {
          var Ot = Resizable.dragControl(o, __assign$2(__assign$2({}, setCustomDrag(t, o.state, [t.deltaX, t.deltaY], !!U, !1, "resizable")), {
            resolveMatrix: !0,
            parentDistance: Dt
          }));
          Ot && (Bt = Ot, Gt = fillAfterTransform(Gt, Ot, t));
        }
        var Et = fillParams(o, t, __assign$2(__assign$2({
          delta: dt,
          dist: ct,
          rotate: pt,
          rotation: pt,
          beforeDist: at,
          beforeDelta: rt,
          beforeRotate: ut,
          beforeRotation: ut,
          absoluteDist: vt,
          absoluteDelta: mt,
          absoluteRotate: _t,
          absoluteRotation: _t,
          isPinch: !!U,
          resize: Bt
        }, ft), Gt));
        return triggerEvent(o, "onRotate", Et), Et;
      }
    }
  },
  dragControlAfter: function(o, t) {
    t.datas.requestValue;
  },
  dragControlEnd: function(o, t) {
    var e = t.datas;
    if (!!e.isRotate) {
      e.isRotate = !1;
      var R = fillEndParams(o, t, {});
      return triggerEvent(o, "onRotateEnd", R), R;
    }
  },
  dragGroupControlCondition: dragControlCondition,
  dragGroupControlStart: function(o, t) {
    var e = t.datas, R = o.state, N = R.left, M = R.top, D = R.beforeOrigin, L = this.dragControlStart(o, t);
    if (!L)
      return !1;
    L.set(e.beforeDirection * o.rotation);
    var B = triggerChildAbles(o, this, "dragControlStart", t, function(H, z) {
      var X = H.state, Y = X.left, W = X.top, q = X.beforeOrigin, Z = plus(minus([Y, W], [N, M]), minus(q, D));
      return z.datas.startGroupClient = Z, z.datas.groupClient = Z, __assign$2(__assign$2({}, z), {
        parentRotate: 0
      });
    }), $ = __assign$2(__assign$2({}, L), {
      targets: o.props.targets,
      events: B
    }), U = triggerEvent(o, "onRotateGroupStart", $);
    return e.isRotate = U !== !1, e.isRotate ? L : !1;
  },
  dragGroupControl: function(o, t) {
    var e = t.datas;
    if (!!e.isRotate) {
      catchEvent(o, "onBeforeRotate", function($) {
        triggerEvent(o, "onBeforeRotateGroup", fillParams(o, t, __assign$2(__assign$2({}, $), {
          targets: o.props.targets
        }), !0));
      });
      var R = this.dragControl(o, t);
      if (!!R) {
        var N = e.beforeDirection, M = R.beforeDist, D = M / 180 * Math.PI, L = triggerChildAbles(o, this, "dragControl", t, function($, U) {
          var H = U.datas.startGroupClient, z = U.datas.groupClient, X = z[0], Y = z[1], W = rotate(H, D * N), q = W[0], Z = W[1], K = [q - X, Z - Y];
          return U.datas.groupClient = [q, Z], __assign$2(__assign$2({}, U), {
            parentRotate: M,
            groupDelta: K
          });
        });
        o.rotation = N * R.beforeRotation;
        var B = __assign$2({
          targets: o.props.targets,
          events: L,
          set: function($) {
            o.rotation = $;
          },
          setGroupRotation: function($) {
            o.rotation = $;
          }
        }, R);
        return triggerEvent(o, "onRotateGroup", B), B;
      }
    }
  },
  dragGroupControlEnd: function(o, t) {
    var e = t.isDrag, R = t.datas;
    if (!!R.isRotate) {
      this.dragControlEnd(o, t);
      var N = triggerChildAbles(o, this, "dragControlEnd", t), M = fillEndParams(o, t, {
        targets: o.props.targets,
        events: N
      });
      return triggerEvent(o, "onRotateGroupEnd", M), e;
    }
  },
  request: function(o) {
    var t = {}, e = 0, R = o.getRotation();
    return {
      isControl: !0,
      requestStart: function() {
        return {
          datas: t
        };
      },
      request: function(N) {
        return "deltaRotate" in N ? e += N.deltaRotate : "rotate" in N && (e = N.rotate - R), {
          datas: t,
          parentDist: e
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  }
}, directionCondition = getDirectionCondition("scalable"), Scalable = {
  name: "scalable",
  ableGroup: "size",
  canPinch: !0,
  props: {
    scalable: Boolean,
    throttleScale: Number,
    renderDirections: String,
    keepRatio: Boolean,
    edge: Boolean
  },
  events: {
    onScaleStart: "scaleStart",
    onBeforeScale: "beforeScale",
    onScale: "scale",
    onScaleEnd: "scaleEnd",
    onScaleGroupStart: "scaleGroupStart",
    onBeforeScaleGroup: "beforeScaleGroup",
    onScaleGroup: "scaleGroup",
    onScaleGroupEnd: "scaleGroupEnd"
  },
  render: getRenderDirections("scalable"),
  dragControlCondition: directionCondition,
  dragControlStart: function(o, t) {
    var e = t.datas, R = t.isPinch, N = t.inputEvent, M = t.parentDirection, D = M || (R ? [0, 0] : getDirection(N.target)), L = o.state, B = L.width, $ = L.height, U = L.targetTransform, H = L.target, z = L.pos1, X = L.pos2, Y = L.pos4;
    if (!D || !H)
      return !1;
    R || setDragStart(o, t), e.datas = {}, e.transform = U, e.prevDist = [1, 1], e.direction = D, e.startOffsetWidth = B, e.startOffsetHeight = $, e.startValue = [1, 1];
    var W = getDist$2(z, X), q = getDist$2(X, Y), Z = !D[0] && !D[1] || D[0] || !D[1];
    e.scaleWidth = W, e.scaleHeight = q, e.scaleXRatio = W / B, e.scaleYRatio = q / $, setDefaultTransformIndex(t, "scale"), e.isWidth = Z;
    function K(tt) {
      e.ratio = tt && isFinite(tt) ? tt : 0;
    }
    e.startPositions = getAbsolutePosesByState(o.state);
    function J(tt) {
      e.fixedDirection = tt, e.fixedPosition = getPosByDirection(e.startPositions, tt);
    }
    e.setFixedDirection = J, K(getDist$2(z, X) / getDist$2(X, Y)), J([-D[0], -D[1]]);
    var Q = fillParams(o, t, __assign$2(__assign$2({
      direction: D,
      set: function(tt) {
        e.startValue = tt;
      },
      setRatio: K,
      setFixedDirection: J
    }, fillTransformStartEvent(t)), {
      dragStart: Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))
    })), et = triggerEvent(o, "onScaleStart", Q);
    return e.startFixedDirection = e.fixedDirection, et !== !1 && (e.isScale = !0, o.state.snapRenderInfo = {
      request: t.isRequest,
      direction: D
    }), e.isScale ? Q : !1;
  },
  dragControl: function(o, t) {
    resolveTransformEvent(t, "scale");
    var e = t.datas, R = t.parentKeepRatio, N = t.parentFlag, M = t.isPinch, D = t.dragClient, L = t.isRequest, B = e.prevDist, $ = e.direction, U = e.startOffsetWidth, H = e.startOffsetHeight, z = e.isScale, X = e.startValue, Y = e.isWidth, W = e.ratio;
    if (!z)
      return !1;
    var q = o.props, Z = q.throttleScale, K = q.parentMoveable, J = $;
    !$[0] && !$[1] && (J = [1, 1]);
    var Q = W && (R != null ? R : q.keepRatio) || !1, et = o.state;
    function tt() {
      var bt = getOffsetSizeDist(J, Q, e, t), Ct = bt.distWidth, Mt = bt.distHeight, wt = (U + Ct) / U, Lt = (H + Mt) / H;
      return wt = J[0] || Q ? wt * X[0] : X[0], Lt = J[1] || Q ? Lt * X[1] : X[1], wt === 0 && (wt = (B[0] > 0 ? 1 : -1) * MIN_SCALE), Lt === 0 && (Lt = (B[1] > 0 ? 1 : -1) * MIN_SCALE), [wt, Lt];
    }
    var st = tt();
    if (!M && o.props.groupable) {
      var rt = et.snapRenderInfo || {}, at = rt.direction;
      isArray(at) && (at[0] || at[1]) && (et.snapRenderInfo = {
        direction: $,
        request: t.isRequest
      });
    }
    triggerEvent(o, "onBeforeScale", fillParams(o, t, {
      scale: st,
      setFixedDirection: function(bt) {
        return e.setFixedDirection(bt), st = tt(), st;
      },
      startFixedDirection: e.startFixedDirection,
      setScale: function(bt) {
        st = bt;
      }
    }, !0));
    var ut = [st[0] / X[0], st[1] / X[1]], dt = D, ct = [0, 0];
    if (D || (!N && M ? dt = getAbsolutePosition(o, [0, 0]) : dt = e.fixedPosition), M || (ct = checkSnapScale(o, ut, $, L, e)), Q) {
      J[0] && J[1] && ct[0] && ct[1] && (Math.abs(ct[0] * U) > Math.abs(ct[1] * H) ? ct[1] = 0 : ct[0] = 0);
      var pt = !ct[0] && !ct[1];
      if (pt && (Y ? ut[0] = throttle(ut[0] * X[0], Z) / X[0] : ut[1] = throttle(ut[1] * X[1], Z) / X[1]), J[0] && !J[1] || ct[0] && !ct[1] || pt && Y) {
        ut[0] += ct[0];
        var mt = U * ut[0] * X[0] / W;
        ut[1] = mt / H / X[1];
      } else if (!J[0] && J[1] || !ct[0] && ct[1] || pt && !Y) {
        ut[1] += ct[1];
        var vt = H * ut[1] * X[1] * W;
        ut[0] = vt / U / X[0];
      }
    } else
      ut[0] += ct[0], ut[1] += ct[1], ct[0] || (ut[0] = throttle(ut[0] * X[0], Z) / X[0]), ct[1] || (ut[1] = throttle(ut[1] * X[1], Z) / X[1]);
    ut[0] === 0 && (ut[0] = (B[0] > 0 ? 1 : -1) * MIN_SCALE), ut[1] === 0 && (ut[1] = (B[1] > 0 ? 1 : -1) * MIN_SCALE);
    var _t = [ut[0] / B[0], ut[1] / B[1]];
    st = multiply2(ut, X);
    var xt = getScaleDist(o, ut, e.fixedDirection, dt, e), At = minus(xt, e.prevInverseDist || [0, 0]);
    if (e.prevDist = ut, e.prevInverseDist = xt, st[0] === B[0] && st[1] === B[1] && At.every(function(bt) {
      return !bt;
    }) && !K)
      return !1;
    var yt = convertTransformFormat(e, "scale(".concat(st.join(", "), ")"), "scale(".concat(ut.join(", "), ")")), ht = fillParams(o, t, __assign$2({
      offsetWidth: U,
      offsetHeight: H,
      direction: $,
      scale: st,
      dist: ut,
      delta: _t,
      isPinch: !!M
    }, fillTransformEvent(o, yt, At, M, t)));
    return triggerEvent(o, "onScale", ht), ht;
  },
  dragControlEnd: function(o, t) {
    var e = t.datas, R = t.isDrag;
    return e.isScale ? (e.isScale = !1, triggerEvent(o, "onScaleEnd", fillEndParams(o, t, {})), R) : !1;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function(o, t) {
    var e = t.datas, R = this.dragControlStart(o, t);
    if (!R)
      return !1;
    var N = fillChildEvents(o, "resizable", t);
    function M(U, H) {
      var z = e.fixedDirection, X = e.fixedPosition, Y = H.datas.startPositions || getAbsolutePosesByState(U.state), W = getPosByDirection(Y, z), q = calculate(createRotateMatrix(-o.rotation / 180 * Math.PI, 3), [W[0] - X[0], W[1] - X[1], 1], 3), Z = q[0], K = q[1];
      return H.datas.originalX = Z, H.datas.originalY = K, H;
    }
    e.moveableScale = o.scale;
    var D = triggerChildAbles(o, this, "dragControlStart", t, function(U, H) {
      return M(U, H);
    }), L = function(U) {
      R.setFixedDirection(U), D.forEach(function(H, z) {
        H.setFixedDirection(U), M(H.moveable, N[z]);
      });
    };
    e.setFixedDirection = L;
    var B = __assign$2(__assign$2({}, R), {
      targets: o.props.targets,
      events: D,
      setFixedDirection: L
    }), $ = triggerEvent(o, "onScaleGroupStart", B);
    return e.isScale = $ !== !1, e.isScale ? B : !1;
  },
  dragGroupControl: function(o, t) {
    var e = t.datas;
    if (!!e.isScale) {
      catchEvent(o, "onBeforeScale", function(H) {
        triggerEvent(o, "onBeforeScaleGroup", fillParams(o, t, __assign$2(__assign$2({}, H), {
          targets: o.props.targets
        }), !0));
      });
      var R = this.dragControl(o, t);
      if (!!R) {
        var N = e.moveableScale;
        o.scale = [R.scale[0] * N[0], R.scale[1] * N[1]];
        var M = o.props.keepRatio, D = R.dist, L = R.scale, B = e.fixedPosition, $ = triggerChildAbles(o, this, "dragControl", t, function(H, z) {
          var X = calculate(createRotateMatrix(o.rotation / 180 * Math.PI, 3), [z.datas.originalX * D[0], z.datas.originalY * D[1], 1], 3), Y = X[0], W = X[1];
          return __assign$2(__assign$2({}, z), {
            parentDist: null,
            parentScale: L,
            parentKeepRatio: M,
            dragClient: plus(B, [Y, W])
          });
        }), U = __assign$2({
          targets: o.props.targets,
          events: $
        }, R);
        return triggerEvent(o, "onScaleGroup", U), U;
      }
    }
  },
  dragGroupControlEnd: function(o, t) {
    var e = t.isDrag, R = t.datas;
    if (!!R.isScale) {
      this.dragControlEnd(o, t);
      var N = triggerChildAbles(o, this, "dragControlEnd", t), M = fillEndParams(o, t, {
        targets: o.props.targets,
        events: N
      });
      return triggerEvent(o, "onScaleGroupEnd", M), e;
    }
  },
  request: function() {
    var o = {}, t = 0, e = 0;
    return {
      isControl: !0,
      requestStart: function(R) {
        return {
          datas: o,
          parentDirection: R.direction || [1, 1]
        };
      },
      request: function(R) {
        return t += R.deltaWidth, e += R.deltaHeight, {
          datas: o,
          parentDist: [t, e],
          parentKeepRatio: R.keepRatio
        };
      },
      requestEnd: function() {
        return {
          datas: o,
          isDrag: !0
        };
      }
    };
  }
};
function getMiddleLinePos(o, t) {
  return o.map(function(e, R) {
    return dot(e, t[R], 1, 2);
  });
}
function getTriangleRad(o, t, e) {
  var R = getRad$1(o, t), N = getRad$1(o, e), M = N - R;
  return M >= 0 ? M : M + 2 * Math.PI;
}
function isValidPos(o, t) {
  var e = getTriangleRad(o[0], o[1], o[2]), R = getTriangleRad(t[0], t[1], t[2]), N = Math.PI;
  return !(e >= N && R <= N || e <= N && R >= N);
}
var Warpable = {
  name: "warpable",
  ableGroup: "size",
  props: {
    warpable: Boolean,
    renderDirections: Array,
    edge: Boolean
  },
  events: {
    onWarpStart: "warpStart",
    onWarp: "warp",
    onWarpEnd: "warpEnd"
  },
  render: function(o, t) {
    var e = o.props, R = e.resizable, N = e.scalable, M = e.warpable, D = e.zoom;
    if (R || N || !M)
      return [];
    var L = o.state, B = L.pos1, $ = L.pos2, U = L.pos3, H = L.pos4, z = getMiddleLinePos(B, $), X = getMiddleLinePos($, B), Y = getMiddleLinePos(B, U), W = getMiddleLinePos(U, B), q = getMiddleLinePos(U, H), Z = getMiddleLinePos(H, U), K = getMiddleLinePos($, H), J = getMiddleLinePos(H, $);
    return __spreadArray([t.createElement("div", {
      className: prefix("line"),
      key: "middeLine1",
      style: getLineStyle(z, q, D)
    }), t.createElement("div", {
      className: prefix("line"),
      key: "middeLine2",
      style: getLineStyle(X, Z, D)
    }), t.createElement("div", {
      className: prefix("line"),
      key: "middeLine3",
      style: getLineStyle(Y, K, D)
    }), t.createElement("div", {
      className: prefix("line"),
      key: "middeLine4",
      style: getLineStyle(W, J, D)
    })], renderAllDirections(o, "warpable", t), !0);
  },
  dragControlCondition: function(o, t) {
    if (t.isRequest)
      return !1;
    var e = t.inputEvent.target;
    return hasClass(e, prefix("direction")) && hasClass(e, prefix("warpable"));
  },
  dragControlStart: function(o, t) {
    var e = t.datas, R = t.inputEvent, N = o.props.target, M = R.target, D = getDirection(M);
    if (!D || !N)
      return !1;
    var L = o.state, B = L.transformOrigin, $ = L.is3d, U = L.targetTransform, H = L.targetMatrix, z = L.width, X = L.height, Y = L.left, W = L.top;
    e.datas = {}, e.targetTransform = U, e.warpTargetMatrix = $ ? H : convertDimension(H, 3, 4), e.targetInverseMatrix = ignoreDimension(invert(e.warpTargetMatrix, 4), 3, 4), e.direction = D, e.left = Y, e.top = W, e.poses = [[0, 0], [z, 0], [0, X], [z, X]].map(function(K) {
      return minus(K, B);
    }), e.nextPoses = e.poses.map(function(K) {
      var J = K[0], Q = K[1];
      return calculate(e.warpTargetMatrix, [J, Q, 0, 1], 4);
    }), e.startValue = createIdentityMatrix(4), e.prevMatrix = createIdentityMatrix(4), e.absolutePoses = getAbsolutePosesByState(L), e.posIndexes = getPosIndexesByDirection(D), setDragStart(o, t), setDefaultTransformIndex(t, "matrix3d"), L.snapRenderInfo = {
      request: t.isRequest,
      direction: D
    };
    var q = fillParams(o, t, __assign$2({
      set: function(K) {
        e.startValue = K;
      }
    }, fillTransformStartEvent(t))), Z = triggerEvent(o, "onWarpStart", q);
    return Z !== !1 && (e.isWarp = !0), e.isWarp;
  },
  dragControl: function(o, t) {
    var e = t.datas, R = t.isRequest, N = t.distX, M = t.distY, D = e.targetInverseMatrix, L = e.prevMatrix, B = e.isWarp, $ = e.startValue, U = e.poses, H = e.posIndexes, z = e.absolutePoses;
    if (!B)
      return !1;
    if (resolveTransformEvent(t, "matrix3d"), hasGuidelines(o, "warpable")) {
      var X = H.map(function(at) {
        return z[at];
      });
      X.length > 1 && X.push([(X[0][0] + X[1][0]) / 2, (X[0][1] + X[1][1]) / 2]);
      var Y = checkMoveableSnapBounds(o, R, {
        horizontal: X.map(function(at) {
          return at[1] + M;
        }),
        vertical: X.map(function(at) {
          return at[0] + N;
        })
      }), W = Y.horizontal, q = Y.vertical;
      M -= W.offset, N -= q.offset;
    }
    var Z = getDragDist({
      datas: e,
      distX: N,
      distY: M
    }, !0), K = e.nextPoses.slice();
    if (H.forEach(function(at) {
      K[at] = plus(K[at], Z);
    }), !NEARBY_POS.every(function(at) {
      return isValidPos(at.map(function(ut) {
        return U[ut];
      }), at.map(function(ut) {
        return K[ut];
      }));
    }))
      return !1;
    var J = createWarpMatrix(U[0], U[2], U[1], U[3], K[0], K[2], K[1], K[3]);
    if (!J.length)
      return !1;
    var Q = multiply(D, J, 4), et = getTransfromMatrix(e, Q, !0), tt = multiply(invert(L, 4), et, 4);
    e.prevMatrix = et;
    var st = multiply($, et, 4), rt = convertTransformFormat(e, "matrix3d(".concat(st.join(", "), ")"), "matrix3d(".concat(et.join(", "), ")"));
    return fillOriginalTransform(t, rt), triggerEvent(o, "onWarp", fillParams(o, t, {
      delta: tt,
      matrix: st,
      dist: et,
      multiply,
      transform: rt
    })), !0;
  },
  dragControlEnd: function(o, t) {
    var e = t.datas, R = t.isDrag;
    return e.isWarp ? (e.isWarp = !1, triggerEvent(o, "onWarpEnd", fillEndParams(o, t, {})), R) : !1;
  }
}, AREA_PIECES = /* @__PURE__ */ prefix("area-pieces"), AREA_PIECE = /* @__PURE__ */ prefix("area-piece"), AVOID = /* @__PURE__ */ prefix("avoid");
function restoreStyle(o) {
  var t = o.areaElement;
  if (!!t) {
    var e = o.state, R = e.width, N = e.height;
    removeClass(t, AVOID), t.style.cssText += "left: 0px; top: 0px; width: ".concat(R, "px; height: ").concat(N, "px");
  }
}
function renderPieces(o) {
  return o.createElement("div", {
    key: "area_pieces",
    className: AREA_PIECES
  }, o.createElement("div", {
    className: AREA_PIECE
  }), o.createElement("div", {
    className: AREA_PIECE
  }), o.createElement("div", {
    className: AREA_PIECE
  }), o.createElement("div", {
    className: AREA_PIECE
  }));
}
var DragArea = {
  name: "dragArea",
  props: {
    dragArea: Boolean,
    passDragArea: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  render: function(o, t) {
    var e = o.props, R = e.target, N = e.dragArea, M = e.groupable, D = e.passDragArea, L = o.state, B = L.width, $ = L.height, U = L.renderPoses, H = D ? prefix("area", "pass") : prefix("area");
    if (M)
      return [t.createElement("div", {
        key: "area",
        ref: ref(o, "areaElement"),
        className: H
      }), renderPieces(t)];
    if (!R || !N)
      return [];
    var z = createWarpMatrix([0, 0], [B, 0], [0, $], [B, $], U[0], U[1], U[2], U[3]), X = z.length ? makeMatrixCSS(z, !0) : "none";
    return [t.createElement("div", {
      key: "area",
      ref: ref(o, "areaElement"),
      className: H,
      style: {
        top: "0px",
        left: "0px",
        width: "".concat(B, "px"),
        height: "".concat($, "px"),
        transformOrigin: "0 0",
        transform: X
      }
    }), renderPieces(t)];
  },
  dragStart: function(o, t) {
    var e = t.datas, R = t.clientX, N = t.clientY, M = t.inputEvent;
    if (!M)
      return !1;
    e.isDragArea = !1;
    var D = o.areaElement, L = o.state, B = L.moveableClientRect, $ = L.renderPoses, U = L.rootMatrix, H = L.is3d, z = B.left, X = B.top, Y = getRect($), W = Y.left, q = Y.top, Z = Y.width, K = Y.height, J = H ? 4 : 3, Q = calculateInversePosition(U, [R - z, N - X], J), et = Q[0], tt = Q[1];
    et -= W, tt -= q;
    var st = [{
      left: W,
      top: q,
      width: Z,
      height: tt - 10
    }, {
      left: W,
      top: q,
      width: et - 10,
      height: K
    }, {
      left: W,
      top: q + tt + 10,
      width: Z,
      height: K - tt - 10
    }, {
      left: W + et + 10,
      top: q,
      width: Z - et - 10,
      height: K
    }], rt = [].slice.call(D.nextElementSibling.children);
    st.forEach(function(at, ut) {
      rt[ut].style.cssText = "left: ".concat(at.left, "px;top: ").concat(at.top, "px; width: ").concat(at.width, "px; height: ").concat(at.height, "px;");
    }), addClass(D, AVOID), L.disableNativeEvent = !0;
  },
  drag: function(o, t) {
    var e = t.datas, R = t.inputEvent;
    if (this.enableNativeEvent(o), !R)
      return !1;
    e.isDragArea || (e.isDragArea = !0, restoreStyle(o));
  },
  dragEnd: function(o, t) {
    this.enableNativeEvent(o);
    var e = t.inputEvent, R = t.datas;
    if (!e)
      return !1;
    R.isDragArea || restoreStyle(o);
  },
  dragGroupStart: function(o, t) {
    return this.dragStart(o, t);
  },
  dragGroup: function(o, t) {
    return this.drag(o, t);
  },
  dragGroupEnd: function(o, t) {
    return this.dragEnd(o, t);
  },
  unset: function(o) {
    restoreStyle(o), o.state.disableNativeEvent = !1;
  },
  enableNativeEvent: function(o) {
    var t = o.state;
    t.disableNativeEvent && requestAnimationFrame$1(function() {
      t.disableNativeEvent = !1;
    });
  }
}, Origin = makeAble("origin", {
  render: function(o, t) {
    var e = o.props.zoom, R = o.state, N = R.beforeOrigin, M = R.rotation;
    return [t.createElement("div", {
      className: prefix("control", "origin"),
      style: getControlTransform(M, e, N),
      key: "beforeOrigin"
    })];
  }
});
function getDefaultScrollPosition(o) {
  var t = o.scrollContainer;
  return [t.scrollLeft, t.scrollTop];
}
var Scrollable = {
  name: "scrollable",
  canPinch: !0,
  props: {
    scrollable: Boolean,
    scrollContainer: Object,
    scrollThreshold: Number,
    getScrollPosition: Function
  },
  events: {
    onScroll: "scroll",
    onScrollGroup: "scrollGroup"
  },
  dragRelation: "strong",
  dragStart: function(o, t) {
    var e = o.props, R = e.scrollContainer, N = R === void 0 ? o.getContainer() : R, M = new DragScroll$1(), D = getRefTarget(N, !0);
    t.datas.dragScroll = M;
    var L = t.isControl ? "controlGesto" : "targetGesto", B = t.targets;
    M.on("scroll", function($) {
      var U = $.container, H = $.direction, z = fillParams(o, t, {
        scrollContainer: U,
        direction: H
      }), X = B ? "onScrollGroup" : "onScroll";
      B && (z.targets = B), triggerEvent(o, X, z);
    }).on("move", function($) {
      var U = $.offsetX, H = $.offsetY;
      o[L].scrollBy(U, H, t.inputEvent, !1);
    }), M.dragStart(t, {
      container: D
    });
  },
  checkScroll: function(o, t) {
    var e = t.datas.dragScroll;
    if (!!e) {
      var R = o.props, N = R.scrollContainer, M = N === void 0 ? o.getContainer() : N, D = R.scrollThreshold, L = D === void 0 ? 0 : D, B = R.getScrollPosition, $ = B === void 0 ? getDefaultScrollPosition : B;
      return e.drag(t, {
        container: M,
        threshold: L,
        getScrollPosition: function(U) {
          return $({
            scrollContainer: U.container,
            direction: U.direction
          });
        }
      }), !0;
    }
  },
  drag: function(o, t) {
    return this.checkScroll(o, t);
  },
  dragEnd: function(o, t) {
    t.datas.dragScroll.dragEnd(), t.datas.dragScroll = null;
  },
  dragControlStart: function(o, t) {
    return this.dragStart(o, __assign$2(__assign$2({}, t), {
      isControl: !0
    }));
  },
  dragControl: function(o, t) {
    return this.drag(o, t);
  },
  dragControlEnd: function(o, t) {
    return this.dragEnd(o, t);
  },
  dragGroupStart: function(o, t) {
    return this.dragStart(o, __assign$2(__assign$2({}, t), {
      targets: o.props.targets
    }));
  },
  dragGroup: function(o, t) {
    return this.drag(o, __assign$2(__assign$2({}, t), {
      targets: o.props.targets
    }));
  },
  dragGroupEnd: function(o, t) {
    return this.dragEnd(o, __assign$2(__assign$2({}, t), {
      targets: o.props.targets
    }));
  },
  dragGroupControlStart: function(o, t) {
    return this.dragStart(o, __assign$2(__assign$2({}, t), {
      targets: o.props.targets,
      isControl: !0
    }));
  },
  dragGroupContro: function(o, t) {
    return this.drag(o, __assign$2(__assign$2({}, t), {
      targets: o.props.targets
    }));
  },
  dragGroupControEnd: function(o, t) {
    return this.dragEnd(o, __assign$2(__assign$2({}, t), {
      targets: o.props.targets
    }));
  }
}, Default = {
  name: "",
  props: {
    target: Object,
    dragTarget: Object,
    container: Object,
    portalContainer: Object,
    rootContainer: Object,
    useResizeObserver: Boolean,
    zoom: Number,
    transformOrigin: Array,
    edge: Object,
    ables: Array,
    className: String,
    pinchThreshold: Number,
    pinchOutside: Boolean,
    triggerAblesSimultaneously: Boolean,
    checkInput: Boolean,
    cspNonce: String,
    translateZ: Number,
    hideDefaultLines: Boolean,
    props: Object,
    flushSync: Function,
    stopPropagation: Boolean,
    preventClickEventOnDrag: Boolean,
    preventClickDefault: Boolean
  },
  events: {}
}, Padding = makeAble("padding", {
  render: function(o, t) {
    var e = o.props;
    if (e.dragArea)
      return [];
    var R = e.padding || {}, N = R.left, M = N === void 0 ? 0 : N, D = R.top, L = D === void 0 ? 0 : D, B = R.right, $ = B === void 0 ? 0 : B, U = R.bottom, H = U === void 0 ? 0 : U, z = o.state, X = z.renderPoses, Y = z.pos1, W = z.pos2, q = z.pos3, Z = z.pos4, K = [Y, W, q, Z], J = [];
    return M > 0 && J.push([0, 2]), L > 0 && J.push([0, 1]), $ > 0 && J.push([1, 3]), H > 0 && J.push([2, 3]), J.map(function(Q, et) {
      var tt = Q[0], st = Q[1], rt = K[tt], at = K[st], ut = X[tt], dt = X[st], ct = createWarpMatrix([0, 0], [100, 0], [0, 100], [100, 100], rt, at, ut, dt);
      if (!!ct.length)
        return t.createElement("div", {
          key: "padding".concat(et),
          className: prefix("padding"),
          style: {
            transform: makeMatrixCSS(ct, !0)
          }
        });
    });
  }
}), RADIUS_DIRECTIONS = ["nw", "ne", "se", "sw"];
function calculateRatio(o, t) {
  var e = o[0] + o[1], R = e > t ? t / e : 1;
  return o[0] *= R, o[1] = t - o[1] * R, o;
}
var HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6], VERTICAL_RADIUS_ORDER = [0, 3, 4, 7], HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1], VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];
function getRadiusStyles(o, t, e, R, N, M, D, L, B) {
  M === void 0 && (M = 0), D === void 0 && (D = 0), L === void 0 && (L = R), B === void 0 && (B = N);
  var $ = [], U = !1, H = o.map(function(z, X) {
    var Y = t[X], W = Y.horizontal, q = Y.vertical;
    if (q && !U && (U = !0, $.push("/")), U) {
      var Z = Math.max(0, q === 1 ? z[1] - D : B - z[1]);
      return $.push(convertCSSSize(Z, N, e)), Z;
    } else {
      var Z = Math.max(0, W === 1 ? z[0] - M : L - z[0]);
      return $.push(convertCSSSize(Z, R, e)), Z;
    }
  });
  return {
    styles: $,
    raws: H
  };
}
function getRadiusRange(o) {
  for (var t = [0, 0], e = [0, 0], R = o.length, N = 0; N < R; ++N) {
    var M = o[N];
    !M.sub || (M.horizontal && (t[1] === 0 && (t[0] = N), t[1] = N - t[0] + 1, e[0] = N + 1), M.vertical && (e[1] === 0 && (e[0] = N), e[1] = N - e[0] + 1));
  }
  return {
    horizontalRange: t,
    verticalRange: e
  };
}
function getRadiusValues(o, t, e, R, N, M) {
  var D, L, B, $;
  M === void 0 && (M = [0, 0]);
  var U = o.indexOf("/"), H = (U > -1 ? o.slice(0, U) : o).length, z = o.slice(0, H), X = o.slice(H + 1), Y = z[0], W = Y === void 0 ? "0px" : Y, q = z[1], Z = q === void 0 ? W : q, K = z[2], J = K === void 0 ? W : K, Q = z[3], et = Q === void 0 ? Z : Q, tt = X[0], st = tt === void 0 ? W : tt, rt = X[1], at = rt === void 0 ? st : rt, ut = X[2], dt = ut === void 0 ? st : ut, ct = X[3], pt = ct === void 0 ? at : ct, mt = [W, Z, J, et].map(function(ht) {
    return convertUnitSize(ht, t);
  }), vt = [st, at, dt, pt].map(function(ht) {
    return convertUnitSize(ht, e);
  }), _t = mt.slice(), xt = vt.slice();
  D = calculateRatio([_t[0], _t[1]], t), _t[0] = D[0], _t[1] = D[1], L = calculateRatio([_t[3], _t[2]], t), _t[3] = L[0], _t[2] = L[1], B = calculateRatio([xt[0], xt[3]], e), xt[0] = B[0], xt[3] = B[1], $ = calculateRatio([xt[1], xt[2]], e), xt[1] = $[0], xt[2] = $[1];
  var At = _t.slice(0, Math.max(M[0], z.length)), yt = xt.slice(0, Math.max(M[1], X.length));
  return __spreadArray(__spreadArray([], At.map(function(ht, bt) {
    var Ct = RADIUS_DIRECTIONS[bt];
    return {
      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[bt],
      vertical: 0,
      pos: [R + ht, N + (VERTICAL_RADIUS_DIRECTIONS[bt] === -1 ? e : 0)],
      sub: !0,
      raw: mt[bt],
      direction: Ct
    };
  }), !0), yt.map(function(ht, bt) {
    var Ct = RADIUS_DIRECTIONS[bt];
    return {
      horizontal: 0,
      vertical: VERTICAL_RADIUS_DIRECTIONS[bt],
      pos: [R + (HORIZONTAL_RADIUS_DIRECTIONS[bt] === -1 ? t : 0), N + ht],
      sub: !0,
      raw: vt[bt],
      direction: Ct
    };
  }), !0);
}
function removeRadiusPos(o, t, e, R, N) {
  N === void 0 && (N = t.length);
  var M = getRadiusRange(o.slice(R)), D = M.horizontalRange, L = M.verticalRange, B = e - R, $ = 0;
  if (B === 0)
    $ = N;
  else if (B > 0 && B < D[1])
    $ = D[1] - B;
  else if (B >= L[0])
    $ = L[0] + L[1] - B;
  else
    return;
  o.splice(e, $), t.splice(e, $);
}
function addRadiusPos(o, t, e, R, N, M, D, L, B, $, U) {
  $ === void 0 && ($ = 0), U === void 0 && (U = 0);
  var H = getRadiusRange(o.slice(e)), z = H.horizontalRange, X = H.verticalRange;
  if (R > -1)
    for (var Y = HORIZONTAL_RADIUS_DIRECTIONS[R] === 1 ? M - $ : L - M, W = z[1]; W <= R; ++W) {
      var q = VERTICAL_RADIUS_DIRECTIONS[W] === 1 ? U : B, Z = 0;
      if (R === W ? Z = M : W === 0 ? Z = $ + Y : HORIZONTAL_RADIUS_DIRECTIONS[W] === -1 && (Z = L - (t[e][0] - $)), o.splice(e + W, 0, {
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[W],
        vertical: 0,
        pos: [Z, q]
      }), t.splice(e + W, 0, [Z, q]), W === 0)
        break;
    }
  else if (N > -1) {
    var K = VERTICAL_RADIUS_DIRECTIONS[N] === 1 ? D - U : B - D;
    if (z[1] === 0 && X[1] === 0) {
      var J = [$ + K, U];
      o.push({
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],
        vertical: 0,
        pos: J
      }), t.push(J);
    }
    for (var Q = X[0], W = X[1]; W <= N; ++W) {
      var Z = HORIZONTAL_RADIUS_DIRECTIONS[W] === 1 ? $ : L, q = 0;
      if (N === W ? q = D : W === 0 ? q = U + K : VERTICAL_RADIUS_DIRECTIONS[W] === 1 ? q = t[e + Q][1] : VERTICAL_RADIUS_DIRECTIONS[W] === -1 && (q = B - (t[e + Q][1] - U)), o.push({
        horizontal: 0,
        vertical: VERTICAL_RADIUS_DIRECTIONS[W],
        pos: [Z, q]
      }), t.push([Z, q]), W === 0)
        break;
    }
  }
}
function splitRadiusPoses(o, t) {
  t === void 0 && (t = o.map(function(N) {
    return N.raw;
  }));
  var e = o.map(function(N, M) {
    return N.horizontal ? t[M] : null;
  }).filter(function(N) {
    return N != null;
  }), R = o.map(function(N, M) {
    return N.vertical ? t[M] : null;
  }).filter(function(N) {
    return N != null;
  });
  return {
    horizontals: e,
    verticals: R
  };
}
var CLIP_DIRECTIONS = [[0, -1, "n"], [1, 0, "e"]], CLIP_RECT_DIRECTIONS = [[-1, -1, "nw"], [0, -1, "n"], [1, -1, "ne"], [1, 0, "e"], [1, 1, "se"], [0, 1, "s"], [-1, 1, "sw"], [-1, 0, "w"]];
function getClipStyles(o, t, e) {
  var R = o.props.clipRelative, N = o.state, M = N.width, D = N.height, L = t, B = L.type, $ = L.poses, U = B === "rect", H = B === "circle";
  if (B === "polygon")
    return e.map(function(tt) {
      return "".concat(convertCSSSize(tt[0], M, R), " ").concat(convertCSSSize(tt[1], D, R));
    });
  if (U || B === "inset") {
    var z = e[1][1], X = e[3][0], Y = e[7][0], W = e[5][1];
    if (U)
      return [z, X, W, Y].map(function(tt) {
        return "".concat(tt, "px");
      });
    var q = [z, M - X, D - W, Y].map(function(tt, st) {
      return convertCSSSize(tt, st % 2 ? M : D, R);
    });
    if (e.length > 8) {
      var Z = minus(e[4], e[0]), K = Z[0], J = Z[1];
      q.push.apply(q, __spreadArray(["round"], getRadiusStyles(e.slice(8), $.slice(8), R, K, J, Y, z, X, W).styles, !1));
    }
    return q;
  } else if (H || B === "ellipse") {
    var Q = e[0], et = convertCSSSize(Math.abs(e[1][1] - Q[1]), H ? Math.sqrt((M * M + D * D) / 2) : D, R), q = H ? [et] : [convertCSSSize(Math.abs(e[2][0] - Q[0]), M, R), et];
    return q.push("at", convertCSSSize(Q[0], M, R), convertCSSSize(Q[1], D, R)), q;
  }
}
function getRectPoses(o, t, e, R) {
  var N = [R, (R + t) / 2, t], M = [o, (o + e) / 2, e];
  return CLIP_RECT_DIRECTIONS.map(function(D) {
    var L = D[0], B = D[1], $ = D[2], U = N[L + 1], H = M[B + 1];
    return {
      vertical: Math.abs(B),
      horizontal: Math.abs(L),
      direction: $,
      pos: [U, H]
    };
  });
}
function getControlSize(o) {
  var t = [1 / 0, -1 / 0], e = [1 / 0, -1 / 0];
  return o.forEach(function(R) {
    var N = R.pos;
    t[0] = Math.min(t[0], N[0]), t[1] = Math.max(t[1], N[0]), e[0] = Math.min(e[0], N[1]), e[1] = Math.max(e[1], N[1]);
  }), [Math.abs(t[1] - t[0]), Math.abs(e[1] - e[0])];
}
function moveControlPos(o, t, e, R, N) {
  var M = o[t], D = M.direction, L = M.sub, B = o.map(function() {
    return [0, 0];
  }), $ = D ? D.split("") : [];
  if (R && t < 8) {
    var U = $.filter(function(pt) {
      return pt === "w" || pt === "e";
    }), H = $.filter(function(pt) {
      return pt === "n" || pt === "s";
    }), z = U[0], X = H[0];
    B[t] = e;
    var Y = getControlSize(o), W = Y[0], q = Y[1], Z = W && q ? W / q : 0;
    if (Z && N) {
      var K = (t + 4) % 8, J = o[K].pos, Q = [0, 0];
      D.indexOf("w") > -1 ? Q[0] = -1 : D.indexOf("e") > -1 && (Q[0] = 1), D.indexOf("n") > -1 ? Q[1] = -1 : D.indexOf("s") > -1 && (Q[1] = 1);
      var et = getSizeDistByDist([W, q], e, Z, Q, !0), tt = W + et[0], st = q + et[1], rt = J[1], at = J[1], ut = J[0], dt = J[0];
      Q[0] === -1 ? ut = dt - tt : Q[0] === 1 ? dt = ut + tt : (ut = ut - tt / 2, dt = dt + tt / 2), Q[1] === -1 ? rt = at - st : (Q[1] === 1 || (rt = at - st / 2), at = rt + st);
      var ct = getRectPoses(rt, dt, at, ut);
      o.forEach(function(pt, mt) {
        B[mt][0] = ct[mt].pos[0] - pt.pos[0], B[mt][1] = ct[mt].pos[1] - pt.pos[1];
      });
    } else
      o.forEach(function(pt, mt) {
        var vt = pt.direction;
        !vt || (vt.indexOf(z) > -1 && (B[mt][0] = e[0]), vt.indexOf(X) > -1 && (B[mt][1] = e[1]));
      }), z && (B[1][0] = e[0] / 2, B[5][0] = e[0] / 2), X && (B[3][1] = e[1] / 2, B[7][1] = e[1] / 2);
  } else
    D && !L ? $.forEach(function(pt) {
      var mt = pt === "n" || pt === "s";
      o.forEach(function(vt, _t) {
        var xt = vt.direction, At = vt.horizontal, yt = vt.vertical;
        !xt || xt.indexOf(pt) === -1 || (B[_t] = [mt || !At ? 0 : e[0], !mt || !yt ? 0 : e[1]]);
      });
    }) : B[t] = e;
  return B;
}
function getClipPath(o, t, e, R, N) {
  var M, D, L, B, $, U, H, z = N;
  if (!z) {
    var X = getComputedStyle$1$1(o), Y = X.clipPath;
    z = Y !== "none" ? Y : X.clip;
  }
  if (!((!z || z === "none" || z === "auto") && (z = R, !z))) {
    var W = splitBracket(z), q = W.prefix, Z = q === void 0 ? z : q, K = W.value, J = K === void 0 ? "" : K, Q = Z === "circle", et = " ";
    if (Z === "polygon") {
      var tt = splitComma(J || "0% 0%, 100% 0%, 100% 100%, 0% 100%");
      et = ",";
      var st = tt.map(function(Rt) {
        var Jt = Rt.split(" "), Kt = Jt[0], ae = Jt[1];
        return {
          vertical: 1,
          horizontal: 1,
          pos: [convertUnitSize(Kt, t), convertUnitSize(ae, e)]
        };
      });
      return {
        type: Z,
        clipText: z,
        poses: st,
        splitter: et
      };
    } else if (Q || Z === "ellipse") {
      var rt = "", at = "", ut = 0, dt = 0, tt = splitSpace(J);
      if (Q) {
        var ct = "";
        M = tt[0], ct = M === void 0 ? "50%" : M, D = tt[2], rt = D === void 0 ? "50%" : D, L = tt[3], at = L === void 0 ? "50%" : L, ut = convertUnitSize(ct, Math.sqrt((t * t + e * e) / 2)), dt = ut;
      } else {
        var pt = "", mt = "";
        B = tt[0], pt = B === void 0 ? "50%" : B, $ = tt[1], mt = $ === void 0 ? "50%" : $, U = tt[3], rt = U === void 0 ? "50%" : U, H = tt[4], at = H === void 0 ? "50%" : H, ut = convertUnitSize(pt, t), dt = convertUnitSize(mt, e);
      }
      var vt = [convertUnitSize(rt, t), convertUnitSize(at, e)], st = __spreadArray([{
        vertical: 1,
        horizontal: 1,
        pos: vt,
        direction: "nesw"
      }], CLIP_DIRECTIONS.slice(0, Q ? 1 : 2).map(function(Kt) {
        return {
          vertical: Math.abs(Kt[1]),
          horizontal: Kt[0],
          direction: Kt[2],
          sub: !0,
          pos: [vt[0] + Kt[0] * ut, vt[1] + Kt[1] * dt]
        };
      }), !0);
      return {
        type: Z,
        clipText: z,
        radiusX: ut,
        radiusY: dt,
        left: vt[0] - ut,
        top: vt[1] - dt,
        poses: st,
        splitter: et
      };
    } else if (Z === "inset") {
      var tt = splitSpace(J || "0 0 0 0"), _t = tt.indexOf("round"), xt = (_t > -1 ? tt.slice(0, _t) : tt).length, At = tt.slice(xt + 1), yt = tt.slice(0, xt), ht = yt[0], bt = yt[1], Ct = bt === void 0 ? ht : bt, Mt = yt[2], wt = Mt === void 0 ? ht : Mt, Lt = yt[3], ft = Lt === void 0 ? Ct : Lt, Gt = [ht, wt].map(function(Kt) {
        return convertUnitSize(Kt, e);
      }), Dt = Gt[0], Bt = Gt[1], Ot = [ft, Ct].map(function(Kt) {
        return convertUnitSize(Kt, t);
      }), Et = Ot[0], Ht = Ot[1], It = t - Ht, St = e - Bt, Nt = getRadiusValues(At, It - Et, St - Dt, Et, Dt), st = __spreadArray(__spreadArray([], getRectPoses(Dt, It, St, Et), !0), Nt, !0);
      return {
        type: "inset",
        clipText: z,
        poses: st,
        top: Dt,
        left: Et,
        right: It,
        bottom: St,
        radius: At,
        splitter: et
      };
    } else if (Z === "rect") {
      var tt = splitComma(J || "0px, ".concat(t, "px, ").concat(e, "px, 0px"));
      et = ",";
      var $t = tt.map(function(ee) {
        var Re = splitUnit(ee).value;
        return Re;
      }), Dt = $t[0], Ht = $t[1], Bt = $t[2], Et = $t[3], st = getRectPoses(Dt, Ht, Bt, Et);
      return {
        type: "rect",
        clipText: z,
        poses: st,
        top: Dt,
        right: Ht,
        bottom: Bt,
        left: Et,
        values: tt,
        splitter: et
      };
    }
  }
}
function addClipPath(o, t) {
  var e = calculatePointerDist(o, t), R = e[0], N = e[1], M = t.datas, D = M.clipPath, L = M.clipIndex, B = D, $ = B.type, U = B.poses, H = B.splitter, z = U.map(function(Z) {
    return Z.pos;
  });
  if ($ === "polygon")
    z.splice(L, 0, [R, N]);
  else if ($ === "inset") {
    var X = HORIZONTAL_RADIUS_ORDER.indexOf(L), Y = VERTICAL_RADIUS_ORDER.indexOf(L), W = U.length;
    if (addRadiusPos(U, z, 8, X, Y, R, N, z[4][0], z[4][1], z[0][0], z[0][1]), W === U.length)
      return;
  } else
    return;
  var q = getClipStyles(o, D, z);
  triggerEvent(o, "onClip", fillParams(o, t, {
    clipEventType: "added",
    clipType: $,
    poses: z,
    clipStyles: q,
    clipStyle: "".concat($, "(").concat(q.join(H), ")"),
    distX: 0,
    distY: 0
  }));
}
function removeClipPath(o, t) {
  var e = t.datas, R = e.clipPath, N = e.clipIndex, M = R, D = M.type, L = M.poses, B = M.splitter, $ = L.map(function(z) {
    return z.pos;
  }), U = $.length;
  if (D === "polygon")
    L.splice(N, 1), $.splice(N, 1);
  else if (D === "inset") {
    if (N < 8 || (removeRadiusPos(L, $, N, 8, U), U === L.length))
      return;
  } else
    return;
  var H = getClipStyles(o, R, $);
  triggerEvent(o, "onClip", fillParams(o, t, {
    clipEventType: "removed",
    clipType: D,
    poses: $,
    clipStyles: H,
    clipStyle: "".concat(D, "(").concat(H.join(B), ")"),
    distX: 0,
    distY: 0
  }));
}
var Clippable = {
  name: "clippable",
  props: {
    clippable: Boolean,
    defaultClipPath: String,
    customClipPath: String,
    keepRatio: Boolean,
    clipRelative: Boolean,
    clipArea: Boolean,
    dragWithClip: Boolean,
    clipTargetBounds: Boolean,
    clipVerticalGuidelines: Array,
    clipHorizontalGuidelines: Array,
    clipSnapThreshold: Boolean
  },
  events: {
    onClipStart: "clipStart",
    onClip: "clip",
    onClipEnd: "clipEnd"
  },
  css: [`.control.clip-control {
    background: #6d6;
    cursor: pointer;
}
.control.clip-control.clip-radius {
    background: #d66;
}
.line.clip-line {
    background: #6e6;
    cursor: move;
    z-index: 1;
}
.clip-area {
    position: absolute;
    top: 0;
    left: 0;
}
.clip-ellipse {
    position: absolute;
    cursor: move;
    border: 1px solid #6d6;
    border: var(--zoompx) solid #6d6;
    border-radius: 50%;
    transform-origin: 0px 0px;
}`, `:host {
    --bounds-color: #d66;
}`, `.guideline {
    pointer-events: none;
    z-index: 2;
}`, `.line.guideline.bounds {
    background: #d66;
    background: var(--bounds-color);
}`],
  render: function(o, t) {
    var e = o.props, R = e.customClipPath, N = e.defaultClipPath, M = e.clipArea, D = e.zoom, L = o.state, B = L.target, $ = L.width, U = L.height, H = L.allMatrix, z = L.is3d, X = L.left, Y = L.top, W = L.pos1, q = L.pos2, Z = L.pos3, K = L.pos4, J = L.clipPathState, Q = L.snapBoundInfos, et = L.rotation;
    if (!B)
      return [];
    var tt = getClipPath(B, $, U, N || "inset", J || R);
    if (!tt)
      return [];
    var st = z ? 4 : 3, rt = tt.type, at = tt.poses, ut = at.map(function(St) {
      var Nt = calculatePosition(H, St.pos, st);
      return [Nt[0] - X, Nt[1] - Y];
    }), dt = [], ct = [], pt = rt === "rect", mt = rt === "inset", vt = rt === "polygon";
    if (pt || mt || vt) {
      var _t = mt ? ut.slice(0, 8) : ut;
      ct = _t.map(function(St, Nt) {
        var $t = Nt === 0 ? _t[_t.length - 1] : _t[Nt - 1], Rt = getRad$1($t, St), Jt = getDiagonalSize($t, St);
        return t.createElement("div", {
          key: "clipLine".concat(Nt),
          className: prefix("line", "clip-line", "snap-control"),
          "data-clip-index": Nt,
          style: {
            width: "".concat(Jt, "px"),
            transform: "translate(".concat($t[0], "px, ").concat($t[1], "px) rotate(").concat(Rt, "rad) scaleY(").concat(D, ")")
          }
        });
      });
    }
    if (dt = ut.map(function(St, Nt) {
      return t.createElement("div", {
        key: "clipControl".concat(Nt),
        className: prefix("control", "clip-control", "snap-control"),
        "data-clip-index": Nt,
        style: {
          transform: "translate(".concat(St[0], "px, ").concat(St[1], "px) rotate(").concat(et, "rad) scale(").concat(D, ")")
        }
      });
    }), mt && dt.push.apply(dt, ut.slice(8).map(function(St, Nt) {
      return t.createElement("div", {
        key: "clipRadiusControl".concat(Nt),
        className: prefix("control", "clip-control", "clip-radius", "snap-control"),
        "data-clip-index": 8 + Nt,
        style: {
          transform: "translate(".concat(St[0], "px, ").concat(St[1], "px) rotate(").concat(et, "rad) scale(").concat(D, ")")
        }
      });
    })), rt === "circle" || rt === "ellipse") {
      var xt = tt.left, At = tt.top, yt = tt.radiusX, ht = tt.radiusY, bt = minus(calculatePosition(H, [xt, At], st), calculatePosition(H, [0, 0], st)), Ct = bt[0], Mt = bt[1], wt = "none";
      if (!M) {
        for (var Lt = Math.max(10, yt / 5, ht / 5), ft = [], Gt = 0; Gt <= Lt; ++Gt) {
          var Dt = Math.PI * 2 / Lt * Gt;
          ft.push([yt + (yt - D) * Math.cos(Dt), ht + (ht - D) * Math.sin(Dt)]);
        }
        ft.push([yt, -2]), ft.push([-2, -2]), ft.push([-2, ht * 2 + 2]), ft.push([yt * 2 + 2, ht * 2 + 2]), ft.push([yt * 2 + 2, -2]), ft.push([yt, -2]), wt = "polygon(".concat(ft.map(function(St) {
          return "".concat(St[0], "px ").concat(St[1], "px");
        }).join(", "), ")");
      }
      dt.push(t.createElement("div", {
        key: "clipEllipse",
        className: prefix("clip-ellipse", "snap-control"),
        style: {
          width: "".concat(yt * 2, "px"),
          height: "".concat(ht * 2, "px"),
          clipPath: wt,
          transform: "translate(".concat(-X + Ct, "px, ").concat(-Y + Mt, "px) ").concat(makeMatrixCSS(H))
        }
      }));
    }
    if (M) {
      var Bt = getRect(__spreadArray([W, q, Z, K], ut, !0)), Ot = Bt.width, Et = Bt.height, Ht = Bt.left, It = Bt.top;
      if (vt || pt || mt) {
        var ft = mt ? ut.slice(0, 8) : ut;
        dt.push(t.createElement("div", {
          key: "clipArea",
          className: prefix("clip-area", "snap-control"),
          style: {
            width: "".concat(Ot, "px"),
            height: "".concat(Et, "px"),
            transform: "translate(".concat(Ht, "px, ").concat(It, "px)"),
            clipPath: "polygon(".concat(ft.map(function(Nt) {
              return "".concat(Nt[0] - Ht, "px ").concat(Nt[1] - It, "px");
            }).join(", "), ")")
          }
        }));
      }
    }
    return Q && ["vertical", "horizontal"].forEach(function(St) {
      var Nt = Q[St], $t = St === "horizontal";
      Nt.isSnap && ct.push.apply(ct, Nt.snap.posInfos.map(function(Rt, Jt) {
        var Kt = Rt.pos, ae = minus(calculatePosition(H, $t ? [0, Kt] : [Kt, 0], st), [X, Y]), Se = minus(calculatePosition(H, $t ? [$, Kt] : [Kt, U], st), [X, Y]);
        return renderLine(t, "", ae, Se, D, "clip".concat(St, "snap").concat(Jt), "guideline");
      })), Nt.isBound && ct.push.apply(ct, Nt.bounds.map(function(Rt, Jt) {
        var Kt = Rt.pos, ae = minus(calculatePosition(H, $t ? [0, Kt] : [Kt, 0], st), [X, Y]), Se = minus(calculatePosition(H, $t ? [$, Kt] : [Kt, U], st), [X, Y]);
        return renderLine(t, "", ae, Se, D, "clip".concat(St, "bounds").concat(Jt), "guideline", "bounds", "bold");
      }));
    }), __spreadArray(__spreadArray([], dt, !0), ct, !0);
  },
  dragControlCondition: function(o, t) {
    return t.inputEvent && (t.inputEvent.target.getAttribute("class") || "").indexOf("clip") > -1;
  },
  dragStart: function(o, t) {
    var e = o.props, R = e.dragWithClip, N = R === void 0 ? !0 : R;
    return N ? !1 : this.dragControlStart(o, t);
  },
  drag: function(o, t) {
    return this.dragControl(o, __assign$2(__assign$2({}, t), {
      isDragTarget: !0
    }));
  },
  dragEnd: function(o, t) {
    return this.dragControlEnd(o, t);
  },
  dragControlStart: function(o, t) {
    var e = o.state, R = o.props, N = R.defaultClipPath, M = R.customClipPath, D = e.target, L = e.width, B = e.height, $ = t.inputEvent ? t.inputEvent.target : null, U = $ && $.getAttribute("class") || "", H = t.datas, z = getClipPath(D, L, B, N || "inset", M);
    if (!z)
      return !1;
    var X = z.clipText, Y = z.type, W = z.poses, q = triggerEvent(o, "onClipStart", fillParams(o, t, {
      clipType: Y,
      clipStyle: X,
      poses: W.map(function(Z) {
        return Z.pos;
      })
    }));
    return q === !1 ? (H.isClipStart = !1, !1) : (H.isControl = U && U.indexOf("clip-control") > -1, H.isLine = U.indexOf("clip-line") > -1, H.isArea = U.indexOf("clip-area") > -1 || U.indexOf("clip-ellipse") > -1, H.clipIndex = $ ? parseInt($.getAttribute("data-clip-index"), 10) : -1, H.clipPath = z, H.isClipStart = !0, e.clipPathState = X, setDragStart(o, t), !0);
  },
  dragControl: function(o, t) {
    var e, R = t.datas, N = t.originalDatas, M = t.isDragTarget;
    if (!R.isClipStart)
      return !1;
    var D = R, L = D.isControl, B = D.isLine, $ = D.isArea, U = D.clipIndex, H = D.clipPath;
    if (!H)
      return !1;
    var z = getProps(o.props, "clippable"), X = z.keepRatio, Y = 0, W = 0, q = N.draggable, Z = getDragDist(t);
    M && q ? (e = q.prevBeforeDist, Y = e[0], W = e[1]) : (Y = Z[0], W = Z[1]);
    var K = [Y, W], J = o.state, Q = J.width, et = J.height, tt = !$ && !L && !B, st = H.type, rt = H.poses, at = H.splitter, ut = rt.map(function(lt) {
      return lt.pos;
    });
    tt && (Y = -Y, W = -W);
    var dt = !L || rt[U].direction === "nesw", ct = st === "inset" || st === "rect", pt = rt.map(function() {
      return [0, 0];
    });
    if (L && !dt) {
      var mt = rt[U], vt = mt.horizontal, _t = mt.vertical, xt = [Y * Math.abs(vt), W * Math.abs(_t)];
      pt = moveControlPos(rt, U, xt, ct, X);
    } else
      dt && (pt = ut.map(function() {
        return [Y, W];
      }));
    var At = ut.map(function(lt, gt) {
      return plus(lt, pt[gt]);
    }), yt = __spreadArray([], At, !0);
    J.snapBoundInfos = null;
    var ht = H.type === "circle", bt = H.type === "ellipse";
    if (ht || bt) {
      var Ct = getRect(At), Mt = Math.abs(Ct.bottom - Ct.top), wt = Math.abs(bt ? Ct.right - Ct.left : Mt), Lt = At[0][1] + Mt, ft = At[0][0] - wt, Gt = At[0][0] + wt;
      ht && (yt.push([Gt, Ct.bottom]), pt.push([1, 0])), yt.push([Ct.left, Lt]), pt.push([0, 1]), yt.push([ft, Ct.bottom]), pt.push([1, 0]);
    }
    var Dt = getDefaultGuidelines((z.clipHorizontalGuidelines || []).map(function(lt) {
      return convertUnitSize("".concat(lt), et);
    }), (z.clipVerticalGuidelines || []).map(function(lt) {
      return convertUnitSize("".concat(lt), Q);
    }), Q, et), Bt = [], Ot = [];
    if (ht || bt)
      Bt = [yt[4][0], yt[2][0]], Ot = [yt[1][1], yt[3][1]];
    else if (ct) {
      var Et = [yt[0], yt[2], yt[4], yt[6]], Ht = [pt[0], pt[2], pt[4], pt[6]];
      Bt = Et.filter(function(lt, gt) {
        return Ht[gt][0];
      }).map(function(lt) {
        return lt[0];
      }), Ot = Et.filter(function(lt, gt) {
        return Ht[gt][1];
      }).map(function(lt) {
        return lt[1];
      });
    } else
      Bt = yt.filter(function(lt, gt) {
        return pt[gt][0];
      }).map(function(lt) {
        return lt[0];
      }), Ot = yt.filter(function(lt, gt) {
        return pt[gt][1];
      }).map(function(lt) {
        return lt[1];
      });
    var It = [0, 0], St = checkSnapBounds(Dt, z.clipTargetBounds && {
      left: 0,
      top: 0,
      right: Q,
      bottom: et
    }, Bt, Ot, 5), Nt = St.horizontal, $t = St.vertical, Rt = Nt.offset, Jt = $t.offset;
    if (Nt.isBound && (It[1] += Rt), $t.isBound && (It[0] += Jt), (bt || ht) && pt[0][0] === 0 && pt[0][1] === 0) {
      var Ct = getRect(At), Kt = Ct.bottom - Ct.top, ae = bt ? Ct.right - Ct.left : Kt, Se = $t.isBound ? Math.abs(Jt) : $t.snapIndex === 0 ? -Jt : Jt, De = Nt.isBound ? Math.abs(Rt) : Nt.snapIndex === 0 ? -Rt : Rt;
      ae -= Se, Kt -= De, ht && (Kt = checkSnapBoundPriority($t, Nt) > 0 ? Kt : ae, ae = Kt);
      var ee = yt[0];
      yt[1][1] = ee[1] - Kt, yt[2][0] = ee[0] + ae, yt[3][1] = ee[1] + Kt, yt[4][0] = ee[0] - ae;
    } else if (ct && X && L) {
      var Re = getControlSize(rt), ve = Re[0], he = Re[1], oe = ve && he ? ve / he : 0, te = rt[U], Oe = te.direction || "", pa = yt[1][1], Lt = yt[5][1], ft = yt[7][0], Gt = yt[3][0];
      Rt <= Jt ? Rt = Jt / oe : Jt = Rt * oe, Oe.indexOf("w") > -1 ? ft -= Jt : Oe.indexOf("e") > -1 ? Gt -= Jt : (ft += Jt / 2, Gt -= Jt / 2), Oe.indexOf("n") > -1 ? pa -= Rt : Oe.indexOf("s") > -1 ? Lt -= Rt : (pa += Rt / 2, Lt -= Rt / 2);
      var sh = getRectPoses(pa, Gt, Lt, ft);
      yt.forEach(function(Pt, Ft) {
        var kt;
        kt = sh[Ft].pos, Pt[0] = kt[0], Pt[1] = kt[1];
      });
    } else
      yt.forEach(function(lt, gt) {
        var Tt = pt[gt];
        Tt[0] && (lt[0] -= Jt), Tt[1] && (lt[1] -= Rt);
      });
    var zo = getClipStyles(o, H, At), va = "".concat(st, "(").concat(zo.join(at), ")");
    if (J.clipPathState = va, ht || bt)
      Bt = [yt[4][0], yt[2][0]], Ot = [yt[1][1], yt[3][1]];
    else if (ct) {
      var Et = [yt[0], yt[2], yt[4], yt[6]];
      Bt = Et.map(function(gt) {
        return gt[0];
      }), Ot = Et.map(function(gt) {
        return gt[1];
      });
    } else
      Bt = yt.map(function(lt) {
        return lt[0];
      }), Ot = yt.map(function(lt) {
        return lt[1];
      });
    if (J.snapBoundInfos = checkSnapBounds(Dt, z.clipTargetBounds && {
      left: 0,
      top: 0,
      right: Q,
      bottom: et
    }, Bt, Ot, 1), q) {
      var jo = J.is3d, Vo = J.allMatrix, Xo = jo ? 4 : 3, ga = It;
      M && (ga = [K[0] + It[0] - Z[0], K[1] + It[1] - Z[1]]), q.deltaOffset = multiply(Vo, [ga[0], ga[1], 0, 0], Xo);
    }
    return triggerEvent(o, "onClip", fillParams(o, t, {
      clipEventType: "changed",
      clipType: st,
      poses: At,
      clipStyle: va,
      clipStyles: zo,
      distX: Y,
      distY: W
    })), !0;
  },
  dragControlEnd: function(o, t) {
    this.unset(o);
    var e = t.isDrag, R = t.datas, N = t.isDouble, M = R.isLine, D = R.isClipStart, L = R.isControl;
    return D ? (triggerEvent(o, "onClipEnd", fillEndParams(o, t, {})), N && (L ? removeClipPath(o, t) : M && addClipPath(o, t)), N || e) : !1;
  },
  unset: function(o) {
    o.state.clipPathState = "", o.state.snapBoundInfos = null;
  }
}, OriginDraggable = {
  name: "originDraggable",
  props: {
    originDraggable: Boolean,
    originRelative: Boolean
  },
  events: {
    onDragOriginStart: "dragOriginStart",
    onDragOrigin: "dragOrigin",
    onDragOriginEnd: "dragOriginEnd"
  },
  css: [`:host[data-able-origindraggable] .control.origin {
    pointer-events: auto;
}`],
  dragControlCondition: function(o, t) {
    return t.isRequest ? t.requestAble === "originDraggable" : hasClass(t.inputEvent.target, prefix("origin"));
  },
  dragControlStart: function(o, t) {
    var e = t.datas;
    setDragStart(o, t);
    var R = fillParams(o, t, {
      dragStart: Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))
    }), N = triggerEvent(o, "onDragOriginStart", R);
    return e.startOrigin = o.state.transformOrigin, e.startTargetOrigin = o.state.targetOrigin, e.prevOrigin = [0, 0], e.isDragOrigin = !0, N === !1 ? (e.isDragOrigin = !1, !1) : R;
  },
  dragControl: function(o, t) {
    var e = t.datas, R = t.isPinch, N = t.isRequest;
    if (!e.isDragOrigin)
      return !1;
    var M = getDragDist(t), D = M[0], L = M[1], B = o.state, $ = B.width, U = B.height, H = B.offsetMatrix, z = B.targetMatrix, X = B.is3d, Y = o.props.originRelative, W = Y === void 0 ? !0 : Y, q = X ? 4 : 3, Z = [D, L];
    if (N) {
      var K = t.distOrigin;
      (K[0] || K[1]) && (Z = K);
    }
    var J = plus(e.startOrigin, Z), Q = plus(e.startTargetOrigin, Z), et = minus(Z, e.prevOrigin), tt = getNextMatrix(H, z, J, q), st = o.getRect(), rt = getRect(calculatePoses(tt, $, U, q)), at = [st.left - rt.left, st.top - rt.top];
    e.prevOrigin = Z;
    var ut = [convertCSSSize(Q[0], $, W), convertCSSSize(Q[1], U, W)].join(" "), dt = fillParams(o, t, {
      width: $,
      height: U,
      origin: J,
      dist: Z,
      delta: et,
      transformOrigin: ut,
      drag: Draggable.drag(o, setCustomDrag(t, o.state, at, !!R, !1))
    });
    return triggerEvent(o, "onDragOrigin", dt), dt;
  },
  dragControlEnd: function(o, t) {
    var e = t.datas;
    return e.isDragOrigin ? (triggerEvent(o, "onDragOriginEnd", fillEndParams(o, t, {})), !0) : !1;
  },
  dragGroupControlCondition: function(o, t) {
    return this.dragControlCondition(o, t);
  },
  dragGroupControlStart: function(o, t) {
    var e = this.dragControlStart(o, t);
    return !!e;
  },
  dragGroupControl: function(o, t) {
    var e = this.dragControl(o, t);
    return e ? (o.transformOrigin = e.transformOrigin, !0) : !1;
  },
  request: function(o) {
    var t = {}, e = o.getRect(), R = 0, N = 0, M = e.transformOrigin, D = [0, 0];
    return {
      isControl: !0,
      requestStart: function() {
        return {
          datas: t
        };
      },
      request: function(L) {
        return "deltaOrigin" in L ? (D[0] += L.deltaOrigin[0], D[1] += L.deltaOrigin[1]) : "origin" in L ? (D[0] = L.origin[0] - M[0], D[1] = L.origin[1] - M[1]) : ("x" in L ? R = L.x - e.left : "deltaX" in L && (R += L.deltaX), "y" in L ? N = L.y - e.top : "deltaY" in L && (N += L.deltaY)), {
          datas: t,
          distX: R,
          distY: N,
          distOrigin: D
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  }
};
function addBorderRadius(o, t, e, R, N, M, D) {
  var L = splitRadiusPoses(o), B = L.horizontals, $ = L.verticals, U = B.length, H = $.length, z = -1, X = -1;
  e === 0 ? U === 0 ? z = 0 : U === 1 && (z = 1) : e === 3 && (U <= 2 ? z = 2 : U <= 3 && (z = 3)), e === 2 ? H === 0 ? X = 0 : H < 4 && (X = 3) : e === 1 && (H <= 1 ? X = 1 : H <= 2 && (X = 2)), addRadiusPos(o, t, 0, z, X, R, N, M, D);
}
function getBorderRadius(o, t, e, R, N) {
  R === void 0 && (R = [0, 0]);
  var M, D = [];
  if (N)
    M = N;
  else {
    var L = getComputedStyle$1$1(o);
    M = L && L.borderRadius || "";
  }
  return !M || !N && M === "0px" ? D = [] : D = splitSpace(M), getRadiusValues(D, t, e, 0, 0, R);
}
function triggerRoundEvent(o, t, e, R, N, M) {
  var D = o.state, L = D.width, B = D.height, $ = getRadiusStyles(M, N, o.props.roundRelative, L, B), U = $.raws, H = $.styles, z = splitRadiusPoses(N, U), X = z.horizontals, Y = z.verticals, W = H.join(" ");
  D.borderRadiusState = W, triggerEvent(o, "onRound", fillParams(o, t, {
    horizontals: X,
    verticals: Y,
    borderRadius: W,
    width: L,
    height: B,
    delta: R,
    dist: e
  }));
}
var Roundable = {
  name: "roundable",
  props: {
    roundable: Boolean,
    roundRelative: Boolean,
    minRoundControls: Array,
    maxRoundControls: Array,
    roundClickable: Boolean
  },
  events: {
    onRoundStart: "roundStart",
    onRound: "round",
    onRoundEnd: "roundEnd"
  },
  css: [`.control.border-radius {
    background: #d66;
    cursor: pointer;
}`, `:host[data-able-roundable] .line.direction {
    cursor: pointer;
}`],
  render: function(o, t) {
    var e = o.state, R = e.target, N = e.width, M = e.height, D = e.allMatrix, L = e.is3d, B = e.left, $ = e.top, U = e.borderRadiusState, H = o.props, z = H.minRoundControls, X = z === void 0 ? [0, 0] : z, Y = H.maxRoundControls, W = Y === void 0 ? [4, 4] : Y, q = H.zoom;
    if (!R)
      return null;
    var Z = L ? 4 : 3, K = getBorderRadius(R, N, M, X, U);
    if (!K)
      return null;
    var J = 0, Q = 0;
    return K.map(function(et, tt) {
      Q += Math.abs(et.horizontal), J += Math.abs(et.vertical);
      var st = minus(calculatePosition(D, et.pos, Z), [B, $]), rt = et.vertical ? J <= W[1] : Q <= W[0];
      return t.createElement("div", {
        key: "borderRadiusControl".concat(tt),
        className: prefix("control", "border-radius"),
        "data-radius-index": tt,
        style: {
          display: rt ? "block" : "none",
          transform: "translate(".concat(st[0], "px, ").concat(st[1], "px) scale(").concat(q, ")")
        }
      });
    });
  },
  dragControlCondition: function(o, t) {
    if (!t.inputEvent || t.isRequest)
      return !1;
    var e = t.inputEvent.target.getAttribute("class") || "";
    return e.indexOf("border-radius") > -1 || e.indexOf("moveable-line") > -1 && e.indexOf("moveable-direction") > -1;
  },
  dragControlStart: function(o, t) {
    var e = t.inputEvent, R = t.datas, N = e.target, M = N.getAttribute("class") || "", D = M.indexOf("border-radius") > -1, L = M.indexOf("moveable-line") > -1 && M.indexOf("moveable-direction") > -1, B = D ? parseInt(N.getAttribute("data-radius-index"), 10) : -1, $ = L ? parseInt(N.getAttribute("data-line-index"), 10) : -1;
    if (!D && !L)
      return !1;
    var U = triggerEvent(o, "onRoundStart", fillParams(o, t, {}));
    if (U === !1)
      return !1;
    R.lineIndex = $, R.controlIndex = B, R.isControl = D, R.isLine = L, setDragStart(o, t);
    var H = o.props, z = H.roundRelative, X = H.minRoundControls, Y = X === void 0 ? [0, 0] : X, W = o.state, q = W.target, Z = W.width, K = W.height;
    R.isRound = !0, R.prevDist = [0, 0];
    var J = getBorderRadius(q, Z, K, Y) || [];
    return R.controlPoses = J, W.borderRadiusState = getRadiusStyles(J.map(function(Q) {
      return Q.pos;
    }), J, z, Z, K).styles.join(" "), !0;
  },
  dragControl: function(o, t) {
    var e = t.datas;
    if (!e.isRound || !e.isControl || !e.controlPoses.length)
      return !1;
    var R = e.controlIndex, N = e.controlPoses, M = getDragDist(t), D = M[0], L = M[1], B = [D, L], $ = minus(B, e.prevDist), U = o.props.maxRoundControls, H = U === void 0 ? [4, 4] : U, z = o.state, X = z.width, Y = z.height, W = N[R], q = W.vertical, Z = W.horizontal, K = N.map(function(Q) {
      var et = Q.horizontal, tt = Q.vertical, st = [et * Z * B[0], tt * q * B[1]];
      if (et) {
        if (H[0] === 1)
          return st;
        if (H[0] < 4 && et !== Z)
          return st;
      } else {
        if (H[1] === 0)
          return st[1] = tt * Z * B[0] / X * Y, st;
        if (q) {
          if (H[1] === 1)
            return st;
          if (H[1] < 4 && tt !== q)
            return st;
        }
      }
      return [0, 0];
    });
    K[R] = B;
    var J = N.map(function(Q, et) {
      return plus(Q.pos, K[et]);
    });
    return e.prevDist = [D, L], triggerRoundEvent(o, t, B, $, N, J), !0;
  },
  dragControlEnd: function(o, t) {
    var e = o.state;
    e.borderRadiusState = "";
    var R = t.datas, N = t.isDouble;
    if (!R.isRound)
      return !1;
    var M = e.width, D = e.height, L = R.isControl, B = R.controlIndex, $ = R.isLine, U = R.lineIndex, H = R.controlPoses, z = H.map(function(J) {
      return J.pos;
    }), X = z.length, Y = o.props.roundClickable, W = Y === void 0 ? !0 : Y;
    if (N && W) {
      if (L)
        removeRadiusPos(H, z, B, 0);
      else if ($) {
        var q = calculatePointerDist(o, t), Z = q[0], K = q[1];
        addBorderRadius(H, z, U, Z, K, M, D);
      }
      X !== H.length && triggerRoundEvent(o, t, [0, 0], [0, 0], H, z);
    }
    return triggerEvent(o, "onRoundEnd", fillEndParams(o, t, {})), e.borderRadiusState = "", !0;
  },
  unset: function(o) {
    o.state.borderRadiusState = "";
  }
};
function isIdentityMatrix(o, t) {
  var e = t ? 4 : 3, R = createIdentityMatrix(e), N = "matrix".concat(t ? "3d" : "", "(").concat(R.join(","), ")");
  return o === N || o === "matrix(1,0,0,1,0,0)";
}
var BeforeRenderable = {
  isPinch: !0,
  name: "beforeRenderable",
  props: {},
  events: {
    onBeforeRenderStart: "beforeRenderStart",
    onBeforeRender: "beforeRender",
    onBeforeRenderEnd: "beforeRenderEnd",
    onBeforeRenderGroupStart: "beforeRenderGroupStart",
    onBeforeRenderGroup: "beforeRenderGroup",
    onBeforeRenderGroupEnd: "beforeRenderGroupEnd"
  },
  dragRelation: "weak",
  setTransform: function(o, t) {
    var e = o.state, R = e.is3d, N = e.target, M = e.targetMatrix, D = N == null ? void 0 : N.style.transform, L = R ? "matrix3d(".concat(M.join(","), ")") : "matrix(".concat(convertMatrixtoCSS(M, !0), ")"), B = !D || D === "none" ? L : D;
    t.datas.startTransforms = isIdentityMatrix(B, R) ? [] : splitSpace(B);
  },
  resetStyle: function(o) {
    var t = o.datas;
    t.nextStyle = {}, t.nextTransforms = o.datas.startTransforms, t.nextTransformAppendedIndexes = [];
  },
  fillDragStartParams: function(o, t) {
    return fillParams(o, t, {
      setTransform: function(e) {
        t.datas.startTransforms = isArray(e) ? e : splitSpace(e);
      },
      isPinch: !!t.isPinch
    });
  },
  fillDragParams: function(o, t) {
    return fillParams(o, t, {
      isPinch: !!t.isPinch
    });
  },
  dragStart: function(o, t) {
    this.setTransform(o, t), triggerEvent(o, "onBeforeRenderStart", this.fillDragStartParams(o, t));
  },
  drag: function(o, t) {
    this.resetStyle(t);
    var e = t.datas;
    e.nextStyle = {}, triggerEvent(o, "onBeforeRender", fillParams(o, t, {
      isPinch: !!t.isPinch
    }));
  },
  dragEnd: function(o, t) {
    triggerEvent(o, "onBeforeRenderEnd", fillParams(o, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag
    }));
  },
  dragGroupStart: function(o, t) {
    var e = this;
    this.dragStart(o, t);
    var R = fillChildEvents(o, "beforeRenderable", t), N = o.moveables, M = R.map(function(D, L) {
      var B = N[L];
      return e.setTransform(B, D), e.fillDragStartParams(B, D);
    });
    triggerEvent(o, "onBeforeRenderGroupStart", fillParams(o, t, {
      isPinch: !!t.isPinch,
      targets: o.props.targets,
      setTransform: function() {
      },
      events: M
    }));
  },
  dragGroup: function(o, t) {
    var e = this;
    this.drag(o, t);
    var R = fillChildEvents(o, "beforeRenderable", t), N = o.moveables, M = R.map(function(D, L) {
      var B = N[L];
      e.resetStyle(D);
      var $ = t.datas;
      return $.nextStyle = {}, e.fillDragParams(B, D);
    });
    triggerEvent(o, "onBeforeRenderGroup", fillParams(o, t, {
      isPinch: !!t.isPinch,
      targets: o.props.targets,
      events: M
    }));
  },
  dragGroupEnd: function(o, t) {
    this.dragEnd(o, t), triggerEvent(o, "onBeforeRenderGroupEnd", fillParams(o, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      targets: o.props.targets
    }));
  },
  dragControlStart: function(o, t) {
    return this.dragStart(o, t);
  },
  dragControl: function(o, t) {
    return this.drag(o, t);
  },
  dragControlEnd: function(o, t) {
    return this.dragEnd(o, t);
  },
  dragGroupControlStart: function(o, t) {
    return this.dragGroupStart(o, t);
  },
  dragGroupControl: function(o, t) {
    return this.dragGroup(o, t);
  },
  dragGroupControlEnd: function(o, t) {
    return this.dragGroupEnd(o, t);
  }
}, Renderable = {
  name: "renderable",
  props: {},
  events: {
    onRenderStart: "renderStart",
    onRender: "render",
    onRenderEnd: "renderEnd",
    onRenderGroupStart: "renderGroupStart",
    onRenderGroup: "renderGroup",
    onRenderGroupEnd: "renderGroupEnd"
  },
  dragRelation: "weak",
  dragStart: function(o, t) {
    triggerEvent(o, "onRenderStart", fillParams(o, t, {
      isPinch: !!t.isPinch
    }));
  },
  drag: function(o, t) {
    triggerEvent(o, "onRender", this.fillDragParams(o, t));
  },
  dragAfter: function(o, t) {
    if (t.resultCount)
      return this.drag(o, t);
  },
  dragEnd: function(o, t) {
    triggerEvent(o, "onRenderEnd", this.fillDragEndParams(o, t));
  },
  dragGroupStart: function(o, t) {
    triggerEvent(o, "onRenderGroupStart", fillParams(o, t, {
      isPinch: !!t.isPinch,
      targets: o.props.targets
    }));
  },
  dragGroup: function(o, t) {
    var e = this, R = fillChildEvents(o, "beforeRenderable", t), N = o.moveables, M = R.map(function(D, L) {
      var B = N[L];
      return e.fillDragParams(B, D);
    });
    triggerEvent(o, "onRenderGroup", fillParams(o, t, __assign$2(__assign$2({
      isPinch: !!t.isPinch,
      targets: o.props.targets,
      transform: getNextTransformText(t)
    }, fillCSSObject(getNextStyle(t))), {
      events: M
    })));
  },
  dragGroupEnd: function(o, t) {
    var e = this, R = fillChildEvents(o, "beforeRenderable", t), N = o.moveables, M = R.map(function(D, L) {
      var B = N[L];
      return e.fillDragEndParams(B, D);
    });
    triggerEvent(o, "onRenderGroupEnd", fillParams(o, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      targets: o.props.targets,
      events: M
    }));
  },
  dragControlStart: function(o, t) {
    return this.dragStart(o, t);
  },
  dragControl: function(o, t) {
    return this.drag(o, t);
  },
  dragControlAfter: function(o, t) {
    return this.dragAfter(o, t);
  },
  dragControlEnd: function(o, t) {
    return this.dragEnd(o, t);
  },
  dragGroupControlStart: function(o, t) {
    return this.dragGroupStart(o, t);
  },
  dragGroupControl: function(o, t) {
    return this.dragGroup(o, t);
  },
  dragGroupControlEnd: function(o, t) {
    return this.dragGroupEnd(o, t);
  },
  fillDragParams: function(o, t) {
    return fillParams(o, t, __assign$2({
      isPinch: !!t.isPinch,
      transform: getNextTransformText(t)
    }, fillCSSObject(getNextStyle(t))));
  },
  fillDragEndParams: function(o, t) {
    return fillParams(o, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag
    });
  }
};
function triggerAble(o, t, e, R, N, M, D) {
  var L = N === "Start", B = o.state.target, $ = M.isRequest;
  if (!B || L && R.indexOf("Control") > -1 && !$ && o.areaElement === M.inputEvent.target)
    return !1;
  var U = "".concat(e).concat(R).concat(N), H = "".concat(e).concat(R, "Condition"), z = N === "End", X = N === "After", Y = L && (!o.targetGesto || !o.controlGesto || !o.targetGesto.isFlag() || !o.controlGesto.isFlag());
  Y && o.updateRect(N, !0, !1), N === "" && !$ && convertDragDist(o.state, M);
  var W = __spreadArray([], o[t], !0);
  if ($) {
    var q = M.requestAble;
    W.some(function(ct) {
      return ct.name === q;
    }) || W.push.apply(W, o.props.ables.filter(function(ct) {
      return ct.name === q;
    }));
  }
  if (!W.length || W.every(function(ct) {
    return ct.dragRelation;
  }))
    return !1;
  var Z = __spreadArray(__spreadArray([BeforeRenderable], W, !0), [Renderable], !1).filter(function(ct) {
    return ct[U];
  }), K = M.datas;
  Y && Z.forEach(function(ct) {
    ct.unset && ct.unset(o);
  });
  var J = M.inputEvent, Q;
  z && J && (Q = document.elementFromPoint(M.clientX, M.clientY) || J.target);
  var et = 0, tt = !1, st = function() {
    var ct;
    tt = !0, (ct = M.stop) === null || ct === void 0 || ct.call(M);
  }, rt = Z.filter(function(ct) {
    var pt = ct.name, mt = K[pt] || (K[pt] = {});
    if (L && (mt.isEventStart = !ct[H] || ct[H](o, M)), mt.isEventStart) {
      var vt = ct[U](o, __assign$2(__assign$2({}, M), {
        stop: st,
        resultCount: et,
        datas: mt,
        originalDatas: K,
        inputTarget: Q
      }));
      return o._emitter.off(), L && vt === !1 && (mt.isEventStart = !1), et += vt ? 1 : 0, vt;
    }
    return !1;
  }), at = rt.length, ut = !1;
  if (L && (tt || Z.length && !at) && (ut = tt || Z.filter(function(ct) {
    var pt = ct.name, mt = K[pt];
    return mt.isEventStart ? ct.dragRelation !== "strong" : !1;
  }).length), (z || ut) && (o.state.gestos = {}, o.moveables && o.moveables.forEach(function(ct) {
    ct.state.gestos = {};
  })), Y && ut && Z.forEach(function(ct) {
    ct.unset && ct.unset(o);
  }), L && !ut && !$ && at && (M == null || M.preventDefault()), o.isUnmounted || ut)
    return !1;
  if (!L && at && !D || z) {
    var dt = o.props.flushSync || defaultSync;
    dt(function() {
      o.updateRect(z ? N : "", !0, !1), o.forceUpdate();
    });
  }
  return !L && !z && !X && at && !D && triggerAble(o, t, e, R, N + "After", M), !0;
}
function getTargetAbleGesto(o, t, e) {
  var R = o.controlBox.getElement(), N = [], M = o.props.dragTarget;
  N.push(R), (!o.props.dragArea || M) && N.push(t);
  var D = function(L) {
    var B = L.inputEvent.target, $ = o.areaElement;
    return M && (B === M || M.contains(B)) || B === $ || !o.isMoveableElement(B) && !o.controlBox.getElement().contains(B) || hasClass(B, "moveable-area") || hasClass(B, "moveable-padding");
  };
  return getAbleGesto(o, N, "targetAbles", e, {
    dragStart: D,
    pinchStart: D
  });
}
function getAbleGesto(o, t, e, R, N) {
  N === void 0 && (N = {});
  var M = e === "targetAbles", D = o.props, L = D.pinchOutside, B = D.pinchThreshold, $ = D.preventClickEventOnDrag, U = D.preventClickDefault, H = D.checkInput, z = {
    preventDefault: !0,
    preventRightClick: !0,
    preventWheelClick: !0,
    container: window,
    pinchThreshold: B,
    pinchOutside: L,
    preventClickEventOnDrag: M ? $ : !1,
    preventClickEventOnDragStart: M ? U : !1,
    preventClickEventByCondition: M ? null : function(W) {
      return o.controlBox.getElement().contains(W.target);
    },
    checkInput: M ? H : !1
  }, X = new Gesto$1(t, z), Y = R === "Control";
  return ["drag", "pinch"].forEach(function(W) {
    ["Start", "", "End"].forEach(function(q) {
      X.on("".concat(W).concat(q), function(Z) {
        var K, J = Z.eventType;
        if (N[J] && !N[J](Z)) {
          Z.stop();
          return;
        }
        var Q = triggerAble(o, e, W, R, q, Z);
        Q ? (o.props.stopPropagation || q === "Start" && Y) && ((K = Z == null ? void 0 : Z.inputEvent) === null || K === void 0 || K.stopPropagation()) : Z.stop();
      });
    });
  }), X;
}
var EventManager = /* @__PURE__ */ function() {
  function o(e, R, N) {
    var M = this;
    this.target = e, this.moveable = R, this.eventName = N, this.ables = [], this._onEvent = function(D) {
      var L = M.eventName, B = M.moveable;
      B.state.disableNativeEvent || M.ables.forEach(function($) {
        $[L](B, {
          inputEvent: D
        });
      });
    }, e.addEventListener(N.toLowerCase(), this._onEvent);
  }
  var t = o.prototype;
  return t.setAbles = function(e) {
    this.ables = e;
  }, t.destroy = function() {
    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent), this.target = null, this.moveable = null;
  }, o;
}();
function getShadowRoot(o) {
  if (o && o.getRootNode) {
    var t = o.getRootNode();
    if (t.nodeType === 11)
      return t;
  }
}
function getMatrixStackInfo(o, t, e) {
  for (var R = o, N = [], M = !e && o === t || o === document.body, D = M, L = !1, B = 3, $, U, H, z = !1, X = getOffsetInfo(t, t, !0).offsetParent; R && !D; ) {
    D = M;
    var Y = getComputedStyle(R), W = Y.position, q = getElementTransform(R, Y), Z = convertCSStoMatrix(getTransformMatrix(q)), K = W === "fixed", J = {
      hasTransform: !1,
      fixedContainer: null
    };
    K && (z = !0, J = getPositionFixedInfo(R), X = J.fixedContainer);
    var Q = Z.length;
    !L && Q === 16 && (L = !0, B = 4, convert3DMatrixes(N), H && (H = convertDimension(H, 3, 4))), L && Q === 9 && (Z = convertDimension(Z, 3, 4));
    var et = getOffsetPosInfo(R, o, Y), tt = et.tagName, st = et.hasOffset, rt = et.isSVG, at = et.origin, ut = et.targetOrigin, dt = et.offset, ct = dt[0], pt = dt[1];
    tt === "svg" && H && (N.push({
      type: "target",
      target: R,
      matrix: getSVGMatrix(R, B)
    }), N.push({
      type: "offset",
      target: R,
      matrix: createIdentityMatrix(B)
    }));
    var mt = void 0, vt = !1, _t = !1;
    if (K)
      mt = J.fixedContainer, vt = !0;
    else {
      var xt = getOffsetInfo(R, t);
      if (mt = xt.offsetParent, vt = xt.isEnd, _t = xt.isStatic, IS_FIREFOX) {
        var At = xt.parentSlotElement;
        if (At) {
          for (var yt = mt, ht = 0, bt = 0; yt && getShadowRoot(yt); )
            ht += yt.offsetLeft, bt += yt.offsetTop, yt = yt.offsetParent;
          ct -= ht, pt -= bt;
        }
      }
    }
    IS_WEBKIT && !IS_SAFARI_ABOVE15 && st && !rt && _t && (W === "relative" || W === "static") && (ct -= mt.offsetLeft, pt -= mt.offsetTop, M = M || vt);
    var Ct = 0, Mt = 0, wt = 0, Lt = 0;
    if (K)
      st && J.hasTransform && (wt = mt.clientLeft, Lt = mt.clientTop);
    else if (st && X !== mt && (Ct = mt.clientLeft, Mt = mt.clientTop), st && mt === document.body) {
      var ft = getBodyOffset(R, !1, Y);
      ct += ft[0], pt += ft[1];
    }
    if (N.push({
      type: "target",
      target: R,
      matrix: getAbsoluteMatrix(Z, B, at)
    }), st) {
      var Gt = R === o, Dt = Gt ? 0 : R.scrollLeft, Bt = Gt ? 0 : R.scrollTop;
      N.push({
        type: "offset",
        target: R,
        matrix: createOriginMatrix([ct - Dt + Ct - wt, pt - Bt + Mt - Lt], B)
      });
    } else
      N.push({
        type: "offset",
        target: R,
        origin: at
      });
    if (H || (H = Z), $ || ($ = at), U || (U = ut), D || K)
      break;
    R = mt, M = vt, (!e || R === document.body) && (D = M);
  }
  return H || (H = createIdentityMatrix(B)), $ || ($ = [0, 0]), U || (U = [0, 0]), {
    offsetContainer: X,
    matrixes: N,
    targetMatrix: H,
    transformOrigin: $,
    targetOrigin: U,
    is3d: L,
    hasFixed: z
  };
}
function calculateMatrixStack(o, t, e, R) {
  var N;
  e === void 0 && (e = t);
  var M = getMatrixStackInfo(o, t), D = M.matrixes, L = M.is3d, B = M.targetMatrix, $ = M.transformOrigin, U = M.targetOrigin, H = M.offsetContainer, z = M.hasFixed, X = getMatrixStackInfo(H, e, !0), Y = X.matrixes, W = X.is3d, q = X.offsetContainer, Z = R || W || L, K = Z ? 4 : 3, J = o.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in o, Q = B, et = createIdentityMatrix(K), tt = createIdentityMatrix(K), st = createIdentityMatrix(K), rt = createIdentityMatrix(K), at = D.length;
  Y.reverse(), D.reverse(), !L && Z && (Q = convertDimension(Q, 3, 4), convert3DMatrixes(D)), !W && Z && convert3DMatrixes(Y), Y.forEach(function(vt) {
    tt = multiply(tt, vt.matrix, K);
  });
  var ut = e || document.body, dt = ((N = Y[0]) === null || N === void 0 ? void 0 : N.target) || getOffsetInfo(ut, ut, !0).offsetParent, ct = Y.slice(1).reduce(function(vt, _t) {
    return multiply(vt, _t.matrix, K);
  }, createIdentityMatrix(K));
  D.forEach(function(vt, _t) {
    if (at - 2 === _t && (st = et.slice()), at - 1 === _t && (rt = et.slice()), !vt.matrix) {
      var xt = D[_t + 1], At = getSVGOffset(vt, xt, dt, K, multiply(ct, et, K));
      vt.matrix = createOriginMatrix(At, K);
    }
    et = multiply(et, vt.matrix, K);
  });
  var pt = !J && L;
  Q || (Q = createIdentityMatrix(pt ? 4 : 3));
  var mt = makeMatrixCSS(J && Q.length === 16 ? convertDimension(Q, 4, 3) : Q, pt);
  return tt = ignoreDimension(tt, K, K), {
    hasFixed: z,
    rootMatrix: tt,
    beforeMatrix: st,
    offsetMatrix: rt,
    allMatrix: et,
    targetMatrix: Q,
    targetTransform: mt,
    transformOrigin: $,
    targetOrigin: U,
    is3d: Z,
    offsetContainer: H,
    offsetRootContainer: q
  };
}
function calculateElementInfo(o, t, e, R) {
  e === void 0 && (e = t);
  var N = 0, M = 0, D = 0, L = {}, B = getSize(o);
  if (o && (N = B.offsetWidth, M = B.offsetHeight), o) {
    var $ = calculateMatrixStack(o, t, e, R), U = calculateMoveablePosition($.allMatrix, $.transformOrigin, N, M);
    L = __assign$2(__assign$2({}, $), U);
    var H = calculateMoveablePosition($.allMatrix, [50, 50], 100, 100);
    D = getRotationRad([H.pos1, H.pos2], H.direction);
  }
  var z = R ? 4 : 3;
  return __assign$2(__assign$2(__assign$2({
    width: N,
    height: M,
    rotation: D
  }, B), {
    rootMatrix: createIdentityMatrix(z),
    beforeMatrix: createIdentityMatrix(z),
    offsetMatrix: createIdentityMatrix(z),
    allMatrix: createIdentityMatrix(z),
    targetMatrix: createIdentityMatrix(z),
    targetTransform: "",
    transformOrigin: [0, 0],
    targetOrigin: [0, 0],
    is3d: !!R,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    origin: [0, 0],
    pos1: [0, 0],
    pos2: [0, 0],
    pos3: [0, 0],
    pos4: [0, 0],
    direction: 1,
    hasFixed: !1,
    offsetContainer: null,
    offsetRootContainer: null
  }), L);
}
function getMoveableTargetInfo(o, t, e, R, N) {
  var M = 1, D = [0, 0], L = resetClientRect(), B = resetClientRect(), $ = resetClientRect(), U = resetClientRect(), H = calculateElementInfo(t, e, N, !0);
  if (t) {
    var z = H.is3d ? 4 : 3, X = calculateMoveablePosition(H.offsetMatrix, plus(H.transformOrigin, getOrigin(H.targetMatrix, z)), H.width, H.height);
    M = X.direction, D = plus(X.origin, [X.left - H.left, X.top - H.top]), L = getClientRect(t);
    var Y = getOffsetInfo(R, R, !0).offsetParent || H.offsetRootContainer;
    $ = getClientRect(Y, !0), U = getClientRect(H.offsetRootContainer), o && (B = getClientRect(o));
  }
  return __assign$2({
    targetClientRect: L,
    containerClientRect: $,
    moveableClientRect: B,
    rootContainerClientRect: U,
    beforeDirection: M,
    beforeOrigin: D,
    originalBeforeOrigin: D,
    target: t
  }, H);
}
var MoveableManager$1 = /* @__PURE__ */ function(o) {
  __extends$1(t, o);
  function t() {
    var R = o !== null && o.apply(this, arguments) || this;
    return R.state = __assign$2({
      container: null,
      gestos: {},
      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],
      disableNativeEvent: !1
    }, getMoveableTargetInfo(null)), R.renderState = {}, R.enabledAbles = [], R.targetAbles = [], R.controlAbles = [], R.rotation = 0, R.scale = [1, 1], R.isUnmounted = !1, R.events = {
      mouseEnter: null,
      mouseLeave: null
    }, R._emitter = new EventEmitter$3(), R._prevTarget = null, R._prevDragArea = !1, R._isPropTargetChanged = !1, R._observer = null, R._observerId = 0, R.checkUpdateRect = function() {
      if (!R.isDragging()) {
        var N = R.props.parentMoveable;
        if (N) {
          N.checkUpdateRect();
          return;
        }
        cancelAnimationFrame$1(R._observerId), R._observerId = requestAnimationFrame$1(function() {
          R.isDragging() || R.updateRect();
        });
      }
    }, R._onPreventClick = function(N) {
      N.stopPropagation(), N.preventDefault();
    }, R;
  }
  var e = t.prototype;
  return e.render = function() {
    var R = this.props, N = this.state, M = R.parentPosition, D = R.className, L = R.target, B = R.zoom, $ = R.cspNonce, U = R.translateZ, H = R.cssStyled, z = R.portalContainer;
    this.checkUpdate(), this.updateRenderPoses();
    var X = M || [0, 0], Y = X[0], W = X[1], q = N.left, Z = N.top, K = N.target, J = N.direction, Q = N.hasFixed, et = R.targets, tt = (et && et.length || L) && K, st = this.isDragging(), rt = {};
    return this.getEnabledAbles().forEach(function(at) {
      rt["data-able-".concat(at.name.toLowerCase())] = !0;
    }), createElement(H, __assign$2({
      cspNonce: $,
      ref: ref(this, "controlBox"),
      className: "".concat(prefix("control-box", J === -1 ? "reverse" : "", st ? "dragging" : ""), " ").concat(D)
    }, rt, {
      onClick: this._onPreventClick,
      portalContainer: z,
      style: {
        position: Q ? "fixed" : "absolute",
        display: tt ? "block" : "none",
        transform: "translate3d(".concat(q - Y, "px, ").concat(Z - W, "px, ").concat(U, ")"),
        "--zoom": B,
        "--zoompx": "".concat(B, "px")
      }
    }), this.renderAbles(), this._renderLines());
  }, e.componentDidMount = function() {
    this.isUnmounted = !1, this.controlBox.getElement();
    var R = this.props, N = R.parentMoveable, M = R.container, D = R.wrapperMoveable;
    this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), !M && !N && !D && this.updateRect("", !1, !0), this.updateCheckInput(), this._updateObserver(this.props);
  }, e.componentDidUpdate = function(R) {
    this._updateNativeEvents(), this._updateEvents(), this._updateTargets(), this.updateCheckInput(), this._updateObserver(R);
  }, e.componentWillUnmount = function() {
    this.isUnmounted = !0, this._emitter.off(), unset(this, "targetGesto"), unset(this, "controlGesto");
    var R = this.events;
    for (var N in R) {
      var M = R[N];
      M && M.destroy();
    }
  }, e.getAble = function(R) {
    var N = this.props.ables || [];
    return find$1(N, function(M) {
      return M.name === R;
    });
  }, e.getContainer = function() {
    var R = this.props, N = R.parentMoveable, M = R.wrapperMoveable, D = R.container;
    return D || M && M.getContainer() || N && N.getContainer() || this.controlBox.getElement().parentElement;
  }, e.isMoveableElement = function(R) {
    var N;
    return R && (((N = R.getAttribute) === null || N === void 0 ? void 0 : N.call(R, "class")) || "").indexOf(PREFIX) > -1;
  }, e.dragStart = function(R) {
    var N = this.targetGesto;
    return N && !N.isFlag() && N.triggerDragStart(R), this;
  }, e.hitTest = function(R) {
    var N = this.state, M = N.target, D = N.pos1, L = N.pos2, B = N.pos3, $ = N.pos4, U = N.targetClientRect;
    if (!M)
      return 0;
    var H;
    if (R instanceof Element) {
      var z = R.getBoundingClientRect();
      H = {
        left: z.left,
        top: z.top,
        width: z.width,
        height: z.height
      };
    } else
      H = __assign$2({
        width: 0,
        height: 0
      }, R);
    var X = H.left, Y = H.top, W = H.width, q = H.height, Z = fitPoints([D, L, $, B], U), K = getOverlapSize(Z, [[X, Y], [X + W, Y], [X + W, Y + q], [X, Y + q]]), J = getAreaSize(Z);
    return !K || !J ? 0 : Math.min(100, K / J * 100);
  }, e.isInside = function(R, N) {
    var M = this.state, D = M.target, L = M.pos1, B = M.pos2, $ = M.pos3, U = M.pos4, H = M.targetClientRect;
    return D ? isInside([R, N], fitPoints([L, B, U, $], H)) : !1;
  }, e.updateRect = function(R, N, M) {
    M === void 0 && (M = !0);
    var D = this.props, L = D.parentMoveable, B = this.state, $ = B.target || this.props.target, U = this.getContainer(), H = L ? L.props.rootContainer : D.rootContainer;
    this.updateState(getMoveableTargetInfo(this.controlBox && this.controlBox.getElement(), $, U, U, H || U), L ? !1 : M);
  }, e.isDragging = function() {
    return (this.targetGesto ? this.targetGesto.isFlag() : !1) || (this.controlGesto ? this.controlGesto.isFlag() : !1);
  }, e.updateTarget = function(R) {
    this.updateRect(R, !0);
  }, e.getRect = function() {
    var R = this.state, N = getAbsolutePosesByState(this.state), M = N[0], D = N[1], L = N[2], B = N[3], $ = getRect(N), U = R.width, H = R.height, z = $.width, X = $.height, Y = $.left, W = $.top, q = [R.left, R.top], Z = plus(q, R.origin), K = plus(q, R.beforeOrigin), J = R.transformOrigin;
    return {
      width: z,
      height: X,
      left: Y,
      top: W,
      pos1: M,
      pos2: D,
      pos3: L,
      pos4: B,
      offsetWidth: U,
      offsetHeight: H,
      beforeOrigin: K,
      origin: Z,
      transformOrigin: J,
      rotation: this.getRotation()
    };
  }, e.getManager = function() {
    return this;
  }, e.getRotation = function() {
    var R = this.state, N = R.pos1, M = R.pos2, D = R.direction;
    return getAbsoluteRotation(N, M, D);
  }, e.request = function(R, N, M) {
    N === void 0 && (N = {});
    var D = this.props, L = D.ables, B = D.groupable, $ = L.filter(function(q) {
      return q.name === R;
    })[0];
    if (this.isDragging() || !$ || !$.request)
      return {
        request: function() {
          return this;
        },
        requestEnd: function() {
          return this;
        }
      };
    var U = this, H = $.request(this), z = M || N.isInstant, X = H.isControl ? "controlAbles" : "targetAbles", Y = "".concat(B ? "Group" : "").concat(H.isControl ? "Control" : ""), W = {
      request: function(q) {
        return triggerAble(U, X, "drag", Y, "", __assign$2(__assign$2({}, H.request(q)), {
          requestAble: R,
          isRequest: !0
        }), z), this;
      },
      requestEnd: function() {
        return triggerAble(U, X, "drag", Y, "End", __assign$2(__assign$2({}, H.requestEnd()), {
          requestAble: R,
          isRequest: !0
        }), z), this;
      }
    };
    return triggerAble(U, X, "drag", Y, "Start", __assign$2(__assign$2({}, H.requestStart(N)), {
      requestAble: R,
      isRequest: !0
    }), z), z ? W.request(N).requestEnd() : W;
  }, e.destroy = function() {
    this.componentWillUnmount();
  }, e.updateRenderPoses = function() {
    var R = this.state, N = this.props, M = R.originalBeforeOrigin, D = R.transformOrigin, L = R.allMatrix, B = R.is3d, $ = R.pos1, U = R.pos2, H = R.pos3, z = R.pos4, X = R.left, Y = R.top, W = N.padding || {}, q = W.left, Z = q === void 0 ? 0 : q, K = W.top, J = K === void 0 ? 0 : K, Q = W.bottom, et = Q === void 0 ? 0 : Q, tt = W.right, st = tt === void 0 ? 0 : tt, rt = B ? 4 : 3, at = N.groupable ? M : plus(M, [X, Y]);
    R.renderPoses = [plus($, calculatePadding(L, [-Z, -J], D, at, rt)), plus(U, calculatePadding(L, [st, -J], D, at, rt)), plus(H, calculatePadding(L, [-Z, et], D, at, rt)), plus(z, calculatePadding(L, [st, et], D, at, rt))];
  }, e.checkUpdate = function() {
    this._isPropTargetChanged = !1;
    var R = this.props, N = R.target, M = R.container, D = R.parentMoveable, L = this.state, B = L.target, $ = L.container;
    if (!(!B && !N)) {
      this.updateAbles();
      var U = !equals(B, N), H = U || !equals($, M);
      if (!!H) {
        var z = M || this.controlBox;
        z && this.unsetAbles(), this.updateState({
          target: N,
          container: M
        }), !D && z && this.updateRect("End", !1, !1), this._isPropTargetChanged = U;
      }
    }
  }, e.waitToChangeTarget = function() {
    return new Promise(function() {
    });
  }, e.triggerEvent = function(R, N) {
    this._emitter.trigger(R, N);
    var M = this.props[R];
    return M && M(N);
  }, e.useCSS = function(R, N) {
    var M = this.props.customStyledMap, D = R + N;
    return M[D] || (M[D] = styled(R, N)), M[D];
  }, e.updateSelectors = function() {
  }, e.unsetAbles = function() {
    var R = this;
    this.targetAbles.forEach(function(N) {
      N.unset && N.unset(R);
    });
  }, e.updateAbles = function(R, N) {
    R === void 0 && (R = this.props.ables), N === void 0 && (N = "");
    var M = this.props, D = M.triggerAblesSimultaneously, L = R.filter(function(X) {
      return X && (X.always && M[X.name] !== !1 || M[X.name]);
    }), B = "drag".concat(N, "Start"), $ = "pinch".concat(N, "Start"), U = "drag".concat(N, "ControlStart"), H = filterAbles(L, [B, $], D), z = filterAbles(L, [U], D);
    this.enabledAbles = L, this.targetAbles = H, this.controlAbles = z;
  }, e.updateState = function(R, N) {
    if (N) {
      if (this.isUnmounted)
        return;
      this.setState(R);
    } else {
      var M = this.state;
      for (var D in R)
        M[D] = R[D];
    }
  }, e.getEnabledAbles = function() {
    var R = this.props, N = R.ables;
    return N.filter(function(M) {
      return M && R[M.name];
    });
  }, e.renderAbles = function() {
    var R = this, N = this.props, M = N.triggerAblesSimultaneously, D = {
      createElement
    };
    return this.renderState = {}, groupByMap(flat(filterAbles(this.getEnabledAbles(), ["render"], M).map(function(L) {
      var B = L.render;
      return B(R, D) || [];
    })).filter(function(L) {
      return L;
    }), function(L) {
      var B = L.key;
      return B;
    }).map(function(L) {
      return L[0];
    });
  }, e.updateCheckInput = function() {
    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);
  }, e._updateObserver = function(R) {
    var N, M = this.props, D = M.target;
    if (!window.ResizeObserver || !D || !M.useResizeObserver) {
      (N = this._observer) === null || N === void 0 || N.disconnect();
      return;
    }
    if (!(R.target === D && this._observer)) {
      var L = new ResizeObserver(this.checkUpdateRect);
      L.observe(D, {
        box: "border-box"
      }), this._observer = L;
    }
  }, e._updateEvents = function() {
    var R = this.controlBox.getElement(), N = this.targetAbles.length, M = this.controlAbles.length, D = this.props, L = D.dragTarget || D.target, B = !N && this.targetGesto || this._isTargetChanged(!0);
    B && (unset(this, "targetGesto"), this.updateState({
      gesto: null
    })), M || unset(this, "controlGesto"), L && N && !this.targetGesto && (this.targetGesto = getTargetAbleGesto(this, L, "")), !this.controlGesto && M && (this.controlGesto = getAbleGesto(this, R, "controlAbles", "Control"));
  }, e._updateTargets = function() {
    var R = this.props;
    this._prevTarget = R.dragTarget || R.target, this._prevDragArea = R.dragArea;
  }, e._renderLines = function() {
    var R = this.props, N = R, M = N.zoom, D = N.hideDefaultLines, L = N.hideChildMoveableDefaultLines, B = N.parentMoveable;
    if (D || B && L)
      return [];
    var $ = this.state.renderPoses, U = {
      createElement
    };
    return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(H, z) {
      var X = H[0], Y = H[1];
      return renderLine(U, "", $[X], $[Y], M, "render-line-".concat(z));
    });
  }, e._isTargetChanged = function(R) {
    var N = this.props, M = N.dragTarget || N.target, D = this._prevTarget, L = this._prevDragArea, B = N.dragArea, $ = !B && D !== M, U = (R || B) && L !== B;
    return $ || U;
  }, e._updateNativeEvents = function() {
    var R = this, N = this.props, M = N.dragArea ? this.areaElement : this.state.target, D = this.events, L = getKeys(D);
    if (this._isTargetChanged())
      for (var B in D) {
        var $ = D[B];
        $ && $.destroy(), D[B] = null;
      }
    if (!!M) {
      var U = this.enabledAbles;
      L.forEach(function(H) {
        var z = filterAbles(U, [H]), X = z.length > 0, Y = D[H];
        if (!X) {
          Y && (Y.destroy(), D[H] = null);
          return;
        }
        Y || (Y = new EventManager(M, R, H), D[H] = Y), Y.setAbles(z);
      });
    }
  }, t.defaultProps = {
    target: null,
    dragTarget: null,
    container: null,
    rootContainer: null,
    origin: !0,
    parentMoveable: null,
    wrapperMoveable: null,
    parentPosition: null,
    portalContainer: null,
    useResizeObserver: !1,
    ables: [],
    pinchThreshold: 20,
    dragArea: !1,
    passDragArea: !1,
    transformOrigin: "",
    className: "",
    zoom: 1,
    triggerAblesSimultaneously: !1,
    padding: {},
    pinchOutside: !0,
    checkInput: !1,
    groupable: !1,
    hideDefaultLines: !1,
    cspNonce: "",
    translateZ: 0,
    cssStyled: null,
    customStyledMap: {},
    props: {},
    stopPropagation: !1,
    preventClickDefault: !1,
    preventClickEventOnDrag: !0,
    flushSync: defaultSync
  }, t;
}(PureComponent), Groupable = {
  name: "groupable",
  props: {
    defaultGroupRotate: Number,
    defaultGroupOrigin: String,
    groupable: Boolean,
    targetGroups: Object,
    hideChildMoveableDefaultLines: Boolean
  },
  events: {},
  render: function(o, t) {
    var e = o.props.targets || [];
    o.moveables = [];
    var R = o.state, N = R.left, M = R.top, D = [N, M], L = o.props, B = L.zoom || 1, $ = o.renderGroupRects;
    return __spreadArray(__spreadArray([], e.map(function(U, H) {
      return t.createElement(MoveableManager$1, {
        key: "moveable" + H,
        ref: refs(o, "moveables", H),
        target: U,
        origin: !1,
        cssStyled: L.cssStyled,
        customStyledMap: L.customStyledMap,
        useResizeObserver: L.useResizeObserver,
        hideChildMoveableDefaultLines: L.hideChildMoveableDefaultLines,
        parentMoveable: o,
        parentPosition: D,
        zoom: B
      });
    }), !0), flat($.map(function(U, H) {
      var z = U.pos1, X = U.pos2, Y = U.pos3, W = U.pos4, q = [z, X, Y, W];
      return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(Z, K) {
        var J = Z[0], Q = Z[1];
        return renderLine(t, "", minus(q[J], D), minus(q[Q], D), B, "group-rect-".concat(H, "-").concat(K));
      });
    })), !0);
  }
}, Clickable = makeAble("clickable", {
  props: {
    clickable: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  always: !0,
  dragRelation: "weak",
  dragStart: function() {
  },
  dragControlStart: function() {
  },
  dragGroupStart: function(o, t) {
    t.datas.inputTarget = t.inputEvent && t.inputEvent.target;
  },
  dragEnd: function(o, t) {
    var e = o.props.target, R = t.inputEvent, N = t.inputTarget, M = o.isMoveableElement(N), D = !M && o.controlBox.getElement().contains(N);
    if (!(!R || !N || t.isDrag || o.isMoveableElement(N) || D)) {
      var L = e.contains(N);
      triggerEvent(o, "onClick", fillParams(o, t, {
        isDouble: t.isDouble,
        inputTarget: N,
        isTarget: e === N,
        moveableTarget: o.props.target,
        containsTarget: L
      }));
    }
  },
  dragGroupEnd: function(o, t) {
    var e = t.inputEvent, R = t.inputTarget;
    if (!(!e || !R || t.isDrag || o.isMoveableElement(R) || t.datas.inputTarget === R)) {
      var N = o.props.targets, M = N.indexOf(R), D = M > -1, L = !1;
      M === -1 && (M = findIndex(N, function(B) {
        return B.contains(R);
      }), L = M > -1), triggerEvent(o, "onClickGroup", fillParams(o, t, {
        isDouble: t.isDouble,
        targets: N,
        inputTarget: R,
        targetIndex: M,
        isTarget: D,
        containsTarget: L,
        moveableTarget: N[M]
      }));
    }
  },
  dragControlEnd: function(o, t) {
    this.dragEnd(o, t);
  },
  dragGroupControlEnd: function(o, t) {
    this.dragEnd(o, t);
  }
});
function getDraggableEvent(o) {
  var t = o.originalDatas.draggable;
  return t || (o.originalDatas.draggable = {}, t = o.originalDatas.draggable), __assign$2(__assign$2({}, o), {
    datas: t
  });
}
var edgeDraggable = makeAble("edgeDraggable", {
  css: [`.edge.edgeDraggable.line {
    cursor: move;
}`],
  render: function(o, t) {
    var e = o.props, R = e.edgeDraggable;
    return R ? renderEdgeLines(t, "edgeDraggable", R, o.state.renderPoses, e.zoom) : [];
  },
  dragControlCondition: function(o, t) {
    if (!o.props.edgeDraggable || !t.inputEvent)
      return !1;
    var e = t.inputEvent.target;
    return hasClass(e, prefix("direction")) && hasClass(e, prefix("edge")) && hasClass(e, prefix("edgeDraggable"));
  },
  dragControlStart: function(o, t) {
    return o.state.snapRenderInfo = {
      request: t.isRequest,
      snap: !0,
      center: !0
    }, Draggable.dragStart(o, getDraggableEvent(t));
  },
  dragControl: function(o, t) {
    return Draggable.drag(o, getDraggableEvent(t));
  },
  dragControlEnd: function(o, t) {
    return Draggable.dragEnd(o, getDraggableEvent(t));
  },
  dragGroupControlCondition: function(o, t) {
    if (!o.props.edgeDraggable || !t.inputEvent)
      return !1;
    var e = t.inputEvent.target;
    return hasClass(e, prefix("direction")) && hasClass(e, prefix("line"));
  },
  dragGroupControlStart: function(o, t) {
    return Draggable.dragGroupStart(o, getDraggableEvent(t));
  },
  dragGroupControl: function(o, t) {
    return Draggable.dragGroup(o, getDraggableEvent(t));
  },
  dragGroupControlEnd: function(o, t) {
    return Draggable.dragGroupEnd(o, getDraggableEvent(t));
  },
  unset: function(o) {
    return Draggable.unset(o);
  }
}), IndividualGroupable = {
  name: "individualGroupable",
  props: {
    individualGroupable: Boolean
  },
  events: {}
}, MOVEABLE_ABLES = [BeforeRenderable, Default, Snappable, Pinchable, Draggable, edgeDraggable, Resizable, Scalable, Warpable, Rotatable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable], MOVEABLE_EVENTS_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(o, t) {
  return __assign$2(__assign$2({}, o), "events" in t ? t.events : {});
}, {}), MOVEABLE_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(o, t) {
  return __assign$2(__assign$2({}, o), t.props);
}, {}), MOVEABLE_EVENTS_MAP = /* @__PURE__ */ invertObject(MOVEABLE_EVENTS_PROPS_MAP), MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP), MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);
function solveConstantsDistance(o, t) {
  var e = o[0], R = o[1], N = o[2];
  return (e * t[0] + R * t[1] + N) / Math.sqrt(e * e + R * R);
}
function solveC(o, t) {
  var e = o[0], R = o[1];
  return -e * t[0] - R * t[1];
}
function getMaxPos(o, t) {
  return Math.max.apply(Math, o.map(function(e) {
    var R = e[0], N = e[1], M = e[2], D = e[3];
    return Math.max(R[t], N[t], M[t], D[t]);
  }));
}
function getMinPos(o, t) {
  return Math.min.apply(Math, o.map(function(e) {
    var R = e[0], N = e[1], M = e[2], D = e[3];
    return Math.min(R[t], N[t], M[t], D[t]);
  }));
}
function getGroupRect(o, t) {
  var e, R = [0, 0], N = [0, 0], M = [0, 0], D = [0, 0], L = 0, B = 0;
  if (!o.length)
    return {
      pos1: R,
      pos2: N,
      pos3: M,
      pos4: D,
      minX: 0,
      minY: 0,
      width: L,
      height: B,
      rotation: t
    };
  var $ = throttle(t, TINY_NUM);
  if ($ % 90) {
    var U = $ / 180 * Math.PI, H = Math.tan(U), z = -1 / H, X = [MAX_NUM, MIN_NUM], Y = [[0, 0], [0, 0]], W = [MAX_NUM, MIN_NUM], q = [[0, 0], [0, 0]];
    o.forEach(function(xt) {
      xt.forEach(function(At) {
        var yt = solveConstantsDistance([-H, 1, 0], At), ht = solveConstantsDistance([-z, 1, 0], At);
        X[0] > yt && (Y[0] = At, X[0] = yt), X[1] < yt && (Y[1] = At, X[1] = yt), W[0] > ht && (q[0] = At, W[0] = ht), W[1] < ht && (q[1] = At, W[1] = ht);
      });
    });
    var Z = Y[0], K = Y[1], J = q[0], Q = q[1], et = [-H, 1, solveC([-H, 1], Z)], tt = [-H, 1, solveC([-H, 1], K)], st = [-z, 1, solveC([-z, 1], J)], rt = [-z, 1, solveC([-z, 1], Q)];
    e = [[et, st], [et, rt], [tt, st], [tt, rt]].map(function(xt) {
      var At = xt[0], yt = xt[1];
      return getIntersectionPointsByConstants(At, yt)[0];
    }), R = e[0], N = e[1], M = e[2], D = e[3], L = W[1] - W[0], B = X[1] - X[0];
  } else {
    var at = getMinPos(o, 0), ut = getMinPos(o, 1), dt = getMaxPos(o, 0), ct = getMaxPos(o, 1);
    if (R = [at, ut], N = [dt, ut], M = [at, ct], D = [dt, ct], L = dt - at, B = ct - ut, $ % 180) {
      var pt = [M, R, D, N];
      R = pt[0], N = pt[1], M = pt[2], D = pt[3], L = ct - ut, B = dt - at;
    }
  }
  if ($ % 360 > 180) {
    var pt = [D, M, N, R];
    R = pt[0], N = pt[1], M = pt[2], D = pt[3];
  }
  var mt = getMinMaxs([R, N, M, D]), vt = mt.minX, _t = mt.minY;
  return {
    pos1: R,
    pos2: N,
    pos3: M,
    pos4: D,
    width: L,
    height: B,
    minX: vt,
    minY: _t,
    rotation: t
  };
}
function findMoveableGroups(o, t) {
  var e = t.map(function(R) {
    if (isArray(R)) {
      var N = findMoveableGroups(o, R), M = N.length;
      return M > 1 ? N : M === 1 ? N[0] : null;
    } else {
      var D = find$1(o, function(L) {
        var B = L.manager;
        return B.props.target === R;
      });
      return D ? (D.finded = !0, D.manager) : null;
    }
  }).filter(Boolean);
  return e.length === 1 && isArray(e[0]) ? e[0] : e;
}
var MoveableGroup = /* @__PURE__ */ function(o) {
  __extends$1(t, o);
  function t() {
    var R = o !== null && o.apply(this, arguments) || this;
    return R.differ = new ChildrenDiffer$1(), R.moveables = [], R.transformOrigin = "50% 50%", R.renderGroupRects = [], R;
  }
  var e = t.prototype;
  return e.checkUpdate = function() {
    this._isPropTargetChanged = !1, this.updateAbles();
  }, e.updateRect = function(R, N, M) {
    if (M === void 0 && (M = !0), !this.controlBox)
      return;
    this.moveables.forEach(function(yt) {
      yt.updateRect(R, !1, !1);
    });
    var D = this.state, L = this.props, B = this.moveables, $ = D.target || L.target, U = B.map(function(yt) {
      return {
        finded: !1,
        manager: yt
      };
    }), H = findMoveableGroups(U, this.props.targetGroups || []);
    H.push.apply(H, U.filter(function(yt) {
      var ht = yt.finded;
      return !ht;
    }).map(function(yt) {
      var ht = yt.manager;
      return ht;
    }));
    var z = [], X = !N || R !== "" && L.updateGroup;
    function Y(yt, ht, bt) {
      var Ct = yt.map(function(Bt) {
        if (isArray(Bt)) {
          var Ot = Y(Bt, ht), Et = [Ot.pos1, Ot.pos2, Ot.pos3, Ot.pos4];
          return z.push(Ot), {
            poses: Et,
            rotation: Ot.rotation
          };
        } else
          return {
            poses: getAbsolutePosesByState(Bt.state),
            rotation: Bt.getRotation()
          };
      }), Mt = Ct.map(function(Bt) {
        var Ot = Bt.rotation;
        return Ot;
      }), wt = 0, Lt = Mt[0], ft = Mt.every(function(Bt) {
        return Math.abs(Lt - Bt) < 0.1;
      });
      X ? wt = ft ? Lt : L.defaultGroupRotate || 0 : wt = !bt && ft ? Lt : ht;
      var Gt = Ct.map(function(Bt) {
        var Ot = Bt.poses;
        return Ot;
      }), Dt = getGroupRect(Gt, wt);
      return Dt;
    }
    var W = Y(H, this.rotation, !0);
    X && (this.rotation = W.rotation, this.transformOrigin = L.defaultGroupOrigin || "50% 50%", this.scale = [1, 1]), this.renderGroupRects = z;
    var q = this.rotation, Z = this.scale, K = W.width, J = W.height, Q = W.minX, et = W.minY, tt = "rotate(".concat(q, "deg) scale(").concat(Z[0] >= 0 ? 1 : -1, ", ").concat(Z[1] >= 0 ? 1 : -1, ")");
    $.style.cssText += "left:0px;top:0px; transform-origin: ".concat(this.transformOrigin, "; width:").concat(K, "px; height:").concat(J, "px;") + "transform:".concat(tt), D.width = K, D.height = J;
    var st = this.getContainer(), rt = getMoveableTargetInfo(this.controlBox.getElement(), $, this.controlBox.getElement(), this.getContainer(), this.props.rootContainer || st), at = [rt.left, rt.top], ut = getAbsolutePosesByState(rt), dt = ut[0], ct = ut[1], pt = ut[2], mt = ut[3], vt = getMinMaxs([dt, ct, pt, mt]), _t = [vt.minX, vt.minY];
    rt.pos1 = minus(dt, _t), rt.pos2 = minus(ct, _t), rt.pos3 = minus(pt, _t), rt.pos4 = minus(mt, _t), rt.left = Q - rt.left + _t[0], rt.top = et - rt.top + _t[1], rt.origin = minus(plus(at, rt.origin), _t), rt.beforeOrigin = minus(plus(at, rt.beforeOrigin), _t), rt.originalBeforeOrigin = plus(at, rt.originalBeforeOrigin);
    var xt = rt.targetClientRect, At = Z[0] * Z[1] > 0 ? 1 : -1;
    xt.top += rt.top - D.top, xt.left += rt.left - D.left, $.style.transform = "translate(".concat(-_t[0], "px, ").concat(-_t[1], "px) ").concat(tt), this.updateState(__assign$2(__assign$2({}, rt), {
      direction: At,
      beforeDirection: At
    }), M);
  }, e.getRect = function() {
    return __assign$2(__assign$2({}, o.prototype.getRect.call(this)), {
      children: this.moveables.map(function(R) {
        return R.getRect();
      })
    });
  }, e.triggerEvent = function(R, N, M) {
    if (M || R.indexOf("Group") > -1)
      return o.prototype.triggerEvent.call(this, R, N);
    this._emitter.trigger(R, N);
  }, e.updateAbles = function() {
    o.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], this.props.ables, !0), [Groupable], !1), "Group");
  }, e._updateTargets = function() {
    o.prototype._updateTargets.call(this), this._prevTarget = this.props.dragTarget || this.areaElement;
  }, e._updateEvents = function() {
    var R = this.state, N = this.props, M = this._prevTarget, D = N.dragTarget || this.areaElement;
    M !== D && (unset(this, "targetGesto"), unset(this, "controlGesto"), R.target = null), R.target || (R.target = this.areaElement, this.controlBox.getElement().style.display = "block"), R.target && (this.targetGesto || (this.targetGesto = getTargetAbleGesto(this, D, "Group")), this.controlGesto || (this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), "controlAbles", "GroupControl")));
    var L = !equals(R.container, N.container);
    L && (R.container = N.container);
    var B = this.differ.update(N.targets), $ = B.added, U = B.changed, H = B.removed, z = $.length || H.length;
    (L || z || U.length) && this.updateRect(), this._isPropTargetChanged = !!z;
  }, e._updateObserver = function() {
  }, t.defaultProps = __assign$2(__assign$2({}, MoveableManager$1.defaultProps), {
    transformOrigin: ["50%", "50%"],
    groupable: !0,
    dragArea: !0,
    keepRatio: !0,
    targets: [],
    defaultGroupRotate: 0,
    defaultGroupOrigin: "50% 50%"
  }), t;
}(MoveableManager$1), MoveableIndividualGroup = /* @__PURE__ */ function(o) {
  __extends$1(t, o);
  function t() {
    var R = o !== null && o.apply(this, arguments) || this;
    return R.moveables = [], R;
  }
  var e = t.prototype;
  return e.render = function() {
    var R = this, N = this.props, M = N.cspNonce, D = N.cssStyled, L = N.targets;
    return createElement(D, {
      cspNonce: M,
      ref: ref(this, "controlBox"),
      className: prefix("control-box")
    }, L.map(function(B, $) {
      return createElement(MoveableManager$1, __assign$2({
        key: "moveable" + $,
        ref: refs(R, "moveables", $)
      }, R.props, {
        target: B,
        wrapperMoveable: R
      }));
    }));
  }, e.componentDidUpdate = function() {
  }, e.updateRect = function(R, N, M) {
    M === void 0 && (M = !0), this.moveables.forEach(function(D) {
      D.updateRect(R, N, M);
    });
  }, e.getRect = function() {
    return __assign$2(__assign$2({}, o.prototype.getRect.call(this)), {
      children: this.moveables.map(function(R) {
        return R.getRect();
      })
    });
  }, e.request = function() {
    return {
      request: function() {
        return this;
      },
      requestEnd: function() {
        return this;
      }
    };
  }, e.dragStart = function() {
    return this;
  }, e.hitTest = function() {
    return 0;
  }, e.isInside = function() {
    return !1;
  }, e.isDragging = function() {
    return !1;
  }, e.updateRenderPoses = function() {
  }, e.checkUpdate = function() {
  }, e.triggerEvent = function() {
  }, e.updateAbles = function() {
  }, e._updateEvents = function() {
  }, e._updateObserver = function() {
  }, t;
}(MoveableManager$1);
function getElementTargets(o, t) {
  var e = [];
  return o.forEach(function(R) {
    if (!!R) {
      if (isString$1(R)) {
        t[R] && e.push.apply(e, t[R]);
        return;
      }
      isArray(R) ? e.push.apply(e, getElementTargets(R, t)) : e.push(R);
    }
  }), e;
}
function getTargetGroups(o, t) {
  var e = [];
  return o.forEach(function(R) {
    if (!!R) {
      if (isString$1(R)) {
        t[R] && e.push.apply(e, t[R]);
        return;
      }
      isArray(R) ? e.push(getTargetGroups(R, t)) : e.push(R);
    }
  }), e;
}
function compareRefTargets(o, t) {
  return o.length !== t.length || o.some(function(e, R) {
    var N = t[R];
    return !e && !N ? !1 : e != N ? isArray(e) && isArray(N) ? compareRefTargets(e, N) : !0 : !1;
  });
}
var InitialMoveable = /* @__PURE__ */ function(o) {
  __extends$1(t, o);
  function t() {
    var R = o !== null && o.apply(this, arguments) || this;
    return R.refTargets = [], R.selectorMap = {}, R._differ = new ChildrenDiffer$1(), R._elementTargets = [], R._onChangetarget = null, R;
  }
  var e = t.prototype;
  return t.makeStyled = function() {
    var R = {}, N = this.getTotalAbles();
    N.forEach(function(D) {
      var L = D.css;
      !L || L.forEach(function(B) {
        R[B] = !0;
      });
    });
    var M = getKeys(R).join(`
`);
    this.defaultStyled = styled("div", prefixCSS(PREFIX, MOVEABLE_CSS + M));
  }, t.getTotalAbles = function() {
    return __spreadArray([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles, !0);
  }, e.render = function() {
    var R = this.constructor;
    R.defaultStyled || R.makeStyled();
    var N = this.props, M = N.ables, D = N.props, L = __rest(N, ["ables", "props"]), B = this._updateRefs(!0), $ = getElementTargets(B, this.selectorMap), U = $.length > 1, H = R.getTotalAbles(), z = __spreadArray(__spreadArray([], H, !0), M || [], !0), X = __assign$2(__assign$2(__assign$2({}, L), D || {}), {
      ables: z,
      cssStyled: R.defaultStyled,
      customStyledMap: R.customStyledMap
    });
    if (this._elementTargets = $, U) {
      if (L.individualGroupable)
        return createElement(MoveableIndividualGroup, __assign$2({
          key: "individual-group",
          ref: ref(this, "moveable")
        }, X, {
          target: null,
          targets: $
        }));
      var Y = getTargetGroups(B, this.selectorMap);
      return createElement(MoveableGroup, __assign$2({
        key: "group",
        ref: ref(this, "moveable")
      }, X, {
        target: null,
        targets: $,
        targetGroups: Y
      }));
    } else
      return createElement(MoveableManager$1, __assign$2({
        key: "single",
        ref: ref(this, "moveable")
      }, X, {
        target: $[0]
      }));
  }, e.componentDidMount = function() {
    this._updateRefs();
  }, e.componentDidUpdate = function() {
    var R = this._differ.update(this._elementTargets), N = R.added, M = R.removed, D = N.length || M.length;
    D && this._onChangetarget && this._onChangetarget(), this._updateRefs();
  }, e.componentWillUnmount = function() {
    this.selectorMap = {}, this.refTargets = [];
  }, e.updateSelectors = function() {
    this.selectorMap = {}, this.refTargets = [], this.forceUpdate();
  }, e.waitToChangeTarget = function() {
    var R = this, N;
    return this._onChangetarget = function() {
      R._onChangetarget = null, N();
    }, new Promise(function(M) {
      N = M;
    });
  }, e.getManager = function() {
    return this.moveable;
  }, e._updateRefs = function(R) {
    var N = this.refTargets, M = getRefTargets(this.props.target || this.props.targets), D = typeof document < "u", L = compareRefTargets(N, M), B = this.selectorMap, $ = {};
    return this.refTargets.forEach(function U(H) {
      if (isString$1(H)) {
        var z = B[H];
        z ? $[H] = B[H] : D && (L = !0, $[H] = [].slice.call(document.querySelectorAll(H)));
      } else
        isArray(H) && H.forEach(U);
    }), this.refTargets = M, this.selectorMap = $, !R && L && this.forceUpdate(), M;
  }, t.defaultAbles = [], t.customStyledMap = {}, t.defaultStyled = null, __decorate$1([withMethods(MOVEABLE_METHODS)], t.prototype, "moveable", void 0), t;
}(PureComponent), Moveable$1 = /* @__PURE__ */ function(o) {
  __extends$1(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  return t.defaultAbles = MOVEABLE_ABLES, t;
}(InitialMoveable), Moveable$2 = Moveable$1;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(o, t) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, R) {
    e.__proto__ = R;
  } || function(e, R) {
    for (var N in R)
      R.hasOwnProperty(N) && (e[N] = R[N]);
  }, extendStatics(o, t);
};
function __extends(o, t) {
  extendStatics(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$1 = function() {
  return __assign$1 = Object.assign || function(t) {
    for (var e, R = 1, N = arguments.length; R < N; R++) {
      e = arguments[R];
      for (var M in e)
        Object.prototype.hasOwnProperty.call(e, M) && (t[M] = e[M]);
    }
    return t;
  }, __assign$1.apply(this, arguments);
};
function __decorate(o, t, e, R) {
  var N = arguments.length, M = N < 3 ? t : R === null ? R = Object.getOwnPropertyDescriptor(t, e) : R, D;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    M = Reflect.decorate(o, t, e, R);
  else
    for (var L = o.length - 1; L >= 0; L--)
      (D = o[L]) && (M = (N < 3 ? D(M) : N > 3 ? D(t, e, M) : D(t, e)) || M);
  return N > 3 && M && Object.defineProperty(t, e, M), M;
}
var InnerMoveable = /* @__PURE__ */ function(o) {
  __extends(t, o);
  function t(R) {
    var N = o.call(this, R) || this;
    return N.state = {}, N.state = N.props, N;
  }
  var e = t.prototype;
  return e.render = function() {
    return createPortal(createElement(Moveable$2, __assign$1({
      ref: ref(this, "moveable")
    }, this.state)), this.state.parentElement);
  }, t;
}(Component), PROPERTIES = MOVEABLE_PROPS, METHODS = MOVEABLE_METHODS, EVENTS = MOVEABLE_EVENTS;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var e, R = 1, N = arguments.length; R < N; R++) {
      e = arguments[R];
      for (var M in e)
        Object.prototype.hasOwnProperty.call(e, M) && (t[M] = e[M]);
    }
    return t;
  }, __assign.apply(this, arguments);
};
function __spreadArrays() {
  for (var o = 0, t = 0, e = arguments.length; t < e; t++)
    o += arguments[t].length;
  for (var R = Array(o), N = 0, t = 0; t < e; t++)
    for (var M = arguments[t], D = 0, L = M.length; D < L; D++, N++)
      R[N] = M[D];
  return R;
}
var EventEmitter = /* @__PURE__ */ function() {
  function o() {
    this._events = {};
  }
  var t = o.prototype;
  return t.on = function(e, R) {
    if (isObject$2(e))
      for (var N in e)
        this.on(N, e[N]);
    else
      this._addEvent(e, R, {});
    return this;
  }, t.off = function(e, R) {
    if (!e)
      this._events = {};
    else if (isObject$2(e))
      for (var N in e)
        this.off(N);
    else if (!R)
      this._events[e] = [];
    else {
      var M = this._events[e];
      if (M) {
        var D = findIndex(M, function(L) {
          return L.listener === R;
        });
        D > -1 && M.splice(D, 1);
      }
    }
    return this;
  }, t.once = function(e, R) {
    var N = this;
    return R && this._addEvent(e, R, {
      once: !0
    }), new Promise(function(M) {
      N._addEvent(e, M, {
        once: !0
      });
    });
  }, t.emit = function(e, R) {
    var N = this;
    R === void 0 && (R = {});
    var M = this._events[e];
    if (!e || !M)
      return !0;
    var D = !1;
    return R.eventType = e, R.stop = function() {
      D = !0;
    }, R.currentTarget = this, __spreadArrays(M).forEach(function(L) {
      L.listener(R), L.once && N.off(e, L.listener);
    }), !D;
  }, t.trigger = function(e, R) {
    return R === void 0 && (R = {}), this.emit(e, R);
  }, t._addEvent = function(e, R, N) {
    var M = this._events;
    M[e] = M[e] || [];
    var D = M[e];
    D.push(__assign({
      listener: R
    }, N));
  }, o;
}(), EventEmitter$1 = EventEmitter, MoveableManager = /* @__PURE__ */ function(o) {
  __extends(t, o);
  function t(R, N) {
    N === void 0 && (N = {});
    var M = o.call(this) || this;
    M.tempElement = document.createElement("div");
    var D = __assign$1({}, N), L = {};
    EVENTS.forEach(function($) {
      L[camelize("on ".concat($))] = function(U) {
        return M.trigger($, U);
      };
    }), render(createElement(InnerMoveable, __assign$1({
      ref: ref(M, "innerMoveable"),
      parentElement: R
    }, D, L)), M.tempElement);
    var B = D.target;
    return isArray(B) && B.length > 1 && M.updateRect(), M;
  }
  var e = t.prototype;
  return e.setState = function(R, N) {
    this.innerMoveable.setState(R, N);
  }, e.forceUpdate = function(R) {
    this.innerMoveable.forceUpdate(R);
  }, e.dragStart = function(R) {
    var N = this.innerMoveable;
    N.$_timer && this.forceUpdate(), this.getMoveable().dragStart(R);
  }, e.destroy = function() {
    render(null, this.tempElement), this.off(), this.tempElement = null, this.innerMoveable = null;
  }, e.getMoveable = function() {
    return this.innerMoveable.moveable;
  }, t = __decorate([Properties(METHODS, function(R, N) {
    R[N] || (R[N] = function() {
      for (var M = [], D = 0; D < arguments.length; D++)
        M[D] = arguments[D];
      var L = this.getMoveable();
      if (!(!L || !L[N]))
        return L[N].apply(L, M);
    });
  }), Properties(PROPERTIES, function(R, N) {
    Object.defineProperty(R, N, {
      get: function() {
        return this.getMoveable().props[N];
      },
      set: function(M) {
        var D;
        this.setState((D = {}, D[N] = M, D));
      },
      enumerable: !0,
      configurable: !0
    });
  })], t), t;
}(EventEmitter$1), Moveable = /* @__PURE__ */ function(o) {
  __extends(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  return t;
}(MoveableManager), __accessCheck$2 = (o, t, e) => {
  if (!t.has(o))
    throw TypeError("Cannot " + e);
}, __privateGet$2 = (o, t, e) => (__accessCheck$2(o, t, "read from private field"), e ? e.call(o) : t.get(o)), __privateAdd$2 = (o, t, e) => {
  if (t.has(o))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(o) : t.set(o, e);
}, __privateSet$2 = (o, t, e, R) => (__accessCheck$2(o, t, "write to private field"), R ? R.call(o, e) : t.set(o, e), e), __privateWrapper = (o, t, e, R) => ({
  set _(N) {
    __privateSet$2(o, t, N, e);
  },
  get _() {
    return __privateGet$2(o, t, R);
  }
}), __privateMethod$2 = (o, t, e) => (__accessCheck$2(o, t, "access private method"), e), _divDesignRoot, _scrItr, _alzTagArg, _cfg$1, _ID_DESIGNMODE, _cntDesignCast, _hId2dc, _aDC, _resizeDiv, resizeDiv_fn;
const _DesignCast = class {
  constructor(o, t = !1) {
    this.bg_col = o, this.isLay = t, __privateAdd$2(this, _resizeDiv), this.hArg = {}, this.id_tag = "", this.hDesignArg = {
      rotation: 0,
      pivot_x: 0,
      pivot_y: 0,
      left: 0,
      center: 0,
      right: 0,
      s_right: 0,
      top: 0,
      middle: 0,
      bottom: 0,
      s_bottom: 0,
      width: 0,
      height: 0
    }, this.fncLay = () => {
    }, this.mov = void 0, this.div = void 0, this.lx = 0, this.ly = 0, this.rect = Rectangle.EMPTY, this.pivot = new Point(0, 0), this.scale = new Point(1, 1), this.rotation = 0, this.oldFn = () => "", this.rotatable = !0;
  }
  static init(o, t, e, R, N, M, D) {
    o.view.insertAdjacentHTML("beforebegin", `<div id="${__privateGet$2(_DesignCast, _ID_DESIGNMODE)}" style="width: ${CmnLib.stageW * _DesignCast.sys.cvsScale}px; height: ${CmnLib.stageH * t.cvsScale}px; background: rgba(0,0,0,0); position: absolute; touch-action: none; user-select: none; display: none;"></div>`), __privateSet$2(_DesignCast, _divDesignRoot, document.getElementById(__privateGet$2(_DesignCast, _ID_DESIGNMODE))), _DesignCast.divHint.classList.add("sn_design_hint"), o.view.parentElement.appendChild(_DesignCast.divHint), _DesignCast.sys = t, __privateSet$2(_DesignCast, _scrItr, e), _DesignCast.prpPrs = R, __privateSet$2(_DesignCast, _alzTagArg, N), __privateSet$2(_DesignCast, _cfg$1, M), _DesignCast.hPages = D, addStyle(`
.sn_design_cast {
	position: absolute; touch-action: none; user-select: none;
	opacity: 0.6; border-radius: 8px;
}

.sn_design_cast.drag_border {
	line-height: 1.8;
	border: dashed 5px #333;
}

.sn_design_hint {
	position: absolute;
	left: 0;
	top: 0;
	padding: 5px;
	border-radius: 5px;
	background: #333;
	z-index: 10;
	color: #fff;
	font-weight: bold;
	font-size: 12px;
	display: none;
}
`);
  }
  static setHint(o, t, e, R) {
    _DesignCast.divHint.innerHTML = o;
    const N = window.getComputedStyle(_DesignCast.divHint), M = parseFloat(N.width), D = parseFloat(N.height);
    _DesignCast.divHint.style.cssText = `display: block; left: ${Math.max(10, R.lx + t - M)}px;
		top: ${Math.max(10, R.ly + e - D - 10)}px;`;
  }
  static cvsResizeDesign() {
    const o = __privateGet$2(_DesignCast, _divDesignRoot).style;
    o.width = `${CmnLib.stageW * _DesignCast.sys.cvsScale}px`, o.height = `${CmnLib.stageH * _DesignCast.sys.cvsScale}px`;
  }
  destroy() {
    var o;
    this.div = void 0, (o = this.mov) == null || o.destroy(), this.mov = void 0;
  }
  gethArg() {
    return this.hArg;
  }
  sethArg(o) {
    var e, R;
    if (!this.includeDesignArg(o))
      return;
    this.id_tag || (this.id_tag = (e = o[":id_tag"]) != null ? e : ""), this.hArg = o;
    const t = (R = o[":id_dc"]) != null ? R : this.id_tag;
    __privateGet$2(_DesignCast, _hId2dc)[t] = this;
  }
  includeDesignArg(o) {
    for (const t in o)
      if (t in this.hDesignArg)
        return !0;
    return !1;
  }
  getRect() {
    return Rectangle.EMPTY;
  }
  cnvPosArg(o, t) {
    return {};
  }
  cnvSizeArg(o, t) {
    return {};
  }
  setPos(o, t) {
  }
  setSize(o, t) {
  }
  setOther(o) {
  }
  adopt(o) {
    this.child = o, o.parent = this;
  }
  static enterMode() {
    _DesignCast.leaveMode(), __privateGet$2(_DesignCast, _divDesignRoot).style.display = "inline", __privateSet$2(_DesignCast, _cntDesignCast, 0), __privateSet$2(_DesignCast, _hId2dc, {});
  }
  static allHide() {
    __privateGet$2(_DesignCast, _aDC).forEach((o) => o.visible = !1);
  }
  set visible(o) {
    !this.div || !this.mov || (this.div.style.display = o ? "inline" : "none", this.mov.updateTarget());
  }
  static leaveMode() {
    __privateGet$2(_DesignCast, _divDesignRoot).textContent = "", __privateGet$2(_DesignCast, _divDesignRoot).style.display = "none", __privateGet$2(_DesignCast, _aDC).forEach((o) => o.destroy()), __privateSet$2(_DesignCast, _aDC, []);
  }
  cvsResize() {
    var o;
    __privateMethod$2(this, _resizeDiv, resizeDiv_fn).call(this), (o = this.mov) == null || o.updateTarget();
  }
  onDragStart() {
  }
  make() {
    var L, B;
    const o = (L = this.hArg[":id_dc"]) != null ? L : this.id_tag;
    __privateGet$2(_DesignCast, _hId2dc)[o] = this;
    const t = this.div = document.createElement("div");
    t.id = __privateGet$2(_DesignCast, _ID_DESIGNMODE) + "_" + ++__privateWrapper(_DesignCast, _cntDesignCast)._, t.classList.add("sn_design_cast"), t.dataset.id_dc = o, t.style.backgroundColor = `${this.bg_col}`, t.style.display = "none", this.rect = this.getRect(), __privateMethod$2(this, _resizeDiv, resizeDiv_fn).call(this), (this.parent && (B = document.querySelector(
      `[data-id_dc="${this.parent.id_tag}"]`
    )) != null ? B : __privateGet$2(_DesignCast, _divDesignRoot)).appendChild(t);
    const e = {
      aPos: [0, 0],
      roDeg: 0,
      trOrg: "",
      origin: [0, 0]
    }, R = () => {
      e.aPos = [NaN, NaN], e.roDeg = this.rotation;
      const $ = this.pivot.x * _DesignCast.sys.cvsScale, U = this.pivot.y * _DesignCast.sys.cvsScale;
      e.trOrg = `${$}px ${U}px`, e.origin = [$, U], Object.assign(this.mov, {
        verticalGuidelines: [],
        horizontalGuidelines: []
      });
    }, N = ($) => {
      _DesignCast.sys.send2Dbg("_changeCast", {
        ...$,
        ":id_tag": this.id_tag
      }), _DesignCast.divHint.style.display = "none";
    }, M = () => {
      const [$, U] = e.aPos;
      if (isNaN($)) {
        _DesignCast.divHint.style.display = "none";
        return;
      }
      const H = int(this.rect.x += $ / _DesignCast.sys.cvsScale + this.pivot.x), z = int(this.rect.y += U / _DesignCast.sys.cvsScale + this.pivot.y);
      this.setPos(H, z);
      const X = uint(this.rect.width), Y = uint(this.rect.height);
      this.setSize(X, Y), N({
        ...this.cnvPosArg(H, z),
        ...this.cnvSizeArg(X, Y)
      });
    };
    let D;
    this.mov = new Moveable(document.body, {
      target: t,
      draggable: !0,
      resizable: !0,
      rotatable: this.rotatable,
      originDraggable: this.rotatable,
      snappable: !0
    }).on("dragStart", ($) => {
      var H;
      R(), this.onDragStart();
      const U = (H = this.child) == null ? void 0 : H.mov;
      U && (D = U.target, U.isInside($.clientX, $.clientY) && (U.target = void 0));
    }).on("drag", ($) => {
      e.aPos = $.beforeTranslate, this.procDragHint($, $.left, $.top);
    }).on("dragEnd", () => {
      var $, U;
      M(), ($ = this.child) != null && $.mov && (this.child.mov.target = D), (U = this.parent) != null && U.mov && (this.parent.mov.target = this.parent.div);
    }).on("resizeStart", R).on("resize", ($) => {
      t.style.width = `${$.width}px`, t.style.height = `${$.height}px`, e.aPos = $.drag.beforeTranslate, this.rect.width = $.width / _DesignCast.sys.cvsScale, this.rect.height = $.height / _DesignCast.sys.cvsScale, this.procResizeHint($, $.drag.left, $.drag.top);
    }).on("resizeEnd", M).on("rotateStart", ($) => {
      R(), $.set(e.roDeg);
    }).on("rotate", ($) => {
      e.roDeg = $.beforeRotate, _DesignCast.setHint(int(e.roDeg) + "\u5EA6", $.drag.left, $.drag.top, this);
    }).on("rotateEnd", () => {
      this.rotation = e.roDeg, this.setOther({}), N({ rotation: int(e.roDeg) });
    }).on("dragOriginStart", () => R).on("dragOrigin", ($) => {
      e.trOrg = $.transformOrigin, e.origin = $.origin;
    }).on("dragOriginEnd", () => {
      const [$, U] = e.origin;
      e.trOrg = `${$}px ${U}px`;
      const H = this.pivot.x = $ / _DesignCast.sys.cvsScale, z = this.pivot.y = U / _DesignCast.sys.cvsScale;
      this.setOther({});
      const X = int(this.rect.x + H), Y = int(this.rect.y + z);
      this.setPos(X, Y), N({
        ...this.cnvPosArg(X, Y),
        pivot_x: int(H),
        pivot_y: int(z)
      });
    }).on("render", () => {
      const { aPos: $, roDeg: U, trOrg: H } = e;
      t.style.transformOrigin = H, t.style.transform = `translate(${$[0]}px, ${$[1]}px) rotate(${U}deg)`;
    }), __privateGet$2(_DesignCast, _aDC).push(this), t.addEventListener("dragenter", () => t.classList.add("drag_border")), t.addEventListener("dragover", ($) => {
      $.stopPropagation(), $.preventDefault(), $.dataTransfer && ($.dataTransfer.dropEffect = "copy");
    }), t.addEventListener("dragleave", () => t.classList.remove("drag_border")), t.addEventListener("drop", ($) => {
      $.stopPropagation(), $.preventDefault(), t.classList.remove("drag_border");
      const U = $.dataTransfer;
      if (!U || U.files.length === 0)
        return;
      const H = U.files[0], z = {
        ":id_tag": this.id_tag,
        fn: getFn(H.name),
        ext: getExt(H.name),
        url: "",
        buf: new ArrayBuffer(0),
        old_fn: this.oldFn(),
        old_url: __privateGet$2(_DesignCast, _cfg$1).searchPath(this.oldFn(), Config.EXT_SPRITE)
      };
      H.arrayBuffer().then((X) => {
        z.buf = X;
        try {
          z.url = __privateGet$2(_DesignCast, _scrItr).cnvPath4Dbg(
            __privateGet$2(_DesignCast, _cfg$1).searchPath(H.name, Config.EXT_SPRITE)
          );
        } catch {
        }
        _DesignCast.sys.send2Dbg("_dropFile", z);
      }).catch((X) => console.error("drop2dc %o", X));
    }), t.addEventListener("dblclick", ($) => {
      $.preventDefault(), _DesignCast.sys.send2Dbg("_focusScript", this.hArg);
    });
  }
  procDragHint(o, t, e) {
    const [R, N] = o.beforeTranslate;
    _DesignCast.setHint(
      `(${int(this.rect.x + R / _DesignCast.sys.cvsScale)}, ${int(this.rect.y + N / _DesignCast.sys.cvsScale)})`,
      t,
      e,
      this
    );
  }
  procResizeHint(o, t, e) {
    _DesignCast.setHint(
      `(${int(o.drag.left)}, ${int(o.drag.top)})<br/>${int(this.rect.width)} x ${int(this.rect.height)}`,
      t,
      e,
      this
    );
  }
  static replaceToken(o) {
    var $, U, H, z, X, Y, W, q, Z, K, J;
    const e = o[":id_tag"], R = __privateGet$2(_DesignCast, _hId2dc)[e];
    if (!document.querySelector(`div[data-id_dc='${e}']`) || !R)
      return;
    const M = o[":token"];
    __privateGet$2(_DesignCast, _scrItr).replace(o[":idx_tkn"], M);
    const [D, L] = tagToken2Name_Args(M);
    R.child && (R.child.hArg[":token"] = R.hArg[":token"]), __privateGet$2(_DesignCast, _alzTagArg).go(L);
    const B = __privateGet$2(_DesignCast, _alzTagArg).hPrm;
    if ("pivot_x" in B || "pivot_y" in B) {
      const Q = Number(_DesignCast.prpPrs.getValAmpersand(($ = B.pivot_x.val) != null ? $ : "0")), et = Number(_DesignCast.prpPrs.getValAmpersand((U = B.pivot_y.val) != null ? U : "0"));
      (isNaN(Q) || isNaN(et)) && DebugMng.myTrace(`pivot_x\u304Bpivot_y\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093
(fn:${o[":path"].slice(13)} ln:${o[":ln"]})
${M}`, "F"), R.pivot.set(Q, et);
    }
    if ("left" in B || "top" in B || "x" in B || "y" in B) {
      const Q = int(_DesignCast.prpPrs.getValAmpersand((z = (H = B.left.val) != null ? H : B.x.val) != null ? z : "0")), et = int(_DesignCast.prpPrs.getValAmpersand((Y = (X = B.top.val) != null ? X : B.y.val) != null ? Y : "0"));
      (isNaN(Q) || isNaN(et)) && DebugMng.myTrace(`width\u304Bheight\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093
(fn:${o[":path"].slice(13)} ln:${o[":ln"]})
${M}`, "F"), R.rect.x = Q - R.pivot.x, R.rect.y = et - R.pivot.y, R.setPos(Q, et);
    }
    if ("width" in B || "height" in B) {
      const Q = int(_DesignCast.prpPrs.getValAmpersand((W = B.width.val) != null ? W : "0")), et = int(_DesignCast.prpPrs.getValAmpersand((q = B.height.val) != null ? q : "0"));
      (isNaN(Q) || isNaN(et)) && DebugMng.myTrace(`width\u304Bheight\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093
(fn:${o[":path"].slice(13)} ln:${o[":ln"]})
${M}`, "F"), R.rect.width = Q, R.rect.height = et, R.setSize(Q, et);
    }
    if ("scale_x" in B || "scale_y" in B) {
      const Q = Number(_DesignCast.prpPrs.getValAmpersand((Z = B.scale_x.val) != null ? Z : "0")), et = Number(_DesignCast.prpPrs.getValAmpersand((K = B.scale_y.val) != null ? K : "0"));
      (isNaN(Q) || isNaN(et)) && DebugMng.myTrace(`scale_x\u304Bscale_y\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093
(fn:${o[":path"].slice(13)} ln:${o[":ln"]})
${M}`, "F"), R.scale.set(Q, et);
    }
    if ("rotation" in B) {
      const Q = Number(_DesignCast.prpPrs.getValAmpersand((J = B.rotation.val) != null ? J : "0"));
      isNaN(Q) && DebugMng.myTrace(`rotation\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093
(fn:${o[":path"].slice(13)} ln:${o[":ln"]})
${M}`, "F"), R.rotation = Q;
    }
    R.setOther(B), R.cvsResize();
  }
};
let DesignCast = _DesignCast;
_divDesignRoot = /* @__PURE__ */ new WeakMap();
_scrItr = /* @__PURE__ */ new WeakMap();
_alzTagArg = /* @__PURE__ */ new WeakMap();
_cfg$1 = /* @__PURE__ */ new WeakMap();
_ID_DESIGNMODE = /* @__PURE__ */ new WeakMap();
_cntDesignCast = /* @__PURE__ */ new WeakMap();
_hId2dc = /* @__PURE__ */ new WeakMap();
_aDC = /* @__PURE__ */ new WeakMap();
_resizeDiv = /* @__PURE__ */ new WeakSet();
resizeDiv_fn = function() {
  this.fncLay(), this.div && Object.assign(this.div.style, {
    left: `${this.lx + this.rect.x * _DesignCast.sys.cvsScale}px`,
    top: `${this.ly + this.rect.y * _DesignCast.sys.cvsScale}px`,
    width: `${this.rect.width * _DesignCast.sys.cvsScale}px`,
    height: `${this.rect.height * _DesignCast.sys.cvsScale}px`,
    transformOrigin: `${this.pivot.x * _DesignCast.sys.cvsScale}px ${this.pivot.y * _DesignCast.sys.cvsScale}px`,
    transform: `scale(${this.scale.x}, ${this.scale.y}) rotate(${this.rotation}deg)`
  });
};
__privateAdd$2(DesignCast, _divDesignRoot, void 0);
__privateAdd$2(DesignCast, _scrItr, void 0);
__privateAdd$2(DesignCast, _alzTagArg, void 0);
__privateAdd$2(DesignCast, _cfg$1, void 0);
DesignCast.divHint = document.createElement("div");
__privateAdd$2(DesignCast, _ID_DESIGNMODE, "DesignMode");
__privateAdd$2(DesignCast, _cntDesignCast, 0);
__privateAdd$2(DesignCast, _hId2dc, {});
__privateAdd$2(DesignCast, _aDC, []);
var Si;
class GrpLayDesignCast extends DesignCast {
  constructor(e, R) {
    super("#29e", !0);
    nt(this, Si, void 0);
    this.spLay = e, this.gl = R, this.oldFn = () => {
      var N;
      return (N = this.hArg.fn) != null ? N : "";
    };
  }
  setSp(e) {
    it(this, Si, e);
  }
  getRect() {
    var e, R, N, M;
    return new Rectangle(this.spLay.x, this.spLay.y, (R = (e = V(this, Si)) == null ? void 0 : e.width) != null ? R : 0, (M = (N = V(this, Si)) == null ? void 0 : N.height) != null ? M : 0);
  }
  cnvPosArg(e, R) {
    return { left: e, top: R };
  }
  cnvSizeArg(e, R) {
    return { width: e, height: R };
  }
  setPos(e, R) {
    this.spLay.x = e, this.spLay.y = R;
  }
  setSize(e, R) {
    V(this, Si).width = e, V(this, Si).height = R;
  }
  setOther(e) {
    var R;
    if ("fn" in e) {
      const N = DesignCast.prpPrs.getValAmpersand((R = e.fn.val) != null ? R : "");
      this.gl.lay({ fn: N });
    }
    this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;
  }
}
Si = new WeakMap();
class TxtLayDesignCast extends DesignCast {
  constructor(t, e) {
    super("#29e", !0), this.spLay = t, this.ts = e, this.hDesignArg = {
      rotation: 0,
      pivot_x: 0,
      pivot_y: 0,
      left: 0,
      center: 0,
      right: 0,
      s_right: 0,
      top: 0,
      middle: 0,
      bottom: 0,
      s_bottom: 0,
      width: 0,
      height: 0,
      pl: 0,
      pr: 0,
      pt: 0,
      pb: 0
    };
  }
  getRect() {
    const t = this.ts.infTL;
    return new Rectangle(this.spLay.x, this.spLay.y, t.$width, t.$height);
  }
  cnvPosArg(t, e) {
    return { left: t, top: e };
  }
  cnvSizeArg(t, e) {
    return { width: t, height: e };
  }
  setPos(t, e) {
    this.spLay.position.set(t, e), this.ts.lay(this.cnvPosArg(t, e));
  }
  setSize(t, e) {
    this.ts.lay(this.cnvSizeArg(t, e));
  }
  setOther(t) {
    var e;
    (e = this.child) == null || e.setOther(t), this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;
  }
}
var Ya, _h;
class TxtLayPadDesignCast extends DesignCast {
  constructor(e) {
    super("#9e2");
    nt(this, Ya);
    this.ts = e, this.rotatable = !1;
  }
  getRect() {
    const e = this.ts.infTL;
    return new Rectangle(
      e.pad_left,
      e.pad_top,
      e.$width - e.pad_left - e.pad_right,
      e.$height - e.pad_top - e.pad_bottom
    );
  }
  cnvPosArg(e, R) {
    return { pl: e, pt: R };
  }
  cnvSizeArg(e, R) {
    const N = this.ts.infTL;
    return {
      pr: N.$width - N.pad_left - e,
      pb: N.$height - N.pad_top - R
    };
  }
  setPos(e, R) {
    this.ts.lay(this.cnvPosArg(e, R));
  }
  setSize(e, R) {
    this.ts.lay({ ...this.cnvSizeArg(e, R), ":redraw": !0 });
  }
  setOther(e) {
    var N, M, D, L, B, $, U, H;
    const R = this.ts.infTL;
    if (("pl" in e || "pt" in e) && (this.setPos(
      this.rect.x = parseFloat(DesignCast.prpPrs.getValAmpersand(
        (M = (N = e.pl) == null ? void 0 : N.val) != null ? M : `${R.pad_left}`
      )),
      this.rect.y = parseFloat(DesignCast.prpPrs.getValAmpersand(
        (L = (D = e.pt) == null ? void 0 : D.val) != null ? L : `${R.pad_top}`
      ))
    ), this.cvsResize()), "pr" in e || "pb" in e) {
      this.ts.lay({
        pr: parseFloat(DesignCast.prpPrs.getValAmpersand(
          ($ = (B = e.pr) == null ? void 0 : B.val) != null ? $ : `${R.pad_right}`
        )),
        pb: parseFloat(DesignCast.prpPrs.getValAmpersand(
          (H = (U = e.pb) == null ? void 0 : U.val) != null ? H : `${R.pad_bottom}`
        ))
      });
      const z = this.getRect();
      this.setSize(
        this.rect.width = z.width,
        this.rect.height = z.height
      ), this.cvsResize();
    }
  }
  procDragHint(e, R, N) {
    const [M, D] = e.beforeTranslate;
    ot(this, Ya, _h).call(this, R, N, M, D);
  }
  procResizeHint(e, R, N) {
    const [M, D] = e.drag.beforeTranslate;
    ot(this, Ya, _h).call(this, R, N, M, D);
  }
}
Ya = new WeakSet(), _h = function(e, R, N, M) {
  const D = this.rect.x, L = this.rect.y, B = this.rect.width, $ = this.rect.height, U = this.ts.infTL, H = int(D + N / DesignCast.sys.cvsScale), z = int(L + M / DesignCast.sys.cvsScale), X = int(U.$width - H - B), Y = int(U.$height - z - $), W = (q) => "&nbsp;".repeat(q);
  DesignCast.setHint(
    W(5 + 5 + 1) + `\u4E0A\u5E45=${z}<br/>
			\u5DE6\u5E45=${H + W(1 + 3 + 5 + 1)}\u53F3\u5E45=${X}<br/>` + W(5) + `\u5185\u5074 ${int(B)} x ${int($)}<br/>` + W(5 + 5) + `\u4E0B\u5E45=${Y}`,
    e,
    R,
    this
  );
};
class BtnDesignCast extends DesignCast {
  constructor(t, e) {
    super("#e92"), this.btn = t, this.hArg = e, this.pivot.x = argChk_Num(e, "pivot_x", this.pivot.x), this.pivot.y = argChk_Num(e, "pivot_y", this.pivot.y), this.scale.x = argChk_Num(e, "scale_x", this.scale.x), this.scale.y = argChk_Num(e, "scale_y", this.scale.y), this.rotation = argChk_Num(e, "rotation", this.rotation), this.sethArg(e);
  }
  sethArg(t) {
    var R;
    super.sethArg(t);
    const e = (R = this.hArg.layer) != null ? R : "";
    this.fncLay = !this.parent && !this.child && e ? () => {
      const N = DesignCast.hPages[e].fore;
      this.lx = N.x * DesignCast.sys.cvsScale, this.ly = N.y * DesignCast.sys.cvsScale;
    } : () => {
    };
  }
  cnvPosArg(t, e) {
    return { left: t, top: e };
  }
  cnvSizeArg(t, e) {
    return { width: t, height: e };
  }
  setPos(t, e) {
    this.btn.x = t, this.btn.y = e;
  }
  setOther(t) {
    this.btn.pivot.copyFrom(this.pivot), this.btn.scale.copyFrom(this.scale), this.btn.angle = this.rotation;
  }
  onDragStart() {
    const t = this.btn.parent.children.filter((e) => e !== this.btn);
    Object.assign(this.mov, {
      verticalGuidelines: t.map((e) => this.lx + e.x * DesignCast.sys.cvsScale),
      horizontalGuidelines: t.map((e) => this.ly + e.y * DesignCast.sys.cvsScale)
    });
  }
}
class TxtBtnDesignCast extends BtnDesignCast {
  constructor(t, e, R) {
    super(t, e), this.txt = R, this.oldFn = () => {
      var N;
      return (N = this.hArg.b_pic) != null ? N : "";
    }, argChk_Boolean(e, "design", !0) || (this.setPos = () => {
    }, this.setSize = () => {
    });
  }
  getRect() {
    return new Rectangle(this.btn.x, this.btn.y, this.txt.width, this.txt.height);
  }
  setSize(t, e) {
    this.txt.width = t, this.txt.height = e;
  }
  setOther(t) {
    var e;
    if (super.setOther(t), "b_pic" in t) {
      const R = DesignCast.prpPrs.getValAmpersand((e = t.b_pic.val) != null ? e : "");
      this.btn.update_b_pic(R, this.txt);
    }
  }
}
var qr;
class PicBtnDesignCast extends BtnDesignCast {
  constructor(e, R) {
    super(e, R);
    nt(this, qr, void 0);
    this.oldFn = () => {
      var N;
      return (N = this.hArg.pic) != null ? N : "";
    };
  }
  setSp(e) {
    it(this, qr, e);
  }
  getRect() {
    return new Rectangle(this.btn.x, this.btn.y, V(this, qr).width, V(this, qr).height);
  }
  setSize(e, R) {
    V(this, qr).width = e, V(this, qr).height = R;
  }
  setOther(e) {
    var R;
    if (super.setOther(e), "pic" in e) {
      const N = DesignCast.prpPrs.getValAmpersand((R = e.pic.val) != null ? R : "");
      this.btn.update_pic(N, V(this, qr));
    }
  }
}
qr = new WeakMap();
var __accessCheck$1 = (o, t, e) => {
  if (!t.has(o))
    throw TypeError("Cannot " + e);
}, __privateGet$1 = (o, t, e) => (__accessCheck$1(o, t, "read from private field"), e ? e.call(o) : t.get(o)), __privateAdd$1 = (o, t, e) => {
  if (t.has(o))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(o) : t.set(o, e);
}, __privateSet$1 = (o, t, e, R) => (__accessCheck$1(o, t, "write to private field"), R ? R.call(o, e) : t.set(o, e), e), __privateMethod$1 = (o, t, e) => (__accessCheck$1(o, t, "access private method"), e), _elc, _hFace, _main, _cfg, _appPixi, _sys, _val, _glbVol, _movVol, _evtMng, _idc$1, _csvFn, _sBkFn, _sBkFace, _width, _height, _dec2cache, _sortAFrameName, sortAFrameName_fn, _dec2cache4Cripto, dec2cache4Cripto_fn, _charmVideoElm, charmVideoElm_fn, _mkSprite, mkSprite_fn, _rtTsy, _spTsy, _fncRender, _hAEncImg, _hEncImgOUrl;
const _GrpLayer = class extends Layer {
  constructor() {
    super(), __privateAdd$1(this, _idc$1, new GrpLayDesignCast(this.spLay, this)), __privateAdd$1(this, _csvFn, ""), __privateAdd$1(this, _sBkFn, ""), __privateAdd$1(this, _sBkFace, ""), this.lay = (o) => this.laySub(o, (t) => {
      t && __privateGet$1(_GrpLayer, _main).resume();
    }), __privateAdd$1(this, _width, 0), __privateAdd$1(this, _height, 0), __privateAdd$1(this, _rtTsy, void 0), __privateAdd$1(this, _spTsy, void 0), __privateAdd$1(this, _fncRender, () => {
    }), this.record = () => ({
      ...super.record(),
      sBkFn: __privateGet$1(this, _sBkFn),
      sBkFace: __privateGet$1(this, _sBkFace),
      idc_hArg: __privateGet$1(this, _idc$1).gethArg()
    }), this.dump = () => super.dump() + `, "pic":"${__privateGet$1(this, _csvFn)}"`, CmnLib.isDbg && (this.setSp = (o) => __privateGet$1(this, _idc$1).setSp(o), this.cvsResize = () => {
      super.cvsResize(), __privateGet$1(this, _idc$1).cvsResize();
    });
  }
  static init(o, t, e, R, N, M) {
    __privateSet$1(_GrpLayer, _main, o), __privateSet$1(_GrpLayer, _cfg, t), __privateSet$1(_GrpLayer, _appPixi, e), __privateSet$1(_GrpLayer, _sys, R), __privateSet$1(_GrpLayer, _val, M);
    const D = () => {
      const L = __privateGet$1(_GrpLayer, _glbVol) * __privateGet$1(_GrpLayer, _movVol);
      for (const B in _GrpLayer.hFn2VElm)
        _GrpLayer.hFn2VElm[B].volume = L;
    };
    N.setNoticeChgVolume(
      (L) => {
        __privateSet$1(_GrpLayer, _glbVol, L), D();
      },
      (L) => {
        __privateSet$1(_GrpLayer, _movVol, L), D();
      }
    ), __privateGet$1(_GrpLayer, _sys).crypto && __privateSet$1(_GrpLayer, _dec2cache, __privateMethod$1(_GrpLayer, _dec2cache4Cripto, dec2cache4Cripto_fn));
  }
  static setEvtMng(o) {
    __privateSet$1(_GrpLayer, _evtMng, o);
  }
  static destroy() {
    __privateGet$1(_GrpLayer, _elc).clear(), __privateSet$1(_GrpLayer, _hFace, {}), _GrpLayer.hFn2ResAniSpr = {}, _GrpLayer.hFn2VElm = {};
  }
  setSp(o) {
  }
  laySub(o, t) {
    const { fn: e, face: R = "" } = o;
    if (__privateGet$1(this, _idc$1).sethArg(o), !e)
      return super.lay(o), this.spLay.children.length > 0 && this.setPos(o), __privateSet$1(this, _sBkFn, ""), __privateSet$1(this, _csvFn, __privateSet$1(this, _sBkFace, R)), t(!1), !1;
    const N = "fn" in o, M = "face" in o;
    return this.clearLay({ filter: "true" }), N && __privateSet$1(this, _sBkFn, e), M && __privateSet$1(this, _sBkFace, R), super.lay(o), o.dx = 0, o.dy = 0, _GrpLayer.csv2Sprites(
      __privateSet$1(this, _csvFn, e + (R ? "," + R : "")),
      this.spLay,
      (D) => {
        ("width" in o || "height" in o) && (D.width = argChk_Num(o, "width", 0), D.height = argChk_Num(o, "height", 0)), __privateSet$1(this, _width, D.width), __privateSet$1(this, _height, D.height), Layer.setXY(D, o, this.spLay, !0), this.setSp(D);
      },
      (D) => {
        Layer.setBlendmode(this.spLay, o), t(D);
      }
    );
  }
  get width() {
    return __privateGet$1(this, _width);
  }
  get height() {
    return __privateGet$1(this, _height);
  }
  static csv2Sprites(o, t, e, R = () => {
  }) {
    let N = !1;
    if (o.slice(0, 5) === "data:") {
      const B = () => {
        const $ = Sprite.from(o);
        t == null || t.addChild($), e($), R(N);
      };
      return o in TextureCache ? B() : (N = !0, new Loader().add(o, o).load(B)), N;
    }
    const M = [], D = new Loader();
    o.split(",").forEach((B, $) => {
      if (!B)
        throw "face\u5C5E\u6027\u306B\u7A7A\u8981\u7D20\u304C\u542B\u307E\u308C\u307E\u3059";
      const U = __privateGet$1(_GrpLayer, _hFace)[B] || {
        fn: B,
        dx: 0,
        dy: 0,
        blendmode: BLEND_MODES$5.NORMAL
      }, H = $ === 0 ? e : (Y) => {
        Y.x = U.dx, Y.y = U.dy, Y.blendMode = U.blendmode;
      };
      if (M.push({ fn: U.fn, fnc: H }), U.fn in _GrpLayer.hFn2ResAniSpr || U.fn in TextureCache || U.fn in Loader.shared.resources)
        return;
      N = !0;
      const z = __privateGet$1(_GrpLayer, _cfg).searchPath(U.fn, Config.EXT_SPRITE), X = __privateGet$1(this, _sys).crypto ? { xhrType: z.slice(-5) === ".json" ? LoaderResource.XHR_RESPONSE_TYPE.TEXT : LoaderResource.XHR_RESPONSE_TYPE.BUFFER } : {};
      D.add({ ...X, name: U.fn, url: z });
    });
    const L = (B) => {
      var $;
      for (const U of M) {
        const H = __privateMethod$1($ = _GrpLayer, _mkSprite, mkSprite_fn).call($, U.fn, B);
        H.name = U.fn, t == null || t.addChild(H), U.fnc(H);
      }
      R(N);
    };
    return N ? D.use((B, $) => {
      __privateGet$1(this, _sys).dec(B.extension, B.data).then((U) => {
        var H;
        return __privateGet$1(H = _GrpLayer, _dec2cache).call(H, U, B, () => $ == null ? void 0 : $());
      }).catch((U) => __privateGet$1(this, _main).errScript(`Graphic \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 fn:${B.name} ${U}`, !1));
    }).load((B, $) => L($)) : L({}), N;
  }
  static wv(o) {
    const { fn: t } = o;
    if (!t)
      throw "fn\u306F\u5FC5\u9808\u3067\u3059";
    const e = _GrpLayer.hFn2VElm[t];
    if (!e || e.loop)
      return !1;
    if (e.ended)
      return delete _GrpLayer.hFn2VElm[t], !1;
    const R = () => {
      e.removeEventListener("ended", R), delete _GrpLayer.hFn2VElm[t], __privateGet$1(this, _main).resume();
    };
    return e.addEventListener("ended", R, { once: !0, passive: !0 }), __privateGet$1(_GrpLayer, _evtMng).waitEvent(
      () => {
        e.pause(), R();
      },
      argChk_Boolean(o, "canskip", !0),
      argChk_Boolean(o, "global", !1)
    );
  }
  renderStart() {
    __privateSet$1(this, _rtTsy, RenderTexture.create({
      width: CmnLib.stageW,
      height: CmnLib.stageH
    })), __privateSet$1(this, _spTsy, new Sprite(__privateGet$1(this, _rtTsy))), __privateGet$1(this, _spTsy).visible = !1, this.spLay.addChildAt(__privateGet$1(this, _spTsy), 0), __privateGet$1(this, _spTsy).position.set(-this.spLay.x, -this.spLay.y);
    let o = () => {
      const t = this.spLay.alpha;
      this.spLay.alpha = 1, this.spLay.children.forEach((e) => e.visible = !0), __privateGet$1(this, _spTsy).visible = !1, __privateGet$1(_GrpLayer, _appPixi).renderer.render(this.spLay, { renderTexture: __privateGet$1(this, _rtTsy) }), this.spLay.alpha = t, this.spLay.children.forEach((e) => e.visible = !1);
    };
    if (!this.containMovement) {
      let t = o;
      o = () => {
        o = () => {
        }, t();
      };
    }
    __privateSet$1(this, _fncRender, () => {
      o(), __privateGet$1(this, _spTsy).visible = !0;
    }), __privateGet$1(_GrpLayer, _appPixi).ticker.add(__privateGet$1(this, _fncRender));
  }
  renderEnd() {
    __privateGet$1(_GrpLayer, _appPixi).ticker.remove(__privateGet$1(this, _fncRender)), this.spLay.removeChild(__privateGet$1(this, _spTsy)), this.spLay.children.forEach((o) => o.visible = !0), __privateGet$1(this, _spTsy).destroy(!0);
  }
  static loadPic2Img(o, t, e) {
    const R = __privateGet$1(this, _hEncImgOUrl)[o];
    if (R) {
      t.src = R;
      return;
    }
    const N = __privateGet$1(this, _hAEncImg)[o];
    if (N) {
      N.push(t);
      return;
    }
    __privateGet$1(this, _hAEncImg)[o] = [t];
    const M = __privateGet$1(_GrpLayer, _cfg).searchPath(o, Config.EXT_SPRITE), D = new Loader().add({ name: o, url: M, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER });
    __privateGet$1(_GrpLayer, _sys).crypto && D.use((L, B) => {
      __privateGet$1(_GrpLayer, _sys).dec(L.extension, L.data).then(($) => {
        if (L.extension !== "bin") {
          B == null || B();
          return;
        }
        L.data = $, $ instanceof HTMLImageElement && (L.type = LoaderResource.TYPE.IMAGE), B == null || B();
      }).catch(($) => __privateGet$1(_GrpLayer, _main).errScript(`GrpLayer loadPic \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 fn:${L.name} ${$}`, !1));
    }), D.load((L, B) => {
      for (const $ in B) {
        const U = __privateGet$1(this, _hEncImgOUrl)[$] = B[$].data.src;
        __privateGet$1(this, _hAEncImg)[$].forEach((H) => {
          H.src = U, e && (H.onload = () => e(H));
        }), delete __privateGet$1(this, _hAEncImg)[$];
      }
    });
  }
  setPos(o) {
    Layer.setXY(
      this.spLay.children.length === 0 ? this.spLay : this.spLay.children[0],
      o,
      this.spLay,
      !0
    );
  }
  static add_face(o) {
    const { name: t } = o;
    if (!t)
      throw "name\u306F\u5FC5\u9808\u3067\u3059";
    if (t in __privateGet$1(_GrpLayer, _hFace))
      throw "\u4E00\u3064\u306Ename\uFF08" + t + "\uFF09\u306B\u5BFE\u3057\u3066\u540C\u3058\u753B\u50CF\u3092\u8907\u6570\u5272\u308A\u5F53\u3066\u3089\u308C\u307E\u305B\u3093";
    const { fn: e = t } = o;
    return __privateGet$1(_GrpLayer, _hFace)[t] = {
      fn: e,
      dx: argChk_Num(o, "dx", 0),
      dy: argChk_Num(o, "dy", 0),
      blendmode: Layer.getBlendmodeNum(o.blendmode || "")
    }, !1;
  }
  static clearFace2Name() {
    __privateSet$1(_GrpLayer, _hFace, {});
  }
  get containMovement() {
    if (__privateGet$1(this, _csvFn) === "")
      return !1;
    const o = this.spLay.children;
    return __privateGet$1(this, _csvFn).split(",").some(
      (t, e) => o[e] instanceof AnimatedSprite || _GrpLayer.hFn2VElm[t]
    );
  }
  clearLay(o) {
    super.clearLay(o);
    for (const t of this.spLay.removeChildren())
      t.destroy();
    __privateSet$1(this, _sBkFn, ""), __privateSet$1(this, _sBkFace, ""), __privateSet$1(this, _csvFn, "");
  }
  playback(o, t) {
    if (super.playback(o, t), o.sBkFn === "" && o.sBkFace === "") {
      __privateSet$1(this, _sBkFn, o.sBkFn), __privateSet$1(this, _sBkFace, o.sBkFace), __privateGet$1(this, _idc$1).sethArg(o.idc_hArg);
      return;
    }
    t.push(new Promise((e) => this.laySub(
      { fn: o.sBkFn, face: o.sBkFace, left: o.x, top: o.y, alpha: o.alpha, blendmode: Layer.getNum2Blendmode(o.blendMode), rotation: o.rotation, scale_x: o.scale_x, scale_y: o.scale_y },
      (R) => {
        this.spLay.position.set(o.x, o.y), e();
      }
    )));
  }
  makeDesignCast(o) {
    !this.spLay.visible || o(__privateGet$1(this, _idc$1));
  }
  cvsResize() {
    super.cvsResize();
  }
  showDesignCast() {
    __privateGet$1(this, _idc$1).visible = !0;
  }
};
let GrpLayer = _GrpLayer;
_elc = /* @__PURE__ */ new WeakMap();
_hFace = /* @__PURE__ */ new WeakMap();
_main = /* @__PURE__ */ new WeakMap();
_cfg = /* @__PURE__ */ new WeakMap();
_appPixi = /* @__PURE__ */ new WeakMap();
_sys = /* @__PURE__ */ new WeakMap();
_val = /* @__PURE__ */ new WeakMap();
_glbVol = /* @__PURE__ */ new WeakMap();
_movVol = /* @__PURE__ */ new WeakMap();
_evtMng = /* @__PURE__ */ new WeakMap();
_idc$1 = /* @__PURE__ */ new WeakMap();
_csvFn = /* @__PURE__ */ new WeakMap();
_sBkFn = /* @__PURE__ */ new WeakMap();
_sBkFace = /* @__PURE__ */ new WeakMap();
_width = /* @__PURE__ */ new WeakMap();
_height = /* @__PURE__ */ new WeakMap();
_dec2cache = /* @__PURE__ */ new WeakMap();
_sortAFrameName = /* @__PURE__ */ new WeakSet();
sortAFrameName_fn = function(o) {
  const t = /([^\d]+)\d+\.(\w+)/.exec(o[0]);
  if (!t)
    return;
  const e = t[1].length, R = -t[2].length - 1;
  o.sort(
    (N, M) => int(N.slice(e, R)) > int(M.slice(e, R)) ? 1 : -1
  );
};
_dec2cache4Cripto = /* @__PURE__ */ new WeakSet();
dec2cache4Cripto_fn = function(o, t, e) {
  var L;
  var R;
  if (t.data = o, t.extension === "bin" && (o instanceof HTMLImageElement ? (t.texture = Texture.fromLoader(o, t.url, t.name), t.type = LoaderResource.TYPE.IMAGE, URL.revokeObjectURL(o.src)) : o instanceof HTMLVideoElement && (o.volume = __privateGet$1(_GrpLayer, _glbVol), _GrpLayer.hFn2VElm[t.name] = __privateMethod$1(R = _GrpLayer, _charmVideoElm, charmVideoElm_fn).call(R, o), t.type = LoaderResource.TYPE.VIDEO, URL.revokeObjectURL(o.src))), t.extension !== "json") {
    e();
    return;
  }
  if (typeof o != "string") {
    e();
    return;
  }
  const N = t.data = JSON.parse(o);
  if (t.type = LoaderResource.TYPE.JSON, !((L = N.meta) != null && L.image)) {
    e();
    return;
  }
  const M = getFn(N.meta.image), D = __privateGet$1(_GrpLayer, _cfg).searchPath(M, Config.EXT_SPRITE);
  new Loader().use((B, $) => {
    __privateGet$1(this, _sys).dec(B.extension, B.data).then((U) => {
      B.data = U, U instanceof HTMLImageElement && (B.type = LoaderResource.TYPE.IMAGE, URL.revokeObjectURL(U.src)), $ == null || $();
    }).catch((U) => __privateGet$1(this, _main).errScript(`Graphic \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 dec2res4Cripto fn:${B.name} ${U}`, !1));
  }).add({ name: M, url: D, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).load((B, $) => {
    var U;
    for (const H in B.resources) {
      const z = Texture.from(B.resources[H].data).baseTexture, X = Object.values(N.frames);
      __privateMethod$1(U = _GrpLayer, _sortAFrameName, sortAFrameName_fn).call(U, X), _GrpLayer.hFn2ResAniSpr[t.name] = {
        aTex: X.map((Y) => new Texture(
          z,
          new Rectangle(
            Y.frame.x,
            Y.frame.y,
            Y.frame.w,
            Y.frame.h
          )
        )),
        meta: N.meta
      };
    }
    e();
  });
};
_charmVideoElm = /* @__PURE__ */ new WeakSet();
charmVideoElm_fn = function(o) {
  return __privateGet$1(_GrpLayer, _val).getVal("const.sn.needClick2Play") && (DebugMng.trace_beforeNew(`[lay\u7CFB] ${DebugMng.strPos()}\u672A\u30AF\u30EA\u30C3\u30AF\u72B6\u614B\u3067\u52D5\u753B\u3092\u81EA\u52D5\u518D\u751F\u3057\u307E\u3059\u3002\u97F3\u58F0\u306F\u30DF\u30E5\u30FC\u30C8\u3055\u308C\u307E\u3059`, "W"), o.muted = !0), o.setAttribute("playsinline", ""), o;
};
_mkSprite = /* @__PURE__ */ new WeakSet();
mkSprite_fn = function(o, t) {
  var R;
  const e = _GrpLayer.hFn2ResAniSpr[o];
  if (e) {
    const N = new AnimatedSprite(e.aTex);
    return N.animationSpeed = (R = e.meta.animationSpeed) != null ? R : 1, N.play(), N;
  }
  return o in TextureCache ? Sprite.from(o) : o in _GrpLayer.hFn2VElm ? Sprite.from(_GrpLayer.hFn2VElm[o]) : o in t ? new Sprite(t[o].texture) : new Sprite();
};
_rtTsy = /* @__PURE__ */ new WeakMap();
_spTsy = /* @__PURE__ */ new WeakMap();
_fncRender = /* @__PURE__ */ new WeakMap();
_hAEncImg = /* @__PURE__ */ new WeakMap();
_hEncImgOUrl = /* @__PURE__ */ new WeakMap();
__privateAdd$1(GrpLayer, _sortAFrameName);
__privateAdd$1(GrpLayer, _dec2cache4Cripto);
__privateAdd$1(GrpLayer, _charmVideoElm);
__privateAdd$1(GrpLayer, _mkSprite);
__privateAdd$1(GrpLayer, _elc, new EventListenerCtn());
__privateAdd$1(GrpLayer, _hFace, {});
__privateAdd$1(GrpLayer, _main, void 0);
__privateAdd$1(GrpLayer, _cfg, void 0);
__privateAdd$1(GrpLayer, _appPixi, void 0);
__privateAdd$1(GrpLayer, _sys, void 0);
__privateAdd$1(GrpLayer, _val, void 0);
__privateAdd$1(GrpLayer, _glbVol, 1);
__privateAdd$1(GrpLayer, _movVol, 1);
__privateAdd$1(GrpLayer, _evtMng, void 0);
GrpLayer.hFn2ResAniSpr = {};
__privateAdd$1(GrpLayer, _dec2cache, (o, t, e) => {
  var R, N;
  switch (t.type) {
    case LoaderResource.TYPE.JSON:
      const M = t.spritesheet._frameKeys;
      __privateMethod$1(R = _GrpLayer, _sortAFrameName, sortAFrameName_fn).call(R, M), _GrpLayer.hFn2ResAniSpr[t.name] = {
        aTex: M.map((L) => Texture.from(L)),
        meta: t.data.meta
      };
      break;
    case LoaderResource.TYPE.VIDEO:
      const D = t.data;
      D.volume = __privateGet$1(_GrpLayer, _glbVol), _GrpLayer.hFn2VElm[t.name] = __privateMethod$1(N = _GrpLayer, _charmVideoElm, charmVideoElm_fn).call(N, D);
  }
  e();
});
GrpLayer.hFn2VElm = {};
__privateAdd$1(GrpLayer, _hAEncImg, {});
__privateAdd$1(GrpLayer, _hEncImgOUrl, {});
var gs, qa, ln, le, Lr, Zr, $u, ar, Ci, jt, Kr, or, ur, _s, tu, Tr, Fr, Za, ms, ku, yc, hn, ys, Jr, cn, fn, dn, bs, Qr, Ka, mh, ti, Ja, ei, Br, Es, Qa, yh, Ii, pn, to, bh, vr;
const Yt = class extends Container {
  constructor(e, R, N) {
    super();
    nt(this, _s);
    nt(this, ku);
    nt(this, Ka);
    nt(this, Qa);
    nt(this, to);
    nt(this, le, document.createElement("span"));
    nt(this, Lr, new Container());
    nt(this, Zr, new Graphics());
    nt(this, ar, new TxtLayDesignCast(this.spLay, this));
    nt(this, Ci, new TxtLayPadDesignCast(this));
    nt(this, jt, {
      fontsize: 24,
      $width: 0,
      $height: 0,
      pad_left: 0,
      pad_right: 0,
      pad_top: 0,
      pad_bottom: 0
    });
    nt(this, Kr, !1);
    nt(this, or, 0);
    nt(this, ur, 0);
    nt(this, Tr, 0);
    nt(this, Fr, !1);
    nt(this, Za, 0);
    nt(this, ms, 0);
    nt(this, hn, void 0);
    nt(this, ys, []);
    nt(this, Jr, []);
    nt(this, cn, 0);
    nt(this, Qr, () => !1);
    nt(this, Es, 0);
    nt(this, Ii, "Quadratic.Out");
    nt(this, pn, "Quadratic.Out");
    nt(this, vr, void 0);
    this.spLay = e, this.canFocus = R, this.sys = N, V(this, le).classList.add("sn_tx"), V(this, le).style.position = "absolute", V(Yt, qa).view.parentElement.appendChild(V(this, le)), this.addChild(V(this, Lr)), this.addChild(V(this, Zr)), V(this, Zr).name = "grpDbgMasume", V(this, ar).adopt(V(this, Ci));
  }
  static init(e, R) {
    it(Yt, gs, e), it(Yt, qa, R), it(Yt, fn, /[、。，．）］｝〉」』】〕”〟ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ！？!?‼⁉・ーゝゞヽヾ々]/), it(Yt, dn, /[［（｛〈「『【〔“〝]/), it(Yt, bs, /[─‥…]/);
  }
  static setEvtMng(e) {
    it(Yt, ln, e);
  }
  static destroy() {
    it(Yt, ti, /* @__PURE__ */ Object.create(null)), it(Yt, ei, /* @__PURE__ */ Object.create(null)), it(Yt, Br, new Container());
  }
  lay(e) {
    var N, M, D, L, B, $, U, H;
    const R = V(this, le).style;
    if ("style" in e)
      if (e.style) {
        const z = document.createElement("span");
        z.style.cssText = e.style;
        const X = z.style.length;
        for (let Y = 0; Y < X; ++Y) {
          const W = z.style[Y];
          if (W in V(Yt, $u)) {
            DebugMng.myTrace(`${W}\u306F\u6307\u5B9A\u3067\u304D\u307E\u305B\u3093`, "W");
            continue;
          }
          R[W] = z.style[W];
        }
        !z.style.opacity && "alpha" in e && (R.opacity = String(this.spLay.alpha));
      } else
        V(this, le).style.cssText = "";
    else
      "alpha" in e && (R.opacity = String(this.spLay.alpha));
    if ("width" in e && (R.width = ((N = e.width) != null ? N : "0") + "px"), "height" in e && (R.height = ((M = e.height) != null ? M : "0") + "px"), "pl" in e && (R.paddingLeft = ((D = e.pl) != null ? D : "0") + "px"), "pr" in e && (R.paddingRight = ((L = e.pr) != null ? L : "0") + "px"), "pt" in e && (R.paddingTop = ((B = e.pt) != null ? B : "0") + "px"), "pb" in e && (R.paddingBottom = (($ = e.pb) != null ? $ : "0") + "px"), "kinsoku_sol" in e && it(Yt, fn, new RegExp(`[${e.kinsoku_sol}]`)), "kinsoku_eol" in e && it(Yt, dn, new RegExp(`[${e.kinsoku_eol}]`)), "kinsoku_dns" in e && it(Yt, bs, new RegExp(`[${e.kinsoku_dns}]`)), ot(this, _s, tu).call(this), V(this, ar).sethArg(e), it(this, Tr, this.spLay.position.x), R.transformOrigin = `${this.spLay.pivot.x}px ${this.spLay.pivot.y}px`, this.cvsResize(), R.display = this.spLay.visible ? "inline" : "none", R.textShadow = (H = (U = e.filter) != null ? U : R.textShadow) != null ? H : "", it(this, Kr, argChk_Boolean(e, "break_fixed", V(this, Kr))), it(this, or, argChk_Num(e, "break_fixed_left", V(this, or))), it(this, ur, argChk_Num(e, "break_fixed_top", V(this, ur))), ":redraw" in e && V(this, cn) > 0) {
      const z = [
        V(this, le).innerHTML.replaceAll(/(animation-delay: )\d+ms/g, "$10ms"),
        `<span class='sn_ch' data-add='{"ch_in_style":"default"}'>\u3000</span>`
      ];
      ot(this, to, bh).call(this), this.goTxt(z);
    }
  }
  cvsResize() {
    const e = V(this, le).style, R = this.sys.cvsScale;
    e.left = `${this.sys.ofsLeft4elm + V(this, Tr) * R}px`, e.top = `${this.sys.ofsTop4elm + this.spLay.position.y * R}px`, e.transform = `rotate(${this.spLay.angle}deg) scale(${this.spLay.scale.x * R}, ${this.spLay.scale.y * R})`, V(this, ar).cvsResize(), V(this, Ci).cvsResize();
  }
  get tategaki() {
    return V(this, Fr);
  }
  get infTL() {
    return V(this, jt);
  }
  get getWidth() {
    return V(this, jt).$width;
  }
  get getHeight() {
    return V(this, jt).$height;
  }
  setSize(e, R) {
    V(this, jt).$width = e, V(this, jt).$height = R, V(this, le).style.width = V(this, jt).$width + "px", V(this, le).style.height = V(this, jt).$height + "px";
  }
  goTxt(e) {
    var K, J, Q, et, tt, st, rt, at, ut, dt, ct;
    V(Yt, Br).visible = !1;
    const R = V(this, Jr).length;
    R === 0 ? (V(Yt, gs).oCfg.debug.masume && (CmnLib.debugLog && console.log(`\u{1F34C} masume ${this.name} v:${this.visible} l:${this.x} t:${this.y} a:${this.alpha} pl:${V(this, jt).pad_left} pr:${V(this, jt).pad_right} pt:${V(this, jt).pad_top} pb:${V(this, jt).pad_bottom} w:${V(this, jt).$width} h:${V(this, jt).$height}`), V(this, Zr).clear().beginFill(3407616, 0.2).lineStyle(1, 3407616, 1).drawRect(-V(this, jt).pad_left, -V(this, jt).pad_top, V(this, jt).$width, V(this, jt).$height).endFill().beginFill(13311, 0.2).lineStyle(2, 13311, 1).drawRect(
      0,
      0,
      V(this, jt).$width - V(this, jt).pad_left - V(this, jt).pad_right,
      V(this, jt).$height - V(this, jt).pad_top - V(this, jt).pad_bottom
    ).endFill()), V(this, le).innerHTML = [...e].join("").replaceAll(/[\n\t]/g, "")) : V(this, le).insertAdjacentHTML("beforeend", e.slice(V(this, cn)).join("").replaceAll(/[\n\t]/g, "")), it(this, cn, e.length);
    const N = this.sys.cvsScale, M = V(this, le).getBoundingClientRect(), D = M.left + V(this, jt).pad_left, L = M.top + V(this, jt).pad_top;
    let B;
    if (N === 1)
      B = (pt, mt) => new Rectangle(
        pt.left - D,
        pt.top - L,
        pt.width,
        pt.height + ("gjqy".includes(mt) ? V(this, Es) : 0)
      );
    else {
      const pt = this.sys.ofsPadLeft_Dom2PIXI + M.left * (1 - N), mt = this.sys.ofsPadTop_Dom2PIXI + M.top * (1 - N);
      B = (vt, _t) => new Rectangle(
        (vt.left - pt) / N - D,
        (vt.top - mt) / N - L,
        vt.width / N,
        (vt.height + ("gjqy".includes(_t) ? V(this, Es) : 0)) / N
      );
    }
    let $ = 0, U = 2, H = !1;
    do {
      const pt = it(this, Jr, ot(this, Qa, yh).call(this, V(this, le), B));
      if ($ = pt.length, !H && ($ < 2 || R === $))
        break;
      H = !0;
      let mt = -1 / 0;
      for (; U < $; ++U) {
        const vt = pt[U];
        if (vt.elm.tagName === "RT")
          continue;
        const _t = this.tategaki ? vt.rect.y : vt.rect.x;
        if (mt <= _t || ((J = (K = vt.elm.previousElementSibling) == null ? void 0 : K.children[0]) == null ? void 0 : J.tagName) === "BR") {
          mt = _t;
          continue;
        }
        let xt = U - 1;
        for (; pt[xt].elm.tagName === "RT"; )
          --xt;
        const At = pt[xt].ch;
        mt = -1 / 0;
        const yt = U;
        if (V(Yt, bs).test(At) && At === vt.ch)
          U = xt;
        else {
          if (V(Yt, dn).test(At))
            U = xt;
          else if (V(Yt, fn).test(vt.ch))
            for (U = xt + 1; U > 0 && V(Yt, fn).test(pt[--U].ch); )
              ;
          else {
            ++U;
            continue;
          }
          for (U = xt + 1; U > 0 && V(Yt, dn).test(pt[--U].ch); )
            ;
        }
        const ht = pt[U].elm.parentElement, bt = document.createElement("br");
        if (ht.classList.contains("sn_tx"))
          ht.insertBefore(bt, pt[U].elm);
        else {
          const Ct = ht.parentElement;
          Ct.classList.contains("sn_ch") ? Ct.parentElement.insertBefore(bt, Ct) : Ct.insertBefore(bt, ht);
        }
        U += 2, U < yt && (U = yt), $ = -1;
        break;
      }
    } while ($ < 0);
    const z = CmnLib.debugLog ? (pt, mt) => console.log(`\u{1F34C} masume ch:${pt.ch} x:${mt.x} y:${mt.y} w:${mt.width} h:${mt.height}`) : () => {
    }, X = V(Yt, gs).oCfg.debug.masume ? (pt, mt) => {
      z(pt, mt), V(this, Zr).beginFill(6737151, 0.5).lineStyle(2, 16724736, 1).drawRect(mt.x, mt.y, mt.width, mt.height).endFill();
    } : () => {
    }, Y = CmnTween.ease(V(this, Ii));
    for (let pt = R; pt < $; ++pt) {
      const mt = V(this, Jr)[pt], vt = mt.rect, _t = JSON.parse((Q = mt.elm.dataset.arg) != null ? Q : '{"delay": 0}'), xt = JSON.parse((et = mt.elm.dataset.add) != null ? et : "{}"), At = V(Yt, ti)[xt.ch_in_style];
      if (X(mt, vt), mt.elm.dataset.cmd === "grp") {
        const yt = new Container();
        V(this, Lr).addChild(yt), GrpLayer.csv2Sprites(_t.pic, yt, (ht) => {
          ot(this, Ka, mh).call(this, yt, _t, xt, vt, Y, At != null ? At : {}), yt.parent || yt.removeChild(ht);
        });
      }
      if (mt.elm.dataset.lnk) {
        const yt = mt.elm.parentElement.closest("[data-arg]"), ht = JSON.parse((tt = yt.dataset.arg) != null ? tt : "{}");
        ht.key = `lnk=[${pt}] ` + this.name;
        const bt = new Sprite();
        ot(this, Ka, mh).call(this, bt, ht, xt, vt, Y, At != null ? At : {});
        const Ct = (st = ht.style) != null ? st : "", Mt = Ct + ((rt = ht.style_hover) != null ? rt : ""), wt = Ct + ((at = ht.style_clicked) != null ? at : ""), Lt = (ut = ht.r_style) != null ? ut : "", ft = Lt + ((dt = ht.r_style_hover) != null ? dt : ""), Gt = Lt + ((ct = ht.r_style_clicked) != null ? ct : ""), Dt = yt.querySelectorAll("rt");
        Dt.forEach((Et) => Et.dataset.st_r_bk = Et.style.cssText);
        const Bt = yt.style.cssText, Ot = (Et, Ht) => {
          yt.style.cssText = Bt + Et, Dt.forEach((It) => It.style.cssText = It.dataset.st_r_bk + Ht);
        };
        V(Yt, ln).button(
          ht,
          bt,
          () => Ot(Ct, Lt),
          () => this.canFocus() ? (Ot(Mt, ft), !0) : !1,
          () => Ot(wt, Gt)
        ), V(this, Lr).addChild(bt);
      }
    }
    const W = V(this, le).querySelectorAll("span.sn_ch");
    if (it(this, Qr, () => (it(this, Qr, () => !1), W.forEach((pt) => pt.className = pt.className.replace(/ go_ch_in_[^\s"]+/g, "")), V(Yt, Br).position.set(
      V(this, or),
      V(this, ur)
    ), V(Yt, Br).visible = !0, V(Yt, ln).noticeCompTxt(), !0)), W.length === 0) {
      V(this, Qr).call(this);
      return;
    }
    W.forEach((pt) => pt.className = pt.className.replace(/sn_ch_in_([^\s"]+)/g, "go_ch_in_$1"));
    let Z;
    for (let pt = $ - 1; pt >= 0; --pt) {
      const mt = V(this, Jr)[pt];
      if (mt.elm.tagName !== "SPAN")
        continue;
      const vt = mt.rect;
      if (it(this, or, vt.x + (V(this, Fr) ? 0 : vt.width)), it(this, ur, vt.y + (V(this, Fr) ? vt.height : 0)), pt !== $) {
        const _t = V(this, Jr)[$ - 1].rect;
        V(this, Fr) ? V(this, ur) < _t.y + _t.height && it(this, ur, _t.y + _t.height) : V(this, or) < _t.x + _t.width && it(this, or, _t.x + _t.width);
      }
      Z = mt.elm;
      break;
    }
    if (!Z || R === $) {
      V(this, Qr).call(this);
      return;
    }
    Z.addEventListener("animationend", V(this, Qr), { once: !0, passive: !0 });
  }
  skipChIn() {
    let e = V(this, Qr).call(this);
    return V(this, ys).forEach((R) => {
      R.tw && (R.tw.stop().end(), e = !0);
    }), it(this, ys, []), e;
  }
  static initChStyle() {
    it(Yt, ti, /* @__PURE__ */ Object.create(null)), it(Yt, ei, /* @__PURE__ */ Object.create(null));
  }
  static getChInStyle(e) {
    return V(Yt, ti)[e];
  }
  static ch_in_style(e) {
    var D, L, B;
    const { name: R } = e;
    if (!R)
      throw "name\u306F\u5FC5\u9808\u3067\u3059";
    if (V(Yt, Ja).test(R))
      throw `name\u3010${R}\u3011\u306B\u4F7F\u3048\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u307E\u3059`;
    if (R in V(Yt, ti))
      throw `name\u3010${R}\u3011\u306F\u3059\u3067\u306B\u3042\u308A\u307E\u3059`;
    const N = String((D = e.x) != null ? D : "=0"), M = String((L = e.y) != null ? L : "=0");
    return V(Yt, ti)[R] = {
      wait: argChk_Num(e, "wait", 500),
      alpha: argChk_Num(e, "alpha", 0),
      x: N,
      y: M,
      nx: parseFloat(N.charAt(0) === "=" ? N.slice(1) : N),
      ny: parseFloat(M.charAt(0) === "=" ? M.slice(1) : M),
      scale_x: argChk_Num(e, "scale_x", 1),
      scale_y: argChk_Num(e, "scale_y", 1),
      rotate: argChk_Num(e, "rotate", 0),
      join: argChk_Boolean(e, "join", !0),
      ease: (B = e.ease) != null ? B : "ease-out"
    };
  }
  static getChOutStyle(e) {
    return V(Yt, ei)[e];
  }
  static ch_out_style(e) {
    var D, L, B;
    const { name: R } = e;
    if (!R)
      throw "name\u306F\u5FC5\u9808\u3067\u3059";
    if (V(Yt, Ja).test(R))
      throw `name\u3010${R}\u3011\u306B\u4F7F\u3048\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u307E\u3059`;
    if (R in V(Yt, ei))
      throw `name\u3010${R}\u3011\u306F\u3059\u3067\u306B\u3042\u308A\u307E\u3059`;
    const N = String((D = e.x) != null ? D : "=0"), M = String((L = e.y) != null ? L : "=0");
    return V(Yt, ei)[R] = {
      wait: argChk_Num(e, "wait", 500),
      alpha: argChk_Num(e, "alpha", 0),
      x: N,
      y: M,
      nx: parseFloat(N.charAt(0) === "=" ? N.slice(1) : N),
      ny: parseFloat(M.charAt(0) === "=" ? M.slice(1) : M),
      scale_x: argChk_Num(e, "scale_x", 1),
      scale_y: argChk_Num(e, "scale_y", 1),
      rotate: argChk_Num(e, "rotate", 0),
      join: argChk_Boolean(e, "join", !1),
      ease: (B = e.ease) != null ? B : "ease-out"
    };
  }
  dispBreak(e) {
    const R = V(Yt, Br);
    R.visible = !1, this.addChild(R), GrpLayer.csv2Sprites(e, R, (N) => {
      R.parent || R.removeChild(N);
    });
  }
  static delBreak() {
    const e = V(Yt, Br);
    e.parent && (e.parent.removeChild(e), e.removeChildren()), it(Yt, Br, new Container());
  }
  reNew() {
    var R;
    ot(this, to, bh).call(this);
    const e = new Yt(this.spLay, () => this.canFocus(), this.sys);
    return it(e, jt, V(this, jt)), V(e, le).style.cssText = V(this, le).style.cssText, it(e, Tr, V(this, Tr)), e.name = this.name, ot(R = e, _s, tu).call(R), V(e, ar).sethArg(V(this, ar).gethArg()), it(e, hn, V(this, hn)), it(e, Ii, V(this, Ii)), it(e, pn, V(this, pn)), it(e, Kr, V(this, Kr)), it(e, or, V(this, or)), it(e, ur, V(this, ur)), this.destroy(), e;
  }
  record() {
    return {
      infTL: V(this, jt),
      cssText: V(this, le).style.cssText,
      left: V(this, Tr),
      idc_hArg: V(this, ar).gethArg(),
      ch_filter: V(this, hn),
      fi_easing: V(this, Ii),
      fo_easing: V(this, pn),
      break_fixed: V(this, Kr),
      break_fixed_left: V(this, or),
      break_fixed_top: V(this, ur)
    };
  }
  playback(e) {
    var R, N, M;
    it(this, jt, e.infTL), this.position.set(V(this, jt).pad_left, V(this, jt).pad_top), V(this, le).style.cssText = e.cssText, it(this, Tr, e.left), ot(this, _s, tu).call(this), V(this, ar).sethArg(e.idc_hArg), it(this, hn, e.ch_filter), it(this, Ii, e.fi_easing), it(this, pn, e.fo_easing), it(this, Kr, (R = e.break_fixed) != null ? R : !1), it(this, or, (N = e.break_fixed_left) != null ? N : 0), it(this, ur, (M = e.break_fixed_top) != null ? M : 0);
  }
  snapshot(e, R) {
    ot(this, ku, yc).call(this, (N) => {
      it(this, vr, new Sprite(N)), V(this, Fr) && (V(this, vr).x += CmnLib.stageW - (V(this, Tr) + V(this, jt).$width)), V(this, vr).y -= V(this, ms), V(this, vr).texture.frame = new Rectangle(0, 0, V(this, jt).$width - V(this, Tr), V(this, jt).$height), V(this, Lr).addChild(V(this, vr)), e.render(V(this, vr), void 0, !1), R();
    }, !1);
  }
  snapshot_end() {
    V(this, vr) && (V(this, Lr).removeChild(V(this, vr)), it(this, vr, void 0));
  }
  makeDesignCast(e) {
    e(V(this, ar));
    const R = V(this, ar).gethArg();
    V(this, Ci).sethArg({ ...R, ":id_dc": R[":id_tag"] + "_pad" }), e(V(this, Ci));
  }
  showDesignCast() {
    V(this, ar).visible = !0, V(this, Ci).visible = !0;
  }
  dump() {
    const e = [], R = V(this, le).style, N = R.length;
    for (let M = 0; M < N; ++M) {
      const D = R[M];
      e.push(`"${D}":"${R[D].replace(/(["\\])/g, "\\$1")}"`);
    }
    return `"txt":"${V(this, le).textContent.replace(/(["\\])/g, "\\$1")}", "style":{${e.join(",")}}`;
  }
  destroy() {
    Yt.delBreak(), V(this, le).parentElement.removeChild(V(this, le)), this.removeChild(V(this, Lr)), this.removeChild(V(this, Zr)), super.destroy();
  }
};
let TxtStage = Yt;
gs = new WeakMap(), qa = new WeakMap(), ln = new WeakMap(), le = new WeakMap(), Lr = new WeakMap(), Zr = new WeakMap(), $u = new WeakMap(), ar = new WeakMap(), Ci = new WeakMap(), jt = new WeakMap(), Kr = new WeakMap(), or = new WeakMap(), ur = new WeakMap(), _s = new WeakSet(), tu = function() {
  var M;
  const e = V(this, le).style, R = parseFloat(e.fontSize || "0");
  V(this, jt).fontsize = R, V(this, jt).pad_left = parseFloat(e.paddingLeft || "0"), V(this, jt).pad_right = parseFloat(e.paddingRight || "0"), V(this, jt).pad_top = parseFloat(e.paddingTop || "0"), V(this, jt).pad_bottom = parseFloat(e.paddingBottom || "0"), V(this, jt).$width = parseFloat(e.width || "0"), V(this, jt).$height = parseFloat(e.height || "0"), this.position.set(V(this, jt).pad_left, V(this, jt).pad_top), it(this, Fr, e.writingMode === "vertical-rl"), it(this, Za, 0), it(this, ms, 0);
  const N = (M = e.lineHeight) != null ? M : "0";
  it(this, Es, V(this, Fr) ? 0 : (N.slice(-2) === "px" ? parseFloat(N) : R * parseFloat(N) - R) / 2);
}, Tr = new WeakMap(), Fr = new WeakMap(), Za = new WeakMap(), ms = new WeakMap(), ku = new WeakSet(), yc = function(e, R = !0) {
  const N = {
    escape: (q) => q.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1"),
    mimeType: (q) => {
      const Z = $(q).toLowerCase();
      return M()[Z] || "";
    },
    dataAsUrl: X,
    isDataUrl: U,
    resolveUrl: H,
    getAndEncode: z,
    asArray: (q) => {
      const Z = [], K = q.length;
      for (let J = 0; J < K; ++J)
        Z.push(q[J]);
      return Z;
    }
  };
  function M() {
    const q = "application/font-woff", Z = "image/jpeg";
    return {
      woff: q,
      woff2: q,
      ttf: "application/font-truetype",
      eot: "application/vnd.ms-fontobject",
      png: "image/png",
      jpg: Z,
      jpeg: Z,
      gif: "image/gif",
      tiff: "image/tiff",
      svg: "image/svg+xml"
    };
  }
  const D = Y(), L = W();
  function B(q) {
    return L.resolveAll().then((Z) => {
      const K = document.createElement("style");
      return q.appendChild(K), K.appendChild(document.createTextNode(Z)), q;
    });
  }
  function $(q) {
    var K;
    const Z = /\.([^\.\/]*?)$/g.exec(q);
    return (K = Z == null ? void 0 : Z[1]) != null ? K : "";
  }
  function U(q) {
    return q.search(/^(data:)/) !== -1;
  }
  function H(q, Z) {
    const K = document.implementation.createHTMLDocument(), J = K.createElement("base");
    K.head.appendChild(J);
    const Q = K.createElement("a");
    return K.body.appendChild(Q), J.href = Z, Q.href = q, Q.href;
  }
  function z(q) {
    let Z = 3e4;
    return new Promise(function(K) {
      const J = new XMLHttpRequest();
      J.onreadystatechange = Q, J.ontimeout = et, J.responseType = "blob", J.timeout = Z, J.open("GET", q, !0), J.send();
      function Q() {
        if (J.readyState !== 4)
          return;
        if (J.status !== 200) {
          tt("cannot fetch resource: " + q + ", status: " + J.status);
          return;
        }
        const st = new FileReader();
        st.onloadend = function() {
          const rt = st.result.toString().split(/,/)[1];
          K(rt);
        }, st.readAsDataURL(J.response);
      }
      function et() {
        tt("timeout of " + Z + "ms occured while fetching resource: " + q);
      }
      function tt(st) {
        console.error(st), K("");
      }
    });
  }
  function X(q, Z) {
    return "data:" + Z + ";base64," + q;
  }
  function Y() {
    const q = /url\(['"]?([^'"]+?)['"]?\)/g;
    return {
      inlineAll: Q,
      shouldProcess: Z
    };
    function Z(et) {
      return et.search(q) !== -1;
    }
    function K(et) {
      const tt = [];
      let st;
      for (; st = q.exec(et); )
        tt.push(st[1]);
      return tt.filter(function(rt) {
        return !N.isDataUrl(rt);
      });
    }
    function J(et, tt, st, rt) {
      return Promise.resolve(tt).then((ut) => st ? N.resolveUrl(ut, st) : ut).then(rt || N.getAndEncode).then((ut) => N.dataAsUrl(ut, N.mimeType(tt))).then((ut) => et.replace(at(tt), "$1" + ut + "$3"));
      function at(ut) {
        return new RegExp(`(url\\(['"]?)(` + N.escape(ut) + `)(['"]?\\))`, "g");
      }
    }
    function Q(et, tt, st) {
      if (rt())
        return Promise.resolve(et);
      return Promise.resolve(et).then(K).then((at) => {
        let ut = Promise.resolve(et);
        for (const dt of at)
          ut = ut.then((ct) => J(ct, dt, tt, st));
        return ut;
      });
      function rt() {
        return !Z(et);
      }
    }
  }
  function W() {
    return {
      resolveAll: q,
      impl: { readAll: Z }
    };
    function q() {
      return Z().then((K) => Promise.allSettled(
        K.map((J) => J.resolve())
      )).then((K) => K.join(`
`));
    }
    function Z() {
      return Promise.resolve(N.asArray(document.styleSheets)).then(J).then(K).then((et) => et.map(Q));
      function K(et) {
        return et.filter((tt) => tt.type === CSSRule.FONT_FACE_RULE).filter((tt) => D.shouldProcess(tt.style.getPropertyValue("src")));
      }
      function J(et) {
        const tt = [];
        for (const st of et)
          try {
            if (st.href)
              continue;
            N.asArray(st.cssRules || []).forEach(tt.push.bind(tt));
          } catch (rt) {
            console.error("Error while reading CSS rules from " + st.href, rt.toString());
          }
        return tt;
      }
      function Q(et) {
        return {
          resolve: function() {
            const st = (et.parentStyleSheet || {}).href;
            return D.inlineAll(et.cssText, st);
          },
          src: function() {
            return et.style.getPropertyValue("src");
          }
        };
      }
    }
  }
  Promise.resolve(V(this, le)).then((q) => {
    const Z = q.cloneNode(!0);
    return Z.style.padding = "0px", Z.style.paddingRight = V(this, Za) + "px", Z.style.paddingTop = V(this, ms) + "px", Z.style.left = "0px", Z.style.top = "0px", Z.style.width = V(this, jt).$width - V(this, jt).pad_left - V(this, jt).pad_right + "px", Z.style.height = V(this, jt).$height - V(this, jt).pad_top - V(this, jt).pad_bottom + "px", V(this, le).hidden = R, Z;
  }).then(B).then((q) => {
    q.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
    const Z = new Image();
    return Z.src = `data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="${V(this, jt).$width}px" height="${V(this, jt).$height}px"><foreignObject x="0" y="0" width="100%" height="100%">${new XMLSerializer().serializeToString(q).replaceAll("#", "%23").replaceAll(`
`, "%0A")}</foreignObject></svg>`, new Promise((K) => Z.onload = () => K(Z));
  }).then((q) => new Promise((Z) => setTimeout(() => Z(q), 100))).then((q) => {
    const Z = document.createElement("canvas");
    Z.width = V(this, jt).$width, Z.height = V(this, jt).$height, Z.getContext("2d").drawImage(q, 0, 0), Z.toBlob((K) => {
      if (!K)
        return;
      const J = URL.createObjectURL(K);
      Texture.from(J).once("update", (Q) => {
        e(Q), URL.revokeObjectURL(J);
      });
    });
  }).catch((q) => DebugMng.myTrace(`goTxt() = ${q}`));
}, hn = new WeakMap(), ys = new WeakMap(), Jr = new WeakMap(), cn = new WeakMap(), fn = new WeakMap(), dn = new WeakMap(), bs = new WeakMap(), Qr = new WeakMap(), Ka = new WeakSet(), mh = function(e, R, N, M, D, L) {
  var $, U, H;
  e.alpha = 0, R.x && (M.x = R.x.charAt(0) === "=" ? M.x + parseInt(R.x.slice(1)) : parseInt(R.x)), R.y && (M.y = R.y.charAt(0) === "=" ? M.y + parseInt(R.y.slice(1)) : parseInt(R.y)), R.width && (M.width = parseInt(R.width)), R.height && (M.height = parseInt(R.height)), R.wait && (L.wait = parseInt(R.wait)), e.width = M.width, e.height = M.height, L.x ? e.position.set(
    L.x.charAt(0) === "=" ? M.x + e.width * L.nx : L.nx,
    L.y.charAt(0) === "=" ? M.y + e.height * L.ny : L.ny
  ) : e.position.set(M.x, M.y);
  const B = {
    sp: e,
    tw: new Tween(e).to({ alpha: 1, x: M.x, y: M.y, width: M.width, height: M.height, angle: 0 }, ($ = L.wait) != null ? $ : 0).easing(D).delay(((U = N.wait) != null ? U : 0) + ((H = R.delay) != null ? H : 0)).onComplete(() => {
      B.tw = void 0;
    }).start()
  };
  V(this, ys).push(B);
}, ti = new WeakMap(), Ja = new WeakMap(), ei = new WeakMap(), Br = new WeakMap(), Es = new WeakMap(), Qa = new WeakSet(), yh = function(e, R) {
  const N = [];
  if (e.nodeType !== e.TEXT_NODE)
    return Array.from(e.childNodes).map((B) => ot(this, Qa, yh).call(this, B, R)).flat();
  const M = e.ownerDocument.createRange();
  M.selectNodeContents(e);
  let D = 0;
  const L = M.endOffset;
  for (; D < L; ) {
    M.setStart(e, D), M.setEnd(e, ++D);
    const B = M.toString();
    N.push({
      ch: B,
      rect: R(M.getBoundingClientRect(), B),
      elm: M.startContainer.parentElement
    });
  }
  return M.detach(), N;
}, Ii = new WeakMap(), pn = new WeakMap(), to = new WeakSet(), bh = function() {
  var D;
  V(this, Zr).clear(), it(this, Jr, []), it(this, cn, 0), this.skipChIn();
  const e = V(this, le).cloneNode(!0);
  e.textContent = "";
  const R = V(this, le);
  R.parentElement.insertBefore(e, R);
  let N = 0;
  R.querySelectorAll("span.sn_ch").forEach((L) => {
    var U, H, z, X, Y, W;
    const B = JSON.parse(
      (W = (Y = (H = L == null ? void 0 : L.dataset.add) != null ? H : (U = L == null ? void 0 : L.children[0]) == null ? void 0 : U.getAttribute("data-add")) != null ? Y : (X = (z = L == null ? void 0 : L.children[0]) == null ? void 0 : z.children[0]) == null ? void 0 : X.getAttribute("data-add")) != null ? W : "{}"
    );
    if (!B.ch_out_style)
      return;
    const $ = V(Yt, ei)[B.ch_out_style];
    if (!!$) {
      if ($.wait === 0) {
        L.style.display = "none";
        return;
      }
      N += $.wait, $.join || (L.style.animationDelay = "0ms"), L.classList.add(`go_ch_out_${B.ch_out_style}`);
    }
  });
  const M = () => {
    R.parentElement.removeChild(R), V(this, Lr).removeChildren().forEach((L) => {
      L instanceof Container && V(Yt, ln).unButton(L), L.destroy();
    });
  };
  N === 0 ? (V(this, le).textContent = "", M()) : (D = R.lastElementChild) == null || D.addEventListener("animationend", M, { once: !0, passive: !0 }), it(this, le, e);
}, vr = new WeakMap(), nt(TxtStage, gs, void 0), nt(TxtStage, qa, void 0), nt(TxtStage, ln, void 0), nt(TxtStage, $u, {
  "background-color": 0,
  "border-bottom-width": 0,
  "border-left-width": 0,
  "border-right-width": 0,
  "border-top-width": 0,
  "margin-bottom": 0,
  "margin-left": 0,
  "margin-right": 0,
  "margin-top": 0
}), nt(TxtStage, fn, void 0), nt(TxtStage, dn, void 0), nt(TxtStage, bs, void 0), nt(TxtStage, ti, /* @__PURE__ */ Object.create(null)), nt(TxtStage, Ja, /[\s\.,]/), nt(TxtStage, ei, /* @__PURE__ */ Object.create(null)), nt(TxtStage, Br, new Container());
var __accessCheck = (o, t, e) => {
  if (!t.has(o))
    throw TypeError("Cannot " + e);
}, __privateGet = (o, t, e) => (__accessCheck(o, t, "read from private field"), e ? e.call(o) : t.get(o)), __privateAdd = (o, t, e) => {
  if (t.has(o))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(o) : t.set(o, e);
}, __privateSet = (o, t, e, R) => (__accessCheck(o, t, "write to private field"), R ? R.call(o, e) : t.set(o, e), e), __privateMethod = (o, t, e) => (__accessCheck(o, t, "access private method"), e), _procMasume4txt, _procMasume4pic, _rctBtnTxt, _idc, _sp_b_pic, _sp_pic, _loaded_b_pic, loaded_b_pic_fn, _hover, _clicked, _loaded_pic, loaded_pic_fn;
const _Button = class extends Container {
  constructor(o, t, e, R) {
    var X, Y, W;
    var N;
    super(), this.hArg = o, this.evtMng = t, this.resolve = e, this.canFocus = R, __privateAdd(this, _loaded_b_pic), __privateAdd(this, _loaded_pic), this.getBtnBounds = () => __privateGet(this, _rctBtnTxt), __privateAdd(this, _rctBtnTxt, new Rectangle()), __privateAdd(this, _idc, void 0), __privateAdd(this, _sp_b_pic, void 0), __privateAdd(this, _sp_pic, void 0), this.normal = () => {
    }, __privateAdd(this, _hover, () => !1), __privateAdd(this, _clicked, () => {
    }), CmnLib.isDbg && (this.makeDesignCast = (q) => q(__privateGet(this, _idc)), this.cvsResize = () => __privateGet(this, _idc).cvsResize());
    let M = {
      x: this.x = uint((X = o.left) != null ? X : 0),
      y: this.y = uint((Y = o.top) != null ? Y : 0),
      rotation: this.angle = argChk_Num(o, "rotation", this.angle),
      pivot_x: this.pivot.x = argChk_Num(o, "pivot_x", this.pivot.x),
      pivot_y: this.pivot.y = argChk_Num(o, "pivot_y", this.pivot.y),
      scale_x: this.scale.x = argChk_Num(o, "scale_x", this.scale.x),
      scale_y: this.scale.y = argChk_Num(o, "scale_y", this.scale.y),
      width: 0,
      height: 0
    };
    this.getBtnBounds = () => (__privateGet(this, _rctBtnTxt).x = M.x, __privateGet(this, _rctBtnTxt).y = M.y, __privateGet(this, _rctBtnTxt));
    const D = M.enabled = argChk_Boolean(o, "enabled", !0);
    if (D && t.button(this.hArg, this, () => this.normal(), () => __privateGet(this, _hover).call(this), () => __privateGet(this, _clicked).call(this)), o.pic) {
      M.type = "pic", __privateSet(this, _idc, new PicBtnDesignCast(this, o)), GrpLayer.csv2Sprites(
        o.pic,
        this,
        (q) => {
          __privateMethod(this, _loaded_pic, loaded_pic_fn).call(this, q, M), __privateGet(this, _rctBtnTxt).width = q.width * M.scale_x, __privateGet(this, _rctBtnTxt).height = q.height * M.scale_y;
        },
        (q) => e
      );
      return;
    }
    if (!o.text)
      throw "text\u307E\u305F\u306Fpic\u5C5E\u6027\u306F\u5FC5\u9808\u3067\u3059";
    const L = argChk_Num(o, "height", 30), B = new TextStyle({
      align: "center",
      dropShadow: !0,
      dropShadowAlpha: 0.7,
      dropShadowColor: "white",
      dropShadowBlur: 7,
      dropShadowDistance: 0,
      fill: "black",
      fontFamily: _Button.fontFamily,
      fontSize: L,
      padding: 5
    });
    if (o.style)
      try {
        const q = JSON.parse(o.style);
        for (const Z in q)
          B[Z] = q[Z];
      } catch (q) {
        throw new Error(mesErrJSON(o, "style", q.message));
      }
    const $ = new Text((W = o.text) != null ? W : "", B);
    $.alpha = argChk_Num(o, "alpha", $.alpha), $.width = argChk_Num(o, "width", 100), $.height = o.height = L, this.setText = (q) => $.text = q, M.type = "text", M = { ...M, ...B }, M.alpha = $.alpha, M.text = $.text, M.width = $.width, M.height = $.height, __privateSet(this, _idc, new TxtBtnDesignCast(this, o, $));
    let U = !1;
    if (o.b_pic && (M.b_pic = o.b_pic, U = GrpLayer.csv2Sprites(
      o.b_pic,
      this,
      (q) => {
        __privateMethod(this, _loaded_b_pic, loaded_b_pic_fn).call(this, q, $), M.width = this.width, M.height = this.height;
      },
      (q) => {
        Layer.setBlendmode(this, o), q && e();
      }
    )), $.name = JSON.stringify(M), this.addChild($), __privateGet(this, _rctBtnTxt).width = $.width, __privateGet(this, _rctBtnTxt).height = $.height, M.width = this.width, M.height = this.height, o.b_pic || Layer.setBlendmode(this, o), __privateGet(N = _Button, _procMasume4txt).call(N, this, $), !D) {
      U || e();
      return;
    }
    const H = B.clone();
    if (o.style_hover)
      try {
        const q = JSON.parse(o.style_hover);
        for (const Z in q)
          H[Z] = q[Z];
      } catch (q) {
        throw new Error(mesErrJSON(o, "style_hover", q.message));
      }
    else
      H.fill = "white";
    const z = H.clone();
    if (o.style_clicked)
      try {
        const q = JSON.parse(o.style_clicked);
        for (const Z in q)
          z[Z] = q[Z];
      } catch (q) {
        throw new Error(mesErrJSON(o, "style_clicked", q.message));
      }
    else
      z.dropShadow = !1;
    this.normal = () => $.style = B, __privateSet(this, _hover, () => R() ? ($.style = H, !0) : !1), __privateSet(this, _clicked, () => $.style = z), U || e();
  }
  static init(o) {
    !o.oCfg.debug.masume || (__privateSet(_Button, _procMasume4txt, (t, e) => t.addChild(
      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(e.x, e.y, e.width, e.height).endFill()
    )), __privateSet(_Button, _procMasume4pic, (t, e, R, N) => t.addChild(
      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(e.x, e.y, R, N).endFill()
    )));
  }
  setText(o) {
  }
  destroy(o) {
    this.evtMng.unButton(this), super.destroy();
  }
  makeDesignCast(o) {
  }
  showDesignCast() {
    __privateGet(this, _idc).visible = !0;
  }
  cvsResize() {
  }
  update_b_pic(o, t) {
    var R;
    const e = JSON.parse((R = t.name) != null ? R : "{}");
    __privateGet(this, _sp_b_pic) && this.removeChild(__privateGet(this, _sp_b_pic)), this.hArg.b_pic = e.b_pic = o, t.name = JSON.stringify(e), o && GrpLayer.csv2Sprites(
      o,
      this,
      (N) => __privateMethod(this, _loaded_b_pic, loaded_b_pic_fn).call(this, N, t),
      () => Layer.setBlendmode(this, this.hArg)
    );
  }
  update_pic(o, t) {
    var R;
    const e = JSON.parse((R = t.name) != null ? R : "{}");
    __privateGet(this, _sp_pic) && this.removeChild(__privateGet(this, _sp_pic)), this.hArg.pic = e.pic = o, t.name = JSON.stringify(e), o && GrpLayer.csv2Sprites(
      o,
      this,
      (N) => __privateMethod(this, _loaded_pic, loaded_pic_fn).call(this, N, e),
      () => Layer.setBlendmode(this, this.hArg)
    );
  }
};
let Button = _Button;
_procMasume4txt = /* @__PURE__ */ new WeakMap();
_procMasume4pic = /* @__PURE__ */ new WeakMap();
_rctBtnTxt = /* @__PURE__ */ new WeakMap();
_idc = /* @__PURE__ */ new WeakMap();
_sp_b_pic = /* @__PURE__ */ new WeakMap();
_sp_pic = /* @__PURE__ */ new WeakMap();
_loaded_b_pic = /* @__PURE__ */ new WeakSet();
loaded_b_pic_fn = function(o, t) {
  __privateSet(this, _sp_b_pic, o), this.setChildIndex(o, 0), o.alpha = t.alpha, o.setTransform(
    t.x,
    t.y,
    1,
    1,
    t.rotation,
    0,
    0,
    (o.width - t.width) / 2,
    (o.height - t.height) / 2
  ), o.name = t.name;
};
_hover = /* @__PURE__ */ new WeakMap();
_clicked = /* @__PURE__ */ new WeakMap();
_loaded_pic = /* @__PURE__ */ new WeakSet();
loaded_pic_fn = function(o, t) {
  var e;
  __privateSet(this, _sp_pic, o), t.alpha = o.alpha = argChk_Num(this.hArg, "alpha", o.alpha), __privateGet(this, _idc).setSp(o);
  const R = o.width / 3, N = o.height, M = o.texture.baseTexture, D = new Texture(M, new Rectangle(0, 0, R, N)), L = new Texture(M, new Rectangle(R, 0, R, N)), B = new Texture(M, new Rectangle(R * 2, 0, R, N)), $ = () => o.texture = D;
  $(), this.normal = $, __privateSet(this, _hover, () => this.canFocus() ? (o.texture = B, !0) : !1), __privateSet(this, _clicked, () => o.texture = L), "width" in this.hArg ? (t.width = uint(this.hArg.width), this.scale.x *= t.width / R) : t.width = R, "height" in this.hArg ? (t.height = uint(this.hArg.height), this.scale.y *= t.height / R) : t.height = R, o.name = JSON.stringify(t), __privateGet(e = _Button, _procMasume4pic).call(e, this, o, R, N);
};
Button.fontFamily = "'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '\u6E38\u30B4\u30B7\u30C3\u30AF Medium', meiryo, sans-serif";
__privateAdd(Button, _procMasume4txt, (o, t) => {
});
__privateAdd(Button, _procMasume4pic, (o, t, e, R) => {
});
var xs, Sr, Ts, eo, ro, Eh, io, xh, no, vn, so, ri, gn, Gu, bc, $r, lr, gr, ce, Cr, ne, Ss, Ir, Uu, He, _n, Ea, wi, mn, yn, xa, bn, ao, Th, oo, Sh, Ri, Pi, En, Cs, Is, ii, ze, Hu, Ec, Ze, ws, Rs, eu, ni, qi, kr, _r, hr, cr, uo, Ch, Ps, ru, lo, Ih, Ai;
const Zt = class extends Layer {
  constructor() {
    super();
    nt(this, _n);
    nt(this, yn);
    nt(this, ao);
    nt(this, oo);
    nt(this, Hu);
    nt(this, Rs);
    nt(this, ni);
    nt(this, uo);
    nt(this, Ps);
    nt(this, lo);
    nt(this, $r, void 0);
    nt(this, lr, void 0);
    nt(this, gr, void 0);
    nt(this, ce, void 0);
    nt(this, Cr, void 0);
    nt(this, ne, void 0);
    nt(this, Ss, void 0);
    nt(this, Ir, void 0);
    nt(this, He, void 0);
    nt(this, wi, void 0);
    nt(this, mn, void 0);
    nt(this, bn, void 0);
    nt(this, Ri, void 0);
    nt(this, Pi, void 0);
    nt(this, En, void 0);
    nt(this, Cs, void 0);
    nt(this, ii, void 0);
    nt(this, ze, void 0);
    nt(this, Ze, void 0);
    nt(this, ws, void 0);
    nt(this, kr, void 0);
    nt(this, _r, void 0);
    nt(this, hr, void 0);
    nt(this, cr, void 0);
    nt(this, Ai, void 0);
    it(this, $r, 0), it(this, lr, 0), it(this, gr, !1), it(this, ce, void 0), it(this, Cr, ""), it(this, ne, new TxtStage(this.spLay, () => this.canFocus(), V(Zt, so))), it(this, Ss, new RubySpliter()), it(this, Ir, document.createElement("span")), it(this, He, new Container()), it(this, wi, ""), it(this, mn, !0), it(this, bn, ""), it(this, Ri, ""), it(this, Pi, (R) => ""), it(this, En, ""), it(this, Cs, new RegExp("[\u3000]")), this.isCur = !1, it(this, ii, () => ""), it(this, ze, ""), it(this, Ze, !1), it(this, ws, (R, N) => {
      var U, H, z, X, Y, W, q, Z, K, J, Q;
      V(Zt, xs).oCfg.debug.putCh && console.log(`\u{1F58A} \u6587\u5B57\u8868\u793A text:\`${R}\` ruby:\`${N}\` name:\`${this.name_}\``);
      const M = N.split("\uFF5C");
      let D = "";
      const [L, ...B] = M, $ = B.join("\uFF5C");
      switch (M.length) {
        case 1:
          if (it(this, Ze, !0), R === `
`) {
            V(this, _r) ? (it(this, _r, !1), D = "<ruby>\u3000<rt>\u3000</rt></ruby><br/>") : D = "<br/>";
            break;
          }
          V(this, _r) && (it(this, _r, !1), N === "" && (N = "\u3000")), D = ot(this, Rs, eu).call(this, R, N, V(this, ze));
          break;
        default:
          switch (L) {
            case "start":
            case "left":
            case "center":
            case "right":
            case "justify":
            case "121":
            case "even":
            case "1ruby":
              it(this, _r, !1), it(this, Ze, !0), D = ot(this, Rs, eu).call(this, R, $, L);
              break;
            case "gotxt":
              ot(this, Ps, ru).call(this), this.isCur && V(U = Zt, Ts).call(U, V(this, hr).join("").replace(/^<ruby>　<rt>　<\/rt><\/ruby>(<br\/>)+/, "").replace(/style='(anim\S+ \S+?;\s*)+/g, "style='").replace(/( style=''| data-(add|arg|cmd)='.+?'|\n+|\t+)/g, "").replace(/class='sn_ch .+?'/g, "class='sn_ch'").replaceAll("class='offrec'", "style='display: none;'").replaceAll("`", "\\`")), V(this, Ze) ? (V(this, ne).goTxt(V(this, hr)), it(this, Ze, !1), it(this, kr, 0)) : this.isCur && V(Zt, vn).noticeCompTxt();
              return;
            case "add":
              {
                const et = JSON.parse($), { style: tt = "", wait: st = null } = et, { cl: rt, sty: at } = ot(this, ni, qi).call(this, !0, st);
                V(this, hr).push(`<span${rt} style='${at} display: inline; ${tt}'>`), delete et.style, ot(this, uo, Ch).call(this, et);
              }
              return;
            case "add_close":
              V(this, hr).push("</span>"), ot(this, Ps, ru).call(this);
              return;
            case "grp":
              it(this, Ze, !0);
              {
                const et = JSON.parse($);
                if ((H = et.id) != null || (et.id = V(this, hr).length), et.id === "break") {
                  V(this, ne).dispBreak(et.pic);
                  return;
                }
                it(this, _r, !1), et.delay = V(this, kr), (z = et.r) != null || (et.r = ""), (X = et.style) != null || (et.style = ""), (Y = et.r_style) != null || (et.r_style = "");
                const { cl: tt, sty: st, lnk: rt } = ot(this, ni, qi).call(this, !0, et.wait);
                D = `<span${tt} style='${st} ${et.style}'><ruby><span data-cmd='grp' data-arg='${JSON.stringify(et)}'${rt} style='${st} display: inline;'>\u3000</span><rt${rt}${this.mkStyle_r_align(
                  "\u3000",
                  et.r,
                  V(this, ze),
                  V(this, Ir).style.cssText + ((q = (W = V(this, cr).at(-1)) == null ? void 0 : W.o.r_style) != null ? q : "") + et.r_style
                )}>${et.r}</rt></ruby></span>`;
              }
              break;
            case "tcy":
              it(this, _r, !1), it(this, Ze, !0);
              {
                V(Zt, Sr).doRecLog() && it(this, Ai, V(this, Ai) + (R + (N ? `\u300A${N}\u300B` : "")));
                const { t: et, r: tt = "", wait: st = null, style: rt = "", r_style: at = "" } = JSON.parse($), ut = CmnLib.isSafari ? tt.replaceAll(/[A-Za-z0-9]/g, (mt) => String.fromCharCode(mt.charCodeAt(0) + 65248)) : tt, { cl: dt, sty: ct, lnk: pt } = ot(this, ni, qi).call(this, !0, st);
                D = `<span${dt} style='${ct}${V(this, Pi).call(this, et)} ${rt}'><ruby><span${pt} style='${ct} display: inline;
text-combine-upright: all;
-webkit-text-combine: horizontal;'>${et}</span><rt${pt}${this.mkStyle_r_align(
                  et,
                  ut,
                  V(this, ze),
                  V(this, Ir).style.cssText + ((K = (Z = V(this, cr).at(-1)) == null ? void 0 : Z.o.r_style) != null ? K : "") + at
                )}>${ut}</rt></ruby></span>`;
              }
              break;
            case "del":
              TxtStage.delBreak();
              return;
            case "span":
              it(this, Ze, !0), ot(this, lo, Ih).call(this, JSON.parse($));
              return;
            case "link":
              it(this, Ze, !0);
              {
                const et = JSON.parse($);
                et[":link"] = " data-lnk='@'";
                const { cl: tt, sty: st, curpos: rt } = ot(this, ni, qi).call(this, !1, et.wait);
                V(this, hr).push(`<span${tt} style='${st} display: inline; ${(J = et.style) != null ? J : ""}' ${rt} data-arg='${$}'>`), delete et.style, ot(this, lo, Ih).call(this, et);
              }
              return;
            case "endlink":
              it(this, Ze, !0), V(this, hr).push("</span>"), ot(this, Ps, ru).call(this);
              return;
            default:
              it(this, Ze, !0), D = ot(this, Rs, eu).call(this, R, N, V(this, ze));
          }
          break;
      }
      V(this, hr).push(V(Q = Zt, Is).call(Q, D));
    }), it(this, kr, 0), it(this, _r, !0), it(this, hr, []), it(this, cr, []), this.click = () => !this.spLay.interactiveChildren || !this.spLay.visible ? !1 : V(this, ne).skipChIn(), it(this, Ai, ""), this.addButton = (R) => new Promise((N) => {
      R.key = `btn=[${V(this, He).children.length}] ` + this.name_, R[":id_tag"] = R.key.slice(0, -7), argChk_Boolean(R, "hint_tate", V(this, ne).tategaki);
      const M = new Button(R, V(Zt, vn), () => N(), () => this.canFocus());
      M.name = JSON.stringify(R).replaceAll('"', "'"), V(this, He).addChild(M);
    }), this.record = () => ({
      ...super.record(),
      enabled: this.enabled,
      r_cssText: V(this, Ir).style.cssText,
      r_align: V(this, ze),
      b_do: V(this, ce) === void 0 ? void 0 : V(this, ce) instanceof Sprite ? "Sprite" : "Graphics",
      b_pic: V(this, Cr),
      b_color: V(this, $r),
      b_alpha: V(this, lr),
      b_alpha_isfixed: V(this, gr),
      ffs: V(this, Ri),
      txs: V(this, ne).record(),
      strNoFFS: V(this, En),
      btns: V(this, He).children.map((R) => R.name)
    }), this.spLay.addChild(V(this, ne)), V(this, Ss).init(V(this, ws)), this.spLay.addChild(V(this, He)), V(this, He).name = "cntBtn";
    const e = 16;
    this.lay({ style: `width: ${CmnLib.stageW}px; height: ${CmnLib.stageH}px; font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '\u6E38\u30B4\u30B7\u30C3\u30AF Medium', meiryo, sans-serif; color: white; font-size: 24px; line-height: 1.5; padding: ${e}px;`, in_style: "default", out_style: "default", back_clear: "true" });
  }
  static init(e, R, N, M, D, L) {
    var $, U;
    it(Zt, xs, e), TxtStage.init(e, L), it(Zt, Sr, N), it(Zt, Ts, M), it(Zt, eo, D), N.setDoRecProc(Zt.chgDoRec), R.autowc = (H) => {
      var z;
      return ot(z = Zt, Gu, bc).call(z, H);
    }, R.autowc({ enabled: !1, text: "", time: 0 }), R.ch_in_style = (H) => {
      var z;
      return ot(z = Zt, ro, Eh).call(z, H);
    }, R.ch_out_style = (H) => {
      var z;
      return ot(z = Zt, io, xh).call(z, H);
    }, TxtStage.initChStyle(), initStyle();
    let B = "";
    e.matchPath(".+", Config.EXT_FONT).forEach((H) => {
      for (const z in H)
        B += `
@font-face {
	font-family: '${H[z]}';
	src: url('${V(this, xs).searchPath(H[z], Config.EXT_FONT)}');
}
`;
    }), B += `
.sn_tx {
	pointer-events: none;
	user-select: none;
	-webkit-touch-callout: none;
	box-sizing: border-box;
}
.sn_ch {
	position: relative;
	display: inline-block;
}
`, addStyle(B), ot($ = Zt, ro, Eh).call($, {
      name: "default",
      wait: 500,
      alpha: 0,
      x: "=0.3",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: !0,
      ease: "ease-out"
    }), ot(U = Zt, io, xh).call(U, {
      name: "default",
      wait: 0,
      alpha: 0,
      x: "=0",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: !1,
      ease: "ease-out"
    });
  }
  static setEvtMng(e, R, N) {
    it(Zt, no, e), it(Zt, vn, R), it(Zt, so, N), TxtStage.setEvtMng(R);
  }
  destroy() {
    V(this, ce) && (this.spLay.removeChild(V(this, ce)).destroy(), it(this, ce, void 0)), this.clearText(), V(this, ne).destroy();
  }
  static destroy() {
    it(Zt, ri, !1), it(Zt, gn, {}), it(Zt, Is, (e) => e);
  }
  set name(e) {
    this.name_ = e, V(this, ne).name = e;
  }
  get name() {
    return this.name_;
  }
  cvsResize() {
    V(this, ne).cvsResize();
  }
  cvsResizeChildren() {
    V(this, He).children.forEach((e) => e.cvsResize());
  }
  lay(e) {
    var R;
    if (super.lay(e), Layer.setXY(this.spLay, e, this.spLay), e[":id_tag"] = this.name_.slice(0, -7), RubySpliter.setting(e), ot(this, oo, Sh).call(this, e), V(this, ne).lay(e), "r_align" in e && it(this, ze, (R = e.r_align) != null ? R : ""), it(this, ii, CmnLib.isSafari ? V(this, ne).tategaki ? (N, M) => `text-align: start; height: ${M}em; padding-top: ${N}; padding-bottom: ${N};` : (N, M) => `text-align: start; width: ${M}em; padding-left: ${N}; padding-right: ${N};` : V(this, ne).tategaki ? (N) => `text-align: justify; text-align-last: justify; padding-top: ${N}; padding-bottom: ${N};` : (N) => `text-align: justify; text-align-last: justify; padding-left: ${N}; padding-right: ${N};`), CmnLib.isFirefox && (this.mkStyle_r_align = ot(this, Hu, Ec)), "r_style" in e)
      if (e.r_style) {
        const N = document.createElement("span");
        N.style.cssText = e.r_style;
        const M = N.style.length, D = V(this, Ir).style;
        for (let L = 0; L < M; ++L) {
          const B = N.style[L];
          if (B in V(Zt, Uu)) {
            DebugMng.myTrace(`${B}\u306F\u6307\u5B9A\u3067\u304D\u307E\u305B\u3093`, "W");
            continue;
          }
          D[B] = N.style[B];
        }
      } else
        V(this, Ir).style.cssText = "";
    return "alpha" in e && V(this, He).children.forEach((N) => N.alpha = this.spLay.alpha), ot(this, _n, Ea).call(this, e), ot(this, yn, xa).call(this, e), ot(this, ao, Th).call(this, e, (N) => {
      N && V(Zt, no).resume();
    });
  }
  get width() {
    return V(this, ne).getWidth;
  }
  get height() {
    return V(this, ne).getHeight;
  }
  chgBackAlpha(e) {
    const R = V(this, gr) ? V(this, lr) : e * V(this, lr);
    V(this, ce) instanceof Graphics && (V(this, ce) && (this.spLay.removeChild(V(this, ce)), V(this, ce).destroy()), this.spLay.addChildAt(
      it(this, ce, new Graphics()).beginFill(V(this, $r)).lineStyle(void 0).drawRect(0, 0, V(this, ne).getWidth, V(this, ne).getHeight).endFill(),
      0
    ), V(this, ce).name = "back(color)"), V(this, ce) && (V(this, ce).visible = R > 0, V(this, ce).alpha = R);
  }
  static chgDoRec(e) {
    it(Zt, Is, e ? (R) => R : (R) => `<span class='offrec'>${R}</span>`);
  }
  mkStyle_r_align(e, R, N, M = "") {
    if (!N)
      return ` style='${M}'`;
    const D = e.length * 2;
    if (D - R.length < 0)
      return ` style='text-align: ${N}; ${M}'`;
    let L = "";
    switch (N) {
      case "justify":
        L = V(this, ii).call(this, "0", D);
        break;
      case "121":
        L = V(this, ii).call(this, `calc(${(D - R.length) / (R.length * 2)}em)`, D);
        break;
      case "even":
        L = V(this, ii).call(this, `calc(${(D - R.length) / (R.length + 1)}em)`, D);
        break;
      case "1ruby":
        L = V(this, ii).call(this, "1em", D);
        break;
      default:
        L = `text-align: ${N};`;
    }
    return ` style='${L} ${M}'`;
  }
  tagCh(e) {
    V(this, Ss).putTxt(e);
  }
  clearText() {
    var e;
    this.spLay.addChild(it(this, ne, V(this, ne).reNew())), it(this, kr, 0), it(this, _r, !0), it(this, hr, []), it(this, Ai, ""), V(e = Zt, Ts).call(e, "", !0);
  }
  get pageText() {
    return V(this, Ai).replace("\u300A\u3000\u300B", "");
  }
  get enabled() {
    return this.spLay.interactiveChildren;
  }
  set enabled(e) {
    this.spLay.interactiveChildren = e;
  }
  canFocus() {
    var e, R;
    return ((e = this.spLay.interactiveChildren) != null ? e : !1) && this.spLay.visible && V(R = Zt, eo).call(R, this);
  }
  clearLay(e) {
    super.clearLay(e), this.clearText(), V(this, He).removeChildren().forEach((R) => R.destroy());
  }
  playback(e, R) {
    super.playback(e, R), this.enabled = e.enabled, V(this, Ir).style.cssText = e.r_cssText, it(this, ze, e.r_align), this.cvsResize(), ot(this, oo, Sh).call(this, e), V(this, ne).playback(e.txs), it(this, lr, e.b_alpha), it(this, gr, e.b_alpha_isfixed), R.push(new Promise((M) => {
      const D = e.b_do ? e.b_do === "Sprite" ? { b_pic: e.b_pic } : { b_color: e.b_color } : { b_pic: "" };
      D.b_alpha = e.b_alpha, D.b_alpha_isfixed = e.b_alpha_isfixed, ot(this, ao, Th).call(this, D, (L) => {
        L && M();
      }) || M();
    }));
    const N = e.btns;
    R = R.concat(N.map((M) => this.addButton(JSON.parse(M.replaceAll("'", '"')))));
  }
  snapshot(e, R) {
    e.render(this.spLay, { clear: !1 }), V(this, ne).snapshot(e, R);
  }
  snapshot_end() {
    V(this, ne).snapshot_end();
  }
  makeDesignCast(e) {
    !this.spLay.visible || V(this, ne).makeDesignCast(e);
  }
  makeDesignCastChildren(e) {
    !this.spLay.visible || V(this, He).children.forEach((R) => R.makeDesignCast(e));
  }
  showDesignCast() {
    V(this, ne).showDesignCast();
  }
  showDesignCastChildren() {
    V(this, He).children.forEach((e) => e.showDesignCast());
  }
  dump() {
    return V(this, ws).call(this, "", "gotxt\uFF5C"), super.dump() + `, "enabled":"${this.enabled}", ${V(this, ne).dump()}, "b_pic":"${V(this, Cr)}", "b_color":"${V(this, $r)}", "b_alpha":${V(this, lr)}, "b_alpha_isfixed":"${V(this, gr)}", "width":${V(this, ne).getWidth}, "height":${V(this, ne).getHeight}, "pixi_obj":[${this.spLay.children.map((e) => `{"class":"${e instanceof Sprite ? "Sprite" : e instanceof Graphics ? "Graphics" : e instanceof Container ? "Container" : "?"}", "name":"${e.name}", "alpha":${e.alpha}, "x":${e.x}, "y":${e.y}, "visible":"${e.visible}"}`).join(",")}], "button":[${V(this, He).children.map((e) => {
      var R;
      return (R = e.children[0].name) != null ? R : "{}";
    }).join(",")}]`;
  }
};
let TxtLayer = Zt;
xs = new WeakMap(), Sr = new WeakMap(), Ts = new WeakMap(), eo = new WeakMap(), ro = new WeakSet(), Eh = function(e) {
  const R = TxtStage.ch_in_style(e), N = R.x.charAt(0) === "=" ? `${R.nx * 100}%` : `${R.nx}px`, M = R.y.charAt(0) === "=" ? `${R.ny * 100}%` : `${R.ny}px`, { name: D } = e;
  return addStyle(`
.sn_ch_in_${D} {
	position: relative;
	display: inline-block;
}
.go_ch_in_${D} {
	opacity: ${R.alpha};
	position: relative;
	display: inline-block;
	animation: sn_ch_in_${D} ${R.wait}ms ${R.ease} 0s both;
}
@keyframes sn_ch_in_${D} {
	from {transform: rotate(${R.rotate}deg) scale(${R.scale_x}, ${R.scale_y}) translate(${N}, ${M});}
	to {opacity: 1; transform: none;}
}
`), !1;
}, io = new WeakSet(), xh = function(e) {
  const R = TxtStage.ch_out_style(e), N = R.x.charAt(0) === "=" ? `${R.nx * 100}%` : `${R.nx}px`, M = R.y.charAt(0) === "=" ? `${R.ny * 100}%` : `${R.ny}px`, { name: D } = e;
  return addStyle(`
.go_ch_out_${D} {
	position: relative;
	display: inline-block;
	animation: go_ch_out_${D} ${R.wait}ms ${R.ease} 0s both;
}
@keyframes go_ch_out_${D} {
	to {
		opacity: ${R.alpha};
		transform: rotate(${R.rotate}deg) scale(${R.scale_x}, ${R.scale_y}) translate(${N}, ${M});
	}
`), !1;
}, no = new WeakMap(), vn = new WeakMap(), so = new WeakMap(), ri = new WeakMap(), gn = new WeakMap(), Gu = new WeakSet(), bc = function(e) {
  it(Zt, ri, argChk_Boolean(e, "enabled", V(Zt, ri))), V(Zt, Sr).setVal_Nochk("save", "const.sn.autowc.enabled", V(Zt, ri));
  const { text: R } = e;
  if ("text" in e != "time" in e)
    throw "[autowc] text\u3068time\u306F\u540C\u6642\u6307\u5B9A\u5FC5\u9808\u3067\u3059";
  if (V(Zt, Sr).setVal_Nochk("save", "const.sn.autowc.text", R), !R)
    return V(Zt, Sr).setVal_Nochk("save", "const.sn.autowc.time", ""), !1;
  const N = R.length;
  if (V(Zt, ri) && N === 0)
    throw '[autowc] enabled === false \u304B\u3064 text === "" \u306F\u8A31\u3055\u308C\u307E\u305B\u3093';
  const M = String(e.time).split(",");
  if (M.length !== N)
    throw "[autowc] text\u6587\u5B57\u6570\u3068time\u306B\u8A18\u8FF0\u3055\u308C\u305F\u5F85\u3061\u6642\u9593\uFF08\u30B3\u30F3\u30DE\u533A\u5207\u308A\uFF09\u306F\u540C\u6570\u306B\u3057\u3066\u4E0B\u3055\u3044";
  return it(Zt, gn, {}), M.forEach((D, L) => V(Zt, gn)[R[L]] = uint(D)), V(Zt, Sr).setVal_Nochk("save", "const.sn.autowc.time", e.time), !1;
}, $r = new WeakMap(), lr = new WeakMap(), gr = new WeakMap(), ce = new WeakMap(), Cr = new WeakMap(), ne = new WeakMap(), Ss = new WeakMap(), Ir = new WeakMap(), Uu = new WeakMap(), He = new WeakMap(), _n = new WeakSet(), Ea = function(e) {
  const { in_style: R } = e;
  if (!R)
    return;
  const N = TxtStage.getChInStyle(R);
  if (!N)
    throw `\u5B58\u5728\u3057\u306A\u3044in_style\u3010${R}\u3011\u3067\u3059`;
  it(this, wi, R), it(this, mn, N.join);
}, wi = new WeakMap(), mn = new WeakMap(), yn = new WeakSet(), xa = function(e) {
  const { out_style: R } = e;
  if (!R)
    return;
  if (!TxtStage.getChOutStyle(R))
    throw `\u5B58\u5728\u3057\u306A\u3044out_style\u3010${R}\u3011\u3067\u3059`;
  it(this, bn, R);
}, bn = new WeakMap(), ao = new WeakSet(), Th = function(e, R) {
  if ("back_clear" in e)
    return argChk_Boolean(e, "back_clear", !1) && (it(this, $r, 0), it(this, lr, 0), it(this, gr, !1), it(this, Cr, "")), R(!1), !1;
  it(this, lr, argChk_Num(e, "b_alpha", V(this, lr))), it(this, gr, argChk_Boolean(e, "b_alpha_isfixed", V(this, gr)));
  const N = (V(this, gr) ? 1 : Number(V(Zt, Sr).getVal("sys:TextLayer.Back.Alpha"))) * V(this, lr);
  if (e.b_pic) {
    if (V(this, Cr) !== e.b_pic)
      return it(this, Cr, e.b_pic), V(this, ce) && (this.spLay.removeChild(V(this, ce)), V(this, ce).destroy()), GrpLayer.csv2Sprites(V(this, Cr), this.spLay, (M) => {
        it(this, ce, M), M.name = "back(pic)", M.visible = N > 0, M.alpha = N, V(this, ne).setSize(M.width, M.height), this.spLay.setChildIndex(M, 0), R(!0);
      });
  } else
    "b_color" in e && (it(this, $r, argChk_Color(e, "b_color", 0)), V(this, ce) && (this.spLay.removeChild(V(this, ce)), V(this, ce).destroy()), it(this, Cr, ""), this.spLay.addChildAt(
      it(this, ce, new Graphics()).beginFill(V(this, $r)).lineStyle(void 0).drawRect(0, 0, V(this, ne).getWidth, V(this, ne).getHeight).endFill(),
      0
    ), V(this, ce).name = "back(color)");
  return V(this, ce) && (V(this, ce).visible = N > 0, V(this, ce).alpha = N), R(!1), !1;
}, oo = new WeakSet(), Sh = function(e) {
  var R, N;
  "noffs" in e && (it(this, En, (R = e.noffs) != null ? R : ""), it(this, Cs, new RegExp(`[\u3000${V(this, En)}]`))), "ffs" in e && ((N = V(this, Ri)) != null || it(this, Ri, ""), it(this, Pi, V(this, Ri) === "" ? () => "" : (M) => V(this, Cs).test(M) ? "" : ` font-feature-settings: ${V(this, Ri)};`));
}, Ri = new WeakMap(), Pi = new WeakMap(), En = new WeakMap(), Cs = new WeakMap(), Is = new WeakMap(), ii = new WeakMap(), ze = new WeakMap(), Hu = new WeakSet(), Ec = function(e, R, N, M = "") {
  if (!N)
    return ` style='${M}'`;
  const D = e.length * 2;
  if (D - R.length < 0)
    return ` style='text-align: ${N}; ${M}'`;
  let L = "";
  switch (N) {
    case "left":
      L = "ruby-align: start;";
      break;
    case "center":
      L = "ruby-align: center;";
      break;
    case "right":
      L = "ruby-align: start;";
      break;
    case "justify":
      L = "ruby-align: space-between;";
      break;
    case "121":
      L = "ruby-align: space-around;";
      break;
    case "even":
      const B = (D - R.length) / (R.length + 1);
      L = "ruby-align: space-between; " + (V(this, ne).tategaki ? `padding-top: ${B}em; padding-bottom: ${B}em;` : `padding-left: ${B}em; padding-right: ${B}em;`);
      break;
    case "1ruby":
      L = "ruby-align: space-between; " + (V(this, ne).tategaki ? "padding-top: 1em; padding-bottom: 1em;" : "padding-left: 1em; padding-right: 1em;");
      break;
    default:
      L = `text-align: ${N};`;
  }
  return ` style='${L} ${M}'`;
}, Ze = new WeakMap(), ws = new WeakMap(), Rs = new WeakSet(), eu = function(e, R, N) {
  var $, U;
  const M = e === " " ? "&nbsp;" : e;
  V(Zt, Sr).doRecLog() && it(this, Ai, V(this, Ai) + (M + (R ? `\u300A${R}\u300B` : "")));
  const { cl: D, sty: L, lnk: B } = ot(this, ni, qi).call(this, !0, null, e);
  return R ? `<span${D} style='${L} ${V(this, Pi).call(this, e)}'><ruby>${Array.from(e).map((H, z) => `<span${D}${B} style='${z > 0 ? ot(this, ni, qi).call(this, !0, null, e).sty : L} display: inline;'>${H === " " ? "&nbsp;" : H}</span>`).join("")}<rt${B}${this.mkStyle_r_align(
    e,
    R,
    N,
    V(this, Ir).style.cssText + ((U = ($ = V(this, cr).at(-1)) == null ? void 0 : $.o.r_style) != null ? U : "")
  )}>${R}</rt></ruby></span>` : `<span${D} style='${L} ${V(this, Pi).call(this, e)}'${B}>${M}</span>`;
}, ni = new WeakSet(), qi = function(e, R, N = `
`) {
  var L, B, $, U, H, z, X;
  const M = V(this, mn) ? ($ = R != null ? R : (L = V(this, cr).at(0)) == null ? void 0 : L.o.wait) != null ? $ : V(Zt, ri) ? (B = V(Zt, gn)[N.charAt(0)]) != null ? B : 0 : LayerMng.msecChWait : 0;
  V(Zt, vn).isSkippingByKeyDown() ? it(this, kr, 0) : e && V(this, mn) && it(this, kr, V(this, kr) + Number(M));
  const D = `data-add='{"ch_in_style":"${V(this, wi)}", "ch_out_style":"${V(this, bn)}"}'`;
  return {
    cl: ` class='sn_ch${M > 0 ? ` sn_ch_in_${V(this, wi)}` : ""}'`,
    sty: `animation-delay: ${V(this, kr)}ms;${(H = (U = V(this, cr).at(-1)) == null ? void 0 : U.o.style) != null ? H : ""}`,
    lnk: ((X = (z = V(this, cr).at(0)) == null ? void 0 : z.o[":link"]) != null ? X : "") + " " + D,
    curpos: D
  };
}, kr = new WeakMap(), _r = new WeakMap(), hr = new WeakMap(), cr = new WeakMap(), uo = new WeakSet(), Ch = function(e) {
  V(this, cr).push({
    o: e,
    r_align: V(this, ze),
    ch_in_style: V(this, wi),
    ch_out_style: V(this, bn)
  }), "r_align" in e && it(this, ze, e.r_align), ot(this, _n, Ea).call(this, e), ot(this, yn, xa).call(this, e);
}, Ps = new WeakSet(), ru = function() {
  const e = V(this, cr).pop();
  !e || (it(this, ze, e.r_align), ot(this, _n, Ea).call(this, { in_style: e.ch_in_style }), ot(this, yn, xa).call(this, { out_style: e.ch_out_style }));
}, lo = new WeakSet(), Ih = function(e) {
  const R = V(this, cr).at(-1);
  if (!R) {
    ot(this, uo, Ch).call(this, e);
    return;
  }
  R.o = { ...R.o, ...e }, !e.style && !e.r_style && (R.o.style = "", R.o.r_style = ""), "r_align" in e && it(this, ze, e.r_align), ot(this, _n, Ea).call(this, e), ot(this, yn, xa).call(this, e);
}, Ai = new WeakMap(), nt(TxtLayer, ro), nt(TxtLayer, io), nt(TxtLayer, Gu), nt(TxtLayer, xs, void 0), nt(TxtLayer, Sr, void 0), nt(TxtLayer, Ts, void 0), nt(TxtLayer, eo, void 0), nt(TxtLayer, no, void 0), nt(TxtLayer, vn, void 0), nt(TxtLayer, so, void 0), nt(TxtLayer, ri, !1), nt(TxtLayer, gn, {}), nt(TxtLayer, Uu, {
  "text-align": 0,
  "text-align-last": 0,
  height: 0,
  width: 0,
  "padding-left": 0,
  "padding-right": 0,
  "padding-top": 0,
  "padding-bottom": 0
}), nt(TxtLayer, Is, (e) => e);
var As, si, zu, xc, Os, Ns, iu, ju, Tc, Vu, Sc, ho, Xu, Cc, Wu, Ic;
class FrameMng {
  constructor(t, e, R, N, M, D, L) {
    nt(this, zu);
    nt(this, Ns);
    nt(this, ju);
    nt(this, Vu);
    nt(this, Xu);
    nt(this, Wu);
    nt(this, As, void 0);
    nt(this, si, /* @__PURE__ */ Object.create(null));
    nt(this, Os, {});
    nt(this, ho, 1);
    this.cfg = t, this.appPixi = R, this.val = N, this.main = M, this.sys = D, this.hTwInf = L, e.add_frame = (B) => ot(this, zu, xc).call(this, B), e.let_frame = (B) => ot(this, ju, Tc).call(this, B), e.set_frame = (B) => ot(this, Vu, Sc).call(this, B), e.frame = (B) => ot(this, Xu, Cc).call(this, B), e.tsy_frame = (B) => ot(this, Wu, Ic).call(this, B);
  }
  setEvtMng(t) {
    it(this, As, t);
  }
  destroy() {
    for (const t in V(this, si)) {
      const e = V(this, si)[t];
      e.parentElement.removeChild(e);
    }
    it(this, si, /* @__PURE__ */ Object.create(null));
  }
  getFrmDisabled(t) {
    return V(this, Os)[t];
  }
  cvsResize() {
    for (const t in V(this, si)) {
      const e = V(this, si)[t], R = "const.sn.frm." + t, N = Number(this.val.getVal(R + ".x")), M = Number(this.val.getVal(R + ".y")), D = Number(this.val.getVal(R + ".width")), L = Number(this.val.getVal(R + ".height"));
      e.style.left = `${this.sys.ofsLeft4elm + N * this.sys.cvsScale}px`, e.style.top = `${this.sys.ofsTop4elm + M * this.sys.cvsScale}px`, e.width = String(D * this.sys.cvsScale), e.height = String(L * this.sys.cvsScale);
    }
  }
}
As = new WeakMap(), si = new WeakMap(), zu = new WeakSet(), xc = function(t) {
  const { id: e, src: R, alpha: N = 1, scale_x: M = 1, scale_y: D = 1, rotate: L = 0 } = t;
  if (!e)
    throw "id\u306F\u5FC5\u9808\u3067\u3059";
  if (!R)
    throw "src\u306F\u5FC5\u9808\u3067\u3059";
  const B = "const.sn.frm." + e;
  if (this.val.getVal(`tmp:${B}`))
    throw `frame\u3010${e}\u3011\u306F\u3059\u3067\u306B\u3042\u308A\u307E\u3059`;
  const $ = argChk_Boolean(t, "visible", !0), U = t.b_color ? ` background-color: ${t.b_color};` : "", H = ot(this, Ns, iu).call(this, t);
  this.appPixi.view.insertAdjacentHTML("beforebegin", `<iframe id="${e}" sandbox="allow-scripts allow-same-origin" style="opacity: ${N}; position: absolute; left:${this.sys.ofsLeft4elm + H.x * this.sys.cvsScale}px; top: ${this.sys.ofsTop4elm + H.y * this.sys.cvsScale}px; z-index: 1; ${U} border: 0px; overflow: hidden; display: ${$ ? "inline" : "none"}; transform: scale(${M}, ${D}) rotate(${L}deg);" width="${H.width * this.sys.cvsScale}" height="${H.height * this.sys.cvsScale}"></iframe>`);
  const z = this.cfg.searchPath(R, Config.EXT_HTML), X = new Loader().add({ name: R, url: z, xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT });
  return this.sys.crypto && X.use((Y, W) => {
    try {
      Y.data = this.sys.decStr(Y.extension, Y.data);
    } catch (q) {
      this.main.errScript(`[add_frame]Html \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 src:${Y.name} ${q}`, !1);
    }
    W == null || W();
  }), X.load((Y, W) => {
    var Z;
    const q = document.getElementById(e);
    V(this, si)[e] = q, V(this, Os)[e] = !1, q.srcdoc = String((Z = W[R]) == null ? void 0 : Z.data).replace("sn_repRes();", "").replace(
      /\s(?:src|href)=(["'])(\S+)\1/g,
      (K, J, Q) => Q.slice(0, 3) === "../" ? this.sys.cur + Q.slice(4) : K.replace(J, J + z.slice(0, z.lastIndexOf("/") + 1))
    ), q.onload = () => {
      var J;
      this.val.setVal_Nochk("tmp", B, !0), this.val.setVal_Nochk("tmp", B + ".alpha", N), this.val.setVal_Nochk("tmp", B + ".x", H.x), this.val.setVal_Nochk("tmp", B + ".y", H.y), this.val.setVal_Nochk("tmp", B + ".scale_x", M), this.val.setVal_Nochk("tmp", B + ".scale_y", D), this.val.setVal_Nochk("tmp", B + ".rotate", L), this.val.setVal_Nochk("tmp", B + ".width", H.width), this.val.setVal_Nochk("tmp", B + ".height", H.height), this.val.setVal_Nochk("tmp", B + ".visible", $);
      const K = q.contentWindow;
      V(this, As).resvFlameEvent(K), (J = K.sn_repRes) == null || J.call(K, (Q) => {
        var et;
        return GrpLayer.loadPic2Img((et = Q.dataset.src) != null ? et : "", Q);
      }), this.main.resume();
    };
  }), !0;
}, Os = new WeakMap(), Ns = new WeakSet(), iu = function(t) {
  const e = { ...t }, R = this.sys.resolution;
  return new DOMRect(
    argChk_Num(e, "x", 0) * R,
    argChk_Num(e, "y", 0) * R,
    argChk_Num(e, "width", CmnLib.stageW) * R,
    argChk_Num(e, "height", CmnLib.stageH) * R
  );
}, ju = new WeakSet(), Tc = function(t) {
  const { id: e, var_name: R } = t;
  if (!e)
    throw "id\u306F\u5FC5\u9808\u3067\u3059";
  const N = document.getElementById(e);
  if (!N)
    throw `id\u3010${e}\u3011\u306F\u30D5\u30EC\u30FC\u30E0\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  const M = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${M}`))
    throw `frame\u3010${e}\u3011\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u3066\u3044\u307E\u305B\u3093`;
  if (!R)
    throw "var_name\u306F\u5FC5\u9808\u3067\u3059";
  const D = N.contentWindow;
  if (!D.hasOwnProperty(R))
    throw `frame\u3010${e}\u3011\u306B\u5909\u6570/\u95A2\u6570\u3010${R}\u3011\u304C\u3042\u308A\u307E\u305B\u3093\u3002\u5909\u6570\u306F var\u4ED8\u304D\u306B\u3057\u3066\u4E0B\u3055\u3044`;
  const L = D[R];
  return this.val.setVal_Nochk(
    "tmp",
    M + "." + R,
    argChk_Boolean(t, "function", !1) ? L() : L
  ), !1;
}, Vu = new WeakSet(), Sc = function(t) {
  const { id: e, var_name: R, text: N } = t;
  if (!e)
    throw "id\u306F\u5FC5\u9808\u3067\u3059";
  const M = document.getElementById(e);
  if (!M)
    throw `id\u3010${e}\u3011\u306F\u30D5\u30EC\u30FC\u30E0\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  const D = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${D}`))
    throw `frame\u3010${e}\u3011\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u3066\u3044\u307E\u305B\u3093`;
  if (!R)
    throw "var_name\u306F\u5FC5\u9808\u3067\u3059";
  if (!N)
    throw "text\u306F\u5FC5\u9808\u3067\u3059";
  this.val.setVal_Nochk("tmp", D + "." + R, N);
  const L = M.contentWindow;
  return L[R] = N, !1;
}, ho = new WeakMap(), Xu = new WeakSet(), Cc = function(t) {
  const { id: e } = t;
  if (!e)
    throw "id\u306F\u5FC5\u9808\u3067\u3059";
  const R = document.getElementById(e);
  if (!R)
    throw `id\u3010${e}\u3011\u306F\u30D5\u30EC\u30FC\u30E0\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  const N = "const.sn.frm." + e;
  if (!this.val.getVal("tmp:" + N))
    throw `frame\u3010${e}\u3011\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u3066\u3044\u307E\u305B\u3093`;
  const M = R.style;
  if (argChk_Boolean(t, "float", !1) ? M.zIndex = `${++Ae(this, ho)._}` : "index" in t ? M.zIndex = `${argChk_Num(t, "index", 0)}` : t.dive && (M.zIndex = `-${++Ae(this, ho)._}`), "alpha" in t) {
    const L = M.opacity = String(t.alpha);
    this.val.setVal_Nochk("tmp", N + ".alpha", L);
  }
  const D = ot(this, Ns, iu).call(this, t);
  if (("x" in t || "y" in t) && (M.left = `${this.sys.ofsLeft4elm + D.x * this.sys.cvsScale}px`, M.top = `${this.sys.ofsTop4elm + D.y * this.sys.cvsScale}px`, this.val.setVal_Nochk("tmp", N + ".x", D.x), this.val.setVal_Nochk("tmp", N + ".y", D.y)), "scale_x" in t || "scale_y" in t || "rotate" in t) {
    const L = argChk_Num(t, "scale_x", 1), B = argChk_Num(t, "scale_y", 1), $ = argChk_Num(t, "rotate", 0);
    M.transform = `scale(${L}, ${B}) rotate(${$}deg)`, this.val.setVal_Nochk("tmp", N + ".scale_x", L), this.val.setVal_Nochk("tmp", N + ".scale_y", B), this.val.setVal_Nochk("tmp", N + ".rotate", $);
  }
  if ("width" in t && (R.width = String(D.width * this.sys.cvsScale), this.val.setVal_Nochk("tmp", N + ".width", D.width)), "height" in t && (R.height = String(D.height * this.sys.cvsScale), this.val.setVal_Nochk("tmp", N + ".height", D.height)), "visible" in t) {
    const L = argChk_Boolean(t, "visible", !0);
    M.display = L ? "inline" : "none", this.val.setVal_Nochk("tmp", N + ".visible", L);
  }
  if ("b_color" in t && (M.backgroundColor = t.b_color), "disabled" in t) {
    const L = V(this, Os)[e] = argChk_Boolean(t, "disabled", !0);
    R.contentDocument.body.querySelectorAll("input,select").forEach(($) => $.disabled = L);
  }
  return !1;
}, Wu = new WeakSet(), Ic = function(t) {
  var q;
  const { id: e } = t;
  if (!e)
    throw "id\u306F\u5FC5\u9808\u3067\u3059";
  const R = document.getElementById(e);
  if (!R)
    throw `id\u3010${e}\u3011\u306F\u30D5\u30EC\u30FC\u30E0\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  const N = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${N}`, 0))
    throw `frame\u3010${e}\u3011\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u3066\u3044\u307E\u305B\u3093`;
  const M = {};
  "alpha" in t && (M.a = R.style.opacity), ("x" in t || "y" in t || "scale_x" in t || "scale_y" in t || "rotate" in t) && (M.x = Number(this.val.getVal(`tmp:${N}.x`)), M.y = Number(this.val.getVal(`tmp:${N}.y`)), M.sx = Number(this.val.getVal(`tmp:${N}.scale_x`)), M.sy = Number(this.val.getVal(`tmp:${N}.scale_y`)), M.r = Number(this.val.getVal(`tmp:${N}.rotate`))), "width" in t && (M.w = this.val.getVal(`tmp:${N}.width`)), "height" in t && (M.h = this.val.getVal(`tmp:${N}.height`));
  const D = cnvTweenArg(t, M), L = {}, B = argChk_Num(t, "repeat", 1);
  let $ = () => {
  };
  "alpha" in t && (L.a = argChk_Num(D, "alpha", 0), $ = () => {
    R.style.opacity = M.a, this.val.setVal_Nochk("tmp", "alpha", M.a);
  });
  let U = () => {
  };
  const H = ot(this, Ns, iu).call(this, D);
  ("x" in t || "y" in t || "scale_x" in t || "scale_y" in t || "rotate" in t) && (L.x = H.x, L.y = H.y, L.sx = argChk_Num(D, "scale_x", 1), L.sy = argChk_Num(D, "scale_y", 1), L.r = argChk_Num(D, "rotate", 0), U = () => {
    R.style.left = this.sys.ofsLeft4elm + M.x * this.sys.cvsScale + "px", R.style.top = this.sys.ofsTop4elm + M.y * this.sys.cvsScale + "px", R.style.transform = `scale(${M.sx}, ${M.sy}) rotate(${M.r}deg)`, this.val.setVal_Nochk("tmp", N + ".x", M.x), this.val.setVal_Nochk("tmp", N + ".y", M.y), this.val.setVal_Nochk("tmp", N + ".scale_x", M.sx), this.val.setVal_Nochk("tmp", N + ".scale_y", M.sy), this.val.setVal_Nochk("tmp", N + ".rotate", M.r);
  });
  let z = () => {
  };
  "width" in t && (L.w = H.width, z = () => {
    R.width = M.w * this.sys.cvsScale + "px", this.val.setVal_Nochk("tmp", N + ".width", M.w);
  });
  let X = () => {
  };
  "height" in t && (L.h = H.height, X = () => {
    R.height = M.h * this.sys.cvsScale + "px", this.val.setVal_Nochk("tmp", N + ".height", M.h);
  }), this.appPixi.stage.interactive = !1;
  const Y = `frm
${t.id}`, W = new Tween(M).to(L, argChk_Num(t, "time", NaN) * (Boolean(this.val.getVal("tmp:sn.skip.enabled") || V(this, As).isSkippingByKeyDown()) ? 0 : 1)).delay(argChk_Num(t, "delay", 0)).easing(CmnTween.ease(t.ease)).repeat(B === 0 ? 1 / 0 : B - 1).yoyo(argChk_Boolean(t, "yoyo", !1)).onUpdate(() => {
    $(), U(), z(), X();
  }).onComplete(() => {
    var K, J;
    this.appPixi.stage.interactive = !0;
    const Z = this.hTwInf[Y];
    !Z || (delete this.hTwInf[Y], (K = Z.tw) == null || K.stop(), Z.resume && this.main.resume(), (J = Z.onEnd) == null || J.call(Z));
  });
  if ("chain" in t) {
    const Z = this.hTwInf[(q = t.chain) != null ? q : ""];
    if (!Z || !Z.tw)
      throw `${t.chain}\u306F\u5B58\u5728\u3057\u306A\u3044\u30FB\u307E\u305F\u306F\u7D42\u4E86\u3057\u305F\u30C8\u30A5\u30A4\u30FC\u30F3\u3067\u3059`;
    delete Z.onEnd, Z.tw.chain(W);
  } else
    W.start();
  return this.hTwInf[Y] = { tw: W, resume: !1 }, !1;
};
var wr, se, me, Oi, xn, Tn, Ms, Ds, Ls, Sn, co, wh, ai, Gr, Yu, wc, je, qu, Rc, Zu, Pc, Ku, Ac, Qt, Rr, Pr, Fs, Ju, Oc, Bs, nu, Qu, Nc, fo, $s, po, Ni, Mi, Ur, Ie, Di, tl, Mc, we, Ve, nr, el, Dc, rl, Lc, il, Fc, Cn, Ta, nl, Bc, Ke, sl, $c, al, kc, ol, Gc, ul, Uc, ll, Hc, Li, ks, su, Je, hl, zc, Gs, cl, jc, Hr, Fi, Bi, Zn, Ar, Or, fl, Vc, dl, Xc, pl, Wc, vl, Yc, gl, qc, _l, Zc, ml, Kc, yl, Jc, bl, Qc, El, tf, xl, ef, Tl, rf, Sl, nf, Cl, sf, Il, af;
const Ji = class {
  constructor(t, e, R, N, M, D, L, B, $, U) {
    nt(this, co);
    nt(this, Yu);
    nt(this, qu);
    nt(this, Zu);
    nt(this, Ku);
    nt(this, Ju);
    nt(this, Bs);
    nt(this, Qu);
    nt(this, tl);
    nt(this, Ve);
    nt(this, el);
    nt(this, rl);
    nt(this, il);
    nt(this, Cn);
    nt(this, nl);
    nt(this, sl);
    nt(this, al);
    nt(this, ol);
    nt(this, ul);
    nt(this, ll);
    nt(this, ks);
    nt(this, hl);
    nt(this, cl);
    nt(this, Bi);
    nt(this, fl);
    nt(this, dl);
    nt(this, pl);
    nt(this, vl);
    nt(this, gl);
    nt(this, _l);
    nt(this, ml);
    nt(this, yl);
    nt(this, bl);
    nt(this, El);
    nt(this, xl);
    nt(this, Tl);
    nt(this, Sl);
    nt(this, Cl);
    nt(this, Il);
    nt(this, wr, void 0);
    nt(this, se, void 0);
    nt(this, me, void 0);
    nt(this, Oi, void 0);
    nt(this, xn, void 0);
    nt(this, Tn, void 0);
    nt(this, Ms, void 0);
    nt(this, Ds, void 0);
    nt(this, Ls, void 0);
    nt(this, Sn, void 0);
    nt(this, ai, void 0);
    nt(this, Gr, void 0);
    nt(this, je, void 0);
    nt(this, Qt, void 0);
    nt(this, Rr, void 0);
    nt(this, Pr, void 0);
    nt(this, Fs, void 0);
    nt(this, fo, void 0);
    nt(this, $s, void 0);
    nt(this, po, void 0);
    nt(this, Ni, void 0);
    nt(this, Mi, void 0);
    nt(this, Ur, void 0);
    nt(this, Ie, void 0);
    nt(this, Di, void 0);
    nt(this, we, void 0);
    nt(this, Ke, void 0);
    nt(this, Je, void 0);
    nt(this, Gs, void 0);
    nt(this, Hr, void 0);
    nt(this, Fi, void 0);
    nt(this, Ar, void 0);
    nt(this, Or, void 0);
    this.cfg = t, this.hTag = e, this.appPixi = R, this.val = N, this.main = M, this.scrItr = D, this.sys = L, this.sndMng = B, this.alzTagArg = $, this.prpPrs = U, it(this, se, new Container()), it(this, me, new Container()), it(this, Tn, new EventListenerCtn()), it(this, Ms, () => update()), it(this, Ds, {
      attach: (W) => (DesignCast.leaveMode(), !1),
      continue: (W) => (DesignCast.leaveMode(), !1),
      disconnect: (W) => (DesignCast.leaveMode(), !1),
      _enterDesign: (W) => (DesignCast.enterMode(), V(this, Rr).forEach((q) => {
        const Z = V(this, Qt)[q].fore;
        Z.makeDesignCastChildren((K) => K.make()), Z.makeDesignCast((K) => K.make());
      }), ot(this, co, wh).call(this, V(this, Pr)), !1),
      _replaceToken: (W, q) => (DesignCast.replaceToken(q), !1),
      _selectNode: (W, q) => (ot(this, co, wh).call(this, q.node), !1)
    }), it(this, Ls, ""), it(this, Sn, ""), this.getFrmDisabled = (W) => V(this, Oi).getFrmDisabled(W), it(this, ai, void 0), it(this, je, (W, q = this.currentTxtlayForeNeedErr, Z = !0) => q.tagCh("\uFF5C\u3000\u300A" + W + "\u300B")), this.goTxt = () => {
    }, this.breakLine = () => {
    }, this.breakPage = () => {
    }, it(this, Qt, {}), it(this, Rr, []), it(this, Pr, ""), it(this, Fs, ""), it(this, fo, `
precision mediump float;

varying vec2 vTextureCoord;
uniform sampler2D uSampler;

uniform sampler2D rule;
uniform float vague;
uniform float tick;

uniform vec4 inputPixel;
uniform highp vec4 outputFrame;
vec2 getUV(vec2 coord) {
	return coord * inputPixel.xy / outputFrame.zw;
}

void main(void) {
	vec4 fg = texture2D(uSampler, vTextureCoord);
	vec4 ru = texture2D(rule, getUV(vTextureCoord));

	float v = ru.r - tick;
	if (abs(v) < vague) {
		float f_a = fg.a *(0.5 +v /vague *0.5);

		gl_FragColor.rgb = fg.rgb *f_a;
		gl_FragColor.a = f_a;
	}
	else {
		gl_FragColor = (v >= 0.0)? fg : vec4(0);
	}
}`), it(this, $s, {
      rule: Texture.EMPTY,
      vague: 0,
      tick: 0
    }), it(this, po, new Filter(void 0, V(this, fo), V(this, $s))), it(this, Ni, RenderTexture.create({
      width: CmnLib.stageW,
      height: CmnLib.stageH
    })), it(this, Mi, new Sprite(V(this, Ni))), it(this, Ur, RenderTexture.create({
      width: CmnLib.stageW,
      height: CmnLib.stageH
    })), it(this, Ie, new Sprite(V(this, Ur))), it(this, Di, []), it(this, we, { tw: void 0, resume: !1 }), it(this, Ke, {}), it(this, Je, (W) => {
      throw V(this, Fi).call(this), 0;
    }), it(this, Gs, (W) => {
      throw V(this, Fi).call(this), 0;
    }), it(this, Fi, () => {
      throw "\u6587\u5B57\u30EC\u30A4\u30E4\u30FC\u304C\u3042\u308A\u307E\u305B\u3093\u3002\u6587\u5B57\u8868\u793A\u3084\u64CD\u4F5C\u3059\u308B\u524D\u306B\u3001[add_lay layer=\uFF08\u30EC\u30A4\u30E4\u540D\uFF09 class=txt]\u3067\u6587\u5B57\u30EC\u30A4\u30E4\u3092\u8FFD\u52A0\u3057\u3066\u4E0B\u3055\u3044";
    }), it(this, Ar, { text: "" }), it(this, Or, []);
    const H = () => {
      L.cvsResize(), this.cvsResizeDesign(), V(this, Sn) ? V(this, Rr).forEach(
        (W) => V(this, Qt)[W].fore.cvsResizeChildren()
      ) : V(this, Rr).forEach(
        (W) => V(this, Qt)[W].fore.cvsResize()
      ), V(this, Oi).cvsResize(), V(this, Gr).cvsResize();
    };
    if (CmnLib.isMobile)
      V(this, Tn).add(globalThis, "orientationchange", H, { passive: !0 });
    else {
      let W;
      V(this, Tn).add(globalThis, "resize", () => {
        W || (W = setTimeout(() => {
          W = void 0, H();
        }, 1e3 / 60 * 10));
      }, { passive: !0 });
    }
    L.cvsResize(), TxtLayer.init(t, e, N, (W) => this.recText(W), (W) => V(this, Qt)[W.layname].fore === W, R), GrpLayer.init(M, t, R, L, B, N), Button.init(t), it(this, Oi, new FrameMng(this.cfg, this.hTag, this.appPixi, this.val, M, this.sys, V(this, Ke))), L.hFactoryCls.grp = () => new GrpLayer(), L.hFactoryCls.txt = () => new TxtLayer(), e.loadplugin = (W) => ot(this, Zu, Pc).call(this, W), e.snapshot = (W) => ot(this, qu, Rc).call(this, W), e.add_lay = (W) => ot(this, Ku, Ac).call(this, W), e.clear_lay = (W) => ot(this, Qu, Nc).call(this, W), e.finish_trans = () => ot(this, Cn, Ta).call(this), e.lay = (W) => ot(this, Ju, Oc).call(this, W), e.trans = (W) => ot(this, tl, Mc).call(this, W), e.wt = (W) => ot(this, il, Fc).call(this, W), e.quake = (W) => ot(this, nl, Bc).call(this, W), e.stop_quake = (W) => e.finish_trans(W), e.wq = (W) => e.wt(W), e.pause_tsy = (W) => ot(this, ul, Uc).call(this, W), e.resume_tsy = (W) => ot(this, ll, Hc).call(this, W), e.stop_tsy = (W) => ot(this, ol, Gc).call(this, W), e.tsy = (W) => ot(this, sl, $c).call(this, W), e.wait_tsy = (W) => ot(this, al, kc).call(this, W), e.ch = (W) => ot(this, ks, su).call(this, W), e.clear_text = (W) => ot(this, fl, Vc).call(this, W), e.current = (W) => V(this, Gs).call(this, W), e.endlink = (W) => ot(this, dl, Xc).call(this, W), e.er = (W) => ot(this, pl, Wc).call(this, W), e.graph = (W) => ot(this, vl, Yc).call(this, W), e.link = (W) => ot(this, gl, qc).call(this, W), e.r = (W) => ot(this, _l, Zc).call(this, W), e.rec_ch = (W) => ot(this, yl, Jc).call(this, W), e.rec_r = () => ot(this, ml, Kc).call(this), e.reset_rec = (W) => ot(this, bl, Qc).call(this, W), e.ruby2 = (W) => ot(this, El, tf).call(this, W), e.span = (W) => ot(this, xl, ef).call(this, W), e.tcy = (W) => ot(this, Tl, rf).call(this, W), e.add_face = (W) => GrpLayer.add_face(W), e.wv = (W) => GrpLayer.wv(W), e.dump_lay = (W) => ot(this, Sl, nf).call(this, W), e.enable_event = (W) => ot(this, Cl, sf).call(this, W), e.button = (W) => ot(this, Il, af).call(this, W), t.existsBreakline && (this.breakLine = () => V(this, je).call(this, 'grp\uFF5C{"id":"break","pic":"breakline"}')), t.existsBreakpage && (this.breakPage = () => V(this, je).call(this, 'grp\uFF5C{"id":"break","pic":"breakpage"}')), it(this, xn, parseColor(String(t.oCfg.init.bg_color)));
    const z = new Graphics();
    z.beginFill(V(this, xn), 1).lineStyle(0, V(this, xn)).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill(), V(this, se).addChild(z.clone()), V(this, me).addChild(z), V(this, me).visible = !1, it(this, wr, this.appPixi.stage), V(this, wr).addChild(V(this, me)), V(this, wr).addChild(V(this, se)), V(this, wr).addChild(V(this, Mi)), V(this, wr).addChild(V(this, Ie)), this.appPixi.ticker.add(V(this, Ms));
    const X = (W, q) => {
      ot(this, Yu, wc).call(this, Number(q));
    };
    X("", N.getVal("sys:TextLayer.Back.Alpha", 1)), N.defValTrg("sys:TextLayer.Back.Alpha", X);
    const Y = (W, q) => Button.fontFamily = q;
    Y("", N.getVal("tmp:sn.button.fontFamily", Button.fontFamily)), N.defValTrg("tmp:sn.button.fontFamily", Y), N.defTmp("const.sn.log.json", () => JSON.stringify(
      V(this, Ar).text ? [...V(this, Or), V(this, Ar)] : V(this, Or)
    )), N.defTmp("const.sn.last_page_text", () => {
      var W, q;
      return (q = (W = this.currentTxtlayFore) == null ? void 0 : W.pageText) != null ? q : "";
    }), CmnLib.isDbg && (DesignCast.init(this.appPixi, L, D, U, $, this.cfg, V(this, Qt)), this.cvsResizeDesign = () => DesignCast.cvsResizeDesign(), L.addHook((W, q) => {
      var Z, K;
      !((K = (Z = V(this, Ds))[W]) != null && K.call(Z, W, q)) || delete V(this, Ds)[W];
    }));
  }
  cvsResizeDesign() {
  }
  cover(t, e = 0) {
    V(this, ai) && (V(this, wr).removeChild(V(this, ai)), V(this, ai).destroy(), it(this, ai, void 0)), t && V(this, wr).addChild(
      it(this, ai, new Graphics()).beginFill(e).lineStyle(0, e).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill()
    );
  }
  setEvtMng(t) {
    it(this, Gr, t), V(this, Oi).setEvtMng(t), GrpLayer.setEvtMng(t);
  }
  before_destroy() {
    for (const t in V(this, Qt))
      V(this, Qt)[t].destroy();
  }
  destroy() {
    V(this, Tn).clear(), GrpLayer.destroy(), RubySpliter.destroy(), TxtStage.destroy(), TxtLayer.destroy(), V(this, Oi).destroy(), this.stopAllTw(), this.appPixi.ticker.remove(V(this, Ms)), it(Ji, Li, 10);
  }
  stopAllTw() {
    it(this, Ke, {}), removeAll();
  }
  clearBreak() {
    !this.currentTxtlayFore || (this.clearBreak = () => V(this, je).call(this, "del\uFF5Cbreak"), this.clearBreak());
  }
  clickTxtLay() {
    return this.currentTxtlayFore ? ot(this, Ve, nr).call(this).some((t) => {
      const e = V(this, Qt)[t].fore;
      return e instanceof TxtLayer && e.click();
    }) : !1;
  }
  static get msecChWait() {
    return V(Ji, Li);
  }
  static set msecChWait(t) {
    it(Ji, Li, t);
  }
  setNormalChWait() {
    it(Ji, Li, this.scrItr.normalWait);
  }
  get currentTxtlayForeNeedErr() {
    return V(this, Fi).call(this), this.currentTxtlayFore;
  }
  get currentTxtlayFore() {
    if (!!V(this, Hr))
      return V(this, Hr).fore;
  }
  recText(t, e = !1) {
    const R = V(this, Ar);
    if (e) {
      R.text && (R.text = String(R.text).replaceAll("</span><span class='sn_ch'>", ""), V(this, Or).push(R) > this.cfg.oCfg.log.max_len && it(this, Or, V(this, Or).slice(-this.cfg.oCfg.log.max_len))), it(this, Ar, { text: "" });
      return;
    }
    R.text = t.replace(/\\`/, "`"), this.val.setVal_Nochk(
      "save",
      "const.sn.sLog",
      String(this.val.getVal("const.sn.log.json"))
    );
  }
  record() {
    const t = {};
    return V(this, Rr).forEach((e) => {
      const R = V(this, Qt)[e];
      t[e] = {
        cls: R.cls,
        fore: R.fore.record(),
        back: R.back.record()
      };
    }), t;
  }
  playback(t, e) {
    var D, L;
    it(this, Or, JSON.parse(String(this.val.getVal("save:const.sn.sLog")))), it(this, Ar, { text: "" });
    const R = [], N = [];
    for (const B in t) {
      const $ = t[B];
      N.push({ layer: B, idx: $.fore.idx });
      const U = (L = (D = V(this, Qt))[B]) != null ? L : D[B] = new Pages(B, $.cls, V(this, se), V(this, me), {}, this.sys, this.val, { isWait: !1 });
      U.fore.playback($.fore, R), U.back.playback($.back, R);
    }
    const M = V(this, se).children.length;
    Promise.allSettled(R).then(() => {
      N.sort(function(B, $) {
        return B.idx < $.idx ? -1 : B.idx > $.idx ? 1 : 0;
      }), N.forEach((B) => {
        const $ = V(this, Qt)[B.layer];
        if (!$)
          return;
        const U = M > B.idx ? B.idx : M - 1;
        V(this, se).setChildIndex($.fore.spLay, U), V(this, me).setChildIndex($.back.spLay, U);
      }), e();
    }).catch((B) => console.error("fn:LayerMng.ts playback e:%o", B));
  }
};
let LayerMng = Ji;
wr = new WeakMap(), se = new WeakMap(), me = new WeakMap(), Oi = new WeakMap(), xn = new WeakMap(), Tn = new WeakMap(), Ms = new WeakMap(), Ds = new WeakMap(), Ls = new WeakMap(), Sn = new WeakMap(), co = new WeakSet(), wh = function(t) {
  [Ae(this, Ls)._, this.Sn = ""] = t.split("/");
  const e = V(this, Qt)[V(this, Ls)];
  !e || (DesignCast.allHide(), V(this, Sn) ? e.fore.showDesignCastChildren() : e.fore.showDesignCast());
}, ai = new WeakMap(), Gr = new WeakMap(), Yu = new WeakSet(), wc = function(t) {
  ot(this, Ve, nr).call(this).forEach((e) => {
    const R = V(this, Qt)[e];
    R.fore instanceof TxtLayer && (R.fore.chgBackAlpha(t), R.back.chgBackAlpha(t));
  });
}, je = new WeakMap(), qu = new WeakSet(), Rc = function(t) {
  const e = t.fn ? t.fn.slice(0, 10) === "userdata:/" ? t.fn : `downloads:/${t.fn + getDateStr("-", "_", "", "_")}.png` : `downloads:/snapshot${getDateStr("-", "_", "", "_")}.png`, R = this.cfg.searchPath(e);
  if (this.sys.canCapturePage(R))
    return !1;
  const N = getExt(R), M = argChk_Color(t, "b_color", V(this, xn)), D = autoDetectRenderer({
    width: argChk_Num(t, "width", CmnLib.stageW),
    height: argChk_Num(t, "height", CmnLib.stageH),
    backgroundAlpha: M > 16777216 && N === "png" ? 0 : 1,
    antialias: argChk_Boolean(t, "smoothing", !1),
    preserveDrawingBuffer: !0,
    backgroundColor: M & 16777215,
    autoDensity: !0
  }), L = [], B = t.page !== "back" ? "fore" : "back";
  return V(this, we).tw ? L.push(new Promise(($) => {
    V(this, me).visible = !0, V(this, Di).forEach((U) => D.render(U, { clear: !1 })), V(this, me).visible = !1, V(this, Mi).visible = !0, V(this, se).filters = V(this, Ie).filters, V(this, se).visible = !0, D.render(V(this, se), { clear: !1 }), V(this, se).visible = !1, V(this, se).filters = [], $();
  })) : ot(this, Ve, nr).call(this, t.layer).forEach(($) => L.push(new Promise(
    (U) => V(this, Qt)[$][B].snapshot(D, () => U())
  ))), Promise.allSettled(L).then(async () => {
    const $ = RenderTexture.create({ width: D.width, height: D.height, transform: !0 });
    D.render(V(this, wr), { renderTexture: $ }), await this.sys.savePic(
      R,
      D.plugins.extract.base64(Sprite.from($))
    ), V(this, we).tw || ot(this, Ve, nr).call(this, t.layer).forEach((U) => V(this, Qt)[U][B].snapshot_end()), D.destroy(!0);
  }), !1;
}, Zu = new WeakSet(), Pc = function(t) {
  const { fn: e } = t;
  if (!e)
    throw "fn\u306F\u5FC5\u9808\u3067\u3059";
  const R = argChk_Boolean(t, "join", !0);
  switch (getExt(e)) {
    case "css":
      (async () => {
        const N = await fetch(e);
        if (!N.ok)
          throw new Error("Network response was not ok.");
        addStyle(await N.text()), R && this.main.resume();
      })();
      break;
    default:
      throw "\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u306A\u3044\u62E1\u5F35\u5B50\u3067\u3059";
  }
  return R;
}, Ku = new WeakSet(), Ac = function(t) {
  const { layer: e, class: R } = t;
  if (!e)
    throw "layer\u306F\u5FC5\u9808\u3067\u3059";
  if (e.includes(","))
    throw "layer\u540D\u306B\u300C,\u300D\u306F\u4F7F\u3048\u307E\u305B\u3093";
  if (e in V(this, Qt))
    throw `layer\u3010${e}\u3011\u306F\u3059\u3067\u306B\u3042\u308A\u307E\u3059`;
  if (!R)
    throw "cls\u306F\u5FC5\u9808\u3067\u3059";
  const N = { isWait: !1 };
  switch (V(this, Qt)[e] = new Pages(e, R, V(this, se), V(this, me), t, this.sys, this.val, N), V(this, Rr).push(e), R) {
    case "txt":
      V(this, Pr) || (it(this, Fi, () => {
      }), it(this, Je, ot(this, hl, zc)), it(this, Gs, ot(this, cl, jc)), this.hTag.current({ layer: e }), this.goTxt = () => {
        this.val.getVal("sn.skip.enabled") ? it(Ji, Li, 0) : this.setNormalChWait(), ot(this, Ve, nr).call(this).forEach((M) => {
          const D = V(this, Qt)[M].fore;
          D instanceof TxtLayer && V(this, je).call(this, "gotxt\uFF5C", D, !1);
        });
      }), this.val.setVal_Nochk(
        "save",
        "const.sn.layer." + (e != null ? e : V(this, Pr)) + ".enabled",
        !0
      );
      break;
    case "grp":
      if (V(this, Fs))
        break;
      it(this, Fs, e);
      break;
  }
  return this.scrItr.recodeDesign(t), N.isWait;
}, Qt = new WeakMap(), Rr = new WeakMap(), Pr = new WeakMap(), Fs = new WeakMap(), Ju = new WeakSet(), Oc = function(t) {
  const e = ot(this, Bi, Zn).call(this, t), R = V(this, Qt)[e], N = R.back.spLay, M = R.fore.spLay;
  if (argChk_Boolean(t, "float", !1))
    V(this, me).setChildIndex(N, V(this, me).children.length - 1), V(this, se).setChildIndex(M, V(this, se).children.length - 1), ot(this, Bs, nu).call(this);
  else if (t.index)
    argChk_Num(t, "index", 0) && (V(this, me).setChildIndex(N, t.index), V(this, se).setChildIndex(M, t.index), ot(this, Bs, nu).call(this));
  else if (t.dive) {
    const { dive: D } = t;
    let L = 0;
    if (e === D)
      throw "[lay] \u5C5E\u6027 layer\u3068dive\u304C\u540C\u3058\u3010" + D + "\u3011\u3067\u3059";
    const B = V(this, Qt)[D];
    if (!B)
      throw "[lay] \u5C5E\u6027 dive\u3010" + D + "\u3011\u304C\u4E0D\u6B63\u3067\u3059\u3002\u30EC\u30A4\u30E4\u30FC\u304C\u3042\u308A\u307E\u305B\u3093";
    const $ = B.back, U = B.fore, H = V(this, me).getChildIndex($.spLay), z = V(this, se).getChildIndex(U.spLay);
    L = H < z ? H : z, L > V(this, me).getChildIndex(N) && --L, V(this, se).setChildIndex(M, L), V(this, me).setChildIndex(N, L), ot(this, Bs, nu).call(this);
  }
  return t[":id_tag"] = R.fore.name.slice(0, -7), this.scrItr.recodeDesign(t), R.lay(t);
}, Bs = new WeakSet(), nu = function() {
  it(this, Rr, ot(this, rl, Lc).call(this));
}, Qu = new WeakSet(), Nc = function(t) {
  return ot(this, el, Dc).call(this, t, (e) => {
    const R = V(this, Qt)[ot(this, Bi, Zn).call(this, { layer: e })];
    t.page === "both" ? (R.fore.clearLay(t), R.back.clearLay(t)) : R.getPage(t).clearLay(t);
  }), !1;
}, fo = new WeakMap(), $s = new WeakMap(), po = new WeakMap(), Ni = new WeakMap(), Mi = new WeakMap(), Ur = new WeakMap(), Ie = new WeakMap(), Di = new WeakMap(), tl = new WeakSet(), Mc = function(t) {
  ot(this, Cn, Ta).call(this);
  const e = CmnTween.ease(t.ease);
  it(this, Di, []);
  const R = {}, N = [];
  ot(this, Ve, nr).call(this, t.layer).forEach((X) => {
    R[X] = !0, N.push(V(this, Qt)[X].fore);
  });
  const M = [];
  ot(this, Ve, nr).call(this).forEach((X) => {
    const Y = V(this, Qt)[X][R[X] ? "back" : "fore"];
    V(this, Di).push(Y.spLay), M.push(Y);
  }), V(this, Ni).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(V(this, me), { renderTexture: V(this, Ni) });
  let D = () => {
    V(this, me).visible = !0, V(this, Di).forEach((X) => {
      this.appPixi.renderer.render(X, { renderTexture: V(this, Ni), clear: !1 });
    }), V(this, me).visible = !1;
  };
  if (!M.some((X) => X.containMovement)) {
    let X = D;
    D = () => {
      D = () => {
      }, X();
    };
  }
  V(this, Ur).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(V(this, se), { renderTexture: V(this, Ur) });
  let L = () => {
    V(this, se).visible = !0, this.appPixi.renderer.render(V(this, se), { renderTexture: V(this, Ur) }), V(this, se).visible = !1;
  };
  if (!N.some((X) => X.containMovement)) {
    let X = L;
    L = () => {
      L = () => {
      }, X();
    };
  }
  const B = () => {
    D(), V(this, Mi).visible = !0, L(), V(this, Ie).visible = !0;
  };
  V(this, Ie).alpha = 1;
  const $ = () => {
    var Y;
    this.appPixi.ticker && this.appPixi.ticker.remove(B), [Ae(this, se)._, Ae(this, me)._] = [V(this, me), V(this, se)];
    const X = [];
    for (const W in V(this, Qt)) {
      const q = V(this, Qt)[W];
      if (R[W]) {
        q.transPage(X);
        continue;
      }
      const Z = V(this, se).getChildIndex(q.back.spLay);
      V(this, se).removeChild(q.back.spLay), V(this, me).removeChild(q.fore.spLay), V(this, se).addChildAt(q.fore.spLay, Z), V(this, me).addChildAt(q.back.spLay, Z);
    }
    Promise.allSettled(X), V(this, se).visible = !0, V(this, me).visible = !1, V(this, Mi).visible = !1, V(this, Ie).visible = !1, (Y = V(this, we).tw) == null || Y.stop(), V(this, we).resume && this.main.resume(), it(this, we, { tw: void 0, resume: !1 });
  };
  it(this, we, { tw: void 0, resume: !1 });
  const U = argChk_Num(t, "time", 0);
  if (U === 0 || V(this, Gr).isSkippingByKeyDown())
    return $(), !1;
  const H = "glsl" in t;
  if (!H && !("rule" in t))
    return V(this, Ie).filters = [], V(this, we).tw = new Tween(V(this, Ie)).to({ alpha: 0 }, U).delay(argChk_Num(t, "delay", 0)).easing(e).onComplete($).start(), this.appPixi.ticker.add(B), !1;
  const z = H ? new Filter(void 0, t.glsl, V(this, $s)) : V(this, po);
  if (z.uniforms.vague = argChk_Num(t, "vague", 0.04), z.uniforms.tick = 0, V(this, we).tw = new Tween(z.uniforms).to({ tick: 1 }, U).delay(argChk_Num(t, "delay", 0)).easing(e).onComplete($), V(this, Ie).filters = [z], H)
    return V(this, we).tw.start(), this.appPixi.ticker.add(B), !1;
  if (!t.rule)
    throw "rule\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093";
  return GrpLayer.csv2Sprites(t.rule, void 0, (X) => {
    var Y;
    z.uniforms.rule = X.texture, X.destroy(), (Y = V(this, we).tw) == null || Y.start(), this.appPixi.ticker.add(B);
  }), !1;
}, we = new WeakMap(), Ve = new WeakSet(), nr = function(t = "") {
  return t ? t.split(",") : V(this, Rr);
}, el = new WeakSet(), Dc = function(t, e) {
  const R = ot(this, Ve, nr).call(this, t.layer);
  return R.forEach((N) => {
    if (!N)
      return;
    const M = V(this, Qt)[N];
    if (!M)
      throw "\u5B58\u5728\u3057\u306A\u3044layer\u3010" + N + "\u3011\u3067\u3059";
    e(N, M);
  }), R;
}, rl = new WeakSet(), Lc = function(t = "") {
  return ot(this, Ve, nr).call(this, t).sort((e, R) => {
    const N = V(this, se).getChildIndex(V(this, Qt)[e].fore.spLay), M = V(this, se).getChildIndex(V(this, Qt)[R].fore.spLay);
    return N < M ? -1 : N > M ? 1 : 0;
  });
}, il = new WeakSet(), Fc = function(t) {
  return V(this, we).tw ? (V(this, we).resume = !0, V(this, Gr).waitLimitedEvent(t, () => ot(this, Cn, Ta).call(this))) : !1;
}, Cn = new WeakSet(), Ta = function() {
  var t;
  return (t = V(this, we).tw) == null || t.end(), !1;
}, nl = new WeakSet(), Bc = function(t) {
  ot(this, Cn, Ta).call(this);
  const e = argChk_Num(t, "time", NaN);
  if (e === 0 || this.val.getVal("tmp:sn.skip.enabled") || V(this, Gr).isSkippingByKeyDown())
    return !1;
  const R = [];
  ot(this, Ve, nr).call(this, t.layer).forEach((H) => {
    R.push(V(this, Qt)[H].fore.spLay);
  }), V(this, Ur).resize(CmnLib.stageW, CmnLib.stageH);
  const N = () => {
    V(this, se).visible = !0, R.forEach(
      (H) => this.appPixi.renderer.render(H, { renderTexture: V(this, Ur), clear: !1 })
    ), V(this, se).visible = !1;
  };
  V(this, Ie).visible = !0, V(this, Ie).alpha = 1;
  const M = uint(argChk_Num(t, "hmax", 10)), D = uint(argChk_Num(t, "vmax", 10)), L = M === 0 ? () => {
  } : () => V(this, Ie).x = Math.round(Math.random() * M * 2) - M, B = D === 0 ? () => {
  } : () => V(this, Ie).y = Math.round(Math.random() * D * 2) - D;
  V(this, Ie).filters = [];
  const $ = argChk_Num(t, "repeat", 1), U = new Tween(V(this, Ie)).to({ x: 0, y: 0 }, e).delay(argChk_Num(t, "delay", 0)).easing(CmnTween.ease(t.ease)).onUpdate(() => {
    L(), B();
  }).repeat($ === 0 ? 1 / 0 : $ - 1).yoyo(argChk_Boolean(t, "yoyo", !1)).onComplete(() => {
    var H, z;
    (H = this.appPixi.ticker) == null || H.remove(N), V(this, se).visible = !0, V(this, Ie).visible = !1, V(this, Ie).x = 0, V(this, Ie).y = 0, (z = V(this, we).tw) == null || z.stop(), V(this, we).resume && this.main.resume(), it(this, we, { tw: void 0, resume: !1 });
  }).start();
  return it(this, we, { tw: U, resume: !1 }), this.appPixi.ticker.add(N), !1;
}, Ke = new WeakMap(), sl = new WeakSet(), $c = function(t) {
  var z, X;
  if (!t.layer)
    throw "layer\u306F\u5FC5\u9808\u3067\u3059";
  const e = ot(this, Bi, Zn).call(this, t);
  let R = V(this, Qt)[e].fore, N = () => {
  };
  const M = V(this, Gr).isSkippingByKeyDown();
  !M && "render" in t && (R.renderStart(), N = () => R.renderEnd());
  const D = cnvTweenArg(t, R), L = argChk_Num(t, "repeat", 1), B = (z = t.name) != null ? z : t.layer, $ = new Tween(R).to(D, argChk_Num(t, "time", NaN) * (Boolean(this.val.getVal("tmp:sn.skip.enabled") || M) ? 0 : 1)).delay(argChk_Num(t, "delay", 0)).easing(CmnTween.ease(t.ease)).repeat(L === 0 ? 1 / 0 : L - 1).yoyo(argChk_Boolean(t, "yoyo", !1)).onComplete(() => {
    var W, q;
    const Y = V(this, Ke)[B];
    !Y || (N(), delete V(this, Ke)[B], (W = Y.tw) == null || W.stop(), Y.resume && this.main.resume(), (q = Y.onEnd) == null || q.call(Y));
  });
  if ("chain" in t) {
    const Y = V(this, Ke)[(X = t.chain) != null ? X : ""];
    if (!(Y != null && Y.tw))
      throw `${t.chain}\u306F\u5B58\u5728\u3057\u306A\u3044\u30FB\u307E\u305F\u306F\u7D42\u4E86\u3057\u305F\u30C8\u30A5\u30A4\u30FC\u30F3\u3067\u3059`;
    delete Y.onEnd, Y.tw.chain($);
  } else
    $.start();
  const U = argChk_Boolean(t, "arrive", !1), H = argChk_Boolean(t, "backlay", !1);
  return V(this, Ke)[B] = { tw: $, resume: !1, onEnd: () => {
    if (U && Object.assign(R, D), H) {
      const Y = V(this, Qt)[e].back.spLay;
      for (const W in hMemberCnt)
        Y[W] = R[W];
    }
  } }, !1;
}, al = new WeakSet(), kc = function(t) {
  var N;
  const e = "id" in t ? `frm
${t.id}` : (N = t.name) != null ? N : t.layer;
  if (!e)
    throw "\u30C8\u30A5\u30A4\u30FC\u30F3\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093";
  const R = V(this, Ke)[e];
  return R != null && R.tw ? R.resume = V(this, Gr).waitEvent(
    () => {
      var M;
      return (M = R.tw) == null ? void 0 : M.end();
    },
    argChk_Boolean(t, "canskip", !0),
    argChk_Boolean(t, "global", !1)
  ) : !1;
}, ol = new WeakSet(), Gc = function(t) {
  var R, N, M;
  const e = "id" in t ? `frm
${t.id}` : (R = t.name) != null ? R : t.layer;
  if (!e)
    throw "\u30C8\u30A5\u30A4\u30FC\u30F3\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093";
  return (M = (N = V(this, Ke)[e]) == null ? void 0 : N.tw) == null || M.end(), !1;
}, ul = new WeakSet(), Uc = function(t) {
  var R, N, M;
  const e = "id" in t ? `frm
${t.id}` : (R = t.name) != null ? R : t.layer;
  if (!e)
    throw "\u30C8\u30A5\u30A4\u30FC\u30F3\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093";
  return (M = (N = V(this, Ke)[e]) == null ? void 0 : N.tw) == null || M.pause(), !1;
}, ll = new WeakSet(), Hc = function(t) {
  var R, N, M;
  const e = "id" in t ? `frm
${t.id}` : (R = t.name) != null ? R : t.layer;
  if (!e)
    throw "\u30C8\u30A5\u30A4\u30FC\u30F3\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093";
  return (M = (N = V(this, Ke)[e]) == null ? void 0 : N.tw) == null || M.resume(), !1;
}, Li = new WeakMap(), ks = new WeakSet(), su = function(t) {
  const { text: e } = t;
  if (!e)
    throw "text\u306F\u5FC5\u9808\u3067\u3059";
  const R = V(this, Je).call(this, t);
  delete t.text, this.val.getVal("tmp:sn.skip.enabled") ? t.wait = 0 : "wait" in t && argChk_Num(t, "wait", NaN);
  const N = encodeURIComponent(JSON.stringify(t));
  V(this, je).call(this, "add\uFF5C" + N, R);
  const M = argChk_Boolean(t, "record", !0), D = this.val.doRecLog();
  return M || this.val.setVal_Nochk("save", "sn.doRecLog", M), R.tagCh(e.replaceAll("[r]", `
`)), M || this.val.setVal_Nochk("save", "sn.doRecLog", D), V(this, je).call(this, "add_close\uFF5C", R), !1;
}, Je = new WeakMap(), hl = new WeakSet(), zc = function(t) {
  const e = ot(this, Bi, Zn).call(this, t, V(this, Pr)), N = V(this, Qt)[e].getPage(t);
  if (!(N instanceof TxtLayer))
    throw e + "\u306FTxtLayer\u3067\u306F\u3042\u308A\u307E\u305B\u3093";
  return N;
}, Gs = new WeakMap(), cl = new WeakSet(), jc = function(t) {
  const { layer: e } = t;
  if (!e)
    throw "[current] layer\u306F\u5FC5\u9808\u3067\u3059";
  if (it(this, Hr, V(this, Qt)[e]), !(V(this, Hr).getPage(t) instanceof TxtLayer))
    throw `${e}\u306FTxtLayer\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  return this.recText("", !0), it(this, Pr, e), this.val.setVal_Nochk("save", "const.sn.mesLayer", e), ot(this, Ve, nr).call(this).forEach((R) => {
    const N = V(this, Qt)[R];
    N.fore instanceof TxtLayer && (N.fore.isCur = N.back.isCur = R === e);
  }), !1;
}, Hr = new WeakMap(), Fi = new WeakMap(), Bi = new WeakSet(), Zn = function(t, e = "") {
  var N;
  const R = (N = t.layer) != null ? N : e;
  if (R.includes(","))
    throw "layer\u540D\u306B\u300C,\u300D\u306F\u4F7F\u3048\u307E\u305B\u3093";
  if (!(R in V(this, Qt)))
    throw "\u5C5E\u6027 layer\u3010" + R + "\u3011\u304C\u4E0D\u6B63\u3067\u3059\u3002\u30EC\u30A4\u30E4\u30FC\u304C\u3042\u308A\u307E\u305B\u3093";
  return t.layer = R;
}, Ar = new WeakMap(), Or = new WeakMap(), fl = new WeakSet(), Vc = function(t) {
  const e = V(this, Je).call(this, t);
  return t.layer === V(this, Pr) && t.page === "fore" && this.recText("", !0), e.clearText(), !1;
}, dl = new WeakSet(), Xc = function(t) {
  return V(this, je).call(this, "endlink\uFF5C", V(this, Je).call(this, t)), !1;
}, pl = new WeakSet(), Wc = function(t) {
  return argChk_Boolean(t, "rec_page_break", !0) && this.recText("", !0), V(this, Hr) && (V(this, Hr).fore.clearLay(t), V(this, Hr).back.clearLay(t)), !1;
}, vl = new WeakSet(), Yc = function(t) {
  if (!t.pic)
    throw "[graph] pic\u306F\u5FC5\u9808\u3067\u3059";
  const e = encodeURIComponent(JSON.stringify(t));
  return V(this, je).call(this, "grp\uFF5C" + e, V(this, Je).call(this, t)), !1;
}, gl = new WeakSet(), qc = function(t) {
  var R, N, M;
  (R = t.style) != null || (t.style = "background-color: rgba(255,0,0,0.5);"), (N = t.style_hover) != null || (t.style_hover = "background-color: rgba(255,0,0,0.9);"), (M = t.style_clicked) != null || (t.style_clicked = t.style);
  const e = encodeURIComponent(JSON.stringify(t));
  return V(this, je).call(this, "link\uFF5C" + e, V(this, Je).call(this, t)), !1;
}, _l = new WeakSet(), Zc = function(t) {
  return t.text = `
`, ot(this, ks, su).call(this, t);
}, ml = new WeakSet(), Kc = function() {
  return this.recText(`
`), !1;
}, yl = new WeakSet(), Jc = function(t) {
  var e;
  return it(this, Ar, t), this.recText((e = t.text) != null ? e : ""), !1;
}, bl = new WeakSet(), Qc = function(t) {
  var e;
  return it(this, Or, []), it(this, Ar, { text: (e = t.text) != null ? e : "" }), this.val.setVal_Nochk(
    "save",
    "const.sn.sLog",
    t.text ? `[{text:"${t.text}"}]` : "[]"
  ), !1;
}, El = new WeakSet(), tf = function(t) {
  const { t: e, r: R } = t;
  if (!e)
    throw "[ruby2] t\u306F\u5FC5\u9808\u3067\u3059";
  if (!R)
    throw "[ruby2] r\u306F\u5FC5\u9808\u3067\u3059";
  return t.text = "\uFF5C" + encodeURIComponent(e) + "\u300A" + encodeURIComponent(R) + "\u300B", delete t.t, delete t.r, ot(this, ks, su).call(this, t);
}, xl = new WeakSet(), ef = function(t) {
  const e = encodeURIComponent(JSON.stringify(t));
  return V(this, je).call(this, "span\uFF5C" + e, V(this, Je).call(this, t)), !1;
}, Tl = new WeakSet(), rf = function(t) {
  if (!t.t)
    throw "[tcy] t\u306F\u5FC5\u9808\u3067\u3059";
  const e = encodeURIComponent(JSON.stringify(t));
  return V(this, je).call(this, "tcy\uFF5C" + e, V(this, Je).call(this, t)), !1;
}, Sl = new WeakSet(), nf = function(t) {
  return console.group("\u{1F95F} [dump_lay]"), ot(this, Ve, nr).call(this, t.layer).forEach((e) => {
    const R = V(this, Qt)[e];
    try {
      console.info(
        `%c${R.fore.name.slice(0, -7)} %o`,
        `color:#${CmnLib.isDarkMode ? "49F" : "05A"};`,
        JSON.parse(`{"back":{${R.back.dump()}}, "fore":{${R.fore.dump()}}}`)
      );
    } catch (N) {
      console.error("dump_lay err:%o", N), console.error(`   back:${R.back.dump()}`), console.error(`   fore:${R.fore.dump()}`);
    }
  }), console.groupEnd(), !1;
}, Cl = new WeakSet(), sf = function(t) {
  const e = ot(this, Bi, Zn).call(this, t, V(this, Pr)), R = argChk_Boolean(t, "enabled", !0);
  return V(this, Je).call(this, t).enabled = R, this.val.setVal_Nochk("save", "const.sn.layer." + e + ".enabled", R), !1;
}, Il = new WeakSet(), af = function(t) {
  var e, R, N;
  return Pages.argChk_page(t, "back"), (e = t.clicksebuf) != null || (t.clicksebuf = "SYS"), (R = t.entersebuf) != null || (t.entersebuf = "SYS"), (N = t.leavesebuf) != null || (t.leavesebuf = "SYS"), t.fn || (t.fn = this.scrItr.scriptFn), V(this, Je).call(this, t).addButton(t), this.scrItr.recodeDesign(t), !1;
}, nt(LayerMng, Li, 10);
var be, pe, Us, wl, of, vo, In, Sa;
class FocusMng {
  constructor() {
    nt(this, wl);
    nt(this, In);
    nt(this, be, []);
    nt(this, pe, -1);
    nt(this, Us, new EventListenerCtn());
    nt(this, vo, CmnLib.debugLog ? (t) => console.log(`\u{1F47E} <FocusMng idx:${t} btn:%o`, V(this, be)[t].btn) : () => {
    });
  }
  destroy() {
    it(this, be, []), it(this, pe, -1), V(this, Us).clear();
  }
  add(t, e, R) {
    var L;
    if (V(this, be).findIndex((B) => B.btn === t) >= 0)
      return;
    if (t instanceof Container) {
      t.on("pointerdown", () => {
        for (let B = V(this, be).length - 1; B >= 0; --B)
          if (V(this, be)[B].btn === t) {
            it(this, pe, B);
            return;
          }
        it(this, pe, -1);
      }), V(this, be).push({ btn: t, on: e, off: R });
      return;
    }
    V(this, Us).add(t, "focus", () => {
      for (let B = V(this, be).length - 1; B >= 0; --B)
        if (V(this, be)[B].btn === t) {
          it(this, pe, B);
          return;
        }
      it(this, pe, -1);
    });
    let N = (B) => {
    }, M = t.localName === "button" || t.localName === "a" ? (B) => !B.isTrusted && B.key === "Enter" : (B) => B.key === "Enter";
    const D = t;
    switch ((L = D.type) != null ? L : "") {
      case "checkbox":
        N = () => D.checked = !D.checked;
        break;
      case "":
        t.querySelectorAll("input[type]").length > 0 && (N = (B) => ot(this, wl, of).call(this, t, B.key), M = () => !1);
        break;
      case "range":
        N = (B) => {
          B.isTrusted || (B.key === "ArrowUp" ? D.stepUp() : D.stepDown());
        };
        break;
      case "text":
      case "textarea":
        N = (B) => {
          var U;
          if (B.isTrusted)
            return;
          let $ = ((U = D.selectionStart) != null ? U : 0) + (B.key === "ArrowUp" ? -1 : 1);
          $ < 0 && ($ = 0), D.setSelectionRange($, $);
        };
        break;
    }
    V(this, Us).add(t, "keydown", (B) => {
      if (!(B.key !== "ArrowUp" && B.key !== "ArrowDown" && B.key !== "Enter")) {
        if (B.stopPropagation(), B.stopImmediatePropagation(), M(B)) {
          t.dispatchEvent(new MouseEvent("click"));
          return;
        }
        N(B);
      }
    }, { passive: !0 }), t.hasAttribute("tabindex") || (t.tabIndex = 0), V(this, be).push({ btn: t, on: e, off: R });
  }
  remove(t) {
    const e = V(this, be).findIndex((R) => R.btn === t);
    e < 0 || (V(this, be).splice(e, 1), V(this, be).length === 0 ? it(this, pe, -1) : e <= V(this, pe) && --Ae(this, pe)._);
  }
  isFocus(t) {
    return V(this, pe) < 0 ? !1 : V(this, be)[V(this, pe)].btn === t;
  }
  prev() {
    ot(this, In, Sa).call(this);
    const t = V(this, be).length;
    if (t !== 0) {
      --Ae(this, pe)._ < 0 && it(this, pe, t - 1);
      for (let e = t; e >= 1; --e) {
        const R = (V(this, pe) + e) % t;
        if (V(this, be)[R].on()) {
          it(this, pe, R), V(this, vo).call(this, R);
          return;
        }
      }
      it(this, pe, -1);
    }
  }
  next() {
    ot(this, In, Sa).call(this);
    const t = V(this, be).length;
    if (t !== 0) {
      ++Ae(this, pe)._ >= t && it(this, pe, 0);
      for (let e = 0; e < t; ++e) {
        const R = (V(this, pe) + e) % t;
        if (V(this, be)[R].on()) {
          it(this, pe, R), V(this, vo).call(this, R);
          return;
        }
      }
      it(this, pe, -1);
    }
  }
  getFocus() {
    if (V(this, pe) < 0)
      return;
    ot(this, In, Sa).call(this), V(this, pe) >= V(this, be).length && it(this, pe, 0);
    const t = V(this, be)[V(this, pe)];
    return t.on() ? t.btn : void 0;
  }
  blur() {
    ot(this, In, Sa).call(this), it(this, pe, -1), globalThis.focus();
  }
}
be = new WeakMap(), pe = new WeakMap(), Us = new WeakMap(), wl = new WeakSet(), of = function(t, e) {
  const R = t.querySelectorAll("input[type]"), N = R.length;
  for (let M = 0; M < N; ++M)
    if (!!R[M].checked) {
      R[(M + N + (e === "ArrowUp" ? -1 : 1)) % N].checked = !0;
      break;
    }
}, vo = new WeakMap(), In = new WeakSet(), Sa = function() {
  for (let t = V(this, be).length - 1; t >= 0; --t) {
    const e = V(this, be)[t];
    !(e.btn instanceof Container) || e.btn.parent ? e.off() : V(this, be).splice(t, 1);
  }
};
var top = "top", bottom = "bottom", right = "right", left = "left", auto = "auto", basePlacements = [top, bottom, right, left], start = "start", end = "end", clippingParents = "clippingParents", viewport = "viewport", popper = "popper", reference = "reference", variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(o, t) {
  return o.concat([t + "-" + start, t + "-" + end]);
}, []), placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(o, t) {
  return o.concat([t, t + "-" + start, t + "-" + end]);
}, []), beforeRead = "beforeRead", read$6 = "read", afterRead = "afterRead", beforeMain = "beforeMain", main$1 = "main", afterMain = "afterMain", beforeWrite = "beforeWrite", write$6 = "write", afterWrite = "afterWrite", modifierPhases = [beforeRead, read$6, afterRead, beforeMain, main$1, afterMain, beforeWrite, write$6, afterWrite];
function getNodeName(o) {
  return o ? (o.nodeName || "").toLowerCase() : null;
}
function getWindow(o) {
  if (o == null)
    return window;
  if (o.toString() !== "[object Window]") {
    var t = o.ownerDocument;
    return t && t.defaultView || window;
  }
  return o;
}
function isElement(o) {
  var t = getWindow(o).Element;
  return o instanceof t || o instanceof Element;
}
function isHTMLElement(o) {
  var t = getWindow(o).HTMLElement;
  return o instanceof t || o instanceof HTMLElement;
}
function isShadowRoot(o) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = getWindow(o).ShadowRoot;
  return o instanceof t || o instanceof ShadowRoot;
}
function applyStyles(o) {
  var t = o.state;
  Object.keys(t.elements).forEach(function(e) {
    var R = t.styles[e] || {}, N = t.attributes[e] || {}, M = t.elements[e];
    !isHTMLElement(M) || !getNodeName(M) || (Object.assign(M.style, R), Object.keys(N).forEach(function(D) {
      var L = N[D];
      L === !1 ? M.removeAttribute(D) : M.setAttribute(D, L === !0 ? "" : L);
    }));
  });
}
function effect$2(o) {
  var t = o.state, e = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
    Object.keys(t.elements).forEach(function(R) {
      var N = t.elements[R], M = t.attributes[R] || {}, D = Object.keys(t.styles.hasOwnProperty(R) ? t.styles[R] : e[R]), L = D.reduce(function(B, $) {
        return B[$] = "", B;
      }, {});
      !isHTMLElement(N) || !getNodeName(N) || (Object.assign(N.style, L), Object.keys(M).forEach(function(B) {
        N.removeAttribute(B);
      }));
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(o) {
  return o.split("-")[0];
}
var max = Math.max, min = Math.min, round = Math.round;
function getUAString() {
  var o = navigator.userAgentData;
  return o != null && o.brands ? o.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(o, t, e) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  var R = o.getBoundingClientRect(), N = 1, M = 1;
  t && isHTMLElement(o) && (N = o.offsetWidth > 0 && round(R.width) / o.offsetWidth || 1, M = o.offsetHeight > 0 && round(R.height) / o.offsetHeight || 1);
  var D = isElement(o) ? getWindow(o) : window, L = D.visualViewport, B = !isLayoutViewport() && e, $ = (R.left + (B && L ? L.offsetLeft : 0)) / N, U = (R.top + (B && L ? L.offsetTop : 0)) / M, H = R.width / N, z = R.height / M;
  return {
    width: H,
    height: z,
    top: U,
    right: $ + H,
    bottom: U + z,
    left: $,
    x: $,
    y: U
  };
}
function getLayoutRect(o) {
  var t = getBoundingClientRect(o), e = o.offsetWidth, R = o.offsetHeight;
  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - R) <= 1 && (R = t.height), {
    x: o.offsetLeft,
    y: o.offsetTop,
    width: e,
    height: R
  };
}
function contains(o, t) {
  var e = t.getRootNode && t.getRootNode();
  if (o.contains(t))
    return !0;
  if (e && isShadowRoot(e)) {
    var R = t;
    do {
      if (R && o.isSameNode(R))
        return !0;
      R = R.parentNode || R.host;
    } while (R);
  }
  return !1;
}
function getComputedStyle$1(o) {
  return getWindow(o).getComputedStyle(o);
}
function isTableElement(o) {
  return ["table", "td", "th"].indexOf(getNodeName(o)) >= 0;
}
function getDocumentElement(o) {
  return ((isElement(o) ? o.ownerDocument : o.document) || window.document).documentElement;
}
function getParentNode(o) {
  return getNodeName(o) === "html" ? o : o.assignedSlot || o.parentNode || (isShadowRoot(o) ? o.host : null) || getDocumentElement(o);
}
function getTrueOffsetParent(o) {
  return !isHTMLElement(o) || getComputedStyle$1(o).position === "fixed" ? null : o.offsetParent;
}
function getContainingBlock(o) {
  var t = /firefox/i.test(getUAString()), e = /Trident/i.test(getUAString());
  if (e && isHTMLElement(o)) {
    var R = getComputedStyle$1(o);
    if (R.position === "fixed")
      return null;
  }
  var N = getParentNode(o);
  for (isShadowRoot(N) && (N = N.host); isHTMLElement(N) && ["html", "body"].indexOf(getNodeName(N)) < 0; ) {
    var M = getComputedStyle$1(N);
    if (M.transform !== "none" || M.perspective !== "none" || M.contain === "paint" || ["transform", "perspective"].indexOf(M.willChange) !== -1 || t && M.willChange === "filter" || t && M.filter && M.filter !== "none")
      return N;
    N = N.parentNode;
  }
  return null;
}
function getOffsetParent(o) {
  for (var t = getWindow(o), e = getTrueOffsetParent(o); e && isTableElement(e) && getComputedStyle$1(e).position === "static"; )
    e = getTrueOffsetParent(e);
  return e && (getNodeName(e) === "html" || getNodeName(e) === "body" && getComputedStyle$1(e).position === "static") ? t : e || getContainingBlock(o) || t;
}
function getMainAxisFromPlacement(o) {
  return ["top", "bottom"].indexOf(o) >= 0 ? "x" : "y";
}
function within(o, t, e) {
  return max(o, min(t, e));
}
function withinMaxClamp(o, t, e) {
  var R = within(o, t, e);
  return R > e ? e : R;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(o) {
  return Object.assign({}, getFreshSideObject(), o);
}
function expandToHashMap(o, t) {
  return t.reduce(function(e, R) {
    return e[R] = o, e;
  }, {});
}
var toPaddingObject = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, mergePaddingObject(typeof t != "number" ? t : expandToHashMap(t, basePlacements));
};
function arrow(o) {
  var t, e = o.state, R = o.name, N = o.options, M = e.elements.arrow, D = e.modifiersData.popperOffsets, L = getBasePlacement(e.placement), B = getMainAxisFromPlacement(L), $ = [left, right].indexOf(L) >= 0, U = $ ? "height" : "width";
  if (!(!M || !D)) {
    var H = toPaddingObject(N.padding, e), z = getLayoutRect(M), X = B === "y" ? top : left, Y = B === "y" ? bottom : right, W = e.rects.reference[U] + e.rects.reference[B] - D[B] - e.rects.popper[U], q = D[B] - e.rects.reference[B], Z = getOffsetParent(M), K = Z ? B === "y" ? Z.clientHeight || 0 : Z.clientWidth || 0 : 0, J = W / 2 - q / 2, Q = H[X], et = K - z[U] - H[Y], tt = K / 2 - z[U] / 2 + J, st = within(Q, tt, et), rt = B;
    e.modifiersData[R] = (t = {}, t[rt] = st, t.centerOffset = st - tt, t);
  }
}
function effect$1(o) {
  var t = o.state, e = o.options, R = e.element, N = R === void 0 ? "[data-popper-arrow]" : R;
  if (N != null && !(typeof N == "string" && (N = t.elements.popper.querySelector(N), !N))) {
    if (process.env.NODE_ENV !== "production" && (isHTMLElement(N) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !contains(t.elements.popper, N)) {
      process.env.NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    t.elements.arrow = N;
  }
}
const arrow$1 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(o) {
  return o.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(o) {
  var t = o.x, e = o.y, R = window, N = R.devicePixelRatio || 1;
  return {
    x: round(t * N) / N || 0,
    y: round(e * N) / N || 0
  };
}
function mapToStyles(o) {
  var t, e = o.popper, R = o.popperRect, N = o.placement, M = o.variation, D = o.offsets, L = o.position, B = o.gpuAcceleration, $ = o.adaptive, U = o.roundOffsets, H = o.isFixed, z = D.x, X = z === void 0 ? 0 : z, Y = D.y, W = Y === void 0 ? 0 : Y, q = typeof U == "function" ? U({
    x: X,
    y: W
  }) : {
    x: X,
    y: W
  };
  X = q.x, W = q.y;
  var Z = D.hasOwnProperty("x"), K = D.hasOwnProperty("y"), J = left, Q = top, et = window;
  if ($) {
    var tt = getOffsetParent(e), st = "clientHeight", rt = "clientWidth";
    if (tt === getWindow(e) && (tt = getDocumentElement(e), getComputedStyle$1(tt).position !== "static" && L === "absolute" && (st = "scrollHeight", rt = "scrollWidth")), tt = tt, N === top || (N === left || N === right) && M === end) {
      Q = bottom;
      var at = H && tt === et && et.visualViewport ? et.visualViewport.height : tt[st];
      W -= at - R.height, W *= B ? 1 : -1;
    }
    if (N === left || (N === top || N === bottom) && M === end) {
      J = right;
      var ut = H && tt === et && et.visualViewport ? et.visualViewport.width : tt[rt];
      X -= ut - R.width, X *= B ? 1 : -1;
    }
  }
  var dt = Object.assign({
    position: L
  }, $ && unsetSides), ct = U === !0 ? roundOffsetsByDPR({
    x: X,
    y: W
  }) : {
    x: X,
    y: W
  };
  if (X = ct.x, W = ct.y, B) {
    var pt;
    return Object.assign({}, dt, (pt = {}, pt[Q] = K ? "0" : "", pt[J] = Z ? "0" : "", pt.transform = (et.devicePixelRatio || 1) <= 1 ? "translate(" + X + "px, " + W + "px)" : "translate3d(" + X + "px, " + W + "px, 0)", pt));
  }
  return Object.assign({}, dt, (t = {}, t[Q] = K ? W + "px" : "", t[J] = Z ? X + "px" : "", t.transform = "", t));
}
function computeStyles(o) {
  var t = o.state, e = o.options, R = e.gpuAcceleration, N = R === void 0 ? !0 : R, M = e.adaptive, D = M === void 0 ? !0 : M, L = e.roundOffsets, B = L === void 0 ? !0 : L;
  if (process.env.NODE_ENV !== "production") {
    var $ = getComputedStyle$1(t.elements.popper).transitionProperty || "";
    D && ["transform", "top", "right", "bottom", "left"].some(function(H) {
      return $.indexOf(H) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var U = {
    placement: getBasePlacement(t.placement),
    variation: getVariation(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: N,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, mapToStyles(Object.assign({}, U, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: D,
    roundOffsets: B
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, mapToStyles(Object.assign({}, U, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: B
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: !0
};
function effect(o) {
  var t = o.state, e = o.instance, R = o.options, N = R.scroll, M = N === void 0 ? !0 : N, D = R.resize, L = D === void 0 ? !0 : D, B = getWindow(t.elements.popper), $ = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return M && $.forEach(function(U) {
    U.addEventListener("scroll", e.update, passive);
  }), L && B.addEventListener("resize", e.update, passive), function() {
    M && $.forEach(function(U) {
      U.removeEventListener("scroll", e.update, passive);
    }), L && B.removeEventListener("resize", e.update, passive);
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(o) {
  return o.replace(/left|right|bottom|top/g, function(t) {
    return hash$1[t];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(o) {
  return o.replace(/start|end/g, function(t) {
    return hash[t];
  });
}
function getWindowScroll(o) {
  var t = getWindow(o), e = t.pageXOffset, R = t.pageYOffset;
  return {
    scrollLeft: e,
    scrollTop: R
  };
}
function getWindowScrollBarX(o) {
  return getBoundingClientRect(getDocumentElement(o)).left + getWindowScroll(o).scrollLeft;
}
function getViewportRect(o, t) {
  var e = getWindow(o), R = getDocumentElement(o), N = e.visualViewport, M = R.clientWidth, D = R.clientHeight, L = 0, B = 0;
  if (N) {
    M = N.width, D = N.height;
    var $ = isLayoutViewport();
    ($ || !$ && t === "fixed") && (L = N.offsetLeft, B = N.offsetTop);
  }
  return {
    width: M,
    height: D,
    x: L + getWindowScrollBarX(o),
    y: B
  };
}
function getDocumentRect(o) {
  var t, e = getDocumentElement(o), R = getWindowScroll(o), N = (t = o.ownerDocument) == null ? void 0 : t.body, M = max(e.scrollWidth, e.clientWidth, N ? N.scrollWidth : 0, N ? N.clientWidth : 0), D = max(e.scrollHeight, e.clientHeight, N ? N.scrollHeight : 0, N ? N.clientHeight : 0), L = -R.scrollLeft + getWindowScrollBarX(o), B = -R.scrollTop;
  return getComputedStyle$1(N || e).direction === "rtl" && (L += max(e.clientWidth, N ? N.clientWidth : 0) - M), {
    width: M,
    height: D,
    x: L,
    y: B
  };
}
function isScrollParent(o) {
  var t = getComputedStyle$1(o), e = t.overflow, R = t.overflowX, N = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + N + R);
}
function getScrollParent(o) {
  return ["html", "body", "#document"].indexOf(getNodeName(o)) >= 0 ? o.ownerDocument.body : isHTMLElement(o) && isScrollParent(o) ? o : getScrollParent(getParentNode(o));
}
function listScrollParents(o, t) {
  var e;
  t === void 0 && (t = []);
  var R = getScrollParent(o), N = R === ((e = o.ownerDocument) == null ? void 0 : e.body), M = getWindow(R), D = N ? [M].concat(M.visualViewport || [], isScrollParent(R) ? R : []) : R, L = t.concat(D);
  return N ? L : L.concat(listScrollParents(getParentNode(D)));
}
function rectToClientRect(o) {
  return Object.assign({}, o, {
    left: o.x,
    top: o.y,
    right: o.x + o.width,
    bottom: o.y + o.height
  });
}
function getInnerBoundingClientRect(o, t) {
  var e = getBoundingClientRect(o, !1, t === "fixed");
  return e.top = e.top + o.clientTop, e.left = e.left + o.clientLeft, e.bottom = e.top + o.clientHeight, e.right = e.left + o.clientWidth, e.width = o.clientWidth, e.height = o.clientHeight, e.x = e.left, e.y = e.top, e;
}
function getClientRectFromMixedType(o, t, e) {
  return t === viewport ? rectToClientRect(getViewportRect(o, e)) : isElement(t) ? getInnerBoundingClientRect(t, e) : rectToClientRect(getDocumentRect(getDocumentElement(o)));
}
function getClippingParents(o) {
  var t = listScrollParents(getParentNode(o)), e = ["absolute", "fixed"].indexOf(getComputedStyle$1(o).position) >= 0, R = e && isHTMLElement(o) ? getOffsetParent(o) : o;
  return isElement(R) ? t.filter(function(N) {
    return isElement(N) && contains(N, R) && getNodeName(N) !== "body";
  }) : [];
}
function getClippingRect(o, t, e, R) {
  var N = t === "clippingParents" ? getClippingParents(o) : [].concat(t), M = [].concat(N, [e]), D = M[0], L = M.reduce(function(B, $) {
    var U = getClientRectFromMixedType(o, $, R);
    return B.top = max(U.top, B.top), B.right = min(U.right, B.right), B.bottom = min(U.bottom, B.bottom), B.left = max(U.left, B.left), B;
  }, getClientRectFromMixedType(o, D, R));
  return L.width = L.right - L.left, L.height = L.bottom - L.top, L.x = L.left, L.y = L.top, L;
}
function computeOffsets(o) {
  var t = o.reference, e = o.element, R = o.placement, N = R ? getBasePlacement(R) : null, M = R ? getVariation(R) : null, D = t.x + t.width / 2 - e.width / 2, L = t.y + t.height / 2 - e.height / 2, B;
  switch (N) {
    case top:
      B = {
        x: D,
        y: t.y - e.height
      };
      break;
    case bottom:
      B = {
        x: D,
        y: t.y + t.height
      };
      break;
    case right:
      B = {
        x: t.x + t.width,
        y: L
      };
      break;
    case left:
      B = {
        x: t.x - e.width,
        y: L
      };
      break;
    default:
      B = {
        x: t.x,
        y: t.y
      };
  }
  var $ = N ? getMainAxisFromPlacement(N) : null;
  if ($ != null) {
    var U = $ === "y" ? "height" : "width";
    switch (M) {
      case start:
        B[$] = B[$] - (t[U] / 2 - e[U] / 2);
        break;
      case end:
        B[$] = B[$] + (t[U] / 2 - e[U] / 2);
        break;
    }
  }
  return B;
}
function detectOverflow(o, t) {
  t === void 0 && (t = {});
  var e = t, R = e.placement, N = R === void 0 ? o.placement : R, M = e.strategy, D = M === void 0 ? o.strategy : M, L = e.boundary, B = L === void 0 ? clippingParents : L, $ = e.rootBoundary, U = $ === void 0 ? viewport : $, H = e.elementContext, z = H === void 0 ? popper : H, X = e.altBoundary, Y = X === void 0 ? !1 : X, W = e.padding, q = W === void 0 ? 0 : W, Z = mergePaddingObject(typeof q != "number" ? q : expandToHashMap(q, basePlacements)), K = z === popper ? reference : popper, J = o.rects.popper, Q = o.elements[Y ? K : z], et = getClippingRect(isElement(Q) ? Q : Q.contextElement || getDocumentElement(o.elements.popper), B, U, D), tt = getBoundingClientRect(o.elements.reference), st = computeOffsets({
    reference: tt,
    element: J,
    strategy: "absolute",
    placement: N
  }), rt = rectToClientRect(Object.assign({}, J, st)), at = z === popper ? rt : tt, ut = {
    top: et.top - at.top + Z.top,
    bottom: at.bottom - et.bottom + Z.bottom,
    left: et.left - at.left + Z.left,
    right: at.right - et.right + Z.right
  }, dt = o.modifiersData.offset;
  if (z === popper && dt) {
    var ct = dt[N];
    Object.keys(ut).forEach(function(pt) {
      var mt = [right, bottom].indexOf(pt) >= 0 ? 1 : -1, vt = [top, bottom].indexOf(pt) >= 0 ? "y" : "x";
      ut[pt] += ct[vt] * mt;
    });
  }
  return ut;
}
function computeAutoPlacement(o, t) {
  t === void 0 && (t = {});
  var e = t, R = e.placement, N = e.boundary, M = e.rootBoundary, D = e.padding, L = e.flipVariations, B = e.allowedAutoPlacements, $ = B === void 0 ? placements : B, U = getVariation(R), H = U ? L ? variationPlacements : variationPlacements.filter(function(Y) {
    return getVariation(Y) === U;
  }) : basePlacements, z = H.filter(function(Y) {
    return $.indexOf(Y) >= 0;
  });
  z.length === 0 && (z = H, process.env.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var X = z.reduce(function(Y, W) {
    return Y[W] = detectOverflow(o, {
      placement: W,
      boundary: N,
      rootBoundary: M,
      padding: D
    })[getBasePlacement(W)], Y;
  }, {});
  return Object.keys(X).sort(function(Y, W) {
    return X[Y] - X[W];
  });
}
function getExpandedFallbackPlacements(o) {
  if (getBasePlacement(o) === auto)
    return [];
  var t = getOppositePlacement(o);
  return [getOppositeVariationPlacement(o), t, getOppositeVariationPlacement(t)];
}
function flip(o) {
  var t = o.state, e = o.options, R = o.name;
  if (!t.modifiersData[R]._skip) {
    for (var N = e.mainAxis, M = N === void 0 ? !0 : N, D = e.altAxis, L = D === void 0 ? !0 : D, B = e.fallbackPlacements, $ = e.padding, U = e.boundary, H = e.rootBoundary, z = e.altBoundary, X = e.flipVariations, Y = X === void 0 ? !0 : X, W = e.allowedAutoPlacements, q = t.options.placement, Z = getBasePlacement(q), K = Z === q, J = B || (K || !Y ? [getOppositePlacement(q)] : getExpandedFallbackPlacements(q)), Q = [q].concat(J).reduce(function(wt, Lt) {
      return wt.concat(getBasePlacement(Lt) === auto ? computeAutoPlacement(t, {
        placement: Lt,
        boundary: U,
        rootBoundary: H,
        padding: $,
        flipVariations: Y,
        allowedAutoPlacements: W
      }) : Lt);
    }, []), et = t.rects.reference, tt = t.rects.popper, st = /* @__PURE__ */ new Map(), rt = !0, at = Q[0], ut = 0; ut < Q.length; ut++) {
      var dt = Q[ut], ct = getBasePlacement(dt), pt = getVariation(dt) === start, mt = [top, bottom].indexOf(ct) >= 0, vt = mt ? "width" : "height", _t = detectOverflow(t, {
        placement: dt,
        boundary: U,
        rootBoundary: H,
        altBoundary: z,
        padding: $
      }), xt = mt ? pt ? right : left : pt ? bottom : top;
      et[vt] > tt[vt] && (xt = getOppositePlacement(xt));
      var At = getOppositePlacement(xt), yt = [];
      if (M && yt.push(_t[ct] <= 0), L && yt.push(_t[xt] <= 0, _t[At] <= 0), yt.every(function(wt) {
        return wt;
      })) {
        at = dt, rt = !1;
        break;
      }
      st.set(dt, yt);
    }
    if (rt)
      for (var ht = Y ? 3 : 1, bt = function(Lt) {
        var ft = Q.find(function(Gt) {
          var Dt = st.get(Gt);
          if (Dt)
            return Dt.slice(0, Lt).every(function(Bt) {
              return Bt;
            });
        });
        if (ft)
          return at = ft, "break";
      }, Ct = ht; Ct > 0; Ct--) {
        var Mt = bt(Ct);
        if (Mt === "break")
          break;
      }
    t.placement !== at && (t.modifiersData[R]._skip = !0, t.placement = at, t.reset = !0);
  }
}
const flip$1 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function getSideOffsets(o, t, e) {
  return e === void 0 && (e = {
    x: 0,
    y: 0
  }), {
    top: o.top - t.height - e.y,
    right: o.right - t.width + e.x,
    bottom: o.bottom - t.height + e.y,
    left: o.left - t.width - e.x
  };
}
function isAnySideFullyClipped(o) {
  return [top, right, bottom, left].some(function(t) {
    return o[t] >= 0;
  });
}
function hide(o) {
  var t = o.state, e = o.name, R = t.rects.reference, N = t.rects.popper, M = t.modifiersData.preventOverflow, D = detectOverflow(t, {
    elementContext: "reference"
  }), L = detectOverflow(t, {
    altBoundary: !0
  }), B = getSideOffsets(D, R), $ = getSideOffsets(L, N, M), U = isAnySideFullyClipped(B), H = isAnySideFullyClipped($);
  t.modifiersData[e] = {
    referenceClippingOffsets: B,
    popperEscapeOffsets: $,
    isReferenceHidden: U,
    hasPopperEscaped: H
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": U,
    "data-popper-escaped": H
  });
}
const hide$1 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(o, t, e) {
  var R = getBasePlacement(o), N = [left, top].indexOf(R) >= 0 ? -1 : 1, M = typeof e == "function" ? e(Object.assign({}, t, {
    placement: o
  })) : e, D = M[0], L = M[1];
  return D = D || 0, L = (L || 0) * N, [left, right].indexOf(R) >= 0 ? {
    x: L,
    y: D
  } : {
    x: D,
    y: L
  };
}
function offset(o) {
  var t = o.state, e = o.options, R = o.name, N = e.offset, M = N === void 0 ? [0, 0] : N, D = placements.reduce(function(U, H) {
    return U[H] = distanceAndSkiddingToXY(H, t.rects, M), U;
  }, {}), L = D[t.placement], B = L.x, $ = L.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += B, t.modifiersData.popperOffsets.y += $), t.modifiersData[R] = D;
}
const offset$1 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(o) {
  var t = o.state, e = o.name;
  t.modifiersData[e] = computeOffsets({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(o) {
  return o === "x" ? "y" : "x";
}
function preventOverflow(o) {
  var t = o.state, e = o.options, R = o.name, N = e.mainAxis, M = N === void 0 ? !0 : N, D = e.altAxis, L = D === void 0 ? !1 : D, B = e.boundary, $ = e.rootBoundary, U = e.altBoundary, H = e.padding, z = e.tether, X = z === void 0 ? !0 : z, Y = e.tetherOffset, W = Y === void 0 ? 0 : Y, q = detectOverflow(t, {
    boundary: B,
    rootBoundary: $,
    padding: H,
    altBoundary: U
  }), Z = getBasePlacement(t.placement), K = getVariation(t.placement), J = !K, Q = getMainAxisFromPlacement(Z), et = getAltAxis(Q), tt = t.modifiersData.popperOffsets, st = t.rects.reference, rt = t.rects.popper, at = typeof W == "function" ? W(Object.assign({}, t.rects, {
    placement: t.placement
  })) : W, ut = typeof at == "number" ? {
    mainAxis: at,
    altAxis: at
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, at), dt = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, ct = {
    x: 0,
    y: 0
  };
  if (!!tt) {
    if (M) {
      var pt, mt = Q === "y" ? top : left, vt = Q === "y" ? bottom : right, _t = Q === "y" ? "height" : "width", xt = tt[Q], At = xt + q[mt], yt = xt - q[vt], ht = X ? -rt[_t] / 2 : 0, bt = K === start ? st[_t] : rt[_t], Ct = K === start ? -rt[_t] : -st[_t], Mt = t.elements.arrow, wt = X && Mt ? getLayoutRect(Mt) : {
        width: 0,
        height: 0
      }, Lt = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : getFreshSideObject(), ft = Lt[mt], Gt = Lt[vt], Dt = within(0, st[_t], wt[_t]), Bt = J ? st[_t] / 2 - ht - Dt - ft - ut.mainAxis : bt - Dt - ft - ut.mainAxis, Ot = J ? -st[_t] / 2 + ht + Dt + Gt + ut.mainAxis : Ct + Dt + Gt + ut.mainAxis, Et = t.elements.arrow && getOffsetParent(t.elements.arrow), Ht = Et ? Q === "y" ? Et.clientTop || 0 : Et.clientLeft || 0 : 0, It = (pt = dt == null ? void 0 : dt[Q]) != null ? pt : 0, St = xt + Bt - It - Ht, Nt = xt + Ot - It, $t = within(X ? min(At, St) : At, xt, X ? max(yt, Nt) : yt);
      tt[Q] = $t, ct[Q] = $t - xt;
    }
    if (L) {
      var Rt, Jt = Q === "x" ? top : left, Kt = Q === "x" ? bottom : right, ae = tt[et], Se = et === "y" ? "height" : "width", De = ae + q[Jt], ee = ae - q[Kt], Re = [top, left].indexOf(Z) !== -1, ve = (Rt = dt == null ? void 0 : dt[et]) != null ? Rt : 0, he = Re ? De : ae - st[Se] - rt[Se] - ve + ut.altAxis, oe = Re ? ae + st[Se] + rt[Se] - ve - ut.altAxis : ee, te = X && Re ? withinMaxClamp(he, ae, oe) : within(X ? he : De, ae, X ? oe : ee);
      tt[et] = te, ct[et] = te - ae;
    }
    t.modifiersData[R] = ct;
  }
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(o) {
  return {
    scrollLeft: o.scrollLeft,
    scrollTop: o.scrollTop
  };
}
function getNodeScroll(o) {
  return o === getWindow(o) || !isHTMLElement(o) ? getWindowScroll(o) : getHTMLElementScroll(o);
}
function isElementScaled(o) {
  var t = o.getBoundingClientRect(), e = round(t.width) / o.offsetWidth || 1, R = round(t.height) / o.offsetHeight || 1;
  return e !== 1 || R !== 1;
}
function getCompositeRect(o, t, e) {
  e === void 0 && (e = !1);
  var R = isHTMLElement(t), N = isHTMLElement(t) && isElementScaled(t), M = getDocumentElement(t), D = getBoundingClientRect(o, N, e), L = {
    scrollLeft: 0,
    scrollTop: 0
  }, B = {
    x: 0,
    y: 0
  };
  return (R || !R && !e) && ((getNodeName(t) !== "body" || isScrollParent(M)) && (L = getNodeScroll(t)), isHTMLElement(t) ? (B = getBoundingClientRect(t, !0), B.x += t.clientLeft, B.y += t.clientTop) : M && (B.x = getWindowScrollBarX(M))), {
    x: D.left + L.scrollLeft - B.x,
    y: D.top + L.scrollTop - B.y,
    width: D.width,
    height: D.height
  };
}
function order(o) {
  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), R = [];
  o.forEach(function(M) {
    t.set(M.name, M);
  });
  function N(M) {
    e.add(M.name);
    var D = [].concat(M.requires || [], M.requiresIfExists || []);
    D.forEach(function(L) {
      if (!e.has(L)) {
        var B = t.get(L);
        B && N(B);
      }
    }), R.push(M);
  }
  return o.forEach(function(M) {
    e.has(M.name) || N(M);
  }), R;
}
function orderModifiers(o) {
  var t = order(o);
  return modifierPhases.reduce(function(e, R) {
    return e.concat(t.filter(function(N) {
      return N.phase === R;
    }));
  }, []);
}
function debounce(o) {
  var t;
  return function() {
    return t || (t = new Promise(function(e) {
      Promise.resolve().then(function() {
        t = void 0, e(o());
      });
    })), t;
  };
}
function format(o) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), R = 1; R < t; R++)
    e[R - 1] = arguments[R];
  return [].concat(e).reduce(function(N, M) {
    return N.replace(/%s/, M);
  }, o);
}
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(o) {
  o.forEach(function(t) {
    [].concat(Object.keys(t), VALID_PROPERTIES).filter(function(e, R, N) {
      return N.indexOf(e) === R;
    }).forEach(function(e) {
      switch (e) {
        case "name":
          typeof t.name != "string" && console.error(format(INVALID_MODIFIER_ERROR, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"'));
          break;
        case "enabled":
          typeof t.enabled != "boolean" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"'));
          break;
        case "phase":
          modifierPhases.indexOf(t.phase) < 0 && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(t.phase) + '"'));
          break;
        case "fn":
          typeof t.fn != "function" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "effect":
          t.effect != null && typeof t.effect != "function" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "requires":
          t.requires != null && !Array.isArray(t.requires) && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(t.requiresIfExists) || console.error(format(INVALID_MODIFIER_ERROR, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(R) {
            return '"' + R + '"';
          }).join(", ") + '; but "' + e + '" was provided.');
      }
      t.requires && t.requires.forEach(function(R) {
        o.find(function(N) {
          return N.name === R;
        }) == null && console.error(format(MISSING_DEPENDENCY_ERROR, String(t.name), R, R));
      });
    });
  });
}
function uniqueBy(o, t) {
  var e = /* @__PURE__ */ new Set();
  return o.filter(function(R) {
    var N = t(R);
    if (!e.has(N))
      return e.add(N), !0;
  });
}
function mergeByName(o) {
  var t = o.reduce(function(e, R) {
    var N = e[R.name];
    return e[R.name] = N ? Object.assign({}, N, R, {
      options: Object.assign({}, N.options, R.options),
      data: Object.assign({}, N.data, R.data)
    }) : R, e;
  }, {});
  return Object.keys(t).map(function(e) {
    return t[e];
  });
}
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var o = arguments.length, t = new Array(o), e = 0; e < o; e++)
    t[e] = arguments[e];
  return !t.some(function(R) {
    return !(R && typeof R.getBoundingClientRect == "function");
  });
}
function popperGenerator(o) {
  o === void 0 && (o = {});
  var t = o, e = t.defaultModifiers, R = e === void 0 ? [] : e, N = t.defaultOptions, M = N === void 0 ? DEFAULT_OPTIONS : N;
  return function(L, B, $) {
    $ === void 0 && ($ = M);
    var U = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, M),
      modifiersData: {},
      elements: {
        reference: L,
        popper: B
      },
      attributes: {},
      styles: {}
    }, H = [], z = !1, X = {
      state: U,
      setOptions: function(Z) {
        var K = typeof Z == "function" ? Z(U.options) : Z;
        W(), U.options = Object.assign({}, M, U.options, K), U.scrollParents = {
          reference: isElement(L) ? listScrollParents(L) : L.contextElement ? listScrollParents(L.contextElement) : [],
          popper: listScrollParents(B)
        };
        var J = orderModifiers(mergeByName([].concat(R, U.options.modifiers)));
        if (U.orderedModifiers = J.filter(function(dt) {
          return dt.enabled;
        }), process.env.NODE_ENV !== "production") {
          var Q = uniqueBy([].concat(J, U.options.modifiers), function(dt) {
            var ct = dt.name;
            return ct;
          });
          if (validateModifiers(Q), getBasePlacement(U.options.placement) === auto) {
            var et = U.orderedModifiers.find(function(dt) {
              var ct = dt.name;
              return ct === "flip";
            });
            et || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var tt = getComputedStyle$1(B), st = tt.marginTop, rt = tt.marginRight, at = tt.marginBottom, ut = tt.marginLeft;
          [st, rt, at, ut].some(function(dt) {
            return parseFloat(dt);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return Y(), X.update();
      },
      forceUpdate: function() {
        if (!z) {
          var Z = U.elements, K = Z.reference, J = Z.popper;
          if (!areValidElements(K, J)) {
            process.env.NODE_ENV !== "production" && console.error(INVALID_ELEMENT_ERROR);
            return;
          }
          U.rects = {
            reference: getCompositeRect(K, getOffsetParent(J), U.options.strategy === "fixed"),
            popper: getLayoutRect(J)
          }, U.reset = !1, U.placement = U.options.placement, U.orderedModifiers.forEach(function(dt) {
            return U.modifiersData[dt.name] = Object.assign({}, dt.data);
          });
          for (var Q = 0, et = 0; et < U.orderedModifiers.length; et++) {
            if (process.env.NODE_ENV !== "production" && (Q += 1, Q > 100)) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
            if (U.reset === !0) {
              U.reset = !1, et = -1;
              continue;
            }
            var tt = U.orderedModifiers[et], st = tt.fn, rt = tt.options, at = rt === void 0 ? {} : rt, ut = tt.name;
            typeof st == "function" && (U = st({
              state: U,
              options: at,
              name: ut,
              instance: X
            }) || U);
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(q) {
          X.forceUpdate(), q(U);
        });
      }),
      destroy: function() {
        W(), z = !0;
      }
    };
    if (!areValidElements(L, B))
      return process.env.NODE_ENV !== "production" && console.error(INVALID_ELEMENT_ERROR), X;
    X.setOptions($).then(function(q) {
      !z && $.onFirstUpdate && $.onFirstUpdate(q);
    });
    function Y() {
      U.orderedModifiers.forEach(function(q) {
        var Z = q.name, K = q.options, J = K === void 0 ? {} : K, Q = q.effect;
        if (typeof Q == "function") {
          var et = Q({
            state: U,
            name: Z,
            instance: X,
            options: J
          }), tt = function() {
          };
          H.push(et || tt);
        }
      });
    }
    function W() {
      H.forEach(function(q) {
        return q();
      }), H = [];
    }
    return X;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1], createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
const { GamepadListener } = require("gamepad.js");
var Qe, $i, Ne, go, _o, Rh, mo, Ph, yo, Ah, Hs, zs, bo, Oh, xe, mr, oi, ui, Eo, ki, Kn, xo, To, ke, js, Vs, So, Rl, uf, Co, wn, Pl, lf, Io, Nh, Al, hf, wo, Mh, Rn, Ca, Pn, Ol, cf, Nl, ff, yr, Ml, df, Dl, pf, Xs, au, li, An, On, Ll, vf, Xe;
class EventMng {
  constructor(t, e, R, N, M, D, L, B, $) {
    nt(this, _o);
    nt(this, mo);
    nt(this, yo);
    nt(this, bo);
    nt(this, ki);
    nt(this, Rl);
    nt(this, Pl);
    nt(this, Io);
    nt(this, Al);
    nt(this, wo);
    nt(this, Rn);
    nt(this, Ol);
    nt(this, Nl);
    nt(this, Ml);
    nt(this, Dl);
    nt(this, Xs);
    nt(this, Ll);
    nt(this, Qe, new EventListenerCtn());
    nt(this, $i, new GamepadListener({
      analog: !1,
      deadZone: 0.3
    }));
    nt(this, Ne, new FocusMng());
    nt(this, go, (t) => {
    });
    nt(this, Hs, !1);
    nt(this, zs, !1);
    nt(this, xe, {});
    nt(this, mr, {});
    nt(this, oi, !1);
    nt(this, ui, !1);
    nt(this, Eo, (t) => {
      var e;
      return (e = V(this, xe)[t]) != null ? e : V(this, mr)[t];
    });
    nt(this, xo, () => {
      it(this, xo, () => {
      }), this.scrItr.firstWait();
    });
    nt(this, To, {
      getBoundingClientRect: (t = 0, e = 0) => DOMRect.fromRect({ x: t, y: e, width: 0, height: 0 })
    });
    nt(this, ke, void 0);
    nt(this, js, void 0);
    nt(this, Vs, void 0);
    nt(this, So, {
      placement: "bottom",
      fallbackPlacements: ["top", "bottom"]
    });
    nt(this, Co, (t, e) => {
    });
    nt(this, wn, new EventListenerCtn());
    nt(this, Pn, () => this.layMng.goTxt());
    nt(this, yr, () => !1);
    nt(this, li, () => {
    });
    nt(this, An, new n());
    nt(this, On, "sn:notice_comp_txt");
    nt(this, Xe, {
      Alt: 0,
      Meta: 0,
      Control: 0,
      ArrowDown: 0,
      End: 0,
      Enter: 0,
      Escape: 0,
      " ": 0,
      GoBack: 0
    });
    var Y;
    if (this.cfg = t, this.hTag = e, this.appPixi = R, this.main = N, this.layMng = M, this.val = D, this.sndMng = L, this.scrItr = B, this.sys = $, e.clear_event = (W) => ot(this, Pl, lf).call(this, W), e.event = (W) => ot(this, Al, hf).call(this, W), e.l = (W) => ot(this, Ol, cf).call(this, W), e.p = (W) => ot(this, Nl, ff).call(this, W), e.s = () => (this.scrItr.recodePage(), ot(this, ki, Kn).call(this, () => {
    }, !1, !0)), e.set_cancel_skip = () => ot(this, Ml, df).call(this), e.set_focus = (W) => ot(this, Dl, pf).call(this, W), e.wait = (W) => ot(this, Xs, au).call(this, W), e.waitclick = () => ot(this, Ll, vf).call(this), L.setEvtMng(this), B.setOtherObj(this, M), TxtLayer.setEvtMng(N, this, $), M.setEvtMng(this), $.setFire((W, q) => this.fire(W, q)), CmnLib.isDbg) {
      const W = {
        pause: () => {
          if (it(this, oi, !0), !V(this, ui))
            return;
          const q = {};
          this.scrItr.recodeDesign(q), this.sys.callHook("_enterDesign", q), this.sys.send2Dbg("_enterDesign", q);
        },
        stopOnBreakpoint: () => it(this, oi, !0),
        stopOnDataBreakpoint: () => it(this, oi, !0),
        continue: () => it(this, oi, !1),
        disconnect: () => it(this, oi, !1)
      };
      W.attach = W.stopOnEntry = W.stopOnStep = W.stopOnStepIn = W.stopOnStepOut = W.stopOnBackstep = W.pause, $.addHook((q) => {
        var Z;
        return (Z = W[q]) == null ? void 0 : Z.call(W);
      });
    }
    addStyle(`
.sn_hint {
	background-color: #3c3225;
	color: white;
	padding: 4px 8px;
	border-radius: 4px;
	font-size: 1.2em;
	z-index: 10000;
	pointer-events: none;
	user-select: none;
}

.sn_hint_ar,
.sn_hint_ar::before {
	position: absolute;
	width: 8px;
	height: 8px;
	background: inherit;
}
.sn_hint_ar {
	visibility: hidden;
}
.sn_hint_ar::before {
	visibility: visible;
	content: '';
	transform: rotate(45deg);
}

.sn_hint[data-popper-placement^='top']		> .sn_hint_ar {bottom: -4px;}
.sn_hint[data-popper-placement^='bottom']	> .sn_hint_ar {top: -4px;}
.sn_hint[data-popper-placement^='left']		> .sn_hint_ar {right: -4px;}
.sn_hint[data-popper-placement^='right']	> .sn_hint_ar {left: -4px;}
`), Array.from(document.getElementsByClassName("sn_hint")).forEach((W) => {
      var q;
      return (q = W.parentElement) == null ? void 0 : q.removeChild(W);
    }), (Y = R.view.parentElement) == null || Y.insertAdjacentHTML("beforeend", `
<div class="sn_hint" role="tooltip">
	<span>Dummy</span>
	<div class="sn_hint_ar" data-popper-arrow></div>
</div>`), it(this, ke, document.querySelector(".sn_hint")), it(this, js, V(this, ke).querySelector("span")), it(this, Vs, createPopper(V(this, To), V(this, ke))), V(this, ke).hidden = !0, R.stage.interactive = !0, CmnLib.isMobile ? R.stage.on("pointerdown", (W) => this.fire("click", W)) : V(this, Qe).add(R.stage, "pointerdown", (W) => {
      switch (W.data.button) {
        case 0:
          this.fire("click", W);
          break;
        case 1:
          this.fire("middleclick", W);
          break;
      }
    }), V(this, Qe).add(window, "keydown", (W) => ot(this, _o, Rh).call(this, W)), V(this, Qe).add(R.view, "contextmenu", (W) => ot(this, mo, Ph).call(this, W));
    const U = (W) => {
      CmnLib.isDarkMode = W.matches, D.setVal_Nochk("tmp", "const.sn.isDarkMode", CmnLib.isDarkMode);
    }, H = globalThis.matchMedia("(prefers-color-scheme: dark)");
    U(H), V(this, Qe).add(H, "change", (W) => {
      U(W), this.fire("sn:chgDarkMode", W);
    }), "WheelEvent" in window && (V(this, Qe).add(R.view, "wheel", (W) => ot(this, yo, Ah).call(this, W), { passive: !0 }), it(this, go, (W) => V(this, Qe).add(W, "wheel", (q) => ot(this, yo, Ah).call(this, q), { passive: !0 })), it(this, Co, (W, q) => W.add(R.view, "wheel", (Z) => {
      Z.isComposing || Z.deltaY <= 0 || (Z.stopPropagation(), q());
    }))), CmnLib.debugLog && (V(this, $i).on("gamepad:connected", (W) => console.log(`\u{1F47A}<'gamepad:connected' index:${W.detail.index} id:${W.detail.gamepad.id}`)), V(this, $i).on("gamepad:disconnected", (W) => console.log(`\u{1F47A}<'gamepad:disconnected' index:${W.detail.index} id:${W.detail.gamepad.id}`)));
    const z = [
      "",
      "ArrowUp",
      "",
      "ArrowLeft",
      "",
      "ArrowRight",
      "",
      "ArrowDown",
      ""
    ], X = [0, 0];
    V(this, $i).on("gamepad:axis", (W) => {
      if (!document.hasFocus() || W.detail.stick !== 0)
        return;
      X[W.detail.axis] = W.detail.value;
      const q = (X[1] + 1) * 3 + (X[0] + 1), Z = z[q];
      if (!Z)
        return;
      const K = V(this, Ne).getFocus();
      (!K || K instanceof Container ? globalThis : K).dispatchEvent(new KeyboardEvent("keydown", { key: Z, bubbles: !0 })), !(!K || K instanceof Container) && K.getAttribute("type") === "range" && K.dispatchEvent(new InputEvent("input", { bubbles: !0 }));
    }), V(this, $i).on("gamepad:button", (W) => {
      if (!(!document.hasFocus() || W.detail.value === 0))
        if (W.detail.button % 2 === 0) {
          const q = V(this, Ne).getFocus();
          (!q || q instanceof Container ? globalThis : q).dispatchEvent(new KeyboardEvent("keydown", { key: "Enter", bubbles: !0 }));
        } else
          R.view.dispatchEvent(new Event("contextmenu"));
    }), V(this, $i).start(), V(this, Qe).add(window, "keyup", (W) => {
      W.isComposing || W.key in V(this, Xe) && (V(this, Xe)[W.key] = 0);
    }), D.defTmp("const.sn.key.alternate", () => V(this, Xe).Alt > 0), D.defTmp("const.sn.key.command", () => V(this, Xe).Meta > 0), D.defTmp("const.sn.key.control", () => V(this, Xe).Control > 0), D.defTmp("const.sn.key.end", () => V(this, Xe).End > 0), D.defTmp("const.sn.key.escape", () => V(this, Xe).Escape > 0), D.defTmp("const.sn.key.back", () => V(this, Xe).GoBack > 0);
  }
  resvFlameEvent(t) {
    V(this, Qe).add(t, "keydown", (e) => ot(this, _o, Rh).call(this, e)), V(this, Qe).add(t, "contextmenu", (e) => ot(this, mo, Ph).call(this, e)), V(this, go).call(this, t);
  }
  destroy() {
    V(this, Ne).destroy(), V(this, Qe).clear();
  }
  fire(t, e) {
    var M;
    if (V(this, yr).call(this) || !V(this, ui) || V(this, oi))
      return;
    const R = t.toLowerCase();
    if (CmnLib.debugLog && console.log(`\u{1F47A} fire<(key:\`${R}\` type:${e.type} e:%o)`, { ...e }), R === "enter") {
      const D = V(this, Ne).getFocus();
      if (D instanceof Container) {
        D.emit("pointerdown", new Event("pointerdown"));
        return;
      }
    }
    const N = V(this, Eo).call(this, R);
    if (!N) {
      R.slice(0, 5) === "swipe" && globalThis.scrollBy(
        -e.deltaX,
        -e.deltaY
      );
      return;
    }
    R.slice(-5) !== "wheel" && ((M = e.preventDefault) == null || M.call(e)), e.stopPropagation(), !(R.slice(0, 4) !== "dom=" && this.layMng.clickTxtLay()) && (it(this, ui, !1), N(e), V(this, ke).hidden = !0);
  }
  popLocalEvts() {
    const t = V(this, xe);
    return it(this, xe, {}), t;
  }
  pushLocalEvts(t) {
    it(this, xe, t);
  }
  waitEvent(t, e = !0, R = !1) {
    if (e && R)
      throw "canskip\u3068global\u3092\u540C\u6642\u306Btrue\u6307\u5B9A\u3067\u304D\u307E\u305B\u3093";
    if (this.val.getVal("tmp:sn.skip.enabled")) {
      if (this.val.getVal("tmp:sn.skip.all") || this.scrItr.isNextKidoku)
        return t(), !1;
      V(this, yr).call(this);
    }
    return ot(this, ki, Kn).call(this, t, e, R);
  }
  unButton(t) {
    V(this, Ne).remove(t);
  }
  button(t, e, R, N, M) {
    var H, z;
    !t.fn && !t.label && this.main.errScript("fn\u307E\u305F\u306Flabel\u306F\u5FC5\u9808\u3067\u3059"), e.interactive = e.buttonMode = !0;
    const D = (z = (H = t.key) == null ? void 0 : H.toLowerCase()) != null ? z : " ";
    t.fn || (t.fn = this.scrItr.scriptFn);
    const L = argChk_Boolean(t, "global", !1);
    L ? V(this, mr)[D] = () => this.main.resumeByJumpOrCall(t) : V(this, xe)[D] = () => this.main.resumeByJumpOrCall(t), e.on("pointerdown", (X) => this.fire(D, X));
    const B = t.hint ? () => ot(this, Rl, uf).call(this, t, e) : () => {
    }, $ = () => {
      R(), V(this, ke).hidden = !0;
    }, U = () => (B(), N());
    if (e.on("pointerover", U), e.on("pointerout", () => {
      V(this, Ne).isFocus(e) ? U() : $();
    }), e.on("pointerdown", () => {
      V(this, ke).hidden = !0;
      const X = V(this, Ne).getFocus();
      M(), X instanceof Button && X.normal();
    }), e.on(
      "pointerup",
      CmnLib.isMobile ? $ : () => {
        V(this, Ne).isFocus(e) ? U() : $();
      }
    ), V(this, Ne).add(e, U, $), t.clickse && (this.cfg.searchPath(t.clickse, Config.EXT_SOUND), e.on("pointerdown", () => {
      const X = { fn: t.clickse, join: !1 };
      t.clicksebuf && (X.buf = t.clicksebuf), this.hTag.playse(X);
    })), t.enterse && (this.cfg.searchPath(t.enterse, Config.EXT_SOUND), e.on("pointerover", () => {
      const X = { fn: t.enterse, join: !1 };
      t.entersebuf && (X.buf = t.entersebuf), this.hTag.playse(X);
    })), t.leavese && (this.cfg.searchPath(t.leavese, Config.EXT_SOUND), e.on("pointerout", () => {
      const X = { fn: t.leavese, join: !1 };
      t.leavesebuf && (X.buf = t.leavesebuf), this.hTag.playse(X);
    })), t.onenter) {
      const X = D + t.onenter.toLowerCase(), Y = { fn: t.fn, label: t.onenter, call: !0, key: X };
      L ? V(this, mr)[X] = () => this.main.resumeByJumpOrCall(Y) : V(this, xe)[X] = () => this.main.resumeByJumpOrCall(Y), e.on("pointerover", (W) => this.fire(X, W));
    }
    if (t.onleave) {
      const X = D + t.onleave.toLowerCase(), Y = { fn: t.fn, label: t.onleave, call: !0, key: X };
      L ? V(this, mr)[X] = () => this.main.resumeByJumpOrCall(Y) : V(this, xe)[X] = () => this.main.resumeByJumpOrCall(Y), e.on("pointerout", (W) => this.fire(X, W));
    }
    this.sndMng.loadAheadSnd(t);
  }
  cvsResize() {
    V(this, ke).hidden = !0;
  }
  waitLimitedEvent(t, e) {
    V(this, Pn).call(this), this.val.saveKidoku();
    const R = () => {
      V(this, wn).clear(), e();
    };
    if (this.val.getVal("tmp:sn.skip.enabled"))
      if (!this.val.getVal("tmp:sn.skip.all") && !this.scrItr.isNextKidoku)
        V(this, yr).call(this);
      else
        return R(), !1;
    return argChk_Boolean(t, "canskip", !0) && (V(this, wn).add(window, "pointerdown", (N) => {
      N.stopPropagation(), R();
    }), V(this, wn).add(window, "keydown", (N) => {
      N.isComposing || (N.stopPropagation(), R());
    }), V(this, Co).call(this, V(this, wn), R)), !0;
  }
  noticeCompTxt() {
    V(this, An).emit(V(this, On));
  }
  isSkippingByKeyDown() {
    if (this.scrItr.skip4page)
      return !0;
    for (const t in V(this, Xe))
      if (V(this, Xe)[t] === 2)
        return !0;
    return !1;
  }
}
Qe = new WeakMap(), $i = new WeakMap(), Ne = new WeakMap(), go = new WeakMap(), _o = new WeakSet(), Rh = function(t) {
  if (t.isComposing)
    return;
  t.key in V(this, Xe) && (V(this, Xe)[t.key] = t.repeat ? 2 : 1);
  const e = (t.altKey ? t.key === "Alt" ? "" : "alt+" : "") + (t.ctrlKey ? t.key === "Control" ? "" : "ctrl+" : "") + (t.shiftKey ? t.key === "Shift" ? "" : "shift+" : "") + t.key;
  this.fire(e, t);
}, mo = new WeakSet(), Ph = function(t) {
  const e = (t.altKey ? t.key === "Alt" ? "" : "alt+" : "") + (t.ctrlKey ? t.key === "Control" ? "" : "ctrl+" : "") + (t.shiftKey ? t.key === "Shift" ? "" : "shift+" : "") + "rightclick";
  this.fire(e, t), t.preventDefault();
}, yo = new WeakSet(), Ah = function(t) {
  if (t.isComposing)
    return;
  if (V(this, Hs)) {
    it(this, zs, !0);
    return;
  }
  it(this, Hs, !0), ot(this, bo, Oh).call(this);
  const e = (t.altKey ? "alt+" : "") + (t.ctrlKey ? "ctrl+" : "") + (t.shiftKey ? "shift+" : "") + (t.deltaY > 0 ? "downwheel" : "upwheel");
  this.fire(e, t);
}, Hs = new WeakMap(), zs = new WeakMap(), bo = new WeakSet(), Oh = function() {
  setTimeout(() => {
    if (V(this, zs)) {
      it(this, zs, !1), ot(this, bo, Oh).call(this);
      return;
    }
    it(this, Hs, !1);
  }, 250);
}, xe = new WeakMap(), mr = new WeakMap(), oi = new WeakMap(), ui = new WeakMap(), Eo = new WeakMap(), ki = new WeakSet(), Kn = function(t, e = !0, R = !0) {
  if (V(this, Pn).call(this), this.val.saveKidoku(), e ? V(this, xe).click = V(this, xe).enter = V(this, xe).arrowdown = V(this, xe)["wheel.y>0"] = t : (delete V(this, xe).click, delete V(this, xe).enter, delete V(this, xe).arrowdown, delete V(this, xe)["wheel.y>0"]), it(this, Eo, R ? (N) => {
    var M;
    return (M = V(this, xe)[N]) != null ? M : V(this, mr)[N];
  } : (N) => V(this, xe)[N]), it(this, ui, !0), V(this, xo).call(this), CmnLib.debugLog) {
    const N = /* @__PURE__ */ Object.create(null);
    N.local = Object.keys(V(this, xe)), N.global = Object.keys(V(this, mr)), console.log("\u{1F38D} wait event... %o", N);
  }
  return !0;
}, xo = new WeakMap(), To = new WeakMap(), ke = new WeakMap(), js = new WeakMap(), Vs = new WeakMap(), So = new WeakMap(), Rl = new WeakSet(), uf = function(t, e) {
  var M, D;
  const R = e instanceof Button ? e.getBtnBounds() : e.getBounds();
  if (!(t[":\u30BF\u30B0\u540D"] === "link")) {
    const L = e.parent.parent;
    R.x += L.x, R.y += L.y;
  }
  if (!t.hint) {
    V(this, ke).hidden = !0;
    return;
  }
  V(this, ke).style.cssText = `position:${V(this, ke).style.position}; transform:${V(this, ke).style.transform};` + ((M = t.hint_style) != null ? M : ""), V(this, js).style.cssText = "", V(this, js).textContent = (D = t.hint) != null ? D : "";
  try {
    const L = t.hint_opt ? { ...V(this, So), ...JSON.parse(t.hint_opt) } : V(this, So);
    V(this, Vs).setOptions(L);
  } catch (L) {
    console.error(mesErrJSON(t, "hint_opt", L.message));
  }
  V(this, To).getBoundingClientRect = () => DOMRect.fromRect({
    x: this.sys.ofsLeft4elm + R.x * this.sys.cvsScale,
    y: this.sys.ofsTop4elm + R.y * this.sys.cvsScale,
    width: R.width,
    height: R.height
  }), V(this, Vs).update(), V(this, ke).hidden = !1;
}, Co = new WeakMap(), wn = new WeakMap(), Pl = new WeakSet(), lf = function(t) {
  const e = argChk_Boolean(t, "global", !1), R = e ? V(this, mr) : V(this, xe);
  for (const N in R)
    ot(this, Io, Nh).call(this, N, R[N]);
  return e ? it(this, mr, {}) : it(this, xe, {}), it(this, ui, !1), !1;
}, Io = new WeakSet(), Nh = function(t, e) {
  t.slice(0, 4) === "dom=" && ot(this, Rn, Ca).call(this, t).el.forEach((R) => R.removeEventListener("click", e));
}, Al = new WeakSet(), hf = function(t) {
  var D, L;
  const e = t.key;
  if (!e)
    throw "key\u306F\u5FC5\u9808\u3067\u3059";
  const R = e.toLowerCase(), N = argChk_Boolean(t, "call", !1), M = argChk_Boolean(t, "global", !1) ? V(this, mr) : V(this, xe);
  if (argChk_Boolean(t, "del", !1)) {
    if (t.fn || t.label || N)
      throw "fn/label/call\u3068del\u306F\u540C\u6642\u6307\u5B9A\u3067\u304D\u307E\u305B\u3093";
    return ot(this, Io, Nh).call(this, e, M[R]), delete M[R], !1;
  }
  if ((D = t.fn) != null || (t.fn = this.scrItr.scriptFn), e.slice(0, 4) === "dom=") {
    const B = ot(this, Rn, Ca).call(this, e);
    if (B.el.length === 0) {
      if (argChk_Boolean(t, "need_err", !0))
        throw `HTML\u5185\u306B\u30BB\u30EC\u30AF\u30BF\uFF08${B.sel}\uFF09\u306B\u5BFE\u5FDC\u3059\u308B\u8981\u7D20\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\u5B58\u5728\u3057\u306A\u3044\u5834\u5408\u3092\u8A31\u5BB9\u3059\u308B\u306A\u3089\u3001need_err=false \u3068\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044`;
      return !1;
    }
    let $ = ["click", "keydown"];
    switch ((L = B.el[0].type) != null ? L : "") {
      case "checkbox":
        $ = ["input"];
        break;
      case "range":
        $ = ["input"];
        break;
      case "text":
      case "textarea":
        $ = ["input", "change"];
        break;
    }
    $.forEach((H, z) => B.el.forEach((X) => {
      V(this, Qe).add(X, H, (Y) => {
        if (!V(this, ui) || this.layMng.getFrmDisabled(B.id) || H === "keydown" && Y.key !== "Enter")
          return;
        const W = X.dataset;
        for (const q in W)
          W.hasOwnProperty(q) && this.val.setVal_Nochk("tmp", `sn.event.domdata.${q}`, W[q]);
        this.fire(e, Y);
      }), z === 0 && V(this, Ne).add(
        X,
        () => ot(this, wo, Mh).call(this, X) ? (X.focus(), !0) : !1,
        () => {
        }
      );
    }));
  }
  return M[R] = () => this.main.resumeByJumpOrCall(t), !1;
}, wo = new WeakSet(), Mh = function(t) {
  if (t.offsetParent === null)
    return !1;
  let e = t;
  do {
    if (getComputedStyle(e).display === "none" || e.dataset.focus === "false" || (e == null ? void 0 : e.disabled))
      return !1;
    e = e.parentElement;
  } while (e !== null);
  return !0;
}, Rn = new WeakSet(), Ca = function(t) {
  const e = t.indexOf(":");
  let R = "";
  if (e >= 0) {
    const N = t.slice(4, e), M = `const.sn.frm.${N}`;
    if (!this.val.getVal(`tmp:${M}`, 0))
      throw `HTML\u3010${N}\u3011\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u3066\u3044\u307E\u305B\u3093`;
    const L = document.getElementById(N).contentWindow;
    return R = t.slice(e + 1), { el: L.document.querySelectorAll(R), id: N, sel: R };
  }
  return R = t.slice(4), { el: document.querySelectorAll(R), id: "", sel: R };
}, Pn = new WeakMap(), Ol = new WeakSet(), cf = function(t) {
  if (this.scrItr.skip4page)
    return !1;
  if (!this.val.getVal("tmp:sn.tagL.enabled"))
    return V(this, Pn).call(this), !1;
  if (this.val.getVal("tmp:sn.skip.enabled")) {
    if (!this.val.getVal("tmp:sn.skip.all") && !this.scrItr.isNextKidoku)
      V(this, yr).call(this);
    else if ("ps".includes(this.val.getVal("sys:sn.skip.mode")))
      return !1;
  }
  return this.val.getVal("tmp:sn.auto.enabled") ? ot(this, Xs, au).call(this, {
    time: Number(this.scrItr.isKidoku ? this.val.getVal("sys:sn.auto.msecLineWait_Kidoku") : this.val.getVal("sys:sn.auto.msecLineWait"))
  }) : (argChk_Boolean(t, "visible", !0) && this.layMng.breakLine(), ot(this, ki, Kn).call(this, () => this.main.resume()));
}, Nl = new WeakSet(), ff = function(t) {
  if (this.scrItr.recodePage(), this.val.getVal("tmp:sn.skip.enabled")) {
    if (!this.val.getVal("tmp:sn.skip.all") && !this.scrItr.isNextKidoku)
      V(this, yr).call(this);
    else if (this.val.getVal("sys:sn.skip.mode") == "s")
      return V(this, Pn).call(this), !1;
  }
  if (this.val.getVal("tmp:sn.auto.enabled"))
    return ot(this, Xs, au).call(this, {
      time: Number(this.scrItr.isKidoku ? this.val.getVal("sys:sn.auto.msecPageWait_Kidoku") : this.val.getVal("sys:sn.auto.msecPageWait"))
    });
  argChk_Boolean(t, "visible", !0) && this.layMng.breakPage();
  const e = () => {
    this.sndMng.clearCache(), this.main.resume();
  };
  return ot(this, ki, Kn).call(this, argChk_Boolean(t, "er", !1) && this.layMng.currentTxtlayFore ? () => {
    this.hTag.er(t), e();
  } : e);
}, yr = new WeakMap(), Ml = new WeakSet(), df = function() {
  return it(this, yr, () => (it(this, yr, () => !1), this.val.setVal_Nochk("tmp", "sn.tagL.enabled", !0), this.val.setVal_Nochk("tmp", "sn.skip.enabled", !1), this.val.setVal_Nochk("tmp", "sn.auto.enabled", !1), this.layMng.setNormalChWait(), V(this, li).call(this), !0)), !1;
}, Dl = new WeakSet(), pf = function(t) {
  const { add: e, del: R, to: N } = t;
  if ((e == null ? void 0 : e.slice(0, 4)) === "dom=") {
    const M = ot(this, Rn, Ca).call(this, e);
    if (M.el.length === 0 && argChk_Boolean(t, "need_err", !0))
      throw `HTML\u5185\u306B\u30BB\u30EC\u30AF\u30BF\uFF08${M.sel}\uFF09\u306B\u5BFE\u5FDC\u3059\u308B\u8981\u7D20\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\u5B58\u5728\u3057\u306A\u3044\u5834\u5408\u3092\u8A31\u5BB9\u3059\u308B\u306A\u3089\u3001need_err=false \u3068\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044`;
    return M.el.forEach((D) => V(this, Ne).add(
      D,
      () => ot(this, wo, Mh).call(this, D) ? (D.focus(), !0) : !1,
      () => {
      }
    )), !1;
  }
  if ((R == null ? void 0 : R.slice(0, 4)) === "dom=") {
    const M = ot(this, Rn, Ca).call(this, R);
    if (M.el.length === 0 && argChk_Boolean(t, "need_err", !0))
      throw `HTML\u5185\u306B\u30BB\u30EC\u30AF\u30BF\uFF08${M.sel}\uFF09\u306B\u5BFE\u5FDC\u3059\u308B\u8981\u7D20\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\u5B58\u5728\u3057\u306A\u3044\u5834\u5408\u3092\u8A31\u5BB9\u3059\u308B\u306A\u3089\u3001need_err=false \u3068\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044`;
    return M.el.forEach((D) => V(this, Ne).remove(D)), !1;
  }
  if (!N)
    throw "[set_focus] add \u304B to \u306F\u5FC5\u9808\u3067\u3059";
  switch (N) {
    case "null":
      V(this, Ne).blur();
      break;
    case "next":
      V(this, Ne).next();
      break;
    case "prev":
      V(this, Ne).prev();
      break;
  }
  return !1;
}, Xs = new WeakSet(), au = function(t) {
  const e = argChk_Num(t, "time", NaN);
  return this.scrItr.skip4page ? !1 : this.val.getVal("tmp:sn.skip.enabled") ? (!this.val.getVal("tmp:sn.skip.all") && !this.scrItr.isNextKidoku && V(this, yr).call(this), !1) : (V(this, An).once(V(this, On), () => {
    V(this, An).off(V(this, On));
    const R = new Tween({}).to({}, e).onComplete(() => {
      it(this, li, () => {
      }), R.stop(), this.main.resume();
    }).start();
    it(this, li, () => R.end());
  }), it(this, li, () => {
    it(this, li, () => {
    }), V(this, An).off(V(this, On));
  }), this.waitEvent(
    () => V(this, li).call(this),
    argChk_Boolean(t, "canskip", !0),
    argChk_Boolean(t, "global", !1)
  ));
}, li = new WeakMap(), An = new WeakMap(), On = new WeakMap(), Ll = new WeakSet(), vf = function() {
  return this.scrItr.skip4page ? !1 : ((this.val.getVal("tmp:sn.skip.enabled") || this.val.getVal("tmp:sn.auto.enabled")) && V(this, yr).call(this), ot(this, ki, Kn).call(this, () => this.main.resume()));
}, Xe = new WeakMap();
class CallStack {
  constructor(t = "", e = 0, R = { ":hEvt1Time": {}, ":hMp": {} }) {
    this.fn = t, this.idx = e, this.csArg = R, this.toString = () => `[fn:${this.fn}, idx:${this.idx}, csArg:${this.csArg}]`;
  }
}
var Wt, ie, zt, de, fe, hi, Ro, Dh, Gi, Nn, Fl, ci, Po, Lh, Ao, Fh, Ws, Ui, Jn, Mn, Ia, Dn, fi, Te, Bl, gf, Ln, wa, $l, _f, Ys, qs, fr, kl, mf, Gl, yf, di, Zi, Ul, bf, Hi, zi, Zs, Ks, Js, tr, Hl, Ef, zl, xf, jl, Tf, Oo, Bh, Vl, Sf, Xl, Cf, Wl, If, No, $h, Qs, Fn, Ra, ji, pi, Ki, Mo, kh, ta, Do, Gh, Lo, Fo, ea, Vi, ra, Yl, wf, We, ql, Rf, Bo, Uh, $o, ko, Go, Zl, Pf, zr, Uo, Hh, Kl, Af, Jl, Of, Ql, Nf, ia, Bn, th, Mf, na, ou, $n, eh, Df, br, rh, Lf, sa, uu, ih, Ff, Er, Me;
const sr = class {
  constructor(t, e, R, N, M, D, L, B, $) {
    nt(this, Ro);
    nt(this, Po);
    nt(this, Ao);
    nt(this, Ui);
    nt(this, Mn);
    nt(this, Bl);
    nt(this, Ln);
    nt(this, $l);
    nt(this, kl);
    nt(this, Gl);
    nt(this, di);
    nt(this, Ul);
    nt(this, Hl);
    nt(this, zl);
    nt(this, jl);
    nt(this, Oo);
    nt(this, Vl);
    nt(this, Xl);
    nt(this, Wl);
    nt(this, No);
    nt(this, Fn);
    nt(this, pi);
    nt(this, Mo);
    nt(this, Do);
    nt(this, Yl);
    nt(this, ql);
    nt(this, Bo);
    nt(this, Zl);
    nt(this, Uo);
    nt(this, Kl);
    nt(this, Jl);
    nt(this, Ql);
    nt(this, th);
    nt(this, na);
    nt(this, eh);
    nt(this, rh);
    nt(this, sa);
    nt(this, ih);
    nt(this, Wt, void 0);
    nt(this, ie, void 0);
    nt(this, zt, void 0);
    nt(this, de, void 0);
    nt(this, fe, void 0);
    nt(this, hi, void 0);
    nt(this, Gi, void 0);
    nt(this, Nn, void 0);
    nt(this, ci, void 0);
    nt(this, Ws, void 0);
    nt(this, Te, void 0);
    nt(this, Ys, void 0);
    nt(this, qs, void 0);
    nt(this, fr, void 0);
    nt(this, Hi, void 0);
    nt(this, zi, void 0);
    nt(this, Zs, void 0);
    nt(this, Ks, void 0);
    nt(this, Js, void 0);
    nt(this, tr, void 0);
    nt(this, Qs, void 0);
    nt(this, ji, void 0);
    nt(this, ta, void 0);
    nt(this, Lo, void 0);
    nt(this, Fo, void 0);
    nt(this, ea, void 0);
    nt(this, Vi, void 0);
    nt(this, ra, void 0);
    nt(this, We, void 0);
    nt(this, $o, void 0);
    nt(this, ko, void 0);
    nt(this, Go, void 0);
    nt(this, zr, void 0);
    nt(this, ia, void 0);
    nt(this, Bn, void 0);
    nt(this, $n, void 0);
    nt(this, br, void 0);
    nt(this, Er, void 0);
    nt(this, Me, void 0);
    if (this.cfg = t, this.hTag = e, this.main = R, this.val = N, this.alzTagArg = M, this.runAnalyze = D, this.prpPrs = L, this.sndMng = B, this.sys = $, it(this, Wt, { aToken: [""], len: 1, aLNum: [1] }), it(this, ie, ""), it(this, zt, 0), it(this, de, 0), this.addLineNum = (U) => it(this, de, V(this, de) + U), it(this, fe, []), it(this, hi, new Grammar()), this.firstWait = () => {
    }, it(this, Gi, {
      disconnect: () => {
        it(sr, Dn, {}), it(sr, fi, {}), this.isBreak = () => !1, V(this, Gi).continue({}), it(this, Te, 0);
      },
      restart: () => this.isBreak = () => !1,
      add_break: (U) => ot(this, Ro, Dh).call(this, U.fn, U.o),
      data_break: (U) => {
        V(this, Te) === 0 && (it(this, Te, 1), this.main.setLoop(!1, `\u5909\u6570 ${U.dataId}\u3010${U.old_v}\u3011\u2192\u3010${U.new_v}\u3011\u30C7\u30FC\u30BF\u30D6\u30EC\u30FC\u30AF`), this.sys.callHook("stopOnDataBreakpoint", {}), this.sys.send2Dbg("stopOnDataBreakpoint", {}));
      },
      set_func_break: (U) => {
        it(sr, fi, {}), U.a.forEach((H) => V(sr, fi)[H.name] = 1), this.sys.send2Dbg(U.ri, {});
      },
      stack: (U) => this.sys.send2Dbg(U.ri, { a: ot(this, $l, _f).call(this) }),
      eval: (U) => {
        this.sys.send2Dbg(U.ri, { v: this.prpPrs.parse(U.txt) });
      },
      continue: () => {
        ot(this, Mn, Ia).call(this) || (it(this, zt, V(this, zt) - V(this, Ui, Jn)), it(this, Te, 3), this.main.setLoop(!0), this.main.resume());
      },
      stepover: (U) => ot(this, Po, Lh).call(this, U),
      stepin: () => {
        if (ot(this, Mn, Ia).call(this))
          return;
        const U = V(this, Wt).aToken[V(this, zt) - V(this, Ui, Jn)];
        this.sys.callHook(`stopOnStep${V(this, Bn).test(U) ? "In" : ""}`, {}), it(this, zt, V(this, zt) - V(this, Ui, Jn)), it(this, Te, V(this, Te) === 1 ? 4 : 5), this.main.setLoop(!0), this.main.resume();
      },
      stepout: (U) => {
        ot(this, Mn, Ia).call(this) || (V(this, fe).length > 0 ? ot(this, Ao, Fh).call(this, !0) : ot(this, Po, Lh).call(this, U));
      },
      pause: () => {
        it(this, Te, 4), this.main.setLoop(!1, "\u4E00\u6642\u505C\u6B62"), this.sys.send2Dbg("stopOnStep", {});
      },
      stopOnEntry: () => {
        it(this, Te, 4), this.main.setLoop(!1, "\u4E00\u6642\u505C\u6B62"), this.sys.send2Dbg("stopOnEntry", {});
      }
    }), it(this, Nn, (U) => this.cfg.searchPath(U, Config.EXT_SCRIPT)), it(this, ci, (U) => (this.sys.pathBaseCnvSnPath4Dbg + V(this, Nn).call(this, U)).replace(V(sr, Fl), `$1/prj/$2/${V(this, ie)}$3`)), this.cnvPath4Dbg = (U) => this.sys.pathBaseCnvSnPath4Dbg + U.replace("/crypto_prj/", "/prj/"), it(this, Ws, 0), it(this, Te, 0), this.isBreak = (U) => !1, it(this, Ys, (U) => {
    }), it(this, Hi, () => {
    }), it(this, zi, () => {
    }), it(this, Zs, ""), it(this, Ks, {}), this.noticeBreak = (U) => {
    }, it(this, Js, 5), it(this, tr, [-1]), it(this, Qs, ""), it(this, ji, ""), this.nextToken = () => "", it(this, ta, (U) => {
    }), it(this, Lo, /(\*{2,})(.*)/), it(this, Fo, /\[macro\s/), it(this, ea, /\[endmacro[\s\]]/), it(this, Vi, /^\[let_ml\s/g), it(this, ra, /^\[endlet_ml\s*]/g), it(this, We, /* @__PURE__ */ Object.create(null)), it(this, $o, /^\[(call|loadplugin)\s/), it(this, ko, /\bfn\s*=\s*[^\s\]]+/), it(this, Go, () => {
      for (let U = V(this, Wt).len - 1; U >= 0; --U) {
        const H = V(this, Wt).aToken[U];
        if (!V(this, $o).test(H))
          continue;
        const [z, X] = tagToken2Name_Args(H);
        this.alzTagArg.go(X);
        const Y = this.alzTagArg.hPrm.fn;
        if (!Y)
          continue;
        const W = Y.val;
        if (!W || W.slice(-1) !== "*")
          continue;
        const q = z === "loadplugin" ? "css" : "sn", Z = this.cfg.matchPath("^" + W.slice(0, -1) + ".*", q);
        V(this, Wt).aToken.splice(U, 1, "	", "; " + H), V(this, Wt).aLNum.splice(U, 1, NaN, NaN);
        for (const K of Z) {
          const J = H.replace(
            V(this, ko),
            "fn=" + decodeURIComponent(getFn(K[q]))
          );
          V(this, Wt).aToken.splice(U, 0, J), V(this, Wt).aLNum.splice(U, 0, NaN);
        }
      }
      V(this, Wt).len = V(this, Wt).aToken.length;
    }), it(this, zr, !1), it(this, ia, "call"), it(this, Bn, /\[(call)\b/), it(this, $n, !1), it(this, br, {
      hSave: {},
      hPages: {},
      aIfStk: [-1]
    }), it(this, Er, []), it(this, Me, -1), e.let_ml = (U) => ot(this, kl, mf).call(this, U), e.dump_stack = () => ot(this, Gl, yf).call(this), e.dump_script = (U) => ot(this, Ul, bf).call(this, U), e.else = e.elsif = e.endif = () => ot(this, Hl, Ef).call(this), e.if = (U) => ot(this, zl, xf).call(this, U), e.call = (U) => ot(this, jl, Tf).call(this, U), e.jump = (U) => ot(this, Vl, Sf).call(this, U), e.page = (U) => ot(this, Xl, Cf).call(this, U), e.pop_stack = (U) => ot(this, Wl, If).call(this, U), e.return = (U) => ot(this, No, $h).call(this, U), e.bracket2macro = (U) => ot(this, Kl, Af).call(this, U), e.char2macro = (U) => ot(this, Jl, Of).call(this, U), e.endmacro = (U) => ot(this, No, $h).call(this, U), e.macro = (U) => ot(this, Ql, Nf).call(this, U), e.load = (U) => ot(this, th, Mf).call(this, U), e.reload_script = (U) => ot(this, eh, Df).call(this, U), e.record_place = () => ot(this, rh, Lf).call(this), e.save = (U) => ot(this, ih, Ff).call(this, U), t.oCfg.debug.token && it(this, ta, (U) => console.log(`\u{1F331} \u30C8\u30FC\u30AF\u30F3 fn:${V(this, ie)} idx:${V(this, zt)} ln:${V(this, de)} token\u3010${U}\u3011`)), N.defTmp("const.sn.vctCallStk.length", () => V(this, fe).length), V(this, hi).setEscape(t.oCfg.init.escape), CmnLib.isDbg) {
      $.addHook((H, z) => {
        var X, Y;
        return (Y = (X = V(this, Gi))[H]) == null ? void 0 : Y.call(X, z);
      }), this.isBreak = ot(this, Bl, gf);
      const U = this.analyzeInit;
      this.analyzeInit = () => {
        this.analyzeInit = () => {
        }, this.sys.send2Dbg("hi", {});
      }, V(this, Gi).auth = (H) => {
        const z = H.hBreakpoint.hFn2hLineBP;
        for (const X in z)
          ot(this, Ro, Dh).call(this, X, z[X]);
        if (it(sr, fi, {}), H.hBreakpoint.aFunc.forEach((X) => V(sr, fi)[X.name] = 1), H.stopOnEntry) {
          for (; ; ) {
            let X = this.nextToken();
            if (!X)
              break;
            const Y = X.charCodeAt(0);
            if (Y === 91 || Y === 38 || Y === 42 && X.length === 1)
              break;
            Y === 10 && it(this, de, V(this, de) + X.length);
          }
          this.sys.callHook("stopOnEntry", {}), this.analyzeInit = U, this.analyzeInit();
        } else
          this.firstWait = () => {
            this.sys.callHook("stopOnEntry", {});
          }, this.analyzeInit = U, this.analyzeInit();
      };
    } else
      this.recodeDesign = () => {
      };
    t.oCfg.debug.tag && it(this, Ys, (U) => console.log(`\u{1F332} \u30BF\u30B0\u89E3\u6790 fn:${V(this, ie)} idx:${V(this, zt)} ln:${V(this, de)} [${U} %o]`, this.alzTagArg.hPrm));
  }
  get scriptFn() {
    return V(this, ie);
  }
  subIdxToken() {
    --Ae(this, zt)._;
  }
  get lineNum() {
    return V(this, de);
  }
  destroy() {
    this.isBreak = () => !1;
  }
  \u30BF\u30B0\u89E3\u6790(t) {
    const [e, R] = tagToken2Name_Args(t), N = this.hTag[e];
    if (!N)
      throw `\u672A\u5B9A\u7FA9\u306E\u30BF\u30B0\u3010${e}\u3011\u3067\u3059`;
    this.alzTagArg.go(R), V(this, Ys).call(this, e);
    const M = this.alzTagArg.hPrm;
    if (M.cond) {
      const B = M.cond.val;
      if (!B || B.charAt(0) === "&")
        throw "\u5C5E\u6027cond\u306F\u300C&\u300D\u304C\u4E0D\u8981\u3067\u3059";
      const $ = this.prpPrs.parse(B), U = String($);
      if (U === "null" || U === "undefined" || !$)
        return !1;
    }
    let D = {};
    const L = V(this, fe).length;
    if (this.alzTagArg.isKomeParam) {
      if (L === 0)
        throw "\u5C5E\u6027\u300C*\u300D\u306F\u30DE\u30AF\u30ED\u306E\u307F\u6709\u52B9\u3067\u3059";
      D = { ...V(this, fe)[V(this, fe).length - 1].csArg };
    }
    D[":\u30BF\u30B0\u540D"] = e;
    for (const B in M) {
      let $ = M[B].val;
      if (($ == null ? void 0 : $.charAt(0)) === "%") {
        if (L === 0)
          throw "\u5C5E\u6027\u300C%\u300D\u306F\u30DE\u30AF\u30ED\u5B9A\u7FA9\u5185\u3067\u306E\u307F\u4F7F\u7528\u3067\u304D\u307E\u3059\uFF08\u305D\u306E\u30DE\u30AF\u30ED\u306E\u5F15\u6570\u3092\u793A\u3059\u7C21\u7565\u6587\u6CD5\u3067\u3042\u308B\u305F\u3081\uFF09";
        const H = V(this, fe)[V(this, fe).length - 1].csArg[$.slice(1)];
        if (H) {
          D[B] = H;
          continue;
        }
        if ($ = M[B].def, $ === void 0 || $ === "null")
          continue;
      }
      if ($ = this.prpPrs.getValAmpersand($ != null ? $ : ""), $ !== "undefined") {
        D[B] = $;
        continue;
      }
      const U = M[B].def;
      U !== void 0 && ($ = this.prpPrs.getValAmpersand(U), $ !== "undefined" && (D[B] = $));
    }
    return N(D);
  }
  setOtherObj(t, e) {
    it(this, qs, t), it(this, fr, e);
  }
  dumpErrForeLine() {
    var D;
    if (V(this, zt) === 0) {
      console.group(`\u{1F95F} Error line (from 0 rows before) fn:${V(this, ie)}`), console.groupEnd();
      return;
    }
    let t = "";
    for (let L = V(this, zt) - 1; L >= 0 && (t = V(this, Wt).aToken[L] + t, !(((D = t.match(/\n/g)) != null ? D : []).length >= V(this, Js))); --L)
      ;
    const e = t.split(`
`).slice(-V(this, Js)), R = e.length;
    console.group(`\u{1F95F} Error line (from ${R} rows before) fn:${V(this, ie)}`);
    const N = String(V(this, de)).length, M = ot(this, di, Zi).call(this, V(this, Wt), V(this, zt));
    for (let L = 0; L < R; ++L) {
      const B = V(this, de) - R + L + 1, $ = `${String(B).padStart(N, " ")}: %c`, U = e[L], H = U.length > 75 ? U.slice(0, 75) + "\u2026" : U;
      L === R - 1 ? console.info(
        $ + H.slice(0, M.col_s) + "%c" + H.slice(M.col_s),
        "color: black; background-color: skyblue;",
        "color: black; background-color: pink;"
      ) : console.info($ + H, "color: black; background-color: skyblue;");
    }
    console.groupEnd();
  }
  analyzeInit() {
    const t = ot(this, Yl, wf).call(this, V(this, Wt), Boolean(this.val.getVal("mp:const.sn.macro.name")), V(this, de), V(this, ji), V(this, zt));
    it(this, zt, t.idx), it(this, de, t.ln), this.runAnalyze();
  }
  get isKidoku() {
    return V(this, zr);
  }
  get isNextKidoku() {
    let t = V(this, ie), e = V(this, zt), R = V(this, Wt).len;
    if (V(this, fe).length > 0) {
      const M = V(this, fe)[0];
      t = M.fn, e = M.idx;
      const D = V(this, We)[t];
      D && (R = D.len);
    }
    const N = this.val.getAreaKidoku(t);
    return !N || e === R ? !1 : N.search(e);
  }
  get normalWait() {
    return V(this, zr) ? this.val.getVal("sys:sn.tagCh.doWait_Kidoku") ? uint(this.val.getVal("sys:sn.tagCh.msecWait_Kidoku")) : 0 : this.val.getVal("sys:sn.tagCh.doWait") ? uint(this.val.getVal("sys:sn.tagCh.msecWait")) : 0;
  }
  get skip4page() {
    return V(this, $n);
  }
  recodePage() {
    if (it(this, $n, !1), !this.val.getVal("save:sn.doRecLog"))
      return;
    const { fn: t, idx: e } = ot(this, sa, uu).call(this), R = e - 1, N = R + ":" + t, M = V(this, Er).findIndex((L) => L.key === N);
    if (M > -1) {
      it(this, Me, M);
      return;
    }
    const D = {
      key: N,
      fn: t,
      idx: R,
      retFn: t,
      retIdx: 0,
      retMark: { ...V(this, br) }
    };
    if (V(this, Me) >= 0) {
      const L = V(this, Er)[V(this, Me)];
      D.retFn = L.fn, D.retIdx = L.idx + 1;
    }
    ++Ae(this, Me)._ === V(this, Er).length ? V(this, Er).push(D) : V(this, Er)[V(this, Me)] = D;
  }
  recodeDesign(t) {
    let e = "", R = 0;
    const N = V(this, fe).length;
    if (t.design_unit && N > 0) {
      const L = V(this, fe)[0];
      e = L.fn, R = L.idx;
    } else
      e = V(this, ie), R = V(this, zt);
    t[":path"] = V(this, ci).call(this, e);
    const M = ot(this, di, Zi).call(this, V(this, We)[e], R);
    t[":ln"] = M.ln, t[":col_s"] = M.col_s, t[":col_e"] = M.col_e;
    const D = R - 1;
    t[":idx_tkn"] = D, t[":token"] = V(this, We)[e].aToken[D], this.sys.send2Dbg("_recodeDesign", t);
  }
  replace(t, e) {
    V(this, Wt).aToken[t] = e;
  }
};
let ScriptIterator = sr;
Wt = new WeakMap(), ie = new WeakMap(), zt = new WeakMap(), de = new WeakMap(), fe = new WeakMap(), hi = new WeakMap(), Ro = new WeakSet(), Dh = function(t, e) {
  V(sr, Dn)[V(this, ci).call(this, t)] = e;
}, Gi = new WeakMap(), Nn = new WeakMap(), Fl = new WeakMap(), ci = new WeakMap(), Po = new WeakSet(), Lh = function(t) {
  if (ot(this, Mn, Ia).call(this))
    return;
  const e = V(this, Wt).aToken[V(this, zt) - V(this, Ui, Jn)];
  V(this, Bn).test(e) ? ot(this, Ao, Fh).call(this, !1) : (this.sys.callHook("stopOnStep", {}), V(this, Gi).stepin(t));
}, Ao = new WeakSet(), Fh = function(t) {
  this.sys.callHook(`stopOnStep${t ? "Out" : ""}`, {}), it(this, Ws, V(this, fe).length - (t ? 1 : 0)), it(this, zt, V(this, zt) - V(this, Ui, Jn)), it(this, Te, t ? 7 : 6), this.main.setLoop(!0), this.main.resume();
}, Ws = new WeakMap(), Ui = new WeakSet(), Jn = function() {
  return V(this, Te) === 2 || V(this, Te) === 4 ? 1 : 0;
}, Mn = new WeakSet(), Ia = function() {
  return V(this, zt) < V(this, Wt).len ? !1 : (this.sys.callHook("stopOnEntry", {}), this.main.setLoop(!1, "\u30B9\u30AF\u30EA\u30D7\u30C8\u7D42\u7AEF\u3067\u3059"), !0);
}, Dn = new WeakMap(), fi = new WeakMap(), Te = new WeakMap(), Bl = new WeakSet(), gf = function(t) {
  switch (V(this, Te)) {
    case 6:
      ot(this, Ln, wa).call(this), it(this, Te, 7);
      break;
    case 7:
      if (V(this, fe).length !== V(this, Ws))
        break;
      return it(this, Te, 4), this.main.setLoop(!1, "\u30B9\u30C6\u30C3\u30D7\u5B9F\u884C"), this.sys.send2Dbg("stopOnStep", {}), !0;
    case 5:
      ot(this, Ln, wa).call(this), it(this, Te, 4);
      break;
    case 4:
      return ot(this, Ln, wa).call(this), this.main.setLoop(!1, "\u30B9\u30C6\u30C3\u30D7\u5B9F\u884C"), this.sys.send2Dbg("stopOnStep", {}), !0;
    case 3:
      ot(this, Ln, wa).call(this), it(this, Te, 0);
      break;
    default:
      if (tagToken2Name(t) in V(sr, fi))
        return it(this, Te, 2), this.main.setLoop(!1, `\u95A2\u6570 ${t} \u30D6\u30EC\u30FC\u30AF`), this.sys.callHook("stopOnBreakpoint", {}), this.sys.send2Dbg("stopOnBreakpoint", {}), !0;
      {
        const e = V(sr, Dn)[V(this, ci).call(this, V(this, ie))];
        if (!e)
          break;
        const R = e[V(this, de)];
        if (!R)
          break;
        if (R.condition) {
          if (!this.prpPrs.parse(R.condition))
            break;
        } else if ("hitCondition" in R && --R.hitCondition > 0)
          break;
        const N = V(this, Te) === 0;
        it(this, Te, 2), this.main.setLoop(!1, N ? (R.condition ? "\u6761\u4EF6" : "\u30D2\u30C3\u30C8\u30AB\u30A6\u30F3\u30C8") + "\u30D6\u30EC\u30FC\u30AF" : "\u30B9\u30C6\u30C3\u30D7\u5B9F\u884C");
        const M = N ? "stopOnBreakpoint" : "stopOnStep";
        this.sys.callHook(M, {}), this.sys.send2Dbg(M, {});
      }
      return !0;
  }
  return !1;
}, Ln = new WeakSet(), wa = function() {
  var e;
  const t = (e = V(sr, Dn)[getFn(V(this, ie))]) == null ? void 0 : e[V(this, de)];
  t != null && t.hitCondition && --t.hitCondition;
}, $l = new WeakSet(), _f = function() {
  var U, H;
  const t = V(this, Te) === 3 ? 1 : 0, e = V(this, Wt).aToken[V(this, zt) - 1 + t], R = V(this, ci).call(this, V(this, ie)), N = tagToken2Name(e), M = N ? `[${N}]` : e, D = (U = this.val.getVal("mp:const.sn.macro")) != null ? U : "{}";
  if (V(this, zt) === 0)
    return [{ fn: R, ln: 1, col: 1, nm: M, ma: D }];
  const L = ot(this, di, Zi).call(this, V(this, Wt), V(this, zt)), B = [{ fn: R, ln: L.ln, col: L.col_s + 1, nm: M, ma: D }], $ = V(this, fe).length;
  if ($ === 0)
    return B;
  for (let z = $ - 1; z >= 0; --z) {
    const X = V(this, fe)[z], Y = V(this, We)[X.fn], W = Y.aToken[X.idx - 1], q = ot(this, di, Zi).call(this, Y, X.idx), Z = tagToken2Name(W);
    B.push({
      fn: V(this, ci).call(this, X.fn),
      ln: q.ln,
      col: q.col_s + 1,
      nm: Z ? `[${Z}]` : W,
      ma: (H = X.csArg[":hMp"]["const.sn.macro"]) != null ? H : "{}"
    });
  }
  return B;
}, Ys = new WeakMap(), qs = new WeakMap(), fr = new WeakMap(), kl = new WeakSet(), mf = function(t) {
  var M;
  const { name: e } = t;
  if (!e)
    throw "name\u306F\u5FC5\u9808\u3067\u3059";
  let R = "";
  const N = V(this, Wt).len;
  for (; V(this, zt) < N && (R = V(this, Wt).aToken[V(this, zt)], R === ""); ++Ae(this, zt)._)
    ;
  return t.text = R, t.cast = "str", this.hTag.let(t), it(this, zt, V(this, zt) + 2), it(this, de, V(this, de) + ((M = R.match(/\n/g)) != null ? M : []).length), !1;
}, Gl = new WeakSet(), yf = function() {
  var N;
  if (V(this, zt) === 0)
    return console.group(`\u{1F95F} [dump_stack] \u30B9\u30AF\u30EA\u30D7\u30C8\u73FE\u5728\u5730 fn:${V(this, ie)} line:${1} col:${0}`), console.groupEnd(), !1;
  const t = ot(this, di, Zi).call(this, V(this, Wt), V(this, zt)), e = `\u30B9\u30AF\u30EA\u30D7\u30C8\u73FE\u5728\u5730 fn:${V(this, ie)} line:${t.ln} col:${t.col_s + 1}`;
  console.group(`\u{1F95F} [dump_stack] ${e}`);
  const R = V(this, fe).length;
  if (R > 0) {
    console.info(e);
    for (let M = R - 1; M >= 0; --M) {
      const D = V(this, fe)[M], L = D.csArg[":hMp"], B = L ? L[":\u30BF\u30B0\u540D"] : void 0, $ = (N = D.csArg[":\u30BF\u30B0\u540D"]) != null ? N : "", U = ot(this, di, Zi).call(this, V(this, We)[D.fn], D.idx);
      console.info(
        `${R - M}\u3064\u524D\u306E\u30B3\u30FC\u30EB\u5143 fn:${D.fn} line:${U.ln} col:${U.col_s + 1}` + (B ? "\uFF08[" + B + "]\u30DE\u30AF\u30ED\u5185\uFF09" : " ") + `\u3067 [${$} ...]\u3092\u30B3\u30FC\u30EB`
      );
    }
  }
  return console.groupEnd(), !1;
}, di = new WeakSet(), Zi = function(t, e) {
  const R = { ln: 1, col_s: 0, col_e: 0 };
  if (!t)
    return R;
  let N = e - 1;
  const M = R.ln = t.aLNum[N];
  for (; t.aLNum[N] === M; ) {
    if (t.aToken[N].charAt(0) !== `
`) {
      const D = t.aToken[N].length;
      R.col_e > 0 && (R.col_s += D), R.col_e += D;
    }
    if (--N < 0)
      break;
  }
  return R;
}, Ul = new WeakSet(), bf = function(t) {
  const { set_fnc: e, break_fnc: R } = t;
  if (!e)
    throw "set_fnc\u306F\u5FC5\u9808\u3067\u3059";
  if (it(this, Hi, globalThis[e]), !V(this, Hi)) {
    if (argChk_Boolean(t, "need_err", !0))
      throw `HTML\u5185\u306B\u95A2\u6570${e}\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093`;
    return it(this, Hi, () => {
    }), !1;
  }
  if (this.noticeBreak = (N) => {
    var M;
    V(this, Zs) !== V(this, ie) && (it(this, Zs, V(this, ie)), V(this, Hi).call(this, V(this, Ks)[V(this, ie)] = (M = V(this, Ks)[V(this, ie)]) != null ? M : V(this, Wt).aToken.join(""))), V(this, zi).call(this, V(this, de), N);
  }, this.noticeBreak(!0), !R)
    return !1;
  if (it(this, zi, globalThis[R]), !V(this, zi)) {
    if (argChk_Boolean(t, "need_err", !0))
      throw `HTML\u5185\u306B\u95A2\u6570${R}\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093`;
    it(this, zi, () => {
    });
  }
  return !1;
}, Hi = new WeakMap(), zi = new WeakMap(), Zs = new WeakMap(), Ks = new WeakMap(), Js = new WeakMap(), tr = new WeakMap(), Hl = new WeakSet(), Ef = function() {
  if (V(this, tr)[0] === -1)
    throw "if\u30D6\u30ED\u30C3\u30AF\u5185\u3067\u306F\u3042\u308A\u307E\u305B\u3093";
  return it(this, zt, V(this, tr)[0]), V(this, tr).shift(), !1;
}, zl = new WeakSet(), xf = function(t) {
  var B;
  const { exp: e } = t;
  if (!e)
    throw "exp\u306F\u5FC5\u9808\u3067\u3059";
  if (e.charAt(0) === "&")
    throw "\u5C5E\u6027exp\u306F\u300C&\u300D\u304C\u4E0D\u8981\u3067\u3059";
  let R = 0, N = this.prpPrs.parse(e) ? V(this, zt) : -1;
  const M = V(this, Wt).aLNum[V(this, zt)];
  let D = V(this, de) - (M || 0);
  const L = V(this, Wt).len;
  for (; V(this, zt) < L; ++Ae(this, zt)._) {
    const $ = V(this, Wt).aLNum[V(this, zt)];
    V(this, Wt).aLNum[V(this, zt)] = ($ || 0) + D;
    const U = V(this, Wt).aToken[V(this, zt)];
    if (!U)
      continue;
    const H = U.charCodeAt(0);
    if (H === 10) {
      it(this, de, V(this, de) + U.length);
      continue;
    }
    if (H !== 91)
      continue;
    const [z, X] = tagToken2Name_Args(U);
    if (!(z in this.hTag))
      throw `\u672A\u5B9A\u7FA9\u306E\u30BF\u30B0[${z}]\u3067\u3059`;
    switch (this.alzTagArg.go(X), z) {
      case "if":
        ++R;
        break;
      case "elsif":
        if (R > 0 || N > -1)
          break;
        const Y = (B = this.alzTagArg.hPrm.exp.val) != null ? B : "";
        if (Y.charAt(0) === "&")
          throw "\u5C5E\u6027exp\u306F\u300C&\u300D\u304C\u4E0D\u8981\u3067\u3059";
        this.prpPrs.parse(Y) && (N = V(this, zt) + 1);
        break;
      case "else":
        if (R > 0)
          break;
        N === -1 && (N = V(this, zt) + 1);
        break;
      case "endif":
        if (R > 0) {
          --R;
          break;
        }
        return N === -1 ? (++Ae(this, zt)._, V(this, Wt).aLNum[V(this, zt)] += D) : (V(this, tr).unshift(V(this, zt) + 1), it(this, zt, N), it(this, de, V(this, Wt).aLNum[V(this, zt)])), !1;
    }
  }
  throw "[endif]\u304C\u306A\u3044\u307E\u307E\u30B9\u30AF\u30EA\u30D7\u30C8\u7D42\u7AEF\u3067\u3059";
}, jl = new WeakSet(), Tf = function(t) {
  argChk_Boolean(t, "count", !1) || ot(this, Uo, Hh).call(this);
  const { fn: e } = t;
  return e && V(this, Nn).call(this, e), ot(this, Oo, Bh).call(this, { ":hEvt1Time": V(this, qs).popLocalEvts(), ":hMp": this.val.cloneMp() }), argChk_Boolean(t, "clear_local_event", !1) && this.hTag.clear_event({}), ot(this, pi, Ki).call(this, e, t.label), !0;
}, Oo = new WeakSet(), Bh = function(t) {
  V(this, Wt).aLNum[V(this, zt)] = V(this, de), V(this, Qs) || (t[":resvToken"] = "", ot(this, Fn, Ra).call(this)), V(this, fe).push(new CallStack(V(this, ie), V(this, zt), t)), V(this, tr).unshift(-1);
}, Vl = new WeakSet(), Sf = function(t) {
  return argChk_Boolean(t, "count", !0) || ot(this, Uo, Hh).call(this), V(this, tr)[0] = -1, ot(this, pi, Ki).call(this, t.fn, t.label), !0;
}, Xl = new WeakSet(), Cf = function(t) {
  if (V(this, Me) === -1)
    return !1;
  if (argChk_Boolean(t, "clear", !1))
    return it(this, Er, []), it(this, Me, -1), !1;
  const { to: e } = t;
  if (!e)
    throw "clear\u304Bto\u306F\u5FC5\u9808\u3067\u3059";
  const R = V(this, Me);
  switch (e) {
    case "prev":
      V(this, Me) > 0 && --Ae(this, Me)._;
      break;
    case "next":
      const L = V(this, Er).length;
      V(this, Me) < L - 1 && ++Ae(this, Me)._;
      break;
    default:
      throw `\u5C5E\u6027to\u300C${e}\u300D\u306F\u7570\u5E38\u3067\u3059`;
  }
  if (R === V(this, Me))
    return !1;
  const N = V(this, Er)[V(this, Me)], { fn: M, idx: D } = ot(this, sa, uu).call(this);
  return N.key === D + ":" + M ? !1 : ot(this, na, ou).call(this, { fn: N.retFn, index: N.retIdx }, N.retMark);
}, Wl = new WeakSet(), If = function(t) {
  if (argChk_Boolean(t, "clear", !1))
    it(this, fe, []);
  else if (!V(this, fe).pop())
    throw "[pop_stack] \u30B9\u30BF\u30C3\u30AF\u304C\u7A7A\u3067\u3059";
  return ot(this, Fn, Ra).call(this), it(this, tr, [-1]), this.val.setMp({}), !1;
}, No = new WeakSet(), $h = function(t) {
  const e = V(this, fe).pop();
  if (!e)
    throw "[return] \u30B9\u30BF\u30C3\u30AF\u304C\u7A7A\u3067\u3059";
  const R = e.csArg;
  V(this, tr).shift();
  const N = R[":hMp"];
  N && this.val.setMp(N);
  const M = R[":resvToken"];
  M ? this.nextToken = () => (ot(this, Fn, Ra).call(this), M) : ot(this, Fn, Ra).call(this), R[":hEvt1Time"] && V(this, qs).pushLocalEvts(R[":hEvt1Time"]);
  const { fn: D, label: L } = t;
  return D || L ? (ot(this, pi, Ki).call(this, D, L), !0) : e.fn in V(this, We) ? (ot(this, Bo, Uh).call(this, e), !1) : (ot(this, pi, Ki).call(this, e.fn, "", e.idx), !0);
}, Qs = new WeakMap(), Fn = new WeakSet(), Ra = function() {
  it(this, Qs, ""), this.nextToken = ot(this, Mo, kh);
}, ji = new WeakMap(), pi = new WeakSet(), Ki = function(t = "", e = "", R = 0) {
  if (!t && !e && this.main.errScript("[jump\u7CFB] fn\u307E\u305F\u306Flabel\u306F\u5FC5\u9808\u3067\u3059"), e ? (e.charAt(0) !== "*" && this.main.errScript("[jump\u7CFB] label\u306F*\u3067\u59CB\u307E\u308A\u307E\u3059"), it(this, ji, e), V(this, ji).slice(0, 2) !== "**" && it(this, zt, R)) : (it(this, ji, ""), it(this, zt, R)), !t) {
    this.analyzeInit();
    return;
  }
  const N = V(this, Nn).call(this, t);
  if (t === V(this, ie)) {
    this.analyzeInit();
    return;
  }
  it(this, ie, t);
  const M = V(this, We)[V(this, ie)];
  if (M) {
    it(this, Wt, M), this.analyzeInit();
    return;
  }
  new Loader().add({ name: V(this, ie), url: N }).use((D, L) => {
    try {
      D.data = this.sys.decStr(D.extension, D.data);
    } catch (B) {
      this.main.errScript(`[jump\u7CFB]sn\u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 fn:${D.name} ${B}`, !1);
    }
    L == null || L();
  }).load((D, L) => {
    this.nextToken = ot(this, Mo, kh), it(this, de, 1), ot(this, ql, Rf).call(this, L[t].data), this.hTag.record_place({}), this.main.resume(() => this.analyzeInit());
  }), this.main.stop();
}, Mo = new WeakSet(), kh = function() {
  var e, R;
  if (ot(this, Do, Gh).call(this))
    return "";
  ot(this, Zl, Pf).call(this), (e = V(this, Wt).aLNum)[R = V(this, zt)] || (e[R] = V(this, de));
  const t = V(this, Wt).aToken[V(this, zt)];
  return V(this, ta).call(this, t), ++Ae(this, zt)._, t;
}, ta = new WeakMap(), Do = new WeakSet(), Gh = function() {
  return V(this, zt) < V(this, Wt).len ? !1 : (this.main.errScript("\u30B9\u30AF\u30EA\u30D7\u30C8\u7D42\u7AEF\u3067\u3059"), !0);
}, Lo = new WeakMap(), Fo = new WeakMap(), ea = new WeakMap(), Vi = new WeakMap(), ra = new WeakMap(), Yl = new WeakSet(), wf = function(t, e, R, N, M) {
  var U, H, z, X, Y;
  const D = t.aToken.length;
  if (!N) {
    if (ot(this, Do, Gh).call(this))
      return { idx: M, ln: R };
    if (t.aLNum[M])
      R = t.aLNum[M];
    else {
      R = 1;
      for (let W = 0; W < M; ++W) {
        (U = t.aLNum)[W] || (U[W] = R);
        const q = t.aToken[W];
        q.charCodeAt(0) === 10 ? R += q.length : R += ((H = q.match(/\n/g)) != null ? H : []).length;
      }
      t.aLNum[M] = R;
    }
    return { idx: M, ln: R };
  }
  t.aLNum[0] = 1;
  const L = N.match(V(this, Lo));
  if (L) {
    N = L[1];
    let W = M;
    switch (L[2]) {
      case "before":
        for (; t.aToken[--W] !== N; )
          W === 0 && DebugMng.myTrace("[jump\u7CFB \u7121\u540D\u30E9\u30D9\u30EBbefore] " + R + "\u884C\u76EE\u4EE5\u524D\u3067" + (e ? "\u30DE\u30AF\u30ED\u5185\u306B" : "") + "\u30E9\u30D9\u30EB\u3010" + N + "\u3011\u304C\u3042\u308A\u307E\u305B\u3093", "ET"), e && t.aToken[W].search(V(this, Fo)) > -1 && DebugMng.myTrace("[jump\u7CFB \u7121\u540D\u30E9\u30D9\u30EBbefore] \u30DE\u30AF\u30ED\u5185\u306B\u30E9\u30D9\u30EB\u3010" + N + "\u3011\u304C\u3042\u308A\u307E\u305B\u3093", "ET");
        return { idx: W + 1, ln: t.aLNum[W] };
      case "after":
        for (; t.aToken[++W] !== N; )
          W === D && DebugMng.myTrace("[jump\u7CFB \u7121\u540D\u30E9\u30D9\u30EBafter] " + R + "\u884C\u76EE\u4EE5\u5F8C\u3067\u30DE\u30AF\u30ED\u5185\u306B\u30E9\u30D9\u30EB\u3010" + N + "\u3011\u304C\u3042\u308A\u307E\u305B\u3093", "ET"), t.aToken[W].search(V(this, ea)) > -1 && DebugMng.myTrace("[jump\u7CFB \u7121\u540D\u30E9\u30D9\u30EBafter] " + R + "\u884C\u76EE\u4EE5\u5F8C\u3067\u30DE\u30AF\u30ED\u5185\u306B\u30E9\u30D9\u30EB\u3010" + N + "\u3011\u304C\u3042\u308A\u307E\u305B\u3093", "ET");
        return { idx: W + 1, ln: t.aLNum[W] };
      default:
        DebugMng.myTrace("[jump\u7CFB] \u7121\u540D\u30E9\u30D9\u30EB\u6307\u5B9A\u3010label=" + N + "\u3011\u304C\u9593\u9055\u3063\u3066\u3044\u307E\u3059", "ET");
    }
  }
  R = 1;
  const B = new RegExp(
    "^" + N.replaceAll("*", "\\*") + "(?:\\s|;|\\[|$)"
  );
  let $ = !1;
  for (let W = 0; W < D; ++W) {
    (z = t.aLNum)[W] || (z[W] = R);
    const q = t.aToken[W];
    if ($) {
      V(this, ra).lastIndex = 0, V(this, ra).test(q) ? $ = !1 : R += ((X = q.match(/\n/g)) != null ? X : []).length;
      continue;
    }
    const Z = q.charCodeAt(0);
    if (Z === 10) {
      R += q.length;
      continue;
    }
    if (Z === 42) {
      if (q.search(B) > -1)
        return { idx: W + 1, ln: R };
      continue;
    }
    Z === 91 && (R += ((Y = q.match(/\n/g)) != null ? Y : []).length, V(this, Vi).lastIndex = 0, V(this, Vi).test(q) && ($ = !0));
  }
  throw $ ? "[let_ml]\u306E\u7D42\u7AEF\u30FB[endlet_ml]\u304C\u3042\u308A\u307E\u305B\u3093" : (DebugMng.myTrace(`[jump\u7CFB] \u30E9\u30D9\u30EB\u3010${N}\u3011\u304C\u3042\u308A\u307E\u305B\u3093`, "ET"), "Dummy");
}, We = new WeakMap(), ql = new WeakSet(), Rf = function(t) {
  const e = V(this, hi).matchToken(t.replace(/(\r\n|\r)/g, `
`));
  for (let N = e.length - 1; N >= 0; --N) {
    const M = e[N];
    if (V(this, Vi).lastIndex = 0, V(this, Vi).test(M)) {
      const D = M.indexOf("]") + 1;
      if (D === 0)
        throw "[let_ml]\u3067\u9589\u3058\u308B\u3010]\u3011\u304C\u3042\u308A\u307E\u305B\u3093";
      const L = M.slice(0, D), B = M.slice(D);
      e.splice(N, 1, L, B);
    }
  }
  it(this, Wt, { aToken: e, len: e.length, aLNum: [] });
  let R = "";
  try {
    R = "ScriptIterator.replaceScriptChar2macro", V(this, hi).replaceScr_C2M_And_let_ml(V(this, Wt)), R = "ScriptIterator.replaceScript_Wildcard", V(this, Go).call(this);
  } catch (N) {
    N instanceof Error ? R += `\u4F8B\u5916 mes=${N.message}(${N.name})` : R = N, this.main.errScript(R, !1);
  }
  V(this, We)[V(this, ie)] = V(this, Wt), this.val.loadScrWork(V(this, ie));
}, Bo = new WeakSet(), Uh = function(t) {
  it(this, ie, t.fn), it(this, zt, t.idx);
  const e = V(this, We)[V(this, ie)];
  e && it(this, Wt, e), it(this, de, V(this, Wt).aLNum[t.idx]);
}, $o = new WeakMap(), ko = new WeakMap(), Go = new WeakMap(), Zl = new WeakSet(), Pf = function() {
  const t = this.val.getAreaKidoku(V(this, ie));
  if (!t)
    throw `recordKidoku fn:'${V(this, ie)}' (areas === null)`;
  if (V(this, fe).length > 0) {
    t.record(V(this, zt));
    return;
  }
  it(this, zr, t.search(V(this, zt))), this.val.setVal_Nochk("tmp", "const.sn.isKidoku", V(this, zr)), !V(this, zr) && t.record(V(this, zt));
}, zr = new WeakMap(), Uo = new WeakSet(), Hh = function() {
  var t;
  (t = this.val.getAreaKidoku(V(this, ie))) == null || t.erase(V(this, zt)), it(this, zr, !1);
}, Kl = new WeakSet(), Af = function(t) {
  return V(this, hi).bracket2macro(t, V(this, Wt), V(this, zt)), !1;
}, Jl = new WeakSet(), Of = function(t) {
  return V(this, hi).char2macro(t, this.hTag, V(this, Wt), V(this, zt)), !1;
}, Ql = new WeakSet(), Nf = function(t) {
  var M, D, L;
  const { name: e } = t;
  if (!e)
    throw "name\u306F\u5FC5\u9808\u3067\u3059";
  if (e in this.hTag)
    throw `[${e}]\u306F\u30BF\u30B0\u304B\u3059\u3067\u306B\u5B9A\u7FA9\u6E08\u307F\u306E\u30DE\u30AF\u30ED\u3067\u3059`;
  const R = V(this, de), N = new CallStack(V(this, ie), V(this, zt));
  for (it(this, ia, V(this, ia) + ("|" + e)), it(this, Bn, new RegExp(`\\[(${V(this, ia)})\\b`)), this.hTag[e] = (B) => (B.design_unit = t.design_unit, ot(this, Oo, Bh).call(this, { ...B, ":hMp": this.val.cloneMp() }), this.val.setMp(B), this.val.setVal_Nochk("mp", "const.sn.macro", JSON.stringify(t)), this.val.setVal_Nochk("mp", "const.sn.me_call_scriptFn", V(this, ie)), it(this, de, R), ot(this, Bo, Uh).call(this, N), !1); V(this, zt) < V(this, Wt).len; ++Ae(this, zt)._) {
    (M = V(this, Wt).aLNum)[D = V(this, zt)] || (M[D] = V(this, de));
    const B = V(this, Wt).aToken[V(this, zt)];
    if (B.search(V(this, ea)) > -1)
      return ++Ae(this, zt)._, !1;
    const $ = B.charCodeAt(0);
    $ === 10 ? it(this, de, V(this, de) + B.length) : $ === 91 && it(this, de, V(this, de) + ((L = B.match(/\n/g)) != null ? L : []).length);
  }
  throw `\u30DE\u30AF\u30ED[${e}]\u5B9A\u7FA9\u306E\u7D42\u7AEF\u30FB[endmacro]\u304C\u3042\u308A\u307E\u305B\u3093`;
}, ia = new WeakMap(), Bn = new WeakMap(), th = new WeakSet(), Mf = function(t) {
  if (!("place" in t))
    throw "place\u306F\u5FC5\u9808\u3067\u3059";
  const e = Number(t.place);
  if ("fn" in t != "label" in t)
    throw "fn\u3068label\u306F\u30BB\u30C3\u30C8\u3067\u6307\u5B9A\u3057\u3066\u4E0B\u3055\u3044";
  const R = this.val.getMark(e);
  if (!R)
    throw `place\u3010${e}\u3011\u306F\u5B58\u5728\u3057\u307E\u305B\u3093`;
  return ot(this, na, ou).call(this, t, R);
}, na = new WeakSet(), ou = function(t, e, R = !0) {
  this.hTag.clear_event({}), this.val.mark2save(e), this.val.setMp({}), V(this, fr).recText("", !0), R && this.sndMng.playLoopFromSaveObj(), argChk_Boolean(t, "do_rec", !0) && it(this, br, {
    hSave: this.val.cloneSave(),
    hPages: { ...e.hPages },
    aIfStk: [...e.aIfStk]
  });
  const N = {
    enabled: this.val.getVal("save:const.sn.autowc.enabled"),
    text: this.val.getVal("save:const.sn.autowc.text"),
    time: Number(this.val.getVal("save:const.sn.autowc.time"))
  };
  this.hTag.autowc(N);
  const M = String(this.val.getVal("save:const.sn.scriptFn")), D = Number(this.val.getVal("save:const.sn.scriptIdx"));
  return it(this, tr, [...V(this, br).aIfStk]), it(this, fe, []), V(this, fr).cover(!0), V(this, fr).stopAllTw(), "index" in t ? (V(this, fr).playback(V(this, br).hPages, () => {
    var L, B;
    V(this, fr).cover(!1), it(this, $n, !0), ot(this, pi, Ki).call(this, (L = t.fn) != null ? L : M, "", (B = t.index) != null ? B : D);
  }), !0) : (delete V(this, We)[M], V(this, fr).playback(
    V(this, br).hPages,
    "label" in t ? () => {
      V(this, fr).cover(!1), it(this, ie, M), it(this, zt, D), this.hTag.call({ fn: t.fn, label: t.label });
    } : () => {
      V(this, fr).cover(!1), ot(this, pi, Ki).call(this, M, "", D);
    }
  ), !0);
}, $n = new WeakMap(), eh = new WeakSet(), Df = function(t) {
  const e = this.val.getMark(0);
  return delete V(this, We)[getFn(e.hSave["const.sn.scriptFn"])], t.do_rec = !1, ot(this, na, ou).call(this, t, e, !1);
}, br = new WeakMap(), rh = new WeakSet(), Lf = function() {
  if (this.main.isDestroyed())
    return !1;
  const { fn: t, idx: e } = ot(this, sa, uu).call(this);
  return this.val.setVal_Nochk("save", "const.sn.scriptFn", t), this.val.setVal_Nochk("save", "const.sn.scriptIdx", e), it(this, br, {
    hSave: this.val.cloneSave(),
    hPages: V(this, fr).record(),
    aIfStk: V(this, tr).slice(V(this, fe).length)
  }), !1;
}, sa = new WeakSet(), uu = function() {
  if (V(this, fe).length === 0)
    return {
      fn: V(this, ie),
      idx: V(this, zt)
    };
  const e = V(this, fe)[0];
  return {
    fn: e.fn,
    idx: e.idx
  };
}, ih = new WeakSet(), Ff = function(t) {
  var N;
  if (!("place" in t))
    throw "place\u306F\u5FC5\u9808\u3067\u3059";
  const e = Number(t.place);
  delete t[":\u30BF\u30B0\u540D"], delete t.place, t.text = ((N = t.text) != null ? N : "").replace(/^(<br\/>)+/, ""), V(this, br).json = t, this.val.setMark(e, V(this, br));
  const R = Number(this.val.getVal("sys:const.sn.save.place"));
  return e === R && this.val.setVal_Nochk("sys", "const.sn.save.place", R + 1), !1;
}, Er = new WeakMap(), Me = new WeakMap(), nt(ScriptIterator, Fl, /(.+)\/crypto_prj\/([^\/]+)\/[^\.]+(\.\w+)/), nt(ScriptIterator, Dn, {}), nt(ScriptIterator, fi, {});
var er, rr, Be, xr, vi, kn, $e, Ho, gi, aa, Xi, oa, ua, Gn, nh, Bf, la, ha, Un, ca, lu, Wi, Hn;
class Main {
  constructor(t) {
    nt(this, nh);
    nt(this, ca);
    nt(this, er, void 0);
    nt(this, rr, void 0);
    nt(this, Be, void 0);
    nt(this, xr, void 0);
    nt(this, vi, void 0);
    nt(this, kn, void 0);
    nt(this, $e, void 0);
    nt(this, Ho, void 0);
    nt(this, gi, void 0);
    nt(this, aa, void 0);
    nt(this, Xi, void 0);
    nt(this, oa, void 0);
    nt(this, ua, void 0);
    nt(this, Gn, void 0);
    nt(this, la, void 0);
    nt(this, ha, void 0);
    nt(this, Un, void 0);
    nt(this, Wi, void 0);
    nt(this, Hn, void 0);
    this.sys = t, it(this, Be, /* @__PURE__ */ Object.create(null)), it(this, Xi, () => {
    }), it(this, oa, new AnalyzeTagArg()), it(this, ua, !1), it(this, Gn, "skynovel"), it(this, la, () => V(this, Xi).call(this)), it(this, ha, (e = ot(this, ca, lu)) => {
      V(this, Wi) || (V(this, gi).clearBreak(), it(this, Xi, e), this.resume = (R = ot(this, ca, lu)) => {
        it(this, Xi, R);
      }, V(this, $e).noticeBreak(!1));
    }), this.resume = V(this, ha), this.stop = () => {
      it(this, Xi, () => {
      }), this.resume = V(this, ha), V(this, $e).noticeBreak(!0);
    }, it(this, Un, !0), it(this, Wi, !1), this.isDestroyed = () => V(this, Wi), skipHello(), Config.generate(t).then((e) => it(this, er, e)).then(() => ot(this, nh, Bf).call(this)).catch((e) => console.error("load err fn:prj.json e:%o", e));
  }
  errScript(t, e = !0) {
    if (this.stop(), DebugMng.myTrace(t), CmnLib.debugLog && console.log("\u{1F35C} SKYNovel err!"), e)
      throw t;
  }
  resumeByJumpOrCall(t) {
    var e, R;
    if (t.url) {
      globalThis.open(t.url);
      return;
    }
    V(this, xr).setVal_Nochk("tmp", "sn.eventArg", (e = t.arg) != null ? e : ""), V(this, xr).setVal_Nochk("tmp", "sn.eventLabel", (R = t.label) != null ? R : ""), argChk_Boolean(t, "call", !1) ? (V(this, $e).subIdxToken(), this.resume(() => V(this, Be).call(t))) : (V(this, Be).clear_event({}), this.resume(() => V(this, Be).jump(t)));
  }
  setLoop(t, e = "") {
    it(this, Un, t) ? this.resume() : this.stop(), this.sys.setTitleInfo(e ? ` -- ${e}\u4E2D` : "");
  }
  fire(t, e) {
    V(this, aa).fire(t, e);
  }
  async destroy(t = 0) {
    V(this, Wi) || (it(this, Wi, !0), V(this, ua) && (this.stop(), it(this, Un, !1), V(this, gi).before_destroy(), t > 0 && await new Promise((e) => setTimeout(e, t)), it(this, Be, {}), V(this, aa).destroy(), V(this, $e).destroy(), V(this, gi).destroy(), V(this, Ho).destroy(), V(this, rr).ticker.remove(V(this, la)), V(this, Hn) && V(this, rr) && V(this, rr).view.parentNode.appendChild(V(this, Hn)), clearTextureCache(), V(this, rr).destroy(!0), this.sys.destroy()));
  }
}
er = new WeakMap(), rr = new WeakMap(), Be = new WeakMap(), xr = new WeakMap(), vi = new WeakMap(), kn = new WeakMap(), $e = new WeakMap(), Ho = new WeakMap(), gi = new WeakMap(), aa = new WeakMap(), Xi = new WeakMap(), oa = new WeakMap(), ua = new WeakMap(), Gn = new WeakMap(), nh = new WeakSet(), Bf = async function() {
  var N, M, D;
  const t = (N = document.createElement("canvas")) == null ? void 0 : N.getContext("2d");
  if (!t)
    throw "argChk_Color err";
  CmnLib.cc4ColorName = t;
  const e = {
    width: V(this, er).oCfg.window.width,
    height: V(this, er).oCfg.window.height,
    backgroundColor: parseColor(String(V(this, er).oCfg.init.bg_color)),
    resolution: (M = globalThis.devicePixelRatio) != null ? M : 1,
    autoResize: !0
  }, R = document.getElementById(V(this, Gn));
  R && (it(this, Hn, R.cloneNode(!0)), V(this, Hn).id = V(this, Gn), e.view = R), it(this, rr, new Application(e)), R || (document.body.appendChild(V(this, rr).view), V(this, rr).view.id = V(this, Gn)), it(this, xr, new Variable(V(this, er), V(this, Be))), it(this, vi, new PropParser(V(this, xr), (D = V(this, er).oCfg.init.escape) != null ? D : "\\")), await Promise.allSettled(this.sys.init(V(this, Be), V(this, rr), V(this, xr), this)), V(this, Be).title({ text: V(this, er).oCfg.book.title || "SKYNovel" }), it(this, kn, new SoundMng(V(this, er), V(this, Be), V(this, xr), this, this.sys)), it(this, $e, new ScriptIterator(V(this, er), V(this, Be), this, V(this, xr), V(this, oa), () => ot(this, ca, lu).call(this), V(this, vi), V(this, kn), this.sys)), it(this, Ho, new DebugMng(this.sys, V(this, Be), V(this, $e))), it(this, gi, new LayerMng(V(this, er), V(this, Be), V(this, rr), V(this, xr), this, V(this, $e), this.sys, V(this, kn), V(this, oa), V(this, vi))), it(this, aa, new EventMng(V(this, er), V(this, Be), V(this, rr), this, V(this, gi), V(this, xr), V(this, kn), V(this, $e), this.sys)), V(this, rr).ticker.add(V(this, la)), this.resumeByJumpOrCall({ fn: "main" }), it(this, ua, !0);
}, la = new WeakMap(), ha = new WeakMap(), Un = new WeakMap(), ca = new WeakSet(), lu = function() {
  var t;
  for (; V(this, Un); ) {
    let e = V(this, $e).nextToken();
    if (!e)
      break;
    const R = e.charCodeAt(0);
    if (R !== 9) {
      if (R === 10) {
        V(this, $e).addLineNum(e.length);
        continue;
      }
      if (R === 91) {
        if (V(this, $e).isBreak(e))
          return;
        try {
          const N = ((t = e.match(/\n/g)) != null ? t : []).length;
          if (N > 0 && V(this, $e).addLineNum(N), V(this, $e).\u30BF\u30B0\u89E3\u6790(e)) {
            this.stop();
            break;
          }
          continue;
        } catch (N) {
          N instanceof Error ? this.errScript(`[${tagToken2Name(e)}]\u30BF\u30B0\u89E3\u6790\u4E2D\u4F8B\u5916 mes=${N.message}(${N.name})`, !1) : this.errScript(String(N), !1);
          return;
        }
      }
      if (R === 38)
        try {
          if (e.slice(-1) !== "&") {
            if (V(this, $e).isBreak(e))
              return;
            const N = splitAmpersand(e.slice(1));
            N.name = V(this, vi).getValAmpersand(N.name), N.text = String(V(this, vi).parse(N.text)), V(this, Be).let(N);
            continue;
          }
          if (e.charAt(1) === "&")
            throw new Error("\u300C&\u8868\u793A&\u300D\u66F8\u5F0F\u3067\u306F\u300C&\u300D\u6307\u5B9A\u304C\u4E0D\u8981\u3067\u3059");
          e = String(V(this, vi).parse(e.slice(1, -1)));
        } catch (N) {
          this.errScript(
            N instanceof Error ? `& \u5909\u6570\u64CD\u4F5C\u30FB\u8868\u793A mes=${N.message}(${N.name})` : N,
            !1
          );
          return;
        }
      else {
        if (R === 59)
          continue;
        if (R === 42 && e.length > 1)
          continue;
      }
      try {
        V(this, gi).currentTxtlayForeNeedErr.tagCh(e);
      } catch (N) {
        this.errScript(
          N instanceof Error ? `\u6587\u5B57\u8868\u793A mes=${N.message}(${N.name})` : N,
          !1
        );
        return;
      }
    }
  }
}, Wi = new WeakMap(), Hn = new WeakMap();
var assign = make_assign(), create$1 = make_create(), trim$1 = make_trim(), Global$5 = typeof window < "u" ? window : commonjsGlobal$1, util$6 = {
  assign,
  create: create$1,
  trim: trim$1,
  bind: bind$1,
  slice: slice$1,
  each: each$7,
  map,
  pluck: pluck$1,
  isList: isList$1,
  isFunction: isFunction$1,
  isObject: isObject$1,
  Global: Global$5
};
function make_assign() {
  return Object.assign ? Object.assign : function(t, e, R, N) {
    for (var M = 1; M < arguments.length; M++)
      each$7(Object(arguments[M]), function(D, L) {
        t[L] = D;
      });
    return t;
  };
}
function make_create() {
  if (Object.create)
    return function(t, e, R, N) {
      var M = slice$1(arguments, 1);
      return assign.apply(this, [Object.create(t)].concat(M));
    };
  {
    let o = function() {
    };
    return function(e, R, N, M) {
      var D = slice$1(arguments, 1);
      return o.prototype = e, assign.apply(this, [new o()].concat(D));
    };
  }
}
function make_trim() {
  return String.prototype.trim ? function(t) {
    return String.prototype.trim.call(t);
  } : function(t) {
    return t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  };
}
function bind$1(o, t) {
  return function() {
    return t.apply(o, Array.prototype.slice.call(arguments, 0));
  };
}
function slice$1(o, t) {
  return Array.prototype.slice.call(o, t || 0);
}
function each$7(o, t) {
  pluck$1(o, function(e, R) {
    return t(e, R), !1;
  });
}
function map(o, t) {
  var e = isList$1(o) ? [] : {};
  return pluck$1(o, function(R, N) {
    return e[N] = t(R, N), !1;
  }), e;
}
function pluck$1(o, t) {
  if (isList$1(o)) {
    for (var e = 0; e < o.length; e++)
      if (t(o[e], e))
        return o[e];
  } else
    for (var R in o)
      if (o.hasOwnProperty(R) && t(o[R], R))
        return o[R];
}
function isList$1(o) {
  return o != null && typeof o != "function" && typeof o.length == "number";
}
function isFunction$1(o) {
  return o && {}.toString.call(o) === "[object Function]";
}
function isObject$1(o) {
  return o && {}.toString.call(o) === "[object Object]";
}
var util$5 = util$6, slice = util$5.slice, pluck = util$5.pluck, each$6 = util$5.each, bind = util$5.bind, create = util$5.create, isList = util$5.isList, isFunction = util$5.isFunction, isObject = util$5.isObject, storeEngine = {
  createStore
}, storeAPI = {
  version: "2.0.12",
  enabled: !1,
  get: function(o, t) {
    var e = this.storage.read(this._namespacePrefix + o);
    return this._deserialize(e, t);
  },
  set: function(o, t) {
    return t === void 0 ? this.remove(o) : (this.storage.write(this._namespacePrefix + o, this._serialize(t)), t);
  },
  remove: function(o) {
    this.storage.remove(this._namespacePrefix + o);
  },
  each: function(o) {
    var t = this;
    this.storage.each(function(e, R) {
      o.call(t, t._deserialize(e), (R || "").replace(t._namespaceRegexp, ""));
    });
  },
  clearAll: function() {
    this.storage.clearAll();
  },
  hasNamespace: function(o) {
    return this._namespacePrefix == "__storejs_" + o + "_";
  },
  createStore: function() {
    return createStore.apply(this, arguments);
  },
  addPlugin: function(o) {
    this._addPlugin(o);
  },
  namespace: function(o) {
    return createStore(this.storage, this.plugins, o);
  }
};
function _warn() {
  var o = typeof console > "u" ? null : console;
  if (!!o) {
    var t = o.warn ? o.warn : o.log;
    t.apply(o, arguments);
  }
}
function createStore(o, t, e) {
  e || (e = ""), o && !isList(o) && (o = [o]), t && !isList(t) && (t = [t]);
  var R = e ? "__storejs_" + e + "_" : "", N = e ? new RegExp("^" + R) : null, M = /^[a-zA-Z0-9_\-]*$/;
  if (!M.test(e))
    throw new Error("store.js namespaces can only have alphanumerics + underscores and dashes");
  var D = {
    _namespacePrefix: R,
    _namespaceRegexp: N,
    _testStorage: function(B) {
      try {
        var $ = "__storejs__test__";
        B.write($, $);
        var U = B.read($) === $;
        return B.remove($), U;
      } catch {
        return !1;
      }
    },
    _assignPluginFnProp: function(B, $) {
      var U = this[$];
      this[$] = function() {
        var z = slice(arguments, 0), X = this;
        function Y() {
          if (!!U)
            return each$6(arguments, function(q, Z) {
              z[Z] = q;
            }), U.apply(X, z);
        }
        var W = [Y].concat(z);
        return B.apply(X, W);
      };
    },
    _serialize: function(B) {
      return JSON.stringify(B);
    },
    _deserialize: function(B, $) {
      if (!B)
        return $;
      var U = "";
      try {
        U = JSON.parse(B);
      } catch {
        U = B;
      }
      return U !== void 0 ? U : $;
    },
    _addStorage: function(B) {
      this.enabled || this._testStorage(B) && (this.storage = B, this.enabled = !0);
    },
    _addPlugin: function(B) {
      var $ = this;
      if (isList(B)) {
        each$6(B, function(z) {
          $._addPlugin(z);
        });
        return;
      }
      var U = pluck(this.plugins, function(z) {
        return B === z;
      });
      if (!U) {
        if (this.plugins.push(B), !isFunction(B))
          throw new Error("Plugins must be function values that return objects");
        var H = B.call(this);
        if (!isObject(H))
          throw new Error("Plugins must return an object of function properties");
        each$6(H, function(z, X) {
          if (!isFunction(z))
            throw new Error("Bad plugin property: " + X + " from plugin " + B.name + ". Plugins should only return functions.");
          $._assignPluginFnProp(z, X);
        });
      }
    },
    addStorage: function(B) {
      _warn("store.addStorage(storage) is deprecated. Use createStore([storages])"), this._addStorage(B);
    }
  }, L = create(D, storeAPI, {
    plugins: []
  });
  return L.raw = {}, each$6(L, function(B, $) {
    isFunction(B) && (L.raw[$] = bind(L, B));
  }), each$6(o, function(B) {
    L._addStorage(B);
  }), each$6(t, function(B) {
    L._addPlugin(B);
  }), L;
}
var util$4 = util$6, Global$4 = util$4.Global, localStorage_1 = {
  name: "localStorage",
  read: read$5,
  write: write$5,
  each: each$5,
  remove: remove$5,
  clearAll: clearAll$5
};
function localStorage() {
  return Global$4.localStorage;
}
function read$5(o) {
  return localStorage().getItem(o);
}
function write$5(o, t) {
  return localStorage().setItem(o, t);
}
function each$5(o) {
  for (var t = localStorage().length - 1; t >= 0; t--) {
    var e = localStorage().key(t);
    o(read$5(e), e);
  }
}
function remove$5(o) {
  return localStorage().removeItem(o);
}
function clearAll$5() {
  return localStorage().clear();
}
var util$3 = util$6, Global$3 = util$3.Global, oldFFGlobalStorage = {
  name: "oldFF-globalStorage",
  read: read$4,
  write: write$4,
  each: each$4,
  remove: remove$4,
  clearAll: clearAll$4
}, globalStorage = Global$3.globalStorage;
function read$4(o) {
  return globalStorage[o];
}
function write$4(o, t) {
  globalStorage[o] = t;
}
function each$4(o) {
  for (var t = globalStorage.length - 1; t >= 0; t--) {
    var e = globalStorage.key(t);
    o(globalStorage[e], e);
  }
}
function remove$4(o) {
  return globalStorage.removeItem(o);
}
function clearAll$4() {
  each$4(function(o, t) {
    delete globalStorage[o];
  });
}
var util$2 = util$6, Global$2 = util$2.Global, oldIEUserDataStorage = {
  name: "oldIE-userDataStorage",
  write: write$3,
  read: read$3,
  each: each$3,
  remove: remove$3,
  clearAll: clearAll$3
}, storageName = "storejs", doc$1 = Global$2.document, _withStorageEl = _makeIEStorageElFunction(), disable = (Global$2.navigator ? Global$2.navigator.userAgent : "").match(/ (MSIE 8|MSIE 9|MSIE 10)\./);
function write$3(o, t) {
  if (!disable) {
    var e = fixKey(o);
    _withStorageEl(function(R) {
      R.setAttribute(e, t), R.save(storageName);
    });
  }
}
function read$3(o) {
  if (!disable) {
    var t = fixKey(o), e = null;
    return _withStorageEl(function(R) {
      e = R.getAttribute(t);
    }), e;
  }
}
function each$3(o) {
  _withStorageEl(function(t) {
    for (var e = t.XMLDocument.documentElement.attributes, R = e.length - 1; R >= 0; R--) {
      var N = e[R];
      o(t.getAttribute(N.name), N.name);
    }
  });
}
function remove$3(o) {
  var t = fixKey(o);
  _withStorageEl(function(e) {
    e.removeAttribute(t), e.save(storageName);
  });
}
function clearAll$3() {
  _withStorageEl(function(o) {
    var t = o.XMLDocument.documentElement.attributes;
    o.load(storageName);
    for (var e = t.length - 1; e >= 0; e--)
      o.removeAttribute(t[e].name);
    o.save(storageName);
  });
}
var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g");
function fixKey(o) {
  return o.replace(/^\d/, "___$&").replace(forbiddenCharsRegex, "___");
}
function _makeIEStorageElFunction() {
  if (!doc$1 || !doc$1.documentElement || !doc$1.documentElement.addBehavior)
    return null;
  var o = "script", t, e, R;
  try {
    e = new ActiveXObject("htmlfile"), e.open(), e.write("<" + o + ">document.w=window</" + o + '><iframe src="/favicon.ico"></iframe>'), e.close(), t = e.w.frames[0].document, R = t.createElement("div");
  } catch {
    R = doc$1.createElement("div"), t = doc$1.body;
  }
  return function(N) {
    var M = [].slice.call(arguments, 0);
    M.unshift(R), t.appendChild(R), R.addBehavior("#default#userData"), R.load(storageName), N.apply(this, M), t.removeChild(R);
  };
}
var util$1 = util$6, Global$1 = util$1.Global, trim = util$1.trim, cookieStorage = {
  name: "cookieStorage",
  read: read$2,
  write: write$2,
  each: each$2,
  remove: remove$2,
  clearAll: clearAll$2
}, doc = Global$1.document;
function read$2(o) {
  if (!o || !_has(o))
    return null;
  var t = "(?:^|.*;\\s*)" + escape(o).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*";
  return unescape(doc.cookie.replace(new RegExp(t), "$1"));
}
function each$2(o) {
  for (var t = doc.cookie.split(/; ?/g), e = t.length - 1; e >= 0; e--)
    if (!!trim(t[e])) {
      var R = t[e].split("="), N = unescape(R[0]), M = unescape(R[1]);
      o(M, N);
    }
}
function write$2(o, t) {
  !o || (doc.cookie = escape(o) + "=" + escape(t) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/");
}
function remove$2(o) {
  !o || !_has(o) || (doc.cookie = escape(o) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/");
}
function clearAll$2() {
  each$2(function(o, t) {
    remove$2(t);
  });
}
function _has(o) {
  return new RegExp("(?:^|;\\s*)" + escape(o).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=").test(doc.cookie);
}
var util = util$6, Global = util.Global, sessionStorage_1 = {
  name: "sessionStorage",
  read: read$1,
  write: write$1,
  each: each$1,
  remove: remove$1,
  clearAll: clearAll$1
};
function sessionStorage$1() {
  return Global.sessionStorage;
}
function read$1(o) {
  return sessionStorage$1().getItem(o);
}
function write$1(o, t) {
  return sessionStorage$1().setItem(o, t);
}
function each$1(o) {
  for (var t = sessionStorage$1().length - 1; t >= 0; t--) {
    var e = sessionStorage$1().key(t);
    o(read$1(e), e);
  }
}
function remove$1(o) {
  return sessionStorage$1().removeItem(o);
}
function clearAll$1() {
  return sessionStorage$1().clear();
}
var memoryStorage_1 = {
  name: "memoryStorage",
  read,
  write,
  each,
  remove,
  clearAll
}, memoryStorage = {};
function read(o) {
  return memoryStorage[o];
}
function write(o, t) {
  memoryStorage[o] = t;
}
function each(o) {
  for (var t in memoryStorage)
    memoryStorage.hasOwnProperty(t) && o(memoryStorage[t], t);
}
function remove(o) {
  delete memoryStorage[o];
}
function clearAll(o) {
  memoryStorage = {};
}
var all = [
  localStorage_1,
  oldFFGlobalStorage,
  oldIEUserDataStorage,
  cookieStorage,
  sessionStorage_1,
  memoryStorage_1
], json2$1 = {}, hasRequiredJson2;
function requireJson2() {
  return hasRequiredJson2 || (hasRequiredJson2 = 1, typeof JSON != "object" && (JSON = {}), function() {
    var rx_one = /^[\],:{}\s]*$/, rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, rx_four = /(?:^|:|,)(?:\s*\[)+/g, rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    function f(o) {
      return o < 10 ? "0" + o : o;
    }
    function this_value() {
      return this.valueOf();
    }
    typeof Date.prototype.toJSON != "function" && (Date.prototype.toJSON = function() {
      return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null;
    }, Boolean.prototype.toJSON = this_value, Number.prototype.toJSON = this_value, String.prototype.toJSON = this_value);
    var gap, indent, meta, rep;
    function quote(o) {
      return rx_escapable.lastIndex = 0, rx_escapable.test(o) ? '"' + o.replace(rx_escapable, function(t) {
        var e = meta[t];
        return typeof e == "string" ? e : "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + o + '"';
    }
    function str(o, t) {
      var e, R, N, M, D = gap, L, B = t[o];
      switch (B && typeof B == "object" && typeof B.toJSON == "function" && (B = B.toJSON(o)), typeof rep == "function" && (B = rep.call(t, o, B)), typeof B) {
        case "string":
          return quote(B);
        case "number":
          return isFinite(B) ? String(B) : "null";
        case "boolean":
        case "null":
          return String(B);
        case "object":
          if (!B)
            return "null";
          if (gap += indent, L = [], Object.prototype.toString.apply(B) === "[object Array]") {
            for (M = B.length, e = 0; e < M; e += 1)
              L[e] = str(e, B) || "null";
            return N = L.length === 0 ? "[]" : gap ? `[
` + gap + L.join(`,
` + gap) + `
` + D + "]" : "[" + L.join(",") + "]", gap = D, N;
          }
          if (rep && typeof rep == "object")
            for (M = rep.length, e = 0; e < M; e += 1)
              typeof rep[e] == "string" && (R = rep[e], N = str(R, B), N && L.push(quote(R) + (gap ? ": " : ":") + N));
          else
            for (R in B)
              Object.prototype.hasOwnProperty.call(B, R) && (N = str(R, B), N && L.push(quote(R) + (gap ? ": " : ":") + N));
          return N = L.length === 0 ? "{}" : gap ? `{
` + gap + L.join(`,
` + gap) + `
` + D + "}" : "{" + L.join(",") + "}", gap = D, N;
      }
    }
    typeof JSON.stringify != "function" && (meta = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    }, JSON.stringify = function(o, t, e) {
      var R;
      if (gap = "", indent = "", typeof e == "number")
        for (R = 0; R < e; R += 1)
          indent += " ";
      else
        typeof e == "string" && (indent = e);
      if (rep = t, t && typeof t != "function" && (typeof t != "object" || typeof t.length != "number"))
        throw new Error("JSON.stringify");
      return str("", { "": o });
    }), typeof JSON.parse != "function" && (JSON.parse = function(text, reviver) {
      var j;
      function walk(o, t) {
        var e, R, N = o[t];
        if (N && typeof N == "object")
          for (e in N)
            Object.prototype.hasOwnProperty.call(N, e) && (R = walk(N, e), R !== void 0 ? N[e] = R : delete N[e]);
        return reviver.call(o, t, N);
      }
      if (text = String(text), rx_dangerous.lastIndex = 0, rx_dangerous.test(text) && (text = text.replace(rx_dangerous, function(o) {
        return "\\u" + ("0000" + o.charCodeAt(0).toString(16)).slice(-4);
      })), rx_one.test(
        text.replace(rx_two, "@").replace(rx_three, "]").replace(rx_four, "")
      ))
        return j = eval("(" + text + ")"), typeof reviver == "function" ? walk({ "": j }, "") : j;
      throw new SyntaxError("JSON.parse");
    });
  }()), json2$1;
}
var json2 = json2Plugin;
function json2Plugin() {
  return requireJson2(), {};
}
var engine = storeEngine, storages = all, plugins = [json2], store_legacy = engine.createStore(storages, plugins);
/*!
devtools-detect
https://github.com/sindresorhus/devtools-detect
By Sindre Sorhus
MIT License
*/
const devtools = {
  isOpen: !1,
  orientation: void 0
}, threshold = 160, emitEvent = (o, t) => {
  globalThis.dispatchEvent(new globalThis.CustomEvent("devtoolschange", {
    detail: {
      isOpen: o,
      orientation: t
    }
  }));
}, main = ({ emitEvents: o = !0 } = {}) => {
  const t = globalThis.outerWidth - globalThis.innerWidth > threshold, e = globalThis.outerHeight - globalThis.innerHeight > threshold, R = t ? "vertical" : "horizontal";
  !(e && t) && (globalThis.Firebug && globalThis.Firebug.chrome && globalThis.Firebug.chrome.isInitialized || t || e) ? ((!devtools.isOpen || devtools.orientation !== R) && o && emitEvent(!0, R), devtools.isOpen = !0, devtools.orientation = R) : (devtools.isOpen && o && emitEvent(!1, void 0), devtools.isOpen = !1, devtools.orientation = void 0);
};
main({ emitEvents: !1 });
setInterval(main, 500);
var zn, fa, jr, da;
class SysWeb extends SysBase {
  constructor(e = {}, R = { cur: "prj/", crypto: !1, dip: "" }) {
    super(e, R);
    nt(this, zn, void 0);
    nt(this, fa, void 0);
    nt(this, jr, void 0);
    nt(this, da, void 0);
    it(this, zn, ""), it(this, fa, ":"), this.run = async () => {
      V(this, jr) && (V(this, jr).destroy(10), await new Promise((D) => setTimeout(D, 10))), it(this, jr, new Main(this));
    }, it(this, jr, void 0), this.pathBaseCnvSnPath4Dbg = "${pathbase}/", this._export = () => ((async () => {
      const M = JSON.stringify({
        sys: this.data.sys,
        mark: this.data.mark,
        kidoku: this.data.kidoku
      }), D = this.crypto ? await this.enc(M) : M, L = new Blob([D], { type: "text/json" }), B = document.createElement("a");
      B.href = URL.createObjectURL(L), B.download = (this.crypto ? "" : "no_crypto_") + this.cfg.getNs() + getDateStr("-", "_", "") + ".swpd", B.click(), CmnLib.debugLog && console.log("\u30D7\u30EC\u30A4\u30C7\u30FC\u30BF\u3092\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F"), setTimeout(() => this.fire("sn:exported", new Event("click")), 10);
    })(), !1), this._import = () => (new Promise((M, D) => {
      const L = document.createElement("input");
      L.type = "file", L.accept = ".swpd, text/plain", L.onchange = () => {
        L.files ? M(L.files[0].path) : D();
      }, L.click();
    }).then((M) => new Promise((D) => {
      const L = new FileReader();
      L.readAsText(M), L.onload = () => D(L.result);
    })).then(async (M) => {
      const D = JSON.parse(this.crypto ? this.decStr("json", M) : M);
      if (!D.sys || !D.mark || !D.kidoku)
        throw new Error("\u7570\u5E38\u306A\u30D7\u30EC\u30A4\u30C7\u30FC\u30BF\u3067\u3059");
      if (D.sys[SysBase.VALNM_CFG_NS] !== this.cfg.oCfg.save_ns) {
        console.error(`\u5225\u306E\u30B2\u30FC\u30E0\u3010\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u540D=${D.sys[SysBase.VALNM_CFG_NS]}\u3011\u306E\u30D7\u30EC\u30A4\u30C7\u30FC\u30BF\u3067\u3059`);
        return;
      }
      this.data.sys = D.sys, this.data.mark = D.mark, this.data.kidoku = D.kidoku, this.flush(), this.val.updateData(D), CmnLib.debugLog && console.log("\u30D7\u30EC\u30A4\u30C7\u30FC\u30BF\u3092\u30A4\u30F3\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F"), this.fire("sn:imported", new Event("click"));
    }).catch((M) => console.error(`\u7570\u5E38\u306A\u30D7\u30EC\u30A4\u30C7\u30FC\u30BF\u3067\u3059 ${M.message}`)), !1), this.navigate_to = (M) => {
      const { url: D } = M;
      if (!D)
        throw "[navigate_to] url\u306F\u5FC5\u9808\u3067\u3059";
      return globalThis.open(D, "_blank"), !1;
    }, it(this, da, {});
    const N = R.cur.split("/");
    it(this, zn, N.length > 2 ? N.slice(0, -2).join("/") + "/" : ""), globalThis.onload = async () => this.loaded(e, R);
  }
  async loaded(e, R) {
    await super.loaded(e, R), document.querySelectorAll("[data-prj]").forEach((L) => {
      const B = L.attributes.getNamedItem("data-prj");
      B && this.elc.add(L, "click", () => this.runSN(B.value), { passive: !0 });
    }), document.querySelectorAll("[data-reload]").forEach(
      (L) => this.elc.add(L, "click", () => this.run(), { passive: !0 })
    ), R.dip && (CmnLib.hDip = JSON.parse(R.dip));
    const N = new URLSearchParams(location.search), M = N.get("dip");
    if (M && (CmnLib.hDip = { ...CmnLib.hDip, ...JSON.parse(M.replaceAll("%2C", ",")) }), !argChk_Boolean(CmnLib.hDip, "oninit_run", !0))
      return;
    argChk_Boolean(CmnLib.hDip, "dbg", !1) && (CmnLib.isDbg = !0, this.fetch = (L) => fetch(L, { mode: "cors" })), this.extPort = argChk_Num(CmnLib.hDip, "port", this.extPort);
    const D = N.get("cur");
    D && (R.cur = V(this, zn) + D + "/"), this.run();
  }
  runSN(e) {
    this.arg.cur = V(this, zn) + e + "/", V(this, fa) !== this.arg.cur && (it(this, fa, this.arg.cur), this.run());
  }
  stop() {
    !V(this, jr) || (V(this, jr).destroy(), it(this, jr, void 0));
  }
  async loadPath(e, R) {
    await super.loadPath(e, R);
    const N = this.arg.cur + "path.json", M = await fetch(N);
    if (!M.ok)
      throw Error(M.statusText);
    const D = await M.text(), L = JSON.parse(this.decStr(N, D));
    for (const B in L) {
      const $ = e[B] = L[B];
      for (const U in $)
        U !== ":cnt" && ($[U] = this.arg.cur + $[U]);
    }
  }
  initVal(e, R, N) {
    const M = encodeURIComponent(document.location.hostname);
    R["const.sn.isDebugger"] = M === "localhost" || M === "127.0.0.1";
    const D = this.cfg.getNs();
    this.flush = this.crypto ? async () => {
      store_legacy.set(D + "sys_", this.enc(JSON.stringify(this.data.sys))), store_legacy.set(D + "mark_", this.enc(JSON.stringify(this.data.mark))), store_legacy.set(D + "kidoku_", this.enc(JSON.stringify(this.data.kidoku)));
    } : () => {
      store_legacy.set(D + "sys", this.data.sys), store_legacy.set(D + "mark", this.data.mark), store_legacy.set(D + "kidoku", this.data.kidoku);
    };
    const L = D + (this.arg.crypto ? "sys_" : "sys");
    if (R["const.sn.isFirstBoot"] = store_legacy.get(L) === void 0) {
      this.data.sys = e.sys, this.data.mark = e.mark, this.data.kidoku = e.kidoku, this.flush(), N(this.data);
      return;
    }
    if (!this.crypto) {
      this.data.sys = store_legacy.get(D + "sys"), this.data.mark = store_legacy.get(D + "mark"), this.data.kidoku = store_legacy.get(D + "kidoku"), N(this.data);
      return;
    }
    let B = "";
    try {
      B = "sys", this.data.sys = JSON.parse(this.decStr("json", store_legacy.get(D + "sys_"))), B += Number(this.val.getVal("sys:TextLayer.Back.Alpha", 1)), B = "mark", this.data.mark = JSON.parse(this.decStr("json", store_legacy.get(D + "mark_"))), B = "kidoku", this.data.kidoku = JSON.parse(this.decStr("json", store_legacy.get(D + "kidoku_")));
    } catch ($) {
      console.error(`\u30BB\u30FC\u30D6\u30C7\u30FC\u30BF\uFF08${B}\uFF09\u304C\u58CA\u308C\u3066\u3044\u307E\u3059\u3002\u4E00\u5EA6\u30AF\u30EA\u30A2\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059 %o`, $);
    }
    N(this.data);
  }
  init(e, R, N, M) {
    super.init(e, R, N, M);
    const D = R.view.parentElement;
    if ("requestFullscreen" in document.body)
      this.tglFlscr_sub = () => this.isFullScr ? document.exitFullscreen() : D.requestFullscreen(), this.elc.add(document, "fullscreenchange", () => this.isFullScr = Boolean(document.fullscreenElement));
    else {
      const L = document;
      this.tglFlscr_sub = () => this.isFullScr ? L.webkitCancelFullScreen() : D.webkitRequestFullscreen(), this.elc.add(document, "fullscreenchange", () => this.isFullScr = Boolean(L.webkitFullscreenElement));
    }
    return this.cfg.oCfg.debug.devtool || this.elc.add(window, "devtoolschange", (L) => {
      !L.detail.isOpen || (console.error("DevTool\u306F\u7981\u6B62\u3055\u308C\u3066\u3044\u307E\u3059\u3002\u8A31\u53EF\u3059\u308B\u5834\u5408\u306F\u3010\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u8A2D\u5B9A\u3011\u306E\u3010devtool\u3011\u3092ON\u306B\u3002"), M.destroy());
    }, { once: !0, passive: !0 }), [];
  }
  cvsResize() {
    if (super.cvsResize(), this.isFullScr) {
      const e = this.appPixi.view.style;
      e.width = e.height = "";
    }
  }
  titleSub(e) {
    document.title = e, document.querySelectorAll("[data-title]").forEach((R) => R.textContent = e);
  }
  async savePic(e, R) {
    const N = document.createElement("a");
    N.href = R, N.download = e, N.click(), CmnLib.debugLog && console.log("\u753B\u50CF\u30D5\u30A1\u30A4\u30EB\u3092\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u3057\u307E\u3059");
  }
  async appendFile(e, R, N) {
    var B;
    const M = ((B = V(this, da)[e]) != null ? B : "") + R;
    V(this, da)[e] = M;
    const D = new Blob([M], { type: "text/json" }), L = document.createElement("a");
    L.href = URL.createObjectURL(D), L.download = e, L.click();
  }
}
zn = new WeakMap(), fa = new WeakMap(), jr = new WeakMap(), da = new WeakMap();
export {
  CmnLib,
  Layer,
  SysWeb,
  argChk_Boolean,
  argChk_Num
};
//# sourceMappingURL=web.js.map
