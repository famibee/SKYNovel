var kp = Object.defineProperty;
var Lp = (o, t, e) => t in o ? kp(o, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : o[t] = e;
var It = (o, t, e) => (Lp(o, typeof t != "symbol" ? t + "" : t, e), e), Xc = (o, t, e) => {
  if (!t.has(o))
    throw TypeError("Cannot " + e);
};
var H = (o, t, e) => (Xc(o, t, "read from private field"), e ? e.call(o) : t.get(o)), rt = (o, t, e) => {
  if (t.has(o))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(o) : t.set(o, e);
}, ot = (o, t, e, r) => (Xc(o, t, "write to private field"), r ? r.call(o, e) : t.set(o, e), e), Ie = (o, t, e, r) => ({
  set _(D) {
    ot(o, t, D, e);
  },
  get _() {
    return H(o, t, r);
  }
}), lt = (o, t, e) => (Xc(o, t, "access private method"), e);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
}
var platform$1 = { exports: {} };
/*!
 * Platform.js v1.3.6
 * Copyright 2014-2020 Benjamin Tan
 * Copyright 2011-2013 John-David Dalton
 * Available under MIT license
 */
platform$1.exports;
(function(o, t) {
  (function() {
    var e = {
      function: !0,
      object: !0
    }, r = e[typeof window] && window || this, D = t, N = o && !o.nodeType && o, k = D && N && typeof commonjsGlobal == "object" && commonjsGlobal;
    k && (k.global === k || k.window === k || k.self === k) && (r = k);
    var $ = Math.pow(2, 53) - 1, G = /\bOpera/, U = Object.prototype, z = U.hasOwnProperty, X = U.toString;
    function V(st) {
      return st = String(st), st.charAt(0).toUpperCase() + st.slice(1);
    }
    function Y(st, at, ut) {
      var ht = {
        "10.0": "10",
        "6.4": "10 Technical Preview",
        "6.3": "8.1",
        "6.2": "8",
        "6.1": "Server 2008 R2 / 7",
        "6.0": "Server 2008 / Vista",
        "5.2": "Server 2003 / XP 64-bit",
        "5.1": "XP",
        "5.01": "2000 SP1",
        "5.0": "2000",
        "4.0": "NT",
        "4.90": "ME"
      };
      return at && ut && /^Win/i.test(st) && !/^Windows Phone /i.test(st) && (ht = ht[/[\d.]+$/.exec(st)]) && (st = "Windows " + ht), st = String(st), at && ut && (st = st.replace(RegExp(at, "i"), ut)), st = q(
        st.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]
      ), st;
    }
    function W(st, at) {
      var ut = -1, ht = st ? st.length : 0;
      if (typeof ht == "number" && ht > -1 && ht <= $)
        for (; ++ut < ht; )
          at(st[ut], ut, st);
      else
        K(st, at);
    }
    function q(st) {
      return st = it(st), /^(?:webOS|i(?:OS|P))/.test(st) ? st : V(st);
    }
    function K(st, at) {
      for (var ut in st)
        z.call(st, ut) && at(st[ut], ut, st);
    }
    function Z(st) {
      return st == null ? V(st) : X.call(st).slice(8, -1);
    }
    function J(st, at) {
      var ut = st != null ? typeof st[at] : "number";
      return !/^(?:boolean|number|string|undefined)$/.test(ut) && (ut == "object" ? !!st[at] : !0);
    }
    function Q(st) {
      return String(st).replace(/([ -])(?!$)/g, "$1?");
    }
    function et(st, at) {
      var ut = null;
      return W(st, function(ht, dt) {
        ut = at(ut, ht, dt, st);
      }), ut;
    }
    function it(st) {
      return String(st).replace(/^ +| +$/g, "");
    }
    function tt(st) {
      var at = r, ut = st && typeof st == "object" && Z(st) != "String";
      ut && (at = st, st = null);
      var ht = at.navigator || {}, dt = ht.userAgent || "";
      st || (st = dt);
      var pt = ut ? !!ht.likeChrome : /\bChrome\b/.test(st) && !/internal|\n/i.test(X.toString()), _t = "Object", mt = ut ? _t : "ScriptBridgingProxyObject", yt = ut ? _t : "Environment", Tt = ut && at.java ? "JavaPackage" : Z(at.java), Pt = ut ? _t : "RuntimeObject", St = /\bJava/.test(Tt) && at.java, gt = St && Z(at.environment) == yt, bt = St ? "a" : "α", At = St ? "b" : "β", Rt = at.document || {}, Nt = at.operamini || at.opera, Mt = G.test(Mt = ut && Nt ? Nt["[[Class]]"] : Z(Nt)) ? Mt : Nt = null, ft, Ft = st, Dt = [], Vt = null, Bt = st == dt, Et = Bt && Nt && typeof Nt.version == "function" && Nt.version(), Ht, kt = Wt([
        { label: "EdgeHTML", pattern: "Edge" },
        "Trident",
        { label: "WebKit", pattern: "AppleWebKit" },
        "iCab",
        "Presto",
        "NetFront",
        "Tasman",
        "KHTML",
        "Gecko"
      ]), wt = Kt([
        "Adobe AIR",
        "Arora",
        "Avant Browser",
        "Breach",
        "Camino",
        "Electron",
        "Epiphany",
        "Fennec",
        "Flock",
        "Galeon",
        "GreenBrowser",
        "iCab",
        "Iceweasel",
        "K-Meleon",
        "Konqueror",
        "Lunascape",
        "Maxthon",
        { label: "Microsoft Edge", pattern: "(?:Edge|Edg|EdgA|EdgiOS)" },
        "Midori",
        "Nook Browser",
        "PaleMoon",
        "PhantomJS",
        "Raven",
        "Rekonq",
        "RockMelt",
        { label: "Samsung Internet", pattern: "SamsungBrowser" },
        "SeaMonkey",
        { label: "Silk", pattern: "(?:Cloud9|Silk-Accelerated)" },
        "Sleipnir",
        "SlimBrowser",
        { label: "SRWare Iron", pattern: "Iron" },
        "Sunrise",
        "Swiftfox",
        "Vivaldi",
        "Waterfox",
        "WebPositive",
        { label: "Yandex Browser", pattern: "YaBrowser" },
        { label: "UC Browser", pattern: "UCBrowser" },
        "Opera Mini",
        { label: "Opera Mini", pattern: "OPiOS" },
        "Opera",
        { label: "Opera", pattern: "OPR" },
        "Chromium",
        "Chrome",
        { label: "Chrome", pattern: "(?:HeadlessChrome)" },
        { label: "Chrome Mobile", pattern: "(?:CriOS|CrMo)" },
        { label: "Firefox", pattern: "(?:Firefox|Minefield)" },
        { label: "Firefox for iOS", pattern: "FxiOS" },
        { label: "IE", pattern: "IEMobile" },
        { label: "IE", pattern: "MSIE" },
        "Safari"
      ]), Lt = Oe([
        { label: "BlackBerry", pattern: "BB10" },
        "BlackBerry",
        { label: "Galaxy S", pattern: "GT-I9000" },
        { label: "Galaxy S2", pattern: "GT-I9100" },
        { label: "Galaxy S3", pattern: "GT-I9300" },
        { label: "Galaxy S4", pattern: "GT-I9500" },
        { label: "Galaxy S5", pattern: "SM-G900" },
        { label: "Galaxy S6", pattern: "SM-G920" },
        { label: "Galaxy S6 Edge", pattern: "SM-G925" },
        { label: "Galaxy S7", pattern: "SM-G930" },
        { label: "Galaxy S7 Edge", pattern: "SM-G935" },
        "Google TV",
        "Lumia",
        "iPad",
        "iPod",
        "iPhone",
        "Kindle",
        { label: "Kindle Fire", pattern: "(?:Cloud9|Silk-Accelerated)" },
        "Nexus",
        "Nook",
        "PlayBook",
        "PlayStation Vita",
        "PlayStation",
        "TouchPad",
        "Transformer",
        { label: "Wii U", pattern: "WiiU" },
        "Wii",
        "Xbox One",
        { label: "Xbox 360", pattern: "Xbox" },
        "Xoom"
      ]), jt = Jt({
        Apple: { iPad: 1, iPhone: 1, iPod: 1 },
        Alcatel: {},
        Archos: {},
        Amazon: { Kindle: 1, "Kindle Fire": 1 },
        Asus: { Transformer: 1 },
        "Barnes & Noble": { Nook: 1 },
        BlackBerry: { PlayBook: 1 },
        Google: { "Google TV": 1, Nexus: 1 },
        HP: { TouchPad: 1 },
        HTC: {},
        Huawei: {},
        Lenovo: {},
        LG: {},
        Microsoft: { Xbox: 1, "Xbox One": 1 },
        Motorola: { Xoom: 1 },
        Nintendo: { "Wii U": 1, Wii: 1 },
        Nokia: { Lumia: 1 },
        Oppo: {},
        Samsung: { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 },
        Sony: { PlayStation: 1, "PlayStation Vita": 1 },
        Xiaomi: { Mi: 1, Redmi: 1 }
      }), Ct = Se([
        "Windows Phone",
        "KaiOS",
        "Android",
        "CentOS",
        { label: "Chrome OS", pattern: "CrOS" },
        "Debian",
        { label: "DragonFly BSD", pattern: "DragonFly" },
        "Fedora",
        "FreeBSD",
        "Gentoo",
        "Haiku",
        "Kubuntu",
        "Linux Mint",
        "OpenBSD",
        "Red Hat",
        "SuSE",
        "Ubuntu",
        "Xubuntu",
        "Cygwin",
        "Symbian OS",
        "hpwOS",
        "webOS ",
        "webOS",
        "Tablet OS",
        "Tizen",
        "Linux",
        "Mac OS X",
        "Macintosh",
        "Mac",
        "Windows 98;",
        "Windows "
      ]);
      function Wt(de) {
        return et(de, function(fe, ne) {
          return fe || RegExp("\\b" + (ne.pattern || Q(ne)) + "\\b", "i").exec(st) && (ne.label || ne);
        });
      }
      function Jt(de) {
        return et(de, function(fe, ne, Ve) {
          return fe || (ne[Lt] || ne[/^[a-z]+(?: +[a-z]+\b)*/i.exec(Lt)] || RegExp("\\b" + Q(Ve) + "(?:\\b|\\w*\\d)", "i").exec(st)) && Ve;
        });
      }
      function Kt(de) {
        return et(de, function(fe, ne) {
          return fe || RegExp("\\b" + (ne.pattern || Q(ne)) + "\\b", "i").exec(st) && (ne.label || ne);
        });
      }
      function Se(de) {
        return et(de, function(fe, ne) {
          var Ve = ne.pattern || Q(ne);
          return !fe && (fe = RegExp("\\b" + Ve + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(st)) && (fe = Y(fe, Ve, ne.label || ne)), fe;
        });
      }
      function Oe(de) {
        return et(de, function(fe, ne) {
          var Ve = ne.pattern || Q(ne);
          return !fe && (fe = RegExp("\\b" + Ve + " *\\d+[.\\w_]*", "i").exec(st) || RegExp("\\b" + Ve + " *\\w+-[\\w]*", "i").exec(st) || RegExp("\\b" + Ve + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(st)) && ((fe = String(ne.label && !RegExp(Ve, "i").test(ne.label) ? ne.label : fe).split("/"))[1] && !/[\d.]+/.test(fe[0]) && (fe[0] += " " + fe[1]), ne = ne.label || ne, fe = q(fe[0].replace(RegExp(Ve, "i"), ne).replace(RegExp("; *(?:" + ne + "[_-])?", "i"), " ").replace(RegExp("(" + ne + ")[-_.]?(\\w)", "i"), "$1 $2"))), fe;
        });
      }
      function he(de) {
        return et(de, function(fe, ne) {
          return fe || (RegExp(ne + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(st) || 0)[1] || null;
        });
      }
      function _e() {
        return this.description || "";
      }
      if (kt && (kt = [kt]), /\bAndroid\b/.test(Ct) && !Lt && (ft = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(st)) && (Lt = it(ft[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null), jt && !Lt ? Lt = Oe([jt]) : jt && Lt && (Lt = Lt.replace(RegExp("^(" + Q(jt) + ")[-_.\\s]", "i"), jt + " ").replace(RegExp("^(" + Q(jt) + ")[-_.]?(\\w)", "i"), jt + " $2")), (ft = /\bGoogle TV\b/.exec(Lt)) && (Lt = ft[0]), /\bSimulator\b/i.test(st) && (Lt = (Lt ? Lt + " " : "") + "Simulator"), wt == "Opera Mini" && /\bOPiOS\b/.test(st) && Dt.push("running in Turbo/Uncompressed mode"), wt == "IE" && /\blike iPhone OS\b/.test(st) ? (ft = tt(st.replace(/like iPhone OS/, "")), jt = ft.manufacturer, Lt = ft.product) : /^iP/.test(Lt) ? (wt || (wt = "Safari"), Ct = "iOS" + ((ft = / OS ([\d_]+)/i.exec(st)) ? " " + ft[1].replace(/_/g, ".") : "")) : wt == "Konqueror" && /^Linux\b/i.test(Ct) ? Ct = "Kubuntu" : jt && jt != "Google" && (/Chrome/.test(wt) && !/\bMobile Safari\b/i.test(st) || /\bVita\b/.test(Lt)) || /\bAndroid\b/.test(Ct) && /^Chrome/.test(wt) && /\bVersion\//i.test(st) ? (wt = "Android Browser", Ct = /\bAndroid\b/.test(Ct) ? Ct : "Android") : wt == "Silk" ? (/\bMobi/i.test(st) || (Ct = "Android", Dt.unshift("desktop mode")), /Accelerated *= *true/i.test(st) && Dt.unshift("accelerated")) : wt == "UC Browser" && /\bUCWEB\b/.test(st) ? Dt.push("speed mode") : wt == "PaleMoon" && (ft = /\bFirefox\/([\d.]+)\b/.exec(st)) ? Dt.push("identifying as Firefox " + ft[1]) : wt == "Firefox" && (ft = /\b(Mobile|Tablet|TV)\b/i.exec(st)) ? (Ct || (Ct = "Firefox OS"), Lt || (Lt = ft[1])) : !wt || (ft = !/\bMinefield\b/i.test(st) && /\b(?:Firefox|Safari)\b/.exec(wt)) ? (wt && !Lt && /[\/,]|^[^(]+?\)/.test(st.slice(st.indexOf(ft + "/") + 8)) && (wt = null), (ft = Lt || jt || Ct) && (Lt || jt || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(Ct)) && (wt = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(Ct) ? Ct : ft) + " Browser")) : wt == "Electron" && (ft = (/\bChrome\/([\d.]+)\b/.exec(st) || 0)[1]) && Dt.push("Chromium " + ft), Et || (Et = he([
        "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
        "Version",
        Q(wt),
        "(?:Firefox|Minefield|NetFront)"
      ])), (ft = kt == "iCab" && parseFloat(Et) > 3 && "WebKit" || /\bOpera\b/.test(wt) && (/\bOPR\b/.test(st) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(st) && !/^(?:Trident|EdgeHTML)$/.test(kt) && "WebKit" || !kt && /\bMSIE\b/i.test(st) && (Ct == "Mac OS" ? "Tasman" : "Trident") || kt == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(wt) && "NetFront") && (kt = [ft]), wt == "IE" && (ft = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(st) || 0)[1]) ? (wt += " Mobile", Ct = "Windows Phone " + (/\+$/.test(ft) ? ft : ft + ".x"), Dt.unshift("desktop mode")) : /\bWPDesktop\b/i.test(st) ? (wt = "IE Mobile", Ct = "Windows Phone 8.x", Dt.unshift("desktop mode"), Et || (Et = (/\brv:([\d.]+)/.exec(st) || 0)[1])) : wt != "IE" && kt == "Trident" && (ft = /\brv:([\d.]+)/.exec(st)) && (wt && Dt.push("identifying as " + wt + (Et ? " " + Et : "")), wt = "IE", Et = ft[1]), Bt) {
        if (J(at, "global"))
          if (St && (ft = St.lang.System, Ft = ft.getProperty("os.arch"), Ct = Ct || ft.getProperty("os.name") + " " + ft.getProperty("os.version")), gt) {
            try {
              Et = at.require("ringo/engine").version.join("."), wt = "RingoJS";
            } catch {
              (ft = at.system) && ft.global.system == at.system && (wt = "Narwhal", Ct || (Ct = ft[0].os || null));
            }
            wt || (wt = "Rhino");
          } else
            typeof at.process == "object" && !at.process.browser && (ft = at.process) && (typeof ft.versions == "object" && (typeof ft.versions.electron == "string" ? (Dt.push("Node " + ft.versions.node), wt = "Electron", Et = ft.versions.electron) : typeof ft.versions.nw == "string" && (Dt.push("Chromium " + Et, "Node " + ft.versions.node), wt = "NW.js", Et = ft.versions.nw)), wt || (wt = "Node.js", Ft = ft.arch, Ct = ft.platform, Et = /[\d.]+/.exec(ft.version), Et = Et ? Et[0] : null));
        else
          Z(ft = at.runtime) == mt ? (wt = "Adobe AIR", Ct = ft.flash.system.Capabilities.os) : Z(ft = at.phantom) == Pt ? (wt = "PhantomJS", Et = (ft = ft.version || null) && ft.major + "." + ft.minor + "." + ft.patch) : typeof Rt.documentMode == "number" && (ft = /\bTrident\/(\d+)/i.exec(st)) ? (Et = [Et, Rt.documentMode], (ft = +ft[1] + 4) != Et[1] && (Dt.push("IE " + Et[1] + " mode"), kt && (kt[1] = ""), Et[1] = ft), Et = wt == "IE" ? String(Et[1].toFixed(1)) : Et[0]) : typeof Rt.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(wt) && (Dt.push("masking as " + wt + " " + Et), wt = "IE", Et = "11.0", kt = ["Trident"], Ct = "Windows");
        Ct = Ct && q(Ct);
      }
      if (Et && (ft = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(Et) || /(?:alpha|beta)(?: ?\d)?/i.exec(st + ";" + (Bt && ht.appMinorVersion)) || /\bMinefield\b/i.test(st) && "a") && (Vt = /b/i.test(ft) ? "beta" : "alpha", Et = Et.replace(RegExp(ft + "\\+?$"), "") + (Vt == "beta" ? At : bt) + (/\d+\+?/.exec(ft) || "")), wt == "Fennec" || wt == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(Ct))
        wt = "Firefox Mobile";
      else if (wt == "Maxthon" && Et)
        Et = Et.replace(/\.[\d.]+/, ".x");
      else if (/\bXbox\b/i.test(Lt))
        Lt == "Xbox 360" && (Ct = null), Lt == "Xbox 360" && /\bIEMobile\b/.test(st) && Dt.unshift("mobile mode");
      else if ((/^(?:Chrome|IE|Opera)$/.test(wt) || wt && !Lt && !/Browser|Mobi/.test(wt)) && (Ct == "Windows CE" || /Mobi/i.test(st)))
        wt += " Mobile";
      else if (wt == "IE" && Bt)
        try {
          at.external === null && Dt.unshift("platform preview");
        } catch {
          Dt.unshift("embedded");
        }
      else
        (/\bBlackBerry\b/.test(Lt) || /\bBB10\b/.test(st)) && (ft = (RegExp(Lt.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(st) || 0)[1] || Et) ? (ft = [ft, /BB10/.test(st)], Ct = (ft[1] ? (Lt = null, jt = "BlackBerry") : "Device Software") + " " + ft[0], Et = null) : this != K && Lt != "Wii" && (Bt && Nt || /Opera/.test(wt) && /\b(?:MSIE|Firefox)\b/i.test(st) || wt == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(Ct) || wt == "IE" && (Ct && !/^Win/.test(Ct) && Et > 5.5 || /\bWindows XP\b/.test(Ct) && Et > 8 || Et == 8 && !/\bTrident\b/.test(st))) && !G.test(ft = tt.call(K, st.replace(G, "") + ";")) && ft.name && (ft = "ing as " + ft.name + ((ft = ft.version) ? " " + ft : ""), G.test(wt) ? (/\bIE\b/.test(ft) && Ct == "Mac OS" && (Ct = null), ft = "identify" + ft) : (ft = "mask" + ft, Mt ? wt = q(Mt.replace(/([a-z])([A-Z])/g, "$1 $2")) : wt = "Opera", /\bIE\b/.test(ft) && (Ct = null), Bt || (Et = null)), kt = ["Presto"], Dt.push(ft));
      (ft = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(st) || 0)[1]) && (ft = [parseFloat(ft.replace(/\.(\d)$/, ".0$1")), ft], wt == "Safari" && ft[1].slice(-1) == "+" ? (wt = "WebKit Nightly", Vt = "alpha", Et = ft[1].slice(0, -1)) : (Et == ft[1] || Et == (ft[2] = (/\bSafari\/([\d.]+\+?)/i.exec(st) || 0)[1])) && (Et = null), ft[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(st) || 0)[1], ft[0] == 537.36 && ft[2] == 537.36 && parseFloat(ft[1]) >= 28 && kt == "WebKit" && (kt = ["Blink"]), !Bt || !pt && !ft[1] ? (kt && (kt[1] = "like Safari"), ft = (ft = ft[0], ft < 400 ? 1 : ft < 500 ? 2 : ft < 526 ? 3 : ft < 533 ? 4 : ft < 534 ? "4+" : ft < 535 ? 5 : ft < 537 ? 6 : ft < 538 ? 7 : ft < 601 ? 8 : ft < 602 ? 9 : ft < 604 ? 10 : ft < 606 ? 11 : ft < 608 ? 12 : "12")) : (kt && (kt[1] = "like Chrome"), ft = ft[1] || (ft = ft[0], ft < 530 ? 1 : ft < 532 ? 2 : ft < 532.05 ? 3 : ft < 533 ? 4 : ft < 534.03 ? 5 : ft < 534.07 ? 6 : ft < 534.1 ? 7 : ft < 534.13 ? 8 : ft < 534.16 ? 9 : ft < 534.24 ? 10 : ft < 534.3 ? 11 : ft < 535.01 ? 12 : ft < 535.02 ? "13+" : ft < 535.07 ? 15 : ft < 535.11 ? 16 : ft < 535.19 ? 17 : ft < 536.05 ? 18 : ft < 536.1 ? 19 : ft < 537.01 ? 20 : ft < 537.11 ? "21+" : ft < 537.13 ? 23 : ft < 537.18 ? 24 : ft < 537.24 ? 25 : ft < 537.36 ? 26 : kt != "Blink" ? "27" : "28")), kt && (kt[1] += " " + (ft += typeof ft == "number" ? ".x" : /[.+]/.test(ft) ? "" : "+")), wt == "Safari" && (!Et || parseInt(Et) > 45) ? Et = ft : wt == "Chrome" && /\bHeadlessChrome/i.test(st) && Dt.unshift("headless")), wt == "Opera" && (ft = /\bzbov|zvav$/.exec(Ct)) ? (wt += " ", Dt.unshift("desktop mode"), ft == "zvav" ? (wt += "Mini", Et = null) : wt += "Mobile", Ct = Ct.replace(RegExp(" *" + ft + "$"), "")) : wt == "Safari" && /\bChrome\b/.exec(kt && kt[1]) ? (Dt.unshift("desktop mode"), wt = "Chrome Mobile", Et = null, /\bOS X\b/.test(Ct) ? (jt = "Apple", Ct = "iOS 4.3+") : Ct = null) : /\bSRWare Iron\b/.test(wt) && !Et && (Et = he("Chrome")), Et && Et.indexOf(ft = /[\d.]+$/.exec(Ct)) == 0 && st.indexOf("/" + ft + "-") > -1 && (Ct = it(Ct.replace(ft, ""))), Ct && Ct.indexOf(wt) != -1 && !RegExp(wt + " OS").test(Ct) && (Ct = Ct.replace(RegExp(" *" + Q(wt) + " *"), "")), kt && !/\b(?:Avant|Nook)\b/.test(wt) && (/Browser|Lunascape|Maxthon/.test(wt) || wt != "Safari" && /^iOS/.test(Ct) && /\bSafari\b/.test(kt[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(wt) && kt[1]) && (ft = kt[kt.length - 1]) && Dt.push(ft), Dt.length && (Dt = ["(" + Dt.join("; ") + ")"]), jt && Lt && Lt.indexOf(jt) < 0 && Dt.push("on " + jt), Lt && Dt.push((/^on /.test(Dt[Dt.length - 1]) ? "" : "on ") + Lt), Ct && (ft = / ([\d.+]+)$/.exec(Ct), Ht = ft && Ct.charAt(Ct.length - ft[0].length - 1) == "/", Ct = {
        architecture: 32,
        family: ft && !Ht ? Ct.replace(ft[0], "") : Ct,
        version: ft ? ft[1] : null,
        toString: function() {
          var de = this.version;
          return this.family + (de && !Ht ? " " + de : "") + (this.architecture == 64 ? " 64-bit" : "");
        }
      }), (ft = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(Ft)) && !/\bi686\b/i.test(Ft) ? (Ct && (Ct.architecture = 64, Ct.family = Ct.family.replace(RegExp(" *" + ft), "")), wt && (/\bWOW64\b/i.test(st) || Bt && /\w(?:86|32)$/.test(ht.cpuClass || ht.platform) && !/\bWin64; x64\b/i.test(st)) && Dt.unshift("32-bit")) : Ct && /^OS X/.test(Ct.family) && wt == "Chrome" && parseFloat(Et) >= 39 && (Ct.architecture = 64), st || (st = null);
      var ve = {};
      return ve.description = st, ve.layout = kt && kt[0], ve.manufacturer = jt, ve.name = wt, ve.prerelease = Vt, ve.product = Lt, ve.ua = st, ve.version = wt && Et, ve.os = Ct || {
        /**
         * The CPU architecture the OS is built for.
         *
         * @memberOf platform.os
         * @type number|null
         */
        architecture: null,
        /**
         * The family of the OS.
         *
         * Common values include:
         * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
         * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
         * "SuSE", "Android", "iOS" and "Windows Phone"
         *
         * @memberOf platform.os
         * @type string|null
         */
        family: null,
        /**
         * The version of the OS.
         *
         * @memberOf platform.os
         * @type string|null
         */
        version: null,
        /**
         * Returns the OS string.
         *
         * @memberOf platform.os
         * @returns {string} The OS string.
         */
        toString: function() {
          return "null";
        }
      }, ve.parse = tt, ve.toString = _e, ve.version && Dt.unshift(Et), ve.name && Dt.unshift(wt), Ct && wt && !(Ct == String(Ct).split(" ")[0] && (Ct == wt.split(" ")[0] || Lt)) && Dt.push(Lt ? "(" + Ct + ")" : "on " + Ct), Dt.length && (ve.description = Dt.join(" ")), ve;
    }
    var nt = tt();
    D && N ? K(nt, function(st, at) {
      D[at] = st;
    }) : r.platform = nt;
  }).call(commonjsGlobal);
})(platform$1, platform$1.exports);
var platformExports = platform$1.exports;
const platform = /* @__PURE__ */ getDefaultExportFromCjs(platformExports);
function int(o) {
  return parseInt(String(o), 10);
}
function uint(o) {
  const t = parseInt(String(o), 10);
  return t < 0 ? -t : t;
}
"toInt" in String.prototype || (String.prototype.toInt = function() {
  return int(this);
});
"toUint" in String.prototype || (String.prototype.toUint = function() {
  const o = int(this);
  return o < 0 ? -o : o;
});
function getDateStr(o = "/", t = " ", e = ":", r = "") {
  const D = /* @__PURE__ */ new Date();
  return D.getFullYear() + o + String(100 + D.getMonth() + 1).slice(1, 3) + o + String(100 + D.getDate()).slice(1, 3) + t + String(100 + D.getHours()).slice(1, 3) + e + String(100 + D.getMinutes()).slice(1, 3) + (r === "" ? "" : r + String(D.getMilliseconds()));
}
const hMemberCnt = {
  alpha: 0,
  height: 0,
  rotation: 0,
  scale_x: 0,
  scale_y: 0,
  pivot_x: 0,
  pivot_y: 0,
  width: 0,
  x: 0,
  y: 0
};
function cnvTweenArg(o, t) {
  const e = {};
  for (const r of Object.keys(hMemberCnt)) {
    if (!(r in o))
      continue;
    const D = String(o[r]), N = (D.at(0) === "=" ? D.slice(1) : D).split(","), k = e[r] = parseFloat(N[0]);
    N.length > 1 && (e[r] += Math.round(Math.random() * (parseFloat(N[1]) - k + 1))), D.at(0) === "=" && (e[r] += parseFloat(t[r]));
  }
  return e;
}
const css_key4del = "/* SKYNovel */";
function initStyle() {
  const o = document.getElementsByTagName("head")[0], t = o.children.length;
  for (let e = t - 1; e >= 0; --e) {
    const r = o.children[e];
    r instanceof HTMLStyleElement && r.innerText.slice(0, 14) === css_key4del && o.removeChild(r);
  }
}
function addStyle(o) {
  const t = document.createElement("style");
  t.innerHTML = css_key4del + o, document.getElementsByTagName("head")[0].appendChild(t);
}
function argChk_Num(o, t, e) {
  const r = o[t];
  if (!(t in o)) {
    if (isNaN(e))
      throw `[${o[":タグ名"]}]属性 ${t} は必須です`;
    return o[t] = e, e;
  }
  const D = String(r).slice(0, 2) === "0x" ? parseInt(r) : parseFloat(r);
  if (isNaN(D))
    throw `[${o[":タグ名"]}]属性 ${t} の値【${r}】が数値ではありません`;
  return o[t] = D;
}
function argChk_Boolean(o, t, e) {
  if (!(t in o))
    return o[t] = e;
  const r = o[t];
  if (r === null)
    return !1;
  const D = String(r);
  return o[t] = D === "false" ? !1 : !!D;
}
function parseColor(o) {
  if (o.at(0) === "#")
    return parseInt(o.slice(1), 16);
  const t = Number(o);
  if (!isNaN(t))
    return t;
  if (o === "black")
    return 0;
  CmnLib.cc4ColorName.fillStyle = o;
  const e = CmnLib.cc4ColorName.fillStyle;
  if (e === "#000000")
    throw `色名前 ${o} が異常です`;
  return parseInt(e.slice(1), 16);
}
function argChk_Color(o, t, e) {
  const r = o[t];
  return r ? o[t] = parseColor(String(r)) : o[t] = e;
}
const REG_ERRMES_JSON = /JSON at position (\d+)$/;
function mesErrJSON(o, t = "", e = "") {
  const r = (e.match(REG_ERRMES_JSON) ?? ["", ""])[1];
  return `[${o[":タグ名"]}] ${t} 属性の解析エラー : ${e}
${o[t]}${r ? `
${"^".padStart(Number(r))}` : ""}`;
}
const REG_FN = /^[^\/\.]+$|[^\/]+(?=\.)/;
function getFn(o) {
  return (o.match(REG_FN) ?? [""])[0];
}
const REG_EXT = /\.([^\.]+)$/;
function getExt(o) {
  return (o.match(REG_EXT) ?? ["", ""])[1];
}
var Ff, $f;
class CmnLib {
}
It(CmnLib, "stageW", 0), It(CmnLib, "stageH", 0), It(CmnLib, "debugLog", !1), It(CmnLib, "isSafari", platformExports.name === "Safari"), It(CmnLib, "isFirefox", platformExports.name === "Firefox"), It(CmnLib, "isMac", new RegExp("OS X").test(((Ff = platformExports.os) == null ? void 0 : Ff.family) ?? "")), It(CmnLib, "isMobile", !new RegExp("(Windows|OS X)").test((($f = platformExports.os) == null ? void 0 : $f.family) ?? "")), It(CmnLib, "hDip", {}), It(CmnLib, "isDbg", !1), It(CmnLib, "isPackaged", !1), It(CmnLib, "isDarkMode", !1), It(CmnLib, "cc4ColorName");
function finallyConstructor(o) {
  var t = this.constructor;
  return this.then(
    function(e) {
      return t.resolve(o()).then(function() {
        return e;
      });
    },
    function(e) {
      return t.resolve(o()).then(function() {
        return t.reject(e);
      });
    }
  );
}
function allSettled(o) {
  var t = this;
  return new t(function(e, r) {
    if (!(o && typeof o.length < "u"))
      return r(
        new TypeError(
          typeof o + " " + o + " is not iterable(cannot read property Symbol(Symbol.iterator))"
        )
      );
    var D = Array.prototype.slice.call(o);
    if (D.length === 0)
      return e([]);
    var N = D.length;
    function k(G, U) {
      if (U && (typeof U == "object" || typeof U == "function")) {
        var z = U.then;
        if (typeof z == "function") {
          z.call(
            U,
            function(X) {
              k(G, X);
            },
            function(X) {
              D[G] = { status: "rejected", reason: X }, --N === 0 && e(D);
            }
          );
          return;
        }
      }
      D[G] = { status: "fulfilled", value: U }, --N === 0 && e(D);
    }
    for (var $ = 0; $ < D.length; $++)
      k($, D[$]);
  });
}
function AggregateError(o, t) {
  this.name = "AggregateError", this.errors = o, this.message = t || "";
}
AggregateError.prototype = Error.prototype;
function any(o) {
  var t = this;
  return new t(function(e, r) {
    if (!(o && typeof o.length < "u"))
      return r(new TypeError("Promise.any accepts an array"));
    var D = Array.prototype.slice.call(o);
    if (D.length === 0)
      return r();
    for (var N = [], k = 0; k < D.length; k++)
      try {
        t.resolve(D[k]).then(e).catch(function($) {
          N.push($), N.length === D.length && r(
            new AggregateError(
              N,
              "All promises were rejected"
            )
          );
        });
      } catch ($) {
        r($);
      }
  });
}
var setTimeoutFunc = setTimeout;
function isArray$1(o) {
  return !!(o && typeof o.length < "u");
}
function noop() {
}
function bind$2(o, t) {
  return function() {
    o.apply(t, arguments);
  };
}
function Promise$1(o) {
  if (!(this instanceof Promise$1))
    throw new TypeError("Promises must be constructed via new");
  if (typeof o != "function")
    throw new TypeError("not a function");
  this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], doResolve(o, this);
}
function handle(o, t) {
  for (; o._state === 3; )
    o = o._value;
  if (o._state === 0) {
    o._deferreds.push(t);
    return;
  }
  o._handled = !0, Promise$1._immediateFn(function() {
    var e = o._state === 1 ? t.onFulfilled : t.onRejected;
    if (e === null) {
      (o._state === 1 ? resolve$1 : reject)(t.promise, o._value);
      return;
    }
    var r;
    try {
      r = e(o._value);
    } catch (D) {
      reject(t.promise, D);
      return;
    }
    resolve$1(t.promise, r);
  });
}
function resolve$1(o, t) {
  try {
    if (t === o)
      throw new TypeError("A promise cannot be resolved with itself.");
    if (t && (typeof t == "object" || typeof t == "function")) {
      var e = t.then;
      if (t instanceof Promise$1) {
        o._state = 3, o._value = t, finale(o);
        return;
      } else if (typeof e == "function") {
        doResolve(bind$2(e, t), o);
        return;
      }
    }
    o._state = 1, o._value = t, finale(o);
  } catch (r) {
    reject(o, r);
  }
}
function reject(o, t) {
  o._state = 2, o._value = t, finale(o);
}
function finale(o) {
  o._state === 2 && o._deferreds.length === 0 && Promise$1._immediateFn(function() {
    o._handled || Promise$1._unhandledRejectionFn(o._value);
  });
  for (var t = 0, e = o._deferreds.length; t < e; t++)
    handle(o, o._deferreds[t]);
  o._deferreds = null;
}
function Handler(o, t, e) {
  this.onFulfilled = typeof o == "function" ? o : null, this.onRejected = typeof t == "function" ? t : null, this.promise = e;
}
function doResolve(o, t) {
  var e = !1;
  try {
    o(
      function(r) {
        e || (e = !0, resolve$1(t, r));
      },
      function(r) {
        e || (e = !0, reject(t, r));
      }
    );
  } catch (r) {
    if (e)
      return;
    e = !0, reject(t, r);
  }
}
Promise$1.prototype.catch = function(o) {
  return this.then(null, o);
};
Promise$1.prototype.then = function(o, t) {
  var e = new this.constructor(noop);
  return handle(this, new Handler(o, t, e)), e;
};
Promise$1.prototype.finally = finallyConstructor;
Promise$1.all = function(o) {
  return new Promise$1(function(t, e) {
    if (!isArray$1(o))
      return e(new TypeError("Promise.all accepts an array"));
    var r = Array.prototype.slice.call(o);
    if (r.length === 0)
      return t([]);
    var D = r.length;
    function N($, G) {
      try {
        if (G && (typeof G == "object" || typeof G == "function")) {
          var U = G.then;
          if (typeof U == "function") {
            U.call(
              G,
              function(z) {
                N($, z);
              },
              e
            );
            return;
          }
        }
        r[$] = G, --D === 0 && t(r);
      } catch (z) {
        e(z);
      }
    }
    for (var k = 0; k < r.length; k++)
      N(k, r[k]);
  });
};
Promise$1.any = any;
Promise$1.allSettled = allSettled;
Promise$1.resolve = function(o) {
  return o && typeof o == "object" && o.constructor === Promise$1 ? o : new Promise$1(function(t) {
    t(o);
  });
};
Promise$1.reject = function(o) {
  return new Promise$1(function(t, e) {
    e(o);
  });
};
Promise$1.race = function(o) {
  return new Promise$1(function(t, e) {
    if (!isArray$1(o))
      return e(new TypeError("Promise.race accepts an array"));
    for (var r = 0, D = o.length; r < D; r++)
      Promise$1.resolve(o[r]).then(t, e);
  });
};
Promise$1._immediateFn = // @ts-ignore
typeof setImmediate == "function" && function(o) {
  setImmediate(o);
} || function(o) {
  setTimeoutFunc(o, 0);
};
Promise$1._unhandledRejectionFn = function(t) {
  typeof console < "u" && console && console.warn("Possible Unhandled Promise Rejection:", t);
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty$1 = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(o) {
  if (o == null)
    throw new TypeError("Object.assign cannot be called with null or undefined");
  return Object(o);
}
function shouldUseNative() {
  try {
    if (!Object.assign)
      return !1;
    var o = new String("abc");
    if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
      return !1;
    for (var t = {}, e = 0; e < 10; e++)
      t["_" + String.fromCharCode(e)] = e;
    var r = Object.getOwnPropertyNames(t).map(function(N) {
      return t[N];
    });
    if (r.join("") !== "0123456789")
      return !1;
    var D = {};
    return "abcdefghijklmnopqrst".split("").forEach(function(N) {
      D[N] = N;
    }), Object.keys(Object.assign({}, D)).join("") === "abcdefghijklmnopqrst";
  } catch {
    return !1;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(o, t) {
  for (var e, r = toObject(o), D, N = 1; N < arguments.length; N++) {
    e = Object(arguments[N]);
    for (var k in e)
      hasOwnProperty$1.call(e, k) && (r[k] = e[k]);
    if (getOwnPropertySymbols) {
      D = getOwnPropertySymbols(e);
      for (var $ = 0; $ < D.length; $++)
        propIsEnumerable.call(e, D[$]) && (r[D[$]] = e[D[$]]);
    }
  }
  return r;
};
const objectAssign$1 = /* @__PURE__ */ getDefaultExportFromCjs(objectAssign);
/*!
 * @pixi/polyfill - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/polyfill is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
typeof globalThis > "u" && (typeof self < "u" ? self.globalThis = self : typeof global < "u" && (global.globalThis = global));
globalThis.Promise || (globalThis.Promise = Promise$1);
Object.assign || (Object.assign = objectAssign$1);
var ONE_FRAME_TIME = 16;
Date.now && Date.prototype.getTime || (Date.now = function() {
  return (/* @__PURE__ */ new Date()).getTime();
});
if (!(globalThis.performance && globalThis.performance.now)) {
  var startTime_1 = Date.now();
  globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {
    return Date.now() - startTime_1;
  };
}
var lastTime = Date.now(), vendors = ["ms", "moz", "webkit", "o"];
for (var x$1 = 0; x$1 < vendors.length && !globalThis.requestAnimationFrame; ++x$1) {
  var p$1 = vendors[x$1];
  globalThis.requestAnimationFrame = globalThis[p$1 + "RequestAnimationFrame"], globalThis.cancelAnimationFrame = globalThis[p$1 + "CancelAnimationFrame"] || globalThis[p$1 + "CancelRequestAnimationFrame"];
}
globalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(o) {
  if (typeof o != "function")
    throw new TypeError(o + "is not a function");
  var t = Date.now(), e = ONE_FRAME_TIME + lastTime - t;
  return e < 0 && (e = 0), lastTime = t, globalThis.self.setTimeout(function() {
    lastTime = Date.now(), o(performance.now());
  }, e);
});
globalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(o) {
  return clearTimeout(o);
});
Math.sign || (Math.sign = function(t) {
  return t = Number(t), t === 0 || isNaN(t) ? t : t > 0 ? 1 : -1;
});
Number.isInteger || (Number.isInteger = function(t) {
  return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
});
globalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array);
globalThis.Float32Array || (globalThis.Float32Array = Array);
globalThis.Uint32Array || (globalThis.Uint32Array = Array);
globalThis.Uint16Array || (globalThis.Uint16Array = Array);
globalThis.Uint8Array || (globalThis.Uint8Array = Array);
globalThis.Int32Array || (globalThis.Int32Array = Array);
/*!
 * @pixi/constants - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV;
(function(o) {
  o[o.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", o[o.WEBGL = 1] = "WEBGL", o[o.WEBGL2 = 2] = "WEBGL2";
})(ENV || (ENV = {}));
var RENDERER_TYPE;
(function(o) {
  o[o.UNKNOWN = 0] = "UNKNOWN", o[o.WEBGL = 1] = "WEBGL", o[o.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE || (RENDERER_TYPE = {}));
var BUFFER_BITS;
(function(o) {
  o[o.COLOR = 16384] = "COLOR", o[o.DEPTH = 256] = "DEPTH", o[o.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS || (BUFFER_BITS = {}));
var BLEND_MODES;
(function(o) {
  o[o.NORMAL = 0] = "NORMAL", o[o.ADD = 1] = "ADD", o[o.MULTIPLY = 2] = "MULTIPLY", o[o.SCREEN = 3] = "SCREEN", o[o.OVERLAY = 4] = "OVERLAY", o[o.DARKEN = 5] = "DARKEN", o[o.LIGHTEN = 6] = "LIGHTEN", o[o.COLOR_DODGE = 7] = "COLOR_DODGE", o[o.COLOR_BURN = 8] = "COLOR_BURN", o[o.HARD_LIGHT = 9] = "HARD_LIGHT", o[o.SOFT_LIGHT = 10] = "SOFT_LIGHT", o[o.DIFFERENCE = 11] = "DIFFERENCE", o[o.EXCLUSION = 12] = "EXCLUSION", o[o.HUE = 13] = "HUE", o[o.SATURATION = 14] = "SATURATION", o[o.COLOR = 15] = "COLOR", o[o.LUMINOSITY = 16] = "LUMINOSITY", o[o.NORMAL_NPM = 17] = "NORMAL_NPM", o[o.ADD_NPM = 18] = "ADD_NPM", o[o.SCREEN_NPM = 19] = "SCREEN_NPM", o[o.NONE = 20] = "NONE", o[o.SRC_OVER = 0] = "SRC_OVER", o[o.SRC_IN = 21] = "SRC_IN", o[o.SRC_OUT = 22] = "SRC_OUT", o[o.SRC_ATOP = 23] = "SRC_ATOP", o[o.DST_OVER = 24] = "DST_OVER", o[o.DST_IN = 25] = "DST_IN", o[o.DST_OUT = 26] = "DST_OUT", o[o.DST_ATOP = 27] = "DST_ATOP", o[o.ERASE = 26] = "ERASE", o[o.SUBTRACT = 28] = "SUBTRACT", o[o.XOR = 29] = "XOR";
})(BLEND_MODES || (BLEND_MODES = {}));
var DRAW_MODES;
(function(o) {
  o[o.POINTS = 0] = "POINTS", o[o.LINES = 1] = "LINES", o[o.LINE_LOOP = 2] = "LINE_LOOP", o[o.LINE_STRIP = 3] = "LINE_STRIP", o[o.TRIANGLES = 4] = "TRIANGLES", o[o.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", o[o.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES || (DRAW_MODES = {}));
var FORMATS;
(function(o) {
  o[o.RGBA = 6408] = "RGBA", o[o.RGB = 6407] = "RGB", o[o.RG = 33319] = "RG", o[o.RED = 6403] = "RED", o[o.RGBA_INTEGER = 36249] = "RGBA_INTEGER", o[o.RGB_INTEGER = 36248] = "RGB_INTEGER", o[o.RG_INTEGER = 33320] = "RG_INTEGER", o[o.RED_INTEGER = 36244] = "RED_INTEGER", o[o.ALPHA = 6406] = "ALPHA", o[o.LUMINANCE = 6409] = "LUMINANCE", o[o.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", o[o.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", o[o.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS || (FORMATS = {}));
var TARGETS;
(function(o) {
  o[o.TEXTURE_2D = 3553] = "TEXTURE_2D", o[o.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", o[o.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", o[o.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", o[o.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", o[o.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", o[o.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS || (TARGETS = {}));
var TYPES;
(function(o) {
  o[o.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", o[o.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", o[o.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", o[o.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", o[o.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", o[o.UNSIGNED_INT = 5125] = "UNSIGNED_INT", o[o.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", o[o.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", o[o.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", o[o.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", o[o.BYTE = 5120] = "BYTE", o[o.SHORT = 5122] = "SHORT", o[o.INT = 5124] = "INT", o[o.FLOAT = 5126] = "FLOAT", o[o.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", o[o.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES || (TYPES = {}));
var SAMPLER_TYPES;
(function(o) {
  o[o.FLOAT = 0] = "FLOAT", o[o.INT = 1] = "INT", o[o.UINT = 2] = "UINT";
})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));
var SCALE_MODES;
(function(o) {
  o[o.NEAREST = 0] = "NEAREST", o[o.LINEAR = 1] = "LINEAR";
})(SCALE_MODES || (SCALE_MODES = {}));
var WRAP_MODES;
(function(o) {
  o[o.CLAMP = 33071] = "CLAMP", o[o.REPEAT = 10497] = "REPEAT", o[o.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES || (WRAP_MODES = {}));
var MIPMAP_MODES;
(function(o) {
  o[o.OFF = 0] = "OFF", o[o.POW2 = 1] = "POW2", o[o.ON = 2] = "ON", o[o.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES || (MIPMAP_MODES = {}));
var ALPHA_MODES;
(function(o) {
  o[o.NPM = 0] = "NPM", o[o.UNPACK = 1] = "UNPACK", o[o.PMA = 2] = "PMA", o[o.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", o[o.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", o[o.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", o[o.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES || (ALPHA_MODES = {}));
var CLEAR_MODES;
(function(o) {
  o[o.NO = 0] = "NO", o[o.YES = 1] = "YES", o[o.AUTO = 2] = "AUTO", o[o.BLEND = 0] = "BLEND", o[o.CLEAR = 1] = "CLEAR", o[o.BLIT = 2] = "BLIT";
})(CLEAR_MODES || (CLEAR_MODES = {}));
var GC_MODES;
(function(o) {
  o[o.AUTO = 0] = "AUTO", o[o.MANUAL = 1] = "MANUAL";
})(GC_MODES || (GC_MODES = {}));
var PRECISION;
(function(o) {
  o.LOW = "lowp", o.MEDIUM = "mediump", o.HIGH = "highp";
})(PRECISION || (PRECISION = {}));
var MASK_TYPES;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.SCISSOR = 1] = "SCISSOR", o[o.STENCIL = 2] = "STENCIL", o[o.SPRITE = 3] = "SPRITE", o[o.COLOR = 4] = "COLOR";
})(MASK_TYPES || (MASK_TYPES = {}));
var COLOR_MASK_BITS;
(function(o) {
  o[o.RED = 1] = "RED", o[o.GREEN = 2] = "GREEN", o[o.BLUE = 4] = "BLUE", o[o.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS || (COLOR_MASK_BITS = {}));
var MSAA_QUALITY;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.LOW = 2] = "LOW", o[o.MEDIUM = 4] = "MEDIUM", o[o.HIGH = 8] = "HIGH";
})(MSAA_QUALITY || (MSAA_QUALITY = {}));
var BUFFER_TYPE;
(function(o) {
  o[o.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", o[o.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", o[o.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE || (BUFFER_TYPE = {}));
/*!
 * @pixi/settings - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var BrowserAdapter = {
  /**
   * Creates a canvas element of the given size.
   * This canvas is created using the browser's native canvas element.
   * @param width - width of the canvas
   * @param height - height of the canvas
   */
  createCanvas: function(o, t) {
    var e = document.createElement("canvas");
    return e.width = o, e.height = t, e;
  },
  getWebGLRenderingContext: function() {
    return WebGLRenderingContext;
  },
  getNavigator: function() {
    return navigator;
  },
  getBaseUrl: function() {
    var o;
    return (o = document.baseURI) !== null && o !== void 0 ? o : window.location.href;
  },
  fetch: function(o, t) {
    return fetch(o, t);
  }
}, appleIphone = /iPhone/i, appleIpod = /iPod/i, appleTablet = /iPad/i, appleUniversal = /\biOS-universal(?:.+)Mac\b/i, androidPhone = /\bAndroid(?:.+)Mobile\b/i, androidTablet = /Android/i, amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, amazonTablet = /Silk/i, windowsPhone = /Windows Phone/i, windowsTablet = /\bWindows(?:.+)ARM\b/i, otherBlackBerry = /BlackBerry/i, otherBlackBerry10 = /BB10/i, otherOpera = /Opera Mini/i, otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i, otherFirefox = /Mobile(?:.+)Firefox\b/i, isAppleTabletOnIos13 = function(o) {
  return typeof o < "u" && o.platform === "MacIntel" && typeof o.maxTouchPoints == "number" && o.maxTouchPoints > 1 && typeof MSStream > "u";
};
function createMatch(o) {
  return function(t) {
    return t.test(o);
  };
}
function isMobile$1(o) {
  var t = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  !o && typeof navigator < "u" ? t = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    maxTouchPoints: navigator.maxTouchPoints || 0
  } : typeof o == "string" ? t.userAgent = o : o && o.userAgent && (t = {
    userAgent: o.userAgent,
    platform: o.platform,
    maxTouchPoints: o.maxTouchPoints || 0
  });
  var e = t.userAgent, r = e.split("[FBAN");
  typeof r[1] < "u" && (e = r[0]), r = e.split("Twitter"), typeof r[1] < "u" && (e = r[0]);
  var D = createMatch(e), N = {
    apple: {
      phone: D(appleIphone) && !D(windowsPhone),
      ipod: D(appleIpod),
      tablet: !D(appleIphone) && (D(appleTablet) || isAppleTabletOnIos13(t)) && !D(windowsPhone),
      universal: D(appleUniversal),
      device: (D(appleIphone) || D(appleIpod) || D(appleTablet) || D(appleUniversal) || isAppleTabletOnIos13(t)) && !D(windowsPhone)
    },
    amazon: {
      phone: D(amazonPhone),
      tablet: !D(amazonPhone) && D(amazonTablet),
      device: D(amazonPhone) || D(amazonTablet)
    },
    android: {
      phone: !D(windowsPhone) && D(amazonPhone) || !D(windowsPhone) && D(androidPhone),
      tablet: !D(windowsPhone) && !D(amazonPhone) && !D(androidPhone) && (D(amazonTablet) || D(androidTablet)),
      device: !D(windowsPhone) && (D(amazonPhone) || D(amazonTablet) || D(androidPhone) || D(androidTablet)) || D(/\bokhttp\b/i)
    },
    windows: {
      phone: D(windowsPhone),
      tablet: D(windowsTablet),
      device: D(windowsPhone) || D(windowsTablet)
    },
    other: {
      blackberry: D(otherBlackBerry),
      blackberry10: D(otherBlackBerry10),
      opera: D(otherOpera),
      firefox: D(otherFirefox),
      chrome: D(otherChrome),
      device: D(otherBlackBerry) || D(otherBlackBerry10) || D(otherOpera) || D(otherFirefox) || D(otherChrome)
    },
    any: !1,
    phone: !1,
    tablet: !1
  };
  return N.any = N.apple.device || N.android.device || N.windows.device || N.other.device, N.phone = N.apple.phone || N.android.phone || N.windows.phone, N.tablet = N.apple.tablet || N.android.tablet || N.windows.tablet, N;
}
var isMobile = isMobile$1(globalThis.navigator);
function canUploadSameBuffer() {
  return !isMobile.apple.device;
}
function maxRecommendedTextures(o) {
  var t = !0;
  if (isMobile.tablet || isMobile.phone) {
    if (isMobile.apple.device) {
      var e = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (e) {
        var r = parseInt(e[1], 10);
        r < 11 && (t = !1);
      }
    }
    if (isMobile.android.device) {
      var e = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (e) {
        var r = parseInt(e[1], 10);
        r < 7 && (t = !1);
      }
    }
  }
  return t ? o : 4;
}
var settings = {
  /**
   * This adapter is used to call methods that are platform dependent.
   * For example `document.createElement` only runs on the web but fails in node environments.
   * This allows us to support more platforms by abstracting away specific implementations per platform.
   *
   * By default the adapter is set to work in the browser. However you can create your own
   * by implementing the `IAdapter` interface. See `IAdapter` for more information.
   * @name ADAPTER
   * @memberof PIXI.settings
   * @type {PIXI.IAdapter}
   * @default PIXI.BrowserAdapter
   */
  ADAPTER: BrowserAdapter,
  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  MIPMAP_TEXTURES: MIPMAP_MODES.POW2,
  /**
   * Default anisotropic filtering level of textures.
   * Usually from 0 to 16
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @default 0
   */
  ANISOTROPIC_LEVEL: 0,
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Default filter resolution.
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,
  /**
   * Default filter samples.
   * @static
   * @name FILTER_MULTISAMPLE
   * @memberof PIXI.settings
   * @type {PIXI.MSAA_QUALITY}
   * @default PIXI.MSAA_QUALITY.NONE
   */
  FILTER_MULTISAMPLE: MSAA_QUALITY.NONE,
  /**
   * The maximum textures that this device supports.
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @type {number}
   * @default 32
   */
  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,
  /**
   * The default render options if none are supplied to {@link PIXI.Renderer}
   * or {@link PIXI.CanvasRenderer}.
   * @static
   * @name RENDER_OPTIONS
   * @memberof PIXI.settings
   * @type {object}
   * @property {HTMLCanvasElement} [view=null] -
   * @property {boolean} [antialias=false] -
   * @property {boolean} [autoDensity=false] -
   * @property {boolean} [useContextAlpha=true]  -
   * @property {number} [backgroundColor=0x000000] -
   * @property {number} [backgroundAlpha=1] -
   * @property {boolean} [clearBeforeRender=true] -
   * @property {boolean} [preserveDrawingBuffer=false] -
   * @property {number} [width=800] -
   * @property {number} [height=600] -
   * @property {boolean} [legacy=false] -
   */
  RENDER_OPTIONS: {
    view: null,
    antialias: !1,
    autoDensity: !1,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: !0,
    clearBeforeRender: !0,
    preserveDrawingBuffer: !1,
    width: 800,
    height: 600,
    legacy: !1
  },
  /**
   * Default Garbage Collection mode.
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: GC_MODES.AUTO,
  /**
   * Default Garbage Collection max idle.
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,
  /**
   * Default Garbage Collection maximum check count.
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,
  /**
   * Default wrap modes that are supported by pixi.
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: WRAP_MODES.CLAMP,
  /**
   * Default scale mode for textures.
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: SCALE_MODES.LINEAR,
  /**
   * Default specify float precision in vertex shader.
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.HIGH
   */
  PRECISION_VERTEX: PRECISION.HIGH,
  /**
   * Default specify float precision in fragment shader.
   * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM,
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: !1,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: !1
}, eventemitter3 = { exports: {} };
(function(o) {
  var t = Object.prototype.hasOwnProperty, e = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (e = !1));
  function D(G, U, z) {
    this.fn = G, this.context = U, this.once = z || !1;
  }
  function N(G, U, z, X, V) {
    if (typeof z != "function")
      throw new TypeError("The listener must be a function");
    var Y = new D(z, X || G, V), W = e ? e + U : U;
    return G._events[W] ? G._events[W].fn ? G._events[W] = [G._events[W], Y] : G._events[W].push(Y) : (G._events[W] = Y, G._eventsCount++), G;
  }
  function k(G, U) {
    --G._eventsCount === 0 ? G._events = new r() : delete G._events[U];
  }
  function $() {
    this._events = new r(), this._eventsCount = 0;
  }
  $.prototype.eventNames = function() {
    var U = [], z, X;
    if (this._eventsCount === 0)
      return U;
    for (X in z = this._events)
      t.call(z, X) && U.push(e ? X.slice(1) : X);
    return Object.getOwnPropertySymbols ? U.concat(Object.getOwnPropertySymbols(z)) : U;
  }, $.prototype.listeners = function(U) {
    var z = e ? e + U : U, X = this._events[z];
    if (!X)
      return [];
    if (X.fn)
      return [X.fn];
    for (var V = 0, Y = X.length, W = new Array(Y); V < Y; V++)
      W[V] = X[V].fn;
    return W;
  }, $.prototype.listenerCount = function(U) {
    var z = e ? e + U : U, X = this._events[z];
    return X ? X.fn ? 1 : X.length : 0;
  }, $.prototype.emit = function(U, z, X, V, Y, W) {
    var q = e ? e + U : U;
    if (!this._events[q])
      return !1;
    var K = this._events[q], Z = arguments.length, J, Q;
    if (K.fn) {
      switch (K.once && this.removeListener(U, K.fn, void 0, !0), Z) {
        case 1:
          return K.fn.call(K.context), !0;
        case 2:
          return K.fn.call(K.context, z), !0;
        case 3:
          return K.fn.call(K.context, z, X), !0;
        case 4:
          return K.fn.call(K.context, z, X, V), !0;
        case 5:
          return K.fn.call(K.context, z, X, V, Y), !0;
        case 6:
          return K.fn.call(K.context, z, X, V, Y, W), !0;
      }
      for (Q = 1, J = new Array(Z - 1); Q < Z; Q++)
        J[Q - 1] = arguments[Q];
      K.fn.apply(K.context, J);
    } else {
      var et = K.length, it;
      for (Q = 0; Q < et; Q++)
        switch (K[Q].once && this.removeListener(U, K[Q].fn, void 0, !0), Z) {
          case 1:
            K[Q].fn.call(K[Q].context);
            break;
          case 2:
            K[Q].fn.call(K[Q].context, z);
            break;
          case 3:
            K[Q].fn.call(K[Q].context, z, X);
            break;
          case 4:
            K[Q].fn.call(K[Q].context, z, X, V);
            break;
          default:
            if (!J)
              for (it = 1, J = new Array(Z - 1); it < Z; it++)
                J[it - 1] = arguments[it];
            K[Q].fn.apply(K[Q].context, J);
        }
    }
    return !0;
  }, $.prototype.on = function(U, z, X) {
    return N(this, U, z, X, !1);
  }, $.prototype.once = function(U, z, X) {
    return N(this, U, z, X, !0);
  }, $.prototype.removeListener = function(U, z, X, V) {
    var Y = e ? e + U : U;
    if (!this._events[Y])
      return this;
    if (!z)
      return k(this, Y), this;
    var W = this._events[Y];
    if (W.fn)
      W.fn === z && (!V || W.once) && (!X || W.context === X) && k(this, Y);
    else {
      for (var q = 0, K = [], Z = W.length; q < Z; q++)
        (W[q].fn !== z || V && !W[q].once || X && W[q].context !== X) && K.push(W[q]);
      K.length ? this._events[Y] = K.length === 1 ? K[0] : K : k(this, Y);
    }
    return this;
  }, $.prototype.removeAllListeners = function(U) {
    var z;
    return U ? (z = e ? e + U : U, this._events[z] && k(this, z)) : (this._events = new r(), this._eventsCount = 0), this;
  }, $.prototype.off = $.prototype.removeListener, $.prototype.addListener = $.prototype.on, $.prefixed = e, $.EventEmitter = $, o.exports = $;
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const i$1 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
var earcut$2 = { exports: {} };
earcut$2.exports = earcut;
earcut$2.exports.default = earcut;
function earcut(o, t, e) {
  e = e || 2;
  var r = t && t.length, D = r ? t[0] * e : o.length, N = linkedList(o, 0, D, e, !0), k = [];
  if (!N || N.next === N.prev)
    return k;
  var $, G, U, z, X, V, Y;
  if (r && (N = eliminateHoles(o, t, N, e)), o.length > 80 * e) {
    $ = U = o[0], G = z = o[1];
    for (var W = e; W < D; W += e)
      X = o[W], V = o[W + 1], X < $ && ($ = X), V < G && (G = V), X > U && (U = X), V > z && (z = V);
    Y = Math.max(U - $, z - G), Y = Y !== 0 ? 32767 / Y : 0;
  }
  return earcutLinked(N, k, e, $, G, Y, 0), k;
}
function linkedList(o, t, e, r, D) {
  var N, k;
  if (D === signedArea(o, t, e, r) > 0)
    for (N = t; N < e; N += r)
      k = insertNode(N, o[N], o[N + 1], k);
  else
    for (N = e - r; N >= t; N -= r)
      k = insertNode(N, o[N], o[N + 1], k);
  return k && equals$1(k, k.next) && (removeNode$1(k), k = k.next), k;
}
function filterPoints(o, t) {
  if (!o)
    return o;
  t || (t = o);
  var e = o, r;
  do
    if (r = !1, !e.steiner && (equals$1(e, e.next) || area(e.prev, e, e.next) === 0)) {
      if (removeNode$1(e), e = t = e.prev, e === e.next)
        break;
      r = !0;
    } else
      e = e.next;
  while (r || e !== t);
  return t;
}
function earcutLinked(o, t, e, r, D, N, k) {
  if (o) {
    !k && N && indexCurve(o, r, D, N);
    for (var $ = o, G, U; o.prev !== o.next; ) {
      if (G = o.prev, U = o.next, N ? isEarHashed(o, r, D, N) : isEar(o)) {
        t.push(G.i / e | 0), t.push(o.i / e | 0), t.push(U.i / e | 0), removeNode$1(o), o = U.next, $ = U.next;
        continue;
      }
      if (o = U, o === $) {
        k ? k === 1 ? (o = cureLocalIntersections(filterPoints(o), t, e), earcutLinked(o, t, e, r, D, N, 2)) : k === 2 && splitEarcut(o, t, e, r, D, N) : earcutLinked(filterPoints(o), t, e, r, D, N, 1);
        break;
      }
    }
  }
}
function isEar(o) {
  var t = o.prev, e = o, r = o.next;
  if (area(t, e, r) >= 0)
    return !1;
  for (var D = t.x, N = e.x, k = r.x, $ = t.y, G = e.y, U = r.y, z = D < N ? D < k ? D : k : N < k ? N : k, X = $ < G ? $ < U ? $ : U : G < U ? G : U, V = D > N ? D > k ? D : k : N > k ? N : k, Y = $ > G ? $ > U ? $ : U : G > U ? G : U, W = r.next; W !== t; ) {
    if (W.x >= z && W.x <= V && W.y >= X && W.y <= Y && pointInTriangle(D, $, N, G, k, U, W.x, W.y) && area(W.prev, W, W.next) >= 0)
      return !1;
    W = W.next;
  }
  return !0;
}
function isEarHashed(o, t, e, r) {
  var D = o.prev, N = o, k = o.next;
  if (area(D, N, k) >= 0)
    return !1;
  for (var $ = D.x, G = N.x, U = k.x, z = D.y, X = N.y, V = k.y, Y = $ < G ? $ < U ? $ : U : G < U ? G : U, W = z < X ? z < V ? z : V : X < V ? X : V, q = $ > G ? $ > U ? $ : U : G > U ? G : U, K = z > X ? z > V ? z : V : X > V ? X : V, Z = zOrder(Y, W, t, e, r), J = zOrder(q, K, t, e, r), Q = o.prevZ, et = o.nextZ; Q && Q.z >= Z && et && et.z <= J; ) {
    if (Q.x >= Y && Q.x <= q && Q.y >= W && Q.y <= K && Q !== D && Q !== k && pointInTriangle($, z, G, X, U, V, Q.x, Q.y) && area(Q.prev, Q, Q.next) >= 0 || (Q = Q.prevZ, et.x >= Y && et.x <= q && et.y >= W && et.y <= K && et !== D && et !== k && pointInTriangle($, z, G, X, U, V, et.x, et.y) && area(et.prev, et, et.next) >= 0))
      return !1;
    et = et.nextZ;
  }
  for (; Q && Q.z >= Z; ) {
    if (Q.x >= Y && Q.x <= q && Q.y >= W && Q.y <= K && Q !== D && Q !== k && pointInTriangle($, z, G, X, U, V, Q.x, Q.y) && area(Q.prev, Q, Q.next) >= 0)
      return !1;
    Q = Q.prevZ;
  }
  for (; et && et.z <= J; ) {
    if (et.x >= Y && et.x <= q && et.y >= W && et.y <= K && et !== D && et !== k && pointInTriangle($, z, G, X, U, V, et.x, et.y) && area(et.prev, et, et.next) >= 0)
      return !1;
    et = et.nextZ;
  }
  return !0;
}
function cureLocalIntersections(o, t, e) {
  var r = o;
  do {
    var D = r.prev, N = r.next.next;
    !equals$1(D, N) && intersects(D, r, r.next, N) && locallyInside(D, N) && locallyInside(N, D) && (t.push(D.i / e | 0), t.push(r.i / e | 0), t.push(N.i / e | 0), removeNode$1(r), removeNode$1(r.next), r = o = N), r = r.next;
  } while (r !== o);
  return filterPoints(r);
}
function splitEarcut(o, t, e, r, D, N) {
  var k = o;
  do {
    for (var $ = k.next.next; $ !== k.prev; ) {
      if (k.i !== $.i && isValidDiagonal(k, $)) {
        var G = splitPolygon(k, $);
        k = filterPoints(k, k.next), G = filterPoints(G, G.next), earcutLinked(k, t, e, r, D, N, 0), earcutLinked(G, t, e, r, D, N, 0);
        return;
      }
      $ = $.next;
    }
    k = k.next;
  } while (k !== o);
}
function eliminateHoles(o, t, e, r) {
  var D = [], N, k, $, G, U;
  for (N = 0, k = t.length; N < k; N++)
    $ = t[N] * r, G = N < k - 1 ? t[N + 1] * r : o.length, U = linkedList(o, $, G, r, !1), U === U.next && (U.steiner = !0), D.push(getLeftmost(U));
  for (D.sort(compareX), N = 0; N < D.length; N++)
    e = eliminateHole(D[N], e);
  return e;
}
function compareX(o, t) {
  return o.x - t.x;
}
function eliminateHole(o, t) {
  var e = findHoleBridge(o, t);
  if (!e)
    return t;
  var r = splitPolygon(e, o);
  return filterPoints(r, r.next), filterPoints(e, e.next);
}
function findHoleBridge(o, t) {
  var e = t, r = o.x, D = o.y, N = -1 / 0, k;
  do {
    if (D <= e.y && D >= e.next.y && e.next.y !== e.y) {
      var $ = e.x + (D - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if ($ <= r && $ > N && (N = $, k = e.x < e.next.x ? e : e.next, $ === r))
        return k;
    }
    e = e.next;
  } while (e !== t);
  if (!k)
    return null;
  var G = k, U = k.x, z = k.y, X = 1 / 0, V;
  e = k;
  do
    r >= e.x && e.x >= U && r !== e.x && pointInTriangle(D < z ? r : N, D, U, z, D < z ? N : r, D, e.x, e.y) && (V = Math.abs(D - e.y) / (r - e.x), locallyInside(e, o) && (V < X || V === X && (e.x > k.x || e.x === k.x && sectorContainsSector(k, e))) && (k = e, X = V)), e = e.next;
  while (e !== G);
  return k;
}
function sectorContainsSector(o, t) {
  return area(o.prev, o, t.prev) < 0 && area(t.next, o, o.next) < 0;
}
function indexCurve(o, t, e, r) {
  var D = o;
  do
    D.z === 0 && (D.z = zOrder(D.x, D.y, t, e, r)), D.prevZ = D.prev, D.nextZ = D.next, D = D.next;
  while (D !== o);
  D.prevZ.nextZ = null, D.prevZ = null, sortLinked(D);
}
function sortLinked(o) {
  var t, e, r, D, N, k, $, G, U = 1;
  do {
    for (e = o, o = null, N = null, k = 0; e; ) {
      for (k++, r = e, $ = 0, t = 0; t < U && ($++, r = r.nextZ, !!r); t++)
        ;
      for (G = U; $ > 0 || G > 0 && r; )
        $ !== 0 && (G === 0 || !r || e.z <= r.z) ? (D = e, e = e.nextZ, $--) : (D = r, r = r.nextZ, G--), N ? N.nextZ = D : o = D, D.prevZ = N, N = D;
      e = r;
    }
    N.nextZ = null, U *= 2;
  } while (k > 1);
  return o;
}
function zOrder(o, t, e, r, D) {
  return o = (o - e) * D | 0, t = (t - r) * D | 0, o = (o | o << 8) & 16711935, o = (o | o << 4) & 252645135, o = (o | o << 2) & 858993459, o = (o | o << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, o | t << 1;
}
function getLeftmost(o) {
  var t = o, e = o;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== o);
  return e;
}
function pointInTriangle(o, t, e, r, D, N, k, $) {
  return (D - k) * (t - $) >= (o - k) * (N - $) && (o - k) * (r - $) >= (e - k) * (t - $) && (e - k) * (N - $) >= (D - k) * (r - $);
}
function isValidDiagonal(o, t) {
  return o.next.i !== t.i && o.prev.i !== t.i && !intersectsPolygon(o, t) && // dones't intersect other edges
  (locallyInside(o, t) && locallyInside(t, o) && middleInside(o, t) && // locally visible
  (area(o.prev, o, t.prev) || area(o, t.prev, t)) || // does not create opposite-facing sectors
  equals$1(o, t) && area(o.prev, o, o.next) > 0 && area(t.prev, t, t.next) > 0);
}
function area(o, t, e) {
  return (t.y - o.y) * (e.x - t.x) - (t.x - o.x) * (e.y - t.y);
}
function equals$1(o, t) {
  return o.x === t.x && o.y === t.y;
}
function intersects(o, t, e, r) {
  var D = sign$1(area(o, t, e)), N = sign$1(area(o, t, r)), k = sign$1(area(e, r, o)), $ = sign$1(area(e, r, t));
  return !!(D !== N && k !== $ || D === 0 && onSegment(o, e, t) || N === 0 && onSegment(o, r, t) || k === 0 && onSegment(e, o, r) || $ === 0 && onSegment(e, t, r));
}
function onSegment(o, t, e) {
  return t.x <= Math.max(o.x, e.x) && t.x >= Math.min(o.x, e.x) && t.y <= Math.max(o.y, e.y) && t.y >= Math.min(o.y, e.y);
}
function sign$1(o) {
  return o > 0 ? 1 : o < 0 ? -1 : 0;
}
function intersectsPolygon(o, t) {
  var e = o;
  do {
    if (e.i !== o.i && e.next.i !== o.i && e.i !== t.i && e.next.i !== t.i && intersects(e, e.next, o, t))
      return !0;
    e = e.next;
  } while (e !== o);
  return !1;
}
function locallyInside(o, t) {
  return area(o.prev, o, o.next) < 0 ? area(o, t, o.next) >= 0 && area(o, o.prev, t) >= 0 : area(o, t, o.prev) < 0 || area(o, o.next, t) < 0;
}
function middleInside(o, t) {
  var e = o, r = !1, D = (o.x + t.x) / 2, N = (o.y + t.y) / 2;
  do
    e.y > N != e.next.y > N && e.next.y !== e.y && D < (e.next.x - e.x) * (N - e.y) / (e.next.y - e.y) + e.x && (r = !r), e = e.next;
  while (e !== o);
  return r;
}
function splitPolygon(o, t) {
  var e = new Node$1(o.i, o.x, o.y), r = new Node$1(t.i, t.x, t.y), D = o.next, N = t.prev;
  return o.next = t, t.prev = o, e.next = D, D.prev = e, r.next = e, e.prev = r, N.next = r, r.prev = N, r;
}
function insertNode(o, t, e, r) {
  var D = new Node$1(o, t, e);
  return r ? (D.next = r.next, D.prev = r, r.next.prev = D, r.next = D) : (D.prev = D, D.next = D), D;
}
function removeNode$1(o) {
  o.next.prev = o.prev, o.prev.next = o.next, o.prevZ && (o.prevZ.nextZ = o.nextZ), o.nextZ && (o.nextZ.prevZ = o.prevZ);
}
function Node$1(o, t, e) {
  this.i = o, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
earcut.deviation = function(o, t, e, r) {
  var D = t && t.length, N = D ? t[0] * e : o.length, k = Math.abs(signedArea(o, 0, N, e));
  if (D)
    for (var $ = 0, G = t.length; $ < G; $++) {
      var U = t[$] * e, z = $ < G - 1 ? t[$ + 1] * e : o.length;
      k -= Math.abs(signedArea(o, U, z, e));
    }
  var X = 0;
  for ($ = 0; $ < r.length; $ += 3) {
    var V = r[$] * e, Y = r[$ + 1] * e, W = r[$ + 2] * e;
    X += Math.abs(
      (o[V] - o[W]) * (o[Y + 1] - o[V + 1]) - (o[V] - o[Y]) * (o[W + 1] - o[V + 1])
    );
  }
  return k === 0 && X === 0 ? 0 : Math.abs((X - k) / k);
};
function signedArea(o, t, e, r) {
  for (var D = 0, N = t, k = e - r; N < e; N += r)
    D += (o[k] - o[N]) * (o[N + 1] + o[k + 1]), k = N;
  return D;
}
earcut.flatten = function(o) {
  for (var t = o[0][0].length, e = { vertices: [], holes: [], dimensions: t }, r = 0, D = 0; D < o.length; D++) {
    for (var N = 0; N < o[D].length; N++)
      for (var k = 0; k < t; k++)
        e.vertices.push(o[D][N][k]);
    D > 0 && (r += o[D - 1].length, e.holes.push(r));
  }
  return e;
};
var earcutExports = earcut$2.exports;
const earcut$1 = /* @__PURE__ */ getDefaultExportFromCjs(earcutExports);
var punycode$1 = { exports: {} };
/*! https://mths.be/punycode v1.3.2 by @mathias */
punycode$1.exports;
(function(o, t) {
  (function(e) {
    var r = t && !t.nodeType && t, D = o && !o.nodeType && o, N = typeof commonjsGlobal == "object" && commonjsGlobal;
    (N.global === N || N.window === N || N.self === N) && (e = N);
    var k, $ = 2147483647, G = 36, U = 1, z = 26, X = 38, V = 700, Y = 72, W = 128, q = "-", K = /^xn--/, Z = /[^\x20-\x7E]/, J = /[\x2E\u3002\uFF0E\uFF61]/g, Q = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, et = G - U, it = Math.floor, tt = String.fromCharCode, nt;
    function st(gt) {
      throw RangeError(Q[gt]);
    }
    function at(gt, bt) {
      for (var At = gt.length, Rt = []; At--; )
        Rt[At] = bt(gt[At]);
      return Rt;
    }
    function ut(gt, bt) {
      var At = gt.split("@"), Rt = "";
      At.length > 1 && (Rt = At[0] + "@", gt = At[1]), gt = gt.replace(J, ".");
      var Nt = gt.split("."), Mt = at(Nt, bt).join(".");
      return Rt + Mt;
    }
    function ht(gt) {
      for (var bt = [], At = 0, Rt = gt.length, Nt, Mt; At < Rt; )
        Nt = gt.charCodeAt(At++), Nt >= 55296 && Nt <= 56319 && At < Rt ? (Mt = gt.charCodeAt(At++), (Mt & 64512) == 56320 ? bt.push(((Nt & 1023) << 10) + (Mt & 1023) + 65536) : (bt.push(Nt), At--)) : bt.push(Nt);
      return bt;
    }
    function dt(gt) {
      return at(gt, function(bt) {
        var At = "";
        return bt > 65535 && (bt -= 65536, At += tt(bt >>> 10 & 1023 | 55296), bt = 56320 | bt & 1023), At += tt(bt), At;
      }).join("");
    }
    function pt(gt) {
      return gt - 48 < 10 ? gt - 22 : gt - 65 < 26 ? gt - 65 : gt - 97 < 26 ? gt - 97 : G;
    }
    function _t(gt, bt) {
      return gt + 22 + 75 * (gt < 26) - ((bt != 0) << 5);
    }
    function mt(gt, bt, At) {
      var Rt = 0;
      for (gt = At ? it(gt / V) : gt >> 1, gt += it(gt / bt); gt > et * z >> 1; Rt += G)
        gt = it(gt / et);
      return it(Rt + (et + 1) * gt / (gt + X));
    }
    function yt(gt) {
      var bt = [], At = gt.length, Rt, Nt = 0, Mt = W, ft = Y, Ft, Dt, Vt, Bt, Et, Ht, kt, wt, Lt;
      for (Ft = gt.lastIndexOf(q), Ft < 0 && (Ft = 0), Dt = 0; Dt < Ft; ++Dt)
        gt.charCodeAt(Dt) >= 128 && st("not-basic"), bt.push(gt.charCodeAt(Dt));
      for (Vt = Ft > 0 ? Ft + 1 : 0; Vt < At; ) {
        for (Bt = Nt, Et = 1, Ht = G; Vt >= At && st("invalid-input"), kt = pt(gt.charCodeAt(Vt++)), (kt >= G || kt > it(($ - Nt) / Et)) && st("overflow"), Nt += kt * Et, wt = Ht <= ft ? U : Ht >= ft + z ? z : Ht - ft, !(kt < wt); Ht += G)
          Lt = G - wt, Et > it($ / Lt) && st("overflow"), Et *= Lt;
        Rt = bt.length + 1, ft = mt(Nt - Bt, Rt, Bt == 0), it(Nt / Rt) > $ - Mt && st("overflow"), Mt += it(Nt / Rt), Nt %= Rt, bt.splice(Nt++, 0, Mt);
      }
      return dt(bt);
    }
    function Tt(gt) {
      var bt, At, Rt, Nt, Mt, ft, Ft, Dt, Vt, Bt, Et, Ht = [], kt, wt, Lt, jt;
      for (gt = ht(gt), kt = gt.length, bt = W, At = 0, Mt = Y, ft = 0; ft < kt; ++ft)
        Et = gt[ft], Et < 128 && Ht.push(tt(Et));
      for (Rt = Nt = Ht.length, Nt && Ht.push(q); Rt < kt; ) {
        for (Ft = $, ft = 0; ft < kt; ++ft)
          Et = gt[ft], Et >= bt && Et < Ft && (Ft = Et);
        for (wt = Rt + 1, Ft - bt > it(($ - At) / wt) && st("overflow"), At += (Ft - bt) * wt, bt = Ft, ft = 0; ft < kt; ++ft)
          if (Et = gt[ft], Et < bt && ++At > $ && st("overflow"), Et == bt) {
            for (Dt = At, Vt = G; Bt = Vt <= Mt ? U : Vt >= Mt + z ? z : Vt - Mt, !(Dt < Bt); Vt += G)
              jt = Dt - Bt, Lt = G - Bt, Ht.push(
                tt(_t(Bt + jt % Lt, 0))
              ), Dt = it(jt / Lt);
            Ht.push(tt(_t(Dt, 0))), Mt = mt(At, wt, Rt == Nt), At = 0, ++Rt;
          }
        ++At, ++bt;
      }
      return Ht.join("");
    }
    function Pt(gt) {
      return ut(gt, function(bt) {
        return K.test(bt) ? yt(bt.slice(4).toLowerCase()) : bt;
      });
    }
    function St(gt) {
      return ut(gt, function(bt) {
        return Z.test(bt) ? "xn--" + Tt(bt) : bt;
      });
    }
    if (k = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "1.3.2",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: ht,
        encode: dt
      },
      decode: yt,
      encode: Tt,
      toASCII: St,
      toUnicode: Pt
    }, r && D)
      if (o.exports == r)
        D.exports = k;
      else
        for (nt in k)
          k.hasOwnProperty(nt) && (r[nt] = k[nt]);
    else
      e.punycode = k;
  })(commonjsGlobal);
})(punycode$1, punycode$1.exports);
var punycodeExports = punycode$1.exports, util$8 = {
  isString: function(o) {
    return typeof o == "string";
  },
  isObject: function(o) {
    return typeof o == "object" && o !== null;
  },
  isNull: function(o) {
    return o === null;
  },
  isNullOrUndefined: function(o) {
    return o == null;
  }
}, querystring$1 = {};
function hasOwnProperty(o, t) {
  return Object.prototype.hasOwnProperty.call(o, t);
}
var decode$2 = function(o, t, e, r) {
  t = t || "&", e = e || "=";
  var D = {};
  if (typeof o != "string" || o.length === 0)
    return D;
  var N = /\+/g;
  o = o.split(t);
  var k = 1e3;
  r && typeof r.maxKeys == "number" && (k = r.maxKeys);
  var $ = o.length;
  k > 0 && $ > k && ($ = k);
  for (var G = 0; G < $; ++G) {
    var U = o[G].replace(N, "%20"), z = U.indexOf(e), X, V, Y, W;
    z >= 0 ? (X = U.substr(0, z), V = U.substr(z + 1)) : (X = U, V = ""), Y = decodeURIComponent(X), W = decodeURIComponent(V), hasOwnProperty(D, Y) ? Array.isArray(D[Y]) ? D[Y].push(W) : D[Y] = [D[Y], W] : D[Y] = W;
  }
  return D;
}, stringifyPrimitive = function(o) {
  switch (typeof o) {
    case "string":
      return o;
    case "boolean":
      return o ? "true" : "false";
    case "number":
      return isFinite(o) ? o : "";
    default:
      return "";
  }
}, encode$2 = function(o, t, e, r) {
  return t = t || "&", e = e || "=", o === null && (o = void 0), typeof o == "object" ? Object.keys(o).map(function(D) {
    var N = encodeURIComponent(stringifyPrimitive(D)) + e;
    return Array.isArray(o[D]) ? o[D].map(function(k) {
      return N + encodeURIComponent(stringifyPrimitive(k));
    }).join(t) : N + encodeURIComponent(stringifyPrimitive(o[D]));
  }).join(t) : r ? encodeURIComponent(stringifyPrimitive(r)) + e + encodeURIComponent(stringifyPrimitive(o)) : "";
};
querystring$1.decode = querystring$1.parse = decode$2;
querystring$1.encode = querystring$1.stringify = encode$2;
var punycode = punycodeExports, util$7 = util$8, parse$2 = urlParse, resolve = urlResolve, format$1 = urlFormat;
function Url() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", `
`, "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  javascript: !0,
  "javascript:": !0
}, hostlessProtocol = {
  javascript: !0,
  "javascript:": !0
}, slashedProtocol = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
}, querystring = querystring$1;
function urlParse(o, t, e) {
  if (o && util$7.isObject(o) && o instanceof Url)
    return o;
  var r = new Url();
  return r.parse(o, t, e), r;
}
Url.prototype.parse = function(o, t, e) {
  if (!util$7.isString(o))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof o);
  var r = o.indexOf("?"), D = r !== -1 && r < o.indexOf("#") ? "?" : "#", N = o.split(D), k = /\\/g;
  N[0] = N[0].replace(k, "/"), o = N.join(D);
  var $ = o;
  if ($ = $.trim(), !e && o.split("#").length === 1) {
    var G = simplePathPattern.exec($);
    if (G)
      return this.path = $, this.href = $, this.pathname = G[1], G[2] ? (this.search = G[2], t ? this.query = querystring.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
  }
  var U = protocolPattern.exec($);
  if (U) {
    U = U[0];
    var z = U.toLowerCase();
    this.protocol = z, $ = $.substr(U.length);
  }
  if (e || U || $.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var X = $.substr(0, 2) === "//";
    X && !(U && hostlessProtocol[U]) && ($ = $.substr(2), this.slashes = !0);
  }
  if (!hostlessProtocol[U] && (X || U && !slashedProtocol[U])) {
    for (var V = -1, Y = 0; Y < hostEndingChars.length; Y++) {
      var W = $.indexOf(hostEndingChars[Y]);
      W !== -1 && (V === -1 || W < V) && (V = W);
    }
    var q, K;
    V === -1 ? K = $.lastIndexOf("@") : K = $.lastIndexOf("@", V), K !== -1 && (q = $.slice(0, K), $ = $.slice(K + 1), this.auth = decodeURIComponent(q)), V = -1;
    for (var Y = 0; Y < nonHostChars.length; Y++) {
      var W = $.indexOf(nonHostChars[Y]);
      W !== -1 && (V === -1 || W < V) && (V = W);
    }
    V === -1 && (V = $.length), this.host = $.slice(0, V), $ = $.slice(V), this.parseHost(), this.hostname = this.hostname || "";
    var Z = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!Z)
      for (var J = this.hostname.split(/\./), Y = 0, Q = J.length; Y < Q; Y++) {
        var et = J[Y];
        if (et && !et.match(hostnamePartPattern)) {
          for (var it = "", tt = 0, nt = et.length; tt < nt; tt++)
            et.charCodeAt(tt) > 127 ? it += "x" : it += et[tt];
          if (!it.match(hostnamePartPattern)) {
            var st = J.slice(0, Y), at = J.slice(Y + 1), ut = et.match(hostnamePartStart);
            ut && (st.push(ut[1]), at.unshift(ut[2])), at.length && ($ = "/" + at.join(".") + $), this.hostname = st.join(".");
            break;
          }
        }
      }
    this.hostname.length > hostnameMaxLen ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), Z || (this.hostname = punycode.toASCII(this.hostname));
    var ht = this.port ? ":" + this.port : "", dt = this.hostname || "";
    this.host = dt + ht, this.href += this.host, Z && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), $[0] !== "/" && ($ = "/" + $));
  }
  if (!unsafeProtocol[z])
    for (var Y = 0, Q = autoEscape.length; Y < Q; Y++) {
      var pt = autoEscape[Y];
      if ($.indexOf(pt) !== -1) {
        var _t = encodeURIComponent(pt);
        _t === pt && (_t = escape(pt)), $ = $.split(pt).join(_t);
      }
    }
  var mt = $.indexOf("#");
  mt !== -1 && (this.hash = $.substr(mt), $ = $.slice(0, mt));
  var yt = $.indexOf("?");
  if (yt !== -1 ? (this.search = $.substr(yt), this.query = $.substr(yt + 1), t && (this.query = querystring.parse(this.query)), $ = $.slice(0, yt)) : t && (this.search = "", this.query = {}), $ && (this.pathname = $), slashedProtocol[z] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var ht = this.pathname || "", Tt = this.search || "";
    this.path = ht + Tt;
  }
  return this.href = this.format(), this;
};
function urlFormat(o) {
  return util$7.isString(o) && (o = urlParse(o)), o instanceof Url ? o.format() : Url.prototype.format.call(o);
}
Url.prototype.format = function() {
  var o = this.auth || "";
  o && (o = encodeURIComponent(o), o = o.replace(/%3A/i, ":"), o += "@");
  var t = this.protocol || "", e = this.pathname || "", r = this.hash || "", D = !1, N = "";
  this.host ? D = o + this.host : this.hostname && (D = o + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (D += ":" + this.port)), this.query && util$7.isObject(this.query) && Object.keys(this.query).length && (N = querystring.stringify(this.query));
  var k = this.search || N && "?" + N || "";
  return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || slashedProtocol[t]) && D !== !1 ? (D = "//" + (D || ""), e && e.charAt(0) !== "/" && (e = "/" + e)) : D || (D = ""), r && r.charAt(0) !== "#" && (r = "#" + r), k && k.charAt(0) !== "?" && (k = "?" + k), e = e.replace(/[?#]/g, function($) {
    return encodeURIComponent($);
  }), k = k.replace("#", "%23"), t + D + e + k + r;
};
function urlResolve(o, t) {
  return urlParse(o, !1, !0).resolve(t);
}
Url.prototype.resolve = function(o) {
  return this.resolveObject(urlParse(o, !1, !0)).format();
};
Url.prototype.resolveObject = function(o) {
  if (util$7.isString(o)) {
    var t = new Url();
    t.parse(o, !1, !0), o = t;
  }
  for (var e = new Url(), r = Object.keys(this), D = 0; D < r.length; D++) {
    var N = r[D];
    e[N] = this[N];
  }
  if (e.hash = o.hash, o.href === "")
    return e.href = e.format(), e;
  if (o.slashes && !o.protocol) {
    for (var k = Object.keys(o), $ = 0; $ < k.length; $++) {
      var G = k[$];
      G !== "protocol" && (e[G] = o[G]);
    }
    return slashedProtocol[e.protocol] && e.hostname && !e.pathname && (e.path = e.pathname = "/"), e.href = e.format(), e;
  }
  if (o.protocol && o.protocol !== e.protocol) {
    if (!slashedProtocol[o.protocol]) {
      for (var U = Object.keys(o), z = 0; z < U.length; z++) {
        var X = U[z];
        e[X] = o[X];
      }
      return e.href = e.format(), e;
    }
    if (e.protocol = o.protocol, !o.host && !hostlessProtocol[o.protocol]) {
      for (var Q = (o.pathname || "").split("/"); Q.length && !(o.host = Q.shift()); )
        ;
      o.host || (o.host = ""), o.hostname || (o.hostname = ""), Q[0] !== "" && Q.unshift(""), Q.length < 2 && Q.unshift(""), e.pathname = Q.join("/");
    } else
      e.pathname = o.pathname;
    if (e.search = o.search, e.query = o.query, e.host = o.host || "", e.auth = o.auth, e.hostname = o.hostname || o.host, e.port = o.port, e.pathname || e.search) {
      var V = e.pathname || "", Y = e.search || "";
      e.path = V + Y;
    }
    return e.slashes = e.slashes || o.slashes, e.href = e.format(), e;
  }
  var W = e.pathname && e.pathname.charAt(0) === "/", q = o.host || o.pathname && o.pathname.charAt(0) === "/", K = q || W || e.host && o.pathname, Z = K, J = e.pathname && e.pathname.split("/") || [], Q = o.pathname && o.pathname.split("/") || [], et = e.protocol && !slashedProtocol[e.protocol];
  if (et && (e.hostname = "", e.port = null, e.host && (J[0] === "" ? J[0] = e.host : J.unshift(e.host)), e.host = "", o.protocol && (o.hostname = null, o.port = null, o.host && (Q[0] === "" ? Q[0] = o.host : Q.unshift(o.host)), o.host = null), K = K && (Q[0] === "" || J[0] === "")), q)
    e.host = o.host || o.host === "" ? o.host : e.host, e.hostname = o.hostname || o.hostname === "" ? o.hostname : e.hostname, e.search = o.search, e.query = o.query, J = Q;
  else if (Q.length)
    J || (J = []), J.pop(), J = J.concat(Q), e.search = o.search, e.query = o.query;
  else if (!util$7.isNullOrUndefined(o.search)) {
    if (et) {
      e.hostname = e.host = J.shift();
      var it = e.host && e.host.indexOf("@") > 0 ? e.host.split("@") : !1;
      it && (e.auth = it.shift(), e.host = e.hostname = it.shift());
    }
    return e.search = o.search, e.query = o.query, (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : "") + (e.search ? e.search : "")), e.href = e.format(), e;
  }
  if (!J.length)
    return e.pathname = null, e.search ? e.path = "/" + e.search : e.path = null, e.href = e.format(), e;
  for (var tt = J.slice(-1)[0], nt = (e.host || o.host || J.length > 1) && (tt === "." || tt === "..") || tt === "", st = 0, at = J.length; at >= 0; at--)
    tt = J[at], tt === "." ? J.splice(at, 1) : tt === ".." ? (J.splice(at, 1), st++) : st && (J.splice(at, 1), st--);
  if (!K && !Z)
    for (; st--; st)
      J.unshift("..");
  K && J[0] !== "" && (!J[0] || J[0].charAt(0) !== "/") && J.unshift(""), nt && J.join("/").substr(-1) !== "/" && J.push("");
  var ut = J[0] === "" || J[0] && J[0].charAt(0) === "/";
  if (et) {
    e.hostname = e.host = ut ? "" : J.length ? J.shift() : "";
    var it = e.host && e.host.indexOf("@") > 0 ? e.host.split("@") : !1;
    it && (e.auth = it.shift(), e.host = e.hostname = it.shift());
  }
  return K = K || e.host && J.length, K && !ut && J.unshift(""), J.length ? e.pathname = J.join("/") : (e.pathname = null, e.path = null), (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : "") + (e.search ? e.search : "")), e.auth = o.auth || e.auth, e.slashes = e.slashes || o.slashes, e.href = e.format(), e;
};
Url.prototype.parseHost = function() {
  var o = this.host, t = portPattern.exec(o);
  t && (t = t[0], t !== ":" && (this.port = t.substr(1)), o = o.substr(0, o.length - t.length)), o && (this.hostname = o);
};
/*!
 * @pixi/utils - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var url$1 = {
  parse: parse$2,
  format: format$1,
  resolve
};
settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var saidHello = !1, VERSION$1 = "6.5.9";
function skipHello() {
  saidHello = !0;
}
function sayHello(o) {
  var t;
  if (!saidHello) {
    if (settings.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      var e = [
        `
 %c %c %c PixiJS ` + VERSION$1 + " - ✰ " + o + ` ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ 

`,
        "background: #ff66a5; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff66a5; background: #030307; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "background: #ffc3dc; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;"
      ];
      (t = globalThis.console).log.apply(t, e);
    } else
      globalThis.console && globalThis.console.log("PixiJS " + VERSION$1 + " - " + o + " - http://www.pixijs.com/");
    saidHello = !0;
  }
}
var supported;
function isWebGLSupported() {
  return typeof supported > "u" && (supported = function() {
    var t = {
      stencil: !0,
      failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
    };
    try {
      if (!settings.ADAPTER.getWebGLRenderingContext())
        return !1;
      var e = settings.ADAPTER.createCanvas(), r = e.getContext("webgl", t) || e.getContext("experimental-webgl", t), D = !!(r && r.getContextAttributes().stencil);
      if (r) {
        var N = r.getExtension("WEBGL_lose_context");
        N && N.loseContext();
      }
      return r = null, D;
    } catch {
      return !1;
    }
  }()), supported;
}
var aliceblue = "#f0f8ff", antiquewhite = "#faebd7", aqua = "#00ffff", aquamarine = "#7fffd4", azure = "#f0ffff", beige = "#f5f5dc", bisque = "#ffe4c4", black = "#000000", blanchedalmond = "#ffebcd", blue = "#0000ff", blueviolet = "#8a2be2", brown = "#a52a2a", burlywood = "#deb887", cadetblue = "#5f9ea0", chartreuse = "#7fff00", chocolate = "#d2691e", coral = "#ff7f50", cornflowerblue = "#6495ed", cornsilk = "#fff8dc", crimson = "#dc143c", cyan = "#00ffff", darkblue = "#00008b", darkcyan = "#008b8b", darkgoldenrod = "#b8860b", darkgray = "#a9a9a9", darkgreen = "#006400", darkgrey = "#a9a9a9", darkkhaki = "#bdb76b", darkmagenta = "#8b008b", darkolivegreen = "#556b2f", darkorange = "#ff8c00", darkorchid = "#9932cc", darkred = "#8b0000", darksalmon = "#e9967a", darkseagreen = "#8fbc8f", darkslateblue = "#483d8b", darkslategray = "#2f4f4f", darkslategrey = "#2f4f4f", darkturquoise = "#00ced1", darkviolet = "#9400d3", deeppink = "#ff1493", deepskyblue = "#00bfff", dimgray = "#696969", dimgrey = "#696969", dodgerblue = "#1e90ff", firebrick = "#b22222", floralwhite = "#fffaf0", forestgreen = "#228b22", fuchsia = "#ff00ff", gainsboro = "#dcdcdc", ghostwhite = "#f8f8ff", goldenrod = "#daa520", gold = "#ffd700", gray = "#808080", green = "#008000", greenyellow = "#adff2f", grey = "#808080", honeydew = "#f0fff0", hotpink = "#ff69b4", indianred = "#cd5c5c", indigo = "#4b0082", ivory = "#fffff0", khaki = "#f0e68c", lavenderblush = "#fff0f5", lavender = "#e6e6fa", lawngreen = "#7cfc00", lemonchiffon = "#fffacd", lightblue = "#add8e6", lightcoral = "#f08080", lightcyan = "#e0ffff", lightgoldenrodyellow = "#fafad2", lightgray = "#d3d3d3", lightgreen = "#90ee90", lightgrey = "#d3d3d3", lightpink = "#ffb6c1", lightsalmon = "#ffa07a", lightseagreen = "#20b2aa", lightskyblue = "#87cefa", lightslategray = "#778899", lightslategrey = "#778899", lightsteelblue = "#b0c4de", lightyellow = "#ffffe0", lime = "#00ff00", limegreen = "#32cd32", linen = "#faf0e6", magenta = "#ff00ff", maroon = "#800000", mediumaquamarine = "#66cdaa", mediumblue = "#0000cd", mediumorchid = "#ba55d3", mediumpurple = "#9370db", mediumseagreen = "#3cb371", mediumslateblue = "#7b68ee", mediumspringgreen = "#00fa9a", mediumturquoise = "#48d1cc", mediumvioletred = "#c71585", midnightblue = "#191970", mintcream = "#f5fffa", mistyrose = "#ffe4e1", moccasin = "#ffe4b5", navajowhite = "#ffdead", navy = "#000080", oldlace = "#fdf5e6", olive = "#808000", olivedrab = "#6b8e23", orange = "#ffa500", orangered = "#ff4500", orchid = "#da70d6", palegoldenrod = "#eee8aa", palegreen = "#98fb98", paleturquoise = "#afeeee", palevioletred = "#db7093", papayawhip = "#ffefd5", peachpuff = "#ffdab9", peru = "#cd853f", pink = "#ffc0cb", plum = "#dda0dd", powderblue = "#b0e0e6", purple = "#800080", rebeccapurple = "#663399", red = "#ff0000", rosybrown = "#bc8f8f", royalblue = "#4169e1", saddlebrown = "#8b4513", salmon = "#fa8072", sandybrown = "#f4a460", seagreen = "#2e8b57", seashell = "#fff5ee", sienna = "#a0522d", silver = "#c0c0c0", skyblue = "#87ceeb", slateblue = "#6a5acd", slategray = "#708090", slategrey = "#708090", snow = "#fffafa", springgreen = "#00ff7f", steelblue = "#4682b4", tan = "#d2b48c", teal = "#008080", thistle = "#d8bfd8", tomato = "#ff6347", turquoise = "#40e0d0", violet = "#ee82ee", wheat = "#f5deb3", white = "#ffffff", whitesmoke = "#f5f5f5", yellow = "#ffff00", yellowgreen = "#9acd32", cssColorNames = {
  aliceblue,
  antiquewhite,
  aqua,
  aquamarine,
  azure,
  beige,
  bisque,
  black,
  blanchedalmond,
  blue,
  blueviolet,
  brown,
  burlywood,
  cadetblue,
  chartreuse,
  chocolate,
  coral,
  cornflowerblue,
  cornsilk,
  crimson,
  cyan,
  darkblue,
  darkcyan,
  darkgoldenrod,
  darkgray,
  darkgreen,
  darkgrey,
  darkkhaki,
  darkmagenta,
  darkolivegreen,
  darkorange,
  darkorchid,
  darkred,
  darksalmon,
  darkseagreen,
  darkslateblue,
  darkslategray,
  darkslategrey,
  darkturquoise,
  darkviolet,
  deeppink,
  deepskyblue,
  dimgray,
  dimgrey,
  dodgerblue,
  firebrick,
  floralwhite,
  forestgreen,
  fuchsia,
  gainsboro,
  ghostwhite,
  goldenrod,
  gold,
  gray,
  green,
  greenyellow,
  grey,
  honeydew,
  hotpink,
  indianred,
  indigo,
  ivory,
  khaki,
  lavenderblush,
  lavender,
  lawngreen,
  lemonchiffon,
  lightblue,
  lightcoral,
  lightcyan,
  lightgoldenrodyellow,
  lightgray,
  lightgreen,
  lightgrey,
  lightpink,
  lightsalmon,
  lightseagreen,
  lightskyblue,
  lightslategray,
  lightslategrey,
  lightsteelblue,
  lightyellow,
  lime,
  limegreen,
  linen,
  magenta,
  maroon,
  mediumaquamarine,
  mediumblue,
  mediumorchid,
  mediumpurple,
  mediumseagreen,
  mediumslateblue,
  mediumspringgreen,
  mediumturquoise,
  mediumvioletred,
  midnightblue,
  mintcream,
  mistyrose,
  moccasin,
  navajowhite,
  navy,
  oldlace,
  olive,
  olivedrab,
  orange,
  orangered,
  orchid,
  palegoldenrod,
  palegreen,
  paleturquoise,
  palevioletred,
  papayawhip,
  peachpuff,
  peru,
  pink,
  plum,
  powderblue,
  purple,
  rebeccapurple,
  red,
  rosybrown,
  royalblue,
  saddlebrown,
  salmon,
  sandybrown,
  seagreen,
  seashell,
  sienna,
  silver,
  skyblue,
  slateblue,
  slategray,
  slategrey,
  snow,
  springgreen,
  steelblue,
  tan,
  teal,
  thistle,
  tomato,
  turquoise,
  violet,
  wheat,
  white,
  whitesmoke,
  yellow,
  yellowgreen
};
function hex2rgb(o, t) {
  return t === void 0 && (t = []), t[0] = (o >> 16 & 255) / 255, t[1] = (o >> 8 & 255) / 255, t[2] = (o & 255) / 255, t;
}
function hex2string(o) {
  var t = o.toString(16);
  return t = "000000".substring(0, 6 - t.length) + t, "#" + t;
}
function string2hex(o) {
  return typeof o == "string" && (o = cssColorNames[o.toLowerCase()] || o, o[0] === "#" && (o = o.slice(1))), parseInt(o, 16);
}
function mapPremultipliedBlendModes() {
  for (var o = [], t = [], e = 0; e < 32; e++)
    o[e] = e, t[e] = e;
  o[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL, o[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD, o[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN, t[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM, t[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM, t[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
  var r = [];
  return r.push(t), r.push(o), r;
}
var premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(o, t) {
  return premultiplyBlendMode[t ? 1 : 0][o];
}
function premultiplyRgba(o, t, e, r) {
  return e = e || new Float32Array(4), r || r === void 0 ? (e[0] = o[0] * t, e[1] = o[1] * t, e[2] = o[2] * t) : (e[0] = o[0], e[1] = o[1], e[2] = o[2]), e[3] = t, e;
}
function premultiplyTint(o, t) {
  if (t === 1)
    return (t * 255 << 24) + o;
  if (t === 0)
    return 0;
  var e = o >> 16 & 255, r = o >> 8 & 255, D = o & 255;
  return e = e * t + 0.5 | 0, r = r * t + 0.5 | 0, D = D * t + 0.5 | 0, (t * 255 << 24) + (e << 16) + (r << 8) + D;
}
function premultiplyTintToRgba(o, t, e, r) {
  return e = e || new Float32Array(4), e[0] = (o >> 16 & 255) / 255, e[1] = (o >> 8 & 255) / 255, e[2] = (o & 255) / 255, (r || r === void 0) && (e[0] *= t, e[1] *= t, e[2] *= t), e[3] = t, e;
}
function createIndicesForQuads(o, t) {
  t === void 0 && (t = null);
  var e = o * 6;
  if (t = t || new Uint16Array(e), t.length !== e)
    throw new Error("Out buffer length is incorrect, got " + t.length + " and expected " + e);
  for (var r = 0, D = 0; r < e; r += 6, D += 4)
    t[r + 0] = D + 0, t[r + 1] = D + 1, t[r + 2] = D + 2, t[r + 3] = D + 0, t[r + 4] = D + 2, t[r + 5] = D + 3;
  return t;
}
function getBufferType(o) {
  if (o.BYTES_PER_ELEMENT === 4)
    return o instanceof Float32Array ? "Float32Array" : o instanceof Uint32Array ? "Uint32Array" : "Int32Array";
  if (o.BYTES_PER_ELEMENT === 2) {
    if (o instanceof Uint16Array)
      return "Uint16Array";
  } else if (o.BYTES_PER_ELEMENT === 1 && o instanceof Uint8Array)
    return "Uint8Array";
  return null;
}
function nextPow2(o) {
  return o += o === 0 ? 1 : 0, --o, o |= o >>> 1, o |= o >>> 2, o |= o >>> 4, o |= o >>> 8, o |= o >>> 16, o + 1;
}
function isPow2(o) {
  return !(o & o - 1) && !!o;
}
function log2(o) {
  var t = (o > 65535 ? 1 : 0) << 4;
  o >>>= t;
  var e = (o > 255 ? 1 : 0) << 3;
  return o >>>= e, t |= e, e = (o > 15 ? 1 : 0) << 2, o >>>= e, t |= e, e = (o > 3 ? 1 : 0) << 1, o >>>= e, t |= e, t | o >> 1;
}
function removeItems(o, t, e) {
  var r = o.length, D;
  if (!(t >= r || e === 0)) {
    e = t + e > r ? r - t : e;
    var N = r - e;
    for (D = t; D < N; ++D)
      o[D] = o[D + e];
    o.length = N;
  }
}
function sign(o) {
  return o === 0 ? 0 : o < 0 ? -1 : 1;
}
var nextUid = 0;
function uid() {
  return ++nextUid;
}
var warnings = {};
function deprecation(o, t, e) {
  if (e === void 0 && (e = 3), !warnings[t]) {
    var r = new Error().stack;
    typeof r > "u" ? console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + o) : (r = r.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", t + `
Deprecated since v` + o), console.warn(r), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + o), console.warn(r))), warnings[t] = !0;
  }
}
var ProgramCache = {}, TextureCache = /* @__PURE__ */ Object.create(null), BaseTextureCache = /* @__PURE__ */ Object.create(null);
function clearTextureCache() {
  var o;
  for (o in TextureCache)
    delete TextureCache[o];
  for (o in BaseTextureCache)
    delete BaseTextureCache[o];
}
var CanvasRenderTarget = (
  /** @class */
  function() {
    function o(t, e, r) {
      this.canvas = settings.ADAPTER.createCanvas(), this.context = this.canvas.getContext("2d"), this.resolution = r || settings.RESOLUTION, this.resize(t, e);
    }
    return o.prototype.clear = function() {
      this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }, o.prototype.resize = function(t, e) {
      this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);
    }, o.prototype.destroy = function() {
      this.context = null, this.canvas = null;
    }, Object.defineProperty(o.prototype, "width", {
      /**
       * The width of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.width;
      },
      set: function(t) {
        this.canvas.width = Math.round(t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "height", {
      /**
       * The height of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.height;
      },
      set: function(t) {
        this.canvas.height = Math.round(t);
      },
      enumerable: !1,
      configurable: !0
    }), o;
  }()
);
function trimCanvas(o) {
  var t = o.width, e = o.height, r = o.getContext("2d", {
    willReadFrequently: !0
  }), D = r.getImageData(0, 0, t, e), N = D.data, k = N.length, $ = {
    top: null,
    left: null,
    right: null,
    bottom: null
  }, G = null, U, z, X;
  for (U = 0; U < k; U += 4)
    N[U + 3] !== 0 && (z = U / 4 % t, X = ~~(U / 4 / t), $.top === null && ($.top = X), ($.left === null || z < $.left) && ($.left = z), ($.right === null || $.right < z) && ($.right = z + 1), ($.bottom === null || $.bottom < X) && ($.bottom = X));
  return $.top !== null && (t = $.right - $.left, e = $.bottom - $.top + 1, G = r.getImageData($.left, $.top, t, e)), {
    height: e,
    width: t,
    data: G
  };
}
var tempAnchor$1;
function determineCrossOrigin(o, t) {
  if (t === void 0 && (t = globalThis.location), o.indexOf("data:") === 0)
    return "";
  t = t || globalThis.location, tempAnchor$1 || (tempAnchor$1 = document.createElement("a")), tempAnchor$1.href = o;
  var e = url$1.parse(tempAnchor$1.href), r = !e.port && t.port === "" || e.port === t.port;
  return e.hostname !== t.hostname || !r || e.protocol !== t.protocol ? "anonymous" : "";
}
function getResolutionOfUrl(o, t) {
  var e = settings.RETINA_PREFIX.exec(o);
  return e ? parseFloat(e[1]) : t !== void 0 ? t : 1;
}
/*!
 * @pixi/math - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var PI_2 = Math.PI * 2, RAD_TO_DEG = 180 / Math.PI, DEG_TO_RAD = Math.PI / 180, SHAPES;
(function(o) {
  o[o.POLY = 0] = "POLY", o[o.RECT = 1] = "RECT", o[o.CIRC = 2] = "CIRC", o[o.ELIP = 3] = "ELIP", o[o.RREC = 4] = "RREC";
})(SHAPES || (SHAPES = {}));
var Point = (
  /** @class */
  function() {
    function o(t, e) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e;
    }
    return o.prototype.clone = function() {
      return new o(this.x, this.y);
    }, o.prototype.copyFrom = function(t) {
      return this.set(t.x, t.y), this;
    }, o.prototype.copyTo = function(t) {
      return t.set(this.x, this.y), t;
    }, o.prototype.equals = function(t) {
      return t.x === this.x && t.y === this.y;
    }, o.prototype.set = function(t, e) {
      return t === void 0 && (t = 0), e === void 0 && (e = t), this.x = t, this.y = e, this;
    }, o.prototype.toString = function() {
      return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
    }, o;
  }()
), tempPoints$1 = [new Point(), new Point(), new Point(), new Point()], Rectangle = (
  /** @class */
  function() {
    function o(t, e, r, D) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), D === void 0 && (D = 0), this.x = Number(t), this.y = Number(e), this.width = Number(r), this.height = Number(D), this.type = SHAPES.RECT;
    }
    return Object.defineProperty(o.prototype, "left", {
      /** Returns the left edge of the rectangle. */
      get: function() {
        return this.x;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "right", {
      /** Returns the right edge of the rectangle. */
      get: function() {
        return this.x + this.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "top", {
      /** Returns the top edge of the rectangle. */
      get: function() {
        return this.y;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "bottom", {
      /** Returns the bottom edge of the rectangle. */
      get: function() {
        return this.y + this.height;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o, "EMPTY", {
      /** A constant empty rectangle. */
      get: function() {
        return new o(0, 0, 0, 0);
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.clone = function() {
      return new o(this.x, this.y, this.width, this.height);
    }, o.prototype.copyFrom = function(t) {
      return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
    }, o.prototype.copyTo = function(t) {
      return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
    }, o.prototype.contains = function(t, e) {
      return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
    }, o.prototype.intersects = function(t, e) {
      if (!e) {
        var r = this.x < t.x ? t.x : this.x, D = this.right > t.right ? t.right : this.right;
        if (D <= r)
          return !1;
        var N = this.y < t.y ? t.y : this.y, k = this.bottom > t.bottom ? t.bottom : this.bottom;
        return k > N;
      }
      var $ = this.left, G = this.right, U = this.top, z = this.bottom;
      if (G <= $ || z <= U)
        return !1;
      var X = tempPoints$1[0].set(t.left, t.top), V = tempPoints$1[1].set(t.left, t.bottom), Y = tempPoints$1[2].set(t.right, t.top), W = tempPoints$1[3].set(t.right, t.bottom);
      if (Y.x <= X.x || V.y <= X.y)
        return !1;
      var q = Math.sign(e.a * e.d - e.b * e.c);
      if (q === 0 || (e.apply(X, X), e.apply(V, V), e.apply(Y, Y), e.apply(W, W), Math.max(X.x, V.x, Y.x, W.x) <= $ || Math.min(X.x, V.x, Y.x, W.x) >= G || Math.max(X.y, V.y, Y.y, W.y) <= U || Math.min(X.y, V.y, Y.y, W.y) >= z))
        return !1;
      var K = q * (V.y - X.y), Z = q * (X.x - V.x), J = K * $ + Z * U, Q = K * G + Z * U, et = K * $ + Z * z, it = K * G + Z * z;
      if (Math.max(J, Q, et, it) <= K * X.x + Z * X.y || Math.min(J, Q, et, it) >= K * W.x + Z * W.y)
        return !1;
      var tt = q * (X.y - Y.y), nt = q * (Y.x - X.x), st = tt * $ + nt * U, at = tt * G + nt * U, ut = tt * $ + nt * z, ht = tt * G + nt * z;
      return !(Math.max(st, at, ut, ht) <= tt * X.x + nt * X.y || Math.min(st, at, ut, ht) >= tt * W.x + nt * W.y);
    }, o.prototype.pad = function(t, e) {
      return t === void 0 && (t = 0), e === void 0 && (e = t), this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
    }, o.prototype.fit = function(t) {
      var e = Math.max(this.x, t.x), r = Math.min(this.x + this.width, t.x + t.width), D = Math.max(this.y, t.y), N = Math.min(this.y + this.height, t.y + t.height);
      return this.x = e, this.width = Math.max(r - e, 0), this.y = D, this.height = Math.max(N - D, 0), this;
    }, o.prototype.ceil = function(t, e) {
      t === void 0 && (t = 1), e === void 0 && (e = 1e-3);
      var r = Math.ceil((this.x + this.width - e) * t) / t, D = Math.ceil((this.y + this.height - e) * t) / t;
      return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = r - this.x, this.height = D - this.y, this;
    }, o.prototype.enlarge = function(t) {
      var e = Math.min(this.x, t.x), r = Math.max(this.x + this.width, t.x + t.width), D = Math.min(this.y, t.y), N = Math.max(this.y + this.height, t.y + t.height);
      return this.x = e, this.width = r - e, this.y = D, this.height = N - D, this;
    }, o.prototype.toString = function() {
      return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    }, o;
  }()
), Circle = (
  /** @class */
  function() {
    function o(t, e, r) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), this.x = t, this.y = e, this.radius = r, this.type = SHAPES.CIRC;
    }
    return o.prototype.clone = function() {
      return new o(this.x, this.y, this.radius);
    }, o.prototype.contains = function(t, e) {
      if (this.radius <= 0)
        return !1;
      var r = this.radius * this.radius, D = this.x - t, N = this.y - e;
      return D *= D, N *= N, D + N <= r;
    }, o.prototype.getBounds = function() {
      return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }, o.prototype.toString = function() {
      return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
    }, o;
  }()
), Ellipse = (
  /** @class */
  function() {
    function o(t, e, r, D) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), D === void 0 && (D = 0), this.x = t, this.y = e, this.width = r, this.height = D, this.type = SHAPES.ELIP;
    }
    return o.prototype.clone = function() {
      return new o(this.x, this.y, this.width, this.height);
    }, o.prototype.contains = function(t, e) {
      if (this.width <= 0 || this.height <= 0)
        return !1;
      var r = (t - this.x) / this.width, D = (e - this.y) / this.height;
      return r *= r, D *= D, r + D <= 1;
    }, o.prototype.getBounds = function() {
      return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
    }, o.prototype.toString = function() {
      return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    }, o;
  }()
), Polygon = (
  /** @class */
  function() {
    function o() {
      for (var t = arguments, e = [], r = 0; r < arguments.length; r++)
        e[r] = t[r];
      var D = Array.isArray(e[0]) ? e[0] : e;
      if (typeof D[0] != "number") {
        for (var N = [], k = 0, $ = D.length; k < $; k++)
          N.push(D[k].x, D[k].y);
        D = N;
      }
      this.points = D, this.type = SHAPES.POLY, this.closeStroke = !0;
    }
    return o.prototype.clone = function() {
      var t = this.points.slice(), e = new o(t);
      return e.closeStroke = this.closeStroke, e;
    }, o.prototype.contains = function(t, e) {
      for (var r = !1, D = this.points.length / 2, N = 0, k = D - 1; N < D; k = N++) {
        var $ = this.points[N * 2], G = this.points[N * 2 + 1], U = this.points[k * 2], z = this.points[k * 2 + 1], X = G > e != z > e && t < (U - $) * ((e - G) / (z - G)) + $;
        X && (r = !r);
      }
      return r;
    }, o.prototype.toString = function() {
      return "[@pixi/math:Polygon" + ("closeStroke=" + this.closeStroke) + ("points=" + this.points.reduce(function(t, e) {
        return t + ", " + e;
      }, "") + "]");
    }, o;
  }()
), RoundedRectangle = (
  /** @class */
  function() {
    function o(t, e, r, D, N) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), D === void 0 && (D = 0), N === void 0 && (N = 20), this.x = t, this.y = e, this.width = r, this.height = D, this.radius = N, this.type = SHAPES.RREC;
    }
    return o.prototype.clone = function() {
      return new o(this.x, this.y, this.width, this.height, this.radius);
    }, o.prototype.contains = function(t, e) {
      if (this.width <= 0 || this.height <= 0)
        return !1;
      if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
        var r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (e >= this.y + r && e <= this.y + this.height - r || t >= this.x + r && t <= this.x + this.width - r)
          return !0;
        var D = t - (this.x + r), N = e - (this.y + r), k = r * r;
        if (D * D + N * N <= k || (D = t - (this.x + this.width - r), D * D + N * N <= k) || (N = e - (this.y + this.height - r), D * D + N * N <= k) || (D = t - (this.x + r), D * D + N * N <= k))
          return !0;
      }
      return !1;
    }, o.prototype.toString = function() {
      return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + ("width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]");
    }, o;
  }()
), ObservablePoint = (
  /** @class */
  function() {
    function o(t, e, r, D) {
      r === void 0 && (r = 0), D === void 0 && (D = 0), this._x = r, this._y = D, this.cb = t, this.scope = e;
    }
    return o.prototype.clone = function(t, e) {
      return t === void 0 && (t = this.cb), e === void 0 && (e = this.scope), new o(t, e, this._x, this._y);
    }, o.prototype.set = function(t, e) {
      return t === void 0 && (t = 0), e === void 0 && (e = t), (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this.cb.call(this.scope)), this;
    }, o.prototype.copyFrom = function(t) {
      return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this;
    }, o.prototype.copyTo = function(t) {
      return t.set(this._x, this._y), t;
    }, o.prototype.equals = function(t) {
      return t.x === this._x && t.y === this._y;
    }, o.prototype.toString = function() {
      return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
    }, Object.defineProperty(o.prototype, "x", {
      /** Position of the observable point on the x axis. */
      get: function() {
        return this._x;
      },
      set: function(t) {
        this._x !== t && (this._x = t, this.cb.call(this.scope));
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "y", {
      /** Position of the observable point on the y axis. */
      get: function() {
        return this._y;
      },
      set: function(t) {
        this._y !== t && (this._y = t, this.cb.call(this.scope));
      },
      enumerable: !1,
      configurable: !0
    }), o;
  }()
), Matrix = (
  /** @class */
  function() {
    function o(t, e, r, D, N, k) {
      t === void 0 && (t = 1), e === void 0 && (e = 0), r === void 0 && (r = 0), D === void 0 && (D = 1), N === void 0 && (N = 0), k === void 0 && (k = 0), this.array = null, this.a = t, this.b = e, this.c = r, this.d = D, this.tx = N, this.ty = k;
    }
    return o.prototype.fromArray = function(t) {
      this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
    }, o.prototype.set = function(t, e, r, D, N, k) {
      return this.a = t, this.b = e, this.c = r, this.d = D, this.tx = N, this.ty = k, this;
    }, o.prototype.toArray = function(t, e) {
      this.array || (this.array = new Float32Array(9));
      var r = e || this.array;
      return t ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r;
    }, o.prototype.apply = function(t, e) {
      e = e || new Point();
      var r = t.x, D = t.y;
      return e.x = this.a * r + this.c * D + this.tx, e.y = this.b * r + this.d * D + this.ty, e;
    }, o.prototype.applyInverse = function(t, e) {
      e = e || new Point();
      var r = 1 / (this.a * this.d + this.c * -this.b), D = t.x, N = t.y;
      return e.x = this.d * r * D + -this.c * r * N + (this.ty * this.c - this.tx * this.d) * r, e.y = this.a * r * N + -this.b * r * D + (-this.ty * this.a + this.tx * this.b) * r, e;
    }, o.prototype.translate = function(t, e) {
      return this.tx += t, this.ty += e, this;
    }, o.prototype.scale = function(t, e) {
      return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
    }, o.prototype.rotate = function(t) {
      var e = Math.cos(t), r = Math.sin(t), D = this.a, N = this.c, k = this.tx;
      return this.a = D * e - this.b * r, this.b = D * r + this.b * e, this.c = N * e - this.d * r, this.d = N * r + this.d * e, this.tx = k * e - this.ty * r, this.ty = k * r + this.ty * e, this;
    }, o.prototype.append = function(t) {
      var e = this.a, r = this.b, D = this.c, N = this.d;
      return this.a = t.a * e + t.b * D, this.b = t.a * r + t.b * N, this.c = t.c * e + t.d * D, this.d = t.c * r + t.d * N, this.tx = t.tx * e + t.ty * D + this.tx, this.ty = t.tx * r + t.ty * N + this.ty, this;
    }, o.prototype.setTransform = function(t, e, r, D, N, k, $, G, U) {
      return this.a = Math.cos($ + U) * N, this.b = Math.sin($ + U) * N, this.c = -Math.sin($ - G) * k, this.d = Math.cos($ - G) * k, this.tx = t - (r * this.a + D * this.c), this.ty = e - (r * this.b + D * this.d), this;
    }, o.prototype.prepend = function(t) {
      var e = this.tx;
      if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
        var r = this.a, D = this.c;
        this.a = r * t.a + this.b * t.c, this.b = r * t.b + this.b * t.d, this.c = D * t.a + this.d * t.c, this.d = D * t.b + this.d * t.d;
      }
      return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
    }, o.prototype.decompose = function(t) {
      var e = this.a, r = this.b, D = this.c, N = this.d, k = t.pivot, $ = -Math.atan2(-D, N), G = Math.atan2(r, e), U = Math.abs($ + G);
      return U < 1e-5 || Math.abs(PI_2 - U) < 1e-5 ? (t.rotation = G, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = $, t.skew.y = G), t.scale.x = Math.sqrt(e * e + r * r), t.scale.y = Math.sqrt(D * D + N * N), t.position.x = this.tx + (k.x * e + k.y * D), t.position.y = this.ty + (k.x * r + k.y * N), t;
    }, o.prototype.invert = function() {
      var t = this.a, e = this.b, r = this.c, D = this.d, N = this.tx, k = t * D - e * r;
      return this.a = D / k, this.b = -e / k, this.c = -r / k, this.d = t / k, this.tx = (r * this.ty - D * N) / k, this.ty = -(t * this.ty - e * N) / k, this;
    }, o.prototype.identity = function() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }, o.prototype.clone = function() {
      var t = new o();
      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
    }, o.prototype.copyTo = function(t) {
      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
    }, o.prototype.copyFrom = function(t) {
      return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
    }, o.prototype.toString = function() {
      return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
    }, Object.defineProperty(o, "IDENTITY", {
      /**
       * A default (identity) matrix
       * @readonly
       */
      get: function() {
        return new o();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o, "TEMP_MATRIX", {
      /**
       * A temp matrix
       * @readonly
       */
      get: function() {
        return new o();
      },
      enumerable: !1,
      configurable: !0
    }), o;
  }()
), ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], rotationCayley = [], rotationMatrices = [], signum = Math.sign;
function init() {
  for (var o = 0; o < 16; o++) {
    var t = [];
    rotationCayley.push(t);
    for (var e = 0; e < 16; e++)
      for (var r = signum(ux[o] * ux[e] + vx[o] * uy[e]), D = signum(uy[o] * ux[e] + vy[o] * uy[e]), N = signum(ux[o] * vx[e] + vx[o] * vy[e]), k = signum(uy[o] * vx[e] + vy[o] * vy[e]), $ = 0; $ < 16; $++)
        if (ux[$] === r && uy[$] === D && vx[$] === N && vy[$] === k) {
          t.push($);
          break;
        }
  }
  for (var o = 0; o < 16; o++) {
    var G = new Matrix();
    G.set(ux[o], uy[o], vx[o], vy[o], 0, 0), rotationMatrices.push(G);
  }
}
init();
var groupD8 = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: function(o) {
    return ux[o];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: function(o) {
    return uy[o];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: function(o) {
    return vx[o];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: function(o) {
    return vy[o];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: function(o) {
    return o & 8 ? o & 15 : -o & 7;
  },
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {PIXI.GD8Symmetry} Composed operation
   */
  add: function(o, t) {
    return rotationCayley[o][t];
  },
  /**
   * Reverse of `add`.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @returns {PIXI.GD8Symmetry} Result
   */
  sub: function(o, t) {
    return rotationCayley[o][groupD8.inv(t)];
  },
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @memberof PIXI.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: function(o) {
    return o ^ 4;
  },
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: function(o) {
    return (o & 3) === 2;
  },
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @memberof PIXI.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: function(o, t) {
    return Math.abs(o) * 2 <= Math.abs(t) ? t >= 0 ? groupD8.S : groupD8.N : Math.abs(t) * 2 <= Math.abs(o) ? o > 0 ? groupD8.E : groupD8.W : t > 0 ? o > 0 ? groupD8.SE : groupD8.SW : o > 0 ? groupD8.NE : groupD8.NW;
  },
  /**
   * Helps sprite to compensate texture packer rotation.
   * @memberof PIXI.groupD8
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: function(o, t, e, r) {
    e === void 0 && (e = 0), r === void 0 && (r = 0);
    var D = rotationMatrices[groupD8.inv(t)];
    D.tx = e, D.ty = r, o.append(D);
  }
}, Transform = (
  /** @class */
  function() {
    function o() {
      this.worldTransform = new Matrix(), this.localTransform = new Matrix(), this.position = new ObservablePoint(this.onChange, this, 0, 0), this.scale = new ObservablePoint(this.onChange, this, 1, 1), this.pivot = new ObservablePoint(this.onChange, this, 0, 0), this.skew = new ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
    }
    return o.prototype.onChange = function() {
      this._localID++;
    }, o.prototype.updateSkew = function() {
      this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
    }, o.prototype.toString = function() {
      return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
    }, o.prototype.updateLocalTransform = function() {
      var t = this.localTransform;
      this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1);
    }, o.prototype.updateTransform = function(t) {
      var e = this.localTransform;
      if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {
        var r = t.worldTransform, D = this.worldTransform;
        D.a = e.a * r.a + e.b * r.c, D.b = e.a * r.b + e.b * r.d, D.c = e.c * r.a + e.d * r.c, D.d = e.c * r.b + e.d * r.d, D.tx = e.tx * r.a + e.ty * r.c + r.tx, D.ty = e.tx * r.b + e.ty * r.d + r.ty, this._parentID = t._worldID, this._worldID++;
      }
    }, o.prototype.setFromMatrix = function(t) {
      t.decompose(this), this._localID++;
    }, Object.defineProperty(o.prototype, "rotation", {
      /** The rotation of the object in radians. */
      get: function() {
        return this._rotation;
      },
      set: function(t) {
        this._rotation !== t && (this._rotation = t, this.updateSkew());
      },
      enumerable: !1,
      configurable: !0
    }), o.IDENTITY = new o(), o;
  }()
);
/*!
 * @pixi/display - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.SORTABLE_CHILDREN = !1;
var Bounds = (
  /** @class */
  function() {
    function o() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
    }
    return o.prototype.isEmpty = function() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }, o.prototype.clear = function() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
    }, o.prototype.getRectangle = function(t) {
      return this.minX > this.maxX || this.minY > this.maxY ? Rectangle.EMPTY : (t = t || new Rectangle(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t);
    }, o.prototype.addPoint = function(t) {
      this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y);
    }, o.prototype.addPointMatrix = function(t, e) {
      var r = t.a, D = t.b, N = t.c, k = t.d, $ = t.tx, G = t.ty, U = r * e.x + N * e.y + $, z = D * e.x + k * e.y + G;
      this.minX = Math.min(this.minX, U), this.maxX = Math.max(this.maxX, U), this.minY = Math.min(this.minY, z), this.maxY = Math.max(this.maxY, z);
    }, o.prototype.addQuad = function(t) {
      var e = this.minX, r = this.minY, D = this.maxX, N = this.maxY, k = t[0], $ = t[1];
      e = k < e ? k : e, r = $ < r ? $ : r, D = k > D ? k : D, N = $ > N ? $ : N, k = t[2], $ = t[3], e = k < e ? k : e, r = $ < r ? $ : r, D = k > D ? k : D, N = $ > N ? $ : N, k = t[4], $ = t[5], e = k < e ? k : e, r = $ < r ? $ : r, D = k > D ? k : D, N = $ > N ? $ : N, k = t[6], $ = t[7], e = k < e ? k : e, r = $ < r ? $ : r, D = k > D ? k : D, N = $ > N ? $ : N, this.minX = e, this.minY = r, this.maxX = D, this.maxY = N;
    }, o.prototype.addFrame = function(t, e, r, D, N) {
      this.addFrameMatrix(t.worldTransform, e, r, D, N);
    }, o.prototype.addFrameMatrix = function(t, e, r, D, N) {
      var k = t.a, $ = t.b, G = t.c, U = t.d, z = t.tx, X = t.ty, V = this.minX, Y = this.minY, W = this.maxX, q = this.maxY, K = k * e + G * r + z, Z = $ * e + U * r + X;
      V = K < V ? K : V, Y = Z < Y ? Z : Y, W = K > W ? K : W, q = Z > q ? Z : q, K = k * D + G * r + z, Z = $ * D + U * r + X, V = K < V ? K : V, Y = Z < Y ? Z : Y, W = K > W ? K : W, q = Z > q ? Z : q, K = k * e + G * N + z, Z = $ * e + U * N + X, V = K < V ? K : V, Y = Z < Y ? Z : Y, W = K > W ? K : W, q = Z > q ? Z : q, K = k * D + G * N + z, Z = $ * D + U * N + X, V = K < V ? K : V, Y = Z < Y ? Z : Y, W = K > W ? K : W, q = Z > q ? Z : q, this.minX = V, this.minY = Y, this.maxX = W, this.maxY = q;
    }, o.prototype.addVertexData = function(t, e, r) {
      for (var D = this.minX, N = this.minY, k = this.maxX, $ = this.maxY, G = e; G < r; G += 2) {
        var U = t[G], z = t[G + 1];
        D = U < D ? U : D, N = z < N ? z : N, k = U > k ? U : k, $ = z > $ ? z : $;
      }
      this.minX = D, this.minY = N, this.maxX = k, this.maxY = $;
    }, o.prototype.addVertices = function(t, e, r, D) {
      this.addVerticesMatrix(t.worldTransform, e, r, D);
    }, o.prototype.addVerticesMatrix = function(t, e, r, D, N, k) {
      N === void 0 && (N = 0), k === void 0 && (k = N);
      for (var $ = t.a, G = t.b, U = t.c, z = t.d, X = t.tx, V = t.ty, Y = this.minX, W = this.minY, q = this.maxX, K = this.maxY, Z = r; Z < D; Z += 2) {
        var J = e[Z], Q = e[Z + 1], et = $ * J + U * Q + X, it = z * Q + G * J + V;
        Y = Math.min(Y, et - N), q = Math.max(q, et + N), W = Math.min(W, it - k), K = Math.max(K, it + k);
      }
      this.minX = Y, this.minY = W, this.maxX = q, this.maxY = K;
    }, o.prototype.addBounds = function(t) {
      var e = this.minX, r = this.minY, D = this.maxX, N = this.maxY;
      this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < r ? t.minY : r, this.maxX = t.maxX > D ? t.maxX : D, this.maxY = t.maxY > N ? t.maxY : N;
    }, o.prototype.addBoundsMask = function(t, e) {
      var r = t.minX > e.minX ? t.minX : e.minX, D = t.minY > e.minY ? t.minY : e.minY, N = t.maxX < e.maxX ? t.maxX : e.maxX, k = t.maxY < e.maxY ? t.maxY : e.maxY;
      if (r <= N && D <= k) {
        var $ = this.minX, G = this.minY, U = this.maxX, z = this.maxY;
        this.minX = r < $ ? r : $, this.minY = D < G ? D : G, this.maxX = N > U ? N : U, this.maxY = k > z ? k : z;
      }
    }, o.prototype.addBoundsMatrix = function(t, e) {
      this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);
    }, o.prototype.addBoundsArea = function(t, e) {
      var r = t.minX > e.x ? t.minX : e.x, D = t.minY > e.y ? t.minY : e.y, N = t.maxX < e.x + e.width ? t.maxX : e.x + e.width, k = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
      if (r <= N && D <= k) {
        var $ = this.minX, G = this.minY, U = this.maxX, z = this.maxY;
        this.minX = r < $ ? r : $, this.minY = D < G ? D : G, this.maxX = N > U ? N : U, this.maxY = k > z ? k : z;
      }
    }, o.prototype.pad = function(t, e) {
      t === void 0 && (t = 0), e === void 0 && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e);
    }, o.prototype.addFramePad = function(t, e, r, D, N, k) {
      t -= N, e -= k, r += N, D += k, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > r ? this.maxX : r, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > D ? this.maxY : D;
    }, o;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$p = function(o, t) {
  return extendStatics$p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$p(o, t);
};
function __extends$p(o, t) {
  extendStatics$p(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var DisplayObject = (
  /** @class */
  function(o) {
    __extends$p(t, o);
    function t() {
      var e = o.call(this) || this;
      return e.tempDisplayObjectParent = null, e.transform = new Transform(), e.alpha = 1, e.visible = !0, e.renderable = !0, e.cullable = !1, e.cullArea = null, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new Bounds(), e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._maskRefCount = 0, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e;
    }
    return t.mixin = function(e) {
      for (var r = Object.keys(e), D = 0; D < r.length; ++D) {
        var N = r[D];
        Object.defineProperty(t.prototype, N, Object.getOwnPropertyDescriptor(e, N));
      }
    }, Object.defineProperty(t.prototype, "destroyed", {
      /**
       * Fired when this DisplayObject is added to a Container.
       * @instance
       * @event added
       * @param {PIXI.Container} container - The container added to.
       */
      /**
       * Fired when this DisplayObject is removed from a Container.
       * @instance
       * @event removed
       * @param {PIXI.Container} container - The container removed from.
       */
      /**
       * Fired when this DisplayObject is destroyed. This event is emitted once
       * destroy is finished.
       * @instance
       * @event destroyed
       */
      /** Readonly flag for destroyed display objects. */
      get: function() {
        return this._destroyed;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype._recursivePostUpdateTransform = function() {
      this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }, t.prototype.updateTransform = function() {
      this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
    }, t.prototype.getBounds = function(e, r) {
      return e || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), r || (this._boundsRect || (this._boundsRect = new Rectangle()), r = this._boundsRect), this._bounds.getRectangle(r);
    }, t.prototype.getLocalBounds = function(e) {
      e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds || (this._localBounds = new Bounds());
      var r = this.transform, D = this.parent;
      this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
      var N = this._bounds, k = this._boundsID;
      this._bounds = this._localBounds;
      var $ = this.getBounds(!1, e);
      return this.parent = D, this.transform = r, this._bounds = N, this._bounds.updateID += this._boundsID - k, $;
    }, t.prototype.toGlobal = function(e, r, D) {
      return D === void 0 && (D = !1), D || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(e, r);
    }, t.prototype.toLocal = function(e, r, D, N) {
      return r && (e = r.toGlobal(e, D, N)), N || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(e, D);
    }, t.prototype.setParent = function(e) {
      if (!e || !e.addChild)
        throw new Error("setParent: Argument must be a Container");
      return e.addChild(this), e;
    }, t.prototype.setTransform = function(e, r, D, N, k, $, G, U, z) {
      return e === void 0 && (e = 0), r === void 0 && (r = 0), D === void 0 && (D = 1), N === void 0 && (N = 1), k === void 0 && (k = 0), $ === void 0 && ($ = 0), G === void 0 && (G = 0), U === void 0 && (U = 0), z === void 0 && (z = 0), this.position.x = e, this.position.y = r, this.scale.x = D || 1, this.scale.y = N || 1, this.rotation = k, this.skew.x = $, this.skew.y = G, this.pivot.x = U, this.pivot.y = z, this;
    }, t.prototype.destroy = function(e) {
      this.parent && this.parent.removeChild(this), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners();
    }, Object.defineProperty(t.prototype, "_tempDisplayObjectParent", {
      /**
       * @protected
       * @member {PIXI.Container}
       */
      get: function() {
        return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new TemporaryDisplayObject()), this.tempDisplayObjectParent;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.enableTempParent = function() {
      var e = this.parent;
      return this.parent = this._tempDisplayObjectParent, e;
    }, t.prototype.disableTempParent = function(e) {
      this.parent = e;
    }, Object.defineProperty(t.prototype, "x", {
      /**
       * The position of the displayObject on the x axis relative to the local coordinates of the parent.
       * An alias to position.x
       */
      get: function() {
        return this.position.x;
      },
      set: function(e) {
        this.transform.position.x = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "y", {
      /**
       * The position of the displayObject on the y axis relative to the local coordinates of the parent.
       * An alias to position.y
       */
      get: function() {
        return this.position.y;
      },
      set: function(e) {
        this.transform.position.y = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "worldTransform", {
      /**
       * Current transform of the object based on world (parent) factors.
       * @readonly
       */
      get: function() {
        return this.transform.worldTransform;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "localTransform", {
      /**
       * Current transform of the object based on local factors: position, scale, other stuff.
       * @readonly
       */
      get: function() {
        return this.transform.localTransform;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "position", {
      /**
       * The coordinate of the object relative to the local coordinates of the parent.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.position;
      },
      set: function(e) {
        this.transform.position.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "scale", {
      /**
       * The scale factors of this object along the local coordinate axes.
       *
       * The default scale is (1, 1).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.scale;
      },
      set: function(e) {
        this.transform.scale.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "pivot", {
      /**
       * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
       * is the projection of `pivot` in the parent's local space.
       *
       * By default, the pivot is the origin (0, 0).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.pivot;
      },
      set: function(e) {
        this.transform.pivot.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "skew", {
      /**
       * The skew factor for the object in radians.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.skew;
      },
      set: function(e) {
        this.transform.skew.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "rotation", {
      /**
       * The rotation of the object in radians.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation;
      },
      set: function(e) {
        this.transform.rotation = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "angle", {
      /**
       * The angle of the object in degrees.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation * RAD_TO_DEG;
      },
      set: function(e) {
        this.transform.rotation = e * DEG_TO_RAD;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "zIndex", {
      /**
       * The zIndex of the displayObject.
       *
       * If a container has the sortableChildren property set to true, children will be automatically
       * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
       * and thus rendered on top of other display objects within the same container.
       * @see PIXI.Container#sortableChildren
       */
      get: function() {
        return this._zIndex;
      },
      set: function(e) {
        this._zIndex = e, this.parent && (this.parent.sortDirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "worldVisible", {
      /**
       * Indicates if the object is globally visible.
       * @readonly
       */
      get: function() {
        var e = this;
        do {
          if (!e.visible)
            return !1;
          e = e.parent;
        } while (e);
        return !0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "mask", {
      /**
       * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
       * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
       * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
       * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
       * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
       * To remove a mask, set this property to `null`.
       *
       * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
       * @example
       * const graphics = new PIXI.Graphics();
       * graphics.beginFill(0xFF3300);
       * graphics.drawRect(50, 250, 100, 100);
       * graphics.endFill();
       *
       * const sprite = new PIXI.Sprite(texture);
       * sprite.mask = graphics;
       * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
       */
      get: function() {
        return this._mask;
      },
      set: function(e) {
        if (this._mask !== e) {
          if (this._mask) {
            var r = this._mask.isMaskData ? this._mask.maskObject : this._mask;
            r && (r._maskRefCount--, r._maskRefCount === 0 && (r.renderable = !0, r.isMask = !1));
          }
          if (this._mask = e, this._mask) {
            var r = this._mask.isMaskData ? this._mask.maskObject : this._mask;
            r && (r._maskRefCount === 0 && (r.renderable = !1, r.isMask = !0), r._maskRefCount++);
          }
        }
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(i$1)
), TemporaryDisplayObject = (
  /** @class */
  function(o) {
    __extends$p(t, o);
    function t() {
      var e = o !== null && o.apply(this, arguments) || this;
      return e.sortDirty = null, e;
    }
    return t;
  }(DisplayObject)
);
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
function sortChildren(o, t) {
  return o.zIndex === t.zIndex ? o._lastSortedIndex - t._lastSortedIndex : o.zIndex - t.zIndex;
}
var Container = (
  /** @class */
  function(o) {
    __extends$p(t, o);
    function t() {
      var e = o.call(this) || this;
      return e.children = [], e.sortableChildren = settings.SORTABLE_CHILDREN, e.sortDirty = !1, e;
    }
    return t.prototype.onChildrenChange = function(e) {
    }, t.prototype.addChild = function() {
      for (var e = arguments, r = [], D = 0; D < arguments.length; D++)
        r[D] = e[D];
      if (r.length > 1)
        for (var N = 0; N < r.length; N++)
          this.addChild(r[N]);
      else {
        var k = r[0];
        k.parent && k.parent.removeChild(k), k.parent = this, this.sortDirty = !0, k.transform._parentID = -1, this.children.push(k), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", k, this, this.children.length - 1), k.emit("added", this);
      }
      return r[0];
    }, t.prototype.addChildAt = function(e, r) {
      if (r < 0 || r > this.children.length)
        throw new Error(e + "addChildAt: The index " + r + " supplied is out of bounds " + this.children.length);
      return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(r, 0, e), this._boundsID++, this.onChildrenChange(r), e.emit("added", this), this.emit("childAdded", e, this, r), e;
    }, t.prototype.swapChildren = function(e, r) {
      if (e !== r) {
        var D = this.getChildIndex(e), N = this.getChildIndex(r);
        this.children[D] = r, this.children[N] = e, this.onChildrenChange(D < N ? D : N);
      }
    }, t.prototype.getChildIndex = function(e) {
      var r = this.children.indexOf(e);
      if (r === -1)
        throw new Error("The supplied DisplayObject must be a child of the caller");
      return r;
    }, t.prototype.setChildIndex = function(e, r) {
      if (r < 0 || r >= this.children.length)
        throw new Error("The index " + r + " supplied is out of bounds " + this.children.length);
      var D = this.getChildIndex(e);
      removeItems(this.children, D, 1), this.children.splice(r, 0, e), this.onChildrenChange(r);
    }, t.prototype.getChildAt = function(e) {
      if (e < 0 || e >= this.children.length)
        throw new Error("getChildAt: Index (" + e + ") does not exist.");
      return this.children[e];
    }, t.prototype.removeChild = function() {
      for (var e = arguments, r = [], D = 0; D < arguments.length; D++)
        r[D] = e[D];
      if (r.length > 1)
        for (var N = 0; N < r.length; N++)
          this.removeChild(r[N]);
      else {
        var k = r[0], $ = this.children.indexOf(k);
        if ($ === -1)
          return null;
        k.parent = null, k.transform._parentID = -1, removeItems(this.children, $, 1), this._boundsID++, this.onChildrenChange($), k.emit("removed", this), this.emit("childRemoved", k, this, $);
      }
      return r[0];
    }, t.prototype.removeChildAt = function(e) {
      var r = this.getChildAt(e);
      return r.parent = null, r.transform._parentID = -1, removeItems(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), r.emit("removed", this), this.emit("childRemoved", r, this, e), r;
    }, t.prototype.removeChildren = function(e, r) {
      e === void 0 && (e = 0), r === void 0 && (r = this.children.length);
      var D = e, N = r, k = N - D, $;
      if (k > 0 && k <= N) {
        $ = this.children.splice(D, k);
        for (var G = 0; G < $.length; ++G)
          $[G].parent = null, $[G].transform && ($[G].transform._parentID = -1);
        this._boundsID++, this.onChildrenChange(e);
        for (var G = 0; G < $.length; ++G)
          $[G].emit("removed", this), this.emit("childRemoved", $[G], this, G);
        return $;
      } else if (k === 0 && this.children.length === 0)
        return [];
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    }, t.prototype.sortChildren = function() {
      for (var e = !1, r = 0, D = this.children.length; r < D; ++r) {
        var N = this.children[r];
        N._lastSortedIndex = r, !e && N.zIndex !== 0 && (e = !0);
      }
      e && this.children.length > 1 && this.children.sort(sortChildren), this.sortDirty = !1;
    }, t.prototype.updateTransform = function() {
      this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (var e = 0, r = this.children.length; e < r; ++e) {
        var D = this.children[e];
        D.visible && D.updateTransform();
      }
    }, t.prototype.calculateBounds = function() {
      this._bounds.clear(), this._calculateBounds();
      for (var e = 0; e < this.children.length; e++) {
        var r = this.children[e];
        if (!(!r.visible || !r.renderable))
          if (r.calculateBounds(), r._mask) {
            var D = r._mask.isMaskData ? r._mask.maskObject : r._mask;
            D ? (D.calculateBounds(), this._bounds.addBoundsMask(r._bounds, D._bounds)) : this._bounds.addBounds(r._bounds);
          } else
            r.filterArea ? this._bounds.addBoundsArea(r._bounds, r.filterArea) : this._bounds.addBounds(r._bounds);
      }
      this._bounds.updateID = this._boundsID;
    }, t.prototype.getLocalBounds = function(e, r) {
      r === void 0 && (r = !1);
      var D = o.prototype.getLocalBounds.call(this, e);
      if (!r)
        for (var N = 0, k = this.children.length; N < k; ++N) {
          var $ = this.children[N];
          $.visible && $.updateTransform();
        }
      return D;
    }, t.prototype._calculateBounds = function() {
    }, t.prototype._renderWithCulling = function(e) {
      var r = e.renderTexture.sourceFrame;
      if (r.width > 0 && r.height > 0) {
        var D, N;
        if (this.cullArea ? (D = this.cullArea, N = this.worldTransform) : this._render !== t.prototype._render && (D = this.getBounds(!0)), D && r.intersects(D, N))
          this._render(e);
        else if (this.cullArea)
          return;
        for (var k = 0, $ = this.children.length; k < $; ++k) {
          var G = this.children[k], U = G.cullable;
          G.cullable = U || !this.cullArea, G.render(e), G.cullable = U;
        }
      }
    }, t.prototype.render = function(e) {
      if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
        if (this._mask || this.filters && this.filters.length)
          this.renderAdvanced(e);
        else if (this.cullable)
          this._renderWithCulling(e);
        else {
          this._render(e);
          for (var r = 0, D = this.children.length; r < D; ++r)
            this.children[r].render(e);
        }
    }, t.prototype.renderAdvanced = function(e) {
      var r = this.filters, D = this._mask;
      if (r) {
        this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
        for (var N = 0; N < r.length; N++)
          r[N].enabled && this._enabledFilters.push(r[N]);
      }
      var k = r && this._enabledFilters && this._enabledFilters.length || D && (!D.isMaskData || D.enabled && (D.autoDetect || D.type !== MASK_TYPES.NONE));
      if (k && e.batch.flush(), r && this._enabledFilters && this._enabledFilters.length && e.filter.push(this, this._enabledFilters), D && e.mask.push(this, this._mask), this.cullable)
        this._renderWithCulling(e);
      else {
        this._render(e);
        for (var N = 0, $ = this.children.length; N < $; ++N)
          this.children[N].render(e);
      }
      k && e.batch.flush(), D && e.mask.pop(this), r && this._enabledFilters && this._enabledFilters.length && e.filter.pop();
    }, t.prototype._render = function(e) {
    }, t.prototype.destroy = function(e) {
      o.prototype.destroy.call(this), this.sortDirty = !1;
      var r = typeof e == "boolean" ? e : e && e.children, D = this.removeChildren(0, this.children.length);
      if (r)
        for (var N = 0; N < D.length; ++N)
          D[N].destroy(e);
    }, Object.defineProperty(t.prototype, "width", {
      /** The width of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.x * this.getLocalBounds().width;
      },
      set: function(e) {
        var r = this.getLocalBounds().width;
        r !== 0 ? this.scale.x = e / r : this.scale.x = 1, this._width = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.y * this.getLocalBounds().height;
      },
      set: function(e) {
        var r = this.getLocalBounds().height;
        r !== 0 ? this.scale.y = e / r : this.scale.y = 1, this._height = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(DisplayObject)
);
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
/*!
 * @pixi/extensions - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/extensions is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$8 = function() {
  return __assign$8 = Object.assign || function(t) {
    for (var e = arguments, r, D = 1, N = arguments.length; D < N; D++) {
      r = e[D];
      for (var k in r)
        Object.prototype.hasOwnProperty.call(r, k) && (t[k] = r[k]);
    }
    return t;
  }, __assign$8.apply(this, arguments);
}, ExtensionType;
(function(o) {
  o.Application = "application", o.RendererPlugin = "renderer-webgl-plugin", o.CanvasRendererPlugin = "renderer-canvas-plugin", o.Loader = "loader", o.LoadParser = "load-parser", o.ResolveParser = "resolve-parser", o.CacheParser = "cache-parser", o.DetectionParser = "detection-parser";
})(ExtensionType || (ExtensionType = {}));
var normalizeExtension = function(o) {
  if (typeof o == "function" || typeof o == "object" && o.extension) {
    if (!o.extension)
      throw new Error("Extension class must have an extension object");
    var t = typeof o.extension != "object" ? { type: o.extension } : o.extension;
    o = __assign$8(__assign$8({}, t), { ref: o });
  }
  if (typeof o == "object")
    o = __assign$8({}, o);
  else
    throw new Error("Invalid extension type");
  return typeof o.type == "string" && (o.type = [o.type]), o;
}, extensions = {
  /** @ignore */
  _addHandlers: null,
  /** @ignore */
  _removeHandlers: null,
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {PIXI.extensions} For chaining.
   */
  remove: function() {
    for (var o = arguments, t = this, e = [], r = 0; r < arguments.length; r++)
      e[r] = o[r];
    return e.map(normalizeExtension).forEach(function(D) {
      D.type.forEach(function(N) {
        var k, $;
        return ($ = (k = t._removeHandlers)[N]) === null || $ === void 0 ? void 0 : $.call(k, D);
      });
    }), this;
  },
  /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {PIXI.extensions} For chaining.
   */
  add: function() {
    for (var o = arguments, t = this, e = [], r = 0; r < arguments.length; r++)
      e[r] = o[r];
    return e.map(normalizeExtension).forEach(function(D) {
      D.type.forEach(function(N) {
        var k = t._addHandlers, $ = t._queue;
        k[N] ? k[N](D) : ($[N] = $[N] || [], $[N].push(D));
      });
    }), this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.
   * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.
   * @returns {PIXI.extensions} For chaining.
   */
  handle: function(o, t, e) {
    var r = this._addHandlers = this._addHandlers || {}, D = this._removeHandlers = this._removeHandlers || {};
    if (r[o] || D[o])
      throw new Error("Extension type " + o + " already has a handler");
    r[o] = t, D[o] = e;
    var N = this._queue;
    return N[o] && (N[o].forEach(function(k) {
      return t(k);
    }), delete N[o]), this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByMap: function(o, t) {
    return this.handle(o, function(e) {
      t[e.name] = e.ref;
    }, function(e) {
      delete t[e.name];
    });
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByList: function(o, t) {
    return this.handle(o, function(e) {
      var r, D;
      t.includes(e.ref) || (t.push(e.ref), o === ExtensionType.Loader && ((D = (r = e.ref).add) === null || D === void 0 || D.call(r)));
    }, function(e) {
      var r = t.indexOf(e.ref);
      r !== -1 && t.splice(r, 1);
    });
  }
};
/*!
 * @pixi/runner - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Runner = (
  /** @class */
  function() {
    function o(t) {
      this.items = [], this._name = t, this._aliasCount = 0;
    }
    return o.prototype.emit = function(t, e, r, D, N, k, $, G) {
      if (arguments.length > 8)
        throw new Error("max arguments reached");
      var U = this, z = U.name, X = U.items;
      this._aliasCount++;
      for (var V = 0, Y = X.length; V < Y; V++)
        X[V][z](t, e, r, D, N, k, $, G);
      return X === this.items && this._aliasCount--, this;
    }, o.prototype.ensureNonAliasedItems = function() {
      this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
    }, o.prototype.add = function(t) {
      return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this;
    }, o.prototype.remove = function(t) {
      var e = this.items.indexOf(t);
      return e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this;
    }, o.prototype.contains = function(t) {
      return this.items.indexOf(t) !== -1;
    }, o.prototype.removeAll = function() {
      return this.ensureNonAliasedItems(), this.items.length = 0, this;
    }, o.prototype.destroy = function() {
      this.removeAll(), this.items = null, this._name = null;
    }, Object.defineProperty(o.prototype, "empty", {
      /**
       * `true` if there are no this Runner contains no listeners
       * @readonly
       */
      get: function() {
        return this.items.length === 0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "name", {
      /**
       * The name of the runner.
       * @readonly
       */
      get: function() {
        return this._name;
      },
      enumerable: !1,
      configurable: !0
    }), o;
  }()
);
Object.defineProperties(Runner.prototype, {
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method dispatch
   * @see PIXI.Runner#emit
   */
  dispatch: { value: Runner.prototype.emit },
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method run
   * @see PIXI.Runner#emit
   */
  run: { value: Runner.prototype.emit }
});
/*!
 * @pixi/ticker - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/ticker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.TARGET_FPMS = 0.06;
var UPDATE_PRIORITY;
(function(o) {
  o[o.INTERACTION = 50] = "INTERACTION", o[o.HIGH = 25] = "HIGH", o[o.NORMAL = 0] = "NORMAL", o[o.LOW = -25] = "LOW", o[o.UTILITY = -50] = "UTILITY";
})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
var TickerListener = (
  /** @class */
  function() {
    function o(t, e, r, D) {
      e === void 0 && (e = null), r === void 0 && (r = 0), D === void 0 && (D = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = r, this.once = D;
    }
    return o.prototype.match = function(t, e) {
      return e === void 0 && (e = null), this.fn === t && this.context === e;
    }, o.prototype.emit = function(t) {
      this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
      var e = this.next;
      return this.once && this.destroy(!0), this._destroyed && (this.next = null), e;
    }, o.prototype.connect = function(t) {
      this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
    }, o.prototype.destroy = function(t) {
      t === void 0 && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
      var e = this.next;
      return this.next = t ? null : e, this.previous = null, e;
    }, o;
  }()
), Ticker = (
  /** @class */
  function() {
    function o() {
      var t = this;
      this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new TickerListener(null, null, 1 / 0), this.deltaMS = 1 / settings.TARGET_FPMS, this.elapsedMS = 1 / settings.TARGET_FPMS, this._tick = function(e) {
        t._requestId = null, t.started && (t.update(e), t.started && t._requestId === null && t._head.next && (t._requestId = requestAnimationFrame(t._tick)));
      };
    }
    return o.prototype._requestIfNeeded = function() {
      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
    }, o.prototype._cancelIfNeeded = function() {
      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }, o.prototype._startIfPossible = function() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }, o.prototype.add = function(t, e, r) {
      return r === void 0 && (r = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, r));
    }, o.prototype.addOnce = function(t, e, r) {
      return r === void 0 && (r = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, r, !0));
    }, o.prototype._addListener = function(t) {
      var e = this._head.next, r = this._head;
      if (!e)
        t.connect(r);
      else {
        for (; e; ) {
          if (t.priority > e.priority) {
            t.connect(r);
            break;
          }
          r = e, e = e.next;
        }
        t.previous || t.connect(r);
      }
      return this._startIfPossible(), this;
    }, o.prototype.remove = function(t, e) {
      for (var r = this._head.next; r; )
        r.match(t, e) ? r = r.destroy() : r = r.next;
      return this._head.next || this._cancelIfNeeded(), this;
    }, Object.defineProperty(o.prototype, "count", {
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       * @readonly
       * @member {number}
       */
      get: function() {
        if (!this._head)
          return 0;
        for (var t = 0, e = this._head; e = e.next; )
          t++;
        return t;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.start = function() {
      this.started || (this.started = !0, this._requestIfNeeded());
    }, o.prototype.stop = function() {
      this.started && (this.started = !1, this._cancelIfNeeded());
    }, o.prototype.destroy = function() {
      if (!this._protected) {
        this.stop();
        for (var t = this._head.next; t; )
          t = t.destroy(!0);
        this._head.destroy(), this._head = null;
      }
    }, o.prototype.update = function(t) {
      t === void 0 && (t = performance.now());
      var e;
      if (t > this.lastTime) {
        if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
          var r = t - this._lastFrame | 0;
          if (r < this._minElapsedMS)
            return;
          this._lastFrame = t - r % this._minElapsedMS;
        }
        this.deltaMS = e, this.deltaTime = this.deltaMS * settings.TARGET_FPMS;
        for (var D = this._head, N = D.next; N; )
          N = N.emit(this.deltaTime);
        D.next || this._cancelIfNeeded();
      } else
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = t;
    }, Object.defineProperty(o.prototype, "FPS", {
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link PIXI.Ticker#speed}, which is specific
       * to scaling {@link PIXI.Ticker#deltaTime}.
       * @member {number}
       * @readonly
       */
      get: function() {
        return 1e3 / this.elapsedMS;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "minFPS", {
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This value is used to cap {@link PIXI.Ticker#deltaTime},
       * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
       * @member {number}
       * @default 10
       */
      get: function() {
        return 1e3 / this._maxElapsedMS;
      },
      set: function(t) {
        var e = Math.min(this.maxFPS, t), r = Math.min(Math.max(0, e) / 1e3, settings.TARGET_FPMS);
        this._maxElapsedMS = 1 / r;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "maxFPS", {
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This will effect the measured value of {@link PIXI.Ticker#FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @member {number}
       * @default 0
       */
      get: function() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
      },
      set: function(t) {
        if (t === 0)
          this._minElapsedMS = 0;
        else {
          var e = Math.max(this.minFPS, t);
          this._minElapsedMS = 1 / (e / 1e3);
        }
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o, "shared", {
      /**
       * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
       * {@link PIXI.VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * let ticker = PIXI.Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the PIXI.Ticker.shared instance.
       * ticker.autoStart = false;
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * // You may use the shared ticker to render...
       * let renderer = PIXI.autoDetectRenderer();
       * let stage = new PIXI.Container();
       * document.body.appendChild(renderer.view);
       * ticker.add(function (time) {
       *     renderer.render(stage);
       * });
       * @example
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * function animate(time) {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * }
       * animate(performance.now());
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!o._shared) {
          var t = o._shared = new o();
          t.autoStart = !0, t._protected = !0;
        }
        return o._shared;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o, "system", {
      /**
       * The system ticker instance used by {@link PIXI.InteractionManager} and by
       * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
       * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!o._system) {
          var t = o._system = new o();
          t.autoStart = !0, t._protected = !0;
        }
        return o._system;
      },
      enumerable: !1,
      configurable: !0
    }), o;
  }()
), TickerPlugin = (
  /** @class */
  function() {
    function o() {
    }
    return o.init = function(t) {
      var e = this;
      t = Object.assign({
        autoStart: !0,
        sharedTicker: !1
      }, t), Object.defineProperty(this, "ticker", {
        set: function(r) {
          this._ticker && this._ticker.remove(this.render, this), this._ticker = r, r && r.add(this.render, this, UPDATE_PRIORITY.LOW);
        },
        get: function() {
          return this._ticker;
        }
      }), this.stop = function() {
        e._ticker.stop();
      }, this.start = function() {
        e._ticker.start();
      }, this._ticker = null, this.ticker = t.sharedTicker ? Ticker.shared : new Ticker(), t.autoStart && this.start();
    }, o.destroy = function() {
      if (this._ticker) {
        var t = this._ticker;
        this.ticker = null, t.destroy();
      }
    }, o.extension = ExtensionType.Application, o;
  }()
);
/*!
 * @pixi/core - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.PREFER_ENV = isMobile.any ? ENV.WEBGL : ENV.WEBGL2;
settings.STRICT_TEXTURE_CACHE = !1;
var INSTALLED = [];
function autoDetectResource(o, t) {
  if (!o)
    return null;
  var e = "";
  if (typeof o == "string") {
    var r = /\.(\w{3,4})(?:$|\?|#)/i.exec(o);
    r && (e = r[1].toLowerCase());
  }
  for (var D = INSTALLED.length - 1; D >= 0; --D) {
    var N = INSTALLED[D];
    if (N.test && N.test(o, e))
      return new N(o, t);
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$o = function(o, t) {
  return extendStatics$o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$o(o, t);
};
function __extends$o(o, t) {
  extendStatics$o(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$7 = function() {
  return __assign$7 = Object.assign || function(t) {
    for (var e = arguments, r, D = 1, N = arguments.length; D < N; D++) {
      r = e[D];
      for (var k in r)
        Object.prototype.hasOwnProperty.call(r, k) && (t[k] = r[k]);
    }
    return t;
  }, __assign$7.apply(this, arguments);
};
function __rest$3(o, t) {
  var e = {};
  for (var r in o)
    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var D = 0, r = Object.getOwnPropertySymbols(o); D < r.length; D++)
      t.indexOf(r[D]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[D]) && (e[r[D]] = o[r[D]]);
  return e;
}
var Resource = (
  /** @class */
  function() {
    function o(t, e) {
      t === void 0 && (t = 0), e === void 0 && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new Runner("setRealSize"), this.onUpdate = new Runner("update"), this.onError = new Runner("onError");
    }
    return o.prototype.bind = function(t) {
      this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height);
    }, o.prototype.unbind = function(t) {
      this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t);
    }, o.prototype.resize = function(t, e) {
      (t !== this._width || e !== this._height) && (this._width = t, this._height = e, this.onResize.emit(t, e));
    }, Object.defineProperty(o.prototype, "valid", {
      /**
       * Has been validated
       * @readonly
       */
      get: function() {
        return !!this._width && !!this._height;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.update = function() {
      this.destroyed || this.onUpdate.emit();
    }, o.prototype.load = function() {
      return Promise.resolve(this);
    }, Object.defineProperty(o.prototype, "width", {
      /**
       * The width of the resource.
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "height", {
      /**
       * The height of the resource.
       * @readonly
       */
      get: function() {
        return this._height;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.style = function(t, e, r) {
      return !1;
    }, o.prototype.dispose = function() {
    }, o.prototype.destroy = function() {
      this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
    }, o.test = function(t, e) {
      return !1;
    }, o;
  }()
), BufferResource = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e, r) {
      var D = this, N = r || {}, k = N.width, $ = N.height;
      if (!k || !$)
        throw new Error("BufferResource width or height invalid");
      return D = o.call(this, k, $) || this, D.data = e, D;
    }
    return t.prototype.upload = function(e, r, D) {
      var N = e.gl;
      N.pixelStorei(N.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === ALPHA_MODES.UNPACK);
      var k = r.realWidth, $ = r.realHeight;
      return D.width === k && D.height === $ ? N.texSubImage2D(r.target, 0, 0, 0, k, $, r.format, D.type, this.data) : (D.width = k, D.height = $, N.texImage2D(r.target, 0, D.internalFormat, k, $, 0, r.format, D.type, this.data)), !0;
    }, t.prototype.dispose = function() {
      this.data = null;
    }, t.test = function(e) {
      return e instanceof Float32Array || e instanceof Uint8Array || e instanceof Uint32Array;
    }, t;
  }(Resource)
), defaultBufferOptions = {
  scaleMode: SCALE_MODES.NEAREST,
  format: FORMATS.RGBA,
  alphaMode: ALPHA_MODES.NPM
}, BaseTexture = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e, r) {
      e === void 0 && (e = null), r === void 0 && (r = null);
      var D = o.call(this) || this;
      r = r || {};
      var N = r.alphaMode, k = r.mipmap, $ = r.anisotropicLevel, G = r.scaleMode, U = r.width, z = r.height, X = r.wrapMode, V = r.format, Y = r.type, W = r.target, q = r.resolution, K = r.resourceOptions;
      return e && !(e instanceof Resource) && (e = autoDetectResource(e, K), e.internal = !0), D.resolution = q || settings.RESOLUTION, D.width = Math.round((U || 0) * D.resolution) / D.resolution, D.height = Math.round((z || 0) * D.resolution) / D.resolution, D._mipmap = k !== void 0 ? k : settings.MIPMAP_TEXTURES, D.anisotropicLevel = $ !== void 0 ? $ : settings.ANISOTROPIC_LEVEL, D._wrapMode = X || settings.WRAP_MODE, D._scaleMode = G !== void 0 ? G : settings.SCALE_MODE, D.format = V || FORMATS.RGBA, D.type = Y || TYPES.UNSIGNED_BYTE, D.target = W || TARGETS.TEXTURE_2D, D.alphaMode = N !== void 0 ? N : ALPHA_MODES.UNPACK, D.uid = uid(), D.touched = 0, D.isPowerOfTwo = !1, D._refreshPOT(), D._glTextures = {}, D.dirtyId = 0, D.dirtyStyleId = 0, D.cacheId = null, D.valid = U > 0 && z > 0, D.textureCacheIds = [], D.destroyed = !1, D.resource = null, D._batchEnabled = 0, D._batchLocation = 0, D.parentTextureArray = null, D.setResource(e), D;
    }
    return Object.defineProperty(t.prototype, "realWidth", {
      /**
       * Pixel width of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.width * this.resolution);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "realHeight", {
      /**
       * Pixel height of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.height * this.resolution);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "mipmap", {
      /**
       * Mipmap mode of the texture, affects downscaled images
       * @default PIXI.settings.MIPMAP_TEXTURES
       */
      get: function() {
        return this._mipmap;
      },
      set: function(e) {
        this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "scaleMode", {
      /**
       * The scale mode to apply when scaling this texture
       * @default PIXI.settings.SCALE_MODE
       */
      get: function() {
        return this._scaleMode;
      },
      set: function(e) {
        this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "wrapMode", {
      /**
       * How the texture wraps
       * @default PIXI.settings.WRAP_MODE
       */
      get: function() {
        return this._wrapMode;
      },
      set: function(e) {
        this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++);
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.setStyle = function(e, r) {
      var D;
      return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e, D = !0), r !== void 0 && r !== this.mipmap && (this.mipmap = r, D = !0), D && this.dirtyStyleId++, this;
    }, t.prototype.setSize = function(e, r, D) {
      return D = D || this.resolution, this.setRealSize(e * D, r * D, D);
    }, t.prototype.setRealSize = function(e, r, D) {
      return this.resolution = D || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(r) / this.resolution, this._refreshPOT(), this.update(), this;
    }, t.prototype._refreshPOT = function() {
      this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
    }, t.prototype.setResolution = function(e) {
      var r = this.resolution;
      return r === e ? this : (this.resolution = e, this.valid && (this.width = Math.round(this.width * r) / e, this.height = Math.round(this.height * r) / e, this.emit("update", this)), this._refreshPOT(), this);
    }, t.prototype.setResource = function(e) {
      if (this.resource === e)
        return this;
      if (this.resource)
        throw new Error("Resource can be set only once");
      return e.bind(this), this.resource = e, this;
    }, t.prototype.update = function() {
      this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this));
    }, t.prototype.onError = function(e) {
      this.emit("error", this, e);
    }, t.prototype.destroy = function() {
      this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete BaseTextureCache[this.cacheId], delete TextureCache[this.cacheId], this.cacheId = null), this.dispose(), t.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0;
    }, t.prototype.dispose = function() {
      this.emit("dispose", this);
    }, t.prototype.castToBaseTexture = function() {
      return this;
    }, t.from = function(e, r, D) {
      D === void 0 && (D = settings.STRICT_TEXTURE_CACHE);
      var N = typeof e == "string", k = null;
      if (N)
        k = e;
      else {
        if (!e._pixiId) {
          var $ = r && r.pixiIdPrefix || "pixiid";
          e._pixiId = $ + "_" + uid();
        }
        k = e._pixiId;
      }
      var G = BaseTextureCache[k];
      if (N && D && !G)
        throw new Error('The cacheId "' + k + '" does not exist in BaseTextureCache.');
      return G || (G = new t(e, r), G.cacheId = k, t.addToCache(G, k)), G;
    }, t.fromBuffer = function(e, r, D, N) {
      e = e || new Float32Array(r * D * 4);
      var k = new BufferResource(e, { width: r, height: D }), $ = e instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
      return new t(k, Object.assign({}, defaultBufferOptions, N || { width: r, height: D, type: $ }));
    }, t.addToCache = function(e, r) {
      r && (e.textureCacheIds.indexOf(r) === -1 && e.textureCacheIds.push(r), BaseTextureCache[r] && console.warn("BaseTexture added to the cache with an id [" + r + "] that already had an entry"), BaseTextureCache[r] = e);
    }, t.removeFromCache = function(e) {
      if (typeof e == "string") {
        var r = BaseTextureCache[e];
        if (r) {
          var D = r.textureCacheIds.indexOf(e);
          return D > -1 && r.textureCacheIds.splice(D, 1), delete BaseTextureCache[e], r;
        }
      } else if (e && e.textureCacheIds) {
        for (var N = 0; N < e.textureCacheIds.length; ++N)
          delete BaseTextureCache[e.textureCacheIds[N]];
        return e.textureCacheIds.length = 0, e;
      }
      return null;
    }, t._globalBatch = 0, t;
  }(i$1)
), AbstractMultiResource = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e, r) {
      var D = this, N = r || {}, k = N.width, $ = N.height;
      D = o.call(this, k, $) || this, D.items = [], D.itemDirtyIds = [];
      for (var G = 0; G < e; G++) {
        var U = new BaseTexture();
        D.items.push(U), D.itemDirtyIds.push(-2);
      }
      return D.length = e, D._load = null, D.baseTexture = null, D;
    }
    return t.prototype.initFromArray = function(e, r) {
      for (var D = 0; D < this.length; D++)
        e[D] && (e[D].castToBaseTexture ? this.addBaseTextureAt(e[D].castToBaseTexture(), D) : e[D] instanceof Resource ? this.addResourceAt(e[D], D) : this.addResourceAt(autoDetectResource(e[D], r), D));
    }, t.prototype.dispose = function() {
      for (var e = 0, r = this.length; e < r; e++)
        this.items[e].destroy();
      this.items = null, this.itemDirtyIds = null, this._load = null;
    }, t.prototype.addResourceAt = function(e, r) {
      if (!this.items[r])
        throw new Error("Index " + r + " is out of bounds");
      return e.valid && !this.valid && this.resize(e.width, e.height), this.items[r].setResource(e), this;
    }, t.prototype.bind = function(e) {
      if (this.baseTexture !== null)
        throw new Error("Only one base texture per TextureArray is allowed");
      o.prototype.bind.call(this, e);
      for (var r = 0; r < this.length; r++)
        this.items[r].parentTextureArray = e, this.items[r].on("update", e.update, e);
    }, t.prototype.unbind = function(e) {
      o.prototype.unbind.call(this, e);
      for (var r = 0; r < this.length; r++)
        this.items[r].parentTextureArray = null, this.items[r].off("update", e.update, e);
    }, t.prototype.load = function() {
      var e = this;
      if (this._load)
        return this._load;
      var r = this.items.map(function(N) {
        return N.resource;
      }).filter(function(N) {
        return N;
      }), D = r.map(function(N) {
        return N.load();
      });
      return this._load = Promise.all(D).then(function() {
        var N = e.items[0], k = N.realWidth, $ = N.realHeight;
        return e.resize(k, $), Promise.resolve(e);
      }), this._load;
    }, t;
  }(Resource)
), ArrayResource = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e, r) {
      var D = this, N = r || {}, k = N.width, $ = N.height, G, U;
      return Array.isArray(e) ? (G = e, U = e.length) : U = e, D = o.call(this, U, { width: k, height: $ }) || this, G && D.initFromArray(G, r), D;
    }
    return t.prototype.addBaseTextureAt = function(e, r) {
      if (e.resource)
        this.addResourceAt(e.resource, r);
      else
        throw new Error("ArrayResource does not support RenderTexture");
      return this;
    }, t.prototype.bind = function(e) {
      o.prototype.bind.call(this, e), e.target = TARGETS.TEXTURE_2D_ARRAY;
    }, t.prototype.upload = function(e, r, D) {
      var N = this, k = N.length, $ = N.itemDirtyIds, G = N.items, U = e.gl;
      D.dirtyId < 0 && U.texImage3D(U.TEXTURE_2D_ARRAY, 0, D.internalFormat, this._width, this._height, k, 0, r.format, D.type, null);
      for (var z = 0; z < k; z++) {
        var X = G[z];
        $[z] < X.dirtyId && ($[z] = X.dirtyId, X.valid && U.texSubImage3D(
          U.TEXTURE_2D_ARRAY,
          0,
          0,
          // xoffset
          0,
          // yoffset
          z,
          // zoffset
          X.resource.width,
          X.resource.height,
          1,
          r.format,
          D.type,
          X.resource.source
        ));
      }
      return !0;
    }, t;
  }(AbstractMultiResource)
), BaseImageResource = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e) {
      var r = this, D = e, N = D.naturalWidth || D.videoWidth || D.width, k = D.naturalHeight || D.videoHeight || D.height;
      return r = o.call(this, N, k) || this, r.source = e, r.noSubImage = !1, r;
    }
    return t.crossOrigin = function(e, r, D) {
      D === void 0 && r.indexOf("data:") !== 0 ? e.crossOrigin = determineCrossOrigin(r) : D !== !1 && (e.crossOrigin = typeof D == "string" ? D : "anonymous");
    }, t.prototype.upload = function(e, r, D, N) {
      var k = e.gl, $ = r.realWidth, G = r.realHeight;
      if (N = N || this.source, N instanceof HTMLImageElement) {
        if (!N.complete || N.naturalWidth === 0)
          return !1;
      } else if (N instanceof HTMLVideoElement && N.readyState <= 1)
        return !1;
      return k.pixelStorei(k.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === ALPHA_MODES.UNPACK), !this.noSubImage && r.target === k.TEXTURE_2D && D.width === $ && D.height === G ? k.texSubImage2D(k.TEXTURE_2D, 0, 0, 0, r.format, D.type, N) : (D.width = $, D.height = G, k.texImage2D(r.target, 0, D.internalFormat, r.format, D.type, N)), !0;
    }, t.prototype.update = function() {
      if (!this.destroyed) {
        var e = this.source, r = e.naturalWidth || e.videoWidth || e.width, D = e.naturalHeight || e.videoHeight || e.height;
        this.resize(r, D), o.prototype.update.call(this);
      }
    }, t.prototype.dispose = function() {
      this.source = null;
    }, t;
  }(Resource)
), CanvasResource = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e) {
      return o.call(this, e) || this;
    }
    return t.test = function(e) {
      var r = globalThis.OffscreenCanvas;
      return r && e instanceof r ? !0 : globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement;
    }, t;
  }(BaseImageResource)
), CubeResource = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e, r) {
      var D = this, N = r || {}, k = N.width, $ = N.height, G = N.autoLoad, U = N.linkBaseTexture;
      if (e && e.length !== t.SIDES)
        throw new Error("Invalid length. Got " + e.length + ", expected 6");
      D = o.call(this, 6, { width: k, height: $ }) || this;
      for (var z = 0; z < t.SIDES; z++)
        D.items[z].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + z;
      return D.linkBaseTexture = U !== !1, e && D.initFromArray(e, r), G !== !1 && D.load(), D;
    }
    return t.prototype.bind = function(e) {
      o.prototype.bind.call(this, e), e.target = TARGETS.TEXTURE_CUBE_MAP;
    }, t.prototype.addBaseTextureAt = function(e, r, D) {
      if (!this.items[r])
        throw new Error("Index " + r + " is out of bounds");
      if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)
        if (e.resource)
          this.addResourceAt(e.resource, r);
        else
          throw new Error("CubeResource does not support copying of renderTexture.");
      else
        e.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + r, e.parentTextureArray = this.baseTexture, this.items[r] = e;
      return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[r] = e, this;
    }, t.prototype.upload = function(e, r, D) {
      for (var N = this.itemDirtyIds, k = 0; k < t.SIDES; k++) {
        var $ = this.items[k];
        (N[k] < $.dirtyId || D.dirtyId < r.dirtyId) && ($.valid && $.resource ? ($.resource.upload(e, $, D), N[k] = $.dirtyId) : N[k] < -1 && (e.gl.texImage2D($.target, 0, D.internalFormat, r.realWidth, r.realHeight, 0, r.format, D.type, null), N[k] = -1));
      }
      return !0;
    }, t.test = function(e) {
      return Array.isArray(e) && e.length === t.SIDES;
    }, t.SIDES = 6, t;
  }(AbstractMultiResource)
), ImageResource = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e, r) {
      var D = this;
      if (r = r || {}, !(e instanceof HTMLImageElement)) {
        var N = new Image();
        BaseImageResource.crossOrigin(N, e, r.crossorigin), N.src = e, e = N;
      }
      return D = o.call(this, e) || this, !e.complete && D._width && D._height && (D._width = 0, D._height = 0), D.url = e.src, D._process = null, D.preserveBitmap = !1, D.createBitmap = (r.createBitmap !== void 0 ? r.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, D.alphaMode = typeof r.alphaMode == "number" ? r.alphaMode : null, D.bitmap = null, D._load = null, r.autoLoad !== !1 && D.load(), D;
    }
    return t.prototype.load = function(e) {
      var r = this;
      return this._load ? this._load : (e !== void 0 && (this.createBitmap = e), this._load = new Promise(function(D, N) {
        var k = r.source;
        r.url = k.src;
        var $ = function() {
          r.destroyed || (k.onload = null, k.onerror = null, r.resize(k.width, k.height), r._load = null, r.createBitmap ? D(r.process()) : D(r));
        };
        k.complete && k.src ? $() : (k.onload = $, k.onerror = function(G) {
          N(G), r.onError.emit(G);
        });
      }), this._load);
    }, t.prototype.process = function() {
      var e = this, r = this.source;
      if (this._process !== null)
        return this._process;
      if (this.bitmap !== null || !globalThis.createImageBitmap)
        return Promise.resolve(this);
      var D = globalThis.createImageBitmap, N = !r.crossOrigin || r.crossOrigin === "anonymous";
      return this._process = fetch(r.src, {
        mode: N ? "cors" : "no-cors"
      }).then(function(k) {
        return k.blob();
      }).then(function(k) {
        return D(k, 0, 0, r.width, r.height, {
          premultiplyAlpha: e.alphaMode === null || e.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
        });
      }).then(function(k) {
        return e.destroyed ? Promise.reject() : (e.bitmap = k, e.update(), e._process = null, Promise.resolve(e));
      }), this._process;
    }, t.prototype.upload = function(e, r, D) {
      if (typeof this.alphaMode == "number" && (r.alphaMode = this.alphaMode), !this.createBitmap)
        return o.prototype.upload.call(this, e, r, D);
      if (!this.bitmap && (this.process(), !this.bitmap))
        return !1;
      if (o.prototype.upload.call(this, e, r, D, this.bitmap), !this.preserveBitmap) {
        var N = !0, k = r._glTextures;
        for (var $ in k) {
          var G = k[$];
          if (G !== D && G.dirtyId !== r.dirtyId) {
            N = !1;
            break;
          }
        }
        N && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
      }
      return !0;
    }, t.prototype.dispose = function() {
      this.source.onload = null, this.source.onerror = null, o.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
    }, t.test = function(e) {
      return typeof e == "string" || e instanceof HTMLImageElement;
    }, t;
  }(BaseImageResource)
), SVGResource = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e, r) {
      var D = this;
      return r = r || {}, D = o.call(this, settings.ADAPTER.createCanvas()) || this, D._width = 0, D._height = 0, D.svg = e, D.scale = r.scale || 1, D._overrideWidth = r.width, D._overrideHeight = r.height, D._resolve = null, D._crossorigin = r.crossorigin, D._load = null, r.autoLoad !== !1 && D.load(), D;
    }
    return t.prototype.load = function() {
      var e = this;
      return this._load ? this._load : (this._load = new Promise(function(r) {
        if (e._resolve = function() {
          e.resize(e.source.width, e.source.height), r(e);
        }, t.SVG_XML.test(e.svg.trim())) {
          if (!btoa)
            throw new Error("Your browser doesn't support base64 conversions.");
          e.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(e.svg)));
        }
        e._loadSvg();
      }), this._load);
    }, t.prototype._loadSvg = function() {
      var e = this, r = new Image();
      BaseImageResource.crossOrigin(r, this.svg, this._crossorigin), r.src = this.svg, r.onerror = function(D) {
        e._resolve && (r.onerror = null, e.onError.emit(D));
      }, r.onload = function() {
        if (e._resolve) {
          var D = r.width, N = r.height;
          if (!D || !N)
            throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
          var k = D * e.scale, $ = N * e.scale;
          (e._overrideWidth || e._overrideHeight) && (k = e._overrideWidth || e._overrideHeight / N * D, $ = e._overrideHeight || e._overrideWidth / D * N), k = Math.round(k), $ = Math.round($);
          var G = e.source;
          G.width = k, G.height = $, G._pixiId = "canvas_" + uid(), G.getContext("2d").drawImage(r, 0, 0, D, N, 0, 0, k, $), e._resolve(), e._resolve = null;
        }
      };
    }, t.getSize = function(e) {
      var r = t.SVG_SIZE.exec(e), D = {};
      return r && (D[r[1]] = Math.round(parseFloat(r[3])), D[r[5]] = Math.round(parseFloat(r[7]))), D;
    }, t.prototype.dispose = function() {
      o.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;
    }, t.test = function(e, r) {
      return r === "svg" || typeof e == "string" && e.startsWith("data:image/svg+xml") || typeof e == "string" && t.SVG_XML.test(e);
    }, t.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, t.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, t;
  }(BaseImageResource)
), VideoResource = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e, r) {
      var D = this;
      if (r = r || {}, !(e instanceof HTMLVideoElement)) {
        var N = document.createElement("video");
        N.setAttribute("preload", "auto"), N.setAttribute("webkit-playsinline", ""), N.setAttribute("playsinline", ""), typeof e == "string" && (e = [e]);
        var k = e[0].src || e[0];
        BaseImageResource.crossOrigin(N, k, r.crossorigin);
        for (var $ = 0; $ < e.length; ++$) {
          var G = document.createElement("source"), U = e[$], z = U.src, X = U.mime;
          z = z || e[$];
          var V = z.split("?").shift().toLowerCase(), Y = V.slice(V.lastIndexOf(".") + 1);
          X = X || t.MIME_TYPES[Y] || "video/" + Y, G.src = z, G.type = X, N.appendChild(G);
        }
        e = N;
      }
      return D = o.call(this, e) || this, D.noSubImage = !0, D._autoUpdate = !0, D._isConnectedToTicker = !1, D._updateFPS = r.updateFPS || 0, D._msToNextUpdate = 0, D.autoPlay = r.autoPlay !== !1, D._load = null, D._resolve = null, D._onCanPlay = D._onCanPlay.bind(D), D._onError = D._onError.bind(D), r.autoLoad !== !1 && D.load(), D;
    }
    return t.prototype.update = function(e) {
      if (!this.destroyed) {
        var r = Ticker.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - r), (!this._updateFPS || this._msToNextUpdate <= 0) && (o.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
      }
    }, t.prototype.load = function() {
      var e = this;
      if (this._load)
        return this._load;
      var r = this.source;
      return (r.readyState === r.HAVE_ENOUGH_DATA || r.readyState === r.HAVE_FUTURE_DATA) && r.width && r.height && (r.complete = !0), r.addEventListener("play", this._onPlayStart.bind(this)), r.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (r.addEventListener("canplay", this._onCanPlay), r.addEventListener("canplaythrough", this._onCanPlay), r.addEventListener("error", this._onError, !0)), this._load = new Promise(function(D) {
        e.valid ? D(e) : (e._resolve = D, r.load());
      }), this._load;
    }, t.prototype._onError = function(e) {
      this.source.removeEventListener("error", this._onError, !0), this.onError.emit(e);
    }, t.prototype._isSourcePlaying = function() {
      var e = this.source;
      return !e.paused && !e.ended && this._isSourceReady();
    }, t.prototype._isSourceReady = function() {
      var e = this.source;
      return e.readyState > 2;
    }, t.prototype._onPlayStart = function() {
      this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0);
    }, t.prototype._onPlayStop = function() {
      this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);
    }, t.prototype._onCanPlay = function() {
      var e = this.source;
      e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlay);
      var r = this.valid;
      this.resize(e.videoWidth, e.videoHeight), !r && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play();
    }, t.prototype.dispose = function() {
      this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);
      var e = this.source;
      e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), o.prototype.dispose.call(this);
    }, Object.defineProperty(t.prototype, "autoUpdate", {
      /** Should the base texture automatically update itself, set to true by default. */
      get: function() {
        return this._autoUpdate;
      },
      set: function(e) {
        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "updateFPS", {
      /**
       * How many times a second to update the texture from the video. Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       */
      get: function() {
        return this._updateFPS;
      },
      set: function(e) {
        e !== this._updateFPS && (this._updateFPS = e);
      },
      enumerable: !1,
      configurable: !0
    }), t.test = function(e, r) {
      return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || t.TYPES.indexOf(r) > -1;
    }, t.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], t.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    }, t;
  }(BaseImageResource)
), ImageBitmapResource = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e) {
      return o.call(this, e) || this;
    }
    return t.test = function(e) {
      return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && e instanceof ImageBitmap;
    }, t;
  }(BaseImageResource)
);
INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
var _resources = {
  __proto__: null,
  Resource,
  BaseImageResource,
  INSTALLED,
  autoDetectResource,
  AbstractMultiResource,
  ArrayResource,
  BufferResource,
  CanvasResource,
  CubeResource,
  ImageResource,
  SVGResource,
  VideoResource,
  ImageBitmapResource
}, DepthResource = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return t.prototype.upload = function(e, r, D) {
      var N = e.gl;
      N.pixelStorei(N.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === ALPHA_MODES.UNPACK);
      var k = r.realWidth, $ = r.realHeight;
      return D.width === k && D.height === $ ? N.texSubImage2D(r.target, 0, 0, 0, k, $, r.format, D.type, this.data) : (D.width = k, D.height = $, N.texImage2D(r.target, 0, D.internalFormat, k, $, 0, r.format, D.type, this.data)), !0;
    }, t;
  }(BufferResource)
), Framebuffer = (
  /** @class */
  function() {
    function o(t, e) {
      this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Runner("disposeFramebuffer"), this.multisample = MSAA_QUALITY.NONE;
    }
    return Object.defineProperty(o.prototype, "colorTexture", {
      /**
       * Reference to the colorTexture.
       * @readonly
       */
      get: function() {
        return this.colorTextures[0];
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.addColorTexture = function(t, e) {
      return t === void 0 && (t = 0), this.colorTextures[t] = e || new BaseTexture(null, {
        scaleMode: SCALE_MODES.NEAREST,
        resolution: 1,
        mipmap: MIPMAP_MODES.OFF,
        width: this.width,
        height: this.height
      }), this.dirtyId++, this.dirtyFormat++, this;
    }, o.prototype.addDepthTexture = function(t) {
      return this.depthTexture = t || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
        scaleMode: SCALE_MODES.NEAREST,
        resolution: 1,
        width: this.width,
        height: this.height,
        mipmap: MIPMAP_MODES.OFF,
        format: FORMATS.DEPTH_COMPONENT,
        type: TYPES.UNSIGNED_SHORT
      }), this.dirtyId++, this.dirtyFormat++, this;
    }, o.prototype.enableDepth = function() {
      return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;
    }, o.prototype.enableStencil = function() {
      return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;
    }, o.prototype.resize = function(t, e) {
      if (t = Math.round(t), e = Math.round(e), !(t === this.width && e === this.height)) {
        this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;
        for (var r = 0; r < this.colorTextures.length; r++) {
          var D = this.colorTextures[r], N = D.resolution;
          D.setSize(t / N, e / N);
        }
        if (this.depthTexture) {
          var N = this.depthTexture.resolution;
          this.depthTexture.setSize(t / N, e / N);
        }
      }
    }, o.prototype.dispose = function() {
      this.disposeRunner.emit(this, !1);
    }, o.prototype.destroyDepthTexture = function() {
      this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
    }, o;
  }()
), BaseRenderTexture = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e) {
      e === void 0 && (e = {});
      var r = this;
      if (typeof e == "number") {
        var D = arguments[0], N = arguments[1], k = arguments[2], $ = arguments[3];
        e = { width: D, height: N, scaleMode: k, resolution: $ };
      }
      return e.width = e.width || 100, e.height = e.height || 100, e.multisample = e.multisample !== void 0 ? e.multisample : MSAA_QUALITY.NONE, r = o.call(this, null, e) || this, r.mipmap = MIPMAP_MODES.OFF, r.valid = !0, r.clearColor = [0, 0, 0, 0], r.framebuffer = new Framebuffer(r.realWidth, r.realHeight).addColorTexture(0, r), r.framebuffer.multisample = e.multisample, r.maskStack = [], r.filterStack = [{}], r;
    }
    return t.prototype.resize = function(e, r) {
      this.framebuffer.resize(e * this.resolution, r * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
    }, t.prototype.dispose = function() {
      this.framebuffer.dispose(), o.prototype.dispose.call(this);
    }, t.prototype.destroy = function() {
      o.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
    }, t;
  }(BaseTexture)
), TextureUvs = (
  /** @class */
  function() {
    function o() {
      this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
    }
    return o.prototype.set = function(t, e, r) {
      var D = e.width, N = e.height;
      if (r) {
        var k = t.width / 2 / D, $ = t.height / 2 / N, G = t.x / D + k, U = t.y / N + $;
        r = groupD8.add(r, groupD8.NW), this.x0 = G + k * groupD8.uX(r), this.y0 = U + $ * groupD8.uY(r), r = groupD8.add(r, 2), this.x1 = G + k * groupD8.uX(r), this.y1 = U + $ * groupD8.uY(r), r = groupD8.add(r, 2), this.x2 = G + k * groupD8.uX(r), this.y2 = U + $ * groupD8.uY(r), r = groupD8.add(r, 2), this.x3 = G + k * groupD8.uX(r), this.y3 = U + $ * groupD8.uY(r);
      } else
        this.x0 = t.x / D, this.y0 = t.y / N, this.x1 = (t.x + t.width) / D, this.y1 = t.y / N, this.x2 = (t.x + t.width) / D, this.y2 = (t.y + t.height) / N, this.x3 = t.x / D, this.y3 = (t.y + t.height) / N;
      this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
    }, o.prototype.toString = function() {
      return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
    }, o;
  }()
), DEFAULT_UVS = new TextureUvs();
function removeAllHandlers(o) {
  o.destroy = function() {
  }, o.on = function() {
  }, o.once = function() {
  }, o.emit = function() {
  };
}
var Texture = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e, r, D, N, k, $) {
      var G = o.call(this) || this;
      if (G.noFrame = !1, r || (G.noFrame = !0, r = new Rectangle(0, 0, 1, 1)), e instanceof t && (e = e.baseTexture), G.baseTexture = e, G._frame = r, G.trim = N, G.valid = !1, G._uvs = DEFAULT_UVS, G.uvMatrix = null, G.orig = D || r, G._rotate = Number(k || 0), k === !0)
        G._rotate = 2;
      else if (G._rotate % 2 !== 0)
        throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
      return G.defaultAnchor = $ ? new Point($.x, $.y) : new Point(0, 0), G._updateID = 0, G.textureCacheIds = [], e.valid ? G.noFrame ? e.valid && G.onBaseTextureUpdated(e) : G.frame = r : e.once("loaded", G.onBaseTextureUpdated, G), G.noFrame && e.on("update", G.onBaseTextureUpdated, G), G;
    }
    return t.prototype.update = function() {
      this.baseTexture.resource && this.baseTexture.resource.update();
    }, t.prototype.onBaseTextureUpdated = function(e) {
      if (this.noFrame) {
        if (!this.baseTexture.valid)
          return;
        this._frame.width = e.width, this._frame.height = e.height, this.valid = !0, this.updateUvs();
      } else
        this.frame = this._frame;
      this.emit("update", this);
    }, t.prototype.destroy = function(e) {
      if (this.baseTexture) {
        if (e) {
          var r = this.baseTexture.resource;
          r && r.url && TextureCache[r.url] && t.removeFromCache(r.url), this.baseTexture.destroy();
        }
        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
      }
      this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, t.removeFromCache(this), this.textureCacheIds = null;
    }, t.prototype.clone = function() {
      var e = this._frame.clone(), r = this._frame === this.orig ? e : this.orig.clone(), D = new t(this.baseTexture, !this.noFrame && e, r, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
      return this.noFrame && (D._frame = e), D;
    }, t.prototype.updateUvs = function() {
      this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
    }, t.from = function(e, r, D) {
      r === void 0 && (r = {}), D === void 0 && (D = settings.STRICT_TEXTURE_CACHE);
      var N = typeof e == "string", k = null;
      if (N)
        k = e;
      else if (e instanceof BaseTexture) {
        if (!e.cacheId) {
          var $ = r && r.pixiIdPrefix || "pixiid";
          e.cacheId = $ + "-" + uid(), BaseTexture.addToCache(e, e.cacheId);
        }
        k = e.cacheId;
      } else {
        if (!e._pixiId) {
          var $ = r && r.pixiIdPrefix || "pixiid";
          e._pixiId = $ + "_" + uid();
        }
        k = e._pixiId;
      }
      var G = TextureCache[k];
      if (N && D && !G)
        throw new Error('The cacheId "' + k + '" does not exist in TextureCache.');
      return !G && !(e instanceof BaseTexture) ? (r.resolution || (r.resolution = getResolutionOfUrl(e)), G = new t(new BaseTexture(e, r)), G.baseTexture.cacheId = k, BaseTexture.addToCache(G.baseTexture, k), t.addToCache(G, k)) : !G && e instanceof BaseTexture && (G = new t(e), t.addToCache(G, k)), G;
    }, t.fromURL = function(e, r) {
      var D = Object.assign({ autoLoad: !1 }, r == null ? void 0 : r.resourceOptions), N = t.from(e, Object.assign({ resourceOptions: D }, r), !1), k = N.baseTexture.resource;
      return N.baseTexture.valid ? Promise.resolve(N) : k.load().then(function() {
        return Promise.resolve(N);
      });
    }, t.fromBuffer = function(e, r, D, N) {
      return new t(BaseTexture.fromBuffer(e, r, D, N));
    }, t.fromLoader = function(e, r, D, N) {
      var k = new BaseTexture(e, Object.assign({
        scaleMode: settings.SCALE_MODE,
        resolution: getResolutionOfUrl(r)
      }, N)), $ = k.resource;
      $ instanceof ImageResource && ($.url = r);
      var G = new t(k);
      return D || (D = r), BaseTexture.addToCache(G.baseTexture, D), t.addToCache(G, D), D !== r && (BaseTexture.addToCache(G.baseTexture, r), t.addToCache(G, r)), G.baseTexture.valid ? Promise.resolve(G) : new Promise(function(U) {
        G.baseTexture.once("loaded", function() {
          return U(G);
        });
      });
    }, t.addToCache = function(e, r) {
      r && (e.textureCacheIds.indexOf(r) === -1 && e.textureCacheIds.push(r), TextureCache[r] && console.warn("Texture added to the cache with an id [" + r + "] that already had an entry"), TextureCache[r] = e);
    }, t.removeFromCache = function(e) {
      if (typeof e == "string") {
        var r = TextureCache[e];
        if (r) {
          var D = r.textureCacheIds.indexOf(e);
          return D > -1 && r.textureCacheIds.splice(D, 1), delete TextureCache[e], r;
        }
      } else if (e && e.textureCacheIds) {
        for (var N = 0; N < e.textureCacheIds.length; ++N)
          TextureCache[e.textureCacheIds[N]] === e && delete TextureCache[e.textureCacheIds[N]];
        return e.textureCacheIds.length = 0, e;
      }
      return null;
    }, Object.defineProperty(t.prototype, "resolution", {
      /**
       * Returns resolution of baseTexture
       * @readonly
       */
      get: function() {
        return this.baseTexture.resolution;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "frame", {
      /**
       * The frame specifies the region of the base texture that this texture uses.
       * Please call `updateUvs()` after you change coordinates of `frame` manually.
       */
      get: function() {
        return this._frame;
      },
      set: function(e) {
        this._frame = e, this.noFrame = !1;
        var r = e.x, D = e.y, N = e.width, k = e.height, $ = r + N > this.baseTexture.width, G = D + k > this.baseTexture.height;
        if ($ || G) {
          var U = $ && G ? "and" : "or", z = "X: " + r + " + " + N + " = " + (r + N) + " > " + this.baseTexture.width, X = "Y: " + D + " + " + k + " = " + (D + k) + " > " + this.baseTexture.height;
          throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (z + " " + U + " " + X));
        }
        this.valid = N && k && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = e), this.valid && this.updateUvs();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "rotate", {
      /**
       * Indicates whether the texture is rotated inside the atlas
       * set to 2 to compensate for texture packer rotation
       * set to 6 to compensate for spine packer rotation
       * can be used to rotate or mirror sprites
       * See {@link PIXI.groupD8} for explanation
       */
      get: function() {
        return this._rotate;
      },
      set: function(e) {
        this._rotate = e, this.valid && this.updateUvs();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "width", {
      /** The width of the Texture in pixels. */
      get: function() {
        return this.orig.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the Texture in pixels. */
      get: function() {
        return this.orig.height;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.castToBaseTexture = function() {
      return this.baseTexture;
    }, Object.defineProperty(t, "EMPTY", {
      /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */
      get: function() {
        return t._EMPTY || (t._EMPTY = new t(new BaseTexture()), removeAllHandlers(t._EMPTY), removeAllHandlers(t._EMPTY.baseTexture)), t._EMPTY;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "WHITE", {
      /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */
      get: function() {
        if (!t._WHITE) {
          var e = settings.ADAPTER.createCanvas(16, 16), r = e.getContext("2d");
          e.width = 16, e.height = 16, r.fillStyle = "white", r.fillRect(0, 0, 16, 16), t._WHITE = new t(BaseTexture.from(e)), removeAllHandlers(t._WHITE), removeAllHandlers(t._WHITE.baseTexture);
        }
        return t._WHITE;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(i$1)
), RenderTexture = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e, r) {
      var D = o.call(this, e, r) || this;
      return D.valid = !0, D.filterFrame = null, D.filterPoolKey = null, D.updateUvs(), D;
    }
    return Object.defineProperty(t.prototype, "framebuffer", {
      /**
       * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
       * @readonly
       */
      get: function() {
        return this.baseTexture.framebuffer;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "multisample", {
      /**
       * Shortcut to `this.framebuffer.multisample`.
       * @default PIXI.MSAA_QUALITY.NONE
       */
      get: function() {
        return this.framebuffer.multisample;
      },
      set: function(e) {
        this.framebuffer.multisample = e;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.resize = function(e, r, D) {
      D === void 0 && (D = !0);
      var N = this.baseTexture.resolution, k = Math.round(e * N) / N, $ = Math.round(r * N) / N;
      this.valid = k > 0 && $ > 0, this._frame.width = this.orig.width = k, this._frame.height = this.orig.height = $, D && this.baseTexture.resize(k, $), this.updateUvs();
    }, t.prototype.setResolution = function(e) {
      var r = this.baseTexture;
      r.resolution !== e && (r.setResolution(e), this.resize(r.width, r.height, !1));
    }, t.create = function(e) {
      for (var r = arguments, D = [], N = 1; N < arguments.length; N++)
        D[N - 1] = r[N];
      return typeof e == "number" && (deprecation("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), e = {
        width: e,
        height: D[0],
        scaleMode: D[1],
        resolution: D[2]
      }), new t(new BaseRenderTexture(e));
    }, t;
  }(Texture)
), RenderTexturePool = (
  /** @class */
  function() {
    function o(t) {
      this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;
    }
    return o.prototype.createTexture = function(t, e, r) {
      r === void 0 && (r = MSAA_QUALITY.NONE);
      var D = new BaseRenderTexture(Object.assign({
        width: t,
        height: e,
        resolution: 1,
        multisample: r
      }, this.textureOptions));
      return new RenderTexture(D);
    }, o.prototype.getOptimalTexture = function(t, e, r, D) {
      r === void 0 && (r = 1), D === void 0 && (D = MSAA_QUALITY.NONE);
      var N;
      t = Math.ceil(t * r - 1e-6), e = Math.ceil(e * r - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || e !== this._pixelsHeight ? (t = nextPow2(t), e = nextPow2(e), N = ((t & 65535) << 16 | e & 65535) >>> 0, D > 1 && (N += D * 4294967296)) : N = D > 1 ? -D : -1, this.texturePool[N] || (this.texturePool[N] = []);
      var k = this.texturePool[N].pop();
      return k || (k = this.createTexture(t, e, D)), k.filterPoolKey = N, k.setResolution(r), k;
    }, o.prototype.getFilterTexture = function(t, e, r) {
      var D = this.getOptimalTexture(t.width, t.height, e || t.resolution, r || MSAA_QUALITY.NONE);
      return D.filterFrame = t.filterFrame, D;
    }, o.prototype.returnTexture = function(t) {
      var e = t.filterPoolKey;
      t.filterFrame = null, this.texturePool[e].push(t);
    }, o.prototype.returnFilterTexture = function(t) {
      this.returnTexture(t);
    }, o.prototype.clear = function(t) {
      if (t = t !== !1, t)
        for (var e in this.texturePool) {
          var r = this.texturePool[e];
          if (r)
            for (var D = 0; D < r.length; D++)
              r[D].destroy(!0);
        }
      this.texturePool = {};
    }, o.prototype.setScreenSize = function(t) {
      if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {
        this.enableFullScreen = t.width > 0 && t.height > 0;
        for (var e in this.texturePool)
          if (Number(e) < 0) {
            var r = this.texturePool[e];
            if (r)
              for (var D = 0; D < r.length; D++)
                r[D].destroy(!0);
            this.texturePool[e] = [];
          }
        this._pixelsWidth = t.width, this._pixelsHeight = t.height;
      }
    }, o.SCREEN_KEY = -1, o;
  }()
), Attribute = (
  /** @class */
  function() {
    function o(t, e, r, D, N, k, $) {
      e === void 0 && (e = 0), r === void 0 && (r = !1), D === void 0 && (D = TYPES.FLOAT), this.buffer = t, this.size = e, this.normalized = r, this.type = D, this.stride = N, this.start = k, this.instance = $;
    }
    return o.prototype.destroy = function() {
      this.buffer = null;
    }, o.from = function(t, e, r, D, N) {
      return new o(t, e, r, D, N);
    }, o;
  }()
), UID$4 = 0, Buffer$1 = (
  /** @class */
  function() {
    function o(t, e, r) {
      e === void 0 && (e = !0), r === void 0 && (r = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = r, this.static = e, this.id = UID$4++, this.disposeRunner = new Runner("disposeBuffer");
    }
    return o.prototype.update = function(t) {
      t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++;
    }, o.prototype.dispose = function() {
      this.disposeRunner.emit(this, !1);
    }, o.prototype.destroy = function() {
      this.dispose(), this.data = null;
    }, Object.defineProperty(o.prototype, "index", {
      get: function() {
        return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      },
      /**
       * Flags whether this is an index buffer.
       *
       * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make
       * the buffer of type `ARRAY_BUFFER`.
       *
       * For backwards compatibility.
       */
      set: function(t) {
        this.type = t ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
      },
      enumerable: !1,
      configurable: !0
    }), o.from = function(t) {
      return t instanceof Array && (t = new Float32Array(t)), new o(t);
    }, o;
  }()
), map$1$1 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(o, t) {
  for (var e = 0, r = 0, D = {}, N = 0; N < o.length; N++)
    r += t[N], e += o[N].length;
  for (var k = new ArrayBuffer(e * 4), $ = null, G = 0, N = 0; N < o.length; N++) {
    var U = t[N], z = o[N], X = getBufferType(z);
    D[X] || (D[X] = new map$1$1[X](k)), $ = D[X];
    for (var V = 0; V < z.length; V++) {
      var Y = (V / U | 0) * r + G, W = V % U;
      $[Y + W] = z[V];
    }
    G += U;
  }
  return new Float32Array(k);
}
var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 }, UID$3 = 0, map$2 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
}, Geometry = (
  /** @class */
  function() {
    function o(t, e) {
      t === void 0 && (t = []), e === void 0 && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = UID$3++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new Runner("disposeGeometry"), this.refCount = 0;
    }
    return o.prototype.addAttribute = function(t, e, r, D, N, k, $, G) {
      if (r === void 0 && (r = 0), D === void 0 && (D = !1), G === void 0 && (G = !1), !e)
        throw new Error("You must pass a buffer when creating an attribute");
      e instanceof Buffer$1 || (e instanceof Array && (e = new Float32Array(e)), e = new Buffer$1(e));
      var U = t.split("|");
      if (U.length > 1) {
        for (var z = 0; z < U.length; z++)
          this.addAttribute(U[z], e, r, D, N);
        return this;
      }
      var X = this.buffers.indexOf(e);
      return X === -1 && (this.buffers.push(e), X = this.buffers.length - 1), this.attributes[t] = new Attribute(X, r, D, N, k, $, G), this.instanced = this.instanced || G, this;
    }, o.prototype.getAttribute = function(t) {
      return this.attributes[t];
    }, o.prototype.getBuffer = function(t) {
      return this.buffers[this.getAttribute(t).buffer];
    }, o.prototype.addIndex = function(t) {
      return t instanceof Buffer$1 || (t instanceof Array && (t = new Uint16Array(t)), t = new Buffer$1(t)), t.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.indexOf(t) === -1 && this.buffers.push(t), this;
    }, o.prototype.getIndex = function() {
      return this.indexBuffer;
    }, o.prototype.interleave = function() {
      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
        return this;
      var t = [], e = [], r = new Buffer$1(), D;
      for (D in this.attributes) {
        var N = this.attributes[D], k = this.buffers[N.buffer];
        t.push(k.data), e.push(N.size * byteSizeMap$1[N.type] / 4), N.buffer = 0;
      }
      for (r.data = interleaveTypedArrays(t, e), D = 0; D < this.buffers.length; D++)
        this.buffers[D] !== this.indexBuffer && this.buffers[D].destroy();
      return this.buffers = [r], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
    }, o.prototype.getSize = function() {
      for (var t in this.attributes) {
        var e = this.attributes[t], r = this.buffers[e.buffer];
        return r.data.length / (e.stride / 4 || e.size);
      }
      return 0;
    }, o.prototype.dispose = function() {
      this.disposeRunner.emit(this, !1);
    }, o.prototype.destroy = function() {
      this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
    }, o.prototype.clone = function() {
      for (var t = new o(), e = 0; e < this.buffers.length; e++)
        t.buffers[e] = new Buffer$1(this.buffers[e].data.slice(0));
      for (var e in this.attributes) {
        var r = this.attributes[e];
        t.attributes[e] = new Attribute(r.buffer, r.size, r.normalized, r.type, r.stride, r.start, r.instance);
      }
      return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER), t;
    }, o.merge = function(t) {
      for (var e = new o(), r = [], D = [], N = [], k, $ = 0; $ < t.length; $++) {
        k = t[$];
        for (var G = 0; G < k.buffers.length; G++)
          D[G] = D[G] || 0, D[G] += k.buffers[G].data.length, N[G] = 0;
      }
      for (var $ = 0; $ < k.buffers.length; $++)
        r[$] = new map$2[getBufferType(k.buffers[$].data)](D[$]), e.buffers[$] = new Buffer$1(r[$]);
      for (var $ = 0; $ < t.length; $++) {
        k = t[$];
        for (var G = 0; G < k.buffers.length; G++)
          r[G].set(k.buffers[G].data, N[G]), N[G] += k.buffers[G].data.length;
      }
      if (e.attributes = k.attributes, k.indexBuffer) {
        e.indexBuffer = e.buffers[k.buffers.indexOf(k.indexBuffer)], e.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        for (var U = 0, z = 0, X = 0, V = 0, $ = 0; $ < k.buffers.length; $++)
          if (k.buffers[$] !== k.indexBuffer) {
            V = $;
            break;
          }
        for (var $ in k.attributes) {
          var Y = k.attributes[$];
          (Y.buffer | 0) === V && (z += Y.size * byteSizeMap$1[Y.type] / 4);
        }
        for (var $ = 0; $ < t.length; $++) {
          for (var W = t[$].indexBuffer.data, G = 0; G < W.length; G++)
            e.indexBuffer.data[G + X] += U;
          U += t[$].buffers[V].data.length / z, X += W.length;
        }
      }
      return e;
    }, o;
  }()
), Quad = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t() {
      var e = o.call(this) || this;
      return e.addAttribute("aVertexPosition", new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ])).addIndex([0, 1, 3, 2]), e;
    }
    return t;
  }(Geometry)
), QuadUv = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t() {
      var e = o.call(this) || this;
      return e.vertices = new Float32Array([
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1
      ]), e.uvs = new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]), e.vertexBuffer = new Buffer$1(e.vertices), e.uvBuffer = new Buffer$1(e.uvs), e.addAttribute("aVertexPosition", e.vertexBuffer).addAttribute("aTextureCoord", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e;
    }
    return t.prototype.map = function(e, r) {
      var D = 0, N = 0;
      return this.uvs[0] = D, this.uvs[1] = N, this.uvs[2] = D + r.width / e.width, this.uvs[3] = N, this.uvs[4] = D + r.width / e.width, this.uvs[5] = N + r.height / e.height, this.uvs[6] = D, this.uvs[7] = N + r.height / e.height, D = r.x, N = r.y, this.vertices[0] = D, this.vertices[1] = N, this.vertices[2] = D + r.width, this.vertices[3] = N, this.vertices[4] = D + r.width, this.vertices[5] = N + r.height, this.vertices[6] = D, this.vertices[7] = N + r.height, this.invalidate(), this;
    }, t.prototype.invalidate = function() {
      return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
    }, t;
  }(Geometry)
), UID$2 = 0, UniformGroup = (
  /** @class */
  function() {
    function o(t, e, r) {
      this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = UID$2++, this.static = !!e, this.ubo = !!r, t instanceof Buffer$1 ? (this.buffer = t, this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Buffer$1(new Float32Array(1)), this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !0));
    }
    return o.prototype.update = function() {
      this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
    }, o.prototype.add = function(t, e, r) {
      if (!this.ubo)
        this.uniforms[t] = new o(e, r);
      else
        throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }, o.from = function(t, e, r) {
      return new o(t, e, r);
    }, o.uboFrom = function(t, e) {
      return new o(t, e ?? !0, !0);
    }, o;
  }()
), FilterState = (
  /** @class */
  function() {
    function o() {
      this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = MSAA_QUALITY.NONE, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.bindingSourceFrame = new Rectangle(), this.bindingDestinationFrame = new Rectangle(), this.filters = [], this.transform = null;
    }
    return o.prototype.clear = function() {
      this.target = null, this.filters = null, this.renderTexture = null;
    }, o;
  }()
), tempPoints = [new Point(), new Point(), new Point(), new Point()], tempMatrix$2 = new Matrix(), FilterSystem = (
  /** @class */
  function() {
    function o(t) {
      this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool(), this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new Quad(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup({
        outputFrame: new Rectangle(),
        inputSize: new Float32Array(4),
        inputPixel: new Float32Array(4),
        inputClamp: new Float32Array(4),
        resolution: 1,
        // legacy variables
        filterArea: new Float32Array(4),
        filterClamp: new Float32Array(4)
      }, !0), this.forceClear = !1, this.useMaxPadding = !1;
    }
    return o.prototype.push = function(t, e) {
      for (var r, D, N = this.renderer, k = this.defaultFilterStack, $ = this.statePool.pop() || new FilterState(), G = this.renderer.renderTexture, U = e[0].resolution, z = e[0].multisample, X = e[0].padding, V = e[0].autoFit, Y = (r = e[0].legacy) !== null && r !== void 0 ? r : !0, W = 1; W < e.length; W++) {
        var q = e[W];
        U = Math.min(U, q.resolution), z = Math.min(z, q.multisample), X = this.useMaxPadding ? Math.max(X, q.padding) : X + q.padding, V = V && q.autoFit, Y = Y || ((D = q.legacy) !== null && D !== void 0 ? D : !0);
      }
      k.length === 1 && (this.defaultFilterStack[0].renderTexture = G.current), k.push($), $.resolution = U, $.multisample = z, $.legacy = Y, $.target = t, $.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), $.sourceFrame.pad(X);
      var K = this.tempRect.copyFrom(G.sourceFrame);
      N.projection.transform && this.transformAABB(tempMatrix$2.copyFrom(N.projection.transform).invert(), K), V ? ($.sourceFrame.fit(K), ($.sourceFrame.width <= 0 || $.sourceFrame.height <= 0) && ($.sourceFrame.width = 0, $.sourceFrame.height = 0)) : $.sourceFrame.intersects(K) || ($.sourceFrame.width = 0, $.sourceFrame.height = 0), this.roundFrame($.sourceFrame, G.current ? G.current.resolution : N.resolution, G.sourceFrame, G.destinationFrame, N.projection.transform), $.renderTexture = this.getOptimalFilterTexture($.sourceFrame.width, $.sourceFrame.height, U, z), $.filters = e, $.destinationFrame.width = $.renderTexture.width, $.destinationFrame.height = $.renderTexture.height;
      var Z = this.tempRect;
      Z.x = 0, Z.y = 0, Z.width = $.sourceFrame.width, Z.height = $.sourceFrame.height, $.renderTexture.filterFrame = $.sourceFrame, $.bindingSourceFrame.copyFrom(G.sourceFrame), $.bindingDestinationFrame.copyFrom(G.destinationFrame), $.transform = N.projection.transform, N.projection.transform = null, G.bind($.renderTexture, $.sourceFrame, Z), N.framebuffer.clear(0, 0, 0, 0);
    }, o.prototype.pop = function() {
      var t = this.defaultFilterStack, e = t.pop(), r = e.filters;
      this.activeState = e;
      var D = this.globalUniforms.uniforms;
      D.outputFrame = e.sourceFrame, D.resolution = e.resolution;
      var N = D.inputSize, k = D.inputPixel, $ = D.inputClamp;
      if (N[0] = e.destinationFrame.width, N[1] = e.destinationFrame.height, N[2] = 1 / N[0], N[3] = 1 / N[1], k[0] = Math.round(N[0] * e.resolution), k[1] = Math.round(N[1] * e.resolution), k[2] = 1 / k[0], k[3] = 1 / k[1], $[0] = 0.5 * k[2], $[1] = 0.5 * k[3], $[2] = e.sourceFrame.width * N[2] - 0.5 * k[2], $[3] = e.sourceFrame.height * N[3] - 0.5 * k[3], e.legacy) {
        var G = D.filterArea;
        G[0] = e.destinationFrame.width, G[1] = e.destinationFrame.height, G[2] = e.sourceFrame.x, G[3] = e.sourceFrame.y, D.filterClamp = D.inputClamp;
      }
      this.globalUniforms.update();
      var U = t[t.length - 1];
      if (this.renderer.framebuffer.blit(), r.length === 1)
        r[0].apply(this, e.renderTexture, U.renderTexture, CLEAR_MODES.BLEND, e), this.returnFilterTexture(e.renderTexture);
      else {
        var z = e.renderTexture, X = this.getOptimalFilterTexture(z.width, z.height, e.resolution);
        X.filterFrame = z.filterFrame;
        var V = 0;
        for (V = 0; V < r.length - 1; ++V) {
          V === 1 && e.multisample > 1 && (X = this.getOptimalFilterTexture(z.width, z.height, e.resolution), X.filterFrame = z.filterFrame), r[V].apply(this, z, X, CLEAR_MODES.CLEAR, e);
          var Y = z;
          z = X, X = Y;
        }
        r[V].apply(this, z, U.renderTexture, CLEAR_MODES.BLEND, e), V > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture(z), this.returnFilterTexture(X);
      }
      e.clear(), this.statePool.push(e);
    }, o.prototype.bindAndClear = function(t, e) {
      e === void 0 && (e = CLEAR_MODES.CLEAR);
      var r = this.renderer, D = r.renderTexture, N = r.state;
      if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) {
        var k = this.tempRect;
        k.x = 0, k.y = 0, k.width = t.filterFrame.width, k.height = t.filterFrame.height, D.bind(t, t.filterFrame, k);
      } else
        t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? D.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
      var $ = N.stateId & 1 || this.forceClear;
      (e === CLEAR_MODES.CLEAR || e === CLEAR_MODES.BLIT && $) && this.renderer.framebuffer.clear(0, 0, 0, 0);
    }, o.prototype.applyFilter = function(t, e, r, D) {
      var N = this.renderer;
      N.state.set(t.state), this.bindAndClear(r, D), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, N.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), N.geometry.bind(this.quadUv), N.geometry.draw(DRAW_MODES.TRIANGLES)) : (N.geometry.bind(this.quad), N.geometry.draw(DRAW_MODES.TRIANGLE_STRIP));
    }, o.prototype.calculateSpriteMatrix = function(t, e) {
      var r = this.activeState, D = r.sourceFrame, N = r.destinationFrame, k = e._texture.orig, $ = t.set(N.width, 0, 0, N.height, D.x, D.y), G = e.worldTransform.copyTo(Matrix.TEMP_MATRIX);
      return G.invert(), $.prepend(G), $.scale(1 / k.width, 1 / k.height), $.translate(e.anchor.x, e.anchor.y), $;
    }, o.prototype.destroy = function() {
      this.renderer = null, this.texturePool.clear(!1);
    }, o.prototype.getOptimalFilterTexture = function(t, e, r, D) {
      return r === void 0 && (r = 1), D === void 0 && (D = MSAA_QUALITY.NONE), this.texturePool.getOptimalTexture(t, e, r, D);
    }, o.prototype.getFilterTexture = function(t, e, r) {
      if (typeof t == "number") {
        var D = t;
        t = e, e = D;
      }
      t = t || this.activeState.renderTexture;
      var N = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, r || MSAA_QUALITY.NONE);
      return N.filterFrame = t.filterFrame, N;
    }, o.prototype.returnFilterTexture = function(t) {
      this.texturePool.returnTexture(t);
    }, o.prototype.emptyPool = function() {
      this.texturePool.clear(!0);
    }, o.prototype.resize = function() {
      this.texturePool.setScreenSize(this.renderer.view);
    }, o.prototype.transformAABB = function(t, e) {
      var r = tempPoints[0], D = tempPoints[1], N = tempPoints[2], k = tempPoints[3];
      r.set(e.left, e.top), D.set(e.left, e.bottom), N.set(e.right, e.top), k.set(e.right, e.bottom), t.apply(r, r), t.apply(D, D), t.apply(N, N), t.apply(k, k);
      var $ = Math.min(r.x, D.x, N.x, k.x), G = Math.min(r.y, D.y, N.y, k.y), U = Math.max(r.x, D.x, N.x, k.x), z = Math.max(r.y, D.y, N.y, k.y);
      e.x = $, e.y = G, e.width = U - $, e.height = z - G;
    }, o.prototype.roundFrame = function(t, e, r, D, N) {
      if (!(t.width <= 0 || t.height <= 0 || r.width <= 0 || r.height <= 0)) {
        if (N) {
          var k = N.a, $ = N.b, G = N.c, U = N.d;
          if ((Math.abs($) > 1e-4 || Math.abs(G) > 1e-4) && (Math.abs(k) > 1e-4 || Math.abs(U) > 1e-4))
            return;
        }
        N = N ? tempMatrix$2.copyFrom(N) : tempMatrix$2.identity(), N.translate(-r.x, -r.y).scale(D.width / r.width, D.height / r.height).translate(D.x, D.y), this.transformAABB(N, t), t.ceil(e), this.transformAABB(N.invert(), t);
      }
    }, o;
  }()
), ObjectRenderer = (
  /** @class */
  function() {
    function o(t) {
      this.renderer = t;
    }
    return o.prototype.flush = function() {
    }, o.prototype.destroy = function() {
      this.renderer = null;
    }, o.prototype.start = function() {
    }, o.prototype.stop = function() {
      this.flush();
    }, o.prototype.render = function(t) {
    }, o;
  }()
), BatchSystem = (
  /** @class */
  function() {
    function o(t) {
      this.renderer = t, this.emptyRenderer = new ObjectRenderer(t), this.currentRenderer = this.emptyRenderer;
    }
    return o.prototype.setObjectRenderer = function(t) {
      this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start());
    }, o.prototype.flush = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, o.prototype.reset = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, o.prototype.copyBoundTextures = function(t, e) {
      for (var r = this.renderer.texture.boundTextures, D = e - 1; D >= 0; --D)
        t[D] = r[D] || null, t[D] && (t[D]._batchLocation = D);
    }, o.prototype.boundArray = function(t, e, r, D) {
      for (var N = t.elements, k = t.ids, $ = t.count, G = 0, U = 0; U < $; U++) {
        var z = N[U], X = z._batchLocation;
        if (X >= 0 && X < D && e[X] === z) {
          k[U] = X;
          continue;
        }
        for (; G < D; ) {
          var V = e[G];
          if (V && V._batchEnabled === r && V._batchLocation === G) {
            G++;
            continue;
          }
          k[U] = G, z._batchLocation = G, e[G] = z;
          break;
        }
      }
    }, o.prototype.destroy = function() {
      this.renderer = null;
    }, o;
  }()
), CONTEXT_UID_COUNTER = 0, ContextSystem = (
  /** @class */
  function() {
    function o(t) {
      this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {
        uint32Indices: !1
      }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener("webglcontextlost", this.handleContextLost, !1), t.view.addEventListener("webglcontextrestored", this.handleContextRestored, !1);
    }
    return Object.defineProperty(o.prototype, "isLost", {
      /**
       * `true` if the context is lost
       * @readonly
       */
      get: function() {
        return !this.gl || this.gl.isContextLost();
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.contextChange = function(t) {
      this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    }, o.prototype.initFromContext = function(t) {
      this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, this.renderer.runners.contextChange.emit(t);
    }, o.prototype.initFromOptions = function(t) {
      var e = this.createContext(this.renderer.view, t);
      this.initFromContext(e);
    }, o.prototype.createContext = function(t, e) {
      var r;
      if (settings.PREFER_ENV >= ENV.WEBGL2 && (r = t.getContext("webgl2", e)), r)
        this.webGLVersion = 2;
      else if (this.webGLVersion = 1, r = t.getContext("webgl", e) || t.getContext("experimental-webgl", e), !r)
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      return this.gl = r, this.getExtensions(), this.gl;
    }, o.prototype.getExtensions = function() {
      var t = this.gl, e = {
        loseContext: t.getExtension("WEBGL_lose_context"),
        anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
        floatTextureLinear: t.getExtension("OES_texture_float_linear"),
        s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: t.getExtension("WEBGL_compressed_texture_etc"),
        etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: t.getExtension("WEBGL_compressed_texture_atc"),
        astc: t.getExtension("WEBGL_compressed_texture_astc")
      };
      this.webGLVersion === 1 ? Object.assign(this.extensions, e, {
        drawBuffers: t.getExtension("WEBGL_draw_buffers"),
        depthTexture: t.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: t.getExtension("OES_element_index_uint"),
        // Floats and half-floats
        floatTexture: t.getExtension("OES_texture_float"),
        floatTextureLinear: t.getExtension("OES_texture_float_linear"),
        textureHalfFloat: t.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
      }) : this.webGLVersion === 2 && Object.assign(this.extensions, e, {
        // Floats and half-floats
        colorBufferFloat: t.getExtension("EXT_color_buffer_float")
      });
    }, o.prototype.handleContextLost = function(t) {
      var e = this;
      t.preventDefault(), setTimeout(function() {
        e.gl.isContextLost() && e.extensions.loseContext && e.extensions.loseContext.restoreContext();
      }, 0);
    }, o.prototype.handleContextRestored = function() {
      this.renderer.runners.contextChange.emit(this.gl);
    }, o.prototype.destroy = function() {
      var t = this.renderer.view;
      this.renderer = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
    }, o.prototype.postrender = function() {
      this.renderer.renderingToScreen && this.gl.flush();
    }, o.prototype.validateContext = function(t) {
      var e = t.getContextAttributes(), r = "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext;
      r && (this.webGLVersion = 2), e && !e.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      var D = r || !!t.getExtension("OES_element_index_uint");
      this.supports.uint32Indices = D, D || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }, o;
  }()
), GLFramebuffer = (
  /** @class */
  function() {
    function o(t) {
      this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = MSAA_QUALITY.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
    }
    return o;
  }()
), tempRectangle = new Rectangle(), FramebufferSystem = (
  /** @class */
  function() {
    function o(t) {
      this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer(10, 10), this.msaaSamples = null;
    }
    return o.prototype.contextChange = function() {
      this.disposeAll(!0);
      var t = this.gl = this.renderer.gl;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Rectangle(), this.hasMRT = !0, this.writeDepthTexture = !0, this.renderer.context.webGLVersion === 1) {
        var e = this.renderer.context.extensions.drawBuffers, r = this.renderer.context.extensions.depthTexture;
        settings.PREFER_ENV === ENV.WEBGL_LEGACY && (e = null, r = null), e ? t.drawBuffers = function(D) {
          return e.drawBuffersWEBGL(D);
        } : (this.hasMRT = !1, t.drawBuffers = function() {
        }), r || (this.writeDepthTexture = !1);
      } else
        this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES);
    }, o.prototype.bind = function(t, e, r) {
      r === void 0 && (r = 0);
      var D = this.gl;
      if (t) {
        var N = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
        this.current !== t && (this.current = t, D.bindFramebuffer(D.FRAMEBUFFER, N.framebuffer)), N.mipLevel !== r && (t.dirtyId++, t.dirtyFormat++, N.mipLevel = r), N.dirtyId !== t.dirtyId && (N.dirtyId = t.dirtyId, N.dirtyFormat !== t.dirtyFormat ? (N.dirtyFormat = t.dirtyFormat, N.dirtySize = t.dirtySize, this.updateFramebuffer(t, r)) : N.dirtySize !== t.dirtySize && (N.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));
        for (var k = 0; k < t.colorTextures.length; k++) {
          var $ = t.colorTextures[k];
          this.renderer.texture.unbind($.parentTextureArray || $);
        }
        if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {
          var G = e.width >> r, U = e.height >> r, z = G / e.width;
          this.setViewport(e.x * z, e.y * z, G, U);
        } else {
          var G = t.width >> r, U = t.height >> r;
          this.setViewport(0, 0, G, U);
        }
      } else
        this.current && (this.current = null, D.bindFramebuffer(D.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
    }, o.prototype.setViewport = function(t, e, r, D) {
      var N = this.viewport;
      t = Math.round(t), e = Math.round(e), r = Math.round(r), D = Math.round(D), (N.width !== r || N.height !== D || N.x !== t || N.y !== e) && (N.x = t, N.y = e, N.width = r, N.height = D, this.gl.viewport(t, e, r, D));
    }, Object.defineProperty(o.prototype, "size", {
      /**
       * Get the size of the current width and height. Returns object with `width` and `height` values.
       * @readonly
       */
      get: function() {
        return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.clear = function(t, e, r, D, N) {
      N === void 0 && (N = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH);
      var k = this.gl;
      k.clearColor(t, e, r, D), k.clear(N);
    }, o.prototype.initFramebuffer = function(t) {
      var e = this.gl, r = new GLFramebuffer(e.createFramebuffer());
      return r.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = r, this.managedFramebuffers.push(t), t.disposeRunner.add(this), r;
    }, o.prototype.resizeFramebuffer = function(t) {
      var e = this.gl, r = t.glFramebuffers[this.CONTEXT_UID];
      r.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, r.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.RGBA8, t.width, t.height)), r.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, r.stencil), r.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));
      var D = t.colorTextures, N = D.length;
      e.drawBuffers || (N = Math.min(N, 1));
      for (var k = 0; k < N; k++) {
        var $ = D[k], G = $.parentTextureArray || $;
        this.renderer.texture.bind(G, 0);
      }
      t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0);
    }, o.prototype.updateFramebuffer = function(t, e) {
      var r = this.gl, D = t.glFramebuffers[this.CONTEXT_UID], N = t.colorTextures, k = N.length;
      r.drawBuffers || (k = Math.min(k, 1)), D.multisample > 1 && this.canMultisampleFramebuffer(t) ? (D.msaaBuffer = D.msaaBuffer || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, D.msaaBuffer), r.renderbufferStorageMultisample(r.RENDERBUFFER, D.multisample, r.RGBA8, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, D.msaaBuffer)) : D.msaaBuffer && (r.deleteRenderbuffer(D.msaaBuffer), D.msaaBuffer = null, D.blitFramebuffer && (D.blitFramebuffer.dispose(), D.blitFramebuffer = null));
      for (var $ = [], G = 0; G < k; G++) {
        var U = N[G], z = U.parentTextureArray || U;
        this.renderer.texture.bind(z, 0), !(G === 0 && D.msaaBuffer) && (r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + G, U.target, z._glTextures[this.CONTEXT_UID].texture, e), $.push(r.COLOR_ATTACHMENT0 + G));
      }
      if ($.length > 1 && r.drawBuffers($), t.depthTexture) {
        var X = this.writeDepthTexture;
        if (X) {
          var V = t.depthTexture;
          this.renderer.texture.bind(V, 0), r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, V._glTextures[this.CONTEXT_UID].texture, e);
        }
      }
      (t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (D.stencil = D.stencil || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, D.stencil), D.msaaBuffer ? r.renderbufferStorageMultisample(r.RENDERBUFFER, D.multisample, r.DEPTH24_STENCIL8, t.width, t.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, D.stencil)) : D.stencil && (r.deleteRenderbuffer(D.stencil), D.stencil = null);
    }, o.prototype.canMultisampleFramebuffer = function(t) {
      return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture;
    }, o.prototype.detectSamples = function(t) {
      var e = this.msaaSamples, r = MSAA_QUALITY.NONE;
      if (t <= 1 || e === null)
        return r;
      for (var D = 0; D < e.length; D++)
        if (e[D] <= t) {
          r = e[D];
          break;
        }
      return r === 1 && (r = MSAA_QUALITY.NONE), r;
    }, o.prototype.blit = function(t, e, r) {
      var D = this, N = D.current, k = D.renderer, $ = D.gl, G = D.CONTEXT_UID;
      if (k.context.webGLVersion === 2 && N) {
        var U = N.glFramebuffers[G];
        if (U) {
          if (!t) {
            if (!U.msaaBuffer)
              return;
            var z = N.colorTextures[0];
            if (!z)
              return;
            U.blitFramebuffer || (U.blitFramebuffer = new Framebuffer(N.width, N.height), U.blitFramebuffer.addColorTexture(0, z)), t = U.blitFramebuffer, t.colorTextures[0] !== z && (t.colorTextures[0] = z, t.dirtyId++, t.dirtyFormat++), (t.width !== N.width || t.height !== N.height) && (t.width = N.width, t.height = N.height, t.dirtyId++, t.dirtySize++);
          }
          e || (e = tempRectangle, e.width = N.width, e.height = N.height), r || (r = e);
          var X = e.width === r.width && e.height === r.height;
          this.bind(t), $.bindFramebuffer($.READ_FRAMEBUFFER, U.framebuffer), $.blitFramebuffer(e.left, e.top, e.right, e.bottom, r.left, r.top, r.right, r.bottom, $.COLOR_BUFFER_BIT, X ? $.NEAREST : $.LINEAR);
        }
      }
    }, o.prototype.disposeFramebuffer = function(t, e) {
      var r = t.glFramebuffers[this.CONTEXT_UID], D = this.gl;
      if (r) {
        delete t.glFramebuffers[this.CONTEXT_UID];
        var N = this.managedFramebuffers.indexOf(t);
        N >= 0 && this.managedFramebuffers.splice(N, 1), t.disposeRunner.remove(this), e || (D.deleteFramebuffer(r.framebuffer), r.msaaBuffer && D.deleteRenderbuffer(r.msaaBuffer), r.stencil && D.deleteRenderbuffer(r.stencil)), r.blitFramebuffer && r.blitFramebuffer.dispose();
      }
    }, o.prototype.disposeAll = function(t) {
      var e = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (var r = 0; r < e.length; r++)
        this.disposeFramebuffer(e[r], t);
    }, o.prototype.forceStencil = function() {
      var t = this.current;
      if (t) {
        var e = t.glFramebuffers[this.CONTEXT_UID];
        if (!(!e || e.stencil)) {
          t.stencil = !0;
          var r = t.width, D = t.height, N = this.gl, k = N.createRenderbuffer();
          N.bindRenderbuffer(N.RENDERBUFFER, k), e.msaaBuffer ? N.renderbufferStorageMultisample(N.RENDERBUFFER, e.multisample, N.DEPTH24_STENCIL8, r, D) : N.renderbufferStorage(N.RENDERBUFFER, N.DEPTH_STENCIL, r, D), e.stencil = k, N.framebufferRenderbuffer(N.FRAMEBUFFER, N.DEPTH_STENCIL_ATTACHMENT, N.RENDERBUFFER, k);
        }
      }
    }, o.prototype.reset = function() {
      this.current = this.unknownFramebuffer, this.viewport = new Rectangle();
    }, o.prototype.destroy = function() {
      this.renderer = null;
    }, o;
  }()
), byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 }, GeometrySystem = (
  /** @class */
  function() {
    function o(t) {
      this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};
    }
    return o.prototype.contextChange = function() {
      this.disposeAll(!0);
      var t = this.gl = this.renderer.gl, e = this.renderer.context;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e.webGLVersion !== 2) {
        var r = this.renderer.context.extensions.vertexArrayObject;
        settings.PREFER_ENV === ENV.WEBGL_LEGACY && (r = null), r ? (t.createVertexArray = function() {
          return r.createVertexArrayOES();
        }, t.bindVertexArray = function(N) {
          return r.bindVertexArrayOES(N);
        }, t.deleteVertexArray = function(N) {
          return r.deleteVertexArrayOES(N);
        }) : (this.hasVao = !1, t.createVertexArray = function() {
          return null;
        }, t.bindVertexArray = function() {
          return null;
        }, t.deleteVertexArray = function() {
          return null;
        });
      }
      if (e.webGLVersion !== 2) {
        var D = t.getExtension("ANGLE_instanced_arrays");
        D ? (t.vertexAttribDivisor = function(N, k) {
          return D.vertexAttribDivisorANGLE(N, k);
        }, t.drawElementsInstanced = function(N, k, $, G, U) {
          return D.drawElementsInstancedANGLE(N, k, $, G, U);
        }, t.drawArraysInstanced = function(N, k, $, G) {
          return D.drawArraysInstancedANGLE(N, k, $, G);
        }) : this.hasInstance = !1;
      }
      this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex;
    }, o.prototype.bind = function(t, e) {
      e = e || this.renderer.shader.shader;
      var r = this.gl, D = t.glVertexArrayObjects[this.CONTEXT_UID], N = !1;
      D || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = D = {}, N = !0);
      var k = D[e.program.id] || this.initGeometryVao(t, e, N);
      this._activeGeometry = t, this._activeVao !== k && (this._activeVao = k, this.hasVao ? r.bindVertexArray(k) : this.activateVao(t, e.program)), this.updateBuffers();
    }, o.prototype.reset = function() {
      this.unbind();
    }, o.prototype.updateBuffers = function() {
      for (var t = this._activeGeometry, e = this.renderer.buffer, r = 0; r < t.buffers.length; r++) {
        var D = t.buffers[r];
        e.update(D);
      }
    }, o.prototype.checkCompatibility = function(t, e) {
      var r = t.attributes, D = e.attributeData;
      for (var N in D)
        if (!r[N])
          throw new Error('shader and geometry incompatible, geometry missing the "' + N + '" attribute');
    }, o.prototype.getSignature = function(t, e) {
      var r = t.attributes, D = e.attributeData, N = ["g", t.id];
      for (var k in r)
        D[k] && N.push(k, D[k].location);
      return N.join("-");
    }, o.prototype.initGeometryVao = function(t, e, r) {
      r === void 0 && (r = !0);
      var D = this.gl, N = this.CONTEXT_UID, k = this.renderer.buffer, $ = e.program;
      $.glPrograms[N] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, $);
      var G = this.getSignature(t, $), U = t.glVertexArrayObjects[this.CONTEXT_UID], z = U[G];
      if (z)
        return U[$.id] = z, z;
      var X = t.buffers, V = t.attributes, Y = {}, W = {};
      for (var q in X)
        Y[q] = 0, W[q] = 0;
      for (var q in V)
        !V[q].size && $.attributeData[q] ? V[q].size = $.attributeData[q].size : V[q].size || console.warn("PIXI Geometry attribute '" + q + "' size cannot be determined (likely the bound shader does not have the attribute)"), Y[V[q].buffer] += V[q].size * byteSizeMap[V[q].type];
      for (var q in V) {
        var K = V[q], Z = K.size;
        K.stride === void 0 && (Y[K.buffer] === Z * byteSizeMap[K.type] ? K.stride = 0 : K.stride = Y[K.buffer]), K.start === void 0 && (K.start = W[K.buffer], W[K.buffer] += Z * byteSizeMap[K.type]);
      }
      z = D.createVertexArray(), D.bindVertexArray(z);
      for (var J = 0; J < X.length; J++) {
        var Q = X[J];
        k.bind(Q), r && Q._glBuffers[N].refCount++;
      }
      return this.activateVao(t, $), this._activeVao = z, U[$.id] = z, U[G] = z, z;
    }, o.prototype.disposeGeometry = function(t, e) {
      var r;
      if (this.managedGeometries[t.id]) {
        delete this.managedGeometries[t.id];
        var D = t.glVertexArrayObjects[this.CONTEXT_UID], N = this.gl, k = t.buffers, $ = (r = this.renderer) === null || r === void 0 ? void 0 : r.buffer;
        if (t.disposeRunner.remove(this), !!D) {
          if ($)
            for (var G = 0; G < k.length; G++) {
              var U = k[G]._glBuffers[this.CONTEXT_UID];
              U && (U.refCount--, U.refCount === 0 && !e && $.dispose(k[G], e));
            }
          if (!e) {
            for (var z in D)
              if (z[0] === "g") {
                var X = D[z];
                this._activeVao === X && this.unbind(), N.deleteVertexArray(X);
              }
          }
          delete t.glVertexArrayObjects[this.CONTEXT_UID];
        }
      }
    }, o.prototype.disposeAll = function(t) {
      for (var e = Object.keys(this.managedGeometries), r = 0; r < e.length; r++)
        this.disposeGeometry(this.managedGeometries[e[r]], t);
    }, o.prototype.activateVao = function(t, e) {
      var r = this.gl, D = this.CONTEXT_UID, N = this.renderer.buffer, k = t.buffers, $ = t.attributes;
      t.indexBuffer && N.bind(t.indexBuffer);
      var G = null;
      for (var U in $) {
        var z = $[U], X = k[z.buffer], V = X._glBuffers[D];
        if (e.attributeData[U]) {
          G !== V && (N.bind(X), G = V);
          var Y = e.attributeData[U].location;
          if (r.enableVertexAttribArray(Y), r.vertexAttribPointer(Y, z.size, z.type || r.FLOAT, z.normalized, z.stride, z.start), z.instance)
            if (this.hasInstance)
              r.vertexAttribDivisor(Y, 1);
            else
              throw new Error("geometry error, GPU Instancing is not supported on this device");
        }
      }
    }, o.prototype.draw = function(t, e, r, D) {
      var N = this.gl, k = this._activeGeometry;
      if (k.indexBuffer) {
        var $ = k.indexBuffer.data.BYTES_PER_ELEMENT, G = $ === 2 ? N.UNSIGNED_SHORT : N.UNSIGNED_INT;
        $ === 2 || $ === 4 && this.canUseUInt32ElementIndex ? k.instanced ? N.drawElementsInstanced(t, e || k.indexBuffer.data.length, G, (r || 0) * $, D || 1) : N.drawElements(t, e || k.indexBuffer.data.length, G, (r || 0) * $) : console.warn("unsupported index buffer type: uint32");
      } else
        k.instanced ? N.drawArraysInstanced(t, r, e || k.getSize(), D || 1) : N.drawArrays(t, r, e || k.getSize());
      return this;
    }, o.prototype.unbind = function() {
      this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
    }, o.prototype.destroy = function() {
      this.renderer = null;
    }, o;
  }()
), MaskData = (
  /** @class */
  function() {
    function o(t) {
      t === void 0 && (t = null), this.type = MASK_TYPES.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = settings.FILTER_MULTISAMPLE, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;
    }
    return Object.defineProperty(o.prototype, "filter", {
      /**
       * The sprite mask filter.
       * If set to `null`, the default sprite mask filter is used.
       * @default null
       */
      get: function() {
        return this._filters ? this._filters[0] : null;
      },
      set: function(t) {
        t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.reset = function() {
      this.pooled && (this.maskObject = null, this.type = MASK_TYPES.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;
    }, o.prototype.copyCountersOrReset = function(t) {
      t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
    }, o;
  }()
);
function compileShader(o, t, e) {
  var r = o.createShader(t);
  return o.shaderSource(r, e), o.compileShader(r), r;
}
function logPrettyShaderError(o, t) {
  var e = o.getShaderSource(t).split(`
`).map(function(U, z) {
    return z + ": " + U;
  }), r = o.getShaderInfoLog(t), D = r.split(`
`), N = {}, k = D.map(function(U) {
    return parseFloat(U.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
  }).filter(function(U) {
    return U && !N[U] ? (N[U] = !0, !0) : !1;
  }), $ = [""];
  k.forEach(function(U) {
    e[U - 1] = "%c" + e[U - 1] + "%c", $.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  var G = e.join(`
`);
  $[0] = G, console.error(r), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, $), console.groupEnd();
}
function logProgramError(o, t, e, r) {
  o.getProgramParameter(t, o.LINK_STATUS) || (o.getShaderParameter(e, o.COMPILE_STATUS) || logPrettyShaderError(o, e), o.getShaderParameter(r, o.COMPILE_STATUS) || logPrettyShaderError(o, r), console.error("PixiJS Error: Could not initialize shader."), o.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", o.getProgramInfoLog(t)));
}
function booleanArray(o) {
  for (var t = new Array(o), e = 0; e < t.length; e++)
    t[e] = !1;
  return t;
}
function defaultValue(o, t) {
  switch (o) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * t);
    case "vec3":
      return new Float32Array(3 * t);
    case "vec4":
      return new Float32Array(4 * t);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * t);
    case "ivec3":
      return new Int32Array(3 * t);
    case "ivec4":
      return new Int32Array(4 * t);
    case "uvec2":
      return new Uint32Array(2 * t);
    case "uvec3":
      return new Uint32Array(3 * t);
    case "uvec4":
      return new Uint32Array(4 * t);
    case "bool":
      return !1;
    case "bvec2":
      return booleanArray(2 * t);
    case "bvec3":
      return booleanArray(3 * t);
    case "bvec4":
      return booleanArray(4 * t);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var unknownContext = {}, context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context && context.isContextLost()) {
    var o = settings.ADAPTER.createCanvas(), t = void 0;
    settings.PREFER_ENV >= ENV.WEBGL2 && (t = o.getContext("webgl2", {})), t || (t = o.getContext("webgl", {}) || o.getContext("experimental-webgl", {}), t ? t.getExtension("WEBGL_draw_buffers") : t = null), context = t;
  }
  return context;
}
var maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION.MEDIUM;
    var o = getTestContext();
    if (o && o.getShaderPrecisionFormat) {
      var t = o.getShaderPrecisionFormat(o.FRAGMENT_SHADER, o.HIGH_FLOAT);
      maxFragmentPrecision = t.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
    }
  }
  return maxFragmentPrecision;
}
function setPrecision(o, t, e) {
  if (o.substring(0, 9) !== "precision") {
    var r = t;
    return t === PRECISION.HIGH && e !== PRECISION.HIGH && (r = PRECISION.MEDIUM), "precision " + r + ` float;
` + o;
  } else if (e !== PRECISION.HIGH && o.substring(0, 15) === "precision highp")
    return o.replace("precision highp", "precision mediump");
  return o;
}
var GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(o) {
  return GLSL_TO_SIZE[o];
}
var GL_TABLE = null, GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(o, t) {
  if (!GL_TABLE) {
    var e = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (var r = 0; r < e.length; ++r) {
      var D = e[r];
      GL_TABLE[o[D]] = GL_TO_GLSL_TYPES[D];
    }
  }
  return GL_TABLE[t];
}
var uniformParsers = [
  // a float cache layer
  {
    test: function(o) {
      return o.type === "float" && o.size === 1 && !o.isArray;
    },
    code: function(o) {
      return `
            if(uv["` + o + '"] !== ud["' + o + `"].value)
            {
                ud["` + o + '"].value = uv["' + o + `"]
                gl.uniform1f(ud["` + o + '"].location, uv["' + o + `"])
            }
            `;
    }
  },
  // handling samplers
  {
    test: function(o, t) {
      return (o.type === "sampler2D" || o.type === "samplerCube" || o.type === "sampler2DArray") && o.size === 1 && !o.isArray && (t == null || t.castToBaseTexture !== void 0);
    },
    code: function(o) {
      return `t = syncData.textureCount++;

            renderer.texture.bind(uv["` + o + `"], t);

            if(ud["` + o + `"].value !== t)
            {
                ud["` + o + `"].value = t;
                gl.uniform1i(ud["` + o + `"].location, t);
; // eslint-disable-line max-len
            }`;
    }
  },
  // uploading pixi matrix object to mat3
  {
    test: function(o, t) {
      return o.type === "mat3" && o.size === 1 && !o.isArray && t.a !== void 0;
    },
    code: function(o) {
      return `
            gl.uniformMatrix3fv(ud["` + o + '"].location, false, uv["' + o + `"].toArray(true));
            `;
    },
    codeUbo: function(o) {
      return `
                var ` + o + "_matrix = uv." + o + `.toArray(true);

                data[offset] = ` + o + `_matrix[0];
                data[offset+1] = ` + o + `_matrix[1];
                data[offset+2] = ` + o + `_matrix[2];
        
                data[offset + 4] = ` + o + `_matrix[3];
                data[offset + 5] = ` + o + `_matrix[4];
                data[offset + 6] = ` + o + `_matrix[5];
        
                data[offset + 8] = ` + o + `_matrix[6];
                data[offset + 9] = ` + o + `_matrix[7];
                data[offset + 10] = ` + o + `_matrix[8];
            `;
    }
  },
  // uploading a pixi point as a vec2 with caching layer
  {
    test: function(o, t) {
      return o.type === "vec2" && o.size === 1 && !o.isArray && t.x !== void 0;
    },
    code: function(o) {
      return `
                cv = ud["` + o + `"].value;
                v = uv["` + o + `"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["` + o + `"].location, v.x, v.y);
                }`;
    },
    codeUbo: function(o) {
      return `
                v = uv.` + o + `;

                data[offset] = v.x;
                data[offset+1] = v.y;
            `;
    }
  },
  // caching layer for a vec2
  {
    test: function(o) {
      return o.type === "vec2" && o.size === 1 && !o.isArray;
    },
    code: function(o) {
      return `
                cv = ud["` + o + `"].value;
                v = uv["` + o + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["` + o + `"].location, v[0], v[1]);
                }
            `;
    }
  },
  // upload a pixi rectangle as a vec4 with caching layer
  {
    test: function(o, t) {
      return o.type === "vec4" && o.size === 1 && !o.isArray && t.width !== void 0;
    },
    code: function(o) {
      return `
                cv = ud["` + o + `"].value;
                v = uv["` + o + `"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["` + o + `"].location, v.x, v.y, v.width, v.height)
                }`;
    },
    codeUbo: function(o) {
      return `
                    v = uv.` + o + `;

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `;
    }
  },
  // a caching layer for vec4 uploading
  {
    test: function(o) {
      return o.type === "vec4" && o.size === 1 && !o.isArray;
    },
    code: function(o) {
      return `
                cv = ud["` + o + `"].value;
                v = uv["` + o + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["` + o + `"].location, v[0], v[1], v[2], v[3])
                }`;
    }
  }
], GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
}, GLSL_TO_ARRAY_SETTERS = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(o, t) {
  var e, r = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (var D in o.uniforms) {
    var N = t[D];
    if (!N) {
      !((e = o.uniforms[D]) === null || e === void 0) && e.group && (o.uniforms[D].ubo ? r.push(`
                        renderer.shader.syncUniformBufferGroup(uv.` + D + ", '" + D + `');
                    `) : r.push(`
                        renderer.shader.syncUniformGroup(uv.` + D + `, syncData);
                    `));
      continue;
    }
    for (var k = o.uniforms[D], $ = !1, G = 0; G < uniformParsers.length; G++)
      if (uniformParsers[G].test(N, k)) {
        r.push(uniformParsers[G].code(D, k)), $ = !0;
        break;
      }
    if (!$) {
      var U = N.size === 1 && !N.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS, z = U[N.type].replace("location", 'ud["' + D + '"].location');
      r.push(`
            cu = ud["` + D + `"];
            cv = cu.value;
            v = uv["` + D + `"];
            ` + z + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", r.join(`
`));
}
var fragTemplate$1 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function generateIfTestSrc(o) {
  for (var t = "", e = 0; e < o; ++e)
    e > 0 && (t += `
else `), e < o - 1 && (t += "if(test == " + e + ".0){}");
  return t;
}
function checkMaxIfStatementsInShader(o, t) {
  if (o === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  for (var e = t.createShader(t.FRAGMENT_SHADER); ; ) {
    var r = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(o));
    if (t.shaderSource(e, r), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))
      o = o / 2 | 0;
    else
      break;
  }
  return o;
}
var unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval == "boolean")
    return unsafeEval;
  try {
    var o = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = o({ a: "b" }, "a", "b") === !0;
  } catch {
    unsafeEval = !1;
  }
  return unsafeEval;
}
var defaultFragment$2 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`, defaultVertex$3 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`, UID$1 = 0, nameCache = {}, Program = (
  /** @class */
  function() {
    function o(t, e, r) {
      r === void 0 && (r = "pixi-shader"), this.id = UID$1++, this.vertexSrc = t || o.defaultVertexSrc, this.fragmentSrc = e || o.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== "#version" && (r = r.replace(/\s+/g, "-"), nameCache[r] ? (nameCache[r]++, r += "-" + nameCache[r]) : nameCache[r] = 1, this.vertexSrc = "#define SHADER_NAME " + r + `
` + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + r + `
` + this.fragmentSrc, this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION.HIGH), this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision())), this.glPrograms = {}, this.syncUniforms = null;
    }
    return Object.defineProperty(o, "defaultVertexSrc", {
      /**
       * The default vertex shader source.
       * @constant
       */
      get: function() {
        return defaultVertex$3;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o, "defaultFragmentSrc", {
      /**
       * The default fragment shader source.
       * @constant
       */
      get: function() {
        return defaultFragment$2;
      },
      enumerable: !1,
      configurable: !0
    }), o.from = function(t, e, r) {
      var D = t + e, N = ProgramCache[D];
      return N || (ProgramCache[D] = N = new o(t, e, r)), N;
    }, o;
  }()
), Shader = (
  /** @class */
  function() {
    function o(t, e) {
      this.uniformBindCount = 0, this.program = t, e ? e instanceof UniformGroup ? this.uniformGroup = e : this.uniformGroup = new UniformGroup(e) : this.uniformGroup = new UniformGroup({}), this.disposeRunner = new Runner("disposeShader");
    }
    return o.prototype.checkUniformExists = function(t, e) {
      if (e.uniforms[t])
        return !0;
      for (var r in e.uniforms) {
        var D = e.uniforms[r];
        if (D.group && this.checkUniformExists(t, D))
          return !0;
      }
      return !1;
    }, o.prototype.destroy = function() {
      this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();
    }, Object.defineProperty(o.prototype, "uniforms", {
      /**
       * Shader uniform values, shortcut for `uniformGroup.uniforms`.
       * @readonly
       */
      get: function() {
        return this.uniformGroup.uniforms;
      },
      enumerable: !1,
      configurable: !0
    }), o.from = function(t, e, r) {
      var D = Program.from(t, e);
      return new o(D, r);
    }, o;
  }()
), BLEND$1 = 0, OFFSET$1 = 1, CULLING$1 = 2, DEPTH_TEST$1 = 3, WINDING$1 = 4, DEPTH_MASK$1 = 5, State = (
  /** @class */
  function() {
    function o() {
      this.data = 0, this.blendMode = BLEND_MODES.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;
    }
    return Object.defineProperty(o.prototype, "blend", {
      /**
       * Activates blending of the computed fragment color values.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << BLEND$1);
      },
      set: function(t) {
        !!(this.data & 1 << BLEND$1) !== t && (this.data ^= 1 << BLEND$1);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "offsets", {
      /**
       * Activates adding an offset to depth values of polygon's fragments
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << OFFSET$1);
      },
      set: function(t) {
        !!(this.data & 1 << OFFSET$1) !== t && (this.data ^= 1 << OFFSET$1);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "culling", {
      /**
       * Activates culling of polygons.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << CULLING$1);
      },
      set: function(t) {
        !!(this.data & 1 << CULLING$1) !== t && (this.data ^= 1 << CULLING$1);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "depthTest", {
      /**
       * Activates depth comparisons and updates to the depth buffer.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << DEPTH_TEST$1);
      },
      set: function(t) {
        !!(this.data & 1 << DEPTH_TEST$1) !== t && (this.data ^= 1 << DEPTH_TEST$1);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "depthMask", {
      /**
       * Enables or disables writing to the depth buffer.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << DEPTH_MASK$1);
      },
      set: function(t) {
        !!(this.data & 1 << DEPTH_MASK$1) !== t && (this.data ^= 1 << DEPTH_MASK$1);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "clockwiseFrontFace", {
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << WINDING$1);
      },
      set: function(t) {
        !!(this.data & 1 << WINDING$1) !== t && (this.data ^= 1 << WINDING$1);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "blendMode", {
      /**
       * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this._blendMode;
      },
      set: function(t) {
        this.blend = t !== BLEND_MODES.NONE, this._blendMode = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "polygonOffset", {
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       * @default 0
       */
      get: function() {
        return this._polygonOffset;
      },
      set: function(t) {
        this.offsets = !!t, this._polygonOffset = t;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.toString = function() {
      return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
    }, o.for2d = function() {
      var t = new o();
      return t.depthTest = !1, t.blend = !0, t;
    }, o;
  }()
), defaultFragment$1 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`, defaultVertex$2 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, Filter = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e, r, D) {
      var N = this, k = Program.from(e || t.defaultVertexSrc, r || t.defaultFragmentSrc);
      return N = o.call(this, k, D) || this, N.padding = 0, N.resolution = settings.FILTER_RESOLUTION, N.multisample = settings.FILTER_MULTISAMPLE, N.enabled = !0, N.autoFit = !0, N.state = new State(), N;
    }
    return t.prototype.apply = function(e, r, D, N, k) {
      e.applyFilter(this, r, D, N);
    }, Object.defineProperty(t.prototype, "blendMode", {
      /**
       * Sets the blend mode of the filter.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this.state.blendMode;
      },
      set: function(e) {
        this.state.blendMode = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "resolution", {
      /**
       * The resolution of the filter. Setting this to be lower will lower the quality but
       * increase the performance of the filter.
       */
      get: function() {
        return this._resolution;
      },
      set: function(e) {
        this._resolution = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @constant
       */
      get: function() {
        return defaultVertex$2;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t, "defaultFragmentSrc", {
      /**
       * The default fragment shader source
       * @constant
       */
      get: function() {
        return defaultFragment$1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Shader)
), vertex$4 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`, fragment$7 = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`, tempMat$1 = new Matrix(), TextureMatrix = (
  /** @class */
  function() {
    function o(t, e) {
      this._texture = t, this.mapCoord = new Matrix(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof e > "u" ? 0.5 : e, this.isSimple = !1;
    }
    return Object.defineProperty(o.prototype, "texture", {
      /** Texture property. */
      get: function() {
        return this._texture;
      },
      set: function(t) {
        this._texture = t, this._textureID = -1;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.multiplyUvs = function(t, e) {
      e === void 0 && (e = t);
      for (var r = this.mapCoord, D = 0; D < t.length; D += 2) {
        var N = t[D], k = t[D + 1];
        e[D] = N * r.a + k * r.c + r.tx, e[D + 1] = N * r.b + k * r.d + r.ty;
      }
      return e;
    }, o.prototype.update = function(t) {
      var e = this._texture;
      if (!e || !e.valid || !t && this._textureID === e._updateID)
        return !1;
      this._textureID = e._updateID, this._updateID++;
      var r = e._uvs;
      this.mapCoord.set(r.x1 - r.x0, r.y1 - r.y0, r.x3 - r.x0, r.y3 - r.y0, r.x0, r.y0);
      var D = e.orig, N = e.trim;
      N && (tempMat$1.set(D.width / N.width, 0, 0, D.height / N.height, -N.x / N.width, -N.y / N.height), this.mapCoord.append(tempMat$1));
      var k = e.baseTexture, $ = this.uClampFrame, G = this.clampMargin / k.resolution, U = this.clampOffset;
      return $[0] = (e._frame.x + G + U) / k.width, $[1] = (e._frame.y + G + U) / k.height, $[2] = (e._frame.x + e._frame.width - G + U) / k.width, $[3] = (e._frame.y + e._frame.height - G + U) / k.height, this.uClampOffset[0] = U / k.realWidth, this.uClampOffset[1] = U / k.realHeight, this.isSimple = e._frame.width === k.width && e._frame.height === k.height && e.rotate === 0, !0;
    }, o;
  }()
), SpriteMaskFilter = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e, r, D) {
      var N = this, k = null;
      return typeof e != "string" && r === void 0 && D === void 0 && (k = e, e = void 0, r = void 0, D = void 0), N = o.call(this, e || vertex$4, r || fragment$7, D) || this, N.maskSprite = k, N.maskMatrix = new Matrix(), N;
    }
    return Object.defineProperty(t.prototype, "maskSprite", {
      /**
       * Sprite mask
       * @type {PIXI.DisplayObject}
       */
      get: function() {
        return this._maskSprite;
      },
      set: function(e) {
        this._maskSprite = e, this._maskSprite && (this._maskSprite.renderable = !1);
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.apply = function(e, r, D, N) {
      var k = this._maskSprite, $ = k._texture;
      $.valid && ($.uvMatrix || ($.uvMatrix = new TextureMatrix($, 0)), $.uvMatrix.update(), this.uniforms.npmAlpha = $.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = $, this.uniforms.otherMatrix = e.calculateSpriteMatrix(this.maskMatrix, k).prepend($.uvMatrix.mapCoord), this.uniforms.alpha = k.worldAlpha, this.uniforms.maskClamp = $.uvMatrix.uClampFrame, e.applyFilter(this, r, D, N));
    }, t;
  }(Filter)
), MaskSystem = (
  /** @class */
  function() {
    function o(t) {
      this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
    }
    return o.prototype.setMaskStack = function(t) {
      this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t);
    }, o.prototype.push = function(t, e) {
      var r = e;
      if (!r.isMaskData) {
        var D = this.maskDataPool.pop() || new MaskData();
        D.pooled = !0, D.maskObject = e, r = D;
      }
      var N = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      if (r.copyCountersOrReset(N), r._colorMask = N ? N._colorMask : 15, r.autoDetect && this.detect(r), r._target = t, r.type !== MASK_TYPES.SPRITE && this.maskStack.push(r), r.enabled)
        switch (r.type) {
          case MASK_TYPES.SCISSOR:
            this.renderer.scissor.push(r);
            break;
          case MASK_TYPES.STENCIL:
            this.renderer.stencil.push(r);
            break;
          case MASK_TYPES.SPRITE:
            r.copyCountersOrReset(null), this.pushSpriteMask(r);
            break;
          case MASK_TYPES.COLOR:
            this.pushColorMask(r);
            break;
        }
      r.type === MASK_TYPES.SPRITE && this.maskStack.push(r);
    }, o.prototype.pop = function(t) {
      var e = this.maskStack.pop();
      if (!(!e || e._target !== t)) {
        if (e.enabled)
          switch (e.type) {
            case MASK_TYPES.SCISSOR:
              this.renderer.scissor.pop(e);
              break;
            case MASK_TYPES.STENCIL:
              this.renderer.stencil.pop(e.maskObject);
              break;
            case MASK_TYPES.SPRITE:
              this.popSpriteMask(e);
              break;
            case MASK_TYPES.COLOR:
              this.popColorMask(e);
              break;
          }
        if (e.reset(), e.pooled && this.maskDataPool.push(e), this.maskStack.length !== 0) {
          var r = this.maskStack[this.maskStack.length - 1];
          r.type === MASK_TYPES.SPRITE && r._filters && (r._filters[0].maskSprite = r.maskObject);
        }
      }
    }, o.prototype.detect = function(t) {
      var e = t.maskObject;
      e ? e.isSprite ? t.type = MASK_TYPES.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = MASK_TYPES.SCISSOR : t.type = MASK_TYPES.STENCIL : t.type = MASK_TYPES.COLOR;
    }, o.prototype.pushSpriteMask = function(t) {
      var e, r, D = t.maskObject, N = t._target, k = t._filters;
      k || (k = this.alphaMaskPool[this.alphaMaskIndex], k || (k = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()]));
      var $ = this.renderer, G = $.renderTexture, U, z;
      if (G.current) {
        var X = G.current;
        U = t.resolution || X.resolution, z = (e = t.multisample) !== null && e !== void 0 ? e : X.multisample;
      } else
        U = t.resolution || $.resolution, z = (r = t.multisample) !== null && r !== void 0 ? r : $.multisample;
      k[0].resolution = U, k[0].multisample = z, k[0].maskSprite = D;
      var V = N.filterArea;
      N.filterArea = D.getBounds(!0), $.filter.push(N, k), N.filterArea = V, t._filters || this.alphaMaskIndex++;
    }, o.prototype.popSpriteMask = function(t) {
      this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
    }, o.prototype.pushColorMask = function(t) {
      var e = t._colorMask, r = t._colorMask = e & t.colorMask;
      r !== e && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0);
    }, o.prototype.popColorMask = function(t) {
      var e = t._colorMask, r = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
      r !== e && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0);
    }, o.prototype.destroy = function() {
      this.renderer = null;
    }, o;
  }()
), AbstractMaskSystem = (
  /** @class */
  function() {
    function o(t) {
      this.renderer = t, this.maskStack = [], this.glConst = 0;
    }
    return o.prototype.getStackLength = function() {
      return this.maskStack.length;
    }, o.prototype.setMaskStack = function(t) {
      var e = this.renderer.gl, r = this.getStackLength();
      this.maskStack = t;
      var D = this.getStackLength();
      D !== r && (D === 0 ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()));
    }, o.prototype._useCurrent = function() {
    }, o.prototype.destroy = function() {
      this.renderer = null, this.maskStack = null;
    }, o;
  }()
), tempMatrix$1 = new Matrix(), rectPool = [], ScissorSystem = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e) {
      var r = o.call(this, e) || this;
      return r.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST, r;
    }
    return t.prototype.getStackLength = function() {
      var e = this.maskStack[this.maskStack.length - 1];
      return e ? e._scissorCounter : 0;
    }, t.prototype.calcScissorRect = function(e) {
      var r;
      if (!e._scissorRectLocal) {
        var D = e._scissorRect, N = e.maskObject, k = this.renderer, $ = k.renderTexture, G = N.getBounds(!0, (r = rectPool.pop()) !== null && r !== void 0 ? r : new Rectangle());
        this.roundFrameToPixels(G, $.current ? $.current.resolution : k.resolution, $.sourceFrame, $.destinationFrame, k.projection.transform), D && G.fit(D), e._scissorRectLocal = G;
      }
    }, t.isMatrixRotated = function(e) {
      if (!e)
        return !1;
      var r = e.a, D = e.b, N = e.c, k = e.d;
      return (Math.abs(D) > 1e-4 || Math.abs(N) > 1e-4) && (Math.abs(r) > 1e-4 || Math.abs(k) > 1e-4);
    }, t.prototype.testScissor = function(e) {
      var r = e.maskObject;
      if (!r.isFastRect || !r.isFastRect() || t.isMatrixRotated(r.worldTransform) || t.isMatrixRotated(this.renderer.projection.transform))
        return !1;
      this.calcScissorRect(e);
      var D = e._scissorRectLocal;
      return D.width > 0 && D.height > 0;
    }, t.prototype.roundFrameToPixels = function(e, r, D, N, k) {
      t.isMatrixRotated(k) || (k = k ? tempMatrix$1.copyFrom(k) : tempMatrix$1.identity(), k.translate(-D.x, -D.y).scale(N.width / D.width, N.height / D.height).translate(N.x, N.y), this.renderer.filter.transformAABB(k, e), e.fit(N), e.x = Math.round(e.x * r), e.y = Math.round(e.y * r), e.width = Math.round(e.width * r), e.height = Math.round(e.height * r));
    }, t.prototype.push = function(e) {
      e._scissorRectLocal || this.calcScissorRect(e);
      var r = this.renderer.gl;
      e._scissorRect || r.enable(r.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent();
    }, t.prototype.pop = function(e) {
      var r = this.renderer.gl;
      e && rectPool.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : r.disable(r.SCISSOR_TEST);
    }, t.prototype._useCurrent = function() {
      var e = this.maskStack[this.maskStack.length - 1]._scissorRect, r;
      this.renderer.renderTexture.current ? r = e.y : r = this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, r, e.width, e.height);
    }, t;
  }(AbstractMaskSystem)
), StencilSystem = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e) {
      var r = o.call(this, e) || this;
      return r.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST, r;
    }
    return t.prototype.getStackLength = function() {
      var e = this.maskStack[this.maskStack.length - 1];
      return e ? e._stencilCounter : 0;
    }, t.prototype.push = function(e) {
      var r = e.maskObject, D = this.renderer.gl, N = e._stencilCounter;
      N === 0 && (this.renderer.framebuffer.forceStencil(), D.clearStencil(0), D.clear(D.STENCIL_BUFFER_BIT), D.enable(D.STENCIL_TEST)), e._stencilCounter++;
      var k = e._colorMask;
      k !== 0 && (e._colorMask = 0, D.colorMask(!1, !1, !1, !1)), D.stencilFunc(D.EQUAL, N, 4294967295), D.stencilOp(D.KEEP, D.KEEP, D.INCR), r.renderable = !0, r.render(this.renderer), this.renderer.batch.flush(), r.renderable = !1, k !== 0 && (e._colorMask = k, D.colorMask((k & 1) !== 0, (k & 2) !== 0, (k & 4) !== 0, (k & 8) !== 0)), this._useCurrent();
    }, t.prototype.pop = function(e) {
      var r = this.renderer.gl;
      if (this.getStackLength() === 0)
        r.disable(r.STENCIL_TEST);
      else {
        var D = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, N = D ? D._colorMask : 15;
        N !== 0 && (D._colorMask = 0, r.colorMask(!1, !1, !1, !1)), r.stencilOp(r.KEEP, r.KEEP, r.DECR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, N !== 0 && (D._colorMask = N, r.colorMask((N & 1) !== 0, (N & 2) !== 0, (N & 4) !== 0, (N & 8) !== 0)), this._useCurrent();
      }
    }, t.prototype._useCurrent = function() {
      var e = this.renderer.gl;
      e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP);
    }, t;
  }(AbstractMaskSystem)
), ProjectionSystem = (
  /** @class */
  function() {
    function o(t) {
      this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Matrix(), this.transform = null;
    }
    return o.prototype.update = function(t, e, r, D) {
      this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, r, D), this.transform && this.projectionMatrix.append(this.transform);
      var N = this.renderer;
      N.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, N.globalUniforms.update(), N.shader.shader && N.shader.syncUniformGroup(N.shader.shader.uniforms.globals);
    }, o.prototype.calculateProjection = function(t, e, r, D) {
      var N = this.projectionMatrix, k = D ? -1 : 1;
      N.identity(), N.a = 1 / e.width * 2, N.d = k * (1 / e.height * 2), N.tx = -1 - e.x * N.a, N.ty = -k - e.y * N.d;
    }, o.prototype.setTransform = function(t) {
    }, o.prototype.destroy = function() {
      this.renderer = null;
    }, o;
  }()
), tempRect = new Rectangle(), tempRect2 = new Rectangle(), RenderTextureSystem = (
  /** @class */
  function() {
    function o(t) {
      this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.viewportFrame = new Rectangle();
    }
    return o.prototype.bind = function(t, e, r) {
      t === void 0 && (t = null);
      var D = this.renderer;
      this.current = t;
      var N, k, $;
      t ? (N = t.baseTexture, $ = N.resolution, e || (tempRect.width = t.frame.width, tempRect.height = t.frame.height, e = tempRect), r || (tempRect2.x = t.frame.x, tempRect2.y = t.frame.y, tempRect2.width = e.width, tempRect2.height = e.height, r = tempRect2), k = N.framebuffer) : ($ = D.resolution, e || (tempRect.width = D.screen.width, tempRect.height = D.screen.height, e = tempRect), r || (r = tempRect, r.width = e.width, r.height = e.height));
      var G = this.viewportFrame;
      G.x = r.x * $, G.y = r.y * $, G.width = r.width * $, G.height = r.height * $, t || (G.y = D.view.height - (G.y + G.height)), G.ceil(), this.renderer.framebuffer.bind(k, G), this.renderer.projection.update(r, e, $, !k), t ? this.renderer.mask.setMaskStack(N.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(r);
    }, o.prototype.clear = function(t, e) {
      this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.clearColor;
      var r = this.destinationFrame, D = this.current ? this.current.baseTexture : this.renderer.screen, N = r.width !== D.width || r.height !== D.height;
      if (N) {
        var k = this.viewportFrame, $ = k.x, G = k.y, U = k.width, z = k.height;
        $ = Math.round($), G = Math.round(G), U = Math.round(U), z = Math.round(z), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor($, G, U, z);
      }
      this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), N && this.renderer.scissor.pop();
    }, o.prototype.resize = function() {
      this.bind(null);
    }, o.prototype.reset = function() {
      this.bind(null);
    }, o.prototype.destroy = function() {
      this.renderer = null;
    }, o;
  }()
);
function uboUpdate(o, t, e, r, D) {
  e.buffer.update(D);
}
var UBO_TO_SINGLE_SETTERS = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}, GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(o) {
  for (var t = o.map(function(G) {
    return {
      data: G,
      offset: 0,
      dataLen: 0,
      dirty: 0
    };
  }), e = 0, r = 0, D = 0, N = 0; N < t.length; N++) {
    var k = t[N];
    if (e = GLSL_TO_STD40_SIZE[k.data.type], k.data.size > 1 && (e = Math.max(e, 16) * k.data.size), k.dataLen = e, r % e !== 0 && r < 16) {
      var $ = r % e % 16;
      r += $, D += $;
    }
    r + e > 16 ? (D = Math.ceil(D / 16) * 16, k.offset = D, D += e, r = e) : (k.offset = D, r += e, D += e);
  }
  return D = Math.ceil(D / 16) * 16, { uboElements: t, size: D };
}
function getUBOData(o, t) {
  var e = [];
  for (var r in o)
    t[r] && e.push(t[r]);
  return e.sort(function(D, N) {
    return D.index - N.index;
  }), e;
}
function generateUniformBufferSync(o, t) {
  if (!o.autoManage)
    return { size: 0, syncFunc: uboUpdate };
  for (var e = getUBOData(o.uniforms, t), r = createUBOElements(e), D = r.uboElements, N = r.size, k = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `], $ = 0; $ < D.length; $++) {
    for (var G = D[$], U = o.uniforms[G.data.name], z = G.data.name, X = !1, V = 0; V < uniformParsers.length; V++) {
      var Y = uniformParsers[V];
      if (Y.codeUbo && Y.test(G.data, U)) {
        k.push("offset = " + G.offset / 4 + ";", uniformParsers[V].codeUbo(G.data.name, U)), X = !0;
        break;
      }
    }
    if (!X)
      if (G.data.size > 1) {
        var W = mapSize(G.data.type), q = Math.max(GLSL_TO_STD40_SIZE[G.data.type] / 16, 1), K = W / q, Z = (4 - K % 4) % 4;
        k.push(`
                cv = ud.` + z + `.value;
                v = uv.` + z + `;
                offset = ` + G.offset / 4 + `;

                t = 0;

                for(var i=0; i < ` + G.data.size * q + `; i++)
                {
                    for(var j = 0; j < ` + K + `; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ` + Z + `;
                }

                `);
      } else {
        var J = UBO_TO_SINGLE_SETTERS[G.data.type];
        k.push(`
                cv = ud.` + z + `.value;
                v = uv.` + z + `;
                offset = ` + G.offset / 4 + `;
                ` + J + `;
                `);
      }
  }
  return k.push(`
       renderer.buffer.update(buffer);
    `), {
    size: N,
    // eslint-disable-next-line no-new-func
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", k.join(`
`))
  };
}
var IGLUniformData = (
  /** @class */
  function() {
    function o() {
    }
    return o;
  }()
), GLProgram = (
  /** @class */
  function() {
    function o(t, e) {
      this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
    }
    return o.prototype.destroy = function() {
      this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
    }, o;
  }()
);
function getAttributeData(o, t) {
  for (var e = {}, r = t.getProgramParameter(o, t.ACTIVE_ATTRIBUTES), D = 0; D < r; D++) {
    var N = t.getActiveAttrib(o, D);
    if (N.name.indexOf("gl_") !== 0) {
      var k = mapType(t, N.type), $ = {
        type: k,
        name: N.name,
        size: mapSize(k),
        location: t.getAttribLocation(o, N.name)
      };
      e[N.name] = $;
    }
  }
  return e;
}
function getUniformData(o, t) {
  for (var e = {}, r = t.getProgramParameter(o, t.ACTIVE_UNIFORMS), D = 0; D < r; D++) {
    var N = t.getActiveUniform(o, D), k = N.name.replace(/\[.*?\]$/, ""), $ = !!N.name.match(/\[.*?\]$/), G = mapType(t, N.type);
    e[k] = {
      name: k,
      index: D,
      type: G,
      size: N.size,
      isArray: $,
      value: defaultValue(G, N.size)
    };
  }
  return e;
}
function generateProgram(o, t) {
  var e = compileShader(o, o.VERTEX_SHADER, t.vertexSrc), r = compileShader(o, o.FRAGMENT_SHADER, t.fragmentSrc), D = o.createProgram();
  if (o.attachShader(D, e), o.attachShader(D, r), o.linkProgram(D), o.getProgramParameter(D, o.LINK_STATUS) || logProgramError(o, D, e, r), t.attributeData = getAttributeData(D, o), t.uniformData = getUniformData(D, o), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc)) {
    var N = Object.keys(t.attributeData);
    N.sort(function(z, X) {
      return z > X ? 1 : -1;
    });
    for (var k = 0; k < N.length; k++)
      t.attributeData[N[k]].location = k, o.bindAttribLocation(D, k, N[k]);
    o.linkProgram(D);
  }
  o.deleteShader(e), o.deleteShader(r);
  var $ = {};
  for (var k in t.uniformData) {
    var G = t.uniformData[k];
    $[k] = {
      location: o.getUniformLocation(D, k),
      value: defaultValue(G.type, G.size)
    };
  }
  var U = new GLProgram(D, $);
  return U;
}
var UID = 0, defaultSyncData = { textureCount: 0, uboCount: 0 }, ShaderSystem = (
  /** @class */
  function() {
    function o(t) {
      this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = UID++;
    }
    return o.prototype.systemCheck = function() {
      if (!unsafeEvalSupported())
        throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }, o.prototype.contextChange = function(t) {
      this.gl = t, this.reset();
    }, o.prototype.bind = function(t, e) {
      t.disposeRunner.add(this), t.uniforms.globals = this.renderer.globalUniforms;
      var r = t.program, D = r.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
      return this.shader = t, this.program !== r && (this.program = r, this.gl.useProgram(D.program)), e || (defaultSyncData.textureCount = 0, defaultSyncData.uboCount = 0, this.syncUniformGroup(t.uniformGroup, defaultSyncData)), D;
    }, o.prototype.setUniforms = function(t) {
      var e = this.shader.program, r = e.glPrograms[this.renderer.CONTEXT_UID];
      e.syncUniforms(r.uniformData, t, this.renderer);
    }, o.prototype.syncUniformGroup = function(t, e) {
      var r = this.getGlProgram();
      (!t.static || t.dirtyId !== r.uniformDirtyGroups[t.id]) && (r.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, r, e));
    }, o.prototype.syncUniforms = function(t, e, r) {
      var D = t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t);
      D(e.uniformData, t.uniforms, this.renderer, r);
    }, o.prototype.createSyncGroups = function(t) {
      var e = this.getSignature(t, this.shader.program.uniformData, "u");
      return this.cache[e] || (this.cache[e] = generateUniformsSync(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id];
    }, o.prototype.syncUniformBufferGroup = function(t, e) {
      var r = this.getGlProgram();
      if (!t.static || t.dirtyId !== 0 || !r.uniformGroups[t.id]) {
        t.dirtyId = 0;
        var D = r.uniformGroups[t.id] || this.createSyncBufferGroup(t, r, e);
        t.buffer.update(), D(r.uniformData, t.uniforms, this.renderer, defaultSyncData, t.buffer);
      }
      this.renderer.buffer.bindBufferBase(t.buffer, r.uniformBufferBindings[e]);
    }, o.prototype.createSyncBufferGroup = function(t, e, r) {
      var D = this.renderer.gl;
      this.renderer.buffer.bind(t.buffer);
      var N = this.gl.getUniformBlockIndex(e.program, r);
      e.uniformBufferBindings[r] = this.shader.uniformBindCount, D.uniformBlockBinding(e.program, N, this.shader.uniformBindCount), this.shader.uniformBindCount++;
      var k = this.getSignature(t, this.shader.program.uniformData, "ubo"), $ = this._uboCache[k];
      if ($ || ($ = this._uboCache[k] = generateUniformBufferSync(t, this.shader.program.uniformData)), t.autoManage) {
        var G = new Float32Array($.size / 4);
        t.buffer.update(G);
      }
      return e.uniformGroups[t.id] = $.syncFunc, e.uniformGroups[t.id];
    }, o.prototype.getSignature = function(t, e, r) {
      var D = t.uniforms, N = [r + "-"];
      for (var k in D)
        N.push(k), e[k] && N.push(e[k].type);
      return N.join("-");
    }, o.prototype.getGlProgram = function() {
      return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
    }, o.prototype.generateProgram = function(t) {
      var e = this.gl, r = t.program, D = generateProgram(e, r);
      return r.glPrograms[this.renderer.CONTEXT_UID] = D, D;
    }, o.prototype.reset = function() {
      this.program = null, this.shader = null;
    }, o.prototype.disposeShader = function(t) {
      this.shader === t && (this.shader = null);
    }, o.prototype.destroy = function() {
      this.renderer = null, this.destroyed = !0;
    }, o;
  }()
);
function mapWebGLBlendModesToPixi(o, t) {
  return t === void 0 && (t = []), t[BLEND_MODES.NORMAL] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.ADD] = [o.ONE, o.ONE], t[BLEND_MODES.MULTIPLY] = [o.DST_COLOR, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SCREEN] = [o.ONE, o.ONE_MINUS_SRC_COLOR, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.OVERLAY] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DARKEN] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.LIGHTEN] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.COLOR_DODGE] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.COLOR_BURN] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.HARD_LIGHT] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SOFT_LIGHT] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DIFFERENCE] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.EXCLUSION] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.HUE] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SATURATION] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.COLOR] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.LUMINOSITY] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.NONE] = [0, 0], t[BLEND_MODES.NORMAL_NPM] = [o.SRC_ALPHA, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.ADD_NPM] = [o.SRC_ALPHA, o.ONE, o.ONE, o.ONE], t[BLEND_MODES.SCREEN_NPM] = [o.SRC_ALPHA, o.ONE_MINUS_SRC_COLOR, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SRC_IN] = [o.DST_ALPHA, o.ZERO], t[BLEND_MODES.SRC_OUT] = [o.ONE_MINUS_DST_ALPHA, o.ZERO], t[BLEND_MODES.SRC_ATOP] = [o.DST_ALPHA, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DST_OVER] = [o.ONE_MINUS_DST_ALPHA, o.ONE], t[BLEND_MODES.DST_IN] = [o.ZERO, o.SRC_ALPHA], t[BLEND_MODES.DST_OUT] = [o.ZERO, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DST_ATOP] = [o.ONE_MINUS_DST_ALPHA, o.SRC_ALPHA], t[BLEND_MODES.XOR] = [o.ONE_MINUS_DST_ALPHA, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SUBTRACT] = [o.ONE, o.ONE, o.ONE, o.ONE, o.FUNC_REVERSE_SUBTRACT, o.FUNC_ADD], t;
}
var BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5, StateSystem = (
  /** @class */
  function() {
    function o() {
      this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = BLEND_MODES.NONE, this._blendEq = !1, this.map = [], this.map[BLEND] = this.setBlend, this.map[OFFSET] = this.setOffset, this.map[CULLING] = this.setCullFace, this.map[DEPTH_TEST] = this.setDepthTest, this.map[WINDING] = this.setFrontFace, this.map[DEPTH_MASK] = this.setDepthMask, this.checks = [], this.defaultState = new State(), this.defaultState.blend = !0;
    }
    return o.prototype.contextChange = function(t) {
      this.gl = t, this.blendModes = mapWebGLBlendModesToPixi(t), this.set(this.defaultState), this.reset();
    }, o.prototype.set = function(t) {
      if (t = t || this.defaultState, this.stateId !== t.data) {
        for (var e = this.stateId ^ t.data, r = 0; e; )
          e & 1 && this.map[r].call(this, !!(t.data & 1 << r)), e = e >> 1, r++;
        this.stateId = t.data;
      }
      for (var r = 0; r < this.checks.length; r++)
        this.checks[r](this, t);
    }, o.prototype.forceState = function(t) {
      t = t || this.defaultState;
      for (var e = 0; e < this.map.length; e++)
        this.map[e].call(this, !!(t.data & 1 << e));
      for (var e = 0; e < this.checks.length; e++)
        this.checks[e](this, t);
      this.stateId = t.data;
    }, o.prototype.setBlend = function(t) {
      this.updateCheck(o.checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND);
    }, o.prototype.setOffset = function(t) {
      this.updateCheck(o.checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    }, o.prototype.setDepthTest = function(t) {
      this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST);
    }, o.prototype.setDepthMask = function(t) {
      this.gl.depthMask(t);
    }, o.prototype.setCullFace = function(t) {
      this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE);
    }, o.prototype.setFrontFace = function(t) {
      this.gl.frontFace(this.gl[t ? "CW" : "CCW"]);
    }, o.prototype.setBlendMode = function(t) {
      if (t !== this.blendMode) {
        this.blendMode = t;
        var e = this.blendModes[t], r = this.gl;
        e.length === 2 ? r.blendFunc(e[0], e[1]) : r.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, r.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD));
      }
    }, o.prototype.setPolygonOffset = function(t, e) {
      this.gl.polygonOffset(t, e);
    }, o.prototype.reset = function() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);
    }, o.prototype.updateCheck = function(t, e) {
      var r = this.checks.indexOf(t);
      e && r === -1 ? this.checks.push(t) : !e && r !== -1 && this.checks.splice(r, 1);
    }, o.checkBlendMode = function(t, e) {
      t.setBlendMode(e.blendMode);
    }, o.checkPolygonOffset = function(t, e) {
      t.setPolygonOffset(1, e.polygonOffset);
    }, o.prototype.destroy = function() {
      this.gl = null;
    }, o;
  }()
), TextureGCSystem = (
  /** @class */
  function() {
    function o(t) {
      this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = settings.GC_MAX_IDLE, this.checkCountMax = settings.GC_MAX_CHECK_COUNT, this.mode = settings.GC_MODE;
    }
    return o.prototype.postrender = function() {
      this.renderer.renderingToScreen && (this.count++, this.mode !== GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
    }, o.prototype.run = function() {
      for (var t = this.renderer.texture, e = t.managedTextures, r = !1, D = 0; D < e.length; D++) {
        var N = e[D];
        !N.framebuffer && this.count - N.touched > this.maxIdle && (t.destroyTexture(N, !0), e[D] = null, r = !0);
      }
      if (r) {
        for (var k = 0, D = 0; D < e.length; D++)
          e[D] !== null && (e[k++] = e[D]);
        e.length = k;
      }
    }, o.prototype.unload = function(t) {
      var e = this.renderer.texture, r = t._texture;
      r && !r.framebuffer && e.destroyTexture(r);
      for (var D = t.children.length - 1; D >= 0; D--)
        this.unload(t.children[D]);
    }, o.prototype.destroy = function() {
      this.renderer = null;
    }, o;
  }()
);
function mapTypeAndFormatToInternalFormat(o) {
  var t, e, r, D, N, k, $, G, U, z, X, V, Y, W, q, K, Z, J, Q, et, it, tt, nt;
  return "WebGL2RenderingContext" in globalThis && o instanceof globalThis.WebGL2RenderingContext ? nt = (t = {}, t[TYPES.UNSIGNED_BYTE] = (e = {}, e[FORMATS.RGBA] = o.RGBA8, e[FORMATS.RGB] = o.RGB8, e[FORMATS.RG] = o.RG8, e[FORMATS.RED] = o.R8, e[FORMATS.RGBA_INTEGER] = o.RGBA8UI, e[FORMATS.RGB_INTEGER] = o.RGB8UI, e[FORMATS.RG_INTEGER] = o.RG8UI, e[FORMATS.RED_INTEGER] = o.R8UI, e[FORMATS.ALPHA] = o.ALPHA, e[FORMATS.LUMINANCE] = o.LUMINANCE, e[FORMATS.LUMINANCE_ALPHA] = o.LUMINANCE_ALPHA, e), t[TYPES.BYTE] = (r = {}, r[FORMATS.RGBA] = o.RGBA8_SNORM, r[FORMATS.RGB] = o.RGB8_SNORM, r[FORMATS.RG] = o.RG8_SNORM, r[FORMATS.RED] = o.R8_SNORM, r[FORMATS.RGBA_INTEGER] = o.RGBA8I, r[FORMATS.RGB_INTEGER] = o.RGB8I, r[FORMATS.RG_INTEGER] = o.RG8I, r[FORMATS.RED_INTEGER] = o.R8I, r), t[TYPES.UNSIGNED_SHORT] = (D = {}, D[FORMATS.RGBA_INTEGER] = o.RGBA16UI, D[FORMATS.RGB_INTEGER] = o.RGB16UI, D[FORMATS.RG_INTEGER] = o.RG16UI, D[FORMATS.RED_INTEGER] = o.R16UI, D[FORMATS.DEPTH_COMPONENT] = o.DEPTH_COMPONENT16, D), t[TYPES.SHORT] = (N = {}, N[FORMATS.RGBA_INTEGER] = o.RGBA16I, N[FORMATS.RGB_INTEGER] = o.RGB16I, N[FORMATS.RG_INTEGER] = o.RG16I, N[FORMATS.RED_INTEGER] = o.R16I, N), t[TYPES.UNSIGNED_INT] = (k = {}, k[FORMATS.RGBA_INTEGER] = o.RGBA32UI, k[FORMATS.RGB_INTEGER] = o.RGB32UI, k[FORMATS.RG_INTEGER] = o.RG32UI, k[FORMATS.RED_INTEGER] = o.R32UI, k[FORMATS.DEPTH_COMPONENT] = o.DEPTH_COMPONENT24, k), t[TYPES.INT] = ($ = {}, $[FORMATS.RGBA_INTEGER] = o.RGBA32I, $[FORMATS.RGB_INTEGER] = o.RGB32I, $[FORMATS.RG_INTEGER] = o.RG32I, $[FORMATS.RED_INTEGER] = o.R32I, $), t[TYPES.FLOAT] = (G = {}, G[FORMATS.RGBA] = o.RGBA32F, G[FORMATS.RGB] = o.RGB32F, G[FORMATS.RG] = o.RG32F, G[FORMATS.RED] = o.R32F, G[FORMATS.DEPTH_COMPONENT] = o.DEPTH_COMPONENT32F, G), t[TYPES.HALF_FLOAT] = (U = {}, U[FORMATS.RGBA] = o.RGBA16F, U[FORMATS.RGB] = o.RGB16F, U[FORMATS.RG] = o.RG16F, U[FORMATS.RED] = o.R16F, U), t[TYPES.UNSIGNED_SHORT_5_6_5] = (z = {}, z[FORMATS.RGB] = o.RGB565, z), t[TYPES.UNSIGNED_SHORT_4_4_4_4] = (X = {}, X[FORMATS.RGBA] = o.RGBA4, X), t[TYPES.UNSIGNED_SHORT_5_5_5_1] = (V = {}, V[FORMATS.RGBA] = o.RGB5_A1, V), t[TYPES.UNSIGNED_INT_2_10_10_10_REV] = (Y = {}, Y[FORMATS.RGBA] = o.RGB10_A2, Y[FORMATS.RGBA_INTEGER] = o.RGB10_A2UI, Y), t[TYPES.UNSIGNED_INT_10F_11F_11F_REV] = (W = {}, W[FORMATS.RGB] = o.R11F_G11F_B10F, W), t[TYPES.UNSIGNED_INT_5_9_9_9_REV] = (q = {}, q[FORMATS.RGB] = o.RGB9_E5, q), t[TYPES.UNSIGNED_INT_24_8] = (K = {}, K[FORMATS.DEPTH_STENCIL] = o.DEPTH24_STENCIL8, K), t[TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV] = (Z = {}, Z[FORMATS.DEPTH_STENCIL] = o.DEPTH32F_STENCIL8, Z), t) : nt = (J = {}, J[TYPES.UNSIGNED_BYTE] = (Q = {}, Q[FORMATS.RGBA] = o.RGBA, Q[FORMATS.RGB] = o.RGB, Q[FORMATS.ALPHA] = o.ALPHA, Q[FORMATS.LUMINANCE] = o.LUMINANCE, Q[FORMATS.LUMINANCE_ALPHA] = o.LUMINANCE_ALPHA, Q), J[TYPES.UNSIGNED_SHORT_5_6_5] = (et = {}, et[FORMATS.RGB] = o.RGB, et), J[TYPES.UNSIGNED_SHORT_4_4_4_4] = (it = {}, it[FORMATS.RGBA] = o.RGBA, it), J[TYPES.UNSIGNED_SHORT_5_5_5_1] = (tt = {}, tt[FORMATS.RGBA] = o.RGBA, tt), J), nt;
}
var GLTexture = (
  /** @class */
  function() {
    function o(t) {
      this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = TYPES.UNSIGNED_BYTE, this.internalFormat = FORMATS.RGBA, this.samplerType = 0;
    }
    return o;
  }()
), TextureSystem = (
  /** @class */
  function() {
    function o(t) {
      this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new BaseTexture(), this.hasIntegerTextures = !1;
    }
    return o.prototype.contextChange = function() {
      var t = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat(t);
      var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = e;
      for (var r = 0; r < e; r++)
        this.boundTextures[r] = null;
      this.emptyTextures = {};
      var D = new GLTexture(t.createTexture());
      t.bindTexture(t.TEXTURE_2D, D.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = D, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new GLTexture(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
      for (var r = 0; r < 6; r++)
        t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
      t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
      for (var r = 0; r < this.boundTextures.length; r++)
        this.bind(null, r);
    }, o.prototype.bind = function(t, e) {
      e === void 0 && (e = 0);
      var r = this.gl;
      if (t = t == null ? void 0 : t.castToBaseTexture(), t && t.valid && !t.parentTextureArray) {
        t.touched = this.renderer.textureGC.count;
        var D = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
        this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(t.target, D.texture)), D.dirtyId !== t.dirtyId ? (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), this.updateTexture(t)) : D.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t), this.boundTextures[e] = t;
      } else
        this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(r.TEXTURE_2D, this.emptyTextures[r.TEXTURE_2D].texture), this.boundTextures[e] = null;
    }, o.prototype.reset = function() {
      this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;
      for (var t = 0; t < this.boundTextures.length; t++)
        this.boundTextures[t] = this.unknownTexture;
    }, o.prototype.unbind = function(t) {
      var e = this, r = e.gl, D = e.boundTextures;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = !1;
        for (var N = 0; N < D.length; N++)
          D[N] === this.unknownTexture && this.bind(null, N);
      }
      for (var N = 0; N < D.length; N++)
        D[N] === t && (this.currentLocation !== N && (r.activeTexture(r.TEXTURE0 + N), this.currentLocation = N), r.bindTexture(t.target, this.emptyTextures[t.target].texture), D[N] = null);
    }, o.prototype.ensureSamplerType = function(t) {
      var e = this, r = e.boundTextures, D = e.hasIntegerTextures, N = e.CONTEXT_UID;
      if (D)
        for (var k = t - 1; k >= 0; --k) {
          var $ = r[k];
          if ($) {
            var G = $._glTextures[N];
            G.samplerType !== SAMPLER_TYPES.FLOAT && this.renderer.texture.unbind($);
          }
        }
    }, o.prototype.initTexture = function(t) {
      var e = new GLTexture(this.gl.createTexture());
      return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), e;
    }, o.prototype.initTextureType = function(t, e) {
      var r, D;
      e.internalFormat = (D = (r = this.internalFormats[t.type]) === null || r === void 0 ? void 0 : r[t.format]) !== null && D !== void 0 ? D : t.format, this.webGLVersion === 2 && t.type === TYPES.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type;
    }, o.prototype.updateTexture = function(t) {
      var e = t._glTextures[this.CONTEXT_UID];
      if (e) {
        var r = this.renderer;
        if (this.initTextureType(t, e), t.resource && t.resource.upload(r, t, e))
          e.samplerType !== SAMPLER_TYPES.FLOAT && (this.hasIntegerTextures = !0);
        else {
          var D = t.realWidth, N = t.realHeight, k = r.gl;
          (e.width !== D || e.height !== N || e.dirtyId < 0) && (e.width = D, e.height = N, k.texImage2D(t.target, 0, e.internalFormat, D, N, 0, t.format, e.type, null));
        }
        t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId;
      }
    }, o.prototype.destroyTexture = function(t, e) {
      var r = this.gl;
      if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), r.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {
        var D = this.managedTextures.indexOf(t);
        D !== -1 && removeItems(this.managedTextures, D, 1);
      }
    }, o.prototype.updateTextureStyle = function(t) {
      var e = t._glTextures[this.CONTEXT_UID];
      e && ((t.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? e.mipmap = !1 : e.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? e.wrapMode = WRAP_MODES.CLAMP : e.wrapMode = t.wrapMode, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId);
    }, o.prototype.setStyle = function(t, e) {
      var r = this.gl;
      if (e.mipmap && t.mipmap !== MIPMAP_MODES.ON_MANUAL && r.generateMipmap(t.target), r.texParameteri(t.target, r.TEXTURE_WRAP_S, e.wrapMode), r.texParameteri(t.target, r.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {
        r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES.LINEAR ? r.LINEAR_MIPMAP_LINEAR : r.NEAREST_MIPMAP_NEAREST);
        var D = this.renderer.context.extensions.anisotropicFiltering;
        if (D && t.anisotropicLevel > 0 && t.scaleMode === SCALE_MODES.LINEAR) {
          var N = Math.min(t.anisotropicLevel, r.getParameter(D.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          r.texParameterf(t.target, D.TEXTURE_MAX_ANISOTROPY_EXT, N);
        }
      } else
        r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES.LINEAR ? r.LINEAR : r.NEAREST);
      r.texParameteri(t.target, r.TEXTURE_MAG_FILTER, t.scaleMode === SCALE_MODES.LINEAR ? r.LINEAR : r.NEAREST);
    }, o.prototype.destroy = function() {
      this.renderer = null;
    }, o;
  }()
), _systems = {
  __proto__: null,
  FilterSystem,
  BatchSystem,
  ContextSystem,
  FramebufferSystem,
  GeometrySystem,
  MaskSystem,
  ScissorSystem,
  StencilSystem,
  ProjectionSystem,
  RenderTextureSystem,
  ShaderSystem,
  StateSystem,
  TextureGCSystem,
  TextureSystem
}, tempMatrix = new Matrix(), AbstractRenderer = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e, r) {
      e === void 0 && (e = RENDERER_TYPE.UNKNOWN);
      var D = o.call(this) || this;
      return r = Object.assign({}, settings.RENDER_OPTIONS, r), D.options = r, D.type = e, D.screen = new Rectangle(0, 0, r.width, r.height), D.view = r.view || settings.ADAPTER.createCanvas(), D.resolution = r.resolution || settings.RESOLUTION, D.useContextAlpha = r.useContextAlpha, D.autoDensity = !!r.autoDensity, D.preserveDrawingBuffer = r.preserveDrawingBuffer, D.clearBeforeRender = r.clearBeforeRender, D._backgroundColor = 0, D._backgroundColorRgba = [0, 0, 0, 1], D._backgroundColorString = "#000000", D.backgroundColor = r.backgroundColor || D._backgroundColor, D.backgroundAlpha = r.backgroundAlpha, r.transparent !== void 0 && (deprecation("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), D.useContextAlpha = r.transparent, D.backgroundAlpha = r.transparent ? 0 : 1), D._lastObjectRendered = null, D.plugins = {}, D;
    }
    return t.prototype.initPlugins = function(e) {
      for (var r in e)
        this.plugins[r] = new e[r](this);
    }, Object.defineProperty(t.prototype, "width", {
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal.
       * @member {number}
       * @readonly
       * @default 800
       */
      get: function() {
        return this.view.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /**
       * Same as view.height, actual number of pixels in the canvas by vertical.
       * @member {number}
       * @readonly
       * @default 600
       */
      get: function() {
        return this.view.height;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.resize = function(e, r) {
      this.view.width = Math.round(e * this.resolution), this.view.height = Math.round(r * this.resolution);
      var D = this.view.width / this.resolution, N = this.view.height / this.resolution;
      this.screen.width = D, this.screen.height = N, this.autoDensity && (this.view.style.width = D + "px", this.view.style.height = N + "px"), this.emit("resize", D, N);
    }, t.prototype.generateTexture = function(e, r, D, N) {
      r === void 0 && (r = {}), typeof r == "number" && (deprecation("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), r = { scaleMode: r, resolution: D, region: N });
      var k = r.region, $ = __rest$3(r, ["region"]);
      N = k || e.getLocalBounds(null, !0), N.width === 0 && (N.width = 1), N.height === 0 && (N.height = 1);
      var G = RenderTexture.create(__assign$7({ width: N.width, height: N.height }, $));
      return tempMatrix.tx = -N.x, tempMatrix.ty = -N.y, this.render(e, {
        renderTexture: G,
        clear: !1,
        transform: tempMatrix,
        skipUpdateTransform: !!e.parent
      }), G;
    }, t.prototype.destroy = function(e) {
      for (var r in this.plugins)
        this.plugins[r].destroy(), this.plugins[r] = null;
      e && this.view.parentNode && this.view.parentNode.removeChild(this.view);
      var D = this;
      D.plugins = null, D.type = RENDERER_TYPE.UNKNOWN, D.view = null, D.screen = null, D._tempDisplayObjectParent = null, D.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;
    }, Object.defineProperty(t.prototype, "backgroundColor", {
      /**
       * The background color to fill if not transparent
       * @member {number}
       */
      get: function() {
        return this._backgroundColor;
      },
      set: function(e) {
        this._backgroundColor = e, this._backgroundColorString = hex2string(e), hex2rgb(e, this._backgroundColorRgba);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "backgroundAlpha", {
      /**
       * The background color alpha. Setting this to 0 will make the canvas transparent.
       * @member {number}
       */
      get: function() {
        return this._backgroundColorRgba[3];
      },
      set: function(e) {
        this._backgroundColorRgba[3] = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(i$1)
), GLBuffer = (
  /** @class */
  function() {
    function o(t) {
      this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
    }
    return o;
  }()
), BufferSystem = (
  /** @class */
  function() {
    function o(t) {
      this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {};
    }
    return o.prototype.destroy = function() {
      this.renderer = null;
    }, o.prototype.contextChange = function() {
      this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    }, o.prototype.bind = function(t) {
      var e = this, r = e.gl, D = e.CONTEXT_UID, N = t._glBuffers[D] || this.createGLBuffer(t);
      r.bindBuffer(t.type, N.buffer);
    }, o.prototype.bindBufferBase = function(t, e) {
      var r = this, D = r.gl, N = r.CONTEXT_UID;
      if (this.boundBufferBases[e] !== t) {
        var k = t._glBuffers[N] || this.createGLBuffer(t);
        this.boundBufferBases[e] = t, D.bindBufferBase(D.UNIFORM_BUFFER, e, k.buffer);
      }
    }, o.prototype.bindBufferRange = function(t, e, r) {
      var D = this, N = D.gl, k = D.CONTEXT_UID;
      r = r || 0;
      var $ = t._glBuffers[k] || this.createGLBuffer(t);
      N.bindBufferRange(N.UNIFORM_BUFFER, e || 0, $.buffer, r * 256, 256);
    }, o.prototype.update = function(t) {
      var e = this, r = e.gl, D = e.CONTEXT_UID, N = t._glBuffers[D];
      if (t._updateID !== N.updateID)
        if (N.updateID = t._updateID, r.bindBuffer(t.type, N.buffer), N.byteLength >= t.data.byteLength)
          r.bufferSubData(t.type, 0, t.data);
        else {
          var k = t.static ? r.STATIC_DRAW : r.DYNAMIC_DRAW;
          N.byteLength = t.data.byteLength, r.bufferData(t.type, t.data, k);
        }
    }, o.prototype.dispose = function(t, e) {
      if (this.managedBuffers[t.id]) {
        delete this.managedBuffers[t.id];
        var r = t._glBuffers[this.CONTEXT_UID], D = this.gl;
        t.disposeRunner.remove(this), r && (e || D.deleteBuffer(r.buffer), delete t._glBuffers[this.CONTEXT_UID]);
      }
    }, o.prototype.disposeAll = function(t) {
      for (var e = Object.keys(this.managedBuffers), r = 0; r < e.length; r++)
        this.dispose(this.managedBuffers[e[r]], t);
    }, o.prototype.createGLBuffer = function(t) {
      var e = this, r = e.CONTEXT_UID, D = e.gl;
      return t._glBuffers[r] = new GLBuffer(D.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[r];
    }, o;
  }()
), Renderer = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e) {
      var r = o.call(this, RENDERER_TYPE.WEBGL, e) || this;
      return e = r.options, r.gl = null, r.CONTEXT_UID = 0, r.runners = {
        destroy: new Runner("destroy"),
        contextChange: new Runner("contextChange"),
        reset: new Runner("reset"),
        update: new Runner("update"),
        postrender: new Runner("postrender"),
        prerender: new Runner("prerender"),
        resize: new Runner("resize")
      }, r.runners.contextChange.add(r), r.globalUniforms = new UniformGroup({
        projectionMatrix: new Matrix()
      }, !0), r.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(BufferSystem, "buffer").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch"), r.initPlugins(t.__plugins), r.multisample = void 0, e.context ? r.context.initFromContext(e.context) : r.context.initFromOptions({
        alpha: !!r.useContextAlpha,
        antialias: e.antialias,
        premultipliedAlpha: r.useContextAlpha && r.useContextAlpha !== "notMultiplied",
        stencil: !0,
        preserveDrawingBuffer: e.preserveDrawingBuffer,
        powerPreference: r.options.powerPreference
      }), r.renderingToScreen = !0, sayHello(r.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1"), r.resize(r.options.width, r.options.height), r;
    }
    return t.create = function(e) {
      if (isWebGLSupported())
        return new t(e);
      throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
    }, t.prototype.contextChange = function() {
      var e = this.gl, r;
      if (this.context.webGLVersion === 1) {
        var D = e.getParameter(e.FRAMEBUFFER_BINDING);
        e.bindFramebuffer(e.FRAMEBUFFER, null), r = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, D);
      } else {
        var D = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);
        e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), r = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, D);
      }
      r >= MSAA_QUALITY.HIGH ? this.multisample = MSAA_QUALITY.HIGH : r >= MSAA_QUALITY.MEDIUM ? this.multisample = MSAA_QUALITY.MEDIUM : r >= MSAA_QUALITY.LOW ? this.multisample = MSAA_QUALITY.LOW : this.multisample = MSAA_QUALITY.NONE;
    }, t.prototype.addSystem = function(e, r) {
      var D = new e(this);
      if (this[r])
        throw new Error('Whoops! The name "' + r + '" is already in use');
      this[r] = D;
      for (var N in this.runners)
        this.runners[N].add(D);
      return this;
    }, t.prototype.render = function(e, r) {
      var D, N, k, $;
      if (r && (r instanceof RenderTexture ? (deprecation("6.0.0", "Renderer#render arguments changed, use options instead."), D = r, N = arguments[2], k = arguments[3], $ = arguments[4]) : (D = r.renderTexture, N = r.clear, k = r.transform, $ = r.skipUpdateTransform)), this.renderingToScreen = !D, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = k, !this.context.isLost) {
        if (D || (this._lastObjectRendered = e), !$) {
          var G = e.enableTempParent();
          e.updateTransform(), e.disableTempParent(G);
        }
        this.renderTexture.bind(D), this.batch.currentRenderer.start(), (N !== void 0 ? N : this.clearBeforeRender) && this.renderTexture.clear(), e.render(this), this.batch.currentRenderer.flush(), D && D.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender");
      }
    }, t.prototype.generateTexture = function(e, r, D, N) {
      r === void 0 && (r = {});
      var k = o.prototype.generateTexture.call(this, e, r, D, N);
      return this.framebuffer.blit(), k;
    }, t.prototype.resize = function(e, r) {
      o.prototype.resize.call(this, e, r), this.runners.resize.emit(this.screen.height, this.screen.width);
    }, t.prototype.reset = function() {
      return this.runners.reset.emit(), this;
    }, t.prototype.clear = function() {
      this.renderTexture.bind(), this.renderTexture.clear();
    }, t.prototype.destroy = function(e) {
      this.runners.destroy.emit();
      for (var r in this.runners)
        this.runners[r].destroy();
      o.prototype.destroy.call(this, e), this.gl = null;
    }, Object.defineProperty(t.prototype, "extract", {
      /**
       * Please use `plugins.extract` instead.
       * @member {PIXI.Extract} extract
       * @deprecated since 6.0.0
       * @readonly
       */
      get: function() {
        return deprecation("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract;
      },
      enumerable: !1,
      configurable: !0
    }), t.registerPlugin = function(e, r) {
      deprecation("6.5.0", "Renderer.registerPlugin() has been deprecated, please use extensions.add() instead."), extensions.add({
        name: e,
        type: ExtensionType.RendererPlugin,
        ref: r
      });
    }, t.__plugins = {}, t;
  }(AbstractRenderer)
);
extensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
function autoDetectRenderer(o) {
  return Renderer.create(o);
}
var $defaultVertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`, $defaultFilterVertex = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, defaultVertex$1 = $defaultVertex, defaultFilterVertex = $defaultFilterVertex, System = (
  /** @class */
  function() {
    function o(t) {
      deprecation("6.1.0", "System class is deprecated, implemement ISystem interface instead."), this.renderer = t;
    }
    return o.prototype.destroy = function() {
      this.renderer = null;
    }, o;
  }()
), BatchDrawCall = (
  /** @class */
  function() {
    function o() {
      this.texArray = null, this.blend = 0, this.type = DRAW_MODES.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
    }
    return o;
  }()
), BatchTextureArray = (
  /** @class */
  function() {
    function o() {
      this.elements = [], this.ids = [], this.count = 0;
    }
    return o.prototype.clear = function() {
      for (var t = 0; t < this.count; t++)
        this.elements[t] = null;
      this.count = 0;
    }, o;
  }()
), ViewableBuffer = (
  /** @class */
  function() {
    function o(t) {
      typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
    }
    return Object.defineProperty(o.prototype, "int8View", {
      /** View on the raw binary data as a `Int8Array`. */
      get: function() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "uint8View", {
      /** View on the raw binary data as a `Uint8Array`. */
      get: function() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "int16View", {
      /**  View on the raw binary data as a `Int16Array`. */
      get: function() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "uint16View", {
      /** View on the raw binary data as a `Uint16Array`. */
      get: function() {
        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "int32View", {
      /** View on the raw binary data as a `Int32Array`. */
      get: function() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.view = function(t) {
      return this[t + "View"];
    }, o.prototype.destroy = function() {
      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
    }, o.sizeOf = function(t) {
      switch (t) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(t + " isn't a valid view type");
      }
    }, o;
  }()
), AbstractBatchRenderer = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e) {
      var r = o.call(this, e) || this;
      return r.shaderGenerator = null, r.geometryClass = null, r.vertexSize = null, r.state = State.for2d(), r.size = settings.SPRITE_BATCH_SIZE * 4, r._vertexCount = 0, r._indexCount = 0, r._bufferedElements = [], r._bufferedTextures = [], r._bufferSize = 0, r._shader = null, r._packedGeometries = [], r._packedGeometryPoolSize = 2, r._flushId = 0, r._aBuffers = {}, r._iBuffers = {}, r.MAX_TEXTURES = 1, r.renderer.on("prerender", r.onPrerender, r), e.runners.contextChange.add(r), r._dcIndex = 0, r._aIndex = 0, r._iIndex = 0, r._attributeBuffer = null, r._indexBuffer = null, r._tempBoundTextures = [], r;
    }
    return t.prototype.contextChange = function() {
      var e = this.renderer.gl;
      settings.PREFER_ENV === ENV.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, e)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
      for (var r = 0; r < this._packedGeometryPoolSize; r++)
        this._packedGeometries[r] = new this.geometryClass();
      this.initFlushBuffers();
    }, t.prototype.initFlushBuffers = function() {
      for (var e = t._drawCallPool, r = t._textureArrayPool, D = this.size / 4, N = Math.floor(D / this.MAX_TEXTURES) + 1; e.length < D; )
        e.push(new BatchDrawCall());
      for (; r.length < N; )
        r.push(new BatchTextureArray());
      for (var k = 0; k < this.MAX_TEXTURES; k++)
        this._tempBoundTextures[k] = null;
    }, t.prototype.onPrerender = function() {
      this._flushId = 0;
    }, t.prototype.render = function(e) {
      e._texture.valid && (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e);
    }, t.prototype.buildTexturesAndDrawCalls = function() {
      var e = this, r = e._bufferedTextures, D = e.MAX_TEXTURES, N = t._textureArrayPool, k = this.renderer.batch, $ = this._tempBoundTextures, G = this.renderer.textureGC.count, U = ++BaseTexture._globalBatch, z = 0, X = N[0], V = 0;
      k.copyBoundTextures($, D);
      for (var Y = 0; Y < this._bufferSize; ++Y) {
        var W = r[Y];
        r[Y] = null, W._batchEnabled !== U && (X.count >= D && (k.boundArray(X, $, U, D), this.buildDrawCalls(X, V, Y), V = Y, X = N[++z], ++U), W._batchEnabled = U, W.touched = G, X.elements[X.count++] = W);
      }
      X.count > 0 && (k.boundArray(X, $, U, D), this.buildDrawCalls(X, V, this._bufferSize), ++z, ++U);
      for (var Y = 0; Y < $.length; Y++)
        $[Y] = null;
      BaseTexture._globalBatch = U;
    }, t.prototype.buildDrawCalls = function(e, r, D) {
      var N = this, k = N._bufferedElements, $ = N._attributeBuffer, G = N._indexBuffer, U = N.vertexSize, z = t._drawCallPool, X = this._dcIndex, V = this._aIndex, Y = this._iIndex, W = z[X];
      W.start = this._iIndex, W.texArray = e;
      for (var q = r; q < D; ++q) {
        var K = k[q], Z = K._texture.baseTexture, J = premultiplyBlendMode[Z.alphaMode ? 1 : 0][K.blendMode];
        k[q] = null, r < q && W.blend !== J && (W.size = Y - W.start, r = q, W = z[++X], W.texArray = e, W.start = Y), this.packInterleavedGeometry(K, $, G, V, Y), V += K.vertexData.length / 2 * U, Y += K.indices.length, W.blend = J;
      }
      r < D && (W.size = Y - W.start, ++X), this._dcIndex = X, this._aIndex = V, this._iIndex = Y;
    }, t.prototype.bindAndClearTexArray = function(e) {
      for (var r = this.renderer.texture, D = 0; D < e.count; D++)
        r.bind(e.elements[D], e.ids[D]), e.elements[D] = null;
      e.count = 0;
    }, t.prototype.updateGeometry = function() {
      var e = this, r = e._packedGeometries, D = e._attributeBuffer, N = e._indexBuffer;
      settings.CAN_UPLOAD_SAME_BUFFER ? (r[this._flushId]._buffer.update(D.rawBinaryData), r[this._flushId]._indexBuffer.update(N), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, r[this._flushId] = new this.geometryClass()), r[this._flushId]._buffer.update(D.rawBinaryData), r[this._flushId]._indexBuffer.update(N), this.renderer.geometry.bind(r[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
    }, t.prototype.drawBatches = function() {
      for (var e = this._dcIndex, r = this.renderer, D = r.gl, N = r.state, k = t._drawCallPool, $ = null, G = 0; G < e; G++) {
        var U = k[G], z = U.texArray, X = U.type, V = U.size, Y = U.start, W = U.blend;
        $ !== z && ($ = z, this.bindAndClearTexArray(z)), this.state.blendMode = W, N.set(this.state), D.drawElements(X, V, D.UNSIGNED_SHORT, Y * 2);
      }
    }, t.prototype.flush = function() {
      this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
    }, t.prototype.start = function() {
      this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), settings.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }, t.prototype.stop = function() {
      this.flush();
    }, t.prototype.destroy = function() {
      for (var e = 0; e < this._packedGeometryPoolSize; e++)
        this._packedGeometries[e] && this._packedGeometries[e].destroy();
      this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), o.prototype.destroy.call(this);
    }, t.prototype.getAttributeBuffer = function(e) {
      var r = nextPow2(Math.ceil(e / 8)), D = log2(r), N = r * 8;
      this._aBuffers.length <= D && (this._iBuffers.length = D + 1);
      var k = this._aBuffers[N];
      return k || (this._aBuffers[N] = k = new ViewableBuffer(N * this.vertexSize * 4)), k;
    }, t.prototype.getIndexBuffer = function(e) {
      var r = nextPow2(Math.ceil(e / 12)), D = log2(r), N = r * 12;
      this._iBuffers.length <= D && (this._iBuffers.length = D + 1);
      var k = this._iBuffers[D];
      return k || (this._iBuffers[D] = k = new Uint16Array(N)), k;
    }, t.prototype.packInterleavedGeometry = function(e, r, D, N, k) {
      for (var $ = r.uint32View, G = r.float32View, U = N / this.vertexSize, z = e.uvs, X = e.indices, V = e.vertexData, Y = e._texture.baseTexture._batchLocation, W = Math.min(e.worldAlpha, 1), q = W < 1 && e._texture.baseTexture.alphaMode ? premultiplyTint(e._tintRGB, W) : e._tintRGB + (W * 255 << 24), K = 0; K < V.length; K += 2)
        G[N++] = V[K], G[N++] = V[K + 1], G[N++] = z[K], G[N++] = z[K + 1], $[N++] = q, G[N++] = Y;
      for (var K = 0; K < X.length; K++)
        D[k++] = U + X[K];
    }, t._drawCallPool = [], t._textureArrayPool = [], t;
  }(ObjectRenderer)
), BatchShaderGenerator = (
  /** @class */
  function() {
    function o(t, e) {
      if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf("%count%") < 0)
        throw new Error('Fragment template must contain "%count%".');
      if (e.indexOf("%forloop%") < 0)
        throw new Error('Fragment template must contain "%forloop%".');
    }
    return o.prototype.generateShader = function(t) {
      if (!this.programCache[t]) {
        for (var e = new Int32Array(t), r = 0; r < t; r++)
          e[r] = r;
        this.defaultGroupCache[t] = UniformGroup.from({ uSamplers: e }, !0);
        var D = this.fragTemplate;
        D = D.replace(/%count%/gi, "" + t), D = D.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new Program(this.vertexSrc, D);
      }
      var N = {
        tint: new Float32Array([1, 1, 1, 1]),
        translationMatrix: new Matrix(),
        default: this.defaultGroupCache[t]
      };
      return new Shader(this.programCache[t], N);
    }, o.prototype.generateSampleSrc = function(t) {
      var e = "";
      e += `
`, e += `
`;
      for (var r = 0; r < t; r++)
        r > 0 && (e += `
else `), r < t - 1 && (e += "if(vTextureId < " + r + ".5)"), e += `
{`, e += `
	color = texture2D(uSamplers[` + r + "], vTextureCoord);", e += `
}`;
      return e += `
`, e += `
`, e;
    }, o;
  }()
), BatchGeometry = (
  /** @class */
  function(o) {
    __extends$o(t, o);
    function t(e) {
      e === void 0 && (e = !1);
      var r = o.call(this) || this;
      return r._buffer = new Buffer$1(null, e, !1), r._indexBuffer = new Buffer$1(null, e, !0), r.addAttribute("aVertexPosition", r._buffer, 2, !1, TYPES.FLOAT).addAttribute("aTextureCoord", r._buffer, 2, !1, TYPES.FLOAT).addAttribute("aColor", r._buffer, 4, !0, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", r._buffer, 1, !0, TYPES.FLOAT).addIndex(r._indexBuffer), r;
    }
    return t;
  }(Geometry)
), defaultVertex = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`, defaultFragment = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`, BatchPluginFactory = (
  /** @class */
  function() {
    function o() {
    }
    return o.create = function(t) {
      var e = Object.assign({
        vertex: defaultVertex,
        fragment: defaultFragment,
        geometryClass: BatchGeometry,
        vertexSize: 6
      }, t), r = e.vertex, D = e.fragment, N = e.vertexSize, k = e.geometryClass;
      return (
        /** @class */
        function($) {
          __extends$o(G, $);
          function G(U) {
            var z = $.call(this, U) || this;
            return z.shaderGenerator = new BatchShaderGenerator(r, D), z.geometryClass = k, z.vertexSize = N, z;
          }
          return G;
        }(AbstractBatchRenderer)
      );
    }, Object.defineProperty(o, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @readonly
       */
      get: function() {
        return defaultVertex;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o, "defaultFragmentTemplate", {
      /**
       * The default fragment shader source
       * @readonly
       */
      get: function() {
        return defaultFragment;
      },
      enumerable: !1,
      configurable: !0
    }), o;
  }()
), BatchRenderer = BatchPluginFactory.create();
Object.assign(BatchRenderer, {
  extension: {
    name: "batch",
    type: ExtensionType.RendererPlugin
  }
});
var resources = {}, _loop_1 = function(o) {
  Object.defineProperty(resources, o, {
    get: function() {
      return deprecation("6.0.0", "PIXI.systems." + o + " has moved to PIXI." + o), _resources[o];
    }
  });
};
for (var name in _resources)
  _loop_1(name);
var systems = {}, _loop_2 = function(o) {
  Object.defineProperty(systems, o, {
    get: function() {
      return deprecation("6.0.0", "PIXI.resources." + o + " has moved to PIXI." + o), _systems[o];
    }
  });
};
for (var name in _systems)
  _loop_2(name);
var VERSION = "6.5.9";
const n = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbstractBatchRenderer,
  AbstractMultiResource,
  AbstractRenderer,
  ArrayResource,
  Attribute,
  BaseImageResource,
  BaseRenderTexture,
  BaseTexture,
  BatchDrawCall,
  BatchGeometry,
  BatchPluginFactory,
  BatchRenderer,
  BatchShaderGenerator,
  BatchSystem,
  BatchTextureArray,
  Buffer: Buffer$1,
  BufferResource,
  CanvasResource,
  ContextSystem,
  CubeResource,
  get ExtensionType() {
    return ExtensionType;
  },
  Filter,
  FilterState,
  FilterSystem,
  Framebuffer,
  FramebufferSystem,
  GLFramebuffer,
  GLProgram,
  GLTexture,
  Geometry,
  GeometrySystem,
  IGLUniformData,
  INSTALLED,
  ImageBitmapResource,
  ImageResource,
  MaskData,
  MaskSystem,
  ObjectRenderer,
  Program,
  ProjectionSystem,
  Quad,
  QuadUv,
  RenderTexture,
  RenderTexturePool,
  RenderTextureSystem,
  Renderer,
  Resource,
  SVGResource,
  ScissorSystem,
  Shader,
  ShaderSystem,
  SpriteMaskFilter,
  State,
  StateSystem,
  StencilSystem,
  System,
  Texture,
  TextureGCSystem,
  TextureMatrix,
  TextureSystem,
  TextureUvs,
  UniformGroup,
  VERSION,
  VideoResource,
  ViewableBuffer,
  autoDetectRenderer,
  autoDetectResource,
  checkMaxIfStatementsInShader,
  createUBOElements,
  defaultFilterVertex,
  defaultVertex: defaultVertex$1,
  extensions,
  generateProgram,
  generateUniformBufferSync,
  getTestContext,
  getUBOData,
  resources,
  systems,
  uniformParsers
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * @pixi/accessibility - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/accessibility is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var accessibleTarget = {
  /**
   *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
   *   shadow div with attributes set
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  accessible: !1,
  /**
   * Sets the title attribute of the shadow div
   * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
   * @member {?string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleTitle: null,
  /**
   * Sets the aria-label attribute of the shadow div
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleHint: null,
  /**
   * @member {number}
   * @memberof PIXI.DisplayObject#
   * @private
   * @todo Needs docs.
   */
  tabIndex: 0,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleActive: !1,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleDiv: null,
  /**
   * Specify the type of div the accessible layer is. Screen readers treat the element differently
   * depending on this type. Defaults to button.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'button'
   */
  accessibleType: "button",
  /**
   * Specify the pointer-events the accessible div will use
   * Defaults to auto.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'auto'
   */
  accessiblePointerEvents: "auto",
  /**
   * Setting to false will prevent any children inside this container to
   * be accessible. Defaults to true.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @default true
   */
  accessibleChildren: !0,
  renderId: -1
};
DisplayObject.mixin(accessibleTarget);
var KEY_CODE_TAB = 9, DIV_TOUCH_SIZE = 100, DIV_TOUCH_POS_X = 0, DIV_TOUCH_POS_Y = 0, DIV_TOUCH_ZINDEX = 2, DIV_HOOK_SIZE = 1, DIV_HOOK_POS_X = -1e3, DIV_HOOK_POS_Y = -1e3, DIV_HOOK_ZINDEX = 2, AccessibilityManager = (
  /** @class */
  function() {
    function o(t) {
      this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (isMobile.tablet || isMobile.phone) && this.createTouchHook();
      var e = document.createElement("div");
      e.style.width = DIV_TOUCH_SIZE + "px", e.style.height = DIV_TOUCH_SIZE + "px", e.style.position = "absolute", e.style.top = DIV_TOUCH_POS_X + "px", e.style.left = DIV_TOUCH_POS_Y + "px", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1);
    }
    return Object.defineProperty(o.prototype, "isActive", {
      /**
       * Value of `true` if accessibility is currently active and accessibility layers are showing.
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this._isActive;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "isMobileAccessibility", {
      /**
       * Value of `true` if accessibility is enabled for touch devices.
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this._isMobileAccessibility;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.createTouchHook = function() {
      var t = this, e = document.createElement("button");
      e.style.width = DIV_HOOK_SIZE + "px", e.style.height = DIV_HOOK_SIZE + "px", e.style.position = "absolute", e.style.top = DIV_HOOK_POS_X + "px", e.style.left = DIV_HOOK_POS_Y + "px", e.style.zIndex = DIV_HOOK_ZINDEX.toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessibility for this content", e.addEventListener("focus", function() {
        t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook();
      }), document.body.appendChild(e), this._hookDiv = e;
    }, o.prototype.destroyTouchHook = function() {
      this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
    }, o.prototype.activate = function() {
      var t;
      this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), (t = this.renderer.view.parentNode) === null || t === void 0 || t.appendChild(this.div));
    }, o.prototype.deactivate = function() {
      var t;
      !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), (t = this.div.parentNode) === null || t === void 0 || t.removeChild(this.div));
    }, o.prototype.updateAccessibleObjects = function(t) {
      if (!(!t.visible || !t.accessibleChildren)) {
        t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);
        var e = t.children;
        if (e)
          for (var r = 0; r < e.length; r++)
            this.updateAccessibleObjects(e[r]);
      }
    }, o.prototype.update = function() {
      var t = performance.now();
      if (!(isMobile.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, !!this.renderer.renderingToScreen)) {
        this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);
        var e = this.renderer.view.getBoundingClientRect(), r = e.left, D = e.top, N = e.width, k = e.height, $ = this.renderer, G = $.width, U = $.height, z = $.resolution, X = N / G * z, V = k / U * z, Y = this.div;
        Y.style.left = r + "px", Y.style.top = D + "px", Y.style.width = G + "px", Y.style.height = U + "px";
        for (var W = 0; W < this.children.length; W++) {
          var q = this.children[W];
          if (q.renderId !== this.renderId)
            q._accessibleActive = !1, removeItems(this.children, W, 1), this.div.removeChild(q._accessibleDiv), this.pool.push(q._accessibleDiv), q._accessibleDiv = null, W--;
          else {
            Y = q._accessibleDiv;
            var K = q.hitArea, Z = q.worldTransform;
            q.hitArea ? (Y.style.left = (Z.tx + K.x * Z.a) * X + "px", Y.style.top = (Z.ty + K.y * Z.d) * V + "px", Y.style.width = K.width * Z.a * X + "px", Y.style.height = K.height * Z.d * V + "px") : (K = q.getBounds(), this.capHitArea(K), Y.style.left = K.x * X + "px", Y.style.top = K.y * V + "px", Y.style.width = K.width * X + "px", Y.style.height = K.height * V + "px", Y.title !== q.accessibleTitle && q.accessibleTitle !== null && (Y.title = q.accessibleTitle), Y.getAttribute("aria-label") !== q.accessibleHint && q.accessibleHint !== null && Y.setAttribute("aria-label", q.accessibleHint)), (q.accessibleTitle !== Y.title || q.tabIndex !== Y.tabIndex) && (Y.title = q.accessibleTitle, Y.tabIndex = q.tabIndex, this.debug && this.updateDebugHTML(Y));
          }
        }
        this.renderId++;
      }
    }, o.prototype.updateDebugHTML = function(t) {
      t.innerHTML = "type: " + t.type + "</br> title : " + t.title + "</br> tabIndex: " + t.tabIndex;
    }, o.prototype.capHitArea = function(t) {
      t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
      var e = this.renderer, r = e.width, D = e.height;
      t.x + t.width > r && (t.width = r - t.x), t.y + t.height > D && (t.height = D - t.y);
    }, o.prototype.addChild = function(t) {
      var e = this.pool.pop();
      e || (e = document.createElement("button"), e.style.width = DIV_TOUCH_SIZE + "px", e.style.height = DIV_TOUCH_SIZE + "px", e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = "displayObject " + t.tabIndex), t.accessibleHint && t.accessibleHint !== null && e.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex;
    }, o.prototype._onClick = function(t) {
      var e = this.renderer.plugins.interaction, r = t.target.displayObject, D = e.eventData;
      e.dispatchEvent(r, "click", D), e.dispatchEvent(r, "pointertap", D), e.dispatchEvent(r, "tap", D);
    }, o.prototype._onFocus = function(t) {
      t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive");
      var e = this.renderer.plugins.interaction, r = t.target.displayObject, D = e.eventData;
      e.dispatchEvent(r, "mouseover", D);
    }, o.prototype._onFocusOut = function(t) {
      t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite");
      var e = this.renderer.plugins.interaction, r = t.target.displayObject, D = e.eventData;
      e.dispatchEvent(r, "mouseout", D);
    }, o.prototype._onKeyDown = function(t) {
      t.keyCode === KEY_CODE_TAB && this.activate();
    }, o.prototype._onMouseMove = function(t) {
      t.movementX === 0 && t.movementY === 0 || this.deactivate();
    }, o.prototype.destroy = function() {
      this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;
    }, o.extension = {
      name: "accessibility",
      type: [
        ExtensionType.RendererPlugin,
        ExtensionType.CanvasRendererPlugin
      ]
    }, o;
  }()
);
/*!
 * @pixi/interaction - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var InteractionData = (
  /** @class */
  function() {
    function o() {
      this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new Point(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;
    }
    return Object.defineProperty(o.prototype, "pointerId", {
      /**
       * The unique identifier of the pointer. It will be the same as `identifier`.
       * @readonly
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
       */
      get: function() {
        return this.identifier;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.getLocalPosition = function(t, e, r) {
      return t.worldTransform.applyInverse(r || this.global, e);
    }, o.prototype.copyEvent = function(t) {
      "isPrimary" in t && t.isPrimary && (this.isPrimary = !0), this.button = "button" in t && t.button;
      var e = "buttons" in t && t.buttons;
      this.buttons = Number.isInteger(e) ? e : "which" in t && t.which, this.width = "width" in t && t.width, this.height = "height" in t && t.height, this.tiltX = "tiltX" in t && t.tiltX, this.tiltY = "tiltY" in t && t.tiltY, this.pointerType = "pointerType" in t && t.pointerType, this.pressure = "pressure" in t && t.pressure, this.rotationAngle = "rotationAngle" in t && t.rotationAngle, this.twist = "twist" in t && t.twist || 0, this.tangentialPressure = "tangentialPressure" in t && t.tangentialPressure || 0;
    }, o.prototype.reset = function() {
      this.isPrimary = !1;
    }, o;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$n = function(o, t) {
  return extendStatics$n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$n(o, t);
};
function __extends$n(o, t) {
  extendStatics$n(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var InteractionEvent = (
  /** @class */
  function() {
    function o() {
      this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null;
    }
    return o.prototype.stopPropagation = function() {
      this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget;
    }, o.prototype.reset = function() {
      this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null;
    }, o;
  }()
), InteractionTrackingData = (
  /** @class */
  function() {
    function o(t) {
      this._pointerId = t, this._flags = o.FLAGS.NONE;
    }
    return o.prototype._doSet = function(t, e) {
      e ? this._flags = this._flags | t : this._flags = this._flags & ~t;
    }, Object.defineProperty(o.prototype, "pointerId", {
      /**
       * Unique pointer id of the event
       * @readonly
       * @private
       * @member {number}
       */
      get: function() {
        return this._pointerId;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "flags", {
      /**
       * State of the tracking data, expressed as bit flags
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags;
      },
      set: function(t) {
        this._flags = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "none", {
      /**
       * Is the tracked event inactive (not over or down)?
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags === o.FLAGS.NONE;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "over", {
      /**
       * Is the tracked event over the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & o.FLAGS.OVER) !== 0;
      },
      set: function(t) {
        this._doSet(o.FLAGS.OVER, t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "rightDown", {
      /**
       * Did the right mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & o.FLAGS.RIGHT_DOWN) !== 0;
      },
      set: function(t) {
        this._doSet(o.FLAGS.RIGHT_DOWN, t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "leftDown", {
      /**
       * Did the left mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & o.FLAGS.LEFT_DOWN) !== 0;
      },
      set: function(t) {
        this._doSet(o.FLAGS.LEFT_DOWN, t);
      },
      enumerable: !1,
      configurable: !0
    }), o.FLAGS = Object.freeze({
      NONE: 0,
      OVER: 1 << 0,
      LEFT_DOWN: 1 << 1,
      RIGHT_DOWN: 1 << 2
    }), o;
  }()
), TreeSearch = (
  /** @class */
  function() {
    function o() {
      this._tempPoint = new Point();
    }
    return o.prototype.recursiveFindHit = function(t, e, r, D, N) {
      var k;
      if (!e || !e.visible)
        return !1;
      var $ = t.data.global;
      N = e.interactive || N;
      var G = !1, U = N, z = !0;
      if (e.hitArea)
        D && (e.worldTransform.applyInverse($, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? G = !0 : (D = !1, z = !1)), U = !1;
      else if (e._mask && D) {
        var X = e._mask.isMaskData ? e._mask.maskObject : e._mask;
        X && !(!((k = X.containsPoint) === null || k === void 0) && k.call(X, $)) && (D = !1);
      }
      if (z && e.interactiveChildren && e.children)
        for (var V = e.children, Y = V.length - 1; Y >= 0; Y--) {
          var W = V[Y], q = this.recursiveFindHit(t, W, r, D, U);
          if (q) {
            if (!W.parent)
              continue;
            U = !1, q && (t.target && (D = !1), G = !0);
          }
        }
      return N && (D && !t.target && !e.hitArea && e.containsPoint && e.containsPoint($) && (G = !0), e.interactive && (G && !t.target && (t.target = e), r && r(t, e, !!G))), G;
    }, o.prototype.findHit = function(t, e, r, D) {
      this.recursiveFindHit(t, e, r, D, !1);
    }, o;
  }()
), interactiveTarget = {
  interactive: !1,
  interactiveChildren: !0,
  hitArea: null,
  /**
   * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
   * Setting this changes the 'cursor' property to `'pointer'`.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.buttonMode = true;
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  get buttonMode() {
    return this.cursor === "pointer";
  },
  set buttonMode(o) {
    o ? this.cursor = "pointer" : this.cursor === "pointer" && (this.cursor = null);
  },
  /**
   * This defines what cursor mode is used when the mouse cursor
   * is hovered over the displayObject.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.cursor = 'wait';
   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  cursor: null,
  /**
   * Internal set of all active pointers, by identifier
   * @member {Map<number, InteractionTrackingData>}
   * @memberof PIXI.DisplayObject#
   * @private
   */
  get trackedPointers() {
    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;
  },
  /**
   * Map of all tracked pointers, by identifier. Use trackedPointers to access.
   * @private
   * @type {Map<number, InteractionTrackingData>}
   */
  _trackedPointers: void 0
};
DisplayObject.mixin(interactiveTarget);
var MOUSE_POINTER_ID = 1, hitTestEvent = {
  target: null,
  data: {
    global: null
  }
}, InteractionManager = (
  /** @class */
  function(o) {
    __extends$n(t, o);
    function t(e, r) {
      var D = o.call(this) || this;
      return r = r || {}, D.renderer = e, D.autoPreventDefault = r.autoPreventDefault !== void 0 ? r.autoPreventDefault : !0, D.interactionFrequency = r.interactionFrequency || 10, D.mouse = new InteractionData(), D.mouse.identifier = MOUSE_POINTER_ID, D.mouse.global.set(-999999), D.activeInteractionData = {}, D.activeInteractionData[MOUSE_POINTER_ID] = D.mouse, D.interactionDataPool = [], D.eventData = new InteractionEvent(), D.interactionDOMElement = null, D.moveWhenInside = !1, D.eventsAdded = !1, D.tickerAdded = !1, D.mouseOverRenderer = !("PointerEvent" in globalThis), D.supportsTouchEvents = "ontouchstart" in globalThis, D.supportsPointerEvents = !!globalThis.PointerEvent, D.onPointerUp = D.onPointerUp.bind(D), D.processPointerUp = D.processPointerUp.bind(D), D.onPointerCancel = D.onPointerCancel.bind(D), D.processPointerCancel = D.processPointerCancel.bind(D), D.onPointerDown = D.onPointerDown.bind(D), D.processPointerDown = D.processPointerDown.bind(D), D.onPointerMove = D.onPointerMove.bind(D), D.processPointerMove = D.processPointerMove.bind(D), D.onPointerOut = D.onPointerOut.bind(D), D.processPointerOverOut = D.processPointerOverOut.bind(D), D.onPointerOver = D.onPointerOver.bind(D), D.cursorStyles = {
        default: "inherit",
        pointer: "pointer"
      }, D.currentCursorMode = null, D.cursor = null, D.resolution = 1, D.delayedEvents = [], D.search = new TreeSearch(), D._tempDisplayObject = new TemporaryDisplayObject(), D._eventListenerOptions = { capture: !0, passive: !1 }, D._useSystemTicker = r.useSystemTicker !== void 0 ? r.useSystemTicker : !0, D.setTargetElement(D.renderer.view, D.renderer.resolution), D;
    }
    return Object.defineProperty(t.prototype, "useSystemTicker", {
      /**
       * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.
       * @default true
       */
      get: function() {
        return this._useSystemTicker;
      },
      set: function(e) {
        this._useSystemTicker = e, e ? this.addTickerListener() : this.removeTickerListener();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastObjectRendered", {
      /**
       * Last rendered object or temp object.
       * @readonly
       * @protected
       */
      get: function() {
        return this.renderer._lastObjectRendered || this._tempDisplayObject;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.hitTest = function(e, r) {
      return hitTestEvent.target = null, hitTestEvent.data.global = e, r || (r = this.lastObjectRendered), this.processInteractive(hitTestEvent, r, null, !0), hitTestEvent.target;
    }, t.prototype.setTargetElement = function(e, r) {
      r === void 0 && (r = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = e, this.resolution = r, this.addEvents(), this.addTickerListener();
    }, t.prototype.addTickerListener = function() {
      this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker || (Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION), this.tickerAdded = !0);
    }, t.prototype.removeTickerListener = function() {
      this.tickerAdded && (Ticker.system.remove(this.tickerUpdate, this), this.tickerAdded = !1);
    }, t.prototype.addEvents = function() {
      if (!(this.eventsAdded || !this.interactionDOMElement)) {
        var e = this.interactionDOMElement.style;
        globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "none", e.msTouchAction = "none") : this.supportsPointerEvents && (e.touchAction = "none"), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0;
      }
    }, t.prototype.removeEvents = function() {
      if (!(!this.eventsAdded || !this.interactionDOMElement)) {
        var e = this.interactionDOMElement.style;
        globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "", e.msTouchAction = "") : this.supportsPointerEvents && (e.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1;
      }
    }, t.prototype.tickerUpdate = function(e) {
      this._deltaTime += e, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());
    }, t.prototype.update = function() {
      if (this.interactionDOMElement) {
        if (this._didMove) {
          this._didMove = !1;
          return;
        }
        this.cursor = null;
        for (var e in this.activeInteractionData)
          if (this.activeInteractionData.hasOwnProperty(e)) {
            var r = this.activeInteractionData[e];
            if (r.originalEvent && r.pointerType !== "touch") {
              var D = this.configureInteractionEventForDOMEvent(this.eventData, r.originalEvent, r);
              this.processInteractive(D, this.lastObjectRendered, this.processPointerOverOut, !0);
            }
          }
        this.setCursorMode(this.cursor);
      }
    }, t.prototype.setCursorMode = function(e) {
      e = e || "default";
      var r = !0;
      if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (r = !1), this.currentCursorMode !== e) {
        this.currentCursorMode = e;
        var D = this.cursorStyles[e];
        if (D)
          switch (typeof D) {
            case "string":
              r && (this.interactionDOMElement.style.cursor = D);
              break;
            case "function":
              D(e);
              break;
            case "object":
              r && Object.assign(this.interactionDOMElement.style, D);
              break;
          }
        else
          r && typeof e == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.interactionDOMElement.style.cursor = e);
      }
    }, t.prototype.dispatchEvent = function(e, r, D) {
      (!D.stopPropagationHint || e === D.stopsPropagatingAt) && (D.currentTarget = e, D.type = r, e.emit(r, D), e[r] && e[r](D));
    }, t.prototype.delayDispatchEvent = function(e, r, D) {
      this.delayedEvents.push({ displayObject: e, eventString: r, eventData: D });
    }, t.prototype.mapPositionToPoint = function(e, r, D) {
      var N;
      this.interactionDOMElement.parentElement ? N = this.interactionDOMElement.getBoundingClientRect() : N = {
        x: 0,
        y: 0,
        width: this.interactionDOMElement.width,
        height: this.interactionDOMElement.height,
        left: 0,
        top: 0
      };
      var k = 1 / this.resolution;
      e.x = (r - N.left) * (this.interactionDOMElement.width / N.width) * k, e.y = (D - N.top) * (this.interactionDOMElement.height / N.height) * k;
    }, t.prototype.processInteractive = function(e, r, D, N) {
      var k = this.search.findHit(e, r, D, N), $ = this.delayedEvents;
      if (!$.length)
        return k;
      e.stopPropagationHint = !1;
      var G = $.length;
      this.delayedEvents = [];
      for (var U = 0; U < G; U++) {
        var z = $[U], X = z.displayObject, V = z.eventString, Y = z.eventData;
        Y.stopsPropagatingAt === X && (Y.stopPropagationHint = !0), this.dispatchEvent(X, V, Y);
      }
      return k;
    }, t.prototype.onPointerDown = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var r = this.normalizeToPointerData(e);
        if (this.autoPreventDefault && r[0].isNormalized) {
          var D = e.cancelable || !("cancelable" in e);
          D && e.preventDefault();
        }
        for (var N = r.length, k = 0; k < N; k++) {
          var $ = r[k], G = this.getInteractionDataForPointerId($), U = this.configureInteractionEventForDOMEvent(this.eventData, $, G);
          if (U.data.originalEvent = e, this.processInteractive(U, this.lastObjectRendered, this.processPointerDown, !0), this.emit("pointerdown", U), $.pointerType === "touch")
            this.emit("touchstart", U);
          else if ($.pointerType === "mouse" || $.pointerType === "pen") {
            var z = $.button === 2;
            this.emit(z ? "rightdown" : "mousedown", this.eventData);
          }
        }
      }
    }, t.prototype.processPointerDown = function(e, r, D) {
      var N = e.data, k = e.data.identifier;
      if (D) {
        if (r.trackedPointers[k] || (r.trackedPointers[k] = new InteractionTrackingData(k)), this.dispatchEvent(r, "pointerdown", e), N.pointerType === "touch")
          this.dispatchEvent(r, "touchstart", e);
        else if (N.pointerType === "mouse" || N.pointerType === "pen") {
          var $ = N.button === 2;
          $ ? r.trackedPointers[k].rightDown = !0 : r.trackedPointers[k].leftDown = !0, this.dispatchEvent(r, $ ? "rightdown" : "mousedown", e);
        }
      }
    }, t.prototype.onPointerComplete = function(e, r, D) {
      var N = this.normalizeToPointerData(e), k = N.length, $ = e.target;
      e.composedPath && e.composedPath().length > 0 && ($ = e.composedPath()[0]);
      for (var G = $ !== this.interactionDOMElement ? "outside" : "", U = 0; U < k; U++) {
        var z = N[U], X = this.getInteractionDataForPointerId(z), V = this.configureInteractionEventForDOMEvent(this.eventData, z, X);
        if (V.data.originalEvent = e, this.processInteractive(V, this.lastObjectRendered, D, r || !G), this.emit(r ? "pointercancel" : "pointerup" + G, V), z.pointerType === "mouse" || z.pointerType === "pen") {
          var Y = z.button === 2;
          this.emit(Y ? "rightup" + G : "mouseup" + G, V);
        } else
          z.pointerType === "touch" && (this.emit(r ? "touchcancel" : "touchend" + G, V), this.releaseInteractionDataForPointerId(z.pointerId));
      }
    }, t.prototype.onPointerCancel = function(e) {
      this.supportsTouchEvents && e.pointerType === "touch" || this.onPointerComplete(e, !0, this.processPointerCancel);
    }, t.prototype.processPointerCancel = function(e, r) {
      var D = e.data, N = e.data.identifier;
      r.trackedPointers[N] !== void 0 && (delete r.trackedPointers[N], this.dispatchEvent(r, "pointercancel", e), D.pointerType === "touch" && this.dispatchEvent(r, "touchcancel", e));
    }, t.prototype.onPointerUp = function(e) {
      this.supportsTouchEvents && e.pointerType === "touch" || this.onPointerComplete(e, !1, this.processPointerUp);
    }, t.prototype.processPointerUp = function(e, r, D) {
      var N = e.data, k = e.data.identifier, $ = r.trackedPointers[k], G = N.pointerType === "touch", U = N.pointerType === "mouse" || N.pointerType === "pen", z = !1;
      if (U) {
        var X = N.button === 2, V = InteractionTrackingData.FLAGS, Y = X ? V.RIGHT_DOWN : V.LEFT_DOWN, W = $ !== void 0 && $.flags & Y;
        D ? (this.dispatchEvent(r, X ? "rightup" : "mouseup", e), W && (this.dispatchEvent(r, X ? "rightclick" : "click", e), z = !0)) : W && this.dispatchEvent(r, X ? "rightupoutside" : "mouseupoutside", e), $ && (X ? $.rightDown = !1 : $.leftDown = !1);
      }
      D ? (this.dispatchEvent(r, "pointerup", e), G && this.dispatchEvent(r, "touchend", e), $ && ((!U || z) && this.dispatchEvent(r, "pointertap", e), G && (this.dispatchEvent(r, "tap", e), $.over = !1))) : $ && (this.dispatchEvent(r, "pointerupoutside", e), G && this.dispatchEvent(r, "touchendoutside", e)), $ && $.none && delete r.trackedPointers[k];
    }, t.prototype.onPointerMove = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var r = this.normalizeToPointerData(e);
        (r[0].pointerType === "mouse" || r[0].pointerType === "pen") && (this._didMove = !0, this.cursor = null);
        for (var D = r.length, N = 0; N < D; N++) {
          var k = r[N], $ = this.getInteractionDataForPointerId(k), G = this.configureInteractionEventForDOMEvent(this.eventData, k, $);
          G.data.originalEvent = e, this.processInteractive(G, this.lastObjectRendered, this.processPointerMove, !0), this.emit("pointermove", G), k.pointerType === "touch" && this.emit("touchmove", G), (k.pointerType === "mouse" || k.pointerType === "pen") && this.emit("mousemove", G);
        }
        r[0].pointerType === "mouse" && this.setCursorMode(this.cursor);
      }
    }, t.prototype.processPointerMove = function(e, r, D) {
      var N = e.data, k = N.pointerType === "touch", $ = N.pointerType === "mouse" || N.pointerType === "pen";
      $ && this.processPointerOverOut(e, r, D), (!this.moveWhenInside || D) && (this.dispatchEvent(r, "pointermove", e), k && this.dispatchEvent(r, "touchmove", e), $ && this.dispatchEvent(r, "mousemove", e));
    }, t.prototype.onPointerOut = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var r = this.normalizeToPointerData(e), D = r[0];
        D.pointerType === "mouse" && (this.mouseOverRenderer = !1, this.setCursorMode(null));
        var N = this.getInteractionDataForPointerId(D), k = this.configureInteractionEventForDOMEvent(this.eventData, D, N);
        k.data.originalEvent = D, this.processInteractive(k, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit("pointerout", k), D.pointerType === "mouse" || D.pointerType === "pen" ? this.emit("mouseout", k) : this.releaseInteractionDataForPointerId(N.identifier);
      }
    }, t.prototype.processPointerOverOut = function(e, r, D) {
      var N = e.data, k = e.data.identifier, $ = N.pointerType === "mouse" || N.pointerType === "pen", G = r.trackedPointers[k];
      D && !G && (G = r.trackedPointers[k] = new InteractionTrackingData(k)), G !== void 0 && (D && this.mouseOverRenderer ? (G.over || (G.over = !0, this.delayDispatchEvent(r, "pointerover", e), $ && this.delayDispatchEvent(r, "mouseover", e)), $ && this.cursor === null && (this.cursor = r.cursor)) : G.over && (G.over = !1, this.dispatchEvent(r, "pointerout", this.eventData), $ && this.dispatchEvent(r, "mouseout", e), G.none && delete r.trackedPointers[k]));
    }, t.prototype.onPointerOver = function(e) {
      if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
        var r = this.normalizeToPointerData(e), D = r[0], N = this.getInteractionDataForPointerId(D), k = this.configureInteractionEventForDOMEvent(this.eventData, D, N);
        k.data.originalEvent = D, D.pointerType === "mouse" && (this.mouseOverRenderer = !0), this.emit("pointerover", k), (D.pointerType === "mouse" || D.pointerType === "pen") && this.emit("mouseover", k);
      }
    }, t.prototype.getInteractionDataForPointerId = function(e) {
      var r = e.pointerId, D;
      return r === MOUSE_POINTER_ID || e.pointerType === "mouse" ? D = this.mouse : this.activeInteractionData[r] ? D = this.activeInteractionData[r] : (D = this.interactionDataPool.pop() || new InteractionData(), D.identifier = r, this.activeInteractionData[r] = D), D.copyEvent(e), D;
    }, t.prototype.releaseInteractionDataForPointerId = function(e) {
      var r = this.activeInteractionData[e];
      r && (delete this.activeInteractionData[e], r.reset(), this.interactionDataPool.push(r));
    }, t.prototype.configureInteractionEventForDOMEvent = function(e, r, D) {
      return e.data = D, this.mapPositionToPoint(D.global, r.clientX, r.clientY), r.pointerType === "touch" && (r.globalX = D.global.x, r.globalY = D.global.y), D.originalEvent = r, e.reset(), e;
    }, t.prototype.normalizeToPointerData = function(e) {
      var r = [];
      if (this.supportsTouchEvents && e instanceof TouchEvent)
        for (var D = 0, N = e.changedTouches.length; D < N; D++) {
          var k = e.changedTouches[D];
          typeof k.button > "u" && (k.button = e.touches.length ? 1 : 0), typeof k.buttons > "u" && (k.buttons = e.touches.length ? 1 : 0), typeof k.isPrimary > "u" && (k.isPrimary = e.touches.length === 1 && e.type === "touchstart"), typeof k.width > "u" && (k.width = k.radiusX || 1), typeof k.height > "u" && (k.height = k.radiusY || 1), typeof k.tiltX > "u" && (k.tiltX = 0), typeof k.tiltY > "u" && (k.tiltY = 0), typeof k.pointerType > "u" && (k.pointerType = "touch"), typeof k.pointerId > "u" && (k.pointerId = k.identifier || 0), typeof k.pressure > "u" && (k.pressure = k.force || 0.5), typeof k.twist > "u" && (k.twist = 0), typeof k.tangentialPressure > "u" && (k.tangentialPressure = 0), typeof k.layerX > "u" && (k.layerX = k.offsetX = k.clientX), typeof k.layerY > "u" && (k.layerY = k.offsetY = k.clientY), k.isNormalized = !0, r.push(k);
        }
      else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {
        var $ = e;
        typeof $.isPrimary > "u" && ($.isPrimary = !0), typeof $.width > "u" && ($.width = 1), typeof $.height > "u" && ($.height = 1), typeof $.tiltX > "u" && ($.tiltX = 0), typeof $.tiltY > "u" && ($.tiltY = 0), typeof $.pointerType > "u" && ($.pointerType = "mouse"), typeof $.pointerId > "u" && ($.pointerId = MOUSE_POINTER_ID), typeof $.pressure > "u" && ($.pressure = 0.5), typeof $.twist > "u" && ($.twist = 0), typeof $.tangentialPressure > "u" && ($.tangentialPressure = 0), $.isNormalized = !0, r.push($);
      } else
        r.push(e);
      return r;
    }, t.prototype.destroy = function() {
      this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;
    }, t.extension = {
      name: "interaction",
      type: [
        ExtensionType.RendererPlugin,
        ExtensionType.CanvasRendererPlugin
      ]
    }, t;
  }(i$1)
);
/*!
 * @pixi/extract - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var TEMP_RECT = new Rectangle(), BYTES_PER_PIXEL = 4, Extract = (
  /** @class */
  function() {
    function o(t) {
      this.renderer = t;
    }
    return o.prototype.image = function(t, e, r) {
      var D = new Image();
      return D.src = this.base64(t, e, r), D;
    }, o.prototype.base64 = function(t, e, r) {
      return this.canvas(t).toDataURL(e, r);
    }, o.prototype.canvas = function(t, e) {
      var r = this._rawPixels(t, e), D = r.pixels, N = r.width, k = r.height, $ = r.flipY, G = new CanvasRenderTarget(N, k, 1), U = G.context.getImageData(0, 0, N, k);
      if (o.arrayPostDivide(D, U.data), G.context.putImageData(U, 0, 0), $) {
        var z = new CanvasRenderTarget(G.width, G.height, 1);
        z.context.scale(1, -1), z.context.drawImage(G.canvas, 0, -k), G.destroy(), G = z;
      }
      return G.canvas;
    }, o.prototype.pixels = function(t, e) {
      var r = this._rawPixels(t, e).pixels;
      return o.arrayPostDivide(r, r), r;
    }, o.prototype._rawPixels = function(t, e) {
      var r = this.renderer, D, N = !1, k, $ = !1;
      if (t)
        if (t instanceof RenderTexture)
          k = t;
        else {
          var G = r.context.webGLVersion >= 2 ? r.multisample : MSAA_QUALITY.NONE;
          if (k = this.renderer.generateTexture(t, { multisample: G }), G !== MSAA_QUALITY.NONE) {
            var U = RenderTexture.create({
              width: k.width,
              height: k.height
            });
            r.framebuffer.bind(k.framebuffer), r.framebuffer.blit(U.framebuffer), r.framebuffer.bind(null), k.destroy(!0), k = U;
          }
          $ = !0;
        }
      k ? (D = k.baseTexture.resolution, e = e ?? k.frame, N = !1, r.renderTexture.bind(k)) : (D = r.resolution, e || (e = TEMP_RECT, e.width = r.width, e.height = r.height), N = !0, r.renderTexture.bind(null));
      var z = Math.round(e.width * D), X = Math.round(e.height * D), V = new Uint8Array(BYTES_PER_PIXEL * z * X), Y = r.gl;
      return Y.readPixels(Math.round(e.x * D), Math.round(e.y * D), z, X, Y.RGBA, Y.UNSIGNED_BYTE, V), $ && k.destroy(!0), { pixels: V, width: z, height: X, flipY: N };
    }, o.prototype.destroy = function() {
      this.renderer = null;
    }, o.arrayPostDivide = function(t, e) {
      for (var r = 0; r < t.length; r += 4) {
        var D = e[r + 3] = t[r + 3];
        D !== 0 ? (e[r] = Math.round(Math.min(t[r] * 255 / D, 255)), e[r + 1] = Math.round(Math.min(t[r + 1] * 255 / D, 255)), e[r + 2] = Math.round(Math.min(t[r + 2] * 255 / D, 255))) : (e[r] = t[r], e[r + 1] = t[r + 1], e[r + 2] = t[r + 2]);
      }
    }, o.extension = {
      name: "extract",
      type: ExtensionType.RendererPlugin
    }, o;
  }()
);
/*!
 * @pixi/loaders - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var SignalBinding = (
  /** @class */
  function() {
    function o(t, e, r) {
      e === void 0 && (e = !1), this._fn = t, this._once = e, this._thisArg = r, this._next = this._prev = this._owner = null;
    }
    return o.prototype.detach = function() {
      return this._owner === null ? !1 : (this._owner.detach(this), !0);
    }, o;
  }()
);
function _addSignalBinding(o, t) {
  return o._head ? (o._tail._next = t, t._prev = o._tail, o._tail = t) : (o._head = t, o._tail = t), t._owner = o, t;
}
var Signal = (
  /** @class */
  function() {
    function o() {
      this._head = this._tail = void 0;
    }
    return o.prototype.handlers = function(t) {
      t === void 0 && (t = !1);
      var e = this._head;
      if (t)
        return !!e;
      for (var r = []; e; )
        r.push(e), e = e._next;
      return r;
    }, o.prototype.has = function(t) {
      if (!(t instanceof SignalBinding))
        throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
      return t._owner === this;
    }, o.prototype.dispatch = function() {
      for (var t = arguments, e = [], r = 0; r < arguments.length; r++)
        e[r] = t[r];
      var D = this._head;
      if (!D)
        return !1;
      for (; D; )
        D._once && this.detach(D), D._fn.apply(D._thisArg, e), D = D._next;
      return !0;
    }, o.prototype.add = function(t, e) {
      if (e === void 0 && (e = null), typeof t != "function")
        throw new Error("MiniSignal#add(): First arg must be a Function.");
      return _addSignalBinding(this, new SignalBinding(t, !1, e));
    }, o.prototype.once = function(t, e) {
      if (e === void 0 && (e = null), typeof t != "function")
        throw new Error("MiniSignal#once(): First arg must be a Function.");
      return _addSignalBinding(this, new SignalBinding(t, !0, e));
    }, o.prototype.detach = function(t) {
      if (!(t instanceof SignalBinding))
        throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
      return t._owner !== this ? this : (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, t._next === null && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null, this);
    }, o.prototype.detachAll = function() {
      var t = this._head;
      if (!t)
        return this;
      for (this._head = this._tail = null; t; )
        t._owner = null, t = t._next;
      return this;
    }, o;
  }()
);
function parseUri(o, t) {
  t = t || {};
  for (var e = {
    // eslint-disable-next-line max-len
    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
    q: {
      name: "queryKey",
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      // eslint-disable-next-line max-len
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      // eslint-disable-next-line max-len
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  }, r = e.parser[t.strictMode ? "strict" : "loose"].exec(o), D = {}, N = 14; N--; )
    D[e.key[N]] = r[N] || "";
  return D[e.q.name] = {}, D[e.key[12]].replace(e.q.parser, function(k, $, G) {
    $ && (D[e.q.name][$] = G);
  }), D;
}
var useXdr, tempAnchor = null, STATUS_NONE = 0, STATUS_OK = 200, STATUS_EMPTY = 204, STATUS_IE_BUG_EMPTY = 1223, STATUS_TYPE_OK = 2;
function _noop$1() {
}
function setExtMap(o, t, e) {
  t && t.indexOf(".") === 0 && (t = t.substring(1)), t && (o[t] = e);
}
function reqType(o) {
  return o.toString().replace("object ", "");
}
var LoaderResource = (
  /** @class */
  function() {
    function o(t, e, r) {
      if (this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof t != "string" || typeof e != "string")
        throw new Error("Both name and url are required for constructing a resource.");
      r = r || {}, this._flags = 0, this._setFlag(o.STATUS_FLAGS.DATA_URL, e.indexOf("data:") === 0), this.name = t, this.url = e, this.extension = this._getExtension(), this.data = null, this.crossOrigin = r.crossOrigin === !0 ? "anonymous" : r.crossOrigin, this.timeout = r.timeout || 0, this.loadType = r.loadType || this._determineLoadType(), this.xhrType = r.xhrType, this.metadata = r.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = o.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new Signal(), this.onProgress = new Signal(), this.onComplete = new Signal(), this.onAfterMiddleware = new Signal();
    }
    return o.setExtensionLoadType = function(t, e) {
      setExtMap(o._loadTypeMap, t, e);
    }, o.setExtensionXhrType = function(t, e) {
      setExtMap(o._xhrTypeMap, t, e);
    }, Object.defineProperty(o.prototype, "isDataUrl", {
      /**
       * When the resource starts to load.
       * @memberof PIXI.LoaderResource
       * @callback OnStartSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       */
      /**
       * When the resource reports loading progress.
       * @memberof PIXI.LoaderResource
       * @callback OnProgressSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       * @param {number} percentage - The progress of the load in the range [0, 1].
       */
      /**
       * When the resource finishes loading.
       * @memberof PIXI.LoaderResource
       * @callback OnCompleteSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       */
      /**
       * @memberof PIXI.LoaderResource
       * @typedef {object} IMetadata
       * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
       *      element to use for loading, instead of creating one.
       * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
       *      is useful if you want to pass in a `loadElement` that you already added load sources to.
       * @property {string|string[]} [mimeType] - The mime type to use for the source element
       *      of a video/audio elment. If the urls are an array, you can pass this as an array as well
       *      where each index is the mime type to use for the corresponding url index.
       */
      /**
       * Stores whether or not this url is a data url.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(o.STATUS_FLAGS.DATA_URL);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "isComplete", {
      /**
       * Describes if this resource has finished loading. Is true when the resource has completely
       * loaded.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(o.STATUS_FLAGS.COMPLETE);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "isLoading", {
      /**
       * Describes if this resource is currently loading. Is true when the resource starts loading,
       * and is false again when complete.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(o.STATUS_FLAGS.LOADING);
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.complete = function() {
      this._clearEvents(), this._finish();
    }, o.prototype.abort = function(t) {
      if (!this.error) {
        if (this.error = new Error(t), this._clearEvents(), this.xhr)
          this.xhr.abort();
        else if (this.xdr)
          this.xdr.abort();
        else if (this.data)
          if (this.data.src)
            this.data.src = o.EMPTY_GIF;
          else
            for (; this.data.firstChild; )
              this.data.removeChild(this.data.firstChild);
        this._finish();
      }
    }, o.prototype.load = function(t) {
      var e = this;
      if (!this.isLoading) {
        if (this.isComplete) {
          t && setTimeout(function() {
            return t(e);
          }, 1);
          return;
        } else
          t && this.onComplete.once(t);
        switch (this._setFlag(o.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), (this.crossOrigin === !1 || typeof this.crossOrigin != "string") && (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
          case o.LOAD_TYPE.IMAGE:
            this.type = o.TYPE.IMAGE, this._loadElement("image");
            break;
          case o.LOAD_TYPE.AUDIO:
            this.type = o.TYPE.AUDIO, this._loadSourceElement("audio");
            break;
          case o.LOAD_TYPE.VIDEO:
            this.type = o.TYPE.VIDEO, this._loadSourceElement("video");
            break;
          case o.LOAD_TYPE.XHR:
          default:
            typeof useXdr > "u" && (useXdr = !!(globalThis.XDomainRequest && !("withCredentials" in new XMLHttpRequest()))), useXdr && this.crossOrigin ? this._loadXdr() : this._loadXhr();
            break;
        }
      }
    }, o.prototype._hasFlag = function(t) {
      return (this._flags & t) !== 0;
    }, o.prototype._setFlag = function(t, e) {
      this._flags = e ? this._flags | t : this._flags & ~t;
    }, o.prototype._clearEvents = function() {
      clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));
    }, o.prototype._finish = function() {
      if (this.isComplete)
        throw new Error("Complete called again for an already completed resource.");
      this._setFlag(o.STATUS_FLAGS.COMPLETE, !0), this._setFlag(o.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this);
    }, o.prototype._loadElement = function(t) {
      this.metadata.loadElement ? this.data = this.metadata.loadElement : t === "image" && typeof globalThis.Image < "u" ? this.data = new Image() : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
    }, o.prototype._loadSourceElement = function(t) {
      if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t === "audio" && typeof globalThis.Audio < "u" ? this.data = new Audio() : this.data = document.createElement(t), this.data === null) {
        this.abort("Unsupported element: " + t);
        return;
      }
      if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)
        if (navigator.isCocoonJS)
          this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
        else if (Array.isArray(this.url))
          for (var e = this.metadata.mimeType, r = 0; r < this.url.length; ++r)
            this.data.appendChild(this._createSource(t, this.url[r], Array.isArray(e) ? e[r] : e));
        else {
          var e = this.metadata.mimeType;
          this.data.appendChild(this._createSource(t, this.url, Array.isArray(e) ? e[0] : e));
        }
      this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
    }, o.prototype._loadXhr = function() {
      typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
      var t = this.xhr = new XMLHttpRequest();
      this.crossOrigin === "use-credentials" && (t.withCredentials = !0), t.open("GET", this.url, !0), t.timeout = this.timeout, this.xhrType === o.XHR_RESPONSE_TYPE.JSON || this.xhrType === o.XHR_RESPONSE_TYPE.DOCUMENT ? t.responseType = o.XHR_RESPONSE_TYPE.TEXT : t.responseType = this.xhrType, t.addEventListener("error", this._boundXhrOnError, !1), t.addEventListener("timeout", this._boundXhrOnTimeout, !1), t.addEventListener("abort", this._boundXhrOnAbort, !1), t.addEventListener("progress", this._boundOnProgress, !1), t.addEventListener("load", this._boundXhrOnLoad, !1), t.send();
    }, o.prototype._loadXdr = function() {
      typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
      var t = this.xhr = new globalThis.XDomainRequest();
      t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open("GET", this.url, !0), setTimeout(function() {
        return t.send();
      }, 1);
    }, o.prototype._createSource = function(t, e, r) {
      r || (r = t + "/" + this._getExtension(e));
      var D = document.createElement("source");
      return D.src = e, D.type = r, D;
    }, o.prototype._onError = function(t) {
      this.abort("Failed to load element using: " + t.target.nodeName);
    }, o.prototype._onProgress = function(t) {
      t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total);
    }, o.prototype._onTimeout = function() {
      this.abort("Load timed out.");
    }, o.prototype._xhrOnError = function() {
      var t = this.xhr;
      this.abort(reqType(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"');
    }, o.prototype._xhrOnTimeout = function() {
      var t = this.xhr;
      this.abort(reqType(t) + " Request timed out.");
    }, o.prototype._xhrOnAbort = function() {
      var t = this.xhr;
      this.abort(reqType(t) + " Request was aborted by the user.");
    }, o.prototype._xhrOnLoad = function() {
      var t = this.xhr, e = "", r = typeof t.status > "u" ? STATUS_OK : t.status;
      (t.responseType === "" || t.responseType === "text" || typeof t.responseType > "u") && (e = t.responseText), r === STATUS_NONE && (e.length > 0 || t.responseType === o.XHR_RESPONSE_TYPE.BUFFER) ? r = STATUS_OK : r === STATUS_IE_BUG_EMPTY && (r = STATUS_EMPTY);
      var D = r / 100 | 0;
      if (D === STATUS_TYPE_OK)
        if (this.xhrType === o.XHR_RESPONSE_TYPE.TEXT)
          this.data = e, this.type = o.TYPE.TEXT;
        else if (this.xhrType === o.XHR_RESPONSE_TYPE.JSON)
          try {
            this.data = JSON.parse(e), this.type = o.TYPE.JSON;
          } catch ($) {
            this.abort("Error trying to parse loaded json: " + $);
            return;
          }
        else if (this.xhrType === o.XHR_RESPONSE_TYPE.DOCUMENT)
          try {
            if (globalThis.DOMParser) {
              var N = new DOMParser();
              this.data = N.parseFromString(e, "text/xml");
            } else {
              var k = document.createElement("div");
              k.innerHTML = e, this.data = k;
            }
            this.type = o.TYPE.XML;
          } catch ($) {
            this.abort("Error trying to parse loaded xml: " + $);
            return;
          }
        else
          this.data = t.response || e;
      else {
        this.abort("[" + t.status + "] " + t.statusText + ": " + t.responseURL);
        return;
      }
      this.complete();
    }, o.prototype._determineCrossOrigin = function(t, e) {
      if (t.indexOf("data:") === 0)
        return "";
      if (globalThis.origin !== globalThis.location.origin)
        return "anonymous";
      e = e || globalThis.location, tempAnchor || (tempAnchor = document.createElement("a")), tempAnchor.href = t;
      var r = parseUri(tempAnchor.href, { strictMode: !0 }), D = !r.port && e.port === "" || r.port === e.port, N = r.protocol ? r.protocol + ":" : "";
      return r.host !== e.hostname || !D || N !== e.protocol ? "anonymous" : "";
    }, o.prototype._determineXhrType = function() {
      return o._xhrTypeMap[this.extension] || o.XHR_RESPONSE_TYPE.TEXT;
    }, o.prototype._determineLoadType = function() {
      return o._loadTypeMap[this.extension] || o.LOAD_TYPE.XHR;
    }, o.prototype._getExtension = function(t) {
      t === void 0 && (t = this.url);
      var e = "";
      if (this.isDataUrl) {
        var r = t.indexOf("/");
        e = t.substring(r + 1, t.indexOf(";", r));
      } else {
        var D = t.indexOf("?"), N = t.indexOf("#"), k = Math.min(D > -1 ? D : t.length, N > -1 ? N : t.length);
        t = t.substring(0, k), e = t.substring(t.lastIndexOf(".") + 1);
      }
      return e.toLowerCase();
    }, o.prototype._getMimeFromXhrType = function(t) {
      switch (t) {
        case o.XHR_RESPONSE_TYPE.BUFFER:
          return "application/octet-binary";
        case o.XHR_RESPONSE_TYPE.BLOB:
          return "application/blob";
        case o.XHR_RESPONSE_TYPE.DOCUMENT:
          return "application/xml";
        case o.XHR_RESPONSE_TYPE.JSON:
          return "application/json";
        case o.XHR_RESPONSE_TYPE.DEFAULT:
        case o.XHR_RESPONSE_TYPE.TEXT:
        default:
          return "text/plain";
      }
    }, o;
  }()
);
(function(o) {
  (function(t) {
    t[t.NONE = 0] = "NONE", t[t.DATA_URL = 1] = "DATA_URL", t[t.COMPLETE = 2] = "COMPLETE", t[t.LOADING = 4] = "LOADING";
  })(o.STATUS_FLAGS || (o.STATUS_FLAGS = {})), function(t) {
    t[t.UNKNOWN = 0] = "UNKNOWN", t[t.JSON = 1] = "JSON", t[t.XML = 2] = "XML", t[t.IMAGE = 3] = "IMAGE", t[t.AUDIO = 4] = "AUDIO", t[t.VIDEO = 5] = "VIDEO", t[t.TEXT = 6] = "TEXT";
  }(o.TYPE || (o.TYPE = {})), function(t) {
    t[t.XHR = 1] = "XHR", t[t.IMAGE = 2] = "IMAGE", t[t.AUDIO = 3] = "AUDIO", t[t.VIDEO = 4] = "VIDEO";
  }(o.LOAD_TYPE || (o.LOAD_TYPE = {})), function(t) {
    t.DEFAULT = "text", t.BUFFER = "arraybuffer", t.BLOB = "blob", t.DOCUMENT = "document", t.JSON = "json", t.TEXT = "text";
  }(o.XHR_RESPONSE_TYPE || (o.XHR_RESPONSE_TYPE = {})), o._loadTypeMap = {
    // images
    gif: o.LOAD_TYPE.IMAGE,
    png: o.LOAD_TYPE.IMAGE,
    bmp: o.LOAD_TYPE.IMAGE,
    jpg: o.LOAD_TYPE.IMAGE,
    jpeg: o.LOAD_TYPE.IMAGE,
    tif: o.LOAD_TYPE.IMAGE,
    tiff: o.LOAD_TYPE.IMAGE,
    webp: o.LOAD_TYPE.IMAGE,
    tga: o.LOAD_TYPE.IMAGE,
    avif: o.LOAD_TYPE.IMAGE,
    svg: o.LOAD_TYPE.IMAGE,
    "svg+xml": o.LOAD_TYPE.IMAGE,
    // audio
    mp3: o.LOAD_TYPE.AUDIO,
    ogg: o.LOAD_TYPE.AUDIO,
    wav: o.LOAD_TYPE.AUDIO,
    // videos
    mp4: o.LOAD_TYPE.VIDEO,
    webm: o.LOAD_TYPE.VIDEO
  }, o._xhrTypeMap = {
    // xml
    xhtml: o.XHR_RESPONSE_TYPE.DOCUMENT,
    html: o.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: o.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: o.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: o.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: o.XHR_RESPONSE_TYPE.DOCUMENT,
    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
    // this should probably be fine.
    tsx: o.XHR_RESPONSE_TYPE.DOCUMENT,
    // images
    gif: o.XHR_RESPONSE_TYPE.BLOB,
    png: o.XHR_RESPONSE_TYPE.BLOB,
    bmp: o.XHR_RESPONSE_TYPE.BLOB,
    jpg: o.XHR_RESPONSE_TYPE.BLOB,
    jpeg: o.XHR_RESPONSE_TYPE.BLOB,
    tif: o.XHR_RESPONSE_TYPE.BLOB,
    tiff: o.XHR_RESPONSE_TYPE.BLOB,
    webp: o.XHR_RESPONSE_TYPE.BLOB,
    tga: o.XHR_RESPONSE_TYPE.BLOB,
    avif: o.XHR_RESPONSE_TYPE.BLOB,
    // json
    json: o.XHR_RESPONSE_TYPE.JSON,
    // text
    text: o.XHR_RESPONSE_TYPE.TEXT,
    txt: o.XHR_RESPONSE_TYPE.TEXT,
    // fonts
    ttf: o.XHR_RESPONSE_TYPE.BUFFER,
    otf: o.XHR_RESPONSE_TYPE.BUFFER
  }, o.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
})(LoaderResource || (LoaderResource = {}));
function _noop() {
}
function onlyOnce(o) {
  return function() {
    for (var e = arguments, r = [], D = 0; D < arguments.length; D++)
      r[D] = e[D];
    if (o === null)
      throw new Error("Callback was already called.");
    var N = o;
    o = null, N.apply(this, r);
  };
}
var AsyncQueueItem = (
  /** @class */
  function() {
    function o(t, e) {
      this.data = t, this.callback = e;
    }
    return o;
  }()
), AsyncQueue = (
  /** @class */
  function() {
    function o(t, e) {
      var r = this;
      if (e === void 0 && (e = 1), this.workers = 0, this.saturated = _noop, this.unsaturated = _noop, this.empty = _noop, this.drain = _noop, this.error = _noop, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function(D, N, k) {
        if (k && typeof k != "function")
          throw new Error("task callback must be a function");
        if (r.started = !0, D == null && r.idle()) {
          setTimeout(function() {
            return r.drain();
          }, 1);
          return;
        }
        var $ = new AsyncQueueItem(D, typeof k == "function" ? k : _noop);
        N ? r._tasks.unshift($) : r._tasks.push($), setTimeout(r.process, 1);
      }, this.process = function() {
        for (; !r.paused && r.workers < r.concurrency && r._tasks.length; ) {
          var D = r._tasks.shift();
          r._tasks.length === 0 && r.empty(), r.workers += 1, r.workers === r.concurrency && r.saturated(), r._worker(D.data, onlyOnce(r._next(D)));
        }
      }, this._worker = t, e === 0)
        throw new Error("Concurrency must not be zero");
      this.concurrency = e, this.buffer = e / 4;
    }
    return o.prototype._next = function(t) {
      var e = this;
      return function() {
        for (var r = arguments, D = [], N = 0; N < arguments.length; N++)
          D[N] = r[N];
        e.workers -= 1, t.callback.apply(t, D), D[0] != null && e.error(D[0], t.data), e.workers <= e.concurrency - e.buffer && e.unsaturated(), e.idle() && e.drain(), e.process();
      };
    }, o.prototype.push = function(t, e) {
      this._insert(t, !1, e);
    }, o.prototype.kill = function() {
      this.workers = 0, this.drain = _noop, this.started = !1, this._tasks = [];
    }, o.prototype.unshift = function(t, e) {
      this._insert(t, !0, e);
    }, o.prototype.length = function() {
      return this._tasks.length;
    }, o.prototype.running = function() {
      return this.workers;
    }, o.prototype.idle = function() {
      return this._tasks.length + this.workers === 0;
    }, o.prototype.pause = function() {
      this.paused !== !0 && (this.paused = !0);
    }, o.prototype.resume = function() {
      if (this.paused !== !1) {
        this.paused = !1;
        for (var t = 1; t <= this.concurrency; t++)
          this.process();
      }
    }, o.eachSeries = function(t, e, r, D) {
      var N = 0, k = t.length;
      function $(G) {
        if (G || N === k) {
          r && r(G);
          return;
        }
        D ? setTimeout(function() {
          e(t[N++], $);
        }, 1) : e(t[N++], $);
      }
      $();
    }, o.queue = function(t, e) {
      return new o(t, e);
    }, o;
  }()
), MAX_PROGRESS = 100, rgxExtractUrlHash = /(#[\w-]+)?$/, Loader = (
  /** @class */
  function() {
    function o(t, e) {
      var r = this;
      t === void 0 && (t = ""), e === void 0 && (e = 10), this.progress = 0, this.loading = !1, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(G, U) {
        return r._loadResource(G, U);
      }, this.resources = {}, this.baseUrl = t, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(G, U) {
        return r._loadResource(G, U);
      }, this._queue = AsyncQueue.queue(this._boundLoadResource, e), this._queue.pause(), this.resources = {}, this.onProgress = new Signal(), this.onError = new Signal(), this.onLoad = new Signal(), this.onStart = new Signal(), this.onComplete = new Signal();
      for (var D = 0; D < o._plugins.length; ++D) {
        var N = o._plugins[D], k = N.pre, $ = N.use;
        k && this.pre(k), $ && this.use($);
      }
      this._protected = !1;
    }
    return o.prototype._add = function(t, e, r, D) {
      if (this.loading && (!r || !r.parentResource))
        throw new Error("Cannot add resources while the loader is running.");
      if (this.resources[t])
        throw new Error('Resource named "' + t + '" already exists.');
      if (e = this._prepareUrl(e), this.resources[t] = new LoaderResource(t, e, r), typeof D == "function" && this.resources[t].onAfterMiddleware.once(D), this.loading) {
        for (var N = r.parentResource, k = [], $ = 0; $ < N.children.length; ++$)
          N.children[$].isComplete || k.push(N.children[$]);
        var G = N.progressChunk * (k.length + 1), U = G / (k.length + 2);
        N.children.push(this.resources[t]), N.progressChunk = U;
        for (var $ = 0; $ < k.length; ++$)
          k[$].progressChunk = U;
        this.resources[t].progressChunk = U;
      }
      return this._queue.push(this.resources[t]), this;
    }, o.prototype.pre = function(t) {
      return this._beforeMiddleware.push(t), this;
    }, o.prototype.use = function(t) {
      return this._afterMiddleware.push(t), this;
    }, o.prototype.reset = function() {
      this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause();
      for (var t in this.resources) {
        var e = this.resources[t];
        e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort("loader reset");
      }
      return this.resources = {}, this;
    }, o.prototype.load = function(t) {
      if (deprecation("6.5.0", "@pixi/loaders is being replaced with @pixi/assets in the next major release."), typeof t == "function" && this.onComplete.once(t), this.loading)
        return this;
      if (this._queue.idle())
        this._onStart(), this._onComplete();
      else {
        for (var e = this._queue._tasks.length, r = MAX_PROGRESS / e, D = 0; D < this._queue._tasks.length; ++D)
          this._queue._tasks[D].data.progressChunk = r;
        this._onStart(), this._queue.resume();
      }
      return this;
    }, Object.defineProperty(o.prototype, "concurrency", {
      /**
       * The number of resources to load concurrently.
       * @default 10
       */
      get: function() {
        return this._queue.concurrency;
      },
      set: function(t) {
        this._queue.concurrency = t;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype._prepareUrl = function(t) {
      var e = parseUri(t, { strictMode: !0 }), r;
      if (e.protocol || !e.path || t.indexOf("//") === 0 ? r = t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && t.charAt(0) !== "/" ? r = this.baseUrl + "/" + t : r = this.baseUrl + t, this.defaultQueryString) {
        var D = rgxExtractUrlHash.exec(r)[0];
        r = r.slice(0, r.length - D.length), r.indexOf("?") !== -1 ? r += "&" + this.defaultQueryString : r += "?" + this.defaultQueryString, r += D;
      }
      return r;
    }, o.prototype._loadResource = function(t, e) {
      var r = this;
      t._dequeue = e, AsyncQueue.eachSeries(this._beforeMiddleware, function(D, N) {
        D.call(r, t, function() {
          N(t.isComplete ? {} : null);
        });
      }, function() {
        t.isComplete ? r._onLoad(t) : (t._onLoadBinding = t.onComplete.once(r._onLoad, r), t.load());
      }, !0);
    }, o.prototype._onStart = function() {
      this.progress = 0, this.loading = !0, this.onStart.dispatch(this);
    }, o.prototype._onComplete = function() {
      this.progress = MAX_PROGRESS, this.loading = !1, this.onComplete.dispatch(this, this.resources);
    }, o.prototype._onLoad = function(t) {
      var e = this;
      t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), AsyncQueue.eachSeries(this._afterMiddleware, function(r, D) {
        r.call(e, t, D);
      }, function() {
        t.onAfterMiddleware.dispatch(t), e.progress = Math.min(MAX_PROGRESS, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && e._resourcesParsing.length === 0 && e._onComplete();
      }, !0);
    }, o.prototype.destroy = function() {
      this._protected || this.reset();
    }, Object.defineProperty(o, "shared", {
      /** A premade instance of the loader that can be used to load resources. */
      get: function() {
        var t = o._shared;
        return t || (t = new o(), t._protected = !0, o._shared = t), t;
      },
      enumerable: !1,
      configurable: !0
    }), o.registerPlugin = function(t) {
      return deprecation("6.5.0", "Loader.registerPlugin() is deprecated, use extensions.add() instead."), extensions.add({
        type: ExtensionType.Loader,
        ref: t
      }), o;
    }, o._plugins = [], o;
  }()
);
extensions.handleByList(ExtensionType.Loader, Loader._plugins);
Loader.prototype.add = function(t, e, r, D) {
  if (Array.isArray(t)) {
    for (var N = 0; N < t.length; ++N)
      this.add(t[N]);
    return this;
  }
  if (typeof t == "object" && (r = t, D = e || r.callback || r.onComplete, e = r.url, t = r.name || r.key || r.url), typeof e != "string" && (D = r, r = e, e = t), typeof e != "string")
    throw new Error("No url passed to add resource to loader.");
  return typeof r == "function" && (D = r, r = null), this._add(t, e, r, D);
};
var AppLoaderPlugin = (
  /** @class */
  function() {
    function o() {
    }
    return o.init = function(t) {
      t = Object.assign({
        sharedLoader: !1
      }, t), this.loader = t.sharedLoader ? Loader.shared : new Loader();
    }, o.destroy = function() {
      this.loader && (this.loader.destroy(), this.loader = null);
    }, o.extension = ExtensionType.Application, o;
  }()
), TextureLoader = (
  /** @class */
  function() {
    function o() {
    }
    return o.add = function() {
      LoaderResource.setExtensionLoadType("svg", LoaderResource.LOAD_TYPE.XHR), LoaderResource.setExtensionXhrType("svg", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
    }, o.use = function(t, e) {
      if (t.data && (t.type === LoaderResource.TYPE.IMAGE || t.extension === "svg")) {
        var r = t.data, D = t.url, N = t.name, k = t.metadata;
        Texture.fromLoader(r, D, N, k).then(function($) {
          t.texture = $, e();
        }).catch(e);
      } else
        e();
    }, o.extension = ExtensionType.Loader, o;
  }()
), _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encodeBinary(o) {
  for (var t = "", e = 0; e < o.length; ) {
    for (var r = [0, 0, 0], D = [0, 0, 0, 0], N = 0; N < r.length; ++N)
      e < o.length ? r[N] = o.charCodeAt(e++) & 255 : r[N] = 0;
    D[0] = r[0] >> 2, D[1] = (r[0] & 3) << 4 | r[1] >> 4, D[2] = (r[1] & 15) << 2 | r[2] >> 6, D[3] = r[2] & 63;
    var k = e - (o.length - 1);
    switch (k) {
      case 2:
        D[3] = 64, D[2] = 64;
        break;
      case 1:
        D[3] = 64;
        break;
    }
    for (var N = 0; N < D.length; ++N)
      t += _keyStr.charAt(D[N]);
  }
  return t;
}
function parsing(o, t) {
  if (!o.data) {
    t();
    return;
  }
  if (o.xhr && o.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {
    if (!self.Blob || typeof o.data == "string") {
      var e = o.xhr.getResponseHeader("content-type");
      if (e && e.indexOf("image") === 0) {
        o.data = new Image(), o.data.src = "data:" + e + ";base64," + encodeBinary(o.xhr.responseText), o.type = LoaderResource.TYPE.IMAGE, o.data.onload = function() {
          o.data.onload = null, t();
        };
        return;
      }
    } else if (o.data.type.indexOf("image") === 0) {
      var r = globalThis.URL || globalThis.webkitURL, D = r.createObjectURL(o.data);
      o.blob = o.data, o.data = new Image(), o.data.src = D, o.type = LoaderResource.TYPE.IMAGE, o.data.onload = function() {
        r.revokeObjectURL(D), o.data.onload = null, t();
      };
      return;
    }
  }
  t();
}
var ParsingLoader = (
  /** @class */
  function() {
    function o() {
    }
    return o.extension = ExtensionType.Loader, o.use = parsing, o;
  }()
);
extensions.add(TextureLoader, ParsingLoader);
/*!
 * @pixi/compressed-textures - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/compressed-textures is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var _a$2, INTERNAL_FORMATS;
(function(o) {
  o[o.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", o[o.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", o[o.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", o[o.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", o[o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", o[o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", o[o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", o[o.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", o[o.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", o[o.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", o[o.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", o[o.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", o[o.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", o[o.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", o[o.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", o[o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", o[o.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", o[o.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", o[o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", o[o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", o[o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", o[o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", o[o.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", o[o.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", o[o.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", o[o.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", o[o.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
})(INTERNAL_FORMATS || (INTERNAL_FORMATS = {}));
var INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = (_a$2 = {}, // WEBGL_compressed_texture_s3tc
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_s3tc
_a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_etc
_a$2[INTERNAL_FORMATS.COMPRESSED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, // WEBGL_compressed_texture_pvrtc
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, // WEBGL_compressed_texture_etc1
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, // @see https://www.khronos.org/registry/OpenGL/extensions/AMD/AMD_compressed_ATC_texture.txt
// WEBGL_compressed_texture_atc
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, // @see https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt
// WEBGL_compressed_texture_astc
/* eslint-disable-next-line camelcase */
_a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ASTC_4x4_KHR] = 1, _a$2);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$m = function(o, t) {
  return extendStatics$m = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$m(o, t);
};
function __extends$m(o, t) {
  extendStatics$m(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function __awaiter(o, t, e, r) {
  function D(N) {
    return N instanceof e ? N : new e(function(k) {
      k(N);
    });
  }
  return new (e || (e = Promise))(function(N, k) {
    function $(z) {
      try {
        U(r.next(z));
      } catch (X) {
        k(X);
      }
    }
    function G(z) {
      try {
        U(r.throw(z));
      } catch (X) {
        k(X);
      }
    }
    function U(z) {
      z.done ? N(z.value) : D(z.value).then($, G);
    }
    U((r = r.apply(o, t || [])).next());
  });
}
function __generator(o, t) {
  var e = { label: 0, sent: function() {
    if (N[0] & 1)
      throw N[1];
    return N[1];
  }, trys: [], ops: [] }, r, D, N, k;
  return k = { next: $(0), throw: $(1), return: $(2) }, typeof Symbol == "function" && (k[Symbol.iterator] = function() {
    return this;
  }), k;
  function $(U) {
    return function(z) {
      return G([U, z]);
    };
  }
  function G(U) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (r = 1, D && (N = U[0] & 2 ? D.return : U[0] ? D.throw || ((N = D.return) && N.call(D), 0) : D.next) && !(N = N.call(D, U[1])).done)
          return N;
        switch (D = 0, N && (U = [U[0] & 2, N.value]), U[0]) {
          case 0:
          case 1:
            N = U;
            break;
          case 4:
            return e.label++, { value: U[1], done: !1 };
          case 5:
            e.label++, D = U[1], U = [0];
            continue;
          case 7:
            U = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (N = e.trys, !(N = N.length > 0 && N[N.length - 1]) && (U[0] === 6 || U[0] === 2)) {
              e = 0;
              continue;
            }
            if (U[0] === 3 && (!N || U[1] > N[0] && U[1] < N[3])) {
              e.label = U[1];
              break;
            }
            if (U[0] === 6 && e.label < N[1]) {
              e.label = N[1], N = U;
              break;
            }
            if (N && e.label < N[2]) {
              e.label = N[2], e.ops.push(U);
              break;
            }
            N[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        U = t.call(o, e);
      } catch (z) {
        U = [6, z], D = 0;
      } finally {
        r = N = 0;
      }
    if (U[0] & 5)
      throw U[1];
    return { value: U[0] ? U[1] : void 0, done: !0 };
  }
}
var BlobResource = (
  /** @class */
  function(o) {
    __extends$m(t, o);
    function t(e, r) {
      r === void 0 && (r = { width: 1, height: 1, autoLoad: !0 });
      var D = this, N, k;
      return typeof e == "string" ? (N = e, k = new Uint8Array()) : (N = null, k = e), D = o.call(this, k, r) || this, D.origin = N, D.buffer = k ? new ViewableBuffer(k) : null, D.origin && r.autoLoad !== !1 && D.load(), k && k.length && (D.loaded = !0, D.onBlobLoaded(D.buffer.rawBinaryData)), D;
    }
    return t.prototype.onBlobLoaded = function(e) {
    }, t.prototype.load = function() {
      return __awaiter(this, void 0, Promise, function() {
        var e, r, D;
        return __generator(this, function(N) {
          switch (N.label) {
            case 0:
              return [4, fetch(this.origin)];
            case 1:
              return e = N.sent(), [4, e.blob()];
            case 2:
              return r = N.sent(), [4, r.arrayBuffer()];
            case 3:
              return D = N.sent(), this.data = new Uint32Array(D), this.buffer = new ViewableBuffer(D), this.loaded = !0, this.onBlobLoaded(D), this.update(), [2, this];
          }
        });
      });
    }, t;
  }(BufferResource)
), CompressedTextureResource = (
  /** @class */
  function(o) {
    __extends$m(t, o);
    function t(e, r) {
      var D = o.call(this, e, r) || this;
      return D.format = r.format, D.levels = r.levels || 1, D._width = r.width, D._height = r.height, D._extension = t._formatToExtension(D.format), (r.levelBuffers || D.buffer) && (D._levelBuffers = r.levelBuffers || t._createLevelBuffers(
        e instanceof Uint8Array ? e : D.buffer.uint8View,
        D.format,
        D.levels,
        4,
        4,
        // PVRTC has 8x4 blocks in 2bpp mode
        D.width,
        D.height
      )), D;
    }
    return t.prototype.upload = function(e, r, D) {
      var N = e.gl, k = e.context.extensions[this._extension];
      if (!k)
        throw new Error(this._extension + " textures are not supported on the current machine");
      if (!this._levelBuffers)
        return !1;
      for (var $ = 0, G = this.levels; $ < G; $++) {
        var U = this._levelBuffers[$], z = U.levelID, X = U.levelWidth, V = U.levelHeight, Y = U.levelBuffer;
        N.compressedTexImage2D(N.TEXTURE_2D, z, this.format, X, V, 0, Y);
      }
      return !0;
    }, t.prototype.onBlobLoaded = function() {
      this._levelBuffers = t._createLevelBuffers(
        this.buffer.uint8View,
        this.format,
        this.levels,
        4,
        4,
        // PVRTC has 8x4 blocks in 2bpp mode
        this.width,
        this.height
      );
    }, t._formatToExtension = function(e) {
      if (e >= 33776 && e <= 33779)
        return "s3tc";
      if (e >= 37488 && e <= 37497)
        return "etc";
      if (e >= 35840 && e <= 35843)
        return "pvrtc";
      if (e >= 36196)
        return "etc1";
      if (e >= 35986 && e <= 34798)
        return "atc";
      throw new Error("Invalid (compressed) texture format given!");
    }, t._createLevelBuffers = function(e, r, D, N, k, $, G) {
      for (var U = new Array(D), z = e.byteOffset, X = $, V = G, Y = X + N - 1 & ~(N - 1), W = V + k - 1 & ~(k - 1), q = Y * W * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[r], K = 0; K < D; K++)
        U[K] = {
          levelID: K,
          levelWidth: D > 1 ? X : Y,
          levelHeight: D > 1 ? V : W,
          levelBuffer: new Uint8Array(e.buffer, z, q)
        }, z += q, X = X >> 1 || 1, V = V >> 1 || 1, Y = X + N - 1 & ~(N - 1), W = V + k - 1 & ~(k - 1), q = Y * W * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[r];
      return U;
    }, t;
  }(BlobResource)
), CompressedTextureLoader = (
  /** @class */
  function() {
    function o() {
    }
    return o.use = function(t, e) {
      var r = t.data, D = this;
      if (t.type === LoaderResource.TYPE.JSON && r && r.cacheID && r.textures) {
        for (var N = r.textures, k = void 0, $ = void 0, G = 0, U = N.length; G < U; G++) {
          var z = N[G], X = z.src, V = z.format;
          if (V || ($ = X), o.textureFormats[V]) {
            k = X;
            break;
          }
        }
        if (k = k || $, !k) {
          e(new Error("Cannot load compressed-textures in " + t.url + ", make sure you provide a fallback"));
          return;
        }
        if (k === t.url) {
          e(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
          return;
        }
        var Y = {
          crossOrigin: t.crossOrigin,
          metadata: t.metadata.imageMetadata,
          parentResource: t
        }, W = url$1.resolve(t.url.replace(D.baseUrl, ""), k), q = r.cacheID;
        D.add(q, W, Y, function(K) {
          if (K.error) {
            e(K.error);
            return;
          }
          var Z = K.texture, J = Z === void 0 ? null : Z, Q = K.textures, et = Q === void 0 ? {} : Q;
          Object.assign(t, { texture: J, textures: et }), e();
        });
      } else
        e();
    }, Object.defineProperty(o, "textureExtensions", {
      /**  Map of available texture extensions. */
      get: function() {
        if (!o._textureExtensions) {
          var t = settings.ADAPTER.createCanvas(), e = t.getContext("webgl");
          if (!e)
            return console.warn("WebGL not available for compressed textures. Silently failing."), {};
          var r = {
            s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: e.getExtension("WEBGL_compressed_texture_etc"),
            etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: e.getExtension("WEBGL_compressed_texture_atc"),
            astc: e.getExtension("WEBGL_compressed_texture_astc")
          };
          o._textureExtensions = r;
        }
        return o._textureExtensions;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o, "textureFormats", {
      /** Map of available texture formats. */
      get: function() {
        if (!o._textureFormats) {
          var t = o.textureExtensions;
          o._textureFormats = {};
          for (var e in t) {
            var r = t[e];
            r && Object.assign(o._textureFormats, Object.getPrototypeOf(r));
          }
        }
        return o._textureFormats;
      },
      enumerable: !1,
      configurable: !0
    }), o.extension = ExtensionType.Loader, o;
  }()
);
function registerCompressedTextures(o, t, e) {
  var r = {
    textures: {},
    texture: null
  };
  if (!t)
    return r;
  var D = t.map(function(N) {
    return new Texture(new BaseTexture(N, Object.assign({
      mipmap: MIPMAP_MODES.OFF,
      alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA
    }, e)));
  });
  return D.forEach(function(N, k) {
    var $ = N.baseTexture, G = o + "-" + (k + 1);
    BaseTexture.addToCache($, G), Texture.addToCache(N, G), k === 0 && (BaseTexture.addToCache($, o), Texture.addToCache(N, o), r.texture = N), r.textures[G] = N;
  }), r;
}
var _a$1, _b$1, DDS_MAGIC_SIZE = 4, DDS_HEADER_SIZE = 124, DDS_HEADER_PF_SIZE = 32, DDS_HEADER_DX10_SIZE = 20, DDS_MAGIC = 542327876, DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
}, DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
}, DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
}, DXGI_FORMAT;
(function(o) {
  o[o.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", o[o.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", o[o.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", o[o.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", o[o.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", o[o.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", o[o.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", o[o.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", o[o.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", o[o.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", o[o.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", o[o.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", o[o.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", o[o.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", o[o.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", o[o.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", o[o.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", o[o.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", o[o.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", o[o.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", o[o.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", o[o.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", o[o.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", o[o.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", o[o.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", o[o.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", o[o.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", o[o.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", o[o.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", o[o.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", o[o.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", o[o.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", o[o.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", o[o.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", o[o.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", o[o.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", o[o.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", o[o.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", o[o.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", o[o.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", o[o.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", o[o.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", o[o.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", o[o.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", o[o.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", o[o.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", o[o.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", o[o.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", o[o.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", o[o.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", o[o.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", o[o.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", o[o.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", o[o.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", o[o.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", o[o.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", o[o.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", o[o.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", o[o.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", o[o.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", o[o.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", o[o.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", o[o.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", o[o.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", o[o.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", o[o.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", o[o.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", o[o.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", o[o.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", o[o.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", o[o.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", o[o.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", o[o.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", o[o.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", o[o.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", o[o.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", o[o.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", o[o.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", o[o.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", o[o.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", o[o.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", o[o.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", o[o.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", o[o.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", o[o.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", o[o.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", o[o.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", o[o.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", o[o.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", o[o.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", o[o.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", o[o.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", o[o.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", o[o.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", o[o.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", o[o.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", o[o.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", o[o.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", o[o.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", o[o.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", o[o.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV", o[o.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410", o[o.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416", o[o.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12", o[o.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010", o[o.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016", o[o.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE", o[o.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2", o[o.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210", o[o.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216", o[o.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11", o[o.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44", o[o.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44", o[o.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8", o[o.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8", o[o.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", o[o.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208", o[o.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208", o[o.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408", o[o.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", o[o.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", o[o.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT";
})(DXGI_FORMAT || (DXGI_FORMAT = {}));
var D3D10_RESOURCE_DIMENSION;
(function(o) {
  o[o.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", o[o.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", o[o.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D";
})(D3D10_RESOURCE_DIMENSION || (D3D10_RESOURCE_DIMENSION = {}));
var PF_FLAGS = 1, DDPF_ALPHA = 2, DDPF_FOURCC = 4, DDPF_RGB = 64, DDPF_YUV = 512, DDPF_LUMINANCE = 131072, FOURCC_DXT1 = 827611204, FOURCC_DXT3 = 861165636, FOURCC_DXT5 = 894720068, FOURCC_DX10 = 808540228, DDS_RESOURCE_MISC_TEXTURECUBE = 4, FOURCC_TO_FORMAT = (_a$1 = {}, _a$1[FOURCC_DXT1] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _a$1[FOURCC_DXT3] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _a$1[FOURCC_DXT5] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _a$1), DXGI_TO_FORMAT = (_b$1 = {}, // WEBGL_compressed_texture_s3tc
_b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, // WEBGL_compressed_texture_s3tc_srgb
_b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _b$1);
function parseDDS(o) {
  var t = new Uint32Array(o), e = t[0];
  if (e !== DDS_MAGIC)
    throw new Error("Invalid DDS file magic word");
  var r = new Uint32Array(o, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT), D = r[DDS_FIELDS.HEIGHT], N = r[DDS_FIELDS.WIDTH], k = r[DDS_FIELDS.MIPMAP_COUNT], $ = new Uint32Array(o, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT), G = $[PF_FLAGS];
  if (G & DDPF_FOURCC) {
    var U = $[DDS_PF_FIELDS.FOURCC];
    if (U !== FOURCC_DX10) {
      var z = FOURCC_TO_FORMAT[U], X = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, V = new Uint8Array(o, X), Y = new CompressedTextureResource(V, {
        format: z,
        width: N,
        height: D,
        levels: k
        // CompressedTextureResource will separate the levelBuffers for us!
      });
      return [Y];
    }
    var W = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, q = new Uint32Array(t.buffer, W, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT), K = q[DDS_DX10_FIELDS.DXGI_FORMAT], Z = q[DDS_DX10_FIELDS.RESOURCE_DIMENSION], J = q[DDS_DX10_FIELDS.MISC_FLAG], Q = q[DDS_DX10_FIELDS.ARRAY_SIZE], et = DXGI_TO_FORMAT[K];
    if (et === void 0)
      throw new Error("DDSParser cannot parse texture data with DXGI format " + K);
    if (J === DDS_RESOURCE_MISC_TEXTURECUBE)
      throw new Error("DDSParser does not support cubemap textures");
    if (Z === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D)
      throw new Error("DDSParser does not supported 3D texture data");
    var it = new Array(), tt = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
    if (Q === 1)
      it.push(new Uint8Array(o, tt));
    else {
      for (var nt = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[et], st = 0, at = N, ut = D, ht = 0; ht < k; ht++) {
        var dt = Math.max(1, at + 3 & -4), pt = Math.max(1, ut + 3 & -4), _t = dt * pt * nt;
        st += _t, at = at >>> 1, ut = ut >>> 1;
      }
      for (var mt = tt, ht = 0; ht < Q; ht++)
        it.push(new Uint8Array(o, mt, st)), mt += st;
    }
    return it.map(function(yt) {
      return new CompressedTextureResource(yt, {
        format: et,
        width: N,
        height: D,
        levels: k
      });
    });
  }
  throw G & DDPF_RGB ? new Error("DDSParser does not support uncompressed texture data.") : G & DDPF_YUV ? new Error("DDSParser does not supported YUV uncompressed texture data.") : G & DDPF_LUMINANCE ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : G & DDPF_ALPHA ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
var _a$3, _b, _c, FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], ENDIANNESS = 67305985, KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
}, FILE_HEADER_SIZE = 64, TYPES_TO_BYTES_PER_COMPONENT = (_a$3 = {}, _a$3[TYPES.UNSIGNED_BYTE] = 1, _a$3[TYPES.UNSIGNED_SHORT] = 2, _a$3[TYPES.INT] = 4, _a$3[TYPES.UNSIGNED_INT] = 4, _a$3[TYPES.FLOAT] = 4, _a$3[TYPES.HALF_FLOAT] = 8, _a$3), FORMATS_TO_COMPONENTS = (_b = {}, _b[FORMATS.RGBA] = 4, _b[FORMATS.RGB] = 3, _b[FORMATS.RG] = 2, _b[FORMATS.RED] = 1, _b[FORMATS.LUMINANCE] = 1, _b[FORMATS.LUMINANCE_ALPHA] = 2, _b[FORMATS.ALPHA] = 1, _b), TYPES_TO_BYTES_PER_PIXEL = (_c = {}, _c[TYPES.UNSIGNED_SHORT_4_4_4_4] = 2, _c[TYPES.UNSIGNED_SHORT_5_5_5_1] = 2, _c[TYPES.UNSIGNED_SHORT_5_6_5] = 2, _c);
function parseKTX(o, t, e) {
  e === void 0 && (e = !1);
  var r = new DataView(t);
  if (!validate(o, r))
    return null;
  var D = r.getUint32(KTX_FIELDS.ENDIANNESS, !0) === ENDIANNESS, N = r.getUint32(KTX_FIELDS.GL_TYPE, D), k = r.getUint32(KTX_FIELDS.GL_FORMAT, D), $ = r.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, D), G = r.getUint32(KTX_FIELDS.PIXEL_WIDTH, D), U = r.getUint32(KTX_FIELDS.PIXEL_HEIGHT, D) || 1, z = r.getUint32(KTX_FIELDS.PIXEL_DEPTH, D) || 1, X = r.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, D) || 1, V = r.getUint32(KTX_FIELDS.NUMBER_OF_FACES, D), Y = r.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, D), W = r.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, D);
  if (U === 0 || z !== 1)
    throw new Error("Only 2D textures are supported");
  if (V !== 1)
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  if (X !== 1)
    throw new Error("WebGL does not support array textures");
  var q = 4, K = 4, Z = G + 3 & -4, J = U + 3 & -4, Q = new Array(X), et = G * U;
  N === 0 && (et = Z * J);
  var it;
  if (N !== 0 ? TYPES_TO_BYTES_PER_COMPONENT[N] ? it = TYPES_TO_BYTES_PER_COMPONENT[N] * FORMATS_TO_COMPONENTS[k] : it = TYPES_TO_BYTES_PER_PIXEL[N] : it = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[$], it === void 0)
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  for (var tt = e ? parseKvData(r, W, D) : null, nt = et * it, st = nt, at = G, ut = U, ht = Z, dt = J, pt = FILE_HEADER_SIZE + W, _t = 0; _t < Y; _t++) {
    for (var mt = r.getUint32(pt, D), yt = pt + 4, Tt = 0; Tt < X; Tt++) {
      var Pt = Q[Tt];
      Pt || (Pt = Q[Tt] = new Array(Y)), Pt[_t] = {
        levelID: _t,
        // don't align mipWidth when texture not compressed! (glType not zero)
        levelWidth: Y > 1 || N !== 0 ? at : ht,
        levelHeight: Y > 1 || N !== 0 ? ut : dt,
        levelBuffer: new Uint8Array(t, yt, st)
      }, yt += st;
    }
    pt += mt + 4, pt = pt % 4 !== 0 ? pt + 4 - pt % 4 : pt, at = at >> 1 || 1, ut = ut >> 1 || 1, ht = at + q - 1 & ~(q - 1), dt = ut + K - 1 & ~(K - 1), st = ht * dt * it;
  }
  return N !== 0 ? {
    uncompressed: Q.map(function(St) {
      var gt = St[0].levelBuffer, bt = !1;
      return N === TYPES.FLOAT ? gt = new Float32Array(St[0].levelBuffer.buffer, St[0].levelBuffer.byteOffset, St[0].levelBuffer.byteLength / 4) : N === TYPES.UNSIGNED_INT ? (bt = !0, gt = new Uint32Array(St[0].levelBuffer.buffer, St[0].levelBuffer.byteOffset, St[0].levelBuffer.byteLength / 4)) : N === TYPES.INT && (bt = !0, gt = new Int32Array(St[0].levelBuffer.buffer, St[0].levelBuffer.byteOffset, St[0].levelBuffer.byteLength / 4)), {
        resource: new BufferResource(gt, {
          width: St[0].levelWidth,
          height: St[0].levelHeight
        }),
        type: N,
        format: bt ? convertFormatToInteger(k) : k
      };
    }),
    kvData: tt
  } : {
    compressed: Q.map(function(St) {
      return new CompressedTextureResource(null, {
        format: $,
        width: G,
        height: U,
        levels: Y,
        levelBuffers: St
      });
    }),
    kvData: tt
  };
}
function validate(o, t) {
  for (var e = 0; e < FILE_IDENTIFIER.length; e++)
    if (t.getUint8(e) !== FILE_IDENTIFIER[e])
      return console.error(o + " is not a valid *.ktx file!"), !1;
  return !0;
}
function convertFormatToInteger(o) {
  switch (o) {
    case FORMATS.RGBA:
      return FORMATS.RGBA_INTEGER;
    case FORMATS.RGB:
      return FORMATS.RGB_INTEGER;
    case FORMATS.RG:
      return FORMATS.RG_INTEGER;
    case FORMATS.RED:
      return FORMATS.RED_INTEGER;
    default:
      return o;
  }
}
function parseKvData(o, t, e) {
  for (var r = /* @__PURE__ */ new Map(), D = 0; D < t; ) {
    var N = o.getUint32(FILE_HEADER_SIZE + D, e), k = FILE_HEADER_SIZE + D + 4, $ = 3 - (N + 3) % 4;
    if (N === 0 || N > t - D) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    for (var G = 0; G < N && o.getUint8(k + G) !== 0; G++)
      ;
    if (G === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    var U = new TextDecoder().decode(new Uint8Array(o.buffer, k, G)), z = new DataView(o.buffer, k + G + 1, N - G - 1);
    r.set(U, z), D += 4 + N + $;
  }
  return r;
}
LoaderResource.setExtensionXhrType("dds", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var DDSLoader = (
  /** @class */
  function() {
    function o() {
    }
    return o.use = function(t, e) {
      if (t.extension === "dds" && t.data)
        try {
          Object.assign(t, registerCompressedTextures(t.name || t.url, parseDDS(t.data), t.metadata));
        } catch (r) {
          e(r);
          return;
        }
      e();
    }, o.extension = ExtensionType.Loader, o;
  }()
);
LoaderResource.setExtensionXhrType("ktx", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var KTXLoader = (
  /** @class */
  function() {
    function o() {
    }
    return o.use = function(t, e) {
      if (t.extension === "ktx" && t.data)
        try {
          var r = t.name || t.url, D = parseKTX(r, t.data, this.loadKeyValueData), N = D.compressed, k = D.uncompressed, $ = D.kvData;
          if (N) {
            var G = registerCompressedTextures(r, N, t.metadata);
            if ($ && G.textures)
              for (var U in G.textures)
                G.textures[U].baseTexture.ktxKeyValueData = $;
            Object.assign(t, G);
          } else if (k) {
            var z = {};
            k.forEach(function(X, V) {
              var Y = new Texture(new BaseTexture(X.resource, {
                mipmap: MIPMAP_MODES.OFF,
                alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
                type: X.type,
                format: X.format
              })), W = r + "-" + (V + 1);
              $ && (Y.baseTexture.ktxKeyValueData = $), BaseTexture.addToCache(Y.baseTexture, W), Texture.addToCache(Y, W), V === 0 && (z[r] = Y, BaseTexture.addToCache(Y.baseTexture, r), Texture.addToCache(Y, r)), z[W] = Y;
            }), Object.assign(t, { textures: z });
          }
        } catch (X) {
          e(X);
          return;
        }
      e();
    }, o.extension = ExtensionType.Loader, o.loadKeyValueData = !1, o;
  }()
);
/*!
 * @pixi/particle-container - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/particle-container is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$l = function(o, t) {
  return extendStatics$l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$l(o, t);
};
function __extends$l(o, t) {
  extendStatics$l(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
(function(o) {
  __extends$l(t, o);
  function t(e, r, D, N) {
    e === void 0 && (e = 1500), D === void 0 && (D = 16384), N === void 0 && (N = !1);
    var k = o.call(this) || this, $ = 16384;
    return D > $ && (D = $), k._properties = [!1, !0, !1, !1, !1], k._maxSize = e, k._batchSize = D, k._buffers = null, k._bufferUpdateIDs = [], k._updateID = 0, k.interactiveChildren = !1, k.blendMode = BLEND_MODES.NORMAL, k.autoResize = N, k.roundPixels = !0, k.baseTexture = null, k.setProperties(r), k._tint = 0, k.tintRgb = new Float32Array(4), k.tint = 16777215, k;
  }
  return t.prototype.setProperties = function(e) {
    e && (this._properties[0] = "vertices" in e || "scale" in e ? !!e.vertices || !!e.scale : this._properties[0], this._properties[1] = "position" in e ? !!e.position : this._properties[1], this._properties[2] = "rotation" in e ? !!e.rotation : this._properties[2], this._properties[3] = "uvs" in e ? !!e.uvs : this._properties[3], this._properties[4] = "tint" in e || "alpha" in e ? !!e.tint || !!e.alpha : this._properties[4]);
  }, t.prototype.updateTransform = function() {
    this.displayObjectUpdateTransform();
  }, Object.defineProperty(t.prototype, "tint", {
    /**
     * The tint applied to the container. This is a hex value.
     * A value of 0xFFFFFF will remove any tint effect.
     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
     * @default 0xFFFFFF
     */
    get: function() {
      return this._tint;
    },
    set: function(e) {
      this._tint = e, hex2rgb(e, this.tintRgb);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.render = function(e) {
    var r = this;
    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", function() {
      return r.onChildrenChange(0);
    })), e.batch.setObjectRenderer(e.plugins.particle), e.plugins.particle.render(this));
  }, t.prototype.onChildrenChange = function(e) {
    for (var r = Math.floor(e / this._batchSize); this._bufferUpdateIDs.length < r; )
      this._bufferUpdateIDs.push(0);
    this._bufferUpdateIDs[r] = ++this._updateID;
  }, t.prototype.dispose = function() {
    if (this._buffers) {
      for (var e = 0; e < this._buffers.length; ++e)
        this._buffers[e].destroy();
      this._buffers = null;
    }
  }, t.prototype.destroy = function(e) {
    o.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;
  }, t;
})(Container);
var ParticleBuffer = (
  /** @class */
  function() {
    function o(t, e, r) {
      this.geometry = new Geometry(), this.indexBuffer = null, this.size = r, this.dynamicProperties = [], this.staticProperties = [];
      for (var D = 0; D < t.length; ++D) {
        var N = t[D];
        N = {
          attributeName: N.attributeName,
          size: N.size,
          uploadFunction: N.uploadFunction,
          type: N.type || TYPES.FLOAT,
          offset: N.offset
        }, e[D] ? this.dynamicProperties.push(N) : this.staticProperties.push(N);
      }
      this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();
    }
    return o.prototype.initBuffers = function() {
      var t = this.geometry, e = 0;
      this.indexBuffer = new Buffer$1(createIndicesForQuads(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;
      for (var r = 0; r < this.dynamicProperties.length; ++r) {
        var D = this.dynamicProperties[r];
        D.offset = e, e += D.size, this.dynamicStride += D.size;
      }
      var N = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
      this.dynamicData = new Float32Array(N), this.dynamicDataUint32 = new Uint32Array(N), this.dynamicBuffer = new Buffer$1(this.dynamicData, !1, !1);
      var k = 0;
      this.staticStride = 0;
      for (var r = 0; r < this.staticProperties.length; ++r) {
        var D = this.staticProperties[r];
        D.offset = k, k += D.size, this.staticStride += D.size;
      }
      var $ = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
      this.staticData = new Float32Array($), this.staticDataUint32 = new Uint32Array($), this.staticBuffer = new Buffer$1(this.staticData, !0, !1);
      for (var r = 0; r < this.dynamicProperties.length; ++r) {
        var D = this.dynamicProperties[r];
        t.addAttribute(D.attributeName, this.dynamicBuffer, 0, D.type === TYPES.UNSIGNED_BYTE, D.type, this.dynamicStride * 4, D.offset * 4);
      }
      for (var r = 0; r < this.staticProperties.length; ++r) {
        var D = this.staticProperties[r];
        t.addAttribute(D.attributeName, this.staticBuffer, 0, D.type === TYPES.UNSIGNED_BYTE, D.type, this.staticStride * 4, D.offset * 4);
      }
    }, o.prototype.uploadDynamic = function(t, e, r) {
      for (var D = 0; D < this.dynamicProperties.length; D++) {
        var N = this.dynamicProperties[D];
        N.uploadFunction(t, e, r, N.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, N.offset);
      }
      this.dynamicBuffer._updateID++;
    }, o.prototype.uploadStatic = function(t, e, r) {
      for (var D = 0; D < this.staticProperties.length; D++) {
        var N = this.staticProperties[D];
        N.uploadFunction(t, e, r, N.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, N.offset);
      }
      this.staticBuffer._updateID++;
    }, o.prototype.destroy = function() {
      this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();
    }, o;
  }()
), fragment$6 = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`, vertex$3 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`, ParticleRenderer = (
  /** @class */
  function(o) {
    __extends$l(t, o);
    function t(e) {
      var r = o.call(this, e) || this;
      return r.shader = null, r.properties = null, r.tempMatrix = new Matrix(), r.properties = [
        // verticesData
        {
          attributeName: "aVertexPosition",
          size: 2,
          uploadFunction: r.uploadVertices,
          offset: 0
        },
        // positionData
        {
          attributeName: "aPositionCoord",
          size: 2,
          uploadFunction: r.uploadPosition,
          offset: 0
        },
        // rotationData
        {
          attributeName: "aRotation",
          size: 1,
          uploadFunction: r.uploadRotation,
          offset: 0
        },
        // uvsData
        {
          attributeName: "aTextureCoord",
          size: 2,
          uploadFunction: r.uploadUvs,
          offset: 0
        },
        // tintData
        {
          attributeName: "aColor",
          size: 1,
          type: TYPES.UNSIGNED_BYTE,
          uploadFunction: r.uploadTint,
          offset: 0
        }
      ], r.shader = Shader.from(vertex$3, fragment$6, {}), r.state = State.for2d(), r;
    }
    return t.prototype.render = function(e) {
      var r = e.children, D = e._maxSize, N = e._batchSize, k = this.renderer, $ = r.length;
      if ($ !== 0) {
        $ > D && !e.autoResize && ($ = D);
        var G = e._buffers;
        G || (G = e._buffers = this.generateBuffers(e));
        var U = r[0]._texture.baseTexture, z = U.alphaMode > 0;
        this.state.blendMode = correctBlendMode(e.blendMode, z), k.state.set(this.state);
        var X = k.gl, V = e.worldTransform.copyTo(this.tempMatrix);
        V.prepend(k.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = V.toArray(!0), this.shader.uniforms.uColor = premultiplyRgba(e.tintRgb, e.worldAlpha, this.shader.uniforms.uColor, z), this.shader.uniforms.uSampler = U, this.renderer.shader.bind(this.shader);
        for (var Y = !1, W = 0, q = 0; W < $; W += N, q += 1) {
          var K = $ - W;
          K > N && (K = N), q >= G.length && G.push(this._generateOneMoreBuffer(e));
          var Z = G[q];
          Z.uploadDynamic(r, W, K);
          var J = e._bufferUpdateIDs[q] || 0;
          Y = Y || Z._updateID < J, Y && (Z._updateID = e._updateID, Z.uploadStatic(r, W, K)), k.geometry.bind(Z.geometry), X.drawElements(X.TRIANGLES, K * 6, X.UNSIGNED_SHORT, 0);
        }
      }
    }, t.prototype.generateBuffers = function(e) {
      for (var r = [], D = e._maxSize, N = e._batchSize, k = e._properties, $ = 0; $ < D; $ += N)
        r.push(new ParticleBuffer(this.properties, k, N));
      return r;
    }, t.prototype._generateOneMoreBuffer = function(e) {
      var r = e._batchSize, D = e._properties;
      return new ParticleBuffer(this.properties, D, r);
    }, t.prototype.uploadVertices = function(e, r, D, N, k, $) {
      for (var G = 0, U = 0, z = 0, X = 0, V = 0; V < D; ++V) {
        var Y = e[r + V], W = Y._texture, q = Y.scale.x, K = Y.scale.y, Z = W.trim, J = W.orig;
        Z ? (U = Z.x - Y.anchor.x * J.width, G = U + Z.width, X = Z.y - Y.anchor.y * J.height, z = X + Z.height) : (G = J.width * (1 - Y.anchor.x), U = J.width * -Y.anchor.x, z = J.height * (1 - Y.anchor.y), X = J.height * -Y.anchor.y), N[$] = U * q, N[$ + 1] = X * K, N[$ + k] = G * q, N[$ + k + 1] = X * K, N[$ + k * 2] = G * q, N[$ + k * 2 + 1] = z * K, N[$ + k * 3] = U * q, N[$ + k * 3 + 1] = z * K, $ += k * 4;
      }
    }, t.prototype.uploadPosition = function(e, r, D, N, k, $) {
      for (var G = 0; G < D; G++) {
        var U = e[r + G].position;
        N[$] = U.x, N[$ + 1] = U.y, N[$ + k] = U.x, N[$ + k + 1] = U.y, N[$ + k * 2] = U.x, N[$ + k * 2 + 1] = U.y, N[$ + k * 3] = U.x, N[$ + k * 3 + 1] = U.y, $ += k * 4;
      }
    }, t.prototype.uploadRotation = function(e, r, D, N, k, $) {
      for (var G = 0; G < D; G++) {
        var U = e[r + G].rotation;
        N[$] = U, N[$ + k] = U, N[$ + k * 2] = U, N[$ + k * 3] = U, $ += k * 4;
      }
    }, t.prototype.uploadUvs = function(e, r, D, N, k, $) {
      for (var G = 0; G < D; ++G) {
        var U = e[r + G]._texture._uvs;
        U ? (N[$] = U.x0, N[$ + 1] = U.y0, N[$ + k] = U.x1, N[$ + k + 1] = U.y1, N[$ + k * 2] = U.x2, N[$ + k * 2 + 1] = U.y2, N[$ + k * 3] = U.x3, N[$ + k * 3 + 1] = U.y3, $ += k * 4) : (N[$] = 0, N[$ + 1] = 0, N[$ + k] = 0, N[$ + k + 1] = 0, N[$ + k * 2] = 0, N[$ + k * 2 + 1] = 0, N[$ + k * 3] = 0, N[$ + k * 3 + 1] = 0, $ += k * 4);
      }
    }, t.prototype.uploadTint = function(e, r, D, N, k, $) {
      for (var G = 0; G < D; ++G) {
        var U = e[r + G], z = U._texture.baseTexture.alphaMode > 0, X = U.alpha, V = X < 1 && z ? premultiplyTint(U._tintRGB, X) : U._tintRGB + (X * 255 << 24);
        N[$] = V, N[$ + k] = V, N[$ + k * 2] = V, N[$ + k * 3] = V, $ += k * 4;
      }
    }, t.prototype.destroy = function() {
      o.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;
    }, t.extension = {
      name: "particle",
      type: ExtensionType.RendererPlugin
    }, t;
  }(ObjectRenderer)
);
/*!
 * @pixi/graphics - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/graphics is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var LINE_JOIN;
(function(o) {
  o.MITER = "miter", o.BEVEL = "bevel", o.ROUND = "round";
})(LINE_JOIN || (LINE_JOIN = {}));
var LINE_CAP;
(function(o) {
  o.BUTT = "butt", o.ROUND = "round", o.SQUARE = "square";
})(LINE_CAP || (LINE_CAP = {}));
var GRAPHICS_CURVES = {
  adaptive: !0,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount: function(o, t) {
    if (t === void 0 && (t = 20), !this.adaptive || !o || isNaN(o))
      return t;
    var e = Math.ceil(o / this.maxLength);
    return e < this.minSegments ? e = this.minSegments : e > this.maxSegments && (e = this.maxSegments), e;
  }
}, FillStyle = (
  /** @class */
  function() {
    function o() {
      this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1, this.reset();
    }
    return o.prototype.clone = function() {
      var t = new o();
      return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t;
    }, o.prototype.reset = function() {
      this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1;
    }, o.prototype.destroy = function() {
      this.texture = null, this.matrix = null;
    }, o;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$k = function(o, t) {
  return extendStatics$k = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$k(o, t);
};
function __extends$k(o, t) {
  extendStatics$k(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function fixOrientation(o, t) {
  var e, r;
  t === void 0 && (t = !1);
  var D = o.length;
  if (!(D < 6)) {
    for (var N = 0, k = 0, $ = o[D - 2], G = o[D - 1]; k < D; k += 2) {
      var U = o[k], z = o[k + 1];
      N += (U - $) * (z + G), $ = U, G = z;
    }
    if (!t && N > 0 || t && N <= 0)
      for (var X = D / 2, k = X + X % 2; k < D; k += 2) {
        var V = D - k - 2, Y = D - k - 1, W = k, q = k + 1;
        e = [o[W], o[V]], o[V] = e[0], o[W] = e[1], r = [o[q], o[Y]], o[Y] = r[0], o[q] = r[1];
      }
  }
}
var buildPoly = {
  build: function(o) {
    o.points = o.shape.points.slice();
  },
  triangulate: function(o, t) {
    var e = o.points, r = o.holes, D = t.points, N = t.indices;
    if (e.length >= 6) {
      fixOrientation(e, !1);
      for (var k = [], $ = 0; $ < r.length; $++) {
        var G = r[$];
        fixOrientation(G.points, !0), k.push(e.length / 2), e = e.concat(G.points);
      }
      var U = earcut$1(e, k, 2);
      if (!U)
        return;
      for (var z = D.length / 2, $ = 0; $ < U.length; $ += 3)
        N.push(U[$] + z), N.push(U[$ + 1] + z), N.push(U[$ + 2] + z);
      for (var $ = 0; $ < e.length; $++)
        D.push(e[$]);
    }
  }
}, buildCircle = {
  build: function(o) {
    var t = o.points, e, r, D, N, k, $;
    if (o.type === SHAPES.CIRC) {
      var G = o.shape;
      e = G.x, r = G.y, k = $ = G.radius, D = N = 0;
    } else if (o.type === SHAPES.ELIP) {
      var U = o.shape;
      e = U.x, r = U.y, k = U.width, $ = U.height, D = N = 0;
    } else {
      var z = o.shape, X = z.width / 2, V = z.height / 2;
      e = z.x + X, r = z.y + V, k = $ = Math.max(0, Math.min(z.radius, Math.min(X, V))), D = X - k, N = V - $;
    }
    if (!(k >= 0 && $ >= 0 && D >= 0 && N >= 0)) {
      t.length = 0;
      return;
    }
    var Y = Math.ceil(2.3 * Math.sqrt(k + $)), W = Y * 8 + (D ? 4 : 0) + (N ? 4 : 0);
    if (t.length = W, W !== 0) {
      if (Y === 0) {
        t.length = 8, t[0] = t[6] = e + D, t[1] = t[3] = r + N, t[2] = t[4] = e - D, t[5] = t[7] = r - N;
        return;
      }
      var q = 0, K = Y * 4 + (D ? 2 : 0) + 2, Z = K, J = W;
      {
        var Q = D + k, et = N, it = e + Q, tt = e - Q, nt = r + et;
        if (t[q++] = it, t[q++] = nt, t[--K] = nt, t[--K] = tt, N) {
          var st = r - et;
          t[Z++] = tt, t[Z++] = st, t[--J] = st, t[--J] = it;
        }
      }
      for (var at = 1; at < Y; at++) {
        var ut = Math.PI / 2 * (at / Y), Q = D + Math.cos(ut) * k, et = N + Math.sin(ut) * $, it = e + Q, tt = e - Q, nt = r + et, st = r - et;
        t[q++] = it, t[q++] = nt, t[--K] = nt, t[--K] = tt, t[Z++] = tt, t[Z++] = st, t[--J] = st, t[--J] = it;
      }
      {
        var Q = D, et = N + $, it = e + Q, tt = e - Q, nt = r + et, st = r - et;
        t[q++] = it, t[q++] = nt, t[--J] = st, t[--J] = it, D && (t[q++] = tt, t[q++] = nt, t[--J] = st, t[--J] = tt);
      }
    }
  },
  triangulate: function(o, t) {
    var e = o.points, r = t.points, D = t.indices;
    if (e.length !== 0) {
      var N = r.length / 2, k = N, $, G;
      if (o.type !== SHAPES.RREC) {
        var U = o.shape;
        $ = U.x, G = U.y;
      } else {
        var z = o.shape;
        $ = z.x + z.width / 2, G = z.y + z.height / 2;
      }
      var X = o.matrix;
      r.push(o.matrix ? X.a * $ + X.c * G + X.tx : $, o.matrix ? X.b * $ + X.d * G + X.ty : G), N++, r.push(e[0], e[1]);
      for (var V = 2; V < e.length; V += 2)
        r.push(e[V], e[V + 1]), D.push(N++, k, N);
      D.push(k + 1, k, N);
    }
  }
}, buildRectangle = {
  build: function(o) {
    var t = o.shape, e = t.x, r = t.y, D = t.width, N = t.height, k = o.points;
    k.length = 0, k.push(e, r, e + D, r, e + D, r + N, e, r + N);
  },
  triangulate: function(o, t) {
    var e = o.points, r = t.points, D = r.length / 2;
    r.push(e[0], e[1], e[2], e[3], e[6], e[7], e[4], e[5]), t.indices.push(D, D + 1, D + 2, D + 1, D + 2, D + 3);
  }
};
function getPt(o, t, e) {
  var r = t - o;
  return o + r * e;
}
function quadraticBezierCurve(o, t, e, r, D, N, k) {
  k === void 0 && (k = []);
  for (var $ = 20, G = k, U = 0, z = 0, X = 0, V = 0, Y = 0, W = 0, q = 0, K = 0; q <= $; ++q)
    K = q / $, U = getPt(o, e, K), z = getPt(t, r, K), X = getPt(e, D, K), V = getPt(r, N, K), Y = getPt(U, X, K), W = getPt(z, V, K), !(q === 0 && G[G.length - 2] === Y && G[G.length - 1] === W) && G.push(Y, W);
  return G;
}
var buildRoundedRectangle = {
  build: function(o) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.build(o);
      return;
    }
    var t = o.shape, e = o.points, r = t.x, D = t.y, N = t.width, k = t.height, $ = Math.max(0, Math.min(t.radius, Math.min(N, k) / 2));
    e.length = 0, $ ? (quadraticBezierCurve(r, D + $, r, D, r + $, D, e), quadraticBezierCurve(r + N - $, D, r + N, D, r + N, D + $, e), quadraticBezierCurve(r + N, D + k - $, r + N, D + k, r + N - $, D + k, e), quadraticBezierCurve(r + $, D + k, r, D + k, r, D + k - $, e)) : e.push(r, D, r + N, D, r + N, D + k, r, D + k);
  },
  triangulate: function(o, t) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.triangulate(o, t);
      return;
    }
    for (var e = o.points, r = t.points, D = t.indices, N = r.length / 2, k = earcut$1(e, null, 2), $ = 0, G = k.length; $ < G; $ += 3)
      D.push(k[$] + N), D.push(k[$ + 1] + N), D.push(k[$ + 2] + N);
    for (var $ = 0, G = e.length; $ < G; $++)
      r.push(e[$], e[++$]);
  }
};
function square(o, t, e, r, D, N, k, $) {
  var G = o - e * D, U = t - r * D, z = o + e * N, X = t + r * N, V, Y;
  k ? (V = r, Y = -e) : (V = -r, Y = e);
  var W = G + V, q = U + Y, K = z + V, Z = X + Y;
  return $.push(W, q), $.push(K, Z), 2;
}
function round$1(o, t, e, r, D, N, k, $) {
  var G = e - o, U = r - t, z = Math.atan2(G, U), X = Math.atan2(D - o, N - t);
  $ && z < X ? z += Math.PI * 2 : !$ && z > X && (X += Math.PI * 2);
  var V = z, Y = X - z, W = Math.abs(Y), q = Math.sqrt(G * G + U * U), K = (15 * W * Math.sqrt(q) / Math.PI >> 0) + 1, Z = Y / K;
  if (V += Z, $) {
    k.push(o, t), k.push(e, r);
    for (var J = 1, Q = V; J < K; J++, Q += Z)
      k.push(o, t), k.push(o + Math.sin(Q) * q, t + Math.cos(Q) * q);
    k.push(o, t), k.push(D, N);
  } else {
    k.push(e, r), k.push(o, t);
    for (var J = 1, Q = V; J < K; J++, Q += Z)
      k.push(o + Math.sin(Q) * q, t + Math.cos(Q) * q), k.push(o, t);
    k.push(D, N), k.push(o, t);
  }
  return K * 2;
}
function buildNonNativeLine(o, t) {
  var e = o.shape, r = o.points || e.points.slice(), D = t.closePointEps;
  if (r.length !== 0) {
    var N = o.lineStyle, k = new Point(r[0], r[1]), $ = new Point(r[r.length - 2], r[r.length - 1]), G = e.type !== SHAPES.POLY || e.closeStroke, U = Math.abs(k.x - $.x) < D && Math.abs(k.y - $.y) < D;
    if (G) {
      r = r.slice(), U && (r.pop(), r.pop(), $.set(r[r.length - 2], r[r.length - 1]));
      var z = (k.x + $.x) * 0.5, X = ($.y + k.y) * 0.5;
      r.unshift(z, X), r.push(z, X);
    }
    var V = t.points, Y = r.length / 2, W = r.length, q = V.length / 2, K = N.width / 2, Z = K * K, J = N.miterLimit * N.miterLimit, Q = r[0], et = r[1], it = r[2], tt = r[3], nt = 0, st = 0, at = -(et - tt), ut = Q - it, ht = 0, dt = 0, pt = Math.sqrt(at * at + ut * ut);
    at /= pt, ut /= pt, at *= K, ut *= K;
    var _t = N.alignment, mt = (1 - _t) * 2, yt = _t * 2;
    G || (N.cap === LINE_CAP.ROUND ? W += round$1(Q - at * (mt - yt) * 0.5, et - ut * (mt - yt) * 0.5, Q - at * mt, et - ut * mt, Q + at * yt, et + ut * yt, V, !0) + 2 : N.cap === LINE_CAP.SQUARE && (W += square(Q, et, at, ut, mt, yt, !0, V))), V.push(Q - at * mt, et - ut * mt), V.push(Q + at * yt, et + ut * yt);
    for (var Tt = 1; Tt < Y - 1; ++Tt) {
      Q = r[(Tt - 1) * 2], et = r[(Tt - 1) * 2 + 1], it = r[Tt * 2], tt = r[Tt * 2 + 1], nt = r[(Tt + 1) * 2], st = r[(Tt + 1) * 2 + 1], at = -(et - tt), ut = Q - it, pt = Math.sqrt(at * at + ut * ut), at /= pt, ut /= pt, at *= K, ut *= K, ht = -(tt - st), dt = it - nt, pt = Math.sqrt(ht * ht + dt * dt), ht /= pt, dt /= pt, ht *= K, dt *= K;
      var Pt = it - Q, St = et - tt, gt = it - nt, bt = st - tt, At = Pt * gt + St * bt, Rt = St * gt - bt * Pt, Nt = Rt < 0;
      if (Math.abs(Rt) < 1e-3 * Math.abs(At)) {
        V.push(it - at * mt, tt - ut * mt), V.push(it + at * yt, tt + ut * yt), At >= 0 && (N.join === LINE_JOIN.ROUND ? W += round$1(it, tt, it - at * mt, tt - ut * mt, it - ht * mt, tt - dt * mt, V, !1) + 4 : W += 2, V.push(it - ht * yt, tt - dt * yt), V.push(it + ht * mt, tt + dt * mt));
        continue;
      }
      var Mt = (-at + Q) * (-ut + tt) - (-at + it) * (-ut + et), ft = (-ht + nt) * (-dt + tt) - (-ht + it) * (-dt + st), Ft = (Pt * ft - gt * Mt) / Rt, Dt = (bt * Mt - St * ft) / Rt, Vt = (Ft - it) * (Ft - it) + (Dt - tt) * (Dt - tt), Bt = it + (Ft - it) * mt, Et = tt + (Dt - tt) * mt, Ht = it - (Ft - it) * yt, kt = tt - (Dt - tt) * yt, wt = Math.min(Pt * Pt + St * St, gt * gt + bt * bt), Lt = Nt ? mt : yt, jt = wt + Lt * Lt * Z, Ct = Vt <= jt;
      Ct ? N.join === LINE_JOIN.BEVEL || Vt / Z > J ? (Nt ? (V.push(Bt, Et), V.push(it + at * yt, tt + ut * yt), V.push(Bt, Et), V.push(it + ht * yt, tt + dt * yt)) : (V.push(it - at * mt, tt - ut * mt), V.push(Ht, kt), V.push(it - ht * mt, tt - dt * mt), V.push(Ht, kt)), W += 2) : N.join === LINE_JOIN.ROUND ? Nt ? (V.push(Bt, Et), V.push(it + at * yt, tt + ut * yt), W += round$1(it, tt, it + at * yt, tt + ut * yt, it + ht * yt, tt + dt * yt, V, !0) + 4, V.push(Bt, Et), V.push(it + ht * yt, tt + dt * yt)) : (V.push(it - at * mt, tt - ut * mt), V.push(Ht, kt), W += round$1(it, tt, it - at * mt, tt - ut * mt, it - ht * mt, tt - dt * mt, V, !1) + 4, V.push(it - ht * mt, tt - dt * mt), V.push(Ht, kt)) : (V.push(Bt, Et), V.push(Ht, kt)) : (V.push(it - at * mt, tt - ut * mt), V.push(it + at * yt, tt + ut * yt), N.join === LINE_JOIN.ROUND ? Nt ? W += round$1(it, tt, it + at * yt, tt + ut * yt, it + ht * yt, tt + dt * yt, V, !0) + 2 : W += round$1(it, tt, it - at * mt, tt - ut * mt, it - ht * mt, tt - dt * mt, V, !1) + 2 : N.join === LINE_JOIN.MITER && Vt / Z <= J && (Nt ? (V.push(Ht, kt), V.push(Ht, kt)) : (V.push(Bt, Et), V.push(Bt, Et)), W += 2), V.push(it - ht * mt, tt - dt * mt), V.push(it + ht * yt, tt + dt * yt), W += 2);
    }
    Q = r[(Y - 2) * 2], et = r[(Y - 2) * 2 + 1], it = r[(Y - 1) * 2], tt = r[(Y - 1) * 2 + 1], at = -(et - tt), ut = Q - it, pt = Math.sqrt(at * at + ut * ut), at /= pt, ut /= pt, at *= K, ut *= K, V.push(it - at * mt, tt - ut * mt), V.push(it + at * yt, tt + ut * yt), G || (N.cap === LINE_CAP.ROUND ? W += round$1(it - at * (mt - yt) * 0.5, tt - ut * (mt - yt) * 0.5, it - at * mt, tt - ut * mt, it + at * yt, tt + ut * yt, V, !1) + 2 : N.cap === LINE_CAP.SQUARE && (W += square(it, tt, at, ut, mt, yt, !1, V)));
    for (var Wt = t.indices, Jt = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon, Tt = q; Tt < W + q - 2; ++Tt)
      Q = V[Tt * 2], et = V[Tt * 2 + 1], it = V[(Tt + 1) * 2], tt = V[(Tt + 1) * 2 + 1], nt = V[(Tt + 2) * 2], st = V[(Tt + 2) * 2 + 1], !(Math.abs(Q * (tt - st) + it * (st - et) + nt * (et - tt)) < Jt) && Wt.push(Tt, Tt + 1, Tt + 2);
  }
}
function buildNativeLine(o, t) {
  var e = 0, r = o.shape, D = o.points || r.points, N = r.type !== SHAPES.POLY || r.closeStroke;
  if (D.length !== 0) {
    var k = t.points, $ = t.indices, G = D.length / 2, U = k.length / 2, z = U;
    for (k.push(D[0], D[1]), e = 1; e < G; e++)
      k.push(D[e * 2], D[e * 2 + 1]), $.push(z, z + 1), z++;
    N && $.push(z, U);
  }
}
function buildLine(o, t) {
  o.lineStyle.native ? buildNativeLine(o, t) : buildNonNativeLine(o, t);
}
var ArcUtils = (
  /** @class */
  function() {
    function o() {
    }
    return o.curveTo = function(t, e, r, D, N, k) {
      var $ = k[k.length - 2], G = k[k.length - 1], U = G - e, z = $ - t, X = D - e, V = r - t, Y = Math.abs(U * V - z * X);
      if (Y < 1e-8 || N === 0)
        return (k[k.length - 2] !== t || k[k.length - 1] !== e) && k.push(t, e), null;
      var W = U * U + z * z, q = X * X + V * V, K = U * X + z * V, Z = N * Math.sqrt(W) / Y, J = N * Math.sqrt(q) / Y, Q = Z * K / W, et = J * K / q, it = Z * V + J * z, tt = Z * X + J * U, nt = z * (J + Q), st = U * (J + Q), at = V * (Z + et), ut = X * (Z + et), ht = Math.atan2(st - tt, nt - it), dt = Math.atan2(ut - tt, at - it);
      return {
        cx: it + t,
        cy: tt + e,
        radius: N,
        startAngle: ht,
        endAngle: dt,
        anticlockwise: z * X > V * U
      };
    }, o.arc = function(t, e, r, D, N, k, $, G, U) {
      for (var z = $ - k, X = GRAPHICS_CURVES._segmentsCount(Math.abs(z) * N, Math.ceil(Math.abs(z) / PI_2) * 40), V = z / (X * 2), Y = V * 2, W = Math.cos(V), q = Math.sin(V), K = X - 1, Z = K % 1 / K, J = 0; J <= K; ++J) {
        var Q = J + Z * J, et = V + k + Y * Q, it = Math.cos(et), tt = -Math.sin(et);
        U.push((W * it + q * tt) * N + r, (W * -tt + q * it) * N + D);
      }
    }, o;
  }()
), BezierUtils = (
  /** @class */
  function() {
    function o() {
    }
    return o.curveLength = function(t, e, r, D, N, k, $, G) {
      for (var U = 10, z = 0, X = 0, V = 0, Y = 0, W = 0, q = 0, K = 0, Z = 0, J = 0, Q = 0, et = 0, it = t, tt = e, nt = 1; nt <= U; ++nt)
        X = nt / U, V = X * X, Y = V * X, W = 1 - X, q = W * W, K = q * W, Z = K * t + 3 * q * X * r + 3 * W * V * N + Y * $, J = K * e + 3 * q * X * D + 3 * W * V * k + Y * G, Q = it - Z, et = tt - J, it = Z, tt = J, z += Math.sqrt(Q * Q + et * et);
      return z;
    }, o.curveTo = function(t, e, r, D, N, k, $) {
      var G = $[$.length - 2], U = $[$.length - 1];
      $.length -= 2;
      var z = GRAPHICS_CURVES._segmentsCount(o.curveLength(G, U, t, e, r, D, N, k)), X = 0, V = 0, Y = 0, W = 0, q = 0;
      $.push(G, U);
      for (var K = 1, Z = 0; K <= z; ++K)
        Z = K / z, X = 1 - Z, V = X * X, Y = V * X, W = Z * Z, q = W * Z, $.push(Y * G + 3 * V * Z * t + 3 * X * W * r + q * N, Y * U + 3 * V * Z * e + 3 * X * W * D + q * k);
    }, o;
  }()
), QuadraticUtils = (
  /** @class */
  function() {
    function o() {
    }
    return o.curveLength = function(t, e, r, D, N, k) {
      var $ = t - 2 * r + N, G = e - 2 * D + k, U = 2 * r - 2 * t, z = 2 * D - 2 * e, X = 4 * ($ * $ + G * G), V = 4 * ($ * U + G * z), Y = U * U + z * z, W = 2 * Math.sqrt(X + V + Y), q = Math.sqrt(X), K = 2 * X * q, Z = 2 * Math.sqrt(Y), J = V / q;
      return (K * W + q * V * (W - Z) + (4 * Y * X - V * V) * Math.log((2 * q + J + W) / (J + Z))) / (4 * K);
    }, o.curveTo = function(t, e, r, D, N) {
      for (var k = N[N.length - 2], $ = N[N.length - 1], G = GRAPHICS_CURVES._segmentsCount(o.curveLength(k, $, t, e, r, D)), U = 0, z = 0, X = 1; X <= G; ++X) {
        var V = X / G;
        U = k + (t - k) * V, z = $ + (e - $) * V, N.push(U + (t + (r - t) * V - U) * V, z + (e + (D - e) * V - z) * V);
      }
    }, o;
  }()
), BatchPart = (
  /** @class */
  function() {
    function o() {
      this.reset();
    }
    return o.prototype.begin = function(t, e, r) {
      this.reset(), this.style = t, this.start = e, this.attribStart = r;
    }, o.prototype.end = function(t, e) {
      this.attribSize = e - this.attribStart, this.size = t - this.start;
    }, o.prototype.reset = function() {
      this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;
    }, o;
  }()
), _a, FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a), BATCH_POOL = [], DRAW_CALL_POOL = [], GraphicsData = (
  /** @class */
  function() {
    function o(t, e, r, D) {
      e === void 0 && (e = null), r === void 0 && (r = null), D === void 0 && (D = null), this.points = [], this.holes = [], this.shape = t, this.lineStyle = r, this.fillStyle = e, this.matrix = D, this.type = t.type;
    }
    return o.prototype.clone = function() {
      return new o(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    }, o.prototype.destroy = function() {
      this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;
    }, o;
  }()
), tmpPoint = new Point(), GraphicsGeometry = (
  /** @class */
  function(o) {
    __extends$k(t, o);
    function t() {
      var e = o.call(this) || this;
      return e.closePointEps = 1e-4, e.boundsPadding = 0, e.uvsFloat32 = null, e.indicesUint16 = null, e.batchable = !1, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.drawCalls = [], e.batchDirty = -1, e.batches = [], e.dirty = 0, e.cacheDirty = -1, e.clearDirty = 0, e.shapeIndex = 0, e._bounds = new Bounds(), e.boundsDirty = -1, e;
    }
    return Object.defineProperty(t.prototype, "bounds", {
      /**
       * Get the current bounds of the graphic geometry.
       * @readonly
       */
      get: function() {
        return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.invalidate = function() {
      this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
      for (var e = 0; e < this.drawCalls.length; e++)
        this.drawCalls[e].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[e]);
      this.drawCalls.length = 0;
      for (var e = 0; e < this.batches.length; e++) {
        var r = this.batches[e];
        r.reset(), BATCH_POOL.push(r);
      }
      this.batches.length = 0;
    }, t.prototype.clear = function() {
      return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;
    }, t.prototype.drawShape = function(e, r, D, N) {
      r === void 0 && (r = null), D === void 0 && (D = null), N === void 0 && (N = null);
      var k = new GraphicsData(e, r, D, N);
      return this.graphicsData.push(k), this.dirty++, this;
    }, t.prototype.drawHole = function(e, r) {
      if (r === void 0 && (r = null), !this.graphicsData.length)
        return null;
      var D = new GraphicsData(e, null, null, r), N = this.graphicsData[this.graphicsData.length - 1];
      return D.lineStyle = N.lineStyle, N.holes.push(D), this.dirty++, this;
    }, t.prototype.destroy = function() {
      o.prototype.destroy.call(this);
      for (var e = 0; e < this.graphicsData.length; ++e)
        this.graphicsData[e].destroy();
      this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;
    }, t.prototype.containsPoint = function(e) {
      for (var r = this.graphicsData, D = 0; D < r.length; ++D) {
        var N = r[D];
        if (N.fillStyle.visible && N.shape && (N.matrix ? N.matrix.applyInverse(e, tmpPoint) : tmpPoint.copyFrom(e), N.shape.contains(tmpPoint.x, tmpPoint.y))) {
          var k = !1;
          if (N.holes)
            for (var $ = 0; $ < N.holes.length; $++) {
              var G = N.holes[$];
              if (G.shape.contains(tmpPoint.x, tmpPoint.y)) {
                k = !0;
                break;
              }
            }
          if (!k)
            return !0;
        }
      }
      return !1;
    }, t.prototype.updateBatches = function() {
      if (!this.graphicsData.length) {
        this.batchable = !0;
        return;
      }
      if (this.validateBatching()) {
        this.cacheDirty = this.dirty;
        var e = this.uvs, r = this.graphicsData, D = null, N = null;
        this.batches.length > 0 && (D = this.batches[this.batches.length - 1], N = D.style);
        for (var k = this.shapeIndex; k < r.length; k++) {
          this.shapeIndex++;
          var $ = r[k], G = $.fillStyle, U = $.lineStyle, z = FILL_COMMANDS[$.type];
          z.build($), $.matrix && this.transformPoints($.points, $.matrix), (G.visible || U.visible) && this.processHoles($.holes);
          for (var X = 0; X < 2; X++) {
            var V = X === 0 ? G : U;
            if (V.visible) {
              var Y = V.texture.baseTexture, W = this.indices.length, q = this.points.length / 2;
              Y.wrapMode = WRAP_MODES.REPEAT, X === 0 ? this.processFill($) : this.processLine($);
              var K = this.points.length / 2 - q;
              K !== 0 && (D && !this._compareStyles(N, V) && (D.end(W, q), D = null), D || (D = BATCH_POOL.pop() || new BatchPart(), D.begin(V, W, q), this.batches.push(D), N = V), this.addUvs(this.points, e, V.texture, q, K, V.matrix));
            }
          }
        }
        var Z = this.indices.length, J = this.points.length / 2;
        if (D && D.end(Z, J), this.batches.length === 0) {
          this.batchable = !0;
          return;
        }
        var Q = J > 65535;
        this.indicesUint16 && this.indices.length === this.indicesUint16.length && Q === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = Q ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();
      }
    }, t.prototype._compareStyles = function(e, r) {
      return !(!e || !r || e.texture.baseTexture !== r.texture.baseTexture || e.color + e.alpha !== r.color + r.alpha || !!e.native != !!r.native);
    }, t.prototype.validateBatching = function() {
      if (this.dirty === this.cacheDirty || !this.graphicsData.length)
        return !1;
      for (var e = 0, r = this.graphicsData.length; e < r; e++) {
        var D = this.graphicsData[e], N = D.fillStyle, k = D.lineStyle;
        if (N && !N.texture.baseTexture.valid || k && !k.texture.baseTexture.valid)
          return !1;
      }
      return !0;
    }, t.prototype.packBatches = function() {
      this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
      for (var e = this.batches, r = 0, D = e.length; r < D; r++)
        for (var N = e[r], k = 0; k < N.size; k++) {
          var $ = N.start + k;
          this.indicesUint16[$] = this.indicesUint16[$] - N.attribStart;
        }
    }, t.prototype.isBatchable = function() {
      if (this.points.length > 65535 * 2)
        return !1;
      for (var e = this.batches, r = 0; r < e.length; r++)
        if (e[r].style.native)
          return !1;
      return this.points.length < t.BATCHABLE_SIZE * 2;
    }, t.prototype.buildDrawCalls = function() {
      for (var e = ++BaseTexture._globalBatch, r = 0; r < this.drawCalls.length; r++)
        this.drawCalls[r].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[r]);
      this.drawCalls.length = 0;
      var D = this.colors, N = this.textureIds, k = DRAW_CALL_POOL.pop();
      k || (k = new BatchDrawCall(), k.texArray = new BatchTextureArray()), k.texArray.count = 0, k.start = 0, k.size = 0, k.type = DRAW_MODES.TRIANGLES;
      var $ = 0, G = null, U = 0, z = !1, X = DRAW_MODES.TRIANGLES, V = 0;
      this.drawCalls.push(k);
      for (var r = 0; r < this.batches.length; r++) {
        var Y = this.batches[r], W = 8, q = Y.style, K = q.texture.baseTexture;
        z !== !!q.native && (z = !!q.native, X = z ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES, G = null, $ = W, e++), G !== K && (G = K, K._batchEnabled !== e && ($ === W && (e++, $ = 0, k.size > 0 && (k = DRAW_CALL_POOL.pop(), k || (k = new BatchDrawCall(), k.texArray = new BatchTextureArray()), this.drawCalls.push(k)), k.start = V, k.size = 0, k.texArray.count = 0, k.type = X), K.touched = 1, K._batchEnabled = e, K._batchLocation = $, K.wrapMode = WRAP_MODES.REPEAT, k.texArray.elements[k.texArray.count++] = K, $++)), k.size += Y.size, V += Y.size, U = K._batchLocation, this.addColors(D, q.color, q.alpha, Y.attribSize, Y.attribStart), this.addTextureIds(N, U, Y.attribSize, Y.attribStart);
      }
      BaseTexture._globalBatch = e, this.packAttributes();
    }, t.prototype.packAttributes = function() {
      for (var e = this.points, r = this.uvs, D = this.colors, N = this.textureIds, k = new ArrayBuffer(e.length * 3 * 4), $ = new Float32Array(k), G = new Uint32Array(k), U = 0, z = 0; z < e.length / 2; z++)
        $[U++] = e[z * 2], $[U++] = e[z * 2 + 1], $[U++] = r[z * 2], $[U++] = r[z * 2 + 1], G[U++] = D[z], $[U++] = N[z];
      this._buffer.update(k), this._indexBuffer.update(this.indicesUint16);
    }, t.prototype.processFill = function(e) {
      if (e.holes.length)
        buildPoly.triangulate(e, this);
      else {
        var r = FILL_COMMANDS[e.type];
        r.triangulate(e, this);
      }
    }, t.prototype.processLine = function(e) {
      buildLine(e, this);
      for (var r = 0; r < e.holes.length; r++)
        buildLine(e.holes[r], this);
    }, t.prototype.processHoles = function(e) {
      for (var r = 0; r < e.length; r++) {
        var D = e[r], N = FILL_COMMANDS[D.type];
        N.build(D), D.matrix && this.transformPoints(D.points, D.matrix);
      }
    }, t.prototype.calculateBounds = function() {
      var e = this._bounds;
      e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding);
    }, t.prototype.transformPoints = function(e, r) {
      for (var D = 0; D < e.length / 2; D++) {
        var N = e[D * 2], k = e[D * 2 + 1];
        e[D * 2] = r.a * N + r.c * k + r.tx, e[D * 2 + 1] = r.b * N + r.d * k + r.ty;
      }
    }, t.prototype.addColors = function(e, r, D, N, k) {
      k === void 0 && (k = 0);
      var $ = (r >> 16) + (r & 65280) + ((r & 255) << 16), G = premultiplyTint($, D);
      e.length = Math.max(e.length, k + N);
      for (var U = 0; U < N; U++)
        e[k + U] = G;
    }, t.prototype.addTextureIds = function(e, r, D, N) {
      N === void 0 && (N = 0), e.length = Math.max(e.length, N + D);
      for (var k = 0; k < D; k++)
        e[N + k] = r;
    }, t.prototype.addUvs = function(e, r, D, N, k, $) {
      $ === void 0 && ($ = null);
      for (var G = 0, U = r.length, z = D.frame; G < k; ) {
        var X = e[(N + G) * 2], V = e[(N + G) * 2 + 1];
        if ($) {
          var Y = $.a * X + $.c * V + $.tx;
          V = $.b * X + $.d * V + $.ty, X = Y;
        }
        G++, r.push(X / z.width, V / z.height);
      }
      var W = D.baseTexture;
      (z.width < W.width || z.height < W.height) && this.adjustUvs(r, D, U, k);
    }, t.prototype.adjustUvs = function(e, r, D, N) {
      for (var k = r.baseTexture, $ = 1e-6, G = D + N * 2, U = r.frame, z = U.width / k.width, X = U.height / k.height, V = U.x / U.width, Y = U.y / U.height, W = Math.floor(e[D] + $), q = Math.floor(e[D + 1] + $), K = D + 2; K < G; K += 2)
        W = Math.min(W, Math.floor(e[K] + $)), q = Math.min(q, Math.floor(e[K + 1] + $));
      V -= W, Y -= q;
      for (var K = D; K < G; K += 2)
        e[K] = (e[K] + V) * z, e[K + 1] = (e[K + 1] + Y) * X;
    }, t.BATCHABLE_SIZE = 100, t;
  }(BatchGeometry)
), LineStyle = (
  /** @class */
  function(o) {
    __extends$k(t, o);
    function t() {
      var e = o !== null && o.apply(this, arguments) || this;
      return e.width = 0, e.alignment = 0.5, e.native = !1, e.cap = LINE_CAP.BUTT, e.join = LINE_JOIN.MITER, e.miterLimit = 10, e;
    }
    return t.prototype.clone = function() {
      var e = new t();
      return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e.width = this.width, e.alignment = this.alignment, e.native = this.native, e.cap = this.cap, e.join = this.join, e.miterLimit = this.miterLimit, e;
    }, t.prototype.reset = function() {
      o.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1;
    }, t;
  }(FillStyle)
), temp = new Float32Array(3), DEFAULT_SHADERS = {}, Graphics = (
  /** @class */
  function(o) {
    __extends$k(t, o);
    function t(e) {
      e === void 0 && (e = null);
      var r = o.call(this) || this;
      return r.shader = null, r.pluginName = "batch", r.currentPath = null, r.batches = [], r.batchTint = -1, r.batchDirty = -1, r.vertexData = null, r._fillStyle = new FillStyle(), r._lineStyle = new LineStyle(), r._matrix = null, r._holeMode = !1, r.state = State.for2d(), r._geometry = e || new GraphicsGeometry(), r._geometry.refCount++, r._transformID = -1, r.tint = 16777215, r.blendMode = BLEND_MODES.NORMAL, r;
    }
    return Object.defineProperty(t.prototype, "geometry", {
      /**
       * Includes vertex positions, face indices, normals, colors, UVs, and
       * custom attributes within buffers, reducing the cost of passing all
       * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
       * @readonly
       */
      get: function() {
        return this._geometry;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.clone = function() {
      return this.finishPoly(), new t(this._geometry);
    }, Object.defineProperty(t.prototype, "blendMode", {
      get: function() {
        return this.state.blendMode;
      },
      /**
       * The blend mode to be applied to the graphic shape. Apply a value of
       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each
       * primitive in the GraphicsGeometry list is rendered sequentially, modes
       * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will
       * be applied per-primitive.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      set: function(e) {
        this.state.blendMode = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      /**
       * The tint applied to each graphic shape. This is a hex value. A value of
       * 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get: function() {
        return this._tint;
      },
      set: function(e) {
        this._tint = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "fill", {
      /**
       * The current fill style.
       * @readonly
       */
      get: function() {
        return this._fillStyle;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "line", {
      /**
       * The current line style.
       * @readonly
       */
      get: function() {
        return this._lineStyle;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.lineStyle = function(e, r, D, N, k) {
      return e === void 0 && (e = null), r === void 0 && (r = 0), D === void 0 && (D = 1), N === void 0 && (N = 0.5), k === void 0 && (k = !1), typeof e == "number" && (e = { width: e, color: r, alpha: D, alignment: N, native: k }), this.lineTextureStyle(e);
    }, t.prototype.lineTextureStyle = function(e) {
      e = Object.assign({
        width: 0,
        texture: Texture.WHITE,
        color: e && e.texture ? 16777215 : 0,
        alpha: 1,
        matrix: null,
        alignment: 0.5,
        native: !1,
        cap: LINE_CAP.BUTT,
        join: LINE_JOIN.MITER,
        miterLimit: 10
      }, e), this.currentPath && this.startPoly();
      var r = e.width > 0 && e.alpha > 0;
      return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, { visible: r }, e)) : this._lineStyle.reset(), this;
    }, t.prototype.startPoly = function() {
      if (this.currentPath) {
        var e = this.currentPath.points, r = this.currentPath.points.length;
        r > 2 && (this.drawShape(this.currentPath), this.currentPath = new Polygon(), this.currentPath.closeStroke = !1, this.currentPath.points.push(e[r - 2], e[r - 1]));
      } else
        this.currentPath = new Polygon(), this.currentPath.closeStroke = !1;
    }, t.prototype.finishPoly = function() {
      this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);
    }, t.prototype.moveTo = function(e, r) {
      return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = r, this;
    }, t.prototype.lineTo = function(e, r) {
      this.currentPath || this.moveTo(0, 0);
      var D = this.currentPath.points, N = D[D.length - 2], k = D[D.length - 1];
      return (N !== e || k !== r) && D.push(e, r), this;
    }, t.prototype._initCurve = function(e, r) {
      e === void 0 && (e = 0), r === void 0 && (r = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, r]) : this.moveTo(e, r);
    }, t.prototype.quadraticCurveTo = function(e, r, D, N) {
      this._initCurve();
      var k = this.currentPath.points;
      return k.length === 0 && this.moveTo(0, 0), QuadraticUtils.curveTo(e, r, D, N, k), this;
    }, t.prototype.bezierCurveTo = function(e, r, D, N, k, $) {
      return this._initCurve(), BezierUtils.curveTo(e, r, D, N, k, $, this.currentPath.points), this;
    }, t.prototype.arcTo = function(e, r, D, N, k) {
      this._initCurve(e, r);
      var $ = this.currentPath.points, G = ArcUtils.curveTo(e, r, D, N, k, $);
      if (G) {
        var U = G.cx, z = G.cy, X = G.radius, V = G.startAngle, Y = G.endAngle, W = G.anticlockwise;
        this.arc(U, z, X, V, Y, W);
      }
      return this;
    }, t.prototype.arc = function(e, r, D, N, k, $) {
      if ($ === void 0 && ($ = !1), N === k)
        return this;
      !$ && k <= N ? k += PI_2 : $ && N <= k && (N += PI_2);
      var G = k - N;
      if (G === 0)
        return this;
      var U = e + Math.cos(N) * D, z = r + Math.sin(N) * D, X = this._geometry.closePointEps, V = this.currentPath ? this.currentPath.points : null;
      if (V) {
        var Y = Math.abs(V[V.length - 2] - U), W = Math.abs(V[V.length - 1] - z);
        Y < X && W < X || V.push(U, z);
      } else
        this.moveTo(U, z), V = this.currentPath.points;
      return ArcUtils.arc(U, z, e, r, D, N, k, $, V), this;
    }, t.prototype.beginFill = function(e, r) {
      return e === void 0 && (e = 0), r === void 0 && (r = 1), this.beginTextureFill({ texture: Texture.WHITE, color: e, alpha: r });
    }, t.prototype.beginTextureFill = function(e) {
      e = Object.assign({
        texture: Texture.WHITE,
        color: 16777215,
        alpha: 1,
        matrix: null
      }, e), this.currentPath && this.startPoly();
      var r = e.alpha > 0;
      return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, { visible: r }, e)) : this._fillStyle.reset(), this;
    }, t.prototype.endFill = function() {
      return this.finishPoly(), this._fillStyle.reset(), this;
    }, t.prototype.drawRect = function(e, r, D, N) {
      return this.drawShape(new Rectangle(e, r, D, N));
    }, t.prototype.drawRoundedRect = function(e, r, D, N, k) {
      return this.drawShape(new RoundedRectangle(e, r, D, N, k));
    }, t.prototype.drawCircle = function(e, r, D) {
      return this.drawShape(new Circle(e, r, D));
    }, t.prototype.drawEllipse = function(e, r, D, N) {
      return this.drawShape(new Ellipse(e, r, D, N));
    }, t.prototype.drawPolygon = function() {
      for (var e = arguments, r = [], D = 0; D < arguments.length; D++)
        r[D] = e[D];
      var N, k = !0, $ = r[0];
      $.points ? (k = $.closeStroke, N = $.points) : Array.isArray(r[0]) ? N = r[0] : N = r;
      var G = new Polygon(N);
      return G.closeStroke = k, this.drawShape(G), this;
    }, t.prototype.drawShape = function(e) {
      return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;
    }, t.prototype.clear = function() {
      return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;
    }, t.prototype.isFastRect = function() {
      var e = this._geometry.graphicsData;
      return e.length === 1 && e[0].shape.type === SHAPES.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width);
    }, t.prototype._render = function(e) {
      this.finishPoly();
      var r = this._geometry;
      r.updateBatches(), r.batchable ? (this.batchDirty !== r.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e));
    }, t.prototype._populateBatches = function() {
      var e = this._geometry, r = this.blendMode, D = e.batches.length;
      this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = D, this.vertexData = new Float32Array(e.points);
      for (var N = 0; N < D; N++) {
        var k = e.batches[N], $ = k.style.color, G = new Float32Array(this.vertexData.buffer, k.attribStart * 4 * 2, k.attribSize * 2), U = new Float32Array(e.uvsFloat32.buffer, k.attribStart * 4 * 2, k.attribSize * 2), z = new Uint16Array(e.indicesUint16.buffer, k.start * 2, k.size), X = {
          vertexData: G,
          blendMode: r,
          indices: z,
          uvs: U,
          _batchRGB: hex2rgb($),
          _tintRGB: $,
          _texture: k.style.texture,
          alpha: k.style.alpha,
          worldAlpha: 1
        };
        this.batches[N] = X;
      }
    }, t.prototype._renderBatched = function(e) {
      if (this.batches.length) {
        e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
        for (var r = 0, D = this.batches.length; r < D; r++) {
          var N = this.batches[r];
          N.worldAlpha = this.worldAlpha * N.alpha, e.plugins[this.pluginName].render(N);
        }
      }
    }, t.prototype._renderDirect = function(e) {
      var r = this._resolveDirectShader(e), D = this._geometry, N = this.tint, k = this.worldAlpha, $ = r.uniforms, G = D.drawCalls;
      $.translationMatrix = this.transform.worldTransform, $.tint[0] = (N >> 16 & 255) / 255 * k, $.tint[1] = (N >> 8 & 255) / 255 * k, $.tint[2] = (N & 255) / 255 * k, $.tint[3] = k, e.shader.bind(r), e.geometry.bind(D, r), e.state.set(this.state);
      for (var U = 0, z = G.length; U < z; U++)
        this._renderDrawCallDirect(e, D.drawCalls[U]);
    }, t.prototype._renderDrawCallDirect = function(e, r) {
      for (var D = r.texArray, N = r.type, k = r.size, $ = r.start, G = D.count, U = 0; U < G; U++)
        e.texture.bind(D.elements[U], U);
      e.geometry.draw(N, k, $);
    }, t.prototype._resolveDirectShader = function(e) {
      var r = this.shader, D = this.pluginName;
      if (!r) {
        if (!DEFAULT_SHADERS[D]) {
          for (var N = e.plugins[D].MAX_TEXTURES, k = new Int32Array(N), $ = 0; $ < N; $++)
            k[$] = $;
          var G = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Matrix(),
            default: UniformGroup.from({ uSamplers: k }, !0)
          }, U = e.plugins[D]._shader.program;
          DEFAULT_SHADERS[D] = new Shader(U, G);
        }
        r = DEFAULT_SHADERS[D];
      }
      return r;
    }, t.prototype._calculateBounds = function() {
      this.finishPoly();
      var e = this._geometry;
      if (e.graphicsData.length) {
        var r = e.bounds, D = r.minX, N = r.minY, k = r.maxX, $ = r.maxY;
        this._bounds.addFrame(this.transform, D, N, k, $);
      }
    }, t.prototype.containsPoint = function(e) {
      return this.worldTransform.applyInverse(e, t._TEMP_POINT), this._geometry.containsPoint(t._TEMP_POINT);
    }, t.prototype.calculateTints = function() {
      if (this.batchTint !== this.tint) {
        this.batchTint = this.tint;
        for (var e = hex2rgb(this.tint, temp), r = 0; r < this.batches.length; r++) {
          var D = this.batches[r], N = D._batchRGB, k = e[0] * N[0] * 255, $ = e[1] * N[1] * 255, G = e[2] * N[2] * 255, U = (k << 16) + ($ << 8) + (G | 0);
          D._tintRGB = (U >> 16) + (U & 65280) + ((U & 255) << 16);
        }
      }
    }, t.prototype.calculateVertices = function() {
      var e = this.transform._worldID;
      if (this._transformID !== e) {
        this._transformID = e;
        for (var r = this.transform.worldTransform, D = r.a, N = r.b, k = r.c, $ = r.d, G = r.tx, U = r.ty, z = this._geometry.points, X = this.vertexData, V = 0, Y = 0; Y < z.length; Y += 2) {
          var W = z[Y], q = z[Y + 1];
          X[V++] = D * W + k * q + G, X[V++] = $ * q + N * W + U;
        }
      }
    }, t.prototype.closePath = function() {
      var e = this.currentPath;
      return e && (e.closeStroke = !0, this.finishPoly()), this;
    }, t.prototype.setMatrix = function(e) {
      return this._matrix = e, this;
    }, t.prototype.beginHole = function() {
      return this.finishPoly(), this._holeMode = !0, this;
    }, t.prototype.endHole = function() {
      return this.finishPoly(), this._holeMode = !1, this;
    }, t.prototype.destroy = function(e) {
      this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, o.prototype.destroy.call(this, e);
    }, t.nextRoundedRectBehavior = !1, t._TEMP_POINT = new Point(), t;
  }(Container)
);
/*!
 * @pixi/sprite - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/sprite is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$j = function(o, t) {
  return extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$j(o, t);
};
function __extends$j(o, t) {
  extendStatics$j(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var tempPoint$2 = new Point(), indices = new Uint16Array([0, 1, 2, 0, 2, 3]), Sprite = (
  /** @class */
  function(o) {
    __extends$j(t, o);
    function t(e) {
      var r = o.call(this) || this;
      return r._anchor = new ObservablePoint(r._onAnchorUpdate, r, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), r._texture = null, r._width = 0, r._height = 0, r._tint = null, r._tintRGB = null, r.tint = 16777215, r.blendMode = BLEND_MODES.NORMAL, r._cachedTint = 16777215, r.uvs = null, r.texture = e || Texture.EMPTY, r.vertexData = new Float32Array(8), r.vertexTrimmedData = null, r._transformID = -1, r._textureID = -1, r._transformTrimmedID = -1, r._textureTrimmedID = -1, r.indices = indices, r.pluginName = "batch", r.isSprite = !0, r._roundPixels = settings.ROUND_PIXELS, r;
    }
    return t.prototype._onTextureUpdate = function() {
      this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height);
    }, t.prototype._onAnchorUpdate = function() {
      this._transformID = -1, this._transformTrimmedID = -1;
    }, t.prototype.calculateVertices = function() {
      var e = this._texture;
      if (!(this._transformID === this.transform._worldID && this._textureID === e._updateID)) {
        this._textureID !== e._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = e._updateID;
        var r = this.transform.worldTransform, D = r.a, N = r.b, k = r.c, $ = r.d, G = r.tx, U = r.ty, z = this.vertexData, X = e.trim, V = e.orig, Y = this._anchor, W = 0, q = 0, K = 0, Z = 0;
        if (X ? (q = X.x - Y._x * V.width, W = q + X.width, Z = X.y - Y._y * V.height, K = Z + X.height) : (q = -Y._x * V.width, W = q + V.width, Z = -Y._y * V.height, K = Z + V.height), z[0] = D * q + k * Z + G, z[1] = $ * Z + N * q + U, z[2] = D * W + k * Z + G, z[3] = $ * Z + N * W + U, z[4] = D * W + k * K + G, z[5] = $ * K + N * W + U, z[6] = D * q + k * K + G, z[7] = $ * K + N * q + U, this._roundPixels)
          for (var J = settings.RESOLUTION, Q = 0; Q < z.length; ++Q)
            z[Q] = Math.round((z[Q] * J | 0) / J);
      }
    }, t.prototype.calculateTrimmedVertices = function() {
      if (!this.vertexTrimmedData)
        this.vertexTrimmedData = new Float32Array(8);
      else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
        return;
      this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
      var e = this._texture, r = this.vertexTrimmedData, D = e.orig, N = this._anchor, k = this.transform.worldTransform, $ = k.a, G = k.b, U = k.c, z = k.d, X = k.tx, V = k.ty, Y = -N._x * D.width, W = Y + D.width, q = -N._y * D.height, K = q + D.height;
      r[0] = $ * Y + U * q + X, r[1] = z * q + G * Y + V, r[2] = $ * W + U * q + X, r[3] = z * q + G * W + V, r[4] = $ * W + U * K + X, r[5] = z * K + G * W + V, r[6] = $ * Y + U * K + X, r[7] = z * K + G * Y + V;
    }, t.prototype._render = function(e) {
      this.calculateVertices(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this);
    }, t.prototype._calculateBounds = function() {
      var e = this._texture.trim, r = this._texture.orig;
      !e || e.width === r.width && e.height === r.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
    }, t.prototype.getLocalBounds = function(e) {
      return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Bounds()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds.getRectangle(e)) : o.prototype.getLocalBounds.call(this, e);
    }, t.prototype.containsPoint = function(e) {
      this.worldTransform.applyInverse(e, tempPoint$2);
      var r = this._texture.orig.width, D = this._texture.orig.height, N = -r * this.anchor.x, k = 0;
      return tempPoint$2.x >= N && tempPoint$2.x < N + r && (k = -D * this.anchor.y, tempPoint$2.y >= k && tempPoint$2.y < k + D);
    }, t.prototype.destroy = function(e) {
      o.prototype.destroy.call(this, e), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null;
      var r = typeof e == "boolean" ? e : e && e.texture;
      if (r) {
        var D = typeof e == "boolean" ? e : e && e.baseTexture;
        this._texture.destroy(!!D);
      }
      this._texture = null;
    }, t.from = function(e, r) {
      var D = e instanceof Texture ? e : Texture.from(e, r);
      return new t(D);
    }, Object.defineProperty(t.prototype, "roundPixels", {
      get: function() {
        return this._roundPixels;
      },
      /**
       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
       *
       * Advantages can include sharper image quality (like text) and faster rendering on canvas.
       * The main disadvantage is movement of objects may appear less smooth.
       *
       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.
       * @default false
       */
      set: function(e) {
        this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "width", {
      /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
      },
      set: function(e) {
        var r = sign(this.scale.x) || 1;
        this.scale.x = r * e / this._texture.orig.width, this._width = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
      },
      set: function(e) {
        var r = sign(this.scale.y) || 1;
        this.scale.y = r * e / this._texture.orig.height, this._height = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "anchor", {
      /**
       * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}
       * and passed to the constructor.
       *
       * The default is `(0,0)`, this means the sprite's origin is the top left.
       *
       * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
       *
       * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
       *
       * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
       * @example
       * const sprite = new PIXI.Sprite(texture);
       * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
       */
      get: function() {
        return this._anchor;
      },
      set: function(e) {
        this._anchor.copyFrom(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      /**
       * The tint applied to the sprite. This is a hex value.
       *
       * A value of 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get: function() {
        return this._tint;
      },
      set: function(e) {
        this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "texture", {
      /** The texture that the sprite is using. */
      get: function() {
        return this._texture;
      },
      set: function(e) {
        this._texture !== e && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = e || Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, e && (e.baseTexture.valid ? this._onTextureUpdate() : e.once("update", this._onTextureUpdate, this)));
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Container)
);
/*!
 * @pixi/text - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/text is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$i = function(o, t) {
  return extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$i(o, t);
};
function __extends$i(o, t) {
  extendStatics$i(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var TEXT_GRADIENT;
(function(o) {
  o[o.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", o[o.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL";
})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));
var defaultStyle = {
  align: "left",
  breakWords: !1,
  dropShadow: !1,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: !1,
  whiteSpace: "pre",
  wordWrap: !1,
  wordWrapWidth: 100,
  leading: 0
}, genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
], TextStyle = (
  /** @class */
  function() {
    function o(t) {
      this.styleID = 0, this.reset(), deepCopyProperties(this, t, t);
    }
    return o.prototype.clone = function() {
      var t = {};
      return deepCopyProperties(t, this, defaultStyle), new o(t);
    }, o.prototype.reset = function() {
      deepCopyProperties(this, defaultStyle, defaultStyle);
    }, Object.defineProperty(o.prototype, "align", {
      /**
       * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
       *
       * @member {string}
       */
      get: function() {
        return this._align;
      },
      set: function(t) {
        this._align !== t && (this._align = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "breakWords", {
      /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
      get: function() {
        return this._breakWords;
      },
      set: function(t) {
        this._breakWords !== t && (this._breakWords = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "dropShadow", {
      /** Set a drop shadow for the text. */
      get: function() {
        return this._dropShadow;
      },
      set: function(t) {
        this._dropShadow !== t && (this._dropShadow = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "dropShadowAlpha", {
      /** Set alpha for the drop shadow. */
      get: function() {
        return this._dropShadowAlpha;
      },
      set: function(t) {
        this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "dropShadowAngle", {
      /** Set a angle of the drop shadow. */
      get: function() {
        return this._dropShadowAngle;
      },
      set: function(t) {
        this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "dropShadowBlur", {
      /** Set a shadow blur radius. */
      get: function() {
        return this._dropShadowBlur;
      },
      set: function(t) {
        this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "dropShadowColor", {
      /** A fill style to be used on the dropshadow e.g 'red', '#00FF00'. */
      get: function() {
        return this._dropShadowColor;
      },
      set: function(t) {
        var e = getColor(t);
        this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "dropShadowDistance", {
      /** Set a distance of the drop shadow. */
      get: function() {
        return this._dropShadowDistance;
      },
      set: function(t) {
        this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "fill", {
      /**
       * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
       *
       * Can be an array to create a gradient eg ['#000000','#FFFFFF']
       * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
       *
       * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
       */
      get: function() {
        return this._fill;
      },
      set: function(t) {
        var e = getColor(t);
        this._fill !== e && (this._fill = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "fillGradientType", {
      /**
       * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
       *
       * @see PIXI.TEXT_GRADIENT
       */
      get: function() {
        return this._fillGradientType;
      },
      set: function(t) {
        this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "fillGradientStops", {
      /**
       * If fill is an array of colours to create a gradient, this array can set the stop points
       * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
       */
      get: function() {
        return this._fillGradientStops;
      },
      set: function(t) {
        areArraysEqual(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "fontFamily", {
      /** The font family. */
      get: function() {
        return this._fontFamily;
      },
      set: function(t) {
        this.fontFamily !== t && (this._fontFamily = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "fontSize", {
      /**
       * The font size
       * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
       */
      get: function() {
        return this._fontSize;
      },
      set: function(t) {
        this._fontSize !== t && (this._fontSize = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "fontStyle", {
      /**
       * The font style
       * ('normal', 'italic' or 'oblique')
       *
       * @member {string}
       */
      get: function() {
        return this._fontStyle;
      },
      set: function(t) {
        this._fontStyle !== t && (this._fontStyle = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "fontVariant", {
      /**
       * The font variant
       * ('normal' or 'small-caps')
       *
       * @member {string}
       */
      get: function() {
        return this._fontVariant;
      },
      set: function(t) {
        this._fontVariant !== t && (this._fontVariant = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "fontWeight", {
      /**
       * The font weight
       * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
       *
       * @member {string}
       */
      get: function() {
        return this._fontWeight;
      },
      set: function(t) {
        this._fontWeight !== t && (this._fontWeight = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "letterSpacing", {
      /** The amount of spacing between letters, default is 0. */
      get: function() {
        return this._letterSpacing;
      },
      set: function(t) {
        this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "lineHeight", {
      /** The line height, a number that represents the vertical space that a letter uses. */
      get: function() {
        return this._lineHeight;
      },
      set: function(t) {
        this._lineHeight !== t && (this._lineHeight = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "leading", {
      /** The space between lines. */
      get: function() {
        return this._leading;
      },
      set: function(t) {
        this._leading !== t && (this._leading = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "lineJoin", {
      /**
       * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
       * Default is 'miter' (creates a sharp corner).
       *
       * @member {string}
       */
      get: function() {
        return this._lineJoin;
      },
      set: function(t) {
        this._lineJoin !== t && (this._lineJoin = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "miterLimit", {
      /**
       * The miter limit to use when using the 'miter' lineJoin mode.
       *
       * This can reduce or increase the spikiness of rendered text.
       */
      get: function() {
        return this._miterLimit;
      },
      set: function(t) {
        this._miterLimit !== t && (this._miterLimit = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "padding", {
      /**
       * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
       * by adding padding to all sides of the text.
       */
      get: function() {
        return this._padding;
      },
      set: function(t) {
        this._padding !== t && (this._padding = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "stroke", {
      /**
       * A canvas fillstyle that will be used on the text stroke
       * e.g 'blue', '#FCFF00'
       */
      get: function() {
        return this._stroke;
      },
      set: function(t) {
        var e = getColor(t);
        this._stroke !== e && (this._stroke = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "strokeThickness", {
      /**
       * A number that represents the thickness of the stroke.
       *
       * @default 0
       */
      get: function() {
        return this._strokeThickness;
      },
      set: function(t) {
        this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "textBaseline", {
      /**
       * The baseline of the text that is rendered.
       *
       * @member {string}
       */
      get: function() {
        return this._textBaseline;
      },
      set: function(t) {
        this._textBaseline !== t && (this._textBaseline = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "trim", {
      /** Trim transparent borders. */
      get: function() {
        return this._trim;
      },
      set: function(t) {
        this._trim !== t && (this._trim = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "whiteSpace", {
      /**
       * How newlines and spaces should be handled.
       * Default is 'pre' (preserve, preserve).
       *
       *  value       | New lines     |   Spaces
       *  ---         | ---           |   ---
       * 'normal'     | Collapse      |   Collapse
       * 'pre'        | Preserve      |   Preserve
       * 'pre-line'   | Preserve      |   Collapse
       *
       * @member {string}
       */
      get: function() {
        return this._whiteSpace;
      },
      set: function(t) {
        this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "wordWrap", {
      /** Indicates if word wrap should be used. */
      get: function() {
        return this._wordWrap;
      },
      set: function(t) {
        this._wordWrap !== t && (this._wordWrap = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "wordWrapWidth", {
      /** The width at which text will wrap, it needs wordWrap to be set to true. */
      get: function() {
        return this._wordWrapWidth;
      },
      set: function(t) {
        this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.toFontString = function() {
      var t = typeof this.fontSize == "number" ? this.fontSize + "px" : this.fontSize, e = this.fontFamily;
      Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
      for (var r = e.length - 1; r >= 0; r--) {
        var D = e[r].trim();
        !/([\"\'])[^\'\"]+\1/.test(D) && genericFontFamilies.indexOf(D) < 0 && (D = '"' + D + '"'), e[r] = D;
      }
      return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t + " " + e.join(",");
    }, o;
  }()
);
function getSingleColor(o) {
  return typeof o == "number" ? hex2string(o) : (typeof o == "string" && o.indexOf("0x") === 0 && (o = o.replace("0x", "#")), o);
}
function getColor(o) {
  if (Array.isArray(o)) {
    for (var t = 0; t < o.length; ++t)
      o[t] = getSingleColor(o[t]);
    return o;
  } else
    return getSingleColor(o);
}
function areArraysEqual(o, t) {
  if (!Array.isArray(o) || !Array.isArray(t) || o.length !== t.length)
    return !1;
  for (var e = 0; e < o.length; ++e)
    if (o[e] !== t[e])
      return !1;
  return !0;
}
function deepCopyProperties(o, t, e) {
  for (var r in e)
    Array.isArray(t[r]) ? o[r] = t[r].slice() : o[r] = t[r];
}
var contextSettings = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: !0
}, TextMetrics = (
  /** @class */
  function() {
    function o(t, e, r, D, N, k, $, G, U) {
      this.text = t, this.style = e, this.width = r, this.height = D, this.lines = N, this.lineWidths = k, this.lineHeight = $, this.maxLineWidth = G, this.fontProperties = U;
    }
    return o.measureText = function(t, e, r, D) {
      D === void 0 && (D = o._canvas), r = r ?? e.wordWrap;
      var N = e.toFontString(), k = o.measureFont(N);
      k.fontSize === 0 && (k.fontSize = e.fontSize, k.ascent = e.fontSize);
      var $ = D.getContext("2d", contextSettings);
      $.font = N;
      for (var G = r ? o.wordWrap(t, e, D) : t, U = G.split(/(?:\r\n|\r|\n)/), z = new Array(U.length), X = 0, V = 0; V < U.length; V++) {
        var Y = $.measureText(U[V]).width + (U[V].length - 1) * e.letterSpacing;
        z[V] = Y, X = Math.max(X, Y);
      }
      var W = X + e.strokeThickness;
      e.dropShadow && (W += e.dropShadowDistance);
      var q = e.lineHeight || k.fontSize + e.strokeThickness, K = Math.max(q, k.fontSize + e.strokeThickness) + (U.length - 1) * (q + e.leading);
      return e.dropShadow && (K += e.dropShadowDistance), new o(t, e, W, K, U, z, q + e.leading, X, k);
    }, o.wordWrap = function(t, e, r) {
      r === void 0 && (r = o._canvas);
      for (var D = r.getContext("2d", contextSettings), N = 0, k = "", $ = "", G = /* @__PURE__ */ Object.create(null), U = e.letterSpacing, z = e.whiteSpace, X = o.collapseSpaces(z), V = o.collapseNewlines(z), Y = !X, W = e.wordWrapWidth + U, q = o.tokenize(t), K = 0; K < q.length; K++) {
        var Z = q[K];
        if (o.isNewline(Z)) {
          if (!V) {
            $ += o.addLine(k), Y = !X, k = "", N = 0;
            continue;
          }
          Z = " ";
        }
        if (X) {
          var J = o.isBreakingSpace(Z), Q = o.isBreakingSpace(k[k.length - 1]);
          if (J && Q)
            continue;
        }
        var et = o.getFromCache(Z, U, G, D);
        if (et > W)
          if (k !== "" && ($ += o.addLine(k), k = "", N = 0), o.canBreakWords(Z, e.breakWords))
            for (var it = o.wordWrapSplit(Z), tt = 0; tt < it.length; tt++) {
              for (var nt = it[tt], st = 1; it[tt + st]; ) {
                var at = it[tt + st], ut = nt[nt.length - 1];
                if (!o.canBreakChars(ut, at, Z, tt, e.breakWords))
                  nt += at;
                else
                  break;
                st++;
              }
              tt += nt.length - 1;
              var ht = o.getFromCache(nt, U, G, D);
              ht + N > W && ($ += o.addLine(k), Y = !1, k = "", N = 0), k += nt, N += ht;
            }
          else {
            k.length > 0 && ($ += o.addLine(k), k = "", N = 0);
            var dt = K === q.length - 1;
            $ += o.addLine(Z, !dt), Y = !1, k = "", N = 0;
          }
        else
          et + N > W && (Y = !1, $ += o.addLine(k), k = "", N = 0), (k.length > 0 || !o.isBreakingSpace(Z) || Y) && (k += Z, N += et);
      }
      return $ += o.addLine(k, !1), $;
    }, o.addLine = function(t, e) {
      return e === void 0 && (e = !0), t = o.trimRight(t), t = e ? t + `
` : t, t;
    }, o.getFromCache = function(t, e, r, D) {
      var N = r[t];
      if (typeof N != "number") {
        var k = t.length * e;
        N = D.measureText(t).width + k, r[t] = N;
      }
      return N;
    }, o.collapseSpaces = function(t) {
      return t === "normal" || t === "pre-line";
    }, o.collapseNewlines = function(t) {
      return t === "normal";
    }, o.trimRight = function(t) {
      if (typeof t != "string")
        return "";
      for (var e = t.length - 1; e >= 0; e--) {
        var r = t[e];
        if (!o.isBreakingSpace(r))
          break;
        t = t.slice(0, -1);
      }
      return t;
    }, o.isNewline = function(t) {
      return typeof t != "string" ? !1 : o._newlines.indexOf(t.charCodeAt(0)) >= 0;
    }, o.isBreakingSpace = function(t, e) {
      return typeof t != "string" ? !1 : o._breakingSpaces.indexOf(t.charCodeAt(0)) >= 0;
    }, o.tokenize = function(t) {
      var e = [], r = "";
      if (typeof t != "string")
        return e;
      for (var D = 0; D < t.length; D++) {
        var N = t[D], k = t[D + 1];
        if (o.isBreakingSpace(N, k) || o.isNewline(N)) {
          r !== "" && (e.push(r), r = ""), e.push(N);
          continue;
        }
        r += N;
      }
      return r !== "" && e.push(r), e;
    }, o.canBreakWords = function(t, e) {
      return e;
    }, o.canBreakChars = function(t, e, r, D, N) {
      return !0;
    }, o.wordWrapSplit = function(t) {
      return t.split("");
    }, o.measureFont = function(t) {
      if (o._fonts[t])
        return o._fonts[t];
      var e = {
        ascent: 0,
        descent: 0,
        fontSize: 0
      }, r = o._canvas, D = o._context;
      D.font = t;
      var N = o.METRICS_STRING + o.BASELINE_SYMBOL, k = Math.ceil(D.measureText(N).width), $ = Math.ceil(D.measureText(o.BASELINE_SYMBOL).width), G = Math.ceil(o.HEIGHT_MULTIPLIER * $);
      $ = $ * o.BASELINE_MULTIPLIER | 0, r.width = k, r.height = G, D.fillStyle = "#f00", D.fillRect(0, 0, k, G), D.font = t, D.textBaseline = "alphabetic", D.fillStyle = "#000", D.fillText(N, 0, $);
      var U = D.getImageData(0, 0, k, G).data, z = U.length, X = k * 4, V = 0, Y = 0, W = !1;
      for (V = 0; V < $; ++V) {
        for (var q = 0; q < X; q += 4)
          if (U[Y + q] !== 255) {
            W = !0;
            break;
          }
        if (!W)
          Y += X;
        else
          break;
      }
      for (e.ascent = $ - V, Y = z - X, W = !1, V = G; V > $; --V) {
        for (var q = 0; q < X; q += 4)
          if (U[Y + q] !== 255) {
            W = !0;
            break;
          }
        if (!W)
          Y -= X;
        else
          break;
      }
      return e.descent = V - $, e.fontSize = e.ascent + e.descent, o._fonts[t] = e, e;
    }, o.clearMetrics = function(t) {
      t === void 0 && (t = ""), t ? delete o._fonts[t] : o._fonts = {};
    }, Object.defineProperty(o, "_canvas", {
      /**
       * Cached canvas element for measuring text
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      get: function() {
        if (!o.__canvas) {
          var t = void 0;
          try {
            var e = new OffscreenCanvas(0, 0), r = e.getContext("2d", contextSettings);
            if (r && r.measureText)
              return o.__canvas = e, e;
            t = settings.ADAPTER.createCanvas();
          } catch {
            t = settings.ADAPTER.createCanvas();
          }
          t.width = t.height = 10, o.__canvas = t;
        }
        return o.__canvas;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o, "_context", {
      /**
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      get: function() {
        return o.__context || (o.__context = o._canvas.getContext("2d", contextSettings)), o.__context;
      },
      enumerable: !1,
      configurable: !0
    }), o;
  }()
);
TextMetrics._fonts = {};
TextMetrics.METRICS_STRING = "|ÉqÅ";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
var defaultDestroyOptions = {
  texture: !0,
  children: !1,
  baseTexture: !0
}, Text = (
  /** @class */
  function(o) {
    __extends$i(t, o);
    function t(e, r, D) {
      var N = this, k = !1;
      D || (D = settings.ADAPTER.createCanvas(), k = !0), D.width = 3, D.height = 3;
      var $ = Texture.from(D);
      return $.orig = new Rectangle(), $.trim = new Rectangle(), N = o.call(this, $) || this, N._ownCanvas = k, N.canvas = D, N.context = D.getContext("2d", {
        // required for trimming to work without warnings
        willReadFrequently: !0
      }), N._resolution = settings.RESOLUTION, N._autoResolution = !0, N._text = null, N._style = null, N._styleListener = null, N._font = "", N.text = e, N.style = r, N.localStyleID = -1, N;
    }
    return t.prototype.updateText = function(e) {
      var r = this._style;
      if (this.localStyleID !== r.styleID && (this.dirty = !0, this.localStyleID = r.styleID), !(!this.dirty && e)) {
        this._font = this._style.toFontString();
        var D = this.context, N = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), k = N.width, $ = N.height, G = N.lines, U = N.lineHeight, z = N.lineWidths, X = N.maxLineWidth, V = N.fontProperties;
        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, k) + r.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, $) + r.padding * 2) * this._resolution), D.scale(this._resolution, this._resolution), D.clearRect(0, 0, this.canvas.width, this.canvas.height), D.font = this._font, D.lineWidth = r.strokeThickness, D.textBaseline = r.textBaseline, D.lineJoin = r.lineJoin, D.miterLimit = r.miterLimit;
        for (var Y, W, q = r.dropShadow ? 2 : 1, K = 0; K < q; ++K) {
          var Z = r.dropShadow && K === 0, J = Z ? Math.ceil(Math.max(1, $) + r.padding * 2) : 0, Q = J * this._resolution;
          if (Z) {
            D.fillStyle = "black", D.strokeStyle = "black";
            var et = r.dropShadowColor, it = hex2rgb(typeof et == "number" ? et : string2hex(et)), tt = r.dropShadowBlur * this._resolution, nt = r.dropShadowDistance * this._resolution;
            D.shadowColor = "rgba(" + it[0] * 255 + "," + it[1] * 255 + "," + it[2] * 255 + "," + r.dropShadowAlpha + ")", D.shadowBlur = tt, D.shadowOffsetX = Math.cos(r.dropShadowAngle) * nt, D.shadowOffsetY = Math.sin(r.dropShadowAngle) * nt + Q;
          } else
            D.fillStyle = this._generateFillStyle(r, G, N), D.strokeStyle = r.stroke, D.shadowColor = "black", D.shadowBlur = 0, D.shadowOffsetX = 0, D.shadowOffsetY = 0;
          var st = (U - V.fontSize) / 2;
          (!t.nextLineHeightBehavior || U - V.fontSize < 0) && (st = 0);
          for (var at = 0; at < G.length; at++)
            Y = r.strokeThickness / 2, W = r.strokeThickness / 2 + at * U + V.ascent + st, r.align === "right" ? Y += X - z[at] : r.align === "center" && (Y += (X - z[at]) / 2), r.stroke && r.strokeThickness && this.drawLetterSpacing(G[at], Y + r.padding, W + r.padding - J, !0), r.fill && this.drawLetterSpacing(G[at], Y + r.padding, W + r.padding - J);
        }
        this.updateTexture();
      }
    }, t.prototype.drawLetterSpacing = function(e, r, D, N) {
      N === void 0 && (N = !1);
      var k = this._style, $ = k.letterSpacing, G = t.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
      if ($ === 0 || G) {
        G && (this.context.letterSpacing = $, this.context.textLetterSpacing = $), N ? this.context.strokeText(e, r, D) : this.context.fillText(e, r, D);
        return;
      }
      for (var U = r, z = Array.from ? Array.from(e) : e.split(""), X = this.context.measureText(e).width, V = 0, Y = 0; Y < z.length; ++Y) {
        var W = z[Y];
        N ? this.context.strokeText(W, U, D) : this.context.fillText(W, U, D);
        for (var q = "", K = Y + 1; K < z.length; ++K)
          q += z[K];
        V = this.context.measureText(q).width, U += X - V + $, X = V;
      }
    }, t.prototype.updateTexture = function() {
      var e = this.canvas;
      if (this._style.trim) {
        var r = trimCanvas(e);
        r.data && (e.width = r.width, e.height = r.height, this.context.putImageData(r.data, 0, 0));
      }
      var D = this._texture, N = this._style, k = N.trim ? 0 : N.padding, $ = D.baseTexture;
      D.trim.width = D._frame.width = e.width / this._resolution, D.trim.height = D._frame.height = e.height / this._resolution, D.trim.x = -k, D.trim.y = -k, D.orig.width = D._frame.width - k * 2, D.orig.height = D._frame.height - k * 2, this._onTextureUpdate(), $.setRealSize(e.width, e.height, this._resolution), D.updateUvs(), this.dirty = !1;
    }, t.prototype._render = function(e) {
      this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), o.prototype._render.call(this, e);
    }, t.prototype.updateTransform = function() {
      this.updateText(!0), o.prototype.updateTransform.call(this);
    }, t.prototype.getBounds = function(e, r) {
      return this.updateText(!0), this._textureID === -1 && (e = !1), o.prototype.getBounds.call(this, e, r);
    }, t.prototype.getLocalBounds = function(e) {
      return this.updateText(!0), o.prototype.getLocalBounds.call(this, e);
    }, t.prototype._calculateBounds = function() {
      this.calculateVertices(), this._bounds.addQuad(this.vertexData);
    }, t.prototype._generateFillStyle = function(e, r, D) {
      var N = e.fill;
      if (Array.isArray(N)) {
        if (N.length === 1)
          return N[0];
      } else
        return N;
      var k, $ = e.dropShadow ? e.dropShadowDistance : 0, G = e.padding || 0, U = this.canvas.width / this._resolution - $ - G * 2, z = this.canvas.height / this._resolution - $ - G * 2, X = N.slice(), V = e.fillGradientStops.slice();
      if (!V.length)
        for (var Y = X.length + 1, W = 1; W < Y; ++W)
          V.push(W / Y);
      if (X.unshift(N[0]), V.unshift(0), X.push(N[N.length - 1]), V.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
        k = this.context.createLinearGradient(U / 2, G, U / 2, z + G);
        for (var q = D.fontProperties.fontSize + e.strokeThickness, W = 0; W < r.length; W++) {
          var K = D.lineHeight * (W - 1) + q, Z = D.lineHeight * W, J = Z;
          W > 0 && K > Z && (J = (Z + K) / 2);
          var Q = Z + q, et = D.lineHeight * (W + 1), it = Q;
          W + 1 < r.length && et < Q && (it = (Q + et) / 2);
          for (var tt = (it - J) / z, nt = 0; nt < X.length; nt++) {
            var st = 0;
            typeof V[nt] == "number" ? st = V[nt] : st = nt / X.length;
            var at = Math.min(1, Math.max(0, J / z + st * tt));
            at = Number(at.toFixed(5)), k.addColorStop(at, X[nt]);
          }
        }
      } else {
        k = this.context.createLinearGradient(G, z / 2, U + G, z / 2);
        for (var ut = X.length + 1, ht = 1, W = 0; W < X.length; W++) {
          var dt = void 0;
          typeof V[W] == "number" ? dt = V[W] : dt = ht / ut, k.addColorStop(dt, X[W]), ht++;
        }
      }
      return k;
    }, t.prototype.destroy = function(e) {
      typeof e == "boolean" && (e = { children: e }), e = Object.assign({}, defaultDestroyOptions, e), o.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;
    }, Object.defineProperty(t.prototype, "width", {
      /** The width of the Text, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;
      },
      set: function(e) {
        this.updateText(!0);
        var r = sign(this.scale.x) || 1;
        this.scale.x = r * e / this._texture.orig.width, this._width = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "height", {
      /** The height of the Text, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;
      },
      set: function(e) {
        this.updateText(!0);
        var r = sign(this.scale.y) || 1;
        this.scale.y = r * e / this._texture.orig.height, this._height = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "style", {
      /**
       * Set the style of the text.
       *
       * Set up an event listener to listen for changes on the style object and mark the text as dirty.
       */
      get: function() {
        return this._style;
      },
      set: function(e) {
        e = e || {}, e instanceof TextStyle ? this._style = e : this._style = new TextStyle(e), this.localStyleID = -1, this.dirty = !0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "text", {
      /** Set the copy for the text object. To split a line you can use '\n'. */
      get: function() {
        return this._text;
      },
      set: function(e) {
        e = String(e ?? ""), this._text !== e && (this._text = e, this.dirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "resolution", {
      /**
       * The resolution / device pixel ratio of the canvas.
       *
       * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
       * @default 1
       */
      get: function() {
        return this._resolution;
      },
      set: function(e) {
        this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), t.nextLineHeightBehavior = !1, t.experimentalLetterSpacing = !1, t;
  }(Sprite)
);
/*!
 * @pixi/prepare - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/prepare is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.UPLOADS_PER_FRAME = 4;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$h = function(o, t) {
  return extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$h(o, t);
};
function __extends$h(o, t) {
  extendStatics$h(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var CountLimiter = (
  /** @class */
  function() {
    function o(t) {
      this.maxItemsPerFrame = t, this.itemsLeft = 0;
    }
    return o.prototype.beginFrame = function() {
      this.itemsLeft = this.maxItemsPerFrame;
    }, o.prototype.allowedToUpload = function() {
      return this.itemsLeft-- > 0;
    }, o;
  }()
);
function findMultipleBaseTextures(o, t) {
  var e = !1;
  if (o && o._textures && o._textures.length) {
    for (var r = 0; r < o._textures.length; r++)
      if (o._textures[r] instanceof Texture) {
        var D = o._textures[r].baseTexture;
        t.indexOf(D) === -1 && (t.push(D), e = !0);
      }
  }
  return e;
}
function findBaseTexture(o, t) {
  if (o.baseTexture instanceof BaseTexture) {
    var e = o.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function findTexture(o, t) {
  if (o._texture && o._texture instanceof Texture) {
    var e = o._texture.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function drawText(o, t) {
  return t instanceof Text ? (t.updateText(!0), !0) : !1;
}
function calculateTextStyle(o, t) {
  if (t instanceof TextStyle) {
    var e = t.toFontString();
    return TextMetrics.measureFont(e), !0;
  }
  return !1;
}
function findText(o, t) {
  if (o instanceof Text) {
    t.indexOf(o.style) === -1 && t.push(o.style), t.indexOf(o) === -1 && t.push(o);
    var e = o._texture.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function findTextStyle(o, t) {
  return o instanceof TextStyle ? (t.indexOf(o) === -1 && t.push(o), !0) : !1;
}
var BasePrepare = (
  /** @class */
  function() {
    function o(t) {
      var e = this;
      this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function() {
        e.queue && e.prepareItems();
      }, this.registerFindHook(findText), this.registerFindHook(findTextStyle), this.registerFindHook(findMultipleBaseTextures), this.registerFindHook(findBaseTexture), this.registerFindHook(findTexture), this.registerUploadHook(drawText), this.registerUploadHook(calculateTextStyle);
    }
    return o.prototype.upload = function(t, e) {
      var r = this;
      return typeof t == "function" && (e = t, t = null), e && deprecation("6.5.0", "BasePrepare.upload callback is deprecated, use the return Promise instead."), new Promise(function(D) {
        t && r.add(t);
        var N = function() {
          e == null || e(), D();
        };
        r.queue.length ? (r.completes.push(N), r.ticking || (r.ticking = !0, Ticker.system.addOnce(r.tick, r, UPDATE_PRIORITY.UTILITY))) : N();
      });
    }, o.prototype.tick = function() {
      setTimeout(this.delayedTick, 0);
    }, o.prototype.prepareItems = function() {
      for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
        var t = this.queue[0], e = !1;
        if (t && !t._destroyed) {
          for (var r = 0, D = this.uploadHooks.length; r < D; r++)
            if (this.uploadHooks[r](this.uploadHookHelper, t)) {
              this.queue.shift(), e = !0;
              break;
            }
        }
        e || this.queue.shift();
      }
      if (this.queue.length)
        Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
      else {
        this.ticking = !1;
        var N = this.completes.slice(0);
        this.completes.length = 0;
        for (var r = 0, D = N.length; r < D; r++)
          N[r]();
      }
    }, o.prototype.registerFindHook = function(t) {
      return t && this.addHooks.push(t), this;
    }, o.prototype.registerUploadHook = function(t) {
      return t && this.uploadHooks.push(t), this;
    }, o.prototype.add = function(t) {
      for (var e = 0, r = this.addHooks.length; e < r && !this.addHooks[e](t, this.queue); e++)
        ;
      if (t instanceof Container)
        for (var e = t.children.length - 1; e >= 0; e--)
          this.add(t.children[e]);
      return this;
    }, o.prototype.destroy = function() {
      this.ticking && Ticker.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;
    }, o;
  }()
);
function uploadBaseTextures(o, t) {
  return t instanceof BaseTexture ? (t._glTextures[o.CONTEXT_UID] || o.texture.bind(t), !0) : !1;
}
function uploadGraphics(o, t) {
  if (!(t instanceof Graphics))
    return !1;
  var e = t.geometry;
  t.finishPoly(), e.updateBatches();
  for (var r = e.batches, D = 0; D < r.length; D++) {
    var N = r[D].style.texture;
    N && uploadBaseTextures(o, N.baseTexture);
  }
  return e.batchable || o.geometry.bind(e, t._resolveDirectShader(o)), !0;
}
function findGraphics(o, t) {
  return o instanceof Graphics ? (t.push(o), !0) : !1;
}
var Prepare = (
  /** @class */
  function(o) {
    __extends$h(t, o);
    function t(e) {
      var r = o.call(this, e) || this;
      return r.uploadHookHelper = r.renderer, r.registerFindHook(findGraphics), r.registerUploadHook(uploadBaseTextures), r.registerUploadHook(uploadGraphics), r;
    }
    return t.extension = {
      name: "prepare",
      type: ExtensionType.RendererPlugin
    }, t;
  }(BasePrepare)
);
/*!
 * @pixi/spritesheet - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/spritesheet is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Spritesheet = (
  /** @class */
  function() {
    function o(t, e, r) {
      r === void 0 && (r = null), this.linkedSheets = [], this._texture = t instanceof Texture ? t : null, this.baseTexture = t instanceof BaseTexture ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;
      var D = this.baseTexture.resource;
      this.resolution = this._updateResolution(r || (D ? D.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
    }
    return o.prototype._updateResolution = function(t) {
      t === void 0 && (t = null);
      var e = this.data.meta.scale, r = getResolutionOfUrl(t, null);
      return r === null && (r = e !== void 0 ? parseFloat(e) : 1), r !== 1 && this.baseTexture.setResolution(r), r;
    }, o.prototype.parse = function(t) {
      var e = this;
      return t && deprecation("6.5.0", "Spritesheet.parse callback is deprecated, use the return Promise instead."), new Promise(function(r) {
        e._callback = function(D) {
          t == null || t(D), r(D);
        }, e._batchIndex = 0, e._frameKeys.length <= o.BATCH_SIZE ? (e._processFrames(0), e._processAnimations(), e._parseComplete()) : e._nextBatch();
      });
    }, o.prototype._processFrames = function(t) {
      for (var e = t, r = o.BATCH_SIZE; e - t < r && e < this._frameKeys.length; ) {
        var D = this._frameKeys[e], N = this._frames[D], k = N.frame;
        if (k) {
          var $ = null, G = null, U = N.trimmed !== !1 && N.sourceSize ? N.sourceSize : N.frame, z = new Rectangle(0, 0, Math.floor(U.w) / this.resolution, Math.floor(U.h) / this.resolution);
          N.rotated ? $ = new Rectangle(Math.floor(k.x) / this.resolution, Math.floor(k.y) / this.resolution, Math.floor(k.h) / this.resolution, Math.floor(k.w) / this.resolution) : $ = new Rectangle(Math.floor(k.x) / this.resolution, Math.floor(k.y) / this.resolution, Math.floor(k.w) / this.resolution, Math.floor(k.h) / this.resolution), N.trimmed !== !1 && N.spriteSourceSize && (G = new Rectangle(Math.floor(N.spriteSourceSize.x) / this.resolution, Math.floor(N.spriteSourceSize.y) / this.resolution, Math.floor(k.w) / this.resolution, Math.floor(k.h) / this.resolution)), this.textures[D] = new Texture(this.baseTexture, $, z, G, N.rotated ? 2 : 0, N.anchor), Texture.addToCache(this.textures[D], D);
        }
        e++;
      }
    }, o.prototype._processAnimations = function() {
      var t = this.data.animations || {};
      for (var e in t) {
        this.animations[e] = [];
        for (var r = 0; r < t[e].length; r++) {
          var D = t[e][r];
          this.animations[e].push(this.textures[D]);
        }
      }
    }, o.prototype._parseComplete = function() {
      var t = this._callback;
      this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
    }, o.prototype._nextBatch = function() {
      var t = this;
      this._processFrames(this._batchIndex * o.BATCH_SIZE), this._batchIndex++, setTimeout(function() {
        t._batchIndex * o.BATCH_SIZE < t._frameKeys.length ? t._nextBatch() : (t._processAnimations(), t._parseComplete());
      }, 0);
    }, o.prototype.destroy = function(t) {
      var e;
      t === void 0 && (t = !1);
      for (var r in this.textures)
        this.textures[r].destroy();
      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) === null || e === void 0 || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];
    }, o.BATCH_SIZE = 1e3, o;
  }()
), SpritesheetLoader = (
  /** @class */
  function() {
    function o() {
    }
    return o.use = function(t, e) {
      var r, D, N = this, k = t.name + "_image";
      if (!t.data || t.type !== LoaderResource.TYPE.JSON || !t.data.frames || N.resources[k]) {
        e();
        return;
      }
      var $ = (D = (r = t.data) === null || r === void 0 ? void 0 : r.meta) === null || D === void 0 ? void 0 : D.related_multi_packs;
      if (Array.isArray($))
        for (var G = function(W) {
          if (typeof W != "string")
            return "continue";
          var q = W.replace(".json", ""), K = url$1.resolve(t.url.replace(N.baseUrl, ""), W);
          if (N.resources[q] || Object.values(N.resources).some(function(J) {
            return url$1.format(url$1.parse(J.url)) === K;
          }))
            return "continue";
          var Z = {
            crossOrigin: t.crossOrigin,
            loadType: LoaderResource.LOAD_TYPE.XHR,
            xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,
            parentResource: t,
            metadata: t.metadata
          };
          N.add(q, K, Z);
        }, U = 0, z = $; U < z.length; U++) {
          var X = z[U];
          G(X);
        }
      var V = {
        crossOrigin: t.crossOrigin,
        metadata: t.metadata.imageMetadata,
        parentResource: t
      }, Y = o.getResourcePath(t, N.baseUrl);
      N.add(k, Y, V, function(q) {
        if (q.error) {
          e(q.error);
          return;
        }
        var K = new Spritesheet(q.texture, t.data, t.url);
        K.parse().then(function() {
          t.spritesheet = K, t.textures = K.textures, e();
        });
      });
    }, o.getResourcePath = function(t, e) {
      return t.isDataUrl ? t.data.meta.image : url$1.resolve(t.url.replace(e, ""), t.data.meta.image);
    }, o.extension = ExtensionType.Loader, o;
  }()
);
/*!
 * @pixi/sprite-tiling - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$g = function(o, t) {
  return extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$g(o, t);
};
function __extends$g(o, t) {
  extendStatics$g(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var tempPoint$1 = new Point();
(function(o) {
  __extends$g(t, o);
  function t(e, r, D) {
    r === void 0 && (r = 100), D === void 0 && (D = 100);
    var N = o.call(this, e) || this;
    return N.tileTransform = new Transform(), N._width = r, N._height = D, N.uvMatrix = N.texture.uvMatrix || new TextureMatrix(e), N.pluginName = "tilingSprite", N.uvRespectAnchor = !1, N;
  }
  return Object.defineProperty(t.prototype, "clampMargin", {
    /**
     * Changes frame clamping in corresponding textureTransform, shortcut
     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
     * @default 0.5
     * @member {number}
     */
    get: function() {
      return this.uvMatrix.clampMargin;
    },
    set: function(e) {
      this.uvMatrix.clampMargin = e, this.uvMatrix.update(!0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tileScale", {
    /** The scaling of the image that is being tiled. */
    get: function() {
      return this.tileTransform.scale;
    },
    set: function(e) {
      this.tileTransform.scale.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tilePosition", {
    /** The offset of the image that is being tiled. */
    get: function() {
      return this.tileTransform.position;
    },
    set: function(e) {
      this.tileTransform.position.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._onTextureUpdate = function() {
    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;
  }, t.prototype._render = function(e) {
    var r = this._texture;
    !r || !r.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this));
  }, t.prototype._calculateBounds = function() {
    var e = this._width * -this._anchor._x, r = this._height * -this._anchor._y, D = this._width * (1 - this._anchor._x), N = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, e, r, D, N);
  }, t.prototype.getLocalBounds = function(e) {
    return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._bounds.getRectangle(e)) : o.prototype.getLocalBounds.call(this, e);
  }, t.prototype.containsPoint = function(e) {
    this.worldTransform.applyInverse(e, tempPoint$1);
    var r = this._width, D = this._height, N = -r * this.anchor._x;
    if (tempPoint$1.x >= N && tempPoint$1.x < N + r) {
      var k = -D * this.anchor._y;
      if (tempPoint$1.y >= k && tempPoint$1.y < k + D)
        return !0;
    }
    return !1;
  }, t.prototype.destroy = function(e) {
    o.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null;
  }, t.from = function(e, r) {
    var D = e instanceof Texture ? e : Texture.from(e, r);
    return new t(D, r.width, r.height);
  }, Object.defineProperty(t.prototype, "width", {
    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this._width;
    },
    set: function(e) {
      this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this._height;
    },
    set: function(e) {
      this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Sprite);
var fragmentSimpleSrc = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`, gl1VertexSrc = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, gl1FragmentSrc = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`, gl2VertexSrc = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, gl2FragmentSrc = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`, tempMat = new Matrix(), TilingSpriteRenderer = (
  /** @class */
  function(o) {
    __extends$g(t, o);
    function t(e) {
      var r = o.call(this, e) || this;
      return e.runners.contextChange.add(r), r.quad = new QuadUv(), r.state = State.for2d(), r;
    }
    return t.prototype.contextChange = function() {
      var e = this.renderer, r = { globals: e.globalUniforms };
      this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, r), this.shader = e.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, r) : Shader.from(gl1VertexSrc, gl1FragmentSrc, r);
    }, t.prototype.render = function(e) {
      var r = this.renderer, D = this.quad, N = D.vertices;
      N[0] = N[6] = e._width * -e.anchor.x, N[1] = N[3] = e._height * -e.anchor.y, N[2] = N[4] = e._width * (1 - e.anchor.x), N[5] = N[7] = e._height * (1 - e.anchor.y);
      var k = e.uvRespectAnchor ? e.anchor.x : 0, $ = e.uvRespectAnchor ? e.anchor.y : 0;
      N = D.uvs, N[0] = N[6] = -k, N[1] = N[3] = -$, N[2] = N[4] = 1 - k, N[5] = N[7] = 1 - $, D.invalidate();
      var G = e._texture, U = G.baseTexture, z = U.alphaMode > 0, X = e.tileTransform.localTransform, V = e.uvMatrix, Y = U.isPowerOfTwo && G.frame.width === U.width && G.frame.height === U.height;
      Y && (U._glTextures[r.CONTEXT_UID] ? Y = U.wrapMode !== WRAP_MODES.CLAMP : U.wrapMode === WRAP_MODES.CLAMP && (U.wrapMode = WRAP_MODES.REPEAT));
      var W = Y ? this.simpleShader : this.shader, q = G.width, K = G.height, Z = e._width, J = e._height;
      tempMat.set(X.a * q / Z, X.b * q / J, X.c * K / Z, X.d * K / J, X.tx / Z, X.ty / J), tempMat.invert(), Y ? tempMat.prepend(V.mapCoord) : (W.uniforms.uMapCoord = V.mapCoord.toArray(!0), W.uniforms.uClampFrame = V.uClampFrame, W.uniforms.uClampOffset = V.uClampOffset), W.uniforms.uTransform = tempMat.toArray(!0), W.uniforms.uColor = premultiplyTintToRgba(e.tint, e.worldAlpha, W.uniforms.uColor, z), W.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0), W.uniforms.uSampler = G, r.shader.bind(W), r.geometry.bind(D), this.state.blendMode = correctBlendMode(e.blendMode, z), r.state.set(this.state), r.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    }, t.extension = {
      name: "tilingSprite",
      type: ExtensionType.RendererPlugin
    }, t;
  }(ObjectRenderer)
);
/*!
 * @pixi/mesh - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/mesh is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$f = function(o, t) {
  return extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$f(o, t);
};
function __extends$f(o, t) {
  extendStatics$f(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var MeshBatchUvs = (
  /** @class */
  function() {
    function o(t, e) {
      this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;
    }
    return o.prototype.update = function(t) {
      if (!(!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)) {
        this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
        var e = this.uvBuffer.data;
        (!this.data || this.data.length !== e.length) && (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++;
      }
    }, o;
  }()
), tempPoint = new Point(), tempPolygon = new Polygon(), Mesh = (
  /** @class */
  function(o) {
    __extends$f(t, o);
    function t(e, r, D, N) {
      N === void 0 && (N = DRAW_MODES.TRIANGLES);
      var k = o.call(this) || this;
      return k.geometry = e, k.shader = r, k.state = D || State.for2d(), k.drawMode = N, k.start = 0, k.size = 0, k.uvs = null, k.indices = null, k.vertexData = new Float32Array(1), k.vertexDirty = -1, k._transformID = -1, k._roundPixels = settings.ROUND_PIXELS, k.batchUvs = null, k;
    }
    return Object.defineProperty(t.prototype, "geometry", {
      /**
       * Includes vertex positions, face indices, normals, colors, UVs, and
       * custom attributes within buffers, reducing the cost of passing all
       * this data to the GPU. Can be shared between multiple Mesh objects.
       */
      get: function() {
        return this._geometry;
      },
      set: function(e) {
        this._geometry !== e && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "uvBuffer", {
      /**
       * To change mesh uv's, change its uvBuffer data and increment its _updateID.
       * @readonly
       */
      get: function() {
        return this.geometry.buffers[1];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "verticesBuffer", {
      /**
       * To change mesh vertices, change its uvBuffer data and increment its _updateID.
       * Incrementing _updateID is optional because most of Mesh objects do it anyway.
       * @readonly
       */
      get: function() {
        return this.geometry.buffers[0];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "material", {
      get: function() {
        return this.shader;
      },
      /** Alias for {@link PIXI.Mesh#shader}. */
      set: function(e) {
        this.shader = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "blendMode", {
      get: function() {
        return this.state.blendMode;
      },
      /**
       * The blend mode to be applied to the Mesh. Apply a value of
       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * @default PIXI.BLEND_MODES.NORMAL;
       */
      set: function(e) {
        this.state.blendMode = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "roundPixels", {
      get: function() {
        return this._roundPixels;
      },
      /**
       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
       * Advantages can include sharper image quality (like text) and faster rendering on canvas.
       * The main disadvantage is movement of objects may appear less smooth.
       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
       * @default false
       */
      set: function(e) {
        this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      /**
       * The multiply tint applied to the Mesh. This is a hex value. A value of
       * `0xFFFFFF` will remove any tint effect.
       *
       * Null for non-MeshMaterial shaders
       * @default 0xFFFFFF
       */
      get: function() {
        return "tint" in this.shader ? this.shader.tint : null;
      },
      set: function(e) {
        this.shader.tint = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "texture", {
      /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
      get: function() {
        return "texture" in this.shader ? this.shader.texture : null;
      },
      set: function(e) {
        this.shader.texture = e;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype._render = function(e) {
      var r = this.geometry.buffers[0].data, D = this.shader;
      D.batchable && this.drawMode === DRAW_MODES.TRIANGLES && r.length < t.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e);
    }, t.prototype._renderDefault = function(e) {
      var r = this.shader;
      r.alpha = this.worldAlpha, r.update && r.update(), e.batch.flush(), r.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(r), e.state.set(this.state), e.geometry.bind(this.geometry, r), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    }, t.prototype._renderToBatch = function(e) {
      var r = this.geometry, D = this.shader;
      D.uvMatrix && (D.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = r.indexBuffer.data, this._tintRGB = D._tintRGB, this._texture = D.texture;
      var N = this.material.pluginName;
      e.batch.setObjectRenderer(e.plugins[N]), e.plugins[N].render(this);
    }, t.prototype.calculateVertices = function() {
      var e = this.geometry, r = e.buffers[0], D = r.data, N = r._updateID;
      if (!(N === this.vertexDirty && this._transformID === this.transform._worldID)) {
        this._transformID = this.transform._worldID, this.vertexData.length !== D.length && (this.vertexData = new Float32Array(D.length));
        for (var k = this.transform.worldTransform, $ = k.a, G = k.b, U = k.c, z = k.d, X = k.tx, V = k.ty, Y = this.vertexData, W = 0; W < Y.length / 2; W++) {
          var q = D[W * 2], K = D[W * 2 + 1];
          Y[W * 2] = $ * q + U * K + X, Y[W * 2 + 1] = G * q + z * K + V;
        }
        if (this._roundPixels)
          for (var Z = settings.RESOLUTION, W = 0; W < Y.length; ++W)
            Y[W] = Math.round((Y[W] * Z | 0) / Z);
        this.vertexDirty = N;
      }
    }, t.prototype.calculateUvs = function() {
      var e = this.geometry.buffers[1], r = this.shader;
      r.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs(e, r.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);
    }, t.prototype._calculateBounds = function() {
      this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    }, t.prototype.containsPoint = function(e) {
      if (!this.getBounds().contains(e.x, e.y))
        return !1;
      this.worldTransform.applyInverse(e, tempPoint);
      for (var r = this.geometry.getBuffer("aVertexPosition").data, D = tempPolygon.points, N = this.geometry.getIndex().data, k = N.length, $ = this.drawMode === 4 ? 3 : 1, G = 0; G + 2 < k; G += $) {
        var U = N[G] * 2, z = N[G + 1] * 2, X = N[G + 2] * 2;
        if (D[0] = r[U], D[1] = r[U + 1], D[2] = r[z], D[3] = r[z + 1], D[4] = r[X], D[5] = r[X + 1], tempPolygon.contains(tempPoint.x, tempPoint.y))
          return !0;
      }
      return !1;
    }, t.prototype.destroy = function(e) {
      o.prototype.destroy.call(this, e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;
    }, t.BATCHABLE_SIZE = 100, t;
  }(Container)
), fragment$5 = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`, vertex$2 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`, MeshMaterial = (
  /** @class */
  function(o) {
    __extends$f(t, o);
    function t(e, r) {
      var D = this, N = {
        uSampler: e,
        alpha: 1,
        uTextureMatrix: Matrix.IDENTITY,
        uColor: new Float32Array([1, 1, 1, 1])
      };
      return r = Object.assign({
        tint: 16777215,
        alpha: 1,
        pluginName: "batch"
      }, r), r.uniforms && Object.assign(N, r.uniforms), D = o.call(this, r.program || Program.from(vertex$2, fragment$5), N) || this, D._colorDirty = !1, D.uvMatrix = new TextureMatrix(e), D.batchable = r.program === void 0, D.pluginName = r.pluginName, D.tint = r.tint, D.alpha = r.alpha, D;
    }
    return Object.defineProperty(t.prototype, "texture", {
      /** Reference to the texture being rendered. */
      get: function() {
        return this.uniforms.uSampler;
      },
      set: function(e) {
        this.uniforms.uSampler !== e && (!this.uniforms.uSampler.baseTexture.alphaMode != !e.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = e, this.uvMatrix.texture = e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "alpha", {
      get: function() {
        return this._alpha;
      },
      /**
       * This gets automatically set by the object using this.
       * @default 1
       */
      set: function(e) {
        e !== this._alpha && (this._alpha = e, this._colorDirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tint", {
      get: function() {
        return this._tint;
      },
      /**
       * Multiply tint for the material.
       * @default 0xFFFFFF
       */
      set: function(e) {
        e !== this._tint && (this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16), this._colorDirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.update = function() {
      if (this._colorDirty) {
        this._colorDirty = !1;
        var e = this.texture.baseTexture;
        premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, e.alphaMode);
      }
      this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
    }, t;
  }(Shader)
), MeshGeometry = (
  /** @class */
  function(o) {
    __extends$f(t, o);
    function t(e, r, D) {
      var N = o.call(this) || this, k = new Buffer$1(e), $ = new Buffer$1(r, !0), G = new Buffer$1(D, !0, !0);
      return N.addAttribute("aVertexPosition", k, 2, !1, TYPES.FLOAT).addAttribute("aTextureCoord", $, 2, !1, TYPES.FLOAT).addIndex(G), N._updateId = -1, N;
    }
    return Object.defineProperty(t.prototype, "vertexDirtyId", {
      /**
       * If the vertex position is updated.
       * @readonly
       * @private
       */
      get: function() {
        return this.buffers[0]._updateID;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Geometry)
);
/*!
 * @pixi/text-bitmap - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/text-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$e = function(o, t) {
  return extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$e(o, t);
};
function __extends$e(o, t) {
  extendStatics$e(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var BitmapFontData = (
  /** @class */
  function() {
    function o() {
      this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];
    }
    return o;
  }()
), TextFormat = (
  /** @class */
  function() {
    function o() {
    }
    return o.test = function(t) {
      return typeof t == "string" && t.indexOf("info face=") === 0;
    }, o.parse = function(t) {
      var e = t.match(/^[a-z]+\s+.+$/gm), r = {
        info: [],
        common: [],
        page: [],
        char: [],
        chars: [],
        kerning: [],
        kernings: [],
        distanceField: []
      };
      for (var D in e) {
        var N = e[D].match(/^[a-z]+/gm)[0], k = e[D].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), $ = {};
        for (var G in k) {
          var U = k[G].split("="), z = U[0], X = U[1].replace(/"/gm, ""), V = parseFloat(X), Y = isNaN(V) ? X : V;
          $[z] = Y;
        }
        r[N].push($);
      }
      var W = new BitmapFontData();
      return r.info.forEach(function(q) {
        return W.info.push({
          face: q.face,
          size: parseInt(q.size, 10)
        });
      }), r.common.forEach(function(q) {
        return W.common.push({
          lineHeight: parseInt(q.lineHeight, 10)
        });
      }), r.page.forEach(function(q) {
        return W.page.push({
          id: parseInt(q.id, 10),
          file: q.file
        });
      }), r.char.forEach(function(q) {
        return W.char.push({
          id: parseInt(q.id, 10),
          page: parseInt(q.page, 10),
          x: parseInt(q.x, 10),
          y: parseInt(q.y, 10),
          width: parseInt(q.width, 10),
          height: parseInt(q.height, 10),
          xoffset: parseInt(q.xoffset, 10),
          yoffset: parseInt(q.yoffset, 10),
          xadvance: parseInt(q.xadvance, 10)
        });
      }), r.kerning.forEach(function(q) {
        return W.kerning.push({
          first: parseInt(q.first, 10),
          second: parseInt(q.second, 10),
          amount: parseInt(q.amount, 10)
        });
      }), r.distanceField.forEach(function(q) {
        return W.distanceField.push({
          distanceRange: parseInt(q.distanceRange, 10),
          fieldType: q.fieldType
        });
      }), W;
    }, o;
  }()
), XMLFormat = (
  /** @class */
  function() {
    function o() {
    }
    return o.test = function(t) {
      return t instanceof XMLDocument && t.getElementsByTagName("page").length && t.getElementsByTagName("info")[0].getAttribute("face") !== null;
    }, o.parse = function(t) {
      for (var e = new BitmapFontData(), r = t.getElementsByTagName("info"), D = t.getElementsByTagName("common"), N = t.getElementsByTagName("page"), k = t.getElementsByTagName("char"), $ = t.getElementsByTagName("kerning"), G = t.getElementsByTagName("distanceField"), U = 0; U < r.length; U++)
        e.info.push({
          face: r[U].getAttribute("face"),
          size: parseInt(r[U].getAttribute("size"), 10)
        });
      for (var U = 0; U < D.length; U++)
        e.common.push({
          lineHeight: parseInt(D[U].getAttribute("lineHeight"), 10)
        });
      for (var U = 0; U < N.length; U++)
        e.page.push({
          id: parseInt(N[U].getAttribute("id"), 10) || 0,
          file: N[U].getAttribute("file")
        });
      for (var U = 0; U < k.length; U++) {
        var z = k[U];
        e.char.push({
          id: parseInt(z.getAttribute("id"), 10),
          page: parseInt(z.getAttribute("page"), 10) || 0,
          x: parseInt(z.getAttribute("x"), 10),
          y: parseInt(z.getAttribute("y"), 10),
          width: parseInt(z.getAttribute("width"), 10),
          height: parseInt(z.getAttribute("height"), 10),
          xoffset: parseInt(z.getAttribute("xoffset"), 10),
          yoffset: parseInt(z.getAttribute("yoffset"), 10),
          xadvance: parseInt(z.getAttribute("xadvance"), 10)
        });
      }
      for (var U = 0; U < $.length; U++)
        e.kerning.push({
          first: parseInt($[U].getAttribute("first"), 10),
          second: parseInt($[U].getAttribute("second"), 10),
          amount: parseInt($[U].getAttribute("amount"), 10)
        });
      for (var U = 0; U < G.length; U++)
        e.distanceField.push({
          fieldType: G[U].getAttribute("fieldType"),
          distanceRange: parseInt(G[U].getAttribute("distanceRange"), 10)
        });
      return e;
    }, o;
  }()
), XMLStringFormat = (
  /** @class */
  function() {
    function o() {
    }
    return o.test = function(t) {
      if (typeof t == "string" && t.indexOf("<font>") > -1) {
        var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
        return XMLFormat.test(e);
      }
      return !1;
    }, o.parse = function(t) {
      var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
      return XMLFormat.parse(e);
    }, o;
  }()
), formats = [
  TextFormat,
  XMLFormat,
  XMLStringFormat
];
function autoDetectFormat(o) {
  for (var t = 0; t < formats.length; t++)
    if (formats[t].test(o))
      return formats[t];
  return null;
}
function generateFillStyle(o, t, e, r, D, N) {
  var k = e.fill;
  if (Array.isArray(k)) {
    if (k.length === 1)
      return k[0];
  } else
    return k;
  var $, G = e.dropShadow ? e.dropShadowDistance : 0, U = e.padding || 0, z = o.width / r - G - U * 2, X = o.height / r - G - U * 2, V = k.slice(), Y = e.fillGradientStops.slice();
  if (!Y.length)
    for (var W = V.length + 1, q = 1; q < W; ++q)
      Y.push(q / W);
  if (V.unshift(k[0]), Y.unshift(0), V.push(k[k.length - 1]), Y.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    $ = t.createLinearGradient(z / 2, U, z / 2, X + U);
    for (var K = 0, Z = N.fontProperties.fontSize + e.strokeThickness, J = Z / X, q = 0; q < D.length; q++)
      for (var Q = N.lineHeight * q, et = 0; et < V.length; et++) {
        var it = 0;
        typeof Y[et] == "number" ? it = Y[et] : it = et / V.length;
        var tt = Q / X + it * J, nt = Math.max(K, tt);
        nt = Math.min(nt, 1), $.addColorStop(nt, V[et]), K = nt;
      }
  } else {
    $ = t.createLinearGradient(U, X / 2, z + U, X / 2);
    for (var st = V.length + 1, at = 1, q = 0; q < V.length; q++) {
      var ut = void 0;
      typeof Y[q] == "number" ? ut = Y[q] : ut = at / st, $.addColorStop(ut, V[q]), at++;
    }
  }
  return $;
}
function drawGlyph(o, t, e, r, D, N, k) {
  var $ = e.text, G = e.fontProperties;
  t.translate(r, D), t.scale(N, N);
  var U = k.strokeThickness / 2, z = -(k.strokeThickness / 2);
  if (t.font = k.toFontString(), t.lineWidth = k.strokeThickness, t.textBaseline = k.textBaseline, t.lineJoin = k.lineJoin, t.miterLimit = k.miterLimit, t.fillStyle = generateFillStyle(o, t, k, N, [$], e), t.strokeStyle = k.stroke, k.dropShadow) {
    var X = k.dropShadowColor, V = hex2rgb(typeof X == "number" ? X : string2hex(X)), Y = k.dropShadowBlur * N, W = k.dropShadowDistance * N;
    t.shadowColor = "rgba(" + V[0] * 255 + "," + V[1] * 255 + "," + V[2] * 255 + "," + k.dropShadowAlpha + ")", t.shadowBlur = Y, t.shadowOffsetX = Math.cos(k.dropShadowAngle) * W, t.shadowOffsetY = Math.sin(k.dropShadowAngle) * W;
  } else
    t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
  k.stroke && k.strokeThickness && t.strokeText($, U, z + e.lineHeight - G.descent), k.fill && t.fillText($, U, z + e.lineHeight - G.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = "rgba(0, 0, 0, 0)";
}
function splitTextToCharacters(o) {
  return Array.from ? Array.from(o) : o.split("");
}
function resolveCharacters(o) {
  typeof o == "string" && (o = [o]);
  for (var t = [], e = 0, r = o.length; e < r; e++) {
    var D = o[e];
    if (Array.isArray(D)) {
      if (D.length !== 2)
        throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + D.length + ".");
      var N = D[0].charCodeAt(0), k = D[1].charCodeAt(0);
      if (k < N)
        throw new Error("[BitmapFont]: Invalid character range.");
      for (var $ = N, G = k; $ <= G; $++)
        t.push(String.fromCharCode($));
    } else
      t.push.apply(t, splitTextToCharacters(D));
  }
  if (t.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return t;
}
function extractCharCode(o) {
  return o.codePointAt ? o.codePointAt(0) : o.charCodeAt(0);
}
var BitmapFont = (
  /** @class */
  function() {
    function o(t, e, r) {
      var D, N, k = t.info[0], $ = t.common[0], G = t.page[0], U = t.distanceField[0], z = getResolutionOfUrl(G.file), X = {};
      this._ownsTextures = r, this.font = k.face, this.size = k.size, this.lineHeight = $.lineHeight / z, this.chars = {}, this.pageTextures = X;
      for (var V = 0; V < t.page.length; V++) {
        var Y = t.page[V], W = Y.id, q = Y.file;
        X[W] = e instanceof Array ? e[V] : e[q], U != null && U.fieldType && U.fieldType !== "none" && (X[W].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA, X[W].baseTexture.mipmap = MIPMAP_MODES.OFF);
      }
      for (var V = 0; V < t.char.length; V++) {
        var K = t.char[V], W = K.id, Z = K.page, J = t.char[V], Q = J.x, et = J.y, it = J.width, tt = J.height, nt = J.xoffset, st = J.yoffset, at = J.xadvance;
        Q /= z, et /= z, it /= z, tt /= z, nt /= z, st /= z, at /= z;
        var ut = new Rectangle(Q + X[Z].frame.x / z, et + X[Z].frame.y / z, it, tt);
        this.chars[W] = {
          xOffset: nt,
          yOffset: st,
          xAdvance: at,
          kerning: {},
          texture: new Texture(X[Z].baseTexture, ut),
          page: Z
        };
      }
      for (var V = 0; V < t.kerning.length; V++) {
        var ht = t.kerning[V], dt = ht.first, pt = ht.second, _t = ht.amount;
        dt /= z, pt /= z, _t /= z, this.chars[pt] && (this.chars[pt].kerning[dt] = _t);
      }
      this.distanceFieldRange = U == null ? void 0 : U.distanceRange, this.distanceFieldType = (N = (D = U == null ? void 0 : U.fieldType) === null || D === void 0 ? void 0 : D.toLowerCase()) !== null && N !== void 0 ? N : "none";
    }
    return o.prototype.destroy = function() {
      for (var t in this.chars)
        this.chars[t].texture.destroy(), this.chars[t].texture = null;
      for (var t in this.pageTextures)
        this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;
      this.chars = null, this.pageTextures = null;
    }, o.install = function(t, e, r) {
      var D;
      if (t instanceof BitmapFontData)
        D = t;
      else {
        var N = autoDetectFormat(t);
        if (!N)
          throw new Error("Unrecognized data format for font.");
        D = N.parse(t);
      }
      e instanceof Texture && (e = [e]);
      var k = new o(D, e, r);
      return o.available[k.font] = k, k;
    }, o.uninstall = function(t) {
      var e = o.available[t];
      if (!e)
        throw new Error("No font found named '" + t + "'");
      e.destroy(), delete o.available[t];
    }, o.from = function(t, e, r) {
      if (!t)
        throw new Error("[BitmapFont] Property `name` is required.");
      var D = Object.assign({}, o.defaultOptions, r), N = D.chars, k = D.padding, $ = D.resolution, G = D.textureWidth, U = D.textureHeight, z = resolveCharacters(N), X = e instanceof TextStyle ? e : new TextStyle(e), V = G, Y = new BitmapFontData();
      Y.info[0] = {
        face: X.fontFamily,
        size: X.fontSize
      }, Y.common[0] = {
        lineHeight: X.fontSize
      };
      for (var W = 0, q = 0, K, Z, J, Q = 0, et = [], it = 0; it < z.length; it++) {
        K || (K = settings.ADAPTER.createCanvas(), K.width = G, K.height = U, Z = K.getContext("2d"), J = new BaseTexture(K, { resolution: $ }), et.push(new Texture(J)), Y.page.push({
          id: et.length - 1,
          file: ""
        }));
        var tt = z[it], nt = TextMetrics.measureText(tt, X, !1, K), st = nt.width, at = Math.ceil(nt.height), ut = Math.ceil((X.fontStyle === "italic" ? 2 : 1) * st);
        if (q >= U - at * $) {
          if (q === 0)
            throw new Error("[BitmapFont] textureHeight " + U + "px is too small " + ("(fontFamily: '" + X.fontFamily + "', fontSize: " + X.fontSize + "px, char: '" + tt + "')"));
          --it, K = null, Z = null, J = null, q = 0, W = 0, Q = 0;
          continue;
        }
        if (Q = Math.max(at + nt.fontProperties.descent, Q), ut * $ + W >= V) {
          if (W === 0)
            throw new Error("[BitmapFont] textureWidth " + G + "px is too small " + ("(fontFamily: '" + X.fontFamily + "', fontSize: " + X.fontSize + "px, char: '" + tt + "')"));
          --it, q += Q * $, q = Math.ceil(q), W = 0, Q = 0;
          continue;
        }
        drawGlyph(K, Z, nt, W, q, $, X);
        var ht = extractCharCode(nt.text);
        Y.char.push({
          id: ht,
          page: et.length - 1,
          x: W / $,
          y: q / $,
          width: ut,
          height: at,
          xoffset: 0,
          yoffset: 0,
          xadvance: Math.ceil(st - (X.dropShadow ? X.dropShadowDistance : 0) - (X.stroke ? X.strokeThickness : 0))
        }), W += (ut + 2 * k) * $, W = Math.ceil(W);
      }
      for (var it = 0, dt = z.length; it < dt; it++)
        for (var pt = z[it], _t = 0; _t < dt; _t++) {
          var mt = z[_t], yt = Z.measureText(pt).width, Tt = Z.measureText(mt).width, Pt = Z.measureText(pt + mt).width, St = Pt - (yt + Tt);
          St && Y.kerning.push({
            first: extractCharCode(pt),
            second: extractCharCode(mt),
            amount: St
          });
        }
      var gt = new o(Y, et, !0);
      return o.available[t] !== void 0 && o.uninstall(t), o.available[t] = gt, gt;
    }, o.ALPHA = [["a", "z"], ["A", "Z"], " "], o.NUMERIC = [["0", "9"]], o.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], o.ASCII = [[" ", "~"]], o.defaultOptions = {
      resolution: 1,
      textureWidth: 512,
      textureHeight: 512,
      padding: 4,
      chars: o.ALPHANUMERIC
    }, o.available = {}, o;
  }()
), msdfFrag = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r
\r
}\r
`, msdfVert = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`, pageMeshDataDefaultPageMeshData = [], pageMeshDataMSDFPageMeshData = [], charRenderDataPool = [];
(function(o) {
  __extends$e(t, o);
  function t(e, r) {
    r === void 0 && (r = {});
    var D = o.call(this) || this;
    D._tint = 16777215;
    var N = Object.assign({}, t.styleDefaults, r), k = N.align, $ = N.tint, G = N.maxWidth, U = N.letterSpacing, z = N.fontName, X = N.fontSize;
    if (!BitmapFont.available[z])
      throw new Error('Missing BitmapFont "' + z + '"');
    return D._activePagesMeshData = [], D._textWidth = 0, D._textHeight = 0, D._align = k, D._tint = $, D._font = void 0, D._fontName = z, D._fontSize = X, D.text = e, D._maxWidth = G, D._maxLineHeight = 0, D._letterSpacing = U, D._anchor = new ObservablePoint(function() {
      D.dirty = !0;
    }, D, 0, 0), D._roundPixels = settings.ROUND_PIXELS, D.dirty = !0, D._resolution = settings.RESOLUTION, D._autoResolution = !0, D._textureCache = {}, D;
  }
  return t.prototype.updateText = function() {
    for (var e, r = BitmapFont.available[this._fontName], D = this.fontSize, N = D / r.size, k = new Point(), $ = [], G = [], U = [], z = this._text.replace(/(?:\r\n|\r)/g, `
`) || " ", X = splitTextToCharacters(z), V = this._maxWidth * r.size / D, Y = r.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData, W = null, q = 0, K = 0, Z = 0, J = -1, Q = 0, et = 0, it = 0, tt = 0, nt = 0; nt < X.length; nt++) {
      var st = X[nt], at = extractCharCode(st);
      if (/(?:\s)/.test(st) && (J = nt, Q = q, tt++), st === "\r" || st === `
`) {
        G.push(q), U.push(-1), K = Math.max(K, q), ++Z, ++et, k.x = 0, k.y += r.lineHeight, W = null, tt = 0;
        continue;
      }
      var ut = r.chars[at];
      if (ut) {
        W && ut.kerning[W] && (k.x += ut.kerning[W]);
        var ht = charRenderDataPool.pop() || {
          texture: Texture.EMPTY,
          line: 0,
          charCode: 0,
          prevSpaces: 0,
          position: new Point()
        };
        ht.texture = ut.texture, ht.line = Z, ht.charCode = at, ht.position.x = k.x + ut.xOffset + this._letterSpacing / 2, ht.position.y = k.y + ut.yOffset, ht.prevSpaces = tt, $.push(ht), q = ht.position.x + Math.max(ut.xAdvance - ut.xOffset, ut.texture.orig.width), k.x += ut.xAdvance + this._letterSpacing, it = Math.max(it, ut.yOffset + ut.texture.height), W = at, J !== -1 && V > 0 && k.x > V && (++et, removeItems($, 1 + J - et, 1 + nt - J), nt = J, J = -1, G.push(Q), U.push($.length > 0 ? $[$.length - 1].prevSpaces : 0), K = Math.max(K, Q), Z++, k.x = 0, k.y += r.lineHeight, W = null, tt = 0);
      }
    }
    var dt = X[X.length - 1];
    dt !== "\r" && dt !== `
` && (/(?:\s)/.test(dt) && (q = Q), G.push(q), K = Math.max(K, q), U.push(-1));
    for (var pt = [], nt = 0; nt <= Z; nt++) {
      var _t = 0;
      this._align === "right" ? _t = K - G[nt] : this._align === "center" ? _t = (K - G[nt]) / 2 : this._align === "justify" && (_t = U[nt] < 0 ? 0 : (K - G[nt]) / U[nt]), pt.push(_t);
    }
    var mt = $.length, yt = {}, Tt = [], Pt = this._activePagesMeshData;
    Y.push.apply(Y, Pt);
    for (var nt = 0; nt < mt; nt++) {
      var St = $[nt].texture, gt = St.baseTexture.uid;
      if (!yt[gt]) {
        var bt = Y.pop();
        if (!bt) {
          var At = new MeshGeometry(), Rt = void 0, Nt = void 0;
          r.distanceFieldType === "none" ? (Rt = new MeshMaterial(Texture.EMPTY), Nt = BLEND_MODES.NORMAL) : (Rt = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } }), Nt = BLEND_MODES.NORMAL_NPM);
          var Mt = new Mesh(At, Rt);
          Mt.blendMode = Nt, bt = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh: Mt,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        bt.index = 0, bt.indexCount = 0, bt.vertexCount = 0, bt.uvsCount = 0, bt.total = 0;
        var ft = this._textureCache;
        ft[gt] = ft[gt] || new Texture(St.baseTexture), bt.mesh.texture = ft[gt], bt.mesh.tint = this._tint, Tt.push(bt), yt[gt] = bt;
      }
      yt[gt].total++;
    }
    for (var nt = 0; nt < Pt.length; nt++)
      Tt.indexOf(Pt[nt]) === -1 && this.removeChild(Pt[nt].mesh);
    for (var nt = 0; nt < Tt.length; nt++)
      Tt[nt].mesh.parent !== this && this.addChild(Tt[nt].mesh);
    this._activePagesMeshData = Tt;
    for (var nt in yt) {
      var bt = yt[nt], Ft = bt.total;
      if (!(((e = bt.indices) === null || e === void 0 ? void 0 : e.length) > 6 * Ft) || bt.vertices.length < Mesh.BATCHABLE_SIZE * 2)
        bt.vertices = new Float32Array(4 * 2 * Ft), bt.uvs = new Float32Array(4 * 2 * Ft), bt.indices = new Uint16Array(6 * Ft);
      else
        for (var Dt = bt.total, Vt = bt.vertices, Bt = Dt * 4 * 2; Bt < Vt.length; Bt++)
          Vt[Bt] = 0;
      bt.mesh.size = 6 * Ft;
    }
    for (var nt = 0; nt < mt; nt++) {
      var st = $[nt], Et = st.position.x + pt[st.line] * (this._align === "justify" ? st.prevSpaces : 1);
      this._roundPixels && (Et = Math.round(Et));
      var Ht = Et * N, kt = st.position.y * N, St = st.texture, wt = yt[St.baseTexture.uid], Lt = St.frame, jt = St._uvs, Ct = wt.index++;
      wt.indices[Ct * 6 + 0] = 0 + Ct * 4, wt.indices[Ct * 6 + 1] = 1 + Ct * 4, wt.indices[Ct * 6 + 2] = 2 + Ct * 4, wt.indices[Ct * 6 + 3] = 0 + Ct * 4, wt.indices[Ct * 6 + 4] = 2 + Ct * 4, wt.indices[Ct * 6 + 5] = 3 + Ct * 4, wt.vertices[Ct * 8 + 0] = Ht, wt.vertices[Ct * 8 + 1] = kt, wt.vertices[Ct * 8 + 2] = Ht + Lt.width * N, wt.vertices[Ct * 8 + 3] = kt, wt.vertices[Ct * 8 + 4] = Ht + Lt.width * N, wt.vertices[Ct * 8 + 5] = kt + Lt.height * N, wt.vertices[Ct * 8 + 6] = Ht, wt.vertices[Ct * 8 + 7] = kt + Lt.height * N, wt.uvs[Ct * 8 + 0] = jt.x0, wt.uvs[Ct * 8 + 1] = jt.y0, wt.uvs[Ct * 8 + 2] = jt.x1, wt.uvs[Ct * 8 + 3] = jt.y1, wt.uvs[Ct * 8 + 4] = jt.x2, wt.uvs[Ct * 8 + 5] = jt.y2, wt.uvs[Ct * 8 + 6] = jt.x3, wt.uvs[Ct * 8 + 7] = jt.y3;
    }
    this._textWidth = K * N, this._textHeight = (k.y + r.lineHeight) * N;
    for (var nt in yt) {
      var bt = yt[nt];
      if (this.anchor.x !== 0 || this.anchor.y !== 0)
        for (var Wt = 0, Jt = this._textWidth * this.anchor.x, Kt = this._textHeight * this.anchor.y, Se = 0; Se < bt.total; Se++)
          bt.vertices[Wt++] -= Jt, bt.vertices[Wt++] -= Kt, bt.vertices[Wt++] -= Jt, bt.vertices[Wt++] -= Kt, bt.vertices[Wt++] -= Jt, bt.vertices[Wt++] -= Kt, bt.vertices[Wt++] -= Jt, bt.vertices[Wt++] -= Kt;
      this._maxLineHeight = it * N;
      var Oe = bt.mesh.geometry.getBuffer("aVertexPosition"), he = bt.mesh.geometry.getBuffer("aTextureCoord"), _e = bt.mesh.geometry.getIndex();
      Oe.data = bt.vertices, he.data = bt.uvs, _e.data = bt.indices, Oe.update(), he.update(), _e.update();
    }
    for (var nt = 0; nt < $.length; nt++)
      charRenderDataPool.push($[nt]);
    this._font = r, this.dirty = !1;
  }, t.prototype.updateTransform = function() {
    this.validate(), this.containerUpdateTransform();
  }, t.prototype._render = function(e) {
    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);
    var r = BitmapFont.available[this._fontName], D = r.distanceFieldRange, N = r.distanceFieldType, k = r.size;
    if (N !== "none")
      for (var $ = this.worldTransform, G = $.a, U = $.b, z = $.c, X = $.d, V = Math.sqrt(G * G + U * U), Y = Math.sqrt(z * z + X * X), W = (Math.abs(V) + Math.abs(Y)) / 2, q = this.fontSize / k, K = 0, Z = this._activePagesMeshData; K < Z.length; K++) {
        var J = Z[K];
        J.mesh.shader.uniforms.uFWidth = W * D * q * this._resolution;
      }
    o.prototype._render.call(this, e);
  }, t.prototype.getLocalBounds = function() {
    return this.validate(), o.prototype.getLocalBounds.call(this);
  }, t.prototype.validate = function() {
    var e = BitmapFont.available[this._fontName];
    if (!e)
      throw new Error('Missing BitmapFont "' + this._fontName + '"');
    this._font !== e && (this.dirty = !0), this.dirty && this.updateText();
  }, Object.defineProperty(t.prototype, "tint", {
    /**
     * The tint of the BitmapText object.
     * @default 0xffffff
     */
    get: function() {
      return this._tint;
    },
    set: function(e) {
      if (this._tint !== e) {
        this._tint = e;
        for (var r = 0; r < this._activePagesMeshData.length; r++)
          this._activePagesMeshData[r].mesh.tint = e;
      }
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "align", {
    /**
     * The alignment of the BitmapText object.
     * @member {string}
     * @default 'left'
     */
    get: function() {
      return this._align;
    },
    set: function(e) {
      this._align !== e && (this._align = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fontName", {
    /** The name of the BitmapFont. */
    get: function() {
      return this._fontName;
    },
    set: function(e) {
      if (!BitmapFont.available[e])
        throw new Error('Missing BitmapFont "' + e + '"');
      this._fontName !== e && (this._fontName = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fontSize", {
    /** The size of the font to display. */
    get: function() {
      var e;
      return (e = this._fontSize) !== null && e !== void 0 ? e : BitmapFont.available[this._fontName].size;
    },
    set: function(e) {
      this._fontSize !== e && (this._fontSize = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "anchor", {
    /**
     * The anchor sets the origin point of the text.
     *
     * The default is `(0,0)`, this means the text's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
     */
    get: function() {
      return this._anchor;
    },
    set: function(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "text", {
    /** The text of the BitmapText object. */
    get: function() {
      return this._text;
    },
    set: function(e) {
      e = String(e ?? ""), this._text !== e && (this._text = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "maxWidth", {
    /**
     * The max width of this bitmap text in pixels. If the text provided is longer than the
     * value provided, line breaks will be automatically inserted in the last whitespace.
     * Disable by setting the value to 0.
     */
    get: function() {
      return this._maxWidth;
    },
    set: function(e) {
      this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "maxLineHeight", {
    /**
     * The max line height. This is useful when trying to use the total height of the Text,
     * i.e. when trying to vertically align.
     * @readonly
     */
    get: function() {
      return this.validate(), this._maxLineHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textWidth", {
    /**
     * The width of the overall text, different from fontSize,
     * which is defined in the style object.
     * @readonly
     */
    get: function() {
      return this.validate(), this._textWidth;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "letterSpacing", {
    /** Additional space between characters. */
    get: function() {
      return this._letterSpacing;
    },
    set: function(e) {
      this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "roundPixels", {
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     * @default PIXI.settings.ROUND_PIXELS
     */
    get: function() {
      return this._roundPixels;
    },
    set: function(e) {
      e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textHeight", {
    /**
     * The height of the overall text, different from fontSize,
     * which is defined in the style object.
     * @readonly
     */
    get: function() {
      return this.validate(), this._textHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "resolution", {
    /**
     * The resolution / device pixel ratio of the canvas.
     *
     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
     * @default 1
     */
    get: function() {
      return this._resolution;
    },
    set: function(e) {
      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.destroy = function(e) {
    var r = this._textureCache, D = BitmapFont.available[this._fontName], N = D.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    N.push.apply(N, this._activePagesMeshData);
    for (var k = 0, $ = this._activePagesMeshData; k < $.length; k++) {
      var G = $[k];
      this.removeChild(G.mesh);
    }
    this._activePagesMeshData = [], N.filter(function(X) {
      return r[X.mesh.texture.baseTexture.uid];
    }).forEach(function(X) {
      X.mesh.texture = Texture.EMPTY;
    });
    for (var U in r) {
      var z = r[U];
      z.destroy(), delete r[U];
    }
    this._font = null, this._textureCache = null, o.prototype.destroy.call(this, e);
  }, t.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
  }, t;
})(Container);
var BitmapFontLoader = (
  /** @class */
  function() {
    function o() {
    }
    return o.add = function() {
      LoaderResource.setExtensionXhrType("fnt", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
    }, o.use = function(t, e) {
      var r = autoDetectFormat(t.data);
      if (!r) {
        e();
        return;
      }
      for (var D = o.getBaseUrl(this, t), N = r.parse(t.data), k = {}, $ = function(q) {
        k[q.metadata.pageFile] = q.texture, Object.keys(k).length === N.page.length && (t.bitmapFont = BitmapFont.install(N, k, !0), e());
      }, G = 0; G < N.page.length; ++G) {
        var U = N.page[G].file, z = D + U, X = !1;
        for (var V in this.resources) {
          var Y = this.resources[V];
          if (Y.url === z) {
            Y.metadata.pageFile = U, Y.texture ? $(Y) : Y.onAfterMiddleware.add($), X = !0;
            break;
          }
        }
        if (!X) {
          var W = {
            crossOrigin: t.crossOrigin,
            loadType: LoaderResource.LOAD_TYPE.IMAGE,
            metadata: Object.assign({ pageFile: U }, t.metadata.imageMetadata),
            parentResource: t
          };
          this.add(z, W, $);
        }
      }
    }, o.getBaseUrl = function(t, e) {
      var r = e.isDataUrl ? "" : o.dirname(e.url);
      return e.isDataUrl && (r === "." && (r = ""), t.baseUrl && r && t.baseUrl.charAt(t.baseUrl.length - 1) === "/" && (r += "/")), r = r.replace(t.baseUrl, ""), r && r.charAt(r.length - 1) !== "/" && (r += "/"), r;
    }, o.dirname = function(t) {
      var e = t.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
      return e === t ? "." : e === "" ? "/" : e;
    }, o.extension = ExtensionType.Loader, o;
  }()
);
/*!
 * @pixi/filter-alpha - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-alpha is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$d = function(o, t) {
  return extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$d(o, t);
};
function __extends$d(o, t) {
  extendStatics$d(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment$4 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
(function(o) {
  __extends$d(t, o);
  function t(e) {
    e === void 0 && (e = 1);
    var r = o.call(this, defaultVertex$1, fragment$4, { uAlpha: 1 }) || this;
    return r.alpha = e, r;
  }
  return Object.defineProperty(t.prototype, "alpha", {
    /**
     * Coefficient for alpha multiplication
     * @default 1
     */
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(e) {
      this.uniforms.uAlpha = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/filter-blur - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$c = function(o, t) {
  return extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$c(o, t);
};
function __extends$c(o, t) {
  extendStatics$c(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function generateBlurVertSource(o, t) {
  var e = Math.ceil(o / 2), r = vertTemplate, D = "", N;
  t ? N = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : N = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  for (var k = 0; k < o; k++) {
    var $ = N.replace("%index%", k.toString());
    $ = $.replace("%sampleIndex%", k - (e - 1) + ".0"), D += $, D += `
`;
  }
  return r = r.replace("%blur%", D), r = r.replace("%size%", o.toString()), r;
}
var GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
}, fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join(`
`);
function generateBlurFragSource(o) {
  for (var t = GAUSSIAN_VALUES[o], e = t.length, r = fragTemplate, D = "", N = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;", k, $ = 0; $ < o; $++) {
    var G = N.replace("%index%", $.toString());
    k = $, $ >= e && (k = o - $ - 1), G = G.replace("%value%", t[k].toString()), D += G, D += `
`;
  }
  return r = r.replace("%blur%", D), r = r.replace("%size%", o.toString()), r;
}
var BlurFilterPass = (
  /** @class */
  function(o) {
    __extends$c(t, o);
    function t(e, r, D, N, k) {
      r === void 0 && (r = 8), D === void 0 && (D = 4), N === void 0 && (N = settings.FILTER_RESOLUTION), k === void 0 && (k = 5);
      var $ = this, G = generateBlurVertSource(k, e), U = generateBlurFragSource(k);
      return $ = o.call(
        this,
        // vertex shader
        G,
        // fragment shader
        U
      ) || this, $.horizontal = e, $.resolution = N, $._quality = 0, $.quality = D, $.blur = r, $;
    }
    return t.prototype.apply = function(e, r, D, N) {
      if (D ? this.horizontal ? this.uniforms.strength = 1 / D.width * (D.width / r.width) : this.uniforms.strength = 1 / D.height * (D.height / r.height) : this.horizontal ? this.uniforms.strength = 1 / e.renderer.width * (e.renderer.width / r.width) : this.uniforms.strength = 1 / e.renderer.height * (e.renderer.height / r.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)
        e.applyFilter(this, r, D, N);
      else {
        var k = e.getFilterTexture(), $ = e.renderer, G = r, U = k;
        this.state.blend = !1, e.applyFilter(this, G, U, CLEAR_MODES.CLEAR);
        for (var z = 1; z < this.passes - 1; z++) {
          e.bindAndClear(G, CLEAR_MODES.BLIT), this.uniforms.uSampler = U;
          var X = U;
          U = G, G = X, $.shader.bind(this), $.geometry.draw(5);
        }
        this.state.blend = !0, e.applyFilter(this, U, D, N), e.returnFilterTexture(k);
      }
    }, Object.defineProperty(t.prototype, "blur", {
      /**
       * Sets the strength of both the blur.
       * @default 16
       */
      get: function() {
        return this.strength;
      },
      set: function(e) {
        this.padding = 1 + Math.abs(e) * 2, this.strength = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "quality", {
      /**
       * Sets the quality of the blur by modifying the number of passes. More passes means higher
       * quality bluring but the lower the performance.
       * @default 4
       */
      get: function() {
        return this._quality;
      },
      set: function(e) {
        this._quality = e, this.passes = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Filter)
);
(function(o) {
  __extends$c(t, o);
  function t(e, r, D, N) {
    e === void 0 && (e = 8), r === void 0 && (r = 4), D === void 0 && (D = settings.FILTER_RESOLUTION), N === void 0 && (N = 5);
    var k = o.call(this) || this;
    return k.blurXFilter = new BlurFilterPass(!0, e, r, D, N), k.blurYFilter = new BlurFilterPass(!1, e, r, D, N), k.resolution = D, k.quality = r, k.blur = e, k.repeatEdgePixels = !1, k;
  }
  return t.prototype.apply = function(e, r, D, N) {
    var k = Math.abs(this.blurXFilter.strength), $ = Math.abs(this.blurYFilter.strength);
    if (k && $) {
      var G = e.getFilterTexture();
      this.blurXFilter.apply(e, r, G, CLEAR_MODES.CLEAR), this.blurYFilter.apply(e, G, D, N), e.returnFilterTexture(G);
    } else
      $ ? this.blurYFilter.apply(e, r, D, N) : this.blurXFilter.apply(e, r, D, N);
  }, t.prototype.updatePadding = function() {
    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
  }, Object.defineProperty(t.prototype, "blur", {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     * @default 2
     */
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(e) {
      this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "quality", {
    /**
     * Sets the number of passes for blur. More passes means higher quality bluring.
     * @default 1
     */
    get: function() {
      return this.blurXFilter.quality;
    },
    set: function(e) {
      this.blurXFilter.quality = this.blurYFilter.quality = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blurX", {
    /**
     * Sets the strength of the blurX property
     * @default 2
     */
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(e) {
      this.blurXFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blurY", {
    /**
     * Sets the strength of the blurY property
     * @default 2
     */
    get: function() {
      return this.blurYFilter.blur;
    },
    set: function(e) {
      this.blurYFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blendMode", {
    /**
     * Sets the blendmode of the filter
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get: function() {
      return this.blurYFilter.blendMode;
    },
    set: function(e) {
      this.blurYFilter.blendMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "repeatEdgePixels", {
    /**
     * If set to true the edge of the target will be clamped
     * @default false
     */
    get: function() {
      return this._repeatEdgePixels;
    },
    set: function(e) {
      this._repeatEdgePixels = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/filter-color-matrix - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-color-matrix is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$b = function(o, t) {
  return extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$b(o, t);
};
function __extends$b(o, t) {
  extendStatics$b(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment$3 = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`, ColorMatrixFilter = (
  /** @class */
  function(o) {
    __extends$b(t, o);
    function t() {
      var e = this, r = {
        m: new Float32Array([
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]),
        uAlpha: 1
      };
      return e = o.call(this, defaultFilterVertex, fragment$3, r) || this, e.alpha = 1, e;
    }
    return t.prototype._loadMatrix = function(e, r) {
      r === void 0 && (r = !1);
      var D = e;
      r && (this._multiply(D, this.uniforms.m, e), D = this._colorMatrix(D)), this.uniforms.m = D;
    }, t.prototype._multiply = function(e, r, D) {
      return e[0] = r[0] * D[0] + r[1] * D[5] + r[2] * D[10] + r[3] * D[15], e[1] = r[0] * D[1] + r[1] * D[6] + r[2] * D[11] + r[3] * D[16], e[2] = r[0] * D[2] + r[1] * D[7] + r[2] * D[12] + r[3] * D[17], e[3] = r[0] * D[3] + r[1] * D[8] + r[2] * D[13] + r[3] * D[18], e[4] = r[0] * D[4] + r[1] * D[9] + r[2] * D[14] + r[3] * D[19] + r[4], e[5] = r[5] * D[0] + r[6] * D[5] + r[7] * D[10] + r[8] * D[15], e[6] = r[5] * D[1] + r[6] * D[6] + r[7] * D[11] + r[8] * D[16], e[7] = r[5] * D[2] + r[6] * D[7] + r[7] * D[12] + r[8] * D[17], e[8] = r[5] * D[3] + r[6] * D[8] + r[7] * D[13] + r[8] * D[18], e[9] = r[5] * D[4] + r[6] * D[9] + r[7] * D[14] + r[8] * D[19] + r[9], e[10] = r[10] * D[0] + r[11] * D[5] + r[12] * D[10] + r[13] * D[15], e[11] = r[10] * D[1] + r[11] * D[6] + r[12] * D[11] + r[13] * D[16], e[12] = r[10] * D[2] + r[11] * D[7] + r[12] * D[12] + r[13] * D[17], e[13] = r[10] * D[3] + r[11] * D[8] + r[12] * D[13] + r[13] * D[18], e[14] = r[10] * D[4] + r[11] * D[9] + r[12] * D[14] + r[13] * D[19] + r[14], e[15] = r[15] * D[0] + r[16] * D[5] + r[17] * D[10] + r[18] * D[15], e[16] = r[15] * D[1] + r[16] * D[6] + r[17] * D[11] + r[18] * D[16], e[17] = r[15] * D[2] + r[16] * D[7] + r[17] * D[12] + r[18] * D[17], e[18] = r[15] * D[3] + r[16] * D[8] + r[17] * D[13] + r[18] * D[18], e[19] = r[15] * D[4] + r[16] * D[9] + r[17] * D[14] + r[18] * D[19] + r[19], e;
    }, t.prototype._colorMatrix = function(e) {
      var r = new Float32Array(e);
      return r[4] /= 255, r[9] /= 255, r[14] /= 255, r[19] /= 255, r;
    }, t.prototype.brightness = function(e, r) {
      var D = [
        e,
        0,
        0,
        0,
        0,
        0,
        e,
        0,
        0,
        0,
        0,
        0,
        e,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(D, r);
    }, t.prototype.tint = function(e, r) {
      var D = e >> 16 & 255, N = e >> 8 & 255, k = e & 255, $ = [
        D / 255,
        0,
        0,
        0,
        0,
        0,
        N / 255,
        0,
        0,
        0,
        0,
        0,
        k / 255,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix($, r);
    }, t.prototype.greyscale = function(e, r) {
      var D = [
        e,
        e,
        e,
        0,
        0,
        e,
        e,
        e,
        0,
        0,
        e,
        e,
        e,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(D, r);
    }, t.prototype.blackAndWhite = function(e) {
      var r = [
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.hue = function(e, r) {
      e = (e || 0) / 180 * Math.PI;
      var D = Math.cos(e), N = Math.sin(e), k = Math.sqrt, $ = 1 / 3, G = k($), U = D + (1 - D) * $, z = $ * (1 - D) - G * N, X = $ * (1 - D) + G * N, V = $ * (1 - D) + G * N, Y = D + $ * (1 - D), W = $ * (1 - D) - G * N, q = $ * (1 - D) - G * N, K = $ * (1 - D) + G * N, Z = D + $ * (1 - D), J = [
        U,
        z,
        X,
        0,
        0,
        V,
        Y,
        W,
        0,
        0,
        q,
        K,
        Z,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(J, r);
    }, t.prototype.contrast = function(e, r) {
      var D = (e || 0) + 1, N = -0.5 * (D - 1), k = [
        D,
        0,
        0,
        0,
        N,
        0,
        D,
        0,
        0,
        N,
        0,
        0,
        D,
        0,
        N,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(k, r);
    }, t.prototype.saturate = function(e, r) {
      e === void 0 && (e = 0);
      var D = e * 2 / 3 + 1, N = (D - 1) * -0.5, k = [
        D,
        N,
        N,
        0,
        0,
        N,
        D,
        N,
        0,
        0,
        N,
        N,
        D,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(k, r);
    }, t.prototype.desaturate = function() {
      this.saturate(-1);
    }, t.prototype.negative = function(e) {
      var r = [
        -1,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        -1,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.sepia = function(e) {
      var r = [
        0.393,
        0.7689999,
        0.18899999,
        0,
        0,
        0.349,
        0.6859999,
        0.16799999,
        0,
        0,
        0.272,
        0.5339999,
        0.13099999,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.technicolor = function(e) {
      var r = [
        1.9125277891456083,
        -0.8545344976951645,
        -0.09155508482755585,
        0,
        11.793603434377337,
        -0.3087833385928097,
        1.7658908555458428,
        -0.10601743074722245,
        0,
        -70.35205161461398,
        -0.231103377548616,
        -0.7501899197440212,
        1.847597816108189,
        0,
        30.950940869491138,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.polaroid = function(e) {
      var r = [
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.toBGR = function(e) {
      var r = [
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.kodachrome = function(e) {
      var r = [
        1.1285582396593525,
        -0.3967382283601348,
        -0.03992559172921793,
        0,
        63.72958762196502,
        -0.16404339962244616,
        1.0835251566291304,
        -0.05498805115633132,
        0,
        24.732407896706203,
        -0.16786010706155763,
        -0.5603416277695248,
        1.6014850761964943,
        0,
        35.62982807460946,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.browni = function(e) {
      var r = [
        0.5997023498159715,
        0.34553243048391263,
        -0.2708298674538042,
        0,
        47.43192855600873,
        -0.037703249837783157,
        0.8609577587992641,
        0.15059552388459913,
        0,
        -36.96841498319127,
        0.24113635128153335,
        -0.07441037908422492,
        0.44972182064877153,
        0,
        -7.562075277591283,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.vintage = function(e) {
      var r = [
        0.6279345635605994,
        0.3202183420819367,
        -0.03965408211312453,
        0,
        9.651285835294123,
        0.02578397704808868,
        0.6441188644374771,
        0.03259127616149294,
        0,
        7.462829176470591,
        0.0466055556782719,
        -0.0851232987247891,
        0.5241648018700465,
        0,
        5.159190588235296,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.colorTone = function(e, r, D, N, k) {
      e = e || 0.2, r = r || 0.15, D = D || 16770432, N = N || 3375104;
      var $ = (D >> 16 & 255) / 255, G = (D >> 8 & 255) / 255, U = (D & 255) / 255, z = (N >> 16 & 255) / 255, X = (N >> 8 & 255) / 255, V = (N & 255) / 255, Y = [
        0.3,
        0.59,
        0.11,
        0,
        0,
        $,
        G,
        U,
        e,
        0,
        z,
        X,
        V,
        r,
        0,
        $ - z,
        G - X,
        U - V,
        0,
        0
      ];
      this._loadMatrix(Y, k);
    }, t.prototype.night = function(e, r) {
      e = e || 0.1;
      var D = [
        e * -2,
        -e,
        0,
        0,
        0,
        -e,
        0,
        e,
        0,
        0,
        0,
        e,
        e * 2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(D, r);
    }, t.prototype.predator = function(e, r) {
      var D = [
        // row 1
        11.224130630493164 * e,
        -4.794486999511719 * e,
        -2.8746118545532227 * e,
        0 * e,
        0.40342438220977783 * e,
        // row 2
        -3.6330697536468506 * e,
        9.193157196044922 * e,
        -2.951810836791992 * e,
        0 * e,
        -1.316135048866272 * e,
        // row 3
        -3.2184197902679443 * e,
        -4.2375030517578125 * e,
        7.476448059082031 * e,
        0 * e,
        0.8044459223747253 * e,
        // row 4
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(D, r);
    }, t.prototype.lsd = function(e) {
      var r = [
        2,
        -0.4,
        0.5,
        0,
        0,
        -0.5,
        2,
        -0.4,
        0,
        0,
        -0.4,
        -0.5,
        3,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(r, e);
    }, t.prototype.reset = function() {
      var e = [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(e, !1);
    }, Object.defineProperty(t.prototype, "matrix", {
      /**
       * The matrix of the color matrix filter
       * @member {number[]}
       * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
       */
      get: function() {
        return this.uniforms.m;
      },
      set: function(e) {
        this.uniforms.m = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "alpha", {
      /**
       * The opacity value to use when mixing the original and resultant colors.
       *
       * When the value is 0, the original color is used without modification.
       * When the value is 1, the result color is used.
       * When in the range (0, 1) the color is interpolated between the original and result by this amount.
       * @default 1
       */
      get: function() {
        return this.uniforms.uAlpha;
      },
      set: function(e) {
        this.uniforms.uAlpha = e;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Filter)
);
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
/*!
 * @pixi/filter-displacement - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-displacement is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$a = function(o, t) {
  return extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$a(o, t);
};
function __extends$a(o, t) {
  extendStatics$a(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment$2 = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`, vertex$1 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
(function(o) {
  __extends$a(t, o);
  function t(e, r) {
    var D = this, N = new Matrix();
    return e.renderable = !1, D = o.call(this, vertex$1, fragment$2, {
      mapSampler: e._texture,
      filterMatrix: N,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    }) || this, D.maskSprite = e, D.maskMatrix = N, r == null && (r = 20), D.scale = new Point(r, r), D;
  }
  return t.prototype.apply = function(e, r, D, N) {
    this.uniforms.filterMatrix = e.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
    var k = this.maskSprite.worldTransform, $ = Math.sqrt(k.a * k.a + k.b * k.b), G = Math.sqrt(k.c * k.c + k.d * k.d);
    $ !== 0 && G !== 0 && (this.uniforms.rotation[0] = k.a / $, this.uniforms.rotation[1] = k.b / $, this.uniforms.rotation[2] = k.c / G, this.uniforms.rotation[3] = k.d / G), e.applyFilter(this, r, D, N);
  }, Object.defineProperty(t.prototype, "map", {
    /** The texture used for the displacement map. Must be power of 2 sized texture. */
    get: function() {
      return this.uniforms.mapSampler;
    },
    set: function(e) {
      this.uniforms.mapSampler = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/filter-fxaa - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-fxaa is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$9 = function(o, t) {
  return extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$9(o, t);
};
function __extends$9(o, t) {
  extendStatics$9(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var vertex = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`, fragment$1 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
(function(o) {
  __extends$9(t, o);
  function t() {
    return o.call(this, vertex, fragment$1) || this;
  }
  return t;
})(Filter);
/*!
 * @pixi/filter-noise - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/filter-noise is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$8 = function(o, t) {
  return extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$8(o, t);
};
function __extends$8(o, t) {
  extendStatics$8(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
(function(o) {
  __extends$8(t, o);
  function t(e, r) {
    e === void 0 && (e = 0.5), r === void 0 && (r = Math.random());
    var D = o.call(this, defaultFilterVertex, fragment, {
      uNoise: 0,
      uSeed: 0
    }) || this;
    return D.noise = e, D.seed = r, D;
  }
  return Object.defineProperty(t.prototype, "noise", {
    /**
     * The amount of noise to apply, this value should be in the range (0, 1].
     * @default 0.5
     */
    get: function() {
      return this.uniforms.uNoise;
    },
    set: function(e) {
      this.uniforms.uNoise = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "seed", {
    /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */
    get: function() {
      return this.uniforms.uSeed;
    },
    set: function(e) {
      this.uniforms.uSeed = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/mixin-cache-as-bitmap - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var _tempMatrix = new Matrix();
DisplayObject.prototype._cacheAsBitmap = !1;
DisplayObject.prototype._cacheData = null;
DisplayObject.prototype._cacheAsBitmapResolution = null;
DisplayObject.prototype._cacheAsBitmapMultisample = MSAA_QUALITY.NONE;
var CacheData = (
  /** @class */
  function() {
    function o() {
      this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;
    }
    return o;
  }()
);
Object.defineProperties(DisplayObject.prototype, {
  /**
   * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution
   * but can be overriden for performance. Lower values will reduce memory usage at the expense
   * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.
   * @member {number} cacheAsBitmapResolution
   * @memberof PIXI.DisplayObject#
   * @default null
   */
  cacheAsBitmapResolution: {
    get: function() {
      return this._cacheAsBitmapResolution;
    },
    set: function(o) {
      o !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = o, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  /**
   * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's
   * sample count is used.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.
   * @member {number} cacheAsBitmapMultisample
   * @memberof PIXI.DisplayObject#
   * @default PIXI.MSAA_QUALITY.NONE
   */
  cacheAsBitmapMultisample: {
    get: function() {
      return this._cacheAsBitmapMultisample;
    },
    set: function(o) {
      o !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = o, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  /**
   * Set this to true if you want this display object to be cached as a bitmap.
   * This basically takes a snap shot of the display object as it is at that moment. It can
   * provide a performance benefit for complex static displayObjects.
   * To remove simply set this property to `false`
   *
   * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
   * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  cacheAsBitmap: {
    get: function() {
      return this._cacheAsBitmap;
    },
    set: function(o) {
      if (this._cacheAsBitmap !== o) {
        this._cacheAsBitmap = o;
        var t;
        o ? (this._cacheData || (this._cacheData = new CacheData()), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea);
      }
    }
  }
});
DisplayObject.prototype._renderCached = function(t) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t));
};
DisplayObject.prototype._initCachedDisplayObject = function(t) {
  var e;
  if (!(this._cacheData && this._cacheData.sprite)) {
    var r = this.alpha;
    this.alpha = 1, t.batch.flush();
    var D = this.getLocalBounds(null, !0).clone();
    if (this.filters && this.filters.length) {
      var N = this.filters[0].padding;
      D.pad(N);
    }
    D.ceil(settings.RESOLUTION);
    var k = t.renderTexture.current, $ = t.renderTexture.sourceFrame.clone(), G = t.renderTexture.destinationFrame.clone(), U = t.projection.transform, z = RenderTexture.create({
      width: D.width,
      height: D.height,
      resolution: this.cacheAsBitmapResolution || t.resolution,
      multisample: (e = this.cacheAsBitmapMultisample) !== null && e !== void 0 ? e : t.multisample
    }), X = "cacheAsBitmap_" + uid();
    this._cacheData.textureCacheId = X, BaseTexture.addToCache(z.baseTexture, X), Texture.addToCache(z, X);
    var V = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-D.x, -D.y);
    this.render = this._cacheData.originalRender, t.render(this, { renderTexture: z, clear: !0, transform: V, skipUpdateTransform: !1 }), t.framebuffer.blit(), t.projection.transform = U, t.renderTexture.bind(k, $, G), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r;
    var Y = new Sprite(z);
    Y.transform.worldTransform = this.transform.worldTransform, Y.anchor.x = -(D.x / D.width), Y.anchor.y = -(D.y / D.height), Y.alpha = r, Y._bounds = this._bounds, this._cacheData.sprite = Y, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = Y.containsPoint.bind(Y);
  }
};
DisplayObject.prototype._renderCachedCanvas = function(t) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t));
};
DisplayObject.prototype._initCachedDisplayObjectCanvas = function(t) {
  if (!(this._cacheData && this._cacheData.sprite)) {
    var e = this.getLocalBounds(null, !0), r = this.alpha;
    this.alpha = 1;
    var D = t.context, N = t._projTransform;
    e.ceil(settings.RESOLUTION);
    var k = RenderTexture.create({ width: e.width, height: e.height }), $ = "cacheAsBitmap_" + uid();
    this._cacheData.textureCacheId = $, BaseTexture.addToCache(k.baseTexture, $), Texture.addToCache(k, $);
    var G = _tempMatrix;
    this.transform.localTransform.copyTo(G), G.invert(), G.tx -= e.x, G.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, { renderTexture: k, clear: !0, transform: G, skipUpdateTransform: !1 }), t.context = D, t._projTransform = N, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r;
    var U = new Sprite(k);
    U.transform.worldTransform = this.transform.worldTransform, U.anchor.x = -(e.x / e.width), U.anchor.y = -(e.y / e.height), U.alpha = r, U._bounds = this._bounds, this._cacheData.sprite = U, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = U.containsPoint.bind(U);
  }
};
DisplayObject.prototype._calculateCachedBounds = function() {
  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;
};
DisplayObject.prototype._getCachedLocalBounds = function() {
  return this._cacheData.sprite.getLocalBounds(null);
};
DisplayObject.prototype._destroyCachedDisplayObject = function() {
  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, BaseTexture.removeFromCache(this._cacheData.textureCacheId), Texture.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;
};
DisplayObject.prototype._cacheAsBitmapDestroy = function(t) {
  this.cacheAsBitmap = !1, this.destroy(t);
};
/*!
 * @pixi/mixin-get-child-by-name - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.name = null;
Container.prototype.getChildByName = function(t, e) {
  for (var r = 0, D = this.children.length; r < D; r++)
    if (this.children[r].name === t)
      return this.children[r];
  if (e)
    for (var r = 0, D = this.children.length; r < D; r++) {
      var N = this.children[r];
      if (N.getChildByName) {
        var k = N.getChildByName(t, !0);
        if (k)
          return k;
      }
    }
  return null;
};
/*!
 * @pixi/mixin-get-global-position - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.getGlobalPosition = function(t, e) {
  return t === void 0 && (t = new Point()), e === void 0 && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t;
};
/*!
 * @pixi/app - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/app is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ResizePlugin = (
  /** @class */
  function() {
    function o() {
    }
    return o.init = function(t) {
      var e = this;
      Object.defineProperty(
        this,
        "resizeTo",
        /**
         * The HTML element or window to automatically resize the
         * renderer's view element to match width and height.
         * @member {Window|HTMLElement}
         * @name resizeTo
         * @memberof PIXI.Application#
         */
        {
          set: function(r) {
            globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = r, r && (globalThis.addEventListener("resize", this.queueResize), this.resize());
          },
          get: function() {
            return this._resizeTo;
          }
        }
      ), this.queueResize = function() {
        e._resizeTo && (e.cancelResize(), e._resizeId = requestAnimationFrame(function() {
          return e.resize();
        }));
      }, this.cancelResize = function() {
        e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null);
      }, this.resize = function() {
        if (e._resizeTo) {
          e.cancelResize();
          var r, D;
          if (e._resizeTo === globalThis.window)
            r = globalThis.innerWidth, D = globalThis.innerHeight;
          else {
            var N = e._resizeTo, k = N.clientWidth, $ = N.clientHeight;
            r = k, D = $;
          }
          e.renderer.resize(r, D);
        }
      }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;
    }, o.destroy = function() {
      globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
    }, o.extension = ExtensionType.Application, o;
  }()
), Application = (
  /** @class */
  function() {
    function o(t) {
      var e = this;
      this.stage = new Container(), t = Object.assign({
        forceCanvas: !1
      }, t), this.renderer = autoDetectRenderer(t), o._plugins.forEach(function(r) {
        r.init.call(e, t);
      });
    }
    return o.registerPlugin = function(t) {
      deprecation("6.5.0", "Application.registerPlugin() is deprecated, use extensions.add()"), extensions.add({
        type: ExtensionType.Application,
        ref: t
      });
    }, o.prototype.render = function() {
      this.renderer.render(this.stage);
    }, Object.defineProperty(o.prototype, "view", {
      /**
       * Reference to the renderer's canvas element.
       * @member {HTMLCanvasElement}
       * @readonly
       */
      get: function() {
        return this.renderer.view;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "screen", {
      /**
       * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
       * @member {PIXI.Rectangle}
       * @readonly
       */
      get: function() {
        return this.renderer.screen;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.destroy = function(t, e) {
      var r = this, D = o._plugins.slice(0);
      D.reverse(), D.forEach(function(N) {
        N.destroy.call(r);
      }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;
    }, o._plugins = [], o;
  }()
);
extensions.handleByList(ExtensionType.Application, Application._plugins);
extensions.add(ResizePlugin);
/*!
 * @pixi/mesh-extras - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/mesh-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$7 = function(o, t) {
  return extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$7(o, t);
};
function __extends$7(o, t) {
  extendStatics$7(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var PlaneGeometry = (
  /** @class */
  function(o) {
    __extends$7(t, o);
    function t(e, r, D, N) {
      e === void 0 && (e = 100), r === void 0 && (r = 100), D === void 0 && (D = 10), N === void 0 && (N = 10);
      var k = o.call(this) || this;
      return k.segWidth = D, k.segHeight = N, k.width = e, k.height = r, k.build(), k;
    }
    return t.prototype.build = function() {
      for (var e = this.segWidth * this.segHeight, r = [], D = [], N = [], k = this.segWidth - 1, $ = this.segHeight - 1, G = this.width / k, U = this.height / $, z = 0; z < e; z++) {
        var X = z % this.segWidth, V = z / this.segWidth | 0;
        r.push(X * G, V * U), D.push(X / k, V / $);
      }
      for (var Y = k * $, z = 0; z < Y; z++) {
        var W = z % k, q = z / k | 0, K = q * this.segWidth + W, Z = q * this.segWidth + W + 1, J = (q + 1) * this.segWidth + W, Q = (q + 1) * this.segWidth + W + 1;
        N.push(K, Z, J, Z, Q, J);
      }
      this.buffers[0].data = new Float32Array(r), this.buffers[1].data = new Float32Array(D), this.indexBuffer.data = new Uint16Array(N), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
    }, t;
  }(MeshGeometry)
), RopeGeometry = (
  /** @class */
  function(o) {
    __extends$7(t, o);
    function t(e, r, D) {
      e === void 0 && (e = 200), D === void 0 && (D = 0);
      var N = o.call(this, new Float32Array(r.length * 4), new Float32Array(r.length * 4), new Uint16Array((r.length - 1) * 6)) || this;
      return N.points = r, N._width = e, N.textureScale = D, N.build(), N;
    }
    return Object.defineProperty(t.prototype, "width", {
      /**
       * The width (i.e., thickness) of the rope.
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.build = function() {
      var e = this.points;
      if (e) {
        var r = this.getBuffer("aVertexPosition"), D = this.getBuffer("aTextureCoord"), N = this.getIndex();
        if (!(e.length < 1)) {
          r.data.length / 4 !== e.length && (r.data = new Float32Array(e.length * 4), D.data = new Float32Array(e.length * 4), N.data = new Uint16Array((e.length - 1) * 6));
          var k = D.data, $ = N.data;
          k[0] = 0, k[1] = 0, k[2] = 0, k[3] = 1;
          for (var G = 0, U = e[0], z = this._width * this.textureScale, X = e.length, V = 0; V < X; V++) {
            var Y = V * 4;
            if (this.textureScale > 0) {
              var W = U.x - e[V].x, q = U.y - e[V].y, K = Math.sqrt(W * W + q * q);
              U = e[V], G += K / z;
            } else
              G = V / (X - 1);
            k[Y] = G, k[Y + 1] = 0, k[Y + 2] = G, k[Y + 3] = 1;
          }
          for (var Z = 0, V = 0; V < X - 1; V++) {
            var Y = V * 2;
            $[Z++] = Y, $[Z++] = Y + 1, $[Z++] = Y + 2, $[Z++] = Y + 2, $[Z++] = Y + 1, $[Z++] = Y + 3;
          }
          D.update(), N.update(), this.updateVertices();
        }
      }
    }, t.prototype.updateVertices = function() {
      var e = this.points;
      if (!(e.length < 1)) {
        for (var r = e[0], D, N = 0, k = 0, $ = this.buffers[0].data, G = e.length, U = 0; U < G; U++) {
          var z = e[U], X = U * 4;
          U < e.length - 1 ? D = e[U + 1] : D = z, k = -(D.x - r.x), N = D.y - r.y;
          var V = Math.sqrt(N * N + k * k), Y = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
          N /= V, k /= V, N *= Y, k *= Y, $[X] = z.x + N, $[X + 1] = z.y + k, $[X + 2] = z.x - N, $[X + 3] = z.y - k, r = z;
        }
        this.buffers[0].update();
      }
    }, t.prototype.update = function() {
      this.textureScale > 0 ? this.build() : this.updateVertices();
    }, t;
  }(MeshGeometry)
);
(function(o) {
  __extends$7(t, o);
  function t(e, r, D) {
    D === void 0 && (D = 0);
    var N = this, k = new RopeGeometry(e.height, r, D), $ = new MeshMaterial(e);
    return D > 0 && (e.baseTexture.wrapMode = WRAP_MODES.REPEAT), N = o.call(this, k, $) || this, N.autoUpdate = !0, N;
  }
  return t.prototype._render = function(e) {
    var r = this.geometry;
    (this.autoUpdate || r._width !== this.shader.texture.height) && (r._width = this.shader.texture.height, r.update()), o.prototype._render.call(this, e);
  }, t;
})(Mesh);
var SimplePlane = (
  /** @class */
  function(o) {
    __extends$7(t, o);
    function t(e, r, D) {
      var N = this, k = new PlaneGeometry(e.width, e.height, r, D), $ = new MeshMaterial(Texture.WHITE);
      return N = o.call(this, k, $) || this, N.texture = e, N.autoResize = !0, N;
    }
    return t.prototype.textureUpdated = function() {
      this._textureID = this.shader.texture._updateID;
      var e = this.geometry, r = this.shader.texture, D = r.width, N = r.height;
      this.autoResize && (e.width !== D || e.height !== N) && (e.width = this.shader.texture.width, e.height = this.shader.texture.height, e.build());
    }, Object.defineProperty(t.prototype, "texture", {
      get: function() {
        return this.shader.texture;
      },
      set: function(e) {
        this.shader.texture !== e && (this.shader.texture = e, this._textureID = -1, e.baseTexture.valid ? this.textureUpdated() : e.once("update", this.textureUpdated, this));
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype._render = function(e) {
      this._textureID !== this.shader.texture._updateID && this.textureUpdated(), o.prototype._render.call(this, e);
    }, t.prototype.destroy = function(e) {
      this.shader.texture.off("update", this.textureUpdated, this), o.prototype.destroy.call(this, e);
    }, t;
  }(Mesh)
);
(function(o) {
  __extends$7(t, o);
  function t(e, r, D, N, k) {
    e === void 0 && (e = Texture.EMPTY);
    var $ = this, G = new MeshGeometry(r, D, N);
    G.getBuffer("aVertexPosition").static = !1;
    var U = new MeshMaterial(e);
    return $ = o.call(this, G, U, null, k) || this, $.autoUpdate = !0, $;
  }
  return Object.defineProperty(t.prototype, "vertices", {
    /**
     * Collection of vertices data.
     * @type {Float32Array}
     */
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(e) {
      this.geometry.getBuffer("aVertexPosition").data = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._render = function(e) {
    this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), o.prototype._render.call(this, e);
  }, t;
})(Mesh);
var DEFAULT_BORDER_SIZE = 10;
(function(o) {
  __extends$7(t, o);
  function t(e, r, D, N, k) {
    r === void 0 && (r = DEFAULT_BORDER_SIZE), D === void 0 && (D = DEFAULT_BORDER_SIZE), N === void 0 && (N = DEFAULT_BORDER_SIZE), k === void 0 && (k = DEFAULT_BORDER_SIZE);
    var $ = o.call(this, Texture.WHITE, 4, 4) || this;
    return $._origWidth = e.orig.width, $._origHeight = e.orig.height, $._width = $._origWidth, $._height = $._origHeight, $._leftWidth = r, $._rightWidth = N, $._topHeight = D, $._bottomHeight = k, $.texture = e, $;
  }
  return t.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID, this._refresh();
  }, Object.defineProperty(t.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(e) {
      this.geometry.getBuffer("aVertexPosition").data = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.updateHorizontalVertices = function() {
    var e = this.vertices, r = this._getMinScale();
    e[9] = e[11] = e[13] = e[15] = this._topHeight * r, e[17] = e[19] = e[21] = e[23] = this._height - this._bottomHeight * r, e[25] = e[27] = e[29] = e[31] = this._height;
  }, t.prototype.updateVerticalVertices = function() {
    var e = this.vertices, r = this._getMinScale();
    e[2] = e[10] = e[18] = e[26] = this._leftWidth * r, e[4] = e[12] = e[20] = e[28] = this._width - this._rightWidth * r, e[6] = e[14] = e[22] = e[30] = this._width;
  }, t.prototype._getMinScale = function() {
    var e = this._leftWidth + this._rightWidth, r = this._width > e ? 1 : this._width / e, D = this._topHeight + this._bottomHeight, N = this._height > D ? 1 : this._height / D, k = Math.min(r, N);
    return k;
  }, Object.defineProperty(t.prototype, "width", {
    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    get: function() {
      return this._width;
    },
    set: function(e) {
      this._width = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    get: function() {
      return this._height;
    },
    set: function(e) {
      this._height = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "leftWidth", {
    /** The width of the left column. */
    get: function() {
      return this._leftWidth;
    },
    set: function(e) {
      this._leftWidth = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "rightWidth", {
    /** The width of the right column. */
    get: function() {
      return this._rightWidth;
    },
    set: function(e) {
      this._rightWidth = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "topHeight", {
    /** The height of the top row. */
    get: function() {
      return this._topHeight;
    },
    set: function(e) {
      this._topHeight = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "bottomHeight", {
    /** The height of the bottom row. */
    get: function() {
      return this._bottomHeight;
    },
    set: function(e) {
      this._bottomHeight = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._refresh = function() {
    var e = this.texture, r = this.geometry.buffers[1].data;
    this._origWidth = e.orig.width, this._origHeight = e.orig.height;
    var D = 1 / this._origWidth, N = 1 / this._origHeight;
    r[0] = r[8] = r[16] = r[24] = 0, r[1] = r[3] = r[5] = r[7] = 0, r[6] = r[14] = r[22] = r[30] = 1, r[25] = r[27] = r[29] = r[31] = 1, r[2] = r[10] = r[18] = r[26] = D * this._leftWidth, r[4] = r[12] = r[20] = r[28] = 1 - D * this._rightWidth, r[9] = r[11] = r[13] = r[15] = N * this._topHeight, r[17] = r[19] = r[21] = r[23] = 1 - N * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();
  }, t;
})(SimplePlane);
/*!
 * @pixi/sprite-animated - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/sprite-animated is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$6 = function(o, t) {
  return extendStatics$6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$6(o, t);
};
function __extends$6(o, t) {
  extendStatics$6(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var AnimatedSprite = (
  /** @class */
  function(o) {
    __extends$6(t, o);
    function t(e, r) {
      r === void 0 && (r = !0);
      var D = o.call(this, e[0] instanceof Texture ? e[0] : e[0].texture) || this;
      return D._textures = null, D._durations = null, D._autoUpdate = r, D._isConnectedToTicker = !1, D.animationSpeed = 1, D.loop = !0, D.updateAnchor = !1, D.onComplete = null, D.onFrameChange = null, D.onLoop = null, D._currentTime = 0, D._playing = !1, D._previousFrame = null, D.textures = e, D;
    }
    return t.prototype.stop = function() {
      this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1));
    }, t.prototype.play = function() {
      this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH), this._isConnectedToTicker = !0));
    }, t.prototype.gotoAndStop = function(e) {
      this.stop();
      var r = this.currentFrame;
      this._currentTime = e, r !== this.currentFrame && this.updateTexture();
    }, t.prototype.gotoAndPlay = function(e) {
      var r = this.currentFrame;
      this._currentTime = e, r !== this.currentFrame && this.updateTexture(), this.play();
    }, t.prototype.update = function(e) {
      if (this._playing) {
        var r = this.animationSpeed * e, D = this.currentFrame;
        if (this._durations !== null) {
          var N = this._currentTime % 1 * this._durations[this.currentFrame];
          for (N += r / 60 * 1e3; N < 0; )
            this._currentTime--, N += this._durations[this.currentFrame];
          var k = Math.sign(this.animationSpeed * e);
          for (this._currentTime = Math.floor(this._currentTime); N >= this._durations[this.currentFrame]; )
            N -= this._durations[this.currentFrame] * k, this._currentTime += k;
          this._currentTime += N / this._durations[this.currentFrame];
        } else
          this._currentTime += r;
        this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : D !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < D ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > D && this.onLoop()), this.updateTexture());
      }
    }, t.prototype.updateTexture = function() {
      var e = this.currentFrame;
      this._previousFrame !== e && (this._previousFrame = e, this._texture = this._textures[e], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));
    }, t.prototype.destroy = function(e) {
      this.stop(), o.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;
    }, t.fromFrames = function(e) {
      for (var r = [], D = 0; D < e.length; ++D)
        r.push(Texture.from(e[D]));
      return new t(r);
    }, t.fromImages = function(e) {
      for (var r = [], D = 0; D < e.length; ++D)
        r.push(Texture.from(e[D]));
      return new t(r);
    }, Object.defineProperty(t.prototype, "totalFrames", {
      /**
       * The total number of frames in the AnimatedSprite. This is the same as number of textures
       * assigned to the AnimatedSprite.
       * @readonly
       * @default 0
       */
      get: function() {
        return this._textures.length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "textures", {
      /** The array of textures used for this AnimatedSprite. */
      get: function() {
        return this._textures;
      },
      set: function(e) {
        if (e[0] instanceof Texture)
          this._textures = e, this._durations = null;
        else {
          this._textures = [], this._durations = [];
          for (var r = 0; r < e.length; r++)
            this._textures.push(e[r].texture), this._durations.push(e[r].time);
        }
        this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "currentFrame", {
      /**
       * The AnimatedSprites current frame index.
       * @readonly
       */
      get: function() {
        var e = Math.floor(this._currentTime) % this._textures.length;
        return e < 0 && (e += this._textures.length), e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "playing", {
      /**
       * Indicates if the AnimatedSprite is currently playing.
       * @readonly
       */
      get: function() {
        return this._playing;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "autoUpdate", {
      /** Whether to use PIXI.Ticker.shared to auto update animation time. */
      get: function() {
        return this._autoUpdate;
      },
      set: function(e) {
        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Sprite)
);
/*!
 * pixi.js - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
extensions.add(
  // Install renderer plugins
  AccessibilityManager,
  Extract,
  InteractionManager,
  ParticleRenderer,
  Prepare,
  BatchRenderer,
  TilingSpriteRenderer,
  // Install loader plugins
  BitmapFontLoader,
  CompressedTextureLoader,
  DDSLoader,
  KTXLoader,
  SpritesheetLoader,
  // Install application plugins
  TickerPlugin,
  AppLoaderPlugin
);
var Ni;
class EventListenerCtn {
  constructor() {
    // リソースリーク対策
    rt(this, Ni, []);
  }
  add(t, e, r, D = {}) {
    if (t instanceof BaseTexture) {
      switch (e) {
        case "loaded":
        case "update":
        case "error":
        case "dispose":
          t.on(e, r, D), H(this, Ni).push(() => t.off(e, r, D));
          break;
      }
      return;
    }
    if (t instanceof i$1) {
      t.on(e, r, D), H(this, Ni).push(() => t.off(e, r, D));
      return;
    }
    t.addEventListener(e, r, D), H(this, Ni).push(() => t.removeEventListener(e, r, { capture: D.capture ?? !1 }));
  }
  clear() {
    for (const t of H(this, Ni))
      t();
    ot(this, Ni, []);
  }
}
Ni = new WeakMap();
var SEARCH_PATH_ARG_EXT = /* @__PURE__ */ ((o) => (o.DEFAULT = "", o.SP_GSM = "png|jpg|jpeg|json|svg|webp|mp4|webm", o.SCRIPT = "sn|ssn", o.FONT = "woff2|woff|otf|ttf", o.SOUND = "mp3|m4a|ogg|aac|flac|wav", o.HTML = "htm|html", o.CSS = "css", o.SN = "sn", o.PSD = "psd", o.TST_PNGPNG_ = "png|png_", o.TST_HH = "hh", o.TST_EEE = "eee", o.TST_GGG = "ggg", o.TST_PNGXML = "png|xml", o))(SEARCH_PATH_ARG_EXT || {}), ro, io, Eu;
class ConfigBase {
  constructor(t) {
    It(this, "oCfg", {
      save_ns: "",
      // 扱うセーブデータを一意に識別するキーワード文字列
      window: {
        // アプリケーションウインドウサイズ
        width: 300,
        height: 300
      },
      book: {
        // プロジェクトの詳細情報です
        title: "",
        //作品タイトル
        creator: "",
        //著作者。同人ならペンネーム
        cre_url: "",
        //著作者URL。ツイッターやメール、サイトなど
        publisher: "",
        //出版社。同人ならサークル名
        pub_url: "",
        //出版社URL。無ければ省略します
        detail: "",
        // 内容紹介。端的に記入
        version: "1.0"
      },
      log: { max_len: 1024 },
      // プレイヤーが読んだ文章を読み返せる履歴の長さ
      init: {
        bg_color: "#000000",
        // 背景色
        tagch_msecwait: 10,
        // 通常文字表示待ち時間（未読／既読）
        auto_msecpagewait: 3500,
        // 自動文字表示、行クリック待ち時間（未読／既読）
        escape: ""
        // エスケープ文字
      },
      debug: {
        devtool: !1,
        token: !1,
        tag: !1,
        putCh: !1,
        debugLog: !1,
        baseTx: !1,
        masume: !1,
        // テキストレイヤ：ガイドマス目を表示するか
        variable: !1
      },
      code: {},
      // 暗号化しないフォルダ
      debuger_token: ""
      // デバッガとの接続トークン
    });
    It(this, "userFnTail", "");
    // 4tst public
    It(this, "hPathFn2Exts", {});
    rt(this, ro, !1);
    rt(this, io, !1);
    rt(this, Eu, /([^\/\s]+)\.([^\d]\w+)/);
    this.sys = t;
  }
  async load(t) {
    var e, r, D, N;
    if (this.oCfg.save_ns = (t == null ? void 0 : t.save_ns) ?? this.oCfg.save_ns, this.oCfg.window.width = Number(((e = t == null ? void 0 : t.window) == null ? void 0 : e.width) ?? this.oCfg.window.width), this.oCfg.window.height = Number(((r = t == null ? void 0 : t.window) == null ? void 0 : r.height) ?? this.oCfg.window.height), this.oCfg.book = { ...this.oCfg.book, ...t.book }, this.oCfg.log.max_len = ((N = (D = t.log) == null ? void 0 : D.max_len) == null ? void 0 : N.max_len) ?? this.oCfg.log.max_len, this.oCfg.init = { ...this.oCfg.init, ...t.init }, this.oCfg.debug = { ...this.oCfg.debug, ...t.debug }, this.oCfg.debuger_token = t.debuger_token, await this.sys.loadPath(this.hPathFn2Exts, this), ot(this, ro, this.matchPath(
      "^breakline$",
      "png|jpg|jpeg|json|svg|webp|mp4|webm"
      /* SP_GSM */
    ).length > 0), ot(this, io, this.matchPath(
      "^breakpage$",
      "png|jpg|jpeg|json|svg|webp|mp4|webm"
      /* SP_GSM */
    ).length > 0), !!this.sys.crypto)
      for (const k of Object.values(this.hPathFn2Exts))
        for (const [$, G] of Object.entries(k)) {
          if ($.slice(-10) !== ":RIPEMD160")
            continue;
          const U = G.slice(G.lastIndexOf("/") + 1), z = k[$.slice(0, -10)], V = await (await this.sys.fetch(z)).text(), Y = this.sys.hash(V);
          if (U !== Y)
            throw `ファイル改竄エラーです fn:${z}`;
        }
  }
  get existsBreakline() {
    return H(this, ro);
  }
  get existsBreakpage() {
    return H(this, io);
  }
  getNs() {
    return `skynovel.${this.oCfg.save_ns} - `;
  }
  // 4 match 498 step(~1ms)  https://regex101.com/r/tpVgmI/1
  searchPath(t, e = "") {
    if (!t)
      throw "[searchPath] fnが空です";
    if (t.slice(0, 7) === "http://")
      return t;
    const r = t.match(H(this, Eu));
    let D = r ? r[1] : t;
    const N = r ? r[2] : "";
    if (this.userFnTail) {
      const G = D + "@@" + this.userFnTail;
      if (G in this.hPathFn2Exts) {
        if (e === "")
          D = G;
        else
          for (const U of Object.keys(this.hPathFn2Exts[G]))
            if (`|${e}|`.indexOf(`|${U}|`) !== -1) {
              D = G;
              break;
            }
      }
    }
    const k = this.hPathFn2Exts[D];
    if (!k)
      throw `サーチパスに存在しないファイル【${t}】です`;
    let $ = "";
    if (!N) {
      const G = int(k[":cnt"]);
      if (e === "") {
        if (G > 1)
          throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;
        return t;
      }
      const U = `|${e}|`;
      if (G > 1) {
        let z = 0;
        for (const X of Object.keys(k))
          if (U.indexOf(`|${X}|`) !== -1 && ++z > 1)
            throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;
      }
      for (let z of Object.keys(k))
        if (U.indexOf(`|${z}|`) > -1)
          return k[z];
      throw `サーチ対象拡張子群【${e}】にマッチするファイルがサーチパスに存在しません。探索ファイル名=【${t}】`;
    }
    if (e !== "" && `|${e}|`.indexOf(`|${N}|`) === -1)
      throw `指定ファイルの拡張子【${N}】は、サーチ対象拡張子群【${e}】にマッチしません。探索ファイル名=【${t}】`;
    if ($ = k[N], !$)
      throw `サーチパスに存在しない拡張子【${N}】です。探索ファイル名=【${t}】、サーチ対象拡張子群【${e}】`;
    return $;
  }
  matchPath(t, e = "") {
    const r = [], D = new RegExp(t), N = new RegExp(e);
    for (const [k, $] of Object.entries(this.hPathFn2Exts)) {
      if (k.search(D) === -1)
        continue;
      if (e === "") {
        r.push($);
        continue;
      }
      const G = {};
      let U = !1;
      for (const z of Object.keys($))
        z.search(N) !== -1 && (G[z] = k, U = !0);
      U && r.push(G);
    }
    return r;
  }
  addPath(t, e) {
    const r = {};
    for (const [D, N] of Object.entries(e))
      r[D] = (D.at(0) === ":" ? "" : this.sys.cur) + N;
    this.hPathFn2Exts[t] = r;
  }
}
ro = new WeakMap(), io = new WeakMap(), Eu = new WeakMap();
class Config extends ConfigBase {
  constructor(t) {
    super(t), this.sys = t;
  }
  static async generate(t) {
    const e = new Config(t), r = t.cur + "prj.json", D = await (await t.fetch(r)).text(), N = JSON.parse(t.decStr(r, D));
    return await e.load(N), e;
  }
  async load(t) {
    await super.load(t), CmnLib.stageW = this.oCfg.window.width, CmnLib.stageH = this.oCfg.window.height, CmnLib.debugLog = this.oCfg.debug.debugLog;
  }
  searchPath(t, e = SEARCH_PATH_ARG_EXT.DEFAULT) {
    return t.slice(0, 11) === "downloads:/" ? this.sys.path_downloads + t.slice(11) : t.slice(0, 10) === "userdata:/" ? this.sys.path_userdata + "storage/" + t.slice(10) : super.searchPath(t, e);
  }
}
const REG_TAG = /(?<name>[^\s;\]]+)/;
function tagToken2Name_Args(o) {
  const t = REG_TAG.exec(o.slice(1, -1)), e = t == null ? void 0 : t.groups;
  if (!e)
    throw `タグ記述【${o}】異常です(タグ解析)`;
  const r = e.name;
  return [r, o.slice(1 + r.length, -1)];
}
function tagToken2Name(o) {
  const t = REG_TAG.exec(o.slice(1)), e = t == null ? void 0 : t.groups;
  if (!e)
    throw `タグ記述【${o}】異常です(タグ解析)`;
  return e.name;
}
function splitAmpersand(o) {
  const t = o.replaceAll("==", "＝").replaceAll("!=", "≠").split("="), e = t.length;
  if (e < 2 || e > 3)
    throw "「&計算」書式では「=」指定が一つか二つ必要です";
  if (t[1].at(0) === "&")
    throw "「&計算」書式では「&」指定が不要です";
  return {
    name: t[0].replaceAll("＝", "==").replaceAll("≠", "!="),
    text: t[1].replaceAll("＝", "==").replaceAll("≠", "!="),
    cast: e === 3 ? t[2].trim() : void 0
  };
}
var hn, cn, no, so, ao, Ye, oo, Os, nu;
class Grammar {
  constructor() {
    rt(this, Os);
    rt(this, hn, void 0);
    rt(this, cn, void 0);
    rt(this, no, new RegExp(""));
    rt(this, so, "");
    rt(this, ao, "");
    rt(this, Ye, void 0);
    rt(this, oo, void 0);
    this.setEscape("");
  }
  setEscape(t) {
    if (H(this, Ye) && t in H(this, Ye))
      throw "[エスケープ文字] char【" + t + "】が登録済みの括弧マクロまたは一文字マクロです";
    ot(this, hn, new RegExp(
      (t ? `\\${t}\\S|` : "") + // エスケープシーケンス
      `\\n+|\\t+|\\[let_ml\\s+[^\\]]+\\].+?(?=\\[endlet_ml[\\]\\s])|\\[(?:(?=([^"'#;\\]]+))\\1|(["'#]).*?\\2|;[^\\n]*)*?]|;[^\\n]*|&[^&\\n]+&|&&?[^&;\\n\\t]+|^\\*[^\\s\\[&;\\\\]+|[^\\n\\t\\[;${t ? `\\${t}` : ""}]+`,
      // 本文
      "gs"
    )), ot(this, cn, new RegExp(`[\\w\\s;[\\]*=&｜《》${t ? `\\${t}` : ""}]`)), ot(this, oo, new RegExp(`[\\n\\t;\\[*&${t ? `\\${t}` : ""}]`));
  }
  // 括弧マクロの定義
  bracket2macro(t, e, r, D) {
    const { name: N, text: k } = t;
    if (!N)
      throw "[bracket2macro] nameは必須です";
    if (!k)
      throw "[bracket2macro] textは必須です";
    const $ = k.at(0);
    if (!$)
      throw "[bracket2macro] textは必須です";
    if (k.length !== 2)
      throw "[bracket2macro] textは括弧の前後を示す二文字を指定してください";
    if (!(N in e))
      throw `[bracket2macro] 未定義のタグ又はマクロ[${N}]です`;
    H(this, Ye) ?? ot(this, Ye, {});
    const G = k.charAt(1);
    if ($ in H(this, Ye))
      throw "[bracket2macro] text【" + $ + "】が登録済みの括弧マクロまたは一文字マクロです";
    if (G in H(this, Ye))
      throw "[bracket2macro] text【" + G + "】が登録済みの括弧マクロまたは一文字マクロです";
    if (H(this, cn).test($))
      throw "[bracket2macro] text【" + $ + "】は括弧マクロに使用できない文字です";
    if (H(this, cn).test(G))
      throw "[bracket2macro] text【" + G + "】は括弧マクロに使用できない文字です";
    H(this, Ye)[G] = "0", H(this, Ye)[$] = `[${N} text=`, this.addC2M(`\\${$}[^\\${G}]*\\${G}`, `\\${$}\\${G}`), lt(this, Os, nu).call(this, r, D);
  }
  // 一文字マクロの定義
  char2macro(t, e, r, D) {
    const { char: N, name: k } = t;
    if (!N)
      throw "[char2macro] charは必須です";
    if (H(this, Ye) ?? ot(this, Ye, {}), N in H(this, Ye))
      throw "[char2macro] char【" + N + "】が登録済みの括弧マクロまたは一文字マクロです";
    if (H(this, cn).test(N))
      throw "[char2macro] char【" + N + "】は一文字マクロに使用できない文字です";
    if (!k)
      throw "[char2macro] nameは必須です";
    if (!(k in e))
      throw `[char2macro] 未定義のタグ又はマクロ[${k}]です`;
    H(this, Ye)[N] = `[${k}]`, this.addC2M(`\\${N}`, `\\${N}`), lt(this, Os, nu).call(this, r, D);
  }
  addC2M(t, e) {
    ot(this, so, H(this, so) + `${t}|`), ot(this, ao, H(this, ao) + `${e}`), ot(this, no, new RegExp(
      `(${H(this, so)}[^${H(this, ao)}]+)`,
      "g"
    ));
  }
  resolveScript(t) {
    var D;
    const e = ((D = t.replaceAll(/(\r\n|\r)/g, `
`).match(H(this, hn))) == null ? void 0 : D.flatMap((N) => {
      if (!this.testTagLetml(N))
        return N;
      const k = /^([^\]]+?])(.*)$/s.exec(N);
      if (!k)
        return N;
      const [, $, G] = k;
      return [$, G];
    })) ?? [], r = { aToken: e, len: e.length, aLNum: [] };
    return lt(this, Os, nu).call(this, r), r;
  }
  testTagLetml(t) {
    return /^\[let_ml\s/.test(t);
  }
  testTagEndLetml(t) {
    return /^\[endlet_ml\s*]/.test(t);
  }
  analyzToken(t) {
    return H(this, hn).lastIndex = 0, H(this, hn).exec(t);
  }
  testNoTxt(t) {
    return H(this, oo).test(t);
  }
  //4tst
}
hn = new WeakMap(), cn = new WeakMap(), no = new WeakMap(), so = new WeakMap(), ao = new WeakMap(), Ye = new WeakMap(), oo = new WeakMap(), Os = new WeakSet(), nu = function(t, e = 0) {
  if (H(this, Ye)) {
    for (let r = t.len - 1; r >= e; --r) {
      const D = t.aToken[r];
      if (this.testNoTxt(D.at(0) ?? `
`))
        continue;
      const N = t.aLNum[r], k = D.match(H(this, no));
      if (!k)
        continue;
      let $ = 1;
      for (let G = k.length - 1; G >= 0; --G) {
        let U = k[G];
        const z = H(this, Ye)[U.at(0) ?? " "];
        z && (U = z + (z.at(-1) === "]" ? "" : `'${U.slice(1, -1)}']`)), t.aToken.splice(r, $, U), t.aLNum.splice(r, $, N), $ = 0;
      }
    }
    t.len = t.aToken.length;
  }
};
var lo, Is, su, fn, Ds;
class AnalyzeTagArg {
  constructor() {
    rt(this, Is);
    // 87 match 2725 step(0.5ms) PCRE2 https://regex101.com/r/aeN57J/1
    /*
    ;[^\n]*
    |	(?<key>[^\s="'#|;]+)
    	(?: \s | ;[^\n]*\n)*
    	=
    	(?: \s | ;[^\n]*\n)*
    	(?:	(?<val> [^\s"'#|;]+)
    	|	(["'#]) (?<val2>.*?) \3 )
    	(?: \|
    		(?: (?<def> [^\s"'#;]+)
    	|	(["'#]) (?<def2>.*?) \6 ) )?
    |	(?<literal>[^\s;]+)
    	*/
    rt(this, lo, /;[^\n]*|(?<key>[^\s="'#|;]+)(?:\s|;[^\n]*\n)*=(?:\s|;[^\n]*\n)*(?:(?<val>[^\s"'#|;]+)|(["'#])(?<val2>.*?)\3)(?:\|(?:(?<def>[^\s"'#;]+)|(["'#])(?<def2>.*?)\6))?|(?<literal>[^\s;]+)/g);
    rt(this, fn, {});
    rt(this, Ds, !1);
  }
  // 【属性 = 値 | 省略値】の分析
  parse(t) {
    ot(this, fn, {}), ot(this, Ds, !1);
    for (const { groups: e } of t.matchAll(H(this, lo))) {
      const { key: r, val: D, val2: N, def: k, def2: $, literal: G } = e;
      r ? H(this, fn)[r] = {
        val: D ?? N,
        def: k ?? $
      } : G && (G === "*" ? ot(this, Ds, !0) : H(this, fn)[G] = { val: "1" });
    }
  }
  // 属性と値の位置をまとめて返す
  parseinDetail(t, e, r, D) {
    const N = {}, k = t.slice(1 + e, -1);
    for (const { groups: $, index: G, 0: U } of k.matchAll(H(this, lo))) {
      if (G === void 0)
        continue;
      const { key: z, val: X, val2: V, literal: Y } = $;
      if (Y) {
        if (Y.at(-1) === "=") {
          const J = Y.length - 1, { ch: Q } = lt(this, Is, su).call(this, e, r, D, k, G + J);
          N[Y.slice(0, -1)] = {
            k_ln: r,
            k_ch: Q - J,
            v_ln: r,
            v_ch: Q + 1,
            //	v_ch: ch +1+lenNm +literal.length +1,
            v_len: 0
          };
        }
        continue;
      }
      if (!z)
        continue;
      const { ln: W, ch: q } = lt(this, Is, su).call(this, e, r, D, k, G), { ln: K, ch: Z } = lt(this, Is, su).call(this, e, r, D, k, G + U.lastIndexOf(X ?? V) - (X ? 0 : 1));
      N[z] = { k_ln: W, k_ch: q, v_ln: K, v_ch: Z, v_len: X ? X.length : V.length + 2 };
    }
    return N;
  }
  get hPrm() {
    return H(this, fn);
  }
  get isKomeParam() {
    return H(this, Ds);
  }
}
lo = new WeakMap(), Is = new WeakSet(), su = function(t, e, r, D, N) {
  const $ = D.slice(0, N).split(`
`), G = $.length;
  return {
    ln: e + G - 1,
    ch: G < 2 ? r + 1 + t + N : $.at(-1).length
  };
}, fn = new WeakMap(), Ds = new WeakMap();
var parsimmon_umd_min = { exports: {} };
(function(o, t) {
  (function(e, r) {
    o.exports = r();
  })(typeof self < "u" ? self : commonjsGlobal, function() {
    return function(e) {
      var r = {};
      function D(N) {
        if (r[N])
          return r[N].exports;
        var k = r[N] = { i: N, l: !1, exports: {} };
        return e[N].call(k.exports, k, k.exports, D), k.l = !0, k.exports;
      }
      return D.m = e, D.c = r, D.d = function(N, k, $) {
        D.o(N, k) || Object.defineProperty(N, k, { configurable: !1, enumerable: !0, get: $ });
      }, D.r = function(N) {
        Object.defineProperty(N, "__esModule", { value: !0 });
      }, D.n = function(N) {
        var k = N && N.__esModule ? function() {
          return N.default;
        } : function() {
          return N;
        };
        return D.d(k, "a", k), k;
      }, D.o = function(N, k) {
        return Object.prototype.hasOwnProperty.call(N, k);
      }, D.p = "", D(D.s = 0);
    }([function(e, r, D) {
      function N(ct) {
        if (!(this instanceof N))
          return new N(ct);
        this._ = ct;
      }
      var k = N.prototype;
      function $(ct, vt) {
        for (var xt = 0; xt < ct; xt++)
          vt(xt);
      }
      function G(ct, vt, xt) {
        return function(Ot, $t) {
          $($t.length, function(Gt) {
            Ot($t[Gt], Gt, $t);
          });
        }(function(Ot, $t, Gt) {
          vt = ct(vt, Ot, $t, Gt);
        }, xt), vt;
      }
      function U(ct, vt) {
        return G(function(xt, Ot, $t, Gt) {
          return xt.concat([ct(Ot, $t, Gt)]);
        }, [], vt);
      }
      function z(ct, vt) {
        var xt = { v: 0, buf: vt };
        return $(ct, function() {
          var Ot;
          xt = { v: xt.v << 1 | (Ot = xt.buf, Ot[0] >> 7), buf: function($t) {
            var Gt = G(function(Ut, ee, Ee, Xe) {
              return Ut.concat(Ee === Xe.length - 1 ? Buffer.from([ee, 0]).readUInt16BE(0) : Xe.readUInt16BE(Ee));
            }, [], $t);
            return Buffer.from(U(function(Ut) {
              return (Ut << 1 & 65535) >> 8;
            }, Gt));
          }(xt.buf) };
        }), xt;
      }
      function X() {
        return typeof Buffer < "u";
      }
      function V() {
        if (!X())
          throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
      }
      function Y(ct) {
        V();
        var vt = G(function(Gt, Ut) {
          return Gt + Ut;
        }, 0, ct);
        if (vt % 8 != 0)
          throw new Error("The bits [" + ct.join(", ") + "] add up to " + vt + " which is not an even number of bytes; the total should be divisible by 8");
        var xt, Ot = vt / 8, $t = (xt = function(Gt) {
          return Gt > 48;
        }, G(function(Gt, Ut) {
          return Gt || (xt(Ut) ? Ut : Gt);
        }, null, ct));
        if ($t)
          throw new Error($t + " bit range requested exceeds 48 bit (6 byte) Number max.");
        return new N(function(Gt, Ut) {
          var ee = Ot + Ut;
          return ee > Gt.length ? st(Ut, Ot.toString() + " bytes") : nt(ee, G(function(Ee, Xe) {
            var Fe = z(Xe, Ee.buf);
            return { coll: Ee.coll.concat(Fe.v), buf: Fe.buf };
          }, { coll: [], buf: Gt.slice(Ut, ee) }, ct).coll);
        });
      }
      function W(ct, vt) {
        return new N(function(xt, Ot) {
          return V(), Ot + vt > xt.length ? st(Ot, vt + " bytes for " + ct) : nt(Ot + vt, xt.slice(Ot, Ot + vt));
        });
      }
      function q(ct, vt) {
        if (typeof (xt = vt) != "number" || Math.floor(xt) !== xt || vt < 0 || vt > 6)
          throw new Error(ct + " requires integer length in range [0, 6].");
        var xt;
      }
      function K(ct) {
        return q("uintBE", ct), W("uintBE(" + ct + ")", ct).map(function(vt) {
          return vt.readUIntBE(0, ct);
        });
      }
      function Z(ct) {
        return q("uintLE", ct), W("uintLE(" + ct + ")", ct).map(function(vt) {
          return vt.readUIntLE(0, ct);
        });
      }
      function J(ct) {
        return q("intBE", ct), W("intBE(" + ct + ")", ct).map(function(vt) {
          return vt.readIntBE(0, ct);
        });
      }
      function Q(ct) {
        return q("intLE", ct), W("intLE(" + ct + ")", ct).map(function(vt) {
          return vt.readIntLE(0, ct);
        });
      }
      function et(ct) {
        return ct instanceof N;
      }
      function it(ct) {
        return {}.toString.call(ct) === "[object Array]";
      }
      function tt(ct) {
        return X() && Buffer.isBuffer(ct);
      }
      function nt(ct, vt) {
        return { status: !0, index: ct, value: vt, furthest: -1, expected: [] };
      }
      function st(ct, vt) {
        return it(vt) || (vt = [vt]), { status: !1, index: -1, value: null, furthest: ct, expected: vt };
      }
      function at(ct, vt) {
        if (!vt || ct.furthest > vt.furthest)
          return ct;
        var xt = ct.furthest === vt.furthest ? function(Ot, $t) {
          if (function() {
            if (N._supportsSet !== void 0)
              return N._supportsSet;
            var ii = typeof Set < "u";
            return N._supportsSet = ii, ii;
          }() && Array.from) {
            for (var Gt = new Set(Ot), Ut = 0; Ut < $t.length; Ut++)
              Gt.add($t[Ut]);
            var ee = Array.from(Gt);
            return ee.sort(), ee;
          }
          for (var Ee = {}, Xe = 0; Xe < Ot.length; Xe++)
            Ee[Ot[Xe]] = !0;
          for (var Fe = 0; Fe < $t.length; Fe++)
            Ee[$t[Fe]] = !0;
          var ri = [];
          for (var nr in Ee)
            ({}).hasOwnProperty.call(Ee, nr) && ri.push(nr);
          return ri.sort(), ri;
        }(ct.expected, vt.expected) : vt.expected;
        return { status: ct.status, index: ct.index, value: ct.value, furthest: vt.furthest, expected: xt };
      }
      var ut = {};
      function ht(ct, vt) {
        if (tt(ct))
          return { offset: vt, line: -1, column: -1 };
        ct in ut || (ut[ct] = {});
        for (var xt = ut[ct], Ot = 0, $t = 0, Gt = 0, Ut = vt; Ut >= 0; ) {
          if (Ut in xt) {
            Ot = xt[Ut].line, Gt === 0 && (Gt = xt[Ut].lineStart);
            break;
          }
          (ct.charAt(Ut) === `
` || ct.charAt(Ut) === "\r" && ct.charAt(Ut + 1) !== `
`) && ($t++, Gt === 0 && (Gt = Ut + 1)), Ut--;
        }
        var ee = Ot + $t, Ee = vt - Gt;
        return xt[vt] = { line: ee, lineStart: Gt }, { offset: vt, line: ee + 1, column: Ee + 1 };
      }
      function dt(ct) {
        if (!et(ct))
          throw new Error("not a parser: " + ct);
      }
      function pt(ct, vt) {
        return typeof ct == "string" ? ct.charAt(vt) : ct[vt];
      }
      function _t(ct) {
        if (typeof ct != "number")
          throw new Error("not a number: " + ct);
      }
      function mt(ct) {
        if (typeof ct != "function")
          throw new Error("not a function: " + ct);
      }
      function yt(ct) {
        if (typeof ct != "string")
          throw new Error("not a string: " + ct);
      }
      var Tt = 2, Pt = 3, St = 8, gt = 5 * St, bt = 4 * St, At = "  ";
      function Rt(ct, vt) {
        return new Array(vt + 1).join(ct);
      }
      function Nt(ct, vt, xt) {
        var Ot = vt - ct.length;
        return Ot <= 0 ? ct : Rt(xt, Ot) + ct;
      }
      function Mt(ct, vt, xt, Ot) {
        return { from: ct - vt > 0 ? ct - vt : 0, to: ct + xt > Ot ? Ot : ct + xt };
      }
      function ft(ct, vt) {
        var xt, Ot, $t, Gt, Ut, ee = vt.index, Ee = ee.offset, Xe = 1;
        if (Ee === ct.length)
          return "Got the end of the input";
        if (tt(ct)) {
          var Fe = Ee - Ee % St, ri = Ee - Fe, nr = Mt(Fe, gt, bt + St, ct.length), ii = U(function(ke) {
            return U(function(ys) {
              return Nt(ys.toString(16), 2, "0");
            }, ke);
          }, function(ke, ys) {
            var bs = ke.length, nn = [], xs = 0;
            if (bs <= ys)
              return [ke.slice()];
            for (var Ss = 0; Ss < bs; Ss++)
              nn[xs] || nn.push([]), nn[xs].push(ke[Ss]), (Ss + 1) % ys == 0 && xs++;
            return nn;
          }(ct.slice(nr.from, nr.to).toJSON().data, St));
          Gt = function(ke) {
            return ke.from === 0 && ke.to === 1 ? { from: ke.from, to: ke.to } : { from: ke.from / St, to: Math.floor(ke.to / St) };
          }(nr), Ot = Fe / St, xt = 3 * ri, ri >= 4 && (xt += 1), Xe = 2, $t = U(function(ke) {
            return ke.length <= 4 ? ke.join(" ") : ke.slice(0, 4).join(" ") + "  " + ke.slice(4).join(" ");
          }, ii), (Ut = (8 * (Gt.to > 0 ? Gt.to - 1 : Gt.to)).toString(16).length) < 2 && (Ut = 2);
        } else {
          var _s = ct.split(/\r\n|[\n\r\u2028\u2029]/);
          xt = ee.column - 1, Ot = ee.line - 1, Gt = Mt(Ot, Tt, Pt, _s.length), $t = _s.slice(Gt.from, Gt.to), Ut = Gt.to.toString().length;
        }
        var Np = Ot - Gt.from;
        return tt(ct) && (Ut = (8 * (Gt.to > 0 ? Gt.to - 1 : Gt.to)).toString(16).length) < 2 && (Ut = 2), G(function(ke, ys, bs) {
          var nn, xs = bs === Np, Ss = xs ? "> " : At;
          return nn = tt(ct) ? Nt((8 * (Gt.from + bs)).toString(16), Ut, "0") : Nt((Gt.from + bs + 1).toString(), Ut, " "), [].concat(ke, [Ss + nn + " | " + ys], xs ? [At + Rt(" ", Ut) + " | " + Nt("", xt, " ") + Rt("^", Xe)] : []);
        }, [], $t).join(`
`);
      }
      function Ft(ct, vt) {
        return [`
`, "-- PARSING FAILED " + Rt("-", 50), `

`, ft(ct, vt), `

`, (xt = vt.expected, xt.length === 1 ? `Expected:

` + xt[0] : `Expected one of the following: 

` + xt.join(", ")), `
`].join("");
        var xt;
      }
      function Dt(ct) {
        return ct.flags !== void 0 ? ct.flags : [ct.global ? "g" : "", ct.ignoreCase ? "i" : "", ct.multiline ? "m" : "", ct.unicode ? "u" : "", ct.sticky ? "y" : ""].join("");
      }
      function Vt() {
        for (var ct = [].slice.call(arguments), vt = ct.length, xt = 0; xt < vt; xt += 1)
          dt(ct[xt]);
        return N(function(Ot, $t) {
          for (var Gt, Ut = new Array(vt), ee = 0; ee < vt; ee += 1) {
            if (!(Gt = at(ct[ee]._(Ot, $t), Gt)).status)
              return Gt;
            Ut[ee] = Gt.value, $t = Gt.index;
          }
          return at(nt($t, Ut), Gt);
        });
      }
      function Bt() {
        var ct = [].slice.call(arguments);
        if (ct.length === 0)
          throw new Error("seqMap needs at least one argument");
        var vt = ct.pop();
        return mt(vt), Vt.apply(null, ct).map(function(xt) {
          return vt.apply(null, xt);
        });
      }
      function Et() {
        var ct = [].slice.call(arguments), vt = ct.length;
        if (vt === 0)
          return Ct("zero alternates");
        for (var xt = 0; xt < vt; xt += 1)
          dt(ct[xt]);
        return N(function(Ot, $t) {
          for (var Gt, Ut = 0; Ut < ct.length; Ut += 1)
            if ((Gt = at(ct[Ut]._(Ot, $t), Gt)).status)
              return Gt;
          return Gt;
        });
      }
      function Ht(ct, vt) {
        return kt(ct, vt).or(jt([]));
      }
      function kt(ct, vt) {
        return dt(ct), dt(vt), Bt(ct, vt.then(ct).many(), function(xt, Ot) {
          return [xt].concat(Ot);
        });
      }
      function wt(ct) {
        yt(ct);
        var vt = "'" + ct + "'";
        return N(function(xt, Ot) {
          var $t = Ot + ct.length, Gt = xt.slice(Ot, $t);
          return Gt === ct ? nt($t, Gt) : st(Ot, vt);
        });
      }
      function Lt(ct, vt) {
        (function($t) {
          if (!($t instanceof RegExp))
            throw new Error("not a regexp: " + $t);
          for (var Gt = Dt($t), Ut = 0; Ut < Gt.length; Ut++) {
            var ee = Gt.charAt(Ut);
            if (ee !== "i" && ee !== "m" && ee !== "u" && ee !== "s")
              throw new Error('unsupported regexp flag "' + ee + '": ' + $t);
          }
        })(ct), arguments.length >= 2 ? _t(vt) : vt = 0;
        var xt = function($t) {
          return RegExp("^(?:" + $t.source + ")", Dt($t));
        }(ct), Ot = "" + ct;
        return N(function($t, Gt) {
          var Ut = xt.exec($t.slice(Gt));
          if (Ut) {
            if (0 <= vt && vt <= Ut.length) {
              var ee = Ut[0], Ee = Ut[vt];
              return nt(Gt + ee.length, Ee);
            }
            return st(Gt, "valid match group (0 to " + Ut.length + ") in " + Ot);
          }
          return st(Gt, Ot);
        });
      }
      function jt(ct) {
        return N(function(vt, xt) {
          return nt(xt, ct);
        });
      }
      function Ct(ct) {
        return N(function(vt, xt) {
          return st(xt, ct);
        });
      }
      function Wt(ct) {
        if (et(ct))
          return N(function(vt, xt) {
            var Ot = ct._(vt, xt);
            return Ot.index = xt, Ot.value = "", Ot;
          });
        if (typeof ct == "string")
          return Wt(wt(ct));
        if (ct instanceof RegExp)
          return Wt(Lt(ct));
        throw new Error("not a string, regexp, or parser: " + ct);
      }
      function Jt(ct) {
        return dt(ct), N(function(vt, xt) {
          var Ot = ct._(vt, xt), $t = vt.slice(xt, Ot.index);
          return Ot.status ? st(xt, 'not "' + $t + '"') : nt(xt, null);
        });
      }
      function Kt(ct) {
        return mt(ct), N(function(vt, xt) {
          var Ot = pt(vt, xt);
          return xt < vt.length && ct(Ot) ? nt(xt + 1, Ot) : st(xt, "a character/byte matching " + ct);
        });
      }
      function Se(ct, vt) {
        arguments.length < 2 && (vt = ct, ct = void 0);
        var xt = N(function(Ot, $t) {
          return xt._ = vt()._, xt._(Ot, $t);
        });
        return ct ? xt.desc(ct) : xt;
      }
      function Oe() {
        return Ct("fantasy-land/empty");
      }
      k.parse = function(ct) {
        if (typeof ct != "string" && !tt(ct))
          throw new Error(".parse must be called with a string or Buffer as its argument");
        var vt, xt = this.skip(de)._(ct, 0);
        return vt = xt.status ? { status: !0, value: xt.value } : { status: !1, index: ht(ct, xt.furthest), expected: xt.expected }, delete ut[ct], vt;
      }, k.tryParse = function(ct) {
        var vt = this.parse(ct);
        if (vt.status)
          return vt.value;
        var xt = Ft(ct, vt), Ot = new Error(xt);
        throw Ot.type = "ParsimmonError", Ot.result = vt, Ot;
      }, k.assert = function(ct, vt) {
        return this.chain(function(xt) {
          return ct(xt) ? jt(xt) : Ct(vt);
        });
      }, k.or = function(ct) {
        return Et(this, ct);
      }, k.trim = function(ct) {
        return this.wrap(ct, ct);
      }, k.wrap = function(ct, vt) {
        return Bt(ct, this, vt, function(xt, Ot) {
          return Ot;
        });
      }, k.thru = function(ct) {
        return ct(this);
      }, k.then = function(ct) {
        return dt(ct), Vt(this, ct).map(function(vt) {
          return vt[1];
        });
      }, k.many = function() {
        var ct = this;
        return N(function(vt, xt) {
          for (var Ot = [], $t = void 0; ; ) {
            if (!($t = at(ct._(vt, xt), $t)).status)
              return at(nt(xt, Ot), $t);
            if (xt === $t.index)
              throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
            xt = $t.index, Ot.push($t.value);
          }
        });
      }, k.tieWith = function(ct) {
        return yt(ct), this.map(function(vt) {
          if (function($t) {
            if (!it($t))
              throw new Error("not an array: " + $t);
          }(vt), vt.length) {
            yt(vt[0]);
            for (var xt = vt[0], Ot = 1; Ot < vt.length; Ot++)
              yt(vt[Ot]), xt += ct + vt[Ot];
            return xt;
          }
          return "";
        });
      }, k.tie = function() {
        return this.tieWith("");
      }, k.times = function(ct, vt) {
        var xt = this;
        return arguments.length < 2 && (vt = ct), _t(ct), _t(vt), N(function(Ot, $t) {
          for (var Gt = [], Ut = void 0, ee = void 0, Ee = 0; Ee < ct; Ee += 1) {
            if (ee = at(Ut = xt._(Ot, $t), ee), !Ut.status)
              return ee;
            $t = Ut.index, Gt.push(Ut.value);
          }
          for (; Ee < vt && (ee = at(Ut = xt._(Ot, $t), ee), Ut.status); Ee += 1)
            $t = Ut.index, Gt.push(Ut.value);
          return at(nt($t, Gt), ee);
        });
      }, k.result = function(ct) {
        return this.map(function() {
          return ct;
        });
      }, k.atMost = function(ct) {
        return this.times(0, ct);
      }, k.atLeast = function(ct) {
        return Bt(this.times(ct), this.many(), function(vt, xt) {
          return vt.concat(xt);
        });
      }, k.map = function(ct) {
        mt(ct);
        var vt = this;
        return N(function(xt, Ot) {
          var $t = vt._(xt, Ot);
          return $t.status ? at(nt($t.index, ct($t.value)), $t) : $t;
        });
      }, k.contramap = function(ct) {
        mt(ct);
        var vt = this;
        return N(function(xt, Ot) {
          var $t = vt.parse(ct(xt.slice(Ot)));
          return $t.status ? nt(Ot + xt.length, $t.value) : $t;
        });
      }, k.promap = function(ct, vt) {
        return mt(ct), mt(vt), this.contramap(ct).map(vt);
      }, k.skip = function(ct) {
        return Vt(this, ct).map(function(vt) {
          return vt[0];
        });
      }, k.mark = function() {
        return Bt(he, this, he, function(ct, vt, xt) {
          return { start: ct, value: vt, end: xt };
        });
      }, k.node = function(ct) {
        return Bt(he, this, he, function(vt, xt, Ot) {
          return { name: ct, value: xt, start: vt, end: Ot };
        });
      }, k.sepBy = function(ct) {
        return Ht(this, ct);
      }, k.sepBy1 = function(ct) {
        return kt(this, ct);
      }, k.lookahead = function(ct) {
        return this.skip(Wt(ct));
      }, k.notFollowedBy = function(ct) {
        return this.skip(Jt(ct));
      }, k.desc = function(ct) {
        it(ct) || (ct = [ct]);
        var vt = this;
        return N(function(xt, Ot) {
          var $t = vt._(xt, Ot);
          return $t.status || ($t.expected = ct), $t;
        });
      }, k.fallback = function(ct) {
        return this.or(jt(ct));
      }, k.ap = function(ct) {
        return Bt(ct, this, function(vt, xt) {
          return vt(xt);
        });
      }, k.chain = function(ct) {
        var vt = this;
        return N(function(xt, Ot) {
          var $t = vt._(xt, Ot);
          return $t.status ? at(ct($t.value)._(xt, $t.index), $t) : $t;
        });
      }, k.concat = k.or, k.empty = Oe, k.of = jt, k["fantasy-land/ap"] = k.ap, k["fantasy-land/chain"] = k.chain, k["fantasy-land/concat"] = k.concat, k["fantasy-land/empty"] = k.empty, k["fantasy-land/of"] = k.of, k["fantasy-land/map"] = k.map;
      var he = N(function(ct, vt) {
        return nt(vt, ht(ct, vt));
      }), _e = N(function(ct, vt) {
        return vt >= ct.length ? st(vt, "any character/byte") : nt(vt + 1, pt(ct, vt));
      }), ve = N(function(ct, vt) {
        return nt(ct.length, ct.slice(vt));
      }), de = N(function(ct, vt) {
        return vt < ct.length ? st(vt, "EOF") : nt(vt, null);
      }), fe = Lt(/[0-9]/).desc("a digit"), ne = Lt(/[0-9]*/).desc("optional digits"), Ve = Lt(/[a-z]/i).desc("a letter"), gs = Lt(/[a-z]*/i).desc("optional letters"), ja = Lt(/\s*/).desc("optional whitespace"), Hc = Lt(/\s+/).desc("whitespace"), za = wt("\r"), ms = wt(`
`), ru = wt(`\r
`), iu = Et(ru, ms, za).desc("newline"), Vc = Et(iu, de);
      N.all = ve, N.alt = Et, N.any = _e, N.cr = za, N.createLanguage = function(ct) {
        var vt = {};
        for (var xt in ct)
          ({}).hasOwnProperty.call(ct, xt) && function(Ot) {
            vt[Ot] = Se(function() {
              return ct[Ot](vt);
            });
          }(xt);
        return vt;
      }, N.crlf = ru, N.custom = function(ct) {
        return N(ct(nt, st));
      }, N.digit = fe, N.digits = ne, N.empty = Oe, N.end = Vc, N.eof = de, N.fail = Ct, N.formatError = Ft, N.index = he, N.isParser = et, N.lazy = Se, N.letter = Ve, N.letters = gs, N.lf = ms, N.lookahead = Wt, N.makeFailure = st, N.makeSuccess = nt, N.newline = iu, N.noneOf = function(ct) {
        return Kt(function(vt) {
          return ct.indexOf(vt) < 0;
        }).desc("none of '" + ct + "'");
      }, N.notFollowedBy = Jt, N.of = jt, N.oneOf = function(ct) {
        for (var vt = ct.split(""), xt = 0; xt < vt.length; xt++)
          vt[xt] = "'" + vt[xt] + "'";
        return Kt(function(Ot) {
          return ct.indexOf(Ot) >= 0;
        }).desc(vt);
      }, N.optWhitespace = ja, N.Parser = N, N.range = function(ct, vt) {
        return Kt(function(xt) {
          return ct <= xt && xt <= vt;
        }).desc(ct + "-" + vt);
      }, N.regex = Lt, N.regexp = Lt, N.sepBy = Ht, N.sepBy1 = kt, N.seq = Vt, N.seqMap = Bt, N.seqObj = function() {
        for (var ct, vt = {}, xt = 0, Ot = (ct = arguments, Array.prototype.slice.call(ct)), $t = Ot.length, Gt = 0; Gt < $t; Gt += 1) {
          var Ut = Ot[Gt];
          if (!et(Ut)) {
            if (it(Ut) && Ut.length === 2 && typeof Ut[0] == "string" && et(Ut[1])) {
              var ee = Ut[0];
              if (Object.prototype.hasOwnProperty.call(vt, ee))
                throw new Error("seqObj: duplicate key " + ee);
              vt[ee] = !0, xt++;
              continue;
            }
            throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
          }
        }
        if (xt === 0)
          throw new Error("seqObj expects at least one named parser, found zero");
        return N(function(Ee, Xe) {
          for (var Fe, ri = {}, nr = 0; nr < $t; nr += 1) {
            var ii, _s;
            if (it(Ot[nr]) ? (ii = Ot[nr][0], _s = Ot[nr][1]) : (ii = null, _s = Ot[nr]), !(Fe = at(_s._(Ee, Xe), Fe)).status)
              return Fe;
            ii && (ri[ii] = Fe.value), Xe = Fe.index;
          }
          return at(nt(Xe, ri), Fe);
        });
      }, N.string = wt, N.succeed = jt, N.takeWhile = function(ct) {
        return mt(ct), N(function(vt, xt) {
          for (var Ot = xt; Ot < vt.length && ct(pt(vt, Ot)); )
            Ot++;
          return nt(Ot, vt.slice(xt, Ot));
        });
      }, N.test = Kt, N.whitespace = Hc, N["fantasy-land/empty"] = Oe, N["fantasy-land/of"] = jt, N.Binary = { bitSeq: Y, bitSeqObj: function(ct) {
        V();
        var vt = {}, xt = 0, Ot = U(function(Gt) {
          if (it(Gt)) {
            var Ut = Gt;
            if (Ut.length !== 2)
              throw new Error("[" + Ut.join(", ") + "] should be length 2, got length " + Ut.length);
            if (yt(Ut[0]), _t(Ut[1]), Object.prototype.hasOwnProperty.call(vt, Ut[0]))
              throw new Error("duplicate key in bitSeqObj: " + Ut[0]);
            return vt[Ut[0]] = !0, xt++, Ut;
          }
          return _t(Gt), [null, Gt];
        }, ct);
        if (xt < 1)
          throw new Error("bitSeqObj expects at least one named pair, got [" + ct.join(", ") + "]");
        var $t = U(function(Gt) {
          return Gt[0];
        }, Ot);
        return Y(U(function(Gt) {
          return Gt[1];
        }, Ot)).map(function(Gt) {
          return G(function(Ut, ee) {
            return ee[0] !== null && (Ut[ee[0]] = ee[1]), Ut;
          }, {}, U(function(Ut, ee) {
            return [Ut, Gt[ee]];
          }, $t));
        });
      }, byte: function(ct) {
        if (V(), _t(ct), ct > 255)
          throw new Error("Value specified to byte constructor (" + ct + "=0x" + ct.toString(16) + ") is larger in value than a single byte.");
        var vt = (ct > 15 ? "0x" : "0x0") + ct.toString(16);
        return N(function(xt, Ot) {
          var $t = pt(xt, Ot);
          return $t === ct ? nt(Ot + 1, $t) : st(Ot, vt);
        });
      }, buffer: function(ct) {
        return W("buffer", ct).map(function(vt) {
          return Buffer.from(vt);
        });
      }, encodedString: function(ct, vt) {
        return W("string", vt).map(function(xt) {
          return xt.toString(ct);
        });
      }, uintBE: K, uint8BE: K(1), uint16BE: K(2), uint32BE: K(4), uintLE: Z, uint8LE: Z(1), uint16LE: Z(2), uint32LE: Z(4), intBE: J, int8BE: J(1), int16BE: J(2), int32BE: J(4), intLE: Q, int8LE: Q(1), int16LE: Q(2), int32LE: Q(4), floatBE: W("floatBE", 4).map(function(ct) {
        return ct.readFloatBE(0);
      }), floatLE: W("floatLE", 4).map(function(ct) {
        return ct.readFloatLE(0);
      }), doubleBE: W("doubleBE", 8).map(function(ct) {
        return ct.readDoubleBE(0);
      }), doubleLE: W("doubleLE", 8).map(function(ct) {
        return ct.readDoubleLE(0);
      }) }, e.exports = N;
    }]);
  });
})(parsimmon_umd_min);
var parsimmon_umd_minExports = parsimmon_umd_min.exports, dn, Zt, Qt, si, ki, Es, Tu, uo, Yc, wu, Cu, Gf;
const Lf = class {
  constructor(t, e = "\\") {
    rt(this, Zt);
    rt(this, ki);
    rt(this, uo);
    rt(this, dn, null);
    rt(this, si, {
      "!num!": (t) => t.shift(),
      "!str!": (t) => lt(this, uo, Yc).call(this, t.shift()),
      "!bool!": (t) => t.shift(),
      PostfixInc: (t) => {
        throw Error("(PropParser)後置インクリメントは未サポートです");
      },
      PostfixDec: (t) => {
        throw Error("(PropParser)後置デクリメントは未サポートです");
      },
      PrefixInc: (t) => {
        throw Error("(PropParser)前置インクリメントは未サポートです");
      },
      PrefixDec: (t) => {
        throw Error("(PropParser)前置デクリメントは未サポートです");
      },
      // 論理 NOT
      "!": (t) => {
        const e = t.shift();
        return e[0] === "!bool!" ? !e[1] : String(lt(this, Zt, Qt).call(this, e)) !== "true";
      },
      // チルダ演算子（ビット反転）
      "~": (t) => ~Number(lt(this, Zt, Qt).call(this, t.shift())),
      //		UnaryNegate:	a=> - Number(this.#calc(a.shift())),
      UnaryNegate: (t) => -H(this, si).Number(t),
      //	Unaryplus:		a=> this.#hFnc['Number'](a),
      // 乗算、除算、剰余
      "**": (t) => Number(lt(this, Zt, Qt).call(this, t.shift())) ** Number(lt(this, Zt, Qt).call(this, t.shift())),
      "*": (t) => Number(lt(this, Zt, Qt).call(this, t.shift())) * Number(lt(this, Zt, Qt).call(this, t.shift())),
      "/": (t) => Number(lt(this, Zt, Qt).call(this, t.shift())) / Number(lt(this, Zt, Qt).call(this, t.shift())),
      "¥": (t) => Math.floor(H(this, si)["/"](t)),
      "%": (t) => Number(lt(this, Zt, Qt).call(this, t.shift())) % Number(lt(this, Zt, Qt).call(this, t.shift())),
      // 加算、減算、文字列の連結
      "+": (t) => {
        const e = lt(this, Zt, Qt).call(this, t.shift()), r = lt(this, Zt, Qt).call(this, t.shift());
        return Object.prototype.toString.call(e) === "[object String]" || Object.prototype.toString.call(r) === "[object String]" ? String(e) + String(r) : Number(e) + Number(r);
      },
      "-": (t) => Number(lt(this, Zt, Qt).call(this, t.shift())) - Number(lt(this, Zt, Qt).call(this, t.shift())),
      // 関数
      int: (t) => int(lt(this, ki, Es).call(this, t.shift())),
      parseInt: (t) => int(H(this, si).Number(t)),
      Number: (t) => {
        const e = lt(this, Zt, Qt).call(this, t.shift());
        return Object.prototype.toString.call(e) === "[object String]" ? lt(this, ki, Es).call(this, H(this, dn).parse(String(e)).value) : Number(e);
      },
      ceil: (t) => Math.ceil(lt(this, ki, Es).call(this, t.shift())),
      floor: (t) => Math.floor(lt(this, ki, Es).call(this, t.shift())),
      round: (t) => Math.round(lt(this, ki, Es).call(this, t.shift())),
      isNaN: (t) => isNaN(Number(lt(this, Zt, Qt).call(this, t.shift()))),
      // ビットシフト
      "<<": (t) => Number(lt(this, Zt, Qt).call(this, t.shift())) << Number(lt(this, Zt, Qt).call(this, t.shift())),
      ">>": (t) => Number(lt(this, Zt, Qt).call(this, t.shift())) >> Number(lt(this, Zt, Qt).call(this, t.shift())),
      ">>>": (t) => Number(lt(this, Zt, Qt).call(this, t.shift())) >>> Number(lt(this, Zt, Qt).call(this, t.shift())),
      // 等値、非等値、厳密等価、厳密非等価
      "<": (t) => Number(lt(this, Zt, Qt).call(this, t.shift())) < Number(lt(this, Zt, Qt).call(this, t.shift())),
      "<=": (t) => Number(lt(this, Zt, Qt).call(this, t.shift())) <= Number(lt(this, Zt, Qt).call(this, t.shift())),
      ">": (t) => Number(lt(this, Zt, Qt).call(this, t.shift())) > Number(lt(this, Zt, Qt).call(this, t.shift())),
      ">=": (t) => Number(lt(this, Zt, Qt).call(this, t.shift())) >= Number(lt(this, Zt, Qt).call(this, t.shift())),
      // 小なり、以下、大なり、以上
      "==": (t) => {
        const e = lt(this, Zt, Qt).call(this, t.shift()), r = lt(this, Zt, Qt).call(this, t.shift());
        return e == null && r == null && (!e || !r) ? e == r : String(e) === String(r);
      },
      "!=": (t) => !H(this, si)["=="](t),
      "===": (t) => {
        const e = lt(this, Zt, Qt).call(this, t.shift()), r = lt(this, Zt, Qt).call(this, t.shift());
        return Object.prototype.toString.call(e) != Object.prototype.toString.call(r) ? !1 : String(e) === String(r);
      },
      "!==": (t) => !H(this, si)["==="](t),
      // ビット演算子
      "&": (t) => Number(lt(this, Zt, Qt).call(this, t.shift())) & Number(lt(this, Zt, Qt).call(this, t.shift())),
      "^": (t) => Number(lt(this, Zt, Qt).call(this, t.shift())) ^ Number(lt(this, Zt, Qt).call(this, t.shift())),
      "|": (t) => Number(lt(this, Zt, Qt).call(this, t.shift())) | Number(lt(this, Zt, Qt).call(this, t.shift())),
      // 論理 AND,OR
      "&&": (t) => String(lt(this, Zt, Qt).call(this, t.shift())) === "true" && String(lt(this, Zt, Qt).call(this, t.shift())) === "true",
      "||": (t) => String(lt(this, Zt, Qt).call(this, t.shift())) === "true" || String(lt(this, Zt, Qt).call(this, t.shift())) === "true",
      // 条件
      "?": (t) => {
        const e = t.shift();
        let r = !1;
        if (e[0] === "!bool!")
          r = !!e[1];
        else {
          const N = String(lt(this, Zt, Qt).call(this, e));
          r = N !== "true" && N !== "false" ? int(N) !== 0 : N === "true";
        }
        const D = t.shift();
        if (D[0] !== ":")
          throw Error("(PropParser)三項演算子の文法エラーです。: が見つかりません");
        return lt(this, Zt, Qt).call(this, D[r ? 1 : 2]);
      },
      ":": () => {
        throw Error("(PropParser)三項演算子の文法エラーです。? が見つかりません");
      }
    });
    rt(this, Tu, /(\$((tmp|sys|save|mp):)?[^\s!--\/:-@[-^`{-~]+|\#\{[^\}]+})/g);
    It(this, "getValAmpersand", (t) => t.at(0) === "&" ? String(this.parse(t.slice(1))) : t);
    this.val = t;
    function r(J) {
      const Q = [];
      for (const et of J)
        Q.push(
          (typeof et == "string" ? parsimmon_umd_minExports.string(et) : parsimmon_umd_minExports.regex(et)).trim(parsimmon_umd_minExports.optWhitespace)
        );
      return parsimmon_umd_minExports.alt.apply(null, Q);
    }
    function D(J) {
      let et = Object.keys(J).sort().map(
        (it) => (typeof J[it] == "string" ? parsimmon_umd_minExports.string(J[it]) : parsimmon_umd_minExports.regex(J[it])).trim(parsimmon_umd_minExports.optWhitespace).result(it)
      );
      return parsimmon_umd_minExports.alt.apply(null, et);
    }
    function N(J, Q) {
      const et = parsimmon_umd_minExports.lazy(() => parsimmon_umd_minExports.seq(J, et).or(Q));
      return et;
    }
    function k(J, Q) {
      return parsimmon_umd_minExports.seqMap(Q, J.many(), (et, it) => it.reduce((tt, nt) => [nt, tt], et));
    }
    function $(J, Q) {
      let et = parsimmon_umd_minExports.lazy(
        () => Q.chain(
          (it) => parsimmon_umd_minExports.seq(
            J,
            parsimmon_umd_minExports.of(it),
            et
          ).or(parsimmon_umd_minExports.of(it))
        )
      );
      return et;
    }
    function G(J, Q) {
      return parsimmon_umd_minExports.seqMap(
        Q,
        parsimmon_umd_minExports.seq(J, Q).many(),
        (et, it) => it.reduce((tt, nt) => [nt[0], tt, nt[1]], et)
      );
    }
    const U = parsimmon_umd_minExports.alt(
      parsimmon_umd_minExports.alt(
        parsimmon_umd_minExports.regex(/-?(0|[1-9][0-9]*)\.[0-9]+/),
        parsimmon_umd_minExports.regex(/0x[0-9a-fA-F]+/)
      ).map(Number),
      parsimmon_umd_minExports.alt(
        parsimmon_umd_minExports.regex(/-?(0|[1-9][0-9]*)/)
      ).map((J) => int(J))
    ).map((J) => ["!num!", J]).desc("number"), z = parsimmon_umd_minExports.string("null").map(() => ["!str!", null]), X = parsimmon_umd_minExports.regex(/(true|false)/).map((J) => ["!bool!", J === "true"]).desc("boolean"), V = parsimmon_umd_minExports.regex(new RegExp(`(?:"(?:\\${e}["'#\\n]|[^"])*"|'(?:\\${e}["'#\\n]|[^'])*'|\\#(?:\\${e}["'#\\n]|[^#])*\\#)`)).map((J) => ["!str!", J.slice(1, -1).replaceAll(e, "")]).desc("string"), Y = /\[[^\]]+\]/g, W = parsimmon_umd_minExports.regex(/-?(?:(?:tmp|sys|save|mp):)?[^\s!-\/:-@[-^`{-~]+(?:\.[^\s!-\/:-@[-^`{-~]+|\[[^\]]+\])*(?:@str)?/).map((J) => {
      const Q = String(J).replaceAll(
        Y,
        (it) => "." + this.parse(it.slice(1, -1))
      ), et = this.val.getVal(Q);
      return et == null ? ["!str!", et] : typeof et == "boolean" ? ["!bool!", et] : Object.prototype.toString.call(et) === "[object String]" ? ["!str!", String(et)] : ["!num!", Number(et)];
    }).desc("string"), q = parsimmon_umd_minExports.lazy(
      () => parsimmon_umd_minExports.string("(").then(H(this, dn)).skip(parsimmon_umd_minExports.string(")")).or(U).or(z).or(X).or(V).or(W)
    ), Z = [
      // 演算子の優先順位 - JavaScript | MDN https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Operator_precedence
      // 優先順位：18（メンバーへのアクセス、計算値によるメンバーへのアクセス）
      // a.b  a[b]
      { type: N, ops: r([/[A-Za-z_][A-Za-z0-9_]*(?=\()/]) },
      // 優先順位：16
      { type: k, ops: D({ PostfixInc: "++" }) },
      { type: k, ops: D({ PostfixDec: "--" }) },
      // 【未サポート】後置インクリメント・デクリメント
      // 優先順位：15
      { type: N, ops: r([/!(?!=)|~/]) },
      // 論理 NOT (!)、ビット単位 NOT (~)
      { type: N, ops: D({ PrefixInc: "++" }) },
      { type: N, ops: D({ PrefixDec: "--" }) },
      // 【未サポート】前置インクリメント・デクリメント
      //	{type: PREFIX, ops: opeH({Unaryplus: /\+(?!\+)/})},	// 単項プラス
      { type: N, ops: D({ UnaryNegate: /-(?!-)/ }) },
      // 単項マイナス
      // 優先順位：14以下（並びに注意）
      { type: $, ops: r(["**"]) },
      { type: G, ops: r(["*", "/", "¥", "%"]) },
      { type: G, ops: r(["+", "-"]) },
      { type: G, ops: r([/>>>|<<|>>/]) },
      { type: G, ops: r([/<=|<|>=|>/]) },
      { type: G, ops: r([/===|!==|==|!=/]) },
      { type: G, ops: r([/&(?!&)/]) },
      { type: G, ops: r(["^"]) },
      { type: G, ops: r([/\|(?!\|)/]) },
      { type: G, ops: r(["&&"]) },
      { type: G, ops: r(["||"]) },
      { type: $, ops: r([":"]) },
      { type: $, ops: r(["?"]) }
    ].reduce(
      (J, Q) => Q.type(Q.ops, J),
      q
    );
    ot(this, dn, Z.trim(parsimmon_umd_minExports.optWhitespace));
  }
  parse(t) {
    const e = H(this, dn).parse(t);
    if (!e.status)
      throw Error("(PropParser)文法エラー【" + t + "】");
    const r = e.value;
    return r[0] === "!str!" ? lt(this, uo, Yc).call(this, r[1]) : lt(this, Zt, Qt).call(this, r);
  }
  // 522 match 18413 step(~10ms) https://regex101.com/r/tmCKuE/1
  // →これは改良しようがない。いい意味で改善の余地なし
  static getValName(t) {
    var $;
    const e = H(this, wu).exec(t.trim()), r = e == null ? void 0 : e.groups;
    if (!r)
      return null;
    const { scope: D = "tmp", name: N, at: k = "" } = r;
    return {
      scope: D,
      name: lt($ = Lf, Cu, Gf).call($, N),
      at: k
    };
  }
};
let PropParser = Lf;
dn = new WeakMap(), Zt = new WeakSet(), Qt = function(t) {
  const e = t.shift();
  if (e instanceof Array)
    return lt(this, Zt, Qt).call(this, e);
  const r = H(this, si)[e];
  return r ? r(t) : Object(null);
}, si = new WeakMap(), ki = new WeakSet(), Es = function(t) {
  const e = lt(this, Zt, Qt).call(this, t);
  if (Object.prototype.toString.call(e) !== "[object Number]")
    throw Error("(PropParser)引数【" + e + "】が数値ではありません");
  return Number(e);
}, Tu = new WeakMap(), uo = new WeakSet(), Yc = function(t) {
  return t == null ? t : String(t).replaceAll(
    H(this, Tu),
    (e) => e.at(0) === "$" ? this.val.getVal(e.slice(1)) : this.parse(e.slice(2, -1))
  );
}, wu = new WeakMap(), Cu = new WeakSet(), Gf = function(t) {
  let e = 0, r = 0;
  for (; ; ) {
    if (e = t.indexOf('["'), e < 0) {
      if (e = t.indexOf("['"), e < 0)
        break;
      r = t.indexOf("']", e + 2);
    } else
      r = t.indexOf('"]', e + 2);
    if (r < 0)
      break;
    t = t.slice(0, e) + "." + t.slice(e + 2, r) + t.slice(r + 2), e = r - 2;
  }
  return t;
}, rt(PropParser, Cu), rt(PropParser, wu, /^((?<scope>\w+?):)?(?<name>[^\s :@]+)(?<at>\@str)?$/);
var wr, pn, As, Cr, ho, Pu, Uf, Mu, jf, Ru, zf, Ou, Hf;
const pe = class {
  constructor(t, e, r) {
    rt(this, Pu);
    rt(this, Mu);
    // ログ出力
    rt(this, ho, !0);
    this.sys = t, ot(pe, wr, r), ot(pe, pn, e), ot(pe, As, e.title), pe.myTrace = lt(pe, Ru, zf), e.log = (D) => lt(this, Pu, Uf).call(this, D), e.trace = (D) => lt(this, Mu, jf).call(this, D), ot(pe, Cr, document.createElement("span")), H(pe, Cr).hidden = !0, H(pe, Cr).textContent = "", H(pe, Cr).style.cssText = `	z-index: ${Number.MAX_SAFE_INTEGER};
			position: absolute; left: 0; top: 0;
			color: black;
			background-color: rgba(255, 255, 255, 0.7);`, document.body.appendChild(H(pe, Cr));
  }
  destroy() {
    ot(pe, As, () => !1), document.body.removeChild(H(pe, Cr)), pe.myTrace = pe.trace_beforeNew;
  }
  // private禁止、galleryでエラーになる
  static trace_beforeNew(t, e = "E") {
    let r = `{${e}} ` + t, D = "";
    switch (e) {
      case "D":
        D = `color:#${CmnLib.isDarkMode ? "49F" : "05A"};`;
        break;
      case "W":
        D = "color:#FF8800;";
        break;
      case "F":
        D = "color:#BB0000;";
        break;
      case "ET":
        throw r;
      case "E":
        console.error("%c" + r, "color:#FF3300;");
        return;
      default:
        D = "color:black;", r = " " + r;
    }
    console.info("%c" + r, D);
  }
};
let DebugMng = pe;
wr = new WeakMap(), pn = new WeakMap(), As = new WeakMap(), Cr = new WeakMap(), ho = new WeakMap(), Pu = new WeakSet(), Uf = function(t) {
  let e = "";
  return H(this, ho) && (ot(this, ho, !1), e = `== ${platform.description} ==
`), this.sys.appendFile(
    this.sys.path_downloads + "log.txt",
    `${e}--- ${getDateStr("-", "_", "")} [fn:${H(pe, wr).scriptFn} line:${H(pe, wr).lineNum}] prj:${this.sys.cur}
${t.text || `(text is ${t.text})`}
`,
    (r) => {
      r && console.log(r);
    }
  ), !1;
}, Mu = new WeakSet(), jf = function(t) {
  return pe.myTrace(t.text || `(text is ${t.text})`, "I"), !1;
}, Ru = new WeakSet(), zf = function(t, e = "E") {
  var N, k;
  let r = `{${e}} ` + pe.strPos() + t;
  lt(N = pe, Ou, Hf).call(N, r, e);
  let D = "";
  switch (e) {
    case "D":
      D = `color:#${CmnLib.isDarkMode ? "49F" : "05A"};`;
      break;
    case "W":
      D = "color:#F80;";
      break;
    case "F":
      D = "color:#B00;";
      break;
    case "ET":
    case "E":
      if (H(k = pe, As).call(k, { text: t }), H(this, pn).dump_lay({}), H(this, pn).dump_val({}), H(pe, wr).dumpErrForeLine(), H(this, pn).dump_stack({}), e === "ET")
        throw r;
      console.error("%c" + r, "color:#F30;");
      return;
    default:
      D = "", r = " " + r;
  }
  console.info("%c" + r, D);
}, Ou = new WeakSet(), Hf = function(t, e) {
  let r = "";
  switch (e) {
    case "D":
      r = "color:#05A;";
      break;
    case "W":
      r = "color:#F80;";
      break;
    case "F":
      r = "color:#B00;";
      break;
    case "ET":
    case "E":
      r = "color:#F30;";
      break;
    default:
      r = "";
  }
  H(pe, Cr).innerHTML += `<span style='${r}'>${t}</span><br/>`, H(pe, Cr).hidden = !1;
}, rt(DebugMng, Ru), rt(DebugMng, Ou), rt(DebugMng, wr, void 0), rt(DebugMng, pn, void 0), rt(DebugMng, As, void 0), rt(DebugMng, Cr, void 0), It(DebugMng, "myTrace", pe.trace_beforeNew), It(DebugMng, "strPos", () => H(pe, wr) && H(pe, wr).lineNum > 0 ? `(fn:${H(pe, wr).scriptFn} line:${H(pe, wr).lineNum}) ` : "");
class Areas {
  constructor() {
    It(this, "hAreas", /* @__PURE__ */ Object.create(null));
  }
  clear() {
    this.hAreas = {};
  }
  search(t) {
    return Object.entries(this.hAreas).some(([e, r]) => t >= parseInt(e) && t <= r);
  }
  record(t) {
    if (!this.search(t)) {
      for (const [e, r] of Object.entries(this.hAreas))
        if (r + 1 === t) {
          String(t + 1) in this.hAreas ? (this.hAreas[e] = this.hAreas[t + 1], delete this.hAreas[t + 1]) : this.hAreas[e] = t;
          return;
        }
      if (String(t + 1) in this.hAreas) {
        this.hAreas[t] = this.hAreas[t + 1], delete this.hAreas[t + 1];
        return;
      }
      this.hAreas[t] = t;
    }
  }
  erase(t) {
    if (this.search(t)) {
      if (String(t) in this.hAreas) {
        this.hAreas[t] > t && (this.hAreas[t + 1] = this.hAreas[t]), delete this.hAreas[t];
        return;
      }
      for (const [e, r] of Object.entries(this.hAreas))
        if (!(t < parseInt(e) || r < t)) {
          if (this.hAreas[e] === t) {
            this.hAreas[e] = t - 1;
            return;
          }
          this.hAreas[t + 1] = r, this.hAreas[e] = t - 1;
          return;
        }
    }
  }
  get count() {
    return Object.keys(this.hAreas).length;
  }
  // 4tst
  toString() {
    let t = ",";
    for (const e of Object.keys(this.hAreas).map((r) => parseInt(r)).sort((r, D) => r - D))
      t += e === this.hAreas[e] ? "," + e : "," + e + "~" + this.hAreas[e];
    return t.slice(1);
  }
}
var Le, pr, Te, ai, De, or, $r, co, Iu, fo, Wc, po, vo, Du, Vf, Au, Xf, vr, Fr, Nu, Yf, ku, Wf, Lu, qf, Bu, Kf, Fu, Zf, $u, Jf, Gu, Qf, Uu, td, Ns, au, go, qc, mo, vn, _o, Kc, ju, zu, ks, yo, Ls, ou, Hu, ed, Vu, rd, bo, Zc, xo, Jc, Xu, id, Yu, nd, Bs, lu;
const Ms = class {
  constructor(t, e) {
    rt(this, fo);
    //	// しおり
    // しおりの複写
    rt(this, Du);
    // しおりの消去
    rt(this, Au);
    //	//	変数操作
    // 変数代入・演算
    rt(this, vr);
    // 絶対値
    rt(this, Nu);
    // 文字列から一字取りだし
    rt(this, ku);
    // 文字列で検索
    rt(this, Lu);
    // 文字列の長さ
    rt(this, Bu);
    // 正規表現で置換
    rt(this, Fu);
    // 四捨五入
    rt(this, $u);
    // 正規表現で検索
    rt(this, Gu);
    // 文字列から抜きだし
    rt(this, Uu);
    //	// デバッグ・その他
    // システム変数の全消去
    rt(this, Ns);
    // ゲーム変数の全消去
    rt(this, go);
    rt(this, _o);
    rt(this, Ls);
    rt(this, Hu);
    rt(this, Vu);
    rt(this, bo);
    rt(this, xo);
    rt(this, Xu);
    rt(this, Yu);
    rt(this, Bs);
    rt(this, Le, { sys: {}, save: {}, tmp: {}, mp: {} });
    rt(this, pr, H(this, Le).save);
    rt(this, Te, H(this, Le).tmp);
    rt(this, ai, void 0);
    rt(this, De, { sys: {}, mark: {}, kidoku: {} });
    rt(this, or, void 0);
    rt(this, $r, {});
    rt(this, co, void 0);
    rt(this, Iu, {
      auth: (t, e) => lt(this, fo, Wc).call(this, e.hBreakpoint.aData),
      var: (t, e) => H(this, ai).send2Dbg(e.ri, { v: H(this, Le)[e.scope] ?? {} }),
      set_var: (t, e) => {
        try {
          H(this, mo).call(this, e.nm, e.val), H(this, ai).send2Dbg(e.ri, {});
        } catch {
        }
      },
      set_data_break: (t, e) => {
        lt(this, fo, Wc).call(this, e.a), H(this, ai).send2Dbg(e.ri, {});
      },
      disconnect: (t) => ot(Ms, vn, {})
    });
    rt(this, po, () => {
    });
    rt(this, vo, (t) => {
    });
    It(this, "getMark", (t) => H(this, De).mark[t]);
    It(this, "getAreaKidoku", (t) => H(this, $r)[t]);
    rt(this, mo, (t, e, r = !0) => {
      if (!t)
        throw "[変数に値セット] nameは必須です";
      if (e == null)
        throw "[変数に値セット] textは必須です（空文字はOK）";
      const D = PropParser.getValName(t);
      if (D === null)
        throw "[変数参照] name(" + t + ")が変数名として異常です";
      const N = H(this, Le)[D.scope];
      if (!N)
        throw "[変数に値セット] scopeが異常【" + D.scope + "】です";
      const k = D.name;
      if (k.slice(0, 6) === "const." && k in N)
        throw "[変数に値セット] 変数【" + k + "】は書き換え不可です";
      this.setVal_Nochk(D.scope, k, e, r);
    });
    It(this, "getVal", (t, e) => {
      if (!t)
        throw "[変数参照] nameは必須です";
      const r = PropParser.getValName(t);
      if (r === null)
        throw "[変数参照] name(" + t + ")が変数名として異常です";
      const D = H(this, Le)[r.scope];
      if (!D)
        throw "[変数参照] scopeが異常【" + r.scope + "】です";
      const N = r.name;
      let k = D[N];
      if (!(N in D)) {
        k = e;
        let $ = "";
        const G = N.split("."), U = G.length;
        for (let z = 0; z < U; ++z, $ += ".") {
          if ($ += G[z], !($ in D))
            continue;
          let X = JSON.parse(D[$]);
          if (Object.prototype.toString.call(X) !== "[object Object]") {
            if (z + 1 === U) {
              k = X;
              break;
            }
            continue;
          }
          let V = z;
          for (; ++V < U; ) {
            if (!(G[V] in X)) {
              k = e;
              break;
            }
            if (X = X[G[V]], Object.prototype.toString.call(X) !== "[object Object]" || V + 1 === U) {
              k = X;
              break;
            }
          }
          k instanceof Object && (k = JSON.stringify(k));
          break;
        }
      }
      return k instanceof Function && (k = k()), r.at === "@str" ? k : lt(this, _o, Kc).call(this, k);
    });
    rt(this, ju, /^-?[\d\.]+$/);
    // 変数のダンプ
    rt(this, zu, () => {
      const t = { tmp: {}, sys: {}, save: {}, mp: {} };
      for (let e in t) {
        const r = H(this, Le)[e], D = t[e];
        for (let [N, k] of Object.entries(r))
          D[N] = Object.prototype.toString.call(k) === "[object Function]" ? k() : k;
      }
      return console.info("🥟 [dump_val]", t), !1;
    });
    rt(this, ks, !1);
    rt(this, yo, {
      // sys
      "sys:sn.tagCh.doWait": (t) => lt(this, Ls, ou).call(this, t),
      "sys:sn.tagCh.doWait_Kidoku": (t) => lt(this, Ls, ou).call(this, t),
      "sys:sn.tagCh.msecWait": (t) => lt(this, Hu, ed).call(this, t),
      "sys:sn.tagCh.msecWait_Kidoku": (t) => lt(this, Vu, rd).call(this, t),
      "sys:sn.tagCh.canskip": (t) => lt(this, Ls, ou).call(this, t),
      "sys:sn.auto.msecPageWait": (t) => lt(this, bo, Zc).call(this, t),
      "sys:sn.auto.msecPageWait_Kidoku": (t) => lt(this, bo, Zc).call(this, t),
      "sys:sn.auto.msecLineWait": (t) => lt(this, xo, Jc).call(this, t),
      "sys:sn.auto.msecLineWait_Kidoku": (t) => lt(this, xo, Jc).call(this, t),
      // save
      "save:sn.doRecLog": (t) => {
        H(this, vo).call(this, ot(this, ks, lt(this, Xu, id).call(this, t)));
      },
      "save:sn.userFnTail": (t, e) => {
        if (e.includes("@"))
          throw "この変数では文字「@」は禁止です";
        this.cfg.userFnTail = e;
      },
      // tmp
      "tmp:sn.tagL.enabled": (t) => lt(this, Yu, nd).call(this, t),
      "tmp:sn.skip.all": (t) => lt(this, Bs, lu).call(this, t),
      "tmp:sn.skip.enabled": (t) => lt(this, Bs, lu).call(this, t),
      "tmp:sn.auto.enabled": (t) => lt(this, Bs, lu).call(this, t),
      "tmp:flash.desktop.NativeApplication.nativeApplication.systemIdleMode": () => {
      }
    });
    if (this.cfg = t, e.let = (N) => lt(this, vr, Fr).call(this, N), e.let_abs = (N) => lt(this, Nu, Yf).call(this, N), e.let_char_at = (N) => lt(this, ku, Wf).call(this, N), e.let_index_of = (N) => lt(this, Lu, qf).call(this, N), e.let_length = (N) => lt(this, Bu, Kf).call(this, N), e.let_replace = (N) => lt(this, Fu, Zf).call(this, N), e.let_round = (N) => lt(this, $u, Jf).call(this, N), e.let_search = (N) => lt(this, Gu, Qf).call(this, N), e.let_substr = (N) => lt(this, Uu, td).call(this, N), e.clearsysvar = () => lt(this, Ns, au).call(this), e.clearvar = () => lt(this, go, qc).call(this), e.dump_val = () => H(this, zu).call(this), e.copybookmark = (N) => lt(this, Du, Vf).call(this, N), e.erasebookmark = (N) => lt(this, Au, Xf).call(this, N), H(this, pr)["sn.userFnTail"] = "", this.defTmp("const.sn.bookmark.json", () => {
      const N = [];
      for (const k of Object.keys(H(this, De).mark).sort()) {
        const $ = { ...H(this, De).mark[k].json };
        $.place = k, N.push($);
      }
      return JSON.stringify(N);
    }), H(this, Te)["const.sn.isFirstBoot"] = !0, H(this, Te)["sn.tagL.enabled"] = !0, H(this, Te)["sn.skip.all"] = !1, H(this, Te)["sn.skip.enabled"] = !1, H(this, Te)["sn.auto.enabled"] = !1, H(this, Te)["const.sn.last_page_text"] = "", H(this, Te)["const.sn.last_page_plain_text"] = "", H(this, Te)["const.sn.displayState"] = !1, H(this, Te)["const.Date.getTime"] = () => (/* @__PURE__ */ new Date()).getTime(), H(this, Te)["const.Date.getDateStr"] = () => getDateStr(), H(this, Te)["const.sn.platform"] = JSON.stringify(platform), lt(this, Ns, au).call(this), lt(this, go, qc).call(this), H(this, Te)["const.sn.config.window.width"] = t.oCfg.window.width, H(this, Te)["const.sn.config.window.height"] = t.oCfg.window.height, H(this, Te)["const.sn.config.book.title"] = t.oCfg.book.title, H(this, Te)["const.sn.config.book.version"] = t.oCfg.book.version, H(this, Te)["const.sn.Math.PI"] = Math.PI, typeof window > "u")
      return;
    const r = window, D = r.AudioContext ?? r.webkitAudioContext;
    H(this, Te)["const.sn.needClick2Play"] = () => new D().state === "suspended";
  }
  setSys(t) {
    ot(this, ai, t), t.initVal(H(this, De), H(this, Te), (e) => {
      this.updateData(e), sessionStorage.clear();
      const r = this.cfg.getNs();
      ot(this, po, this.cfg.oCfg.debug.variable ? () => {
        const N = {};
        for (const [X, V] of Object.entries(H(this, or)))
          N["sys:" + X] = V instanceof Function ? V() : V;
        sessionStorage[r + "sys"] = JSON.stringify(N);
        const k = {};
        for (const [X, V] of Object.entries(H(this, pr)))
          k["save:" + X] = V instanceof Function ? V() : V;
        sessionStorage[r + "save"] = JSON.stringify(k);
        const $ = {};
        for (const [X, V] of Object.entries(H(this, Te)))
          $[X] = V instanceof Function ? V() : V;
        sessionStorage[r + "tmp"] = JSON.stringify($);
        const G = {};
        for (const [X, V] of Object.entries(H(this, Le).mp))
          G[X] = V instanceof Function ? V() : V;
        sessionStorage[r + "mp"] = JSON.stringify(G);
        const U = {};
        for (const [X, V] of Object.entries(H(this, De).mark))
          U[X] = V instanceof Function ? V() : V;
        sessionStorage[r + "mark"] = JSON.stringify(U);
        const z = {};
        for (const [X, V] of Object.entries(H(this, De).kidoku))
          z[X] = V instanceof Function ? V() : V;
        sessionStorage[r + "kidoku"] = JSON.stringify(z), t.flush();
      } : () => t.flush()), ot(this, co, (N, k) => t.callHook(N, k)), t.addHook((N, k) => {
        var $, G;
        return (G = ($ = H(this, Iu))[N]) == null ? void 0 : G.call($, N, k);
      });
      const D = this.getVal("sys:sn.tagCh.msecWait", -1);
      (H(this, Te)["const.sn.isFirstBoot"] || D === -1) && lt(this, Ns, au).call(this);
    });
  }
  updateData(t) {
    ot(this, De, t), ot(this, or, H(this, Le).sys = H(this, De).sys), ot(this, $r, {});
    for (const [e, r] of Object.entries(H(this, De).kidoku)) {
      const D = new Areas();
      D.hAreas = { ...r }, H(this, $r)[e] = D;
    }
  }
  flush() {
    H(this, po).call(this);
  }
  // 先にこのメソッドへの参照を配ってしまうので、中身を入れ替える
  setDoRecProc(t) {
    ot(this, vo, t);
  }
  defTmp(t, e) {
    H(this, Te)[t] = e;
  }
  cloneMp() {
    return { ...H(this, Le).mp };
  }
  setMp(t) {
    H(this, Le).mp = t;
  }
  setMark(t, e) {
    H(this, De).mark[t] = e, this.flush();
  }
  cloneSave() {
    return { ...H(this, Le).save };
  }
  mark2save(t) {
    ot(this, pr, H(this, Le).save = { ...t.hSave }), ot(this, ks, H(this, pr)["sn.doRecLog"] ?? !1);
  }
  // 既読系
  loadScrWork(t) {
    t in H(this, $r) || (H(this, $r)[t] = new Areas());
  }
  saveKidoku() {
    for (const [t, { hAreas: e }] of Object.entries(H(this, $r)))
      H(this, De).kidoku[t] = { ...e };
    this.flush();
  }
  setVal_Nochk(t, e, r, D = !1) {
    var $, G;
    const N = H(this, Le)[t];
    D && (r = lt(this, _o, Kc).call(this, r));
    const k = t + ":" + e;
    if (k in H(Ms, vn)) {
      const U = N[e], z = r;
      U != z && H(this, co).call(this, "data_break", {
        dataId: k,
        old_v: U,
        new_v: z
      });
    }
    N[e] = r, (G = ($ = H(this, yo))[k]) == null || G.call($, e, r);
  }
  doRecLog() {
    return H(this, ks);
  }
  defValTrg(t, e) {
    H(this, yo)[t] = e;
  }
};
let Variable = Ms;
Le = new WeakMap(), pr = new WeakMap(), Te = new WeakMap(), ai = new WeakMap(), De = new WeakMap(), or = new WeakMap(), $r = new WeakMap(), co = new WeakMap(), Iu = new WeakMap(), fo = new WeakSet(), Wc = function(t) {
  ot(Ms, vn, {});
  for (const e of t)
    H(Ms, vn)[e.dataId] = 1;
}, po = new WeakMap(), vo = new WeakMap(), Du = new WeakSet(), Vf = function(t) {
  if (!("from" in t))
    throw "fromは必須です";
  if (!("to" in t))
    throw "toは必須です";
  const e = Number(t.from), r = Number(t.to);
  if (e === r)
    return !1;
  if (!(e in H(this, De).mark))
    throw `from:${e} のセーブデータは存在しません`;
  return this.setMark(r, { ...H(this, De).mark[e] }), H(this, ai).copyBMFolder(e, r), !1;
}, Au = new WeakSet(), Xf = function(t) {
  const { place: e } = t;
  if (!e)
    throw "placeは必須です";
  return delete H(this, De).mark[e], this.flush(), H(this, ai).eraseBMFolder(e), !1;
}, vr = new WeakSet(), Fr = function(t) {
  if (!t.name)
    throw "nameは必須です";
  let e = !0;
  if (t.cast)
    switch (t.cast) {
      case "num":
        argChk_Num(t, "text", NaN);
        break;
      case "int":
        t.text = String(int(argChk_Num(t, "text", NaN)));
        break;
      case "uint":
        t.text = String(uint(argChk_Num(t, "text", NaN)));
        break;
      case "bool":
        argChk_Boolean(t, "text", !1);
        break;
      case "str":
        e = !1;
        break;
      default:
        throw "cast【" + t.cast + "】は未定義です";
    }
  return H(this, mo).call(this, t.name, t.text, e), !1;
}, Nu = new WeakSet(), Yf = function(t) {
  const e = argChk_Num(t, "text", 0);
  return t.text = String(e < 0 ? -e : e), lt(this, vr, Fr).call(this, t), !1;
}, ku = new WeakSet(), Wf = function(t) {
  return t.text = (t.text ?? "").charAt(argChk_Num(t, "pos", 0)), lt(this, vr, Fr).call(this, t), !1;
}, Lu = new WeakSet(), qf = function(t) {
  const { val: e } = t;
  if (!e)
    throw "valは必須です";
  const r = argChk_Num(t, "start", 0);
  return t.text = String((t.text ?? "").indexOf(e, r)), lt(this, vr, Fr).call(this, t), !1;
}, Bu = new WeakSet(), Kf = function(t) {
  return t.text = String((t.text ?? "").length), lt(this, vr, Fr).call(this, t), !1;
}, Fu = new WeakSet(), Zf = function(t) {
  if (!t.reg)
    throw "regは必須です";
  const { flags: e } = t, r = e ? new RegExp(t.reg, e) : new RegExp(t.reg);
  return t.text = String(t.text ?? "").replace(r, String(t.val)), lt(this, vr, Fr).call(this, t), !1;
}, $u = new WeakSet(), Jf = function(t) {
  const e = argChk_Num(t, "text", 0);
  return t.text = String(Math.round(e)), lt(this, vr, Fr).call(this, t), !1;
}, Gu = new WeakSet(), Qf = function(t) {
  if (!t.reg)
    throw "regは必須です";
  const { flags: e } = t, r = e ? new RegExp(t.reg, e) : new RegExp(t.reg);
  return t.text = String((t.text ?? "").search(r)), lt(this, vr, Fr).call(this, t), !1;
}, Uu = new WeakSet(), td = function(t) {
  const e = argChk_Num(t, "pos", 0);
  return t.text = t.len !== "all" ? (t.text ?? "").slice(e, e + int(argChk_Num(t, "len", 1))) : (t.text ?? "").slice(e), lt(this, vr, Fr).call(this, t), !1;
}, Ns = new WeakSet(), au = function() {
  const t = ot(this, or, H(this, Le).sys = H(this, De).sys = {});
  typeof process < "u" || (this.setVal_Nochk("sys", "const.sn.window.x", 0), this.setVal_Nochk("sys", "const.sn.window.y", 0)), this.setVal_Nochk("sys", "sn.tagCh.doWait", !0), this.setVal_Nochk("sys", "sn.tagCh.doWait_Kidoku", !0), this.setVal_Nochk("sys", "sn.tagCh.msecWait", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk("sys", "sn.tagCh.msecWait_Kidoku", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk("sys", "sn.tagCh.canskip", !0), this.setVal_Nochk("sys", "sn.skip.mode", "s"), this.setVal_Nochk("sys", "sn.auto.msecPageWait", argChk_Num(t, "sn.auto.msecPageWait", this.cfg.oCfg.init.auto_msecpagewait ?? 3500)), this.setVal_Nochk("sys", "sn.auto.msecPageWait_Kidoku", argChk_Num(t, "sn.auto.msecPageWait", this.cfg.oCfg.init.auto_msecpagewait ?? 3500)), this.setVal_Nochk("sys", "sn.auto.msecLineWait", 500), this.setVal_Nochk("sys", "sn.auto.msecLineWait_Kidoku", 500), this.setVal_Nochk("sys", "const.sn.sound.BGM.volume", 1), this.setVal_Nochk("sys", "const.sn.sound.SE.volume", 1), this.setVal_Nochk("sys", "const.sn.sound.SYS.volume", 1);
  for (const [r, D] of Object.entries(H(this, De).kidoku))
    D.hAreas = {}, H(this, $r)[r].clear();
  return this.setVal_Nochk("sys", "TextLayer.Back.Alpha", 0.5), H(this, Le).mark = H(this, De).mark = {}, this.setVal_Nochk("sys", "const.sn.save.place", 1), this.flush(), !1;
}, go = new WeakSet(), qc = function() {
  const t = H(this, pr)["const.sn.mesLayer"] ?? "", e = H(this, pr)["sn.doRecLog"] ?? !1, r = H(this, pr)["const.sn.sLog"] ?? "[]";
  return ot(this, pr, H(this, Le).save = {}), this.setVal_Nochk("save", "const.sn.mesLayer", t), this.setVal_Nochk("save", "sn.doRecLog", e), this.setVal_Nochk("save", "const.sn.sLog", r), !1;
}, mo = new WeakMap(), vn = new WeakMap(), _o = new WeakSet(), Kc = function(t) {
  const e = t;
  if (e === "true")
    return !0;
  if (e === "false")
    return !1;
  if (e === "null")
    return null;
  if (e !== "undefined")
    return H(this, ju).test(e) ? parseFloat(e) : t;
}, ju = new WeakMap(), zu = new WeakMap(), ks = new WeakMap(), yo = new WeakMap(), Ls = new WeakSet(), ou = function(t) {
  argChk_Boolean(H(this, or), t, !0);
}, Hu = new WeakSet(), ed = function(t) {
  argChk_Num(H(this, or), t, 10), H(this, or)["sn.tagCh.doWait"];
}, Vu = new WeakSet(), rd = function(t) {
  argChk_Num(
    H(this, or),
    t,
    this.cfg.oCfg.init.tagch_msecwait === void 0 ? 10 : this.cfg.oCfg.init.tagch_msecwait
  ), H(this, or)["sn.tagCh.doWait_Kidoku"];
}, bo = new WeakSet(), Zc = function(t) {
  argChk_Num(
    H(this, or),
    t,
    this.cfg.oCfg.init.auto_msecpagewait === void 0 ? 3500 : this.cfg.oCfg.init.auto_msecpagewait
  );
}, xo = new WeakSet(), Jc = function(t) {
  argChk_Num(H(this, or), t, 500);
}, Xu = new WeakSet(), id = function(t) {
  return argChk_Boolean(H(this, pr), t, !0);
}, Yu = new WeakSet(), nd = function(t) {
  argChk_Boolean(H(this, Te), t, !0);
}, Bs = new WeakSet(), lu = function(t) {
  argChk_Boolean(H(this, Te), t, !1);
}, // reload 再生成 Main に受け渡すため static
rt(Variable, vn, {});
var Easing = Object.freeze({
  Linear: Object.freeze({
    None: function(o) {
      return o;
    },
    In: function(o) {
      return this.None(o);
    },
    Out: function(o) {
      return this.None(o);
    },
    InOut: function(o) {
      return this.None(o);
    }
  }),
  Quadratic: Object.freeze({
    In: function(o) {
      return o * o;
    },
    Out: function(o) {
      return o * (2 - o);
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o : -0.5 * (--o * (o - 2) - 1);
    }
  }),
  Cubic: Object.freeze({
    In: function(o) {
      return o * o * o;
    },
    Out: function(o) {
      return --o * o * o + 1;
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o * o : 0.5 * ((o -= 2) * o * o + 2);
    }
  }),
  Quartic: Object.freeze({
    In: function(o) {
      return o * o * o * o;
    },
    Out: function(o) {
      return 1 - --o * o * o * o;
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o * o * o : -0.5 * ((o -= 2) * o * o * o - 2);
    }
  }),
  Quintic: Object.freeze({
    In: function(o) {
      return o * o * o * o * o;
    },
    Out: function(o) {
      return --o * o * o * o * o + 1;
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o * o * o * o : 0.5 * ((o -= 2) * o * o * o * o + 2);
    }
  }),
  Sinusoidal: Object.freeze({
    In: function(o) {
      return 1 - Math.sin((1 - o) * Math.PI / 2);
    },
    Out: function(o) {
      return Math.sin(o * Math.PI / 2);
    },
    InOut: function(o) {
      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - o)));
    }
  }),
  Exponential: Object.freeze({
    In: function(o) {
      return o === 0 ? 0 : Math.pow(1024, o - 1);
    },
    Out: function(o) {
      return o === 1 ? 1 : 1 - Math.pow(2, -10 * o);
    },
    InOut: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : (o *= 2) < 1 ? 0.5 * Math.pow(1024, o - 1) : 0.5 * (-Math.pow(2, -10 * (o - 1)) + 2);
    }
  }),
  Circular: Object.freeze({
    In: function(o) {
      return 1 - Math.sqrt(1 - o * o);
    },
    Out: function(o) {
      return Math.sqrt(1 - --o * o);
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? -0.5 * (Math.sqrt(1 - o * o) - 1) : 0.5 * (Math.sqrt(1 - (o -= 2) * o) + 1);
    }
  }),
  Elastic: Object.freeze({
    In: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : -Math.pow(2, 10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI);
    },
    Out: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : Math.pow(2, -10 * o) * Math.sin((o - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : (o *= 2, o < 1 ? -0.5 * Math.pow(2, 10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI) + 1);
    }
  }),
  Back: Object.freeze({
    In: function(o) {
      var t = 1.70158;
      return o === 1 ? 1 : o * o * ((t + 1) * o - t);
    },
    Out: function(o) {
      var t = 1.70158;
      return o === 0 ? 0 : --o * o * ((t + 1) * o + t) + 1;
    },
    InOut: function(o) {
      var t = 2.5949095;
      return (o *= 2) < 1 ? 0.5 * (o * o * ((t + 1) * o - t)) : 0.5 * ((o -= 2) * o * ((t + 1) * o + t) + 2);
    }
  }),
  Bounce: Object.freeze({
    In: function(o) {
      return 1 - Easing.Bounce.Out(1 - o);
    },
    Out: function(o) {
      return o < 1 / 2.75 ? 7.5625 * o * o : o < 2 / 2.75 ? 7.5625 * (o -= 1.5 / 2.75) * o + 0.75 : o < 2.5 / 2.75 ? 7.5625 * (o -= 2.25 / 2.75) * o + 0.9375 : 7.5625 * (o -= 2.625 / 2.75) * o + 0.984375;
    },
    InOut: function(o) {
      return o < 0.5 ? Easing.Bounce.In(o * 2) * 0.5 : Easing.Bounce.Out(o * 2 - 1) * 0.5 + 0.5;
    }
  }),
  generatePow: function(o) {
    return o === void 0 && (o = 4), o = o < Number.EPSILON ? Number.EPSILON : o, o = o > 1e4 ? 1e4 : o, {
      In: function(t) {
        return Math.pow(t, o);
      },
      Out: function(t) {
        return 1 - Math.pow(1 - t, o);
      },
      InOut: function(t) {
        return t < 0.5 ? Math.pow(t * 2, o) / 2 : (1 - Math.pow(2 - t * 2, o)) / 2 + 0.5;
      }
    };
  }
}), now$1 = function() {
  return performance.now();
}, Group = (
  /** @class */
  function() {
    function o() {
      this._tweens = {}, this._tweensAddedDuringUpdate = {};
    }
    return o.prototype.getAll = function() {
      var t = this;
      return Object.keys(this._tweens).map(function(e) {
        return t._tweens[e];
      });
    }, o.prototype.removeAll = function() {
      this._tweens = {};
    }, o.prototype.add = function(t) {
      this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t;
    }, o.prototype.remove = function(t) {
      delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()];
    }, o.prototype.update = function(t, e) {
      t === void 0 && (t = now$1()), e === void 0 && (e = !1);
      var r = Object.keys(this._tweens);
      if (r.length === 0)
        return !1;
      for (; r.length > 0; ) {
        this._tweensAddedDuringUpdate = {};
        for (var D = 0; D < r.length; D++) {
          var N = this._tweens[r[D]], k = !e;
          N && N.update(t, k) === !1 && !e && delete this._tweens[r[D]];
        }
        r = Object.keys(this._tweensAddedDuringUpdate);
      }
      return !0;
    }, o;
  }()
), Interpolation = {
  Linear: function(o, t) {
    var e = o.length - 1, r = e * t, D = Math.floor(r), N = Interpolation.Utils.Linear;
    return t < 0 ? N(o[0], o[1], r) : t > 1 ? N(o[e], o[e - 1], e - r) : N(o[D], o[D + 1 > e ? e : D + 1], r - D);
  },
  Bezier: function(o, t) {
    for (var e = 0, r = o.length - 1, D = Math.pow, N = Interpolation.Utils.Bernstein, k = 0; k <= r; k++)
      e += D(1 - t, r - k) * D(t, k) * o[k] * N(r, k);
    return e;
  },
  CatmullRom: function(o, t) {
    var e = o.length - 1, r = e * t, D = Math.floor(r), N = Interpolation.Utils.CatmullRom;
    return o[0] === o[e] ? (t < 0 && (D = Math.floor(r = e * (1 + t))), N(o[(D - 1 + e) % e], o[D], o[(D + 1) % e], o[(D + 2) % e], r - D)) : t < 0 ? o[0] - (N(o[0], o[0], o[1], o[1], -r) - o[0]) : t > 1 ? o[e] - (N(o[e], o[e], o[e - 1], o[e - 1], r - e) - o[e]) : N(o[D ? D - 1 : 0], o[D], o[e < D + 1 ? e : D + 1], o[e < D + 2 ? e : D + 2], r - D);
  },
  Utils: {
    Linear: function(o, t, e) {
      return (t - o) * e + o;
    },
    Bernstein: function(o, t) {
      var e = Interpolation.Utils.Factorial;
      return e(o) / e(t) / e(o - t);
    },
    Factorial: function() {
      var o = [1];
      return function(t) {
        var e = 1;
        if (o[t])
          return o[t];
        for (var r = t; r > 1; r--)
          e *= r;
        return o[t] = e, e;
      };
    }(),
    CatmullRom: function(o, t, e, r, D) {
      var N = (e - o) * 0.5, k = (r - t) * 0.5, $ = D * D, G = D * $;
      return (2 * t - 2 * e + N + k) * G + (-3 * t + 3 * e - 2 * N - k) * $ + N * D + t;
    }
  }
}, Sequence = (
  /** @class */
  function() {
    function o() {
    }
    return o.nextId = function() {
      return o._nextId++;
    }, o._nextId = 0, o;
  }()
), mainGroup = new Group(), Tween = (
  /** @class */
  function() {
    function o(t, e) {
      e === void 0 && (e = mainGroup), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = !1, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = Easing.Linear.None, this._interpolationFunction = Interpolation.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = Sequence.nextId(), this._isChainStopped = !1, this._propertiesAreSetUp = !1, this._goToEnd = !1;
    }
    return o.prototype.getId = function() {
      return this._id;
    }, o.prototype.isPlaying = function() {
      return this._isPlaying;
    }, o.prototype.isPaused = function() {
      return this._isPaused;
    }, o.prototype.to = function(t, e) {
      if (e === void 0 && (e = 1e3), this._isPlaying)
        throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
      return this._valuesEnd = t, this._propertiesAreSetUp = !1, this._duration = e, this;
    }, o.prototype.duration = function(t) {
      return t === void 0 && (t = 1e3), this._duration = t, this;
    }, o.prototype.dynamic = function(t) {
      return t === void 0 && (t = !1), this._isDynamic = t, this;
    }, o.prototype.start = function(t, e) {
      if (t === void 0 && (t = now$1()), e === void 0 && (e = !1), this._isPlaying)
        return this;
      if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {
        this._reversed = !1;
        for (var r in this._valuesStartRepeat)
          this._swapEndStartRepeatValues(r), this._valuesStart[r] = this._valuesStartRepeat[r];
      }
      if (this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t, this._startTime += this._delayTime, !this._propertiesAreSetUp || e) {
        if (this._propertiesAreSetUp = !0, !this._isDynamic) {
          var D = {};
          for (var N in this._valuesEnd)
            D[N] = this._valuesEnd[N];
          this._valuesEnd = D;
        }
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, e);
      }
      return this;
    }, o.prototype.startFromCurrentValues = function(t) {
      return this.start(t, !0);
    }, o.prototype._setupProperties = function(t, e, r, D, N) {
      for (var k in r) {
        var $ = t[k], G = Array.isArray($), U = G ? "array" : typeof $, z = !G && Array.isArray(r[k]);
        if (!(U === "undefined" || U === "function")) {
          if (z) {
            var X = r[k];
            if (X.length === 0)
              continue;
            for (var V = [$], Y = 0, W = X.length; Y < W; Y += 1) {
              var q = this._handleRelativeValue($, X[Y]);
              if (isNaN(q)) {
                z = !1, console.warn("Found invalid interpolation list. Skipping.");
                break;
              }
              V.push(q);
            }
            z && (r[k] = V);
          }
          if ((U === "object" || G) && $ && !z) {
            e[k] = G ? [] : {};
            var K = $;
            for (var Z in K)
              e[k][Z] = K[Z];
            D[k] = G ? [] : {};
            var X = r[k];
            if (!this._isDynamic) {
              var J = {};
              for (var Z in X)
                J[Z] = X[Z];
              r[k] = X = J;
            }
            this._setupProperties(K, e[k], X, D[k], N);
          } else
            (typeof e[k] > "u" || N) && (e[k] = $), G || (e[k] *= 1), z ? D[k] = r[k].slice().reverse() : D[k] = e[k] || 0;
        }
      }
    }, o.prototype.stop = function() {
      return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
    }, o.prototype.end = function() {
      return this._goToEnd = !0, this.update(1 / 0), this;
    }, o.prototype.pause = function(t) {
      return t === void 0 && (t = now$1()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this), this);
    }, o.prototype.resume = function(t) {
      return t === void 0 && (t = now$1()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);
    }, o.prototype.stopChainedTweens = function() {
      for (var t = 0, e = this._chainedTweens.length; t < e; t++)
        this._chainedTweens[t].stop();
      return this;
    }, o.prototype.group = function(t) {
      return t === void 0 && (t = mainGroup), this._group = t, this;
    }, o.prototype.delay = function(t) {
      return t === void 0 && (t = 0), this._delayTime = t, this;
    }, o.prototype.repeat = function(t) {
      return t === void 0 && (t = 0), this._initialRepeat = t, this._repeat = t, this;
    }, o.prototype.repeatDelay = function(t) {
      return this._repeatDelayTime = t, this;
    }, o.prototype.yoyo = function(t) {
      return t === void 0 && (t = !1), this._yoyo = t, this;
    }, o.prototype.easing = function(t) {
      return t === void 0 && (t = Easing.Linear.None), this._easingFunction = t, this;
    }, o.prototype.interpolation = function(t) {
      return t === void 0 && (t = Interpolation.Linear), this._interpolationFunction = t, this;
    }, o.prototype.chain = function() {
      for (var t = [], e = 0; e < arguments.length; e++)
        t[e] = arguments[e];
      return this._chainedTweens = t, this;
    }, o.prototype.onStart = function(t) {
      return this._onStartCallback = t, this;
    }, o.prototype.onEveryStart = function(t) {
      return this._onEveryStartCallback = t, this;
    }, o.prototype.onUpdate = function(t) {
      return this._onUpdateCallback = t, this;
    }, o.prototype.onRepeat = function(t) {
      return this._onRepeatCallback = t, this;
    }, o.prototype.onComplete = function(t) {
      return this._onCompleteCallback = t, this;
    }, o.prototype.onStop = function(t) {
      return this._onStopCallback = t, this;
    }, o.prototype.update = function(t, e) {
      if (t === void 0 && (t = now$1()), e === void 0 && (e = !0), this._isPaused)
        return !0;
      var r, D, N = this._startTime + this._duration;
      if (!this._goToEnd && !this._isPlaying) {
        if (t > N)
          return !1;
        e && this.start(t, !0);
      }
      if (this._goToEnd = !1, t < this._startTime)
        return !0;
      this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), this._onEveryStartCallbackFired === !1 && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0), D = (t - this._startTime) / this._duration, D = this._duration === 0 || D > 1 ? 1 : D;
      var k = this._easingFunction(D);
      if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, k), this._onUpdateCallback && this._onUpdateCallback(this._object, D), D === 1)
        if (this._repeat > 0) {
          isFinite(this._repeat) && this._repeat--;
          for (r in this._valuesStartRepeat)
            !this._yoyo && typeof this._valuesEnd[r] == "string" && (this._valuesStartRepeat[r] = // eslint-disable-next-line
            // @ts-ignore FIXME?
            this._valuesStartRepeat[r] + parseFloat(this._valuesEnd[r])), this._yoyo && this._swapEndStartRepeatValues(r), this._valuesStart[r] = this._valuesStartRepeat[r];
          return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0;
        } else {
          this._onCompleteCallback && this._onCompleteCallback(this._object);
          for (var $ = 0, G = this._chainedTweens.length; $ < G; $++)
            this._chainedTweens[$].start(this._startTime + this._duration, !1);
          return this._isPlaying = !1, !1;
        }
      return !0;
    }, o.prototype._updateProperties = function(t, e, r, D) {
      for (var N in r)
        if (e[N] !== void 0) {
          var k = e[N] || 0, $ = r[N], G = Array.isArray(t[N]), U = Array.isArray($), z = !G && U;
          z ? t[N] = this._interpolationFunction($, D) : typeof $ == "object" && $ ? this._updateProperties(t[N], k, $, D) : ($ = this._handleRelativeValue(k, $), typeof $ == "number" && (t[N] = k + ($ - k) * D));
        }
    }, o.prototype._handleRelativeValue = function(t, e) {
      return typeof e != "string" ? e : e.charAt(0) === "+" || e.charAt(0) === "-" ? t + parseFloat(e) : parseFloat(e);
    }, o.prototype._swapEndStartRepeatValues = function(t) {
      var e = this._valuesStartRepeat[t], r = this._valuesEnd[t];
      typeof r == "string" ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(r) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = e;
    }, o;
  }()
), TWEEN = mainGroup;
TWEEN.getAll.bind(TWEEN);
var removeAll = TWEEN.removeAll.bind(TWEEN);
TWEEN.add.bind(TWEEN);
var remove$6 = TWEEN.remove.bind(TWEEN), update = TWEEN.update.bind(TWEEN), So;
const Wu = class {
  static ease(t) {
    if (!t)
      return (e) => Easing.Linear.None(e);
    if (!(t in H(Wu, So)))
      throw "異常なease指定です";
    return H(Wu, So)[t];
  }
};
let CmnTween = Wu;
So = new WeakMap(), rt(CmnTween, So, {
  "Back.In": (t) => Easing.Back.In(t),
  "Back.InOut": (t) => Easing.Back.InOut(t),
  "Back.Out": (t) => Easing.Back.Out(t),
  "Bounce.In": (t) => Easing.Bounce.In(t),
  "Bounce.InOut": (t) => Easing.Bounce.InOut(t),
  "Bounce.Out": (t) => Easing.Bounce.Out(t),
  "Circular.In": (t) => Easing.Circular.In(t),
  "Circular.InOut": (t) => Easing.Circular.InOut(t),
  "Circular.Out": (t) => Easing.Circular.Out(t),
  "Cubic.In": (t) => Easing.Cubic.In(t),
  "Cubic.InOut": (t) => Easing.Cubic.InOut(t),
  "Cubic.Out": (t) => Easing.Cubic.Out(t),
  "Elastic.In": (t) => Easing.Elastic.In(t),
  "Elastic.InOut": (t) => Easing.Elastic.InOut(t),
  "Elastic.Out": (t) => Easing.Elastic.Out(t),
  "Exponential.In": (t) => Easing.Exponential.In(t),
  "Exponential.InOut": (t) => Easing.Exponential.InOut(t),
  "Exponential.Out": (t) => Easing.Exponential.Out(t),
  "Linear.None": (t) => Easing.Linear.None(t),
  "Quadratic.In": (t) => Easing.Quadratic.In(t),
  "Quadratic.InOut": (t) => Easing.Quadratic.InOut(t),
  "Quadratic.Out": (t) => Easing.Quadratic.Out(t),
  "Quartic.In": (t) => Easing.Quartic.In(t),
  "Quartic.InOut": (t) => Easing.Quartic.InOut(t),
  "Quartic.Out": (t) => Easing.Quartic.Out(t),
  "Quintic.In": (t) => Easing.Quintic.In(t),
  "Quintic.InOut": (t) => Easing.Quintic.InOut(t),
  "Quintic.Out": (t) => Easing.Quintic.Out(t),
  "Sinusoidal.In": (t) => Easing.Sinusoidal.In(t),
  "Sinusoidal.InOut": (t) => Easing.Sinusoidal.InOut(t),
  "Sinusoidal.Out": (t) => Easing.Sinusoidal.Out(t)
});
/*!
 * @pixi/sound - v4.3.3
 * https://github.com/pixijs/pixi-sound
 * Compiled Fri, 10 Mar 2023 17:19:30 UTC
 *
 * @pixi/sound is licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license
 */
var s;
function u() {
  return s;
}
var a = function(o, t) {
  return (a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      Object.prototype.hasOwnProperty.call(r, D) && (e[D] = r[D]);
  })(o, t);
};
function c(o, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function e() {
    this.constructor = o;
  }
  a(o, t), o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var l = function() {
  return (l = Object.assign || function(o) {
    for (var t, e = 1, r = arguments.length; e < r; e++)
      for (var D in t = arguments[e])
        Object.prototype.hasOwnProperty.call(t, D) && (o[D] = t[D]);
    return o;
  }).apply(this, arguments);
}, p = ["mp3", "ogg", "oga", "opus", "mpeg", "wav", "m4a", "aiff", "wma", "mid", "caf"], h = {};
function f(o) {
  var t = l({ m4a: "audio/mp4", oga: "audio/ogg", opus: 'audio/ogg; codecs="opus"', caf: 'audio/x-caf; codecs="opus"' }, o || {}), e = document.createElement("audio"), r = {}, D = /^no$/;
  p.forEach(function(N) {
    var k = e.canPlayType("audio/".concat(N)).replace(D, ""), $ = t[N] ? e.canPlayType(t[N]).replace(D, "") : "";
    r[N] = !!k || !!$;
  }), Object.assign(h, r);
}
f();
var d = /\.(\{([^\}]+)\})(\?.*)?$/;
function _(o) {
  var t = d, e = typeof o == "string" ? o : o.url;
  if (!t.test(e))
    return e;
  for (var r = t.exec(e), D = r[2].split(","), N = D[D.length - 1], k = 0, $ = D.length; k < $; k++) {
    var G = D[k];
    if (h[G]) {
      N = G;
      break;
    }
  }
  var U = e.replace(r[1], N);
  if (typeof o != "string") {
    var z = o;
    z.extension = N, z.url = U;
  }
  return U;
}
var y = p.filter(function(o) {
  return h[o];
}), m = function() {
  function o() {
  }
  return o.add = function() {
    o.setLegacy(u().useLegacy);
  }, o.setLegacy = function(t) {
    t ? y.forEach(function(e) {
      LoaderResource.setExtensionXhrType(e, LoaderResource.XHR_RESPONSE_TYPE.DEFAULT), LoaderResource.setExtensionLoadType(e, LoaderResource.LOAD_TYPE.AUDIO);
    }) : y.forEach(function(e) {
      LoaderResource.setExtensionXhrType(e, LoaderResource.XHR_RESPONSE_TYPE.BUFFER), LoaderResource.setExtensionLoadType(e, LoaderResource.LOAD_TYPE.XHR);
    });
  }, o.pre = function(t, e) {
    _(t), e();
  }, o.use = function(t, e) {
    t.data && y.indexOf(t.extension) > -1 ? t.sound = u().add(t.name, { loaded: e, preload: !0, url: t.url, source: t.data }) : e();
  }, o.extension = "loader", o;
}(), b = 0, g = function(o) {
  function t(e) {
    var r = o.call(this) || this;
    return r.id = b++, r.init(e), r;
  }
  return c(t, o), t.prototype.set = function(e, r) {
    if (this[e] === void 0)
      throw new Error("Property with name ".concat(e, " does not exist."));
    switch (e) {
      case "speed":
        this.speed = r;
        break;
      case "volume":
        this.volume = r;
        break;
      case "paused":
        this.paused = r;
        break;
      case "loop":
        this.loop = r;
        break;
      case "muted":
        this.muted = r;
    }
    return this;
  }, Object.defineProperty(t.prototype, "progress", { get: function() {
    return this._source.currentTime / this._duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    this._paused = e, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), t.prototype._onPlay = function() {
    this._playing = !0;
  }, t.prototype._onPause = function() {
    this._playing = !1;
  }, t.prototype.init = function(e) {
    this._playing = !1, this._duration = e.source.duration;
    var r = this._source = e.source.cloneNode(!1);
    r.src = e.parent.url, r.onplay = this._onPlay.bind(this), r.onpause = this._onPause.bind(this), e.context.on("refresh", this.refresh, this), e.context.on("refreshPaused", this.refreshPaused, this), this._media = e;
  }, t.prototype._internalStop = function() {
    this._source && this._playing && (this._source.onended = null, this._source.pause());
  }, t.prototype.stop = function() {
    this._internalStop(), this._source && this.emit("stop");
  }, Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(e) {
    this._speed = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(e) {
    this._volume = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(e) {
    this._loop = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(e) {
    this._muted = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    var e = this._media.context, r = this._media.parent;
    this._source.loop = this._loop || r.loop;
    var D = e.volume * (e.muted ? 0 : 1), N = r.volume * (r.muted ? 0 : 1), k = this._volume * (this._muted ? 0 : 1);
    this._source.volume = k * D * N, this._source.playbackRate = this._speed * e.speed * r.speed;
  }, t.prototype.refreshPaused = function() {
    var e = this._media.context, r = this._media.parent, D = this._paused || r.paused || e.paused;
    D !== this._pausedReal && (this._pausedReal = D, D ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop })), this.emit("pause", D));
  }, t.prototype.play = function(e) {
    var r = this, D = e.start, N = e.end, k = e.speed, $ = e.loop, G = e.volume, U = e.muted;
    this._speed = k, this._volume = G, this._loop = !!$, this._muted = U, this.refresh(), this.loop && N !== null && (this.loop = !1), this._start = D, this._end = N || this._duration, this._start = Math.max(0, this._start - t.PADDING), this._end = Math.min(this._end + t.PADDING, this._duration), this._source.onloadedmetadata = function() {
      r._source && (r._source.currentTime = D, r._source.onloadedmetadata = null, r.emit("progress", D, r._duration), Ticker.shared.add(r._onUpdate, r));
    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit("start");
  }, t.prototype._onUpdate = function() {
    this.emit("progress", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();
  }, t.prototype._onComplete = function() {
    Ticker.shared.remove(this._onUpdate, this), this._internalStop(), this.emit("progress", 1, this._duration), this.emit("end", this);
  }, t.prototype.destroy = function() {
    Ticker.shared.remove(this._onUpdate, this), this.removeAllListeners();
    var e = this._source;
    e && (e.onended = null, e.onplay = null, e.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = !1, this._end = null, this._start = 0, this._duration = 0, this._playing = !1, this._pausedReal = !1, this._paused = !1, this._muted = !1, this._media && (this._media.context.off("refresh", this.refresh, this), this._media.context.off("refreshPaused", this.refreshPaused, this), this._media = null);
  }, t.prototype.toString = function() {
    return "[HTMLAudioInstance id=".concat(this.id, "]");
  }, t.PADDING = 0.1, t;
}(i$1), v = function(o) {
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  return c(t, o), t.prototype.init = function(e) {
    this.parent = e, this._source = e.options.source || new Audio(), e.url && (this._source.src = e.url);
  }, t.prototype.create = function() {
    return new g(this);
  }, Object.defineProperty(t.prototype, "isPlayable", { get: function() {
    return !!this._source && this._source.readyState === 4;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "duration", { get: function() {
    return this._source.duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = "", this._source.load(), this._source = null);
  }, Object.defineProperty(t.prototype, "source", { get: function() {
    return this._source;
  }, enumerable: !1, configurable: !0 }), t.prototype.load = function(e) {
    var r = this._source, D = this.parent;
    if (r.readyState !== 4)
      if (D.url) {
        r.src = D.url;
        var N = function() {
          G(), D.isLoaded = !0;
          var z = D.autoPlayStart();
          e && e(null, D, z);
        }, k = function() {
          G(), e && e(new Error("Sound loading has been aborted"));
        }, $ = function() {
          G();
          var z = "Failed to load audio element (code: ".concat(r.error.code, ")");
          e && e(new Error(z));
        }, G = function() {
          r.removeEventListener("canplaythrough", N), r.removeEventListener("load", N), r.removeEventListener("abort", k), r.removeEventListener("error", $);
        };
        r.addEventListener("canplaythrough", N, !1), r.addEventListener("load", N, !1), r.addEventListener("abort", k, !1), r.addEventListener("error", $, !1), r.load();
      } else
        e(new Error("sound.url or sound.source must be set"));
    else {
      D.isLoaded = !0;
      var U = D.autoPlayStart();
      e && setTimeout(function() {
        e(null, D, U);
      }, 0);
    }
  }, t;
}(i$1), P = function() {
  function o(t, e) {
    this.parent = t, Object.assign(this, e), this.duration = this.end - this.start;
  }
  return o.prototype.play = function(t) {
    return this.parent.play({ complete: t, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop });
  }, o.prototype.destroy = function() {
    this.parent = null;
  }, o;
}(), x = function() {
  function o() {
  }
  return o.setParamValue = function(t, e) {
    if (t.setValueAtTime) {
      var r = u().context;
      t.setValueAtTime(e, r.audioContext.currentTime);
    } else
      t.value = e;
    return e;
  }, o;
}(), O = 0, j = function(o) {
  function t(e) {
    var r = o.call(this) || this;
    return r.id = O++, r._media = null, r._paused = !1, r._muted = !1, r._elapsed = 0, r.init(e), r;
  }
  return c(t, o), t.prototype.set = function(e, r) {
    if (this[e] === void 0)
      throw new Error("Property with name ".concat(e, " does not exist."));
    switch (e) {
      case "speed":
        this.speed = r;
        break;
      case "volume":
        this.volume = r;
        break;
      case "muted":
        this.muted = r;
        break;
      case "loop":
        this.loop = r;
        break;
      case "paused":
        this.paused = r;
    }
    return this;
  }, t.prototype.stop = function() {
    this._source && (this._internalStop(), this.emit("stop"));
  }, Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(e) {
    this._speed = e, this.refresh(), this._update(!0);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(e) {
    this._volume = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(e) {
    this._muted = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(e) {
    this._loop = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(e) {
    var r;
    this._filters && ((r = this._filters) === null || r === void 0 || r.filter(function(D) {
      return D;
    }).forEach(function(D) {
      return D.disconnect();
    }), this._filters = null, this._source.connect(this._gain)), this._filters = e != null && e.length ? e.slice(0) : null, this.refresh();
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    if (this._source) {
      var e = this._media.context, r = this._media.parent;
      this._source.loop = this._loop || r.loop;
      var D = e.volume * (e.muted ? 0 : 1), N = r.volume * (r.muted ? 0 : 1), k = this._volume * (this._muted ? 0 : 1);
      x.setParamValue(this._gain.gain, k * N * D), x.setParamValue(this._source.playbackRate, this._speed * r.speed * e.speed), this.applyFilters();
    }
  }, t.prototype.applyFilters = function() {
    var e;
    if (!((e = this._filters) === null || e === void 0) && e.length) {
      this._source.disconnect();
      var r = this._source;
      this._filters.forEach(function(D) {
        r.connect(D.destination), r = D;
      }), r.connect(this._gain);
    }
  }, t.prototype.refreshPaused = function() {
    var e = this._media.context, r = this._media.parent, D = this._paused || r.paused || e.paused;
    D !== this._pausedReal && (this._pausedReal = D, D ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume })), this.emit("pause", D));
  }, t.prototype.play = function(e) {
    var r = e.start, D = e.end, N = e.speed, k = e.loop, $ = e.volume, G = e.muted, U = e.filters;
    this._paused = !1;
    var z = this._media.nodes.cloneBufferSource(), X = z.source, V = z.gain;
    this._source = X, this._gain = V, this._speed = N, this._volume = $, this._loop = !!k, this._muted = G, this._filters = U, this.refresh();
    var Y = this._source.buffer.duration;
    this._duration = Y, this._end = D, this._lastUpdate = this._now(), this._elapsed = r, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = D, this._source.loopStart = r, this._source.start(0, r)) : D ? this._source.start(0, r, D - r) : this._source.start(0, r), this.emit("start"), this._update(!0), this.enableTicker(!0);
  }, t.prototype.enableTicker = function(e) {
    Ticker.shared.remove(this._updateListener, this), e && Ticker.shared.add(this._updateListener, this);
  }, Object.defineProperty(t.prototype, "progress", { get: function() {
    return this._progress;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    this._paused = e, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    var e;
    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off("refresh", this.refresh, this), this._media.context.events.off("refreshPaused", this.refreshPaused, this), this._media = null), (e = this._filters) === null || e === void 0 || e.forEach(function(r) {
      return r.disconnect();
    }), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = !1, this._elapsed = 0, this._duration = 0, this._paused = !1, this._muted = !1, this._pausedReal = !1;
  }, t.prototype.toString = function() {
    return "[WebAudioInstance id=".concat(this.id, "]");
  }, t.prototype._now = function() {
    return this._media.context.audioContext.currentTime;
  }, t.prototype._updateListener = function() {
    this._update();
  }, t.prototype._update = function(e) {
    if (e === void 0 && (e = !1), this._source) {
      var r = this._now(), D = r - this._lastUpdate;
      if (D > 0 || e) {
        var N = this._source.playbackRate.value;
        this._elapsed += D * N, this._lastUpdate = r;
        var k = this._duration, $ = void 0;
        if (this._source.loopStart) {
          var G = this._source.loopEnd - this._source.loopStart;
          $ = (this._source.loopStart + this._elapsed % G) / k;
        } else
          $ = this._elapsed % k / k;
        this._progress = $, this.emit("progress", this._progress, k);
      }
    }
  }, t.prototype.init = function(e) {
    this._media = e, e.context.events.on("refresh", this.refresh, this), e.context.events.on("refreshPaused", this.refreshPaused, this);
  }, t.prototype._internalStop = function() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.stop(0), this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch {
      }
      this._source = null;
    }
  }, t.prototype._onComplete = function() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch {
      }
    }
    this._source = null, this._progress = 1, this.emit("progress", 1, this._duration), this.emit("end", this);
  }, t;
}(i$1), w = function() {
  function o(t, e) {
    this._output = e, this._input = t;
  }
  return Object.defineProperty(o.prototype, "destination", { get: function() {
    return this._input;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(t) {
    var e = this;
    if (this._filters && (this._filters.forEach(function(D) {
      D && D.disconnect();
    }), this._filters = null, this._input.connect(this._output)), t && t.length) {
      this._filters = t.slice(0), this._input.disconnect();
      var r = null;
      t.forEach(function(D) {
        r === null ? e._input.connect(D.destination) : r.connect(D.destination), r = D;
      }), r.connect(this._output);
    }
  }, enumerable: !1, configurable: !0 }), o.prototype.destroy = function() {
    this.filters = null, this._input = null, this._output = null;
  }, o;
}(), A = function(o) {
  function t(e) {
    var r = this, D = e.audioContext, N = D.createBufferSource(), k = D.createGain(), $ = D.createAnalyser();
    return N.connect($), $.connect(k), k.connect(e.destination), (r = o.call(this, $, k) || this).context = e, r.bufferSource = N, r.gain = k, r.analyser = $, r;
  }
  return c(t, o), Object.defineProperty(t.prototype, "script", { get: function() {
    return this._script || (this._script = this.context.audioContext.createScriptProcessor(t.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    o.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;
  }, t.prototype.cloneBufferSource = function() {
    var e = this.bufferSource, r = this.context.audioContext.createBufferSource();
    r.buffer = e.buffer, x.setParamValue(r.playbackRate, e.playbackRate.value), r.loop = e.loop;
    var D = this.context.audioContext.createGain();
    return r.connect(D), D.connect(this.destination), { source: r, gain: D };
  }, Object.defineProperty(t.prototype, "bufferSize", { get: function() {
    return this.script.bufferSize;
  }, enumerable: !1, configurable: !0 }), t.BUFFER_SIZE = 0, t;
}(w), F = function() {
  function o() {
  }
  return o.prototype.init = function(t) {
    this.parent = t, this._nodes = new A(this.context), this._source = this._nodes.bufferSource, this.source = t.options.source;
  }, o.prototype.destroy = function() {
    this.parent = null, this._nodes.destroy(), this._nodes = null;
    try {
      this._source.buffer = null;
    } catch {
    }
    this._source = null, this.source = null;
  }, o.prototype.create = function() {
    return new j(this);
  }, Object.defineProperty(o.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "isPlayable", { get: function() {
    return !!this._source && !!this._source.buffer;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "filters", { get: function() {
    return this._nodes.filters;
  }, set: function(t) {
    this._nodes.filters = t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "duration", { get: function() {
    return this._source.buffer.duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "buffer", { get: function() {
    return this._source.buffer;
  }, set: function(t) {
    this._source.buffer = t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "nodes", { get: function() {
    return this._nodes;
  }, enumerable: !1, configurable: !0 }), o.prototype.load = function(t) {
    this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t && t(new Error("sound.url or sound.source must be set"));
  }, o.prototype._loadUrl = function(t) {
    var e = this, r = new XMLHttpRequest(), D = this.parent.url;
    r.open("GET", D, !0), r.responseType = "arraybuffer", r.onload = function() {
      e.source = r.response, e._decode(r.response, t);
    }, r.send();
  }, o.prototype._decode = function(t, e) {
    var r = this, D = function(N, k) {
      if (N)
        e && e(N);
      else {
        r.parent.isLoaded = !0, r.buffer = k;
        var $ = r.parent.autoPlayStart();
        e && e(null, r.parent, $);
      }
    };
    t instanceof AudioBuffer ? D(null, t) : this.parent.context.decode(t, D);
  }, o;
}(), E = function() {
  function o(t, e) {
    this.media = t, this.options = e, this._instances = [], this._sprites = {}, this.media.init(this);
    var r = e.complete;
    this._autoPlayOptions = r ? { complete: r } : null, this.isLoaded = !1, this.isPlaying = !1, this.autoPlay = e.autoPlay, this.singleInstance = e.singleInstance, this.preload = e.preload || this.autoPlay, this.url = e.url, this.speed = e.speed, this.volume = e.volume, this.loop = e.loop, e.sprites && this.addSprites(e.sprites), this.preload && this._preload(e.loaded);
  }
  return o.from = function(t) {
    var e = {};
    return typeof t == "string" ? e.url = t : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? e.source = t : e = t, (e = l({ autoPlay: !1, singleInstance: !1, url: null, source: null, preload: !1, volume: 1, speed: 1, complete: null, loaded: null, loop: !1 }, e)).url && (e.url = _(e.url)), Object.freeze(e), new o(u().useLegacy ? new v() : new F(), e);
  }, Object.defineProperty(o.prototype, "context", { get: function() {
    return u().context;
  }, enumerable: !1, configurable: !0 }), o.prototype.pause = function() {
    return this.isPlaying = !1, this.paused = !0, this;
  }, o.prototype.resume = function() {
    return this.isPlaying = this._instances.length > 0, this.paused = !1, this;
  }, Object.defineProperty(o.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(t) {
    this._paused = t, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(t) {
    this._speed = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "filters", { get: function() {
    return this.media.filters;
  }, set: function(t) {
    this.media.filters = t;
  }, enumerable: !1, configurable: !0 }), o.prototype.addSprites = function(t, e) {
    if (typeof t == "object") {
      var r = {};
      for (var D in t)
        r[D] = this.addSprites(D, t[D]);
      return r;
    }
    var N = new P(this, e);
    return this._sprites[t] = N, N;
  }, o.prototype.destroy = function() {
    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;
  }, o.prototype.removeSprites = function(t) {
    if (t) {
      var e = this._sprites[t];
      e !== void 0 && (e.destroy(), delete this._sprites[t]);
    } else
      for (var r in this._sprites)
        this.removeSprites(r);
    return this;
  }, Object.defineProperty(o.prototype, "isPlayable", { get: function() {
    return this.isLoaded && this.media && this.media.isPlayable;
  }, enumerable: !1, configurable: !0 }), o.prototype.stop = function() {
    if (!this.isPlayable)
      return this.autoPlay = !1, this._autoPlayOptions = null, this;
    this.isPlaying = !1;
    for (var t = this._instances.length - 1; t >= 0; t--)
      this._instances[t].stop();
    return this;
  }, o.prototype.play = function(t, e) {
    var r, D = this;
    if (typeof t == "string" ? r = { sprite: k = t, loop: this.loop, complete: e } : typeof t == "function" ? (r = {}).complete = t : r = t, (r = l({ complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: !1, loop: !1 }, r || {})).sprite) {
      var N = r.sprite, k = this._sprites[N];
      r.start = k.start + (r.start || 0), r.end = k.end, r.speed = k.speed || 1, r.loop = k.loop || r.loop, delete r.sprite;
    }
    if (r.offset && (r.start = r.offset), !this.isLoaded)
      return new Promise(function(G, U) {
        D.autoPlay = !0, D._autoPlayOptions = r, D._preload(function(z, X, V) {
          z ? U(z) : (r.loaded && r.loaded(z, X, V), G(V));
        });
      });
    (this.singleInstance || r.singleInstance) && this._removeInstances();
    var $ = this._createInstance();
    return this._instances.push($), this.isPlaying = !0, $.once("end", function() {
      r.complete && r.complete(D), D._onComplete($);
    }), $.once("stop", function() {
      D._onComplete($);
    }), $.play(r), $;
  }, o.prototype.refresh = function() {
    for (var t = this._instances.length, e = 0; e < t; e++)
      this._instances[e].refresh();
  }, o.prototype.refreshPaused = function() {
    for (var t = this._instances.length, e = 0; e < t; e++)
      this._instances[e].refreshPaused();
  }, Object.defineProperty(o.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(t) {
    this._volume = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(t) {
    this._muted = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(t) {
    this._loop = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), o.prototype._preload = function(t) {
    this.media.load(t);
  }, Object.defineProperty(o.prototype, "instances", { get: function() {
    return this._instances;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "sprites", { get: function() {
    return this._sprites;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "duration", { get: function() {
    return this.media.duration;
  }, enumerable: !1, configurable: !0 }), o.prototype.autoPlayStart = function() {
    var t;
    return this.autoPlay && (t = this.play(this._autoPlayOptions)), t;
  }, o.prototype._removeInstances = function() {
    for (var t = this._instances.length - 1; t >= 0; t--)
      this._poolInstance(this._instances[t]);
    this._instances.length = 0;
  }, o.prototype._onComplete = function(t) {
    if (this._instances) {
      var e = this._instances.indexOf(t);
      e > -1 && this._instances.splice(e, 1), this.isPlaying = this._instances.length > 0;
    }
    this._poolInstance(t);
  }, o.prototype._createInstance = function() {
    if (o._pool.length > 0) {
      var t = o._pool.pop();
      return t.init(this.media), t;
    }
    return this.media.create();
  }, o.prototype._poolInstance = function(t) {
    t.destroy(), o._pool.indexOf(t) < 0 && o._pool.push(t);
  }, o._pool = [], o;
}(), L = function(o) {
  function t() {
    var e = o !== null && o.apply(this, arguments) || this;
    return e.speed = 1, e.muted = !1, e.volume = 1, e.paused = !1, e;
  }
  return c(t, o), t.prototype.refresh = function() {
    this.emit("refresh");
  }, t.prototype.refreshPaused = function() {
    this.emit("refreshPaused");
  }, Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "audioContext", { get: function() {
    return null;
  }, enumerable: !1, configurable: !0 }), t.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, t.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this.paused;
  }, t.prototype.destroy = function() {
    this.removeAllListeners();
  }, t;
}(i$1), C = function(o) {
  function t() {
    var e = this, r = window, D = new t.AudioContext(), N = D.createDynamicsCompressor(), k = D.createAnalyser();
    return k.connect(N), N.connect(D.destination), (e = o.call(this, k, N) || this)._ctx = D, e._offlineCtx = new t.OfflineAudioContext(1, 2, r.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, D.sampleRate)) : 44100), e.compressor = N, e.analyser = k, e.events = new i$1(), e.volume = 1, e.speed = 1, e.muted = !1, e.paused = !1, e._locked = D.state === "suspended" && ("ontouchstart" in globalThis || "onclick" in globalThis), e._locked && (e._unlock(), e._unlock = e._unlock.bind(e), document.addEventListener("mousedown", e._unlock, !0), document.addEventListener("touchstart", e._unlock, !0), document.addEventListener("touchend", e._unlock, !0)), e.onFocus = e.onFocus.bind(e), e.onBlur = e.onBlur.bind(e), globalThis.addEventListener("focus", e.onFocus), globalThis.addEventListener("blur", e.onBlur), e;
  }
  return c(t, o), t.prototype.onFocus = function() {
    var e = this._ctx.state;
    e !== "suspended" && e !== "interrupted" && this._locked || this._ctx.resume();
  }, t.prototype.onBlur = function() {
    this._locked || this._ctx.suspend();
  }, t.prototype._unlock = function() {
    this._locked && (this.playEmptySound(), this._ctx.state === "running" && (document.removeEventListener("mousedown", this._unlock, !0), document.removeEventListener("touchend", this._unlock, !0), document.removeEventListener("touchstart", this._unlock, !0), this._locked = !1));
  }, t.prototype.playEmptySound = function() {
    var e = this._ctx.createBufferSource();
    e.buffer = this._ctx.createBuffer(1, 1, 22050), e.connect(this._ctx.destination), e.start(0, 0, 0), e.context.state === "suspended" && e.context.resume();
  }, Object.defineProperty(t, "AudioContext", { get: function() {
    var e = window;
    return e.AudioContext || e.webkitAudioContext || null;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "OfflineAudioContext", { get: function() {
    var e = window;
    return e.OfflineAudioContext || e.webkitOfflineAudioContext || null;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    o.prototype.destroy.call(this);
    var e = this._ctx;
    e.close !== void 0 && e.close(), globalThis.removeEventListener("focus", this.onFocus), globalThis.removeEventListener("blur", this.onBlur), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;
  }, Object.defineProperty(t.prototype, "audioContext", { get: function() {
    return this._ctx;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "offlineContext", { get: function() {
    return this._offlineCtx;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    e && this._ctx.state === "running" ? this._ctx.suspend() : e || this._ctx.state !== "suspended" || this._ctx.resume(), this._paused = e;
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    this.events.emit("refresh");
  }, t.prototype.refreshPaused = function() {
    this.events.emit("refreshPaused");
  }, t.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, t.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this._paused;
  }, t.prototype.decode = function(e, r) {
    var D = function(k) {
      r(new Error((k == null ? void 0 : k.message) || "Unable to decode file"));
    }, N = this._offlineCtx.decodeAudioData(e, function(k) {
      r(null, k);
    }, D);
    N && N.catch(D);
  }, t;
}(w), S = function() {
  function o() {
    this.init();
  }
  return o.prototype.init = function() {
    return this.supported && (this._webAudioContext = new C()), this._htmlAudioContext = new L(), this._sounds = {}, this.useLegacy = !this.supported, this;
  }, Object.defineProperty(o.prototype, "context", { get: function() {
    return this._context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "filtersAll", { get: function() {
    return this.useLegacy ? [] : this._context.filters;
  }, set: function(t) {
    this.useLegacy || (this._context.filters = t);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "supported", { get: function() {
    return C.AudioContext !== null;
  }, enumerable: !1, configurable: !0 }), o.prototype.add = function(t, e) {
    if (typeof t == "object") {
      var r = {};
      for (var D in t) {
        var N = this._getOptions(t[D], e);
        r[D] = this.add(D, N);
      }
      return r;
    }
    if (e instanceof E)
      return this._sounds[t] = e, e;
    var k = this._getOptions(e), $ = E.from(k);
    return this._sounds[t] = $, $;
  }, o.prototype._getOptions = function(t, e) {
    var r;
    return r = typeof t == "string" ? { url: t } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? { source: t } : t, r = l(l({}, r), e || {});
  }, Object.defineProperty(o.prototype, "useLegacy", { get: function() {
    return this._useLegacy;
  }, set: function(t) {
    m.setLegacy(t), this._useLegacy = t, this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext;
  }, enumerable: !1, configurable: !0 }), o.prototype.remove = function(t) {
    return this.exists(t, !0), this._sounds[t].destroy(), delete this._sounds[t], this;
  }, Object.defineProperty(o.prototype, "volumeAll", { get: function() {
    return this._context.volume;
  }, set: function(t) {
    this._context.volume = t, this._context.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "speedAll", { get: function() {
    return this._context.speed;
  }, set: function(t) {
    this._context.speed = t, this._context.refresh();
  }, enumerable: !1, configurable: !0 }), o.prototype.togglePauseAll = function() {
    return this._context.togglePause();
  }, o.prototype.pauseAll = function() {
    return this._context.paused = !0, this._context.refreshPaused(), this;
  }, o.prototype.resumeAll = function() {
    return this._context.paused = !1, this._context.refreshPaused(), this;
  }, o.prototype.toggleMuteAll = function() {
    return this._context.toggleMute();
  }, o.prototype.muteAll = function() {
    return this._context.muted = !0, this._context.refresh(), this;
  }, o.prototype.unmuteAll = function() {
    return this._context.muted = !1, this._context.refresh(), this;
  }, o.prototype.removeAll = function() {
    for (var t in this._sounds)
      this._sounds[t].destroy(), delete this._sounds[t];
    return this;
  }, o.prototype.stopAll = function() {
    for (var t in this._sounds)
      this._sounds[t].stop();
    return this;
  }, o.prototype.exists = function(t, e) {
    return !!this._sounds[t];
  }, o.prototype.find = function(t) {
    return this.exists(t, !0), this._sounds[t];
  }, o.prototype.play = function(t, e) {
    return this.find(t).play(e);
  }, o.prototype.stop = function(t) {
    return this.find(t).stop();
  }, o.prototype.pause = function(t) {
    return this.find(t).pause();
  }, o.prototype.resume = function(t) {
    return this.find(t).resume();
  }, o.prototype.volume = function(t, e) {
    var r = this.find(t);
    return e !== void 0 && (r.volume = e), r.volume;
  }, o.prototype.speed = function(t, e) {
    var r = this.find(t);
    return e !== void 0 && (r.speed = e), r.speed;
  }, o.prototype.duration = function(t) {
    return this.find(t).duration;
  }, o.prototype.close = function() {
    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;
  }, o;
}(), M = function() {
  function o(t, e) {
    this.init(t, e);
  }
  return o.prototype.init = function(t, e) {
    this.destination = t, this.source = e || t;
  }, o.prototype.connect = function(t) {
    this.source.connect(t);
  }, o.prototype.disconnect = function() {
    this.source.disconnect();
  }, o.prototype.destroy = function() {
    this.disconnect(), this.destination = null, this.source = null;
  }, o;
}(), T = { __proto__: null, Filter: M, EqualizerFilter: function(o) {
  function t(e, r, D, N, k, $, G, U, z, X) {
    e === void 0 && (e = 0), r === void 0 && (r = 0), D === void 0 && (D = 0), N === void 0 && (N = 0), k === void 0 && (k = 0), $ === void 0 && ($ = 0), G === void 0 && (G = 0), U === void 0 && (U = 0), z === void 0 && (z = 0), X === void 0 && (X = 0);
    var V = this;
    if (!u().useLegacy) {
      var Y = [{ f: t.F32, type: "lowshelf", gain: e }, { f: t.F64, type: "peaking", gain: r }, { f: t.F125, type: "peaking", gain: D }, { f: t.F250, type: "peaking", gain: N }, { f: t.F500, type: "peaking", gain: k }, { f: t.F1K, type: "peaking", gain: $ }, { f: t.F2K, type: "peaking", gain: G }, { f: t.F4K, type: "peaking", gain: U }, { f: t.F8K, type: "peaking", gain: z }, { f: t.F16K, type: "highshelf", gain: X }].map(function(K) {
        var Z = u().context.audioContext.createBiquadFilter();
        return Z.type = K.type, x.setParamValue(Z.Q, 1), Z.frequency.value = K.f, x.setParamValue(Z.gain, K.gain), Z;
      });
      (V = o.call(this, Y[0], Y[Y.length - 1]) || this).bands = Y, V.bandsMap = {};
      for (var W = 0; W < V.bands.length; W++) {
        var q = V.bands[W];
        W > 0 && V.bands[W - 1].connect(q), V.bandsMap[q.frequency.value] = q;
      }
      return V;
    }
    V = o.call(this, null) || this;
  }
  return c(t, o), t.prototype.setGain = function(e, r) {
    if (r === void 0 && (r = 0), !this.bandsMap[e])
      throw new Error("No band found for frequency ".concat(e));
    x.setParamValue(this.bandsMap[e].gain, r);
  }, t.prototype.getGain = function(e) {
    if (!this.bandsMap[e])
      throw new Error("No band found for frequency ".concat(e));
    return this.bandsMap[e].gain.value;
  }, Object.defineProperty(t.prototype, "f32", { get: function() {
    return this.getGain(t.F32);
  }, set: function(e) {
    this.setGain(t.F32, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f64", { get: function() {
    return this.getGain(t.F64);
  }, set: function(e) {
    this.setGain(t.F64, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f125", { get: function() {
    return this.getGain(t.F125);
  }, set: function(e) {
    this.setGain(t.F125, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f250", { get: function() {
    return this.getGain(t.F250);
  }, set: function(e) {
    this.setGain(t.F250, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f500", { get: function() {
    return this.getGain(t.F500);
  }, set: function(e) {
    this.setGain(t.F500, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f1k", { get: function() {
    return this.getGain(t.F1K);
  }, set: function(e) {
    this.setGain(t.F1K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f2k", { get: function() {
    return this.getGain(t.F2K);
  }, set: function(e) {
    this.setGain(t.F2K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f4k", { get: function() {
    return this.getGain(t.F4K);
  }, set: function(e) {
    this.setGain(t.F4K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f8k", { get: function() {
    return this.getGain(t.F8K);
  }, set: function(e) {
    this.setGain(t.F8K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f16k", { get: function() {
    return this.getGain(t.F16K);
  }, set: function(e) {
    this.setGain(t.F16K, e);
  }, enumerable: !1, configurable: !0 }), t.prototype.reset = function() {
    this.bands.forEach(function(e) {
      x.setParamValue(e.gain, 0);
    });
  }, t.prototype.destroy = function() {
    this.bands.forEach(function(e) {
      e.disconnect();
    }), this.bands = null, this.bandsMap = null;
  }, t.F32 = 32, t.F64 = 64, t.F125 = 125, t.F250 = 250, t.F500 = 500, t.F1K = 1e3, t.F2K = 2e3, t.F4K = 4e3, t.F8K = 8e3, t.F16K = 16e3, t;
}(M), DistortionFilter: function(o) {
  function t(e) {
    e === void 0 && (e = 0);
    var r = this;
    if (!u().useLegacy) {
      var D = u().context.audioContext.createWaveShaper();
      return (r = o.call(this, D) || this)._distortion = D, r.amount = e, r;
    }
    r = o.call(this, null) || this;
  }
  return c(t, o), Object.defineProperty(t.prototype, "amount", { get: function() {
    return this._amount;
  }, set: function(e) {
    this._amount = e;
    for (var r, D = 1e3 * e, N = 44100, k = new Float32Array(N), $ = Math.PI / 180, G = 0; G < N; ++G)
      r = 2 * G / N - 1, k[G] = (3 + D) * r * 20 * $ / (Math.PI + D * Math.abs(r));
    this._distortion.curve = k, this._distortion.oversample = "4x";
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this._distortion = null, o.prototype.destroy.call(this);
  }, t;
}(M), StereoFilter: function(o) {
  function t(e) {
    e === void 0 && (e = 0);
    var r = this;
    if (!u().useLegacy) {
      var D, N, k, $ = u().context.audioContext;
      return $.createStereoPanner ? k = D = $.createStereoPanner() : ((N = $.createPanner()).panningModel = "equalpower", k = N), (r = o.call(this, k) || this)._stereo = D, r._panner = N, r.pan = e, r;
    }
    r = o.call(this, null) || this;
  }
  return c(t, o), Object.defineProperty(t.prototype, "pan", { get: function() {
    return this._pan;
  }, set: function(e) {
    this._pan = e, this._stereo ? x.setParamValue(this._stereo.pan, e) : this._panner.setPosition(e, 0, 1 - Math.abs(e));
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    o.prototype.destroy.call(this), this._stereo = null, this._panner = null;
  }, t;
}(M), ReverbFilter: function(o) {
  function t(e, r, D) {
    e === void 0 && (e = 3), r === void 0 && (r = 2), D === void 0 && (D = !1);
    var N = this;
    if (!u().useLegacy)
      return (N = o.call(this, null) || this)._seconds = N._clamp(e, 1, 50), N._decay = N._clamp(r, 0, 100), N._reverse = D, N._rebuild(), N;
    N = o.call(this, null) || this;
  }
  return c(t, o), t.prototype._clamp = function(e, r, D) {
    return Math.min(D, Math.max(r, e));
  }, Object.defineProperty(t.prototype, "seconds", { get: function() {
    return this._seconds;
  }, set: function(e) {
    this._seconds = this._clamp(e, 1, 50), this._rebuild();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "decay", { get: function() {
    return this._decay;
  }, set: function(e) {
    this._decay = this._clamp(e, 0, 100), this._rebuild();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "reverse", { get: function() {
    return this._reverse;
  }, set: function(e) {
    this._reverse = e, this._rebuild();
  }, enumerable: !1, configurable: !0 }), t.prototype._rebuild = function() {
    for (var e, r = u().context.audioContext, D = r.sampleRate, N = D * this._seconds, k = r.createBuffer(2, N, D), $ = k.getChannelData(0), G = k.getChannelData(1), U = 0; U < N; U++)
      e = this._reverse ? N - U : U, $[U] = (2 * Math.random() - 1) * Math.pow(1 - e / N, this._decay), G[U] = (2 * Math.random() - 1) * Math.pow(1 - e / N, this._decay);
    var z = u().context.audioContext.createConvolver();
    z.buffer = k, this.init(z);
  }, t;
}(M), MonoFilter: function(o) {
  function t() {
    var e = this;
    if (!u().useLegacy) {
      var r = u().context.audioContext, D = r.createChannelSplitter(), N = r.createChannelMerger();
      return N.connect(D), (e = o.call(this, N, D) || this)._merger = N, e;
    }
    e = o.call(this, null) || this;
  }
  return c(t, o), t.prototype.destroy = function() {
    this._merger.disconnect(), this._merger = null, o.prototype.destroy.call(this);
  }, t;
}(M), StreamFilter: function(o) {
  function t() {
    var e = this;
    if (!u().useLegacy) {
      var r = u().context.audioContext, D = r.createMediaStreamDestination(), N = r.createMediaStreamSource(D.stream);
      return (e = o.call(this, D, N) || this)._stream = D.stream, e;
    }
    e = o.call(this, null) || this;
  }
  return c(t, o), Object.defineProperty(t.prototype, "stream", { get: function() {
    return this._stream;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this._stream = null, o.prototype.destroy.call(this);
  }, t;
}(M), TelephoneFilter: function(o) {
  function t() {
    if (!u().useLegacy) {
      var e = u().context.audioContext, r = e.createBiquadFilter(), D = e.createBiquadFilter(), N = e.createBiquadFilter(), k = e.createBiquadFilter();
      return r.type = "lowpass", x.setParamValue(r.frequency, 2e3), D.type = "lowpass", x.setParamValue(D.frequency, 2e3), N.type = "highpass", x.setParamValue(N.frequency, 500), k.type = "highpass", x.setParamValue(k.frequency, 500), r.connect(D), D.connect(N), N.connect(k), o.call(this, r, k) || this;
    }
    o.call(this, null);
  }
  return c(t, o), t;
}(M) }, I = 0, B = { __proto__: null, playOnce: function(o, t) {
  var e = "alias".concat(I++);
  return u().add(e, { url: o, preload: !0, autoPlay: !0, loaded: function(r) {
    r && (u().remove(e), t && t(r));
  }, complete: function() {
    u().remove(e), t && t(null);
  } }), e;
}, get PLAY_ID() {
  return I;
}, render: function(o, t) {
  var e = document.createElement("canvas");
  t = l({ width: 512, height: 128, fill: "black" }, t || {}), e.width = t.width, e.height = t.height;
  var r = BaseTexture.from(e);
  if (!(o.media instanceof F))
    return r;
  var D = o.media, N = e.getContext("2d");
  N.fillStyle = t.fill;
  for (var k = D.buffer.getChannelData(0), $ = Math.ceil(k.length / t.width), G = t.height / 2, U = 0; U < t.width; U++) {
    for (var z = 1, X = -1, V = 0; V < $; V++) {
      var Y = k[U * $ + V];
      Y < z && (z = Y), Y > X && (X = Y);
    }
    N.fillRect(U, (1 + z) * G, 1, Math.max(1, (X - z) * G));
  }
  return r;
}, resolveUrl: _, sineTone: function(o, t) {
  o === void 0 && (o = 200), t === void 0 && (t = 1);
  var e = E.from({ singleInstance: !0 });
  if (!(e.media instanceof F))
    return e;
  for (var r = e.media, D = e.context.audioContext.createBuffer(1, 48e3 * t, 48e3), N = D.getChannelData(0), k = 0; k < N.length; k++) {
    var $ = o * (k / D.sampleRate) * Math.PI;
    N[k] = 2 * Math.sin($);
  }
  return r.buffer = D, e.isLoaded = !0, e;
}, validateFormats: f, supported: h, extensions: p }, R = function(o) {
  return s = o, o;
}(new S());
"extensions" in n ? extensions.add(m) : Loader.registerPlugin(m);
var Pe, $e, Li, qu, sd, Fs, uu, Ku, ad, Zu, od, Eo, Qc, gn, Ha, To, tf, $s, Gs, hu, wo, ef, Co, Us, cu, Ju, ld, Gr, Ii, Qu, ud, Po, rf, mn, Va, th, hd, Mo, nf, eh, cd, rh, fd, js, fu;
const eo = class {
  constructor(t, e, r, D, N) {
    // 音量設定（独自拡張）
    rt(this, qu);
    rt(this, Fs);
    // BGM/効果音のフェードアウト（loadから使うのでマクロ化禁止）
    rt(this, Ku);
    // 効果音のフェードアウト（loadから使うのでマクロ化禁止）
    rt(this, Zu);
    // BGMのフェード（loadから使うのでマクロ化禁止）
    rt(this, Eo);
    // 効果音のフェード
    rt(this, gn);
    // BGM の演奏
    rt(this, To);
    rt(this, Gs);
    rt(this, wo);
    // 全効果音再生の停止
    rt(this, Us);
    // BGM 演奏の停止（loadから使うのでマクロ化禁止）
    rt(this, Ju);
    // 効果音再生の停止
    rt(this, Gr);
    // BGM フェードの終了待ち
    rt(this, Qu);
    // 効果音フェードの終了待ち
    rt(this, Po);
    // 音声フェードの停止
    rt(this, mn);
    // BGM 再生の終了待ち
    rt(this, th);
    // 効果音再生の終了待ち
    rt(this, Mo);
    // 再生トラックの交換
    rt(this, eh);
    rt(this, rh);
    rt(this, js);
    rt(this, Pe, {});
    rt(this, $e, {});
    rt(this, Li, void 0);
    rt(this, Co, () => {
      R.volumeAll = Number(this.val.getVal("sys:sn.sound.global_volume", 1)), ot(this, Co, () => {
      });
    });
    this.cfg = t, this.val = r, this.main = D, this.sys = N, e.volume = (k) => lt(this, qu, sd).call(this, k), e.fadebgm = (k) => lt(this, Eo, Qc).call(this, k), e.fadeoutbgm = (k) => lt(this, Ku, ad).call(this, k), e.fadeoutse = (k) => lt(this, Zu, od).call(this, k), e.fadese = (k) => lt(this, gn, Ha).call(this, k), e.playbgm = (k) => lt(this, To, tf).call(this, k), e.playse = (k) => lt(this, Gs, hu).call(this, k), e.stop_allse = () => lt(this, Us, cu).call(this), e.stopbgm = (k) => lt(this, Ju, ld).call(this, k), e.stopse = (k) => lt(this, Gr, Ii).call(this, k), e.wb = (k) => lt(this, Qu, ud).call(this, k), e.wf = (k) => lt(this, Po, rf).call(this, k), e.stopfadese = (k) => lt(this, mn, Va).call(this, k), e.wl = (k) => lt(this, th, hd).call(this, k), e.ws = (k) => lt(this, Mo, nf).call(this, k), e.xchgbuf = (k) => lt(this, eh, cd).call(this, k), this.val.setVal_Nochk("save", "const.sn.loopPlaying", "{}"), r.setVal_Nochk("tmp", "const.sn.sound.codecs", JSON.stringify(B.supported));
  }
  setEvtMng(t) {
    ot(this, Li, t);
  }
  setNoticeChgVolume(t, e) {
    this.val.defValTrg("sys:sn.sound.global_volume", (r, D) => t(R.volumeAll = Number(D))), this.val.defValTrg("sys:sn.sound.movie_volume", (r, D) => e(Number(D))), this.val.setVal_Nochk("sys", "sn.sound.global_volume", this.val.getVal("sys:sn.sound.global_volume", 1)), this.val.setVal_Nochk("sys", "sn.sound.movie_volume", this.val.getVal("sys:sn.sound.movie_volume", 1));
  }
  clearCache() {
    R.removeAll();
  }
  // しおりの読込（BGM状態復元）
  playLoopFromSaveObj() {
    const t = String(this.val.getVal("save:const.sn.loopPlaying", "{}"));
    if (this.val.flush(), t === "{}") {
      lt(this, Us, cu).call(this);
      return;
    }
    ot(this, $e, JSON.parse(t));
    const e = Object.keys(H(this, $e)).map((r) => () => {
      const D = "save:const.sn.sound." + r + ".", N = {
        fn: String(this.val.getVal(D + "fn")),
        buf: r,
        join: !1,
        loop: !0,
        volume: Number(this.val.getVal(D + "volume")),
        start_ms: Number(this.val.getVal(D + "start_ms")),
        end_ms: Number(this.val.getVal(D + "end_ms")),
        ret_ms: Number(this.val.getVal(D + "ret_ms"))
      };
      N.buf === "BGM" ? lt(this, To, tf).call(this, N) : lt(this, Gs, hu).call(this, N);
    });
    lt(this, Us, cu).call(this);
    for (const r of e)
      r();
  }
};
let SoundMng = eo;
Pe = new WeakMap(), $e = new WeakMap(), Li = new WeakMap(), qu = new WeakSet(), sd = function(t) {
  const { buf: e = "SE" } = t, r = "const.sn.sound." + e + ".volume", D = lt(this, Fs, uu).call(this, t, 1);
  return Number(this.val.getVal("sys:" + r)) === D ? !1 : (this.val.setVal_Nochk("sys", r, D), this.val.flush(), t.time = 0, t.volume = Number(this.val.getVal("save:" + r)), lt(this, gn, Ha).call(this, t));
}, Fs = new WeakSet(), uu = function(t, e) {
  const r = argChk_Num(t, "volume", e);
  return r < 0 ? 0 : r > 1 ? 1 : r;
}, Ku = new WeakSet(), ad = function(t) {
  return t.volume = 0, lt(this, Eo, Qc).call(this, t);
}, Zu = new WeakSet(), od = function(t) {
  return t.volume = 0, lt(this, gn, Ha).call(this, t);
}, Eo = new WeakSet(), Qc = function(t) {
  return t.buf = "BGM", lt(this, gn, Ha).call(this, t);
}, gn = new WeakSet(), Ha = function(t) {
  lt(this, mn, Va).call(this, t);
  const { buf: e = "SE" } = t, r = H(this, Pe)[e];
  if (!(r != null && r.playing()) || !r.snd)
    return !1;
  const D = "const.sn.sound." + e + ".", N = D + "volume", k = lt(this, Fs, uu).call(this, t, NaN);
  this.val.setVal_Nochk("save", N, k);
  const $ = k * Number(this.val.getVal("sys:" + N, 1)), G = argChk_Boolean(t, "stop", k === 0);
  G && (lt(this, js, fu).call(this, e), this.val.setVal_Nochk("save", D + "fn", "")), this.val.flush();
  const U = argChk_Num(t, "time", NaN), z = argChk_Num(t, "delay", 0);
  if (U === 0 && z === 0 || this.val.getVal("tmp:sn.skip.enabled") || H(this, Li).isSkippingByKeyDown())
    return r.snd.volume = $, G && lt(this, Gr, Ii).call(this, t), !1;
  const X = argChk_Num(t, "repeat", 1);
  return r.updFade = (V) => r.snd.volume = V, r.twFade = new Tween({ v: r.snd.volume }).to({ v: $ }, U).delay(z).easing(CmnTween.ease(t.ease)).repeat(X === 0 ? 1 / 0 : X - 1).yoyo(argChk_Boolean(t, "yoyo", !1)).onUpdate(({ v: V }) => r.updFade(V)).onComplete(() => {
    const V = H(this, Pe)[r.now_buf];
    (V == null ? void 0 : V.twFade) !== void 0 && (V.updFade = () => {
    }, remove$6(V.twFade), delete V.twFade, G && (t.buf = r.now_buf, lt(this, Gr, Ii).call(this, t)), V.resumeFade && this.main.resume());
  }).start(), !1;
}, To = new WeakSet(), tf = function(t) {
  return t.buf = "BGM", t.canskip = !1, argChk_Boolean(t, "loop", !0), lt(this, Gs, hu).call(this, t);
}, $s = new WeakMap(), Gs = new WeakSet(), hu = function(t) {
  const { buf: e = "SE", fn: r } = t;
  if (lt(this, Gr, Ii).call(this, { buf: e }), !r)
    throw `[playse] fnは必須です buf:${e}`;
  if (argChk_Boolean(t, "canskip", !0) && H(this, Li).isSkippingByKeyDown())
    return !1;
  const D = argChk_Boolean(t, "loop", !1);
  lt(this, rh, fd).call(this, e, D);
  const N = "const.sn.sound." + e + ".";
  this.val.setVal_Nochk("save", N + "fn", r);
  const k = lt(this, Fs, uu).call(this, t, 1);
  this.val.setVal_Nochk("save", N + "volume", k);
  const $ = k * Number(this.val.getVal("sys:" + N + "volume", 1)), G = argChk_Num(t, "start_ms", 0), U = argChk_Num(t, "end_ms", H(eo, $s)), z = argChk_Num(t, "ret_ms", 0), X = argChk_Num(t, "pan", 0), V = argChk_Num(t, "speed", 1);
  if (G < 0)
    throw `[playse] start_ms:${G} が負の値です`;
  if (z < 0)
    throw `[playse] ret_ms:${z} が負の値です`;
  if (U > 0) {
    if (G >= U)
      throw `[playse] start_ms:${G} >= end_ms:${U} は異常値です`;
    if (z >= U)
      throw `[playse] ret_ms:${z} >= end_ms:${U} は異常値です`;
  }
  this.val.setVal_Nochk("save", N + "start_ms", G), this.val.setVal_Nochk("save", N + "end_ms", U), this.val.setVal_Nochk("save", N + "ret_ms", z), this.val.flush();
  const Y = R.find(r), W = H(this, Pe)[e] = {
    now_buf: e,
    snd: Y,
    loop: D,
    start_ms: G,
    end_ms: U,
    ret_ms: z,
    resume: !1,
    pan: X,
    playing: () => !0,
    // [ws]的にはここでtrueが欲しい
    updFade: () => {
    },
    onend: () => {
      const J = W.now_buf, Q = H(this, Pe)[J];
      if (!Q)
        return;
      delete H(this, Pe)[J], Q.playing = () => !1;
      const et = "const.sn.sound." + J + ".";
      this.val.setVal_Nochk("tmp", et + "playing", !1), t.buf = J, lt(this, mn, Va).call(this, t), Q.resume && this.main.resume();
    }
  };
  this.val.setVal_Nochk("tmp", N + "playing", !0);
  const q = {
    loop: D,
    speed: V,
    volume: $,
    loaded: (J, Q) => {
      if (J) {
        this.main.errScript(`Sound ロード失敗ですa fn:${r} ${J}`, !1);
        return;
      }
      if (!Q)
        return;
      const et = H(this, Pe)[W.now_buf];
      et && (et.snd = Q);
    }
  };
  let K = "";
  if (G > 0 || U < H(eo, $s)) {
    K = `${r};${G};${U};${z}`;
    const J = (q.sprites ?? (q.sprites = {}))[K] = {
      start: G / 1e3,
      end: U / 1e3
    };
    q.preload = !0;
    const Q = q.loaded;
    q.loaded = (et, it) => {
      Q(et, it);
      const tt = it, nt = tt.duration;
      if (J.end < 0) {
        if (J.end += nt, tt.removeSprites(K), tt.addSprites(K, J), J.start >= J.end)
          throw `[playse] start_ms:${G} >= end_ms:${U}(${J.end * 1e3}) は異常値です`;
        if (z >= J.end * 1e3)
          throw `[playse] ret_ms:${z} >= end_ms:${U}(${J.end * 1e3}) は異常値です`;
      }
      if (J.start >= nt)
        throw `[playse] start_ms:${G} >= 音声ファイル再生時間:${nt} は異常値です`;
      if (U !== H(eo, $s) && J.end >= nt)
        throw `[playse] end_ms:${U} >= 音声ファイル再生時間:${nt} は異常値です`;
      tt.play(K, q.complete);
    };
  } else
    q.autoPlay = !0;
  if (D ? z !== 0 && (q.loop = !1, q.complete = async (J) => {
    const Q = J.duration, et = z / 1e3, it = U / 1e3;
    if (et >= Q)
      throw `[playse] ret_ms:${z} >= 音声ファイル再生時間:${Q} は異常値です`;
    await R.play(r, {
      // 一周目はループなし、なのでキャッシュされてる
      start: et,
      end: it < 0 ? it + Q : it,
      // 負の値は末尾から
      speed: V,
      loop: !0,
      volume: $,
      //	sprite	: sp_nm2,	// err
      //-	muted?: boolean;
      filters: W.pan !== 0 ? [new T.StereoFilter(W.pan)] : []
      //-	complete?: CompleteCallback;
      //-	loaded?: LoadedCallback;
      //-	singleInstance?: boolean;
    });
    const tt = H(this, Pe)[W.now_buf];
    tt && (tt.snd = R.find(r));
  }) : q.complete = () => {
    var J;
    return (J = H(this, Pe)[W.now_buf]) == null ? void 0 : J.onend();
  }, H(this, Co).call(this), Y) {
    if (Y.volume = $, K)
      lt(this, wo, ef).call(this, e, r, q);
    else if (Y.isPlayable) {
      const J = Y.options.source;
      !(J instanceof ArrayBuffer) || J.byteLength === 0 ? Y.play(q) : W.snd = E.from({
        ...q,
        url: Y.options.url,
        source: J
      }), Y.filters = [new T.StereoFilter(X)];
    }
    return !1;
  }
  const Z = argChk_Boolean(t, "join", !0);
  if (Z) {
    const J = q.loaded;
    q.loaded = (Q, et) => {
      J == null || J(Q, et), this.main.resume();
    };
  }
  return lt(this, wo, ef).call(this, e, r, q), Z;
}, wo = new WeakSet(), ef = function(t, e, r) {
  const D = this.cfg.searchPath(e, SEARCH_PATH_ARG_EXT.SOUND);
  if (D.slice(-4) !== ".bin") {
    r.url = D;
    const N = E.from(r);
    if (t) {
      const k = H(this, Pe)[t];
      if (!k)
        return;
      k.snd = N, k.pan !== 0 && (N.filters = [new T.StereoFilter(k.pan)]);
    }
    r.loop || R.add(e, N);
    return;
  }
  new Loader().add({ name: e, url: D, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).use((N, k) => {
    this.sys.dec(N.extension, N.data).then(($) => {
      N.data = $, k == null || k();
    }).catch(($) => this.main.errScript(`Sound ロード失敗ですc fn:${N.name} ${$}`, !1));
  }).load((N, k) => {
    var G;
    r.source = (G = k[e]) == null ? void 0 : G.data;
    const $ = E.from(r);
    if (t) {
      const U = H(this, Pe)[t];
      if (!U)
        return;
      U.snd = $, U.pan !== 0 && ($.filters = [new T.StereoFilter(U.pan)]);
    }
    r.loop || R.add(e, $);
  });
}, Co = new WeakMap(), Us = new WeakSet(), cu = function() {
  for (const t of Object.keys(H(this, Pe)))
    lt(this, Gr, Ii).call(this, { buf: t });
  return ot(this, Pe, {}), R.stopAll(), !1;
}, Ju = new WeakSet(), ld = function(t) {
  return t.buf = "BGM", lt(this, Gr, Ii).call(this, t);
}, Gr = new WeakSet(), Ii = function(t) {
  var D;
  const { buf: e = "SE" } = t;
  lt(this, js, fu).call(this, e);
  const r = H(this, Pe)[e];
  return r && ((D = r.snd) == null || D.stop(), r.onend()), !1;
}, Qu = new WeakSet(), ud = function(t) {
  return t.buf = "BGM", lt(this, Po, rf).call(this, t);
}, Po = new WeakSet(), rf = function(t) {
  const { buf: e = "SE" } = t, r = H(this, Pe)[e];
  return !(r != null && r.twFade) || !r.playing() ? !1 : r.resumeFade = H(this, Li).waitEvent(
    () => lt(this, mn, Va).call(this, t),
    argChk_Boolean(t, "canskip", !0),
    argChk_Boolean(t, "global", !1)
  );
}, mn = new WeakSet(), Va = function(t) {
  var r, D;
  const { buf: e = "SE" } = t;
  return (D = (r = H(this, Pe)[e]) == null ? void 0 : r.twFade) == null || D.stop().end(), !1;
}, th = new WeakSet(), hd = function(t) {
  return t.buf = "BGM", lt(this, Mo, nf).call(this, t);
}, Mo = new WeakSet(), nf = function(t) {
  const { buf: e = "SE" } = t, r = H(this, Pe)[e];
  return !(r != null && r.playing()) || r.loop ? !1 : r.resume = H(this, Li).waitEvent(
    () => {
      t.buf = r.now_buf, lt(this, Gr, Ii).call(this, t);
      const D = H(this, Pe)[t.buf];
      !(D != null && D.playing()) || D.loop || D.onend();
    },
    argChk_Boolean(t, "canskip", !1),
    argChk_Boolean(t, "global", !1)
  );
}, eh = new WeakSet(), cd = function(t) {
  const { buf: e = "SE", buf2: r = "SE" } = t;
  if (e === r)
    return !1;
  const D = H(this, Pe)[e];
  D && (D.now_buf = r);
  const N = H(this, Pe)[r];
  N && (N.now_buf = e), [H(this, Pe)[e], H(this, Pe)[r]] = [N, D];
  const k = "const.sn.sound." + e + ".", $ = Number(this.val.getVal("save:" + k + "volume")), G = Number(this.val.getVal("save:" + k + "fn")), U = String(this.val.getVal("tmp:" + k + "playing")) === "true", z = "const.sn.sound." + r + ".", X = Number(this.val.getVal("save:" + z + "volume")), V = Number(this.val.getVal("save:" + z + "fn")), Y = String(this.val.getVal("tmp:" + z + "playing")) === "true";
  return this.val.setVal_Nochk("save", k + "volume", X), this.val.setVal_Nochk("save", z + "volume", $), this.val.setVal_Nochk("save", k + "fn", V), this.val.setVal_Nochk("save", z + "fn", G), this.val.setVal_Nochk("tmp", k + "playing", Y), this.val.setVal_Nochk("tmp", z + "playing", U), e in H(this, $e) == r in H(this, $e) && (e in H(this, $e) ? (delete H(this, $e)[e], H(this, $e)[r] = 0) : (delete H(this, $e)[r], H(this, $e)[e] = 0), this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(H(this, $e)))), this.val.flush(), !1;
}, rh = new WeakSet(), fd = function(t, e) {
  if (!e) {
    lt(this, js, fu).call(this, t);
    return;
  }
  H(this, $e)[t] = 0, this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(H(this, $e))), this.val.flush();
}, js = new WeakSet(), fu = function(t) {
  delete H(this, $e)[t], this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(H(this, $e))), this.val.flush();
}, // 効果音の再生
rt(SoundMng, $s, 999e3);
var ye;
const Bf = class {
  constructor(t, e, r, D, N, k, $, G) {
    rt(this, ye, void 0);
    It(this, "lay", (t) => this.getPage(t).lay(t));
    It(this, "getPage", (t) => Bf.argChk_page(t, "fore") !== "back" ? H(this, ye).fore : H(this, ye).back);
    this.cls = e, this.hArg = N, this.sys = k, this.val = $, this.ret = G;
    const U = k.hFactoryCls[e];
    if (!U)
      throw `属性 class【${e}】が不正です`;
    const z = U(), X = U();
    z.layname = X.layname = t;
    const V = N[":id_tag"] = `layer:${t} cls:${e} page:`;
    z.spLay.name = z.name = V + "A", z.spLay.name = X.name = V + "B", r.addChild(z.spLay), D.addChild(X.spLay), argChk_Boolean(N, "visible", !0), argChk_Boolean(N, "visible", !0), G.isWait = z.lay(N) || X.lay(N), ot(this, ye, { fore: z, back: X });
    const Y = `const.sn.lay.${t}`;
    $.setVal_Nochk("tmp", Y, !0), $.defTmp(Y + ".fore.alpha", () => H(this, ye).fore.alpha), $.defTmp(Y + ".back.alpha", () => H(this, ye).back.alpha), $.defTmp(Y + ".fore.height", () => H(this, ye).fore.height), $.defTmp(Y + ".back.height", () => H(this, ye).back.height), $.defTmp(Y + ".fore.visible", () => H(this, ye).fore.spLay.visible), $.defTmp(Y + ".back.visible", () => H(this, ye).back.spLay.visible), $.defTmp(Y + ".fore.width", () => H(this, ye).fore.width), $.defTmp(Y + ".back.width", () => H(this, ye).back.width), $.defTmp(Y + ".fore.x", () => H(this, ye).fore.x), $.defTmp(Y + ".back.x", () => H(this, ye).back.x), $.defTmp(Y + ".fore.y", () => H(this, ye).fore.y), $.defTmp(Y + ".back.y", () => H(this, ye).back.y);
  }
  destroy() {
    H(this, ye).fore.destroy(), H(this, ye).back.destroy();
  }
  static argChk_page(t, e) {
    const r = t.page ?? e;
    if (r === "fore" || r === "back")
      return t.page = r;
    throw Error("属性 page【" + r + "】が不正です");
  }
  get fore() {
    return H(this, ye).fore;
  }
  get back() {
    return H(this, ye).back;
  }
  transPage(t) {
    [H(this, ye).back, H(this, ye).fore] = [H(this, ye).fore, H(this, ye).back], H(this, ye).back.copy(H(this, ye).fore, t);
  }
};
let Pages = Bf;
ye = new WeakMap();
var ih, nh;
const ni = class {
  constructor() {
    It(this, "layname", "");
    It(this, "name_", "");
    It(this, "spLay", new Sprite(Texture.EMPTY));
  }
  set name(t) {
    this.name_ = t;
  }
  get name() {
    return this.name_;
  }
  // tsy用
  get alpha() {
    return this.spLay.alpha;
  }
  set alpha(t) {
    this.spLay.alpha = t;
  }
  get height() {
    return this.spLay.height;
  }
  get rotation() {
    return this.spLay.angle;
  }
  set rotation(t) {
    this.spLay.angle = t;
  }
  get scale_x() {
    return this.spLay.scale.x;
  }
  set scale_x(t) {
    this.spLay.scale.x = t;
  }
  get scale_y() {
    return this.spLay.scale.y;
  }
  set scale_y(t) {
    this.spLay.scale.y = t;
  }
  get width() {
    return this.spLay.width;
  }
  get x() {
    return this.spLay.x;
  }
  set x(t) {
    this.procSetX(t), this.spLay.x = t;
  }
  procSetX(t) {
  }
  // set を override できないので
  get y() {
    return this.spLay.y;
  }
  set y(t) {
    this.procSetY(t), this.spLay.y = t;
  }
  procSetY(t) {
  }
  // set を override できないので
  destroy() {
  }
  lay(t) {
    return "alpha" in t && (this.spLay.alpha = argChk_Num(t, "alpha", 1)), ni.setBlendmode(this.spLay, t), ("pivot_x" in t || "pivot_y" in t) && this.spLay.pivot.set(
      argChk_Num(t, "pivot_x", this.spLay.pivot.x),
      argChk_Num(t, "pivot_y", this.spLay.pivot.y)
    ), "rotation" in t && (this.spLay.angle = argChk_Num(t, "rotation", 0)), ("scale_x" in t || "scale_y" in t) && this.spLay.scale.set(
      argChk_Num(t, "scale_x", this.spLay.scale.x),
      argChk_Num(t, "scale_y", this.spLay.scale.y)
    ), "visible" in t && (this.spLay.visible = argChk_Boolean(t, "visible", !0)), !1;
  }
  static setBlendmodeParentOnly(t, e) {
    const { blendmode: r } = e;
    if (!r)
      return;
    const D = ni.getBlendmodeNum(r);
    t instanceof Sprite && (t.blendMode = D);
  }
  static setBlendmode(t, e) {
    const { blendmode: r } = e;
    if (!r)
      return;
    const D = ni.getBlendmodeNum(r);
    t instanceof Sprite && (t.blendMode = D);
    for (const N of t.children)
      N instanceof Sprite && (N.blendMode = D);
  }
  static getBlendmodeNum(t) {
    if (!t)
      return BLEND_MODES.NORMAL;
    const e = H(ni, ih)[t];
    if (e !== void 0)
      return e;
    throw `${t} はサポートされない blendmode です`;
  }
  static getNum2Blendmode(t) {
    return H(ni, nh)[t] ?? "normal";
  }
  // アニメ・動画があるか
  get containMovement() {
    return !1;
  }
  renderStart() {
  }
  renderEnd() {
  }
  clearLay(t) {
    this.spLay.alpha = 1, this.spLay.blendMode = BLEND_MODES.NORMAL, this.spLay.pivot.set(0, 0), this.spLay.angle = 0, this.spLay.scale.set(1, 1), argChk_Boolean(t, "filter", !1) && (this.spLay.filters = []);
  }
  copy(t, e) {
    const r = this.name_;
    this.playback(t.record(), e), this.name = r;
  }
  record() {
    return {
      name: this.name_,
      idx: this.spLay.parent.getChildIndex(this.spLay),
      alpha: this.spLay.alpha,
      blendMode: this.spLay.blendMode,
      rotation: this.spLay.angle,
      scale_x: this.spLay.scale.x,
      scale_y: this.spLay.scale.y,
      pivot_x: this.spLay.pivot.x,
      pivot_y: this.spLay.pivot.y,
      x: this.spLay.x,
      y: this.spLay.y,
      visible: this.spLay.visible
    };
  }
  playback(t, e) {
    this.name = t.name, this.clearLay({ filter: "true" }), this.spLay.alpha = t.alpha, this.spLay.blendMode = t.blendMode, this.spLay.angle = t.rotation, this.spLay.scale.set(t.scale_x, t.scale_y), this.spLay.pivot.set(t.pivot_x, t.pivot_y), this.spLay.position.set(t.x, t.y), this.spLay.visible = t.visible;
  }
  snapshot(t, e) {
    t.render(this.spLay, { clear: !1 }), e();
  }
  snapshot_end() {
  }
  makeDesignCast(t) {
  }
  makeDesignCastChildren(t) {
  }
  showDesignCast() {
  }
  showDesignCastChildren() {
  }
  cvsResize() {
  }
  cvsResizeChildren() {
  }
  dump() {
    return ` "idx":${this.spLay.parent.getChildIndex(this.spLay)}, "visible":"${this.spLay.visible}", "left":${this.spLay.x}, "top":${this.spLay.y}, "alpha":${this.spLay.alpha}, "rotation":${this.spLay.angle}, "name":"${this.name_}", "scale_x":${this.spLay.scale.x}, "scale_y":${this.spLay.scale.y}`;
  }
  static setXY(t, e, r, D = !1, N = !1) {
    if (e.pos) {
      ni.setXYByPos(t, e.pos, r);
      return;
    }
    const k = t.getBounds(), $ = r.scale.x < 0 ? -r.scale.x : r.scale.x, G = $ === 1 ? k.width : k.width * $, U = r.scale.y < 0 ? -r.scale.y : r.scale.y, z = U === 1 ? k.height : k.height * U;
    let X = r.x;
    "left" in e ? (X = argChk_Num(e, "left", 0), X > -1 && X < 1 && (X *= CmnLib.stageW)) : "center" in e ? (X = argChk_Num(e, "center", 0), X > -1 && X < 1 && (X *= CmnLib.stageW), X = X - (N ? G / 3 : G) / 2) : "right" in e ? (X = argChk_Num(e, "right", 0), X > -1 && X < 1 && (X *= CmnLib.stageW), X = X - (N ? G / 3 : G)) : "s_right" in e && (X = argChk_Num(e, "s_right", 0), X > -1 && X < 1 && (X *= CmnLib.stageW), X = CmnLib.stageW - X - (N ? G / 3 : G)), r.x = int(r.scale.x < 0 ? X + (N ? G / 3 : G) : X);
    let V = r.y;
    "top" in e ? (V = argChk_Num(e, "top", 0), V > -1 && V < 1 && (V *= CmnLib.stageH)) : "middle" in e ? (V = argChk_Num(e, "middle", 0), V > -1 && V < 1 && (V *= CmnLib.stageH), V = V - z / 2) : "bottom" in e ? (V = argChk_Num(e, "bottom", 0), V > -1 && V < 1 && (V *= CmnLib.stageH), V = V - z) : "s_bottom" in e && (V = argChk_Num(e, "s_bottom", 0), V > -1 && V < 1 && (V *= CmnLib.stageH), V = CmnLib.stageH - V - z), r.y = int(r.scale.y < 0 ? V + z : V), D && !("left" in e) && !("center" in e) && !("right" in e) && !("s_right" in e) && !("top" in e) && !("middle" in e) && !("bottom" in e) && !("s_bottom" in e) && ni.setXYByPos(t, "c", r);
  }
  static setXYByPos(t, e, r) {
    if (e === "stay")
      return;
    if (t === void 0)
      throw "setXYByPos base === undefined";
    if (r === void 0)
      throw "setXYByPos result === undefined";
    const D = t.getBounds(), N = r.scale.x < 0 ? -r.scale.x : r.scale.x, k = N === 1 ? D.width : D.width * N, $ = r.scale.y < 0 ? -r.scale.y : r.scale.y, G = $ === 1 ? D.height : D.height * $;
    let U = 0;
    !e || e === "c" ? U = CmnLib.stageW * 0.5 : e === "r" ? U = CmnLib.stageW - k * 0.5 : e === "l" ? U = k * 0.5 : U = int(e), r.x = int(U - k * 0.5), r.y = CmnLib.stageH - G, r.scale.x < 0 && (r.x += k), r.scale.y < 0 && (r.y += G);
  }
  static setXYCenter(t) {
    const e = t.getBounds();
    t.x = (CmnLib.stageW - e.width) * 0.5, t.y = (CmnLib.stageH - e.height) * 0.5;
  }
};
let Layer = ni;
ih = new WeakMap(), nh = new WeakMap(), rt(Layer, ih, {
  normal: BLEND_MODES.NORMAL,
  add: BLEND_MODES.ADD,
  multiply: BLEND_MODES.MULTIPLY,
  screen: BLEND_MODES.SCREEN
  /*
  		'overlay'		: BLEND_MODES.OVERLAY,
  		'darken'		: BLEND_MODES.DARKEN,
  		'lighten'		: BLEND_MODES.LIGHTEN,
  		'color_dodge'	: BLEND_MODES.COLOR_DODGE,
  		'color_burn'	: BLEND_MODES.COLOR_BURN,
  		'hard_light'	: BLEND_MODES.HARD_LIGHT,
  		'soft_light'	: BLEND_MODES.SOFT_LIGHT,
  		'difference'	: BLEND_MODES.DIFFERENCE,
  		'exclusion'		: BLEND_MODES.EXCLUSION,
  		'hue'			: BLEND_MODES.HUE,
  		'saturation'	: BLEND_MODES.SATURATION,
  		'color'			: BLEND_MODES.COLOR,
  		'luminosity'	: BLEND_MODES.LUMINOSITY,
  
  		'normal_npm'	: BLEND_MODES.NORMAL_NPM,
  		'add_npm'		: BLEND_MODES.ADD_NPM,
  		'screen_npm'	: BLEND_MODES.SCREEN_NPM,
  		'none'			: BLEND_MODES.NONE,
  		'src_in'		: BLEND_MODES.SRC_IN,
  		'src_out'		: BLEND_MODES.SRC_OUT,
  		'src_atop'		: BLEND_MODES.SRC_ATOP,
  		'dst_over'		: BLEND_MODES.DST_OVER,
  		'dst_in'		: BLEND_MODES.DST_IN,
  		'dst_out'		: BLEND_MODES.DST_OUT,
  		'dst_atop'		: BLEND_MODES.DST_ATOP,
  		'subtract'		: BLEND_MODES.SUBTRACT,
  		'src_over'		: BLEND_MODES.SRC_OVER,
  		'erase'			: BLEND_MODES.ERASE,
  		'xor'			: BLEND_MODES.XOR,
  */
}), rt(Layer, nh, {
  0: "normal",
  1: "add",
  2: "multiply",
  3: "screen"
});
function prefixNames(o) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  return t.map(function(r) {
    return r.split(" ").map(function(D) {
      return D ? "" + o + D : "";
    }).join(" ");
  }).join(" ");
}
function prefixCSS(o, t) {
  return t.replace(/([^}{]*){/gm, function(e, r) {
    return r.replace(/\.([^{,\s\d.]+)/g, "." + o + "$1") + "{";
  });
}
function ref(o, t) {
  return function(e) {
    e && (o[t] = e);
  };
}
function refs(o, t, e) {
  return function(r) {
    r && (o[t][e] = r);
  };
}
function Properties(o, t) {
  return function(e) {
    var r = e.prototype;
    o.forEach(function(D) {
      t(r, D);
    });
  };
}
function withMethods(o, t) {
  return t === void 0 && (t = {}), function(e, r) {
    o.forEach(function(D) {
      var N = t[D] || D;
      N in e || (e[N] = function() {
        for (var k, $ = [], G = 0; G < arguments.length; G++)
          $[G] = arguments[G];
        var U = (k = this[r])[D].apply(k, $);
        return U === this[r] ? this : U;
      });
    });
  };
}
var FUNCTION = "function", OBJECT = "object", STRING = "string", NUMBER = "number", UNDEFINED = "undefined", IS_WINDOW = typeof window !== UNDEFINED, OPEN_CLOSED_CHARACTERS = [{
  open: "(",
  close: ")"
}, {
  open: '"',
  close: '"'
}, {
  open: "'",
  close: "'"
}, {
  open: '\\"',
  close: '\\"'
}, {
  open: "\\'",
  close: "\\'"
}], TINY_NUM$1 = 1e-7, DEFAULT_UNIT_PRESETS = {
  cm: function(o) {
    return o * 96 / 2.54;
  },
  mm: function(o) {
    return o * 96 / 254;
  },
  in: function(o) {
    return o * 96;
  },
  pt: function(o) {
    return o * 96 / 72;
  },
  pc: function(o) {
    return o * 96 / 6;
  },
  "%": function(o, t) {
    return o * t / 100;
  },
  vw: function(o, t) {
    return t === void 0 && (t = window.innerWidth), o / 100 * t;
  },
  vh: function(o, t) {
    return t === void 0 && (t = window.innerHeight), o / 100 * t;
  },
  vmax: function(o, t) {
    return t === void 0 && (t = Math.max(window.innerWidth, window.innerHeight)), o / 100 * t;
  },
  vmin: function(o, t) {
    return t === void 0 && (t = Math.min(window.innerWidth, window.innerHeight)), o / 100 * t;
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __spreadArrays$2() {
  for (var o = 0, t = 0, e = arguments.length; t < e; t++)
    o += arguments[t].length;
  for (var r = Array(o), D = 0, t = 0; t < e; t++)
    for (var N = arguments[t], k = 0, $ = N.length; k < $; k++, D++)
      r[D] = N[k];
  return r;
}
function dot(o, t, e, r) {
  return (o * r + t * e) / (e + r);
}
function isUndefined(o) {
  return typeof o === UNDEFINED;
}
function isObject$2(o) {
  return o && typeof o === OBJECT;
}
function isArray(o) {
  return Array.isArray(o);
}
function isString(o) {
  return typeof o === STRING;
}
function isNumber(o) {
  return typeof o === NUMBER;
}
function isFunction$2(o) {
  return typeof o === FUNCTION;
}
function isEqualSeparator(o, t) {
  var e = o === "" || o == " ", r = t === "" || t == " ";
  return r && e || o === t;
}
function findOpen(o, t, e, r, D) {
  var N = findIgnore(o, t, e);
  return N ? e : findClose(o, t, e + 1, r, D);
}
function findIgnore(o, t, e) {
  if (!o.ignore)
    return null;
  var r = t.slice(Math.max(e - 3, 0), e + 3).join("");
  return new RegExp(o.ignore).exec(r);
}
function findClose(o, t, e, r, D) {
  for (var N = function(U) {
    var z = t[U].trim();
    if (z === o.close && !findIgnore(o, t, U))
      return {
        value: U
      };
    var X = U, V = find$1(D, function(Y) {
      var W = Y.open;
      return W === z;
    });
    if (V && (X = findOpen(V, t, U, r, D)), X === -1)
      return k = U, "break";
    U = X, k = U;
  }, k, $ = e; $ < r; ++$) {
    var G = N($);
    if ($ = k, typeof G == "object")
      return G.value;
    if (G === "break")
      break;
  }
  return -1;
}
function splitText(o, t) {
  var e = isString(t) ? {
    separator: t
  } : t, r = e.separator, D = r === void 0 ? "," : r, N = e.isSeparateFirst, k = e.isSeparateOnlyOpenClose, $ = e.isSeparateOpenClose, G = $ === void 0 ? k : $, U = e.openCloseCharacters, z = U === void 0 ? OPEN_CLOSED_CHARACTERS : U, X = z.map(function(nt) {
    var st = nt.open, at = nt.close;
    return st === at ? st : st + "|" + at;
  }).join("|"), V = "(\\s*" + D + "\\s*|" + X + "|\\s+)", Y = new RegExp(V, "g"), W = o.split(Y).filter(function(nt) {
    return nt && nt !== "undefined";
  }), q = W.length, K = [], Z = [];
  function J() {
    return Z.length ? (K.push(Z.join("")), Z = [], !0) : !1;
  }
  for (var Q = function(nt) {
    var st = W[nt].trim(), at = nt, ut = find$1(z, function(pt) {
      var _t = pt.open;
      return _t === st;
    }), ht = find$1(z, function(pt) {
      var _t = pt.close;
      return _t === st;
    });
    if (ut) {
      if (at = findOpen(ut, W, nt, q, z), at !== -1 && G)
        return J() && N || (K.push(W.slice(nt, at + 1).join("")), nt = at, N) ? (et = nt, "break") : (et = nt, "continue");
    } else if (ht && !findIgnore(ht, W, nt)) {
      var dt = __spreadArrays$2(z);
      return dt.splice(z.indexOf(ht), 1), {
        value: splitText(o, {
          separator: D,
          isSeparateFirst: N,
          isSeparateOnlyOpenClose: k,
          isSeparateOpenClose: G,
          openCloseCharacters: dt
        })
      };
    } else if (isEqualSeparator(st, D) && !k)
      return J(), N ? (et = nt, "break") : (et = nt, "continue");
    at === -1 && (at = q - 1), Z.push(W.slice(nt, at + 1).join("")), nt = at, et = nt;
  }, et, it = 0; it < q; ++it) {
    var tt = Q(it);
    if (it = et, typeof tt == "object")
      return tt.value;
    if (tt === "break")
      break;
  }
  return Z.length && K.push(Z.join("")), K;
}
function splitSpace(o) {
  return splitText(o, "");
}
function splitComma(o) {
  return splitText(o, ",");
}
function splitBracket(o) {
  var t = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(o);
  return !t || t.length < 4 ? {} : {
    prefix: t[1],
    value: t[2],
    suffix: t[3]
  };
}
function splitUnit(o) {
  var t = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(o);
  if (!t)
    return {
      prefix: "",
      unit: "",
      value: NaN
    };
  var e = t[1], r = t[2], D = t[3];
  return {
    prefix: e,
    unit: D,
    value: parseFloat(r)
  };
}
function camelize(o) {
  return o.replace(/[\s-_]+([^\s-_])/g, function(t, e) {
    return e.toUpperCase();
  });
}
function decamelize(o, t) {
  return t === void 0 && (t = "-"), o.replace(/([a-z])([A-Z])/g, function(e, r, D) {
    return "" + r + t + D.toLowerCase();
  });
}
function now() {
  return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
}
function findIndex(o, t, e) {
  e === void 0 && (e = -1);
  for (var r = o.length, D = 0; D < r; ++D)
    if (t(o[D], D, o))
      return D;
  return e;
}
function find$1(o, t, e) {
  var r = findIndex(o, t);
  return r > -1 ? o[r] : e;
}
var requestAnimationFrame$1 = /* @__PURE__ */ function() {
  var o = now(), t = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return t ? t.bind(window) : function(e) {
    var r = now(), D = setTimeout(function() {
      e(r - o);
    }, 1e3 / 60);
    return D;
  };
}(), cancelAnimationFrame$1 = /* @__PURE__ */ function() {
  var o = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return o ? o.bind(window) : function(t) {
    clearTimeout(t);
  };
}();
function getKeys(o) {
  return Object.keys(o);
}
function getValues(o) {
  var t = getKeys(o);
  return t.map(function(e) {
    return o[e];
  });
}
function convertUnitSize(o, t) {
  var e = splitUnit(o), r = e.value, D = e.unit;
  if (isObject$2(t)) {
    var N = t[D];
    if (N) {
      if (isFunction$2(N))
        return N(r);
      if (DEFAULT_UNIT_PRESETS[D])
        return DEFAULT_UNIT_PRESETS[D](r, N);
    }
  } else if (D === "%")
    return r * t / 100;
  return DEFAULT_UNIT_PRESETS[D] ? DEFAULT_UNIT_PRESETS[D](r) : r;
}
function between(o, t, e) {
  return Math.max(t, Math.min(o, e));
}
function checkBoundSize(o, t, e, r) {
  return r === void 0 && (r = o[0] / o[1]), [[throttle(t[0], TINY_NUM$1), throttle(t[0] / r, TINY_NUM$1)], [throttle(t[1] * r, TINY_NUM$1), throttle(t[1], TINY_NUM$1)]].filter(function(D) {
    return D.every(function(N, k) {
      var $ = t[k], G = throttle($, TINY_NUM$1);
      return e ? N <= $ || N <= G : N >= $ || N >= G;
    });
  })[0] || o;
}
function calculateBoundSize(o, t, e, r) {
  if (!r)
    return o.map(function(Y, W) {
      return between(Y, t[W], e[W]);
    });
  var D = o[0], N = o[1], k = r === !0 ? D / N : r, $ = checkBoundSize(o, t, !1, k), G = $[0], U = $[1], z = checkBoundSize(o, e, !0, k), X = z[0], V = z[1];
  return D < G || N < U ? (D = G, N = U) : (D > X || N > V) && (D = X, N = V), [D, N];
}
function sum(o) {
  for (var t = o.length, e = 0, r = t - 1; r >= 0; --r)
    e += o[r];
  return e;
}
function average(o) {
  for (var t = o.length, e = 0, r = t - 1; r >= 0; --r)
    e += o[r];
  return t ? e / t : 0;
}
function getRad$1(o, t) {
  var e = t[0] - o[0], r = t[1] - o[1], D = Math.atan2(r, e);
  return D >= 0 ? D : D + Math.PI * 2;
}
function getCenterPoint(o) {
  return [0, 1].map(function(t) {
    return average(o.map(function(e) {
      return e[t];
    }));
  });
}
function getShapeDirection(o) {
  var t = getCenterPoint(o), e = getRad$1(t, o[0]), r = getRad$1(t, o[1]);
  return e < r && r - e < Math.PI || e > r && r - e < -Math.PI ? 1 : -1;
}
function getDist$2(o, t) {
  return Math.sqrt(Math.pow((t ? t[0] : 0) - o[0], 2) + Math.pow((t ? t[1] : 0) - o[1], 2));
}
function throttle(o, t) {
  if (!t)
    return o;
  var e = 1 / t;
  return Math.round(o / t) / e;
}
function throttleArray(o, t) {
  return o.forEach(function(e, r) {
    o[r] = throttle(o[r], t);
  }), o;
}
function flat$2(o) {
  return o.reduce(function(t, e) {
    return t.concat(e);
  }, []);
}
function pushSet(o, t) {
  o.indexOf(t) === -1 && o.push(t);
}
function hasClass(o, t) {
  return o.classList ? o.classList.contains(t) : !!o.className.match(new RegExp("(\\s|^)" + t + "(\\s|$)"));
}
function addClass(o, t) {
  o.classList ? o.classList.add(t) : o.className += " " + t;
}
function removeClass(o, t) {
  if (o.classList)
    o.classList.remove(t);
  else {
    var e = new RegExp("(\\s|^)" + t + "(\\s|$)");
    o.className = o.className.replace(e, " ");
  }
}
function addEvent(o, t, e, r) {
  o.addEventListener(t, e, r);
}
function removeEvent(o, t, e, r) {
  o.removeEventListener(t, e, r);
}
var PolyMap = /* @__PURE__ */ function() {
  function o() {
    this.keys = [], this.values = [];
  }
  var t = o.prototype;
  return t.get = function(e) {
    return this.values[this.keys.indexOf(e)];
  }, t.set = function(e, r) {
    var D = this.keys, N = this.values, k = D.indexOf(e), $ = k === -1 ? D.length : k;
    D[$] = e, N[$] = r;
  }, o;
}(), HashMap = /* @__PURE__ */ function() {
  function o() {
    this.object = {};
  }
  var t = o.prototype;
  return t.get = function(e) {
    return this.object[e];
  }, t.set = function(e, r) {
    this.object[e] = r;
  }, o;
}(), SUPPORT_MAP = typeof Map == "function", Link = /* @__PURE__ */ function() {
  function o() {
  }
  var t = o.prototype;
  return t.connect = function(e, r) {
    this.prev = e, this.next = r, e && (e.next = this), r && (r.prev = this);
  }, t.disconnect = function() {
    var e = this.prev, r = this.next;
    e && (e.next = r), r && (r.prev = e);
  }, t.getIndex = function() {
    for (var e = this, r = -1; e; )
      e = e.prev, ++r;
    return r;
  }, o;
}();
function orderChanged(o, t) {
  var e = [], r = [];
  return o.forEach(function(D) {
    var N = D[0], k = D[1], $ = new Link();
    e[N] = $, r[k] = $;
  }), e.forEach(function(D, N) {
    D.connect(e[N - 1]);
  }), o.filter(function(D, N) {
    return !t[N];
  }).map(function(D, N) {
    var k = D[0], $ = D[1];
    if (k === $)
      return [0, 0];
    var G = e[k], U = r[$ - 1], z = G.getIndex();
    G.disconnect(), U ? G.connect(U, U.next) : G.connect(void 0, e[0]);
    var X = G.getIndex();
    return [z, X];
  });
}
var Result = /* @__PURE__ */ function() {
  function o(e, r, D, N, k, $, G, U) {
    this.prevList = e, this.list = r, this.added = D, this.removed = N, this.changed = k, this.maintained = $, this.changedBeforeAdded = G, this.fixed = U;
  }
  var t = o.prototype;
  return Object.defineProperty(t, "ordered", {
    get: function() {
      return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t, "pureChanged", {
    get: function() {
      return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged;
    },
    enumerable: !0,
    configurable: !0
  }), t.caculateOrdered = function() {
    var e = orderChanged(this.changedBeforeAdded, this.fixed), r = this.changed, D = [];
    this.cacheOrdered = e.filter(function(N, k) {
      var $ = N[0], G = N[1], U = r[k], z = U[0], X = U[1];
      if ($ !== G)
        return D.push([z, X]), !0;
    }), this.cachePureChanged = D;
  }, o;
}();
function diff$1(o, t, e) {
  var r = SUPPORT_MAP ? Map : e ? HashMap : PolyMap, D = e || function(J) {
    return J;
  }, N = [], k = [], $ = [], G = o.map(D), U = t.map(D), z = new r(), X = new r(), V = [], Y = [], W = {}, q = [], K = 0, Z = 0;
  return G.forEach(function(J, Q) {
    z.set(J, Q);
  }), U.forEach(function(J, Q) {
    X.set(J, Q);
  }), G.forEach(function(J, Q) {
    var et = X.get(J);
    typeof et > "u" ? (++Z, k.push(Q)) : W[et] = Z;
  }), U.forEach(function(J, Q) {
    var et = z.get(J);
    typeof et > "u" ? (N.push(Q), ++K) : ($.push([et, Q]), Z = W[Q] || 0, V.push([et - Z, Q - K]), Y.push(Q === et), et !== Q && q.push([et, Q]));
  }), k.reverse(), new Result(o, t, N, k, q, $, V, Y);
}
var ListDiffer = /* @__PURE__ */ function() {
  function o(e, r) {
    e === void 0 && (e = []), this.findKeyCallback = r, this.list = [].slice.call(e);
  }
  var t = o.prototype;
  return t.update = function(e) {
    var r = [].slice.call(e), D = diff$1(this.list, r, this.findKeyCallback);
    return this.list = r, D;
  }, o;
}(), extendStatics$5 = function(o, t) {
  return extendStatics$5 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      Object.prototype.hasOwnProperty.call(r, D) && (e[D] = r[D]);
  }, extendStatics$5(o, t);
};
function __extends$5(o, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  extendStatics$5(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$6 = function() {
  return __assign$6 = Object.assign || function(t) {
    for (var e, r = 1, D = arguments.length; r < D; r++) {
      e = arguments[r];
      for (var N in e)
        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);
    }
    return t;
  }, __assign$6.apply(this, arguments);
};
function __rest$2(o, t) {
  var e = {};
  for (var r in o)
    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var D = 0, r = Object.getOwnPropertySymbols(o); D < r.length; D++)
      t.indexOf(r[D]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[D]) && (e[r[D]] = o[r[D]]);
  return e;
}
function __spreadArray$1(o, t, e) {
  if (e || arguments.length === 2)
    for (var r = 0, D = t.length, N; r < D; r++)
      (N || !(r in t)) && (N || (N = Array.prototype.slice.call(t, 0, r)), N[r] = t[r]);
  return o.concat(N || Array.prototype.slice.call(t));
}
function fillKeys(o) {
  var t = 0;
  return o.map(function(e) {
    return e == null ? "$compat".concat(++t) : "".concat(e);
  });
}
function flat$1(o) {
  var t = [];
  return o.forEach(function(e) {
    t = t.concat(isArray(e) ? flat$1(e) : e);
  }), t;
}
function fillProps(o, t) {
  if (!t)
    return o;
  for (var e in t)
    isUndefined(o[e]) && (o[e] = t[e]);
  return o;
}
function isDiff(o, t) {
  if (o === t)
    return !1;
  for (var e in o)
    if (!(e in t))
      return !0;
  for (var e in t)
    if (o[e] !== t[e])
      return !0;
  return !1;
}
function getAttributes(o) {
  var t = o.className, e = __rest$2(o, ["className"]);
  return t != null && (e.class = t), delete e.style, delete e.children, e;
}
function splitProps(o) {
  var t = {}, e = {};
  for (var r in o)
    r.indexOf("on") === 0 ? e[r] = o[r] : t[r] = o[r];
  return [t, e];
}
function findContainerNode(o) {
  if (!o)
    return null;
  var t = o.b;
  return t instanceof Node ? t : findContainerNode(o.c);
}
function removeNode(o) {
  var t = o.parentNode;
  t && t.removeChild(o);
}
function executeHooks(o) {
  o.forEach(function(t) {
    t();
  });
}
function renderFunctionComponent() {
  return this.constructor(this.props, this.context);
}
var hooksIndex = 0, current = null, Provider = /* @__PURE__ */ function() {
  function o(e, r, D, N, k, $, G) {
    G === void 0 && (G = {}), this.t = e, this.d = r, this.k = D, this.i = N, this.c = k, this.ref = $, this.ps = G, this.typ = "prov", this._ps = [], this._cs = {}, this._hyd = null, this._sel = !1;
  }
  var t = o.prototype;
  return t.s = function() {
    return !0;
  }, t.u = function(e, r, D, N, k) {
    var $ = this, G = $.d, U = getValues(r).filter(function(W) {
      return W.$_req;
    }), z = flat$1(U.map(function(W) {
      return W.$_subs;
    })), X = find$1(z, function(W) {
      return W.d === G;
    });
    if ($.b && !isString(D) && !k && !$.s(D.props, N) && !X) {
      var V = z.reduce(function(W, q) {
        var K = q.d;
        return W[0] ? W[0].d === K && W.push(q) : K > G && W.push(q), W;
      }, []);
      return V.forEach(function(W) {
        renderProviders(W, W._ps, [W.o], e, r, !0);
      }), !1;
    }
    $.o = D, $.ss(N);
    var Y = $.ps;
    return isString(D) || ($.ps = D.props, $.ref = D.ref), setCurrentInstance(this), $.r(e, r, $.b ? Y : {}, N), !0;
  }, t.md = function() {
    this.rr();
  }, t.ss = function() {
  }, t.ud = function() {
    this.rr();
  }, t.rr = function() {
    var e = this, r = e.ref, D = e.fr;
    r && r(D ? D.current : e.b);
  }, o;
}();
function getCurrentInstance() {
  return current;
}
function getHooksIndex() {
  return hooksIndex;
}
function setHooksInex(o) {
  hooksIndex = o;
}
function setCurrentInstance(o) {
  current = o, hooksIndex = 0;
}
var Component = /* @__PURE__ */ function() {
  function o(e, r) {
    e === void 0 && (e = {}), this.props = e, this.context = r, this.state = {}, this.$_timer = 0, this.$_state = {}, this.$_subs = [], this.$_cs = {};
  }
  var t = o.prototype;
  return t.render = function() {
    return null;
  }, t.shouldComponentUpdate = function(e, r) {
    return this.props !== e || this.state !== r;
  }, t.setState = function(e, r, D) {
    var N = this;
    N.$_timer || (N.$_state = {}), clearTimeout(N.$_timer), N.$_timer = 0, N.$_state = __assign$6(__assign$6({}, N.$_state), e), D ? N.$_setState(r, D) : N.$_timer = window.setTimeout(function() {
      N.$_timer = 0, N.$_setState(r, D);
    });
  }, t.forceUpdate = function(e) {
    this.setState({}, e, !0);
  }, t.componentDidMount = function() {
  }, t.componentDidUpdate = function(e, r) {
  }, t.componentWillUnmount = function() {
  }, t.$_setState = function(e, r) {
    var D = [], N = this.$_p, k = renderProviders(N.c, [N], [N.o], D, N._cs, __assign$6(__assign$6({}, this.state), this.$_state), r);
    k && (e && D.push(e), executeHooks(D), setCurrentInstance(null));
  }, o;
}(), PureComponent = /* @__PURE__ */ function(o) {
  __extends$5(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.shouldComponentUpdate = function(r, D) {
    return isDiff(this.props, r) || isDiff(this.state, D);
  }, t;
}(Component);
function createRef(o) {
  var t = function(e) {
    t.current = e;
  };
  return t.current = o, t;
}
function forwardRef(o) {
  return o._fr = !0, o;
}
function createComponent(o, t, e, r) {
  var D, N;
  return !((D = o == null ? void 0 : o.prototype) === null || D === void 0) && D.render ? N = new o(t, e) : (N = new Component(t, e), N.constructor = o, o._fr ? (r.fr = createRef(), N.render = function() {
    return this.constructor(this.props, r.fr);
  }) : N.render = renderFunctionComponent), N.$_p = r, N;
}
var ComponentProvider = /* @__PURE__ */ function(o) {
  __extends$5(t, o);
  function t(r, D, N, k, $, G, U) {
    U === void 0 && (U = {});
    var z = o.call(this, r, D, N, k, $, G, fillProps(U, r.defaultProps)) || this;
    return z.typ = "comp", z._usefs = [], z._uefs = [], z._defs = [], z;
  }
  var e = t.prototype;
  return e.s = function(r, D) {
    var N = this.b;
    return N.shouldComponentUpdate(fillProps(r, this.t.defaultProps), D || N.state) !== !1;
  }, e.r = function(r, D, N) {
    var k, $, G = this, U = G.t;
    G.ps = fillProps(G.ps, G.t.defaultProps);
    var z = G.ps, X = !G.b, V = U.contextType, Y = G.b, W = V == null ? void 0 : V.get(G);
    G._cs = D, X ? (Y = createComponent(U, z, W, G), G.b = Y) : (Y.props = z, Y.context = W);
    var q = Y.state;
    G._usefs = [], G._uefs = [];
    var K = Y.render();
    (($ = (k = K == null ? void 0 : K.props) === null || k === void 0 ? void 0 : k.children) === null || $ === void 0 ? void 0 : $.length) === 0 && (K.props.children = G.ps.children);
    var Z = __assign$6(__assign$6({}, D), Y.$_cs);
    renderProviders(G, G._ps, K ? [K] : [], r, Z), X ? G._uefs.push(function() {
      V == null || V.register(G), Y.componentDidMount();
    }) : G._uefs.push(function() {
      Y.componentDidUpdate(N, q);
    }), r.push(function() {
      G._usefs.forEach(function(J) {
        J();
      }), X ? G.md() : G.ud(), G._defs = G._uefs.map(function(J) {
        return J();
      });
    });
  }, e.ss = function(r) {
    var D = this.b;
    !D || !r || (D.state = r);
  }, e.un = function() {
    var r, D = this;
    D._ps.forEach(function(k) {
      k.un();
    });
    var N = D.t;
    (r = N.contextType) === null || r === void 0 || r.unregister(D), clearTimeout(D.b.$_timer), D._defs.forEach(function(k) {
      k && k();
    }), D.b.componentWillUnmount();
  }, t;
}(Provider);
function diffAttributes(o, t, e) {
  var r = diffObject(getAttributes(o), getAttributes(t)), D = r.added, N = r.removed, k = r.changed;
  for (var $ in D)
    e.setAttribute($, D[$]);
  for (var G in k)
    e.setAttribute(G, k[G][1]);
  for (var U in N)
    e.removeAttribute(U);
}
function diffEvents(o, t, e) {
  var r = diffObject(o, t), D = r.added, N = r.removed;
  for (var k in N)
    e.e(k, !0);
  for (var $ in D)
    e.e($);
}
function diffObject(o, t) {
  var e = getKeys(o), r = getKeys(t), D = diff$1(e, r, function(G) {
    return G;
  }), N = {}, k = {}, $ = {};
  return D.added.forEach(function(G) {
    var U = r[G];
    N[U] = t[U];
  }), D.removed.forEach(function(G) {
    var U = e[G];
    k[U] = o[U];
  }), D.maintained.forEach(function(G) {
    var U = G[0], z = e[U], X = [o[z], t[z]];
    o[z] !== t[z] && ($[z] = X);
  }), {
    added: N,
    removed: k,
    changed: $
  };
}
function diffStyle(o, t, e) {
  var r = e.style, D = diffObject(o, t), N = D.added, k = D.removed, $ = D.changed;
  for (var G in N) {
    var U = decamelize(G, "-");
    r.setProperty(U, N[G]);
  }
  for (var G in $) {
    var z = decamelize(G, "-");
    r.setProperty(z, $[G][1]);
  }
  for (var G in k) {
    var X = decamelize(G, "-");
    r.removeProperty(X);
  }
}
function getNativeEventName(o) {
  return o.replace(/^on/g, "").toLowerCase();
}
var ElementProvider = /* @__PURE__ */ function(o) {
  __extends$5(t, o);
  function t() {
    var r = o !== null && o.apply(this, arguments) || this;
    return r.typ = "elem", r._es = {}, r._svg = !1, r;
  }
  var e = t.prototype;
  return e.e = function(r, D) {
    var N = this, k = N._es, $ = N.b, G = getNativeEventName(r);
    D ? (removeEvent($, G, k[r]), delete k[r]) : (k[r] = function(U) {
      var z, X;
      (X = (z = N.ps)[r]) === null || X === void 0 || X.call(z, U);
    }, addEvent($, G, k[r]));
  }, e.s = function(r) {
    return isDiff(this.ps, r);
  }, e.r = function(r, D, N) {
    var k, $ = this, G = !$.b, U = $.ps;
    if (G) {
      var z = !1;
      if ($._svg || $.t === "svg")
        z = !0;
      else {
        var X = findContainerNode($.c);
        z = X && X.ownerSVGElement;
      }
      $._svg = z;
      var V = U.portalContainer;
      if (!V) {
        V = (k = $._hyd) === null || k === void 0 ? void 0 : k.splice(0, 1)[0];
        var Y = $.t;
        V ? $._hyd = [].slice.call(V.children) : z ? V = document.createElementNS("http://www.w3.org/2000/svg", Y) : V = document.createElement(Y);
      }
      $.b = V;
    }
    renderProviders($, $._ps, U.children, r, D);
    var W = $.b, q = splitProps(N), K = q[0], Z = q[1], J = splitProps(U), Q = J[0], et = J[1];
    return diffAttributes(K, Q, W), diffEvents(Z, et, $), diffStyle(N.style || {}, U.style || {}, W), r.push(function() {
      G ? $.md() : $.ud();
    }), !0;
  }, e.un = function() {
    var r = this, D = r._es, N = r.b;
    for (var k in D)
      removeEvent(N, k, D[k]);
    r._ps.forEach(function($) {
      $.un();
    }), r._es = {}, !r.ps.portalContainer && !r._sel && removeNode(N);
  }, t;
}(Provider);
function findDOMNode(o) {
  if (!o || o instanceof Node)
    return o;
  var t = o.$_p._ps;
  return t.length ? findDOMNode(t[0].b) : null;
}
function findNodeProvider(o) {
  if (o) {
    if (o.b && o.b instanceof Node)
      return o;
    var t = o._ps;
    return t.length ? findNodeProvider(t[0]) : null;
  }
}
function createElement(o, t) {
  for (var e = [], r = 2; r < arguments.length; r++)
    e[r - 2] = arguments[r];
  var D = t || {}, N = D.key, k = D.ref, $ = __rest$2(D, ["key", "ref"]);
  return {
    type: o,
    key: N,
    ref: k,
    props: __assign$6(__assign$6({}, $), {
      children: flat$2(e).filter(function(G) {
        return G != null && G !== !1;
      })
    })
  };
}
var ContainerProvider = /* @__PURE__ */ function(o) {
  __extends$5(t, o);
  function t(r, D) {
    D === void 0 && (D = 0);
    var N = o.call(this, "container", D, "container", 0, null) || this;
    return N.typ = "container", N.b = r, N;
  }
  var e = t.prototype;
  return e.r = function() {
    return !0;
  }, e.un = function() {
  }, t;
}(Provider), TextProvider = /* @__PURE__ */ function(o) {
  __extends$5(t, o);
  function t() {
    var r = o !== null && o.apply(this, arguments) || this;
    return r.typ = "text", r;
  }
  var e = t.prototype;
  return e.r = function(r) {
    var D, N = this, k = !N.b;
    if (k) {
      var $ = (D = N._hyd) === null || D === void 0 ? void 0 : D.splice(0, 1)[0];
      N.b = $ || document.createTextNode(N.t.replace("text_", ""));
    }
    return r.push(function() {
      k ? N.md() : N.ud();
    }), !0;
  }, e.un = function() {
    removeNode(this.b);
  }, t;
}(Provider);
function diffProviders(o, t, e) {
  var r = e.map(function(G) {
    return isString(G) ? null : G.key;
  }), D = fillKeys(t.map(function(G) {
    return G.k;
  })), N = fillKeys(r), k = diff$1(D, N, function(G) {
    return G;
  });
  k.removed.forEach(function(G) {
    t.splice(G, 1)[0].un();
  }), k.ordered.forEach(function(G) {
    var U = G[0], z = G[1], X = t.splice(U, 1)[0];
    t.splice(z, 0, X);
    var V = findDOMNode(X.b), Y = findDOMNode(t[z + 1] && t[z + 1].b);
    V && V.parentNode.insertBefore(V, Y);
  }), k.added.forEach(function(G) {
    t.splice(G, 0, createProvider(e[G], r[G], G, o));
  });
  var $ = k.maintained.filter(function(G) {
    G[0];
    var U = G[1], z = e[U], X = t[U], V = isString(z) ? "text_".concat(z) : z.type;
    return V !== X.t ? (X.un(), t.splice(U, 1, createProvider(z, r[U], U, o)), !0) : (X.i = U, !1);
  });
  return __spreadArray$1(__spreadArray$1([], k.added, !0), $.map(function(G) {
    G[0];
    var U = G[1];
    return U;
  }), !0);
}
function getNextSibiling(o, t) {
  for (var e = o._ps, r = e.length, D = t.i + 1; D < r; ++D) {
    var N = findDOMNode(e[D].b);
    if (N)
      return N;
  }
  return null;
}
function createProvider(o, t, e, r) {
  var D = r.d + 1;
  if (isString(o) || isNumber(o))
    return new TextProvider("text_".concat(o), D, t, e, r, null, {});
  var N = o.type, k = typeof N == "string" ? ElementProvider : ComponentProvider;
  return new k(N, D, t, e, r, o.ref, o.props);
}
function renderProviders(o, t, e, r, D, N, k) {
  var $ = diffProviders(o, t, e), G = o._hyd, U = t.filter(function(X, V) {
    return X._hyd = G, X.u(r, D, e[V], N, k);
  });
  o.typ === "container" && o._sel && t.forEach(function(X) {
    var V = findNodeProvider(X);
    V && (V._sel = !0);
  }), o._hyd = null;
  var z = findContainerNode(o);
  return z && $.reverse().forEach(function(X) {
    var V = t[X], Y = findDOMNode(V.b);
    if (Y && z !== Y && !Y.parentNode) {
      var W = getNextSibiling(o, V);
      z.insertBefore(Y, W);
    }
  }), U.length > 0;
}
function renderProvider(o, t, e, r) {
  e === void 0 && (e = t.__CROACT__), r === void 0 && (r = {});
  var D = !!e;
  e || (e = new ContainerProvider(t));
  var N = [];
  return renderProviders(e, e._ps, o ? [o] : [], N, r, void 0, void 0), executeHooks(N), setCurrentInstance(null), D || (t.__CROACT__ = e), e;
}
function renderSelf(o, t, e) {
  return !e && o && (e = new ContainerProvider(t.parentElement), e._hyd = [t], e._sel = !0), renderProvider(o, t, e), e;
}
function checkHookInfo(o) {
  var t = getCurrentInstance(), e = t._hs || (t._hs = []), r = getHooksIndex(), D = e[r];
  if (setHooksInex(r + 1), D) {
    if (!isDiff(D.deps, o.deps))
      return D.updated = !1, D;
    e[r] = o;
  } else
    e.push(o);
  return o.value = o.func(), o.updated = !0, o;
}
function useMemo(o, t) {
  var e = checkHookInfo({
    func: o,
    deps: t
  });
  return e.value;
}
function useRef(o) {
  return useMemo(function() {
    return createRef(o);
  }, []);
}
function useEffect(o, t, e) {
  var r = getCurrentInstance(), D = checkHookInfo({
    func: function() {
      return o;
    },
    deps: t
  }), N = e ? r._usefs : r._uefs;
  D.updated ? N.push(function() {
    return D.effect && D.effect(), D.effect = o(), D.effect;
  }) : N.push(function() {
    return D.effect;
  });
}
function useImperativeHandle(o, t, e) {
  useEffect(function() {
    o == null || o(t());
  }, e, !0);
}
function some(o, t) {
  for (var e = o.length, r = 0; r < e; ++r)
    if (t(o[r], r))
      return !0;
  return !1;
}
function find(o, t) {
  for (var e = o.length, r = 0; r < e; ++r)
    if (t(o[r], r))
      return o[r];
  return null;
}
function getUserAgentString(o) {
  var t = o;
  if (typeof t > "u") {
    if (typeof navigator > "u" || !navigator)
      return "";
    t = navigator.userAgent || "";
  }
  return t.toLowerCase();
}
function execRegExp(o, t) {
  try {
    return new RegExp(o, "g").exec(t);
  } catch {
    return null;
  }
}
function hasUserAgentData() {
  if (typeof navigator > "u" || !navigator || !navigator.userAgentData)
    return !1;
  var o = navigator.userAgentData, t = o.brands || o.uaList;
  return !!(t && t.length);
}
function findVersion(o, t) {
  var e = execRegExp("(" + o + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", t);
  return e ? e[3] : "";
}
function convertVersion(o) {
  return o.replace(/_/g, ".");
}
function findPreset(o, t) {
  var e = null, r = "-1";
  return some(o, function(D) {
    var N = execRegExp("(" + D.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", t);
    return !N || D.brand ? !1 : (e = D, r = N[3] || "-1", D.versionAlias ? r = D.versionAlias : D.versionTest && (r = findVersion(D.versionTest.toLowerCase(), t) || r), r = convertVersion(r), !0);
  }), {
    preset: e,
    version: r
  };
}
function findPresetBrand(o, t) {
  var e = {
    brand: "",
    version: "-1"
  };
  return some(o, function(r) {
    var D = findBrand(t, r);
    return D ? (e.brand = r.id, e.version = r.versionAlias || D.version, e.version !== "-1") : !1;
  }), e;
}
function findBrand(o, t) {
  return find(o, function(e) {
    var r = e.brand;
    return execRegExp("" + t.test, r.toLowerCase());
  });
}
var BROWSER_PRESETS = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}], CHROMIUM_PRESETS = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: !0
}], WEBKIT_PRESETS = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}], WEBVIEW_PRESETS = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}], OS_PRESETS = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];
function isWebView(o) {
  return !!findPreset(WEBVIEW_PRESETS, o).preset;
}
function getLegacyAgent(o) {
  var t = getUserAgentString(o), e = !!/mobi/g.exec(t), r = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: isWebView(t),
    chromium: !1,
    chromiumVersion: "-1",
    webkit: !1,
    webkitVersion: "-1"
  }, D = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  }, N = findPreset(BROWSER_PRESETS, t), k = N.preset, $ = N.version, G = findPreset(OS_PRESETS, t), U = G.preset, z = G.version, X = findPreset(CHROMIUM_PRESETS, t);
  if (r.chromium = !!X.preset, r.chromiumVersion = X.version, !r.chromium) {
    var V = findPreset(WEBKIT_PRESETS, t);
    r.webkit = !!V.preset, r.webkitVersion = V.version;
  }
  return U && (D.name = U.id, D.version = z, D.majorVersion = parseInt(z, 10)), k && (r.name = k.id, r.version = $, r.webview && D.name === "ios" && r.name !== "safari" && (r.webview = !1)), r.majorVersion = parseInt(r.version, 10), {
    browser: r,
    os: D,
    isMobile: e,
    isHints: !1
  };
}
function getClientHintsAgent(o) {
  var t = navigator.userAgentData, e = (t.uaList || t.brands).slice(), r = o && o.fullVersionList, D = t.mobile || !1, N = e[0], k = (o && o.platform || t.platform || navigator.platform).toLowerCase(), $ = {
    name: N.brand,
    version: N.version,
    majorVersion: -1,
    webkit: !1,
    webkitVersion: "-1",
    chromium: !1,
    chromiumVersion: "-1",
    webview: !!findPresetBrand(WEBVIEW_PRESETS, e).brand || isWebView(getUserAgentString())
  }, G = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  $.webkit = !$.chromium && some(WEBKIT_PRESETS, function(W) {
    return findBrand(e, W);
  });
  var U = findPresetBrand(CHROMIUM_PRESETS, e);
  if ($.chromium = !!U.brand, $.chromiumVersion = U.version, !$.chromium) {
    var z = findPresetBrand(WEBKIT_PRESETS, e);
    $.webkit = !!z.brand, $.webkitVersion = z.version;
  }
  var X = find(OS_PRESETS, function(W) {
    return new RegExp("" + W.test, "g").exec(k);
  });
  if (G.name = X ? X.id : "", o && (G.version = o.platformVersion), r && r.length) {
    var V = findPresetBrand(BROWSER_PRESETS, r);
    $.name = V.brand || $.name, $.version = V.version || $.version;
  } else {
    var Y = findPresetBrand(BROWSER_PRESETS, e);
    $.name = Y.brand || $.name, $.version = Y.brand && o ? o.uaFullVersion : Y.version;
  }
  return $.webkit && (G.name = D ? "ios" : "mac"), G.name === "ios" && $.webview && ($.version = "-1"), G.version = convertVersion(G.version), $.version = convertVersion($.version), G.majorVersion = parseInt(G.version, 10), $.majorVersion = parseInt($.version, 10), {
    browser: $,
    os: G,
    isMobile: D,
    isHints: !0
  };
}
function agent$1(o) {
  return typeof o > "u" && hasUserAgentData() ? getClientHintsAgent() : getLegacyAgent(o);
}
function add(o, t, e, r, D, N) {
  for (var k = 0; k < D; ++k) {
    var $ = e + k * D, G = r + k * D;
    o[$] += o[G] * N, t[$] += t[G] * N;
  }
}
function swap(o, t, e, r, D) {
  for (var N = 0; N < D; ++N) {
    var k = e + N * D, $ = r + N * D, G = o[k], U = t[k];
    o[k] = o[$], o[$] = G, t[k] = t[$], t[$] = U;
  }
}
function divide(o, t, e, r, D) {
  for (var N = 0; N < r; ++N) {
    var k = e + N * r;
    o[k] /= D, t[k] /= D;
  }
}
function ignoreDimension(o, t, e) {
  e === void 0 && (e = Math.sqrt(o.length));
  for (var r = o.slice(), D = 0; D < e; ++D)
    r[D * e + t - 1] = 0, r[(t - 1) * e + D] = 0;
  return r[(t - 1) * (e + 1)] = 1, r;
}
function invert(o, t) {
  t === void 0 && (t = Math.sqrt(o.length));
  for (var e = o.slice(), r = createIdentityMatrix(t), D = 0; D < t; ++D) {
    var N = t * D + D;
    if (!throttle(e[N], TINY_NUM$1)) {
      for (var k = D + 1; k < t; ++k)
        if (e[t * D + k]) {
          swap(e, r, D, k, t);
          break;
        }
    }
    if (!throttle(e[N], TINY_NUM$1))
      return [];
    divide(e, r, D, t, e[N]);
    for (var k = 0; k < t; ++k) {
      var $ = k, G = k + D * t, U = e[G];
      !throttle(U, TINY_NUM$1) || D === k || add(e, r, $, D, t, -U);
    }
  }
  return r;
}
function transpose(o, t) {
  t === void 0 && (t = Math.sqrt(o.length));
  for (var e = [], r = 0; r < t; ++r)
    for (var D = 0; D < t; ++D)
      e[D * t + r] = o[t * r + D];
  return e;
}
function getOrigin(o, t) {
  t === void 0 && (t = Math.sqrt(o.length));
  for (var e = [], r = o[t * t - 1], D = 0; D < t - 1; ++D)
    e[D] = o[t * (t - 1) + D] / r;
  return e[t - 1] = 0, e;
}
function fromTranslation(o, t) {
  for (var e = createIdentityMatrix(t), r = 0; r < t - 1; ++r)
    e[t * (t - 1) + r] = o[r] || 0;
  return e;
}
function convertPositionMatrix(o, t) {
  for (var e = o.slice(), r = o.length; r < t - 1; ++r)
    e[r] = 0;
  return e[t - 1] = 1, e;
}
function convertDimension(o, t, e) {
  if (t === void 0 && (t = Math.sqrt(o.length)), t === e)
    return o;
  for (var r = createIdentityMatrix(e), D = Math.min(t, e), N = 0; N < D - 1; ++N) {
    for (var k = 0; k < D - 1; ++k)
      r[N * e + k] = o[N * t + k];
    r[(N + 1) * e - 1] = o[(N + 1) * t - 1], r[(e - 1) * e + N] = o[(t - 1) * t + N];
  }
  return r[e * e - 1] = o[t * t - 1], r;
}
function multiplies(o) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  var r = createIdentityMatrix(o);
  return t.forEach(function(D) {
    r = multiply(r, D, o);
  }), r;
}
function multiply(o, t, e) {
  e === void 0 && (e = Math.sqrt(o.length));
  var r = [], D = o.length / e, N = t.length / D;
  if (D) {
    if (!N)
      return o;
  } else
    return t;
  for (var k = 0; k < e; ++k)
    for (var $ = 0; $ < N; ++$) {
      r[$ * e + k] = 0;
      for (var G = 0; G < D; ++G)
        r[$ * e + k] += o[G * e + k] * t[$ * D + G];
    }
  return r;
}
function plus(o, t) {
  for (var e = Math.min(o.length, t.length), r = o.slice(), D = 0; D < e; ++D)
    r[D] = r[D] + t[D];
  return r;
}
function minus(o, t) {
  for (var e = Math.min(o.length, t.length), r = o.slice(), D = 0; D < e; ++D)
    r[D] = r[D] - t[D];
  return r;
}
function convertCSStoMatrix(o, t) {
  return t === void 0 && (t = o.length === 6), t ? [o[0], o[1], 0, o[2], o[3], 0, o[4], o[5], 1] : o;
}
function convertMatrixtoCSS(o, t) {
  return t === void 0 && (t = o.length === 9), t ? [o[0], o[1], o[3], o[4], o[6], o[7]] : o;
}
function calculate(o, t, e) {
  e === void 0 && (e = t.length);
  var r = multiply(o, t, e), D = r[e - 1];
  return r.map(function(N) {
    return N / D;
  });
}
function rotateX3d(o, t) {
  return multiply(o, [1, 0, 0, 0, 0, Math.cos(t), Math.sin(t), 0, 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1], 4);
}
function rotateY3d(o, t) {
  return multiply(o, [Math.cos(t), 0, -Math.sin(t), 0, 0, 1, 0, 0, Math.sin(t), 0, Math.cos(t), 0, 0, 0, 0, 1], 4);
}
function rotateZ3d(o, t) {
  return multiply(o, createRotateMatrix(t, 4));
}
function scale3d(o, t) {
  var e = t[0], r = e === void 0 ? 1 : e, D = t[1], N = D === void 0 ? 1 : D, k = t[2], $ = k === void 0 ? 1 : k;
  return multiply(o, [r, 0, 0, 0, 0, N, 0, 0, 0, 0, $, 0, 0, 0, 0, 1], 4);
}
function rotate(o, t) {
  return calculate(createRotateMatrix(t, 3), convertPositionMatrix(o, 3));
}
function translate3d(o, t) {
  var e = t[0], r = e === void 0 ? 0 : e, D = t[1], N = D === void 0 ? 0 : D, k = t[2], $ = k === void 0 ? 0 : k;
  return multiply(o, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, r, N, $, 1], 4);
}
function matrix3d(o, t) {
  return multiply(o, t, 4);
}
function createRotateMatrix(o, t) {
  var e = Math.cos(o), r = Math.sin(o), D = createIdentityMatrix(t);
  return D[0] = e, D[1] = r, D[t] = -r, D[t + 1] = e, D;
}
function createIdentityMatrix(o) {
  for (var t = o * o, e = [], r = 0; r < t; ++r)
    e[r] = r % (o + 1) ? 0 : 1;
  return e;
}
function createScaleMatrix(o, t) {
  for (var e = createIdentityMatrix(t), r = Math.min(o.length, t - 1), D = 0; D < r; ++D)
    e[(t + 1) * D] = o[D];
  return e;
}
function createOriginMatrix(o, t) {
  for (var e = createIdentityMatrix(t), r = Math.min(o.length, t - 1), D = 0; D < r; ++D)
    e[t * (t - 1) + D] = o[D];
  return e;
}
function createWarpMatrix(o, t, e, r, D, N, k, $) {
  var G = o[0], U = o[1], z = t[0], X = t[1], V = e[0], Y = e[1], W = r[0], q = r[1], K = D[0], Z = D[1], J = N[0], Q = N[1], et = k[0], it = k[1], tt = $[0], nt = $[1], st = [G, 0, z, 0, V, 0, W, 0, U, 0, X, 0, Y, 0, q, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, G, 0, z, 0, V, 0, W, 0, U, 0, X, 0, Y, 0, q, 0, 1, 0, 1, 0, 1, 0, 1, -K * G, -Z * G, -J * z, -Q * z, -et * V, -it * V, -tt * W, -nt * W, -K * U, -Z * U, -J * X, -Q * X, -et * Y, -it * Y, -tt * q, -nt * q], at = invert(st, 8);
  if (!at.length)
    return [];
  var ut = multiply(at, [K, Z, J, Q, et, it, tt, nt], 8);
  return ut[8] = 1, convertDimension(transpose(ut), 3, 4);
}
function createMatrix() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function parseMat(o) {
  return toMat(parse$1(o));
}
function calculateMatrixDist(o, t) {
  var e = calculate(o, [t[0], t[1] || 0, t[2] || 0, 1], 4), r = e[3] || 1;
  return [e[0] / r, e[1] / r, e[2] / r];
}
function toMat(o) {
  var t = createMatrix();
  return o.forEach(function(e) {
    var r = e.matrixFunction, D = e.functionValue;
    r && (t = r(t, D));
  }), t;
}
function parse$1(o) {
  var t = isArray(o) ? o : splitSpace(o);
  return t.map(function(e) {
    var r = splitBracket(e), D = r.prefix, N = r.value, k = null, $ = D, G = "";
    if (D === "translate" || D === "translateX" || D === "translate3d") {
      var U = splitComma(N).map(function(ut) {
        return parseFloat(ut);
      }), z = U[0], X = U[1], V = X === void 0 ? 0 : X, Y = U[2], W = Y === void 0 ? 0 : Y;
      k = translate3d, G = [z, V, W];
    } else if (D === "translateY") {
      var V = parseFloat(N);
      k = translate3d, G = [0, V, 0];
    } else if (D === "translateZ") {
      var W = parseFloat(N);
      k = translate3d, G = [0, 0, W];
    } else if (D === "scale" || D === "scale3d") {
      var q = splitComma(N).map(function(ut) {
        return parseFloat(ut);
      }), K = q[0], Z = q[1], J = Z === void 0 ? K : Z, Q = q[2], et = Q === void 0 ? 1 : Q;
      k = scale3d, G = [K, J, et];
    } else if (D === "scaleX") {
      var K = parseFloat(N);
      k = scale3d, G = [K, 1, 1];
    } else if (D === "scaleY") {
      var J = parseFloat(N);
      k = scale3d, G = [1, J, 1];
    } else if (D === "scaleZ") {
      var et = parseFloat(N);
      k = scale3d, G = [1, 1, et];
    } else if (D === "rotate" || D === "rotateZ" || D === "rotateX" || D === "rotateY") {
      var it = splitUnit(N), tt = it.unit, nt = it.value, st = tt === "rad" ? nt : nt * Math.PI / 180;
      D === "rotate" || D === "rotateZ" ? ($ = "rotateZ", k = rotateZ3d) : D === "rotateX" ? k = rotateX3d : D === "rotateY" && (k = rotateY3d), G = st;
    } else if (D === "matrix3d")
      k = matrix3d, G = splitComma(N).map(function(ut) {
        return parseFloat(ut);
      });
    else if (D === "matrix") {
      var at = splitComma(N).map(function(ut) {
        return parseFloat(ut);
      });
      k = matrix3d, G = [at[0], at[1], 0, 0, at[2], at[3], 0, 0, 0, 0, 1, 0, at[4], at[5], 0, 1];
    } else
      $ = "";
    return {
      name: D,
      functionName: $,
      value: N,
      matrixFunction: k,
      functionValue: G
    };
  });
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$4 = function(o, t) {
  return extendStatics$4 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$4(o, t);
};
function __extends$4(o, t) {
  extendStatics$4(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var findKeyCallback = typeof Map == "function" ? void 0 : function() {
  var o = 0;
  return function(t) {
    return t.__DIFF_KEY__ || (t.__DIFF_KEY__ = ++o);
  };
}(), ChildrenDiffer = /* @__PURE__ */ function(o) {
  __extends$4(t, o);
  function t(e) {
    return e === void 0 && (e = []), o.call(this, e, findKeyCallback) || this;
  }
  return t;
}(ListDiffer);
function diff(o, t) {
  return diff$1(o, t, findKeyCallback);
}
const ChildrenDiffer$1 = ChildrenDiffer;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$5 = function() {
  return __assign$5 = Object.assign || function(t) {
    for (var e, r = 1, D = arguments.length; r < D; r++) {
      e = arguments[r];
      for (var N in e)
        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);
    }
    return t;
  }, __assign$5.apply(this, arguments);
};
function __spreadArrays$1() {
  for (var o = 0, t = 0, e = arguments.length; t < e; t++)
    o += arguments[t].length;
  for (var r = Array(o), D = 0, t = 0; t < e; t++)
    for (var N = arguments[t], k = 0, $ = N.length; k < $; k++, D++)
      r[D] = N[k];
  return r;
}
var EventEmitter = /* @__PURE__ */ function() {
  function o() {
    this._events = {};
  }
  var t = o.prototype;
  return t.on = function(e, r) {
    if (isObject$2(e))
      for (var D in e)
        this.on(D, e[D]);
    else
      this._addEvent(e, r, {});
    return this;
  }, t.off = function(e, r) {
    if (!e)
      this._events = {};
    else if (isObject$2(e))
      for (var D in e)
        this.off(D);
    else if (!r)
      this._events[e] = [];
    else {
      var N = this._events[e];
      if (N) {
        var k = findIndex(N, function($) {
          return $.listener === r;
        });
        k > -1 && N.splice(k, 1);
      }
    }
    return this;
  }, t.once = function(e, r) {
    var D = this;
    return r && this._addEvent(e, r, {
      once: !0
    }), new Promise(function(N) {
      D._addEvent(e, N, {
        once: !0
      });
    });
  }, t.emit = function(e, r) {
    var D = this;
    r === void 0 && (r = {});
    var N = this._events[e];
    if (!e || !N)
      return !0;
    var k = !1;
    return r.eventType = e, r.stop = function() {
      k = !0;
    }, r.currentTarget = this, __spreadArrays$1(N).forEach(function($) {
      $.listener(r), $.once && D.off(e, $.listener);
    }), !k;
  }, t.trigger = function(e, r) {
    return r === void 0 && (r = {}), this.emit(e, r);
  }, t._addEvent = function(e, r, D) {
    var N = this._events;
    N[e] = N[e] || [];
    var k = N[e];
    k.push(__assign$5({
      listener: r
    }, D));
  }, o;
}();
const EventEmitter$1 = EventEmitter;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$3 = function(o, t) {
  return extendStatics$3 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$3(o, t);
};
function __extends$3(o, t) {
  extendStatics$3(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$4 = function() {
  return __assign$4 = Object.assign || function(t) {
    for (var e, r = 1, D = arguments.length; r < D; r++) {
      e = arguments[r];
      for (var N in e)
        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);
    }
    return t;
  }, __assign$4.apply(this, arguments);
};
function getDefaultScrollPosition$1(o) {
  var t = o.container;
  return t === document.body ? [t.scrollLeft || document.documentElement.scrollLeft, t.scrollTop || document.documentElement.scrollTop] : [t.scrollLeft, t.scrollTop];
}
function checkDefaultScrollEvent(o, t) {
  return o.addEventListener("scroll", t), function() {
    o.removeEventListener("scroll", t);
  };
}
function getContainerElement(o) {
  if (o) {
    if (isString(o))
      return document.querySelector(o);
  } else
    return null;
  if (isFunction$2(o))
    return o();
  if (o instanceof Element)
    return o;
  if ("current" in o)
    return o.current;
  if ("value" in o)
    return o.value;
}
var DragScroll = /* @__PURE__ */ function(o) {
  __extends$3(t, o);
  function t() {
    var r = o !== null && o.apply(this, arguments) || this;
    return r._startRect = null, r._startPos = [], r._prevTime = 0, r._timer = 0, r._prevScrollPos = [0, 0], r._isWait = !1, r._flag = !1, r._currentOptions = null, r._lock = !1, r._unregister = null, r._onScroll = function() {
      var D = r._currentOptions;
      r._lock || !D || r.emit("scrollDrag", {
        next: function(N) {
          r.checkScroll({
            container: D.container,
            inputEvent: N
          });
        }
      });
    }, r;
  }
  var e = t.prototype;
  return e.dragStart = function(r, D) {
    var N = getContainerElement(D.container);
    if (!N) {
      this._flag = !1;
      return;
    }
    var k = 0, $ = 0, G = 0, U = 0;
    if (N === document.body)
      G = window.innerWidth, U = window.innerHeight;
    else {
      var z = N.getBoundingClientRect();
      k = z.top, $ = z.left, G = z.width, U = z.height;
    }
    this._flag = !0, this._startPos = [r.clientX, r.clientY], this._startRect = {
      top: k,
      left: $,
      width: G,
      height: U
    }, this._prevScrollPos = this._getScrollPosition([0, 0], D), this._currentOptions = D, this._registerScrollEvent(D);
  }, e.drag = function(r, D) {
    if (clearTimeout(this._timer), !!this._flag) {
      var N = r.clientX, k = r.clientY, $ = D.threshold, G = $ === void 0 ? 0 : $, U = this, z = U._startRect, X = U._startPos;
      this._currentOptions = D;
      var V = [0, 0];
      return z.top > k - G ? (X[1] > z.top || k < X[1]) && (V[1] = -1) : z.top + z.height < k + G && (X[1] < z.top + z.height || k > X[1]) && (V[1] = 1), z.left > N - G ? (X[0] > z.left || N < X[0]) && (V[0] = -1) : z.left + z.width < N + G && (X[0] < z.left + z.width || N > X[0]) && (V[0] = 1), !V[0] && !V[1] ? !1 : this._continueDrag(__assign$4(__assign$4({}, D), {
        direction: V,
        inputEvent: r,
        isDrag: !0
      }));
    }
  }, e.checkScroll = function(r) {
    var D = this;
    if (this._isWait)
      return !1;
    var N = r.prevScrollPos, k = N === void 0 ? this._prevScrollPos : N, $ = r.direction, G = r.throttleTime, U = G === void 0 ? 0 : G, z = r.inputEvent, X = r.isDrag, V = this._getScrollPosition($ || [0, 0], r), Y = V[0] - k[0], W = V[1] - k[1], q = $ || [Y ? Math.abs(Y) / Y : 0, W ? Math.abs(W) / W : 0];
    return this._prevScrollPos = V, this._lock = !1, !Y && !W ? !1 : (this.emit("move", {
      offsetX: q[0] ? Y : 0,
      offsetY: q[1] ? W : 0,
      inputEvent: z
    }), U && X && (clearTimeout(this._timer), this._timer = window.setTimeout(function() {
      D._continueDrag(r);
    }, U)), !0);
  }, e.dragEnd = function() {
    this._flag = !1, this._lock = !1, clearTimeout(this._timer), this._unregisterScrollEvent();
  }, e._getScrollPosition = function(r, D) {
    var N = D.container, k = D.getScrollPosition, $ = k === void 0 ? getDefaultScrollPosition$1 : k;
    return $({
      container: getContainerElement(N),
      direction: r
    });
  }, e._continueDrag = function(r) {
    var D = this, N, k = r.container, $ = r.direction, G = r.throttleTime, U = r.useScroll, z = r.isDrag, X = r.inputEvent;
    if (!(!this._flag || z && this._isWait)) {
      var V = now(), Y = Math.max(G + this._prevTime - V, 0);
      if (Y > 0)
        return clearTimeout(this._timer), this._timer = window.setTimeout(function() {
          D._continueDrag(r);
        }, Y), !1;
      this._prevTime = V;
      var W = this._getScrollPosition($, r);
      this._prevScrollPos = W, z && (this._isWait = !0), U || (this._lock = !0);
      var q = {
        container: getContainerElement(k),
        direction: $,
        inputEvent: X
      };
      return (N = r.requestScroll) === null || N === void 0 || N.call(r, q), this.emit("scroll", q), this._isWait = !1, U || this.checkScroll(__assign$4(__assign$4({}, r), {
        prevScrollPos: W,
        direction: $,
        inputEvent: X
      }));
    }
  }, e._registerScrollEvent = function(r) {
    this._unregisterScrollEvent();
    var D = r.checkScrollEvent;
    if (D) {
      var N = D === !0 ? checkDefaultScrollEvent : D, k = getContainerElement(r.container);
      D === !0 && (k === document.body || k === document.documentElement) ? this._unregister = checkDefaultScrollEvent(window, this._onScroll) : this._unregister = N(k, this._onScroll);
    }
  }, e._unregisterScrollEvent = function() {
    var r;
    (r = this._unregister) === null || r === void 0 || r.call(this), this._unregister = null;
  }, t;
}(EventEmitter$1);
const DragScroll$1 = DragScroll;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __spreadArrays() {
  for (var o = 0, t = 0, e = arguments.length; t < e; t++)
    o += arguments[t].length;
  for (var r = Array(o), D = 0, t = 0; t < e; t++)
    for (var N = arguments[t], k = 0, $ = N.length; k < $; k++, D++)
      r[D] = N[k];
  return r;
}
function tinyThrottle(o) {
  return throttle(o, TINY_NUM$1);
}
function isSameConstants(o, t) {
  return o.every(function(e, r) {
    return tinyThrottle(e - t[r]) === 0;
  });
}
function isSamePoint(o, t) {
  return !tinyThrottle(o[0] - t[0]) && !tinyThrottle(o[1] - t[1]);
}
function getAreaSize(o) {
  return o.length < 3 ? 0 : Math.abs(sum(o.map(function(t, e) {
    var r = o[e + 1] || o[0];
    return t[0] * r[1] - r[0] * t[1];
  }))) / 2;
}
function fitPoints(o, t) {
  var e = t.width, r = t.height, D = t.left, N = t.top, k = getMinMaxs(o), $ = k.minX, G = k.minY, U = k.maxX, z = k.maxY, X = e / (U - $), V = r / (z - G);
  return o.map(function(Y) {
    return [D + (Y[0] - $) * X, N + (Y[1] - G) * V];
  });
}
function getMinMaxs(o) {
  var t = o.map(function(r) {
    return r[0];
  }), e = o.map(function(r) {
    return r[1];
  });
  return {
    minX: Math.min.apply(Math, t),
    minY: Math.min.apply(Math, e),
    maxX: Math.max.apply(Math, t),
    maxY: Math.max.apply(Math, e)
  };
}
function isInside(o, t, e) {
  var r = o[0], D = o[1], N = getMinMaxs(t), k = N.minX, $ = N.maxX, G = [[k, D], [$, D]], U = getLinearConstants(G[0], G[1]), z = convertLines(t), X = [];
  if (z.forEach(function(W) {
    var q = getLinearConstants(W[0], W[1]), K = W[0];
    if (isSameConstants(U, q))
      X.push({
        pos: o,
        line: W,
        type: "line"
      });
    else {
      var Z = getPointsOnLines(getIntersectionPointsByConstants(U, q), [G, W]);
      Z.forEach(function(J) {
        W.some(function(Q) {
          return isSamePoint(Q, J);
        }) ? X.push({
          pos: J,
          line: W,
          type: "point"
        }) : tinyThrottle(K[1] - D) !== 0 && X.push({
          pos: J,
          line: W,
          type: "intersection"
        });
      });
    }
  }), !e && find$1(X, function(W) {
    return W[0] === r;
  }))
    return !0;
  var V = 0, Y = {};
  return X.forEach(function(W) {
    var q = W.pos, K = W.type, Z = W.line;
    if (!(q[0] > r))
      if (K === "intersection")
        ++V;
      else {
        if (K === "line")
          return;
        if (K === "point") {
          var J = find$1(Z, function(it) {
            return it[1] !== D;
          }), Q = Y[q[0]], et = J[1] > D ? 1 : -1;
          Q ? Q !== et && ++V : Y[q[0]] = et;
        }
      }
  }), V % 2 === 1;
}
function getLinearConstants(o, t) {
  var e = o[0], r = o[1], D = t[0], N = t[1], k = D - e, $ = N - r;
  Math.abs(k) < TINY_NUM$1 && (k = 0), Math.abs($) < TINY_NUM$1 && ($ = 0);
  var G = 0, U = 0, z = 0;
  return k ? $ ? (G = -$ / k, U = 1, z = -G * e - r) : (U = 1, z = -r) : $ && (G = -1, z = e), [G, U, z];
}
function getIntersectionPointsByConstants(o, t) {
  var e = o[0], r = o[1], D = o[2], N = t[0], k = t[1], $ = t[2], G = e === 0 && N === 0, U = r === 0 && k === 0, z = [];
  if (G && U)
    return [];
  if (G) {
    var X = -D / r, V = -$ / k;
    return X !== V ? [] : [[-1 / 0, X], [1 / 0, X]];
  } else if (U) {
    var Y = -D / e, W = -$ / N;
    return Y !== W ? [] : [[Y, -1 / 0], [Y, 1 / 0]];
  } else if (e === 0) {
    var q = -D / r, K = -(k * q + $) / N;
    z = [[K, q]];
  } else if (N === 0) {
    var q = -$ / k, K = -(r * q + D) / e;
    z = [[K, q]];
  } else if (r === 0) {
    var K = -D / e, q = -(N * K + $) / k;
    z = [[K, q]];
  } else if (k === 0) {
    var K = -$ / N, q = -(e * K + D) / r;
    z = [[K, q]];
  } else {
    var K = (r * $ - k * D) / (k * e - r * N), q = -(e * K + D) / r;
    z = [[K, q]];
  }
  return z.map(function(Z) {
    return [Z[0], Z[1]];
  });
}
function getPointsOnLines(o, t) {
  var e = t.map(function(X) {
    return [0, 1].map(function(V) {
      return [Math.min(X[0][V], X[1][V]), Math.max(X[0][V], X[1][V])];
    });
  }), r = [];
  if (o.length === 2) {
    var D = o[0], N = D[0], k = D[1];
    if (tinyThrottle(N - o[1][0])) {
      if (!tinyThrottle(k - o[1][1])) {
        var U = Math.max.apply(Math, e.map(function(X) {
          return X[0][0];
        })), z = Math.min.apply(Math, e.map(function(X) {
          return X[0][1];
        }));
        if (tinyThrottle(U - z) > 0)
          return [];
        r = [[U, k], [z, k]];
      }
    } else {
      var $ = Math.max.apply(Math, e.map(function(X) {
        return X[1][0];
      })), G = Math.min.apply(Math, e.map(function(X) {
        return X[1][1];
      }));
      if (tinyThrottle($ - G) > 0)
        return [];
      r = [[N, $], [N, G]];
    }
  }
  return r.length || (r = o.filter(function(X) {
    var V = X[0], Y = X[1];
    return e.every(function(W) {
      return 0 <= tinyThrottle(V - W[0][0]) && 0 <= tinyThrottle(W[0][1] - V) && 0 <= tinyThrottle(Y - W[1][0]) && 0 <= tinyThrottle(W[1][1] - Y);
    });
  })), r.map(function(X) {
    return [tinyThrottle(X[0]), tinyThrottle(X[1])];
  });
}
function convertLines(o) {
  return __spreadArrays(o.slice(1), [o[0]]).map(function(t, e) {
    return [o[e], t];
  });
}
function getOverlapPointInfos(o, t) {
  var e = o.slice(), r = t.slice();
  getShapeDirection(e) === -1 && e.reverse(), getShapeDirection(r) === -1 && r.reverse();
  var D = convertLines(e), N = convertLines(r), k = D.map(function(z) {
    return getLinearConstants(z[0], z[1]);
  }), $ = N.map(function(z) {
    return getLinearConstants(z[0], z[1]);
  }), G = [];
  k.forEach(function(z, X) {
    var V = D[X], Y = [];
    $.forEach(function(W, q) {
      var K = getIntersectionPointsByConstants(z, W), Z = getPointsOnLines(K, [V, N[q]]);
      Y.push.apply(Y, Z.map(function(J) {
        return {
          index1: X,
          index2: q,
          pos: J,
          type: "intersection"
        };
      }));
    }), Y.sort(function(W, q) {
      return getDist$2(V[0], W.pos) - getDist$2(V[0], q.pos);
    }), G.push.apply(G, Y), isInside(V[1], r) && G.push({
      index1: X,
      index2: -1,
      pos: V[1],
      type: "inside"
    });
  }), N.forEach(function(z, X) {
    if (isInside(z[1], e)) {
      var V = !1, Y = findIndex(G, function(W) {
        var q = W.index2;
        return q === X ? (V = !0, !1) : !!V;
      });
      Y === -1 && (V = !1, Y = findIndex(G, function(W) {
        var q = W.index1, K = W.index2;
        return q === -1 && K + 1 === X ? (V = !0, !1) : !!V;
      })), Y === -1 ? G.push({
        index1: -1,
        index2: X,
        pos: z[1],
        type: "inside"
      }) : G.splice(Y, 0, {
        index1: -1,
        index2: X,
        pos: z[1],
        type: "inside"
      });
    }
  });
  var U = {};
  return G.filter(function(z) {
    var X = z.pos, V = X[0] + "x" + X[1];
    return U[V] ? !1 : (U[V] = !0, !0);
  });
}
function getOverlapPoints(o, t) {
  var e = getOverlapPointInfos(o, t);
  return e.map(function(r) {
    var D = r.pos;
    return D;
  });
}
function getOverlapSize(o, t) {
  var e = getOverlapPoints(o, t);
  return getAreaSize(e);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$2 = function(o, t) {
  return extendStatics$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      r.hasOwnProperty(D) && (e[D] = r[D]);
  }, extendStatics$2(o, t);
};
function __extends$2(o, t) {
  extendStatics$2(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$3 = function() {
  return __assign$3 = Object.assign || function(t) {
    for (var e, r = 1, D = arguments.length; r < D; r++) {
      e = arguments[r];
      for (var N in e)
        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);
    }
    return t;
  }, __assign$3.apply(this, arguments);
};
function getRad(o, t) {
  var e = t[0] - o[0], r = t[1] - o[1], D = Math.atan2(r, e);
  return D >= 0 ? D : D + Math.PI * 2;
}
function getRotatiion(o) {
  return getRad([
    o[0].clientX,
    o[0].clientY
  ], [
    o[1].clientX,
    o[1].clientY
  ]) / Math.PI * 180;
}
function isMultiTouch(o) {
  return o.touches && o.touches.length >= 2;
}
function getEventClients(o) {
  return o ? o.touches ? getClients(o.touches) : [getClient(o)] : [];
}
function isMouseEvent(o) {
  return o && (o.type.indexOf("mouse") > -1 || "button" in o);
}
function getPosition(o, t, e) {
  var r = e.length, D = getAverageClient(o, r), N = D.clientX, k = D.clientY, $ = D.originalClientX, G = D.originalClientY, U = getAverageClient(t, r), z = U.clientX, X = U.clientY, V = getAverageClient(e, r), Y = V.clientX, W = V.clientY, q = N - z, K = k - X, Z = N - Y, J = k - W;
  return {
    clientX: $,
    clientY: G,
    deltaX: q,
    deltaY: K,
    distX: Z,
    distY: J
  };
}
function getDist$1(o) {
  return Math.sqrt(Math.pow(o[0].clientX - o[1].clientX, 2) + Math.pow(o[0].clientY - o[1].clientY, 2));
}
function getClients(o) {
  for (var t = Math.min(o.length, 2), e = [], r = 0; r < t; ++r)
    e.push(getClient(o[r]));
  return e;
}
function getClient(o) {
  return {
    clientX: o.clientX,
    clientY: o.clientY
  };
}
function getAverageClient(o, t) {
  t === void 0 && (t = o.length);
  for (var e = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  }, r = 0; r < t; ++r) {
    var D = o[r];
    e.originalClientX += "originalClientX" in D ? D.originalClientX : D.clientX, e.originalClientY += "originalClientY" in D ? D.originalClientY : D.clientY, e.clientX += D.clientX, e.clientY += D.clientY;
  }
  return t ? {
    clientX: e.clientX / t,
    clientY: e.clientY / t,
    originalClientX: e.originalClientX / t,
    originalClientY: e.originalClientY / t
  } : e;
}
var ClientStore = /* @__PURE__ */ function() {
  function o(t) {
    this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = t, this.prevClients = t, this.length = t.length;
  }
  return o.prototype.getAngle = function(t) {
    return t === void 0 && (t = this.prevClients), getRotatiion(t);
  }, o.prototype.getRotation = function(t) {
    return t === void 0 && (t = this.prevClients), getRotatiion(t) - getRotatiion(this.startClients);
  }, o.prototype.getPosition = function(t, e) {
    t === void 0 && (t = this.prevClients);
    var r = getPosition(t || this.prevClients, this.prevClients, this.startClients), D = r.deltaX, N = r.deltaY;
    return this.movement += Math.sqrt(D * D + N * N), this.prevClients = t, r;
  }, o.prototype.getPositions = function(t) {
    t === void 0 && (t = this.prevClients);
    var e = this.prevClients;
    return this.startClients.map(function(r, D) {
      return getPosition([t[D]], [e[D]], [r]);
    });
  }, o.prototype.getMovement = function(t) {
    var e = this.movement;
    if (!t)
      return e;
    var r = getAverageClient(t, this.length), D = getAverageClient(this.prevClients, this.length), N = r.clientX - D.clientX, k = r.clientY - D.clientY;
    return Math.sqrt(N * N + k * k) + e;
  }, o.prototype.getDistance = function(t) {
    return t === void 0 && (t = this.prevClients), getDist$1(t);
  }, o.prototype.getScale = function(t) {
    return t === void 0 && (t = this.prevClients), getDist$1(t) / getDist$1(this.startClients);
  }, o.prototype.move = function(t, e) {
    this.startClients.forEach(function(r) {
      r.clientX -= t, r.clientY -= e;
    }), this.prevClients.forEach(function(r) {
      r.clientX -= t, r.clientY -= e;
    });
  }, o;
}(), INPUT_TAGNAMES = ["textarea", "input"], Gesto = /* @__PURE__ */ function(o) {
  __extends$2(t, o);
  function t(e, r) {
    r === void 0 && (r = {});
    var D = o.call(this) || this;
    D.options = {}, D.flag = !1, D.pinchFlag = !1, D.data = {}, D.isDrag = !1, D.isPinch = !1, D.isMouse = !1, D.isTouch = !1, D.clientStores = [], D.targets = [], D.prevTime = 0, D.doubleFlag = !1, D._dragFlag = !1, D._isTrusted = !1, D._isMouseEvent = !1, D._isSecondaryButton = !1, D._preventMouseEvent = !1, D._prevInputEvent = null, D.onDragStart = function(X, V) {
      if (V === void 0 && (V = !0), !(!D.flag && X.cancelable === !1)) {
        var Y = D.options, W = Y.container, q = Y.pinchOutside, K = Y.preventWheelClick, Z = Y.preventRightClick, J = Y.preventDefault, Q = Y.checkInput, et = Y.dragFocusedInput, it = Y.preventClickEventOnDragStart, tt = Y.preventClickEventOnDrag, nt = Y.preventClickEventByCondition, st = D.isTouch, at = !D.flag;
        if (D._isSecondaryButton = X.which === 3 || X.button === 2, K && (X.which === 2 || X.button === 1) || Z && (X.which === 3 || X.button === 2))
          return D.stop(), !1;
        if (at) {
          var ut = document.activeElement, ht = X.target;
          if (ht) {
            var dt = ht.tagName.toLowerCase(), pt = INPUT_TAGNAMES.indexOf(dt) > -1, _t = ht.isContentEditable;
            if (pt || _t) {
              if (Q || !et && ut === ht || ut && _t && ut.isContentEditable && ut.contains(ht))
                return !1;
            } else if ((J || X.type === "touchstart") && ut) {
              var mt = ut.tagName.toLowerCase();
              (ut.isContentEditable || INPUT_TAGNAMES.indexOf(mt) > -1) && ut.blur();
            }
            (it || tt || nt) && addEvent(window, "click", D._onClick, !0);
          }
          D.clientStores = [new ClientStore(getEventClients(X))], D.flag = !0, D.isDrag = !1, D._isTrusted = V, D._dragFlag = !0, D._prevInputEvent = X, D.data = {}, D.doubleFlag = now() - D.prevTime < 200, D._isMouseEvent = isMouseEvent(X), !D._isMouseEvent && D._preventMouseEvent && (D._preventMouseEvent = !1);
          var yt = D._preventMouseEvent || D.emit("dragStart", __assign$3(__assign$3({ data: D.data, datas: D.data, inputEvent: X, isMouseEvent: D._isMouseEvent, isSecondaryButton: D._isSecondaryButton, isTrusted: V, isDouble: D.doubleFlag }, D.getCurrentStore().getPosition()), { preventDefault: function() {
            X.preventDefault();
          }, preventDrag: function() {
            D._dragFlag = !1;
          } }));
          yt === !1 && D.stop(), D._isMouseEvent && D.flag && J && X.preventDefault();
        }
        if (!D.flag)
          return !1;
        var Tt = 0;
        if (at ? (D._attchDragEvent(), st && q && (Tt = setTimeout(function() {
          addEvent(W, "touchstart", D.onDragStart, {
            passive: !1
          });
        }))) : st && q && removeEvent(W, "touchstart", D.onDragStart), D.flag && isMultiTouch(X)) {
          if (clearTimeout(Tt), at && X.touches.length !== X.changedTouches.length)
            return;
          D.pinchFlag || D.onPinchStart(X);
        }
      }
    }, D.onDrag = function(X, V) {
      if (D.flag) {
        var Y = D.options.preventDefault;
        !D._isMouseEvent && Y && X.preventDefault(), D._prevInputEvent = X;
        var W = getEventClients(X), q = D.moveClients(W, X, !1);
        if (D._dragFlag) {
          if (D.pinchFlag || q.deltaX || q.deltaY) {
            var K = D._preventMouseEvent || D.emit("drag", __assign$3(__assign$3({}, q), { isScroll: !!V, inputEvent: X }));
            if (K === !1) {
              D.stop();
              return;
            }
          }
          D.pinchFlag && D.onPinch(X, W);
        }
        D.getCurrentStore().getPosition(W, !0);
      }
    }, D.onDragEnd = function(X) {
      if (D.flag) {
        var V = D.options, Y = V.pinchOutside, W = V.container, q = V.preventClickEventOnDrag, K = V.preventClickEventOnDragStart, Z = V.preventClickEventByCondition, J = D.isDrag;
        (q || K || Z) && requestAnimationFrame(function() {
          D._allowClickEvent();
        }), !Z && !K && q && !J && D._allowClickEvent(), D.isTouch && Y && removeEvent(W, "touchstart", D.onDragStart), D.pinchFlag && D.onPinchEnd(X);
        var Q = X != null && X.touches ? getEventClients(X) : [], et = Q.length;
        et === 0 || !D.options.keepDragging ? D.flag = !1 : D._addStore(new ClientStore(Q));
        var it = D._getPosition(), tt = now(), nt = !J && D.doubleFlag;
        D._prevInputEvent = null, D.prevTime = J || nt ? 0 : tt, D.flag || (D._dettachDragEvent(), D._preventMouseEvent || D.emit("dragEnd", __assign$3({ data: D.data, datas: D.data, isDouble: nt, isDrag: J, isClick: !J, isMouseEvent: D._isMouseEvent, isSecondaryButton: D._isSecondaryButton, inputEvent: X, isTrusted: D._isTrusted }, it)), D.clientStores = [], D._isMouseEvent || (D._preventMouseEvent = !0, requestAnimationFrame(function() {
          requestAnimationFrame(function() {
            D._preventMouseEvent = !1;
          });
        })));
      }
    }, D.onBlur = function() {
      D.onDragEnd();
    }, D._allowClickEvent = function() {
      removeEvent(window, "click", D._onClick, !0);
    }, D._onClick = function(X) {
      D._allowClickEvent(), D._preventMouseEvent = !1;
      var V = D.options.preventClickEventByCondition;
      V != null && V(X) || (X.stopPropagation(), X.preventDefault());
    }, D._onContextMenu = function(X) {
      var V = D.options;
      V.preventRightClick ? D.onDragEnd(X) : X.preventDefault();
    }, D._passCallback = function() {
    };
    var N = [].concat(e);
    D.options = __assign$3({ checkInput: !1, container: N.length > 1 ? window : N[0], preventRightClick: !0, preventWheelClick: !0, preventClickEventOnDragStart: !1, preventClickEventOnDrag: !1, preventClickEventByCondition: null, preventDefault: !0, checkWindowBlur: !1, keepDragging: !1, pinchThreshold: 0, events: ["touch", "mouse"] }, r);
    var k = D.options, $ = k.container, G = k.events, U = k.checkWindowBlur;
    if (D.isTouch = G.indexOf("touch") > -1, D.isMouse = G.indexOf("mouse") > -1, D.targets = N, D.isMouse && (N.forEach(function(X) {
      addEvent(X, "mousedown", D.onDragStart), addEvent(X, "mousemove", D._passCallback);
    }), addEvent($, "contextmenu", D._onContextMenu)), U && addEvent(window, "blur", D.onBlur), D.isTouch) {
      var z = {
        passive: !1
      };
      N.forEach(function(X) {
        addEvent(X, "touchstart", D.onDragStart, z), addEvent(X, "touchmove", D._passCallback, z);
      });
    }
    return D;
  }
  return t.prototype.stop = function() {
    this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._allowClickEvent(), this._dettachDragEvent();
  }, t.prototype.getMovement = function(e) {
    return this.getCurrentStore().getMovement(e) + this.clientStores.slice(1).reduce(function(r, D) {
      return r + D.movement;
    }, 0);
  }, t.prototype.isDragging = function() {
    return this.isDrag;
  }, t.prototype.isFlag = function() {
    return this.flag;
  }, t.prototype.isPinchFlag = function() {
    return this.pinchFlag;
  }, t.prototype.isDoubleFlag = function() {
    return this.doubleFlag;
  }, t.prototype.isPinching = function() {
    return this.isPinch;
  }, t.prototype.scrollBy = function(e, r, D, N) {
    N === void 0 && (N = !0), this.flag && (this.clientStores[0].move(e, r), N && this.onDrag(D, !0));
  }, t.prototype.move = function(e, r) {
    var D = e[0], N = e[1], k = this.getCurrentStore(), $ = k.prevClients;
    return this.moveClients($.map(function(G) {
      var U = G.clientX, z = G.clientY;
      return {
        clientX: U + D,
        clientY: z + N,
        originalClientX: U,
        originalClientY: z
      };
    }), r, !0);
  }, t.prototype.triggerDragStart = function(e) {
    this.onDragStart(e, !1);
  }, t.prototype.setEventData = function(e) {
    var r = this.data;
    for (var D in e)
      r[D] = e[D];
    return this;
  }, t.prototype.setEventDatas = function(e) {
    return this.setEventData(e);
  }, t.prototype.getCurrentEvent = function(e) {
    return e === void 0 && (e = this._prevInputEvent), __assign$3(__assign$3({ data: this.data, datas: this.data }, this._getPosition()), { movement: this.getMovement(), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, inputEvent: e });
  }, t.prototype.getEventData = function() {
    return this.data;
  }, t.prototype.getEventDatas = function() {
    return this.data;
  }, t.prototype.unset = function() {
    var e = this, r = this.targets, D = this.options.container;
    this.off(), removeEvent(window, "blur", this.onBlur), this.isMouse && (r.forEach(function(N) {
      removeEvent(N, "mousedown", e.onDragStart);
    }), removeEvent(D, "contextmenu", this._onContextMenu)), this.isTouch && (r.forEach(function(N) {
      removeEvent(N, "touchstart", e.onDragStart);
    }), removeEvent(D, "touchstart", this.onDragStart)), this._prevInputEvent = null, this._allowClickEvent(), this._dettachDragEvent();
  }, t.prototype.onPinchStart = function(e) {
    var r = this, D = this.options.pinchThreshold;
    if (!(this.isDrag && this.getMovement() > D)) {
      var N = new ClientStore(getEventClients(e));
      this.pinchFlag = !0, this._addStore(N);
      var k = this.emit("pinchStart", __assign$3(__assign$3({ data: this.data, datas: this.data, angle: N.getAngle(), touches: this.getCurrentStore().getPositions() }, N.getPosition()), { inputEvent: e, isTrusted: this._isTrusted, preventDefault: function() {
        e.preventDefault();
      }, preventDrag: function() {
        r._dragFlag = !1;
      } }));
      k === !1 && (this.pinchFlag = !1);
    }
  }, t.prototype.onPinch = function(e, r) {
    if (!(!this.flag || !this.pinchFlag || r.length < 2)) {
      var D = this.getCurrentStore();
      this.isPinch = !0, this.emit("pinch", __assign$3(__assign$3({ data: this.data, datas: this.data, movement: this.getMovement(r), angle: D.getAngle(r), rotation: D.getRotation(r), touches: D.getPositions(r), scale: D.getScale(r), distance: D.getDistance(r) }, D.getPosition(r)), { inputEvent: e, isTrusted: this._isTrusted }));
    }
  }, t.prototype.onPinchEnd = function(e) {
    if (this.pinchFlag) {
      var r = this.isPinch;
      this.isPinch = !1, this.pinchFlag = !1;
      var D = this.getCurrentStore();
      this.emit("pinchEnd", __assign$3(__assign$3({ data: this.data, datas: this.data, isPinch: r, touches: D.getPositions() }, D.getPosition()), { inputEvent: e }));
    }
  }, t.prototype.getCurrentStore = function() {
    return this.clientStores[0];
  }, t.prototype.moveClients = function(e, r, D) {
    var N = this._getPosition(e, D), k = this.isDrag;
    (N.deltaX || N.deltaY) && (this.isDrag = !0);
    var $ = !1;
    return !k && this.isDrag && ($ = !0), __assign$3(__assign$3({ data: this.data, datas: this.data }, N), { movement: this.getMovement(e), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, isMouseEvent: this._isMouseEvent, isSecondaryButton: this._isSecondaryButton, inputEvent: r, isTrusted: this._isTrusted, isFirstDrag: $ });
  }, t.prototype._addStore = function(e) {
    this.clientStores.splice(0, 0, e);
  }, t.prototype._getPosition = function(e, r) {
    var D = this.getCurrentStore(), N = D.getPosition(e, r), k = this.clientStores.slice(1).reduce(function(U, z) {
      var X = z.getPosition();
      return U.distX += X.distX, U.distY += X.distY, U;
    }, N), $ = k.distX, G = k.distY;
    return __assign$3(__assign$3({}, N), { distX: $, distY: G });
  }, t.prototype._attchDragEvent = function() {
    var e = this.options.container, r = {
      passive: !1
    };
    this.isMouse && (addEvent(e, "mousemove", this.onDrag), addEvent(e, "mouseup", this.onDragEnd)), this.isTouch && (addEvent(e, "touchmove", this.onDrag, r), addEvent(e, "touchend", this.onDragEnd, r), addEvent(e, "touchcancel", this.onDragEnd, r));
  }, t.prototype._dettachDragEvent = function() {
    var e = this.options.container;
    this.isMouse && (removeEvent(e, "mousemove", this.onDrag), removeEvent(e, "mouseup", this.onDragEnd)), this.isTouch && (removeEvent(e, "touchstart", this.onDragStart), removeEvent(e, "touchmove", this.onDrag), removeEvent(e, "touchend", this.onDragEnd), removeEvent(e, "touchcancel", this.onDragEnd));
  }, t;
}(EventEmitter$1);
function hash$2(o) {
  for (var t = 5381, e = o.length; e; )
    t = t * 33 ^ o.charCodeAt(--e);
  return t >>> 0;
}
var stringHash = hash$2;
function getHash(o) {
  return stringHash(o).toString(36);
}
function getShadowRoot$1(o) {
  if (o && o.getRootNode) {
    var t = o.getRootNode();
    if (t.nodeType === 11)
      return t;
  }
}
function replaceStyle(o, t, e) {
  return e.original ? t : t.replace(/([^};{\s}][^};{]*|^\s*){/mg, function(r, D) {
    var N = D.trim();
    return (N ? splitComma(N) : [""]).map(function(k) {
      var $ = k.trim();
      return $.indexOf("@") === 0 ? $ : $.indexOf(":global") > -1 ? $.replace(/\:global/g, "") : $.indexOf(":host") > -1 ? "" + $.replace(/\:host/g, "." + o) : $ ? "." + o + " " + $ : "." + o;
    }).join(", ") + " {";
  });
}
function injectStyle(o, t, e, r) {
  var D = document.createElement("style");
  return D.setAttribute("type", "text/css"), D.setAttribute("data-styled-id", o), e.nonce && D.setAttribute("nonce", e.nonce), D.innerHTML = replaceStyle(o, t, e), (r || document.head || document.body).appendChild(D), D;
}
function styled$1(o) {
  var t = "rCS" + getHash(o), e = 0, r;
  return {
    className: t,
    inject: function(D, N) {
      N === void 0 && (N = {});
      var k = getShadowRoot$1(D), $ = e === 0, G;
      return (k || $) && (G = injectStyle(t, o, N, k)), $ && (r = G), k || ++e, {
        destroy: function() {
          k ? (k.removeChild(G), G = null) : (e > 0 && --e, e === 0 && r && (r.parentNode.removeChild(r), r = null));
        }
      };
    }
  };
}
var __assign$2 = function() {
  return __assign$2 = Object.assign || function(t) {
    for (var e, r = 1, D = arguments.length; r < D; r++) {
      e = arguments[r];
      for (var N in e)
        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);
    }
    return t;
  }, __assign$2.apply(this, arguments);
};
function __rest$1(o, t) {
  var e = {};
  for (var r in o)
    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var D = 0, r = Object.getOwnPropertySymbols(o); D < r.length; D++)
      t.indexOf(r[D]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[D]) && (e[r[D]] = o[r[D]]);
  return e;
}
function styled(o, t) {
  var e = styled$1(t), r = e.className;
  return forwardRef(function(D, N) {
    var k = D.className, $ = k === void 0 ? "" : k;
    D.cspNonce;
    var G = __rest$1(D, ["className", "cspNonce"]), U = useRef();
    return useImperativeHandle(N, function() {
      return U.current;
    }, []), useEffect(function() {
      var z = e.inject(U.current, {
        nonce: D.cspNonce
      });
      return function() {
        z.destroy();
      };
    }, []), createElement(o, __assign$2({
      ref: U,
      "data-styled-id": r,
      className: "".concat($, " ").concat(r)
    }, G));
  });
}
var extendStatics$1 = function(o, t) {
  return extendStatics$1 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      Object.prototype.hasOwnProperty.call(r, D) && (e[D] = r[D]);
  }, extendStatics$1(o, t);
};
function __extends$1(o, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  extendStatics$1(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$1 = function() {
  return __assign$1 = Object.assign || function(t) {
    for (var e, r = 1, D = arguments.length; r < D; r++) {
      e = arguments[r];
      for (var N in e)
        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);
    }
    return t;
  }, __assign$1.apply(this, arguments);
};
function __rest(o, t) {
  var e = {};
  for (var r in o)
    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var D = 0, r = Object.getOwnPropertySymbols(o); D < r.length; D++)
      t.indexOf(r[D]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[D]) && (e[r[D]] = o[r[D]]);
  return e;
}
function __decorate$1(o, t, e, r) {
  var D = arguments.length, N = D < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, k;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    N = Reflect.decorate(o, t, e, r);
  else
    for (var $ = o.length - 1; $ >= 0; $--)
      (k = o[$]) && (N = (D < 3 ? k(N) : D > 3 ? k(t, e, N) : k(t, e)) || N);
  return D > 3 && N && Object.defineProperty(t, e, N), N;
}
function __spreadArray(o, t, e) {
  if (e || arguments.length === 2)
    for (var r = 0, D = t.length, N; r < D; r++)
      (N || !(r in t)) && (N || (N = Array.prototype.slice.call(t, 0, r)), N[r] = t[r]);
  return o.concat(N || Array.prototype.slice.call(t));
}
function makeAble(o, t) {
  return __assign$1({
    events: [],
    props: [],
    name: o
  }, t);
}
var DIRECTIONS4 = ["n", "w", "s", "e"], DIRECTIONS = ["n", "w", "s", "e", "nw", "ne", "sw", "se"];
function getSVGCursor(o, t) {
  return 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="'.concat(32 * o, 'px" height="').concat(32 * o, 'px" viewBox="0 0 32 32" ><path d="M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z" stroke-linejoin="round" stroke-width="1.2" fill="black" stroke="white" style="transform:rotate(').concat(t, 'deg);transform-origin: 16px 16px"></path></svg>');
}
function getCursorCSS(o) {
  var t = getSVGCursor(1, o), e = Math.round(o / 45) * 45 % 180, r = "ns-resize";
  return e === 135 ? r = "nwse-resize" : e === 45 ? r = "nesw-resize" : e === 90 && (r = "ew-resize"), "cursor:".concat(r, ";cursor: url('").concat(t, "') 16 16, ").concat(r, ";");
}
var agent = agent$1(), IS_WEBKIT = agent.browser.webkit, IS_WEBKIT605 = IS_WEBKIT && function() {
  var o = typeof window > "u" ? {
    userAgent: ""
  } : window.navigator, t = /applewebkit\/([^\s]+)/g.exec(o.userAgent.toLowerCase());
  return t ? parseFloat(t[1]) < 605 : !1;
}(), browserName = agent.browser.name, browserVersion = parseInt(agent.browser.version, 10), IS_CHROME = browserName === "chrome", IS_CHROMIUM = agent.browser.chromium, chromiumVersion = parseInt(agent.browser.chromiumVersion, 10) || 0, IS_CHROMIUM109 = IS_CHROME && browserVersion >= 109 || IS_CHROMIUM && chromiumVersion >= 109, IS_FIREFOX = browserName === "firefox", IS_SAFARI_ABOVE15 = parseInt(agent.browser.webkitVersion, 10) >= 612 || browserVersion >= 15, PREFIX = "moveable-", directionCSS = DIRECTIONS.map(function(o) {
  var t = "", e = "", r = "center", D = "center";
  return o.indexOf("n") > -1 && (t = "top: -20px;", D = "bottom"), o.indexOf("s") > -1 && (t = "top: 0px;", D = "top"), o.indexOf("w") > -1 && (e = "left: -20px;", r = "right"), o.indexOf("e") > -1 && (e = "left: 0px;", r = "left"), '.around-control[data-direction*="'.concat(o, `"] {
        `).concat(e).concat(t, `
        transform-origin: `).concat(r, " ").concat(D, `;
    }`);
}).join(`
`), MOVEABLE_CSS = `
{
position: absolute;
width: 1px;
height: 1px;
left: 0;
top: 0;
z-index: 3000;
--moveable-color: #4af;
--zoom: 1;
--zoompx: 1px;
will-change: transform;
outline: 1px solid transparent;
}
.control-box {
z-index: 0;
}
.line, .control {
position: absolute;
left: 0;
top: 0;
will-change: transform;
}
.control {
width: 14px;
height: 14px;
border-radius: 50%;
border: 2px solid #fff;
box-sizing: border-box;
background: #4af;
background: var(--moveable-color);
margin-top: -7px;
margin-left: -7px;
border: 2px solid #fff;
z-index: 10;
}
.around-control {
position: absolute;
will-change: transform;
width: calc(var(--moveable-control-padding, 20) * 1px);
height: calc(var(--moveable-control-padding, 20) * 1px);
left: -10px;
top: -10px;
box-sizing: border-box;
background: transparent;
z-index: 8;
cursor: alias;
transform-origin: center center;
}
`.concat(directionCSS, `
.padding {
position: absolute;
top: 0px;
left: 0px;
width: 100px;
height: 100px;
transform-origin: 0 0;
}
.line {
width: 1px;
height: 1px;
background: #4af;
background: var(--moveable-color);
transform-origin: 0px 50%;
}
.line.edge {
z-index: 1;
background: transparent;
}
.line.dashed {
box-sizing: border-box;
background: transparent;
}
.line.dashed.horizontal {
border-top: 1px dashed #4af;
border-top-color: #4af;
border-top-color: var(--moveable-color);
}
.line.dashed.vertical {
border-left: 1px dashed #4af;
border-left-color: #4af;
border-left-color: var(--moveable-color);
}
.line.vertical {
transform: translateX(-50%);
}
.line.horizontal {
transform: translateY(-50%);
}
.line.vertical.bold {
width: 2px;
}
.line.horizontal.bold {
height: 2px;
}

.control.origin {
border-color: #f55;
background: #fff;
width: 12px;
height: 12px;
margin-top: -6px;
margin-left: -6px;
pointer-events: none;
}
`).concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function(o) {
  return `
.direction[data-rotation="`.concat(o, '"], :global .view-control-rotation').concat(o, ` {
`).concat(getCursorCSS(o), `
}
`);
}).join(`
`), `

.line.direction:before {
content: "";
position: absolute;
width: 100%;
height: calc(var(--moveable-line-padding, 0) * 1px);
bottom: 0;
left: 0;
}
.group {
z-index: -1;
}
.area {
position: absolute;
}
.area-pieces {
position: absolute;
top: 0;
left: 0;
display: none;
}
.area.avoid, .area.pass {
pointer-events: none;
}
.area.avoid+.area-pieces {
display: block;
}
.area-piece {
position: absolute;
}

`).concat(IS_WEBKIT605 ? `:global svg *:before {
content:"";
transform-origin: inherit;
}` : "", `
`), NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]], FLOAT_POINT_NUM = 1e-4, TINY_NUM = 1e-7, MIN_SCALE = 1e-9, MAX_NUM = Math.pow(10, 10), MIN_NUM = -MAX_NUM, DIRECTION_REGION_TO_DIRECTION = {
  n: [0, -1],
  e: [1, 0],
  s: [0, 1],
  w: [-1, 0],
  nw: [-1, -1],
  ne: [1, -1],
  sw: [-1, 1],
  se: [1, 1]
}, DIRECTION_INDEXES = {
  n: [0, 1],
  e: [1, 3],
  s: [3, 2],
  w: [2, 0],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
}, DIRECTION_ROTATIONS = {
  n: 0,
  s: 180,
  w: 270,
  e: 90,
  nw: 315,
  ne: 45,
  sw: 225,
  se: 135
}, MOVEABLE_METHODS = ["isMoveableElement", "updateRect", "updateTarget", "destroy", "dragStart", "isInside", "hitTest", "setState", "getRect", "request", "isDragging", "getManager", "forceUpdate", "waitToChangeTarget", "updateSelectors", "getTargets", "stopDrag"];
function setCustomDrag(o, t, e, r, D, N) {
  var k, $;
  N === void 0 && (N = "draggable");
  var G = ($ = (k = t.gestos[N]) === null || k === void 0 ? void 0 : k.move(e, o.inputEvent)) !== null && $ !== void 0 ? $ : {}, U = G.originalDatas || G.datas, z = U[N] || (U[N] = {});
  return __assign$1(__assign$1({}, D ? convertDragDist(t, G) : G), {
    isPinch: !!r,
    parentEvent: !0,
    datas: z,
    originalDatas: o.originalDatas
  });
}
var CustomGesto = /* @__PURE__ */ function() {
  function o(e) {
    var r;
    e === void 0 && (e = "draggable"), this.ableName = e, this.prevX = 0, this.prevY = 0, this.startX = 0, this.startY = 0, this.isDrag = !1, this.isFlag = !1, this.datas = {
      draggable: {}
    }, this.datas = (r = {}, r[e] = {}, r);
  }
  var t = o.prototype;
  return t.dragStart = function(e, r) {
    this.isDrag = !1, this.isFlag = !1;
    var D = r.originalDatas;
    return this.datas = D, D[this.ableName] || (D[this.ableName] = {}), __assign$1(__assign$1({}, this.move(e, r.inputEvent)), {
      type: "dragstart"
    });
  }, t.drag = function(e, r) {
    return this.move([e[0] - this.prevX, e[1] - this.prevY], r);
  }, t.move = function(e, r) {
    var D, N, k = !1;
    if (!this.isFlag)
      this.prevX = e[0], this.prevY = e[1], this.startX = e[0], this.startY = e[1], D = e[0], N = e[1], this.isFlag = !0;
    else {
      var $ = this.isDrag;
      D = this.prevX + e[0], N = this.prevY + e[1], (e[0] || e[1]) && (this.isDrag = !0), !$ && this.isDrag && (k = !0);
    }
    return this.prevX = D, this.prevY = N, {
      type: "drag",
      clientX: D,
      clientY: N,
      inputEvent: r,
      isFirstDrag: k,
      isDrag: this.isDrag,
      distX: D - this.startX,
      distY: N - this.startY,
      deltaX: e[0],
      deltaY: e[1],
      datas: this.datas[this.ableName],
      originalDatas: this.datas,
      parentEvent: !0,
      parentGesto: this
    };
  }, o;
}();
function calculatePointerDist(o, t) {
  var e = t.clientX, r = t.clientY, D = t.datas, N = o.state, k = N.moveableClientRect, $ = N.rootMatrix, G = N.is3d, U = N.pos1, z = k.left, X = k.top, V = G ? 4 : 3, Y = minus(calculateInversePosition($, [e - z, r - X], V), U), W = Y[0], q = Y[1], K = getDragDist({
    datas: D,
    distX: W,
    distY: q
  }), Z = K[0], J = K[1];
  return [Z, J];
}
function setDragStart(o, t) {
  var e = t.datas, r = o.state, D = r.allMatrix, N = r.beforeMatrix, k = r.is3d, $ = r.left, G = r.top, U = r.origin, z = r.offsetMatrix, X = r.targetMatrix, V = r.transformOrigin, Y = k ? 4 : 3;
  e.is3d = k, e.matrix = D, e.targetMatrix = X, e.beforeMatrix = N, e.offsetMatrix = z, e.transformOrigin = V, e.inverseMatrix = invert(D, Y), e.inverseBeforeMatrix = invert(N, Y), e.absoluteOrigin = convertPositionMatrix(plus([$, G], U), Y), e.startDragBeforeDist = calculate(e.inverseBeforeMatrix, e.absoluteOrigin, Y), e.startDragDist = calculate(e.inverseMatrix, e.absoluteOrigin, Y);
}
function getTransformDirection(o) {
  return calculateMoveablePosition(o.datas.beforeTransform, [50, 50], 100, 100).direction;
}
function resolveTransformEvent(o, t) {
  var e = o.datas, r = o.originalDatas.beforeRenderable, D = e.transformIndex, N = r.nextTransforms, k = N.length, $ = r.nextTransformAppendedIndexes, G = -1;
  D === -1 ? (t === "translate" ? G = 0 : t === "rotate" && (G = findIndex(N, function(V) {
    return V.match(/scale\(/g);
  })), G === -1 && (G = N.length), e.transformIndex = G) : find$1($, function(V) {
    return V.index === D && V.functionName === t;
  }) ? G = D : G = D + $.filter(function(V) {
    return V.index < D;
  }).length;
  var U = convertTransformInfo(N, G), z = U.targetFunction, X = t === "rotate" ? "rotateZ" : t;
  e.beforeFunctionTexts = U.beforeFunctionTexts, e.afterFunctionTexts = U.afterFunctionTexts, e.beforeTransform = U.beforeFunctionMatrix, e.beforeTransform2 = U.beforeFunctionMatrix2, e.targetTansform = U.targetFunctionMatrix, e.afterTransform = U.afterFunctionMatrix, e.afterTransform2 = U.afterFunctionMatrix2, e.targetAllTransform = U.allFunctionMatrix, z.functionName === X ? (e.afterFunctionTexts.splice(0, 1), e.isAppendTransform = !1) : k > G && (e.isAppendTransform = !0, r.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], $, !0), [{
    functionName: t,
    index: G,
    isAppend: !0
  }], !1));
}
function convertTransformFormat(o, t, e) {
  return "".concat(o.beforeFunctionTexts.join(" "), " ").concat(o.isAppendTransform ? e : t, " ").concat(o.afterFunctionTexts.join(" "));
}
function getTransformDist(o) {
  var t = o.datas, e = o.distX, r = o.distY, D = getBeforeDragDist({
    datas: t,
    distX: e,
    distY: r
  }), N = D[0], k = D[1], $ = getTransfromMatrix(t, fromTranslation([N, k], 4));
  return calculate($, convertPositionMatrix([0, 0, 0], 4), 4);
}
function getTransfromMatrix(o, t, e) {
  var r = o.beforeTransform, D = o.afterTransform, N = o.beforeTransform2, k = o.afterTransform2, $ = o.targetAllTransform, G = e ? multiply($, t, 4) : multiply(t, $, 4), U = multiply(invert(e ? N : r, 4), G, 4), z = multiply(U, invert(e ? k : D, 4), 4);
  return z;
}
function getBeforeDragDist(o) {
  var t = o.datas, e = o.distX, r = o.distY, D = t.inverseBeforeMatrix, N = t.is3d, k = t.startDragBeforeDist, $ = t.absoluteOrigin, G = N ? 4 : 3;
  return minus(calculate(D, plus($, [e, r]), G), k);
}
function getDragDist(o, t) {
  var e = o.datas, r = o.distX, D = o.distY, N = e.inverseBeforeMatrix, k = e.inverseMatrix, $ = e.is3d, G = e.startDragBeforeDist, U = e.startDragDist, z = e.absoluteOrigin, X = $ ? 4 : 3;
  return minus(calculate(t ? N : k, plus(z, [r, D]), X), t ? G : U);
}
function getInverseDragDist(o, t) {
  var e = o.datas, r = o.distX, D = o.distY, N = e.beforeMatrix, k = e.matrix, $ = e.is3d, G = e.startDragBeforeDist, U = e.startDragDist, z = e.absoluteOrigin, X = $ ? 4 : 3;
  return minus(calculate(t ? N : k, plus(t ? G : U, [r, D]), X), z);
}
function calculateTransformOrigin(o, t, e, r, D, N) {
  return r === void 0 && (r = t), D === void 0 && (D = e), N === void 0 && (N = [0, 0]), o ? o.map(function(k, $) {
    var G = splitUnit(k), U = G.value, z = G.unit, X = $ ? D : r, V = $ ? e : t;
    if (k === "%" || isNaN(U)) {
      var Y = X ? N[$] / X : 0;
      return V * Y;
    } else if (z !== "%")
      return U;
    return V * U / 100;
  }) : N;
}
function getPosIndexesByDirection(o) {
  var t = [];
  return o[1] >= 0 && (o[0] >= 0 && t.push(3), o[0] <= 0 && t.push(2)), o[1] <= 0 && (o[0] >= 0 && t.push(1), o[0] <= 0 && t.push(0)), t;
}
function getPosesByDirection(o, t) {
  return getPosIndexesByDirection(t).map(function(e) {
    return o[e];
  });
}
function getPosByDirection(o, t) {
  var e = (t[0] + 1) / 2, r = (t[1] + 1) / 2, D = [dot(o[0][0], o[1][0], e, 1 - e), dot(o[0][1], o[1][1], e, 1 - e)], N = [dot(o[2][0], o[3][0], e, 1 - e), dot(o[2][1], o[3][1], e, 1 - e)];
  return [dot(D[0], N[0], r, 1 - r), dot(D[1], N[1], r, 1 - r)];
}
function getDist(o, t, e, r, D, N) {
  var k = calculatePoses(t, e, r, D), $ = getPosByDirection(k, N), G = o[0] - $[0], U = o[1] - $[1];
  return [G, U];
}
function getNextMatrix(o, t, e, r) {
  return multiply(o, getAbsoluteMatrix(t, r, e), r);
}
function getNextTransformMatrix(o, t, e) {
  var r = o.transformOrigin, D = o.offsetMatrix, N = o.is3d, k = N ? 4 : 3, $;
  if (isString(e)) {
    var G = t.beforeTransform, U = t.afterTransform;
    $ = convertDimension(multiply(multiply(G, parseMat([e]), 4), U, 4), 4, k);
  } else
    $ = e;
  return getNextMatrix(D, $, r, k);
}
function scaleMatrix(o, t) {
  var e = o.transformOrigin, r = o.offsetMatrix, D = o.is3d, N = o.targetMatrix, k = o.targetAllTransform, $ = D ? 4 : 3;
  return getNextMatrix(r, multiply(k || N, createScaleMatrix(t, $), $), e, $);
}
function fillTransformStartEvent(o) {
  var t = getBeforeRenderableDatas(o);
  return {
    setTransform: function(e, r) {
      r === void 0 && (r = -1), t.startTransforms = isArray(e) ? e : splitSpace(e), setTransformIndex(o, r);
    },
    setTransformIndex: function(e) {
      setTransformIndex(o, e);
    }
  };
}
function setDefaultTransformIndex(o, t) {
  var e = getBeforeRenderableDatas(o), r = e.startTransforms;
  setTransformIndex(o, findIndex(r, function(D) {
    return D.indexOf("".concat(t, "(")) === 0;
  }));
}
function setTransformIndex(o, t) {
  var e = getBeforeRenderableDatas(o), r = o.datas;
  if (r.transformIndex = t, t !== -1) {
    var D = e.startTransforms[t];
    if (D) {
      var N = parse$1([D]);
      r.startValue = N[0].functionValue;
    }
  }
}
function fillOriginalTransform(o, t) {
  var e = getBeforeRenderableDatas(o);
  e.nextTransforms = splitSpace(t);
}
function getBeforeRenderableDatas(o) {
  return o.originalDatas.beforeRenderable;
}
function getNextTransforms(o) {
  var t = o.originalDatas.beforeRenderable;
  return t.nextTransforms;
}
function getNextTransformText(o) {
  return getNextTransforms(o).join(" ");
}
function getNextStyle(o) {
  return getBeforeRenderableDatas(o).nextStyle;
}
function fillTransformEvent(o, t, e, r, D) {
  fillOriginalTransform(D, t);
  var N = Draggable.drag(o, setCustomDrag(D, o.state, e, r, !1)), k = N ? N.transform : t;
  return __assign$1(__assign$1({
    transform: t,
    drag: N
  }, fillCSSObject({
    transform: k
  }, D)), {
    afterTransform: k
  });
}
function getTranslateFixedPosition(o, t, e, r) {
  var D = getNextTransformMatrix(o.state, r, t), N = getDirectionOffset(o, e, D);
  return N;
}
function getTranslateDist(o, t, e, r, D) {
  var N = getTranslateFixedPosition(o, t, e, D), k = o.state, $ = k.left, G = k.top, U = o.props.groupable, z = U ? $ : 0, X = U ? G : 0, V = minus(r, N);
  return minus(V, [z, X]);
}
function getScaleDist(o, t, e, r, D) {
  var N = getTranslateDist(o, "scale(".concat(t.join(", "), ")"), e, r, D);
  return N;
}
function getDirectionByPos(o, t, e) {
  return [-1 + o[0] / (t / 2), -1 + o[1] / (e / 2)];
}
function getDirectionOffset(o, t, e) {
  e === void 0 && (e = o.state.allMatrix);
  var r = o.state, D = r.width, N = r.height, k = r.is3d, $ = k ? 4 : 3, G = [D / 2 * (1 + t[0]), N / 2 * (1 + t[1])];
  return calculatePosition(e, G, $);
}
function getRotateDist(o, t, e) {
  var r = e.fixedDirection, D = e.fixedPosition;
  return getTranslateDist(o, "rotate(".concat(t, "deg)"), r, D, e);
}
function getResizeDist(o, t, e, r, D, N) {
  var k = o.props.groupable, $ = o.state, G = $.transformOrigin, U = $.offsetMatrix, z = $.is3d, X = $.width, V = $.height, Y = $.left, W = $.top, q = N.fixedDirection, K = N.nextTargetMatrix || $.targetMatrix, Z = z ? 4 : 3, J = calculateTransformOrigin(D, t, e, X, V, G), Q = k ? Y : 0, et = k ? W : 0, it = getNextMatrix(U, K, J, Z), tt = getDist(r, it, t, e, Z, q);
  return minus(tt, [Q, et]);
}
function getAbsolutePosition(o, t) {
  return getPosByDirection(getAbsolutePosesByState(o.state), t);
}
function getGestoData(o, t) {
  var e = o.targetGesto, r = o.controlGesto, D;
  return e != null && e.isFlag() && (D = e.getEventData()[t]), !D && (r != null && r.isFlag()) && (D = r.getEventData()[t]), D || {};
}
function getShadowRoot(o) {
  if (o && o.getRootNode) {
    var t = o.getRootNode();
    if (t.nodeType === 11)
      return t;
  }
}
function getMatrixStackInfo(o, t, e) {
  for (var r = o, D = [], N = document.documentElement || document.body, k = !e && o === t || o === N, $ = k, G = !1, U = 3, z, X, V, Y = !1, W = getOffsetInfo(t, t, !0).offsetParent, q = 1; r && !$; ) {
    $ = k;
    var K = getCachedStyle(r), Z = K("position"), J = K("scale"), Q = getElementTransform(r), et = Z === "fixed", it = convertCSStoMatrix(getTransformMatrix(Q)), tt = void 0, nt = !1, st = !1, at = 0, ut = 0, ht = 0, dt = 0, pt = {
      hasTransform: !1,
      fixedContainer: null
    };
    et && (Y = !0, pt = getPositionFixedInfo(r), W = pt.fixedContainer);
    var _t = it.length;
    !G && _t === 16 && (G = !0, U = 4, convert3DMatrixes(D), V && (V = convertDimension(V, 3, 4))), G && _t === 9 && (it = convertDimension(it, 3, 4));
    var mt = getOffsetPosInfo(r, o), yt = mt.tagName, Tt = mt.hasOffset, Pt = mt.isSVG, St = mt.origin, gt = mt.targetOrigin, bt = mt.offset, At = bt[0], Rt = bt[1];
    yt === "svg" && V && (D.push({
      type: "target",
      target: r,
      matrix: getSVGMatrix(r, U)
    }), D.push({
      type: "offset",
      target: r,
      matrix: createIdentityMatrix(U)
    }));
    var Nt = parseFloat(K("zoom")) || 1;
    if (et)
      tt = pt.fixedContainer, nt = !0;
    else {
      var Mt = getOffsetInfo(r, t, !1, !0, K), ft = Mt.offsetZoom;
      if (tt = Mt.offsetParent, nt = Mt.isEnd, st = Mt.isStatic, q *= ft, (Mt.isCustomElement || ft !== 1) && st)
        At -= tt.offsetLeft, Rt -= tt.offsetTop;
      else if (IS_FIREFOX || IS_CHROMIUM109) {
        var Ft = Mt.parentSlotElement;
        if (Ft) {
          for (var Dt = tt, Vt = 0, Bt = 0; Dt && getShadowRoot(Dt); )
            Vt += Dt.offsetLeft, Bt += Dt.offsetTop, Dt = Dt.offsetParent;
          At -= Vt, Rt -= Bt;
        }
      }
    }
    if (IS_WEBKIT && !IS_SAFARI_ABOVE15 && Tt && !Pt && st && (Z === "relative" || Z === "static") && (At -= tt.offsetLeft, Rt -= tt.offsetTop, k = k || nt), et)
      Tt && pt.hasTransform && (ht = tt.clientLeft, dt = tt.clientTop);
    else if (Tt && W !== tt && (at = tt.clientLeft, ut = tt.clientTop), Tt && tt === N) {
      var Et = getBodyOffset(r, !1);
      At += Et[0], Rt += Et[1];
    }
    if (D.push({
      type: "target",
      target: r,
      matrix: getAbsoluteMatrix(it, U, St)
    }), J && J !== "1" && J !== "none") {
      var Ht = J.split(" ").map(function(Kt) {
        return parseFloat(Kt);
      }), kt = Ht[0], wt = Ht[1], Lt = wt === void 0 ? kt : wt, jt = createScaleMatrix([kt, Lt], U);
      D.push({
        type: "offset",
        target: r,
        matrix: createIdentityMatrix(U)
      }), D.push({
        type: "target",
        target: r,
        matrix: getAbsoluteMatrix(jt, U, St)
      });
    }
    if (Tt) {
      var Ct = r === o, Wt = Ct ? 0 : r.scrollLeft, Jt = Ct ? 0 : r.scrollTop;
      D.push({
        type: "offset",
        target: r,
        matrix: createOriginMatrix([At - Wt + at - ht, Rt - Jt + ut - dt], U)
      });
    } else
      D.push({
        type: "offset",
        target: r,
        origin: St
      });
    if (Nt !== 1 && D.push({
      type: "zoom",
      target: r,
      matrix: getAbsoluteMatrix(createScaleMatrix([Nt, Nt], U), U, [0, 0])
    }), V || (V = it), z || (z = St), X || (X = gt), $ || et)
      break;
    r = tt, k = nt, (!e || r === N) && ($ = k);
  }
  return V || (V = createIdentityMatrix(U)), z || (z = [0, 0]), X || (X = [0, 0]), {
    zoom: q,
    offsetContainer: W,
    matrixes: D,
    targetMatrix: V,
    transformOrigin: z,
    targetOrigin: X,
    is3d: G,
    hasFixed: Y
  };
}
var cacheStyleMap = null, clientRectStyleMap = null, matrixContainerInfos = null;
function setStoreCache(o) {
  o ? (window.Map && (cacheStyleMap = /* @__PURE__ */ new Map(), clientRectStyleMap = /* @__PURE__ */ new Map()), matrixContainerInfos = []) : (cacheStyleMap = null, matrixContainerInfos = null, clientRectStyleMap = null);
}
function getCachedClientRect(o) {
  var t = clientRectStyleMap == null ? void 0 : clientRectStyleMap.get(o);
  if (t)
    return t;
  var e = getClientRect(o, !0);
  return clientRectStyleMap && clientRectStyleMap.set(o, e), e;
}
function getCachedMatrixContainerInfo(o, t) {
  if (matrixContainerInfos) {
    var e = find$1(matrixContainerInfos, function(D) {
      return D[0][0] == o && D[0][1] == t;
    });
    if (e)
      return e[1];
  }
  var r = getMatrixStackInfo(o, t, !0);
  return matrixContainerInfos && matrixContainerInfos.push([[o, t], r]), r;
}
function getCachedStyle(o) {
  var t = cacheStyleMap == null ? void 0 : cacheStyleMap.get(o);
  if (!t) {
    var e = window.getComputedStyle(o);
    if (!cacheStyleMap)
      return function(N) {
        return e[N];
      };
    t = {
      style: e,
      cached: {}
    }, cacheStyleMap.set(o, t);
  }
  var r = t.cached, D = t.style;
  return function(N) {
    return N in r || (r[N] = D[N]), r[N];
  };
}
function multiply2(o, t) {
  return [o[0] * t[0], o[1] * t[1]];
}
function prefix() {
  for (var o = [], t = 0; t < arguments.length; t++)
    o[t] = arguments[t];
  return prefixNames.apply(void 0, __spreadArray([PREFIX], o, !1));
}
function defaultSync(o) {
  o();
}
function getTransformMatrix(o) {
  return !o || o === "none" ? [1, 0, 0, 1, 0, 0] : isObject$2(o) ? o : parseMat(o);
}
function getAbsoluteMatrix(o, t, e) {
  return multiplies(t, createOriginMatrix(e, t), o, createOriginMatrix(e.map(function(r) {
    return -r;
  }), t));
}
function measureSVGSize(o, t, e) {
  if (t === "%") {
    var r = getSVGViewBox(o.ownerSVGElement);
    return r[e ? "width" : "height"] / 100;
  }
  return 1;
}
function getBeforeTransformOrigin(o) {
  var t = getTransformOrigin(getComputedStyle$2(o, ":before"));
  return t.map(function(e, r) {
    var D = splitUnit(e), N = D.value, k = D.unit;
    return N * measureSVGSize(o, k, r === 0);
  });
}
function getTransformOriginArray(o) {
  return o ? o.split(" ") : ["0", "0"];
}
function getTransformOrigin(o) {
  return getTransformOriginArray(o.transformOrigin);
}
function getElementTransform(o) {
  var t = getCachedStyle(o), e = t("transform");
  if (e && e !== "none")
    return e;
  if ("transform" in o) {
    var r = o.transform, D = r.baseVal;
    if (!D)
      return "";
    var N = D.length;
    if (!N)
      return "";
    for (var k = [], $ = function(U) {
      var z = D[U].matrix;
      k.push("matrix(".concat(["a", "b", "c", "d", "e", "f"].map(function(X) {
        return z[X];
      }).join(", "), ")"));
    }, G = 0; G < N; ++G)
      $(G);
    return k.join(" ");
  }
  return "";
}
function getOffsetInfo(o, t, e, r, D) {
  var N, k, $ = o && o.ownerDocument ? o.ownerDocument : document, G = $.documentElement || $.body, U = !1, z, X;
  if (!o || e)
    z = o;
  else {
    var V = (N = o == null ? void 0 : o.assignedSlot) === null || N === void 0 ? void 0 : N.parentElement, Y = o.parentElement;
    V ? (U = !0, X = Y, z = V) : z = Y;
  }
  for (var W = !1, q = o === t || z === t, K = "relative", Z = 1, J = parseFloat(D == null ? void 0 : D("zoom")) || 1, Q = D == null ? void 0 : D("position"); z && z !== G; ) {
    t === z && (q = !0);
    var et = getCachedStyle(z), it = z.tagName.toLowerCase(), tt = getElementTransform(z), nt = et("willChange"), st = parseFloat(et("zoom")) || 1;
    if (K = et("position"), r && st !== 1) {
      Z = st;
      break;
    }
    if (
      // offsetParent is the parentElement if the target's zoom is not 1 and not absolute.
      !e && r && J !== 1 && Q && Q !== "absolute" || it === "svg" || K !== "static" || tt && tt !== "none" || nt === "transform"
    )
      break;
    var at = (k = o == null ? void 0 : o.assignedSlot) === null || k === void 0 ? void 0 : k.parentNode, ut = z.parentNode;
    at && (U = !0, X = ut);
    var ht = ut;
    if (ht && ht.nodeType === 11) {
      z = ht.host, W = !0, K = getCachedStyle(z)("position");
      break;
    }
    z = ht, K = "relative";
  }
  return {
    offsetZoom: Z,
    hasSlot: U,
    parentSlotElement: X,
    isCustomElement: W,
    isStatic: K === "static",
    isEnd: q || !z || z === G,
    offsetParent: z || G
  };
}
function getOffsetPosInfo(o, t) {
  var e, r = o.tagName.toLowerCase(), D = o.offsetLeft, N = o.offsetTop, k = getCachedStyle(o), $ = isUndefined(D), G = !$, U, z;
  return !G && r !== "svg" ? (U = IS_WEBKIT605 ? getBeforeTransformOrigin(o) : getTransformOriginArray(k("transformOrigin")).map(function(X) {
    return parseFloat(X);
  }), z = U.slice(), G = !0, e = getSVGGraphicsOffset(o, U, o === t && t.tagName.toLowerCase() === "g"), D = e[0], N = e[1], U[0] = e[2], U[1] = e[3]) : (U = getTransformOriginArray(k("transformOrigin")).map(function(X) {
    return parseFloat(X);
  }), z = U.slice()), {
    tagName: r,
    isSVG: $,
    hasOffset: G,
    offset: [D || 0, N || 0],
    origin: U,
    targetOrigin: z
  };
}
function getBodyOffset(o, t) {
  var e = getCachedStyle(o), r = getCachedStyle(document.body), D = r("position");
  if (!t && (!D || D === "static"))
    return [0, 0];
  var N = parseInt(r("marginLeft"), 10), k = parseInt(r("marginTop"), 10);
  return e("position") === "absolute" && ((e("top") !== "auto" || e("bottom") !== "auto") && (k = 0), (e("left") !== "auto" || e("right") !== "auto") && (N = 0)), [N, k];
}
function convert3DMatrixes(o) {
  o.forEach(function(t) {
    var e = t.matrix;
    e && (t.matrix = convertDimension(e, 3, 4));
  });
}
function getPositionFixedInfo(o) {
  for (var t = o.parentElement, e = !1; t; ) {
    var r = getComputedStyle$2(t).transform;
    if (r && r !== "none") {
      e = !0;
      break;
    }
    if (t === document.body)
      break;
    t = t.parentElement;
  }
  return {
    fixedContainer: t || document.body,
    hasTransform: e
  };
}
function makeMatrixCSS(o, t) {
  return t === void 0 && (t = o.length > 9), "".concat(t ? "matrix3d" : "matrix", "(").concat(convertMatrixtoCSS(o, !t).join(","), ")");
}
function getSVGViewBox(o) {
  var t = o.clientWidth, e = o.clientHeight;
  if (!o)
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      clientWidth: t,
      clientHeight: e
    };
  var r = o.viewBox, D = r && r.baseVal || {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  return {
    x: D.x,
    y: D.y,
    width: D.width || t,
    height: D.height || e,
    clientWidth: t,
    clientHeight: e
  };
}
function getSVGMatrix(o, t) {
  var e = getSVGViewBox(o), r = e.width, D = e.height, N = e.clientWidth, k = e.clientHeight, $ = N / r, G = k / D, U = o.preserveAspectRatio.baseVal, z = U.align, X = U.meetOrSlice, V = [0, 0], Y = [$, G], W = [0, 0];
  if (z !== 1) {
    var q = (z - 2) % 3, K = Math.floor((z - 2) / 3);
    V[0] = r * q / 2, V[1] = D * K / 2;
    var Z = X === 2 ? Math.max(G, $) : Math.min($, G);
    Y[0] = Z, Y[1] = Z, W[0] = (N - r) / 2 * q, W[1] = (k - D) / 2 * K;
  }
  var J = createScaleMatrix(Y, t);
  return J[t * (t - 1)] = W[0], J[t * (t - 1) + 1] = W[1], getAbsoluteMatrix(J, t, V);
}
function getSVGGraphicsOffset(o, t, e) {
  if (!o.getBBox || !e && o.tagName.toLowerCase() === "g")
    return [0, 0, 0, 0];
  var r = o.getBBox(), D = getSVGViewBox(o.ownerSVGElement), N = r.x - D.x, k = r.y - D.y;
  return [N, k, t[0] - N, t[1] - k];
}
function calculatePosition(o, t, e) {
  return calculate(o, convertPositionMatrix(t, e), e);
}
function calculatePoses(o, t, e, r) {
  return [[0, 0], [t, 0], [0, e], [t, e]].map(function(D) {
    return calculatePosition(o, D, r);
  });
}
function getRect(o) {
  var t = o.map(function(U) {
    return U[0];
  }), e = o.map(function(U) {
    return U[1];
  }), r = Math.min.apply(Math, t), D = Math.min.apply(Math, e), N = Math.max.apply(Math, t), k = Math.max.apply(Math, e), $ = N - r, G = k - D;
  return {
    left: r,
    top: D,
    right: N,
    bottom: k,
    width: $,
    height: G
  };
}
function calculateRect(o, t, e, r) {
  var D = calculatePoses(o, t, e, r);
  return getRect(D);
}
function getSVGOffset(o, t, e, r, D) {
  var N, k = o.target, $ = o.origin, G = t.matrix, U = getSize(k), z = U.offsetWidth, X = U.offsetHeight, V = e.getBoundingClientRect(), Y = [0, 0];
  e === document.body && (Y = getBodyOffset(k, !0));
  for (var W = k.getBoundingClientRect(), q = W.left - V.left + e.scrollLeft - (e.clientLeft || 0) + Y[0], K = W.top - V.top + e.scrollTop - (e.clientTop || 0) + Y[1], Z = W.width, J = W.height, Q = multiplies(r, D, G), et = calculateRect(Q, z, X, r), it = et.left, tt = et.top, nt = et.width, st = et.height, at = calculatePosition(Q, $, r), ut = minus(at, [it, tt]), ht = [q + ut[0] * Z / nt, K + ut[1] * J / st], dt = [0, 0], pt = 0; ++pt < 10; ) {
    var _t = invert(D, r);
    N = minus(calculatePosition(_t, ht, r), calculatePosition(_t, at, r)), dt[0] = N[0], dt[1] = N[1];
    var mt = multiplies(r, D, createOriginMatrix(dt, r), G), yt = calculateRect(mt, z, X, r), Tt = yt.left, Pt = yt.top, St = Tt - q, gt = Pt - K;
    if (Math.abs(St) < 2 && Math.abs(gt) < 2)
      break;
    ht[0] -= St, ht[1] -= gt;
  }
  return dt.map(function(bt) {
    return Math.round(bt);
  });
}
function calculateMoveableClientPositions(o, t, e) {
  var r = o.length === 16, D = r ? 4 : 3, N = t.map(function(G) {
    return calculatePosition(o, G, D);
  }), k = e.left, $ = e.top;
  return N.map(function(G) {
    return [G[0] + k, G[1] + $];
  });
}
function calculateMoveablePosition(o, t, e, r) {
  var D = o.length === 16, N = D ? 4 : 3, k = calculatePoses(o, e, r, N), $ = k[0], G = $[0], U = $[1], z = k[1], X = z[0], V = z[1], Y = k[2], W = Y[0], q = Y[1], K = k[3], Z = K[0], J = K[1], Q = calculatePosition(o, t, N), et = Q[0], it = Q[1], tt = Math.min(G, X, W, Z), nt = Math.min(U, V, q, J), st = Math.max(G, X, W, Z), at = Math.max(U, V, q, J);
  G = G - tt || 0, X = X - tt || 0, W = W - tt || 0, Z = Z - tt || 0, U = U - nt || 0, V = V - nt || 0, q = q - nt || 0, J = J - nt || 0, et = et - tt || 0, it = it - nt || 0;
  var ut = getShapeDirection(calculatePoses(o, 100, 100, N));
  return {
    left: tt,
    top: nt,
    right: st,
    bottom: at,
    origin: [et, it],
    pos1: [G, U],
    pos2: [X, V],
    pos3: [W, q],
    pos4: [Z, J],
    direction: ut
  };
}
function getDistSize(o) {
  return Math.sqrt(o[0] * o[0] + o[1] * o[1]);
}
function getDiagonalSize(o, t) {
  return getDistSize([t[0] - o[0], t[1] - o[1]]);
}
function getLineStyle(o, t, e, r) {
  e === void 0 && (e = 1), r === void 0 && (r = getRad$1(o, t));
  var D = getDiagonalSize(o, t);
  return {
    transform: "translateY(-50%) translate(".concat(o[0], "px, ").concat(o[1], "px) rotate(").concat(r, "rad) scaleY(").concat(e, ")"),
    width: "".concat(D, "px")
  };
}
function getControlTransform(o, t) {
  for (var e = [], r = 2; r < arguments.length; r++)
    e[r - 2] = arguments[r];
  var D = e.length, N = e.reduce(function($, G) {
    return $ + G[0];
  }, 0) / D, k = e.reduce(function($, G) {
    return $ + G[1];
  }, 0) / D;
  return {
    transform: "translateZ(0px) translate(".concat(N, "px, ").concat(k, "px) rotate(").concat(o, "rad) scale(").concat(t, ")")
  };
}
function getProps(o, t) {
  var e = o[t];
  return isObject$2(e) ? __assign$1(__assign$1({}, o), e) : o;
}
function getSize(o) {
  var t = o && !isUndefined(o.offsetWidth), e = 0, r = 0, D = 0, N = 0, k = 0, $ = 0, G = 0, U = 0, z = 0, X = 0, V = 0, Y = 0, W = 1 / 0, q = 1 / 0, K = 1 / 0, Z = 1 / 0, J = 0, Q = 0, et = !1;
  if (o)
    if (!t && o.tagName.toLowerCase() !== "svg") {
      var it = o.getBBox();
      et = !0, e = it.width, r = it.height, k = e, $ = r, G = e, U = r, D = e, N = r;
    } else {
      var tt = getCachedStyle(o), nt = o.style, st = tt("boxSizing") === "border-box", at = parseFloat(tt("borderLeftWidth")) || 0, ut = parseFloat(tt("borderRightWidth")) || 0, ht = parseFloat(tt("borderTopWidth")) || 0, dt = parseFloat(tt("borderBottomWidth")) || 0, pt = parseFloat(tt("paddingLeft")) || 0, _t = parseFloat(tt("paddingRight")) || 0, mt = parseFloat(tt("paddingTop")) || 0, yt = parseFloat(tt("paddingBottom")) || 0, Tt = pt + _t, Pt = mt + yt, St = at + ut, gt = ht + dt, bt = Tt + St, At = Pt + gt, Rt = tt("position"), Nt = 0, Mt = 0;
      if ("clientLeft" in o) {
        var ft = null;
        if (Rt === "absolute") {
          var Ft = getOffsetInfo(o, document.body);
          ft = Ft.offsetParent;
        } else
          ft = o.parentElement;
        if (ft) {
          var Dt = getCachedStyle(ft);
          Nt = parseFloat(Dt("width")), Mt = parseFloat(Dt("height"));
        }
      }
      z = Math.max(Tt, convertUnitSize(tt("minWidth"), Nt) || 0), X = Math.max(Pt, convertUnitSize(tt("minHeight"), Mt) || 0), W = convertUnitSize(tt("maxWidth"), Nt), q = convertUnitSize(tt("maxHeight"), Mt), isNaN(W) && (W = 1 / 0), isNaN(q) && (q = 1 / 0), J = convertUnitSize(nt.width, 0) || 0, Q = convertUnitSize(nt.height, 0) || 0, k = parseFloat(tt("width")) || 0, $ = parseFloat(tt("height")) || 0, G = Math.abs(k - J) < 1 ? between(z, J || k, W) : k, U = Math.abs($ - Q) < 1 ? between(X, Q || $, q) : $, e = G, r = U, D = G, N = U, st ? (K = W, Z = q, V = z, Y = X, G = e - bt, U = r - At) : (K = W + bt, Z = q + At, V = z + bt, Y = X + At, e = G + bt, r = U + At), D = G + Tt, N = U + Pt;
    }
  return {
    svg: et,
    offsetWidth: e,
    offsetHeight: r,
    clientWidth: D,
    clientHeight: N,
    contentWidth: G,
    contentHeight: U,
    inlineCSSWidth: J,
    inlineCSSHeight: Q,
    cssWidth: k,
    cssHeight: $,
    minWidth: z,
    minHeight: X,
    maxWidth: W,
    maxHeight: q,
    minOffsetWidth: V,
    minOffsetHeight: Y,
    maxOffsetWidth: K,
    maxOffsetHeight: Z
  };
}
function getRotationRad(o, t) {
  return getRad$1(t > 0 ? o[0] : o[1], t > 0 ? o[1] : o[0]);
}
function resetClientRect() {
  return {
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    right: 0,
    bottom: 0,
    clientLeft: 0,
    clientTop: 0,
    clientWidth: 0,
    clientHeight: 0,
    scrollWidth: 0,
    scrollHeight: 0
  };
}
function getExtendsRect(o, t) {
  var e = o === document.body || o === document.documentElement, r = {
    clientLeft: o.clientLeft,
    clientTop: o.clientTop,
    clientWidth: o.clientWidth,
    clientHeight: o.clientHeight,
    scrollWidth: o.scrollWidth,
    scrollHeight: o.scrollHeight,
    overflow: !1
  };
  return e && (r.clientHeight = Math.max(t.height, r.clientHeight), r.scrollHeight = Math.max(t.height, r.scrollHeight)), r.overflow = getCachedStyle(o)("overflow") !== "visible", __assign$1(__assign$1({}, t), r);
}
function getClientRectByPosition(o, t, e, r) {
  var D = o.left, N = o.right, k = o.top, $ = o.bottom, G = t.top, U = t.left, z = {
    left: U + D,
    top: G + k,
    right: U + N,
    bottom: G + $,
    width: N - D,
    height: $ - k
  };
  return e && r ? getExtendsRect(e, z) : z;
}
function getClientRect(o, t) {
  var e = 0, r = 0, D = 0, N = 0;
  if (o) {
    var k = o.getBoundingClientRect();
    e = k.left, r = k.top, D = k.width, N = k.height;
  }
  var $ = {
    left: e,
    top: r,
    width: D,
    height: N,
    right: e + D,
    bottom: r + N
  };
  return o && t ? getExtendsRect(o, $) : $;
}
function getTotalDirection(o, t, e, r) {
  var D;
  if (o)
    D = o;
  else if (t)
    D = [0, 0];
  else {
    var N = e.target;
    D = getDirection(N, r);
  }
  return D;
}
function getDirection(o, t) {
  if (o) {
    var e = o.getAttribute("data-rotation") || "", r = o.getAttribute("data-direction");
    if (t.deg = e, !!r) {
      var D = [0, 0];
      return r.indexOf("w") > -1 && (D[0] = -1), r.indexOf("e") > -1 && (D[0] = 1), r.indexOf("n") > -1 && (D[1] = -1), r.indexOf("s") > -1 && (D[1] = 1), D;
    }
  }
}
function getAbsolutePoses(o, t) {
  return [plus(t, o[0]), plus(t, o[1]), plus(t, o[2]), plus(t, o[3])];
}
function getAbsolutePosesByState(o) {
  var t = o.left, e = o.top, r = o.pos1, D = o.pos2, N = o.pos3, k = o.pos4;
  return getAbsolutePoses([r, D, N, k], [t, e]);
}
function unset(o, t) {
  var e;
  (e = o[t]) === null || e === void 0 || e.unset(), o[t] = null;
}
function fillCSSObject(o, t) {
  if (t) {
    var e = getBeforeRenderableDatas(t);
    e.nextStyle = __assign$1(__assign$1({}, e.nextStyle), o);
  }
  return {
    style: o,
    cssText: getKeys(o).map(function(r) {
      return "".concat(decamelize(r, "-"), ": ").concat(o[r], ";");
    }).join("")
  };
}
function fillAfterTransform(o, t, e) {
  var r = t.afterTransform || t.transform;
  return __assign$1(__assign$1({}, fillCSSObject(__assign$1(__assign$1(__assign$1({}, o.style), t.style), {
    transform: r
  }), e)), {
    afterTransform: r,
    transform: o.transform
  });
}
function fillParams(o, t, e, r) {
  var D = t.datas;
  D.datas || (D.datas = {});
  var N = __assign$1(__assign$1({}, e), {
    target: o.state.target,
    clientX: t.clientX,
    clientY: t.clientY,
    inputEvent: t.inputEvent,
    currentTarget: o,
    moveable: o,
    datas: D.datas,
    isFirstDrag: !!t.isFirstDrag,
    isTrusted: t.isTrusted !== !1,
    stopAble: function() {
      D.isEventStart = !1;
    },
    stopDrag: function() {
      var k;
      (k = t.stop) === null || k === void 0 || k.call(t);
    }
  });
  return D.isStartEvent ? r || (D.lastEvent = N) : D.isStartEvent = !0, N;
}
function fillEndParams(o, t, e) {
  var r = t.datas, D = "isDrag" in e ? e.isDrag : t.isDrag;
  return r.datas || (r.datas = {}), __assign$1(__assign$1({
    isDrag: D
  }, e), {
    moveable: o,
    target: o.state.target,
    clientX: t.clientX,
    clientY: t.clientY,
    inputEvent: t.inputEvent,
    currentTarget: o,
    lastEvent: r.lastEvent,
    isDouble: t.isDouble,
    datas: r.datas,
    isFirstDrag: !!t.isFirstDrag
  });
}
function catchEvent(o, t, e) {
  o._emitter.on(t, e);
}
function triggerEvent(o, t, e, r) {
  return o.triggerEvent(t, e, r);
}
function getComputedStyle$2(o, t) {
  return window.getComputedStyle(o, t);
}
function filterAbles(o, t, e) {
  var r = {}, D = {};
  return o.filter(function(N) {
    var k = N.name;
    if (r[k] || !t.some(function($) {
      return N[$];
    }))
      return !1;
    if (!e && N.ableGroup) {
      if (D[N.ableGroup])
        return !1;
      D[N.ableGroup] = !0;
    }
    return r[k] = !0, !0;
  });
}
function equals(o, t) {
  return o === t || o == null && t == null;
}
function selectValue() {
  for (var o = [], t = 0; t < arguments.length; t++)
    o[t] = arguments[t];
  for (var e = o.length - 1, r = 0; r < e; ++r) {
    var D = o[r];
    if (!isUndefined(D))
      return D;
  }
  return o[e];
}
function groupBy(o, t) {
  var e = [], r = [];
  return o.forEach(function(D, N) {
    var k = t(D, N, o), $ = r.indexOf(k), G = e[$] || [];
    $ === -1 && (r.push(k), e.push(G)), G.push(D);
  }), e;
}
function groupByMap(o, t) {
  var e = [], r = {};
  return o.forEach(function(D, N) {
    var k = t(D, N, o), $ = r[k];
    $ || ($ = [], r[k] = $, e.push($)), $.push(D);
  }), e;
}
function flat(o) {
  return o.reduce(function(t, e) {
    return t.concat(e);
  }, []);
}
function maxOffset() {
  for (var o = [], t = 0; t < arguments.length; t++)
    o[t] = arguments[t];
  return o.sort(function(e, r) {
    return Math.abs(r) - Math.abs(e);
  }), o[0];
}
function calculateInversePosition(o, t, e) {
  return calculate(invert(o, e), convertPositionMatrix(t, e), e);
}
function convertDragDist(o, t) {
  var e, r = o.is3d, D = o.rootMatrix, N = r ? 4 : 3;
  return e = calculateInversePosition(D, [t.distX, t.distY], N), t.distX = e[0], t.distY = e[1], t;
}
function calculatePadding(o, t, e, r, D) {
  return minus(calculatePosition(o, plus(e, t), D), r);
}
function convertCSSSize(o, t, e) {
  return e ? "".concat(o / t * 100, "%") : "".concat(o, "px");
}
function getTinyDist(o) {
  return Math.abs(o) <= TINY_NUM ? 0 : o;
}
function getDirectionViewClassName(o) {
  return function(t) {
    if (!t.isDragging(o))
      return "";
    var e = getGestoData(t, o), r = e.deg;
    return r ? prefix("view-control-rotation".concat(r)) : "";
  };
}
function getDirectionCondition(o, t) {
  return t === void 0 && (t = [o]), function(e, r) {
    if (r.isRequest)
      return t.some(function(N) {
        return r.requestAble === N;
      }) ? r.parentDirection : !1;
    var D = r.inputEvent.target;
    return hasClass(D, prefix("direction")) && (!o || hasClass(D, prefix(o)));
  };
}
function convertTransformInfo(o, t) {
  var e = o.slice(0, t < 0 ? void 0 : t), r = o.slice(0, t < 0 ? void 0 : t + 1), D = o[t] || "", N = t < 0 ? [] : o.slice(t), k = t < 0 ? [] : o.slice(t + 1), $ = parse$1(e), G = parse$1(r), U = parse$1([D]), z = parse$1(N), X = parse$1(k), V = toMat($), Y = toMat(G), W = toMat(z), q = toMat(X), K = multiply(V, W, 4);
  return {
    transforms: o,
    beforeFunctionMatrix: V,
    beforeFunctionMatrix2: Y,
    targetFunctionMatrix: toMat(U),
    afterFunctionMatrix: W,
    afterFunctionMatrix2: q,
    allFunctionMatrix: K,
    beforeFunctions: $,
    beforeFunctions2: G,
    targetFunction: U[0],
    afterFunctions: z,
    afterFunctions2: X,
    beforeFunctionTexts: e,
    beforeFunctionTexts2: r,
    targetFunctionText: D,
    afterFunctionTexts: N,
    afterFunctionTexts2: k
  };
}
function isArrayFormat(o) {
  return !o || !isObject$2(o) || o instanceof Element ? !1 : isArray(o) || "length" in o;
}
function getRefTarget(o, t) {
  return o ? o instanceof Element ? o : isString(o) ? t ? document.querySelector(o) : o : isFunction$2(o) ? o() : "current" in o ? o.current : o : null;
}
function getRefTargets(o, t) {
  if (!o)
    return [];
  var e = isArrayFormat(o) ? [].slice.call(o) : [o];
  return e.reduce(function(r, D) {
    return isString(D) && t ? __spreadArray(__spreadArray([], r, !0), [].slice.call(document.querySelectorAll(D)), !0) : (isArray(D) ? r.push(getRefTargets(D, t)) : r.push(getRefTarget(D, t)), r);
  }, []);
}
function getAbsoluteRotation(o, t, e) {
  var r = getRad$1(o, t) / Math.PI * 180;
  return r = e >= 0 ? r : 180 - r, r = r >= 0 ? r : 360 + r, r;
}
function getDragDistByState(o, t) {
  var e = o.rootMatrix, r = o.is3d, D = r ? 4 : 3, N = invert(e, D);
  return r || (N = convertDimension(N, 3, 4)), N[12] = 0, N[13] = 0, N[14] = 0, calculateMatrixDist(N, t);
}
function getSizeDistByDist(o, t, e, r, D) {
  var N = o[0], k = o[1], $ = 0, G = 0;
  if (D && N && k) {
    var U = getRad$1([0, 0], t), z = getRad$1([0, 0], r), X = getDistSize(t), V = Math.cos(U - z) * X;
    if (!r[0])
      G = V, $ = G * e;
    else if (!r[1])
      $ = V, G = $ / e;
    else {
      var Y = r[0] * N, W = r[1] * k, q = Math.atan2(Y + t[0], W + t[1]), K = Math.atan2(Y, W);
      q < 0 && (q += Math.PI * 2), K < 0 && (K += Math.PI * 2);
      var Z = 0;
      Math.abs(q - K) < Math.PI / 2 || Math.abs(q - K) > Math.PI / 2 * 3 || (K += Math.PI), Z = q - K, Z > Math.PI * 2 ? Z -= Math.PI * 2 : Z > Math.PI ? Z = 2 * Math.PI - Z : Z < -Math.PI && (Z = -2 * Math.PI - Z);
      var J = getDistSize([Y + t[0], W + t[1]]) * Math.cos(Z);
      $ = J * Math.sin(K) - Y, G = J * Math.cos(K) - W, r[0] < 0 && ($ *= -1), r[1] < 0 && (G *= -1);
    }
  } else
    $ = r[0] * t[0], G = r[1] * t[1];
  return [$, G];
}
function getOffsetSizeDist(o, t, e, r) {
  var D, N = e.ratio, k = e.startOffsetWidth, $ = e.startOffsetHeight, G = 0, U = 0, z = r.distX, X = r.distY, V = r.pinchScale, Y = r.parentDistance, W = r.parentDist, q = r.parentScale, K = e.fixedDirection, Z = [0, 1].map(function(nt) {
    return Math.abs(o[nt] - K[nt]);
  }), J = [0, 1].map(function(nt) {
    var st = Z[nt];
    return st !== 0 && (st = 2 / st), st;
  });
  if (W)
    G = W[0], U = W[1], t && (G ? U || (U = G / N) : G = U * N);
  else if (isNumber(V))
    G = (V - 1) * k, U = (V - 1) * $;
  else if (q)
    G = (q[0] - 1) * k, U = (q[1] - 1) * $;
  else if (Y) {
    var Q = k * Z[0], et = $ * Z[1], it = getDistSize([Q, et]);
    G = Y / it * Q * J[0], U = Y / it * et * J[1];
  } else {
    var tt = getDragDist({
      datas: e,
      distX: z,
      distY: X
    });
    tt = J.map(function(nt, st) {
      return tt[st] * nt;
    }), D = getSizeDistByDist([k, $], tt, N, o, t), G = D[0], U = D[1];
  }
  return {
    // direction,
    // sizeDirection,
    distWidth: G,
    distHeight: U
  };
}
function convertTransformUnit(o, t) {
  if (t) {
    if (o === "left")
      return {
        x: "0%",
        y: "50%"
      };
    if (o === "top")
      return {
        x: "50%",
        y: "50%"
      };
    if (o === "center")
      return {
        x: "50%",
        y: "50%"
      };
    if (o === "right")
      return {
        x: "100%",
        y: "50%"
      };
    if (o === "bottom")
      return {
        x: "50%",
        y: "100%"
      };
    var e = o.split(" "), r = e[0], D = e[1], N = convertTransformUnit(r || ""), k = convertTransformUnit(D || ""), $ = __assign$1(__assign$1({}, N), k), G = {
      x: "50%",
      y: "50%"
    };
    return $.x && (G.x = $.x), $.y && (G.y = $.y), $.value && ($.x && !$.y && (G.y = $.value), !$.x && $.y && (G.x = $.value)), G;
  }
  return o === "left" ? {
    x: "0%"
  } : o === "right" ? {
    x: "100%"
  } : o === "top" ? {
    y: "0%"
  } : o === "bottom" ? {
    y: "100%"
  } : o ? o === "center" ? {
    value: "50%"
  } : {
    value: o
  } : {};
}
function convertTransformOriginArray(o, t, e) {
  var r = convertTransformUnit(o, !0), D = r.x, N = r.y;
  return [convertUnitSize(D, t) || 0, convertUnitSize(N, e) || 0];
}
function rotatePosesInfo(o, t, e) {
  var r = o.map(function(N) {
    return minus(N, t);
  }), D = r.map(function(N) {
    return rotate(N, e);
  });
  return {
    prev: r,
    next: D,
    result: D.map(function(N) {
      return plus(N, t);
    })
  };
}
function isDeepArrayEquals(o, t) {
  return o.length === t.length && o.every(function(e, r) {
    var D = t[r], N = isArray(e), k = isArray(D);
    return N && k ? isDeepArrayEquals(e, D) : !N && !k ? e === D : !1;
  });
}
function watchValue(o, t, e, r) {
  var D = o[t];
  return t in o && (D === e || r(D) === r(e)) ? D : (o[t] = e, e);
}
var Pinchable = makeAble("pinchable", {
  props: ["pinchable"],
  events: ["pinchStart", "pinch", "pinchEnd", "pinchGroupStart", "pinchGroup", "pinchGroupEnd"],
  dragStart: function() {
    return !0;
  },
  pinchStart: function(o, t) {
    var e = t.datas, r = t.targets, D = t.angle, N = t.originalDatas, k = o.props, $ = k.pinchable, G = k.ables;
    if (!$)
      return !1;
    var U = "onPinch".concat(r ? "Group" : "", "Start"), z = "drag".concat(r ? "Group" : "", "ControlStart"), X = ($ === !0 ? o.controlAbles : G.filter(function(q) {
      return $.indexOf(q.name) > -1;
    })).filter(function(q) {
      return q.canPinch && q[z];
    }), V = fillParams(o, t, {});
    r && (V.targets = r);
    var Y = triggerEvent(o, U, V);
    e.isPinch = Y !== !1, e.ables = X;
    var W = e.isPinch;
    return W ? (X.forEach(function(q) {
      if (N[q.name] = N[q.name] || {}, !!q[z]) {
        var K = __assign$1(__assign$1({}, t), {
          datas: N[q.name],
          parentRotate: D,
          isPinch: !0
        });
        q[z](o, K);
      }
    }), o.state.snapRenderInfo = {
      request: t.isRequest,
      direction: [0, 0]
    }, W) : !1;
  },
  pinch: function(o, t) {
    var e = t.datas, r = t.scale, D = t.distance, N = t.originalDatas, k = t.inputEvent, $ = t.targets, G = t.angle;
    if (e.isPinch) {
      var U = D * (1 - 1 / r), z = fillParams(o, t, {});
      $ && (z.targets = $);
      var X = "onPinch".concat($ ? "Group" : "");
      triggerEvent(o, X, z);
      var V = e.ables, Y = "drag".concat($ ? "Group" : "", "Control");
      return V.forEach(function(W) {
        W[Y] && W[Y](o, __assign$1(__assign$1({}, t), {
          datas: N[W.name],
          inputEvent: k,
          resolveMatrix: !0,
          pinchScale: r,
          parentDistance: U,
          parentRotate: G,
          isPinch: !0
        }));
      }), z;
    }
  },
  pinchEnd: function(o, t) {
    var e = t.datas, r = t.isPinch, D = t.inputEvent, N = t.targets, k = t.originalDatas;
    if (e.isPinch) {
      var $ = "onPinch".concat(N ? "Group" : "", "End"), G = fillEndParams(o, t, {
        isDrag: r
      });
      N && (G.targets = N), triggerEvent(o, $, G);
      var U = e.ables, z = "drag".concat(N ? "Group" : "", "ControlEnd");
      return U.forEach(function(X) {
        X[z] && X[z](o, __assign$1(__assign$1({}, t), {
          isDrag: r,
          datas: k[X.name],
          inputEvent: D,
          isPinch: !0
        }));
      }), r;
    }
  },
  pinchGroupStart: function(o, t) {
    return this.pinchStart(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  },
  pinchGroup: function(o, t) {
    return this.pinch(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  },
  pinchGroupEnd: function(o, t) {
    return this.pinchEnd(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  }
});
function fillChildEvents(o, t, e) {
  var r = e.originalDatas;
  r.groupable = r.groupable || {};
  var D = r.groupable;
  D.childDatas = D.childDatas || [];
  var N = D.childDatas;
  return o.moveables.map(function(k, $) {
    return N[$] = N[$] || {}, N[$][t] = N[$][t] || {}, __assign$1(__assign$1({}, e), {
      datas: N[$][t],
      originalDatas: N[$]
    });
  });
}
function triggerChildGesto(o, t, e, r, D, N, k) {
  var $ = !!e.match(/Start$/g), G = !!e.match(/End$/g), U = D.isPinch, z = D.datas, X = fillChildEvents(o, t.name, D), V = o.moveables, Y = X.map(function(W, q) {
    var K = V[q], Z = K.state, J = Z.gestos, Q = W;
    if ($)
      Q = new CustomGesto(k).dragStart(r, W);
    else {
      if (J[k] || (J[k] = z.childGestos[q]), !J[k])
        return;
      Q = setCustomDrag(W, Z, r, U, N, k);
    }
    var et = t[e](K, __assign$1(__assign$1({}, Q), {
      parentFlag: !0
    }));
    return G && (J[k] = null), et;
  });
  return $ && (z.childGestos = V.map(function(W) {
    return W.state.gestos[k];
  })), Y;
}
function triggerChildAbles(o, t, e, r, D, N) {
  D === void 0 && (D = function(z, X) {
    return X;
  });
  var k = !!e.match(/End$/g), $ = fillChildEvents(o, t.name, r), G = o.moveables, U = $.map(function(z, X) {
    var V = G[X], Y = z;
    Y = D(V, z);
    var W = t[e](V, __assign$1(__assign$1({}, Y), {
      parentFlag: !0
    }));
    return W && N && N(V, z, W, X), k && (V.state.gestos = {}), W;
  });
  return U;
}
function startChildDist(o, t, e, r) {
  var D = e.fixedDirection, N = e.fixedPosition, k = r.datas.startPositions || getAbsolutePosesByState(t.state), $ = getPosByDirection(k, D), G = calculate(createRotateMatrix(-o.rotation / 180 * Math.PI, 3), [$[0] - N[0], $[1] - N[1], 1], 3), U = G[0], z = G[1];
  return r.datas.originalX = U, r.datas.originalY = z, r;
}
var VERTICAL_NAMES = ["left", "right", "center"], HORIZONTAL_NAMES = ["top", "bottom", "middle"], VERTICAL_NAMES_MAP = {
  start: "left",
  end: "right",
  center: "center"
}, HORIZONTAL_NAMES_MAP = {
  start: "top",
  end: "bottom",
  center: "middle"
};
function hasGuidelines(o, t) {
  var e = o.props, r = e.snappable, D = e.bounds, N = e.innerBounds, k = e.verticalGuidelines, $ = e.horizontalGuidelines, G = e.snapGridWidth, U = e.snapGridHeight, z = o.state, X = z.guidelines, V = z.enableSnap;
  return !r || !V || t && r !== !0 && r.indexOf(t) < 0 ? !1 : !!(G || U || D || N || X && X.length || k && k.length || $ && $.length);
}
function getSnapDirections(o) {
  return o === !1 ? {} : o === !0 || !o ? {
    left: !0,
    right: !0,
    top: !0,
    bottom: !0
  } : o;
}
function mapSnapDirectionPoses(o, t) {
  var e = getSnapDirections(o), r = {};
  for (var D in e)
    D in t && e[D] && (r[D] = t[D]);
  return r;
}
function splitSnapDirectionPoses(o, t) {
  var e = mapSnapDirectionPoses(o, t), r = HORIZONTAL_NAMES.filter(function(N) {
    return N in e;
  }), D = VERTICAL_NAMES.filter(function(N) {
    return N in e;
  });
  return {
    horizontal: r.map(function(N) {
      return e[N];
    }),
    vertical: D.map(function(N) {
      return e[N];
    })
  };
}
function calculateContainerPos(o, t, e) {
  var r = calculatePosition(o, [t.clientLeft, t.clientTop], e);
  return [t.left + r[0], t.top + r[1]];
}
function solveLineConstants(o) {
  var t = o[0], e = o[1], r = e[0] - t[0], D = e[1] - t[1];
  Math.abs(r) < TINY_NUM$1 && (r = 0), Math.abs(D) < TINY_NUM$1 && (D = 0);
  var N = 0, k = 0, $ = 0;
  return r ? D ? (N = -D / r, k = 1, $ = N * t[0] - t[1]) : (k = 1, $ = -t[1]) : (N = -1, $ = t[0]), [N, k, $].map(function(G) {
    return throttle(G, TINY_NUM$1);
  });
}
function checkMoveableSnapPoses(o, t, e, r) {
  var D = o.props, N = selectValue(r, D.snapThreshold, 5);
  return checkSnapPoses(o.state.guidelines, t, e, N);
}
function checkSnapPoses(o, t, e, r) {
  return {
    vertical: checkSnap(o, "vertical", t, r),
    horizontal: checkSnap(o, "horizontal", e, r)
  };
}
function checkSnapKeepRatio(o, t, e) {
  var r = e[0], D = e[1], N = t[0], k = t[1], $ = minus(e, t), G = $[0], U = $[1], z = U > 0, X = G > 0;
  G = getTinyDist(G), U = getTinyDist(U);
  var V = {
    isSnap: !1,
    offset: 0,
    pos: 0
  }, Y = {
    isSnap: !1,
    offset: 0,
    pos: 0
  };
  if (G === 0 && U === 0)
    return {
      vertical: V,
      horizontal: Y
    };
  var W = checkMoveableSnapPoses(o, G ? [r] : [], U ? [D] : []), q = W.vertical, K = W.horizontal;
  q.posInfos.filter(function(_t) {
    var mt = _t.pos;
    return X ? mt >= N : mt <= N;
  }), K.posInfos.filter(function(_t) {
    var mt = _t.pos;
    return z ? mt >= k : mt <= k;
  }), q.isSnap = q.posInfos.length > 0, K.isSnap = K.posInfos.length > 0;
  var Z = getNearestSnapGuidelineInfo(q), J = Z.isSnap, Q = Z.guideline, et = getNearestSnapGuidelineInfo(K), it = et.isSnap, tt = et.guideline, nt = it ? tt.pos[1] : 0, st = J ? Q.pos[0] : 0;
  if (G === 0)
    it && (Y.isSnap = !0, Y.pos = tt.pos[1], Y.offset = D - Y.pos);
  else if (U === 0)
    J && (V.isSnap = !0, V.pos = st, V.offset = r - st);
  else {
    var at = U / G, ut = e[1] - at * r, ht = 0, dt = 0, pt = !1;
    J ? (dt = st, ht = at * dt + ut, pt = !0) : it && (ht = nt, dt = (ht - ut) / at, pt = !0), pt && (V.isSnap = !0, V.pos = dt, V.offset = r - dt, Y.isSnap = !0, Y.pos = ht, Y.offset = D - ht);
  }
  return {
    vertical: V,
    horizontal: Y
  };
}
function checkSnaps(o, t, e) {
  var r = splitSnapDirectionPoses(o.props.snapDirections, t);
  return checkMoveableSnapPoses(o, r.vertical, r.horizontal, e);
}
function getNearestSnapGuidelineInfo(o) {
  var t = o.isSnap;
  if (!t)
    return {
      isSnap: !1,
      offset: 0,
      dist: -1,
      pos: 0,
      guideline: null
    };
  var e = o.posInfos[0], r = e.guidelineInfos[0], D = r.offset, N = r.dist, k = r.guideline;
  return {
    isSnap: t,
    offset: D,
    dist: N,
    pos: e.pos,
    guideline: k
  };
}
function checkSnap(o, t, e, r) {
  if (!o || !o.length)
    return {
      isSnap: !1,
      index: -1,
      posInfos: []
    };
  var D = t === "vertical", N = D ? 0 : 1, k = e.map(function(G, U) {
    var z = o.map(function(X) {
      var V = X.pos, Y = G - V[N];
      return {
        offset: Y,
        dist: Math.abs(Y),
        guideline: X
      };
    }).filter(function(X) {
      var V = X.guideline, Y = X.dist, W = V.type;
      return !(W !== t || Y > r);
    }).sort(function(X, V) {
      return X.dist - V.dist;
    });
    return {
      pos: G,
      index: U,
      guidelineInfos: z
    };
  }).filter(function(G) {
    return G.guidelineInfos.length > 0;
  }).sort(function(G, U) {
    return G.guidelineInfos[0].dist - U.guidelineInfos[0].dist;
  }), $ = k.length > 0;
  return {
    isSnap: $,
    index: $ ? k[0].index : -1,
    posInfos: k
  };
}
function getSnapInfosByDirection(o, t, e, r) {
  r === void 0 && (r = 1);
  var D = [];
  if (e[0] && e[1])
    D = [e, [-e[0], e[1]], [e[0], -e[1]]].map(function($) {
      return getPosByDirection(t, $);
    });
  else if (!e[0] && !e[1])
    for (var N = [t[0], t[1], t[3], t[2], t[0]], k = 0; k < 4; ++k)
      D.push(N[k]), D.push([(N[k][0] + N[k + 1][0]) / 2, (N[k][1] + N[k + 1][1]) / 2]);
  else
    o.props.keepRatio ? D = [[-1, -1], [-1, 1], [1, -1], [1, 1], e].map(function($) {
      return getPosByDirection(t, $);
    }) : (D = getPosesByDirection(t, e), D.length > 1 && D.push([(D[0][0] + D[1][0]) / 2, (D[0][1] + D[1][1]) / 2]));
  return checkMoveableSnapPoses(o, D.map(function($) {
    return $[0];
  }), D.map(function($) {
    return $[1];
  }), r);
}
function checkSnapBoundPriority(o, t) {
  var e = Math.abs(o.offset), r = Math.abs(t.offset);
  return o.isBound && t.isBound ? r - e : o.isBound ? -1 : t.isBound ? 1 : o.isSnap && t.isSnap ? r - e : o.isSnap ? -1 : t.isSnap || e < TINY_NUM ? 1 : r < TINY_NUM ? -1 : e - r;
}
function getNearOffsetInfo(o, t) {
  return o.slice().sort(function(e, r) {
    var D = e.sign[t], N = r.sign[t], k = e.offset[t], $ = r.offset[t];
    if (D) {
      if (!N)
        return -1;
    } else
      return 1;
    return checkSnapBoundPriority({
      isBound: e.isBound,
      isSnap: e.isSnap,
      offset: k
    }, {
      isBound: r.isBound,
      isSnap: r.isSnap,
      offset: $
    });
  })[0];
}
function getCheckSnapDirections(o, t, e) {
  var r = [];
  if (e)
    Math.abs(t[0]) !== 1 || Math.abs(t[1]) !== 1 ? r.push([t, [-1, -1]], [t, [-1, 1]], [t, [1, -1]], [t, [1, 1]]) : r.push([t, [o[0], -o[1]]], [t, [-o[0], o[1]]]), r.push([t, o]);
  else if (o[0] && o[1] || !o[0] && !o[1]) {
    var D = o[0] ? o : [1, 1];
    [1, -1].forEach(function(k) {
      [1, -1].forEach(function($) {
        var G = [k * D[0], $ * D[1]];
        t[0] === G[0] && t[1] === G[1] || r.push([t, G]);
      });
    });
  } else if (o[0]) {
    var N = Math.abs(t[0]) === 1 ? [1] : [1, -1];
    N.forEach(function(k) {
      r.push([[t[0], -1], [k * o[0], -1]], [[t[0], 0], [k * o[0], 0]], [[t[0], 1], [k * o[0], 1]]);
    });
  } else if (o[1]) {
    var N = Math.abs(t[1]) === 1 ? [1] : [1, -1];
    N.forEach(function($) {
      r.push([[-1, t[1]], [-1, $ * o[1]]], [[0, t[1]], [0, $ * o[1]]], [[1, t[1]], [1, $ * o[1]]]);
    });
  }
  return r;
}
function isStartLine(o, t) {
  var e = average([t[0][0], t[1][0]]), r = average([t[0][1], t[1][1]]);
  return {
    vertical: e <= o[0],
    horizontal: r <= o[1]
  };
}
function hitTestLine(o, t) {
  var e = t[0], r = t[1], D = r[0] - e[0], N = r[1] - e[1];
  Math.abs(D) < TINY_NUM && (D = 0), Math.abs(N) < TINY_NUM && (N = 0);
  var k, $;
  if (!D)
    k = e[0], $ = o[0];
  else if (!N)
    k = e[1], $ = o[1];
  else {
    var G = N / D;
    k = G * (o[0] - e[0]) + e[1], $ = o[1];
  }
  return k - $;
}
function isSameStartLine(o, t, e, r) {
  return r === void 0 && (r = TINY_NUM), o.every(function(D) {
    var N = hitTestLine(D, t), k = N <= 0;
    return k === e || Math.abs(N) <= r;
  });
}
function checkInnerBoundDot(o, t, e, r, D) {
  return D === void 0 && (D = 0), r && t - D <= o || !r && o <= e + D ? {
    isBound: !0,
    offset: r ? t - o : e - o
  } : {
    isBound: !1,
    offset: 0
  };
}
function checkInnerBound(o, t) {
  var e = t.line, r = t.centerSign, D = t.verticalSign, N = t.horizontalSign, k = t.lineConstants, $ = o.props.innerBounds;
  if (!$)
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  var G = $.left, U = $.top, z = $.width, X = $.height, V = [[G, U], [G, U + X]], Y = [[G, U], [G + z, U]], W = [[G + z, U], [G + z, U + X]], q = [[G, U + X], [G + z, U + X]];
  if (isSameStartLine([[G, U], [G + z, U], [G, U + X], [G + z, U + X]], e, r))
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  var K = checkLineBoundCollision(e, k, Y, D), Z = checkLineBoundCollision(e, k, q, D), J = checkLineBoundCollision(e, k, V, N), Q = checkLineBoundCollision(e, k, W, N), et = K.isBound && Z.isBound, it = K.isBound || Z.isBound, tt = J.isBound && Q.isBound, nt = J.isBound || Q.isBound, st = maxOffset(K.offset, Z.offset), at = maxOffset(J.offset, Q.offset), ut = [0, 0], ht = !1, dt = !1;
  return Math.abs(at) < Math.abs(st) ? (ut = [st, 0], ht = it, dt = et) : (ut = [0, at], ht = nt, dt = tt), {
    isAllBound: dt,
    isVerticalBound: it,
    isHorizontalBound: nt,
    isBound: ht,
    offset: ut
  };
}
function checkLineBoundCollision(o, t, e, r, D, N) {
  var k = t[0], $ = t[1], G = o[0], U = e[0], z = e[1], X = getTinyDist(z[1] - U[1]), V = getTinyDist(z[0] - U[0]), Y = $, W = k, q = -k / $;
  if (V) {
    if (!X) {
      if (N && !Y)
        return {
          isBound: !1,
          offset: 0
        };
      if (W) {
        var Q = (U[1] - G[1]) / q + G[0];
        return checkInnerBoundDot(Q, U[0], z[0], r, D);
      } else {
        var Z = U[1] - G[1], J = Math.abs(Z) <= (D || 0);
        return {
          isBound: J,
          offset: J ? Z : 0
        };
      }
    }
  } else {
    if (N && !W)
      return {
        isBound: !1,
        offset: 0
      };
    if (Y) {
      var K = q * (U[0] - G[0]) + G[1];
      return checkInnerBoundDot(K, U[1], z[1], r, D);
    } else {
      var Z = U[0] - G[0], J = Math.abs(Z) <= (D || 0);
      return {
        isBound: J,
        offset: J ? Z : 0
      };
    }
  }
  return {
    isBound: !1,
    offset: 0
  };
}
function getInnerBoundInfo(o, t, e) {
  return t.map(function(r) {
    var D = checkInnerBound(o, r), N = D.isBound, k = D.offset, $ = D.isVerticalBound, G = D.isHorizontalBound, U = r.multiple, z = getDragDist({
      datas: e,
      distX: k[0],
      distY: k[1]
    }).map(function(X, V) {
      return X * (U[V] ? 2 / U[V] : 0);
    });
    return {
      sign: U,
      isBound: N,
      isVerticalBound: $,
      isHorizontalBound: G,
      isSnap: !1,
      offset: z
    };
  });
}
function getInnerBoundDragInfo(o, t, e) {
  var r, D = getCheckInnerBoundLineInfos(o, t, [0, 0], !1).map(function(V) {
    return __assign$1(__assign$1({}, V), {
      multiple: V.multiple.map(function(Y) {
        return Math.abs(Y) * 2;
      })
    });
  }), N = getInnerBoundInfo(o, D, e), k = getNearOffsetInfo(N, 0), $ = getNearOffsetInfo(N, 1), G = 0, U = 0, z = k.isVerticalBound || $.isVerticalBound, X = k.isHorizontalBound || $.isHorizontalBound;
  return (z || X) && (r = getInverseDragDist({
    datas: e,
    distX: -k.offset[0],
    distY: -$.offset[1]
  }), G = r[0], U = r[1]), {
    vertical: {
      isBound: z,
      offset: G
    },
    horizontal: {
      isBound: X,
      offset: U
    }
  };
}
function getCheckSnapLineDirections(o, t) {
  var e = [], r = o[0], D = o[1];
  return r && D ? e.push([[0, D * 2], o, [-r, D]], [[r * 2, 0], o, [r, -D]]) : r ? (e.push([[r * 2, 0], [r, 1], [r, -1]]), t && e.push([[0, -1], [r, -1], [-r, -1]], [[0, 1], [r, 1], [-r, 1]])) : D ? (e.push([[0, D * 2], [1, D], [-1, D]]), t && e.push([[-1, 0], [-1, D], [-1, -D]], [[1, 0], [1, D], [1, -D]])) : e.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]), e;
}
function getCheckInnerBoundLineInfos(o, t, e, r) {
  var D = o.state, N = D.allMatrix, k = D.is3d, $ = calculatePoses(N, 100, 100, k ? 4 : 3), G = getPosByDirection($, [0, 0]);
  return getCheckSnapLineDirections(e, r).map(function(U) {
    var z = U[0], X = U[1], V = U[2], Y = [getPosByDirection($, X), getPosByDirection($, V)], W = solveLineConstants(Y), q = isStartLine(G, Y), K = q.vertical, Z = q.horizontal, J = hitTestLine(G, Y) <= 0;
    return {
      multiple: z,
      centerSign: J,
      verticalSign: K,
      horizontalSign: Z,
      lineConstants: W,
      line: [getPosByDirection(t, X), getPosByDirection(t, V)]
    };
  });
}
function isBoundRotate$1(o, t, e, r) {
  var D = r ? o.map(function(N) {
    return rotate(N, r);
  }) : o;
  return [[D[0], D[1]], [D[1], D[3]], [D[3], D[2]], [D[2], D[0]]].some(function(N) {
    var k = hitTestLine(e, N) <= 0;
    return !isSameStartLine(t, N, k);
  });
}
function getDistPointLine(o) {
  var t = o[0], e = o[1], r = e[0] - t[0], D = e[1] - t[1];
  if (!r)
    return Math.abs(t[0]);
  if (!D)
    return Math.abs(t[1]);
  var N = D / r;
  return Math.abs((-N * t[0] + t[1]) / Math.sqrt(Math.pow(N, 2) + 1));
}
function solveReverseLine(o) {
  var t = o[0], e = o[1], r = e[0] - t[0], D = e[1] - t[1];
  if (!r)
    return [t[0], 0];
  if (!D)
    return [0, t[1]];
  var N = D / r, k = -N * t[0] + t[1];
  return [-k / (N + 1 / N), k / (N * N + 1)];
}
function checkRotateInnerBounds(o, t, e, r, D) {
  var N = o.props.innerBounds, k = D * Math.PI / 180;
  if (!N)
    return [];
  var $ = N.left, G = N.top, U = N.width, z = N.height, X = $ - r[0], V = $ + U - r[0], Y = G - r[1], W = G + z - r[1], q = [[X, Y], [V, Y], [X, W], [V, W]], K = getPosByDirection(e, [0, 0]);
  if (!isBoundRotate$1(e, q, K, 0))
    return [];
  var Z = [], J = q.map(function(Q) {
    return [getDistSize(Q), getRad$1([0, 0], Q)];
  });
  return [[e[0], e[1]], [e[1], e[3]], [e[3], e[2]], [e[2], e[0]]].forEach(function(Q) {
    var et = getRad$1([0, 0], solveReverseLine(Q)), it = getDistPointLine(Q);
    Z.push.apply(Z, J.filter(function(tt) {
      var nt = tt[0];
      return nt && it <= nt;
    }).map(function(tt) {
      var nt = tt[0], st = tt[1], at = Math.acos(nt ? it / nt : 0), ut = st + at, ht = st - at;
      return [k + ut - et, k + ht - et];
    }).reduce(function(tt, nt) {
      return tt.push.apply(tt, nt), tt;
    }, []).filter(function(tt) {
      return !isBoundRotate$1(t, q, K, tt);
    }).map(function(tt) {
      return throttle(tt * 180 / Math.PI, TINY_NUM);
    }));
  }), Z;
}
function checkInnerBoundPoses(o) {
  var t = o.props.innerBounds;
  if (!t)
    return {
      vertical: [],
      horizontal: []
    };
  var e = o.getRect(), r = e.pos1, D = e.pos2, N = e.pos3, k = e.pos4, $ = [r, D, N, k], G = getPosByDirection($, [0, 0]), U = t.left, z = t.top, X = t.width, V = t.height, Y = [[U, z], [U, z + V]], W = [[U, z], [U + X, z]], q = [[U + X, z], [U + X, z + V]], K = [[U, z + V], [U + X, z + V]], Z = getCheckInnerBoundLineInfos(o, $, [0, 0], !1), J = [], Q = [], et = {
    top: !1,
    bottom: !1,
    left: !1,
    right: !1
  };
  return Z.forEach(function(it) {
    var tt = it.line, nt = it.lineConstants, st = isStartLine(G, tt), at = st.horizontal, ut = st.vertical, ht = checkLineBoundCollision(tt, nt, W, ut, 1, !0), dt = checkLineBoundCollision(tt, nt, K, ut, 1, !0), pt = checkLineBoundCollision(tt, nt, Y, at, 1, !0), _t = checkLineBoundCollision(tt, nt, q, at, 1, !0);
    ht.isBound && !et.top && (J.push(z), et.top = !0), dt.isBound && !et.bottom && (J.push(z + V), et.bottom = !0), pt.isBound && !et.left && (Q.push(U), et.left = !0), _t.isBound && !et.right && (Q.push(U + X), et.right = !0);
  }), {
    horizontal: J,
    vertical: Q
  };
}
function checkBoundPoses(o, t, e) {
  var r = o || {}, D = r.position, N = D === void 0 ? "client" : D, k = r.left, $ = k === void 0 ? -1 / 0 : k, G = r.top, U = G === void 0 ? -1 / 0 : G, z = r.right, X = z === void 0 ? 1 / 0 : z, V = r.bottom, Y = V === void 0 ? 1 / 0 : V, W = {
    position: N,
    left: $,
    top: U,
    right: X,
    bottom: Y
  };
  return {
    vertical: checkBounds(W, t, !0),
    horizontal: checkBounds(W, e, !1)
  };
}
function getBounds(o, t) {
  var e = o.state, r = e.containerClientRect, D = r.clientHeight, N = r.clientWidth, k = r.clientLeft, $ = r.clientTop, G = e.snapOffset, U = G.left, z = G.top, X = G.right, V = G.bottom, Y = t || o.props.bounds || {}, W = Y.position || "client", q = W === "css", K = Y.left, Z = K === void 0 ? -1 / 0 : K, J = Y.top, Q = J === void 0 ? -1 / 0 : J, et = Y.right, it = et === void 0 ? q ? -1 / 0 : 1 / 0 : et, tt = Y.bottom, nt = tt === void 0 ? q ? -1 / 0 : 1 / 0 : tt;
  return q && (it = N + X - U - it, nt = D + V - z - nt), {
    left: Z + U - k,
    right: it + U - k,
    top: Q + z - $,
    bottom: nt + z - $
  };
}
function checkBoundKeepRatio(o, t, e) {
  var r = getBounds(o), D = r.left, N = r.top, k = r.right, $ = r.bottom, G = e[0], U = e[1], z = minus(e, t), X = z[0], V = z[1];
  Math.abs(X) < TINY_NUM && (X = 0), Math.abs(V) < TINY_NUM && (V = 0);
  var Y = V > 0, W = X > 0, q = {
    isBound: !1,
    offset: 0,
    pos: 0
  }, K = {
    isBound: !1,
    offset: 0,
    pos: 0
  };
  if (X === 0 && V === 0)
    return {
      vertical: q,
      horizontal: K
    };
  if (X === 0)
    Y ? $ < U && (K.pos = $, K.offset = U - $) : N > U && (K.pos = N, K.offset = U - N);
  else if (V === 0)
    W ? k < G && (q.pos = k, q.offset = G - k) : D > G && (q.pos = D, q.offset = G - D);
  else {
    var Z = V / X, J = e[1] - Z * G, Q = 0, et = 0, it = !1;
    W && k <= G ? (Q = Z * k + J, et = k, it = !0) : !W && G <= D && (Q = Z * D + J, et = D, it = !0), it && (Q < N || Q > $) && (it = !1), it || (Y && $ <= U ? (Q = $, et = (Q - J) / Z, it = !0) : !Y && U <= N && (Q = N, et = (Q - J) / Z, it = !0)), it && (q.isBound = !0, q.pos = et, q.offset = G - et, K.isBound = !0, K.pos = Q, K.offset = U - Q);
  }
  return {
    vertical: q,
    horizontal: K
  };
}
function checkBounds(o, t, e) {
  var r = o[e ? "left" : "top"], D = o[e ? "right" : "bottom"], N = Math.min.apply(Math, t), k = Math.max.apply(Math, t), $ = [];
  return r + 1 > N && $.push({
    isBound: !0,
    offset: N - r,
    pos: r
  }), D - 1 < k && $.push({
    isBound: !0,
    offset: k - D,
    pos: D
  }), $.length || $.push({
    isBound: !1,
    offset: 0,
    pos: 0
  }), $.sort(function(G, U) {
    return Math.abs(U.offset) - Math.abs(G.offset);
  });
}
function isBoundRotate(o, t, e) {
  var r = e ? o.map(function(D) {
    return rotate(D, e);
  }) : o;
  return r.some(function(D) {
    return D[0] < t.left && Math.abs(D[0] - t.left) > 0.1 || D[0] > t.right && Math.abs(D[0] - t.right) > 0.1 || D[1] < t.top && Math.abs(D[1] - t.top) > 0.1 || D[1] > t.bottom && Math.abs(D[1] - t.bottom) > 0.1;
  });
}
function boundRotate(o, t, e) {
  var r = getDistSize(o), D = Math.sqrt(r * r - t * t) || 0;
  return [D, -D].sort(function(N, k) {
    return Math.abs(N - o[e ? 0 : 1]) - Math.abs(k - o[e ? 0 : 1]);
  }).map(function(N) {
    return getRad$1([0, 0], e ? [N, t] : [t, N]);
  });
}
function checkRotateBounds(o, t, e, r, D) {
  if (!o.props.bounds)
    return [];
  var N = D * Math.PI / 180, k = getBounds(o), $ = k.left, G = k.top, U = k.right, z = k.bottom, X = $ - r[0], V = U - r[0], Y = G - r[1], W = z - r[1], q = {
    left: X,
    top: Y,
    right: V,
    bottom: W
  };
  if (!isBoundRotate(e, q, 0))
    return [];
  var K = [];
  return [[X, 0], [V, 0], [Y, 1], [W, 1]].forEach(function(Z) {
    var J = Z[0], Q = Z[1];
    e.forEach(function(et) {
      var it = getRad$1([0, 0], et);
      K.push.apply(K, boundRotate(et, J, Q).map(function(tt) {
        return N + tt - it;
      }).filter(function(tt) {
        return !isBoundRotate(t, q, tt);
      }).map(function(tt) {
        return throttle(tt * 180 / Math.PI, TINY_NUM);
      }));
    });
  }), K;
}
function renderGuideline(o, t) {
  var e, r = o.direction, D = o.classNames, N = o.size, k = o.pos, $ = o.zoom, G = o.key, U = r === "horizontal", z = U ? "Y" : "X";
  return t.createElement("div", {
    key: G,
    className: D.join(" "),
    style: (e = {}, e[U ? "width" : "height"] = "".concat(N), e.transform = "translate(".concat(k[0], ", ").concat(k[1], ") translate").concat(z, "(-50%) scale").concat(z, "(").concat($, ")"), e)
  });
}
function renderInnerGuideline(o, t) {
  return renderGuideline(__assign$1(__assign$1({}, o), {
    classNames: __spreadArray([prefix("line", "guideline", o.direction)], o.classNames, !0).filter(function(e) {
      return e;
    }),
    size: o.size || "".concat(o.sizeValue, "px"),
    pos: o.pos || o.posValue.map(function(e) {
      return "".concat(throttle(e, 0.1), "px");
    })
  }), t);
}
function renderSnapPoses(o, t, e, r, D, N, k, $) {
  var G = o.props.zoom;
  return e.map(function(U, z) {
    var X = U.type, V = U.pos, Y = [0, 0];
    return Y[k] = r, Y[k ? 0 : 1] = -D + V, renderInnerGuideline({
      key: "".concat(t, "TargetGuideline").concat(z),
      classNames: [prefix("target", "bold", X)],
      posValue: Y,
      sizeValue: N,
      zoom: G,
      direction: t
    }, $);
  });
}
function renderGuidelines(o, t, e, r, D, N) {
  var k = o.props, $ = k.zoom, G = k.isDisplayInnerSnapDigit, U = t === "horizontal" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, z = D[U.start], X = D[U.end];
  return e.filter(function(V) {
    var Y = V.hide, W = V.elementRect;
    if (Y)
      return !1;
    if (G && W) {
      var q = W.rect;
      if (q[U.start] <= z && X <= q[U.end])
        return !1;
    }
    return !0;
  }).map(function(V, Y) {
    var W = V.pos, q = V.size, K = V.element, Z = V.className, J = [-r[0] + W[0], -r[1] + W[1]];
    return renderInnerGuideline({
      key: "".concat(t, "-default-guideline-").concat(Y),
      classNames: K ? [prefix("bold"), Z] : [prefix("normal"), Z],
      direction: t,
      posValue: J,
      sizeValue: q,
      zoom: $
    }, N);
  });
}
function renderDigitLine(o, t, e, r, D, N, k, $) {
  var G, U = o.props, z = U.snapDigit, X = z === void 0 ? 0 : z, V = U.isDisplaySnapDigit, Y = V === void 0 ? !0 : V, W = U.snapDistFormat, q = W === void 0 ? function(it, tt) {
    return it;
  } : W, K = U.zoom, Z = t === "horizontal" ? "X" : "Y", J = t === "vertical" ? "height" : "width", Q = Math.abs(D), et = Y ? parseFloat(Q.toFixed(X)) : 0;
  return $.createElement("div", {
    key: "".concat(t, "-").concat(e, "-guideline-").concat(r),
    className: prefix("guideline-group", t),
    style: (G = {
      left: "".concat(N[0], "px"),
      top: "".concat(N[1], "px")
    }, G[J] = "".concat(Q, "px"), G)
  }, renderInnerGuideline({
    direction: t,
    classNames: [prefix(e), k],
    size: "100%",
    posValue: [0, 0],
    sizeValue: Q,
    zoom: K
  }, $), $.createElement("div", {
    className: prefix("size-value", "gap"),
    style: {
      transform: "translate".concat(Z, "(-50%) scale(").concat(K, ")")
    }
  }, et > 0 ? q(et, t) : ""));
}
function groupByElementGuidelines(o, t, e, r) {
  var D = o === "vertical" ? 0 : 1, N = o === "vertical" ? 1 : 0, k = D ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, $ = e[k.start], G = e[k.end];
  return groupBy(t, function(U) {
    return U.pos[D];
  }).map(function(U) {
    var z = [], X = [], V = [];
    return U.forEach(function(Y) {
      var W, q, K = Y.element, Z = Y.elementRect.rect;
      if (Z[k.end] < $)
        z.push(Y);
      else if (G < Z[k.start])
        X.push(Y);
      else if (Z[k.start] <= $ && G <= Z[k.end] && r) {
        var J = Y.pos, Q = {
          element: K,
          rect: __assign$1(__assign$1({}, Z), (W = {}, W[k.end] = Z[k.start], W))
        }, et = {
          element: K,
          rect: __assign$1(__assign$1({}, Z), (q = {}, q[k.start] = Z[k.end], q))
        }, it = [0, 0], tt = [0, 0];
        it[D] = J[D], it[N] = J[N], tt[D] = J[D], tt[N] = J[N] + Y.size, z.push({
          type: o,
          pos: it,
          size: 0,
          elementRect: Q
        }), X.push({
          type: o,
          pos: tt,
          size: 0,
          elementRect: et
        });
      }
    }), z.sort(function(Y, W) {
      return W.pos[N] - Y.pos[N];
    }), X.sort(function(Y, W) {
      return Y.pos[N] - W.pos[N];
    }), {
      total: U,
      start: z,
      end: X,
      inner: V
    };
  });
}
function renderDashedGuidelines(o, t, e, r, D) {
  var N = o.props.isDisplayInnerSnapDigit, k = [];
  return ["vertical", "horizontal"].forEach(function($) {
    var G = t.filter(function(K) {
      return K.type === $;
    }), U = $ === "vertical" ? 1 : 0, z = U ? 0 : 1, X = groupByElementGuidelines($, G, r, N), V = U ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, Y = U ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, W = r[V.start], q = r[V.end];
    X.forEach(function(K) {
      var Z = K.total, J = K.start, Q = K.end, et = K.inner, it = e[z] + Z[0].pos[z] - r[Y.start], tt = r;
      J.forEach(function(nt) {
        var st = nt.elementRect.rect, at = tt[V.start] - st[V.end];
        if (at > 0) {
          var ut = [0, 0];
          ut[U] = e[U] + tt[V.start] - W - at, ut[z] = it, k.push(renderDigitLine(o, $, "dashed", k.length, at, ut, nt.className, D));
        }
        tt = st;
      }), tt = r, Q.forEach(function(nt) {
        var st = nt.elementRect.rect, at = st[V.start] - tt[V.end];
        if (at > 0) {
          var ut = [0, 0];
          ut[U] = e[U] + tt[V.end] - W, ut[z] = it, k.push(renderDigitLine(o, $, "dashed", k.length, at, ut, nt.className, D));
        }
        tt = st;
      }), et.forEach(function(nt) {
        var st = nt.elementRect.rect, at = W - st[V.start], ut = st[V.end] - q, ht = [0, 0], dt = [0, 0];
        ht[U] = e[U] - at, ht[z] = it, dt[U] = e[U] + q - W, dt[z] = it, k.push(renderDigitLine(o, $, "dashed", k.length, at, ht, nt.className, D)), k.push(renderDigitLine(o, $, "dashed", k.length, ut, dt, nt.className, D));
      });
    });
  }), k;
}
function renderGapGuidelines(o, t, e, r, D) {
  var N = [];
  return ["horizontal", "vertical"].forEach(function(k) {
    var $ = t.filter(function(K) {
      return K.type === k;
    }).slice(0, 1), G = k === "vertical" ? 0 : 1, U = G ? 0 : 1, z = G ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, X = G ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, V = r[z.start], Y = r[z.end], W = r[X.start], q = r[X.end];
    $.forEach(function(K) {
      var Z = K.gap, J = K.gapRects, Q = Math.max.apply(Math, __spreadArray([W], J.map(function(tt) {
        var nt = tt.rect;
        return nt[X.start];
      }), !1)), et = Math.min.apply(Math, __spreadArray([q], J.map(function(tt) {
        var nt = tt.rect;
        return nt[X.end];
      }), !1)), it = (Q + et) / 2;
      Q === et || it === (W + q) / 2 || J.forEach(function(tt) {
        var nt = tt.rect, st = tt.className, at = [e[0], e[1]];
        if (nt[z.end] < V)
          at[G] += nt[z.end] - V;
        else if (Y < nt[z.start])
          at[G] += nt[z.start] - V - Z;
        else
          return;
        at[U] += it - W, N.push(renderDigitLine(o, G ? "vertical" : "horizontal", "gap", N.length, Z, at, st, D));
      });
    });
  }), N;
}
function solveEquation(o, t, e, r) {
  var D = t[0] - o[0], N = t[1] - o[1];
  if (Math.abs(D) < TINY_NUM$1 && (D = 0), Math.abs(N) < TINY_NUM$1 && (N = 0), !D)
    return r ? [0, 0] : [0, e];
  if (!N)
    return r ? [e, 0] : [0, 0];
  var k = N / D, $ = o[1] - k * o[0];
  if (r) {
    var G = k * (t[0] + e) + $;
    return [e, G - t[1]];
  } else {
    var U = (t[1] + e - $) / k;
    return [U - t[0], e];
  }
}
function solveNextOffset(o, t, e, r, D) {
  var N = solveEquation(o, t, e, r);
  if (!N)
    return {
      isOutside: !1,
      offset: [0, 0]
    };
  var k = getDist$2(o, t), $ = getDist$2(N, o), G = getDist$2(N, t), U = $ > k || G > k, z = getDragDist({
    datas: D,
    distX: N[0],
    distY: N[1]
  }), X = z[0], V = z[1];
  return {
    offset: [X, V],
    isOutside: U
  };
}
function getSnapBound(o, t) {
  return o.isBound ? o.offset : t.isSnap ? getNearestSnapGuidelineInfo(t).offset : 0;
}
function checkThrottleDragRotate(o, t, e, r, D) {
  var N = t[0], k = t[1], $ = e[0], G = e[1], U = r[0], z = r[1], X = D[0], V = D[1], Y = -X, W = -V;
  if (o && N && k) {
    Y = 0, W = 0;
    var q = [];
    if ($ && G ? q.push([0, V], [X, 0]) : $ ? q.push([X, 0]) : G ? q.push([0, V]) : U && z ? q.push([0, V], [X, 0]) : U ? q.push([X, 0]) : z && q.push([0, V]), q.length) {
      q.sort(function(Q, et) {
        return getDistSize(minus([N, k], Q)) - getDistSize(minus([N, k], et));
      });
      var K = q[0];
      if (K[0] && Math.abs(N) > TINY_NUM$1)
        Y = -K[0], W = k * Math.abs(N + Y) / Math.abs(N) - k;
      else if (K[1] && Math.abs(k) > TINY_NUM$1) {
        var Z = k;
        W = -K[1], Y = N * Math.abs(k + W) / Math.abs(Z) - N;
      }
      if (o && G && $)
        if (Math.abs(Y) > TINY_NUM$1 && Math.abs(Y) < Math.abs(X)) {
          var J = Math.abs(X) / Math.abs(Y);
          Y *= J, W *= J;
        } else if (Math.abs(W) > TINY_NUM$1 && Math.abs(W) < Math.abs(V)) {
          var J = Math.abs(V) / Math.abs(W);
          Y *= J, W *= J;
        } else
          Y = maxOffset(-X, Y), W = maxOffset(-V, W);
    }
  } else
    Y = N || $ ? -X : 0, W = k || G ? -V : 0;
  return [Y, W];
}
function checkSnapBoundsDrag(o, t, e, r, D, N) {
  if (!hasGuidelines(o, "draggable"))
    return [{
      isSnap: !1,
      isBound: !1,
      offset: 0
    }, {
      isSnap: !1,
      isBound: !1,
      offset: 0
    }];
  var k = getAbsolutePoses(N.absolutePoses, [t, e]), $ = getRect(k), G = $.left, U = $.right, z = $.top, X = $.bottom, V = {
    horizontal: k.map(function(_t) {
      return _t[1];
    }),
    vertical: k.map(function(_t) {
      return _t[0];
    })
  }, Y = getSnapDirections(o.props.snapDirections), W = splitSnapDirectionPoses(Y, {
    left: G,
    right: U,
    top: z,
    bottom: X,
    center: (G + U) / 2,
    middle: (z + X) / 2
  }), q = checkMoveableSnapBounds(o, D, W, V), K = q.vertical, Z = q.horizontal, J = getInnerBoundDragInfo(o, k, N), Q = J.vertical, et = J.horizontal, it = K.isSnap, tt = Z.isSnap, nt = K.isBound || Q.isBound, st = Z.isBound || et.isBound, at = maxOffset(K.offset, Q.offset), ut = maxOffset(Z.offset, et.offset), ht = checkThrottleDragRotate(r, [t, e], [nt, st], [it, tt], [at, ut]), dt = ht[0], pt = ht[1];
  return [{
    isBound: nt,
    isSnap: it,
    offset: dt
  }, {
    isBound: st,
    isSnap: tt,
    offset: pt
  }];
}
function checkMoveableSnapBounds(o, t, e, r) {
  r === void 0 && (r = e);
  var D = checkBoundPoses(getBounds(o), r.vertical, r.horizontal), N = D.horizontal, k = D.vertical, $ = t ? {
    horizontal: {
      isSnap: !1,
      index: -1
    },
    vertical: {
      isSnap: !1,
      index: -1
    }
  } : checkMoveableSnapPoses(o, e.vertical, e.horizontal), G = $.horizontal, U = $.vertical, z = getSnapBound(N[0], G), X = getSnapBound(k[0], U), V = Math.abs(z), Y = Math.abs(X);
  return {
    horizontal: {
      isBound: N[0].isBound,
      isSnap: G.isSnap,
      snapIndex: G.index,
      offset: z,
      dist: V,
      bounds: N,
      snap: G
    },
    vertical: {
      isBound: k[0].isBound,
      isSnap: U.isSnap,
      snapIndex: U.index,
      offset: X,
      dist: Y,
      bounds: k,
      snap: U
    }
  };
}
function checkSnapBounds(o, t, e, r, D) {
  var N = checkBoundPoses(t, e, r), k = N.horizontal, $ = N.vertical, G = checkSnapPoses(o, e, r, D), U = G.horizontal, z = G.vertical, X = getSnapBound(k[0], U), V = getSnapBound($[0], z), Y = Math.abs(X), W = Math.abs(V);
  return {
    horizontal: {
      isBound: k[0].isBound,
      isSnap: U.isSnap,
      snapIndex: U.index,
      offset: X,
      dist: Y,
      bounds: k,
      snap: U
    },
    vertical: {
      isBound: $[0].isBound,
      isSnap: z.isSnap,
      snapIndex: z.index,
      offset: V,
      dist: W,
      bounds: $,
      snap: z
    }
  };
}
function checkSnapRightLine(o, t, e, r) {
  var D = getRad$1(o, t) / Math.PI * 180, N = e.vertical, k = N.isBound, $ = N.isSnap, G = N.dist, U = e.horizontal, z = U.isBound, X = U.isSnap, V = U.dist, Y = D % 180, W = Y < 3 || Y > 177, q = Y > 87 && Y < 93;
  return V < G && (k || $ && !q && (!r || !W)) ? "vertical" : z || X && !W && (!r || !q) ? "horizontal" : "";
}
function getSnapBoundInfo(o, t, e, r, D, N) {
  return e.map(function(k) {
    var $ = k[0], G = k[1], U = getPosByDirection(t, $), z = getPosByDirection(t, G), X = r ? checkSnapBoundsKeepRatio(o, U, z, D) : checkMoveableSnapBounds(o, D, {
      vertical: [z[0]],
      horizontal: [z[1]]
    }), V = X.horizontal, Y = V.offset, W = V.isBound, q = V.isSnap, K = X.vertical, Z = K.offset, J = K.isBound, Q = K.isSnap, et = minus(G, $);
    if (!Z && !Y)
      return {
        isBound: J || W,
        isSnap: Q || q,
        sign: et,
        offset: [0, 0]
      };
    var it = checkSnapRightLine(U, z, X, r);
    if (!it)
      return {
        sign: et,
        isBound: !1,
        isSnap: !1,
        offset: [0, 0]
      };
    var tt = it === "vertical", nt = [0, 0];
    return !r && Math.abs(G[0]) === 1 && Math.abs(G[1]) === 1 && $[0] !== G[0] && $[1] !== G[1] ? nt = getDragDist({
      datas: N,
      distX: -Z,
      distY: -Y
    }) : nt = solveNextOffset(U, z, -(tt ? Z : Y), tt, N).offset, nt = nt.map(function(st, at) {
      return st * (et[at] ? 2 / et[at] : 0);
    }), {
      sign: et,
      isBound: tt ? J : W,
      isSnap: tt ? Q : q,
      offset: nt
    };
  });
}
function getSnapBoundOffset(o, t) {
  return o.isBound ? o.offset : t.isSnap ? t.offset : 0;
}
function checkSnapBoundsKeepRatio(o, t, e, r) {
  var D = checkBoundKeepRatio(o, t, e), N = D.horizontal, k = D.vertical, $ = r ? {
    horizontal: {
      isSnap: !1
    },
    vertical: {
      isSnap: !1
    }
  } : checkSnapKeepRatio(o, t, e), G = $.horizontal, U = $.vertical, z = getSnapBoundOffset(N, G), X = getSnapBoundOffset(k, U), V = Math.abs(z), Y = Math.abs(X);
  return {
    horizontal: {
      isBound: N.isBound,
      isSnap: G.isSnap,
      offset: z,
      dist: V
    },
    vertical: {
      isBound: k.isBound,
      isSnap: U.isSnap,
      offset: X,
      dist: Y
    }
  };
}
function checkMaxBounds(o, t, e, r, D) {
  var N = [-e[0], -e[1]], k = o.state, $ = k.width, G = k.height, U = o.props.bounds, z = 1 / 0, X = 1 / 0;
  if (U) {
    var V = [[e[0], -e[1]], [-e[0], e[1]]], Y = U.left, W = Y === void 0 ? -1 / 0 : Y, q = U.top, K = q === void 0 ? -1 / 0 : q, Z = U.right, J = Z === void 0 ? 1 / 0 : Z, Q = U.bottom, et = Q === void 0 ? 1 / 0 : Q;
    V.forEach(function(it) {
      var tt = it[0] !== N[0], nt = it[1] !== N[1], st = getPosByDirection(t, it), at = getRad$1(r, st) * 360 / Math.PI;
      if (nt) {
        var ut = st.slice();
        (Math.abs(at - 360) < 2 || Math.abs(at - 180) < 2) && (ut[1] = r[1]);
        var ht = solveNextOffset(r, ut, (r[1] < st[1] ? et : K) - st[1], !1, D), dt = ht.offset, pt = dt[1], _t = ht.isOutside;
        isNaN(pt) || (X = G + (_t ? 1 : -1) * Math.abs(pt));
      }
      if (tt) {
        var ut = st.slice();
        (Math.abs(at - 90) < 2 || Math.abs(at - 270) < 2) && (ut[0] = r[0]);
        var mt = solveNextOffset(r, ut, (r[0] < st[0] ? J : W) - st[0], !0, D), yt = mt.offset[0], Tt = mt.isOutside;
        isNaN(yt) || (z = $ + (Tt ? 1 : -1) * Math.abs(yt));
      }
    });
  }
  return {
    maxWidth: z,
    maxHeight: X
  };
}
function getTotalGuidelines(o) {
  var t = o.state, e = t.containerClientRect, r = t.hasFixed, D = e.overflow, N = e.scrollHeight, k = e.scrollWidth, $ = e.clientHeight, G = e.clientWidth, U = e.clientLeft, z = e.clientTop, X = o.props, V = X.snapGap, Y = V === void 0 ? !0 : V, W = X.verticalGuidelines, q = X.horizontalGuidelines, K = X.snapThreshold, Z = K === void 0 ? 5 : K, J = X.snapGridWidth, Q = J === void 0 ? 0 : J, et = X.snapGridHeight, it = et === void 0 ? 0 : et, tt = X.maxSnapElementGuidelineDistance, nt = tt === void 0 ? 1 / 0 : tt, st = getRect(getAbsolutePosesByState(o.state)), at = st.top, ut = st.left, ht = st.bottom, dt = st.right, pt = {
    top: at,
    left: ut,
    bottom: ht,
    right: dt,
    center: (ut + dt) / 2,
    middle: (at + ht) / 2
  }, _t = getElementGuidelines(o), mt = __spreadArray([], _t, !0);
  Y && mt.push.apply(mt, getGapGuidelines(o, pt, Z)), mt.push.apply(mt, getGridGuidelines(Q, it, D ? k : G, D ? N : $, U, z));
  var yt = __assign$1({}, t.snapOffset || {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  });
  if (r) {
    var Tt = e.left, Pt = e.top;
    yt.left += Tt, yt.top += Pt, yt.right += Tt, yt.bottom += Pt;
  }
  return mt.push.apply(mt, getDefaultGuidelines(q || !1, W || !1, D ? k : G, D ? N : $, U, z, yt)), mt = mt.filter(function(St) {
    var gt = St.element, bt = St.elementRect, At = St.type;
    if (!gt || !bt)
      return !0;
    var Rt = bt.rect;
    return checkBetweenRects(pt, Rt, At, nt);
  }), mt;
}
function getGapGuidelines(o, t, e) {
  var r = o.props, D = r.maxSnapElementGuidelineDistance, N = D === void 0 ? 1 / 0 : D, k = r.maxSnapElementGapDistance, $ = k === void 0 ? 1 / 0 : k, G = o.state.elementRects, U = [];
  return [["vertical", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP], ["horizontal", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP]].forEach(function(z) {
    var X = z[0], V = z[1], Y = z[2], W = t[V.start], q = t[V.end], K = t[V.center], Z = t[Y.start], J = t[Y.end];
    function Q(tt) {
      var nt = tt.rect;
      return nt[V.end] < W + e ? W - nt[V.end] : q - e < nt[V.start] ? nt[V.start] - q : -1;
    }
    var et = G.filter(function(tt) {
      var nt = tt.rect;
      return nt[Y.start] > J || nt[Y.end] < Z ? !1 : Q(tt) > 0;
    }).sort(function(tt, nt) {
      return Q(tt) - Q(nt);
    }), it = [];
    et.forEach(function(tt) {
      et.forEach(function(nt) {
        if (tt !== nt) {
          var st = tt.rect, at = nt.rect, ut = st[Y.start], ht = st[Y.end], dt = at[Y.start], pt = at[Y.end];
          ut > pt || dt > ht || it.push([tt, nt]);
        }
      });
    }), it.forEach(function(tt) {
      var nt = tt[0], st = tt[1], at = nt.rect, ut = st.rect, ht = at[V.start], dt = at[V.end], pt = ut[V.start], _t = ut[V.end], mt = 0, yt = 0, Tt = !1, Pt = !1, St = !1;
      if (dt <= W && q <= pt) {
        if (Pt = !0, mt = (pt - dt - (q - W)) / 2, yt = dt + mt + (q - W) / 2, Math.abs(yt - K) > e)
          return;
      } else if (dt < pt && _t < W + e) {
        if (Tt = !0, mt = pt - dt, yt = _t + mt, Math.abs(yt - W) > e)
          return;
      } else if (dt < pt && q - e < ht) {
        if (St = !0, mt = pt - dt, yt = ht - mt, Math.abs(yt - q) > e)
          return;
      } else
        return;
      mt && checkBetweenRects(t, ut, X, N) && (mt > $ || U.push({
        type: X,
        pos: X === "vertical" ? [yt, 0] : [0, yt],
        element: st.element,
        size: 0,
        className: st.className,
        isStart: Tt,
        isCenter: Pt,
        isEnd: St,
        gap: mt,
        hide: !0,
        gapRects: [nt, st]
      }));
    });
  }), U;
}
function getGridGuidelines(o, t, e, r, D, N) {
  D === void 0 && (D = 0), N === void 0 && (N = 0);
  var k = [];
  if (t)
    for (var $ = 0; $ <= r; $ += t)
      k.push({
        type: "horizontal",
        pos: [0, throttle($ - N, 0.1)],
        size: e,
        hide: !0
      });
  if (o)
    for (var $ = 0; $ <= e; $ += o)
      k.push({
        type: "vertical",
        pos: [throttle($ - D, 0.1), 0],
        size: r,
        hide: !0
      });
  return k;
}
function checkBetweenRects(o, t, e, r) {
  return e === "horizontal" ? Math.abs(o.right - t.left) <= r || Math.abs(o.left - t.right) <= r || o.left <= t.right && t.left <= o.right : e === "vertical" ? Math.abs(o.bottom - t.top) <= r || Math.abs(o.top - t.bottom) <= r || o.top <= t.bottom && t.top <= o.bottom : !0;
}
function getElementGuidelines(o) {
  var t = o.state, e = o.props.elementGuidelines, r = e === void 0 ? [] : e;
  if (!r.length)
    return t.elementRects = [], [];
  var D = (t.elementRects || []).filter(function(V) {
    return !V.refresh;
  }), N = r.map(function(V) {
    return isObject$2(V) && "element" in V ? __assign$1(__assign$1({}, V), {
      element: getRefTarget(V.element, !0)
    }) : {
      element: getRefTarget(V, !0)
    };
  }).filter(function(V) {
    return V.element;
  }), k = diff(D.map(function(V) {
    return V.element;
  }), N.map(function(V) {
    return V.element;
  })), $ = k.maintained, G = k.added, U = [];
  $.forEach(function(V) {
    var Y = V[0], W = V[1];
    U[W] = D[Y];
  }), getSnapElementRects(o, G.map(function(V) {
    return N[V];
  })).map(function(V, Y) {
    U[G[Y]] = V;
  }), t.elementRects = U;
  var z = getSnapDirections(o.props.elementSnapDirections), X = [];
  return U.forEach(function(V) {
    var Y = V.element, W = V.top, q = W === void 0 ? z.top : W, K = V.left, Z = K === void 0 ? z.left : K, J = V.right, Q = J === void 0 ? z.right : J, et = V.bottom, it = et === void 0 ? z.bottom : et, tt = V.center, nt = tt === void 0 ? z.center : tt, st = V.middle, at = st === void 0 ? z.middle : st, ut = V.className, ht = V.rect, dt = splitSnapDirectionPoses({
      top: q,
      right: Q,
      left: Z,
      bottom: it,
      center: nt,
      middle: at
    }, ht), pt = dt.horizontal, _t = dt.vertical, mt = ht.top, yt = ht.left, Tt = ht.right - yt, Pt = ht.bottom - mt, St = [Tt, Pt];
    _t.forEach(function(gt) {
      X.push({
        type: "vertical",
        element: Y,
        pos: [throttle(gt, 0.1), mt],
        size: Pt,
        sizes: St,
        className: ut,
        elementRect: V
      });
    }), pt.forEach(function(gt) {
      X.push({
        type: "horizontal",
        element: Y,
        pos: [yt, throttle(gt, 0.1)],
        size: Tt,
        sizes: St,
        className: ut,
        elementRect: V
      });
    });
  }), X;
}
function getObjectGuidelines(o, t) {
  return o ? o.map(function(e) {
    var r = isObject$2(e) ? e : {
      pos: e
    }, D = r.pos;
    return isNumber(D) ? r : __assign$1(__assign$1({}, r), {
      pos: convertUnitSize(D, t)
    });
  }) : [];
}
function getDefaultGuidelines(o, t, e, r, D, N, k) {
  D === void 0 && (D = 0), N === void 0 && (N = 0), k === void 0 && (k = {
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  });
  var $ = [], G = k.left, U = k.top, z = k.bottom, X = k.right, V = e + X - G, Y = r + z - U;
  return getObjectGuidelines(o, Y).forEach(function(W) {
    $.push({
      type: "horizontal",
      pos: [G, throttle(W.pos - N + U, 0.1)],
      size: V,
      className: W.className
    });
  }), getObjectGuidelines(t, V).forEach(function(W) {
    $.push({
      type: "vertical",
      pos: [throttle(W.pos - D + G, 0.1), U],
      size: Y,
      className: W.className
    });
  }), $;
}
function getSnapElementRects(o, t) {
  if (!t.length)
    return [];
  var e = o.state, r = e.containerClientRect, D = e.rootMatrix, N = e.is3d, k = e.offsetDelta, $ = N ? 4 : 3, G = calculateContainerPos(D, r, $), U = G[0], z = G[1];
  return t.map(function(X) {
    var V = X.element.getBoundingClientRect(), Y = V.left - U - k[0], W = V.top - z - k[1], q = W + V.height, K = Y + V.width, Z = calculateInversePosition(D, [Y, W], $), J = Z[0], Q = Z[1], et = calculateInversePosition(D, [K, q], $), it = et[0], tt = et[1];
    return __assign$1(__assign$1({}, X), {
      rect: {
        left: J,
        right: it,
        top: Q,
        bottom: tt,
        center: (J + it) / 2,
        middle: (Q + tt) / 2
      }
    });
  });
}
function checkSnapInfo(o) {
  var t = o.state, e = t.container, r = o.props.snapContainer || e;
  if (t.snapContainer === r && t.guidelines && t.guidelines.length)
    return !1;
  var D = t.containerClientRect, N = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  };
  if (e !== r) {
    var k = getRefTarget(r, !0);
    if (k) {
      var $ = getClientRect(k), G = getDragDistByState(t, [$.left - D.left, $.top - D.top]), U = getDragDistByState(t, [$.right - D.right, $.bottom - D.bottom]);
      N.left = throttle(G[0], 1e-5), N.top = throttle(G[1], 1e-5), N.right = throttle(U[0], 1e-5), N.bottom = throttle(U[1], 1e-5);
    }
  }
  return t.snapContainer = r, t.snapOffset = N, t.guidelines = getTotalGuidelines(o), t.enableSnap = !0, !0;
}
function getNextFixedPoses(o, t, e, r, D, N) {
  var k = calculatePoses(o, t, e, N ? 4 : 3), $ = getPosByDirection(k, r);
  return getAbsolutePoses(k, minus(D, $));
}
function getSizeOffsetInfo(o, t, e, r, D, N) {
  var k = N.fixedDirection, $ = getCheckSnapDirections(e, k, r), G = getCheckInnerBoundLineInfos(o, t, e, r), U = __spreadArray(__spreadArray([], getSnapBoundInfo(o, t, $, r, D, N), !0), getInnerBoundInfo(o, G, N), !0), z = getNearOffsetInfo(U, 0), X = getNearOffsetInfo(U, 1);
  return {
    width: {
      isBound: z.isBound,
      offset: z.offset[0]
    },
    height: {
      isBound: X.isBound,
      offset: X.offset[1]
    }
  };
}
function recheckSizeByTwoDirection(o, t, e, r, D, N, k, $, G) {
  var U = getPosByDirection(t, k), z = checkMoveableSnapBounds(o, $, {
    vertical: [U[0]],
    horizontal: [U[1]]
  }), X = z.horizontal.offset, V = z.vertical.offset;
  if (throttle(V, FLOAT_POINT_NUM) || throttle(X, FLOAT_POINT_NUM)) {
    var Y = getDragDist({
      datas: G,
      distX: -V,
      distY: -X
    }), W = Y[0], q = Y[1], K = Math.min(D || 1 / 0, e + k[0] * W), Z = Math.min(N || 1 / 0, r + k[1] * q);
    return [K - e, Z - r];
  }
  return [0, 0];
}
function checkSizeDist(o, t, e, r, D, N, k, $) {
  for (var G = getAbsolutePosesByState(o.state), U = o.props.keepRatio, z = 0, X = 0, V = 0; V < 2; ++V) {
    var Y = t(z, X), W = getSizeOffsetInfo(o, Y, D, U, k, $), q = W.width, K = W.height, Z = q.isBound, J = K.isBound, Q = q.offset, et = K.offset;
    if (V === 1 && (Z || (Q = 0), J || (et = 0)), V === 0 && k && !Z && !J)
      return [0, 0];
    if (U) {
      var it = Math.abs(Q) * (e ? 1 / e : 1), tt = Math.abs(et) * (r ? 1 / r : 1), nt = Z && J ? it < tt : J || !Z && it < tt;
      nt ? Q = e * et / r : et = r * Q / e;
    }
    z += Q, X += et;
  }
  if (D[0] && D[1]) {
    var st = checkMaxBounds(o, G, D, N, $), at = st.maxWidth, ut = st.maxHeight, ht = recheckSizeByTwoDirection(o, t(z, X).map(function(_t) {
      return _t.map(function(mt) {
        return throttle(mt, FLOAT_POINT_NUM);
      });
    }), e + z, r + X, at, ut, D, k, $), Q = ht[0], et = ht[1];
    z += Q, X += et;
  }
  return [z, X];
}
function checkSnapRotate(o, t, e) {
  if (!hasGuidelines(o, "rotatable"))
    return {
      isSnap: !1,
      rotation: e
    };
  var r = t.pos1, D = t.pos2, N = t.pos3, k = t.pos4, $ = t.origin, G = e * Math.PI / 180, U = [r, D, N, k].map(function(Y) {
    return minus(Y, $);
  }), z = U.map(function(Y) {
    return rotate(Y, G);
  }), X = __spreadArray(__spreadArray([], checkRotateBounds(o, U, z, $, e), !0), checkRotateInnerBounds(o, U, z, $, e), !0);
  X.sort(function(Y, W) {
    return Math.abs(Y - e) - Math.abs(W - e);
  });
  var V = X.length > 0;
  return {
    isSnap: V,
    rotation: V ? X[0] : e
  };
}
function checkSnapResize(o, t, e, r, D, N, k) {
  if (!hasGuidelines(o, "resizable"))
    return [0, 0];
  var $ = k.fixedDirection, G = k.nextAllMatrix, U = o.state, z = U.allMatrix, X = U.is3d;
  return checkSizeDist(o, function(V, Y) {
    return getNextFixedPoses(G || z, t + V, e + Y, $, D, X);
  }, t, e, r, D, N, k);
}
function checkSnapScale(o, t, e, r, D) {
  if (!hasGuidelines(o, "scalable"))
    return [0, 0];
  var N = D.startOffsetWidth, k = D.startOffsetHeight, $ = D.fixedPosition, G = D.fixedDirection, U = D.is3d, z = checkSizeDist(o, function(X, V) {
    return getNextFixedPoses(scaleMatrix(D, plus(t, [X / N, V / k])), N, k, G, $, U);
  }, N, k, e, $, r, D);
  return [z[0] / N, z[1] / k];
}
function startCheckSnapDrag(o, t) {
  t.absolutePoses = getAbsolutePosesByState(o.state);
}
function getSnapGuidelines(o) {
  var t = [];
  return o.forEach(function(e) {
    e.guidelineInfos.forEach(function(r) {
      var D = r.guideline;
      t.indexOf(D) > -1 || t.push(D);
    });
  }), t;
}
function addBoundGuidelines(o, t, e, r, D, N) {
  var k = checkBoundPoses(getBounds(o, N), t, e), $ = k.vertical, G = k.horizontal;
  $.forEach(function(V) {
    V.isBound && r.push({
      type: "bounds",
      pos: V.pos
    });
  }), G.forEach(function(V) {
    V.isBound && D.push({
      type: "bounds",
      pos: V.pos
    });
  });
  var U = checkInnerBoundPoses(o), z = U.vertical, X = U.horizontal;
  z.forEach(function(V) {
    findIndex(r, function(Y) {
      var W = Y.type, q = Y.pos;
      return W === "bounds" && q === V;
    }) >= 0 || r.push({
      type: "bounds",
      pos: V
    });
  }), X.forEach(function(V) {
    findIndex(D, function(Y) {
      var W = Y.type, q = Y.pos;
      return W === "bounds" && q === V;
    }) >= 0 || D.push({
      type: "bounds",
      pos: V
    });
  });
}
var directionCondition$2 = getDirectionCondition("", ["resizable", "scalable"]), Snappable = {
  name: "snappable",
  dragRelation: "strong",
  props: ["snappable", "snapContainer", "snapDirections", "elementSnapDirections", "snapGap", "snapGridWidth", "snapGridHeight", "isDisplaySnapDigit", "isDisplayInnerSnapDigit", "snapDigit", "snapThreshold", "snapRenderThreshold", "horizontalGuidelines", "verticalGuidelines", "elementGuidelines", "bounds", "innerBounds", "snapDistFormat", "maxSnapElementGuidelineDistance", "maxSnapElementGapDistance"],
  events: ["snap"],
  css: [`:host {
--bounds-color: #d66;
}
.guideline {
pointer-events: none;
z-index: 2;
}
.guideline.bounds {
background: #d66;
background: var(--bounds-color);
}
.guideline-group {
position: absolute;
top: 0;
left: 0;
}
.guideline-group .size-value {
position: absolute;
color: #f55;
font-size: 12px;
font-size: calc(12px * var(--zoom));
font-weight: bold;
}
.guideline-group.horizontal .size-value {
transform-origin: 50% 100%;
transform: translateX(-50%);
left: 50%;
bottom: 5px;
bottom: calc(2px + 3px * var(--zoom));
}
.guideline-group.vertical .size-value {
transform-origin: 0% 50%;
top: 50%;
transform: translateY(-50%);
left: 5px;
left: calc(2px + 3px * var(--zoom));
}
.guideline.gap {
background: #f55;
}
.size-value.gap {
color: #f55;
}
`],
  render: function(o, t) {
    var e = o.state, r = e.top, D = e.left, N = e.pos1, k = e.pos2, $ = e.pos3, G = e.pos4, U = e.snapRenderInfo, z = o.props.snapRenderThreshold, X = z === void 0 ? 1 : z;
    if (!U || !U.render || !hasGuidelines(o, ""))
      return [];
    e.guidelines = getTotalGuidelines(o);
    var V = Math.min(N[0], k[0], $[0], G[0]), Y = Math.min(N[1], k[1], $[1], G[1]), W = U.externalPoses || [], q = getAbsolutePosesByState(o.state), K = [], Z = [], J = [], Q = [], et = [], it = getRect(q), tt = it.width, nt = it.height, st = it.top, at = it.left, ut = it.bottom, ht = it.right, dt = {
      left: at,
      right: ht,
      top: st,
      bottom: ut,
      center: (at + ht) / 2,
      middle: (st + ut) / 2
    }, pt = W.length > 0, _t = pt ? getRect(W) : {};
    if (!U.request) {
      if (U.direction && et.push(getSnapInfosByDirection(o, q, U.direction, X)), U.snap) {
        var mt = getRect(q);
        U.center && (mt.middle = (mt.top + mt.bottom) / 2, mt.center = (mt.left + mt.right) / 2), et.push(checkSnaps(o, mt, X));
      }
      pt && (U.center && (_t.middle = (_t.top + _t.bottom) / 2, _t.center = (_t.left + _t.right) / 2), et.push(checkSnaps(o, _t, X))), et.forEach(function(St) {
        var gt = St.vertical.posInfos, bt = St.horizontal.posInfos;
        K.push.apply(K, gt.filter(function(At) {
          var Rt = At.guidelineInfos;
          return Rt.some(function(Nt) {
            var Mt = Nt.guideline;
            return !Mt.hide;
          });
        }).map(function(At) {
          return {
            type: "snap",
            pos: At.pos
          };
        })), Z.push.apply(Z, bt.filter(function(At) {
          var Rt = At.guidelineInfos;
          return Rt.some(function(Nt) {
            var Mt = Nt.guideline;
            return !Mt.hide;
          });
        }).map(function(At) {
          return {
            type: "snap",
            pos: At.pos
          };
        })), J.push.apply(J, getSnapGuidelines(gt)), Q.push.apply(Q, getSnapGuidelines(bt));
      });
    }
    addBoundGuidelines(o, [at, ht], [st, ut], K, Z), pt && addBoundGuidelines(o, [_t.left, _t.right], [_t.top, _t.bottom], K, Z, U.externalBounds);
    var yt = __spreadArray(__spreadArray([], J, !0), Q, !0), Tt = yt.filter(function(St) {
      return St.element && !St.gapRects;
    }), Pt = yt.filter(function(St) {
      return St.gapRects;
    }).sort(function(St, gt) {
      return St.gap - gt.gap;
    });
    return triggerEvent(o, "onSnap", {
      guidelines: yt.filter(function(St) {
        var gt = St.element;
        return !gt;
      }),
      elements: Tt,
      gaps: Pt
    }, !0), __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], renderDashedGuidelines(o, Tt, [V, Y], dt, t), !0), renderGapGuidelines(o, Pt, [V, Y], dt, t), !0), renderGuidelines(o, "horizontal", Q, [D, r], dt, t), !0), renderGuidelines(o, "vertical", J, [D, r], dt, t), !0), renderSnapPoses(o, "horizontal", Z, V, r, tt, 0, t), !0), renderSnapPoses(o, "vertical", K, Y, D, nt, 1, t), !0);
  },
  dragStart: function(o, t) {
    o.state.snapRenderInfo = {
      request: t.isRequest,
      snap: !0,
      center: !0
    }, checkSnapInfo(o);
  },
  drag: function(o) {
    var t = o.state;
    checkSnapInfo(o) || (t.guidelines = getTotalGuidelines(o)), t.snapRenderInfo && (t.snapRenderInfo.render = !0);
  },
  pinchStart: function(o) {
    this.unset(o);
  },
  dragEnd: function(o) {
    this.unset(o);
  },
  dragControlCondition: function(o, t) {
    if (directionCondition$2(o, t) || dragControlCondition(o, t))
      return !0;
    if (!t.isRequest && t.inputEvent)
      return hasClass(t.inputEvent.target, prefix("snap-control"));
  },
  dragControlStart: function(o) {
    o.state.snapRenderInfo = null, checkSnapInfo(o);
  },
  dragControl: function(o) {
    this.drag(o);
  },
  dragControlEnd: function(o) {
    this.unset(o);
  },
  dragGroupStart: function(o, t) {
    this.dragStart(o, t);
  },
  dragGroup: function(o) {
    this.drag(o);
  },
  dragGroupEnd: function(o) {
    this.unset(o);
  },
  dragGroupControlStart: function(o) {
    o.state.snapRenderInfo = null, checkSnapInfo(o);
  },
  dragGroupControl: function(o) {
    this.drag(o);
  },
  dragGroupControlEnd: function(o) {
    this.unset(o);
  },
  unset: function(o) {
    var t = o.state;
    t.enableSnap = !1, t.guidelines = [], t.snapRenderInfo = null, t.elementRects = [];
  }
};
function renderDirectionControlsByInfos(o, t, e, r) {
  var D = o.getState(), N = D.renderPoses, k = D.rotation, $ = D.direction, G = getProps(o.props, t).zoom, U = $ > 0 ? 1 : -1, z = k / Math.PI * 180, X = {}, V = o.renderState;
  V.renderDirectionMap || (V.renderDirectionMap = {});
  var Y = V.renderDirectionMap;
  return e.forEach(function(W) {
    var q = W.dir;
    X[q] = !0;
  }), e.map(function(W) {
    var q = W.data, K = W.classNames, Z = W.dir, J = DIRECTION_INDEXES[Z];
    if (!J || !X[Z])
      return null;
    Y[Z] = !0;
    var Q = (throttle(z, 15) + U * DIRECTION_ROTATIONS[Z] + 720) % 180, et = {};
    return getKeys(q).forEach(function(it) {
      et["data-".concat(it)] = q[it];
    }), r.createElement("div", __assign$1({
      className: prefix.apply(void 0, __spreadArray(["control", "direction", Z, t], K, !1)),
      "data-rotation": Q,
      "data-direction": Z
    }, et, {
      key: "direction-".concat(Z),
      style: getControlTransform.apply(void 0, __spreadArray([k, G], J.map(function(it) {
        return N[it];
      }), !1))
    }));
  });
}
function renderDirectionControls(o, t, e, r) {
  var D = getProps(o.props, e), N = D.renderDirections, k = N === void 0 ? t : N, $ = D.displayAroundControls;
  if (!k)
    return [];
  var G = k === !0 ? DIRECTIONS : k;
  return __spreadArray(__spreadArray([], $ ? renderAroundControls(o, r, e, G) : [], !0), renderDirectionControlsByInfos(o, e, G.map(function(U) {
    return {
      data: {},
      classNames: [],
      dir: U
    };
  }), r), !0);
}
function renderLine(o, t, e, r, D, N) {
  for (var k = [], $ = 6; $ < arguments.length; $++)
    k[$ - 6] = arguments[$];
  var G = getRad$1(e, r), U = t ? throttle(G / Math.PI * 180, 15) % 180 : -1;
  return o.createElement("div", {
    key: "line-".concat(N),
    className: prefix.apply(void 0, __spreadArray(["line", "direction", t ? "edge" : "", t], k, !1)),
    "data-rotation": U,
    "data-line-key": N,
    "data-direction": t,
    style: getLineStyle(e, r, D, G)
  });
}
function renderEdgeLines(o, t, e, r, D) {
  var N = e === !0 ? DIRECTIONS4 : e;
  return N.map(function(k, $) {
    var G = DIRECTION_INDEXES[k], U = G[0], z = G[1];
    if (z != null)
      return renderLine(o, k, r[U], r[z], D, "".concat(t, "Edge").concat($), t);
  }).filter(Boolean);
}
function getRenderDirections(o) {
  return function(t, e) {
    var r = getProps(t.props, o).edge;
    return r && (r === !0 || r.length) ? __spreadArray(__spreadArray([], renderEdgeLines(e, o, r, t.getState().renderPoses, t.props.zoom), !0), renderDiagonalDirections(t, o, e), !0) : renderAllDirections(t, o, e);
  };
}
function renderAllDirections(o, t, e) {
  return renderDirectionControls(o, DIRECTIONS, t, e);
}
function renderDiagonalDirections(o, t, e) {
  return renderDirectionControls(o, ["nw", "ne", "sw", "se"], t, e);
}
function renderAroundControls(o, t, e, r) {
  var D = o.renderState;
  D.renderDirectionMap || (D.renderDirectionMap = {});
  var N = o.getState(), k = N.renderPoses, $ = N.rotation, G = N.direction, U = D.renderDirectionMap, z = o.props.zoom, X = G > 0 ? 1 : -1, V = $ / Math.PI * 180;
  return (r || getKeys(U)).map(function(Y) {
    var W = DIRECTION_INDEXES[Y];
    if (!W)
      return null;
    var q = (throttle(V, 15) + X * DIRECTION_ROTATIONS[Y] + 720) % 180, K = ["around-control"];
    return e && K.push("direction", e), t.createElement("div", {
      className: prefix.apply(void 0, K),
      "data-rotation": q,
      "data-direction": Y,
      key: "direction-around-".concat(Y),
      style: getControlTransform.apply(void 0, __spreadArray([$, z], W.map(function(Z) {
        return k[Z];
      }), !1))
    });
  });
}
var Draggable = {
  name: "draggable",
  props: ["draggable", "throttleDrag", "throttleDragRotate", "startDragRotate", "edgeDraggable"],
  events: ["dragStart", "drag", "dragEnd", "dragGroupStart", "dragGroup", "dragGroupEnd"],
  requestStyle: function() {
    return ["left", "top", "right", "bottom"];
  },
  requestChildStyle: function() {
    return ["left", "top", "right", "bottom"];
  },
  render: function(o, t) {
    var e = o.props, r = e.throttleDragRotate, D = e.zoom, N = o.getState(), k = N.dragInfo, $ = N.beforeOrigin;
    if (!r || !k)
      return [];
    var G = k.dist;
    if (!G[0] && !G[1])
      return [];
    var U = getDistSize(G), z = getRad$1(G, [0, 0]);
    return [t.createElement("div", {
      className: prefix("line", "horizontal", "dragline", "dashed"),
      key: "dragRotateGuideline",
      style: {
        width: "".concat(U, "px"),
        transform: "translate(".concat($[0], "px, ").concat($[1], "px) rotate(").concat(z, "rad) scaleY(").concat(D, ")")
      }
    })];
  },
  dragStart: function(o, t) {
    var e = t.datas, r = t.parentEvent, D = t.parentGesto, N = o.state, k = N.gestos, $ = N.style;
    if (k.draggable)
      return !1;
    k.draggable = D || o.targetGesto, e.datas = {}, e.left = parseFloat($.left || "") || 0, e.top = parseFloat($.top || "") || 0, e.bottom = parseFloat($.bottom || "") || 0, e.right = parseFloat($.right || "") || 0, e.startValue = [0, 0], setDragStart(o, t), setDefaultTransformIndex(t, "translate"), startCheckSnapDrag(o, e), e.prevDist = [0, 0], e.prevBeforeDist = [0, 0], e.isDrag = !1, e.deltaOffset = [0, 0];
    var G = fillParams(o, t, __assign$1({
      set: function(z) {
        e.startValue = z;
      }
    }, fillTransformStartEvent(t))), U = r || triggerEvent(o, "onDragStart", G);
    return U !== !1 ? (e.isDrag = !0, o.state.dragInfo = {
      startRect: o.getRect(),
      dist: [0, 0]
    }) : (k.draggable = null, e.isPinch = !1), e.isDrag ? G : !1;
  },
  drag: function(o, t) {
    if (t) {
      resolveTransformEvent(t, "translate");
      var e = t.datas, r = t.parentEvent, D = t.parentFlag, N = t.isPinch, k = t.isRequest, $ = t.deltaOffset, G = t.distX, U = t.distY, z = e.isDrag, X = e.prevDist, V = e.prevBeforeDist, Y = e.startValue;
      if (z) {
        $ && (G += $[0], U += $[1]);
        var W = o.props, q = W.parentMoveable, K = r ? 0 : W.throttleDrag || 0, Z = r ? 0 : W.throttleDragRotate || 0, J = 0, Q = !1, et = !1, it = !1, tt = !1;
        if (!r && Z > 0 && (G || U)) {
          var nt = W.startDragRotate || 0, st = throttle(nt + getRad$1([0, 0], [G, U]) * 180 / Math.PI, Z) - nt, at = U * Math.abs(Math.cos((st - 90) / 180 * Math.PI)), ut = G * Math.abs(Math.cos(st / 180 * Math.PI)), ht = getDistSize([ut, at]);
          J = st * Math.PI / 180, G = ht * Math.cos(J), U = ht * Math.sin(J);
        }
        if (!N && !r && !D) {
          var dt = checkSnapBoundsDrag(o, G, U, Z, k || $, e), pt = dt[0], _t = dt[1];
          Q = pt.isSnap, et = pt.isBound, it = _t.isSnap, tt = _t.isBound;
          var mt = pt.offset, yt = _t.offset;
          G += mt, U += yt;
        }
        var Tt = plus(getBeforeDragDist({
          datas: e,
          distX: G,
          distY: U
        }), Y), Pt = plus(getTransformDist({
          datas: e,
          distX: G,
          distY: U
        }), Y);
        throttleArray(Pt, TINY_NUM), throttleArray(Tt, TINY_NUM), Z || (!Q && !et && (Pt[0] = throttle(Pt[0], K), Tt[0] = throttle(Tt[0], K)), !it && !tt && (Pt[1] = throttle(Pt[1], K), Tt[1] = throttle(Tt[1], K)));
        var St = minus(Tt, Y), gt = minus(Pt, Y), bt = minus(gt, X), At = minus(St, V);
        e.prevDist = gt, e.prevBeforeDist = St, e.passDelta = bt, e.passDist = gt;
        var Rt = e.left + St[0], Nt = e.top + St[1], Mt = e.right - St[0], ft = e.bottom - St[1], Ft = convertTransformFormat(e, "translate(".concat(Pt[0], "px, ").concat(Pt[1], "px)"), "translate(".concat(gt[0], "px, ").concat(gt[1], "px)"));
        if (fillOriginalTransform(t, Ft), o.state.dragInfo.dist = r ? [0, 0] : gt, !(!r && !q && bt.every(function(Ht) {
          return !Ht;
        }) && At.some(function(Ht) {
          return !Ht;
        }))) {
          var Dt = o.state, Vt = Dt.width, Bt = Dt.height, Et = fillParams(o, t, __assign$1({
            transform: Ft,
            dist: gt,
            delta: bt,
            translate: Pt,
            beforeDist: St,
            beforeDelta: At,
            beforeTranslate: Tt,
            left: Rt,
            top: Nt,
            right: Mt,
            bottom: ft,
            width: Vt,
            height: Bt,
            isPinch: N
          }, fillCSSObject({
            transform: Ft
          }, t)));
          return !r && triggerEvent(o, "onDrag", Et), Et;
        }
      }
    }
  },
  dragAfter: function(o, t) {
    var e = t.datas, r = e.deltaOffset;
    return r[0] || r[1] ? (e.deltaOffset = [0, 0], this.drag(o, __assign$1(__assign$1({}, t), {
      deltaOffset: r
    }))) : !1;
  },
  dragEnd: function(o, t) {
    var e = t.parentEvent, r = t.datas;
    if (o.state.dragInfo = null, !!r.isDrag) {
      r.isDrag = !1;
      var D = fillEndParams(o, t, {});
      return !e && triggerEvent(o, "onDragEnd", D), D;
    }
  },
  dragGroupStart: function(o, t) {
    var e = t.datas, r = t.clientX, D = t.clientY, N = this.dragStart(o, t);
    if (!N)
      return !1;
    var k = triggerChildGesto(o, this, "dragStart", [r || 0, D || 0], t, !1, "draggable"), $ = __assign$1(__assign$1({}, N), {
      targets: o.props.targets,
      events: k
    }), G = triggerEvent(o, "onDragGroupStart", $);
    return e.isDrag = G !== !1, e.isDrag ? N : !1;
  },
  dragGroup: function(o, t) {
    var e = t.datas;
    if (e.isDrag) {
      var r = this.drag(o, t), D = t.datas.passDelta, N = triggerChildGesto(o, this, "drag", D, t, !1, "draggable");
      if (r) {
        var k = __assign$1({
          targets: o.props.targets,
          events: N
        }, r);
        return triggerEvent(o, "onDragGroup", k), k;
      }
    }
  },
  dragGroupEnd: function(o, t) {
    var e = t.isDrag, r = t.datas;
    if (r.isDrag) {
      this.dragEnd(o, t);
      var D = triggerChildGesto(o, this, "dragEnd", [0, 0], t, !1, "draggable");
      return triggerEvent(o, "onDragGroupEnd", fillEndParams(o, t, {
        targets: o.props.targets,
        events: D
      })), e;
    }
  },
  /**
   * @method Moveable.Draggable#request
   * @param {object} [e] - the draggable's request parameter
   * @param {number} [e.x] - x position
   * @param {number} [e.y] - y position
   * @param {number} [e.deltaX] - X number to move
   * @param {number} [e.deltaY] - Y number to move
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * // Use Relative Value
   * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
   * // Use Absolute Value
   * moveable.request("draggable", { x: 200, y: 100 }, true);
   *
   * // requestStart
   * const requester = moveable.request("draggable");
   *
   * // request
   * // Use Relative Value
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * // Use Absolute Value
   * moveable.request("draggable", { x: 200, y: 100 });
   * moveable.request("draggable", { x: 220, y: 100 });
   * moveable.request("draggable", { x: 240, y: 100 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function(o) {
    var t = {}, e = o.getRect(), r = 0, D = 0;
    return {
      isControl: !1,
      requestStart: function() {
        return {
          datas: t
        };
      },
      request: function(N) {
        return "x" in N ? r = N.x - e.left : "deltaX" in N && (r += N.deltaX), "y" in N ? D = N.y - e.top : "deltaY" in N && (D += N.deltaY), {
          datas: t,
          distX: r,
          distY: D
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  },
  unset: function(o) {
    o.state.gestos.draggable = null, o.state.dragInfo = null;
  }
}, directionCondition$1 = getDirectionCondition("resizable"), Resizable = {
  name: "resizable",
  ableGroup: "size",
  canPinch: !0,
  props: ["resizable", "throttleResize", "renderDirections", "displayAroundControls", "keepRatio", "resizeFormat", "keepRatioFinally", "edge", "checkResizableError"],
  events: ["resizeStart", "beforeResize", "resize", "resizeEnd", "resizeGroupStart", "beforeResizeGroup", "resizeGroup", "resizeGroupEnd"],
  render: getRenderDirections("resizable"),
  dragControlCondition: directionCondition$1,
  viewClassName: getDirectionViewClassName("resizable"),
  dragControlStart: function(o, t) {
    var e, r = t.inputEvent, D = t.isPinch, N = t.isGroup, k = t.parentDirection, $ = t.parentGesto, G = t.datas, U = t.parentFixedDirection, z = t.parentEvent, X = getTotalDirection(k, D, r, G), V = o.state, Y = V.target, W = V.width, q = V.height, K = V.gestos;
    if (!X || !Y || K.resizable)
      return !1;
    K.resizable = $ || o.controlGesto, !D && setDragStart(o, t), G.datas = {}, G.direction = X, G.startOffsetWidth = W, G.startOffsetHeight = q, G.prevWidth = 0, G.prevHeight = 0, G.minSize = [0, 0], G.startWidth = V.inlineCSSWidth || V.cssWidth, G.startHeight = V.inlineCSSHeight || V.cssHeight, G.maxSize = [1 / 0, 1 / 0], N || (G.minSize = [V.minOffsetWidth, V.minOffsetHeight], G.maxSize = [V.maxOffsetWidth, V.maxOffsetHeight]);
    var Z = o.props.transformOrigin || "% %";
    G.transformOrigin = Z && isString(Z) ? Z.split(" ") : Z, G.startOffsetMatrix = V.offsetMatrix, G.startTransformOrigin = V.transformOrigin, G.isWidth = (e = t == null ? void 0 : t.parentIsWidth) !== null && e !== void 0 ? e : !X[0] && !X[1] || X[0] || !X[1];
    function J(at) {
      G.ratio = at && isFinite(at) ? at : 0;
    }
    G.startPositions = getAbsolutePosesByState(o.state);
    function Q(at) {
      G.fixedDirection = at, G.fixedPosition = getPosByDirection(G.startPositions, at);
    }
    function et(at) {
      var ut = o.state, ht = ut.width, dt = ut.height;
      G.fixedPosition = at, G.fixedDirection = getDirectionByPos(at, ht, dt);
    }
    function it(at) {
      G.minSize = [convertUnitSize("".concat(at[0]), 0) || 0, convertUnitSize("".concat(at[1]), 0) || 0];
    }
    function tt(at) {
      var ut = [at[0] || 1 / 0, at[1] || 1 / 0];
      (!isNumber(ut[0]) || isFinite(ut[0])) && (ut[0] = convertUnitSize("".concat(ut[0]), 0) || 1 / 0), (!isNumber(ut[1]) || isFinite(ut[1])) && (ut[1] = convertUnitSize("".concat(ut[1]), 0) || 1 / 0), G.maxSize = ut;
    }
    J(W / q), Q(U || [-X[0], -X[1]]), G.setFixedDirection = Q, G.setFixedPosition = et, G.setMin = it, G.setMax = tt;
    var nt = fillParams(o, t, {
      direction: X,
      startRatio: G.ratio,
      set: function(at) {
        var ut = at[0], ht = at[1];
        G.startWidth = ut, G.startHeight = ht;
      },
      setMin: it,
      setMax: tt,
      setRatio: J,
      setFixedDirection: Q,
      setFixedPosition: et,
      setOrigin: function(at) {
        G.transformOrigin = at;
      },
      dragStart: Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))
    }), st = z || triggerEvent(o, "onResizeStart", nt);
    return G.startFixedDirection = G.fixedDirection, G.startFixedPosition = G.fixedPosition, st !== !1 && (G.isResize = !0, o.state.snapRenderInfo = {
      request: t.isRequest,
      direction: X
    }), G.isResize ? nt : !1;
  },
  dragControl: function(o, t) {
    var e, r = t.datas, D = t.parentFlag, N = t.isPinch, k = t.parentKeepRatio, $ = t.dragClient, G = t.parentDist, U = t.isRequest, z = t.isGroup, X = t.parentEvent, V = t.resolveMatrix, Y = r.isResize, W = r.transformOrigin, q = r.startWidth, K = r.startHeight, Z = r.prevWidth, J = r.prevHeight, Q = r.minSize, et = r.maxSize, it = r.ratio, tt = r.startOffsetWidth, nt = r.startOffsetHeight, st = r.isWidth;
    if (!Y)
      return;
    if (V) {
      var at = o.state.is3d, ut = r.startOffsetMatrix, ht = r.startTransformOrigin, dt = at ? 4 : 3, pt = parseMat(getNextTransforms(t)), _t = Math.sqrt(pt.length);
      dt !== _t && (pt = convertDimension(pt, _t, dt));
      var mt = getNextMatrix(ut, pt, ht, dt), yt = calculatePoses(mt, tt, nt, dt);
      r.startPositions = yt, r.nextTargetMatrix = pt, r.nextAllMatrix = mt;
    }
    var Tt = getProps(o.props, "resizable"), Pt = Tt.resizeFormat, St = Tt.throttleResize, gt = St === void 0 ? D ? 0 : 1 : St, bt = Tt.parentMoveable, At = Tt.keepRatioFinally, Rt = r.direction, Nt = Rt, Mt = 0, ft = 0;
    !Rt[0] && !Rt[1] && (Nt = [1, 1]);
    var Ft = it && (k ?? Tt.keepRatio) || !1;
    function Dt() {
      var he = r.fixedDirection, _e = getOffsetSizeDist(Nt, Ft, r, t);
      Mt = _e.distWidth, ft = _e.distHeight;
      var ve = Nt[0] - he[0] || Ft ? Math.max(tt + Mt, TINY_NUM) : tt, de = Nt[1] - he[1] || Ft ? Math.max(nt + ft, TINY_NUM) : nt;
      return Ft && tt && nt && (st ? de = ve / it : ve = de * it), [ve, de];
    }
    var Vt = Dt(), Bt = Vt[0], Et = Vt[1];
    X || (r.setFixedDirection(r.fixedDirection), triggerEvent(o, "onBeforeResize", fillParams(o, t, {
      startFixedDirection: r.startFixedDirection,
      startFixedPosition: r.startFixedPosition,
      setFixedDirection: function(he) {
        var _e;
        return r.setFixedDirection(he), _e = Dt(), Bt = _e[0], Et = _e[1], [Bt, Et];
      },
      setFixedPosition: function(he) {
        var _e;
        return r.setFixedPosition(he), _e = Dt(), Bt = _e[0], Et = _e[1], [Bt, Et];
      },
      boundingWidth: Bt,
      boundingHeight: Et,
      setSize: function(he) {
        Bt = he[0], Et = he[1];
      }
    }, !0)));
    var Ht = $;
    $ || (!D && N ? Ht = getAbsolutePosition(o, [0, 0]) : Ht = r.fixedPosition);
    var kt = [0, 0];
    N || (kt = checkSnapResize(o, Bt, Et, Rt, Ht, U, r)), G && (!G[0] && (kt[0] = 0), !G[1] && (kt[1] = 0));
    function wt() {
      var he;
      Pt && (he = Pt([Bt, Et]), Bt = he[0], Et = he[1]), Bt = throttle(Bt, gt), Et = throttle(Et, gt);
    }
    if (Ft) {
      Nt[0] && Nt[1] && kt[0] && kt[1] && (Math.abs(kt[0]) > Math.abs(kt[1]) ? kt[1] = 0 : kt[0] = 0);
      var Lt = !kt[0] && !kt[1];
      Lt && wt(), Nt[0] && !Nt[1] || kt[0] && !kt[1] || Lt && st ? (Bt += kt[0], Et = Bt / it) : (!Nt[0] && Nt[1] || !kt[0] && kt[1] || Lt && !st) && (Et += kt[1], Bt = Et * it);
    } else
      Bt += kt[0], Et += kt[1], Bt = Math.max(0, Bt), Et = Math.max(0, Et);
    e = calculateBoundSize([Bt, Et], Q, et, Ft ? it : !1), Bt = e[0], Et = e[1], wt(), Ft && (z || At) && (st ? Et = Bt / it : Bt = Et * it), Mt = Bt - tt, ft = Et - nt;
    var jt = [Mt - Z, ft - J];
    r.prevWidth = Mt, r.prevHeight = ft;
    var Ct = getResizeDist(o, Bt, Et, Ht, W, r);
    if (!(!bt && jt.every(function(he) {
      return !he;
    }) && Ct.every(function(he) {
      return !he;
    }))) {
      var Wt = Draggable.drag(o, setCustomDrag(t, o.state, Ct, !!N, !1, "draggable")), Jt = Wt.transform, Kt = q + Mt, Se = K + ft, Oe = fillParams(o, t, __assign$1({
        width: Kt,
        height: Se,
        offsetWidth: Math.round(Bt),
        offsetHeight: Math.round(Et),
        startRatio: it,
        boundingWidth: Bt,
        boundingHeight: Et,
        direction: Rt,
        dist: [Mt, ft],
        delta: jt,
        isPinch: !!N,
        drag: Wt
      }, fillAfterTransform({
        style: {
          width: "".concat(Kt, "px"),
          height: "".concat(Se, "px")
        },
        transform: Jt
      }, Wt, t)));
      return !X && triggerEvent(o, "onResize", Oe), Oe;
    }
  },
  dragControlAfter: function(o, t) {
    var e = t.datas, r = e.isResize, D = e.startOffsetWidth, N = e.startOffsetHeight, k = e.prevWidth, $ = e.prevHeight;
    if (!(!r || o.props.checkResizableError === !1)) {
      var G = o.state, U = G.width, z = G.height, X = U - (D + k), V = z - (N + $), Y = Math.abs(X) > 3, W = Math.abs(V) > 3;
      if (Y && (e.startWidth += X, e.startOffsetWidth += X, e.prevWidth += X), W && (e.startHeight += V, e.startOffsetHeight += V, e.prevHeight += V), Y || W)
        return this.dragControl(o, t);
    }
  },
  dragControlEnd: function(o, t) {
    var e = t.datas, r = t.parentEvent;
    if (e.isResize) {
      e.isResize = !1;
      var D = fillEndParams(o, t, {});
      return !r && triggerEvent(o, "onResizeEnd", D), D;
    }
  },
  dragGroupControlCondition: directionCondition$1,
  dragGroupControlStart: function(o, t) {
    var e = t.datas, r = this.dragControlStart(o, __assign$1(__assign$1({}, t), {
      isGroup: !0
    }));
    if (!r)
      return !1;
    var D = fillChildEvents(o, "resizable", t), N = e.startOffsetWidth, k = e.startOffsetHeight;
    function $() {
      var Y = e.minSize;
      D.forEach(function(W) {
        var q = W.datas, K = q.minSize, Z = q.startOffsetWidth, J = q.startOffsetHeight, Q = N * (Z ? K[0] / Z : 0), et = k * (J ? K[1] / J : 0);
        Y[0] = Math.max(Y[0], Q), Y[1] = Math.max(Y[1], et);
      });
    }
    function G() {
      var Y = e.maxSize;
      D.forEach(function(W) {
        var q = W.datas, K = q.maxSize, Z = q.startOffsetWidth, J = q.startOffsetHeight, Q = N * (Z ? K[0] / Z : 0), et = k * (J ? K[1] / J : 0);
        Y[0] = Math.min(Y[0], Q), Y[1] = Math.min(Y[1], et);
      });
    }
    var U = triggerChildAbles(o, this, "dragControlStart", t, function(Y, W) {
      return startChildDist(o, Y, e, W);
    });
    $(), G();
    var z = function(Y) {
      r.setFixedDirection(Y), U.forEach(function(W, q) {
        W.setFixedDirection(Y), startChildDist(o, W.moveable, e, D[q]);
      });
    };
    e.setFixedDirection = z;
    var X = __assign$1(__assign$1({}, r), {
      targets: o.props.targets,
      events: U.map(function(Y) {
        return __assign$1(__assign$1({}, Y), {
          setMin: function(W) {
            Y.setMin(W), $();
          },
          setMax: function(W) {
            Y.setMax(W), G();
          }
        });
      }),
      setFixedDirection: z,
      setMin: function(Y) {
        r.setMin(Y), $();
      },
      setMax: function(Y) {
        r.setMax(Y), G();
      }
    }), V = triggerEvent(o, "onResizeGroupStart", X);
    return e.isResize = V !== !1, e.isResize ? r : !1;
  },
  dragGroupControl: function(o, t) {
    var e = t.datas;
    if (e.isResize) {
      var r = getProps(o.props, "resizable");
      catchEvent(o, "onBeforeResize", function(Y) {
        triggerEvent(o, "onBeforeResizeGroup", fillParams(o, t, __assign$1(__assign$1({}, Y), {
          targets: r.targets
        }), !0));
      });
      var D = this.dragControl(o, __assign$1(__assign$1({}, t), {
        isGroup: !0
      }));
      if (D) {
        var N = D.boundingWidth, k = D.boundingHeight, $ = D.dist, G = r.keepRatio, U = [N / (N - $[0]), k / (k - $[1])], z = e.fixedPosition, X = triggerChildAbles(o, this, "dragControl", t, function(Y, W) {
          var q = calculate(createRotateMatrix(o.rotation / 180 * Math.PI, 3), [W.datas.originalX * U[0], W.datas.originalY * U[1], 1], 3), K = q[0], Z = q[1];
          return __assign$1(__assign$1({}, W), {
            parentDist: null,
            parentScale: U,
            dragClient: plus(z, [K, Z]),
            parentKeepRatio: G
          });
        }), V = __assign$1({
          targets: r.targets,
          events: X
        }, D);
        return triggerEvent(o, "onResizeGroup", V), V;
      }
    }
  },
  dragGroupControlEnd: function(o, t) {
    var e = t.isDrag, r = t.datas;
    if (r.isResize) {
      this.dragControlEnd(o, t);
      var D = triggerChildAbles(o, this, "dragControlEnd", t), N = fillEndParams(o, t, {
        targets: o.props.targets,
        events: D
      });
      return triggerEvent(o, "onResizeGroupEnd", N), e;
    }
  },
  /**
   * @method Moveable.Resizable#request
   * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * // Use Relative Value
   * moveable.request("resizable", { deltaWidth: 10, deltaHeight: 10 }, true);
   *
   * // Use Absolute Value
   * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 }, true);
   *
   * // requestStart
   * const requester = moveable.request("resizable");
   *
   * // request
   * // Use Relative Value
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   *
   * // Use Absolute Value
   * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 });
   * moveable.request("resizable", { offsetWidth: 110, offsetHeight: 100 });
   * moveable.request("resizable", { offsetWidth: 120, offsetHeight: 100 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function(o) {
    var t = {}, e = 0, r = 0, D = o.getRect();
    return {
      isControl: !0,
      requestStart: function(N) {
        var k;
        return {
          datas: t,
          parentDirection: N.direction || [1, 1],
          parentIsWidth: (k = N == null ? void 0 : N.horizontal) !== null && k !== void 0 ? k : !0
        };
      },
      request: function(N) {
        return "offsetWidth" in N ? e = N.offsetWidth - D.offsetWidth : "deltaWidth" in N && (e += N.deltaWidth), "offsetHeight" in N ? r = N.offsetHeight - D.offsetHeight : "deltaHeight" in N && (r += N.deltaHeight), {
          datas: t,
          parentDist: [e, r],
          parentKeepRatio: N.keepRatio
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  },
  unset: function(o) {
    o.state.gestos.resizable = null;
  }
};
function setRotateStartInfo(o, t, e, r, D) {
  var N = o.props.groupable, k = o.state, $ = k.is3d ? 4 : 3, G = t.origin, U = calculatePosition(
    o.state.rootMatrix,
    // TO-DO #710
    minus([G[0], G[1]], N ? [0, 0] : [k.left, k.top]),
    $
  ), z = plus([D.left, D.top], U);
  t.startAbsoluteOrigin = z, t.prevDeg = getRad$1(z, [e, r]) / Math.PI * 180, t.defaultDeg = t.prevDeg, t.prevSnapDeg = 0, t.loop = 0, t.startDist = getDist$2(z, [e, r]);
}
function getAbsoluteDist(o, t, e) {
  var r = e.defaultDeg, D = e.prevDeg, N = D % 360, k = Math.floor(D / 360);
  N < 0 && (N += 360), N > o && N > 270 && o < 90 ? ++k : N < o && N < 90 && o > 270 && --k;
  var $ = t * (k * 360 + o - r);
  return e.prevDeg = r + $, $;
}
function getAbsoluteDistByClient(o, t, e, r) {
  return getAbsoluteDist(getRad$1(r.startAbsoluteOrigin, [o, t]) / Math.PI * 180, e, r);
}
function getRotateInfo(o, t, e, r, D, N) {
  var k = o.props.throttleRotate, $ = k === void 0 ? 0 : k, G = e.prevSnapDeg, U = 0, z = !1;
  if (N) {
    var X = checkSnapRotate(o, t, r);
    z = X.isSnap, U = D + X.rotation;
  }
  z || (U = throttle(D + r, $));
  var V = U - D;
  return e.prevSnapDeg = V, [V - G, V, U];
}
function getRotationPositions(o, t, e) {
  var r = t[0], D = t[1], N = t[2], k = t[3];
  if (o === "none")
    return [];
  if (isArray(o))
    return o.map(function(q) {
      return getRotationPositions(q, [r, D, N, k], e)[0];
    });
  var $ = (o || "top").split("-"), G = $[0], U = $[1], z = [r, D];
  G === "left" ? z = [N, r] : G === "right" ? z = [D, k] : G === "bottom" && (z = [k, N]);
  var X = [(z[0][0] + z[1][0]) / 2, (z[0][1] + z[1][1]) / 2], V = getRotationRad(z, e);
  if (U) {
    var Y = U === "top" || U === "left", W = G === "bottom" || G === "left";
    X = z[Y && !W || !Y && W ? 0 : 1];
  }
  return [[X, V]];
}
function dragControlCondition(o, t) {
  if (t.isRequest)
    return t.requestAble === "rotatable";
  var e = t.inputEvent.target;
  if (hasClass(e, prefix("rotation-control")) || o.props.rotateAroundControls && hasClass(e, prefix("around-control")) || hasClass(e, prefix("control")) && hasClass(e, prefix("rotatable")))
    return !0;
  var r = o.props.rotationTarget;
  return r ? getRefTargets(r, !0).some(function(D) {
    return D ? e === D || e.contains(D) : !1;
  }) : !1;
}
var css = `.rotation {
position: absolute;
height: 40px;
width: 1px;
transform-origin: 50% 100%;
height: calc(40px * var(--zoom));
top: auto;
left: 0;
bottom: 100%;
will-change: transform;
}
.rotation .rotation-line {
display: block;
width: 100%;
height: 100%;
transform-origin: 50% 50%;
}
.rotation .rotation-control {
border-color: #4af;
border-color: var(--moveable-color);
background:#fff;
cursor: alias;
}
:global .view-rotation-dragging, .rotatable.direction.control {
cursor: alias;
}
.rotatable.direction.control.move {
cursor: move;
}
`, Rotatable = {
  name: "rotatable",
  canPinch: !0,
  props: ["rotatable", "rotationPosition", "throttleRotate", "renderDirections", "rotationTarget", "rotateAroundControls", "edge", "resolveAblesWithRotatable", "displayAroundControls"],
  events: ["rotateStart", "beforeRotate", "rotate", "rotateEnd", "rotateGroupStart", "beforeRotateGroup", "rotateGroup", "rotateGroupEnd"],
  css: [css],
  viewClassName: function(o) {
    return o.isDragging("rotatable") ? prefix("view-rotation-dragging") : "";
  },
  render: function(o, t) {
    var e = getProps(o.props, "rotatable"), r = e.rotatable, D = e.rotationPosition, N = e.zoom, k = e.renderDirections, $ = e.rotateAroundControls, G = e.resolveAblesWithRotatable, U = o.getState(), z = U.renderPoses, X = U.direction;
    if (!r)
      return null;
    var V = getRotationPositions(D, z, X), Y = [];
    if (V.forEach(function(Z, J) {
      var Q = Z[0], et = Z[1];
      Y.push(t.createElement("div", {
        key: "rotation".concat(J),
        className: prefix("rotation"),
        style: {
          // tslint:disable-next-line: max-line-length
          transform: "translate(-50%) translate(".concat(Q[0], "px, ").concat(Q[1], "px) rotate(").concat(et, "rad)")
        }
      }, t.createElement("div", {
        className: prefix("line rotation-line"),
        style: {
          transform: "scaleX(".concat(N, ")")
        }
      }), t.createElement("div", {
        className: prefix("control rotation-control"),
        style: {
          transform: "translate(0.5px) scale(".concat(N, ")")
        }
      })));
    }), k) {
      var W = getKeys(G || {}), q = {};
      W.forEach(function(Z) {
        G[Z].forEach(function(J) {
          q[J] = Z;
        });
      });
      var K = [];
      isArray(k) && (K = k.map(function(Z) {
        var J = q[Z];
        return {
          data: J ? {
            resolve: J
          } : {},
          classNames: J ? ["move"] : [],
          dir: Z
        };
      })), Y.push.apply(Y, renderDirectionControlsByInfos(o, "rotatable", K, t));
    }
    return $ && Y.push.apply(Y, renderAroundControls(o, t)), Y;
  },
  dragControlCondition,
  dragControlStart: function(o, t) {
    var e, r, D = t.datas, N = t.clientX, k = t.clientY, $ = t.parentRotate, G = t.parentFlag, U = t.isPinch, z = t.isRequest, X = o.state, V = X.target, Y = X.left, W = X.top, q = X.direction, K = X.beforeDirection, Z = X.targetTransform, J = X.moveableClientRect, Q = X.offsetMatrix, et = X.targetMatrix, it = X.allMatrix, tt = X.width, nt = X.height;
    if (!z && !V)
      return !1;
    var st = o.getRect();
    D.rect = st, D.transform = Z, D.left = Y, D.top = W;
    var at = function(Mt) {
      var ft = o.state, Ft = ft.allMatrix, Dt = ft.is3d, Vt = ft.width, Bt = ft.height, Et = getDirectionByPos(Mt, Vt, Bt);
      D.fixedDirection = Et, D.fixedPosition = calculatePosition(Ft, Mt, Dt ? 4 : 3), bt && bt.setFixedPosition(Mt);
    }, ut = function(Mt) {
      D.fixedDirection = Mt, D.fixedPosition = getDirectionOffset(o, Mt), bt && bt.setFixedDirection(Mt);
    }, ht = N, dt = k;
    if (z || U || G) {
      var pt = $ || 0;
      D.beforeInfo = {
        origin: st.beforeOrigin,
        prevDeg: pt,
        defaultDeg: pt,
        prevSnapDeg: 0,
        startDist: 0
      }, D.afterInfo = __assign$1(__assign$1({}, D.beforeInfo), {
        origin: st.origin
      }), D.absoluteInfo = __assign$1(__assign$1({}, D.beforeInfo), {
        origin: st.origin,
        startValue: pt
      });
    } else {
      var _t = (r = t.inputEvent) === null || r === void 0 ? void 0 : r.target;
      if (_t) {
        var mt = _t.getAttribute("data-direction") || "", yt = DIRECTION_REGION_TO_DIRECTION[mt];
        if (yt) {
          D.isControl = !0, D.isAroundControl = hasClass(_t, prefix("around-control")), D.controlDirection = yt;
          var Tt = _t.getAttribute("data-resolve");
          Tt && (D.resolveAble = Tt);
          var Pt = calculateMoveableClientPositions(X.rootMatrix, X.renderPoses, J);
          e = getPosByDirection(Pt, yt), ht = e[0], dt = e[1];
        }
      }
      D.beforeInfo = {
        origin: st.beforeOrigin
      }, D.afterInfo = {
        origin: st.origin
      }, D.absoluteInfo = {
        origin: st.origin,
        startValue: st.rotation
      };
      var St = at;
      at = function(Mt) {
        var ft = X.is3d ? 4 : 3, Ft = plus(getOrigin(et, ft), Mt), Dt = Ft[0], Vt = Ft[1], Bt = calculate(Q, convertPositionMatrix([Dt, Vt], ft)), Et = calculate(it, convertPositionMatrix([Mt[0], Mt[1]], ft));
        St(Mt);
        var Ht = X.posDelta;
        D.beforeInfo.origin = minus(Bt, Ht), D.afterInfo.origin = minus(Et, Ht), D.absoluteInfo.origin = minus(Et, Ht), setRotateStartInfo(o, D.beforeInfo, ht, dt, J), setRotateStartInfo(o, D.afterInfo, ht, dt, J), setRotateStartInfo(o, D.absoluteInfo, ht, dt, J);
      }, ut = function(Mt) {
        var ft = getPosByDirection([[0, 0], [tt, 0], [0, nt], [tt, nt]], Mt);
        at(ft);
      };
    }
    D.startClientX = ht, D.startClientY = dt, D.direction = q, D.beforeDirection = K, D.startValue = 0, D.datas = {}, setDefaultTransformIndex(t, "rotate");
    var gt = !1, bt = !1;
    if (D.isControl && D.resolveAble) {
      var At = D.resolveAble;
      At === "resizable" && (bt = Resizable.dragControlStart(o, __assign$1(__assign$1({}, new CustomGesto("resizable").dragStart([0, 0], t)), {
        parentPosition: D.controlPosition,
        parentFixedPosition: D.fixedPosition
      })));
    }
    bt || (gt = Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))), at(X.transformOrigin);
    var Rt = fillParams(o, t, __assign$1(__assign$1({
      set: function(Mt) {
        D.startValue = Mt * Math.PI / 180;
      },
      setFixedDirection: ut,
      setFixedPosition: at
    }, fillTransformStartEvent(t)), {
      dragStart: gt,
      resizeStart: bt
    })), Nt = triggerEvent(o, "onRotateStart", Rt);
    return D.isRotate = Nt !== !1, X.snapRenderInfo = {
      request: t.isRequest
    }, D.isRotate ? Rt : !1;
  },
  dragControl: function(o, t) {
    var e, r, D, N = t.datas, k = t.clientDistX, $ = t.clientDistY, G = t.parentRotate, U = t.parentFlag, z = t.isPinch, X = t.groupDelta, V = t.resolveMatrix, Y = N.beforeDirection, W = N.beforeInfo, q = N.afterInfo, K = N.absoluteInfo, Z = N.isRotate, J = N.startValue, Q = N.rect, et = N.startClientX, it = N.startClientY;
    if (Z) {
      resolveTransformEvent(t, "rotate");
      var tt = getTransformDirection(t), nt = Y * tt, st = o.props.parentMoveable, at = 0, ut, ht, dt = 0, pt, _t, mt = 0, yt, Tt, Pt = 180 / Math.PI * J, St = K.startValue, gt = !1, bt = et + k, At = it + $;
      if (!U && "parentDist" in t) {
        var Rt = t.parentDist;
        ut = Rt, pt = Rt, yt = Rt;
      } else
        z || U ? (ut = getAbsoluteDist(G, Y, W), pt = getAbsoluteDist(G, nt, q), yt = getAbsoluteDist(G, nt, K)) : (ut = getAbsoluteDistByClient(bt, At, Y, W), pt = getAbsoluteDistByClient(bt, At, nt, q), yt = getAbsoluteDistByClient(bt, At, nt, K), gt = !0);
      if (ht = Pt + ut, _t = Pt + pt, Tt = St + yt, triggerEvent(o, "onBeforeRotate", fillParams(o, t, {
        beforeRotation: ht,
        rotation: _t,
        absoluteRotation: Tt,
        setRotation: function(kt) {
          pt = kt - Pt, ut = pt, yt = pt;
        }
      }, !0)), e = getRotateInfo(o, Q, W, ut, Pt, gt), at = e[0], ut = e[1], ht = e[2], r = getRotateInfo(o, Q, q, pt, Pt, gt), dt = r[0], pt = r[1], _t = r[2], D = getRotateInfo(o, Q, K, yt, St, gt), mt = D[0], yt = D[1], Tt = D[2], !(!mt && !dt && !at && !st && !V)) {
        var Nt = convertTransformFormat(N, "rotate(".concat(_t, "deg)"), "rotate(".concat(pt, "deg)"));
        V && (N.fixedPosition = getTranslateFixedPosition(o, N.targetAllTransform, [0, 0], N));
        var Mt = getRotateDist(o, pt, N), ft = minus(plus(X || [0, 0], Mt), N.prevInverseDist || [0, 0]);
        N.prevInverseDist = Mt, N.requestValue = null;
        var Ft = fillTransformEvent(o, Nt, ft, z, t), Dt = Ft, Vt = getDist$2([bt, At], K.startAbsoluteOrigin) - K.startDist, Bt = void 0;
        if (N.resolveAble === "resizable") {
          var Et = Resizable.dragControl(o, __assign$1(__assign$1({}, setCustomDrag(t, o.state, [t.deltaX, t.deltaY], !!z, !1, "resizable")), {
            resolveMatrix: !0,
            parentDistance: Vt
          }));
          Et && (Bt = Et, Dt = fillAfterTransform(Dt, Et, t));
        }
        var Ht = fillParams(o, t, __assign$1(__assign$1({
          delta: dt,
          dist: pt,
          rotate: _t,
          rotation: _t,
          beforeDist: ut,
          beforeDelta: at,
          beforeRotate: ht,
          beforeRotation: ht,
          absoluteDist: yt,
          absoluteDelta: mt,
          absoluteRotate: Tt,
          absoluteRotation: Tt,
          isPinch: !!z,
          resize: Bt
        }, Ft), Dt));
        return triggerEvent(o, "onRotate", Ht), Ht;
      }
    }
  },
  dragControlEnd: function(o, t) {
    var e = t.datas;
    if (e.isRotate) {
      e.isRotate = !1;
      var r = fillEndParams(o, t, {});
      return triggerEvent(o, "onRotateEnd", r), r;
    }
  },
  dragGroupControlCondition: dragControlCondition,
  dragGroupControlStart: function(o, t) {
    var e = t.datas, r = o.state, D = r.left, N = r.top, k = r.beforeOrigin, $ = this.dragControlStart(o, t);
    if (!$)
      return !1;
    $.set(e.beforeDirection * o.rotation);
    var G = triggerChildAbles(o, this, "dragControlStart", t, function(X, V) {
      var Y = X.state, W = Y.left, q = Y.top, K = Y.beforeOrigin, Z = plus(minus([W, q], [D, N]), minus(K, k));
      return V.datas.startGroupClient = Z, V.datas.groupClient = Z, __assign$1(__assign$1({}, V), {
        parentRotate: 0
      });
    }), U = __assign$1(__assign$1({}, $), {
      targets: o.props.targets,
      events: G
    }), z = triggerEvent(o, "onRotateGroupStart", U);
    return e.isRotate = z !== !1, e.isRotate ? $ : !1;
  },
  dragGroupControl: function(o, t) {
    var e = t.datas;
    if (e.isRotate) {
      catchEvent(o, "onBeforeRotate", function(U) {
        triggerEvent(o, "onBeforeRotateGroup", fillParams(o, t, __assign$1(__assign$1({}, U), {
          targets: o.props.targets
        }), !0));
      });
      var r = this.dragControl(o, t);
      if (r) {
        var D = e.beforeDirection, N = r.beforeDist, k = N / 180 * Math.PI, $ = triggerChildAbles(o, this, "dragControl", t, function(U, z) {
          var X = z.datas.startGroupClient, V = z.datas.groupClient, Y = V[0], W = V[1], q = rotate(X, k * D), K = q[0], Z = q[1], J = [K - Y, Z - W];
          return z.datas.groupClient = [K, Z], __assign$1(__assign$1({}, z), {
            parentRotate: N,
            groupDelta: J
          });
        });
        o.rotation = D * r.beforeRotation;
        var G = __assign$1({
          targets: o.props.targets,
          events: $,
          set: function(U) {
            o.rotation = U;
          },
          setGroupRotation: function(U) {
            o.rotation = U;
          }
        }, r);
        return triggerEvent(o, "onRotateGroup", G), G;
      }
    }
  },
  dragGroupControlEnd: function(o, t) {
    var e = t.isDrag, r = t.datas;
    if (r.isRotate) {
      this.dragControlEnd(o, t);
      var D = triggerChildAbles(o, this, "dragControlEnd", t), N = fillEndParams(o, t, {
        targets: o.props.targets,
        events: D
      });
      return triggerEvent(o, "onRotateGroupEnd", N), e;
    }
  },
  /**
   * @method Moveable.Rotatable#request
   * @param {object} [e] - the Resizable's request parameter
   * @param {number} [e.deltaRotate=0] -  delta number of rotation
   * @param {number} [e.rotate=0] - absolute number of moveable's rotation
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("rotatable", { deltaRotate: 10 }, true);
   *
   * * moveable.request("rotatable", { rotate: 10 }, true);
   *
   * // requestStart
   * const requester = moveable.request("rotatable");
   *
   * // request
   * requester.request({ deltaRotate: 10 });
   * requester.request({ deltaRotate: 10 });
   * requester.request({ deltaRotate: 10 });
   *
   * requester.request({ rotate: 10 });
   * requester.request({ rotate: 20 });
   * requester.request({ rotate: 30 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function(o) {
    var t = {}, e = 0, r = o.getRotation();
    return {
      isControl: !0,
      requestStart: function() {
        return {
          datas: t
        };
      },
      request: function(D) {
        return "deltaRotate" in D ? e += D.deltaRotate : "rotate" in D && (e = D.rotate - r), {
          datas: t,
          parentDist: e
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  }
}, directionCondition = getDirectionCondition("scalable"), Scalable = {
  name: "scalable",
  ableGroup: "size",
  canPinch: !0,
  props: ["scalable", "throttleScale", "renderDirections", "keepRatio", "edge", "displayAroundControls"],
  events: ["scaleStart", "beforeScale", "scale", "scaleEnd", "scaleGroupStart", "beforeScaleGroup", "scaleGroup", "scaleGroupEnd"],
  render: getRenderDirections("scalable"),
  dragControlCondition: directionCondition,
  viewClassName: getDirectionViewClassName("scalable"),
  dragControlStart: function(o, t) {
    var e = t.datas, r = t.isPinch, D = t.inputEvent, N = t.parentDirection, k = getTotalDirection(N, r, D, e), $ = o.state, G = $.width, U = $.height, z = $.targetTransform, X = $.target, V = $.pos1, Y = $.pos2, W = $.pos4;
    if (!k || !X)
      return !1;
    r || setDragStart(o, t), e.datas = {}, e.transform = z, e.prevDist = [1, 1], e.direction = k, e.startOffsetWidth = G, e.startOffsetHeight = U, e.startValue = [1, 1];
    var q = getDist$2(V, Y), K = getDist$2(Y, W), Z = !k[0] && !k[1] || k[0] || !k[1];
    e.scaleWidth = q, e.scaleHeight = K, e.scaleXRatio = q / G, e.scaleYRatio = K / U, setDefaultTransformIndex(t, "scale"), e.isWidth = Z;
    function J(tt) {
      e.ratio = tt && isFinite(tt) ? tt : 0;
    }
    e.startPositions = getAbsolutePosesByState(o.state);
    function Q(tt) {
      e.fixedDirection = tt, e.fixedPosition = getPosByDirection(e.startPositions, tt);
    }
    e.setFixedDirection = Q, J(getDist$2(V, Y) / getDist$2(Y, W)), Q([-k[0], -k[1]]);
    var et = fillParams(o, t, __assign$1(__assign$1({
      direction: k,
      set: function(tt) {
        e.startValue = tt;
      },
      setRatio: J,
      setFixedDirection: Q
    }, fillTransformStartEvent(t)), {
      dragStart: Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))
    })), it = triggerEvent(o, "onScaleStart", et);
    return e.startFixedDirection = e.fixedDirection, it !== !1 && (e.isScale = !0, o.state.snapRenderInfo = {
      request: t.isRequest,
      direction: k
    }), e.isScale ? et : !1;
  },
  dragControl: function(o, t) {
    resolveTransformEvent(t, "scale");
    var e = t.datas, r = t.parentKeepRatio, D = t.parentFlag, N = t.isPinch, k = t.dragClient, $ = t.isRequest, G = t.resolveMatrix, U = e.prevDist, z = e.direction, X = e.startOffsetWidth, V = e.startOffsetHeight, Y = e.isScale, W = e.startValue, q = e.isWidth, K = e.ratio;
    if (!Y)
      return !1;
    var Z = o.props, J = Z.throttleScale, Q = Z.parentMoveable, et = z;
    !z[0] && !z[1] && (et = [1, 1]);
    var it = K && (r ?? Z.keepRatio) || !1, tt = o.state;
    function nt() {
      var Rt = getOffsetSizeDist(et, it, e, t), Nt = Rt.distWidth, Mt = Rt.distHeight, ft = X ? (X + Nt) / X : 1, Ft = V ? (V + Mt) / V : 1;
      return ft = et[0] || it ? ft * W[0] : W[0], Ft = et[1] || it ? Ft * W[1] : W[1], ft === 0 && (ft = (U[0] > 0 ? 1 : -1) * MIN_SCALE), Ft === 0 && (Ft = (U[1] > 0 ? 1 : -1) * MIN_SCALE), [ft, Ft];
    }
    var st = nt();
    if (!N && o.props.groupable) {
      var at = tt.snapRenderInfo || {}, ut = at.direction;
      isArray(ut) && (ut[0] || ut[1]) && (tt.snapRenderInfo = {
        direction: z,
        request: t.isRequest
      });
    }
    triggerEvent(o, "onBeforeScale", fillParams(o, t, {
      scale: st,
      setFixedDirection: function(Rt) {
        return e.setFixedDirection(Rt), st = nt(), st;
      },
      startFixedDirection: e.startFixedDirection,
      setScale: function(Rt) {
        st = Rt;
      }
    }, !0));
    var ht = [st[0] / W[0], st[1] / W[1]], dt = k, pt = [0, 0], _t = !k && !D && N;
    if (_t || G ? dt = getTranslateFixedPosition(o, e.targetAllTransform, [0, 0], e) : k || (dt = e.fixedPosition), N || (pt = checkSnapScale(o, ht, z, $, e)), it) {
      et[0] && et[1] && pt[0] && pt[1] && (Math.abs(pt[0] * X) > Math.abs(pt[1] * V) ? pt[1] = 0 : pt[0] = 0);
      var mt = !pt[0] && !pt[1];
      if (mt && (q ? ht[0] = throttle(ht[0] * W[0], J) / W[0] : ht[1] = throttle(ht[1] * W[1], J) / W[1]), et[0] && !et[1] || pt[0] && !pt[1] || mt && q) {
        ht[0] += pt[0];
        var yt = X * ht[0] * W[0] / K;
        ht[1] = yt / V / W[1];
      } else if (!et[0] && et[1] || !pt[0] && pt[1] || mt && !q) {
        ht[1] += pt[1];
        var Tt = V * ht[1] * W[1] * K;
        ht[0] = Tt / X / W[0];
      }
    } else
      ht[0] += pt[0], ht[1] += pt[1], pt[0] || (ht[0] = throttle(ht[0] * W[0], J) / W[0]), pt[1] || (ht[1] = throttle(ht[1] * W[1], J) / W[1]);
    ht[0] === 0 && (ht[0] = (U[0] > 0 ? 1 : -1) * MIN_SCALE), ht[1] === 0 && (ht[1] = (U[1] > 0 ? 1 : -1) * MIN_SCALE);
    var Pt = [ht[0] / U[0], ht[1] / U[1]];
    st = multiply2(ht, W);
    var St = getScaleDist(o, ht, e.fixedDirection, dt, e), gt = _t ? St : minus(St, e.prevInverseDist || [0, 0]);
    if (e.prevDist = ht, e.prevInverseDist = St, st[0] === U[0] && st[1] === U[1] && gt.every(function(Rt) {
      return !Rt;
    }) && !Q && !_t)
      return !1;
    var bt = convertTransformFormat(e, "scale(".concat(st.join(", "), ")"), "scale(".concat(ht.join(", "), ")")), At = fillParams(o, t, __assign$1({
      offsetWidth: X,
      offsetHeight: V,
      direction: z,
      scale: st,
      dist: ht,
      delta: Pt,
      isPinch: !!N
    }, fillTransformEvent(o, bt, gt, N, t)));
    return triggerEvent(o, "onScale", At), At;
  },
  dragControlEnd: function(o, t) {
    var e = t.datas;
    if (!e.isScale)
      return !1;
    e.isScale = !1;
    var r = fillEndParams(o, t, {});
    return triggerEvent(o, "onScaleEnd", r), r;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function(o, t) {
    var e = t.datas, r = this.dragControlStart(o, t);
    if (!r)
      return !1;
    var D = fillChildEvents(o, "resizable", t);
    e.moveableScale = o.scale;
    var N = triggerChildAbles(o, this, "dragControlStart", t, function(U, z) {
      return startChildDist(o, U, e, z);
    }), k = function(U) {
      r.setFixedDirection(U), N.forEach(function(z, X) {
        z.setFixedDirection(U), startChildDist(o, z.moveable, e, D[X]);
      });
    };
    e.setFixedDirection = k;
    var $ = __assign$1(__assign$1({}, r), {
      targets: o.props.targets,
      events: N,
      setFixedDirection: k
    }), G = triggerEvent(o, "onScaleGroupStart", $);
    return e.isScale = G !== !1, e.isScale ? $ : !1;
  },
  dragGroupControl: function(o, t) {
    var e = t.datas;
    if (e.isScale) {
      catchEvent(o, "onBeforeScale", function(X) {
        triggerEvent(o, "onBeforeScaleGroup", fillParams(o, t, __assign$1(__assign$1({}, X), {
          targets: o.props.targets
        }), !0));
      });
      var r = this.dragControl(o, t);
      if (r) {
        var D = e.moveableScale;
        o.scale = [r.scale[0] * D[0], r.scale[1] * D[1]];
        var N = o.props.keepRatio, k = r.dist, $ = r.scale, G = e.fixedPosition, U = triggerChildAbles(o, this, "dragControl", t, function(X, V) {
          var Y = calculate(createRotateMatrix(o.rotation / 180 * Math.PI, 3), [V.datas.originalX * k[0], V.datas.originalY * k[1], 1], 3), W = Y[0], q = Y[1];
          return __assign$1(__assign$1({}, V), {
            parentDist: null,
            parentScale: $,
            parentKeepRatio: N,
            dragClient: plus(G, [W, q])
          });
        }), z = __assign$1({
          targets: o.props.targets,
          events: U
        }, r);
        return triggerEvent(o, "onScaleGroup", z), z;
      }
    }
  },
  dragGroupControlEnd: function(o, t) {
    var e = t.isDrag, r = t.datas;
    if (r.isScale) {
      this.dragControlEnd(o, t);
      var D = triggerChildAbles(o, this, "dragControlEnd", t), N = fillEndParams(o, t, {
        targets: o.props.targets,
        events: D
      });
      return triggerEvent(o, "onScaleGroupEnd", N), e;
    }
  },
  /**
   * @method Moveable.Scalable#request
   * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("scalable", { deltaWidth: 10, deltaHeight: 10 }, true);
   *
   * // requestStart
   * const requester = moveable.request("scalable");
   *
   * // request
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function() {
    var o = {}, t = 0, e = 0;
    return {
      isControl: !0,
      requestStart: function(r) {
        return {
          datas: o,
          parentDirection: r.direction || [1, 1]
        };
      },
      request: function(r) {
        return t += r.deltaWidth, e += r.deltaHeight, {
          datas: o,
          parentDist: [t, e],
          parentKeepRatio: r.keepRatio
        };
      },
      requestEnd: function() {
        return {
          datas: o,
          isDrag: !0
        };
      }
    };
  }
};
function getMiddleLinePos(o, t) {
  return o.map(function(e, r) {
    return dot(e, t[r], 1, 2);
  });
}
function getTriangleRad(o, t, e) {
  var r = getRad$1(o, t), D = getRad$1(o, e), N = D - r;
  return N >= 0 ? N : N + 2 * Math.PI;
}
function isValidPos(o, t) {
  var e = getTriangleRad(o[0], o[1], o[2]), r = getTriangleRad(t[0], t[1], t[2]), D = Math.PI;
  return !(e >= D && r <= D || e <= D && r >= D);
}
var Warpable = {
  name: "warpable",
  ableGroup: "size",
  props: ["warpable", "renderDirections", "edge", "displayAroundControls"],
  events: ["warpStart", "warp", "warpEnd"],
  viewClassName: getDirectionViewClassName("warpable"),
  render: function(o, t) {
    var e = o.props, r = e.resizable, D = e.scalable, N = e.warpable, k = e.zoom;
    if (r || D || !N)
      return [];
    var $ = o.state, G = $.pos1, U = $.pos2, z = $.pos3, X = $.pos4, V = getMiddleLinePos(G, U), Y = getMiddleLinePos(U, G), W = getMiddleLinePos(G, z), q = getMiddleLinePos(z, G), K = getMiddleLinePos(z, X), Z = getMiddleLinePos(X, z), J = getMiddleLinePos(U, X), Q = getMiddleLinePos(X, U);
    return __spreadArray([t.createElement("div", {
      className: prefix("line"),
      key: "middeLine1",
      style: getLineStyle(V, K, k)
    }), t.createElement("div", {
      className: prefix("line"),
      key: "middeLine2",
      style: getLineStyle(Y, Z, k)
    }), t.createElement("div", {
      className: prefix("line"),
      key: "middeLine3",
      style: getLineStyle(W, J, k)
    }), t.createElement("div", {
      className: prefix("line"),
      key: "middeLine4",
      style: getLineStyle(q, Q, k)
    })], renderAllDirections(o, "warpable", t), !0);
  },
  dragControlCondition: function(o, t) {
    if (t.isRequest)
      return !1;
    var e = t.inputEvent.target;
    return hasClass(e, prefix("direction")) && hasClass(e, prefix("warpable"));
  },
  dragControlStart: function(o, t) {
    var e = t.datas, r = t.inputEvent, D = o.props.target, N = r.target, k = getDirection(N, e);
    if (!k || !D)
      return !1;
    var $ = o.state, G = $.transformOrigin, U = $.is3d, z = $.targetTransform, X = $.targetMatrix, V = $.width, Y = $.height, W = $.left, q = $.top;
    e.datas = {}, e.targetTransform = z, e.warpTargetMatrix = U ? X : convertDimension(X, 3, 4), e.targetInverseMatrix = ignoreDimension(invert(e.warpTargetMatrix, 4), 3, 4), e.direction = k, e.left = W, e.top = q, e.poses = [[0, 0], [V, 0], [0, Y], [V, Y]].map(function(J) {
      return minus(J, G);
    }), e.nextPoses = e.poses.map(function(J) {
      var Q = J[0], et = J[1];
      return calculate(e.warpTargetMatrix, [Q, et, 0, 1], 4);
    }), e.startValue = createIdentityMatrix(4), e.prevMatrix = createIdentityMatrix(4), e.absolutePoses = getAbsolutePosesByState($), e.posIndexes = getPosIndexesByDirection(k), setDragStart(o, t), setDefaultTransformIndex(t, "matrix3d"), $.snapRenderInfo = {
      request: t.isRequest,
      direction: k
    };
    var K = fillParams(o, t, __assign$1({
      set: function(J) {
        e.startValue = J;
      }
    }, fillTransformStartEvent(t))), Z = triggerEvent(o, "onWarpStart", K);
    return Z !== !1 && (e.isWarp = !0), e.isWarp;
  },
  dragControl: function(o, t) {
    var e = t.datas, r = t.isRequest, D = t.distX, N = t.distY, k = e.targetInverseMatrix, $ = e.prevMatrix, G = e.isWarp, U = e.startValue, z = e.poses, X = e.posIndexes, V = e.absolutePoses;
    if (!G)
      return !1;
    if (resolveTransformEvent(t, "matrix3d"), hasGuidelines(o, "warpable")) {
      var Y = X.map(function(at) {
        return V[at];
      });
      Y.length > 1 && Y.push([(Y[0][0] + Y[1][0]) / 2, (Y[0][1] + Y[1][1]) / 2]);
      var W = checkMoveableSnapBounds(o, r, {
        horizontal: Y.map(function(at) {
          return at[1] + N;
        }),
        vertical: Y.map(function(at) {
          return at[0] + D;
        })
      }), q = W.horizontal, K = W.vertical;
      N -= q.offset, D -= K.offset;
    }
    var Z = getDragDist({
      datas: e,
      distX: D,
      distY: N
    }, !0), J = e.nextPoses.slice();
    if (X.forEach(function(at) {
      J[at] = plus(J[at], Z);
    }), !NEARBY_POS.every(function(at) {
      return isValidPos(at.map(function(ut) {
        return z[ut];
      }), at.map(function(ut) {
        return J[ut];
      }));
    }))
      return !1;
    var Q = createWarpMatrix(z[0], z[2], z[1], z[3], J[0], J[2], J[1], J[3]);
    if (!Q.length)
      return !1;
    var et = multiply(k, Q, 4), it = getTransfromMatrix(e, et, !0), tt = multiply(invert($, 4), it, 4);
    e.prevMatrix = it;
    var nt = multiply(U, it, 4), st = convertTransformFormat(e, "matrix3d(".concat(nt.join(", "), ")"), "matrix3d(".concat(it.join(", "), ")"));
    return fillOriginalTransform(t, st), triggerEvent(o, "onWarp", fillParams(o, t, __assign$1({
      delta: tt,
      matrix: nt,
      dist: it,
      multiply,
      transform: st
    }, fillCSSObject({
      transform: st
    }, t)))), !0;
  },
  dragControlEnd: function(o, t) {
    var e = t.datas, r = t.isDrag;
    return e.isWarp ? (e.isWarp = !1, triggerEvent(o, "onWarpEnd", fillEndParams(o, t, {})), r) : !1;
  }
}, AREA_PIECES = /* @__PURE__ */ prefix("area-pieces"), AREA_PIECE = /* @__PURE__ */ prefix("area-piece"), AVOID = /* @__PURE__ */ prefix("avoid"), VIEW_DRAGGING = prefix("view-dragging");
function restoreStyle(o) {
  var t = o.areaElement;
  if (t) {
    var e = o.state, r = e.width, D = e.height;
    removeClass(t, AVOID), t.style.cssText += "left: 0px; top: 0px; width: ".concat(r, "px; height: ").concat(D, "px");
  }
}
function renderPieces(o) {
  return o.createElement("div", {
    key: "area_pieces",
    className: AREA_PIECES
  }, o.createElement("div", {
    className: AREA_PIECE
  }), o.createElement("div", {
    className: AREA_PIECE
  }), o.createElement("div", {
    className: AREA_PIECE
  }), o.createElement("div", {
    className: AREA_PIECE
  }));
}
var DragArea = {
  name: "dragArea",
  props: ["dragArea", "passDragArea"],
  events: ["click", "clickGroup"],
  render: function(o, t) {
    var e = o.props, r = e.target, D = e.dragArea, N = e.groupable, k = e.passDragArea, $ = o.getState(), G = $.width, U = $.height, z = $.renderPoses, X = k ? prefix("area", "pass") : prefix("area");
    if (N)
      return [t.createElement("div", {
        key: "area",
        ref: ref(o, "areaElement"),
        className: X
      }), renderPieces(t)];
    if (!r || !D)
      return [];
    var V = createWarpMatrix([0, 0], [G, 0], [0, U], [G, U], z[0], z[1], z[2], z[3]), Y = V.length ? makeMatrixCSS(V, !0) : "none";
    return [t.createElement("div", {
      key: "area",
      ref: ref(o, "areaElement"),
      className: X,
      style: {
        top: "0px",
        left: "0px",
        width: "".concat(G, "px"),
        height: "".concat(U, "px"),
        transformOrigin: "0 0",
        transform: Y
      }
    }), renderPieces(t)];
  },
  dragStart: function(o, t) {
    var e = t.datas, r = t.clientX, D = t.clientY, N = t.inputEvent;
    if (!N)
      return !1;
    e.isDragArea = !1;
    var k = o.areaElement, $ = o.state, G = $.moveableClientRect, U = $.renderPoses, z = $.rootMatrix, X = $.is3d, V = G.left, Y = G.top, W = getRect(U), q = W.left, K = W.top, Z = W.width, J = W.height, Q = X ? 4 : 3, et = calculateInversePosition(z, [r - V, D - Y], Q), it = et[0], tt = et[1];
    it -= q, tt -= K;
    var nt = [{
      left: q,
      top: K,
      width: Z,
      height: tt - 10
    }, {
      left: q,
      top: K,
      width: it - 10,
      height: J
    }, {
      left: q,
      top: K + tt + 10,
      width: Z,
      height: J - tt - 10
    }, {
      left: q + it + 10,
      top: K,
      width: Z - it - 10,
      height: J
    }], st = [].slice.call(k.nextElementSibling.children);
    nt.forEach(function(at, ut) {
      st[ut].style.cssText = "left: ".concat(at.left, "px;top: ").concat(at.top, "px; width: ").concat(at.width, "px; height: ").concat(at.height, "px;");
    }), addClass(k, AVOID), $.disableNativeEvent = !0;
  },
  drag: function(o, t) {
    var e = t.datas, r = t.inputEvent;
    if (this.enableNativeEvent(o), !r)
      return !1;
    e.isDragArea || (e.isDragArea = !0, restoreStyle(o));
  },
  dragEnd: function(o, t) {
    this.enableNativeEvent(o);
    var e = t.inputEvent, r = t.datas;
    if (!e)
      return !1;
    r.isDragArea || restoreStyle(o);
  },
  dragGroupStart: function(o, t) {
    return this.dragStart(o, t);
  },
  dragGroup: function(o, t) {
    return this.drag(o, t);
  },
  dragGroupEnd: function(o, t) {
    return this.dragEnd(o, t);
  },
  unset: function(o) {
    restoreStyle(o), o.state.disableNativeEvent = !1;
  },
  enableNativeEvent: function(o) {
    var t = o.state;
    t.disableNativeEvent && requestAnimationFrame$1(function() {
      t.disableNativeEvent = !1;
    });
  }
}, Origin = makeAble("origin", {
  render: function(o, t) {
    var e = o.props.zoom, r = o.getState(), D = r.beforeOrigin, N = r.rotation;
    return [t.createElement("div", {
      className: prefix("control", "origin"),
      style: getControlTransform(N, e, D),
      key: "beforeOrigin"
    })];
  }
});
function getDefaultScrollPosition(o) {
  var t = o.scrollContainer;
  return [t.scrollLeft, t.scrollTop];
}
var Scrollable = {
  name: "scrollable",
  canPinch: !0,
  props: ["scrollable", "scrollContainer", "scrollThreshold", "scrollThrottleTime", "getScrollPosition", "scrollOptions"],
  events: ["scroll", "scrollGroup"],
  dragRelation: "strong",
  dragStart: function(o, t) {
    var e = o.props, r = e.scrollContainer, D = r === void 0 ? o.getContainer() : r, N = e.scrollOptions, k = new DragScroll$1(), $ = getRefTarget(D, !0);
    t.datas.dragScroll = k, o.state.dragScroll = k;
    var G = t.isControl ? "controlGesto" : "targetGesto", U = t.targets;
    k.on("scroll", function(z) {
      var X = z.container, V = z.direction, Y = fillParams(o, t, {
        scrollContainer: X,
        direction: V
      }), W = U ? "onScrollGroup" : "onScroll";
      U && (Y.targets = U), triggerEvent(o, W, Y);
    }).on("move", function(z) {
      var X = z.offsetX, V = z.offsetY, Y = z.inputEvent;
      o[G].scrollBy(X, V, Y.inputEvent, !0);
    }).on("scrollDrag", function(z) {
      var X = z.next;
      X(o[G].getCurrentEvent());
    }), k.dragStart(t, __assign$1({
      container: $
    }, N));
  },
  checkScroll: function(o, t) {
    var e = t.datas.dragScroll;
    if (e) {
      var r = o.props, D = r.scrollContainer, N = D === void 0 ? o.getContainer() : D, k = r.scrollThreshold, $ = k === void 0 ? 0 : k, G = r.scrollThrottleTime, U = G === void 0 ? 0 : G, z = r.getScrollPosition, X = z === void 0 ? getDefaultScrollPosition : z, V = r.scrollOptions;
      return e.drag(t, __assign$1({
        container: N,
        threshold: $,
        throttleTime: U,
        getScrollPosition: function(Y) {
          return X({
            scrollContainer: Y.container,
            direction: Y.direction
          });
        }
      }, V)), !0;
    }
  },
  drag: function(o, t) {
    return this.checkScroll(o, t);
  },
  dragEnd: function(o, t) {
    t.datas.dragScroll.dragEnd(), t.datas.dragScroll = null;
  },
  dragControlStart: function(o, t) {
    return this.dragStart(o, __assign$1(__assign$1({}, t), {
      isControl: !0
    }));
  },
  dragControl: function(o, t) {
    return this.drag(o, t);
  },
  dragControlEnd: function(o, t) {
    return this.dragEnd(o, t);
  },
  dragGroupStart: function(o, t) {
    return this.dragStart(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  },
  dragGroup: function(o, t) {
    return this.drag(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  },
  dragGroupEnd: function(o, t) {
    return this.dragEnd(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  },
  dragGroupControlStart: function(o, t) {
    return this.dragStart(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets,
      isControl: !0
    }));
  },
  dragGroupControl: function(o, t) {
    return this.drag(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  },
  dragGroupControEnd: function(o, t) {
    return this.dragEnd(o, __assign$1(__assign$1({}, t), {
      targets: o.props.targets
    }));
  },
  unset: function(o) {
    var t, e = o.state;
    (t = e.dragScroll) === null || t === void 0 || t.dragEnd(), e.dragScroll = null;
  }
}, Default = {
  name: "",
  props: ["target", "dragTarget", "container", "warpSelf", "rootContainer", "useResizeObserver", "useMutationObserver", "zoom", "transformOrigin", "edge", "ables", "className", "pinchThreshold", "pinchOutside", "triggerAblesSimultaneously", "checkInput", "cspNonce", "translateZ", "hideDefaultLines", "props", "flushSync", "stopPropagation", "preventClickEventOnDrag", "preventClickDefault", "viewContainer", "persistData", "useAccuratePosition", "firstRenderState", "linePadding", "displayAroundControls", "controlPadding", "preventDefault", "requestStyles"],
  events: ["changeTargets"]
}, Padding = makeAble("padding", {
  render: function(o, t) {
    var e = o.props;
    if (e.dragArea)
      return [];
    var r = e.padding || {}, D = r.left, N = D === void 0 ? 0 : D, k = r.top, $ = k === void 0 ? 0 : k, G = r.right, U = G === void 0 ? 0 : G, z = r.bottom, X = z === void 0 ? 0 : z, V = o.getState(), Y = V.renderPoses, W = V.pos1, q = V.pos2, K = V.pos3, Z = V.pos4, J = [W, q, K, Z], Q = [];
    return N > 0 && Q.push([0, 2]), $ > 0 && Q.push([0, 1]), U > 0 && Q.push([1, 3]), X > 0 && Q.push([2, 3]), Q.map(function(et, it) {
      var tt = et[0], nt = et[1], st = J[tt], at = J[nt], ut = Y[tt], ht = Y[nt], dt = createWarpMatrix([0, 0], [100, 0], [0, 100], [100, 100], st, at, ut, ht);
      if (dt.length)
        return t.createElement("div", {
          key: "padding".concat(it),
          className: prefix("padding"),
          style: {
            transform: makeMatrixCSS(dt, !0)
          }
        });
    });
  }
}), RADIUS_DIRECTIONS = ["nw", "ne", "se", "sw"];
function calculateRatio(o, t) {
  var e = o[0] + o[1], r = e > t ? t / e : 1;
  return o[0] *= r, o[1] = t - o[1] * r, o;
}
var HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6], VERTICAL_RADIUS_ORDER = [0, 3, 4, 7], HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1], VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];
function getRadiusStyles(o, t, e, r, D, N, k, $) {
  D === void 0 && (D = 0), N === void 0 && (N = 0), k === void 0 && (k = e), $ === void 0 && ($ = r);
  var G = [], U = !1, z = o.filter(function(V) {
    return !V.virtual;
  }), X = z.map(function(V) {
    var Y = V.horizontal, W = V.vertical, q = V.pos;
    if (W && !U && (U = !0, G.push("/")), U) {
      var K = Math.max(0, W === 1 ? q[1] - N : $ - q[1]);
      return G.push(convertCSSSize(K, r, t)), K;
    } else {
      var K = Math.max(0, Y === 1 ? q[0] - D : k - q[0]);
      return G.push(convertCSSSize(K, e, t)), K;
    }
  });
  return {
    radiusPoses: z,
    styles: G,
    raws: X
  };
}
function getRadiusRange(o) {
  for (var t = [0, 0], e = [0, 0], r = o.length, D = 0; D < r; ++D) {
    var N = o[D];
    N.sub && (N.horizontal && (t[1] === 0 && (t[0] = D), t[1] = D - t[0] + 1, e[0] = D + 1), N.vertical && (e[1] === 0 && (e[0] = D), e[1] = D - e[0] + 1));
  }
  return {
    horizontalRange: t,
    verticalRange: e
  };
}
function getRadiusValues(o, t, e, r, D, N, k) {
  var $, G, U, z;
  N === void 0 && (N = [0, 0]), k === void 0 && (k = !1);
  var X = o.indexOf("/"), V = (X > -1 ? o.slice(0, X) : o).length, Y = o.slice(0, V), W = o.slice(V + 1), q = Y.length, K = W.length, Z = K > 0, J = Y[0], Q = J === void 0 ? "0px" : J, et = Y[1], it = et === void 0 ? Q : et, tt = Y[2], nt = tt === void 0 ? Q : tt, st = Y[3], at = st === void 0 ? it : st, ut = W[0], ht = ut === void 0 ? Q : ut, dt = W[1], pt = dt === void 0 ? Z ? ht : it : dt, _t = W[2], mt = _t === void 0 ? Z ? ht : nt : _t, yt = W[3], Tt = yt === void 0 ? Z ? pt : at : yt, Pt = [Q, it, nt, at].map(function(Nt) {
    return convertUnitSize(Nt, t);
  }), St = [ht, pt, mt, Tt].map(function(Nt) {
    return convertUnitSize(Nt, e);
  }), gt = Pt.slice(), bt = St.slice();
  $ = calculateRatio([gt[0], gt[1]], t), gt[0] = $[0], gt[1] = $[1], G = calculateRatio([gt[3], gt[2]], t), gt[3] = G[0], gt[2] = G[1], U = calculateRatio([bt[0], bt[3]], e), bt[0] = U[0], bt[3] = U[1], z = calculateRatio([bt[1], bt[2]], e), bt[1] = z[0], bt[2] = z[1];
  var At = k ? gt : gt.slice(0, Math.max(N[0], q)), Rt = k ? bt : bt.slice(0, Math.max(N[1], K));
  return __spreadArray(__spreadArray([], At.map(function(Nt, Mt) {
    var ft = RADIUS_DIRECTIONS[Mt];
    return {
      virtual: Mt >= q,
      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[Mt],
      vertical: 0,
      pos: [r + Nt, D + (VERTICAL_RADIUS_DIRECTIONS[Mt] === -1 ? e : 0)],
      sub: !0,
      raw: Pt[Mt],
      direction: ft
    };
  }), !0), Rt.map(function(Nt, Mt) {
    var ft = RADIUS_DIRECTIONS[Mt];
    return {
      virtual: Mt >= K,
      horizontal: 0,
      vertical: VERTICAL_RADIUS_DIRECTIONS[Mt],
      pos: [r + (HORIZONTAL_RADIUS_DIRECTIONS[Mt] === -1 ? t : 0), D + Nt],
      sub: !0,
      raw: St[Mt],
      direction: ft
    };
  }), !0);
}
function removeRadiusPos(o, t, e, r, D) {
  D === void 0 && (D = t.length);
  var N = getRadiusRange(o.slice(r)), k = N.horizontalRange, $ = N.verticalRange, G = e - r, U = 0;
  if (G === 0)
    U = D;
  else if (G > 0 && G < k[1])
    U = k[1] - G;
  else if (G >= $[0])
    U = $[0] + $[1] - G;
  else
    return;
  o.splice(e, U), t.splice(e, U);
}
function addRadiusPos(o, t, e, r, D, N, k, $, G, U, z) {
  U === void 0 && (U = 0), z === void 0 && (z = 0);
  var X = getRadiusRange(o.slice(e)), V = X.horizontalRange, Y = X.verticalRange;
  if (r > -1)
    for (var W = HORIZONTAL_RADIUS_DIRECTIONS[r] === 1 ? N - U : $ - N, q = V[1]; q <= r; ++q) {
      var K = VERTICAL_RADIUS_DIRECTIONS[q] === 1 ? z : G, Z = 0;
      if (r === q ? Z = N : q === 0 ? Z = U + W : HORIZONTAL_RADIUS_DIRECTIONS[q] === -1 && (Z = $ - (t[e][0] - U)), o.splice(e + q, 0, {
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[q],
        vertical: 0,
        pos: [Z, K]
      }), t.splice(e + q, 0, [Z, K]), q === 0)
        break;
    }
  else if (D > -1) {
    var J = VERTICAL_RADIUS_DIRECTIONS[D] === 1 ? k - z : G - k;
    if (V[1] === 0 && Y[1] === 0) {
      var Q = [U + J, z];
      o.push({
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],
        vertical: 0,
        pos: Q
      }), t.push(Q);
    }
    for (var et = Y[0], q = Y[1]; q <= D; ++q) {
      var Z = HORIZONTAL_RADIUS_DIRECTIONS[q] === 1 ? U : $, K = 0;
      if (D === q ? K = k : q === 0 ? K = z + J : VERTICAL_RADIUS_DIRECTIONS[q] === 1 ? K = t[e + et][1] : VERTICAL_RADIUS_DIRECTIONS[q] === -1 && (K = G - (t[e + et][1] - z)), o.push({
        horizontal: 0,
        vertical: VERTICAL_RADIUS_DIRECTIONS[q],
        pos: [Z, K]
      }), t.push([Z, K]), q === 0)
        break;
    }
  }
}
function splitRadiusPoses(o, t) {
  t === void 0 && (t = o.map(function(D) {
    return D.raw;
  }));
  var e = o.map(function(D, N) {
    return D.horizontal ? t[N] : null;
  }).filter(function(D) {
    return D != null;
  }), r = o.map(function(D, N) {
    return D.vertical ? t[N] : null;
  }).filter(function(D) {
    return D != null;
  });
  return {
    horizontals: e,
    verticals: r
  };
}
var CLIP_DIRECTIONS = [[0, -1, "n"], [1, 0, "e"]], CLIP_RECT_DIRECTIONS = [[-1, -1, "nw"], [0, -1, "n"], [1, -1, "ne"], [1, 0, "e"], [1, 1, "se"], [0, 1, "s"], [-1, 1, "sw"], [-1, 0, "w"]];
function getClipStyles(o, t, e) {
  var r = o.props.clipRelative, D = o.state, N = D.width, k = D.height, $ = t, G = $.type, U = $.poses, z = G === "rect", X = G === "circle";
  if (G === "polygon")
    return e.map(function(tt) {
      return "".concat(convertCSSSize(tt[0], N, r), " ").concat(convertCSSSize(tt[1], k, r));
    });
  if (z || G === "inset") {
    var V = e[1][1], Y = e[3][0], W = e[7][0], q = e[5][1];
    if (z)
      return [V, Y, q, W].map(function(tt) {
        return "".concat(tt, "px");
      });
    var K = [V, N - Y, k - q, W].map(function(tt, nt) {
      return convertCSSSize(tt, nt % 2 ? N : k, r);
    });
    if (e.length > 8) {
      var Z = minus(e[4], e[0]), J = Z[0], Q = Z[1];
      K.push.apply(K, __spreadArray(["round"], getRadiusStyles(U.slice(8).map(function(tt, nt) {
        return __assign$1(__assign$1({}, tt), {
          pos: e[nt]
        });
      }), r, J, Q, W, V, Y, q).styles, !1));
    }
    return K;
  } else if (X || G === "ellipse") {
    var et = e[0], it = convertCSSSize(Math.abs(e[1][1] - et[1]), X ? Math.sqrt((N * N + k * k) / 2) : k, r), K = X ? [it] : [convertCSSSize(Math.abs(e[2][0] - et[0]), N, r), it];
    return K.push("at", convertCSSSize(et[0], N, r), convertCSSSize(et[1], k, r)), K;
  }
}
function getRectPoses(o, t, e, r) {
  var D = [r, (r + t) / 2, t], N = [o, (o + e) / 2, e];
  return CLIP_RECT_DIRECTIONS.map(function(k) {
    var $ = k[0], G = k[1], U = k[2], z = D[$ + 1], X = N[G + 1];
    return {
      vertical: Math.abs(G),
      horizontal: Math.abs($),
      direction: U,
      pos: [z, X]
    };
  });
}
function getControlSize(o) {
  var t = [1 / 0, -1 / 0], e = [1 / 0, -1 / 0];
  return o.forEach(function(r) {
    var D = r.pos;
    t[0] = Math.min(t[0], D[0]), t[1] = Math.max(t[1], D[0]), e[0] = Math.min(e[0], D[1]), e[1] = Math.max(e[1], D[1]);
  }), [Math.abs(t[1] - t[0]), Math.abs(e[1] - e[0])];
}
function getClipPath(o, t, e, r, D) {
  var N, k, $, G, U, z, X;
  if (o) {
    var V = D;
    if (!V) {
      var Y = getCachedStyle(o), W = Y("clipPath");
      V = W !== "none" ? W : Y("clip");
    }
    if (!((!V || V === "none" || V === "auto") && (V = r, !V))) {
      var q = splitBracket(V), K = q.prefix, Z = K === void 0 ? V : K, J = q.value, Q = J === void 0 ? "" : J, et = Z === "circle", it = " ";
      if (Z === "polygon") {
        var tt = splitComma(Q || "0% 0%, 100% 0%, 100% 100%, 0% 100%");
        it = ",";
        var nt = tt.map(function(Wt) {
          var Jt = Wt.split(" "), Kt = Jt[0], Se = Jt[1];
          return {
            vertical: 1,
            horizontal: 1,
            pos: [convertUnitSize(Kt, t), convertUnitSize(Se, e)]
          };
        }), st = getMinMaxs(nt.map(function(Wt) {
          return Wt.pos;
        }));
        return {
          type: Z,
          clipText: V,
          poses: nt,
          splitter: it,
          left: st.minX,
          right: st.maxX,
          top: st.minY,
          bottom: st.maxY
        };
      } else if (et || Z === "ellipse") {
        var at = "", ut = "", ht = 0, dt = 0, tt = splitSpace(Q);
        if (et) {
          var pt = "";
          N = tt[0], pt = N === void 0 ? "50%" : N, k = tt[2], at = k === void 0 ? "50%" : k, $ = tt[3], ut = $ === void 0 ? "50%" : $, ht = convertUnitSize(pt, Math.sqrt((t * t + e * e) / 2)), dt = ht;
        } else {
          var _t = "", mt = "";
          G = tt[0], _t = G === void 0 ? "50%" : G, U = tt[1], mt = U === void 0 ? "50%" : U, z = tt[3], at = z === void 0 ? "50%" : z, X = tt[4], ut = X === void 0 ? "50%" : X, ht = convertUnitSize(_t, t), dt = convertUnitSize(mt, e);
        }
        var yt = [convertUnitSize(at, t), convertUnitSize(ut, e)], nt = __spreadArray([{
          vertical: 1,
          horizontal: 1,
          pos: yt,
          direction: "nesw"
        }], CLIP_DIRECTIONS.slice(0, et ? 1 : 2).map(function(Kt) {
          return {
            vertical: Math.abs(Kt[1]),
            horizontal: Kt[0],
            direction: Kt[2],
            sub: !0,
            pos: [yt[0] + Kt[0] * ht, yt[1] + Kt[1] * dt]
          };
        }), !0);
        return {
          type: Z,
          clipText: V,
          radiusX: ht,
          radiusY: dt,
          left: yt[0] - ht,
          top: yt[1] - dt,
          right: yt[0] + ht,
          bottom: yt[1] + dt,
          poses: nt,
          splitter: it
        };
      } else if (Z === "inset") {
        var tt = splitSpace(Q || "0 0 0 0"), Tt = tt.indexOf("round"), Pt = (Tt > -1 ? tt.slice(0, Tt) : tt).length, St = tt.slice(Pt + 1), gt = tt.slice(0, Pt), bt = gt[0], At = gt[1], Rt = At === void 0 ? bt : At, Nt = gt[2], Mt = Nt === void 0 ? bt : Nt, ft = gt[3], Ft = ft === void 0 ? Rt : ft, Dt = [bt, Mt].map(function(Kt) {
          return convertUnitSize(Kt, e);
        }), Vt = Dt[0], Bt = Dt[1], Et = [Ft, Rt].map(function(Kt) {
          return convertUnitSize(Kt, t);
        }), Ht = Et[0], kt = Et[1], wt = t - kt, Lt = e - Bt, jt = getRadiusValues(St, wt - Ht, Lt - Vt, Ht, Vt), nt = __spreadArray(__spreadArray([], getRectPoses(Vt, wt, Lt, Ht), !0), jt, !0);
        return {
          type: "inset",
          clipText: V,
          poses: nt,
          top: Vt,
          left: Ht,
          right: wt,
          bottom: Lt,
          radius: St,
          splitter: it
        };
      } else if (Z === "rect") {
        var tt = splitComma(Q || "0px, ".concat(t, "px, ").concat(e, "px, 0px"));
        it = ",";
        var Ct = tt.map(function(_e) {
          var ve = splitUnit(_e).value;
          return ve;
        }), Vt = Ct[0], kt = Ct[1], Bt = Ct[2], Ht = Ct[3], nt = getRectPoses(Vt, kt, Bt, Ht);
        return {
          type: "rect",
          clipText: V,
          poses: nt,
          top: Vt,
          right: kt,
          bottom: Bt,
          left: Ht,
          values: tt,
          splitter: it
        };
      }
    }
  }
}
function moveControlPos(o, t, e, r, D) {
  var N = o[t], k = N.direction, $ = N.sub, G = o.map(function() {
    return [0, 0];
  }), U = k ? k.split("") : [];
  if (r && t < 8) {
    var z = U.filter(function(pt) {
      return pt === "w" || pt === "e";
    }), X = U.filter(function(pt) {
      return pt === "n" || pt === "s";
    }), V = z[0], Y = X[0];
    G[t] = e;
    var W = getControlSize(o), q = W[0], K = W[1], Z = q && K ? q / K : 0;
    if (Z && D) {
      var J = (t + 4) % 8, Q = o[J].pos, et = [0, 0];
      k.indexOf("w") > -1 ? et[0] = -1 : k.indexOf("e") > -1 && (et[0] = 1), k.indexOf("n") > -1 ? et[1] = -1 : k.indexOf("s") > -1 && (et[1] = 1);
      var it = getSizeDistByDist([q, K], e, Z, et, !0), tt = q + it[0], nt = K + it[1], st = Q[1], at = Q[1], ut = Q[0], ht = Q[0];
      et[0] === -1 ? ut = ht - tt : et[0] === 1 ? ht = ut + tt : (ut = ut - tt / 2, ht = ht + tt / 2), et[1] === -1 ? st = at - nt : (et[1] === 1 || (st = at - nt / 2), at = st + nt);
      var dt = getRectPoses(st, ht, at, ut);
      o.forEach(function(pt, _t) {
        G[_t][0] = dt[_t].pos[0] - pt.pos[0], G[_t][1] = dt[_t].pos[1] - pt.pos[1];
      });
    } else
      o.forEach(function(pt, _t) {
        var mt = pt.direction;
        mt && (mt.indexOf(V) > -1 && (G[_t][0] = e[0]), mt.indexOf(Y) > -1 && (G[_t][1] = e[1]));
      }), V && (G[1][0] = e[0] / 2, G[5][0] = e[0] / 2), Y && (G[3][1] = e[1] / 2, G[7][1] = e[1] / 2);
  } else
    k && !$ ? U.forEach(function(pt) {
      var _t = pt === "n" || pt === "s";
      o.forEach(function(mt, yt) {
        var Tt = mt.direction, Pt = mt.horizontal, St = mt.vertical;
        !Tt || Tt.indexOf(pt) === -1 || (G[yt] = [_t || !Pt ? 0 : e[0], !_t || !St ? 0 : e[1]]);
      });
    }) : G[t] = e;
  return G;
}
function addClipPath(o, t) {
  var e = calculatePointerDist(o, t), r = e[0], D = e[1], N = t.datas, k = N.clipPath, $ = N.clipIndex, G = k, U = G.type, z = G.poses, X = G.splitter, V = z.map(function(J) {
    return J.pos;
  });
  if (U === "polygon")
    V.splice($, 0, [r, D]);
  else if (U === "inset") {
    var Y = HORIZONTAL_RADIUS_ORDER.indexOf($), W = VERTICAL_RADIUS_ORDER.indexOf($), q = z.length;
    if (addRadiusPos(z, V, 8, Y, W, r, D, V[4][0], V[4][1], V[0][0], V[0][1]), q === z.length)
      return;
  } else
    return;
  var K = getClipStyles(o, k, V), Z = "".concat(U, "(").concat(K.join(X), ")");
  triggerEvent(o, "onClip", fillParams(o, t, __assign$1({
    clipEventType: "added",
    clipType: U,
    poses: V,
    clipStyles: K,
    clipStyle: Z,
    distX: 0,
    distY: 0
  }, fillCSSObject({
    clipPath: Z
  }, t))));
}
function removeClipPath(o, t) {
  var e = t.datas, r = e.clipPath, D = e.clipIndex, N = r, k = N.type, $ = N.poses, G = N.splitter, U = $.map(function(Y) {
    return Y.pos;
  }), z = U.length;
  if (k === "polygon")
    $.splice(D, 1), U.splice(D, 1);
  else if (k === "inset") {
    if (D < 8 || (removeRadiusPos($, U, D, 8, z), z === $.length))
      return;
  } else
    return;
  var X = getClipStyles(o, r, U), V = "".concat(k, "(").concat(X.join(G), ")");
  triggerEvent(o, "onClip", fillParams(o, t, __assign$1({
    clipEventType: "removed",
    clipType: k,
    poses: U,
    clipStyles: X,
    clipStyle: V,
    distX: 0,
    distY: 0
  }, fillCSSObject({
    clipPath: V
  }, t))));
}
var Clippable = {
  name: "clippable",
  props: ["clippable", "defaultClipPath", "customClipPath", "keepRatio", "clipRelative", "clipArea", "dragWithClip", "clipTargetBounds", "clipVerticalGuidelines", "clipHorizontalGuidelines", "clipSnapThreshold"],
  events: ["clipStart", "clip", "clipEnd"],
  css: [`.control.clip-control {
background: #6d6;
cursor: pointer;
}
.control.clip-control.clip-radius {
background: #d66;
}
.line.clip-line {
background: #6e6;
cursor: move;
z-index: 1;
}
.clip-area {
position: absolute;
top: 0;
left: 0;
}
.clip-ellipse {
position: absolute;
cursor: move;
border: 1px solid #6d6;
border: var(--zoompx) solid #6d6;
border-radius: 50%;
transform-origin: 0px 0px;
}`, `:host {
--bounds-color: #d66;
}`, `.guideline {
pointer-events: none;
z-index: 2;
}`, `.line.guideline.bounds {
background: #d66;
background: var(--bounds-color);
}`],
  render: function(o, t) {
    var e = o.props, r = e.customClipPath, D = e.defaultClipPath, N = e.clipArea, k = e.zoom, $ = e.groupable, G = o.getState(), U = G.target, z = G.width, X = G.height, V = G.allMatrix, Y = G.is3d, W = G.left, q = G.top, K = G.pos1, Z = G.pos2, J = G.pos3, Q = G.pos4, et = G.clipPathState, it = G.snapBoundInfos, tt = G.rotation;
    if (!U || $)
      return [];
    var nt = getClipPath(U, z, X, D || "inset", et || r);
    if (!nt)
      return [];
    var st = Y ? 4 : 3, at = nt.type, ut = nt.poses, ht = ut.map(function(Lt) {
      var jt = calculatePosition(V, Lt.pos, st);
      return [jt[0] - W, jt[1] - q];
    }), dt = [], pt = [], _t = at === "rect", mt = at === "inset", yt = at === "polygon";
    if (_t || mt || yt) {
      var Tt = mt ? ht.slice(0, 8) : ht;
      pt = Tt.map(function(Lt, jt) {
        var Ct = jt === 0 ? Tt[Tt.length - 1] : Tt[jt - 1], Wt = getRad$1(Ct, Lt), Jt = getDiagonalSize(Ct, Lt);
        return t.createElement("div", {
          key: "clipLine".concat(jt),
          className: prefix("line", "clip-line", "snap-control"),
          "data-clip-index": jt,
          style: {
            width: "".concat(Jt, "px"),
            transform: "translate(".concat(Ct[0], "px, ").concat(Ct[1], "px) rotate(").concat(Wt, "rad) scaleY(").concat(k, ")")
          }
        });
      });
    }
    if (dt = ht.map(function(Lt, jt) {
      return t.createElement("div", {
        key: "clipControl".concat(jt),
        className: prefix("control", "clip-control", "snap-control"),
        "data-clip-index": jt,
        style: {
          transform: "translate(".concat(Lt[0], "px, ").concat(Lt[1], "px) rotate(").concat(tt, "rad) scale(").concat(k, ")")
        }
      });
    }), mt && dt.push.apply(dt, ht.slice(8).map(function(Lt, jt) {
      return t.createElement("div", {
        key: "clipRadiusControl".concat(jt),
        className: prefix("control", "clip-control", "clip-radius", "snap-control"),
        "data-clip-index": 8 + jt,
        style: {
          transform: "translate(".concat(Lt[0], "px, ").concat(Lt[1], "px) rotate(").concat(tt, "rad) scale(").concat(k, ")")
        }
      });
    })), at === "circle" || at === "ellipse") {
      var Pt = nt.left, St = nt.top, gt = nt.radiusX, bt = nt.radiusY, At = minus(calculatePosition(V, [Pt, St], st), calculatePosition(V, [0, 0], st)), Rt = At[0], Nt = At[1], Mt = "none";
      if (!N) {
        for (var ft = Math.max(10, gt / 5, bt / 5), Ft = [], Dt = 0; Dt <= ft; ++Dt) {
          var Vt = Math.PI * 2 / ft * Dt;
          Ft.push([gt + (gt - k) * Math.cos(Vt), bt + (bt - k) * Math.sin(Vt)]);
        }
        Ft.push([gt, -2]), Ft.push([-2, -2]), Ft.push([-2, bt * 2 + 2]), Ft.push([gt * 2 + 2, bt * 2 + 2]), Ft.push([gt * 2 + 2, -2]), Ft.push([gt, -2]), Mt = "polygon(".concat(Ft.map(function(Lt) {
          return "".concat(Lt[0], "px ").concat(Lt[1], "px");
        }).join(", "), ")");
      }
      dt.push(t.createElement("div", {
        key: "clipEllipse",
        className: prefix("clip-ellipse", "snap-control"),
        style: {
          width: "".concat(gt * 2, "px"),
          height: "".concat(bt * 2, "px"),
          clipPath: Mt,
          transform: "translate(".concat(-W + Rt, "px, ").concat(-q + Nt, "px) ").concat(makeMatrixCSS(V))
        }
      }));
    }
    if (N) {
      var Bt = getRect(__spreadArray([K, Z, J, Q], ht, !0)), Et = Bt.width, Ht = Bt.height, kt = Bt.left, wt = Bt.top;
      if (yt || _t || mt) {
        var Ft = mt ? ht.slice(0, 8) : ht;
        dt.push(t.createElement("div", {
          key: "clipArea",
          className: prefix("clip-area", "snap-control"),
          style: {
            width: "".concat(Et, "px"),
            height: "".concat(Ht, "px"),
            transform: "translate(".concat(kt, "px, ").concat(wt, "px)"),
            clipPath: "polygon(".concat(Ft.map(function(jt) {
              return "".concat(jt[0] - kt, "px ").concat(jt[1] - wt, "px");
            }).join(", "), ")")
          }
        }));
      }
    }
    return it && ["vertical", "horizontal"].forEach(function(Lt) {
      var jt = it[Lt], Ct = Lt === "horizontal";
      jt.isSnap && pt.push.apply(pt, jt.snap.posInfos.map(function(Wt, Jt) {
        var Kt = Wt.pos, Se = minus(calculatePosition(V, Ct ? [0, Kt] : [Kt, 0], st), [W, q]), Oe = minus(calculatePosition(V, Ct ? [z, Kt] : [Kt, X], st), [W, q]);
        return renderLine(t, "", Se, Oe, k, "clip".concat(Lt, "snap").concat(Jt), "guideline");
      })), jt.isBound && pt.push.apply(pt, jt.bounds.map(function(Wt, Jt) {
        var Kt = Wt.pos, Se = minus(calculatePosition(V, Ct ? [0, Kt] : [Kt, 0], st), [W, q]), Oe = minus(calculatePosition(V, Ct ? [z, Kt] : [Kt, X], st), [W, q]);
        return renderLine(t, "", Se, Oe, k, "clip".concat(Lt, "bounds").concat(Jt), "guideline", "bounds", "bold");
      }));
    }), __spreadArray(__spreadArray([], dt, !0), pt, !0);
  },
  dragControlCondition: function(o, t) {
    return t.inputEvent && (t.inputEvent.target.getAttribute("class") || "").indexOf("clip") > -1;
  },
  dragStart: function(o, t) {
    var e = o.props, r = e.dragWithClip, D = r === void 0 ? !0 : r;
    return D ? !1 : this.dragControlStart(o, t);
  },
  drag: function(o, t) {
    return this.dragControl(o, __assign$1(__assign$1({}, t), {
      isDragTarget: !0
    }));
  },
  dragEnd: function(o, t) {
    return this.dragControlEnd(o, t);
  },
  dragControlStart: function(o, t) {
    var e = o.state, r = o.props, D = r.defaultClipPath, N = r.customClipPath, k = e.target, $ = e.width, G = e.height, U = t.inputEvent ? t.inputEvent.target : null, z = U && U.getAttribute("class") || "", X = t.datas, V = getClipPath(k, $, G, D || "inset", N);
    if (!V)
      return !1;
    var Y = V.clipText, W = V.type, q = V.poses, K = triggerEvent(o, "onClipStart", fillParams(o, t, {
      clipType: W,
      clipStyle: Y,
      poses: q.map(function(Z) {
        return Z.pos;
      })
    }));
    return K === !1 ? (X.isClipStart = !1, !1) : (X.isControl = z && z.indexOf("clip-control") > -1, X.isLine = z.indexOf("clip-line") > -1, X.isArea = z.indexOf("clip-area") > -1 || z.indexOf("clip-ellipse") > -1, X.clipIndex = U ? parseInt(U.getAttribute("data-clip-index"), 10) : -1, X.clipPath = V, X.isClipStart = !0, e.clipPathState = Y, setDragStart(o, t), !0);
  },
  dragControl: function(o, t) {
    var e, r, D = t.datas, N = t.originalDatas, k = t.isDragTarget;
    if (!D.isClipStart)
      return !1;
    var $ = D, G = $.isControl, U = $.isLine, z = $.isArea, X = $.clipIndex, V = $.clipPath;
    if (!V)
      return !1;
    var Y = getProps(o.props, "clippable"), W = Y.keepRatio, q = 0, K = 0, Z = N.draggable, J = getDragDist(t);
    k && Z ? (e = Z.prevBeforeDist, q = e[0], K = e[1]) : (q = J[0], K = J[1]);
    var Q = [q, K], et = o.state, it = et.width, tt = et.height, nt = !z && !G && !U, st = V.type, at = V.poses, ut = V.splitter, ht = at.map(function(vt) {
      return vt.pos;
    });
    nt && (q = -q, K = -K);
    var dt = !G || at[X].direction === "nesw", pt = st === "inset" || st === "rect", _t = at.map(function() {
      return [0, 0];
    });
    if (G && !dt) {
      var mt = at[X], yt = mt.horizontal, Tt = mt.vertical, Pt = [q * Math.abs(yt), K * Math.abs(Tt)];
      _t = moveControlPos(at, X, Pt, pt, W);
    } else
      dt && (_t = ht.map(function() {
        return [q, K];
      }));
    var St = ht.map(function(vt, xt) {
      return plus(vt, _t[xt]);
    }), gt = __spreadArray([], St, !0);
    et.snapBoundInfos = null;
    var bt = V.type === "circle", At = V.type === "ellipse";
    if (bt || At) {
      var Rt = getRect(St), Nt = Math.abs(Rt.bottom - Rt.top), Mt = Math.abs(At ? Rt.right - Rt.left : Nt), ft = St[0][1] + Nt, Ft = St[0][0] - Mt, Dt = St[0][0] + Mt;
      bt && (gt.push([Dt, Rt.bottom]), _t.push([1, 0])), gt.push([Rt.left, ft]), _t.push([0, 1]), gt.push([Ft, Rt.bottom]), _t.push([1, 0]);
    }
    var Vt = getDefaultGuidelines((Y.clipHorizontalGuidelines || []).map(function(vt) {
      return convertUnitSize("".concat(vt), tt);
    }), (Y.clipVerticalGuidelines || []).map(function(vt) {
      return convertUnitSize("".concat(vt), it);
    }), it, tt), Bt = [], Et = [];
    if (bt || At)
      Bt = [gt[4][0], gt[2][0]], Et = [gt[1][1], gt[3][1]];
    else if (pt) {
      var Ht = [gt[0], gt[2], gt[4], gt[6]], kt = [_t[0], _t[2], _t[4], _t[6]];
      Bt = Ht.filter(function(vt, xt) {
        return kt[xt][0];
      }).map(function(vt) {
        return vt[0];
      }), Et = Ht.filter(function(vt, xt) {
        return kt[xt][1];
      }).map(function(vt) {
        return vt[1];
      });
    } else
      Bt = gt.filter(function(vt, xt) {
        return _t[xt][0];
      }).map(function(vt) {
        return vt[0];
      }), Et = gt.filter(function(vt, xt) {
        return _t[xt][1];
      }).map(function(vt) {
        return vt[1];
      });
    var wt = [0, 0], Lt = checkSnapBounds(Vt, Y.clipTargetBounds && {
      left: 0,
      top: 0,
      right: it,
      bottom: tt
    }, Bt, Et, 5), jt = Lt.horizontal, Ct = Lt.vertical, Wt = jt.offset, Jt = Ct.offset;
    if (jt.isBound && (wt[1] += Wt), Ct.isBound && (wt[0] += Jt), (At || bt) && _t[0][0] === 0 && _t[0][1] === 0) {
      var Rt = getRect(St), Kt = Rt.bottom - Rt.top, Se = At ? Rt.right - Rt.left : Kt, Oe = Ct.isBound ? Math.abs(Jt) : Ct.snapIndex === 0 ? -Jt : Jt, he = jt.isBound ? Math.abs(Wt) : jt.snapIndex === 0 ? -Wt : Wt;
      Se -= Oe, Kt -= he, bt && (Kt = checkSnapBoundPriority(Ct, jt) > 0 ? Kt : Se, Se = Kt);
      var _e = gt[0];
      gt[1][1] = _e[1] - Kt, gt[2][0] = _e[0] + Se, gt[3][1] = _e[1] + Kt, gt[4][0] = _e[0] - Se;
    } else if (pt && W && G) {
      var ve = getControlSize(at), de = ve[0], fe = ve[1], ne = de && fe ? de / fe : 0, Ve = at[X], gs = Ve.direction || "", ja = gt[1][1], ft = gt[5][1], Ft = gt[7][0], Dt = gt[3][0];
      Wt <= Jt ? Wt = Jt / ne : Jt = Wt * ne, gs.indexOf("w") > -1 ? Ft -= Jt : gs.indexOf("e") > -1 ? Dt -= Jt : (Ft += Jt / 2, Dt -= Jt / 2), gs.indexOf("n") > -1 ? ja -= Wt : gs.indexOf("s") > -1 ? ft -= Wt : (ja += Wt / 2, ft -= Wt / 2);
      var Hc = getRectPoses(ja, Dt, ft, Ft);
      gt.forEach(function($t, Gt) {
        var Ut;
        Ut = Hc[Gt].pos, $t[0] = Ut[0], $t[1] = Ut[1];
      });
    } else
      gt.forEach(function(vt, xt) {
        var Ot = _t[xt];
        Ot[0] && (vt[0] -= Jt), Ot[1] && (vt[1] -= Wt);
      });
    var za = getClipStyles(o, V, St), ms = "".concat(st, "(").concat(za.join(ut), ")");
    if (et.clipPathState = ms, bt || At)
      Bt = [gt[4][0], gt[2][0]], Et = [gt[1][1], gt[3][1]];
    else if (pt) {
      var Ht = [gt[0], gt[2], gt[4], gt[6]];
      Bt = Ht.map(function(xt) {
        return xt[0];
      }), Et = Ht.map(function(xt) {
        return xt[1];
      });
    } else
      Bt = gt.map(function(vt) {
        return vt[0];
      }), Et = gt.map(function(vt) {
        return vt[1];
      });
    if (et.snapBoundInfos = checkSnapBounds(Vt, Y.clipTargetBounds && {
      left: 0,
      top: 0,
      right: it,
      bottom: tt
    }, Bt, Et, 1), Z) {
      var ru = et.is3d, iu = et.allMatrix, Vc = ru ? 4 : 3, ct = wt;
      k && (ct = [Q[0] + wt[0] - J[0], Q[1] + wt[1] - J[1]]), Z.deltaOffset = multiply(iu, [ct[0], ct[1], 0, 0], Vc);
    }
    return triggerEvent(o, "onClip", fillParams(o, t, __assign$1({
      clipEventType: "changed",
      clipType: st,
      poses: St,
      clipStyle: ms,
      clipStyles: za,
      distX: q,
      distY: K
    }, fillCSSObject((r = {}, r[st === "rect" ? "clip" : "clipPath"] = ms, r), t)))), !0;
  },
  dragControlEnd: function(o, t) {
    this.unset(o);
    var e = t.isDrag, r = t.datas, D = t.isDouble, N = r.isLine, k = r.isClipStart, $ = r.isControl;
    return k ? (triggerEvent(o, "onClipEnd", fillEndParams(o, t, {})), D && ($ ? removeClipPath(o, t) : N && addClipPath(o, t)), D || e) : !1;
  },
  unset: function(o) {
    o.state.clipPathState = "", o.state.snapBoundInfos = null;
  }
}, OriginDraggable = {
  name: "originDraggable",
  props: ["originDraggable", "originRelative"],
  events: ["dragOriginStart", "dragOrigin", "dragOriginEnd"],
  css: [`:host[data-able-origindraggable] .control.origin {
pointer-events: auto;
}`],
  dragControlCondition: function(o, t) {
    return t.isRequest ? t.requestAble === "originDraggable" : hasClass(t.inputEvent.target, prefix("origin"));
  },
  dragControlStart: function(o, t) {
    var e = t.datas;
    setDragStart(o, t);
    var r = fillParams(o, t, {
      dragStart: Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))
    }), D = triggerEvent(o, "onDragOriginStart", r);
    return e.startOrigin = o.state.transformOrigin, e.startTargetOrigin = o.state.targetOrigin, e.prevOrigin = [0, 0], e.isDragOrigin = !0, D === !1 ? (e.isDragOrigin = !1, !1) : r;
  },
  dragControl: function(o, t) {
    var e = t.datas, r = t.isPinch, D = t.isRequest;
    if (!e.isDragOrigin)
      return !1;
    var N = getDragDist(t), k = N[0], $ = N[1], G = o.state, U = G.width, z = G.height, X = G.offsetMatrix, V = G.targetMatrix, Y = G.is3d, W = o.props.originRelative, q = W === void 0 ? !0 : W, K = Y ? 4 : 3, Z = [k, $];
    if (D) {
      var J = t.distOrigin;
      (J[0] || J[1]) && (Z = J);
    }
    var Q = plus(e.startOrigin, Z), et = plus(e.startTargetOrigin, Z), it = minus(Z, e.prevOrigin), tt = getNextMatrix(X, V, Q, K), nt = o.getRect(), st = getRect(calculatePoses(tt, U, z, K)), at = [nt.left - st.left, nt.top - st.top];
    e.prevOrigin = Z;
    var ut = [convertCSSSize(et[0], U, q), convertCSSSize(et[1], z, q)].join(" "), ht = Draggable.drag(o, setCustomDrag(t, o.state, at, !!r, !1)), dt = fillParams(o, t, __assign$1(__assign$1({
      width: U,
      height: z,
      origin: Q,
      dist: Z,
      delta: it,
      transformOrigin: ut,
      drag: ht
    }, fillCSSObject({
      transformOrigin: ut,
      transform: ht.transform
    }, t)), {
      afterTransform: ht.transform
    }));
    return triggerEvent(o, "onDragOrigin", dt), dt;
  },
  dragControlEnd: function(o, t) {
    var e = t.datas;
    return e.isDragOrigin ? (triggerEvent(o, "onDragOriginEnd", fillEndParams(o, t, {})), !0) : !1;
  },
  dragGroupControlCondition: function(o, t) {
    return this.dragControlCondition(o, t);
  },
  dragGroupControlStart: function(o, t) {
    var e = this.dragControlStart(o, t);
    return !!e;
  },
  dragGroupControl: function(o, t) {
    var e = this.dragControl(o, t);
    return e ? (o.transformOrigin = e.transformOrigin, !0) : !1;
  },
  /**
  * @method Moveable.OriginDraggable#request
  * @param {object} e - the OriginDraggable's request parameter
  * @param {number} [e.x] - x position
  * @param {number} [e.y] - y position
  * @param {number} [e.deltaX] - x number to move
  * @param {number} [e.deltaY] - y number to move
  * @param {array} [e.deltaOrigin] - left, top number to move transform-origin
  * @param {array} [e.origin] - transform-origin position
  * @param {number} [e.isInstant] - Whether to execute the request instantly
  * @return {Moveable.Requester} Moveable Requester
  * @example
   * // Instantly Request (requestStart - request - requestEnd)
  * // Use Relative Value
  * moveable.request("originDraggable", { deltaX: 10, deltaY: 10 }, true);
  * // Use Absolute Value
  * moveable.request("originDraggable", { x: 200, y: 100 }, true);
  * // Use Transform Value
  * moveable.request("originDraggable", { deltaOrigin: [10, 0] }, true);
  * moveable.request("originDraggable", { origin: [100, 0] }, true);
  * // requestStart
  * const requester = moveable.request("originDraggable");
  *
  * // request
  * // Use Relative Value
  * requester.request({ deltaX: 10, deltaY: 10 });
  * requester.request({ deltaX: 10, deltaY: 10 });
  * requester.request({ deltaX: 10, deltaY: 10 });
  * // Use Absolute Value
  * moveable.request("originDraggable", { x: 200, y: 100 });
  * moveable.request("originDraggable", { x: 220, y: 100 });
  * moveable.request("originDraggable", { x: 240, y: 100 });
  *
  * // requestEnd
  * requester.requestEnd();
  */
  request: function(o) {
    var t = {}, e = o.getRect(), r = 0, D = 0, N = e.transformOrigin, k = [0, 0];
    return {
      isControl: !0,
      requestStart: function() {
        return {
          datas: t
        };
      },
      request: function($) {
        return "deltaOrigin" in $ ? (k[0] += $.deltaOrigin[0], k[1] += $.deltaOrigin[1]) : "origin" in $ ? (k[0] = $.origin[0] - N[0], k[1] = $.origin[1] - N[1]) : ("x" in $ ? r = $.x - e.left : "deltaX" in $ && (r += $.deltaX), "y" in $ ? D = $.y - e.top : "deltaY" in $ && (D += $.deltaY)), {
          datas: t,
          distX: r,
          distY: D,
          distOrigin: k
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  }
};
function addBorderRadiusByLine(o, t, e, r) {
  var D = o.filter(function(G) {
    var U = G.virtual, z = G.horizontal;
    return z && !U;
  }).length, N = o.filter(function(G) {
    var U = G.virtual, z = G.vertical;
    return z && !U;
  }).length, k = -1;
  if (t === 0 && (D === 0 ? k = 0 : D === 1 && (k = 1)), t === 2 && (D <= 2 ? k = 2 : D <= 3 && (k = 3)), t === 3 && (N === 0 ? k = 4 : N < 4 && (k = 7)), t === 1 && (N <= 1 ? k = 5 : N <= 2 && (k = 6)), !(k === -1 || !o[k].virtual)) {
    var $ = o[k];
    addBorderRadius(o, k), k < 4 ? $.pos[0] = e : $.pos[1] = r;
  }
}
function addBorderRadius(o, t) {
  t < 4 ? o.slice(0, t + 1).forEach(function(e) {
    e.virtual = !1;
  }) : (o[0].virtual && (o[0].virtual = !1), o.slice(4, t + 1).forEach(function(e) {
    e.virtual = !1;
  }));
}
function removeBorderRadius(o, t) {
  t < 4 ? o.slice(t, 4).forEach(function(e) {
    e.virtual = !0;
  }) : o.slice(t).forEach(function(e) {
    e.virtual = !0;
  });
}
function getBorderRadius(o, t, e, r, D) {
  r === void 0 && (r = [0, 0]);
  var N = [];
  return !o || o === "0px" ? N = [] : N = splitSpace(o), getRadiusValues(N, t, e, 0, 0, r, D);
}
function triggerRoundEvent(o, t, e, r, D) {
  var N = o.state, k = N.width, $ = N.height, G = getRadiusStyles(D, o.props.roundRelative, k, $), U = G.raws, z = G.styles, X = G.radiusPoses, V = splitRadiusPoses(X, U), Y = V.horizontals, W = V.verticals, q = z.join(" ");
  N.borderRadiusState = q;
  var K = fillParams(o, t, __assign$1({
    horizontals: Y,
    verticals: W,
    borderRadius: q,
    width: k,
    height: $,
    delta: r,
    dist: e
  }, fillCSSObject({
    borderRadius: q
  }, t)));
  return triggerEvent(o, "onRound", K), K;
}
function getStyleBorderRadius(o) {
  var t, e, r = o.getState().style, D = r.borderRadius || "";
  if (!D && o.props.groupable) {
    var N = o.moveables[0], k = o.getTargets()[0];
    k && ((N == null ? void 0 : N.props.target) === k ? (D = (e = (t = o.moveables[0]) === null || t === void 0 ? void 0 : t.state.style.borderRadius) !== null && e !== void 0 ? e : "", r.borderRadius = D) : (D = getComputedStyle$2(k).borderRadius, r.borderRadius = D));
  }
  return D;
}
var Roundable = {
  name: "roundable",
  props: ["roundable", "roundRelative", "minRoundControls", "maxRoundControls", "roundClickable", "roundPadding", "isDisplayShadowRoundControls"],
  events: ["roundStart", "round", "roundEnd", "roundGroupStart", "roundGroup", "roundGroupEnd"],
  css: [`.control.border-radius {
background: #d66;
cursor: pointer;
z-index: 3;
}`, `.control.border-radius.vertical {
background: #d6d;
z-index: 2;
}`, `.control.border-radius.virtual {
opacity: 0.5;
z-index: 1;
}`, `:host.round-line-clickable .line.direction {
cursor: pointer;
}`],
  className: function(o) {
    var t = o.props.roundClickable;
    return t === !0 || t === "line" ? prefix("round-line-clickable") : "";
  },
  requestStyle: function() {
    return ["borderRadius"];
  },
  requestChildStyle: function() {
    return ["borderRadius"];
  },
  render: function(o, t) {
    var e = o.getState(), r = e.target, D = e.width, N = e.height, k = e.allMatrix, $ = e.is3d, G = e.left, U = e.top, z = e.borderRadiusState, X = o.props, V = X.minRoundControls, Y = V === void 0 ? [0, 0] : V, W = X.maxRoundControls, q = W === void 0 ? [4, 4] : W, K = X.zoom, Z = X.roundPadding, J = Z === void 0 ? 0 : Z, Q = X.isDisplayShadowRoundControls, et = X.groupable;
    if (!r)
      return null;
    var it = z || getStyleBorderRadius(o), tt = $ ? 4 : 3, nt = getBorderRadius(it, D, N, Y, !0);
    if (!nt)
      return null;
    var st = 0, at = 0, ut = et ? [0, 0] : [G, U];
    return nt.map(function(ht, dt) {
      var pt = ht.horizontal, _t = ht.vertical, mt = ht.direction || "", yt = __spreadArray([], ht.pos, !0);
      at += Math.abs(pt), st += Math.abs(_t), pt && mt.indexOf("n") > -1 && (yt[1] -= J), _t && mt.indexOf("w") > -1 && (yt[0] -= J), pt && mt.indexOf("s") > -1 && (yt[1] += J), _t && mt.indexOf("e") > -1 && (yt[0] += J);
      var Tt = minus(calculatePosition(k, yt, tt), ut), Pt = ht.vertical ? st <= q[1] && (Q || !ht.virtual) : at <= q[0] && (Q || !ht.virtual);
      return t.createElement("div", {
        key: "borderRadiusControl".concat(dt),
        className: prefix("control", "border-radius", ht.vertical ? "vertical" : "", ht.virtual ? "virtual" : ""),
        "data-radius-index": dt,
        style: {
          display: Pt ? "block" : "none",
          transform: "translate(".concat(Tt[0], "px, ").concat(Tt[1], "px) scale(").concat(K, ")")
        }
      });
    });
  },
  dragControlCondition: function(o, t) {
    if (!t.inputEvent || t.isRequest)
      return !1;
    var e = t.inputEvent.target.getAttribute("class") || "";
    return e.indexOf("border-radius") > -1 || e.indexOf("moveable-line") > -1 && e.indexOf("moveable-direction") > -1;
  },
  dragGroupControlCondition: function(o, t) {
    return this.dragControlCondition(o, t);
  },
  dragControlStart: function(o, t) {
    var e = t.inputEvent, r = t.datas, D = e.target, N = D.getAttribute("class") || "", k = N.indexOf("border-radius") > -1, $ = N.indexOf("moveable-line") > -1 && N.indexOf("moveable-direction") > -1, G = k ? parseInt(D.getAttribute("data-radius-index"), 10) : -1, U = -1;
    if ($) {
      var z = D.getAttribute("data-line-key") || "";
      z && (U = parseInt(z.replace(/render-line-/g, ""), 10), isNaN(U) && (U = -1));
    }
    if (!k && !$)
      return !1;
    var X = fillParams(o, t, {}), V = triggerEvent(o, "onRoundStart", X);
    if (V === !1)
      return !1;
    r.lineIndex = U, r.controlIndex = G, r.isControl = k, r.isLine = $, setDragStart(o, t);
    var Y = o.props, W = Y.roundRelative, q = Y.minRoundControls, K = q === void 0 ? [0, 0] : q, Z = o.state, J = Z.width, Q = Z.height;
    r.isRound = !0, r.prevDist = [0, 0];
    var et = getStyleBorderRadius(o), it = getBorderRadius(et || "", J, Q, K, !0) || [];
    return r.controlPoses = it, Z.borderRadiusState = getRadiusStyles(it, W, J, Q).styles.join(" "), X;
  },
  dragControl: function(o, t) {
    var e = t.datas, r = e.controlPoses;
    if (!e.isRound || !e.isControl || !r.length)
      return !1;
    var D = e.controlIndex, N = getDragDist(t), k = N[0], $ = N[1], G = [k, $], U = minus(G, e.prevDist), z = o.props.maxRoundControls, X = z === void 0 ? [4, 4] : z, V = o.state, Y = V.width, W = V.height, q = r[D], K = q.vertical, Z = q.horizontal, J = r.map(function(et) {
      var it = et.horizontal, tt = et.vertical, nt = [it * Z * G[0], tt * K * G[1]];
      if (it) {
        if (X[0] === 1)
          return nt;
        if (X[0] < 4 && it !== Z)
          return nt;
      } else {
        if (X[1] === 0)
          return nt[1] = tt * Z * G[0] / Y * W, nt;
        if (K) {
          if (X[1] === 1)
            return nt;
          if (X[1] < 4 && tt !== K)
            return nt;
        }
      }
      return [0, 0];
    });
    J[D] = G;
    var Q = r.map(function(et, it) {
      return __assign$1(__assign$1({}, et), {
        pos: plus(et.pos, J[it])
      });
    });
    return D < 4 ? Q.slice(0, D + 1).forEach(function(et) {
      et.virtual = !1;
    }) : Q.slice(4, D + 1).forEach(function(et) {
      et.virtual = !1;
    }), e.prevDist = [k, $], triggerRoundEvent(o, t, G, U, Q);
  },
  dragControlEnd: function(o, t) {
    var e = o.state;
    e.borderRadiusState = "";
    var r = t.datas, D = t.isDouble;
    if (!r.isRound)
      return !1;
    var N = r.isControl, k = r.controlIndex, $ = r.isLine, G = r.lineIndex, U = r.controlPoses, z = U.filter(function(Z) {
      var J = Z.virtual;
      return J;
    }).length, X = o.props.roundClickable, V = X === void 0 ? !0 : X;
    if (D && V) {
      if (N && (V === !0 || V === "control"))
        removeBorderRadius(U, k);
      else if ($ && (V === !0 || V === "line")) {
        var Y = calculatePointerDist(o, t), W = Y[0], q = Y[1];
        addBorderRadiusByLine(U, G, W, q);
      }
      z !== U.filter(function(Z) {
        var J = Z.virtual;
        return J;
      }).length && triggerRoundEvent(o, t, [0, 0], [0, 0], U);
    }
    var K = fillEndParams(o, t, {});
    return triggerEvent(o, "onRoundEnd", K), e.borderRadiusState = "", K;
  },
  dragGroupControlStart: function(o, t) {
    var e = this.dragControlStart(o, t);
    if (!e)
      return !1;
    var r = o.moveables, D = o.props.targets, N = fillChildEvents(o, "roundable", t), k = __assign$1({
      targets: o.props.targets,
      events: N.map(function($, G) {
        return __assign$1(__assign$1({}, $), {
          target: D[G],
          moveable: r[G],
          currentTarget: r[G]
        });
      })
    }, e);
    return triggerEvent(o, "onRoundGroupStart", k), e;
  },
  dragGroupControl: function(o, t) {
    var e = this.dragControl(o, t);
    if (!e)
      return !1;
    var r = o.moveables, D = o.props.targets, N = fillChildEvents(o, "roundable", t), k = __assign$1({
      targets: o.props.targets,
      events: N.map(function($, G) {
        return __assign$1(__assign$1(__assign$1({}, $), {
          target: D[G],
          moveable: r[G],
          currentTarget: r[G]
        }), fillCSSObject({
          borderRadius: e.borderRadius
        }, $));
      })
    }, e);
    return triggerEvent(o, "onRoundGroup", k), k;
  },
  dragGroupControlEnd: function(o, t) {
    var e = o.moveables, r = o.props.targets, D = fillChildEvents(o, "roundable", t);
    catchEvent(o, "onRound", function($) {
      var G = __assign$1({
        targets: o.props.targets,
        events: D.map(function(U, z) {
          return __assign$1(__assign$1(__assign$1({}, U), {
            target: r[z],
            moveable: e[z],
            currentTarget: e[z]
          }), fillCSSObject({
            borderRadius: $.borderRadius
          }, U));
        })
      }, $);
      triggerEvent(o, "onRoundGroup", G);
    });
    var N = this.dragControlEnd(o, t);
    if (!N)
      return !1;
    var k = __assign$1({
      targets: o.props.targets,
      events: D.map(function($, G) {
        var U;
        return __assign$1(__assign$1({}, $), {
          target: r[G],
          moveable: e[G],
          currentTarget: e[G],
          lastEvent: (U = $.datas) === null || U === void 0 ? void 0 : U.lastEvent
        });
      })
    }, N);
    return triggerEvent(o, "onRoundGroupEnd", k), k;
  },
  unset: function(o) {
    o.state.borderRadiusState = "";
  }
};
function isIdentityMatrix(o, t) {
  var e = t ? 4 : 3, r = createIdentityMatrix(e), D = "matrix".concat(t ? "3d" : "", "(").concat(r.join(","), ")");
  return o === D || o === "matrix(1,0,0,1,0,0)";
}
var BeforeRenderable = {
  isPinch: !0,
  name: "beforeRenderable",
  props: [],
  events: ["beforeRenderStart", "beforeRender", "beforeRenderEnd", "beforeRenderGroupStart", "beforeRenderGroup", "beforeRenderGroupEnd"],
  dragRelation: "weak",
  setTransform: function(o, t) {
    var e = o.state, r = e.is3d, D = e.target, N = e.targetMatrix, k = D == null ? void 0 : D.style.transform, $ = r ? "matrix3d(".concat(N.join(","), ")") : "matrix(".concat(convertMatrixtoCSS(N, !0), ")"), G = !k || k === "none" ? $ : k;
    t.datas.startTransforms = isIdentityMatrix(G, r) ? [] : splitSpace(G);
  },
  resetStyle: function(o) {
    var t = o.datas;
    t.nextStyle = {}, t.nextTransforms = o.datas.startTransforms, t.nextTransformAppendedIndexes = [];
  },
  fillDragStartParams: function(o, t) {
    return fillParams(o, t, {
      setTransform: function(e) {
        t.datas.startTransforms = isArray(e) ? e : splitSpace(e);
      },
      isPinch: !!t.isPinch
    });
  },
  fillDragParams: function(o, t) {
    return fillParams(o, t, {
      isPinch: !!t.isPinch
    });
  },
  dragStart: function(o, t) {
    this.setTransform(o, t), this.resetStyle(t), triggerEvent(o, "onBeforeRenderStart", this.fillDragStartParams(o, t));
  },
  drag: function(o, t) {
    this.resetStyle(t), triggerEvent(o, "onBeforeRender", fillParams(o, t, {
      isPinch: !!t.isPinch
    }));
  },
  dragEnd: function(o, t) {
    triggerEvent(o, "onBeforeRenderEnd", fillParams(o, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag
    }));
  },
  dragGroupStart: function(o, t) {
    var e = this;
    this.dragStart(o, t);
    var r = fillChildEvents(o, "beforeRenderable", t), D = o.moveables, N = r.map(function(k, $) {
      var G = D[$];
      return e.setTransform(G, k), e.resetStyle(k), e.fillDragStartParams(G, k);
    });
    triggerEvent(o, "onBeforeRenderGroupStart", fillParams(o, t, {
      isPinch: !!t.isPinch,
      targets: o.props.targets,
      setTransform: function() {
      },
      events: N
    }));
  },
  dragGroup: function(o, t) {
    var e = this;
    this.drag(o, t);
    var r = fillChildEvents(o, "beforeRenderable", t), D = o.moveables, N = r.map(function(k, $) {
      var G = D[$];
      return e.resetStyle(k), e.fillDragParams(G, k);
    });
    triggerEvent(o, "onBeforeRenderGroup", fillParams(o, t, {
      isPinch: !!t.isPinch,
      targets: o.props.targets,
      events: N
    }));
  },
  dragGroupEnd: function(o, t) {
    this.dragEnd(o, t), triggerEvent(o, "onBeforeRenderGroupEnd", fillParams(o, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      targets: o.props.targets
    }));
  },
  dragControlStart: function(o, t) {
    return this.dragStart(o, t);
  },
  dragControl: function(o, t) {
    return this.drag(o, t);
  },
  dragControlEnd: function(o, t) {
    return this.dragEnd(o, t);
  },
  dragGroupControlStart: function(o, t) {
    return this.dragGroupStart(o, t);
  },
  dragGroupControl: function(o, t) {
    return this.dragGroup(o, t);
  },
  dragGroupControlEnd: function(o, t) {
    return this.dragGroupEnd(o, t);
  }
}, Renderable = {
  name: "renderable",
  props: [],
  events: ["renderStart", "render", "renderEnd", "renderGroupStart", "renderGroup", "renderGroupEnd"],
  dragRelation: "weak",
  dragStart: function(o, t) {
    triggerEvent(o, "onRenderStart", fillParams(o, t, {
      isPinch: !!t.isPinch
    }));
  },
  drag: function(o, t) {
    triggerEvent(o, "onRender", this.fillDragParams(o, t));
  },
  dragAfter: function(o, t) {
    return this.drag(o, t);
  },
  dragEnd: function(o, t) {
    triggerEvent(o, "onRenderEnd", this.fillDragEndParams(o, t));
  },
  dragGroupStart: function(o, t) {
    triggerEvent(o, "onRenderGroupStart", fillParams(o, t, {
      isPinch: !!t.isPinch,
      targets: o.props.targets
    }));
  },
  dragGroup: function(o, t) {
    var e = this, r = fillChildEvents(o, "beforeRenderable", t), D = o.moveables, N = r.map(function(k, $) {
      var G = D[$];
      return e.fillDragParams(G, k);
    });
    triggerEvent(o, "onRenderGroup", fillParams(o, t, __assign$1(__assign$1({
      isPinch: !!t.isPinch,
      targets: o.props.targets,
      transform: getNextTransformText(t)
    }, fillCSSObject(getNextStyle(t))), {
      events: N
    })));
  },
  dragGroupEnd: function(o, t) {
    var e = this, r = fillChildEvents(o, "beforeRenderable", t), D = o.moveables, N = r.map(function(k, $) {
      var G = D[$];
      return e.fillDragEndParams(G, k);
    });
    triggerEvent(o, "onRenderGroupEnd", fillParams(o, t, __assign$1({
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      targets: o.props.targets,
      events: N,
      transform: getNextTransformText(t)
    }, fillCSSObject(getNextStyle(t)))));
  },
  dragControlStart: function(o, t) {
    return this.dragStart(o, t);
  },
  dragControl: function(o, t) {
    return this.drag(o, t);
  },
  dragControlAfter: function(o, t) {
    return this.dragAfter(o, t);
  },
  dragControlEnd: function(o, t) {
    return this.dragEnd(o, t);
  },
  dragGroupControlStart: function(o, t) {
    return this.dragGroupStart(o, t);
  },
  dragGroupControl: function(o, t) {
    return this.dragGroup(o, t);
  },
  dragGroupControlEnd: function(o, t) {
    return this.dragGroupEnd(o, t);
  },
  fillDragParams: function(o, t) {
    return fillParams(o, t, __assign$1({
      isPinch: !!t.isPinch,
      transform: getNextTransformText(t)
    }, fillCSSObject(getNextStyle(t))));
  },
  fillDragEndParams: function(o, t) {
    return fillParams(o, t, __assign$1({
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      transform: getNextTransformText(t)
    }, fillCSSObject(getNextStyle(t))));
  }
};
function triggerAble(o, t, e, r, D, N, k) {
  N.clientDistX = N.distX, N.clientDistY = N.distY;
  var $ = D === "Start", G = D === "End", U = D === "After", z = o.state.target, X = N.isRequest;
  if (!z || $ && r.indexOf("Control") > -1 && !X && o.areaElement === N.inputEvent.target)
    return !1;
  var V = __spreadArray([], o[t], !0);
  if (X) {
    var Y = N.requestAble;
    V.some(function(at) {
      return at.name === Y;
    }) || V.push.apply(V, o.props.ables.filter(function(at) {
      return at.name === Y;
    }));
  }
  if (!V.length || V.every(function(at) {
    return at.dragRelation;
  }))
    return !1;
  var W = N.inputEvent, q;
  G && W && (q = document.elementFromPoint(N.clientX, N.clientY) || W.target);
  var K = !1, Z = function() {
    var at;
    K = !0, (at = N.stop) === null || at === void 0 || at.call(N);
  }, J = $ && (!o.targetGesto || !o.controlGesto || !o.targetGesto.isFlag() || !o.controlGesto.isFlag());
  J && o.updateRect(D, !0, !1);
  var Q = N.datas, et = function(at, ut, ht) {
    if (!(ut in at))
      return !1;
    var dt = at.name, pt = Q[dt] || (Q[dt] = {});
    if ($ && (pt.isEventStart = !ht || !at[ht] || at[ht](o, N)), !pt.isEventStart)
      return !1;
    var _t = at[ut](o, __assign$1(__assign$1({}, N), {
      stop: Z,
      datas: pt,
      originalDatas: Q,
      inputTarget: q
    }));
    return o._emitter.off(), $ && _t === !1 && (pt.isEventStart = !1), _t;
  };
  J && V.forEach(function(at) {
    at.unset && at.unset(o);
  }), et(BeforeRenderable, "drag".concat(r).concat(D));
  var it = 0, tt = 0;
  e.forEach(function(at) {
    if (K)
      return !1;
    var ut = "".concat(at).concat(r).concat(D), ht = "".concat(at).concat(r, "Condition");
    D === "" && !X && convertDragDist(o.state, N);
    var dt = V.filter(function(mt) {
      return mt[ut];
    });
    dt = dt.filter(function(mt, yt) {
      return mt.name && dt.indexOf(mt) === yt;
    });
    var pt = dt.filter(function(mt) {
      return et(mt, ut, ht);
    }), _t = pt.length;
    K && ++it, _t && ++tt, !K && $ && dt.length && !_t && (it += dt.filter(function(mt) {
      var yt = mt.name, Tt = Q[yt];
      return Tt.isEventStart ? mt.dragRelation !== "strong" : !1;
    }).length ? 1 : 0);
  }), (!U || tt) && et(Renderable, "drag".concat(r).concat(D));
  var nt = it === e.length;
  if ((G || K || nt) && (o.state.gestos = {}, o.moveables && o.moveables.forEach(function(at) {
    at.state.gestos = {};
  }), V.forEach(function(at) {
    at.unset && at.unset(o);
  })), $ && !nt && !X && tt && o.props.preventDefault && (N == null || N.preventDefault()), o.isUnmounted || nt)
    return !1;
  if (!$ && tt && !k || G) {
    var st = o.props.flushSync || defaultSync;
    st(function() {
      o.updateRect(G ? D : "", !0, !1), o.forceUpdate();
    });
  }
  return !$ && !G && !U && tt && !k && triggerAble(o, t, e, r, D + "After", N), !0;
}
function checkMoveableTarget(o) {
  return function(t) {
    var e = o.props.dragTarget, r = t.inputEvent.target, D = o.areaElement;
    return e && (r === e || e.contains(r)) || r === D || !o.isMoveableElement(r) && !o.controlBox.contains(r) || hasClass(r, "moveable-area") || hasClass(r, "moveable-padding") || hasClass(r, "moveable-edgeDraggable");
  };
}
function getTargetAbleGesto(o, t, e) {
  var r = o.controlBox, D = [], N = o.props.dragTarget;
  return D.push(r), (!o.props.dragArea || N) && D.push(t), getAbleGesto(o, D, "targetAbles", e, {
    dragStart: checkMoveableTarget(o),
    pinchStart: checkMoveableTarget(o)
  });
}
function getAbleGesto(o, t, e, r, D) {
  D === void 0 && (D = {});
  var N = e === "targetAbles", k = o.props, $ = k.pinchOutside, G = k.pinchThreshold, U = k.preventClickEventOnDrag, z = k.preventClickDefault, X = k.checkInput, V = k.preventDefault, Y = V === void 0 ? !0 : V, W = {
    preventDefault: Y,
    preventRightClick: !0,
    preventWheelClick: !0,
    container: window,
    pinchThreshold: G,
    pinchOutside: $,
    preventClickEventOnDrag: N ? U : !1,
    preventClickEventOnDragStart: N ? z : !1,
    preventClickEventByCondition: N ? null : function(Z) {
      return o.controlBox.contains(Z.target);
    },
    checkInput: N ? X : !1
  }, q = new Gesto(t, W), K = r === "Control";
  return ["drag", "pinch"].forEach(function(Z) {
    ["Start", "", "End"].forEach(function(J) {
      q.on("".concat(Z).concat(J), function(Q) {
        var et, it = Q.eventType, tt = Z === "drag" && Q.isPinch;
        if (D[it] && !D[it](Q)) {
          Q.stop();
          return;
        }
        if (!tt) {
          var nt = Z === "drag" ? [Z] : ["drag", Z], st = triggerAble(o, e, nt, r, J, Q);
          st ? (o.props.stopPropagation || J === "Start" && K) && ((et = Q == null ? void 0 : Q.inputEvent) === null || et === void 0 || et.stopPropagation()) : Q.stop();
        }
      });
    });
  }), q;
}
var EventManager = /* @__PURE__ */ function() {
  function o(e, r, D) {
    var N = this;
    this.target = e, this.moveable = r, this.eventName = D, this.ables = [], this._onEvent = function(k) {
      var $ = N.eventName, G = N.moveable;
      G.state.disableNativeEvent || N.ables.forEach(function(U) {
        U[$](G, {
          inputEvent: k
        });
      });
    }, e.addEventListener(D.toLowerCase(), this._onEvent);
  }
  var t = o.prototype;
  return t.setAbles = function(e) {
    this.ables = e;
  }, t.destroy = function() {
    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent), this.target = null, this.moveable = null;
  }, o;
}();
function calculateMatrixStack(o, t, e, r) {
  var D;
  e === void 0 && (e = t);
  var N = getMatrixStackInfo(o, t), k = N.matrixes, $ = N.is3d, G = N.targetMatrix, U = N.transformOrigin, z = N.targetOrigin, X = N.offsetContainer, V = N.hasFixed, Y = N.zoom, W = getCachedMatrixContainerInfo(X, e), q = W.matrixes, K = W.is3d, Z = W.offsetContainer, J = W.zoom, Q = r || K || $, et = Q ? 4 : 3, it = o.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in o, tt = G, nt = createIdentityMatrix(et), st = createIdentityMatrix(et), at = createIdentityMatrix(et), ut = createIdentityMatrix(et), ht = k.length, dt = __spreadArray([], q, !0).reverse();
  k.reverse(), !$ && Q && (tt = convertDimension(tt, 3, 4), convert3DMatrixes(k)), !K && Q && convert3DMatrixes(dt), dt.forEach(function(St) {
    st = multiply(st, St.matrix, et);
  });
  var pt = e || document.body, _t = ((D = dt[0]) === null || D === void 0 ? void 0 : D.target) || getOffsetInfo(pt, pt, !0).offsetParent, mt = dt.slice(1).reduce(function(St, gt) {
    return multiply(St, gt.matrix, et);
  }, createIdentityMatrix(et));
  k.forEach(function(St, gt) {
    if (ht - 2 === gt && (at = nt.slice()), ht - 1 === gt && (ut = nt.slice()), !St.matrix) {
      var bt = k[gt + 1], At = getSVGOffset(St, bt, _t, et, multiply(mt, nt, et));
      St.matrix = createOriginMatrix(At, et);
    }
    nt = multiply(nt, St.matrix, et);
  });
  var yt = !it && $;
  tt || (tt = createIdentityMatrix(yt ? 4 : 3));
  var Tt = makeMatrixCSS(it && tt.length === 16 ? convertDimension(tt, 4, 3) : tt, yt), Pt = st;
  return st = ignoreDimension(st, et, et), {
    hasZoom: Y !== 1 || J !== 1,
    hasFixed: V,
    rootMatrix: st,
    originalRootMatrix: Pt,
    beforeMatrix: at,
    offsetMatrix: ut,
    allMatrix: nt,
    targetMatrix: tt,
    targetTransform: Tt,
    transformOrigin: U,
    targetOrigin: z,
    is3d: Q,
    offsetContainer: X,
    offsetRootContainer: Z
  };
}
function calculateElementInfo(o, t, e, r) {
  e === void 0 && (e = t);
  var D = 0, N = 0, k = 0, $ = {}, G = getSize(o);
  if (o && (D = G.offsetWidth, N = G.offsetHeight), o) {
    var U = calculateMatrixStack(o, t, e, r), z = calculateMoveablePosition(U.allMatrix, U.transformOrigin, D, N);
    $ = __assign$1(__assign$1({}, U), z);
    var X = calculateMoveablePosition(U.allMatrix, [50, 50], 100, 100);
    k = getRotationRad([X.pos1, X.pos2], X.direction);
  }
  var V = r ? 4 : 3;
  return __assign$1(__assign$1(__assign$1({
    hasZoom: !1,
    width: D,
    height: N,
    rotation: k
  }, G), {
    originalRootMatrix: createIdentityMatrix(V),
    rootMatrix: createIdentityMatrix(V),
    beforeMatrix: createIdentityMatrix(V),
    offsetMatrix: createIdentityMatrix(V),
    allMatrix: createIdentityMatrix(V),
    targetMatrix: createIdentityMatrix(V),
    targetTransform: "",
    transformOrigin: [0, 0],
    targetOrigin: [0, 0],
    is3d: !!r,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    origin: [0, 0],
    pos1: [0, 0],
    pos2: [0, 0],
    pos3: [0, 0],
    pos4: [0, 0],
    direction: 1,
    hasFixed: !1,
    offsetContainer: null,
    offsetRootContainer: null
  }), $);
}
function getMoveableTargetInfo(o, t, e, r, D, N) {
  N === void 0 && (N = []);
  var k = 1, $ = [0, 0], G = resetClientRect(), U = resetClientRect(), z = resetClientRect(), X = resetClientRect(), V = [0, 0], Y = {}, W = calculateElementInfo(t, e, D, !0);
  if (t) {
    var q = getCachedStyle(t);
    N.forEach(function(dt) {
      Y[dt] = q(dt);
    });
    var K = W.is3d ? 4 : 3, Z = calculateMoveablePosition(W.offsetMatrix, plus(W.transformOrigin, getOrigin(W.targetMatrix, K)), W.width, W.height);
    k = Z.direction, $ = plus(Z.origin, [Z.left - W.left, Z.top - W.top]), X = getClientRect(W.offsetRootContainer);
    var J = getOffsetInfo(r, r, !0).offsetParent || W.offsetRootContainer;
    if (W.hasZoom) {
      var Q = calculateMoveablePosition(multiply(W.originalRootMatrix, W.allMatrix), W.transformOrigin, W.width, W.height), et = calculateMoveablePosition(W.originalRootMatrix, getTransformOriginArray(getCachedStyle(J)("transformOrigin")).map(function(dt) {
        return parseFloat(dt);
      }), J.offsetWidth, J.offsetHeight);
      if (G = getClientRectByPosition(Q, X), z = getClientRectByPosition(et, X, J, !0), o) {
        var it = Q.left, tt = Q.top;
        U = getClientRectByPosition({
          left: it,
          top: tt,
          bottom: tt,
          right: tt
        }, X);
      }
    } else {
      G = getClientRect(t), z = getCachedClientRect(J), o && (U = getClientRect(o));
      var nt = z.left, st = z.top, at = z.clientLeft, ut = z.clientTop, ht = [G.left - nt, G.top - st];
      V = minus(calculateInversePosition(W.rootMatrix, ht, 4), [at + W.left, ut + W.top]);
    }
  }
  return __assign$1({
    targetClientRect: G,
    containerClientRect: z,
    moveableClientRect: U,
    rootContainerClientRect: X,
    beforeDirection: k,
    beforeOrigin: $,
    originalBeforeOrigin: $,
    target: t,
    style: Y,
    offsetDelta: V
  }, W);
}
function getPersistState(o) {
  var t = o.pos1, e = o.pos2, r = o.pos3, D = o.pos4;
  if (!t || !e || !r || !D)
    return null;
  var N = getMinMaxs([t, e, r, D]), k = [N.minX, N.minY], $ = minus(o.origin, k);
  return t = minus(t, k), e = minus(e, k), r = minus(r, k), D = minus(D, k), __assign$1(__assign$1({}, o), {
    left: o.left,
    top: o.top,
    posDelta: k,
    pos1: t,
    pos2: e,
    pos3: r,
    pos4: D,
    origin: $,
    beforeOrigin: $,
    // originalBeforeOrigin: origin,
    isPersisted: !0
  });
}
var MoveableManager$1 = /* @__PURE__ */ function(o) {
  __extends$1(t, o);
  function t() {
    var r = o !== null && o.apply(this, arguments) || this;
    return r.state = __assign$1({
      container: null,
      gestos: {},
      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],
      disableNativeEvent: !1,
      posDelta: [0, 0]
    }, getMoveableTargetInfo(null)), r.renderState = {}, r.enabledAbles = [], r.targetAbles = [], r.controlAbles = [], r.rotation = 0, r.scale = [1, 1], r.isMoveableMounted = !1, r.isUnmounted = !1, r.events = {
      mouseEnter: null,
      mouseLeave: null
    }, r._emitter = new EventEmitter$1(), r._prevTarget = null, r._prevDragArea = !1, r._isPropTargetChanged = !1, r._hasFirstTarget = !1, r._reiszeObserver = null, r._observerId = 0, r._mutationObserver = null, r._rootContainer = null, r._viewContainer = null, r._viewClassNames = [], r._store = {}, r.checkUpdateRect = function() {
      if (!r.isDragging()) {
        var D = r.props.parentMoveable;
        if (D) {
          D.checkUpdateRect();
          return;
        }
        cancelAnimationFrame$1(r._observerId), r._observerId = requestAnimationFrame$1(function() {
          r.isDragging() || r.updateRect();
        });
      }
    }, r._onPreventClick = function(D) {
      D.stopPropagation(), D.preventDefault();
    }, r;
  }
  var e = t.prototype;
  return e.render = function() {
    var r = this.props, D = this.getState(), N = r.parentPosition, k = r.className, $ = r.target, G = r.zoom, U = r.cspNonce, z = r.translateZ, X = r.cssStyled, V = r.groupable, Y = r.linePadding, W = r.controlPadding;
    this._checkUpdateRootContainer(), this.checkUpdate(), this.updateRenderPoses();
    var q = N || [0, 0], K = q[0], Z = q[1], J = D.left, Q = D.top, et = D.target, it = D.direction, tt = D.hasFixed, nt = D.offsetDelta, st = r.targets, at = this.isDragging(), ut = {};
    this.getEnabledAbles().forEach(function(yt) {
      ut["data-able-".concat(yt.name.toLowerCase())] = !0;
    });
    var ht = this._getAbleClassName(), dt = st && st.length && (et || V) || $ || !this._hasFirstTarget && this.state.isPersisted, pt = this.controlBox || this.props.firstRenderState || this.props.persistData, _t = [J - K, Q - Z];
    !V && r.useAccuratePosition && (_t[0] += nt[0], _t[1] += nt[1]);
    var mt = {
      position: tt ? "fixed" : "absolute",
      display: dt ? "block" : "none",
      visibility: pt ? "visible" : "hidden",
      transform: "translate3d(".concat(_t[0], "px, ").concat(_t[1], "px, ").concat(z, ")"),
      "--zoom": G,
      "--zoompx": "".concat(G, "px")
    };
    return Y && (mt["--moveable-line-padding"] = Y), W && (mt["--moveable-control-padding"] = W), createElement(X, __assign$1({
      cspNonce: U,
      ref: ref(this, "controlBox"),
      className: "".concat(prefix("control-box", it === -1 ? "reverse" : "", at ? "dragging" : ""), " ").concat(ht, " ").concat(k)
    }, ut, {
      onClick: this._onPreventClick,
      style: mt
    }), this.renderAbles(), this._renderLines());
  }, e.componentDidMount = function() {
    this.isMoveableMounted = !0, this.isUnmounted = !1;
    var r = this.props, D = r.parentMoveable, N = r.container, k = r.wrapperMoveable;
    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(this.props), !N && !D && !k && !this.state.isPersisted && (this.updateRect("", !1, !1), this.forceUpdate());
  }, e.componentDidUpdate = function(r) {
    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateNativeEvents(), this._updateEvents(), this._updateTargets(), this.updateCheckInput(), this._updateObserver(r);
  }, e.componentWillUnmount = function() {
    var r, D;
    this.isMoveableMounted = !1, this.isUnmounted = !0, this._emitter.off(), (r = this._reiszeObserver) === null || r === void 0 || r.disconnect(), (D = this._mutationObserver) === null || D === void 0 || D.disconnect();
    var N = this._viewContainer;
    N && this._changeAbleViewClassNames([]), unset(this, "targetGesto"), unset(this, "controlGesto");
    var k = this.events;
    for (var $ in k) {
      var G = k[$];
      G && G.destroy();
    }
  }, e.getTargets = function() {
    var r = this.props.target;
    return r ? [r] : [];
  }, e.getAble = function(r) {
    var D = this.props.ables || [];
    return find$1(D, function(N) {
      return N.name === r;
    });
  }, e.getContainer = function() {
    var r = this.props, D = r.parentMoveable, N = r.wrapperMoveable, k = r.container;
    return k || N && N.getContainer() || D && D.getContainer() || this.controlBox.parentElement;
  }, e.isMoveableElement = function(r) {
    var D;
    return r && (((D = r.getAttribute) === null || D === void 0 ? void 0 : D.call(r, "class")) || "").indexOf(PREFIX) > -1;
  }, e.dragStart = function(r) {
    var D = this.targetGesto, N = this.controlGesto;
    return D && checkMoveableTarget(this)({
      inputEvent: r
    }) ? D.isFlag() || D.triggerDragStart(r) : N && this.isMoveableElement(r.target) && (N.isFlag() || N.triggerDragStart(r)), this;
  }, e.hitTest = function(r) {
    var D = this.state, N = D.target, k = D.pos1, $ = D.pos2, G = D.pos3, U = D.pos4, z = D.targetClientRect;
    if (!N)
      return 0;
    var X;
    if (r instanceof Element) {
      var V = r.getBoundingClientRect();
      X = {
        left: V.left,
        top: V.top,
        width: V.width,
        height: V.height
      };
    } else
      X = __assign$1({
        width: 0,
        height: 0
      }, r);
    var Y = X.left, W = X.top, q = X.width, K = X.height, Z = fitPoints([k, $, U, G], z), J = getOverlapSize(Z, [[Y, W], [Y + q, W], [Y + q, W + K], [Y, W + K]]), Q = getAreaSize(Z);
    return !J || !Q ? 0 : Math.min(100, J / Q * 100);
  }, e.isInside = function(r, D) {
    var N = this.state, k = N.target, $ = N.pos1, G = N.pos2, U = N.pos3, z = N.pos4, X = N.targetClientRect;
    return k ? isInside([r, D], fitPoints([$, G, z, U], X)) : !1;
  }, e.updateRect = function(r, D, N) {
    N === void 0 && (N = !0);
    var k = this.props, $ = !k.parentPosition && !k.wrapperMoveable;
    $ && setStoreCache(!0);
    var G = k.parentMoveable, U = this.state, z = U.target || k.target, X = this.getContainer(), V = G ? G._rootContainer : this._rootContainer, Y = getMoveableTargetInfo(this.controlBox, z, X, X, V || X, this._getRequestStyles());
    if (!z && this._hasFirstTarget && k.persistData) {
      var W = getPersistState(k.persistData);
      for (var q in W)
        Y[q] = W[q];
    }
    $ && setStoreCache(), this.updateState(Y, G ? !1 : N);
  }, e.isDragging = function(r) {
    var D, N, k = this.targetGesto, $ = this.controlGesto;
    if (k != null && k.isFlag()) {
      if (!r)
        return !0;
      var G = k.getEventData();
      return !!(!((D = G[r]) === null || D === void 0) && D.isEventStart);
    }
    if ($ != null && $.isFlag()) {
      if (!r)
        return !0;
      var G = $.getEventData();
      return !!(!((N = G[r]) === null || N === void 0) && N.isEventStart);
    }
    return !1;
  }, e.updateTarget = function(r) {
    this.updateRect(r, !0);
  }, e.getRect = function() {
    var r = this.state, D = getAbsolutePosesByState(this.state), N = D[0], k = D[1], $ = D[2], G = D[3], U = getRect(D), z = r.width, X = r.height, V = U.width, Y = U.height, W = U.left, q = U.top, K = [r.left, r.top], Z = plus(K, r.origin), J = plus(K, r.beforeOrigin), Q = r.transformOrigin;
    return {
      width: V,
      height: Y,
      left: W,
      top: q,
      pos1: N,
      pos2: k,
      pos3: $,
      pos4: G,
      offsetWidth: z,
      offsetHeight: X,
      beforeOrigin: J,
      origin: Z,
      transformOrigin: Q,
      rotation: this.getRotation()
    };
  }, e.getManager = function() {
    return this;
  }, e.stopDrag = function(r) {
    var D, N;
    (!r || r === "target") && ((D = this.targetGesto) === null || D === void 0 || D.stop()), (!r || r === "control") && ((N = this.controlGesto) === null || N === void 0 || N.stop());
  }, e.getRotation = function() {
    var r = this.state, D = r.pos1, N = r.pos2, k = r.direction;
    return getAbsoluteRotation(D, N, k);
  }, e.request = function(r, D, N) {
    D === void 0 && (D = {});
    var k = this.props, $ = k.ables, G = k.groupable, U = $.filter(function(K) {
      return K.name === r;
    })[0];
    if (this.isDragging() || !U || !U.request)
      return {
        request: function() {
          return this;
        },
        requestEnd: function() {
          return this;
        }
      };
    var z = this, X = U.request(this), V = N || D.isInstant, Y = X.isControl ? "controlAbles" : "targetAbles", W = "".concat(G ? "Group" : "").concat(X.isControl ? "Control" : ""), q = {
      request: function(K) {
        return triggerAble(z, Y, ["drag"], W, "", __assign$1(__assign$1({}, X.request(K)), {
          requestAble: r,
          isRequest: !0
        }), V), this;
      },
      requestEnd: function() {
        return triggerAble(z, Y, ["drag"], W, "End", __assign$1(__assign$1({}, X.requestEnd()), {
          requestAble: r,
          isRequest: !0
        }), V), this;
      }
    };
    return triggerAble(z, Y, ["drag"], W, "Start", __assign$1(__assign$1({}, X.requestStart(D)), {
      requestAble: r,
      isRequest: !0
    }), V), V ? q.request(D).requestEnd() : q;
  }, e.destroy = function() {
    this.componentWillUnmount();
  }, e.updateRenderPoses = function() {
    var r = this.getState(), D = this.props, N = r.originalBeforeOrigin, k = r.transformOrigin, $ = r.allMatrix, G = r.is3d, U = r.pos1, z = r.pos2, X = r.pos3, V = r.pos4, Y = r.left, W = r.top, q = r.isPersisted, K = D.padding || {}, Z = K.left, J = Z === void 0 ? 0 : Z, Q = K.top, et = Q === void 0 ? 0 : Q, it = K.bottom, tt = it === void 0 ? 0 : it, nt = K.right, st = nt === void 0 ? 0 : nt, at = G ? 4 : 3, ut = [];
    q ? ut = k : this.controlBox && D.groupable ? ut = N : ut = plus(N, [Y, W]), r.renderPoses = [plus(U, calculatePadding($, [-J, -et], k, ut, at)), plus(z, calculatePadding($, [st, -et], k, ut, at)), plus(X, calculatePadding($, [-J, tt], k, ut, at)), plus(V, calculatePadding($, [st, tt], k, ut, at))];
  }, e.checkUpdate = function() {
    this._isPropTargetChanged = !1;
    var r = this.props, D = r.target, N = r.container, k = r.parentMoveable, $ = this.state, G = $.target, U = $.container;
    if (!(!G && !D)) {
      this.updateAbles();
      var z = !equals(G, D), X = z || !equals(U, N);
      if (X) {
        var V = N || this.controlBox;
        V && this.unsetAbles(), this.updateState({
          target: D,
          container: N
        }), !k && V && this.updateRect("End", !1, !1), this._isPropTargetChanged = z;
      }
    }
  }, e.waitToChangeTarget = function() {
    return new Promise(function() {
    });
  }, e.triggerEvent = function(r, D) {
    this._emitter.trigger(r, D);
    var N = this.props[r];
    return N && N(D);
  }, e.useCSS = function(r, D) {
    var N = this.props.customStyledMap, k = r + D;
    return N[k] || (N[k] = styled(r, D)), N[k];
  }, e.getState = function() {
    var r, D = this.props;
    (D.target || !((r = D.targets) === null || r === void 0) && r.length) && (this._hasFirstTarget = !0);
    var N = this.controlBox, k = D.persistData, $ = D.firstRenderState;
    if ($ && !N)
      return $;
    if (!this._hasFirstTarget && k) {
      var G = getPersistState(k);
      if (G)
        return this.updateState(G, !1), this.state;
    }
    return this.state.isPersisted = !1, this.state;
  }, e.updateSelectors = function() {
  }, e.unsetAbles = function() {
    var r = this;
    this.targetAbles.forEach(function(D) {
      D.unset && D.unset(r);
    });
  }, e.updateAbles = function(r, D) {
    r === void 0 && (r = this.props.ables), D === void 0 && (D = "");
    var N = this.props, k = N.triggerAblesSimultaneously, $ = this.getEnabledAbles(r), G = "drag".concat(D, "Start"), U = "pinch".concat(D, "Start"), z = "drag".concat(D, "ControlStart"), X = filterAbles($, [G, U], k), V = filterAbles($, [z], k);
    this.enabledAbles = $, this.targetAbles = X, this.controlAbles = V;
  }, e.updateState = function(r, D) {
    if (D) {
      if (this.isUnmounted)
        return;
      this.setState(r);
    } else {
      var N = this.state;
      for (var k in r)
        N[k] = r[k];
    }
  }, e.getEnabledAbles = function(r) {
    r === void 0 && (r = this.props.ables);
    var D = this.props;
    return r.filter(function(N) {
      return N && (N.always && D[N.name] !== !1 || D[N.name]);
    });
  }, e.renderAbles = function() {
    var r = this, D = this.props, N = D.triggerAblesSimultaneously, k = {
      createElement
    };
    return this.renderState = {}, groupByMap(flat(filterAbles(this.getEnabledAbles(), ["render"], N).map(function($) {
      var G = $.render;
      return G(r, k) || [];
    })).filter(function($) {
      return $;
    }), function($) {
      var G = $.key;
      return G;
    }).map(function($) {
      return $[0];
    });
  }, e.updateCheckInput = function() {
    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);
  }, e._getRequestStyles = function() {
    var r = this.getEnabledAbles().reduce(function(D, N) {
      var k, $, G = ($ = (k = N.requestStyle) === null || k === void 0 ? void 0 : k.call(N)) !== null && $ !== void 0 ? $ : [];
      return __spreadArray(__spreadArray([], D, !0), G, !0);
    }, __spreadArray([], this.props.requestStyles || [], !0));
    return r;
  }, e._updateObserver = function(r) {
    this._updateResizeObserver(r), this._updateMutationObserver(r);
  }, e._updateEvents = function() {
    var r = this.controlBox, D = this.targetAbles.length, N = this.controlAbles.length, k = this.props, $ = k.dragTarget || k.target, G = !D && this.targetGesto || this._isTargetChanged(!0);
    G && (unset(this, "targetGesto"), this.updateState({
      gesto: null
    })), N || unset(this, "controlGesto"), $ && D && !this.targetGesto && (this.targetGesto = getTargetAbleGesto(this, $, "")), !this.controlGesto && N && (this.controlGesto = getAbleGesto(this, r, "controlAbles", "Control"));
  }, e._updateTargets = function() {
    var r = this.props;
    this._prevTarget = r.dragTarget || r.target, this._prevDragArea = r.dragArea;
  }, e._renderLines = function() {
    var r = this.props, D = r, N = D.zoom, k = D.hideDefaultLines, $ = D.hideChildMoveableDefaultLines, G = D.parentMoveable;
    if (k || G && $)
      return [];
    var U = this.getState().renderPoses, z = {
      createElement
    };
    return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(X, V) {
      var Y = X[0], W = X[1];
      return renderLine(z, "", U[Y], U[W], N, "render-line-".concat(V));
    });
  }, e._isTargetChanged = function(r) {
    var D = this.props, N = D.dragTarget || D.target, k = this._prevTarget, $ = this._prevDragArea, G = D.dragArea, U = !G && k !== N, z = (r || G) && $ !== G;
    return U || z;
  }, e._updateNativeEvents = function() {
    var r = this, D = this.props, N = D.dragArea ? this.areaElement : this.state.target, k = this.events, $ = getKeys(k);
    if (this._isTargetChanged())
      for (var G in k) {
        var U = k[G];
        U && U.destroy(), k[G] = null;
      }
    if (N) {
      var z = this.enabledAbles;
      $.forEach(function(X) {
        var V = filterAbles(z, [X]), Y = V.length > 0, W = k[X];
        if (!Y) {
          W && (W.destroy(), k[X] = null);
          return;
        }
        W || (W = new EventManager(N, r, X), k[X] = W), W.setAbles(V);
      });
    }
  }, e._checkUpdateRootContainer = function() {
    var r = this.props.rootContainer;
    !this._rootContainer && r && (this._rootContainer = getRefTarget(r, !0));
  }, e._checkUpdateViewContainer = function() {
    var r = this.props.viewContainer;
    !this._viewContainer && r && (this._viewContainer = getRefTarget(r, !0));
    var D = this._viewContainer;
    D && this._changeAbleViewClassNames(__spreadArray(__spreadArray([], this._getAbleViewClassNames(), !0), [this.isDragging() ? VIEW_DRAGGING : ""], !1));
  }, e._changeAbleViewClassNames = function(r) {
    var D = this._viewContainer, N = groupBy(r.filter(Boolean), function(z) {
      return z;
    }).map(function(z) {
      var X = z[0];
      return X;
    }), k = this._viewClassNames, $ = diff$1(k, N), G = $.removed, U = $.added;
    G.forEach(function(z) {
      removeClass(D, k[z]);
    }), U.forEach(function(z) {
      addClass(D, N[z]);
    }), this._viewClassNames = N;
  }, e._getAbleViewClassNames = function() {
    var r = this;
    return (this.getEnabledAbles().map(function(D) {
      var N;
      return ((N = D.viewClassName) === null || N === void 0 ? void 0 : N.call(D, r)) || "";
    }).join(" ") + " ".concat(this._getAbleClassName("-view"))).split(/\s+/g);
  }, e._getAbleClassName = function(r) {
    var D = this;
    r === void 0 && (r = "");
    var N = this.getEnabledAbles(), k = this.targetGesto, $ = this.controlGesto, G = k != null && k.isFlag() ? k.getEventData() : {}, U = $ != null && $.isFlag() ? $.getEventData() : {};
    return N.map(function(z) {
      var X, V, Y, W = z.name, q = ((X = z.className) === null || X === void 0 ? void 0 : X.call(z, D)) || "";
      return (!((V = G[W]) === null || V === void 0) && V.isEventStart || !((Y = U[W]) === null || Y === void 0) && Y.isEventStart) && (q += " ".concat(prefix("".concat(W).concat(r, "-dragging")))), q.trim();
    }).filter(Boolean).join(" ");
  }, e._updateResizeObserver = function(r) {
    var D, N = this.props, k = N.target;
    if (!window.ResizeObserver || !k || !N.useResizeObserver) {
      (D = this._reiszeObserver) === null || D === void 0 || D.disconnect();
      return;
    }
    if (!(r.target === k && this._reiszeObserver)) {
      var $ = new ResizeObserver(this.checkUpdateRect);
      $.observe(k, {
        box: "border-box"
      }), this._reiszeObserver = $;
    }
  }, e._updateMutationObserver = function(r) {
    var D = this, N, k = this.props, $ = k.target;
    if (!window.MutationObserver || !$ || !k.useMutationObserver) {
      (N = this._mutationObserver) === null || N === void 0 || N.disconnect();
      return;
    }
    if (!(r.target === $ && this._mutationObserver)) {
      var G = new MutationObserver(function(U) {
        for (var z = 0, X = U; z < X.length; z++) {
          var V = X[z];
          V.type === "attributes" && V.attributeName === "style" && D.checkUpdateRect();
        }
      });
      G.observe($, {
        attributes: !0
      }), this._mutationObserver = G;
    }
  }, t.defaultProps = {
    target: null,
    dragTarget: null,
    container: null,
    rootContainer: null,
    origin: !0,
    parentMoveable: null,
    wrapperMoveable: null,
    isWrapperMounted: !1,
    parentPosition: null,
    warpSelf: !1,
    useResizeObserver: !1,
    useMutationObserver: !1,
    preventDefault: !0,
    linePadding: 0,
    controlPadding: 0,
    ables: [],
    pinchThreshold: 20,
    dragArea: !1,
    passDragArea: !1,
    transformOrigin: "",
    className: "",
    zoom: 1,
    triggerAblesSimultaneously: !1,
    padding: {},
    pinchOutside: !0,
    checkInput: !1,
    groupable: !1,
    hideDefaultLines: !1,
    cspNonce: "",
    translateZ: 0,
    cssStyled: null,
    customStyledMap: {},
    props: {},
    stopPropagation: !1,
    preventClickDefault: !1,
    preventClickEventOnDrag: !0,
    flushSync: defaultSync,
    firstRenderState: null,
    persistData: null,
    viewContainer: null,
    requestStyles: [],
    useAccuratePosition: !1
  }, t;
}(PureComponent), Groupable = {
  name: "groupable",
  props: ["defaultGroupRotate", "defaultGroupOrigin", "groupable", "groupableProps", "targetGroups", "hideChildMoveableDefaultLines"],
  events: [],
  render: function(o, t) {
    var e, r = o.props, D = r.targets || [], N = o.getState(), k = N.left, $ = N.top, G = N.isPersisted, U = r.zoom || 1, z = o.renderGroupRects, X = ((e = r.persistData) === null || e === void 0 ? void 0 : e.children) || [];
    G ? D = X.map(function() {
      return null;
    }) : X = [];
    var V = o._store, Y = watchValue(V, "parentPosition", [k, $], function(q) {
      return q.join(",");
    }), W = watchValue(V, "requestStyles", o.getRequestChildStyles(), function(q) {
      return q.join(",");
    });
    return o.moveables = o.moveables.slice(0, D.length), __spreadArray(__spreadArray([], D.map(function(q, K) {
      return t.createElement(MoveableManager$1, {
        key: "moveable" + K,
        ref: refs(o, "moveables", K),
        target: q,
        origin: !1,
        requestStyles: W,
        cssStyled: r.cssStyled,
        customStyledMap: r.customStyledMap,
        useResizeObserver: r.useResizeObserver,
        hideChildMoveableDefaultLines: r.hideChildMoveableDefaultLines,
        parentMoveable: o,
        parentPosition: [k, $],
        persistData: X[K],
        zoom: U
      });
    }), !0), flat(z.map(function(q, K) {
      var Z = q.pos1, J = q.pos2, Q = q.pos3, et = q.pos4, it = [Z, J, Q, et];
      return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(tt, nt) {
        var st = tt[0], at = tt[1];
        return renderLine(t, "", minus(it[st], Y), minus(it[at], Y), U, "group-rect-".concat(K, "-").concat(nt));
      });
    })), !0);
  }
}, Clickable = makeAble("clickable", {
  props: ["clickable"],
  events: ["click", "clickGroup"],
  always: !0,
  dragRelation: "weak",
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  dragStart: function() {
  },
  dragControlStart: function() {
  },
  dragGroupStart: function(o, t) {
    t.datas.inputTarget = t.inputEvent && t.inputEvent.target;
  },
  dragEnd: function(o, t) {
    var e = o.props.target, r = t.inputEvent, D = t.inputTarget, N = o.isMoveableElement(D), k = !N && o.controlBox.contains(D);
    if (!(!r || !D || t.isDrag || o.isMoveableElement(D) || k)) {
      var $ = e.contains(D);
      triggerEvent(o, "onClick", fillParams(o, t, {
        isDouble: t.isDouble,
        inputTarget: D,
        isTarget: e === D,
        moveableTarget: o.props.target,
        containsTarget: $
      }));
    }
  },
  dragGroupEnd: function(o, t) {
    var e = t.inputEvent, r = t.inputTarget;
    if (!(!e || !r || t.isDrag || o.isMoveableElement(r) || t.datas.inputTarget === r)) {
      var D = o.props.targets, N = D.indexOf(r), k = N > -1, $ = !1;
      N === -1 && (N = findIndex(D, function(G) {
        return G.contains(r);
      }), $ = N > -1), triggerEvent(o, "onClickGroup", fillParams(o, t, {
        isDouble: t.isDouble,
        targets: D,
        inputTarget: r,
        targetIndex: N,
        isTarget: k,
        containsTarget: $,
        moveableTarget: D[N]
      }));
    }
  },
  dragControlEnd: function(o, t) {
    this.dragEnd(o, t);
  },
  dragGroupControlEnd: function(o, t) {
    this.dragEnd(o, t);
  }
});
function getDraggableEvent(o) {
  var t = o.originalDatas.draggable;
  return t || (o.originalDatas.draggable = {}, t = o.originalDatas.draggable), __assign$1(__assign$1({}, o), {
    datas: t
  });
}
var edgeDraggable = makeAble("edgeDraggable", {
  css: [`.edge.edgeDraggable.line {
cursor: move;
}`],
  render: function(o, t) {
    var e = o.props, r = e.edgeDraggable;
    return r ? renderEdgeLines(t, "edgeDraggable", r, o.getState().renderPoses, e.zoom) : [];
  },
  dragCondition: function(o, t) {
    var e, r = o.props, D = (e = t.inputEvent) === null || e === void 0 ? void 0 : e.target;
    return !r.edgeDraggable || !D ? !1 : !r.draggable && hasClass(D, prefix("direction")) && hasClass(D, prefix("edge")) && hasClass(D, prefix("edgeDraggable"));
  },
  dragStart: function(o, t) {
    return Draggable.dragStart(o, getDraggableEvent(t));
  },
  drag: function(o, t) {
    return Draggable.drag(o, getDraggableEvent(t));
  },
  dragEnd: function(o, t) {
    return Draggable.dragEnd(o, getDraggableEvent(t));
  },
  dragGroupCondition: function(o, t) {
    var e, r = o.props, D = (e = t.inputEvent) === null || e === void 0 ? void 0 : e.target;
    return !r.edgeDraggable || !D ? !1 : !r.draggable && hasClass(D, prefix("direction")) && hasClass(D, prefix("line"));
  },
  dragGroupStart: function(o, t) {
    return Draggable.dragGroupStart(o, getDraggableEvent(t));
  },
  dragGroup: function(o, t) {
    return Draggable.dragGroup(o, getDraggableEvent(t));
  },
  dragGroupEnd: function(o, t) {
    return Draggable.dragGroupEnd(o, getDraggableEvent(t));
  },
  unset: function(o) {
    return Draggable.unset(o);
  }
}), IndividualGroupable = {
  name: "individualGroupable",
  props: ["individualGroupable", "individualGroupableProps"],
  events: []
}, MOVEABLE_ABLES = [BeforeRenderable, Default, Snappable, Pinchable, Draggable, edgeDraggable, Resizable, Scalable, Warpable, Rotatable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable], MOVEABLE_EVENTS = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(o, t) {
  return (t.events || []).forEach(function(e) {
    pushSet(o, e);
  }), o;
}, []), MOVEABLE_PROPS = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(o, t) {
  return (t.props || []).forEach(function(e) {
    pushSet(o, e);
  }), o;
}, []);
function solveConstantsDistance(o, t) {
  var e = o[0], r = o[1], D = o[2];
  return (e * t[0] + r * t[1] + D) / Math.sqrt(e * e + r * r);
}
function solveC(o, t) {
  var e = o[0], r = o[1];
  return -e * t[0] - r * t[1];
}
function getMaxPos(o, t) {
  return Math.max.apply(Math, o.map(function(e) {
    var r = e[0], D = e[1], N = e[2], k = e[3];
    return Math.max(r[t], D[t], N[t], k[t]);
  }));
}
function getMinPos(o, t) {
  return Math.min.apply(Math, o.map(function(e) {
    var r = e[0], D = e[1], N = e[2], k = e[3];
    return Math.min(r[t], D[t], N[t], k[t]);
  }));
}
function getGroupRect(o, t) {
  var e, r = [0, 0], D = [0, 0], N = [0, 0], k = [0, 0], $ = 0, G = 0;
  if (!o.length)
    return {
      pos1: r,
      pos2: D,
      pos3: N,
      pos4: k,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: $,
      height: G,
      rotation: t
    };
  var U = throttle(t, TINY_NUM);
  if (U % 90) {
    var z = U / 180 * Math.PI, X = Math.tan(z), V = -1 / X, Y = [MAX_NUM, MIN_NUM], W = [[0, 0], [0, 0]], q = [MAX_NUM, MIN_NUM], K = [[0, 0], [0, 0]];
    o.forEach(function(St) {
      St.forEach(function(gt) {
        var bt = solveConstantsDistance([-X, 1, 0], gt), At = solveConstantsDistance([-V, 1, 0], gt);
        Y[0] > bt && (W[0] = gt, Y[0] = bt), Y[1] < bt && (W[1] = gt, Y[1] = bt), q[0] > At && (K[0] = gt, q[0] = At), q[1] < At && (K[1] = gt, q[1] = At);
      });
    });
    var Z = W[0], J = W[1], Q = K[0], et = K[1], it = [-X, 1, solveC([-X, 1], Z)], tt = [-X, 1, solveC([-X, 1], J)], nt = [-V, 1, solveC([-V, 1], Q)], st = [-V, 1, solveC([-V, 1], et)];
    e = [[it, nt], [it, st], [tt, nt], [tt, st]].map(function(St) {
      var gt = St[0], bt = St[1];
      return getIntersectionPointsByConstants(gt, bt)[0];
    }), r = e[0], D = e[1], N = e[2], k = e[3], $ = q[1] - q[0], G = Y[1] - Y[0];
  } else {
    var at = getMinPos(o, 0), ut = getMinPos(o, 1), ht = getMaxPos(o, 0), dt = getMaxPos(o, 1);
    if (r = [at, ut], D = [ht, ut], N = [at, dt], k = [ht, dt], $ = ht - at, G = dt - ut, U % 180) {
      var pt = [N, r, k, D];
      r = pt[0], D = pt[1], N = pt[2], k = pt[3], $ = dt - ut, G = ht - at;
    }
  }
  if (U % 360 > 180) {
    var pt = [k, N, D, r];
    r = pt[0], D = pt[1], N = pt[2], k = pt[3];
  }
  var _t = getMinMaxs([r, D, N, k]), mt = _t.minX, yt = _t.minY, Tt = _t.maxX, Pt = _t.maxY;
  return {
    pos1: r,
    pos2: D,
    pos3: N,
    pos4: k,
    width: $,
    height: G,
    minX: mt,
    minY: yt,
    maxX: Tt,
    maxY: Pt,
    rotation: t
  };
}
function findMoveableGroups(o, t) {
  var e = t.map(function(r) {
    if (isArray(r)) {
      var D = findMoveableGroups(o, r), N = D.length;
      return N > 1 ? D : N === 1 ? D[0] : null;
    } else {
      var k = find$1(o, function($) {
        var G = $.manager;
        return G.props.target === r;
      });
      return k ? (k.finded = !0, k.manager) : null;
    }
  }).filter(Boolean);
  return e.length === 1 && isArray(e[0]) ? e[0] : e;
}
var MoveableGroup = /* @__PURE__ */ function(o) {
  __extends$1(t, o);
  function t() {
    var r = o !== null && o.apply(this, arguments) || this;
    return r.differ = new ChildrenDiffer$1(), r.moveables = [], r.transformOrigin = "50% 50%", r.renderGroupRects = [], r._targetGroups = [], r._hasFirstTargets = !1, r;
  }
  var e = t.prototype;
  return e.componentDidMount = function() {
    o.prototype.componentDidMount.call(this);
  }, e.checkUpdate = function() {
    this._isPropTargetChanged = !1, this.updateAbles();
  }, e.getTargets = function() {
    return this.props.targets;
  }, e.updateRect = function(r, D, N) {
    var k;
    N === void 0 && (N = !0);
    var $ = this.state;
    if (!this.controlBox || $.isPersisted)
      return;
    setStoreCache(!0), this.moveables.forEach(function(Dt) {
      Dt.updateRect(r, !1, !1);
    });
    var G = this.props, U = this.moveables, z = $.target || G.target, X = U.map(function(Dt) {
      return {
        finded: !1,
        manager: Dt
      };
    }), V = this.props.targetGroups || [], Y = findMoveableGroups(X, V);
    Y.push.apply(Y, X.filter(function(Dt) {
      var Vt = Dt.finded;
      return !Vt;
    }).map(function(Dt) {
      var Vt = Dt.manager;
      return Vt;
    }));
    var W = [], q = !D || r !== "" && G.updateGroup, K = G.defaultGroupRotate || 0;
    if (!this._hasFirstTargets) {
      var Z = (k = this.props.persistData) === null || k === void 0 ? void 0 : k.rotation;
      Z != null && (K = Z);
    }
    function J(Dt, Vt, Bt) {
      var Et = Dt.map(function(Wt) {
        if (isArray(Wt)) {
          var Jt = J(Wt, Vt), Kt = [Jt.pos1, Jt.pos2, Jt.pos3, Jt.pos4];
          return W.push(Jt), {
            poses: Kt,
            rotation: Jt.rotation
          };
        } else
          return {
            poses: getAbsolutePosesByState(Wt.state),
            rotation: Wt.getRotation()
          };
      }), Ht = Et.map(function(Wt) {
        var Jt = Wt.rotation;
        return Jt;
      }), kt = 0, wt = Ht[0], Lt = Ht.every(function(Wt) {
        return Math.abs(wt - Wt) < 0.1;
      });
      q ? kt = Lt ? wt : K : kt = !Bt && Lt ? wt : Vt;
      var jt = Et.map(function(Wt) {
        var Jt = Wt.poses;
        return Jt;
      }), Ct = getGroupRect(jt, kt);
      return Ct;
    }
    var Q = J(Y, this.rotation, !0);
    q && (this.rotation = Q.rotation, this.transformOrigin = G.defaultGroupOrigin || "50% 50%", this.scale = [1, 1]), this._targetGroups = V, this.renderGroupRects = W;
    var et = this.transformOrigin, it = this.rotation, tt = this.scale, nt = Q.width, st = Q.height, at = Q.minX, ut = Q.minY, ht = rotatePosesInfo([[0, 0], [nt, 0], [0, st], [nt, st]], convertTransformOriginArray(et, nt, st), this.rotation / 180 * Math.PI), dt = getMinMaxs(ht.result), pt = dt.minX, _t = dt.minY, mt = " rotate(".concat(it, "deg)") + " scale(".concat(tt[0] >= 0 ? 1 : -1, ", ").concat(tt[1] >= 0 ? 1 : -1, ")"), yt = "translate(".concat(-pt, "px, ").concat(-_t, "px)").concat(mt);
    this.controlBox.style.transform = "translate3d(".concat(at, "px, ").concat(ut, "px, ").concat(this.props.translateZ || 0, ")"), z.style.cssText += "left:0px;top:0px;" + "transform-origin:".concat(et, ";") + "width:".concat(nt, "px;height:").concat(st, "px;") + "transform: ".concat(yt), $.width = nt, $.height = st;
    var Tt = this.getContainer(), Pt = getMoveableTargetInfo(this.controlBox, z, this.controlBox, this.getContainer(), this._rootContainer || Tt, []), St = [Pt.left, Pt.top], gt = getAbsolutePosesByState(Pt), bt = gt[0], At = gt[1], Rt = gt[2], Nt = gt[3], Mt = getMinMaxs([bt, At, Rt, Nt]), ft = [Mt.minX, Mt.minY], Ft = tt[0] * tt[1] > 0 ? 1 : -1;
    Pt.pos1 = minus(bt, ft), Pt.pos2 = minus(At, ft), Pt.pos3 = minus(Rt, ft), Pt.pos4 = minus(Nt, ft), Pt.left = at - Pt.left + ft[0], Pt.top = ut - Pt.top + ft[1], Pt.origin = minus(plus(St, Pt.origin), ft), Pt.beforeOrigin = minus(plus(St, Pt.beforeOrigin), ft), Pt.originalBeforeOrigin = plus(St, Pt.originalBeforeOrigin), Pt.transformOrigin = minus(plus(St, Pt.transformOrigin), ft), z.style.transform = "translate(".concat(-pt - ft[0], "px, ").concat(-_t - ft[1], "px)") + mt, setStoreCache(), this.updateState(__assign$1(__assign$1({}, Pt), {
      posDelta: ft,
      direction: Ft,
      beforeDirection: Ft
    }), N);
  }, e.getRect = function() {
    return __assign$1(__assign$1({}, o.prototype.getRect.call(this)), {
      children: this.moveables.map(function(r) {
        return r.getRect();
      })
    });
  }, e.triggerEvent = function(r, D, N) {
    if (N || r.indexOf("Group") > -1)
      return o.prototype.triggerEvent.call(this, r, D);
    this._emitter.trigger(r, D);
  }, e.getRequestChildStyles = function() {
    var r = this.getEnabledAbles().reduce(function(D, N) {
      var k, $, G = ($ = (k = N.requestChildStyle) === null || k === void 0 ? void 0 : k.call(N)) !== null && $ !== void 0 ? $ : [];
      return __spreadArray(__spreadArray([], D, !0), G, !0);
    }, []);
    return r;
  }, e.updateAbles = function() {
    o.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], this.props.ables, !0), [Groupable], !1), "Group");
  }, e._updateTargets = function() {
    o.prototype._updateTargets.call(this), this._prevTarget = this.props.dragTarget || this.areaElement;
  }, e._updateEvents = function() {
    var r = this.state, D = this.props, N = this._prevTarget, k = D.dragTarget || this.areaElement;
    N !== k && (unset(this, "targetGesto"), unset(this, "controlGesto"), r.target = null), r.target || (r.target = this.areaElement, this.controlBox.style.display = "block"), r.target && (this.targetGesto || (this.targetGesto = getTargetAbleGesto(this, k, "Group")), this.controlGesto || (this.controlGesto = getAbleGesto(this, this.controlBox, "controlAbles", "GroupControl")));
    var $ = !equals(r.container, D.container);
    $ && (r.container = D.container);
    var G = D.targets, U = this.differ.update(G), z = U.added, X = U.changed, V = U.removed, Y = z.length || V.length;
    ($ || Y || this.transformOrigin !== (D.defaultGroupOrigin || "50% 50%") || X.length || G.length && !isDeepArrayEquals(this._targetGroups, D.targetGroups || [])) && (this.updateRect(), this._hasFirstTargets = !0), this._isPropTargetChanged = !!Y;
  }, e._updateObserver = function() {
  }, t.defaultProps = __assign$1(__assign$1({}, MoveableManager$1.defaultProps), {
    transformOrigin: ["50%", "50%"],
    groupable: !0,
    dragArea: !0,
    keepRatio: !0,
    targets: [],
    defaultGroupRotate: 0,
    defaultGroupOrigin: "50% 50%"
  }), t;
}(MoveableManager$1), MoveableIndividualGroup = /* @__PURE__ */ function(o) {
  __extends$1(t, o);
  function t() {
    var r = o !== null && o.apply(this, arguments) || this;
    return r.moveables = [], r;
  }
  var e = t.prototype;
  return e.render = function() {
    var r = this, D, N = this.props, k = N.cspNonce, $ = N.cssStyled, G = N.persistData, U = N.targets || [], z = U.length, X = this.isUnmounted || !z, V = (D = G == null ? void 0 : G.children) !== null && D !== void 0 ? D : [];
    return X && !z && V.length ? U = V.map(function() {
      return null;
    }) : X || (V = []), createElement($, {
      cspNonce: k,
      ref: ref(this, "controlBox"),
      className: prefix("control-box")
    }, U.map(function(Y, W) {
      var q, K, Z = (K = (q = N.individualGroupableProps) === null || q === void 0 ? void 0 : q.call(N, Y, W)) !== null && K !== void 0 ? K : {};
      return createElement(MoveableManager$1, __assign$1({
        key: "moveable" + W,
        ref: refs(r, "moveables", W)
      }, N, Z, {
        target: Y,
        wrapperMoveable: r,
        isWrapperMounted: r.isMoveableMounted,
        persistData: V[W]
      }));
    }));
  }, e.componentDidUpdate = function() {
  }, e.getTargets = function() {
    return this.props.targets;
  }, e.updateRect = function(r, D, N) {
    N === void 0 && (N = !0), setStoreCache(!0), this.moveables.forEach(function(k) {
      k.updateRect(r, D, N);
    }), setStoreCache();
  }, e.getRect = function() {
    return __assign$1(__assign$1({}, o.prototype.getRect.call(this)), {
      children: this.moveables.map(function(r) {
        return r.getRect();
      })
    });
  }, e.request = function() {
    return {
      request: function() {
        return this;
      },
      requestEnd: function() {
        return this;
      }
    };
  }, e.dragStart = function() {
    return this;
  }, e.hitTest = function() {
    return 0;
  }, e.isInside = function() {
    return !1;
  }, e.isDragging = function() {
    return !1;
  }, e.updateRenderPoses = function() {
  }, e.checkUpdate = function() {
  }, e.triggerEvent = function() {
  }, e.updateAbles = function() {
  }, e._updateEvents = function() {
  }, e._updateObserver = function() {
  }, t;
}(MoveableManager$1);
function getElementTargets(o, t) {
  var e = [];
  return o.forEach(function(r) {
    if (r) {
      if (isString(r)) {
        t[r] && e.push.apply(e, t[r]);
        return;
      }
      isArray(r) ? e.push.apply(e, getElementTargets(r, t)) : e.push(r);
    }
  }), e;
}
function getTargetGroups(o, t) {
  var e = [];
  return o.forEach(function(r) {
    if (r) {
      if (isString(r)) {
        t[r] && e.push.apply(e, t[r]);
        return;
      }
      isArray(r) ? e.push(getTargetGroups(r, t)) : e.push(r);
    }
  }), e;
}
function compareRefTargets(o, t) {
  return o.length !== t.length || o.some(function(e, r) {
    var D = t[r];
    return !e && !D ? !1 : e != D ? isArray(e) && isArray(D) ? compareRefTargets(e, D) : !0 : !1;
  });
}
var InitialMoveable = /* @__PURE__ */ function(o) {
  __extends$1(t, o);
  function t() {
    var r = o !== null && o.apply(this, arguments) || this;
    return r.refTargets = [], r.selectorMap = {}, r._differ = new ChildrenDiffer$1(), r._elementTargets = [], r._onChangeTargets = null, r;
  }
  var e = t.prototype;
  return t.makeStyled = function() {
    var r = {}, D = this.getTotalAbles();
    D.forEach(function(k) {
      var $ = k.css;
      $ && $.forEach(function(G) {
        r[G] = !0;
      });
    });
    var N = getKeys(r).join(`
`);
    this.defaultStyled = styled("div", prefixCSS(PREFIX, MOVEABLE_CSS + N));
  }, t.getTotalAbles = function() {
    return __spreadArray([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles, !0);
  }, e.render = function() {
    var r, D = this.constructor;
    D.defaultStyled || D.makeStyled();
    var N = this.props, k = N.ables, $ = N.props, G = __rest(N, ["ables", "props"]), U = this._updateRefs(!0), z = getElementTargets(U, this.selectorMap), X = z.length > 1, V = D.getTotalAbles(), Y = __spreadArray(__spreadArray([], V, !0), k || [], !0), W = __assign$1(__assign$1(__assign$1({}, G), $ || {}), {
      ables: Y,
      cssStyled: D.defaultStyled,
      customStyledMap: D.customStyledMap
    });
    this._elementTargets = z;
    var q = null, K = this.moveable, Z = G.persistData;
    if (Z != null && Z.children && (X = !0), G.individualGroupable)
      return createElement(MoveableIndividualGroup, __assign$1({
        key: "individual-group",
        ref: ref(this, "moveable")
      }, W, {
        target: null,
        targets: z
      }));
    if (X) {
      var J = getTargetGroups(U, this.selectorMap);
      if (K && !K.props.groupable && !K.props.individualGroupable) {
        var Q = K.props.target;
        Q && z.indexOf(Q) > -1 && (q = __assign$1({}, K.state));
      }
      return createElement(MoveableGroup, __assign$1({
        key: "group",
        ref: ref(this, "moveable")
      }, W, (r = G.groupableProps) !== null && r !== void 0 ? r : {}, {
        target: null,
        targets: z,
        targetGroups: J,
        firstRenderState: q
      }));
    } else {
      var et = z[0];
      if (K && (K.props.groupable || K.props.individualGroupable)) {
        var it = K.moveables || [], tt = find$1(it, function(nt) {
          return nt.props.target === et;
        });
        tt && (q = __assign$1({}, tt.state));
      }
      return createElement(MoveableManager$1, __assign$1({
        key: "single",
        ref: ref(this, "moveable")
      }, W, {
        target: et,
        firstRenderState: q
      }));
    }
  }, e.componentDidMount = function() {
    this._checkChangeTargets(), this._updateRefs();
  }, e.componentDidUpdate = function() {
    this._checkChangeTargets();
  }, e.componentWillUnmount = function() {
    this.selectorMap = {}, this.refTargets = [];
  }, e.getTargets = function() {
    var r, D;
    return (D = (r = this.moveable) === null || r === void 0 ? void 0 : r.getTargets()) !== null && D !== void 0 ? D : [];
  }, e.updateSelectors = function() {
    this.selectorMap = {}, this._updateRefs();
  }, e.waitToChangeTarget = function() {
    var r = this, D;
    return this._onChangeTargets = function() {
      r._onChangeTargets = null, D();
    }, new Promise(function(N) {
      D = N;
    });
  }, e.waitToChangeTargets = function() {
    return this.waitToChangeTarget();
  }, e.getManager = function() {
    return this.moveable;
  }, e._updateRefs = function(r) {
    var D = this.refTargets, N = getRefTargets(this.props.target || this.props.targets), k = typeof document < "u", $ = compareRefTargets(D, N), G = this.selectorMap, U = {};
    return this.refTargets.forEach(function z(X) {
      if (isString(X)) {
        var V = G[X];
        V ? U[X] = G[X] : k && ($ = !0, U[X] = [].slice.call(document.querySelectorAll(X)));
      } else
        isArray(X) && X.forEach(z);
    }), this.refTargets = N, this.selectorMap = U, !r && $ && this.forceUpdate(), N;
  }, e._checkChangeTargets = function() {
    var r, D, N, k = this._differ.update(this._elementTargets), $ = k.added, G = k.removed, U = $.length || G.length;
    U && ((D = (r = this.props).onChangeTargets) === null || D === void 0 || D.call(r, {
      moveable: this.moveable,
      targets: this._elementTargets
    }), (N = this._onChangeTargets) === null || N === void 0 || N.call(this)), this._updateRefs();
  }, t.defaultAbles = [], t.customStyledMap = {}, t.defaultStyled = null, __decorate$1([withMethods(MOVEABLE_METHODS)], t.prototype, "moveable", void 0), t;
}(PureComponent), Moveable$1 = /* @__PURE__ */ function(o) {
  __extends$1(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  return t.defaultAbles = MOVEABLE_ABLES, t;
}(InitialMoveable), Moveable$2 = Moveable$1, extendStatics = function(o, t) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var D in r)
      Object.prototype.hasOwnProperty.call(r, D) && (e[D] = r[D]);
  }, extendStatics(o, t);
};
function __extends(o, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  extendStatics(o, t);
  function e() {
    this.constructor = o;
  }
  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var e, r = 1, D = arguments.length; r < D; r++) {
      e = arguments[r];
      for (var N in e)
        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);
    }
    return t;
  }, __assign.apply(this, arguments);
};
function __decorate(o, t, e, r) {
  var D = arguments.length, N = D < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, k;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    N = Reflect.decorate(o, t, e, r);
  else
    for (var $ = o.length - 1; $ >= 0; $--)
      (k = o[$]) && (N = (D < 3 ? k(N) : D > 3 ? k(t, e, N) : k(t, e)) || N);
  return D > 3 && N && Object.defineProperty(t, e, N), N;
}
var InnerMoveable = /* @__PURE__ */ function(o) {
  __extends(t, o);
  function t(r) {
    var D = o.call(this, r) || this;
    return D.state = {}, D.state = D.props, D;
  }
  var e = t.prototype;
  return e.render = function() {
    return createElement(Moveable$2, __assign({
      ref: ref(this, "moveable")
    }, this.state));
  }, t;
}(Component), PROPERTIES = MOVEABLE_PROPS, METHODS = MOVEABLE_METHODS, EVENTS = MOVEABLE_EVENTS, MoveableManager = /* @__PURE__ */ function(o) {
  __extends(t, o);
  function t(r, D) {
    D === void 0 && (D = {});
    var N = o.call(this) || this;
    N.containerProvider = null, N.selfElement = null, N._warp = !1;
    var k = __assign({}, D), $ = {};
    EVENTS.forEach(function(z) {
      $[camelize("on ".concat(z))] = function(X) {
        return N.trigger(z, X);
      };
    });
    var G;
    D.warpSelf ? (delete D.warpSelf, N._warp = !0, G = r) : (G = document.createElement("div"), r.appendChild(G)), N.containerProvider = renderSelf(createElement(InnerMoveable, __assign({
      ref: ref(N, "innerMoveable")
    }, k, $)), G);
    var U = k.target;
    return isArray(U) && U.length > 1 && N.updateRect(), N;
  }
  var e = t.prototype;
  return e.setState = function(r, D) {
    this.innerMoveable.setState(r, D);
  }, e.forceUpdate = function(r) {
    this.innerMoveable.forceUpdate(r);
  }, e.dragStart = function(r) {
    var D = this.innerMoveable;
    D.$_timer && this.forceUpdate(), this.getMoveable().dragStart(r);
  }, e.destroy = function() {
    var r, D = this.selfElement;
    renderSelf(null, D, this.containerProvider), this._warp || (r = D == null ? void 0 : D.parentElement) === null || r === void 0 || r.removeChild(D), this.containerProvider = null, this.off(), this.selfElement = null, this.innerMoveable = null;
  }, e.getMoveable = function() {
    return this.innerMoveable.moveable;
  }, t = __decorate([Properties(METHODS, function(r, D) {
    r[D] || (r[D] = function() {
      for (var N = [], k = 0; k < arguments.length; k++)
        N[k] = arguments[k];
      var $ = this.getMoveable();
      if (!(!$ || !$[D]))
        return $[D].apply($, N);
    });
  }), Properties(PROPERTIES, function(r, D) {
    Object.defineProperty(r, D, {
      get: function() {
        return this.getMoveable().props[D];
      },
      set: function(N) {
        var k;
        this.setState((k = {}, k[D] = N, k));
      },
      enumerable: !0,
      configurable: !0
    });
  })], t), t;
}(EventEmitter$1), Moveable = /* @__PURE__ */ function(o) {
  __extends(t, o);
  function t() {
    return o !== null && o.apply(this, arguments) || this;
  }
  return t;
}(MoveableManager), Ur, zs, Hs, Vs, Xs, Ro, _n, yn, Oo, sf;
const zt = class {
  constructor(t, e = !1) {
    // divでmovを更新
    rt(this, Oo);
    It(this, "hArg", {});
    It(this, "id_tag", "");
    It(this, "hDesignArg", {
      rotation: 0,
      pivot_x: 0,
      pivot_y: 0,
      left: 0,
      center: 0,
      right: 0,
      s_right: 0,
      top: 0,
      middle: 0,
      bottom: 0,
      s_bottom: 0,
      width: 0,
      height: 0
    });
    It(this, "child");
    It(this, "parent");
    It(this, "fncLay", () => {
    });
    It(this, "mov");
    It(this, "div");
    It(this, "lx", 0);
    // これ以後の this変数スケールは SKYNovel スクリプト値
    It(this, "ly", 0);
    It(this, "rect", Rectangle.EMPTY);
    // cvsResizeBaseやhint座標など計算用
    It(this, "pivot", new Point(0, 0));
    It(this, "scale", new Point(1, 1));
    It(this, "rotation", 0);
    It(this, "oldFn", () => "");
    It(this, "rotatable", !0);
    this.bg_col = t, this.isLay = e;
  }
  static init(t, e, r, D, N, k, $) {
    zt.sys = e, ot(zt, zs, r), zt.prpPrs = D, ot(zt, Hs, N), ot(zt, Vs, k), zt.hPages = $, Main.cvs.insertAdjacentHTML("beforebegin", `<div id="${H(zt, Xs)}" style="width: ${CmnLib.stageW * e.cvsScale}px; height: ${CmnLib.stageH * e.cvsScale}px; background: rgba(0,0,0,0); position: absolute; touch-action: none; user-select: none; display: none;"></div>`), ot(zt, Ur, document.getElementById(H(zt, Xs))), zt.divHint.classList.add("sn_design_hint"), t.view.parentElement.appendChild(zt.divHint), addStyle(`
.sn_design_cast {
	position: absolute; touch-action: none; user-select: none;
	opacity: 0.6; border-radius: 8px;
}

.sn_design_cast.drag_border {
	line-height: 1.8;
	border: dashed 5px #333;
}

.sn_design_hint {
	position: absolute;
	left: 0;
	top: 0;
	padding: 5px;
	border-radius: 5px;
	background: #333;
	z-index: 10;
	color: #fff;
	font-weight: bold;
	font-size: 12px;
	display: none;
}
`);
  }
  static setHint(t, e, r, D) {
    zt.divHint.innerHTML = t;
    const N = window.getComputedStyle(zt.divHint), k = parseFloat(N.width), $ = parseFloat(N.height);
    zt.divHint.style.cssText = `display: block; left: ${Math.max(10, D.lx + e - k)}px;
		top: ${Math.max(10, D.ly + r - $ - 10)}px;`;
  }
  static cvsResizeDesign() {
    const t = H(zt, Ur).style;
    t.width = `${CmnLib.stageW * zt.sys.cvsScale}px`, t.height = `${CmnLib.stageH * zt.sys.cvsScale}px`;
  }
  destroy() {
    var t;
    this.div = void 0, (t = this.mov) == null || t.destroy(), this.mov = void 0;
  }
  gethArg() {
    return this.hArg;
  }
  sethArg(t) {
    if (!this.includeDesignArg(t))
      return;
    this.id_tag || (this.id_tag = t[":id_tag"] ?? ""), this.hArg = t;
    const e = t[":id_dc"] ?? this.id_tag;
    H(zt, _n)[e] = this;
  }
  includeDesignArg(t) {
    return Object.keys(t).some((e) => e in this.hDesignArg);
  }
  getRect() {
    return Rectangle.EMPTY;
  }
  cnvPosArg(t, e) {
    return {};
  }
  cnvSizeArg(t, e) {
    return {};
  }
  setPos(t, e) {
  }
  setSize(t, e) {
  }
  setOther(t) {
  }
  adopt(t) {
    this.child = t, t.parent = this;
  }
  static enterMode() {
    zt.leaveMode(), H(zt, Ur).style.display = "inline", ot(zt, Ro, 0), ot(zt, _n, {});
  }
  static allHide() {
    H(zt, yn).forEach((t) => t.visible = !1);
  }
  set visible(t) {
    !this.div || !this.mov || (this.div.style.display = t ? "inline" : "none", this.mov.updateTarget());
  }
  static leaveMode() {
    H(zt, Ur).textContent = "", H(zt, Ur).style.display = "none", H(zt, yn).forEach((t) => t.destroy()), ot(zt, yn, []);
  }
  cvsResize() {
    var t;
    lt(this, Oo, sf).call(this), (t = this.mov) == null || t.updateTarget();
  }
  onDragStart() {
  }
  make() {
    const t = this.hArg[":id_dc"] ?? this.id_tag;
    H(zt, _n)[t] = this;
    const e = this.div = document.createElement("div");
    e.id = H(zt, Xs) + "_" + ++Ie(zt, Ro)._, e.classList.add("sn_design_cast"), e.dataset.id_dc = t, e.style.backgroundColor = `${this.bg_col}`, e.style.display = "none", this.rect = this.getRect(), lt(this, Oo, sf).call(this), (this.parent ? document.querySelector(
      `[data-id_dc="${this.parent.id_tag}"]`
      // 親なので
    ) ?? H(zt, Ur) : H(zt, Ur)).appendChild(e);
    const r = {
      // movがdivを操作する際の雑用。スケールはHTML DOM
      aPos: [0, 0],
      roDeg: 0,
      trOrg: "",
      origin: [0, 0]
    }, D = () => {
      r.aPos = [NaN, NaN], r.roDeg = this.rotation;
      const G = this.pivot.x * zt.sys.cvsScale, U = this.pivot.y * zt.sys.cvsScale;
      r.trOrg = `${G}px ${U}px`, r.origin = [G, U];
    }, N = (G) => {
      zt.sys.send2Dbg("_changeCast", {
        ...G,
        ":id_tag": this.id_tag
      }), zt.divHint.style.display = "none";
    }, k = () => {
      const [G, U] = r.aPos;
      if (isNaN(G)) {
        zt.divHint.style.display = "none";
        return;
      }
      const z = int(this.rect.x += G / zt.sys.cvsScale + this.pivot.x), X = int(this.rect.y += U / zt.sys.cvsScale + this.pivot.y);
      this.setPos(z, X);
      const V = uint(this.rect.width), Y = uint(this.rect.height);
      this.setSize(V, Y), N({
        ...this.cnvPosArg(z, X),
        ...this.cnvSizeArg(V, Y)
      });
    };
    let $;
    this.mov = new Moveable(document.body, {
      target: e,
      draggable: !0,
      resizable: !0,
      //	scalable	: true,
      rotatable: this.rotatable,
      originDraggable: this.rotatable,
      snappable: !0
    }).on("dragStart", (G) => {
      var z;
      D(), this.onDragStart();
      const U = (z = this.child) == null ? void 0 : z.mov;
      U && ($ = U.target, U.isInside(G.clientX, G.clientY) && (U.target = void 0));
    }).on("drag", (G) => {
      r.aPos = G.beforeTranslate, this.procDragHint(G, G.left, G.top);
    }).on("dragEnd", () => {
      var G, U;
      k(), (G = this.child) != null && G.mov && (this.child.mov.target = $), (U = this.parent) != null && U.mov && (this.parent.mov.target = this.parent.div);
    }).on("resizeStart", D).on("resize", (G) => {
      e.style.width = `${G.width}px`, e.style.height = `${G.height}px`, r.aPos = G.drag.beforeTranslate, this.rect.width = G.width / zt.sys.cvsScale, this.rect.height = G.height / zt.sys.cvsScale, this.procResizeHint(G, G.drag.left, G.drag.top);
    }).on("resizeEnd", k).on("rotateStart", (G) => {
      D(), G.set(r.roDeg);
    }).on("rotate", (G) => {
      r.roDeg = G.beforeRotate, zt.setHint(int(r.roDeg) + "度", G.drag.left, G.drag.top, this);
    }).on("rotateEnd", () => {
      this.rotation = r.roDeg, this.setOther({}), N({ rotation: int(r.roDeg) });
    }).on("dragOriginStart", () => D).on("dragOrigin", (G) => {
      r.trOrg = G.transformOrigin, r.origin = G.origin;
    }).on("dragOriginEnd", () => {
      const [G, U] = r.origin;
      r.trOrg = `${G}px ${U}px`;
      const z = this.pivot.x = G / zt.sys.cvsScale, X = this.pivot.y = U / zt.sys.cvsScale;
      this.setOther({});
      const V = int(this.rect.x + z), Y = int(this.rect.y + X);
      this.setPos(V, Y), N({
        ...this.cnvPosArg(V, Y),
        pivot_x: int(z),
        pivot_y: int(X)
      });
    }).on("render", () => {
      const { aPos: G, roDeg: U, trOrg: z } = r;
      e.style.transformOrigin = z, e.style.transform = `translate(${G[0]}px, ${G[1]}px) rotate(${U}deg)`;
    }), H(zt, yn).push(this), e.addEventListener("dragenter", () => e.classList.add("drag_border")), e.addEventListener("dragover", (G) => {
      G.stopPropagation(), G.preventDefault(), G.dataTransfer && (G.dataTransfer.dropEffect = "copy");
    }), e.addEventListener("dragleave", () => e.classList.remove("drag_border")), e.addEventListener("drop", (G) => {
      G.stopPropagation(), G.preventDefault(), e.classList.remove("drag_border");
      const U = G.dataTransfer;
      if (!U || U.files.length === 0)
        return;
      const z = U.files[0], X = {
        ":id_tag": this.id_tag,
        fn: getFn(z.name),
        ext: getExt(z.name),
        url: "",
        buf: new ArrayBuffer(0),
        old_fn: this.oldFn(),
        old_url: H(zt, Vs).searchPath(this.oldFn(), SEARCH_PATH_ARG_EXT.SP_GSM)
      };
      z.arrayBuffer().then((V) => {
        X.buf = V;
        try {
          X.url = H(zt, zs).cnvPath4Dbg(
            H(zt, Vs).searchPath(z.name, SEARCH_PATH_ARG_EXT.SP_GSM)
          );
        } catch {
        }
        zt.sys.send2Dbg("_dropFile", X);
      }).catch((V) => console.error("drop2dc %o", V));
    }), e.addEventListener("dblclick", (G) => {
      G.preventDefault(), zt.sys.send2Dbg("_focusScript", this.hArg);
    });
  }
  procDragHint(t, e, r) {
    const [D, N] = t.beforeTranslate;
    zt.setHint(
      `(${int(this.rect.x + D / zt.sys.cvsScale)}, ${int(this.rect.y + N / zt.sys.cvsScale)})`,
      e,
      r,
      this
    );
  }
  procResizeHint(t, e, r) {
    zt.setHint(
      `(${int(t.drag.left)}, ${int(t.drag.top)})<br/>${int(this.rect.width)} x ${int(this.rect.height)}`,
      e,
      r,
      this
    );
  }
  static replaceToken(t) {
    var z, X, V, Y, W, q, K, Z;
    const r = t[":id_tag"], D = H(zt, _n)[r];
    if (!document.querySelector(`div[data-id_dc='${r}']`) || !D)
      return;
    const k = t[":token"];
    H(zt, zs).replace(t[":idx_tkn"], k);
    const [$, G] = tagToken2Name_Args(k);
    D.child && (D.child.hArg[":token"] = D.hArg[":token"]), H(zt, Hs).parse(G);
    const U = H(zt, Hs).hPrm;
    if ("pivot_x" in U || "pivot_y" in U) {
      const J = Number(zt.prpPrs.getValAmpersand(U.pivot_x.val)), Q = Number(zt.prpPrs.getValAmpersand(U.pivot_y.val));
      (isNaN(J) || isNaN(Q)) && DebugMng.myTrace(`pivot_xかpivot_yが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${k}`, "F"), D.pivot.set(J, Q);
    }
    if ("left" in U || "top" in U || "x" in U || "y" in U) {
      const J = int(zt.prpPrs.getValAmpersand(((z = U.left) == null ? void 0 : z.val) ?? ((X = U.x) == null ? void 0 : X.val) ?? "0")), Q = int(zt.prpPrs.getValAmpersand(((V = U.top) == null ? void 0 : V.val) ?? ((Y = U.y) == null ? void 0 : Y.val) ?? "0"));
      (isNaN(J) || isNaN(Q)) && DebugMng.myTrace(`widthかheightが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${k}`, "F"), D.rect.x = J - D.pivot.x, D.rect.y = Q - D.pivot.y, D.setPos(J, Q);
    }
    if ("width" in U || "height" in U) {
      const J = int(zt.prpPrs.getValAmpersand(((W = U.width) == null ? void 0 : W.val) ?? "0")), Q = int(zt.prpPrs.getValAmpersand(((q = U.height) == null ? void 0 : q.val) ?? "0"));
      (isNaN(J) || isNaN(Q)) && DebugMng.myTrace(`widthかheightが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${k}`, "F"), D.rect.width = J, D.rect.height = Q, D.setSize(J, Q);
    }
    if ("scale_x" in U || "scale_y" in U) {
      const J = Number(zt.prpPrs.getValAmpersand(((K = U.scale_x) == null ? void 0 : K.val) ?? "0")), Q = Number(zt.prpPrs.getValAmpersand(((Z = U.scale_y) == null ? void 0 : Z.val) ?? "0"));
      (isNaN(J) || isNaN(Q)) && DebugMng.myTrace(`scale_xかscale_yが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${k}`, "F"), D.scale.set(J, Q);
    }
    if ("rotation" in U) {
      const J = Number(zt.prpPrs.getValAmpersand(U.rotation.val));
      isNaN(J) && DebugMng.myTrace(`rotationが数値ではありません
(fn:${t[":path"].slice(13)} ln:${t[":ln"]})
${k}`, "F"), D.rotation = J;
    }
    D.setOther(U), D.cvsResize();
  }
};
let DesignCast = zt;
Ur = new WeakMap(), zs = new WeakMap(), Hs = new WeakMap(), Vs = new WeakMap(), Xs = new WeakMap(), Ro = new WeakMap(), _n = new WeakMap(), yn = new WeakMap(), Oo = new WeakSet(), sf = function() {
  this.fncLay(), this.div && Object.assign(this.div.style, {
    left: `${this.lx + this.rect.x * zt.sys.cvsScale}px`,
    top: `${this.ly + this.rect.y * zt.sys.cvsScale}px`,
    width: `${this.rect.width * zt.sys.cvsScale}px`,
    height: `${this.rect.height * zt.sys.cvsScale}px`,
    transformOrigin: `${this.pivot.x * zt.sys.cvsScale}px ${this.pivot.y * zt.sys.cvsScale}px`,
    transform: `scale(${this.scale.x}, ${this.scale.y}) rotate(${this.rotation}deg)`
  });
}, rt(DesignCast, Ur, void 0), It(DesignCast, "sys"), rt(DesignCast, zs, void 0), It(DesignCast, "prpPrs"), rt(DesignCast, Hs, void 0), rt(DesignCast, Vs, void 0), It(DesignCast, "hPages"), It(DesignCast, "divHint", document.createElement("div")), rt(DesignCast, Xs, "DesignMode"), rt(DesignCast, Ro, 0), rt(DesignCast, _n, {}), rt(DesignCast, yn, []);
var Bi;
class GrpLayDesignCast extends DesignCast {
  constructor(e, r) {
    super("#29e", !0);
    rt(this, Bi, void 0);
    It(this, "oldFn", () => this.hArg.fn ?? "");
    this.spLay = e, this.gl = r;
  }
  setSp(e) {
    ot(this, Bi, e);
  }
  getRect() {
    var e, r;
    return new Rectangle(this.spLay.x, this.spLay.y, ((e = H(this, Bi)) == null ? void 0 : e.width) ?? 0, ((r = H(this, Bi)) == null ? void 0 : r.height) ?? 0);
  }
  cnvPosArg(e, r) {
    return { left: e, top: r };
  }
  cnvSizeArg(e, r) {
    return { width: e, height: r };
  }
  setPos(e, r) {
    this.spLay.x = e, this.spLay.y = r;
  }
  setSize(e, r) {
    H(this, Bi).width = e, H(this, Bi).height = r;
  }
  setOther(e) {
    if ("fn" in e) {
      const r = DesignCast.prpPrs.getValAmpersand(e.fn.val);
      this.gl.lay({ fn: r });
    }
    this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;
  }
}
Bi = new WeakMap();
class TxtLayDesignCast extends DesignCast {
  constructor(e, r) {
    super("#29e", !0);
    It(this, "hDesignArg", {
      rotation: 0,
      pivot_x: 0,
      pivot_y: 0,
      left: 0,
      center: 0,
      right: 0,
      s_right: 0,
      top: 0,
      middle: 0,
      bottom: 0,
      s_bottom: 0,
      width: 0,
      height: 0,
      pl: 0,
      pr: 0,
      pt: 0,
      pb: 0
    });
    this.spLay = e, this.ts = r;
  }
  getRect() {
    const e = this.ts.infTL;
    return new Rectangle(this.spLay.x, this.spLay.y, e.$width, e.$height);
  }
  cnvPosArg(e, r) {
    return { left: e, top: r };
  }
  cnvSizeArg(e, r) {
    return { width: e, height: r };
  }
  setPos(e, r) {
    this.spLay.position.set(e, r), this.ts.lay(this.cnvPosArg(e, r));
  }
  setSize(e, r) {
    this.ts.lay(this.cnvSizeArg(e, r));
  }
  setOther(e) {
    var r;
    (r = this.child) == null || r.setOther(e), this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;
  }
}
var Io, af;
class TxtLayPadDesignCast extends DesignCast {
  constructor(e) {
    super("#9e2");
    rt(this, Io);
    It(this, "rotatable", !1);
    this.ts = e;
  }
  getRect() {
    const e = this.ts.infTL;
    return new Rectangle(
      e.pad_left,
      e.pad_top,
      e.$width - e.pad_left - e.pad_right,
      e.$height - e.pad_top - e.pad_bottom
    );
  }
  cnvPosArg(e, r) {
    return { pl: e, pt: r };
  }
  cnvSizeArg(e, r) {
    const D = this.ts.infTL;
    return {
      pr: D.$width - D.pad_left - e,
      pb: D.$height - D.pad_top - r
    };
  }
  setPos(e, r) {
    this.ts.lay(this.cnvPosArg(e, r));
  }
  setSize(e, r) {
    this.ts.lay({ ...this.cnvSizeArg(e, r), ":redraw": !0 });
  }
  setOther(e) {
    var D, N, k, $;
    const r = this.ts.infTL;
    if (("pl" in e || "pt" in e) && (this.setPos(
      this.rect.x = parseFloat(DesignCast.prpPrs.getValAmpersand(
        ((D = e.pl) == null ? void 0 : D.val) ?? `${r.pad_left}`
      )),
      this.rect.y = parseFloat(DesignCast.prpPrs.getValAmpersand(
        ((N = e.pt) == null ? void 0 : N.val) ?? `${r.pad_top}`
      ))
    ), this.cvsResize()), "pr" in e || "pb" in e) {
      this.ts.lay({
        pr: parseFloat(DesignCast.prpPrs.getValAmpersand(
          ((k = e.pr) == null ? void 0 : k.val) ?? `${r.pad_right}`
        )),
        pb: parseFloat(DesignCast.prpPrs.getValAmpersand(
          (($ = e.pb) == null ? void 0 : $.val) ?? `${r.pad_bottom}`
        ))
      });
      const G = this.getRect();
      this.setSize(
        this.rect.width = G.width,
        this.rect.height = G.height
      ), this.cvsResize();
    }
  }
  procDragHint(e, r, D) {
    const [N, k] = e.beforeTranslate;
    lt(this, Io, af).call(this, r, D, N, k);
  }
  procResizeHint(e, r, D) {
    const [N, k] = e.drag.beforeTranslate;
    lt(this, Io, af).call(this, r, D, N, k);
  }
}
Io = new WeakSet(), af = function(e, r, D, N) {
  const k = this.rect.x, $ = this.rect.y, G = this.rect.width, U = this.rect.height, z = this.ts.infTL, X = int(k + D / DesignCast.sys.cvsScale), V = int($ + N / DesignCast.sys.cvsScale), Y = int(z.$width - X - G), W = int(z.$height - V - U), q = (K) => "&nbsp;".repeat(K);
  DesignCast.setHint(
    q(5 + 5 + 1) + `上幅=${V}<br/>
			左幅=${X + q(1 + 3 + 5 + 1)}右幅=${Y}<br/>` + q(5) + `内側 ${int(G)} x ${int(U)}<br/>` + q(5 + 5) + `下幅=${W}`,
    e,
    r,
    this
  );
};
class BtnDesignCast extends DesignCast {
  constructor(t, e) {
    super("#e92"), this.btn = t, this.hArg = e, this.pivot.x = argChk_Num(e, "pivot_x", this.pivot.x), this.pivot.y = argChk_Num(e, "pivot_y", this.pivot.y), this.scale.x = argChk_Num(e, "scale_x", this.scale.x), this.scale.y = argChk_Num(e, "scale_y", this.scale.y), this.rotation = argChk_Num(e, "rotation", this.rotation), this.sethArg(e);
  }
  sethArg(t) {
    super.sethArg(t);
    const e = this.hArg.layer ?? "";
    this.fncLay = !this.parent && !this.child && e ? () => {
      const r = DesignCast.hPages[e].fore;
      this.lx = r.x * DesignCast.sys.cvsScale, this.ly = r.y * DesignCast.sys.cvsScale;
    } : () => {
    };
  }
  cnvPosArg(t, e) {
    return { left: t, top: e };
  }
  cnvSizeArg(t, e) {
    return { width: t, height: e };
  }
  setPos(t, e) {
    this.btn.x = t, this.btn.y = e;
  }
  setOther(t) {
    this.btn.pivot.copyFrom(this.pivot), this.btn.scale.copyFrom(this.scale), this.btn.angle = this.rotation;
  }
  onDragStart() {
  }
}
class TxtBtnDesignCast extends BtnDesignCast {
  constructor(e, r, D) {
    super(e, r);
    It(this, "oldFn", () => this.hArg.b_pic ?? "");
    this.txt = D, argChk_Boolean(r, "design", !0) || (this.setPos = () => {
    }, this.setSize = () => {
    });
  }
  getRect() {
    return new Rectangle(this.btn.x, this.btn.y, this.txt.width, this.txt.height);
  }
  setSize(e, r) {
    this.txt.width = e, this.txt.height = r;
  }
  setOther(e) {
    if (super.setOther(e), "b_pic" in e) {
      const r = DesignCast.prpPrs.getValAmpersand(e.b_pic.val ?? "");
      this.btn.update_b_pic(r, this.txt);
    }
  }
}
var oi;
class PicBtnDesignCast extends BtnDesignCast {
  constructor(e, r) {
    super(e, r);
    rt(this, oi, void 0);
    It(this, "oldFn", () => this.hArg.pic ?? "");
  }
  setSp(e) {
    ot(this, oi, e);
  }
  getRect() {
    return new Rectangle(this.btn.x, this.btn.y, H(this, oi).width, H(this, oi).height);
  }
  setSize(e, r) {
    H(this, oi).width = e, H(this, oi).height = r;
  }
  setOther(e) {
    if (super.setOther(e), "pic" in e) {
      const r = DesignCast.prpPrs.getValAmpersand(e.pic.val);
      this.btn.update_pic(r, H(this, oi));
    }
  }
}
oi = new WeakMap();
var sh, Fi, li, bn, xn, jr, Ys, Sn, Do, Ws, zr, ui, hi, $i, Ao, No, ko, ah, dd, oh, pd, Lo, of, lh, vd, qs, du, Ks, Pr, Zs, uh, En, Bo;
const Yt = class extends Layer {
  constructor() {
    super();
    rt(this, zr, new GrpLayDesignCast(this.spLay, this));
    rt(this, ui, "");
    rt(this, hi, "");
    rt(this, $i, "");
    It(this, "lay", (e) => this.laySub(e, (r) => {
      r && H(Yt, li).resume();
    }));
    rt(this, Ao, 0);
    rt(this, No, 0);
    rt(this, Ks, void 0);
    rt(this, Pr, void 0);
    rt(this, Zs, () => {
    });
    It(this, "record", () => ({
      ...super.record(),
      sBkFn: H(this, hi),
      sBkFace: H(this, $i),
      idc_hArg: H(this, zr).gethArg()
    }));
    //showDesignCastChildren() {}
    It(this, "dump", () => super.dump() + `, "pic":"${H(this, ui)}"`);
    CmnLib.isDbg && (this.setSp = (e) => H(this, zr).setSp(e), this.cvsResize = () => {
      super.cvsResize(), H(this, zr).cvsResize();
    });
  }
  static init(e, r, D, N, k, $) {
    ot(Yt, li, e), ot(Yt, bn, r), ot(Yt, xn, D), ot(Yt, jr, N), ot(Yt, Ys, $);
    const G = () => {
      const U = H(Yt, Sn) * H(Yt, Do);
      for (const z of Object.values(Yt.hFn2VElm))
        z.volume = U;
    };
    k.setNoticeChgVolume(
      (U) => {
        ot(Yt, Sn, U), G();
      },
      (U) => {
        ot(Yt, Do, U), G();
      }
    ), H(Yt, jr).crypto && ot(Yt, ko, lt(Yt, oh, pd));
  }
  static setEvtMng(e) {
    ot(Yt, Ws, e);
  }
  static destroy() {
    H(Yt, sh).clear(), ot(Yt, Fi, {}), Yt.hFn2ResAniSpr = {}, Yt.hFn2VElm = {};
  }
  setSp(e) {
  }
  laySub(e, r) {
    var G;
    lt(G = Yt, qs, du).call(G, H(this, hi));
    const { fn: D, face: N = "" } = e;
    if (H(this, zr).sethArg(e), !D)
      return super.lay(e), this.spLay.children.length > 0 && this.setPos(e), ot(this, hi, ""), ot(this, ui, ot(this, $i, N)), r(!1), !1;
    const k = "fn" in e, $ = "face" in e;
    return this.clearLay({ filter: "true" }), k && ot(this, hi, D), $ && ot(this, $i, N), super.lay(e), e.dx = 0, e.dy = 0, Yt.csv2Sprites(
      ot(this, ui, D + (N ? "," + N : "")),
      this.spLay,
      (U) => {
        ("width" in e || "height" in e) && (U.width = argChk_Num(e, "width", 0), U.height = argChk_Num(e, "height", 0)), ot(this, Ao, U.width), ot(this, No, U.height), Layer.setXY(U, e, this.spLay, !0), this.setSp(U);
      },
      (U) => {
        Layer.setBlendmodeParentOnly(this.spLay, e), r(U);
      }
    );
  }
  get width() {
    return H(this, Ao);
  }
  get height() {
    return H(this, No);
  }
  //	static #ldrHFn: {[name: string]: 1} = {};
  static csv2Sprites(e, r, D, N = () => {
  }) {
    let k = !1;
    if (e.slice(0, 5) === "data:") {
      const z = () => {
        const X = Sprite.from(e);
        r == null || r.addChild(X), D(X), N(k);
      };
      return e in TextureCache ? z() : (k = !0, new Loader().add(e, e).load(z)), k;
    }
    const $ = [], G = new Loader();
    e.split(",").forEach((z, X) => {
      if (!z)
        throw "face属性に空要素が含まれます";
      const { dx: V, dy: Y, blendmode: W, fn: q } = H(Yt, Fi)[z] || {
        fn: z,
        dx: 0,
        dy: 0,
        blendmode: BLEND_MODES.NORMAL
      }, K = X === 0 ? D : (Q) => {
        Q.x = V, Q.y = Y, Q.blendMode = W;
      };
      if ($.push({ fn: q, fnc: K }), q in Yt.hFn2ResAniSpr || q in TextureCache || q in Loader.shared.resources)
        return;
      k = !0;
      const Z = H(Yt, bn).searchPath(q, SEARCH_PATH_ARG_EXT.SP_GSM), J = H(this, jr).crypto ? { xhrType: Z.slice(-5) === ".json" ? LoaderResource.XHR_RESPONSE_TYPE.TEXT : LoaderResource.XHR_RESPONSE_TYPE.BUFFER } : {};
      G.add({ ...J, name: q, url: Z });
    });
    const U = (z) => {
      var X;
      for (const { fn: V, fnc: Y } of $) {
        const W = lt(X = Yt, lh, vd).call(X, V, z);
        W.name = V, r == null || r.addChild(W), Y(W);
      }
      N(k);
    };
    return k ? G.use((z, X) => {
      H(this, jr).dec(z.extension, z.data).then((V) => {
        var Y;
        return H(Y = Yt, ko).call(Y, V, z, () => X == null ? void 0 : X());
      }).catch((V) => H(this, li).errScript(`Graphic ロード失敗です fn:${z.name} ${V}`, !1));
    }).load((z, X) => U(X)) : U({}), k;
  }
  static wv(e) {
    var k;
    const { fn: r } = e;
    if (!r)
      throw "fnは必須です";
    const D = Yt.hFn2VElm[r];
    if (!D || D.loop)
      return !1;
    if (H(this, Ys).getVal("tmp:sn.skip.enabled") || H(this, Ws).isSkippingByKeyDown() || D.ended)
      return lt(k = Yt, qs, du).call(k, r), !1;
    const N = () => {
      var $;
      lt($ = Yt, qs, du).call($, r), H(this, li).resume();
    };
    return D.addEventListener("ended", N, { once: !0, passive: !0 }), H(Yt, Ws).waitEvent(
      () => {
        D.removeEventListener("ended", N), N();
      },
      argChk_Boolean(e, "canskip", !0),
      argChk_Boolean(e, "global", !1)
    );
  }
  renderStart() {
    ot(this, Ks, RenderTexture.create({
      width: CmnLib.stageW,
      height: CmnLib.stageH
    })), ot(this, Pr, new Sprite(H(this, Ks))), H(this, Pr).visible = !1, this.spLay.addChildAt(H(this, Pr), 0), H(this, Pr).position.set(-this.spLay.x, -this.spLay.y);
    let e = () => {
      const r = this.spLay.alpha;
      this.spLay.alpha = 1;
      for (const D of this.spLay.children)
        D.visible = !0;
      H(this, Pr).visible = !1, H(Yt, xn).renderer.render(this.spLay, { renderTexture: H(this, Ks) }), this.spLay.alpha = r;
      for (const D of this.spLay.children)
        D.visible = !1;
    };
    if (!this.containMovement) {
      let r = e;
      e = () => {
        e = () => {
        }, r();
      };
    }
    ot(this, Zs, () => {
      e(), H(this, Pr).visible = !0;
    }), H(Yt, xn).ticker.add(H(this, Zs));
  }
  renderEnd() {
    H(Yt, xn).ticker.remove(H(this, Zs)), this.spLay.removeChild(H(this, Pr));
    for (const e of this.spLay.children)
      e.visible = !0;
    H(this, Pr).destroy(!0);
  }
  // https://regex101.com/r/ZUnoFq/1
  static loadPic2Img(e, r, D) {
    const N = e.replace(H(Yt, uh), ""), k = e === N ? "" : e.slice(N.length), $ = H(this, Bo)[e];
    if ($) {
      r.src = $;
      return;
    }
    const G = H(this, En)[e];
    if (G) {
      G.push(r);
      return;
    }
    H(this, En)[e] = [r];
    const U = H(Yt, bn).searchPath(N, SEARCH_PATH_ARG_EXT.SP_GSM), z = new Loader().add({ name: e, url: U, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER });
    H(Yt, jr).crypto && getExt(U) === "bin" && z.use((X, V) => {
      H(Yt, jr).dec(X.extension, X.data).then((Y) => {
        if (X.extension !== "bin") {
          V == null || V();
          return;
        }
        X.data = Y, Y instanceof HTMLImageElement && (X.type = LoaderResource.TYPE.IMAGE), V == null || V();
      }).catch((Y) => H(Yt, li).errScript(`GrpLayer loadPic ロード失敗です fn:${X.name} ${Y}`, !1));
    }), z.load((X, V) => {
      for (const [Y, { data: { src: W } }] of Object.entries(V)) {
        const q = H(this, Bo)[Y] = W + (W.slice(0, 5) === "blob:" ? "" : k);
        for (const K of H(this, En)[Y])
          K.src = q, D && (K.onload = () => D(K));
        delete H(this, En)[Y];
      }
    });
  }
  setPos(e) {
    Layer.setXY(
      this.spLay.children.length === 0 ? this.spLay : this.spLay.children[0],
      e,
      this.spLay,
      !0
    );
  }
  static add_face(e) {
    const { name: r } = e;
    if (!r)
      throw "nameは必須です";
    if (r in H(Yt, Fi))
      throw "一つのname（" + r + "）に対して同じ画像を複数割り当てられません";
    const { fn: D = r } = e;
    return H(Yt, Fi)[r] = {
      fn: D,
      dx: argChk_Num(e, "dx", 0),
      dy: argChk_Num(e, "dy", 0),
      blendmode: Layer.getBlendmodeNum(e.blendmode || "")
    }, !1;
  }
  static clearFace2Name() {
    ot(Yt, Fi, {});
  }
  // アニメ・動画を含むか
  get containMovement() {
    if (H(this, ui) === "")
      return !1;
    const e = this.spLay.children;
    return H(this, ui).split(",").some(
      (r, D) => e[D] instanceof AnimatedSprite || Yt.hFn2VElm[r]
    );
  }
  clearLay(e) {
    super.clearLay(e);
    for (const r of this.spLay.removeChildren())
      r.destroy();
    ot(this, hi, ""), ot(this, $i, ""), ot(this, ui, "");
  }
  playback(e, r) {
    if (super.playback(e, r), e.sBkFn === "" && e.sBkFace === "") {
      ot(this, hi, e.sBkFn), ot(this, $i, e.sBkFace), H(this, zr).sethArg(e.idc_hArg);
      return;
    }
    r.push(new Promise((D) => this.laySub(
      { fn: e.sBkFn, face: e.sBkFace, left: e.x, top: e.y, alpha: e.alpha, blendmode: Layer.getNum2Blendmode(e.blendMode), rotation: e.rotation, scale_x: e.scale_x, scale_y: e.scale_y },
      (N) => {
        this.spLay.position.set(e.x, e.y), D();
      }
      // Layer.setXY()の後に再度移動
    )));
  }
  makeDesignCast(e) {
    this.spLay.visible && e(H(this, zr));
  }
  //makeDesignCastChildren(_gdc: IMakeDesignCast) {}
  cvsResize() {
    super.cvsResize();
  }
  showDesignCast() {
    H(this, zr).visible = !0;
  }
};
let GrpLayer = Yt;
sh = new WeakMap(), Fi = new WeakMap(), li = new WeakMap(), bn = new WeakMap(), xn = new WeakMap(), jr = new WeakMap(), Ys = new WeakMap(), Sn = new WeakMap(), Do = new WeakMap(), Ws = new WeakMap(), zr = new WeakMap(), ui = new WeakMap(), hi = new WeakMap(), $i = new WeakMap(), Ao = new WeakMap(), No = new WeakMap(), ko = new WeakMap(), ah = new WeakSet(), dd = function(e) {
  const r = /([^\d]+)\d+\.(\w+)/.exec(e[0]);
  if (!r)
    return [];
  const D = r[1].length, N = -r[2].length - 1;
  return e.sort(
    (k, $) => int(k.slice(D, N)) > int($.slice(D, N)) ? 1 : -1
  );
}, oh = new WeakSet(), pd = function(e, r, D) {
  var U;
  if (r.data = e, r.extension === "bin" && (e instanceof HTMLImageElement ? (r.texture = Texture.fromLoader(e, r.url, r.name), r.type = LoaderResource.TYPE.IMAGE) : e instanceof HTMLVideoElement && (e.volume = H(Yt, Sn), Yt.hFn2VElm[r.name] = lt(U = Yt, Lo, of).call(U, e), r.type = LoaderResource.TYPE.VIDEO)), r.extension !== "json") {
    D();
    return;
  }
  if (typeof e != "string") {
    D();
    return;
  }
  const { meta: N, frames: k } = r.data = JSON.parse(e);
  if (r.type = LoaderResource.TYPE.JSON, !(N != null && N.image)) {
    D();
    return;
  }
  const $ = getFn(N.image), G = H(Yt, bn).searchPath($, SEARCH_PATH_ARG_EXT.SP_GSM);
  new Loader().use((z, X) => {
    H(this, jr).dec(z.extension, z.data).then((V) => {
      z.data = V, V instanceof HTMLImageElement && (z.type = LoaderResource.TYPE.IMAGE, URL.revokeObjectURL(V.src)), X == null || X();
    }).catch((V) => H(this, li).errScript(`Graphic ロード失敗です dec2res4Cripto fn:${z.name} ${V}`, !1));
  }).add({ name: $, url: G, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).load((z, X) => {
    for (const { data: V } of Object.values(z.resources)) {
      const { baseTexture: Y } = Texture.from(V), W = Object.values(k);
      Yt.hFn2ResAniSpr[r.name] = {
        aTex: W.map(({ frame: { x: q, y: K, w: Z, h: J } }) => new Texture(
          Y,
          new Rectangle(q, K, Z, J)
        )),
        meta: N
      };
    }
    D();
  });
}, Lo = new WeakSet(), of = function(e) {
  return H(Yt, Ys).getVal("const.sn.needClick2Play") && (DebugMng.trace_beforeNew(`[lay系] ${DebugMng.strPos()}未クリック状態で動画を自動再生します。音声はミュートされます`, "W"), e.muted = !0), e.setAttribute("playsinline", ""), e;
}, lh = new WeakSet(), vd = function(e, r) {
  const D = Yt.hFn2ResAniSpr[e];
  if (D) {
    const N = new AnimatedSprite(D.aTex);
    return N.animationSpeed = D.meta.animationSpeed ?? 1, N.play(), N;
  }
  return e in TextureCache ? Sprite.from(e) : e in Yt.hFn2VElm ? Sprite.from(Yt.hFn2VElm[e]) : e in r ? new Sprite(r[e].texture) : new Sprite();
}, qs = new WeakSet(), du = function(e) {
  const r = Yt.hFn2VElm[e];
  r && (delete Yt.hFn2VElm[e], r.pause(), r.currentTime = r.duration);
}, Ks = new WeakMap(), Pr = new WeakMap(), Zs = new WeakMap(), uh = new WeakMap(), En = new WeakMap(), Bo = new WeakMap(), rt(GrpLayer, ah), rt(GrpLayer, oh), rt(GrpLayer, Lo), rt(GrpLayer, lh), rt(GrpLayer, qs), rt(GrpLayer, sh, new EventListenerCtn()), rt(GrpLayer, Fi, {}), rt(GrpLayer, li, void 0), rt(GrpLayer, bn, void 0), rt(GrpLayer, xn, void 0), rt(GrpLayer, jr, void 0), rt(GrpLayer, Ys, void 0), rt(GrpLayer, Sn, 1), rt(GrpLayer, Do, 1), rt(GrpLayer, Ws, void 0), It(GrpLayer, "hFn2ResAniSpr", {}), rt(GrpLayer, ko, (e, r, D) => {
  var N, k;
  switch (r.type) {
    case LoaderResource.TYPE.JSON:
      const $ = r.spritesheet._frameKeys;
      lt(N = Yt, ah, dd).call(N, $), Yt.hFn2ResAniSpr[r.name] = {
        aTex: $.map((U) => Texture.from(U)),
        meta: r.data.meta
      };
      break;
    case LoaderResource.TYPE.VIDEO:
      const G = r.data;
      G.volume = H(Yt, Sn), Yt.hFn2VElm[r.name] = lt(k = Yt, Lo, of).call(k, G);
  }
  D();
}), It(GrpLayer, "hFn2VElm", {}), rt(GrpLayer, uh, /\?([^?]+)$/), rt(GrpLayer, En, {}), rt(GrpLayer, Bo, {});
var Js, Fo, Tn, se, Hr, ci, hh, lr, Gi, qt, gr, We, qe, Qs, pu, Mr, fi, $o, ta, ch, gd, wn, ea, Ui, Cn, Pn, Mn, ra, Go, ji, Uo, lf, di, jo, pi, Vr, ia, zo, uf, zi, Rn, Ho, hf, Qe;
const te = class extends Container {
  constructor(e, r, D) {
    super();
    rt(this, Qs);
    rt(this, ch);
    rt(this, Uo);
    // 「g」などで下が欠ける問題対策
    rt(this, zo);
    rt(this, Ho);
    rt(this, se, document.createElement("span"));
    // サンプリング元
    rt(this, Hr, new Container());
    // サンプリング先
    rt(this, ci, new Graphics());
    rt(this, lr, new TxtLayDesignCast(this.spLay, this));
    rt(this, Gi, new TxtLayPadDesignCast(this));
    rt(this, qt, {
      fontsize: 24,
      $width: 0,
      // レイヤサイズであり、背景色（画像）サイズ
      $height: 0,
      pad_left: 0,
      // paddingLeft（レイヤサイズの内側のスペーサー）
      pad_right: 0,
      // paddingRight
      pad_top: 0,
      // paddingTop
      pad_bottom: 0
      // paddingBottom
    });
    rt(this, gr, !1);
    rt(this, We, 0);
    rt(this, qe, 0);
    rt(this, Mr, 0);
    rt(this, fi, !1);
    rt(this, $o, 0);
    rt(this, ta, 0);
    rt(this, wn, void 0);
    // 文字にかけるフィルター
    rt(this, ea, []);
    rt(this, Ui, []);
    rt(this, Cn, 0);
    rt(this, ji, () => !1);
    rt(this, ia, 0);
    rt(this, zi, "Quadratic.Out");
    rt(this, Rn, "Quadratic.Out");
    rt(this, Qe, void 0);
    this.spLay = e, this.canFocus = r, this.sys = D, H(this, se).classList.add("sn_tx"), H(this, se).style.position = "absolute", H(te, Fo).view.parentElement.appendChild(H(this, se)), this.addChild(H(this, Hr)), this.addChild(H(this, ci)), H(this, ci).name = "grpDbgMasume", H(this, lr).adopt(H(this, Gi));
  }
  static init(e, r) {
    ot(te, Js, e), ot(te, Fo, r), ot(te, Pn, /[、。，．）］｝〉」』】〕”〟ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ！？!?‼⁉・ーゝゞヽヾ々]/), ot(te, Mn, /[［（｛〈「『【〔“〝]/), ot(te, ra, /[─‥…]/);
  }
  static setEvtMng(e) {
    ot(te, Tn, e);
  }
  static destroy() {
    ot(te, di, /* @__PURE__ */ Object.create(null)), ot(te, pi, /* @__PURE__ */ Object.create(null)), ot(te, Vr, new Container());
  }
  lay(e) {
    const r = H(this, se).style;
    if ("style" in e)
      if (e.style) {
        const D = document.createElement("span");
        D.style.cssText = e.style;
        const N = D.style.length;
        for (let k = 0; k < N; ++k) {
          const $ = D.style[k];
          if ($ in H(te, hh)) {
            DebugMng.myTrace(`${$}は指定できません`, "W");
            continue;
          }
          r[$] = D.style[$];
        }
        !D.style.opacity && "alpha" in e && (r.opacity = String(this.spLay.alpha));
      } else
        H(this, se).style.cssText = "";
    else
      "alpha" in e && (r.opacity = String(this.spLay.alpha));
    if ("width" in e && (r.width = (e.width ?? "0") + "px"), "height" in e && (r.height = (e.height ?? "0") + "px"), "pl" in e && (r.paddingLeft = (e.pl ?? "0") + "px"), "pr" in e && (r.paddingRight = (e.pr ?? "0") + "px"), "pt" in e && (r.paddingTop = (e.pt ?? "0") + "px"), "pb" in e && (r.paddingBottom = (e.pb ?? "0") + "px"), "kinsoku_sol" in e && ot(te, Pn, new RegExp(`[${e.kinsoku_sol}]`)), "kinsoku_eol" in e && ot(te, Mn, new RegExp(`[${e.kinsoku_eol}]`)), "kinsoku_dns" in e && ot(te, ra, new RegExp(`[${e.kinsoku_dns}]`)), lt(this, Qs, pu).call(this), H(this, lr).sethArg(e), ot(this, Mr, this.spLay.position.x), r.transformOrigin = `${this.spLay.pivot.x}px ${this.spLay.pivot.y}px`, this.cvsResize(), r.display = this.spLay.visible ? "inline" : "none", r.textShadow = e.filter ?? r.textShadow ?? "", ot(this, gr, argChk_Boolean(e, "break_fixed", H(this, gr))), ot(this, We, argChk_Num(e, "break_fixed_left", H(this, We))), ot(this, qe, argChk_Num(e, "break_fixed_top", H(this, qe))), ":redraw" in e && H(this, Cn) > 0) {
      const D = [
        H(this, se).innerHTML.replaceAll(/(animation-delay: )\d+ms/g, "$10ms"),
        `<span class='sn_ch' data-add='{"ch_in_style":"default"}'>　</span>`
      ];
      lt(this, Ho, hf).call(this), this.goTxt(D, !0);
    }
  }
  cvsResize() {
    const e = H(this, se).style, r = this.sys.cvsScale;
    e.left = `${this.sys.ofsLeft4elm + H(this, Mr) * r}px`, e.top = `${this.sys.ofsTop4elm + this.spLay.position.y * r}px`, e.transform = `rotate(${this.spLay.angle}deg) scale(${this.spLay.scale.x * r}, ${this.spLay.scale.y * r})`, H(this, lr).cvsResize(), H(this, Gi).cvsResize();
  }
  get tategaki() {
    return H(this, fi);
  }
  get infTL() {
    return H(this, qt);
  }
  get getWidth() {
    return H(this, qt).$width;
  }
  get getHeight() {
    return H(this, qt).$height;
  }
  setSize(e, r) {
    H(this, qt).$width = e, H(this, qt).$height = r, H(this, se).style.width = H(this, qt).$width + "px", H(this, se).style.height = H(this, qt).$height + "px";
  }
  goTxt(e, r) {
    var Q, et, it;
    H(te, Vr).visible = !1;
    let D = H(this, Ui).length, N = "";
    if (D === 0) {
      if (H(te, Js).oCfg.debug.masume && (CmnLib.debugLog && console.log(`🍌 masume ${this.name} v:${this.visible} l:${this.x} t:${this.y} a:${this.alpha} pl:${H(this, qt).pad_left} pr:${H(this, qt).pad_right} pt:${H(this, qt).pad_top} pb:${H(this, qt).pad_bottom} w:${H(this, qt).$width} h:${H(this, qt).$height}`), H(this, ci).clear().beginFill(3407616, 0.2).lineStyle(1, 3407616, 1).drawRect(-H(this, qt).pad_left, -H(this, qt).pad_top, H(this, qt).$width, H(this, qt).$height).endFill().beginFill(13311, 0.2).lineStyle(2, 13311, 1).drawRect(
        0,
        0,
        H(this, qt).$width - H(this, qt).pad_left - H(this, qt).pad_right,
        H(this, qt).$height - H(this, qt).pad_top - H(this, qt).pad_bottom
      ).endFill()), H(this, se).innerHTML = [...e].join("").replaceAll(/[\n\t]/g, "") + H(te, Go), !H(this, gr)) {
        const tt = globalThis.getComputedStyle(H(this, se)), nt = parseFloat(tt.fontSize);
        H(this, fi) ? (ot(this, We, (H(this, qt).$width - H(this, qt).pad_left - H(this, qt).pad_right - nt * 1.5) * this.sys.cvsScale), ot(this, qe, 0)) : (ot(this, We, 0), ot(this, qe, nt / 2 * this.sys.cvsScale));
      }
    } else
      N = H(this, se).innerHTML, H(this, se).querySelectorAll(":scope > br").forEach((tt) => H(this, se).removeChild(tt)), H(this, se).insertAdjacentHTML(
        "beforeend",
        e.slice(H(this, Cn)).join("").replaceAll(/[\n\t]/g, "") + H(te, Go)
        // 末尾改行削除挙動対策
      ), --D, (Q = H(this, se).querySelector(".sn_ch_last")) == null || Q.remove();
    ot(this, Cn, e.length);
    const k = this.sys.cvsScale, $ = H(this, se).getBoundingClientRect(), G = $.left + H(this, qt).pad_left, U = $.top + H(this, qt).pad_top;
    let z;
    if (k === 1)
      z = (tt, nt) => new Rectangle(
        tt.left - G,
        tt.top - U,
        tt.width,
        tt.height + ("gjqy".includes(nt) ? H(this, ia) : 0)
      );
    else {
      const tt = this.sys.ofsPadLeft_Dom2PIXI + $.left * (1 - k), nt = this.sys.ofsPadTop_Dom2PIXI + $.top * (1 - k);
      z = (st, at) => new Rectangle(
        (st.left - tt) / k - G,
        (st.top - nt) / k - U,
        st.width / k,
        (st.height + ("gjqy".includes(at) ? H(this, ia) : 0)) / k
      );
    }
    let X = 0, V = 2, Y = !1;
    do {
      const tt = ot(this, Ui, lt(this, zo, uf).call(this, H(this, se), z));
      if (X = tt.length, !Y && (X < 2 || D === X)) {
        D > 0 && D === X && (H(this, se).innerHTML = N.replaceAll('class="sn_ch"', 'class="sn_ch sn_ch_in_default"'));
        break;
      }
      Y = !0;
      let nt = -1 / 0;
      for (; V < X; ++V) {
        const st = tt[V];
        if (st.elm.tagName === "RT")
          continue;
        const at = this.tategaki ? st.rect.y : st.rect.x;
        if (nt <= at || ((it = (et = st.elm.previousElementSibling) == null ? void 0 : et.children[0]) == null ? void 0 : it.tagName) === "BR") {
          nt = at, H(this, gr) || (ot(this, We, st.rect.x), ot(this, qe, st.rect.y));
          continue;
        }
        let ut = V - 1;
        for (; tt[ut].elm.tagName === "RT"; )
          --ut;
        const ht = tt[ut], dt = ht.ch;
        if (!H(this, gr)) {
          ot(this, We, ht.rect.x), ot(this, qe, ht.rect.y);
          const yt = globalThis.getComputedStyle(ht.elm), Tt = parseFloat(yt.fontSize);
          H(this, fi) ? ot(this, qe, H(this, qe) + Tt) : ot(this, We, H(this, We) + Tt);
        }
        nt = -1 / 0;
        const pt = V;
        if (H(te, ra).test(dt) && dt === st.ch)
          V = ut;
        else {
          if (H(te, Mn).test(dt))
            V = ut;
          else if (H(te, Pn).test(st.ch))
            for (V = ut + 1; V > 0 && H(te, Pn).test(tt[--V].ch); )
              ;
          else {
            ++V;
            continue;
          }
          for (V = ut + 1; V > 0 && H(te, Mn).test(tt[--V].ch); )
            ;
        }
        const _t = tt[V].elm.parentElement, mt = document.createElement("br");
        if (_t.classList.contains("sn_tx"))
          _t.insertBefore(mt, tt[V].elm);
        else {
          const yt = _t.parentElement;
          yt.classList.contains("sn_ch") ? yt.parentElement.insertBefore(mt, yt) : yt.insertBefore(mt, _t);
        }
        V += 2, V < pt && (V = pt), X = -1;
        break;
      }
    } while (X < 0);
    const W = CmnLib.debugLog ? (tt, nt) => console.log(`🍌 masume ch:${tt.ch} x:${nt.x} y:${nt.y} w:${nt.width} h:${nt.height}`) : () => {
    }, q = H(te, Js).oCfg.debug.masume ? (tt, nt) => {
      W(tt, nt), H(this, ci).beginFill(6737151, 0.5).lineStyle(2, 16724736, 1).drawRect(nt.x, nt.y, nt.width, nt.height).endFill();
    } : () => {
    }, K = CmnTween.ease(H(this, zi));
    for (let tt = D; tt < X; ++tt) {
      const nt = H(this, Ui)[tt], st = nt.rect, at = JSON.parse(nt.elm.dataset.arg ?? '{"delay": 0}'), ut = JSON.parse(nt.elm.dataset.add ?? "{}"), ht = H(te, di)[ut.ch_in_style];
      if (q(nt, st), nt.elm.dataset.cmd === "grp") {
        const dt = new Container();
        H(this, Hr).addChild(dt), GrpLayer.csv2Sprites(at.pic, dt, (pt) => {
          lt(this, Uo, lf).call(this, dt, at, ut, st, K, ht ?? {}), dt.parent || dt.removeChild(pt);
        });
      }
      if (nt.elm.dataset.lnk) {
        const dt = nt.elm.parentElement.closest("[data-arg]"), pt = JSON.parse(dt.dataset.arg ?? "{}");
        pt.key = `lnk=[${tt}] ` + this.name;
        const _t = new Sprite();
        lt(this, Uo, lf).call(this, _t, pt, ut, st, K, ht ?? {});
        const mt = pt.style ?? "", yt = mt + (pt.style_hover ?? ""), Tt = mt + (pt.style_clicked ?? ""), Pt = pt.r_style ?? "", St = Pt + (pt.r_style_hover ?? ""), gt = Pt + (pt.r_style_clicked ?? ""), bt = dt.querySelectorAll("rt");
        bt.forEach((Mt) => Mt.dataset.st_r_bk = Mt.style.cssText);
        const At = dt.style.cssText, Rt = (Mt, ft) => {
          dt.style.cssText = At + Mt, bt.forEach((Ft) => Ft.style.cssText = Ft.dataset.st_r_bk + ft);
        };
        argChk_Boolean(pt, "enabled", !0) ? H(te, Tn).button(
          pt,
          _t,
          () => Rt(mt, Pt),
          () => this.canFocus() ? (Rt(yt, St), !0) : !1,
          () => Rt(Tt, gt)
        ) : Rt(
          mt + (pt.style_disable ?? "color: gray;"),
          Pt + (pt.r_style_disable ?? "color: gray;")
        ), H(this, Hr).addChild(_t);
      }
    }
    const Z = H(this, se).querySelectorAll("span.sn_ch");
    ot(this, ji, () => (ot(this, ji, () => !1), Z.forEach((tt) => tt.className = tt.className.replaceAll(/ go_ch_in_[^\s"]+/g, "")), H(te, Vr).position.set(
      H(this, We),
      H(this, qe)
    ), H(te, Vr).visible = !0, H(te, Tn).noticeCompTxt(), !0)), Z.forEach((tt) => tt.className = tt.className.replaceAll(/sn_ch_in_([^\s"]+)/g, "go_ch_in_$1")), D > 0 && ++D;
    let J;
    for (let tt = X - 2; tt >= 0; --tt) {
      const nt = H(this, Ui)[tt];
      if (nt.elm.tagName === "SPAN") {
        J = nt.elm;
        break;
      }
    }
    if (!J || r || D === X) {
      H(this, ji).call(this);
      return;
    }
    J.addEventListener("animationend", H(this, ji), { once: !0, passive: !0 });
  }
  skipChIn() {
    let e = H(this, ji).call(this);
    for (const r of H(this, ea))
      r.tw && (r.tw.stop().end(), e = !0);
    return ot(this, ea, []), e;
  }
  static initChStyle() {
    ot(te, di, /* @__PURE__ */ Object.create(null)), ot(te, pi, /* @__PURE__ */ Object.create(null));
  }
  static getChInStyle(e) {
    return H(te, di)[e];
  }
  static ch_in_style(e) {
    const { name: r } = e;
    if (!r)
      throw "nameは必須です";
    if (H(te, jo).test(r))
      throw `name【${r}】に使えない文字が含まれます`;
    if (r in H(te, di))
      throw `name【${r}】はすでにあります`;
    const D = String(e.x ?? "=0"), N = String(e.y ?? "=0");
    return H(te, di)[r] = {
      wait: argChk_Num(e, "wait", 500),
      // アニメ・FI時間
      alpha: argChk_Num(e, "alpha", 0),
      x: D,
      // 初期x値
      y: N,
      // [tsy]と同様に絶対・相対指定可能
      // {x:500}			X位置を500に
      // {x:'=500'}		現在のX位置に+500加算した位置
      // {x:'=-500'}		現在のX位置に-500加算した位置
      // {x:'250,500'}	+250から＋500までの間でランダムな値をX位置に
      // {x:'=250,500'}	+250から＋500までの間でランダムな値を現在のX位置に加算
      nx: parseFloat(D.at(0) === "=" ? D.slice(1) : D),
      ny: parseFloat(N.at(0) === "=" ? N.slice(1) : N),
      scale_x: argChk_Num(e, "scale_x", 1),
      scale_y: argChk_Num(e, "scale_y", 1),
      rotate: argChk_Num(e, "rotate", 0),
      join: argChk_Boolean(e, "join", !0),
      // 文字を順番に出すか（true）同時か（false）
      ease: e.ease ?? "ease-out"
    };
  }
  static getChOutStyle(e) {
    return H(te, pi)[e];
  }
  static ch_out_style(e) {
    const { name: r } = e;
    if (!r)
      throw "nameは必須です";
    if (H(te, jo).test(r))
      throw `name【${r}】に使えない文字が含まれます`;
    if (r in H(te, pi))
      throw `name【${r}】はすでにあります`;
    const D = String(e.x ?? "=0"), N = String(e.y ?? "=0");
    return H(te, pi)[r] = {
      wait: argChk_Num(e, "wait", 500),
      // アニメ・FI時間
      alpha: argChk_Num(e, "alpha", 0),
      x: D,
      // 初期x値
      y: N,
      // [tsy]と同様に絶対・相対指定可能
      // {x:500}			X位置を500に
      // {x:'=500'}		現在のX位置に+500加算した位置
      // {x:'=-500'}		現在のX位置に-500加算した位置
      // {x:'250,500'}	+250から＋500までの間でランダムな値をX位置に
      // {x:'=250,500'}	+250から＋500までの間でランダムな値を現在のX位置に加算
      nx: parseFloat(D.at(0) === "=" ? D.slice(1) : D),
      ny: parseFloat(N.at(0) === "=" ? N.slice(1) : N),
      scale_x: argChk_Num(e, "scale_x", 1),
      scale_y: argChk_Num(e, "scale_y", 1),
      rotate: argChk_Num(e, "rotate", 0),
      join: argChk_Boolean(e, "join", !1),
      // 文字を順番に出すか（true）同時か（false）
      ease: e.ease ?? "ease-out"
    };
  }
  dispBreak(e) {
    const r = H(te, Vr);
    r.visible = !1, this.addChild(r), GrpLayer.csv2Sprites(e, r, (D) => {
      r.parent || r.removeChild(D);
    });
  }
  static delBreak() {
    const e = H(te, Vr);
    e.parent && (e.parent.removeChild(e), e.removeChildren()), ot(te, Vr, new Container());
  }
  reNew() {
    var r;
    lt(this, Ho, hf).call(this);
    const e = new te(this.spLay, () => this.canFocus(), this.sys);
    return ot(e, qt, H(this, qt)), H(e, se).style.cssText = H(this, se).style.cssText, ot(e, Mr, H(this, Mr)), e.name = this.name, lt(r = e, Qs, pu).call(r), H(e, lr).sethArg(H(this, lr).gethArg()), ot(e, wn, H(this, wn)), ot(e, zi, H(this, zi)), ot(e, Rn, H(this, Rn)), ot(e, gr, H(this, gr)), ot(e, We, H(this, We)), ot(e, qe, H(this, qe)), this.destroy(), e;
  }
  record() {
    return {
      infTL: H(this, qt),
      cssText: H(this, se).style.cssText,
      left: H(this, Mr),
      idc_hArg: H(this, lr).gethArg(),
      ch_filter: H(this, wn),
      fi_easing: H(this, zi),
      fo_easing: H(this, Rn),
      break_fixed: H(this, gr),
      break_fixed_left: H(this, We),
      break_fixed_top: H(this, qe)
    };
  }
  playback(e) {
    ot(this, qt, e.infTL), this.position.set(H(this, qt).pad_left, H(this, qt).pad_top), H(this, se).style.cssText = e.cssText, ot(this, Mr, e.left), lt(this, Qs, pu).call(this), H(this, lr).sethArg(e.idc_hArg), ot(this, wn, e.ch_filter), ot(this, zi, e.fi_easing), ot(this, Rn, e.fo_easing), ot(this, gr, e.break_fixed ?? !1), ot(this, We, e.break_fixed_left ?? 0), ot(this, qe, e.break_fixed_top ?? 0);
  }
  snapshot(e, r) {
    lt(this, ch, gd).call(this, (D) => {
      ot(this, Qe, new Sprite(D)), H(this, fi) && (H(this, Qe).x += CmnLib.stageW - (H(this, Mr) + H(this, qt).$width)), H(this, Qe).y -= H(this, ta), H(this, Qe).texture.frame = new Rectangle(
        0,
        0,
        Math.min(H(this, Qe).width, H(this, qt).$width - H(this, Mr)),
        Math.min(H(this, Qe).height, H(this, qt).$height)
      ), H(this, Hr).addChild(H(this, Qe)), e.render(H(this, Qe), { clear: !1 }), r();
    }, !1);
  }
  snapshot_end() {
    H(this, Qe) && (H(this, Hr).removeChild(H(this, Qe)), ot(this, Qe, void 0));
  }
  makeDesignCast(e) {
    e(H(this, lr));
    const r = H(this, lr).gethArg();
    H(this, Gi).sethArg({ ...r, ":id_dc": r[":id_tag"] + "_pad" }), e(H(this, Gi));
  }
  showDesignCast() {
    H(this, lr).visible = !0, H(this, Gi).visible = !0;
  }
  dump() {
    const e = [], r = H(this, se).style, D = r.length;
    for (let N = 0; N < D; ++N) {
      const k = r[N];
      e.push(`"${k}":"${r[k].replaceAll(/(["\\])/g, "\\$1")}"`);
    }
    return `"txt":"${H(this, se).textContent.replaceAll(/(["\\])/g, "\\$1")}", "style":{${e.join(",")}}`;
  }
  destroy() {
    te.delBreak(), H(this, se).parentElement.removeChild(H(this, se)), this.removeChild(H(this, Hr)), this.removeChild(H(this, ci)), super.destroy();
  }
};
let TxtStage = te;
Js = new WeakMap(), Fo = new WeakMap(), Tn = new WeakMap(), se = new WeakMap(), Hr = new WeakMap(), ci = new WeakMap(), hh = new WeakMap(), lr = new WeakMap(), Gi = new WeakMap(), qt = new WeakMap(), gr = new WeakMap(), We = new WeakMap(), qe = new WeakMap(), Qs = new WeakSet(), pu = function() {
  const e = H(this, se).style, r = parseFloat(e.fontSize || "0");
  H(this, qt).fontsize = r, H(this, qt).pad_left = parseFloat(e.paddingLeft || "0"), H(this, qt).pad_right = parseFloat(e.paddingRight || "0"), H(this, qt).pad_top = parseFloat(e.paddingTop || "0"), H(this, qt).pad_bottom = parseFloat(e.paddingBottom || "0"), H(this, qt).$width = parseFloat(e.width || "0"), H(this, qt).$height = parseFloat(e.height || "0"), this.position.set(H(this, qt).pad_left, H(this, qt).pad_top), ot(this, fi, e.writingMode === "vertical-rl"), ot(this, $o, 0), ot(this, ta, 0);
  const D = e.lineHeight ?? "0";
  ot(this, ia, H(this, fi) ? 0 : (D.slice(-2) === "px" ? parseFloat(D) : r * parseFloat(D) - r) / 2);
}, Mr = new WeakMap(), fi = new WeakMap(), $o = new WeakMap(), ta = new WeakMap(), ch = new WeakSet(), gd = function(e, r = !0) {
  const D = {
    escape: (K) => K.replaceAll(/([.*+?^${}()|\[\]\/\\])/g, "\\$1"),
    mimeType: (K) => {
      const Z = U(K).toLowerCase();
      return N()[Z] || "";
    },
    dataAsUrl: Y,
    isDataUrl: z,
    resolveUrl: X,
    getAndEncode: V,
    asArray: (K) => {
      const Z = [], J = K.length;
      for (let Q = 0; Q < J; ++Q)
        Z.push(K[Q]);
      return Z;
    }
  };
  function N() {
    const K = "application/font-woff", Z = "image/jpeg";
    return {
      woff: K,
      woff2: K,
      ttf: "application/font-truetype",
      eot: "application/vnd.ms-fontobject",
      png: "image/png",
      jpg: Z,
      jpeg: Z,
      gif: "image/gif",
      tiff: "image/tiff",
      svg: "image/svg+xml"
    };
  }
  const k = W(), $ = q();
  function G(K) {
    return $.resolveAll().then((Z) => {
      const J = document.createElement("style");
      return K.appendChild(J), J.appendChild(document.createTextNode(Z)), K;
    });
  }
  function U(K) {
    const Z = /\.([^\.\/]*?)$/g.exec(K);
    return (Z == null ? void 0 : Z[1]) ?? "";
  }
  function z(K) {
    return K.search(/^(data:)/) !== -1;
  }
  function X(K, Z) {
    const J = document.implementation.createHTMLDocument(), Q = J.createElement("base");
    J.head.appendChild(Q);
    const et = J.createElement("a");
    return J.body.appendChild(et), Q.href = Z, et.href = K, et.href;
  }
  function V(K) {
    let Z = 3e4;
    return new Promise(function(J) {
      const Q = new XMLHttpRequest();
      Q.onreadystatechange = et, Q.ontimeout = it, Q.responseType = "blob", Q.timeout = Z, Q.open("GET", K, !0), Q.send();
      function et() {
        if (Q.readyState !== 4)
          return;
        if (Q.status !== 200) {
          tt("cannot fetch resource: " + K + ", status: " + Q.status);
          return;
        }
        const nt = new FileReader();
        nt.onloadend = function() {
          const st = nt.result.toString().split(/,/)[1];
          J(st);
        }, nt.readAsDataURL(Q.response);
      }
      function it() {
        tt("timeout of " + Z + "ms occured while fetching resource: " + K);
      }
      function tt(nt) {
        console.error(nt), J("");
      }
    });
  }
  function Y(K, Z) {
    return "data:" + Z + ";base64," + K;
  }
  function W() {
    const K = /url\(['"]?([^'"]+?)['"]?\)/g;
    return {
      inlineAll: et,
      shouldProcess: Z
    };
    function Z(it) {
      return it.search(K) !== -1;
    }
    function J(it) {
      const tt = [];
      let nt;
      for (; nt = K.exec(it); )
        tt.push(nt[1]);
      return tt.filter(function(st) {
        return !D.isDataUrl(st);
      });
    }
    function Q(it, tt, nt, st) {
      return Promise.resolve(tt).then((ut) => nt ? D.resolveUrl(ut, nt) : ut).then(st || D.getAndEncode).then((ut) => D.dataAsUrl(ut, D.mimeType(tt))).then((ut) => it.replace(at(tt), "$1" + ut + "$3"));
      function at(ut) {
        return new RegExp(`(url\\(['"]?)(` + D.escape(ut) + `)(['"]?\\))`, "g");
      }
    }
    function et(it, tt, nt) {
      if (st())
        return Promise.resolve(it);
      return Promise.resolve(it).then(J).then((at) => {
        let ut = Promise.resolve(it);
        for (const ht of at)
          ut = ut.then((dt) => Q(dt, ht, tt, nt));
        return ut;
      });
      function st() {
        return !Z(it);
      }
    }
  }
  function q() {
    return {
      resolveAll: K,
      impl: { readAll: Z }
    };
    function K() {
      return Z().then((J) => Promise.allSettled(
        J.map((Q) => Q.resolve())
      )).then((J) => J.join(`
`));
    }
    function Z() {
      return Promise.resolve(D.asArray(document.styleSheets)).then(Q).then(J).then((it) => it.map(et));
      function J(it) {
        return it.filter((tt) => tt.type === CSSRule.FONT_FACE_RULE).filter((tt) => k.shouldProcess(tt.style.getPropertyValue("src")));
      }
      function Q(it) {
        const tt = [];
        for (const nt of it)
          try {
            if (nt.href)
              continue;
            D.asArray(nt.cssRules || []).forEach(tt.push.bind(tt));
          } catch (st) {
            console.error("Error while reading CSS rules from " + nt.href, st.toString());
          }
        return tt;
      }
      function et(it) {
        return {
          resolve: function() {
            const nt = (it.parentStyleSheet || {}).href;
            return k.inlineAll(it.cssText, nt);
          },
          src: function() {
            return it.style.getPropertyValue("src");
          }
        };
      }
    }
  }
  Promise.resolve(H(this, se)).then((K) => {
    const Z = K.cloneNode(!0);
    return Z.style.padding = "0px", Z.style.paddingRight = H(this, $o) + "px", Z.style.paddingTop = H(this, ta) + "px", Z.style.left = "0px", Z.style.top = "0px", Z.style.width = H(this, qt).$width - H(this, qt).pad_left - H(this, qt).pad_right + "px", Z.style.height = H(this, qt).$height - H(this, qt).pad_top - H(this, qt).pad_bottom + "px", H(this, se).hidden = r, Z;
  }).then(G).then((K) => {
    K.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
    const Z = new Image();
    return Z.src = `data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="${H(this, qt).$width}px" height="${H(this, qt).$height}px"><foreignObject x="0" y="0" width="100%" height="100%">${new XMLSerializer().serializeToString(K).replaceAll("#", "%23").replaceAll(`
`, "%0A")}</foreignObject></svg>`, new Promise((J) => Z.onload = () => J(Z));
  }).then((K) => new Promise((Z) => setTimeout(() => Z(K), 100))).then((K) => {
    const Z = document.createElement("canvas");
    Z.width = H(this, qt).$width, Z.height = H(this, qt).$height, Z.getContext("2d").drawImage(K, 0, 0), Z.toBlob((J) => {
      if (!J)
        return;
      const Q = URL.createObjectURL(J);
      Texture.from(Q).once("update", (et) => {
        e(et), URL.revokeObjectURL(Q);
      });
    });
  }).catch((K) => DebugMng.myTrace(`goTxt() = ${K}`));
}, wn = new WeakMap(), ea = new WeakMap(), Ui = new WeakMap(), Cn = new WeakMap(), Pn = new WeakMap(), Mn = new WeakMap(), ra = new WeakMap(), Go = new WeakMap(), ji = new WeakMap(), Uo = new WeakSet(), lf = function(e, r, D, N, k, $) {
  e.alpha = 0, r.x && (N.x = r.x.at(0) === "=" ? N.x + parseInt(r.x.slice(1)) : parseInt(r.x)), r.y && (N.y = r.y.at(0) === "=" ? N.y + parseInt(r.y.slice(1)) : parseInt(r.y)), r.width && (N.width = parseInt(r.width)), r.height && (N.height = parseInt(r.height)), r.wait && ($.wait = parseInt(r.wait)), e.width = N.width, e.height = N.height, $.x ? e.position.set(
    $.x.at(0) === "=" ? N.x + e.width * $.nx : $.nx,
    $.y.at(0) === "=" ? N.y + e.height * $.ny : $.ny
  ) : e.position.set(N.x, N.y);
  const G = {
    sp: e,
    tw: new Tween(e).to({ alpha: 1, x: N.x, y: N.y, width: N.width, height: N.height, angle: 0 }, $.wait ?? 0).easing(k).delay((D.wait ?? 0) + (r.delay ?? 0)).onComplete(() => {
      G.tw = void 0;
    }).start()
  };
  H(this, ea).push(G);
}, di = new WeakMap(), jo = new WeakMap(), pi = new WeakMap(), Vr = new WeakMap(), ia = new WeakMap(), zo = new WeakSet(), uf = function(e, r) {
  const D = [];
  if (e.nodeType !== e.TEXT_NODE)
    return Array.from(e.childNodes).map((G) => lt(this, zo, uf).call(this, G, r)).flat();
  const N = e.ownerDocument.createRange();
  N.selectNodeContents(e);
  let k = 0;
  const $ = N.endOffset;
  for (; k < $; ) {
    N.setStart(e, k), N.setEnd(e, ++k);
    const G = N.toString();
    D.push({
      ch: G,
      rect: r(N.getBoundingClientRect(), G),
      elm: N.startContainer.parentElement
    });
  }
  return N.detach(), D;
}, zi = new WeakMap(), Rn = new WeakMap(), Ho = new WeakSet(), hf = function() {
  var k;
  H(this, ci).clear(), ot(this, Ui, []), ot(this, Cn, 0), this.skipChIn();
  const e = H(this, se).cloneNode(!0);
  e.textContent = "";
  const r = H(this, se);
  r.parentElement.insertBefore(e, r);
  let D = 0;
  r.querySelectorAll("span.sn_ch").forEach(($) => {
    var z, X, V;
    const G = JSON.parse(
      ($ == null ? void 0 : $.dataset.add) ?? // 通常文字
      ((z = $ == null ? void 0 : $.children[0]) == null ? void 0 : z.getAttribute("data-add")) ?? // ルビ
      ((V = (X = $ == null ? void 0 : $.children[0]) == null ? void 0 : X.children[0]) == null ? void 0 : V.getAttribute("data-add")) ?? "{}"
      // 縦中横
    );
    if (!G.ch_out_style)
      return;
    const U = H(te, pi)[G.ch_out_style];
    if (U) {
      if (U.wait === 0) {
        $.style.display = "none";
        return;
      }
      D += U.wait, U.join || ($.style.animationDelay = "0ms"), $.classList.add(`go_ch_out_${G.ch_out_style}`);
    }
  });
  const N = () => {
    r.parentElement.removeChild(r);
    for (const $ of H(this, Hr).removeChildren())
      $ instanceof Container && H(te, Tn).unButton($), $.destroy();
  };
  D === 0 ? (H(this, se).textContent = "", N()) : (k = r.lastElementChild) == null || k.addEventListener("animationend", N, { once: !0, passive: !0 }), ot(this, se, e);
}, Qe = new WeakMap(), rt(TxtStage, Js, void 0), rt(TxtStage, Fo, void 0), rt(TxtStage, Tn, void 0), rt(TxtStage, hh, {
  "background-color": 0,
  "border-bottom-width": 0,
  "border-left-width": 0,
  "border-right-width": 0,
  "border-top-width": 0,
  "margin-bottom": 0,
  "margin-left": 0,
  "margin-right": 0,
  "margin-top": 0
}), rt(TxtStage, Pn, void 0), rt(TxtStage, Mn, void 0), rt(TxtStage, ra, void 0), rt(TxtStage, Go, "<span class='sn_ch sn_ch_last'>　</span>"), rt(TxtStage, di, /* @__PURE__ */ Object.create(null)), rt(TxtStage, jo, /[\s\.,]/), rt(TxtStage, pi, /* @__PURE__ */ Object.create(null)), rt(TxtStage, Vr, new Container());
var On, Xr, Vo;
const Di = class {
  constructor() {
    rt(this, Xr, () => {
    });
  }
  static setting(t) {
    t.sesame && ot(Di, On, t.sesame);
  }
  static getSesame() {
    return H(Di, On);
  }
  static destroy() {
    ot(Di, On, "ヽ");
  }
  init(t) {
    ot(this, Xr, t);
  }
  static setEscape(t) {
    ot(Di, Vo, new RegExp(
      `${t ? `(?<ce>\\${t}\\S)|` : ""}｜(?<str>[^《\\n]+)《(?<ruby>[^》\\n]+)》|(?:(?<kan>[⺀-⿟々〇〻㐀-鿿豈-﫿]+[ぁ-ヿ]*|[^　｜《》\\n])《(?<kan_ruby>[^》\\n]+)》)|(?<txt>[\uD800-\uDBFF][\uDC00-\uDFFF]|[^｜《》]+?|.)`,
      "gs"
    ));
  }
  putTxt(t) {
    for (const { groups: e } of t.matchAll(H(Di, Vo))) {
      const { ruby: r, kan_ruby: D, kan: N, ce: k, txt: $ = "", str: G } = e;
      if (r) {
        this.putTxtRb(decodeURIComponent(G), r);
        continue;
      }
      if (D) {
        this.putTxtRb(N, D);
        continue;
      }
      if (k) {
        H(this, Xr).call(this, k.slice(1), "");
        continue;
      }
      for (const U of Array.from($))
        H(this, Xr).call(this, U, "");
    }
  }
  putTxtRb(t, e) {
    if (/^\w+｜{"/.test(e)) {
      H(this, Xr).call(this, t, e);
      return;
    }
    const r = Array.from(t), D = r.length;
    if (/^\*.?$/.test(e)) {
      const G = "center｜" + (e === "*" ? H(Di, On) : e.charAt(1));
      for (let U = 0; U < D; ++U)
        H(this, Xr).call(this, r[U], G);
      return;
    }
    if (D === 1 || e.indexOf(" ") === -1) {
      H(this, Xr).call(this, t, decodeURIComponent(e));
      return;
    }
    const N = e.split(" "), k = N.length, $ = k > D ? k : D;
    for (let G = 0; G < $; ++G)
      H(this, Xr).call(this, G < D ? r[G] : "", G < k ? decodeURIComponent(N[G]) : "");
  }
};
let RubySpliter = Di;
On = new WeakMap(), Xr = new WeakMap(), Vo = new WeakMap(), rt(RubySpliter, On, "ヽ"), /*
		★Unicodeで「漢字」の正規表現 – ものかの http://tama-san.com/kanji-regex/
		2E80..2FDF CJK部首補助＋康熙部首
		3005 々（漢字の踊り字）
		3007 〇（漢数字のゼロ）
		303B 〻（漢字の踊り字）
		3400..4DBF CJK統合漢字拡張A
		4E00..9FFF CJK統合漢字
		F900..FAFF CJK互換漢字
		20000..2FFFF CJK統合漢字拡張B〜F＋CJK互換漢字追加＋念のためU+2FFFFまで

		[\x{2E80}-\x{2FDF}々〇〻\x{3400}-\x{4DBF}\x{4E00}-\x{9FFF}\x{F900}-\x{FAFF}\x{20000}-\x{2FFFF}]
		[\u2E80-\u2FDF々〇〻\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\u20000-\u2FFFF]
		[⺀-⿟々〇〻㐀-䶿一-鿿豈-﫿\u20000-\u2FFFF]		// 含まれない文字がある
		[⺀-⿟々〇〻㐀-鿿豈-﫿\u20000-\u2FFFF]			// ヽ--30FD が変に引っかかる。多分\u2000-\u2FFF解釈
		\\u{20000}-\\u{2FFFF}	// 五桁だとエラー

		【2022/10/03】ruby正規表現のUnicode プロパティ(とPOSIX文字クラス) - Qiita https://qiita.com/Takayuki_Nakano/items/8d38beaddb84b488d683
			> このHiraganaプロパティ、長音記号は含まれていません。
			> \p{Han}…簡体字や繁体字、韓国語の漢字…ベトナム語の漢字にもマッチ
		
		・Unicode文字一覧表 - instant tools https://tools.m-bsys.com/ex/unicode_table.php
*/
rt(RubySpliter, Vo, void 0);
var Xo, Yo, Rr, vi, na, sa, Wo, cf, aa, oa, qo, ff;
const un = class extends Container {
  constructor(e, r, D, N) {
    var W;
    super();
    rt(this, Wo);
    rt(this, qo);
    It(this, "getBtnBounds", () => H(this, Rr));
    // 文字ボタンは背景画像を含まない位置指定なので、その当たり判定用
    rt(this, Rr, new Rectangle());
    rt(this, vi, void 0);
    rt(this, na, void 0);
    rt(this, sa, void 0);
    It(this, "normal", () => {
    });
    rt(this, aa, () => !1);
    rt(this, oa, () => {
    });
    this.hArg = e, this.evtMng = r, this.resolve = D, this.canFocus = N, CmnLib.isDbg && (this.makeDesignCast = (q) => q(H(this, vi)), this.cvsResize = () => H(this, vi).cvsResize());
    let k = {
      x: this.x = uint(e.left ?? 0),
      y: this.y = uint(e.top ?? 0),
      rotation: this.angle = argChk_Num(e, "rotation", this.angle),
      // flash : rotation is in degrees.
      // pixijs: rotation is in radians, angle is in degrees.
      pivot_x: this.pivot.x = argChk_Num(e, "pivot_x", this.pivot.x),
      pivot_y: this.pivot.y = argChk_Num(e, "pivot_y", this.pivot.y),
      scale_x: this.scale.x = argChk_Num(e, "scale_x", this.scale.x),
      scale_y: this.scale.y = argChk_Num(e, "scale_y", this.scale.y),
      width: 0,
      height: 0
    };
    this.getBtnBounds = () => (H(this, Rr).x = k.x, H(this, Rr).y = k.y, H(this, Rr));
    const $ = k.enabled = argChk_Boolean(e, "enabled", !0);
    if ($ && r.button(this.hArg, this, () => this.normal(), () => H(this, aa).call(this), () => H(this, oa).call(this)), e.pic) {
      k.type = "pic", ot(this, vi, new PicBtnDesignCast(this, e)), GrpLayer.csv2Sprites(
        e.pic,
        this,
        (q) => {
          lt(this, qo, ff).call(this, q, k), H(this, Rr).width = q.width * k.scale_x, H(this, Rr).height = q.height * k.scale_y;
        },
        (q) => D
      );
      return;
    }
    if (!e.text)
      throw "textまたはpic属性は必須です";
    const G = argChk_Num(e, "height", 30), U = new TextStyle({
      align: "center",
      dropShadow: !0,
      dropShadowAlpha: 0.7,
      dropShadowColor: "white",
      dropShadowBlur: 7,
      dropShadowDistance: 0,
      fill: $ ? "black" : "gray",
      fontFamily: un.fontFamily,
      fontSize: G,
      padding: 5
    });
    if (e.style)
      try {
        const q = JSON.parse(e.style);
        for (const [K, Z] of Object.entries(q))
          U[K] = Z;
      } catch (q) {
        throw new Error(mesErrJSON(e, "style", q.message));
      }
    const z = new Text(e.text ?? "", U);
    z.alpha = argChk_Num(e, "alpha", z.alpha), z.width = argChk_Num(e, "width", 100), z.height = e.height = G, this.setText = (q) => z.text = q, k.type = "text", k = { ...k, ...U }, k.alpha = z.alpha, k.text = z.text, k.width = z.width, k.height = z.height, ot(this, vi, new TxtBtnDesignCast(this, e, z));
    let X = !1;
    if (k.width = this.width, k.height = this.height, e.b_pic && (k.b_pic = e.b_pic, X = GrpLayer.csv2Sprites(
      e.b_pic,
      this,
      (q) => {
        lt(this, Wo, cf).call(this, q, z), k.width = this.width, k.height = this.height;
      },
      (q) => {
        Layer.setBlendmode(this, e), q && D();
      }
    )), z.name = JSON.stringify(k), this.addChild(z), H(this, Rr).width = z.width, H(this, Rr).height = z.height, e.b_pic || Layer.setBlendmode(this, e), H(W = un, Xo).call(W, this, z), !$) {
      X || D();
      return;
    }
    const V = U.clone();
    if (e.style_hover)
      try {
        const q = JSON.parse(e.style_hover);
        for (const [K, Z] of Object.entries(q))
          V[K] = Z;
      } catch (q) {
        throw new Error(mesErrJSON(e, "style_hover", q.message));
      }
    else
      V.fill = "white";
    const Y = V.clone();
    if (e.style_clicked)
      try {
        const q = JSON.parse(e.style_clicked);
        for (const [K, Z] of Object.entries(q))
          Y[K] = Z;
      } catch (q) {
        throw new Error(mesErrJSON(e, "style_clicked", q.message));
      }
    else
      Y.dropShadow = !1;
    this.normal = () => z.style = U, ot(this, aa, () => N() ? (z.style = V, !0) : !1), ot(this, oa, () => z.style = Y), X || D();
  }
  static init(e) {
    e.oCfg.debug.masume && (ot(un, Xo, (r, D) => r.addChild(
      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(D.x, D.y, D.width, D.height).endFill()
    )), ot(un, Yo, (r, D, N, k) => r.addChild(
      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(D.x, D.y, N, k).endFill()
    )));
  }
  setText(e) {
  }
  destroy(e) {
    this.evtMng.unButton(this), super.destroy();
  }
  makeDesignCast(e) {
  }
  showDesignCast() {
    H(this, vi).visible = !0;
  }
  cvsResize() {
  }
  update_b_pic(e, r) {
    const D = JSON.parse(r.name ?? "{}");
    H(this, na) && this.removeChild(H(this, na)), this.hArg.b_pic = D.b_pic = e, r.name = JSON.stringify(D), e && GrpLayer.csv2Sprites(
      e,
      this,
      (N) => lt(this, Wo, cf).call(this, N, r),
      () => Layer.setBlendmode(this, this.hArg)
    );
  }
  update_pic(e, r) {
    const D = JSON.parse(r.name ?? "{}");
    H(this, sa) && this.removeChild(H(this, sa)), this.hArg.pic = D.pic = e, r.name = JSON.stringify(D), e && GrpLayer.csv2Sprites(
      e,
      this,
      (N) => lt(this, qo, ff).call(this, N, D),
      () => Layer.setBlendmode(this, this.hArg)
    );
  }
};
let Button = un;
Xo = new WeakMap(), Yo = new WeakMap(), Rr = new WeakMap(), vi = new WeakMap(), na = new WeakMap(), sa = new WeakMap(), Wo = new WeakSet(), cf = function(e, r) {
  ot(this, na, e), this.setChildIndex(e, 0), e.alpha = r.alpha, e.setTransform(
    r.x,
    r.y,
    1,
    1,
    r.rotation,
    0,
    0,
    (e.width - r.width) / 2,
    (e.height - r.height) / 2
  ), e.name = r.name;
}, aa = new WeakMap(), oa = new WeakMap(), qo = new WeakSet(), ff = function(e, r) {
  var X;
  ot(this, sa, e), r.alpha = e.alpha = argChk_Num(this.hArg, "alpha", e.alpha), H(this, vi).setSp(e);
  const D = e.width / 3, N = e.height, k = e.texture.baseTexture, $ = new Texture(k, new Rectangle(0, 0, D, N)), G = new Texture(k, new Rectangle(D, 0, D, N)), U = new Texture(k, new Rectangle(D * 2, 0, D, N)), z = () => e.texture = $;
  z(), this.normal = z, ot(this, aa, () => this.canFocus() ? (e.texture = U, !0) : !1), ot(this, oa, () => e.texture = G), "width" in this.hArg ? (r.width = uint(this.hArg.width), this.scale.x *= r.width / D) : r.width = D, "height" in this.hArg ? (r.height = uint(this.hArg.height), this.scale.y *= r.height / N) : r.height = N, e.name = JSON.stringify(r), H(X = un, Yo).call(X, this, e, D, N);
}, It(Button, "fontFamily", "'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif"), rt(Button, Xo, (e, r) => {
}), rt(Button, Yo, (e, r, D, N) => {
});
var la, Or, Ko, ua, Zo, df, Jo, pf, Qo, In, tl, gi, Dn, fh, md, mi, mr, Ir, ge, Yr, le, el, Wr, dh, tr, An, Xa, Nn, ha, kn, Ya, ca, rl, vf, il, gf, Ln, Bn, fa, nl, da, Hi, er, ph, _d, ur, sl, pa, vu, _i, sn, qr, Dr, _r, yr, al, mf, va, gu, ol, _f, Fn, $n;
const ie = class extends Layer {
  constructor() {
    super();
    rt(this, An);
    rt(this, kn);
    rt(this, rl);
    rt(this, il);
    rt(this, ph);
    rt(this, pa);
    rt(this, _i);
    rt(this, al);
    rt(this, va);
    rt(this, ol);
    // バック
    rt(this, mi, 0);
    rt(this, mr, 0);
    rt(this, Ir, !1);
    rt(this, ge, void 0);
    rt(this, Yr, "");
    // 背景画像無し（＝単色塗り）
    // 文字表示
    rt(this, le, new TxtStage(this.spLay, () => this.canFocus(), H(ie, tl)));
    rt(this, el, new RubySpliter());
    rt(this, Wr, document.createElement("span"));
    rt(this, tr, new Container());
    rt(this, Nn, "");
    rt(this, ha, !0);
    rt(this, ca, "");
    rt(this, Ln, "");
    rt(this, Bn, (e) => "");
    rt(this, fa, "");
    rt(this, nl, new RegExp("[　]"));
    It(this, "isCur", !1);
    rt(this, Hi, () => "");
    rt(this, er, "");
    rt(this, ur, !1);
    rt(this, sl, (e, r) => {
      var U, z, X;
      H(ie, la).oCfg.debug.putCh && console.log(`🖊 文字表示 text:\`${e}\` ruby:\`${r}\` name:\`${this.name_}\``);
      const D = r.split("｜");
      let N = "";
      const [k, ...$] = D, G = $.join("｜");
      switch (D.length) {
        case 1:
          if (ot(this, ur, !0), e === `
`) {
            H(this, Dr) ? (ot(this, Dr, !1), N = "<ruby>　<rt>　</rt></ruby><br/>") : N = "<br/>";
            break;
          }
          H(this, Dr) && (ot(this, Dr, !1), r === "" && (r = "　")), N = lt(this, pa, vu).call(this, e, r, H(this, er));
          break;
        default:
          switch (k) {
            case "start":
            case "left":
            case "center":
            case "right":
            case "justify":
            case "121":
            case "even":
            case "1ruby":
              ot(this, Dr, !1), ot(this, ur, !0), N = lt(this, pa, vu).call(this, e, G, k);
              break;
            case "gotxt":
              lt(this, va, gu).call(this), H(this, ur) ? (this.isCur && H(ie, ua).recText(
                H(this, _r).join("").replace(/^<ruby>　<rt>　<\/rt><\/ruby>(<br\/>)+/, "").replaceAll(/style='(anim\S+ \S+?;\s*)+/g, "style='").replaceAll(/( style=''| data-(add|arg|cmd)='.+?'|\n+|\t+)/g, "").replaceAll(/class='sn_ch .+?'/g, "class='sn_ch'").replaceAll("display: none;", "").replaceAll("class='offrec'", "style='display: none;'")
                // 囲んだ領域は履歴で非表示
              ), H(this, le).goTxt(H(this, _r), H(this, qr) === 0), ot(this, ur, !1), ot(this, qr, 0)) : this.isCur && H(ie, In).noticeCompTxt();
              return;
            case "add":
              {
                const V = JSON.parse(G), { style: Y = "", wait: W = null } = V, { cl: q, sty: K } = lt(this, _i, sn).call(this, !0, W);
                H(this, _r).push(`<span${q} style='${K} display: inline; ${Y}'>`), delete V.style, lt(this, al, mf).call(this, V);
              }
              return;
            case "add_close":
              H(this, _r).push("</span>"), lt(this, va, gu).call(this);
              return;
            case "grp":
              ot(this, ur, !0);
              {
                const V = JSON.parse(G);
                if (V.id ?? (V.id = H(this, _r).length), V.id === "break") {
                  H(this, le).dispBreak(V.pic);
                  return;
                }
                ot(this, Dr, !1), V.delay = H(this, qr), V.r ?? (V.r = ""), V.style ?? (V.style = ""), V.r_style ?? (V.r_style = "");
                const { cl: Y, sty: W, lnk: q } = lt(this, _i, sn).call(this, !0, V.wait);
                N = `<span${Y} style='${W} ${V.style}'><ruby><span data-cmd='grp' data-arg='${JSON.stringify(V)}'${q} style='${W} display: inline;'>　</span><rt${q}${this.mkStyle_r_align(
                  "　",
                  V.r,
                  H(this, er),
                  H(this, Wr).style.cssText + (((U = H(this, yr).at(-1)) == null ? void 0 : U.o.r_style) ?? "") + V.r_style
                )}>${V.r}</rt></ruby></span>`;
              }
              break;
            case "tcy":
              ot(this, Dr, !1), ot(this, ur, !0);
              {
                const { t: V, r: Y = "", wait: W = null, style: q = "", r_style: K = "" } = JSON.parse(G);
                H(ie, Or).doRecLog() && (ot(this, Fn, H(this, Fn) + (e + (r ? `《${r}》` : ""))), ot(this, $n, H(this, $n) + V));
                const Z = CmnLib.isSafari ? Y.replaceAll(/[A-Za-z0-9]/g, (it) => String.fromCharCode(it.charCodeAt(0) + 65248)) : Y, { cl: J, sty: Q, lnk: et } = lt(this, _i, sn).call(this, !0, W);
                N = `<span${J} style='${Q}${H(this, Bn).call(this, V)} ${q}'><ruby><span${et} style='${Q} display: inline;
text-combine-upright: all;
-webkit-text-combine: horizontal;'>${V}</span><rt${et}${this.mkStyle_r_align(
                  V,
                  Z,
                  H(this, er),
                  H(this, Wr).style.cssText + (((z = H(this, yr).at(-1)) == null ? void 0 : z.o.r_style) ?? "") + K
                )}>${Z}</rt></ruby></span>`;
              }
              break;
            case "del":
              TxtStage.delBreak();
              return;
            case "span":
              ot(this, ur, !0), lt(this, ol, _f).call(this, JSON.parse(G));
              return;
            case "link":
              ot(this, ur, !0);
              {
                const V = JSON.parse(G);
                V[":link"] = " data-lnk='@'";
                const { cl: Y, sty: W, curpos: q } = lt(this, _i, sn).call(this, !1, V.wait);
                H(this, _r).push(`<span${Y} style='${W} display: inline; ${V.style ?? ""}' ${q} data-arg='${G}'>`), delete V.style, lt(this, ol, _f).call(this, V);
              }
              return;
            case "endlink":
              ot(this, ur, !0), H(this, _r).push("</span>"), lt(this, va, gu).call(this);
              return;
            default:
              ot(this, ur, !0), N = lt(this, pa, vu).call(this, e, r, H(this, er));
          }
          break;
      }
      H(this, _r).push(H(X = ie, da).call(X, N));
    });
    rt(this, qr, 0);
    rt(this, Dr, !0);
    rt(this, _r, []);
    rt(this, yr, []);
    It(this, "click", () => !this.spLay.interactiveChildren || !this.spLay.visible ? !1 : H(this, le).skipChIn());
    rt(this, Fn, "");
    rt(this, $n, "");
    It(this, "addButton", (e) => new Promise((r) => {
      e.key = `btn=[${H(this, tr).children.length}] ` + this.name_, e[":id_tag"] = e.key.slice(0, -7), argChk_Boolean(e, "hint_tate", H(this, le).tategaki);
      const D = new Button(e, H(ie, In), () => r(), () => this.canFocus());
      D.name = JSON.stringify(e).replaceAll('"', "'"), H(this, tr).addChild(D);
    }));
    It(this, "record", () => ({
      ...super.record(),
      enabled: this.enabled,
      r_cssText: H(this, Wr).style.cssText,
      r_align: H(this, er),
      // バック
      b_do: H(this, ge) === void 0 ? void 0 : H(this, ge) instanceof Sprite ? "Sprite" : "Graphics",
      b_pic: H(this, Yr),
      b_color: H(this, mi),
      b_alpha: H(this, mr),
      b_alpha_isfixed: H(this, Ir),
      ffs: H(this, Ln),
      txs: H(this, le).record(),
      strNoFFS: H(this, fa),
      btns: H(this, tr).children.map((e) => e.name)
    }));
    this.spLay.addChild(H(this, le)), H(this, el).init(H(this, sl)), this.spLay.addChild(H(this, tr)), H(this, tr).name = "cntBtn";
    const e = 16;
    this.lay({ style: `width: ${CmnLib.stageW}px; height: ${CmnLib.stageH}px; font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif; color: white; font-size: 24px; line-height: 1.5; padding: ${e}px;`, in_style: "default", out_style: "default", back_clear: "true" });
  }
  static init(e, r, D, N, k, $) {
    var G, U;
    ot(ie, la, e), TxtStage.init(e, $), ot(ie, Or, D), ot(ie, ua, N), ot(ie, Ko, k), D.setDoRecProc(ie.chgDoRec), r.autowc = (z) => {
      var X;
      return lt(X = ie, fh, md).call(X, z);
    }, r.autowc({ enabled: !1, text: "", time: 0 }), r.ch_in_style = (z) => {
      var X;
      return lt(X = ie, Zo, df).call(X, z);
    }, r.ch_out_style = (z) => {
      var X;
      return lt(X = ie, Jo, pf).call(X, z);
    }, TxtStage.initChStyle(), initStyle(), addStyle(
      e.matchPath(".+", SEARCH_PATH_ARG_EXT.FONT).flatMap((z) => Object.values(z).map((X) => `
@font-face {
	font-family: '${X}';
	src: url('${H(this, la).searchPath(X, SEARCH_PATH_ARG_EXT.FONT)}');
}
`)).join("") + `
.sn_tx {
	pointer-events: none;
	user-select: none;
	-webkit-touch-callout: none;
	box-sizing: border-box;
}
.sn_ch {
	position: relative;
	display: inline-block;
}
`
      // 「sn_ch」と「sn_ch_in_〜」の中身が重複しているが、これは必須
    ), lt(G = ie, Zo, df).call(G, {
      name: "default",
      wait: 500,
      alpha: 0,
      x: "=0.3",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: !0,
      ease: "ease-out"
    }), lt(U = ie, Jo, pf).call(U, {
      name: "default",
      wait: 0,
      alpha: 0,
      x: "=0",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: !1,
      ease: "ease-out"
    });
  }
  static setEvtMng(e, r, D) {
    ot(ie, Qo, e), ot(ie, In, r), ot(ie, tl, D), TxtStage.setEvtMng(r);
  }
  destroy() {
    H(this, ge) && (this.spLay.removeChild(H(this, ge)).destroy(), ot(this, ge, void 0)), this.clearText(), H(this, le).destroy();
  }
  static destroy() {
    ot(ie, gi, !1), ot(ie, Dn, {}), ot(ie, da, (e) => e);
  }
  set name(e) {
    this.name_ = e, H(this, le).name = e;
  }
  get name() {
    return this.name_;
  }
  // getは継承しないらしい
  cvsResize() {
    H(this, le).cvsResize();
  }
  cvsResizeChildren() {
    for (const e of H(this, tr).children)
      e.cvsResize();
  }
  procSetX(e) {
    H(this, le).lay({ x: e });
  }
  procSetY(e) {
    H(this, le).lay({ y: e });
  }
  lay(e) {
    if (super.lay(e), Layer.setXY(this.spLay, e, this.spLay), e[":id_tag"] = this.name_.slice(0, -7), RubySpliter.setting(e), lt(this, il, gf).call(this, e), H(this, le).lay(e), "r_align" in e && ot(this, er, e.r_align ?? ""), ot(this, Hi, CmnLib.isSafari ? H(this, le).tategaki ? (r, D) => `text-align: start; height: ${D}em; padding-top: ${r}; padding-bottom: ${r};` : (r, D) => `text-align: start; width: ${D}em; padding-left: ${r}; padding-right: ${r};` : H(this, le).tategaki ? (r) => `text-align: justify; text-align-last: justify; padding-top: ${r}; padding-bottom: ${r};` : (r) => `text-align: justify; text-align-last: justify; padding-left: ${r}; padding-right: ${r};`), CmnLib.isFirefox && (this.mkStyle_r_align = lt(this, ph, _d)), "r_style" in e)
      if (e.r_style) {
        const r = document.createElement("span");
        r.style.cssText = e.r_style;
        const D = r.style.length, N = H(this, Wr).style;
        for (let k = 0; k < D; ++k) {
          const $ = r.style[k];
          if ($ in H(ie, dh)) {
            DebugMng.myTrace(`${$}は指定できません`, "W");
            continue;
          }
          N[$] = r.style[$];
        }
      } else
        H(this, Wr).style.cssText = "";
    if ("alpha" in e)
      for (const r of H(this, tr).children)
        r.alpha = this.spLay.alpha;
    return lt(this, An, Xa).call(this, e), lt(this, kn, Ya).call(this, e), lt(this, rl, vf).call(this, e, (r) => {
      r && H(ie, Qo).resume();
    });
  }
  get width() {
    return H(this, le).getWidth;
  }
  get height() {
    return H(this, le).getHeight;
  }
  chgBackAlpha(e) {
    const r = H(this, Ir) ? H(this, mr) : e * H(this, mr);
    H(this, ge) instanceof Graphics && (H(this, ge) && (this.spLay.removeChild(H(this, ge)), H(this, ge).destroy()), this.spLay.addChildAt(
      ot(this, ge, new Graphics()).beginFill(H(this, mi)).lineStyle(void 0).drawRect(0, 0, H(this, le).getWidth, H(this, le).getHeight).endFill(),
      0
    ), H(this, ge).name = "back(color)"), H(this, ge) && (H(this, ge).visible = r > 0, H(this, ge).alpha = r);
  }
  // Safariが全体に「font-feature-settings」した後、特定文字の「font-feature-settings: initial;」を受け付けてくれないのでわざわざ一つずつ指定
  static chgDoRec(e) {
    ot(ie, da, e ? (r) => r : (r) => `<span class='offrec'>${r}</span>`);
  }
  mkStyle_r_align(e, r, D, N = "") {
    if (!D)
      return ` style='${N}'`;
    const k = e.length * 2;
    if (k - r.length < 0)
      return ` style='text-align: ${D}; ${N}'`;
    let $ = "";
    switch (D) {
      case "justify":
        $ = H(this, Hi).call(this, "0", k);
        break;
      case "121":
        $ = H(this, Hi).call(this, `calc(${(k - r.length) / (r.length * 2)}em)`, k);
        break;
      case "even":
        $ = H(this, Hi).call(this, `calc(${(k - r.length) / (r.length + 1)}em)`, k);
        break;
      case "1ruby":
        $ = H(this, Hi).call(this, "1em", k);
        break;
      default:
        $ = `text-align: ${D};`;
    }
    return ` style='${$} ${N}'`;
  }
  tagCh(e) {
    H(this, el).putTxt(e);
  }
  clearText() {
    this.spLay.addChild(ot(this, le, H(this, le).reNew())), ot(this, qr, 0), ot(this, Dr, !0), ot(this, _r, []), ot(this, Fn, ""), ot(this, $n, ""), H(ie, ua).recPagebreak();
  }
  get pageText() {
    return H(this, Fn).replace("《　》", "");
  }
  get pagePlainText() {
    return H(this, $n);
  }
  get enabled() {
    return this.spLay.interactiveChildren;
  }
  set enabled(e) {
    this.spLay.interactiveChildren = e;
  }
  canFocus() {
    var e;
    return (this.spLay.interactiveChildren ?? !1) && this.spLay.visible && H(e = ie, Ko).call(e, this);
  }
  clearLay(e) {
    super.clearLay(e), this.clearText();
    for (const r of H(this, tr).removeChildren())
      r.destroy();
  }
  playback(e, r) {
    super.playback(e, r), this.enabled = e.enabled, H(this, Wr).style.cssText = e.r_cssText, ot(this, er, e.r_align), this.cvsResize(), lt(this, il, gf).call(this, e), H(this, le).playback(e.txs), ot(this, mr, e.b_alpha), ot(this, Ir, e.b_alpha_isfixed), r.push(new Promise((N) => {
      const k = e.b_do ? e.b_do === "Sprite" ? { b_pic: e.b_pic } : { b_color: e.b_color } : { b_pic: "" };
      k.b_alpha = e.b_alpha, k.b_alpha_isfixed = e.b_alpha_isfixed, lt(this, rl, vf).call(this, k, ($) => {
        $ && N();
      }) || N();
    }));
    const D = e.btns;
    r = r.concat(D.map((N) => this.addButton(JSON.parse(N.replaceAll("'", '"')))));
  }
  snapshot(e, r) {
    e.render(this.spLay, { clear: !1 }), H(this, le).snapshot(e, r);
  }
  snapshot_end() {
    H(this, le).snapshot_end();
  }
  makeDesignCast(e) {
    this.spLay.visible && H(this, le).makeDesignCast(e);
  }
  makeDesignCastChildren(e) {
    if (this.spLay.visible)
      for (const r of H(this, tr).children)
        r.makeDesignCast(e);
  }
  showDesignCast() {
    H(this, le).showDesignCast();
  }
  showDesignCastChildren() {
    for (const e of H(this, tr).children)
      e.showDesignCast();
  }
  dump() {
    return H(this, sl).call(this, "", "gotxt｜"), super.dump() + `, "enabled":"${this.enabled}", ${H(this, le).dump()}, "b_pic":"${H(this, Yr)}", "b_color":"${H(this, mi)}", "b_alpha":${H(this, mr)}, "b_alpha_isfixed":"${H(this, Ir)}", "width":${H(this, le).getWidth}, "height":${H(this, le).getHeight}, "pixi_obj":[${this.spLay.children.map((e) => `{"class":"${e instanceof Sprite ? "Sprite" : e instanceof Graphics ? "Graphics" : e instanceof Container ? "Container" : "?"}", "name":"${e.name}", "alpha":${e.alpha}, "x":${e.x}, "y":${e.y}, "visible":"${e.visible}"}`).join(",")}], "button":[${H(this, tr).children.map((e) => e.children[0].name ?? "{}").join(",")}]`;
  }
};
let TxtLayer = ie;
la = new WeakMap(), Or = new WeakMap(), Ko = new WeakMap(), ua = new WeakMap(), Zo = new WeakSet(), df = function(e) {
  const r = TxtStage.ch_in_style(e), D = r.x.at(0) === "=" ? `${r.nx * 100}%` : `${r.nx}px`, N = r.y.at(0) === "=" ? `${r.ny * 100}%` : `${r.ny}px`, { name: k } = e;
  return addStyle(`
.sn_ch_in_${k} {
	position: relative;
	display: inline-block;
}
.go_ch_in_${k} {
	opacity: ${r.alpha};
	position: relative;
	display: inline-block;
	animation: sn_ch_in_${k} ${r.wait}ms ${r.ease} 0s both;
}
@keyframes sn_ch_in_${k} {
	from {transform: rotate(${r.rotate}deg) scale(${r.scale_x}, ${r.scale_y}) translate(${D}, ${N});}
	to {opacity: 1; transform: none;}
}
`), !1;
}, Jo = new WeakSet(), pf = function(e) {
  const r = TxtStage.ch_out_style(e), D = r.x.at(0) === "=" ? `${r.nx * 100}%` : `${r.nx}px`, N = r.y.at(0) === "=" ? `${r.ny * 100}%` : `${r.ny}px`, { name: k } = e;
  return addStyle(`
.go_ch_out_${k} {
	position: relative;
	display: inline-block;
	animation: go_ch_out_${k} ${r.wait}ms ${r.ease} 0s both;
}
@keyframes go_ch_out_${k} {
	to {
		opacity: ${r.alpha};
		transform: rotate(${r.rotate}deg) scale(${r.scale_x}, ${r.scale_y}) translate(${D}, ${N});
	}
`), !1;
}, Qo = new WeakMap(), In = new WeakMap(), tl = new WeakMap(), gi = new WeakMap(), Dn = new WeakMap(), fh = new WeakSet(), md = function(e) {
  ot(ie, gi, argChk_Boolean(e, "enabled", H(ie, gi))), H(ie, Or).setVal_Nochk("save", "const.sn.autowc.enabled", H(ie, gi));
  const { text: r } = e;
  if ("text" in e != "time" in e)
    throw "[autowc] textとtimeは同時指定必須です";
  if (H(ie, Or).setVal_Nochk("save", "const.sn.autowc.text", r), !r)
    return H(ie, Or).setVal_Nochk("save", "const.sn.autowc.time", ""), !1;
  const D = r.length;
  if (H(ie, gi) && D === 0)
    throw '[autowc] enabled === false かつ text === "" は許されません';
  const N = String(e.time).split(",");
  if (N.length !== D)
    throw "[autowc] text文字数とtimeに記述された待ち時間（コンマ区切り）は同数にして下さい";
  return ot(ie, Dn, {}), N.forEach((k, $) => H(ie, Dn)[r[$]] = uint(k)), H(ie, Or).setVal_Nochk("save", "const.sn.autowc.time", e.time), !1;
}, mi = new WeakMap(), mr = new WeakMap(), Ir = new WeakMap(), ge = new WeakMap(), Yr = new WeakMap(), le = new WeakMap(), el = new WeakMap(), Wr = new WeakMap(), dh = new WeakMap(), tr = new WeakMap(), An = new WeakSet(), Xa = function(e) {
  const { in_style: r } = e;
  if (!r)
    return;
  const D = TxtStage.getChInStyle(r);
  if (!D)
    throw `存在しないin_style【${r}】です`;
  ot(this, Nn, r), ot(this, ha, D.join);
}, Nn = new WeakMap(), ha = new WeakMap(), kn = new WeakSet(), Ya = function(e) {
  const { out_style: r } = e;
  if (!r)
    return;
  if (!TxtStage.getChOutStyle(r))
    throw `存在しないout_style【${r}】です`;
  ot(this, ca, r);
}, ca = new WeakMap(), rl = new WeakSet(), vf = function(e, r) {
  if ("back_clear" in e)
    return argChk_Boolean(e, "back_clear", !1) && (ot(this, mi, 0), ot(this, mr, 0), ot(this, Ir, !1), ot(this, Yr, "")), r(!1), !1;
  ot(this, mr, argChk_Num(e, "b_alpha", H(this, mr))), ot(this, Ir, argChk_Boolean(e, "b_alpha_isfixed", H(this, Ir)));
  const D = (H(this, Ir) ? 1 : Number(H(ie, Or).getVal("sys:TextLayer.Back.Alpha"))) * H(this, mr);
  if (e.b_pic) {
    if (H(this, Yr) !== e.b_pic)
      return ot(this, Yr, e.b_pic), H(this, ge) && (this.spLay.removeChild(H(this, ge)), H(this, ge).destroy()), GrpLayer.csv2Sprites(H(this, Yr), this.spLay, (N) => {
        ot(this, ge, N), N.name = "back(pic)", N.visible = D > 0, N.alpha = D, H(this, le).setSize(N.width, N.height), this.spLay.setChildIndex(N, 0), r(!0);
      });
  } else
    "b_color" in e && (ot(this, mi, argChk_Color(e, "b_color", 0)), H(this, ge) && (this.spLay.removeChild(H(this, ge)), H(this, ge).destroy()), ot(this, Yr, ""), this.spLay.addChildAt(
      ot(this, ge, new Graphics()).beginFill(H(this, mi)).lineStyle(void 0).drawRect(0, 0, H(this, le).getWidth, H(this, le).getHeight).endFill(),
      0
    ), H(this, ge).name = "back(color)");
  return H(this, ge) && (H(this, ge).visible = D > 0, H(this, ge).alpha = D), r(!1), !1;
}, il = new WeakSet(), gf = function(e) {
  "noffs" in e && (ot(this, fa, e.noffs ?? ""), ot(this, nl, new RegExp(`[　${H(this, fa)}]`))), "ffs" in e && (H(this, Ln) ?? ot(this, Ln, ""), ot(this, Bn, H(this, Ln) === "" ? () => "" : (r) => H(this, nl).test(r) ? "" : ` font-feature-settings: ${H(this, Ln)};`));
}, Ln = new WeakMap(), Bn = new WeakMap(), fa = new WeakMap(), nl = new WeakMap(), da = new WeakMap(), Hi = new WeakMap(), er = new WeakMap(), ph = new WeakSet(), _d = function(e, r, D, N = "") {
  if (!D)
    return ` style='${N}'`;
  const k = e.length * 2;
  if (k - r.length < 0)
    return ` style='text-align: ${D}; ${N}'`;
  let $ = "";
  switch (D) {
    case "left":
      $ = "ruby-align: start;";
      break;
    case "center":
      $ = "ruby-align: center;";
      break;
    case "right":
      $ = "ruby-align: start;";
      break;
    case "justify":
      $ = "ruby-align: space-between;";
      break;
    case "121":
      $ = "ruby-align: space-around;";
      break;
    case "even":
      const G = (k - r.length) / (r.length + 1);
      $ = "ruby-align: space-between; " + (H(this, le).tategaki ? `padding-top: ${G}em; padding-bottom: ${G}em;` : `padding-left: ${G}em; padding-right: ${G}em;`);
      break;
    case "1ruby":
      $ = "ruby-align: space-between; " + (H(this, le).tategaki ? "padding-top: 1em; padding-bottom: 1em;" : "padding-left: 1em; padding-right: 1em;");
      break;
    default:
      $ = `text-align: ${D};`;
  }
  return ` style='${$} ${N}'`;
}, ur = new WeakMap(), sl = new WeakMap(), pa = new WeakSet(), vu = function(e, r, D) {
  var U;
  const N = e === " " ? "&nbsp;" : e;
  H(ie, Or).doRecLog() && (ot(this, Fn, H(this, Fn) + (N + (r ? `《${r}》` : ""))), e !== " " && ot(this, $n, H(this, $n) + e));
  const { cl: k, sty: $, lnk: G } = lt(this, _i, sn).call(this, !0, null, e);
  return r ? `<span${k} style='${$} ${H(this, Bn).call(this, e)}'><ruby>${// 文字個別に出現させるため以下にも ${cl} が必要
  Array.from(e).map((z, X) => `<span${k}${G} style='${X > 0 ? lt(this, _i, sn).call(this, !0, null, e).sty : $} display: inline;'>${z === " " ? "&nbsp;" : z}</span>`).join("")}<rt${G}${this.mkStyle_r_align(
    e,
    r,
    D,
    H(this, Wr).style.cssText + (((U = H(this, yr).at(-1)) == null ? void 0 : U.o.r_style) ?? "")
  )}>${r}</rt></ruby></span>` : `<span${k} style='${$} ${H(this, Bn).call(this, e)}'${G}>${N}</span>`;
}, _i = new WeakSet(), sn = function(e, r, D = `
`) {
  var $, G, U;
  const N = H(this, ha) ? r ?? (($ = H(this, yr).at(0)) == null ? void 0 : $.o.wait) ?? (H(ie, gi) ? H(ie, Dn)[D.at(0) ?? ""] ?? 0 : LayerMng.msecChWait) : 0;
  H(ie, In).isSkippingByKeyDown() ? ot(this, qr, 0) : e && H(this, ha) && ot(this, qr, H(this, qr) + Number(N));
  const k = `data-add='{"ch_in_style":"${H(this, Nn)}", "ch_out_style":"${H(this, ca)}"}'`;
  return {
    cl: ` class='sn_ch${N > 0 ? ` sn_ch_in_${H(this, Nn)}` : ""}'`,
    // TxtStage.goTxt()はこれ単位で文字出現させる
    sty: `animation-delay: ${H(this, qr)}ms;${((G = H(this, yr).at(-1)) == null ? void 0 : G.o.style) ?? ""}`,
    // TxtStage.goTxt()はこれ単位で文字出現させる
    lnk: (((U = H(this, yr).at(0)) == null ? void 0 : U.o[":link"]) ?? "") + " " + k,
    curpos: k
  };
}, qr = new WeakMap(), Dr = new WeakMap(), _r = new WeakMap(), yr = new WeakMap(), al = new WeakSet(), mf = function(e) {
  H(this, yr).push({
    o: e,
    r_align: H(this, er),
    ch_in_style: H(this, Nn),
    ch_out_style: H(this, ca)
  }), "r_align" in e && ot(this, er, e.r_align), lt(this, An, Xa).call(this, e), lt(this, kn, Ya).call(this, e);
}, va = new WeakSet(), gu = function() {
  const e = H(this, yr).pop();
  e && (ot(this, er, e.r_align), lt(this, An, Xa).call(this, { in_style: e.ch_in_style }), lt(this, kn, Ya).call(this, { out_style: e.ch_out_style }));
}, ol = new WeakSet(), _f = function(e) {
  const r = H(this, yr).at(-1);
  if (!r) {
    lt(this, al, mf).call(this, e);
    return;
  }
  r.o = { ...r.o, ...e }, !e.style && !e.r_style && (r.o.style = "", r.o.r_style = ""), "r_align" in e && ot(this, er, e.r_align), lt(this, An, Xa).call(this, e), lt(this, kn, Ya).call(this, e);
}, Fn = new WeakMap(), $n = new WeakMap(), // 文字出現演出
rt(TxtLayer, Zo), // 文字消去演出
rt(TxtLayer, Jo), rt(TxtLayer, fh), rt(TxtLayer, la, void 0), rt(TxtLayer, Or, void 0), rt(TxtLayer, Ko, void 0), rt(TxtLayer, ua, void 0), rt(TxtLayer, Qo, void 0), rt(TxtLayer, In, void 0), rt(TxtLayer, tl, void 0), // 文字ごとのウェイト
rt(TxtLayer, gi, !1), rt(TxtLayer, Dn, {}), // cssチェック・保存用
rt(TxtLayer, dh, {
  "text-align": 0,
  "text-align-last": 0,
  height: 0,
  width: 0,
  "padding-left": 0,
  "padding-right": 0,
  "padding-top": 0,
  "padding-bottom": 0
}), rt(TxtLayer, da, (e) => e);
var ga, Gn, vh, yd, ma, ya, mu, gh, bd, mh, xd, ll, _h, Sd, yh, Ed;
class FrameMng {
  constructor(t, e, r, D, N, k, $) {
    //	HTMLフレーム
    // フレーム追加
    rt(this, vh);
    rt(this, ya);
    // フレーム変数を取得
    rt(this, gh);
    // フレーム変数に設定
    rt(this, mh);
    rt(this, _h);
    // フレームをトゥイーン開始
    rt(this, yh);
    rt(this, ga, void 0);
    rt(this, Gn, /* @__PURE__ */ Object.create(null));
    rt(this, ma, {});
    // フレームに設定
    rt(this, ll, 1);
    this.cfg = t, this.appPixi = r, this.val = D, this.main = N, this.sys = k, this.hTwInf = $, e.add_frame = (G) => lt(this, vh, yd).call(this, G), e.let_frame = (G) => lt(this, gh, bd).call(this, G), e.set_frame = (G) => lt(this, mh, xd).call(this, G), e.frame = (G) => lt(this, _h, Sd).call(this, G), e.tsy_frame = (G) => lt(this, yh, Ed).call(this, G);
  }
  setEvtMng(t) {
    ot(this, ga, t);
  }
  destroy() {
    for (const t of Object.values(H(this, Gn)))
      t.parentElement.removeChild(t);
    ot(this, Gn, /* @__PURE__ */ Object.create(null));
  }
  getFrmDisabled(t) {
    return H(this, ma)[t];
  }
  cvsResize() {
    for (const [t, e] of Object.entries(H(this, Gn))) {
      const r = "const.sn.frm." + t, D = Number(this.val.getVal(r + ".x")), N = Number(this.val.getVal(r + ".y")), k = Number(this.val.getVal(r + ".width")), $ = Number(this.val.getVal(r + ".height"));
      e.style.left = `${this.sys.ofsLeft4elm + D * this.sys.cvsScale}px`, e.style.top = `${this.sys.ofsTop4elm + N * this.sys.cvsScale}px`, e.width = String(k * this.sys.cvsScale), e.height = String($ * this.sys.cvsScale);
    }
  }
}
ga = new WeakMap(), Gn = new WeakMap(), vh = new WeakSet(), yd = function(t) {
  const { id: e, src: r, alpha: D = 1, scale_x: N = 1, scale_y: k = 1, rotate: $ = 0 } = t;
  if (!e)
    throw "idは必須です";
  if (!r)
    throw "srcは必須です";
  const G = "const.sn.frm." + e;
  if (this.val.getVal(`tmp:${G}`))
    throw `frame【${e}】はすでにあります`;
  const U = argChk_Boolean(t, "visible", !0), z = t.b_color ? ` background-color: ${t.b_color};` : "", X = lt(this, ya, mu).call(this, t);
  Main.cvs.insertAdjacentHTML("beforebegin", `<iframe id="${e}" sandbox="allow-scripts allow-same-origin" style="opacity: ${D}; position: absolute; left:${this.sys.ofsLeft4elm + X.x * this.sys.cvsScale}px; top: ${this.sys.ofsTop4elm + X.y * this.sys.cvsScale}px; z-index: 1; ${z} border: 0px; overflow: hidden; display: ${U ? "inline" : "none"}; transform: scale(${N}, ${k}) rotate(${$}deg);" width="${X.width * this.sys.cvsScale}" height="${X.height * this.sys.cvsScale}"></iframe>`);
  const V = this.cfg.searchPath(r, SEARCH_PATH_ARG_EXT.HTML), Y = new Loader().add({ name: r, url: V, xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT });
  return this.sys.crypto && Y.use((W, q) => {
    try {
      W.data = this.sys.decStr(W.extension, W.data);
    } catch (K) {
      this.main.errScript(`[add_frame]Html ロード失敗です src:${W.name} ${K}`, !1);
    }
    q == null || q();
  }), Y.load((W, q) => {
    var Z;
    const K = document.getElementById(e);
    H(this, Gn)[e] = K, H(this, ma)[e] = !1, K.srcdoc = String((Z = q[r]) == null ? void 0 : Z.data).replace("sn_repRes();", "").replaceAll(
      /\s(?:src|href)=(["'])(\S+)\1/g,
      (J, Q, et) => et.slice(0, 3) === "../" ? this.sys.cur + et.slice(4) : J.replace(Q, Q + V.slice(0, V.lastIndexOf("/") + 1))
    ), K.onload = () => {
      var Q;
      this.val.setVal_Nochk("tmp", G, !0), this.val.setVal_Nochk("tmp", G + ".alpha", D), this.val.setVal_Nochk("tmp", G + ".x", X.x), this.val.setVal_Nochk("tmp", G + ".y", X.y), this.val.setVal_Nochk("tmp", G + ".scale_x", N), this.val.setVal_Nochk("tmp", G + ".scale_y", k), this.val.setVal_Nochk("tmp", G + ".rotate", $), this.val.setVal_Nochk("tmp", G + ".width", X.width), this.val.setVal_Nochk("tmp", G + ".height", X.height), this.val.setVal_Nochk("tmp", G + ".visible", U);
      const J = K.contentWindow;
      H(this, ga).resvFlameEvent(J), (Q = J.sn_repRes) == null || Q.call(J, (et) => GrpLayer.loadPic2Img(et.dataset.src ?? "", et)), this.main.resume();
    };
  }), !0;
}, ma = new WeakMap(), ya = new WeakSet(), mu = function(t) {
  const e = { ...t }, r = this.sys.resolution;
  return new DOMRect(
    argChk_Num(e, "x", 0) * r,
    argChk_Num(e, "y", 0) * r,
    argChk_Num(e, "width", CmnLib.stageW) * r,
    argChk_Num(e, "height", CmnLib.stageH) * r
  );
}, gh = new WeakSet(), bd = function(t) {
  const { id: e, var_name: r } = t;
  if (!e)
    throw "idは必須です";
  const D = document.getElementById(e);
  if (!D)
    throw `id【${e}】はフレームではありません`;
  const N = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${N}`))
    throw `frame【${e}】が読み込まれていません`;
  if (!r)
    throw "var_nameは必須です";
  const k = D.contentWindow;
  if (!k.hasOwnProperty(r))
    throw `frame【${e}】に変数/関数【${r}】がありません。変数は var付きにして下さい`;
  const $ = k[r];
  return this.val.setVal_Nochk(
    "tmp",
    N + "." + r,
    argChk_Boolean(t, "function", !1) ? $() : $
  ), !1;
}, mh = new WeakSet(), xd = function(t) {
  const { id: e, var_name: r, text: D } = t;
  if (!e)
    throw "idは必須です";
  const N = document.getElementById(e);
  if (!N)
    throw `id【${e}】はフレームではありません`;
  const k = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${k}`))
    throw `frame【${e}】が読み込まれていません`;
  if (!r)
    throw "var_nameは必須です";
  if (!D)
    throw "textは必須です";
  this.val.setVal_Nochk("tmp", k + "." + r, D);
  const $ = N.contentWindow;
  return $[r] = D, !1;
}, ll = new WeakMap(), _h = new WeakSet(), Sd = function(t) {
  const { id: e } = t;
  if (!e)
    throw "idは必須です";
  const r = document.getElementById(e);
  if (!r)
    throw `id【${e}】はフレームではありません`;
  const D = "const.sn.frm." + e;
  if (!this.val.getVal("tmp:" + D))
    throw `frame【${e}】が読み込まれていません`;
  const N = r.style;
  if (argChk_Boolean(t, "float", !1) ? N.zIndex = `${++Ie(this, ll)._}` : "index" in t ? N.zIndex = `${argChk_Num(t, "index", 0)}` : t.dive && (N.zIndex = `-${++Ie(this, ll)._}`), "alpha" in t) {
    const $ = N.opacity = String(t.alpha);
    this.val.setVal_Nochk("tmp", D + ".alpha", $);
  }
  const k = lt(this, ya, mu).call(this, t);
  if (("x" in t || "y" in t) && (N.left = `${this.sys.ofsLeft4elm + k.x * this.sys.cvsScale}px`, N.top = `${this.sys.ofsTop4elm + k.y * this.sys.cvsScale}px`, this.val.setVal_Nochk("tmp", D + ".x", k.x), this.val.setVal_Nochk("tmp", D + ".y", k.y)), "scale_x" in t || "scale_y" in t || "rotate" in t) {
    const $ = argChk_Num(t, "scale_x", 1), G = argChk_Num(t, "scale_y", 1), U = argChk_Num(t, "rotate", 0);
    N.transform = `scale(${$}, ${G}) rotate(${U}deg)`, this.val.setVal_Nochk("tmp", D + ".scale_x", $), this.val.setVal_Nochk("tmp", D + ".scale_y", G), this.val.setVal_Nochk("tmp", D + ".rotate", U);
  }
  if ("width" in t && (r.width = String(k.width * this.sys.cvsScale), this.val.setVal_Nochk("tmp", D + ".width", k.width)), "height" in t && (r.height = String(k.height * this.sys.cvsScale), this.val.setVal_Nochk("tmp", D + ".height", k.height)), "visible" in t) {
    const $ = argChk_Boolean(t, "visible", !0);
    N.display = $ ? "inline" : "none", this.val.setVal_Nochk("tmp", D + ".visible", $);
  }
  if ("b_color" in t && (N.backgroundColor = t.b_color), "disabled" in t) {
    const $ = H(this, ma)[e] = argChk_Boolean(t, "disabled", !0);
    r.contentDocument.body.querySelectorAll("input,select").forEach((U) => U.disabled = $);
  }
  return !1;
}, yh = new WeakSet(), Ed = function(t) {
  const { id: e, alpha: r, x: D, y: N, scale_x: k, scale_y: $, rotate: G, width: U, height: z, ease: X, path: V, chain: Y } = t;
  if (!e)
    throw "idは必須です";
  const W = document.getElementById(e);
  if (!W)
    throw `id【${e}】はフレームではありません`;
  const q = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${q}`, 0))
    throw `frame【${e}】が読み込まれていません`;
  const K = {};
  r && (K.a = W.style.opacity), (D || N || k || $ || G) && (K.x = Number(this.val.getVal(`tmp:${q}.x`)), K.y = Number(this.val.getVal(`tmp:${q}.y`)), K.sx = Number(this.val.getVal(`tmp:${q}.scale_x`)), K.sy = Number(this.val.getVal(`tmp:${q}.scale_y`)), K.r = Number(this.val.getVal(`tmp:${q}.rotate`))), U && (K.w = this.val.getVal(`tmp:${q}.width`)), z && (K.h = this.val.getVal(`tmp:${q}.height`));
  const Z = cnvTweenArg(t, K), J = {};
  let Q = () => {
  };
  r && (J.a = argChk_Num(Z, "alpha", 0), Q = () => {
    W.style.opacity = K.a, this.val.setVal_Nochk("tmp", "alpha", K.a);
  });
  let et = () => {
  };
  const it = lt(this, ya, mu).call(this, Z);
  (D || N || k || $ || G) && (J.x = it.x, J.y = it.y, J.sx = argChk_Num(Z, "scale_x", 1), J.sy = argChk_Num(Z, "scale_y", 1), J.r = argChk_Num(Z, "rotate", 0), et = () => {
    W.style.left = this.sys.ofsLeft4elm + K.x * this.sys.cvsScale + "px", W.style.top = this.sys.ofsTop4elm + K.y * this.sys.cvsScale + "px", W.style.transform = `scale(${K.sx}, ${K.sy}) rotate(${K.r}deg)`, this.val.setVal_Nochk("tmp", q + ".x", K.x), this.val.setVal_Nochk("tmp", q + ".y", K.y), this.val.setVal_Nochk("tmp", q + ".scale_x", K.sx), this.val.setVal_Nochk("tmp", q + ".scale_y", K.sy), this.val.setVal_Nochk("tmp", q + ".rotate", K.r);
  });
  let tt = () => {
  };
  U && (J.w = it.width, tt = () => {
    W.width = K.w * this.sys.cvsScale + "px", this.val.setVal_Nochk("tmp", q + ".width", K.w);
  });
  let nt = () => {
  };
  z && (J.h = it.height, nt = () => {
    W.height = K.h * this.sys.cvsScale + "px", this.val.setVal_Nochk("tmp", q + ".height", K.h);
  }), this.appPixi.stage.interactive = !1;
  const st = `frm
${e}`, at = () => {
    var St, gt;
    this.appPixi.stage.interactive = !0;
    const Pt = this.hTwInf[st];
    Pt && (delete this.hTwInf[st], (St = Pt.tw) == null || St.stop(), Pt.resume && this.main.resume(), (gt = Pt.onEnd) == null || gt.call(Pt));
  }, ut = argChk_Num(t, "time", NaN) * (this.val.getVal("tmp:sn.skip.enabled") || H(this, ga).isSkippingByKeyDown() ? 0 : 1), ht = CmnTween.ease(X), dt = argChk_Num(t, "repeat", 1), pt = dt === 0 ? 1 / 0 : dt - 1, _t = argChk_Boolean(t, "yoyo", !1), mt = argChk_Num(t, "delay", 0), yt = new Tween(K).to(J, ut).easing(ht).repeat(pt).yoyo(_t).delay(mt).onUpdate(() => {
    Q(), et(), tt(), nt();
  });
  let Tt = yt;
  if (V) {
    CmnLib.debugLog && console.group(`🍝 [tsy_frame] path=${V}= start(${K.x},${K.y},${K.alpha})`);
    for (const { groups: Pt } of V.matchAll(LayerMng.REG_TSY_PATH)) {
      const { x: St, x2: gt, y: bt, y2: At, o: Rt, o2: Nt, json: Mt } = Pt;
      let ft = {};
      if (Mt)
        try {
          ft = JSON.parse(Mt);
        } catch (Vt) {
          console.error(`🍝 json=${Mt} ` + Vt);
          continue;
        }
      else
        (St ?? gt) && (ft.x = St ?? gt), (bt ?? At) && (ft.y = bt ?? At), (Rt ?? Nt) && (ft.alpha = Rt ?? Nt);
      const Ft = cnvTweenArg(ft, K);
      CmnLib.debugLog && console.info(`🍝 {x:${St} y:${bt} o:${Rt}} => hTo:${JSON.stringify(Ft)}`);
      const Dt = new Tween(K).to(Ft, ut).easing(ht).repeat(pt).yoyo(_t);
      Tt.chain(Dt), Tt = Dt;
    }
    CmnLib.debugLog && console.groupEnd();
  }
  if (Tt.onComplete(at), Y) {
    const Pt = this.hTwInf[Y ?? ""];
    if (!Pt || !Pt.tw)
      throw `${Y}は存在しない・または終了したトゥイーンです`;
    delete Pt.onEnd, Pt.tw.chain(yt);
  } else
    yt.start();
  return this.hTwInf[st] = { tw: Tt, resume: !1 }, !1;
};
var br, ue, we, Vi, Un, ba, ul, hl, cl, xa, fl, yf, Xi, Ar, bh, Td, rr, xh, wd, Sh, Cd, Eh, Pd, ae, Kr, Zr, dl, Th, Md, Sa, _u, wh, Rd, Ch, pl, Ph, jn, zn, yi, Ae, Hn, Mh, Od, Ne, Ke, sr, Rh, Id, Oh, Dd, Ih, Ad, Vn, Wa, Dh, Nd, hr, Ah, kd, Nh, Ld, kh, Bd, Lh, Fd, Bh, $d, Yi, Xn, qa, cr, Fh, Gd, vl, $h, Ud, Jr, Yn, Wi, Ts, Nr, Qr, Gh, jd, Uh, zd, jh, Hd, zh, Vd, Hh, Xd, Vh, Yd, Xh, Wd, gl, bf, Yh, qd, Wh, Kd, qh, Zd, Kh, Jd, Zh, Qd, Jh, tp, Qh, ep;
const Ai = class {
  constructor(t, e, r, D, N, k, $, G, U, z) {
    rt(this, fl);
    // 既存の全文字レイヤの実際のバック不透明度、を再計算
    rt(this, bh);
    //	//	システム
    // スナップショット
    rt(this, xh);
    // プラグインの読み込み
    rt(this, Sh);
    //	//	レイヤ共通
    // レイヤを追加する
    rt(this, Eh);
    rt(this, Th);
    rt(this, Sa);
    // レイヤ設定の消去
    rt(this, wh);
    // ページ裏表を交換
    rt(this, Mh);
    rt(this, Ke);
    rt(this, Rh);
    rt(this, Oh);
    // トランス終了待ち
    rt(this, Ih);
    // レイヤのトランジションの停止
    rt(this, Vn);
    // 画面を揺らす
    rt(this, Dh);
    rt(this, Ah);
    // トゥイーン終了待ち
    rt(this, Nh);
    // トゥイーン中断
    rt(this, kh);
    // 一時停止
    rt(this, Lh);
    // 一時停止再開
    rt(this, Bh);
    // 文字を追加する
    rt(this, Xn);
    rt(this, Fh);
    rt(this, $h);
    rt(this, Wi);
    rt(this, Gh);
    // ハイパーリンクの終了
    rt(this, Uh);
    // ページ両面の文字消去
    rt(this, jh);
    // インライン画像表示
    rt(this, zh);
    // ハイパーリンク
    rt(this, Hh);
    // 改行
    rt(this, Vh);
    // 履歴改行
    rt(this, Xh);
    // 履歴書き込み
    rt(this, gl);
    // 履歴リセット
    rt(this, Yh);
    // 文字列と複数ルビの追加
    rt(this, Wh);
    // インラインスタイル設定
    rt(this, qh);
    // tcy縦中横を表示する
    rt(this, Kh);
    // レイヤのダンプ
    rt(this, Zh);
    // イベント有無の切替
    rt(this, Jh);
    // ボタンを表示
    rt(this, Qh);
    rt(this, br, void 0);
    rt(this, ue, new Container());
    rt(this, we, new Container());
    rt(this, Vi, void 0);
    rt(this, Un, void 0);
    rt(this, ba, new EventListenerCtn());
    rt(this, ul, () => update());
    rt(this, hl, {
      attach: (t) => (DesignCast.leaveMode(), !1),
      continue: (t) => (DesignCast.leaveMode(), !1),
      disconnect: (t) => (DesignCast.leaveMode(), !1),
      _enterDesign: (t) => {
        DesignCast.enterMode();
        for (const e of H(this, Kr)) {
          const r = H(this, ae)[e].fore;
          r.makeDesignCastChildren((D) => D.make()), r.makeDesignCast((D) => D.make());
        }
        return lt(this, fl, yf).call(this, H(this, Zr)), !1;
      },
      _replaceToken: (t, e) => (DesignCast.replaceToken(e), !1),
      _selectNode: (t, e) => (lt(this, fl, yf).call(this, e.node), !1)
    });
    rt(this, cl, "");
    rt(this, xa, "");
    It(this, "getFrmDisabled", (t) => H(this, Vi).getFrmDisabled(t));
    rt(this, Xi, void 0);
    rt(this, Ar, void 0);
    rt(this, rr, (t, e = this.currentTxtlayForeNeedErr, r = !0) => e.tagCh("｜　《" + t + "》"));
    It(this, "goTxt", () => {
    });
    It(this, "breakLine", () => {
    });
    It(this, "breakPage", () => {
    });
    rt(this, ae, {});
    // しおりLoad時再読込
    rt(this, Kr, []);
    // 最適化用
    rt(this, Zr, "");
    rt(this, dl, "");
    rt(this, Ch, `
precision mediump float;

varying vec2 vTextureCoord;
uniform sampler2D uSampler;

uniform sampler2D rule;
uniform float vague;
uniform float tick;

uniform vec4 inputPixel;
uniform highp vec4 outputFrame;
vec2 getUV(vec2 coord) {
	return coord * inputPixel.xy / outputFrame.zw;
}

void main(void) {
	vec4 fg = texture2D(uSampler, vTextureCoord);
	vec4 ru = texture2D(rule, getUV(vTextureCoord));

	float v = ru.r - tick;
	if (abs(v) < vague) {
		float f_a = fg.a *(0.5 +v /vague *0.5);

		gl_FragColor.rgb = fg.rgb *f_a;
		gl_FragColor.a = f_a;
	}
	else {
		gl_FragColor = (v >= 0.0)? fg : vec4(0);
	}
}`);
    rt(this, pl, {
      rule: Texture.EMPTY,
      vague: 0,
      tick: 0
    });
    rt(this, Ph, new Filter(void 0, H(this, Ch), H(this, pl)));
    rt(this, jn, RenderTexture.create({
      width: CmnLib.stageW,
      height: CmnLib.stageH
    }));
    rt(this, zn, new Sprite(H(this, jn)));
    rt(this, yi, RenderTexture.create({
      width: CmnLib.stageW,
      height: CmnLib.stageH
    }));
    rt(this, Ae, new Sprite(H(this, yi)));
    rt(this, Hn, []);
    rt(this, Ne, { tw: void 0, resume: !1 });
    // トゥイーン開始
    rt(this, hr, {});
    rt(this, cr, (t) => {
      throw H(this, Yn).call(this), 0;
    });
    // 操作対象のメッセージレイヤの指定
    rt(this, vl, (t) => {
      throw H(this, Yn).call(this), 0;
    });
    rt(this, Jr, void 0);
    // カレントテキストレイヤ
    rt(this, Yn, () => {
      throw "文字レイヤーがありません。文字表示や操作する前に、[add_lay layer=（レイヤ名） class=txt]で文字レイヤを追加して下さい";
    });
    rt(this, Nr, "");
    rt(this, Qr, []);
    this.cfg = t, this.hTag = e, this.appPixi = r, this.val = D, this.main = N, this.scrItr = k, this.sys = $, this.sndMng = G, this.alzTagArg = U, this.prpPrs = z;
    const X = () => {
      if ($.cvsResize(), this.cvsResizeDesign(), H(this, xa))
        for (const q of H(this, Kr))
          H(this, ae)[q].fore.cvsResizeChildren();
      else
        for (const q of H(this, Kr))
          H(this, ae)[q].fore.cvsResize();
      H(this, Vi).cvsResize(), H(this, Ar).cvsResize();
    };
    if (CmnLib.isMobile)
      H(this, ba).add(globalThis, "orientationchange", X, { passive: !0 });
    else {
      let q;
      H(this, ba).add(globalThis, "resize", () => {
        q || (q = setTimeout(() => {
          q = void 0, X();
        }, 1e3 / 60 * 10));
      }, { passive: !0 });
    }
    $.cvsResize(), TxtLayer.init(t, e, D, this, (q) => H(this, ae)[q.layname].fore === q, r), GrpLayer.init(N, t, r, $, G, D), Button.init(t), ot(this, Vi, new FrameMng(t, e, r, D, N, $, H(this, hr))), $.hFactoryCls.grp = () => new GrpLayer(), $.hFactoryCls.txt = () => new TxtLayer(), e.loadplugin = (q) => lt(this, Sh, Cd).call(this, q), e.snapshot = (q) => lt(this, xh, wd).call(this, q), e.add_lay = (q) => lt(this, Eh, Pd).call(this, q), e.clear_lay = (q) => lt(this, wh, Rd).call(this, q), e.finish_trans = () => lt(this, Vn, Wa).call(this), e.lay = (q) => lt(this, Th, Md).call(this, q), e.trans = (q) => lt(this, Mh, Od).call(this, q), e.wt = (q) => lt(this, Ih, Ad).call(this, q), e.quake = (q) => lt(this, Dh, Nd).call(this, q), e.stop_quake = (q) => e.finish_trans(q), e.wq = (q) => e.wt(q), e.pause_tsy = (q) => lt(this, Lh, Fd).call(this, q), e.resume_tsy = (q) => lt(this, Bh, $d).call(this, q), e.stop_tsy = (q) => lt(this, kh, Bd).call(this, q), e.tsy = (q) => lt(this, Ah, kd).call(this, q), e.wait_tsy = (q) => lt(this, Nh, Ld).call(this, q), e.ch = (q) => lt(this, Xn, qa).call(this, q), e.clear_text = (q) => lt(this, Gh, jd).call(this, q), e.current = (q) => H(this, vl).call(this, q), e.endlink = (q) => lt(this, Uh, zd).call(this, q), e.er = (q) => lt(this, jh, Hd).call(this, q), e.graph = (q) => lt(this, zh, Vd).call(this, q), e.link = (q) => lt(this, Hh, Xd).call(this, q), e.r = (q) => lt(this, Vh, Yd).call(this, q), e.rec_ch = (q) => lt(this, gl, bf).call(this, q), e.rec_r = (q) => lt(this, Xh, Wd).call(this, q), e.reset_rec = (q) => lt(this, Yh, qd).call(this, q), e.ruby2 = (q) => lt(this, Wh, Kd).call(this, q), e.span = (q) => lt(this, qh, Zd).call(this, q), e.tcy = (q) => lt(this, Kh, Jd).call(this, q), e.add_face = (q) => GrpLayer.add_face(q), e.wv = (q) => GrpLayer.wv(q), e.dump_lay = (q) => lt(this, Zh, Qd).call(this, q), e.enable_event = (q) => lt(this, Jh, tp).call(this, q), e.button = (q) => lt(this, Qh, ep).call(this, q), t.existsBreakline && (this.breakLine = () => H(this, rr).call(this, 'grp｜{"id":"break","pic":"breakline"}')), t.existsBreakpage && (this.breakPage = () => H(this, rr).call(this, 'grp｜{"id":"break","pic":"breakpage"}')), ot(this, Un, parseColor(String(t.oCfg.init.bg_color)));
    const V = new Graphics();
    V.beginFill(H(this, Un), 1).lineStyle(0, H(this, Un)).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill(), H(this, ue).addChild(V.clone()), H(this, we).addChild(V), H(this, we).visible = !1, H(this, ue).name = "page:A", H(this, we).name = "page:B", ot(this, br, r.stage), H(this, br).addChild(H(this, we)), H(this, br).addChild(H(this, ue)), H(this, br).addChild(H(this, zn)), H(this, br).addChild(H(this, Ae)), H(this, br).name = "stage", r.ticker.add(H(this, ul));
    const Y = (q, K) => {
      lt(this, bh, Td).call(this, Number(K));
    };
    Y("", D.getVal("sys:TextLayer.Back.Alpha", 1)), D.defValTrg("sys:TextLayer.Back.Alpha", Y);
    const W = (q, K) => Button.fontFamily = K;
    W("", D.getVal("tmp:sn.button.fontFamily", Button.fontFamily)), D.defValTrg("tmp:sn.button.fontFamily", W), D.defTmp("const.sn.log.json", () => JSON.stringify(
      H(this, Nr) ? [...H(this, Qr), { text: H(this, Nr).replaceAll("</span><span class='sn_ch'>", "") }] : H(this, Qr)
    )), D.defTmp("const.sn.last_page_text", () => {
      var q;
      return ((q = this.currentTxtlayFore) == null ? void 0 : q.pageText) ?? "";
    }), D.defTmp("const.sn.last_page_plain_text", () => {
      var q;
      return ((q = this.currentTxtlayFore) == null ? void 0 : q.pagePlainText) ?? "";
    }), CmnLib.isDbg && (DesignCast.init(r, $, k, z, U, t, H(this, ae)), this.cvsResizeDesign = () => DesignCast.cvsResizeDesign(), $.addHook((q, K) => {
      var Z, J;
      (J = (Z = H(this, hl))[q]) != null && J.call(Z, q, K) && delete H(this, hl)[q];
    }));
  }
  cvsResizeDesign() {
  }
  cover(t, e = 0) {
    H(this, Xi) && (H(this, br).removeChild(H(this, Xi)), H(this, Xi).destroy(), ot(this, Xi, void 0)), t && H(this, br).addChild(
      ot(this, Xi, new Graphics()).beginFill(e).lineStyle(0, e).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill()
    );
  }
  setEvtMng(t) {
    ot(this, Ar, t), H(this, Vi).setEvtMng(t), GrpLayer.setEvtMng(t);
  }
  before_destroy() {
    for (const t of Object.values(H(this, ae)))
      t.destroy();
  }
  destroy() {
    H(this, ba).clear(), GrpLayer.destroy(), RubySpliter.destroy(), TxtStage.destroy(), TxtLayer.destroy(), H(this, Vi).destroy(), this.stopAllTw(), this.appPixi.ticker.remove(H(this, ul)), ot(Ai, Yi, 10);
  }
  // トゥイーン全停止
  stopAllTw() {
    ot(this, hr, {}), removeAll();
  }
  clearBreak() {
    this.currentTxtlayFore && (this.clearBreak = () => H(this, rr).call(this, "del｜break"), this.clearBreak());
  }
  clickTxtLay() {
    return this.currentTxtlayFore ? lt(this, Ke, sr).call(this).some((t) => {
      const e = H(this, ae)[t].fore;
      return e instanceof TxtLayer && e.click();
    }) : !1;
  }
  static get msecChWait() {
    return H(Ai, Yi);
  }
  static set msecChWait(t) {
    ot(Ai, Yi, t);
  }
  setNormalChWait() {
    ot(Ai, Yi, this.scrItr.normalWait);
  }
  get currentTxtlayForeNeedErr() {
    return H(this, Yn).call(this), this.currentTxtlayFore;
  }
  get currentTxtlayFore() {
    return H(this, Jr) ? H(this, Jr).fore : null;
  }
  recText(t) {
    ot(this, Nr, t), this.val.setVal_Nochk(
      "save",
      "const.sn.sLog",
      String(this.val.getVal("const.sn.log.json"))
      // これを起動したい
    );
  }
  recPagebreak() {
    if (!H(this, Nr))
      return;
    const t = H(this, Nr).replaceAll("</span><span class='sn_ch'>", "");
    H(this, Qr).push({ text: t }) > this.cfg.oCfg.log.max_len && ot(this, Qr, H(this, Qr).slice(-this.cfg.oCfg.log.max_len)), ot(this, Nr, "");
  }
  record() {
    const t = {};
    for (const e of H(this, Kr)) {
      const r = H(this, ae)[e];
      t[e] = {
        cls: r.cls,
        fore: r.fore.record(),
        back: r.back.record()
      };
    }
    return t;
  }
  playback(t, e) {
    var k;
    ot(this, Qr, JSON.parse(String(this.val.getVal("save:const.sn.sLog")))), ot(this, Nr, "");
    const r = [], D = [];
    for (const [$, { fore: G, fore: { idx: U }, back: z, cls: X }] of Object.entries(t)) {
      D.push({ layer: $, idx: U });
      const V = (k = H(this, ae))[$] ?? (k[$] = new Pages($, X, H(this, ue), H(this, we), {}, this.sys, this.val, { isWait: !1 }));
      V.fore.playback(G, r), V.back.playback(z, r);
    }
    const N = H(this, ue).children.length;
    Promise.allSettled(r).then(() => {
      for (const { layer: $, idx: G } of D.sort(({ idx: U }, { idx: z }) => U === z ? 0 : U < z ? -1 : 1)) {
        const { fore: U, back: z } = H(this, ae)[$];
        if (!U)
          return;
        const X = N > G ? G : N - 1;
        H(this, ue).setChildIndex(U.spLay, X), H(this, we).setChildIndex(z.spLay, X);
      }
      e();
    }).catch(($) => console.error("fn:LayerMng.ts playback e:%o", $));
  }
};
let LayerMng = Ai;
br = new WeakMap(), ue = new WeakMap(), we = new WeakMap(), Vi = new WeakMap(), Un = new WeakMap(), ba = new WeakMap(), ul = new WeakMap(), hl = new WeakMap(), cl = new WeakMap(), xa = new WeakMap(), fl = new WeakSet(), yf = function(t) {
  [Ie(this, cl)._, this.xa = ""] = t.split("/");
  const e = H(this, ae)[H(this, cl)];
  e && (DesignCast.allHide(), H(this, xa) ? e.fore.showDesignCastChildren() : e.fore.showDesignCast());
}, Xi = new WeakMap(), Ar = new WeakMap(), bh = new WeakSet(), Td = function(t) {
  for (const e of lt(this, Ke, sr).call(this)) {
    const r = H(this, ae)[e];
    r.fore instanceof TxtLayer && (r.fore.chgBackAlpha(t), r.back.chgBackAlpha(t));
  }
}, rr = new WeakMap(), xh = new WeakSet(), wd = function(t) {
  const e = t.fn ? t.fn.slice(0, 10) === "userdata:/" ? t.fn : `downloads:/${t.fn + getDateStr("-", "_", "", "_")}.png` : `downloads:/snapshot${getDateStr("-", "_", "", "_")}.png`, r = this.cfg.searchPath(e);
  if (!("layer" in t) && this.sys.canCapturePage(r, () => this.main.resume()))
    return !0;
  const D = getExt(r), N = argChk_Color(t, "b_color", H(this, Un)), k = autoDetectRenderer({
    width: argChk_Num(t, "width", CmnLib.stageW),
    height: argChk_Num(t, "height", CmnLib.stageH),
    backgroundAlpha: N > 16777216 && D === "png" ? 0 : 1,
    antialias: argChk_Boolean(t, "smoothing", !1),
    preserveDrawingBuffer: !0,
    backgroundColor: N & 16777215,
    autoDensity: !0
  }), $ = [], G = t.page !== "back" ? "fore" : "back";
  if (H(this, Ne).tw)
    $.push(new Promise((U) => {
      H(this, we).visible = !0;
      for (const z of H(this, Hn))
        k.render(z, { clear: !1 });
      H(this, we).visible = !1, H(this, zn).visible = !0, H(this, ue).filters = H(this, Ae).filters, H(this, ue).visible = !0, k.render(H(this, ue), { clear: !1 }), H(this, ue).visible = !1, H(this, ue).filters = [], U();
    }));
  else
    for (const U of lt(this, Ke, sr).call(this, t.layer))
      $.push(
        new Promise((z) => H(this, ae)[U][G].snapshot(k, () => z()))
      );
  return Promise.allSettled($).then(async () => {
    const U = RenderTexture.create({ width: k.width, height: k.height });
    if (k.render(H(this, br), { renderTexture: U }), await this.sys.savePic(
      r,
      k.plugins.extract.base64(Sprite.from(U))
    ), !H(this, Ne).tw)
      for (const z of lt(this, Ke, sr).call(this, t.layer))
        H(this, ae)[z][G].snapshot_end();
    k.destroy(!0), this.main.resume();
  }), !0;
}, Sh = new WeakSet(), Cd = function(t) {
  const { fn: e } = t;
  if (!e)
    throw "fnは必須です";
  const r = argChk_Boolean(t, "join", !0);
  switch (getExt(e)) {
    case "css":
      (async () => {
        const D = await fetch(e);
        if (!D.ok)
          throw new Error("Network response was not ok.");
        addStyle(await D.text()), r && this.main.resume();
      })();
      break;
    default:
      throw "サポートされない拡張子です";
  }
  return r;
}, Eh = new WeakSet(), Pd = function(t) {
  const { layer: e, class: r } = t;
  if (!e)
    throw "layerは必須です";
  if (e.includes(","))
    throw "layer名に「,」は使えません";
  if (e in H(this, ae))
    throw `layer【${e}】はすでにあります`;
  if (!r)
    throw "clsは必須です";
  const D = { isWait: !1 };
  switch (H(this, ae)[e] = new Pages(e, r, H(this, ue), H(this, we), t, this.sys, this.val, D), H(this, Kr).push(e), r) {
    case "txt":
      H(this, Zr) || (ot(this, Yn, () => {
      }), ot(this, cr, lt(this, Fh, Gd)), ot(this, vl, lt(this, $h, Ud)), this.hTag.current({ layer: e }), this.goTxt = () => {
        this.val.getVal("sn.skip.enabled") ? ot(Ai, Yi, 0) : this.setNormalChWait();
        for (const N of lt(this, Ke, sr).call(this)) {
          const k = H(this, ae)[N].fore;
          k instanceof TxtLayer && H(this, rr).call(this, "gotxt｜", k, !1);
        }
      }), this.val.setVal_Nochk(
        "save",
        "const.sn.layer." + (e ?? H(this, Zr)) + ".enabled",
        !0
      );
      break;
    case "grp":
      if (H(this, dl))
        break;
      ot(this, dl, e);
      break;
  }
  return this.scrItr.recodeDesign(t), D.isWait;
}, ae = new WeakMap(), Kr = new WeakMap(), Zr = new WeakMap(), dl = new WeakMap(), Th = new WeakSet(), Md = function(t) {
  const e = lt(this, Wi, Ts).call(this, t), r = H(this, ae)[e], D = r.back.spLay, N = r.fore.spLay;
  if (argChk_Boolean(t, "float", !1))
    H(this, we).setChildIndex(D, H(this, we).children.length - 1), H(this, ue).setChildIndex(N, H(this, ue).children.length - 1), lt(this, Sa, _u).call(this);
  else if (t.index)
    argChk_Num(t, "index", 0) && (H(this, we).setChildIndex(D, t.index), H(this, ue).setChildIndex(N, t.index), lt(this, Sa, _u).call(this));
  else if (t.dive) {
    const { dive: k } = t;
    let $ = 0;
    if (e === k)
      throw "[lay] 属性 layerとdiveが同じ【" + k + "】です";
    const G = H(this, ae)[k];
    if (!G)
      throw "[lay] 属性 dive【" + k + "】が不正です。レイヤーがありません";
    const U = G.back, z = G.fore, X = H(this, we).getChildIndex(U.spLay), V = H(this, ue).getChildIndex(z.spLay);
    $ = X < V ? X : V, $ > H(this, we).getChildIndex(D) && --$, H(this, ue).setChildIndex(N, $), H(this, we).setChildIndex(D, $), lt(this, Sa, _u).call(this);
  }
  return t[":id_tag"] = r.fore.name.slice(0, -7), this.scrItr.recodeDesign(t), r.lay(t);
}, Sa = new WeakSet(), _u = function() {
  ot(this, Kr, lt(this, Oh, Dd).call(this));
}, wh = new WeakSet(), Rd = function(t) {
  return lt(this, Rh, Id).call(this, t, (e) => {
    const r = H(this, ae)[lt(this, Wi, Ts).call(this, { layer: e })];
    t.page === "both" ? (r.fore.clearLay(t), r.back.clearLay(t)) : r.getPage(t).clearLay(t);
  }), !1;
}, Ch = new WeakMap(), pl = new WeakMap(), Ph = new WeakMap(), jn = new WeakMap(), zn = new WeakMap(), yi = new WeakMap(), Ae = new WeakMap(), Hn = new WeakMap(), Mh = new WeakSet(), Od = function(t) {
  lt(this, Vn, Wa).call(this), H(this, Ar).hideHint();
  const { layer: e } = t;
  ot(this, Hn, []);
  const r = {}, D = [];
  for (const K of lt(this, Ke, sr).call(this, e))
    r[K] = !0, D.push(H(this, ae)[K].fore);
  const N = [];
  for (const K of lt(this, Ke, sr).call(this)) {
    const Z = H(this, ae)[K][r[K] ? "back" : "fore"];
    H(this, Hn).push(Z.spLay), N.push(Z);
  }
  H(this, jn).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(H(this, we), { renderTexture: H(this, jn) });
  let k = () => {
    H(this, we).visible = !0;
    for (const K of H(this, Hn))
      this.appPixi.renderer.render(K, { renderTexture: H(this, jn), clear: !1 });
    H(this, we).visible = !1;
  };
  if (!N.some((K) => K.containMovement)) {
    let K = k;
    k = () => {
      k = () => {
      }, K();
    };
  }
  H(this, yi).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(H(this, ue), { renderTexture: H(this, yi) });
  let $ = () => {
    H(this, ue).visible = !0, this.appPixi.renderer.render(H(this, ue), { renderTexture: H(this, yi) }), H(this, ue).visible = !1;
  };
  if (!D.some((K) => K.containMovement)) {
    let K = $;
    $ = () => {
      $ = () => {
      }, K();
    };
  }
  const G = () => {
    k(), H(this, zn).visible = !0, $(), H(this, Ae).visible = !0;
  };
  H(this, Ae).alpha = 1;
  const U = () => {
    var Z;
    this.appPixi.ticker && this.appPixi.ticker.remove(G), [Ie(this, ue)._, Ie(this, we)._] = [H(this, we), H(this, ue)];
    const K = [];
    for (const [J, Q] of Object.entries(H(this, ae))) {
      if (r[J]) {
        Q.transPage(K);
        continue;
      }
      const { fore: { spLay: et }, back: { spLay: it } } = Q, tt = H(this, ue).getChildIndex(it);
      H(this, ue).removeChild(it), H(this, we).removeChild(et), H(this, ue).addChildAt(et, tt), H(this, we).addChildAt(it, tt);
    }
    Promise.allSettled(K), H(this, ue).visible = !0, H(this, we).visible = !1, H(this, zn).visible = !1, H(this, Ae).visible = !1, (Z = H(this, Ne).tw) == null || Z.stop(), H(this, Ne).resume && this.main.resume(), ot(this, Ne, { tw: void 0, resume: !1 });
  };
  ot(this, Ne, { tw: void 0, resume: !1 });
  const z = argChk_Num(t, "time", 0);
  if (z === 0 || H(this, Ar).isSkippingByKeyDown())
    return U(), !1;
  const { ease: X, glsl: V, rule: Y } = t, W = CmnTween.ease(X);
  if (!V && !Y)
    return H(this, Ae).filters = [], H(this, Ne).tw = new Tween(H(this, Ae)).to({ alpha: 0 }, z).delay(argChk_Num(t, "delay", 0)).easing(W).onComplete(U).start(), this.appPixi.ticker.add(G), !1;
  const q = V ? new Filter(void 0, V, H(this, pl)) : H(this, Ph);
  if (q.uniforms.vague = argChk_Num(t, "vague", 0.04), q.uniforms.tick = 0, H(this, Ne).tw = new Tween(q.uniforms).to({ tick: 1 }, z).delay(argChk_Num(t, "delay", 0)).easing(W).onComplete(U), H(this, Ae).filters = [q], V)
    return H(this, Ne).tw.start(), this.appPixi.ticker.add(G), !1;
  if (!Y)
    throw "ruleが指定されていません";
  return GrpLayer.csv2Sprites(Y, void 0, (K) => {
    var Z;
    q.uniforms.rule = K.texture, K.destroy(), (Z = H(this, Ne).tw) == null || Z.start(), this.appPixi.ticker.add(G);
  }), !1;
}, Ne = new WeakMap(), Ke = new WeakSet(), sr = function(t = "") {
  return t ? t.split(",") : H(this, Kr);
}, Rh = new WeakSet(), Id = function(t, e) {
  const r = lt(this, Ke, sr).call(this, t.layer);
  for (const D of r) {
    if (!D)
      continue;
    const N = H(this, ae)[D];
    if (!N)
      throw "存在しないlayer【" + D + "】です";
    e(D, N);
  }
  return r;
}, Oh = new WeakSet(), Dd = function(t = "") {
  return lt(this, Ke, sr).call(this, t).sort((e, r) => {
    const D = H(this, ue).getChildIndex(H(this, ae)[e].fore.spLay), N = H(this, ue).getChildIndex(H(this, ae)[r].fore.spLay);
    return D < N ? -1 : D > N ? 1 : 0;
  });
}, Ih = new WeakSet(), Ad = function(t) {
  return H(this, Ne).tw ? (H(this, Ne).resume = !0, H(this, Ar).waitLimitedEvent(t, () => lt(this, Vn, Wa).call(this))) : !1;
}, Vn = new WeakSet(), Wa = function() {
  var t;
  return (t = H(this, Ne).tw) == null || t.end(), !1;
}, Dh = new WeakSet(), Nd = function(t) {
  lt(this, Vn, Wa).call(this);
  const e = argChk_Num(t, "time", NaN);
  if (e === 0 || this.val.getVal("tmp:sn.skip.enabled") || H(this, Ar).isSkippingByKeyDown())
    return !1;
  const { layer: r, ease: D } = t, N = [];
  for (const Y of lt(this, Ke, sr).call(this, r))
    N.push(H(this, ae)[Y].fore.spLay);
  H(this, yi).resize(CmnLib.stageW, CmnLib.stageH);
  const k = () => {
    H(this, ue).visible = !0;
    for (const Y of N)
      this.appPixi.renderer.render(
        Y,
        { renderTexture: H(this, yi), clear: !1 }
      );
    H(this, ue).visible = !1;
  };
  H(this, Ae).visible = !0, H(this, Ae).alpha = 1;
  const $ = uint(argChk_Num(t, "hmax", 10)), G = uint(argChk_Num(t, "vmax", 10)), U = $ === 0 ? () => {
  } : () => H(this, Ae).x = Math.round(Math.random() * $ * 2) - $, z = G === 0 ? () => {
  } : () => H(this, Ae).y = Math.round(Math.random() * G * 2) - G;
  H(this, Ae).filters = [];
  const X = argChk_Num(t, "repeat", 1), V = new Tween(H(this, Ae)).to({ x: 0, y: 0 }, e).delay(argChk_Num(t, "delay", 0)).easing(CmnTween.ease(D)).onUpdate(() => {
    U(), z();
  }).repeat(X === 0 ? 1 / 0 : X - 1).yoyo(argChk_Boolean(t, "yoyo", !1)).onComplete(() => {
    var Y, W;
    (Y = this.appPixi.ticker) == null || Y.remove(k), H(this, ue).visible = !0, H(this, Ae).visible = !1, H(this, Ae).x = 0, H(this, Ae).y = 0, (W = H(this, Ne).tw) == null || W.stop(), H(this, Ne).resume && this.main.resume(), ot(this, Ne, { tw: void 0, resume: !1 });
  }).start();
  return ot(this, Ne, { tw: V, resume: !1 }), this.appPixi.ticker.add(k), !1;
}, hr = new WeakMap(), Ah = new WeakSet(), kd = function(t) {
  const { layer: e, render: r, path: D, name: N, ease: k, chain: $ } = t;
  if (!e)
    throw "layerは必須です";
  const G = lt(this, Wi, Ts).call(this, t);
  let U = H(this, ae)[G].fore, z = () => {
  };
  const X = H(this, Ar).isSkippingByKeyDown();
  !X && r && (U.renderStart(), z = () => U.renderEnd());
  const V = N ?? e, Y = () => {
    var ut, ht;
    const at = H(this, hr)[V];
    at && (z(), delete H(this, hr)[V], (ut = at.tw) == null || ut.stop(), at.resume && this.main.resume(), (ht = at.onEnd) == null || ht.call(at));
  }, W = cnvTweenArg(t, U), q = argChk_Num(t, "time", NaN) * (this.val.getVal("tmp:sn.skip.enabled") || X ? 0 : 1), K = CmnTween.ease(k), Z = argChk_Num(t, "repeat", 1), J = Z === 0 ? 1 / 0 : Z - 1, Q = argChk_Boolean(t, "yoyo", !1), et = argChk_Num(t, "delay", 0), it = new Tween(U).to(W, q).easing(K).repeat(J).yoyo(Q).delay(et);
  let tt = it;
  if (D) {
    CmnLib.debugLog && console.group(`🍝 [tsy] path=${D}= start(${U.x},${U.y},${U.alpha})`);
    for (const { groups: at } of D.matchAll(Ai.REG_TSY_PATH)) {
      const { x: ut, x2: ht, y: dt, y2: pt, o: _t, o2: mt, json: yt } = at;
      let Tt = {};
      if (yt)
        try {
          Tt = JSON.parse(yt);
        } catch (gt) {
          console.error(`🍝 json=${yt} ` + gt);
          continue;
        }
      else
        (ut ?? ht) && (Tt.x = ut ?? ht), (dt ?? pt) && (Tt.y = dt ?? pt), (_t ?? mt) && (Tt.alpha = _t ?? mt);
      const Pt = cnvTweenArg(Tt, U);
      CmnLib.debugLog && console.info(`🍝 ${yt ?? `{x:${ut} y:${dt} o:${_t}}`} => hTo:${JSON.stringify(Pt)}`);
      const St = new Tween(U).to(Pt, q).easing(K).repeat(J).yoyo(Q);
      tt.chain(St), tt = St;
    }
    CmnLib.debugLog && console.groupEnd();
  }
  if (tt.onComplete(Y), $) {
    const at = H(this, hr)[$ ?? ""];
    if (!(at != null && at.tw))
      throw `${$}は存在しない・または終了したトゥイーンです`;
    delete at.onEnd, at.tw.chain(it);
  } else
    it.start();
  const nt = argChk_Boolean(t, "arrive", !1), st = argChk_Boolean(t, "backlay", !1);
  return H(this, hr)[V] = { tw: tt, resume: !1, onEnd: () => {
    if (nt && Object.assign(U, W), st) {
      const at = H(this, ae)[G].back.spLay;
      for (const ut of Object.keys(hMemberCnt))
        at[ut] = U[ut];
    }
  } }, !1;
}, Nh = new WeakSet(), Ld = function(t) {
  const { layer: e = "", id: r, name: D } = t, N = r ? `frm
${r}` : D ?? e;
  if (!N)
    throw "トゥイーンが指定されていません";
  const k = H(this, hr)[N];
  return k != null && k.tw ? k.resume = H(this, Ar).waitEvent(
    () => {
      var $;
      return ($ = k.tw) == null ? void 0 : $.end();
    },
    // stop()とend()は別
    argChk_Boolean(t, "canskip", !0),
    argChk_Boolean(t, "global", !1)
  ) : !1;
}, kh = new WeakSet(), Bd = function(t) {
  var k, $;
  const { layer: e = "", id: r, name: D } = t, N = r ? `frm
${r}` : D ?? e;
  if (!N)
    throw "トゥイーンが指定されていません";
  return ($ = (k = H(this, hr)[N]) == null ? void 0 : k.tw) == null || $.end(), !1;
}, Lh = new WeakSet(), Fd = function(t) {
  var k, $;
  const { layer: e = "", id: r, name: D } = t, N = r ? `frm
${r}` : D ?? e;
  if (!N)
    throw "トゥイーンが指定されていません";
  return ($ = (k = H(this, hr)[N]) == null ? void 0 : k.tw) == null || $.pause(), !1;
}, Bh = new WeakSet(), $d = function(t) {
  var k, $;
  const { layer: e = "", id: r, name: D } = t, N = r ? `frm
${r}` : D ?? e;
  if (!N)
    throw "トゥイーンが指定されていません";
  return ($ = (k = H(this, hr)[N]) == null ? void 0 : k.tw) == null || $.resume(), !1;
}, Yi = new WeakMap(), Xn = new WeakSet(), qa = function(t) {
  const { text: e } = t;
  if (!e)
    throw "textは必須です";
  const r = H(this, cr).call(this, t);
  delete t.text, this.val.getVal("tmp:sn.skip.enabled") ? t.wait = 0 : "wait" in t && argChk_Num(t, "wait", NaN);
  const D = encodeURIComponent(JSON.stringify(t));
  H(this, rr).call(this, "add｜" + D, r);
  const N = argChk_Boolean(t, "record", !0), k = this.val.doRecLog();
  return N || this.val.setVal_Nochk("save", "sn.doRecLog", N), r.tagCh(e.replaceAll("[r]", `
`)), this.val.setVal_Nochk("save", "sn.doRecLog", k), H(this, rr).call(this, "add_close｜", r), !1;
}, cr = new WeakMap(), Fh = new WeakSet(), Gd = function(t) {
  const e = lt(this, Wi, Ts).call(this, t, H(this, Zr)), D = H(this, ae)[e].getPage(t);
  if (!(D instanceof TxtLayer))
    throw e + "はTxtLayerではありません";
  return D;
}, vl = new WeakMap(), $h = new WeakSet(), Ud = function(t) {
  const { layer: e } = t;
  if (!e)
    throw "[current] layerは必須です";
  if (ot(this, Jr, H(this, ae)[e]), !(H(this, Jr).getPage(t) instanceof TxtLayer))
    throw `${e}はTxtLayerではありません`;
  this.recPagebreak(), ot(this, Zr, e), this.val.setVal_Nochk("save", "const.sn.mesLayer", e);
  for (const r of lt(this, Ke, sr).call(this)) {
    const D = H(this, ae)[r];
    D.fore instanceof TxtLayer && (D.fore.isCur = D.back.isCur = r === e);
  }
  return !1;
}, Jr = new WeakMap(), Yn = new WeakMap(), Wi = new WeakSet(), Ts = function(t, e = "") {
  const r = t.layer ?? e;
  if (r.includes(","))
    throw "layer名に「,」は使えません";
  if (!(r in H(this, ae)))
    throw "属性 layer【" + r + "】が不正です。レイヤーがありません";
  return t.layer = r;
}, Nr = new WeakMap(), Qr = new WeakMap(), Gh = new WeakSet(), jd = function(t) {
  const e = H(this, cr).call(this, t);
  return t.layer === H(this, Zr) && t.page === "fore" && this.recPagebreak(), e.clearText(), !1;
}, Uh = new WeakSet(), zd = function(t) {
  return H(this, rr).call(this, "endlink｜", H(this, cr).call(this, t)), !1;
}, jh = new WeakSet(), Hd = function(t) {
  return argChk_Boolean(t, "rec_page_break", !0) && this.recPagebreak(), H(this, Jr) && (H(this, Jr).fore.clearLay(t), H(this, Jr).back.clearLay(t)), !1;
}, zh = new WeakSet(), Vd = function(t) {
  if (!t.pic)
    throw "[graph] picは必須です";
  const e = encodeURIComponent(JSON.stringify(t));
  return H(this, rr).call(this, "grp｜" + e, H(this, cr).call(this, t)), !1;
}, Hh = new WeakSet(), Xd = function(t) {
  t.style ?? (t.style = "background-color: rgba(255,0,0,0.5);"), t.style_hover ?? (t.style_hover = "background-color: rgba(255,0,0,0.9);"), t.style_clicked ?? (t.style_clicked = t.style);
  const e = encodeURIComponent(JSON.stringify(t));
  return H(this, rr).call(this, "link｜" + e, H(this, cr).call(this, t)), !1;
}, Vh = new WeakSet(), Yd = function(t) {
  return t.text = `
`, lt(this, Xn, qa).call(this, t);
}, Xh = new WeakSet(), Wd = function(t) {
  return lt(this, gl, bf).call(this, { ...t, text: "[r]" });
}, gl = new WeakSet(), bf = function(t) {
  return t.text ? (t.record = !0, t.style ?? (t.style = ""), t.style += "display: none;", t.wait = 0, lt(this, Xn, qa).call(this, t)) : !1;
}, Yh = new WeakSet(), qd = function(t) {
  return ot(this, Qr, []), ot(this, Nr, t.text ?? ""), this.val.setVal_Nochk(
    "save",
    "const.sn.sLog",
    t.text ? `[{text:"${t.text}"}]` : "[]"
  ), !1;
}, Wh = new WeakSet(), Kd = function(t) {
  const { t: e, r } = t;
  if (!e)
    throw "[ruby2] tは必須です";
  if (!r)
    throw "[ruby2] rは必須です";
  return t.text = "｜" + encodeURIComponent(e) + "《" + encodeURIComponent(r) + "》", delete t.t, delete t.r, lt(this, Xn, qa).call(this, t);
}, qh = new WeakSet(), Zd = function(t) {
  const e = encodeURIComponent(JSON.stringify(t));
  return H(this, rr).call(this, "span｜" + e, H(this, cr).call(this, t)), !1;
}, Kh = new WeakSet(), Jd = function(t) {
  if (!t.t)
    throw "[tcy] tは必須です";
  const e = encodeURIComponent(JSON.stringify(t));
  return H(this, rr).call(this, "tcy｜" + e, H(this, cr).call(this, t)), !1;
}, Zh = new WeakSet(), Qd = function(t) {
  console.group("🥟 [dump_lay]");
  for (const e of lt(this, Ke, sr).call(this, t.layer)) {
    const r = H(this, ae)[e];
    try {
      console.info(
        `%c${r.fore.name.slice(0, -7)} %o`,
        `color:#${CmnLib.isDarkMode ? "49F" : "05A"};`,
        JSON.parse(`{"back":{${r.back.dump()}}, "fore":{${r.fore.dump()}}}`)
      );
    } catch (D) {
      console.error("dump_lay err:%o", D), console.error(`   back:${r.back.dump()}`), console.error(`   fore:${r.fore.dump()}`);
    }
  }
  return console.groupEnd(), !1;
}, Jh = new WeakSet(), tp = function(t) {
  const e = lt(this, Wi, Ts).call(this, t, H(this, Zr)), r = argChk_Boolean(t, "enabled", !0);
  return H(this, cr).call(this, t).enabled = r, this.val.setVal_Nochk("save", "const.sn.layer." + e + ".enabled", r), !1;
}, Qh = new WeakSet(), ep = function(t) {
  return Pages.argChk_page(t, "back"), t.clicksebuf ?? (t.clicksebuf = "SYS"), t.entersebuf ?? (t.entersebuf = "SYS"), t.leavesebuf ?? (t.leavesebuf = "SYS"), t.fn || (t.fn = this.scrItr.scriptFn), H(this, cr).call(this, t).addButton(t), this.scrItr.recodeDesign(t), !1;
}, // 11 match 301 step (0.1ms) PCRE2 https://regex101.com/r/reinpq/1
// List ${x}${x2}/${y}${y2}/${o}${o2}=${json}\n
/*
\(\s*
(?:	(?<x>[-=\d\.]+)	|	(['"])	(?<x2>.*?)	\2	)?
(?:
	\s*,\s*
	(?:	(?<y>[-=\d\.]+)	|	(['"])	(?<y2>.*?)	\5	)?
	(?:
		\s*,\s*
		(?:	(?<o>[-=\d\.]+)	|	(['"])	(?<o2>.*?)	\8	)

	)?
)?
|
(?<json>\{[^{}]*})
*/
It(LayerMng, "REG_TSY_PATH", /\(\s*(?:(?<x>[-=\d\.]+)|(['"])(?<x2>.*?)\2)?(?:\s*,\s*(?:(?<y>[-=\d\.]+)|(['"])(?<y2>.*?)\5)?(?:\s*,\s*(?:(?<o>[-=\d\.]+)|(['"])(?<o2>.*?)\8))?)?|(?<json>\{[^{}]*})/g), //	// 文字・文字レイヤ
rt(LayerMng, Yi, 10);
var Ce, be, Ea, tc, rp, ml, Wn, Ka;
class FocusMng {
  constructor() {
    rt(this, tc);
    rt(this, Wn);
    rt(this, Ce, []);
    rt(this, be, -1);
    rt(this, Ea, new EventListenerCtn());
    rt(this, ml, CmnLib.debugLog ? (t) => console.log(`👾 <FocusMng idx:${t} btn:%o`, H(this, Ce)[t].btn) : () => {
    });
  }
  destroy() {
    ot(this, Ce, []), ot(this, be, -1), H(this, Ea).clear();
  }
  add(t, e, r) {
    if (H(this, Ce).findIndex(($) => $.btn === t) >= 0)
      return;
    if (t instanceof Container) {
      t.on("pointerdown", () => {
        for (let $ = H(this, Ce).length - 1; $ >= 0; --$)
          if (H(this, Ce)[$].btn === t) {
            ot(this, be, $);
            return;
          }
        ot(this, be, -1);
      }), H(this, Ce).push({ btn: t, on: e, off: r });
      return;
    }
    H(this, Ea).add(t, "focus", () => {
      for (let $ = H(this, Ce).length - 1; $ >= 0; --$)
        if (H(this, Ce)[$].btn === t) {
          ot(this, be, $);
          return;
        }
      ot(this, be, -1);
    });
    let D = ($) => {
    }, N = t.localName === "button" || t.localName === "a" ? ($) => !$.isTrusted && $.key === "Enter" : ($) => $.key === "Enter";
    const k = t;
    switch (k.type ?? "") {
      case "checkbox":
        D = () => k.checked = !k.checked;
        break;
      case "":
        t.querySelectorAll("input[type]").length > 0 && (D = ($) => lt(this, tc, rp).call(this, t, $.key), N = () => !1);
        break;
      case "range":
        D = ($) => {
          $.isTrusted || ($.key === "ArrowUp" ? k.stepUp() : k.stepDown());
        };
        break;
      case "text":
      case "textarea":
        D = ($) => {
          if ($.isTrusted)
            return;
          let G = (k.selectionStart ?? 0) + ($.key === "ArrowUp" ? -1 : 1);
          G < 0 && (G = 0), k.setSelectionRange(G, G);
        };
        break;
    }
    H(this, Ea).add(t, "keydown", ($) => {
      if (!($.key !== "ArrowUp" && $.key !== "ArrowDown" && $.key !== "Enter")) {
        if ($.stopPropagation(), $.stopImmediatePropagation(), N($)) {
          t.dispatchEvent(new MouseEvent("click"));
          return;
        }
        D($);
      }
    }, { passive: !0 }), t.hasAttribute("tabindex") || (t.tabIndex = 0), H(this, Ce).push({ btn: t, on: e, off: r });
  }
  remove(t) {
    const e = H(this, Ce).findIndex((r) => r.btn === t);
    e < 0 || (H(this, Ce).splice(e, 1), H(this, Ce).length === 0 ? ot(this, be, -1) : e <= H(this, be) && --Ie(this, be)._);
  }
  isFocus(t) {
    return H(this, be) < 0 ? !1 : H(this, Ce)[H(this, be)].btn === t;
  }
  prev() {
    lt(this, Wn, Ka).call(this);
    const t = H(this, Ce).length;
    if (t !== 0) {
      --Ie(this, be)._ < 0 && ot(this, be, t - 1);
      for (let e = t; e >= 1; --e) {
        const r = (H(this, be) + e) % t;
        if (H(this, Ce)[r].on()) {
          ot(this, be, r), H(this, ml).call(this, r);
          return;
        }
      }
      ot(this, be, -1);
    }
  }
  next() {
    lt(this, Wn, Ka).call(this);
    const t = H(this, Ce).length;
    if (t !== 0) {
      ++Ie(this, be)._ >= t && ot(this, be, 0);
      for (let e = 0; e < t; ++e) {
        const r = (H(this, be) + e) % t;
        if (H(this, Ce)[r].on()) {
          ot(this, be, r), H(this, ml).call(this, r);
          return;
        }
      }
      ot(this, be, -1);
    }
  }
  getFocus() {
    if (H(this, be) < 0)
      return null;
    lt(this, Wn, Ka).call(this), H(this, be) >= H(this, Ce).length && ot(this, be, 0);
    const t = H(this, Ce)[H(this, be)];
    return t.on() ? t.btn : null;
  }
  blur() {
    lt(this, Wn, Ka).call(this), ot(this, be, -1), globalThis.focus();
  }
}
Ce = new WeakMap(), be = new WeakMap(), Ea = new WeakMap(), tc = new WeakSet(), rp = function(t, e) {
  const r = t.querySelectorAll("input[type]"), D = r.length;
  for (let N = 0; N < D; ++N)
    if (r[N].checked) {
      r[(N + D + (e === "ArrowUp" ? -1 : 1)) % D].checked = !0;
      break;
    }
}, ml = new WeakMap(), Wn = new WeakSet(), Ka = function() {
  for (let t = H(this, Ce).length - 1; t >= 0; --t) {
    const e = H(this, Ce)[t];
    !(e.btn instanceof Container) || e.btn.parent ? e.off() : H(this, Ce).splice(t, 1);
  }
};
var top = "top", bottom = "bottom", right = "right", left = "left", auto = "auto", basePlacements = [top, bottom, right, left], start = "start", end = "end", clippingParents = "clippingParents", viewport = "viewport", popper = "popper", reference = "reference", variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(o, t) {
  return o.concat([t + "-" + start, t + "-" + end]);
}, []), placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(o, t) {
  return o.concat([t, t + "-" + start, t + "-" + end]);
}, []), beforeRead = "beforeRead", read$6 = "read", afterRead = "afterRead", beforeMain = "beforeMain", main$1 = "main", afterMain = "afterMain", beforeWrite = "beforeWrite", write$6 = "write", afterWrite = "afterWrite", modifierPhases = [beforeRead, read$6, afterRead, beforeMain, main$1, afterMain, beforeWrite, write$6, afterWrite];
function getNodeName(o) {
  return o ? (o.nodeName || "").toLowerCase() : null;
}
function getWindow(o) {
  if (o == null)
    return window;
  if (o.toString() !== "[object Window]") {
    var t = o.ownerDocument;
    return t && t.defaultView || window;
  }
  return o;
}
function isElement(o) {
  var t = getWindow(o).Element;
  return o instanceof t || o instanceof Element;
}
function isHTMLElement(o) {
  var t = getWindow(o).HTMLElement;
  return o instanceof t || o instanceof HTMLElement;
}
function isShadowRoot(o) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = getWindow(o).ShadowRoot;
  return o instanceof t || o instanceof ShadowRoot;
}
function applyStyles(o) {
  var t = o.state;
  Object.keys(t.elements).forEach(function(e) {
    var r = t.styles[e] || {}, D = t.attributes[e] || {}, N = t.elements[e];
    !isHTMLElement(N) || !getNodeName(N) || (Object.assign(N.style, r), Object.keys(D).forEach(function(k) {
      var $ = D[k];
      $ === !1 ? N.removeAttribute(k) : N.setAttribute(k, $ === !0 ? "" : $);
    }));
  });
}
function effect$2(o) {
  var t = o.state, e = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
    Object.keys(t.elements).forEach(function(r) {
      var D = t.elements[r], N = t.attributes[r] || {}, k = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : e[r]), $ = k.reduce(function(G, U) {
        return G[U] = "", G;
      }, {});
      !isHTMLElement(D) || !getNodeName(D) || (Object.assign(D.style, $), Object.keys(N).forEach(function(G) {
        D.removeAttribute(G);
      }));
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(o) {
  return o.split("-")[0];
}
var max = Math.max, min = Math.min, round = Math.round;
function getUAString() {
  var o = navigator.userAgentData;
  return o != null && o.brands && Array.isArray(o.brands) ? o.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(o, t, e) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  var r = o.getBoundingClientRect(), D = 1, N = 1;
  t && isHTMLElement(o) && (D = o.offsetWidth > 0 && round(r.width) / o.offsetWidth || 1, N = o.offsetHeight > 0 && round(r.height) / o.offsetHeight || 1);
  var k = isElement(o) ? getWindow(o) : window, $ = k.visualViewport, G = !isLayoutViewport() && e, U = (r.left + (G && $ ? $.offsetLeft : 0)) / D, z = (r.top + (G && $ ? $.offsetTop : 0)) / N, X = r.width / D, V = r.height / N;
  return {
    width: X,
    height: V,
    top: z,
    right: U + X,
    bottom: z + V,
    left: U,
    x: U,
    y: z
  };
}
function getLayoutRect(o) {
  var t = getBoundingClientRect(o), e = o.offsetWidth, r = o.offsetHeight;
  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
    x: o.offsetLeft,
    y: o.offsetTop,
    width: e,
    height: r
  };
}
function contains(o, t) {
  var e = t.getRootNode && t.getRootNode();
  if (o.contains(t))
    return !0;
  if (e && isShadowRoot(e)) {
    var r = t;
    do {
      if (r && o.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function getComputedStyle$1(o) {
  return getWindow(o).getComputedStyle(o);
}
function isTableElement(o) {
  return ["table", "td", "th"].indexOf(getNodeName(o)) >= 0;
}
function getDocumentElement(o) {
  return ((isElement(o) ? o.ownerDocument : (
    // $FlowFixMe[prop-missing]
    o.document
  )) || window.document).documentElement;
}
function getParentNode(o) {
  return getNodeName(o) === "html" ? o : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    o.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    o.parentNode || // DOM Element detected
    (isShadowRoot(o) ? o.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(o)
  );
}
function getTrueOffsetParent(o) {
  return !isHTMLElement(o) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(o).position === "fixed" ? null : o.offsetParent;
}
function getContainingBlock(o) {
  var t = /firefox/i.test(getUAString()), e = /Trident/i.test(getUAString());
  if (e && isHTMLElement(o)) {
    var r = getComputedStyle$1(o);
    if (r.position === "fixed")
      return null;
  }
  var D = getParentNode(o);
  for (isShadowRoot(D) && (D = D.host); isHTMLElement(D) && ["html", "body"].indexOf(getNodeName(D)) < 0; ) {
    var N = getComputedStyle$1(D);
    if (N.transform !== "none" || N.perspective !== "none" || N.contain === "paint" || ["transform", "perspective"].indexOf(N.willChange) !== -1 || t && N.willChange === "filter" || t && N.filter && N.filter !== "none")
      return D;
    D = D.parentNode;
  }
  return null;
}
function getOffsetParent(o) {
  for (var t = getWindow(o), e = getTrueOffsetParent(o); e && isTableElement(e) && getComputedStyle$1(e).position === "static"; )
    e = getTrueOffsetParent(e);
  return e && (getNodeName(e) === "html" || getNodeName(e) === "body" && getComputedStyle$1(e).position === "static") ? t : e || getContainingBlock(o) || t;
}
function getMainAxisFromPlacement(o) {
  return ["top", "bottom"].indexOf(o) >= 0 ? "x" : "y";
}
function within(o, t, e) {
  return max(o, min(t, e));
}
function withinMaxClamp(o, t, e) {
  var r = within(o, t, e);
  return r > e ? e : r;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(o) {
  return Object.assign({}, getFreshSideObject(), o);
}
function expandToHashMap(o, t) {
  return t.reduce(function(e, r) {
    return e[r] = o, e;
  }, {});
}
var toPaddingObject = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, mergePaddingObject(typeof t != "number" ? t : expandToHashMap(t, basePlacements));
};
function arrow(o) {
  var t, e = o.state, r = o.name, D = o.options, N = e.elements.arrow, k = e.modifiersData.popperOffsets, $ = getBasePlacement(e.placement), G = getMainAxisFromPlacement($), U = [left, right].indexOf($) >= 0, z = U ? "height" : "width";
  if (!(!N || !k)) {
    var X = toPaddingObject(D.padding, e), V = getLayoutRect(N), Y = G === "y" ? top : left, W = G === "y" ? bottom : right, q = e.rects.reference[z] + e.rects.reference[G] - k[G] - e.rects.popper[z], K = k[G] - e.rects.reference[G], Z = getOffsetParent(N), J = Z ? G === "y" ? Z.clientHeight || 0 : Z.clientWidth || 0 : 0, Q = q / 2 - K / 2, et = X[Y], it = J - V[z] - X[W], tt = J / 2 - V[z] / 2 + Q, nt = within(et, tt, it), st = G;
    e.modifiersData[r] = (t = {}, t[st] = nt, t.centerOffset = nt - tt, t);
  }
}
function effect$1(o) {
  var t = o.state, e = o.options, r = e.element, D = r === void 0 ? "[data-popper-arrow]" : r;
  if (D != null && !(typeof D == "string" && (D = t.elements.popper.querySelector(D), !D))) {
    if (process.env.NODE_ENV !== "production" && (isHTMLElement(D) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !contains(t.elements.popper, D)) {
      process.env.NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    t.elements.arrow = D;
  }
}
const arrow$1 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(o) {
  return o.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(o, t) {
  var e = o.x, r = o.y, D = t.devicePixelRatio || 1;
  return {
    x: round(e * D) / D || 0,
    y: round(r * D) / D || 0
  };
}
function mapToStyles(o) {
  var t, e = o.popper, r = o.popperRect, D = o.placement, N = o.variation, k = o.offsets, $ = o.position, G = o.gpuAcceleration, U = o.adaptive, z = o.roundOffsets, X = o.isFixed, V = k.x, Y = V === void 0 ? 0 : V, W = k.y, q = W === void 0 ? 0 : W, K = typeof z == "function" ? z({
    x: Y,
    y: q
  }) : {
    x: Y,
    y: q
  };
  Y = K.x, q = K.y;
  var Z = k.hasOwnProperty("x"), J = k.hasOwnProperty("y"), Q = left, et = top, it = window;
  if (U) {
    var tt = getOffsetParent(e), nt = "clientHeight", st = "clientWidth";
    if (tt === getWindow(e) && (tt = getDocumentElement(e), getComputedStyle$1(tt).position !== "static" && $ === "absolute" && (nt = "scrollHeight", st = "scrollWidth")), tt = tt, D === top || (D === left || D === right) && N === end) {
      et = bottom;
      var at = X && tt === it && it.visualViewport ? it.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        tt[nt]
      );
      q -= at - r.height, q *= G ? 1 : -1;
    }
    if (D === left || (D === top || D === bottom) && N === end) {
      Q = right;
      var ut = X && tt === it && it.visualViewport ? it.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        tt[st]
      );
      Y -= ut - r.width, Y *= G ? 1 : -1;
    }
  }
  var ht = Object.assign({
    position: $
  }, U && unsetSides), dt = z === !0 ? roundOffsetsByDPR({
    x: Y,
    y: q
  }, getWindow(e)) : {
    x: Y,
    y: q
  };
  if (Y = dt.x, q = dt.y, G) {
    var pt;
    return Object.assign({}, ht, (pt = {}, pt[et] = J ? "0" : "", pt[Q] = Z ? "0" : "", pt.transform = (it.devicePixelRatio || 1) <= 1 ? "translate(" + Y + "px, " + q + "px)" : "translate3d(" + Y + "px, " + q + "px, 0)", pt));
  }
  return Object.assign({}, ht, (t = {}, t[et] = J ? q + "px" : "", t[Q] = Z ? Y + "px" : "", t.transform = "", t));
}
function computeStyles(o) {
  var t = o.state, e = o.options, r = e.gpuAcceleration, D = r === void 0 ? !0 : r, N = e.adaptive, k = N === void 0 ? !0 : N, $ = e.roundOffsets, G = $ === void 0 ? !0 : $;
  if (process.env.NODE_ENV !== "production") {
    var U = getComputedStyle$1(t.elements.popper).transitionProperty || "";
    k && ["transform", "top", "right", "bottom", "left"].some(function(X) {
      return U.indexOf(X) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var z = {
    placement: getBasePlacement(t.placement),
    variation: getVariation(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: D,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, mapToStyles(Object.assign({}, z, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: k,
    roundOffsets: G
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, mapToStyles(Object.assign({}, z, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: G
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: !0
};
function effect(o) {
  var t = o.state, e = o.instance, r = o.options, D = r.scroll, N = D === void 0 ? !0 : D, k = r.resize, $ = k === void 0 ? !0 : k, G = getWindow(t.elements.popper), U = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return N && U.forEach(function(z) {
    z.addEventListener("scroll", e.update, passive);
  }), $ && G.addEventListener("resize", e.update, passive), function() {
    N && U.forEach(function(z) {
      z.removeEventListener("scroll", e.update, passive);
    }), $ && G.removeEventListener("resize", e.update, passive);
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(o) {
  return o.replace(/left|right|bottom|top/g, function(t) {
    return hash$1[t];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(o) {
  return o.replace(/start|end/g, function(t) {
    return hash[t];
  });
}
function getWindowScroll(o) {
  var t = getWindow(o), e = t.pageXOffset, r = t.pageYOffset;
  return {
    scrollLeft: e,
    scrollTop: r
  };
}
function getWindowScrollBarX(o) {
  return getBoundingClientRect(getDocumentElement(o)).left + getWindowScroll(o).scrollLeft;
}
function getViewportRect(o, t) {
  var e = getWindow(o), r = getDocumentElement(o), D = e.visualViewport, N = r.clientWidth, k = r.clientHeight, $ = 0, G = 0;
  if (D) {
    N = D.width, k = D.height;
    var U = isLayoutViewport();
    (U || !U && t === "fixed") && ($ = D.offsetLeft, G = D.offsetTop);
  }
  return {
    width: N,
    height: k,
    x: $ + getWindowScrollBarX(o),
    y: G
  };
}
function getDocumentRect(o) {
  var t, e = getDocumentElement(o), r = getWindowScroll(o), D = (t = o.ownerDocument) == null ? void 0 : t.body, N = max(e.scrollWidth, e.clientWidth, D ? D.scrollWidth : 0, D ? D.clientWidth : 0), k = max(e.scrollHeight, e.clientHeight, D ? D.scrollHeight : 0, D ? D.clientHeight : 0), $ = -r.scrollLeft + getWindowScrollBarX(o), G = -r.scrollTop;
  return getComputedStyle$1(D || e).direction === "rtl" && ($ += max(e.clientWidth, D ? D.clientWidth : 0) - N), {
    width: N,
    height: k,
    x: $,
    y: G
  };
}
function isScrollParent(o) {
  var t = getComputedStyle$1(o), e = t.overflow, r = t.overflowX, D = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + D + r);
}
function getScrollParent(o) {
  return ["html", "body", "#document"].indexOf(getNodeName(o)) >= 0 ? o.ownerDocument.body : isHTMLElement(o) && isScrollParent(o) ? o : getScrollParent(getParentNode(o));
}
function listScrollParents(o, t) {
  var e;
  t === void 0 && (t = []);
  var r = getScrollParent(o), D = r === ((e = o.ownerDocument) == null ? void 0 : e.body), N = getWindow(r), k = D ? [N].concat(N.visualViewport || [], isScrollParent(r) ? r : []) : r, $ = t.concat(k);
  return D ? $ : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    $.concat(listScrollParents(getParentNode(k)))
  );
}
function rectToClientRect(o) {
  return Object.assign({}, o, {
    left: o.x,
    top: o.y,
    right: o.x + o.width,
    bottom: o.y + o.height
  });
}
function getInnerBoundingClientRect(o, t) {
  var e = getBoundingClientRect(o, !1, t === "fixed");
  return e.top = e.top + o.clientTop, e.left = e.left + o.clientLeft, e.bottom = e.top + o.clientHeight, e.right = e.left + o.clientWidth, e.width = o.clientWidth, e.height = o.clientHeight, e.x = e.left, e.y = e.top, e;
}
function getClientRectFromMixedType(o, t, e) {
  return t === viewport ? rectToClientRect(getViewportRect(o, e)) : isElement(t) ? getInnerBoundingClientRect(t, e) : rectToClientRect(getDocumentRect(getDocumentElement(o)));
}
function getClippingParents(o) {
  var t = listScrollParents(getParentNode(o)), e = ["absolute", "fixed"].indexOf(getComputedStyle$1(o).position) >= 0, r = e && isHTMLElement(o) ? getOffsetParent(o) : o;
  return isElement(r) ? t.filter(function(D) {
    return isElement(D) && contains(D, r) && getNodeName(D) !== "body";
  }) : [];
}
function getClippingRect(o, t, e, r) {
  var D = t === "clippingParents" ? getClippingParents(o) : [].concat(t), N = [].concat(D, [e]), k = N[0], $ = N.reduce(function(G, U) {
    var z = getClientRectFromMixedType(o, U, r);
    return G.top = max(z.top, G.top), G.right = min(z.right, G.right), G.bottom = min(z.bottom, G.bottom), G.left = max(z.left, G.left), G;
  }, getClientRectFromMixedType(o, k, r));
  return $.width = $.right - $.left, $.height = $.bottom - $.top, $.x = $.left, $.y = $.top, $;
}
function computeOffsets(o) {
  var t = o.reference, e = o.element, r = o.placement, D = r ? getBasePlacement(r) : null, N = r ? getVariation(r) : null, k = t.x + t.width / 2 - e.width / 2, $ = t.y + t.height / 2 - e.height / 2, G;
  switch (D) {
    case top:
      G = {
        x: k,
        y: t.y - e.height
      };
      break;
    case bottom:
      G = {
        x: k,
        y: t.y + t.height
      };
      break;
    case right:
      G = {
        x: t.x + t.width,
        y: $
      };
      break;
    case left:
      G = {
        x: t.x - e.width,
        y: $
      };
      break;
    default:
      G = {
        x: t.x,
        y: t.y
      };
  }
  var U = D ? getMainAxisFromPlacement(D) : null;
  if (U != null) {
    var z = U === "y" ? "height" : "width";
    switch (N) {
      case start:
        G[U] = G[U] - (t[z] / 2 - e[z] / 2);
        break;
      case end:
        G[U] = G[U] + (t[z] / 2 - e[z] / 2);
        break;
    }
  }
  return G;
}
function detectOverflow(o, t) {
  t === void 0 && (t = {});
  var e = t, r = e.placement, D = r === void 0 ? o.placement : r, N = e.strategy, k = N === void 0 ? o.strategy : N, $ = e.boundary, G = $ === void 0 ? clippingParents : $, U = e.rootBoundary, z = U === void 0 ? viewport : U, X = e.elementContext, V = X === void 0 ? popper : X, Y = e.altBoundary, W = Y === void 0 ? !1 : Y, q = e.padding, K = q === void 0 ? 0 : q, Z = mergePaddingObject(typeof K != "number" ? K : expandToHashMap(K, basePlacements)), J = V === popper ? reference : popper, Q = o.rects.popper, et = o.elements[W ? J : V], it = getClippingRect(isElement(et) ? et : et.contextElement || getDocumentElement(o.elements.popper), G, z, k), tt = getBoundingClientRect(o.elements.reference), nt = computeOffsets({
    reference: tt,
    element: Q,
    strategy: "absolute",
    placement: D
  }), st = rectToClientRect(Object.assign({}, Q, nt)), at = V === popper ? st : tt, ut = {
    top: it.top - at.top + Z.top,
    bottom: at.bottom - it.bottom + Z.bottom,
    left: it.left - at.left + Z.left,
    right: at.right - it.right + Z.right
  }, ht = o.modifiersData.offset;
  if (V === popper && ht) {
    var dt = ht[D];
    Object.keys(ut).forEach(function(pt) {
      var _t = [right, bottom].indexOf(pt) >= 0 ? 1 : -1, mt = [top, bottom].indexOf(pt) >= 0 ? "y" : "x";
      ut[pt] += dt[mt] * _t;
    });
  }
  return ut;
}
function computeAutoPlacement(o, t) {
  t === void 0 && (t = {});
  var e = t, r = e.placement, D = e.boundary, N = e.rootBoundary, k = e.padding, $ = e.flipVariations, G = e.allowedAutoPlacements, U = G === void 0 ? placements : G, z = getVariation(r), X = z ? $ ? variationPlacements : variationPlacements.filter(function(W) {
    return getVariation(W) === z;
  }) : basePlacements, V = X.filter(function(W) {
    return U.indexOf(W) >= 0;
  });
  V.length === 0 && (V = X, process.env.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var Y = V.reduce(function(W, q) {
    return W[q] = detectOverflow(o, {
      placement: q,
      boundary: D,
      rootBoundary: N,
      padding: k
    })[getBasePlacement(q)], W;
  }, {});
  return Object.keys(Y).sort(function(W, q) {
    return Y[W] - Y[q];
  });
}
function getExpandedFallbackPlacements(o) {
  if (getBasePlacement(o) === auto)
    return [];
  var t = getOppositePlacement(o);
  return [getOppositeVariationPlacement(o), t, getOppositeVariationPlacement(t)];
}
function flip(o) {
  var t = o.state, e = o.options, r = o.name;
  if (!t.modifiersData[r]._skip) {
    for (var D = e.mainAxis, N = D === void 0 ? !0 : D, k = e.altAxis, $ = k === void 0 ? !0 : k, G = e.fallbackPlacements, U = e.padding, z = e.boundary, X = e.rootBoundary, V = e.altBoundary, Y = e.flipVariations, W = Y === void 0 ? !0 : Y, q = e.allowedAutoPlacements, K = t.options.placement, Z = getBasePlacement(K), J = Z === K, Q = G || (J || !W ? [getOppositePlacement(K)] : getExpandedFallbackPlacements(K)), et = [K].concat(Q).reduce(function(Nt, Mt) {
      return Nt.concat(getBasePlacement(Mt) === auto ? computeAutoPlacement(t, {
        placement: Mt,
        boundary: z,
        rootBoundary: X,
        padding: U,
        flipVariations: W,
        allowedAutoPlacements: q
      }) : Mt);
    }, []), it = t.rects.reference, tt = t.rects.popper, nt = /* @__PURE__ */ new Map(), st = !0, at = et[0], ut = 0; ut < et.length; ut++) {
      var ht = et[ut], dt = getBasePlacement(ht), pt = getVariation(ht) === start, _t = [top, bottom].indexOf(dt) >= 0, mt = _t ? "width" : "height", yt = detectOverflow(t, {
        placement: ht,
        boundary: z,
        rootBoundary: X,
        altBoundary: V,
        padding: U
      }), Tt = _t ? pt ? right : left : pt ? bottom : top;
      it[mt] > tt[mt] && (Tt = getOppositePlacement(Tt));
      var Pt = getOppositePlacement(Tt), St = [];
      if (N && St.push(yt[dt] <= 0), $ && St.push(yt[Tt] <= 0, yt[Pt] <= 0), St.every(function(Nt) {
        return Nt;
      })) {
        at = ht, st = !1;
        break;
      }
      nt.set(ht, St);
    }
    if (st)
      for (var gt = W ? 3 : 1, bt = function(Mt) {
        var ft = et.find(function(Ft) {
          var Dt = nt.get(Ft);
          if (Dt)
            return Dt.slice(0, Mt).every(function(Vt) {
              return Vt;
            });
        });
        if (ft)
          return at = ft, "break";
      }, At = gt; At > 0; At--) {
        var Rt = bt(At);
        if (Rt === "break")
          break;
      }
    t.placement !== at && (t.modifiersData[r]._skip = !0, t.placement = at, t.reset = !0);
  }
}
const flip$1 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function getSideOffsets(o, t, e) {
  return e === void 0 && (e = {
    x: 0,
    y: 0
  }), {
    top: o.top - t.height - e.y,
    right: o.right - t.width + e.x,
    bottom: o.bottom - t.height + e.y,
    left: o.left - t.width - e.x
  };
}
function isAnySideFullyClipped(o) {
  return [top, right, bottom, left].some(function(t) {
    return o[t] >= 0;
  });
}
function hide(o) {
  var t = o.state, e = o.name, r = t.rects.reference, D = t.rects.popper, N = t.modifiersData.preventOverflow, k = detectOverflow(t, {
    elementContext: "reference"
  }), $ = detectOverflow(t, {
    altBoundary: !0
  }), G = getSideOffsets(k, r), U = getSideOffsets($, D, N), z = isAnySideFullyClipped(G), X = isAnySideFullyClipped(U);
  t.modifiersData[e] = {
    referenceClippingOffsets: G,
    popperEscapeOffsets: U,
    isReferenceHidden: z,
    hasPopperEscaped: X
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": z,
    "data-popper-escaped": X
  });
}
const hide$1 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(o, t, e) {
  var r = getBasePlacement(o), D = [left, top].indexOf(r) >= 0 ? -1 : 1, N = typeof e == "function" ? e(Object.assign({}, t, {
    placement: o
  })) : e, k = N[0], $ = N[1];
  return k = k || 0, $ = ($ || 0) * D, [left, right].indexOf(r) >= 0 ? {
    x: $,
    y: k
  } : {
    x: k,
    y: $
  };
}
function offset(o) {
  var t = o.state, e = o.options, r = o.name, D = e.offset, N = D === void 0 ? [0, 0] : D, k = placements.reduce(function(z, X) {
    return z[X] = distanceAndSkiddingToXY(X, t.rects, N), z;
  }, {}), $ = k[t.placement], G = $.x, U = $.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += G, t.modifiersData.popperOffsets.y += U), t.modifiersData[r] = k;
}
const offset$1 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(o) {
  var t = o.state, e = o.name;
  t.modifiersData[e] = computeOffsets({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(o) {
  return o === "x" ? "y" : "x";
}
function preventOverflow(o) {
  var t = o.state, e = o.options, r = o.name, D = e.mainAxis, N = D === void 0 ? !0 : D, k = e.altAxis, $ = k === void 0 ? !1 : k, G = e.boundary, U = e.rootBoundary, z = e.altBoundary, X = e.padding, V = e.tether, Y = V === void 0 ? !0 : V, W = e.tetherOffset, q = W === void 0 ? 0 : W, K = detectOverflow(t, {
    boundary: G,
    rootBoundary: U,
    padding: X,
    altBoundary: z
  }), Z = getBasePlacement(t.placement), J = getVariation(t.placement), Q = !J, et = getMainAxisFromPlacement(Z), it = getAltAxis(et), tt = t.modifiersData.popperOffsets, nt = t.rects.reference, st = t.rects.popper, at = typeof q == "function" ? q(Object.assign({}, t.rects, {
    placement: t.placement
  })) : q, ut = typeof at == "number" ? {
    mainAxis: at,
    altAxis: at
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, at), ht = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, dt = {
    x: 0,
    y: 0
  };
  if (tt) {
    if (N) {
      var pt, _t = et === "y" ? top : left, mt = et === "y" ? bottom : right, yt = et === "y" ? "height" : "width", Tt = tt[et], Pt = Tt + K[_t], St = Tt - K[mt], gt = Y ? -st[yt] / 2 : 0, bt = J === start ? nt[yt] : st[yt], At = J === start ? -st[yt] : -nt[yt], Rt = t.elements.arrow, Nt = Y && Rt ? getLayoutRect(Rt) : {
        width: 0,
        height: 0
      }, Mt = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : getFreshSideObject(), ft = Mt[_t], Ft = Mt[mt], Dt = within(0, nt[yt], Nt[yt]), Vt = Q ? nt[yt] / 2 - gt - Dt - ft - ut.mainAxis : bt - Dt - ft - ut.mainAxis, Bt = Q ? -nt[yt] / 2 + gt + Dt + Ft + ut.mainAxis : At + Dt + Ft + ut.mainAxis, Et = t.elements.arrow && getOffsetParent(t.elements.arrow), Ht = Et ? et === "y" ? Et.clientTop || 0 : Et.clientLeft || 0 : 0, kt = (pt = ht == null ? void 0 : ht[et]) != null ? pt : 0, wt = Tt + Vt - kt - Ht, Lt = Tt + Bt - kt, jt = within(Y ? min(Pt, wt) : Pt, Tt, Y ? max(St, Lt) : St);
      tt[et] = jt, dt[et] = jt - Tt;
    }
    if ($) {
      var Ct, Wt = et === "x" ? top : left, Jt = et === "x" ? bottom : right, Kt = tt[it], Se = it === "y" ? "height" : "width", Oe = Kt + K[Wt], he = Kt - K[Jt], _e = [top, left].indexOf(Z) !== -1, ve = (Ct = ht == null ? void 0 : ht[it]) != null ? Ct : 0, de = _e ? Oe : Kt - nt[Se] - st[Se] - ve + ut.altAxis, fe = _e ? Kt + nt[Se] + st[Se] - ve - ut.altAxis : he, ne = Y && _e ? withinMaxClamp(de, Kt, fe) : within(Y ? de : Oe, Kt, Y ? fe : he);
      tt[it] = ne, dt[it] = ne - Kt;
    }
    t.modifiersData[r] = dt;
  }
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(o) {
  return {
    scrollLeft: o.scrollLeft,
    scrollTop: o.scrollTop
  };
}
function getNodeScroll(o) {
  return o === getWindow(o) || !isHTMLElement(o) ? getWindowScroll(o) : getHTMLElementScroll(o);
}
function isElementScaled(o) {
  var t = o.getBoundingClientRect(), e = round(t.width) / o.offsetWidth || 1, r = round(t.height) / o.offsetHeight || 1;
  return e !== 1 || r !== 1;
}
function getCompositeRect(o, t, e) {
  e === void 0 && (e = !1);
  var r = isHTMLElement(t), D = isHTMLElement(t) && isElementScaled(t), N = getDocumentElement(t), k = getBoundingClientRect(o, D, e), $ = {
    scrollLeft: 0,
    scrollTop: 0
  }, G = {
    x: 0,
    y: 0
  };
  return (r || !r && !e) && ((getNodeName(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  isScrollParent(N)) && ($ = getNodeScroll(t)), isHTMLElement(t) ? (G = getBoundingClientRect(t, !0), G.x += t.clientLeft, G.y += t.clientTop) : N && (G.x = getWindowScrollBarX(N))), {
    x: k.left + $.scrollLeft - G.x,
    y: k.top + $.scrollTop - G.y,
    width: k.width,
    height: k.height
  };
}
function order(o) {
  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), r = [];
  o.forEach(function(N) {
    t.set(N.name, N);
  });
  function D(N) {
    e.add(N.name);
    var k = [].concat(N.requires || [], N.requiresIfExists || []);
    k.forEach(function($) {
      if (!e.has($)) {
        var G = t.get($);
        G && D(G);
      }
    }), r.push(N);
  }
  return o.forEach(function(N) {
    e.has(N.name) || D(N);
  }), r;
}
function orderModifiers(o) {
  var t = order(o);
  return modifierPhases.reduce(function(e, r) {
    return e.concat(t.filter(function(D) {
      return D.phase === r;
    }));
  }, []);
}
function debounce(o) {
  var t;
  return function() {
    return t || (t = new Promise(function(e) {
      Promise.resolve().then(function() {
        t = void 0, e(o());
      });
    })), t;
  };
}
function format(o) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    e[r - 1] = arguments[r];
  return [].concat(e).reduce(function(D, N) {
    return D.replace(/%s/, N);
  }, o);
}
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(o) {
  o.forEach(function(t) {
    [].concat(Object.keys(t), VALID_PROPERTIES).filter(function(e, r, D) {
      return D.indexOf(e) === r;
    }).forEach(function(e) {
      switch (e) {
        case "name":
          typeof t.name != "string" && console.error(format(INVALID_MODIFIER_ERROR, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"'));
          break;
        case "enabled":
          typeof t.enabled != "boolean" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"'));
          break;
        case "phase":
          modifierPhases.indexOf(t.phase) < 0 && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(t.phase) + '"'));
          break;
        case "fn":
          typeof t.fn != "function" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "effect":
          t.effect != null && typeof t.effect != "function" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "requires":
          t.requires != null && !Array.isArray(t.requires) && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(t.requiresIfExists) || console.error(format(INVALID_MODIFIER_ERROR, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(r) {
            return '"' + r + '"';
          }).join(", ") + '; but "' + e + '" was provided.');
      }
      t.requires && t.requires.forEach(function(r) {
        o.find(function(D) {
          return D.name === r;
        }) == null && console.error(format(MISSING_DEPENDENCY_ERROR, String(t.name), r, r));
      });
    });
  });
}
function uniqueBy(o, t) {
  var e = /* @__PURE__ */ new Set();
  return o.filter(function(r) {
    var D = t(r);
    if (!e.has(D))
      return e.add(D), !0;
  });
}
function mergeByName(o) {
  var t = o.reduce(function(e, r) {
    var D = e[r.name];
    return e[r.name] = D ? Object.assign({}, D, r, {
      options: Object.assign({}, D.options, r.options),
      data: Object.assign({}, D.data, r.data)
    }) : r, e;
  }, {});
  return Object.keys(t).map(function(e) {
    return t[e];
  });
}
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var o = arguments.length, t = new Array(o), e = 0; e < o; e++)
    t[e] = arguments[e];
  return !t.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function popperGenerator(o) {
  o === void 0 && (o = {});
  var t = o, e = t.defaultModifiers, r = e === void 0 ? [] : e, D = t.defaultOptions, N = D === void 0 ? DEFAULT_OPTIONS : D;
  return function($, G, U) {
    U === void 0 && (U = N);
    var z = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, N),
      modifiersData: {},
      elements: {
        reference: $,
        popper: G
      },
      attributes: {},
      styles: {}
    }, X = [], V = !1, Y = {
      state: z,
      setOptions: function(Z) {
        var J = typeof Z == "function" ? Z(z.options) : Z;
        q(), z.options = Object.assign({}, N, z.options, J), z.scrollParents = {
          reference: isElement($) ? listScrollParents($) : $.contextElement ? listScrollParents($.contextElement) : [],
          popper: listScrollParents(G)
        };
        var Q = orderModifiers(mergeByName([].concat(r, z.options.modifiers)));
        if (z.orderedModifiers = Q.filter(function(ht) {
          return ht.enabled;
        }), process.env.NODE_ENV !== "production") {
          var et = uniqueBy([].concat(Q, z.options.modifiers), function(ht) {
            var dt = ht.name;
            return dt;
          });
          if (validateModifiers(et), getBasePlacement(z.options.placement) === auto) {
            var it = z.orderedModifiers.find(function(ht) {
              var dt = ht.name;
              return dt === "flip";
            });
            it || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var tt = getComputedStyle$1(G), nt = tt.marginTop, st = tt.marginRight, at = tt.marginBottom, ut = tt.marginLeft;
          [nt, st, at, ut].some(function(ht) {
            return parseFloat(ht);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return W(), Y.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!V) {
          var Z = z.elements, J = Z.reference, Q = Z.popper;
          if (!areValidElements(J, Q)) {
            process.env.NODE_ENV !== "production" && console.error(INVALID_ELEMENT_ERROR);
            return;
          }
          z.rects = {
            reference: getCompositeRect(J, getOffsetParent(Q), z.options.strategy === "fixed"),
            popper: getLayoutRect(Q)
          }, z.reset = !1, z.placement = z.options.placement, z.orderedModifiers.forEach(function(ht) {
            return z.modifiersData[ht.name] = Object.assign({}, ht.data);
          });
          for (var et = 0, it = 0; it < z.orderedModifiers.length; it++) {
            if (process.env.NODE_ENV !== "production" && (et += 1, et > 100)) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
            if (z.reset === !0) {
              z.reset = !1, it = -1;
              continue;
            }
            var tt = z.orderedModifiers[it], nt = tt.fn, st = tt.options, at = st === void 0 ? {} : st, ut = tt.name;
            typeof nt == "function" && (z = nt({
              state: z,
              options: at,
              name: ut,
              instance: Y
            }) || z);
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(K) {
          Y.forceUpdate(), K(z);
        });
      }),
      destroy: function() {
        q(), V = !0;
      }
    };
    if (!areValidElements($, G))
      return process.env.NODE_ENV !== "production" && console.error(INVALID_ELEMENT_ERROR), Y;
    Y.setOptions(U).then(function(K) {
      !V && U.onFirstUpdate && U.onFirstUpdate(K);
    });
    function W() {
      z.orderedModifiers.forEach(function(K) {
        var Z = K.name, J = K.options, Q = J === void 0 ? {} : J, et = K.effect;
        if (typeof et == "function") {
          var it = et({
            state: z,
            name: Z,
            instance: Y,
            options: Q
          }), tt = function() {
          };
          X.push(it || tt);
        }
      });
    }
    function q() {
      X.forEach(function(K) {
        return K();
      }), X = [];
    }
    return Y;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1], createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
const { GamepadListener } = require("gamepad.js");
var Ze, qi, Be, _l, yl, xf, bl, Sf, xl, Ef, Ta, wa, Sl, Tf, Me, xr, bi, xi, El, Ki, ws, Tl, wl, ze, Ca, Pa, Cl, ec, ip, Pl, qn, rc, np, Ml, wf, ic, sp, Rl, Cf, Kn, Za, Zn, nc, ap, sc, op, Sr, ac, lp, oc, up, Ma, yu, Si, Jn, Qn, lc, hp, Je;
class EventMng {
  constructor(t, e, r, D, N, k, $, G, U) {
    rt(this, yl);
    rt(this, bl);
    rt(this, xl);
    rt(this, Sl);
    rt(this, Ki);
    rt(this, ec);
    // イベントを全消去
    rt(this, rc);
    rt(this, Ml);
    // イベントを予約
    rt(this, ic);
    rt(this, Rl);
    rt(this, Kn);
    // 行末クリック待ち
    rt(this, nc);
    // 改ページクリック待ち
    rt(this, sc);
    rt(this, ac);
    // フォーカス移動
    rt(this, oc);
    // ウェイトを入れる
    rt(this, Ma);
    // クリックを待つ
    rt(this, lc);
    rt(this, Ze, new EventListenerCtn());
    rt(this, qi, new GamepadListener({
      analog: !1,
      deadZone: 0.3
    }));
    rt(this, Be, new FocusMng());
    rt(this, _l, (t) => {
    });
    rt(this, Ta, !1);
    rt(this, wa, !1);
    rt(this, Me, {});
    rt(this, xr, {});
    rt(this, bi, !1);
    rt(this, xi, !1);
    // 予約イベントの発生待ち中か
    rt(this, El, (t) => H(this, Me)[t] ?? H(this, xr)[t]);
    rt(this, Tl, () => {
      ot(this, Tl, () => {
      }), this.scrItr.firstWait();
    });
    rt(this, wl, {
      getBoundingClientRect: (t = 0, e = 0) => DOMRect.fromRect({ x: t, y: e, width: 0, height: 0 })
    });
    rt(this, ze, void 0);
    rt(this, Ca, void 0);
    rt(this, Pa, void 0);
    rt(this, Cl, {
      placement: "bottom",
      fallbackPlacements: ["top", "bottom"]
    });
    rt(this, Pl, (t, e) => {
    });
    rt(this, qn, new EventListenerCtn());
    rt(this, Zn, () => this.layMng.goTxt());
    // スキップ中断予約
    rt(this, Sr, () => !1);
    rt(this, Si, () => {
    });
    rt(this, Jn, new i$1());
    rt(this, Qn, "sn:notice_comp_txt");
    // 0:no push  1:one push  2:push repeating
    rt(this, Je, {
      Alt: 0,
      Meta: 0,
      // COMMANDキー
      Control: 0,
      ArrowDown: 0,
      End: 0,
      Enter: 0,
      Escape: 0,
      " ": 0,
      GoBack: 0
      // AndroidのBackキーだと思う
    });
    var q, K;
    if (this.cfg = t, this.hTag = e, this.appPixi = r, this.main = D, this.layMng = N, this.val = k, this.sndMng = $, this.scrItr = G, this.sys = U, e.clear_event = (Z) => lt(this, rc, np).call(this, Z), e.event = (Z) => lt(this, ic, sp).call(this, Z), e.l = (Z) => lt(this, nc, ap).call(this, Z), e.p = (Z) => lt(this, sc, op).call(this, Z), e.s = () => (G.recodePage(), lt(this, Ki, ws).call(this, () => {
    }, !1, !0)), e.set_cancel_skip = () => lt(this, ac, lp).call(this), e.set_focus = (Z) => lt(this, oc, up).call(this, Z), e.wait = (Z) => lt(this, Ma, yu).call(this, Z), e.waitclick = () => lt(this, lc, hp).call(this), $.setEvtMng(this), G.setOtherObj(this, N), TxtLayer.setEvtMng(D, this, U), N.setEvtMng(this), U.setFire((Z, J) => this.fire(Z, J)), CmnLib.isDbg) {
      const Z = {
        pause: () => {
          if (ot(this, bi, !0), !H(this, xi))
            return;
          const J = {};
          G.recodeDesign(J), U.callHook("_enterDesign", J), U.send2Dbg("_enterDesign", J);
        },
        stopOnBreakpoint: () => ot(this, bi, !0),
        stopOnDataBreakpoint: () => ot(this, bi, !0),
        continue: () => ot(this, bi, !1),
        disconnect: () => ot(this, bi, !1)
      };
      Z.attach = Z.stopOnEntry = Z.stopOnStep = Z.stopOnStepIn = Z.stopOnStepOut = Z.stopOnBackstep = Z.pause, U.addHook((J) => {
        var Q;
        return (Q = Z[J]) == null ? void 0 : Q.call(Z);
      });
    }
    addStyle(`
.sn_hint {
	background-color: #3c3225;
	color: white;
	padding: 4px 8px;
	border-radius: 4px;
	font-size: 1.2em;
	z-index: 10000;
	pointer-events: none;
	user-select: none;
}

.sn_hint_ar,
.sn_hint_ar::before {
	position: absolute;
	width: 8px;
	height: 8px;
	background: inherit;
}
.sn_hint_ar {
	visibility: hidden;
}
.sn_hint_ar::before {
	visibility: visible;
	content: '';
	transform: rotate(45deg);
}

.sn_hint[data-popper-placement^='top']		> .sn_hint_ar {bottom: -4px;}
.sn_hint[data-popper-placement^='bottom']	> .sn_hint_ar {top: -4px;}
.sn_hint[data-popper-placement^='left']		> .sn_hint_ar {right: -4px;}
.sn_hint[data-popper-placement^='right']	> .sn_hint_ar {left: -4px;}
`);
    for (const Z of Array.from(document.getElementsByClassName("sn_hint")))
      (q = Z.parentElement) == null || q.removeChild(Z);
    (K = Main.cvs.parentElement) == null || K.insertAdjacentHTML("beforeend", `
<div class="sn_hint" role="tooltip">
	<span>Dummy</span>
	<div class="sn_hint_ar" data-popper-arrow></div>
</div>`), ot(this, ze, document.querySelector(".sn_hint")), ot(this, Ca, H(this, ze).querySelector("span")), ot(this, Pa, createPopper(H(this, wl), H(this, ze))), H(this, ze).hidden = !0, r.stage.interactive = !0, CmnLib.isMobile ? r.stage.on("pointerdown", (Z) => this.fire("click", Z)) : H(this, Ze).add(r.stage, "pointerdown", (Z) => {
      switch (Z.data.button) {
        case 0:
          this.fire("click", Z);
          break;
        case 1:
          this.fire("middleclick", Z);
          break;
      }
    }), H(this, Ze).add(window, "keydown", (Z) => lt(this, yl, xf).call(this, Z)), H(this, Ze).add(Main.cvs, "contextmenu", (Z) => lt(this, bl, Sf).call(this, Z));
    const z = () => k.setVal_Nochk("tmp", "const.sn.navigator.language", navigator.language);
    H(this, Ze).add(window, "languagechange", (Z) => {
      z(), this.fire("sn:chgNavLang", Z), clearTextureCache();
    }), z();
    const X = (Z) => {
      CmnLib.isDarkMode = Z.matches, k.setVal_Nochk("tmp", "const.sn.isDarkMode", CmnLib.isDarkMode);
    }, V = globalThis.matchMedia("(prefers-color-scheme: dark)");
    X(V), H(this, Ze).add(V, "change", (Z) => {
      X(Z), this.fire("sn:chgDarkMode", Z);
    }), "WheelEvent" in window && (H(this, Ze).add(Main.cvs, "wheel", (Z) => lt(this, xl, Ef).call(this, Z), { passive: !0 }), ot(this, _l, (Z) => H(this, Ze).add(Z, "wheel", (J) => lt(this, xl, Ef).call(this, J), { passive: !0 })), ot(this, Pl, (Z, J) => Z.add(Main.cvs, "wheel", (Q) => {
      Q.isComposing || Q.deltaY <= 0 || (Q.stopPropagation(), J());
    }))), CmnLib.debugLog && (H(this, qi).on("gamepad:connected", (Z) => console.log(`👺<'gamepad:connected' index:${Z.detail.index} id:${Z.detail.gamepad.id}`)), H(this, qi).on("gamepad:disconnected", (Z) => console.log(`👺<'gamepad:disconnected' index:${Z.detail.index} id:${Z.detail.gamepad.id}`)));
    const Y = [
      "",
      "ArrowUp",
      "",
      // '7', '8', '9',
      "ArrowLeft",
      "",
      "ArrowRight",
      // '4', '5', '6',
      "",
      "ArrowDown",
      ""
      // '1', '2', '3',
    ], W = [0, 0];
    H(this, qi).on("gamepad:axis", (Z) => {
      if (!document.hasFocus() || Z.detail.stick !== 0)
        return;
      W[Z.detail.axis] = Z.detail.value;
      const J = (W[1] + 1) * 3 + (W[0] + 1), Q = Y[J];
      if (!Q)
        return;
      const et = H(this, Be).getFocus();
      (!et || et instanceof Container ? globalThis : et).dispatchEvent(new KeyboardEvent("keydown", { key: Q, bubbles: !0 })), !(!et || et instanceof Container) && et.getAttribute("type") === "range" && et.dispatchEvent(new InputEvent("input", { bubbles: !0 }));
    }), H(this, qi).on("gamepad:button", (Z) => {
      if (document.hasFocus())
        if (Z.detail.button % 2 === 0) {
          const J = H(this, Be).getFocus();
          (!J || J instanceof Container ? globalThis : J).dispatchEvent(new KeyboardEvent("keydown", { key: "Enter", bubbles: !0 }));
        } else
          Main.cvs.dispatchEvent(new Event("contextmenu"));
    }), H(this, qi).start(), H(this, Ze).add(window, "keyup", (Z) => {
      Z.isComposing || Z.key in H(this, Je) && (H(this, Je)[Z.key] = 0);
    }), k.defTmp("const.sn.key.alternate", () => H(this, Je).Alt > 0), k.defTmp("const.sn.key.command", () => H(this, Je).Meta > 0), k.defTmp("const.sn.key.control", () => H(this, Je).Control > 0), k.defTmp("const.sn.key.end", () => H(this, Je).End > 0), k.defTmp("const.sn.key.escape", () => H(this, Je).Escape > 0), k.defTmp("const.sn.key.back", () => H(this, Je).GoBack > 0);
  }
  resvFlameEvent(t) {
    H(this, Ze).add(t, "keydown", (e) => lt(this, yl, xf).call(this, e)), H(this, Ze).add(t, "contextmenu", (e) => lt(this, bl, Sf).call(this, e)), H(this, _l).call(this, t);
  }
  destroy() {
    H(this, Be).destroy(), H(this, Ze).clear();
  }
  fire(t, e) {
    var N;
    if (H(this, Sr).call(this) || !H(this, xi) || H(this, bi))
      return;
    const r = t.toLowerCase();
    if (CmnLib.debugLog && console.log(`👺 fire<(key:\`${r}\` type:${e.type} e:%o)`, { ...e }), r === "enter") {
      const k = H(this, Be).getFocus();
      if (k instanceof Container) {
        k.emit("pointerdown", new Event("pointerdown"));
        return;
      }
    }
    const D = H(this, El).call(this, r);
    if (!D) {
      r.slice(0, 5) === "swipe" && globalThis.scrollBy(
        -e.deltaX,
        -e.deltaY
      );
      return;
    }
    r.slice(-5) !== "wheel" && ((N = e.preventDefault) == null || N.call(e)), e.stopPropagation(), !(r.slice(0, 4) !== "dom=" && this.layMng.clickTxtLay()) && (ot(this, xi, !1), D(e));
  }
  popLocalEvts() {
    const t = H(this, Me);
    return ot(this, Me, {}), t;
  }
  pushLocalEvts(t) {
    ot(this, Me, t);
  }
  waitEvent(t, e = !0, r = !1) {
    if (e && r)
      throw "canskipとglobalを同時にtrue指定できません";
    if (this.val.getVal("tmp:sn.skip.enabled")) {
      if (this.val.getVal("tmp:sn.skip.all") || this.scrItr.isNextKidoku)
        return t(), !1;
      H(this, Sr).call(this);
    }
    return lt(this, Ki, ws).call(this, t, e, r);
  }
  unButton(t) {
    H(this, Be).remove(t);
  }
  button(t, e, r, D, N) {
    var X;
    !t.fn && !t.label && this.main.errScript("fnまたはlabelは必須です"), e.interactive = e.buttonMode = !0;
    const k = ((X = t.key) == null ? void 0 : X.toLowerCase()) ?? " ";
    t.fn || (t.fn = this.scrItr.scriptFn);
    const $ = argChk_Boolean(t, "global", !1);
    $ ? H(this, xr)[k] = () => this.main.resumeByJumpOrCall(t) : H(this, Me)[k] = () => this.main.resumeByJumpOrCall(t), e.on("pointerdown", (V) => this.fire(k, V));
    const G = t.hint ? () => lt(this, ec, ip).call(this, t, e) : () => {
    }, U = () => {
      r(), H(this, ze).hidden = !0;
    }, z = () => (G(), D());
    if (e.on("pointerover", z), e.on("pointerout", () => {
      H(this, Be).isFocus(e) ? z() : U();
    }), e.on("pointerdown", () => {
      H(this, ze).hidden = !0;
      const V = H(this, Be).getFocus();
      N(), V instanceof Button && V.normal();
    }), e.on(
      "pointerup",
      CmnLib.isMobile ? U : () => {
        H(this, Be).isFocus(e) ? z() : U();
      }
    ), H(this, Be).add(e, z, U), t.clickse && (this.cfg.searchPath(t.clickse, SEARCH_PATH_ARG_EXT.SOUND), e.on("pointerdown", () => {
      const V = { fn: t.clickse, join: !1 };
      t.clicksebuf && (V.buf = t.clicksebuf), this.hTag.playse(V);
    })), t.enterse && (this.cfg.searchPath(t.enterse, SEARCH_PATH_ARG_EXT.SOUND), e.on("pointerover", () => {
      const V = { fn: t.enterse, join: !1 };
      t.entersebuf && (V.buf = t.entersebuf), this.hTag.playse(V);
    })), t.leavese && (this.cfg.searchPath(t.leavese, SEARCH_PATH_ARG_EXT.SOUND), e.on("pointerout", () => {
      const V = { fn: t.leavese, join: !1 };
      t.leavesebuf && (V.buf = t.leavesebuf), this.hTag.playse(V);
    })), t.onenter) {
      const V = k + t.onenter.toLowerCase(), Y = { fn: t.fn, label: t.onenter, call: !0, key: V };
      $ ? H(this, xr)[V] = () => this.main.resumeByJumpOrCall(Y) : H(this, Me)[V] = () => this.main.resumeByJumpOrCall(Y), e.on("pointerover", (W) => this.fire(V, W));
    }
    if (t.onleave) {
      const V = k + t.onleave.toLowerCase(), Y = { fn: t.fn, label: t.onleave, call: !0, key: V };
      $ ? H(this, xr)[V] = () => this.main.resumeByJumpOrCall(Y) : H(this, Me)[V] = () => this.main.resumeByJumpOrCall(Y), e.on("pointerout", (W) => this.fire(V, W));
    }
  }
  hideHint() {
    H(this, ze).hidden = !0;
  }
  cvsResize() {
    H(this, ze).hidden = !0;
  }
  // 予約イベントの発生待ちしない waitEvent()
  waitLimitedEvent(t, e) {
    H(this, Zn).call(this), this.val.saveKidoku();
    const r = () => {
      H(this, qn).clear(), e();
    };
    if (this.val.getVal("tmp:sn.skip.enabled"))
      if (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
      !this.scrItr.isNextKidoku)
        H(this, Sr).call(this);
      else
        return r(), !1;
    return argChk_Boolean(t, "canskip", !0) && (H(this, qn).add(window, "pointerdown", (D) => {
      D.stopPropagation(), r();
    }), H(this, qn).add(window, "keydown", (D) => {
      D.isComposing || (D.stopPropagation(), r());
    }), H(this, Pl).call(this, H(this, qn), r)), !0;
  }
  noticeCompTxt() {
    H(this, Jn).emit(H(this, Qn));
  }
  // キー押下によるスキップ中か
  isSkippingByKeyDown() {
    return this.scrItr.skip4page ? !0 : Object.keys(H(this, Je)).some((t) => H(this, Je)[t] === 2);
  }
}
Ze = new WeakMap(), qi = new WeakMap(), Be = new WeakMap(), _l = new WeakMap(), yl = new WeakSet(), xf = function(t) {
  if (t.isComposing)
    return;
  t.key in H(this, Je) && (H(this, Je)[t.key] = t.repeat ? 2 : 1);
  const e = (t.altKey ? t.key === "Alt" ? "" : "alt+" : "") + (t.ctrlKey ? t.key === "Control" ? "" : "ctrl+" : "") + (t.shiftKey ? t.key === "Shift" ? "" : "shift+" : "") + t.key;
  this.fire(e, t);
}, bl = new WeakSet(), Sf = function(t) {
  const e = (t.altKey ? t.key === "Alt" ? "" : "alt+" : "") + (t.ctrlKey ? t.key === "Control" ? "" : "ctrl+" : "") + (t.shiftKey ? t.key === "Shift" ? "" : "shift+" : "") + "rightclick";
  this.fire(e, t), t.preventDefault();
}, xl = new WeakSet(), Ef = function(t) {
  if (t.isComposing)
    return;
  if (H(this, Ta)) {
    ot(this, wa, !0);
    return;
  }
  ot(this, Ta, !0), lt(this, Sl, Tf).call(this);
  const e = (t.altKey ? "alt+" : "") + (t.ctrlKey ? "ctrl+" : "") + (t.shiftKey ? "shift+" : "") + (t.deltaY > 0 ? "downwheel" : "upwheel");
  this.fire(e, t);
}, Ta = new WeakMap(), wa = new WeakMap(), Sl = new WeakSet(), Tf = function() {
  setTimeout(() => {
    if (H(this, wa)) {
      ot(this, wa, !1), lt(this, Sl, Tf).call(this);
      return;
    }
    ot(this, Ta, !1);
  }, 250);
}, Me = new WeakMap(), xr = new WeakMap(), bi = new WeakMap(), xi = new WeakMap(), El = new WeakMap(), Ki = new WeakSet(), ws = function(t, e = !0, r = !0) {
  if (H(this, Zn).call(this), this.val.saveKidoku(), e ? H(this, Me).click = //this.hTag.event({key:'enter', breakout: fnc});
  //hTag.event({key:'down', breakout: fnc});
  //	hTag.event()は内部で使わず、こうする
  H(this, Me).enter = H(this, Me).arrowdown = // hTag.event({key:'downwheel', breakout: fnc});
  //	hTag.event()は内部で使わず、こうする
  H(this, Me)["wheel.y>0"] = t : (delete H(this, Me).click, delete H(this, Me).enter, delete H(this, Me).arrowdown, delete H(this, Me)["wheel.y>0"]), ot(this, El, r ? (D) => H(this, Me)[D] ?? H(this, xr)[D] : (D) => H(this, Me)[D]), ot(this, xi, !0), H(this, Tl).call(this), CmnLib.debugLog) {
    const D = /* @__PURE__ */ Object.create(null);
    D.local = Object.keys(H(this, Me)), D.global = Object.keys(H(this, xr)), console.log("🎍 wait event... %o", D);
  }
  return !0;
}, Tl = new WeakMap(), wl = new WeakMap(), ze = new WeakMap(), Ca = new WeakMap(), Pa = new WeakMap(), Cl = new WeakMap(), ec = new WeakSet(), ip = function(t, e) {
  const r = e instanceof Button ? e.getBtnBounds() : e.getBounds();
  if (!(t[":タグ名"] === "link")) {
    const N = e.parent.parent;
    r.x += N.x, r.y += N.y;
  }
  if (!t.hint) {
    H(this, ze).hidden = !0;
    return;
  }
  H(this, ze).style.cssText = `position:${H(this, ze).style.position}; transform:${H(this, ze).style.transform};` + (t.hint_style ?? ""), H(this, Ca).style.cssText = "", H(this, Ca).textContent = t.hint ?? "";
  try {
    const N = t.hint_opt ? { ...H(this, Cl), ...JSON.parse(t.hint_opt) } : H(this, Cl);
    H(this, Pa).setOptions(N);
  } catch (N) {
    console.error(mesErrJSON(t, "hint_opt", N.message));
  }
  H(this, wl).getBoundingClientRect = () => DOMRect.fromRect({
    x: this.sys.ofsLeft4elm + r.x * this.sys.cvsScale,
    y: this.sys.ofsTop4elm + r.y * this.sys.cvsScale,
    width: r.width,
    height: r.height
  }), H(this, Pa).update(), H(this, ze).hidden = !1;
}, Pl = new WeakMap(), qn = new WeakMap(), rc = new WeakSet(), np = function(t) {
  const e = argChk_Boolean(t, "global", !1), r = e ? H(this, xr) : H(this, Me);
  for (const [D, N] of Object.entries(r))
    lt(this, Ml, wf).call(this, D, N);
  return e ? ot(this, xr, {}) : ot(this, Me, {}), ot(this, xi, !1), !1;
}, Ml = new WeakSet(), wf = function(t, e) {
  t.slice(0, 4) === "dom=" && lt(this, Kn, Za).call(this, t).el.forEach((r) => r.removeEventListener("click", e));
}, ic = new WeakSet(), sp = function(t) {
  const e = t.key;
  if (!e)
    throw "keyは必須です";
  const r = e.toLowerCase(), D = argChk_Boolean(t, "call", !1), N = argChk_Boolean(t, "global", !1) ? H(this, xr) : H(this, Me);
  if (argChk_Boolean(t, "del", !1)) {
    if (t.fn || t.label || D)
      throw "fn/label/callとdelは同時指定できません";
    return lt(this, Ml, wf).call(this, e, N[r]), delete N[r], !1;
  }
  if (t.fn ?? (t.fn = this.scrItr.scriptFn), e.slice(0, 4) === "dom=") {
    const k = lt(this, Kn, Za).call(this, e);
    if (k.el.length === 0) {
      if (argChk_Boolean(t, "need_err", !0))
        throw `HTML内にセレクタ（${k.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;
      return !1;
    }
    let $ = ["click", "keydown"];
    switch (k.el[0].type ?? "") {
      case "checkbox":
        $ = ["input"];
        break;
      case "range":
        $ = ["input"];
        break;
      case "text":
      case "textarea":
        $ = ["input", "change"];
        break;
    }
    $.forEach((U, z) => k.el.forEach((X) => {
      H(this, Ze).add(X, U, (V) => {
        if (!H(this, xi) || this.layMng.getFrmDisabled(k.id) || U === "keydown" && V.key !== "Enter")
          return;
        const Y = X.dataset;
        for (const [W, q] of Object.entries(Y))
          this.val.setVal_Nochk("tmp", `sn.event.domdata.${W}`, q);
        this.fire(e, V);
      }), z === 0 && H(this, Be).add(
        X,
        () => lt(this, Rl, Cf).call(this, X) ? (X.focus(), !0) : !1,
        () => {
        }
      );
    }));
  }
  return N[r] = () => this.main.resumeByJumpOrCall(t), !1;
}, Rl = new WeakSet(), Cf = function(t) {
  if (t.offsetParent === null)
    return !1;
  let e = t;
  do {
    if (getComputedStyle(e).display === "none" || e.dataset.focus === "false" || e != null && e.disabled)
      return !1;
    e = e.parentElement;
  } while (e !== null);
  return !0;
}, Kn = new WeakSet(), Za = function(t) {
  const e = t.indexOf(":");
  let r = "";
  if (e >= 0) {
    const D = t.slice(4, e), N = `const.sn.frm.${D}`;
    if (!this.val.getVal(`tmp:${N}`, 0))
      throw `HTML【${D}】が読み込まれていません`;
    const $ = document.getElementById(D).contentWindow;
    return r = t.slice(e + 1), { el: $.document.querySelectorAll(r), id: D, sel: r };
  }
  return r = t.slice(4), { el: document.querySelectorAll(r), id: "", sel: r };
}, Zn = new WeakMap(), nc = new WeakSet(), ap = function(t) {
  if (this.scrItr.skip4page)
    return !1;
  if (!this.val.getVal("tmp:sn.tagL.enabled"))
    return H(this, Zn).call(this), !1;
  if (this.val.getVal("tmp:sn.skip.enabled")) {
    if (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
    !this.scrItr.isNextKidoku)
      H(this, Sr).call(this);
    else if ("ps".includes(this.val.getVal("sys:sn.skip.mode")))
      return !1;
  }
  return this.val.getVal("tmp:sn.auto.enabled") ? lt(this, Ma, yu).call(this, {
    time: Number(this.scrItr.isKidoku ? this.val.getVal("sys:sn.auto.msecLineWait_Kidoku") : this.val.getVal("sys:sn.auto.msecLineWait"))
  }) : (argChk_Boolean(t, "visible", !0) && this.layMng.breakLine(), lt(this, Ki, ws).call(this, () => this.main.resume()));
}, sc = new WeakSet(), op = function(t) {
  if (this.scrItr.recodePage(), this.val.getVal("tmp:sn.skip.enabled")) {
    if (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
    !this.scrItr.isNextKidoku)
      H(this, Sr).call(this);
    else if (this.val.getVal("sys:sn.skip.mode") == "s")
      return H(this, Zn).call(this), !1;
  }
  if (this.val.getVal("tmp:sn.auto.enabled"))
    return lt(this, Ma, yu).call(this, {
      time: Number(this.scrItr.isKidoku ? this.val.getVal("sys:sn.auto.msecPageWait_Kidoku") : this.val.getVal("sys:sn.auto.msecPageWait"))
    });
  argChk_Boolean(t, "visible", !0) && this.layMng.breakPage();
  const e = () => {
    this.sndMng.clearCache(), this.main.resume();
  };
  return lt(this, Ki, ws).call(this, argChk_Boolean(t, "er", !1) && this.layMng.currentTxtlayFore ? () => {
    this.hTag.er(t), e();
  } : e);
}, Sr = new WeakMap(), ac = new WeakSet(), lp = function() {
  return ot(this, Sr, () => (ot(this, Sr, () => !1), this.val.setVal_Nochk("tmp", "sn.tagL.enabled", !0), this.val.setVal_Nochk("tmp", "sn.skip.enabled", !1), this.val.setVal_Nochk("tmp", "sn.auto.enabled", !1), this.layMng.setNormalChWait(), H(this, Si).call(this), !0)), !1;
}, oc = new WeakSet(), up = function(t) {
  const { add: e, del: r, to: D } = t;
  if ((e == null ? void 0 : e.slice(0, 4)) === "dom=") {
    const N = lt(this, Kn, Za).call(this, e);
    if (N.el.length === 0 && argChk_Boolean(t, "need_err", !0))
      throw `HTML内にセレクタ（${N.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;
    return N.el.forEach((k) => H(this, Be).add(
      k,
      () => lt(this, Rl, Cf).call(this, k) ? (k.focus(), !0) : !1,
      () => {
      }
    )), !1;
  }
  if ((r == null ? void 0 : r.slice(0, 4)) === "dom=") {
    const N = lt(this, Kn, Za).call(this, r);
    if (N.el.length === 0 && argChk_Boolean(t, "need_err", !0))
      throw `HTML内にセレクタ（${N.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;
    return N.el.forEach((k) => H(this, Be).remove(k)), !1;
  }
  if (!D)
    throw "[set_focus] add か to は必須です";
  switch (D) {
    case "null":
      H(this, Be).blur();
      break;
    case "next":
      H(this, Be).next();
      break;
    case "prev":
      H(this, Be).prev();
      break;
  }
  return !1;
}, Ma = new WeakSet(), yu = function(t) {
  const e = argChk_Num(t, "time", NaN);
  return this.scrItr.skip4page ? !1 : this.val.getVal("tmp:sn.skip.enabled") ? (!this.val.getVal("tmp:sn.skip.all") && // 未読で停止
  !this.scrItr.isNextKidoku && H(this, Sr).call(this), !1) : (H(this, Jn).once(H(this, Qn), () => {
    H(this, Jn).off(H(this, Qn));
    const r = new Tween({}).to({}, e).onComplete(() => {
      ot(this, Si, () => {
      }), r.stop(), this.main.resume();
    }).start();
    ot(this, Si, () => r.end());
  }), ot(this, Si, () => {
    ot(this, Si, () => {
    }), H(this, Jn).off(H(this, Qn));
  }), this.waitEvent(
    () => H(this, Si).call(this),
    argChk_Boolean(t, "canskip", !0),
    // スキップ中は利かない
    argChk_Boolean(t, "global", !1)
  ));
}, Si = new WeakMap(), Jn = new WeakMap(), Qn = new WeakMap(), lc = new WeakSet(), hp = function() {
  return this.scrItr.skip4page ? !1 : ((this.val.getVal("tmp:sn.skip.enabled") || this.val.getVal("tmp:sn.auto.enabled")) && H(this, Sr).call(this), lt(this, Ki, ws).call(this, () => this.main.resume()));
}, Je = new WeakMap();
class CallStack {
  constructor(t = "", e = 0, r = { ":hEvt1Time": {}, ":hMp": {} }) {
    It(this, "toString", () => `[fn:${this.fn}, idx:${this.idx}, csArg:${this.csArg}]`);
    this.fn = t, this.idx = e, this.csArg = r;
  }
}
var oe, ce, Xt, xe, me, Ei, Ol, Pf, ts, Zi, uc, Ji, Il, Mf, Dl, Rf, Al, Qi, Cs, es, Ja, rs, Ti, Re, hc, cp, is, Qa, cc, fp, Nl, Ra, fr, fc, dp, dc, pp, wi, an, pc, vp, ns, ss, kl, Ll, Bl, dr, vc, gp, gc, mp, mc, _p, Fl, Of, yc, yp, bc, bp, xc, xp, $l, If, Gl, as, to, os, Ci, ln, Ul, Df, jl, zl, Af, Sc, Ec, Hl, Tc, Sp, Ge, wc, Ep, Vl, Nf, Cc, Pc, Mc, Tp, Rc, wp, Pi, Xl, kf, Oc, Cp, Ic, Pp, Dc, Ac, Mp, Yl, Oa, Nc, Rp, Ia, bu, Da, kc, Op, kr, Lc, Ip, Aa, xu, Bc, Dp, Lr, Ue;
const ar = class {
  constructor(t, e, r, D, N, k, $, G, U) {
    rt(this, Ol);
    rt(this, Il);
    rt(this, Dl);
    rt(this, Qi);
    rt(this, es);
    rt(this, hc);
    rt(this, is);
    rt(this, cc);
    //	//	変数操作
    // インラインテキスト代入
    rt(this, fc);
    //	// デバッグ・その他
    // スタックのダンプ
    rt(this, dc);
    rt(this, wi);
    // 外部へスクリプトを表示
    rt(this, pc);
    // FIFOバッファ（push/unshift）
    rt(this, vc);
    rt(this, gc);
    //	// ラベル・ジャンプ
    // サブルーチンコール
    rt(this, mc);
    rt(this, Fl);
    // シナリオジャンプ
    rt(this, yc);
    // ページ移動
    rt(this, bc);
    // コールスタック破棄
    rt(this, xc);
    // サブルーチンから戻る
    rt(this, $l);
    rt(this, as);
    rt(this, Ci);
    // 初期化前に終了した場合向け
    rt(this, Ul);
    rt(this, zl);
    rt(this, Tc);
    //{} シナリオキャッシュ
    rt(this, wc);
    rt(this, Vl);
    rt(this, Mc);
    rt(this, Rc);
    rt(this, Xl);
    //	// マクロ
    // 括弧マクロの定義
    rt(this, Oc);
    // 一文字マクロの定義
    rt(this, Ic);
    rt(this, Ac);
    // https://regex101.com/r/Lk9ASK/1
    //	// しおり
    // しおりの読込
    rt(this, Nc);
    rt(this, Ia);
    // スクリプト再読込
    rt(this, kc);
    rt(this, Lc);
    rt(this, Aa);
    // しおりの保存
    rt(this, Bc);
    rt(this, oe, { aToken: [""], len: 1, aLNum: [1] });
    rt(this, ce, "");
    rt(this, Xt, 0);
    rt(this, xe, 0);
    It(this, "addLineNum", (t) => ot(this, xe, H(this, xe) + t));
    rt(this, me, []);
    // FILOバッファ（push/pop）
    rt(this, Ei, new Grammar());
    It(this, "firstWait", () => {
    });
    rt(this, ts, {
      //auth: // constructorで
      //launch:	// ここでは冒頭停止に間に合わないのでanalyzeInit()で
      disconnect: () => {
        ot(ar, rs, {}), ot(ar, Ti, {}), this.isBreak = () => !1, H(this, ts).continue({}), ot(this, Re, 0);
      },
      restart: () => this.isBreak = () => !1,
      // ブレークポイント登録
      add_break: (t) => lt(this, Ol, Pf).call(this, t.fn, t.o),
      data_break: (t) => {
        H(this, Re) === 0 && (ot(this, Re, 1), this.main.setLoop(!1, `変数 ${t.dataId}【${t.old_v}】→【${t.new_v}】データブレーク`), this.sys.callHook("stopOnDataBreakpoint", {}), this.sys.send2Dbg("stopOnDataBreakpoint", {}));
      },
      set_func_break: (t) => {
        ot(ar, Ti, {});
        for (const e of t.a)
          H(ar, Ti)[e.name] = 1;
        this.sys.send2Dbg(t.ri, {});
      },
      // 情報問い合わせ系
      stack: (t) => this.sys.send2Dbg(t.ri, { a: lt(this, cc, fp).call(this) }),
      eval: (t) => {
        this.sys.send2Dbg(t.ri, { v: this.prpPrs.parse(t.txt) });
      },
      // デバッガからの操作系
      continue: () => {
        lt(this, es, Ja).call(this) || (ot(this, Xt, H(this, Xt) - H(this, Qi, Cs)), ot(this, Re, 3), this.main.setLoop(!0), this.main.resume());
      },
      stepover: (t) => lt(this, Il, Mf).call(this, t),
      stepin: () => {
        if (lt(this, es, Ja).call(this))
          return;
        const t = H(this, oe).aToken[H(this, Xt) - H(this, Qi, Cs)];
        this.sys.callHook(`stopOnStep${H(this, Oa).test(t) ? "In" : ""}`, {}), ot(this, Xt, H(this, Xt) - H(this, Qi, Cs)), ot(this, Re, H(this, Re) === 1 ? 4 : 5), this.main.setLoop(!0), this.main.resume();
      },
      stepout: (t) => {
        lt(this, es, Ja).call(this) || (H(this, me).length > 0 ? lt(this, Dl, Rf).call(this, !0) : lt(this, Il, Mf).call(this, t));
      },
      pause: () => {
        ot(this, Re, 4), this.main.setLoop(!1, "一時停止"), this.sys.send2Dbg("stopOnStep", {});
      },
      stopOnEntry: () => {
        ot(this, Re, 4), this.main.setLoop(!1, "一時停止"), this.sys.send2Dbg("stopOnEntry", {});
      }
    });
    rt(this, Zi, (t) => this.cfg.searchPath(t, SEARCH_PATH_ARG_EXT.SCRIPT));
    // https://regex101.com/r/Km54EK/1 141 steps (~0ms)
    rt(this, Ji, (t) => (this.sys.pathBaseCnvSnPath4Dbg + H(this, Zi).call(this, t)).replace(H(ar, uc), `$1/prj/$2/${H(this, ce)}$3`));
    It(this, "cnvPath4Dbg", (t) => this.sys.pathBaseCnvSnPath4Dbg + t.replace("/crypto_prj/", "/prj/"));
    rt(this, Al, 0);
    rt(this, Re, 0);
    // https://raw.githubusercontent.com/famibee/SKYNovel-vscode-extension/master/src/doc/BreakStateSMD.pu
    It(this, "isBreak", (t) => !1);
    // result = true : waitする  resume()で再開
    rt(this, Nl, (t) => {
    });
    rt(this, Ra, void 0);
    rt(this, fr, void 0);
    rt(this, ns, () => {
    });
    rt(this, ss, () => {
    });
    rt(this, kl, "");
    rt(this, Ll, {});
    It(this, "noticeBreak", (t) => {
    });
    rt(this, Bl, 5);
    //	// 条件分岐
    rt(this, dr, [-1]);
    rt(this, Gl, "");
    rt(this, os, "");
    // シナリオ解析処理ループ・冒頭処理
    It(this, "nextToken", () => "");
    rt(this, jl, (t) => {
    });
    rt(this, Sc, /(\*{2,})([^\|]*)/);
    rt(this, Ec, /\[macro\s/);
    rt(this, Hl, /\[endmacro[\s\]]/);
    rt(this, Ge, /* @__PURE__ */ Object.create(null));
    rt(this, Cc, /^\[(call|loadplugin)\s/);
    rt(this, Pc, /\bfn\s*=\s*[^\s\]]+/);
    rt(this, Pi, !1);
    // マクロ定義の開始
    rt(this, Dc, new RegExp(`["'#;\\]　]+`));
    rt(this, Yl, "call");
    rt(this, Oa, /\[(call)\b/);
    rt(this, Da, !1);
    // セーブポイント指定
    rt(this, kr, {
      hSave: {},
      hPages: {},
      aIfStk: [-1]
    });
    rt(this, Lr, []);
    rt(this, Ue, -1);
    this.cfg = t, this.hTag = e, this.main = r, this.val = D, this.alzTagArg = N, this.runAnalyze = k, this.prpPrs = $, this.sndMng = G, this.sys = U, e.let_ml = (X) => lt(this, fc, dp).call(this, X), e.endlet_ml = () => !1, e.dump_stack = () => lt(this, dc, pp).call(this), e.dump_script = (X) => lt(this, pc, vp).call(this, X), e.else = // その他ifブロック開始
    e.elsif = // 別条件のifブロック開始
    e.endif = () => lt(this, vc, gp).call(this), e.if = (X) => lt(this, gc, mp).call(this, X), e.call = (X) => lt(this, mc, _p).call(this, X), e.jump = (X) => lt(this, yc, yp).call(this, X), e.page = (X) => lt(this, bc, bp).call(this, X), e.pop_stack = (X) => lt(this, xc, xp).call(this, X), e.return = (X) => lt(this, $l, If).call(this, X), e.bracket2macro = (X) => lt(this, Oc, Cp).call(this, X), e.char2macro = (X) => lt(this, Ic, Pp).call(this, X), e.endmacro = (X) => lt(this, $l, If).call(this, X), e.macro = (X) => lt(this, Ac, Mp).call(this, X), e.load = (X) => lt(this, Nc, Rp).call(this, X), e.reload_script = (X) => lt(this, kc, Op).call(this, X), e.record_place = () => lt(this, Lc, Ip).call(this), e.save = (X) => lt(this, Bc, Dp).call(this, X), t.oCfg.debug.token && ot(this, jl, (X) => console.log(`🌱 トークン fn:${H(this, ce)} idx:${H(this, Xt)} ln:${H(this, xe)} token【${X}】`)), D.defTmp("const.sn.vctCallStk.length", () => H(this, me).length);
    const z = t.oCfg.init.escape;
    if (H(this, Ei).setEscape(z), RubySpliter.setEscape(z), CmnLib.isDbg) {
      U.addHook((V, Y) => {
        var W, q;
        return (q = (W = H(this, ts))[V]) == null ? void 0 : q.call(W, Y);
      }), this.isBreak = lt(this, hc, cp);
      const X = this.analyzeInit;
      this.analyzeInit = () => {
        this.analyzeInit = () => {
        }, this.sys.send2Dbg("hi", {});
      }, H(this, ts).auth = (V) => {
        const Y = V.hBreakpoint.hFn2hLineBP;
        for (const [W, q] of Object.entries(Y))
          lt(this, Ol, Pf).call(this, W, q);
        ot(ar, Ti, {});
        for (const W of V.hBreakpoint.aFunc)
          H(ar, Ti)[W.name] = 1;
        if (V.stopOnEntry) {
          for (; ; ) {
            let W = this.nextToken();
            if (!W)
              break;
            const q = W.charCodeAt(0);
            if (q === 91 || q === 38 || q === 42 && W.length === 1)
              break;
            q === 10 && ot(this, xe, H(this, xe) + W.length);
          }
          this.sys.callHook("stopOnEntry", {}), this.analyzeInit = X, this.analyzeInit();
        } else
          this.firstWait = () => {
            this.sys.callHook("stopOnEntry", {});
          }, this.analyzeInit = X, this.analyzeInit();
      };
    } else
      this.recodeDesign = () => {
      };
    t.oCfg.debug.tag && ot(this, Nl, (X) => console.log(`🌲 タグ解析 fn:${H(this, ce)} idx:${H(this, Xt)} ln:${H(this, xe)} [${X} %o]`, this.alzTagArg.hPrm));
  }
  get scriptFn() {
    return H(this, ce);
  }
  subIdxToken() {
    --Ie(this, Xt)._;
  }
  get lineNum() {
    return H(this, xe);
  }
  destroy() {
    this.isBreak = () => !1;
  }
  タグ解析(t) {
    const [e, r] = tagToken2Name_Args(t), D = this.hTag[e];
    if (!D)
      throw `未定義のタグ【${e}】です`;
    this.alzTagArg.parse(r), H(this, Nl).call(this, e);
    const N = this.alzTagArg.hPrm;
    if (N.cond) {
      const G = N.cond.val;
      if (!G || G.at(0) === "&")
        throw "属性condは「&」が不要です";
      const U = this.prpPrs.parse(G), z = String(U);
      if (z === "null" || z === "undefined" || !U)
        return !1;
    }
    let k = {};
    const $ = H(this, me).length;
    if (this.alzTagArg.isKomeParam) {
      if ($ === 0)
        throw "属性「*」はマクロのみ有効です";
      k = { ...H(this, me)[H(this, me).length - 1].csArg };
    }
    k[":タグ名"] = e;
    for (const [G, { val: U, def: z }] of Object.entries(N)) {
      let X = U;
      if ((X == null ? void 0 : X.at(0)) === "%") {
        if ($ === 0)
          throw "属性「%」はマクロ定義内でのみ使用できます（そのマクロの引数を示す簡略文法であるため）";
        const V = H(this, me)[H(this, me).length - 1].csArg[X.slice(1)];
        if (V) {
          k[G] = V;
          continue;
        }
        if (z === void 0 || z === "null")
          continue;
        X = z;
      }
      if (X = this.prpPrs.getValAmpersand(X ?? ""), X !== "undefined") {
        k[G] = X;
        continue;
      }
      z !== void 0 && (X = this.prpPrs.getValAmpersand(z), X !== "undefined" && (k[G] = X));
    }
    return D(k);
  }
  setOtherObj(t, e) {
    ot(this, Ra, t), ot(this, fr, e);
  }
  dumpErrForeLine() {
    if (H(this, Xt) === 0) {
      console.group(`🥟 Error line (from 0 rows before) fn:${H(this, ce)}`), console.groupEnd();
      return;
    }
    let t = "";
    for (let k = H(this, Xt) - 1; k >= 0 && (t = H(this, oe).aToken[k] + t, !((t.match(/\n/g) ?? []).length >= H(this, Bl))); --k)
      ;
    const e = t.split(`
`).slice(-H(this, Bl)), r = e.length;
    console.group(`🥟 Error line (from ${r} rows before) fn:${H(this, ce)}`);
    const D = String(H(this, xe)).length, N = lt(this, wi, an).call(this, H(this, oe), H(this, Xt));
    for (let k = 0; k < r; ++k) {
      const $ = H(this, xe) - r + k + 1, G = `${String($).padStart(D, " ")}: %c`, U = e[k], z = U.length > 75 ? U.slice(0, 75) + "…" : U;
      k === r - 1 ? console.info(
        G + z.slice(0, N.col_s) + "%c" + z.slice(N.col_s),
        "color: black; background-color: skyblue;",
        "color: black; background-color: pink;"
      ) : console.info(G + z, "color: black; background-color: skyblue;");
    }
    console.groupEnd();
  }
  analyzeInit() {
    const t = lt(this, Tc, Sp).call(this, H(this, oe), !!this.val.getVal("mp:const.sn.macro.name"), H(this, xe), H(this, os), H(this, Xt));
    ot(this, Xt, t.idx), ot(this, xe, t.ln), this.runAnalyze();
  }
  get isKidoku() {
    return H(this, Pi);
  }
  get isNextKidoku() {
    let t = H(this, ce), e = H(this, Xt), r = H(this, oe).len;
    if (H(this, me).length > 0) {
      const N = H(this, me)[0];
      t = N.fn, e = N.idx;
      const k = H(this, Ge)[t];
      k && (r = k.len);
    }
    const D = this.val.getAreaKidoku(t);
    return !D || e === r ? !1 : D.search(e);
  }
  get normalWait() {
    return H(this, Pi) ? this.val.getVal("sys:sn.tagCh.doWait_Kidoku") ? uint(this.val.getVal("sys:sn.tagCh.msecWait_Kidoku")) : 0 : this.val.getVal("sys:sn.tagCh.doWait") ? uint(this.val.getVal("sys:sn.tagCh.msecWait")) : 0;
  }
  get skip4page() {
    return H(this, Da);
  }
  recodePage() {
    if (ot(this, Da, !1), !this.val.getVal("save:sn.doRecLog"))
      return;
    const { fn: t, idx: e } = lt(this, Aa, xu).call(this), r = e - 1, D = r + ":" + t, N = H(this, Lr).findIndex(($) => $.key === D);
    if (N > -1) {
      ot(this, Ue, N);
      return;
    }
    const k = {
      key: D,
      fn: t,
      idx: r,
      retFn: t,
      retIdx: 0,
      retMark: { ...H(this, kr) }
    };
    if (H(this, Ue) >= 0) {
      const $ = H(this, Lr)[H(this, Ue)];
      k.retFn = $.fn, k.retIdx = $.idx + 1;
    }
    ++Ie(this, Ue)._ === H(this, Lr).length ? H(this, Lr).push(k) : H(this, Lr)[H(this, Ue)] = k;
  }
  recodeDesign(t) {
    let e = "", r = 0;
    const D = H(this, me).length;
    if (t.design_unit && D > 0) {
      const $ = H(this, me)[0];
      e = $.fn, r = $.idx;
    } else
      e = H(this, ce), r = H(this, Xt);
    t[":path"] = H(this, Ji).call(this, e);
    const N = lt(this, wi, an).call(this, H(this, Ge)[e], r);
    t[":ln"] = N.ln, t[":col_s"] = N.col_s, t[":col_e"] = N.col_e;
    const k = r - 1;
    t[":idx_tkn"] = k, t[":token"] = H(this, Ge)[e].aToken[k], this.sys.send2Dbg("_recodeDesign", t);
  }
  replace(t, e) {
    H(this, oe).aToken[t] = e;
  }
};
let ScriptIterator = ar;
oe = new WeakMap(), ce = new WeakMap(), Xt = new WeakMap(), xe = new WeakMap(), me = new WeakMap(), Ei = new WeakMap(), Ol = new WeakSet(), Pf = function(t, e) {
  H(ar, rs)[H(this, Ji).call(this, t)] = e;
}, ts = new WeakMap(), Zi = new WeakMap(), uc = new WeakMap(), Ji = new WeakMap(), Il = new WeakSet(), Mf = function(t) {
  if (lt(this, es, Ja).call(this))
    return;
  const e = H(this, oe).aToken[H(this, Xt) - H(this, Qi, Cs)];
  H(this, Oa).test(e) ? lt(this, Dl, Rf).call(this, !1) : (this.sys.callHook("stopOnStep", {}), H(this, ts).stepin(t));
}, Dl = new WeakSet(), Rf = function(t) {
  this.sys.callHook(`stopOnStep${t ? "Out" : ""}`, {}), ot(this, Al, H(this, me).length - (t ? 1 : 0)), ot(this, Xt, H(this, Xt) - H(this, Qi, Cs)), ot(this, Re, t ? 7 : 6), this.main.setLoop(!0), this.main.resume();
}, Al = new WeakMap(), Qi = new WeakSet(), Cs = function() {
  return H(this, Re) === 2 || H(this, Re) === 4 ? 1 : 0;
}, es = new WeakSet(), Ja = function() {
  return H(this, Xt) < H(this, oe).len ? !1 : (this.sys.callHook("stopOnEntry", {}), this.main.setLoop(!1, "スクリプト終端です"), !0);
}, rs = new WeakMap(), Ti = new WeakMap(), Re = new WeakMap(), hc = new WeakSet(), cp = function(t) {
  switch (H(this, Re)) {
    case 6:
      lt(this, is, Qa).call(this), ot(this, Re, 7);
      break;
    case 7:
      if (H(this, me).length !== H(this, Al))
        break;
      return ot(this, Re, 4), this.main.setLoop(!1, "ステップ実行"), this.sys.send2Dbg("stopOnStep", {}), !0;
    case 5:
      lt(this, is, Qa).call(this), ot(this, Re, 4);
      break;
    case 4:
      return lt(this, is, Qa).call(this), this.main.setLoop(!1, "ステップ実行"), this.sys.send2Dbg("stopOnStep", {}), !0;
    case 3:
      lt(this, is, Qa).call(this), ot(this, Re, 0);
      break;
    default:
      if (tagToken2Name(t) in H(ar, Ti))
        return ot(this, Re, 2), this.main.setLoop(!1, `関数 ${t} ブレーク`), this.sys.callHook("stopOnBreakpoint", {}), this.sys.send2Dbg("stopOnBreakpoint", {}), !0;
      {
        const e = H(ar, rs)[H(this, Ji).call(this, H(this, ce))];
        if (!e)
          break;
        const r = e[H(this, xe)];
        if (!r)
          break;
        if (r.condition) {
          if (!this.prpPrs.parse(r.condition))
            break;
        } else if ("hitCondition" in r && --r.hitCondition > 0)
          break;
        const D = H(this, Re) === 0;
        ot(this, Re, 2), this.main.setLoop(!1, D ? (r.condition ? "条件" : "ヒットカウント") + "ブレーク" : "ステップ実行");
        const N = D ? "stopOnBreakpoint" : "stopOnStep";
        this.sys.callHook(N, {}), this.sys.send2Dbg(N, {});
      }
      return !0;
  }
  return !1;
}, is = new WeakSet(), Qa = function() {
  var e;
  const t = (e = H(ar, rs)[getFn(H(this, ce))]) == null ? void 0 : e[H(this, xe)];
  t != null && t.hitCondition && --t.hitCondition;
}, cc = new WeakSet(), fp = function() {
  const t = H(this, Re) === 3 ? 1 : 0, e = H(this, oe).aToken[H(this, Xt) - 1 + t], r = H(this, Ji).call(this, H(this, ce)), D = tagToken2Name(e), N = D ? `[${D}]` : e, k = this.val.getVal("mp:const.sn.macro") ?? "{}";
  if (H(this, Xt) === 0)
    return [{ fn: r, ln: 1, col: 1, nm: N, ma: k }];
  const $ = lt(this, wi, an).call(this, H(this, oe), H(this, Xt)), G = [{ fn: r, ln: $.ln, col: $.col_s + 1, nm: N, ma: k }], U = H(this, me).length;
  if (U === 0)
    return G;
  for (let z = U - 1; z >= 0; --z) {
    const X = H(this, me)[z], V = H(this, Ge)[X.fn], Y = V.aToken[X.idx - 1], W = lt(this, wi, an).call(this, V, X.idx), q = tagToken2Name(Y);
    G.push({
      fn: H(this, Ji).call(this, X.fn),
      ln: W.ln,
      col: W.col_s + 1,
      nm: q ? `[${q}]` : Y,
      ma: X.csArg[":hMp"]["const.sn.macro"] ?? "{}"
    });
  }
  return G;
}, Nl = new WeakMap(), Ra = new WeakMap(), fr = new WeakMap(), fc = new WeakSet(), dp = function(t) {
  const { name: e } = t;
  if (!e)
    throw "nameは必須です";
  let r = "";
  const D = H(this, oe).len;
  for (; H(this, Xt) < D && (r = H(this, oe).aToken[H(this, Xt)], r === ""); ++Ie(this, Xt)._)
    ;
  return t.text = r, t.cast = "str", this.hTag.let(t), ot(this, Xt, H(this, Xt) + 2), ot(this, xe, H(this, xe) + (r.match(/\n/g) ?? []).length), !1;
}, dc = new WeakSet(), pp = function() {
  if (H(this, Xt) === 0)
    return console.group(`🥟 [dump_stack] スクリプト現在地 fn:${H(this, ce)} line:1 col:0`), console.groupEnd(), !1;
  const t = lt(this, wi, an).call(this, H(this, oe), H(this, Xt)), e = `スクリプト現在地 fn:${H(this, ce)} line:${t.ln} col:${t.col_s + 1}`;
  console.group(`🥟 [dump_stack] ${e}`);
  const r = H(this, me).length;
  if (r > 0) {
    console.info(e);
    for (let D = r - 1; D >= 0; --D) {
      const N = H(this, me)[D], k = N.csArg[":hMp"], $ = k ? k[":タグ名"] : void 0, G = N.csArg[":タグ名"] ?? "", U = lt(this, wi, an).call(this, H(this, Ge)[N.fn], N.idx);
      console.info(
        `${r - D}つ前のコール元 fn:${N.fn} line:${U.ln} col:${U.col_s + 1}` + ($ ? "（[" + $ + "]マクロ内）" : " ") + `で [${G} ...]をコール`
      );
    }
  }
  return console.groupEnd(), !1;
}, wi = new WeakSet(), an = function(t, e) {
  const r = { ln: 1, col_s: 0, col_e: 0 };
  if (!t)
    return r;
  let D = e - 1;
  const N = r.ln = t.aLNum[D];
  for (; t.aLNum[D] === N; ) {
    if (t.aToken[D].at(0) !== `
`) {
      const k = t.aToken[D].length;
      r.col_e > 0 && (r.col_s += k), r.col_e += k;
    }
    if (--D < 0)
      break;
  }
  return r;
}, pc = new WeakSet(), vp = function(t) {
  const { set_fnc: e, break_fnc: r } = t;
  if (!e)
    throw "set_fncは必須です";
  if (ot(this, ns, globalThis[e]), !H(this, ns)) {
    if (argChk_Boolean(t, "need_err", !0))
      throw `HTML内に関数${e}が見つかりません`;
    return ot(this, ns, () => {
    }), !1;
  }
  if (this.noticeBreak = (D) => {
    H(this, kl) !== H(this, ce) && (ot(this, kl, H(this, ce)), H(this, ns).call(this, H(this, Ll)[H(this, ce)] = H(this, Ll)[H(this, ce)] ?? H(this, oe).aToken.join(""))), H(this, ss).call(this, H(this, xe), D);
  }, this.noticeBreak(!0), !r)
    return !1;
  if (ot(this, ss, globalThis[r]), !H(this, ss)) {
    if (argChk_Boolean(t, "need_err", !0))
      throw `HTML内に関数${r}が見つかりません`;
    ot(this, ss, () => {
    });
  }
  return !1;
}, ns = new WeakMap(), ss = new WeakMap(), kl = new WeakMap(), Ll = new WeakMap(), Bl = new WeakMap(), dr = new WeakMap(), vc = new WeakSet(), gp = function() {
  if (H(this, dr)[0] === -1)
    throw "ifブロック内ではありません";
  return ot(this, Xt, H(this, dr)[0]), H(this, dr).shift(), !1;
}, gc = new WeakSet(), mp = function(t) {
  const { exp: e } = t;
  if (!e)
    throw "expは必須です";
  if (e.at(0) === "&")
    throw "属性expは「&」が不要です";
  let r = 0, D = this.prpPrs.parse(e) ? H(this, Xt) : -1;
  const N = H(this, oe).aLNum[H(this, Xt)];
  let k = H(this, xe) - (N || 0);
  const $ = H(this, oe).len;
  for (; H(this, Xt) < $; ++Ie(this, Xt)._) {
    const G = H(this, oe).aLNum[H(this, Xt)];
    H(this, oe).aLNum[H(this, Xt)] = (G || 0) + k;
    const U = H(this, oe).aToken[H(this, Xt)];
    if (!U)
      continue;
    const z = U.charCodeAt(0);
    if (z === 10) {
      ot(this, xe, H(this, xe) + U.length);
      continue;
    }
    if (z !== 91)
      continue;
    const [X, V] = tagToken2Name_Args(U);
    if (!(X in this.hTag))
      throw `未定義のタグ[${X}]です`;
    switch (this.alzTagArg.parse(V), X) {
      case "if":
        ++r;
        break;
      case "elsif":
        if (r > 0 || D > -1)
          break;
        const Y = this.alzTagArg.hPrm.exp.val;
        if (Y.at(0) === "&")
          throw "属性expは「&」が不要です";
        this.prpPrs.parse(Y) && (D = H(this, Xt) + 1);
        break;
      case "else":
        if (r > 0)
          break;
        D === -1 && (D = H(this, Xt) + 1);
        break;
      case "endif":
        if (r > 0) {
          --r;
          break;
        }
        return D === -1 ? (++Ie(this, Xt)._, H(this, oe).aLNum[H(this, Xt)] += k) : (H(this, dr).unshift(H(this, Xt) + 1), ot(this, Xt, D), ot(this, xe, H(this, oe).aLNum[H(this, Xt)])), !1;
    }
  }
  throw "[endif]がないままスクリプト終端です";
}, mc = new WeakSet(), _p = function(t) {
  argChk_Boolean(t, "count", !1) || lt(this, Xl, kf).call(this);
  const { fn: e } = t;
  return e && H(this, Zi).call(this, e), lt(this, Fl, Of).call(this, { ":hEvt1Time": H(this, Ra).popLocalEvts(), ":hMp": this.val.cloneMp() }), argChk_Boolean(t, "clear_local_event", !1) && this.hTag.clear_event({}), lt(this, Ci, ln).call(this, e, t.label), !0;
}, Fl = new WeakSet(), Of = function(t) {
  H(this, oe).aLNum[H(this, Xt)] = H(this, xe), H(this, Gl) || (t[":resvToken"] = "", lt(this, as, to).call(this)), H(this, me).push(new CallStack(H(this, ce), H(this, Xt), t)), H(this, dr).unshift(-1);
}, yc = new WeakSet(), yp = function(t) {
  return argChk_Boolean(t, "count", !0) || lt(this, Xl, kf).call(this), H(this, dr)[0] = -1, lt(this, Ci, ln).call(this, t.fn, t.label), !0;
}, bc = new WeakSet(), bp = function(t) {
  if (H(this, Ue) === -1)
    return !1;
  if (argChk_Boolean(t, "clear", !1))
    return ot(this, Lr, []), ot(this, Ue, -1), !1;
  const { to: e } = t;
  if (!e)
    throw "clearかtoは必須です";
  const r = H(this, Ue);
  switch (e) {
    case "prev":
      H(this, Ue) > 0 && --Ie(this, Ue)._;
      break;
    case "next":
      const $ = H(this, Lr).length;
      H(this, Ue) < $ - 1 && ++Ie(this, Ue)._;
      break;
    default:
      throw `属性to「${e}」は異常です`;
  }
  if (r === H(this, Ue))
    return !1;
  const D = H(this, Lr)[H(this, Ue)], { fn: N, idx: k } = lt(this, Aa, xu).call(this);
  return D.key === k + ":" + N ? !1 : lt(this, Ia, bu).call(this, { fn: D.retFn, index: D.retIdx }, D.retMark);
}, xc = new WeakSet(), xp = function(t) {
  if (argChk_Boolean(t, "clear", !1))
    ot(this, me, []);
  else if (!H(this, me).pop())
    throw "[pop_stack] スタックが空です";
  return lt(this, as, to).call(this), ot(this, dr, [-1]), this.val.setMp({}), !1;
}, $l = new WeakSet(), If = function(t) {
  const e = H(this, me).pop();
  if (!e)
    throw "[return] スタックが空です";
  const r = e.csArg;
  H(this, dr).shift();
  const D = r[":hMp"];
  D && this.val.setMp(D);
  const N = r[":resvToken"];
  N ? this.nextToken = () => (lt(this, as, to).call(this), N) : lt(this, as, to).call(this), r[":hEvt1Time"] && H(this, Ra).pushLocalEvts(r[":hEvt1Time"]);
  const { fn: k, label: $ } = t;
  return k || $ ? (lt(this, Ci, ln).call(this, k, $), !0) : e.fn in H(this, Ge) ? (lt(this, Vl, Nf).call(this, e), !1) : (lt(this, Ci, ln).call(this, e.fn, "", e.idx), !0);
}, Gl = new WeakMap(), as = new WeakSet(), to = function() {
  ot(this, Gl, ""), this.nextToken = lt(this, Ul, Df);
}, os = new WeakMap(), Ci = new WeakSet(), ln = function(t = "", e = "", r = 0) {
  if (!t && !e && this.main.errScript("[jump系] fnまたはlabelは必須です"), e ? (e.at(0) !== "*" && this.main.errScript("[jump系] labelは*で始まります"), ot(this, os, e), H(this, os).slice(0, 2) !== "**" && ot(this, Xt, r)) : (ot(this, os, ""), ot(this, Xt, r)), !t) {
    this.analyzeInit();
    return;
  }
  if (t.includes("@"))
    throw "[jump系] fn には文字「@」は禁止です";
  const D = H(this, Zi).call(this, t);
  if (t === H(this, ce)) {
    this.analyzeInit();
    return;
  }
  ot(this, ce, t);
  const N = H(this, Ge)[t];
  if (N) {
    ot(this, oe, N), this.analyzeInit();
    return;
  }
  const k = new Loader();
  let $ = "";
  try {
    $ = H(this, Zi).call(this, t + "@"), k.add({ name: t + ":base", url: D }), k.add({ name: t, url: $ });
  } catch {
    k.add({ name: t, url: D });
  }
  k.use((G, U) => {
    try {
      G.data = this.sys.decStr(G.extension, G.data);
    } catch (z) {
      this.main.errScript(`[jump系]snロード失敗です fn:${G.name} ${z}`, !1);
    }
    U == null || U();
  }).load((G, U) => {
    if ($) {
      const z = U[t + ":base"].data, X = U[t].data, V = z.split(`
`), Y = X.split(`
`), W = V.length, q = Y.length;
      for (let K = 0; K < q && K < W; ++K)
        Y[K] || (Y[K] = V[K]);
      U[t].data = Y.join(`
`), delete U[t + ":base"];
    }
    this.nextToken = lt(this, Ul, Df), ot(this, xe, 1), lt(this, wc, Ep).call(this, U[t].data), this.hTag.record_place({}), this.main.resume(() => this.analyzeInit());
  }), this.main.stop();
}, Ul = new WeakSet(), Df = function() {
  var e, r;
  if (lt(this, zl, Af).call(this))
    return "";
  lt(this, Rc, wp).call(this), (e = H(this, oe).aLNum)[r = H(this, Xt)] || (e[r] = H(this, xe));
  const t = H(this, oe).aToken[H(this, Xt)];
  return H(this, jl).call(this, t), ++Ie(this, Xt)._, t;
}, jl = new WeakMap(), zl = new WeakSet(), Af = function() {
  return H(this, Xt) < H(this, oe).len ? !1 : (this.main.errScript("スクリプト終端です"), !0);
}, Sc = new WeakMap(), Ec = new WeakMap(), Hl = new WeakMap(), Tc = new WeakSet(), Sp = function(t, e, r, D, N) {
  var z, X;
  const k = t.aToken.length;
  if (!D) {
    if (lt(this, zl, Af).call(this))
      return { idx: N, ln: r };
    if (t.aLNum[N])
      r = t.aLNum[N];
    else {
      r = 1;
      for (let V = 0; V < N; ++V) {
        (z = t.aLNum)[V] || (z[V] = r);
        const Y = t.aToken[V];
        Y.charCodeAt(0) === 10 ? r += Y.length : r += (Y.match(/\n/g) ?? []).length;
      }
      t.aLNum[N] = r;
    }
    return { idx: N, ln: r };
  }
  t.aLNum[0] = 1;
  const $ = D.match(H(this, Sc));
  if ($) {
    D = $[1];
    let V = N;
    switch ($[2]) {
      case "before":
        for (; t.aToken[--V] !== D; )
          V === 0 && DebugMng.myTrace("[jump系 無名ラベルbefore] " + r + "行目以前で" + (e ? "マクロ内に" : "") + "ラベル【" + D + "】がありません", "ET"), e && t.aToken[V].search(H(this, Ec)) > -1 && DebugMng.myTrace("[jump系 無名ラベルbefore] マクロ内にラベル【" + D + "】がありません", "ET");
        return { idx: V + 1, ln: t.aLNum[V] };
      case "after":
        for (; t.aToken[++V] !== D; )
          V === k && DebugMng.myTrace("[jump系 無名ラベルafter] " + r + "行目以後でマクロ内にラベル【" + D + "】がありません", "ET"), t.aToken[V].search(H(this, Hl)) > -1 && DebugMng.myTrace("[jump系 無名ラベルafter] " + r + "行目以後でマクロ内にラベル【" + D + "】がありません", "ET");
        return { idx: V + 1, ln: t.aLNum[V] };
      default:
        DebugMng.myTrace("[jump系] 無名ラベル指定【label=" + D + "】が間違っています", "ET");
    }
  }
  r = 1;
  const G = new RegExp(
    "^" + D.replaceAll("*", "\\*") + "(?=\\s|;|\\[|\\||$)"
  );
  let U = !1;
  for (let V = 0; V < k; ++V) {
    (X = t.aLNum)[V] || (X[V] = r);
    const Y = t.aToken[V];
    if (U) {
      H(this, Ei).testTagEndLetml(Y) ? U = !1 : r += (Y.match(/\n/g) ?? []).length;
      continue;
    }
    const W = Y.charCodeAt(0);
    if (W === 10) {
      r += Y.length;
      continue;
    }
    if (W === 42) {
      if (Y.search(G) > -1)
        return { idx: V + 1, ln: r };
      continue;
    }
    W === 91 && (r += (Y.match(/\n/g) ?? []).length, H(this, Ei).testTagLetml(Y) && (U = !0));
  }
  throw U ? "[let_ml]の終端・[endlet_ml]がありません" : (DebugMng.myTrace(`[jump系] ラベル【${D}】がありません`, "ET"), "Dummy");
}, Ge = new WeakMap(), wc = new WeakSet(), Ep = function(t) {
  let e = "";
  try {
    e = "ScriptIterator.resolveScript";
    const r = H(this, Ei).resolveScript(t);
    e = "ScriptIterator.replaceScript_Wildcard", lt(this, Mc, Tp).call(this, r), H(this, Ge)[H(this, ce)] = ot(this, oe, r);
  } catch (r) {
    r instanceof Error ? e += `例外 mes=${r.message}(${r.name})` : e = r, this.main.errScript(e, !1);
  }
  this.val.loadScrWork(H(this, ce));
}, Vl = new WeakSet(), Nf = function(t) {
  ot(this, ce, t.fn), ot(this, Xt, t.idx);
  const e = H(this, Ge)[H(this, ce)];
  e && ot(this, oe, e), ot(this, xe, H(this, oe).aLNum[t.idx]);
}, Cc = new WeakMap(), Pc = new WeakMap(), Mc = new WeakSet(), Tp = function(t) {
  for (let e = t.len - 1; e >= 0; --e) {
    const r = t.aToken[e];
    if (!H(this, Cc).test(r))
      continue;
    const [D, N] = tagToken2Name_Args(r);
    this.alzTagArg.parse(N);
    const k = this.alzTagArg.hPrm.fn;
    if (!k)
      continue;
    const { val: $ } = k;
    if (!$ || $.at(-1) !== "*")
      continue;
    t.aToken.splice(e, 1, "	", "; " + r), t.aLNum.splice(e, 1, NaN, NaN);
    const G = D === "loadplugin" ? SEARCH_PATH_ARG_EXT.CSS : SEARCH_PATH_ARG_EXT.SN, U = this.cfg.matchPath("^" + $.slice(0, -1) + ".*", G);
    for (const z of U) {
      const X = r.replace(
        H(this, Pc),
        "fn=" + decodeURIComponent(getFn(z[G]))
      );
      t.aToken.splice(e, 0, X), t.aLNum.splice(e, 0, NaN);
    }
  }
  t.len = t.aToken.length;
}, Rc = new WeakSet(), wp = function() {
  const t = this.val.getAreaKidoku(H(this, ce));
  if (!t)
    throw `recordKidoku fn:'${H(this, ce)}' (areas === null)`;
  if (H(this, me).length > 0) {
    t.record(H(this, Xt));
    return;
  }
  ot(this, Pi, t.search(H(this, Xt))), this.val.setVal_Nochk("tmp", "const.sn.isKidoku", H(this, Pi)), !H(this, Pi) && t.record(H(this, Xt));
}, Pi = new WeakMap(), Xl = new WeakSet(), kf = function() {
  var t;
  (t = this.val.getAreaKidoku(H(this, ce))) == null || t.erase(H(this, Xt)), ot(this, Pi, !1);
}, Oc = new WeakSet(), Cp = function(t) {
  return H(this, Ei).bracket2macro(t, this.hTag, H(this, oe), H(this, Xt)), !1;
}, Ic = new WeakSet(), Pp = function(t) {
  return H(this, Ei).char2macro(t, this.hTag, H(this, oe), H(this, Xt)), !1;
}, Dc = new WeakMap(), Ac = new WeakSet(), Mp = function(t) {
  var N, k;
  const { name: e } = t;
  if (!e)
    throw "nameは必須です";
  if (e in this.hTag)
    throw `[${e}]はタグかすでに定義済みのマクロです`;
  if (H(this, Dc).test(e))
    throw `[${e}]はマクロ名として異常です`;
  const r = H(this, xe), D = new CallStack(H(this, ce), H(this, Xt));
  for (ot(this, Yl, H(this, Yl) + ("|" + e)), ot(this, Oa, new RegExp(`\\[(${H(this, Yl)})\\b`)), this.hTag[e] = ($) => ($.design_unit = t.design_unit, lt(this, Fl, Of).call(this, { ...$, ":hMp": this.val.cloneMp() }), this.val.setMp($), this.val.setVal_Nochk("mp", "const.sn.macro", JSON.stringify(t)), this.val.setVal_Nochk("mp", "const.sn.me_call_scriptFn", H(this, ce)), ot(this, xe, r), lt(this, Vl, Nf).call(this, D), !1); H(this, Xt) < H(this, oe).len; ++Ie(this, Xt)._) {
    (N = H(this, oe).aLNum)[k = H(this, Xt)] || (N[k] = H(this, xe));
    const $ = H(this, oe).aToken[H(this, Xt)];
    if ($.search(H(this, Hl)) > -1)
      return ++Ie(this, Xt)._, !1;
    const G = $.charCodeAt(0);
    G === 10 ? ot(this, xe, H(this, xe) + $.length) : G === 91 && ot(this, xe, H(this, xe) + ($.match(/\n/g) ?? []).length);
  }
  throw `マクロ[${e}]定義の終端・[endmacro]がありません`;
}, Yl = new WeakMap(), Oa = new WeakMap(), Nc = new WeakSet(), Rp = function(t) {
  if (!("place" in t))
    throw "placeは必須です";
  const e = Number(t.place);
  if ("fn" in t != "label" in t)
    throw "fnとlabelはセットで指定して下さい";
  const r = this.val.getMark(e);
  if (!r)
    throw `place【${e}】は存在しません`;
  return lt(this, Ia, bu).call(this, t, r);
}, Ia = new WeakSet(), bu = function(t, e, r = !0) {
  this.hTag.clear_event({}), this.val.mark2save(e), this.val.setMp({}), H(this, fr).recPagebreak(), r && this.sndMng.playLoopFromSaveObj(), argChk_Boolean(t, "do_rec", !0) && ot(this, kr, {
    hSave: this.val.cloneSave(),
    hPages: { ...e.hPages },
    aIfStk: [...e.aIfStk]
  });
  const D = {
    enabled: this.val.getVal("save:const.sn.autowc.enabled"),
    text: this.val.getVal("save:const.sn.autowc.text"),
    time: Number(this.val.getVal("save:const.sn.autowc.time"))
  };
  this.hTag.autowc(D);
  const N = String(this.val.getVal("save:const.sn.scriptFn")), k = Number(this.val.getVal("save:const.sn.scriptIdx"));
  return ot(this, dr, [...H(this, kr).aIfStk]), ot(this, me, []), H(this, fr).cover(!0), H(this, fr).stopAllTw(), "index" in t ? (H(this, fr).playback(H(this, kr).hPages, () => {
    H(this, fr).cover(!1), ot(this, Da, !0), lt(this, Ci, ln).call(this, t.fn ?? N, "", t.index ?? k);
  }), !0) : (delete H(this, Ge)[N], H(this, fr).playback(
    H(this, kr).hPages,
    "label" in t ? () => {
      H(this, fr).cover(!1), ot(this, ce, N), ot(this, Xt, k), this.hTag.call({ fn: t.fn, label: t.label });
    } : () => {
      H(this, fr).cover(!1), lt(this, Ci, ln).call(this, N, "", k);
    }
  ), !0);
}, Da = new WeakMap(), kc = new WeakSet(), Op = function(t) {
  const e = this.val.getMark(0);
  delete H(this, Ge)[getFn(e.hSave["const.sn.scriptFn"])];
  const r = {};
  for (const D in H(this, Ge))
    try {
      H(this, Zi).call(this, D + "@");
    } catch {
      r[D] = H(this, Ge)[D];
    }
  return ot(this, Ge, r), t.do_rec = !1, lt(this, Ia, bu).call(this, t, e, !1);
}, kr = new WeakMap(), Lc = new WeakSet(), Ip = function() {
  if (this.main.isDestroyed())
    return !1;
  const { fn: t, idx: e } = lt(this, Aa, xu).call(this);
  return this.val.setVal_Nochk("save", "const.sn.scriptFn", t), this.val.setVal_Nochk("save", "const.sn.scriptIdx", e), ot(this, kr, {
    hSave: this.val.cloneSave(),
    hPages: H(this, fr).record(),
    aIfStk: H(this, dr).slice(H(this, me).length)
  }), !1;
}, Aa = new WeakSet(), xu = function() {
  if (H(this, me).length === 0)
    return {
      fn: H(this, ce),
      idx: H(this, Xt)
    };
  const e = H(this, me)[0];
  return {
    fn: e.fn,
    idx: e.idx
  };
}, Bc = new WeakSet(), Dp = function(t) {
  if (!("place" in t))
    throw "placeは必須です";
  const e = Number(t.place);
  delete t[":タグ名"], delete t.place, t.text = t.text ?? "", H(this, kr).json = t, this.val.setMark(e, H(this, kr));
  const r = Number(this.val.getVal("sys:const.sn.save.place"));
  return e === r && this.val.setVal_Nochk("sys", "const.sn.save.place", r + 1), !1;
}, Lr = new WeakMap(), Ue = new WeakMap(), rt(ScriptIterator, uc, /(.+)\/crypto_prj\/([^\/]+)\/[^\.]+(\.\w+)/), // reload 再生成 Main に受け渡すため static
rt(ScriptIterator, rs, {}), rt(ScriptIterator, Ti, {});
var ir, Er, He, Tr, Mi, ls, je, Wl, Ri, Na, us, ql, Kl, ka, Fc, Ap, Zl, Jl, La, Ba, Su, hs, cs;
const Rs = class {
  constructor(t) {
    rt(this, Fc);
    rt(this, Ba);
    rt(this, ir, void 0);
    rt(this, Er, void 0);
    rt(this, He, /* @__PURE__ */ Object.create(null));
    // タグ処理辞書
    rt(this, Tr, void 0);
    rt(this, Mi, void 0);
    rt(this, ls, void 0);
    rt(this, je, void 0);
    rt(this, Wl, void 0);
    rt(this, Ri, void 0);
    rt(this, Na, void 0);
    rt(this, us, () => {
    });
    rt(this, ql, new AnalyzeTagArg());
    rt(this, Kl, !1);
    rt(this, ka, "skynovel");
    rt(this, Zl, () => H(this, us).call(this));
    // メイン処理（シナリオ解析）
    rt(this, Jl, (t = lt(this, Ba, Su)) => {
      H(this, hs) || (H(this, Ri).clearBreak(), ot(this, us, t), this.resume = (e = lt(this, Ba, Su)) => {
        ot(this, us, e);
      }, H(this, je).noticeBreak(!1));
    });
    It(this, "resume", H(this, Jl));
    It(this, "stop", () => {
      ot(this, us, () => {
      }), this.resume = H(this, Jl), H(this, je).noticeBreak(!0);
    });
    rt(this, La, !0);
    rt(this, hs, !1);
    It(this, "isDestroyed", () => H(this, hs));
    rt(this, cs, void 0);
    this.sys = t, skipHello(), Config.generate(t).then((e) => ot(this, ir, e)).then(() => lt(this, Fc, Ap).call(this)).catch((e) => console.error("load err fn:prj.json e:%o", e));
  }
  // thisの扱いによりメソッド代入はダメ
  errScript(t, e = !0) {
    if (this.stop(), DebugMng.myTrace(t), CmnLib.debugLog && console.log("🍜 SKYNovel err!"), e)
      throw t;
  }
  resumeByJumpOrCall(t) {
    if (t.url) {
      globalThis.open(t.url);
      return;
    }
    H(this, Tr).setVal_Nochk("tmp", "sn.eventArg", t.arg ?? ""), H(this, Tr).setVal_Nochk("tmp", "sn.eventLabel", t.label ?? ""), argChk_Boolean(t, "call", !1) ? (H(this, je).subIdxToken(), this.resume(() => H(this, He).call(t))) : (H(this, He).clear_event({}), this.resume(() => H(this, He).jump(t)));
  }
  setLoop(t, e = "") {
    ot(this, La, t) ? this.resume() : this.stop(), this.sys.setTitleInfo(e ? ` -- ${e}中` : "");
  }
  fire(t, e) {
    H(this, Na).fire(t, e);
  }
  async destroy(t = 0) {
    H(this, hs) || (ot(this, hs, !0), H(this, Kl) && (this.stop(), ot(this, La, !1), H(this, Ri).before_destroy(), t > 0 && await new Promise((e) => setTimeout(e, t)), ot(this, He, {}), H(this, Na).destroy(), H(this, je).destroy(), H(this, Ri).destroy(), H(this, Wl).destroy(), H(this, Er).ticker.remove(H(this, Zl)), H(this, cs) && H(this, Er) && Rs.cvs.parentNode.appendChild(H(this, cs)), clearTextureCache(), H(this, Er).destroy(!0), this.sys.destroy()));
  }
};
let Main = Rs;
ir = new WeakMap(), Er = new WeakMap(), He = new WeakMap(), Tr = new WeakMap(), Mi = new WeakMap(), ls = new WeakMap(), je = new WeakMap(), Wl = new WeakMap(), Ri = new WeakMap(), Na = new WeakMap(), us = new WeakMap(), ql = new WeakMap(), Kl = new WeakMap(), ka = new WeakMap(), Fc = new WeakSet(), Ap = async function() {
  var D;
  const t = (D = document.createElement("canvas")) == null ? void 0 : D.getContext("2d");
  if (!t)
    throw "argChk_Color err";
  CmnLib.cc4ColorName = t;
  const e = {
    width: H(this, ir).oCfg.window.width,
    height: H(this, ir).oCfg.window.height,
    backgroundColor: parseColor(String(H(this, ir).oCfg.init.bg_color)),
    // このString()は後方互換性のため必須
    //	resolution		: sys.resolution,
    resolution: globalThis.devicePixelRatio ?? 1
    // 理想
  }, r = document.getElementById(H(this, ka));
  r && (ot(this, cs, r.cloneNode(!0)), H(this, cs).id = H(this, ka), e.view = r), ot(this, Er, new Application(e)), Rs.cvs = H(this, Er).view, r || (document.body.appendChild(Rs.cvs), Rs.cvs.id = H(this, ka)), ot(this, Tr, new Variable(H(this, ir), H(this, He))), ot(this, Mi, new PropParser(H(this, Tr), H(this, ir).oCfg.init.escape ?? "\\")), await Promise.allSettled(this.sys.init(H(this, He), H(this, Er), H(this, Tr), this)), H(this, He).title({ text: H(this, ir).oCfg.book.title || "SKYNovel" }), ot(this, ls, new SoundMng(H(this, ir), H(this, He), H(this, Tr), this, this.sys)), ot(this, je, new ScriptIterator(H(this, ir), H(this, He), this, H(this, Tr), H(this, ql), () => lt(this, Ba, Su).call(this), H(this, Mi), H(this, ls), this.sys)), ot(this, Wl, new DebugMng(this.sys, H(this, He), H(this, je))), ot(this, Ri, new LayerMng(H(this, ir), H(this, He), H(this, Er), H(this, Tr), this, H(this, je), this.sys, H(this, ls), H(this, ql), H(this, Mi))), ot(this, Na, new EventMng(H(this, ir), H(this, He), H(this, Er), this, H(this, Ri), H(this, Tr), H(this, ls), H(this, je), this.sys)), H(this, Er).ticker.add(H(this, Zl)), this.resumeByJumpOrCall({ fn: "main" }), ot(this, Kl, !0);
}, Zl = new WeakMap(), Jl = new WeakMap(), La = new WeakMap(), Ba = new WeakSet(), Su = function() {
  for (; H(this, La); ) {
    let t = H(this, je).nextToken();
    if (!t)
      break;
    const e = t.charCodeAt(0);
    if (e !== 9) {
      if (e === 10) {
        H(this, je).addLineNum(t.length);
        continue;
      }
      if (e === 91) {
        if (H(this, je).isBreak(t))
          return;
        try {
          const r = (t.match(/\n/g) ?? []).length;
          if (r > 0 && H(this, je).addLineNum(r), H(this, je).タグ解析(t)) {
            this.stop();
            break;
          }
          continue;
        } catch (r) {
          r instanceof Error ? this.errScript(`[${tagToken2Name(t)}]タグ解析中例外 mes=${r.message}(${r.name})`, !1) : this.errScript(String(r), !1);
          return;
        }
      }
      if (e === 38)
        try {
          if (t.at(-1) !== "&") {
            if (H(this, je).isBreak(t))
              return;
            const r = splitAmpersand(t.slice(1));
            r.name = H(this, Mi).getValAmpersand(r.name), r.text = String(H(this, Mi).parse(r.text)), H(this, He).let(r);
            continue;
          }
          if (t.charAt(1) === "&")
            throw new Error("「&表示&」書式では「&」指定が不要です");
          t = String(H(this, Mi).parse(t.slice(1, -1)));
        } catch (r) {
          this.errScript(
            r instanceof Error ? `& 変数操作・表示 mes=${r.message}(${r.name})` : r,
            !1
          );
          return;
        }
      else {
        if (e === 59)
          continue;
        if (e === 42 && t.length > 1)
          continue;
      }
      try {
        H(this, Ri).currentTxtlayForeNeedErr.tagCh(t);
      } catch (r) {
        this.errScript(
          r instanceof Error ? `文字表示 mes=${r.message}(${r.name})` : r,
          !1
        );
        return;
      }
    }
  }
}, hs = new WeakMap(), cs = new WeakMap(), It(Main, "cvs");
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES.open = "0";
PACKET_TYPES.close = "1";
PACKET_TYPES.ping = "2";
PACKET_TYPES.pong = "3";
PACKET_TYPES.message = "4";
PACKET_TYPES.upgrade = "5";
PACKET_TYPES.noop = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((o) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[o]] = o;
});
const ERROR_PACKET = { type: "error", data: "parser error" }, withNativeBlob$1 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", withNativeArrayBuffer$2 = typeof ArrayBuffer == "function", isView$1 = (o) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(o) : o && o.buffer instanceof ArrayBuffer, encodePacket = ({ type: o, data: t }, e, r) => withNativeBlob$1 && t instanceof Blob ? e ? r(t) : encodeBlobAsBase64(t, r) : withNativeArrayBuffer$2 && (t instanceof ArrayBuffer || isView$1(t)) ? e ? r(t) : encodeBlobAsBase64(new Blob([t]), r) : r(PACKET_TYPES[o] + (t || "")), encodeBlobAsBase64 = (o, t) => {
  const e = new FileReader();
  return e.onload = function() {
    const r = e.result.split(",")[1];
    t("b" + (r || ""));
  }, e.readAsDataURL(o);
}, chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup$1 = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let o = 0; o < chars.length; o++)
  lookup$1[chars.charCodeAt(o)] = o;
const decode$1 = (o) => {
  let t = o.length * 0.75, e = o.length, r, D = 0, N, k, $, G;
  o[o.length - 1] === "=" && (t--, o[o.length - 2] === "=" && t--);
  const U = new ArrayBuffer(t), z = new Uint8Array(U);
  for (r = 0; r < e; r += 4)
    N = lookup$1[o.charCodeAt(r)], k = lookup$1[o.charCodeAt(r + 1)], $ = lookup$1[o.charCodeAt(r + 2)], G = lookup$1[o.charCodeAt(r + 3)], z[D++] = N << 2 | k >> 4, z[D++] = (k & 15) << 4 | $ >> 2, z[D++] = ($ & 3) << 6 | G & 63;
  return U;
}, withNativeArrayBuffer$1 = typeof ArrayBuffer == "function", decodePacket = (o, t) => {
  if (typeof o != "string")
    return {
      type: "message",
      data: mapBinary(o, t)
    };
  const e = o.charAt(0);
  return e === "b" ? {
    type: "message",
    data: decodeBase64Packet(o.substring(1), t)
  } : PACKET_TYPES_REVERSE[e] ? o.length > 1 ? {
    type: PACKET_TYPES_REVERSE[e],
    data: o.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[e]
  } : ERROR_PACKET;
}, decodeBase64Packet = (o, t) => {
  if (withNativeArrayBuffer$1) {
    const e = decode$1(o);
    return mapBinary(e, t);
  } else
    return { base64: !0, data: o };
}, mapBinary = (o, t) => {
  switch (t) {
    case "blob":
      return o instanceof ArrayBuffer ? new Blob([o]) : o;
    case "arraybuffer":
    default:
      return o;
  }
}, SEPARATOR = String.fromCharCode(30), encodePayload = (o, t) => {
  const e = o.length, r = new Array(e);
  let D = 0;
  o.forEach((N, k) => {
    encodePacket(N, !1, ($) => {
      r[k] = $, ++D === e && t(r.join(SEPARATOR));
    });
  });
}, decodePayload = (o, t) => {
  const e = o.split(SEPARATOR), r = [];
  for (let D = 0; D < e.length; D++) {
    const N = decodePacket(e[D], t);
    if (r.push(N), N.type === "error")
      break;
  }
  return r;
}, protocol$1 = 4;
function Emitter(o) {
  if (o)
    return mixin(o);
}
function mixin(o) {
  for (var t in Emitter.prototype)
    o[t] = Emitter.prototype[t];
  return o;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(o, t) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + o] = this._callbacks["$" + o] || []).push(t), this;
};
Emitter.prototype.once = function(o, t) {
  function e() {
    this.off(o, e), t.apply(this, arguments);
  }
  return e.fn = t, this.on(o, e), this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(o, t) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var e = this._callbacks["$" + o];
  if (!e)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + o], this;
  for (var r, D = 0; D < e.length; D++)
    if (r = e[D], r === t || r.fn === t) {
      e.splice(D, 1);
      break;
    }
  return e.length === 0 && delete this._callbacks["$" + o], this;
};
Emitter.prototype.emit = function(o) {
  this._callbacks = this._callbacks || {};
  for (var t = new Array(arguments.length - 1), e = this._callbacks["$" + o], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  if (e) {
    e = e.slice(0);
    for (var r = 0, D = e.length; r < D; ++r)
      e[r].apply(this, t);
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(o) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + o] || [];
};
Emitter.prototype.hasListeners = function(o) {
  return !!this.listeners(o).length;
};
const globalThisShim = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
function pick(o, ...t) {
  return t.reduce((e, r) => (o.hasOwnProperty(r) && (e[r] = o[r]), e), {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout, NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(o, t) {
  t.useNativeTimers ? (o.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim), o.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim)) : (o.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim), o.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim));
}
const BASE64_OVERHEAD = 1.33;
function byteLength(o) {
  return typeof o == "string" ? utf8Length(o) : Math.ceil((o.byteLength || o.size) * BASE64_OVERHEAD);
}
function utf8Length(o) {
  let t = 0, e = 0;
  for (let r = 0, D = o.length; r < D; r++)
    t = o.charCodeAt(r), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (r++, e += 4);
  return e;
}
class TransportError extends Error {
  constructor(t, e, r) {
    super(t), this.description = e, this.context = r, this.type = "TransportError";
  }
}
class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(t) {
    super(), this.writable = !1, installTimerFunctions(this, t), this.opts = t, this.query = t.query, this.socket = t.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(t, e, r) {
    return super.emitReserved("error", new TransportError(t, e, r)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(t) {
    this.readyState === "open" && this.write(t);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(t) {
    const e = decodePacket(t, this.socket.binaryType);
    this.onPacket(e);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(t) {
    super.emitReserved("packet", t);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(t) {
    this.readyState = "closed", super.emitReserved("close", t);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(t) {
  }
}
const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map$1 = {};
let seed = 0, i = 0, prev;
function encode$1(o) {
  let t = "";
  do
    t = alphabet[o % length] + t, o = Math.floor(o / length);
  while (o > 0);
  return t;
}
function yeast() {
  const o = encode$1(+/* @__PURE__ */ new Date());
  return o !== prev ? (seed = 0, prev = o) : o + "." + encode$1(seed++);
}
for (; i < length; i++)
  map$1[alphabet[i]] = i;
function encode(o) {
  let t = "";
  for (let e in o)
    o.hasOwnProperty(e) && (t.length && (t += "&"), t += encodeURIComponent(e) + "=" + encodeURIComponent(o[e]));
  return t;
}
function decode(o) {
  let t = {}, e = o.split("&");
  for (let r = 0, D = e.length; r < D; r++) {
    let N = e[r].split("=");
    t[decodeURIComponent(N[0])] = decodeURIComponent(N[1]);
  }
  return t;
}
let value = !1;
try {
  value = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const hasCORS = value;
function XHR(o) {
  const t = o.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!t || hasCORS))
      return new XMLHttpRequest();
  } catch {
  }
  if (!t)
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
function empty() {
}
const hasXHR2 = function() {
  return new XHR({
    xdomain: !1
  }).responseType != null;
}();
class Polling extends Transport {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(t) {
    if (super(t), this.polling = !1, typeof location < "u") {
      const r = location.protocol === "https:";
      let D = location.port;
      D || (D = r ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || D !== t.port, this.xs = t.secure !== r;
    }
    const e = t && t.forceBase64;
    this.supportsBinary = hasXHR2 && !e;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(t) {
    this.readyState = "pausing";
    const e = () => {
      this.readyState = "paused", t();
    };
    if (this.polling || !this.writable) {
      let r = 0;
      this.polling && (r++, this.once("pollComplete", function() {
        --r || e();
      })), this.writable || (r++, this.once("drain", function() {
        --r || e();
      }));
    } else
      e();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  poll() {
    this.polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(t) {
    const e = (r) => {
      if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(r);
    };
    decodePayload(t, this.socket.binaryType).forEach(e), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const t = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? t() : this.once("open", t);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(t) {
    this.writable = !1, encodePayload(t, (e) => {
      this.doWrite(e, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    let t = this.query || {};
    const e = this.opts.secure ? "https" : "http";
    let r = "";
    this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = yeast()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.opts.port && (e === "https" && Number(this.opts.port) !== 443 || e === "http" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port);
    const D = encode(t), N = this.opts.hostname.indexOf(":") !== -1;
    return e + "://" + (N ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (D.length ? "?" + D : "");
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @private
   */
  request(t = {}) {
    return Object.assign(t, { xd: this.xd, xs: this.xs }, this.opts), new Request(this.uri(), t);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(t, e) {
    const r = this.request({
      method: "POST",
      data: t
    });
    r.on("success", e), r.on("error", (D, N) => {
      this.onError("xhr post error", D, N);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const t = this.request();
    t.on("data", this.onData.bind(this)), t.on("error", (e, r) => {
      this.onError("xhr poll error", e, r);
    }), this.pollXhr = t;
  }
}
class Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(t, e) {
    super(), installTimerFunctions(this, e), this.opts = e, this.method = e.method || "GET", this.uri = t, this.async = e.async !== !1, this.data = e.data !== void 0 ? e.data : null, this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  create() {
    const t = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    t.xdomain = !!this.opts.xd, t.xscheme = !!this.opts.xs;
    const e = this.xhr = new XHR(t);
    try {
      e.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0);
          for (let r in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(r) && e.setRequestHeader(r, this.opts.extraHeaders[r]);
        }
      } catch {
      }
      if (this.method === "POST")
        try {
          e.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        e.setRequestHeader("Accept", "*/*");
      } catch {
      }
      "withCredentials" in e && (e.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (e.timeout = this.opts.requestTimeout), e.onreadystatechange = () => {
        e.readyState === 4 && (e.status === 200 || e.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
          this.onError(typeof e.status == "number" ? e.status : 0);
        }, 0));
      }, e.send(this.data);
    } catch (r) {
      this.setTimeoutFn(() => {
        this.onError(r);
      }, 0);
      return;
    }
    typeof document < "u" && (this.index = Request.requestsCount++, Request.requests[this.index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  onError(t) {
    this.emitReserved("error", t, this.xhr), this.cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  cleanup(t) {
    if (!(typeof this.xhr > "u" || this.xhr === null)) {
      if (this.xhr.onreadystatechange = empty, t)
        try {
          this.xhr.abort();
        } catch {
        }
      typeof document < "u" && delete Request.requests[this.index], this.xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  onLoad() {
    const t = this.xhr.responseText;
    t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this.cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this.cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", unloadHandler);
  else if (typeof addEventListener == "function") {
    const o = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(o, unloadHandler, !1);
  }
}
function unloadHandler() {
  for (let o in Request.requests)
    Request.requests.hasOwnProperty(o) && Request.requests[o].abort();
}
const nextTick = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0))(), WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket, usingBrowserWebSocket = !0, defaultBinaryType = "arraybuffer", isReactNative = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class WS extends Transport {
  /**
   * WebSocket transport constructor.
   *
   * @param {Object} opts - connection options
   * @protected
   */
  constructor(t) {
    super(t), this.supportsBinary = !t.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check())
      return;
    const t = this.uri(), e = this.opts.protocols, r = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? e ? new WebSocket(t, e) : new WebSocket(t) : new WebSocket(t, e, r);
    } catch (D) {
      return this.emitReserved("error", D);
    }
    this.ws.binaryType = this.socket.binaryType || defaultBinaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const r = t[e], D = e === t.length - 1;
      encodePacket(r, this.supportsBinary, (N) => {
        const k = {};
        try {
          usingBrowserWebSocket && this.ws.send(N);
        } catch {
        }
        D && nextTick(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    let t = this.query || {};
    const e = this.opts.secure ? "wss" : "ws";
    let r = "";
    this.opts.port && (e === "wss" && Number(this.opts.port) !== 443 || e === "ws" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port), this.opts.timestampRequests && (t[this.opts.timestampParam] = yeast()), this.supportsBinary || (t.b64 = 1);
    const D = encode(t), N = this.opts.hostname.indexOf(":") !== -1;
    return e + "://" + (N ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (D.length ? "?" + D : "");
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @private
   */
  check() {
    return !!WebSocket;
  }
}
const transports = {
  websocket: WS,
  polling: Polling
}, re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse(o) {
  const t = o, e = o.indexOf("["), r = o.indexOf("]");
  e != -1 && r != -1 && (o = o.substring(0, e) + o.substring(e, r).replace(/:/g, ";") + o.substring(r, o.length));
  let D = re.exec(o || ""), N = {}, k = 14;
  for (; k--; )
    N[parts[k]] = D[k] || "";
  return e != -1 && r != -1 && (N.source = t, N.host = N.host.substring(1, N.host.length - 1).replace(/;/g, ":"), N.authority = N.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), N.ipv6uri = !0), N.pathNames = pathNames(N, N.path), N.queryKey = queryKey(N, N.query), N;
}
function pathNames(o, t) {
  const e = /\/{2,9}/g, r = t.replace(e, "/").split("/");
  return (t.slice(0, 1) == "/" || t.length === 0) && r.splice(0, 1), t.slice(-1) == "/" && r.splice(r.length - 1, 1), r;
}
function queryKey(o, t) {
  const e = {};
  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, D, N) {
    D && (e[D] = N);
  }), e;
}
let Socket$1 = class Ps extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(t, e = {}) {
    super(), this.writeBuffer = [], t && typeof t == "object" && (e = t, t = null), t ? (t = parse(t), e.hostname = t.host, e.secure = t.protocol === "https" || t.protocol === "wss", e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = parse(e.host).host), installTimerFunctions(this, e), this.secure = e.secure != null ? e.secure : typeof location < "u" && location.protocol === "https:", e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.hostname = e.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = e.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = e.transports || ["polling", "websocket"], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !0
    }, e), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = decode(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this.offlineEventListener = () => {
      this.onClose("transport close", {
        description: "network connection lost"
      });
    }, addEventListener("offline", this.offlineEventListener, !1))), this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(t) {
    const e = Object.assign({}, this.opts.query);
    e.EIO = protocol$1, e.transport = t, this.id && (e.sid = this.id);
    const r = Object.assign({}, this.opts.transportOptions[t], this.opts, {
      query: e,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    });
    return new transports[t](r);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  open() {
    let t;
    if (this.opts.rememberUpgrade && Ps.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
      t = "websocket";
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else
      t = this.transports[0];
    this.readyState = "opening";
    try {
      t = this.createTransport(t);
    } catch {
      this.transports.shift(), this.open();
      return;
    }
    t.open(), this.setTransport(t);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(t) {
    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (e) => this.onClose("transport close", e));
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  probe(t) {
    let e = this.createTransport(t), r = !1;
    Ps.priorWebsocketSuccess = !1;
    const D = () => {
      r || (e.send([{ type: "ping", data: "probe" }]), e.once("packet", (X) => {
        if (!r)
          if (X.type === "pong" && X.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", e), !e)
              return;
            Ps.priorWebsocketSuccess = e.name === "websocket", this.transport.pause(() => {
              r || this.readyState !== "closed" && (z(), this.setTransport(e), e.send([{ type: "upgrade" }]), this.emitReserved("upgrade", e), e = null, this.upgrading = !1, this.flush());
            });
          } else {
            const V = new Error("probe error");
            V.transport = e.name, this.emitReserved("upgradeError", V);
          }
      }));
    };
    function N() {
      r || (r = !0, z(), e.close(), e = null);
    }
    const k = (X) => {
      const V = new Error("probe error: " + X);
      V.transport = e.name, N(), this.emitReserved("upgradeError", V);
    };
    function $() {
      k("transport closed");
    }
    function G() {
      k("socket closed");
    }
    function U(X) {
      e && X.name !== e.name && N();
    }
    const z = () => {
      e.removeListener("open", D), e.removeListener("error", k), e.removeListener("close", $), this.off("close", G), this.off("upgrading", U);
    };
    e.once("open", D), e.once("error", k), e.once("close", $), this.once("close", G), this.once("upgrading", U), e.open();
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    if (this.readyState = "open", Ps.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade) {
      let t = 0;
      const e = this.upgrades.length;
      for (; t < e; t++)
        this.probe(this.upgrades[t]);
    }
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  onPacket(t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;
        case "ping":
          this.resetPingTimeout(), this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
          break;
        case "error":
          const e = new Error("server error");
          e.code = t.data, this.onError(e);
          break;
        case "message":
          this.emitReserved("data", t.data), this.emitReserved("message", t.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(t) {
    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const t = this.getWritablePackets();
      this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  getWritablePackets() {
    if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let e = 1;
    for (let r = 0; r < this.writeBuffer.length; r++) {
      const D = this.writeBuffer[r].data;
      if (D && (e += byteLength(D)), r > 0 && e > this.maxPayload)
        return this.writeBuffer.slice(0, r);
      e += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} callback function.
   * @return {Socket} for chaining.
   */
  write(t, e, r) {
    return this.sendPacket("message", t, e, r), this;
  }
  send(t, e, r) {
    return this.sendPacket("message", t, e, r), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  sendPacket(t, e, r, D) {
    if (typeof e == "function" && (D = e, e = void 0), typeof r == "function" && (D = r, r = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    r = r || {}, r.compress = r.compress !== !1;
    const N = {
      type: t,
      data: e,
      options: r
    };
    this.emitReserved("packetCreate", N), this.writeBuffer.push(N), D && this.once("flush", D), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const t = () => {
      this.onClose("forced close"), this.transport.close();
    }, e = () => {
      this.off("upgrade", e), this.off("upgradeError", e), t();
    }, r = () => {
      this.once("upgrade", e), this.once("upgradeError", e);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? r() : t();
    }) : this.upgrading ? r() : t()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  onError(t) {
    Ps.priorWebsocketSuccess = !1, this.emitReserved("error", t), this.onClose("transport error", t);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  onClose(t, e) {
    (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", t, e), this.writeBuffer = [], this.prevBufferLen = 0);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  filterUpgrades(t) {
    const e = [];
    let r = 0;
    const D = t.length;
    for (; r < D; r++)
      ~this.transports.indexOf(t[r]) && e.push(t[r]);
    return e;
  }
};
Socket$1.protocol = protocol$1;
function url(o, t = "", e) {
  let r = o;
  e = e || typeof location < "u" && location, o == null && (o = e.protocol + "//" + e.host), typeof o == "string" && (o.charAt(0) === "/" && (o.charAt(1) === "/" ? o = e.protocol + o : o = e.host + o), /^(https?|wss?):\/\//.test(o) || (typeof e < "u" ? o = e.protocol + "//" + o : o = "https://" + o), r = parse(o)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/";
  const N = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
  return r.id = r.protocol + "://" + N + ":" + r.port + t, r.href = r.protocol + "://" + N + (e && e.port === r.port ? "" : ":" + r.port), r;
}
const withNativeArrayBuffer = typeof ArrayBuffer == "function", isView = (o) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(o) : o.buffer instanceof ArrayBuffer, toString = Object.prototype.toString, withNativeBlob = typeof Blob == "function" || typeof Blob < "u" && toString.call(Blob) === "[object BlobConstructor]", withNativeFile = typeof File == "function" || typeof File < "u" && toString.call(File) === "[object FileConstructor]";
function isBinary(o) {
  return withNativeArrayBuffer && (o instanceof ArrayBuffer || isView(o)) || withNativeBlob && o instanceof Blob || withNativeFile && o instanceof File;
}
function hasBinary(o, t) {
  if (!o || typeof o != "object")
    return !1;
  if (Array.isArray(o)) {
    for (let e = 0, r = o.length; e < r; e++)
      if (hasBinary(o[e]))
        return !0;
    return !1;
  }
  if (isBinary(o))
    return !0;
  if (o.toJSON && typeof o.toJSON == "function" && arguments.length === 1)
    return hasBinary(o.toJSON(), !0);
  for (const e in o)
    if (Object.prototype.hasOwnProperty.call(o, e) && hasBinary(o[e]))
      return !0;
  return !1;
}
function deconstructPacket(o) {
  const t = [], e = o.data, r = o;
  return r.data = _deconstructPacket(e, t), r.attachments = t.length, { packet: r, buffers: t };
}
function _deconstructPacket(o, t) {
  if (!o)
    return o;
  if (isBinary(o)) {
    const e = { _placeholder: !0, num: t.length };
    return t.push(o), e;
  } else if (Array.isArray(o)) {
    const e = new Array(o.length);
    for (let r = 0; r < o.length; r++)
      e[r] = _deconstructPacket(o[r], t);
    return e;
  } else if (typeof o == "object" && !(o instanceof Date)) {
    const e = {};
    for (const r in o)
      Object.prototype.hasOwnProperty.call(o, r) && (e[r] = _deconstructPacket(o[r], t));
    return e;
  }
  return o;
}
function reconstructPacket(o, t) {
  return o.data = _reconstructPacket(o.data, t), delete o.attachments, o;
}
function _reconstructPacket(o, t) {
  if (!o)
    return o;
  if (o && o._placeholder === !0) {
    if (typeof o.num == "number" && o.num >= 0 && o.num < t.length)
      return t[o.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(o))
    for (let e = 0; e < o.length; e++)
      o[e] = _reconstructPacket(o[e], t);
  else if (typeof o == "object")
    for (const e in o)
      Object.prototype.hasOwnProperty.call(o, e) && (o[e] = _reconstructPacket(o[e], t));
  return o;
}
const protocol = 5;
var PacketType;
(function(o) {
  o[o.CONNECT = 0] = "CONNECT", o[o.DISCONNECT = 1] = "DISCONNECT", o[o.EVENT = 2] = "EVENT", o[o.ACK = 3] = "ACK", o[o.CONNECT_ERROR = 4] = "CONNECT_ERROR", o[o.BINARY_EVENT = 5] = "BINARY_EVENT", o[o.BINARY_ACK = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(t) {
    this.replacer = t;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(t) {
    return (t.type === PacketType.EVENT || t.type === PacketType.ACK) && hasBinary(t) ? this.encodeAsBinary({
      type: t.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
      nsp: t.nsp,
      data: t.data,
      id: t.id
    }) : [this.encodeAsString(t)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(t) {
    let e = "" + t.type;
    return (t.type === PacketType.BINARY_EVENT || t.type === PacketType.BINARY_ACK) && (e += t.attachments + "-"), t.nsp && t.nsp !== "/" && (e += t.nsp + ","), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(t) {
    const e = deconstructPacket(t), r = this.encodeAsString(e.packet), D = e.buffers;
    return D.unshift(r), D;
  }
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(t) {
    super(), this.reviver = t;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(t) {
    let e;
    if (typeof t == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      e = this.decodeString(t);
      const r = e.type === PacketType.BINARY_EVENT;
      r || e.type === PacketType.BINARY_ACK ? (e.type = r ? PacketType.EVENT : PacketType.ACK, this.reconstructor = new BinaryReconstructor(e), e.attachments === 0 && super.emitReserved("decoded", e)) : super.emitReserved("decoded", e);
    } else if (isBinary(t) || t.base64)
      if (this.reconstructor)
        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved("decoded", e));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + t);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(t) {
    let e = 0;
    const r = {
      type: Number(t.charAt(0))
    };
    if (PacketType[r.type] === void 0)
      throw new Error("unknown packet type " + r.type);
    if (r.type === PacketType.BINARY_EVENT || r.type === PacketType.BINARY_ACK) {
      const N = e + 1;
      for (; t.charAt(++e) !== "-" && e != t.length; )
        ;
      const k = t.substring(N, e);
      if (k != Number(k) || t.charAt(e) !== "-")
        throw new Error("Illegal attachments");
      r.attachments = Number(k);
    }
    if (t.charAt(e + 1) === "/") {
      const N = e + 1;
      for (; ++e && !(t.charAt(e) === "," || e === t.length); )
        ;
      r.nsp = t.substring(N, e);
    } else
      r.nsp = "/";
    const D = t.charAt(e + 1);
    if (D !== "" && Number(D) == D) {
      const N = e + 1;
      for (; ++e; ) {
        const k = t.charAt(e);
        if (k == null || Number(k) != k) {
          --e;
          break;
        }
        if (e === t.length)
          break;
      }
      r.id = Number(t.substring(N, e + 1));
    }
    if (t.charAt(++e)) {
      const N = this.tryParse(t.substr(e));
      if (Decoder.isPayloadValid(r.type, N))
        r.data = N;
      else
        throw new Error("invalid payload");
    }
    return r;
  }
  tryParse(t) {
    try {
      return JSON.parse(t, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(t, e) {
    switch (t) {
      case PacketType.CONNECT:
        return typeof e == "object";
      case PacketType.DISCONNECT:
        return e === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof e == "string" || typeof e == "object";
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(e) && e.length > 0;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(e);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class BinaryReconstructor {
  constructor(t) {
    this.packet = t, this.buffers = [], this.reconPack = t;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(t) {
    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
      const e = reconstructPacket(this.reconPack, this.buffers);
      return this.finishedReconstruction(), e;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on(o, t, e) {
  return o.on(t, e), function() {
    o.off(t, e);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(t, e, r) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const t = this.io;
    this.subs = [
      on(t, "open", this.onopen.bind(this)),
      on(t, "packet", this.onpacket.bind(this)),
      on(t, "error", this.onerror.bind(this)),
      on(t, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...t) {
    return t.unshift("message"), this.emit.apply(this, t), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(t, ...e) {
    if (RESERVED_EVENTS.hasOwnProperty(t))
      throw new Error('"' + t.toString() + '" is a reserved event name');
    if (e.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(e), this;
    const r = {
      type: PacketType.EVENT,
      data: e
    };
    if (r.options = {}, r.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == "function") {
      const k = this.ids++, $ = e.pop();
      this._registerAckCallback(k, $), r.id = k;
    }
    const D = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    return this.flags.volatile && (!D || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(t, e) {
    var r;
    const D = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout;
    if (D === void 0) {
      this.acks[t] = e;
      return;
    }
    const N = this.io.setTimeoutFn(() => {
      delete this.acks[t];
      for (let k = 0; k < this.sendBuffer.length; k++)
        this.sendBuffer[k].id === t && this.sendBuffer.splice(k, 1);
      e.call(this, new Error("operation has timed out"));
    }, D);
    this.acks[t] = (...k) => {
      this.io.clearTimeoutFn(N), e.apply(this, [null, ...k]);
    };
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(t, ...e) {
    const r = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((D, N) => {
      e.push((k, $) => r ? k ? N(k) : D($) : D(k)), this.emit(t, ...e);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(t) {
    let e;
    typeof t[t.length - 1] == "function" && (e = t.pop());
    const r = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: t,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    t.push((D, ...N) => r !== this._queue[0] ? void 0 : (D !== null ? r.tryCount > this._opts.retries && (this._queue.shift(), e && e(D)) : (this._queue.shift(), e && e(null, ...N)), r.pending = !1, this._drainQueue())), this._queue.push(r), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(t = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const e = this._queue[0];
    e.pending && !t || (e.pending = !0, e.tryCount++, this.flags = e.flags, this.emit.apply(this, e.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(t) {
    t.nsp = this.nsp, this.io._packet(t);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((t) => {
      this._sendConnectPacket(t);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(t) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(t) {
    this.connected || this.emitReserved("connect_error", t);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(t, e) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", t, e);
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case PacketType.CONNECT:
          t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          this.onevent(t);
          break;
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          this.onack(t);
          break;
        case PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case PacketType.CONNECT_ERROR:
          this.destroy();
          const r = new Error(t.data.message);
          r.data = t.data.data, this.emitReserved("connect_error", r);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(t) {
    const e = t.data || [];
    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const e = this._anyListeners.slice();
      for (const r of e)
        r.apply(this, t);
    }
    super.emit.apply(this, t), this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(t) {
    const e = this;
    let r = !1;
    return function(...D) {
      r || (r = !0, e.packet({
        type: PacketType.ACK,
        id: t,
        data: D
      }));
    };
  }
  /**
   * Called upon a server acknowlegement.
   *
   * @param packet
   * @private
   */
  onack(t) {
    const e = this.acks[t.id];
    typeof e == "function" && (e.apply(this, t.data), delete this.acks[t.id]);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(t, e) {
    this.id = t, this.recovered = e && this._pid === e, this._pid = e, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {
      this.notifyOutgoingListeners(t), this.packet(t);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: PacketType.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(t) {
    return this.flags.compress = t, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(t) {
    return this.flags.timeout = t, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(t) {
    if (!this._anyListeners)
      return this;
    if (t) {
      const e = this._anyListeners;
      for (let r = 0; r < e.length; r++)
        if (t === e[r])
          return e.splice(r, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners)
      return this;
    if (t) {
      const e = this._anyOutgoingListeners;
      for (let r = 0; r < e.length; r++)
        if (t === e[r])
          return e.splice(r, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const e = this._anyOutgoingListeners.slice();
      for (const r of e)
        r.apply(this, t.data);
    }
  }
}
function Backoff(o) {
  o = o || {}, this.ms = o.min || 100, this.max = o.max || 1e4, this.factor = o.factor || 2, this.jitter = o.jitter > 0 && o.jitter <= 1 ? o.jitter : 0, this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var o = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t = Math.random(), e = Math.floor(t * this.jitter * o);
    o = Math.floor(t * 10) & 1 ? o + e : o - e;
  }
  return Math.min(o, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(o) {
  this.ms = o;
};
Backoff.prototype.setMax = function(o) {
  this.max = o;
};
Backoff.prototype.setJitter = function(o) {
  this.jitter = o;
};
class Manager extends Emitter {
  constructor(t, e) {
    var r;
    super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (e = t, t = void 0), e = e || {}, e.path = e.path || "/socket.io", this.opts = e, installTimerFunctions(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((r = e.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = "closed", this.uri = t;
    const D = e.parser || parser;
    this.encoder = new D.Encoder(), this.decoder = new D.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(t) {
    return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);
  }
  reconnectionDelay(t) {
    var e;
    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);
  }
  randomizationFactor(t) {
    var e;
    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);
  }
  reconnectionDelayMax(t) {
    var e;
    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);
  }
  timeout(t) {
    return arguments.length ? (this._timeout = t, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(t) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const e = this.engine, r = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const D = on(e, "open", function() {
      r.onopen(), t && t();
    }), N = on(e, "error", (k) => {
      r.cleanup(), r._readyState = "closed", this.emitReserved("error", k), t ? t(k) : r.maybeReconnectOnOpen();
    });
    if (this._timeout !== !1) {
      const k = this._timeout;
      k === 0 && D();
      const $ = this.setTimeoutFn(() => {
        D(), e.close(), e.emit("error", new Error("timeout"));
      }, k);
      this.opts.autoUnref && $.unref(), this.subs.push(function() {
        clearTimeout($);
      });
    }
    return this.subs.push(D), this.subs.push(N), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(t) {
    return this.open(t);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const t = this.engine;
    this.subs.push(on(t, "ping", this.onping.bind(this)), on(t, "data", this.ondata.bind(this)), on(t, "error", this.onerror.bind(this)), on(t, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(t) {
    try {
      this.decoder.add(t);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(t) {
    nextTick(() => {
      this.emitReserved("packet", t);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(t) {
    this.emitReserved("error", t);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(t, e) {
    let r = this.nsps[t];
    return r ? this._autoConnect && !r.active && r.connect() : (r = new Socket(this, t, e), this.nsps[t] = r), r;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(t) {
    const e = Object.keys(this.nsps);
    for (const r of e)
      if (this.nsps[r].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(t) {
    const e = this.encoder.encode(t);
    for (let r = 0; r < e.length; r++)
      this.engine.write(e[r], t.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(t, e) {
    this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, e), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const t = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const e = this.backoff.duration();
      this._reconnecting = !0;
      const r = this.setTimeoutFn(() => {
        t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open((D) => {
          D ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", D)) : t.onreconnect();
        }));
      }, e);
      this.opts.autoUnref && r.unref(), this.subs.push(function() {
        clearTimeout(r);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const t = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t);
  }
}
const cache = {};
function lookup(o, t) {
  typeof o == "object" && (t = o, o = void 0), t = t || {};
  const e = url(o, t.path || "/socket.io"), r = e.source, D = e.id, N = e.path, k = cache[D] && N in cache[D].nsps, $ = t.forceNew || t["force new connection"] || t.multiplex === !1 || k;
  let G;
  return $ ? G = new Manager(r, t) : (cache[D] || (cache[D] = new Manager(r, t)), G = cache[D]), e.query && !t.query && (t.query = e.queryKey), G.socket(e.path, t);
}
Object.assign(lookup, {
  Manager,
  Socket,
  io: lookup,
  connect: lookup
});
var Br, ti, ei, fs, ds, tn, en, rn, $c, Gc, Ql, Fa, Uc, $a, ps, jc, vs, Ga;
const zc = class {
  constructor(t = {}, e) {
    It(this, "hFactoryCls", {});
    It(this, "elc", new EventListenerCtn());
    It(this, "fetch", (t) => fetch(t));
    It(this, "resolution", 1);
    It(this, "cfg");
    It(this, "data", { sys: {}, mark: {}, kidoku: {} });
    It(this, "val");
    It(this, "appPixi");
    rt(this, Br, 0);
    rt(this, ti, 0);
    rt(this, ei, 1);
    rt(this, fs, 0);
    rt(this, ds, 0);
    rt(this, tn, 0);
    rt(this, en, 0);
    It(this, "isFullScr", !1);
    It(this, "extPort", 3776);
    rt(this, rn, void 0);
    rt(this, $c, {
      auth: (t) => {
        if (t.t !== this.cfg.oCfg.debuger_token) {
          this.end();
          return;
        }
        this.toast("接続");
      },
      continue: () => this.toast("再生"),
      disconnect: () => this.toast("切断"),
      restart: (t) => {
        this.send2Dbg((t == null ? void 0 : t.ri) ?? "", {}), this.end(), this.run();
      },
      pause: () => this.toast("一時停止"),
      stopOnEntry: () => this.toast("一時停止"),
      stopOnDataBreakpoint: () => this.toast("注意"),
      stopOnBreakpoint: () => this.toast("注意"),
      stopOnStep: () => this.toast("一歩進む"),
      stopOnStepIn: () => this.toast("ステップイン"),
      stopOnStepOut: () => this.toast("ステップアウト"),
      stopOnBackstep: () => this.toast("一歩戻る"),
      _addPath: (t) => this.cfg.addPath(t.fn, t.o)
    });
    It(this, "pathBaseCnvSnPath4Dbg", "");
    It(this, "fire");
    rt(this, Ql, []);
    It(this, "callHook", (t, e) => {
    });
    It(this, "send2Dbg", (t, e) => {
      var r;
      (r = H(this, rn)) == null || r.emit("data", t, e);
    });
    It(this, "copyBMFolder", (t, e) => {
    });
    It(this, "eraseBMFolder", (t) => {
    });
    It(this, "close", () => !1);
    It(this, "_export", () => !1);
    It(this, "_import", () => !1);
    It(this, "navigate_to", () => !1);
    It(this, "title", (t) => {
      const { text: e } = t;
      if (!e)
        throw "[title] textは必須です";
      return ot(this, Fa, e), this.titleSub(H(this, Fa) + H(this, $a)), !1;
    });
    rt(this, Fa, "");
    rt(this, Uc, (t) => {
      if (!t.key)
        return this.tglFlscr_sub(), !1;
      const e = t.key.toLowerCase();
      return this.elc.add(document, "keydown", (r) => {
        (r.altKey ? r.key === "Alt" ? "" : "alt+" : "") + (r.ctrlKey ? r.key === "Control" ? "" : "ctrl+" : "") + (r.shiftKey ? r.key === "Shift" ? "" : "shift+" : "") + r.key.toLowerCase() === e && (r.stopPropagation(), this.tglFlscr_sub());
      }, { passive: !0 }), !1;
    });
    It(this, "update_check", () => !1);
    It(this, "window", () => !1);
    rt(this, $a, "");
    rt(this, ps, (t, e) => ({ ret: e.toString(), ext_num: 0 }));
    rt(this, jc, {
      1: { ext: "jpeg", fnc: (t) => H(this, vs).call(this, t), mime: "image/jpeg" },
      2: { ext: "png", fnc: (t) => H(this, vs).call(this, t), mime: "image/png" },
      3: { ext: "svg", fnc: (t) => H(this, vs).call(this, t), mime: "image/svg+xml" },
      4: { ext: "webp", fnc: (t) => H(this, vs).call(this, t), mime: "image/webp" },
      10: { ext: "mp3", fnc: (t) => t.arrayBuffer(), mime: "audio/mpeg" },
      11: { ext: "m4a", fnc: (t) => t.arrayBuffer(), mime: "audio/aac" },
      12: { ext: "ogg", fnc: (t) => t.arrayBuffer(), mime: "audio/ogg" },
      13: { ext: "aac", fnc: (t) => t.arrayBuffer(), mime: "audio/aac" },
      14: { ext: "flac", fnc: (t) => t.arrayBuffer(), mime: "audio/flac" },
      15: { ext: "wav", fnc: (t) => t.arrayBuffer(), mime: "audio/wav" },
      20: { ext: "mp4", fnc: (t) => H(this, Ga).call(this, t), mime: "video/mp4" },
      21: { ext: "webm", fnc: (t) => H(this, Ga).call(this, t), mime: "video/webm" },
      22: { ext: "ogv", fnc: (t) => H(this, Ga).call(this, t), mime: "video/ogv" }
    });
    rt(this, vs, (t) => new Promise((e, r) => {
      const D = new Image();
      D.onload = () => e(D), D.onerror = (N) => r(N), D.src = URL.createObjectURL(t);
    }));
    rt(this, Ga, (t) => new Promise((e, r) => {
      const D = document.createElement("video");
      this.elc.add(D, "error", () => {
        var N;
        return r(((N = D == null ? void 0 : D.error) == null ? void 0 : N.message) ?? "");
      }), this.elc.add(D, "canplay", () => e(D)), D.src = URL.createObjectURL(t);
    }));
    It(this, "enc", (t) => t);
    It(this, "stk", () => "");
    It(this, "hash", (t) => "");
    It(this, "isApp", !1);
    It(this, "$path_downloads", "");
    It(this, "$path_userdata", "");
    this.hPlg = t, this.arg = e;
  }
  async loaded(t, e) {
    const r = t.snsys_pre;
    return delete t.snsys_pre, r == null ? void 0 : r.init({
      addTag: () => {
      },
      addLayCls: () => {
      },
      searchPath: () => "",
      getVal: () => ({}),
      resume: () => {
      },
      render: () => {
      },
      setDec: (D) => ot(this, ps, D),
      setEnc: (D) => this.enc = D,
      getStK: (D) => this.stk = D,
      getHash: (D) => this.hash = D
    });
  }
  get cur() {
    return this.arg.cur;
  }
  get crypto() {
    return this.arg.crypto;
  }
  destroy() {
    this.elc.clear();
  }
  async loadPath(t, e) {
    this.cfg = e;
  }
  initVal(t, e, r) {
  }
  flush() {
  }
  async run() {
  }
  init(t, e, r, D) {
    this.val = r, this.appPixi = e;
    let N = "";
    try {
      this.val.setSys(this), N = "sys", N += Number(this.val.getVal("sys:TextLayer.Back.Alpha", 1)), N = "kidoku", this.val.saveKidoku();
    } catch (k) {
      console.error(`セーブデータ（${N}）が壊れています。一度クリアする必要があります %o`, k);
    }
    return t.close = (k) => this.close(k), t.export = (k) => this._export(k), t.import = (k) => this._import(k), t.navigate_to = (k) => this.navigate_to(k), t.title = (k) => this.title(k), t.toggle_full_screen = (k) => H(this, Uc).call(this, k), t.update_check = (k) => this.update_check(k), t.window = (k) => this.window(k), r.setVal_Nochk("tmp", "const.sn.isApp", () => this.isApp), r.setVal_Nochk("tmp", "const.sn.isDbg", () => CmnLib.isDbg), r.setVal_Nochk("tmp", "const.sn.isPackaged", () => CmnLib.isPackaged), this.val.defTmp("const.sn.displayState", () => this.isFullScr), r.setVal_Nochk("sys", zc.VALNM_CFG_NS, this.cfg.oCfg.save_ns), r.flush(), CmnLib.isDbg && this.attach_debug(D), this.hFactoryCls = {}, Object.values(this.hPlg).map((k) => k.init({
      addTag: ($, G) => {
        if (t[$])
          throw `すでに定義済みのタグ[${$}]です`;
        t[$] = G;
      },
      addLayCls: ($, G) => {
        if (this.hFactoryCls[$])
          throw `すでに定義済みのレイヤcls【${$}】です`;
        this.hFactoryCls[$] = G;
      },
      searchPath: ($, G = "") => this.cfg.searchPath($, G),
      getVal: r.getVal,
      resume: () => D.resume(),
      render: ($, G, U = !1) => this.appPixi.renderer.render($, { renderTexture: G, clear: U }),
      setDec: ($) => ot(this, ps, $),
      setEnc: ($) => this.enc = $,
      getStK: ($) => this.stk = $,
      getHash: ($) => this.hash = $
    }));
  }
  get cvsWidth() {
    return H(this, Br);
  }
  get cvsHeight() {
    return H(this, ti);
  }
  get cvsScale() {
    return H(this, ei);
  }
  get ofsLeft4elm() {
    return H(this, fs);
  }
  get ofsTop4elm() {
    return H(this, ds);
  }
  get ofsPadLeft_Dom2PIXI() {
    return H(this, tn);
  }
  get ofsPadTop_Dom2PIXI() {
    return H(this, en);
  }
  cvsResize() {
    var G;
    let t = globalThis.innerWidth, e = globalThis.innerHeight;
    const r = Main.cvs, D = r.parentElement !== document.body;
    if (D) {
      const U = globalThis.getComputedStyle(r);
      t = parseFloat(U.width), e = parseFloat(U.height);
    }
    if (CmnLib.isMobile) {
      const z = (((G = screen.orientation) == null ? void 0 : G.angle) ?? 0) % 180 === 0;
      (z && t > e || !z && t < e) && ([t, e] = [e, t]);
    }
    const N = r.getBoundingClientRect();
    if (argChk_Boolean(CmnLib.hDip, "expanding", !0) || D || CmnLib.stageW > t || CmnLib.stageH > e)
      if (CmnLib.stageW / CmnLib.stageH <= t / e ? (ot(this, ti, e), ot(this, Br, CmnLib.stageW / CmnLib.stageH * e)) : (ot(this, Br, t), ot(this, ti, CmnLib.stageH / CmnLib.stageW * t)), ot(this, ei, H(this, Br) / CmnLib.stageW), D)
        ot(this, tn, 0), ot(this, en, 0);
      else {
        const U = 1 - H(this, ei);
        CmnLib.isMobile ? (ot(this, tn, (t - H(this, Br)) / 2 * U), ot(this, en, (e - H(this, ti)) / 2 * U)) : (ot(this, tn, N.left * U), ot(this, en, N.top * U));
      }
    else
      ot(this, Br, CmnLib.stageW), ot(this, ti, CmnLib.stageH), ot(this, ei, 1), ot(this, tn, 0), ot(this, en, 0);
    const k = r.parentElement.style;
    D || (k.position = "relative", k.width = `${H(this, Br)}px`, k.height = `${H(this, ti)}px`);
    const $ = r.style;
    $.width = k.width, $.height = k.height, D ? (ot(this, fs, N.left), ot(this, ds, N.top)) : (ot(this, fs, 0), ot(this, ds, 0)), this.isFullScr && (ot(this, fs, H(this, fs) + (t - H(this, Br)) / 2), ot(this, ds, H(this, ds) + (e - H(this, ti)) / 2));
  }
  // デバッガ接続
  attach_debug(t) {
    this.attach_debug = () => {
    };
    const e = document.createElement("style");
    e.innerHTML = `/* SKYNovel Dbg */
.sn_BounceInOut { animation: sn_kfBounceInOut linear 1.5s; }
@keyframes sn_kfBounceInOut{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
10%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
20%	{				transform: scaleX(0.95) scaleY(0.95);}
30%	{				transform: scaleX(1.00) scaleY(1.00);}
70%	{opacity: 1;}
100%{opacity: 0;}
}
.sn_BounceIn { animation: sn_kfBounceIn linear 0.3s; }
@keyframes sn_kfBounceIn{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
50%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
100%{				transform: scaleX(0.95) scaleY(0.95);}
}
.sn_HopIn { animation: sn_kfHopIn linear 0.8s; }
@keyframes sn_kfHopIn{
0%	{transform:	translate(0px,   0px);}
15% {transform:	translate(0px, -25px);}
30% {transform:	translate(0px,   0px);}
45% {transform:	translate(0px, -15px);}
60% {transform:	translate(0px,   0px);}
75% {transform:	translate(0px,  -5px);}
100%{transform:	translate(0px,   0px);}
}`, document.getElementsByTagName("head")[0].appendChild(e), this.addHook((r, D) => {
      var N, k;
      return (k = (N = H(this, $c))[r]) == null ? void 0 : k.call(N, D);
    }), ot(this, rn, lookup(`http://localhost:${this.extPort}`)), H(this, rn).on("data", (r, D) => {
      this.callHook(r, D);
    }).on("disconnect", () => t.setLoop(!0)), this.callHook = (r, D) => {
      for (const N of H(this, Ql))
        N(r, D);
    };
  }
  end() {
    var t;
    (t = H(this, rn)) == null || t.disconnect(), ot(this, rn, void 0);
  }
  toast(t) {
    const e = document.body;
    e.querySelectorAll(".sn_BounceIn, .sn_HopIn").forEach((k) => e.removeChild(k));
    const r = document.createElement("img"), D = H(zc, Gc)[t];
    r.src = `data:image/svg+xml;base64,${D.dat}`;
    const N = Math.min(CmnLib.stageW, CmnLib.stageH) / 4 * H(this, ei);
    r.width = r.height = N, r.style.cssText = `position: absolute;
left: ${(CmnLib.stageW - N) / 2 * H(this, ei) + N * (D.dx ?? 0)}px;
top: ${(CmnLib.stageH - N) / 2 * H(this, ei) + N * (D.dy ?? 0)}px;`, r.classList.add("sn_toast", D.ease ?? "sn_BounceInOut"), D.ease || r.addEventListener("animationend", () => e.removeChild(r), { once: !0, passive: !0 }), e.insertBefore(r, Main.cvs);
  }
  setFire(t) {
    this.fire = t;
  }
  addHook(t) {
    H(this, Ql).push(t);
  }
  titleSub(t) {
  }
  tglFlscr_sub() {
  }
  setTitleInfo(t) {
    ot(this, $a, t), this.titleSub(H(this, Fa) + H(this, $a));
  }
  decStr(t, e) {
    return H(this, ps).call(this, t, e).ret;
  }
  async dec(t, e) {
    const { ret: r, ext_num: D } = H(this, ps).call(this, t, e), N = H(this, jc)[D];
    return N != null && N.fnc ? await N.fnc(new Blob([r], { type: N.mime })) : r;
  }
  get path_downloads() {
    return this.$path_downloads;
  }
  get path_userdata() {
    return this.$path_userdata;
  }
  canCapturePage(t, e) {
    return !1;
  }
  async savePic(t, e) {
  }
  async appendFile(t, e, r) {
  }
  async ensureFileSync(t) {
  }
};
let SysBase = zc;
Br = new WeakMap(), ti = new WeakMap(), ei = new WeakMap(), fs = new WeakMap(), ds = new WeakMap(), tn = new WeakMap(), en = new WeakMap(), rn = new WeakMap(), $c = new WeakMap(), Gc = new WeakMap(), Ql = new WeakMap(), Fa = new WeakMap(), Uc = new WeakMap(), $a = new WeakMap(), ps = new WeakMap(), jc = new WeakMap(), vs = new WeakMap(), Ga = new WeakMap(), It(SysBase, "VALNM_CFG_NS", "const.sn.cfg.ns"), rt(SysBase, Gc, {
  // Thanks ICOOON MONO https://icooon-mono.com/ 、 https://vectr.com/ で 640x640化、ImageOptim経由、Base64エンコーダー https://lab.syncer.jp/Tool/Base64-encode/ 
  接続: { dx: -1, dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMCAyOTJ2NTUuODhoMTI3LjEzYzEyLjM3IDQ2IDU0LjEyIDc5Ljg3IDEwNCA3OS44N2g3Ny44N3YtMjE1LjYyYy00Ni43MyAwLTcyLjY4IDAtNzcuODggMC00OS43NCAwLTkxLjYyIDMzLjg3LTEwMy45OSA3OS44Ny0xNi45NSAwLTU5LjMzIDAtMTI3LjEzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im01MTIuODggMjkyYy0xMi4zOC00Ni01NC4xMy03OS44Ny0xMDQtNzkuODctNS4yMSAwLTMxLjIxIDAtNzggMHYyMTUuNzRoNzcuODdjNDkuODggMCA5MS43NS0zMy44NyAxMDQtNzkuODdoMTI3LjI1di01NmMtNzYuMjcgMC0xMTguNjUgMC0xMjcuMTIgMHoiLz48L2RlZnM+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9IiMzYWFiZDIiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYiIvPjx1c2UgZmlsbD0iIzNhYWJkMiIgeGxpbms6aHJlZj0iI2MiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNjIi8+PC9zdmc+" },
  切断: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMTkxLjUzIDIyMS4yNGMtNDUuNjggMC04NC4wMSAzMS4wNC05NS4zIDczLjE2LTYuNDEgMC0zOC40OSAwLTk2LjIzIDB2NTEuMjFoOTYuMjNjMTEuMyA0Mi4xMSA0OS42MyA3My4xNiA5NS4zIDczLjE2aDcxLjMzdi00OC4yNGg1My43OHYtMTAxLjA1aC01My43OHYtNDguMjRjLTQyLjggMC02Ni41NyAwLTcxLjMzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im00NDguNDcgMjIxLjIzYy00Ljc2IDAtMjguNTMgMC03MS4zMyAwdjE5Ny41M2g3MS4zM2M0NS42OCAwIDgzLjk5LTMxLjA0IDk1LjI5LTczLjE1aDk2LjI0di01MS4yMWgtOTYuMjRjLTMzLjA4LTQ4Ljc4LTY0Ljg0LTczLjE3LTk1LjI5LTczLjE3eiIvPjwvZGVmcz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0iI2RmNTY1NiIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSIjZGY1NjU2IiB4bGluazpocmVmPSIjYyIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2MiLz48L3N2Zz4=" },
  再生: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yNTguODMgMTExLjA1Yy0xLjI5Ljc5LTIuOTMuODMtNC4yNi4wNC0xLjI5LS43NC0yLjExLTIuMTItMi4xMS0zLjY3IDAtNy4xNiAwLTQyLjk3IDAtMTA3LjQzczAtMTAwLjI3IDAtMTA3LjQzYzAtMS41My44Mi0yLjkzIDIuMTEtMy42OCAxLjMzLS43NiAyLjk3LS43MiA0LjI2LjA0IDE4IDEwLjc1IDE2MiA5Ni43MSAxODAgMTA3LjQ2IDEuMjkuNzMgMi4wNSAyLjE0IDIuMDUgMy42MSAwIDEuNDktLjc2IDIuODgtMi4wNSAzLjYzLTM2IDIxLjQ5LTE2MiA5Ni42OS0xODAgMTA3LjQzeiIvPjwvZGVmcz48cGF0aCBkPSJtMTU0LjU3IDE3MC4xOWgzNDYuMTV2MzA3LjY5aC0zNDYuMTV6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
  一時停止: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yMDAgMTAwdi0yMDBoODB2MjAwem0xNjAgMHYtMjAwaDgwdjIwMHoiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxODAuNDFoMzUyLjR2MjgyLjY5aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
  注意: { ease: "sn_HopIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMzQzLjM0IDI5LjJjLTEwLjM3LTE3Ljk3LTM2LjMxLTE3Ljk3LTQ2LjY5IDAtMjkuMyA1MC43NS0yNjMuNyA0NTYuNzQtMjkzIDUwNy40OS0xMC4zNyAxNy45NyAyLjU5IDQwLjQ0IDIzLjM0IDQwLjQ0aDU4Ni4wMWMyMC43NSAwIDMzLjcyLTIyLjQ2IDIzLjM1LTQwLjQ0LTU4LjYtMTAxLjUtMjYzLjctNDU2Ljc0LTI5My4wMS01MDcuNDl6bS0yMy4zNCA0ODIuODNjLTE0LjUyIDAtMjYuMjktMi43MS0yNi4yOS02LjA2IDAtNC4yMSAwLTM3Ljg2IDAtNDIuMDcgMC0zLjM1IDExLjc3LTYuMDcgMjYuMjktNi4wN3MyNi4yOSAyLjcyIDI2LjI5IDYuMDd2NDIuMDdjLTcuODQgNC4wNC0xNi42MSA2LjA2LTI2LjI5IDYuMDZ6bTIxLjk5LTEwMy44NGMwIDUuNDMtOS44NSA5LjgzLTIxLjk5IDkuODMtMTIuMTUgMC0yMS45OS00LjQtMjEuOTktOS44MyAwLS4xMy4wNy0uMjUuMDgtLjM4LTEuMzctMTcuNTYtMTIuMy0xNTguMDYtMTMuNjctMTc1LjYyIDAtNS40MyAxNS45My05Ljg0IDM1LjU4LTkuODRzMzUuNTggNC40MSAzNS41OCA5Ljg0Yy0uOTEgMTEuNy01LjQ3IDcwLjI1LTEzLjY3IDE3NS42Mi4wNi4xNi4wOC4yOS4wOC4zOHoiLz48L2RlZnM+PHBhdGggZD0ibTI0MS4yOSAxOTEuNDRoMTQ1LjQ5djM1MS42NmgtMTQ1LjQ5eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iI2QyYmYzYSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
  一歩進む: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0zNzYuOTMgOTEuOTdjMC01My41MSAwLTgzLjI0IDAtODkuMTktLjE1LjE0LS4yNS4zNC0uNDQuNDUtMTYuMTEgOS42Mi0xNDQuOTUgODYuNTQtMTYxLjA2IDk2LjE1LTEuMTUuNjktMi42Mi43My0zLjgxLjAyLTEuMTUtLjY0LTEuODktMS44OS0xLjg5LTMuMjggMC02LjQxIDAtMzguNDQgMC05Ni4xMSAwLTU3LjY5IDAtODkuNzQgMC05Ni4xNSAwLTEuMzUuNzQtMi42MiAxLjg5LTMuMjkgMS4xOS0uNjggMi42Ni0uNjQgMy44MS4wNCAxNi4xMSA5LjYyIDE0NC45NSA4Ni41NCAxNjEuMDYgOTYuMTYuMTkuMS4yOS4zMS40NC40NSAwLTYuMTMgMC0zNi43NyAwLTkxLjkyaDUzLjMydjE4Ni42N3oiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxNTQuMmgzNTIuNHYzMDguOWgtMzUyLjR6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
  一歩戻る: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem00MzAuMjcgOTYuMTRjMCAxLjM1LS43NCAyLjYyLTEuODkgMy4yOC0xLjE5LjY5LTIuNjYuNjUtMy44MS0uMDMtMTYuMTEtOS42Mi0xNDQuOTUtODYuNTQtMTYxLjA1LTk2LjE2LS4yLS4xLS4yOS0uMzEtLjQ1LS40NXY5MS45MmgtNTMuMzJ2LTE4Ni42N2g1My4zMnY4OS4xOWMuMTYtLjE0LjI1LS4zNC40NS0uNDUgMTYuMS05LjYyIDE0NC45NC04Ni41NCAxNjEuMDUtOTYuMTYgMS4xNS0uNjggMi42Mi0uNzIgMy44MS0uMDEgMS4xNS42NCAxLjg5IDEuODkgMS44OSAzLjI4djk2LjExeiIvPjwvZGVmcz48cGF0aCBkPSJtMTQ3LjQ5IDE1NC4yaDM1Mi40djMwOC45aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
  ステップイン: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMTkuOTljMCAxNzYuNzQgMTQzLjI3IDMyMC4wMSAzMjAuMDEgMzIwLjAxIDE3Ni43MiAwIDMxOS45OS0xNDMuMjcgMzE5Ljk5LTMyMC4wMSAwLTE3Ni43Mi0xNDMuMjctMzE5Ljk5LTMxOS45OS0zMTkuOTktMTc2Ljc0IDAtMzIwLjAxIDE0My4yNy0zMjAuMDEgMzE5Ljk5em0xNTMuMDUtMjkuNzIgNTUuMTItNTUuMTMgMTExLjg0IDExMS44MiAxMTEuODItMTExLjgyIDU1LjEyIDU1LjEyLTE2Ni45NCAxNjYuOTd6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
  ステップアウト: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjAuMDFjMCAxNzYuNzIgMTQzLjI3IDMxOS45OSAzMTkuOTkgMzE5Ljk5IDE3Ni43NCAwIDMyMC4wMS0xNDMuMjcgMzIwLjAxLTMxOS45OSAwLTE3Ni43NC0xNDMuMjctMzIwLjAxLTMyMC4wMS0zMjAuMDEtMTc2LjcyIDAtMzE5Ljk5IDE0My4yNy0zMTkuOTkgMzIwLjAxem0zMTkuOTktMjYuOTgtMTExLjgyIDExMS44My01NS4xMi01NS4xMyAxNjYuOTQtMTY2Ljk2IDE2Ni45NiAxNjYuOTYtNTUuMTIgNTUuMTN6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" }
});
var assign = make_assign(), create$1 = make_create(), trim$1 = make_trim(), Global$5 = typeof window < "u" ? window : commonjsGlobal, util$6 = {
  assign,
  create: create$1,
  trim: trim$1,
  bind: bind$1,
  slice: slice$1,
  each: each$7,
  map,
  pluck: pluck$1,
  isList: isList$1,
  isFunction: isFunction$1,
  isObject: isObject$1,
  Global: Global$5
};
function make_assign() {
  return Object.assign ? Object.assign : function(t, e, r, D) {
    for (var N = 1; N < arguments.length; N++)
      each$7(Object(arguments[N]), function(k, $) {
        t[$] = k;
      });
    return t;
  };
}
function make_create() {
  if (Object.create)
    return function(t, e, r, D) {
      var N = slice$1(arguments, 1);
      return assign.apply(this, [Object.create(t)].concat(N));
    };
  {
    let o = function() {
    };
    return function(e, r, D, N) {
      var k = slice$1(arguments, 1);
      return o.prototype = e, assign.apply(this, [new o()].concat(k));
    };
  }
}
function make_trim() {
  return String.prototype.trim ? function(t) {
    return String.prototype.trim.call(t);
  } : function(t) {
    return t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  };
}
function bind$1(o, t) {
  return function() {
    return t.apply(o, Array.prototype.slice.call(arguments, 0));
  };
}
function slice$1(o, t) {
  return Array.prototype.slice.call(o, t || 0);
}
function each$7(o, t) {
  pluck$1(o, function(e, r) {
    return t(e, r), !1;
  });
}
function map(o, t) {
  var e = isList$1(o) ? [] : {};
  return pluck$1(o, function(r, D) {
    return e[D] = t(r, D), !1;
  }), e;
}
function pluck$1(o, t) {
  if (isList$1(o)) {
    for (var e = 0; e < o.length; e++)
      if (t(o[e], e))
        return o[e];
  } else
    for (var r in o)
      if (o.hasOwnProperty(r) && t(o[r], r))
        return o[r];
}
function isList$1(o) {
  return o != null && typeof o != "function" && typeof o.length == "number";
}
function isFunction$1(o) {
  return o && {}.toString.call(o) === "[object Function]";
}
function isObject$1(o) {
  return o && {}.toString.call(o) === "[object Object]";
}
var util$5 = util$6, slice = util$5.slice, pluck = util$5.pluck, each$6 = util$5.each, bind = util$5.bind, create = util$5.create, isList = util$5.isList, isFunction = util$5.isFunction, isObject = util$5.isObject, storeEngine = {
  createStore
}, storeAPI = {
  version: "2.0.12",
  enabled: !1,
  // get returns the value of the given key. If that value
  // is undefined, it returns optionalDefaultValue instead.
  get: function(o, t) {
    var e = this.storage.read(this._namespacePrefix + o);
    return this._deserialize(e, t);
  },
  // set will store the given value at key and returns value.
  // Calling set with value === undefined is equivalent to calling remove.
  set: function(o, t) {
    return t === void 0 ? this.remove(o) : (this.storage.write(this._namespacePrefix + o, this._serialize(t)), t);
  },
  // remove deletes the key and value stored at the given key.
  remove: function(o) {
    this.storage.remove(this._namespacePrefix + o);
  },
  // each will call the given callback once for each key-value pair
  // in this store.
  each: function(o) {
    var t = this;
    this.storage.each(function(e, r) {
      o.call(t, t._deserialize(e), (r || "").replace(t._namespaceRegexp, ""));
    });
  },
  // clearAll will remove all the stored key-value pairs in this store.
  clearAll: function() {
    this.storage.clearAll();
  },
  // additional functionality that can't live in plugins
  // ---------------------------------------------------
  // hasNamespace returns true if this store instance has the given namespace.
  hasNamespace: function(o) {
    return this._namespacePrefix == "__storejs_" + o + "_";
  },
  // createStore creates a store.js instance with the first
  // functioning storage in the list of storage candidates,
  // and applies the the given mixins to the instance.
  createStore: function() {
    return createStore.apply(this, arguments);
  },
  addPlugin: function(o) {
    this._addPlugin(o);
  },
  namespace: function(o) {
    return createStore(this.storage, this.plugins, o);
  }
};
function _warn() {
  var o = typeof console > "u" ? null : console;
  if (o) {
    var t = o.warn ? o.warn : o.log;
    t.apply(o, arguments);
  }
}
function createStore(o, t, e) {
  e || (e = ""), o && !isList(o) && (o = [o]), t && !isList(t) && (t = [t]);
  var r = e ? "__storejs_" + e + "_" : "", D = e ? new RegExp("^" + r) : null, N = /^[a-zA-Z0-9_\-]*$/;
  if (!N.test(e))
    throw new Error("store.js namespaces can only have alphanumerics + underscores and dashes");
  var k = {
    _namespacePrefix: r,
    _namespaceRegexp: D,
    _testStorage: function(G) {
      try {
        var U = "__storejs__test__";
        G.write(U, U);
        var z = G.read(U) === U;
        return G.remove(U), z;
      } catch {
        return !1;
      }
    },
    _assignPluginFnProp: function(G, U) {
      var z = this[U];
      this[U] = function() {
        var V = slice(arguments, 0), Y = this;
        function W() {
          if (z)
            return each$6(arguments, function(K, Z) {
              V[Z] = K;
            }), z.apply(Y, V);
        }
        var q = [W].concat(V);
        return G.apply(Y, q);
      };
    },
    _serialize: function(G) {
      return JSON.stringify(G);
    },
    _deserialize: function(G, U) {
      if (!G)
        return U;
      var z = "";
      try {
        z = JSON.parse(G);
      } catch {
        z = G;
      }
      return z !== void 0 ? z : U;
    },
    _addStorage: function(G) {
      this.enabled || this._testStorage(G) && (this.storage = G, this.enabled = !0);
    },
    _addPlugin: function(G) {
      var U = this;
      if (isList(G)) {
        each$6(G, function(V) {
          U._addPlugin(V);
        });
        return;
      }
      var z = pluck(this.plugins, function(V) {
        return G === V;
      });
      if (!z) {
        if (this.plugins.push(G), !isFunction(G))
          throw new Error("Plugins must be function values that return objects");
        var X = G.call(this);
        if (!isObject(X))
          throw new Error("Plugins must return an object of function properties");
        each$6(X, function(V, Y) {
          if (!isFunction(V))
            throw new Error("Bad plugin property: " + Y + " from plugin " + G.name + ". Plugins should only return functions.");
          U._assignPluginFnProp(V, Y);
        });
      }
    },
    // Put deprecated properties in the private API, so as to not expose it to accidential
    // discovery through inspection of the store object.
    // Deprecated: addStorage
    addStorage: function(G) {
      _warn("store.addStorage(storage) is deprecated. Use createStore([storages])"), this._addStorage(G);
    }
  }, $ = create(k, storeAPI, {
    plugins: []
  });
  return $.raw = {}, each$6($, function(G, U) {
    isFunction(G) && ($.raw[U] = bind($, G));
  }), each$6(o, function(G) {
    $._addStorage(G);
  }), each$6(t, function(G) {
    $._addPlugin(G);
  }), $;
}
var util$4 = util$6, Global$4 = util$4.Global, localStorage_1 = {
  name: "localStorage",
  read: read$5,
  write: write$5,
  each: each$5,
  remove: remove$5,
  clearAll: clearAll$5
};
function localStorage() {
  return Global$4.localStorage;
}
function read$5(o) {
  return localStorage().getItem(o);
}
function write$5(o, t) {
  return localStorage().setItem(o, t);
}
function each$5(o) {
  for (var t = localStorage().length - 1; t >= 0; t--) {
    var e = localStorage().key(t);
    o(read$5(e), e);
  }
}
function remove$5(o) {
  return localStorage().removeItem(o);
}
function clearAll$5() {
  return localStorage().clear();
}
var util$3 = util$6, Global$3 = util$3.Global, oldFFGlobalStorage = {
  name: "oldFF-globalStorage",
  read: read$4,
  write: write$4,
  each: each$4,
  remove: remove$4,
  clearAll: clearAll$4
}, globalStorage = Global$3.globalStorage;
function read$4(o) {
  return globalStorage[o];
}
function write$4(o, t) {
  globalStorage[o] = t;
}
function each$4(o) {
  for (var t = globalStorage.length - 1; t >= 0; t--) {
    var e = globalStorage.key(t);
    o(globalStorage[e], e);
  }
}
function remove$4(o) {
  return globalStorage.removeItem(o);
}
function clearAll$4() {
  each$4(function(o, t) {
    delete globalStorage[o];
  });
}
var util$2 = util$6, Global$2 = util$2.Global, oldIEUserDataStorage = {
  name: "oldIE-userDataStorage",
  write: write$3,
  read: read$3,
  each: each$3,
  remove: remove$3,
  clearAll: clearAll$3
}, storageName = "storejs", doc$1 = Global$2.document, _withStorageEl = _makeIEStorageElFunction(), disable = (Global$2.navigator ? Global$2.navigator.userAgent : "").match(/ (MSIE 8|MSIE 9|MSIE 10)\./);
function write$3(o, t) {
  if (!disable) {
    var e = fixKey(o);
    _withStorageEl(function(r) {
      r.setAttribute(e, t), r.save(storageName);
    });
  }
}
function read$3(o) {
  if (!disable) {
    var t = fixKey(o), e = null;
    return _withStorageEl(function(r) {
      e = r.getAttribute(t);
    }), e;
  }
}
function each$3(o) {
  _withStorageEl(function(t) {
    for (var e = t.XMLDocument.documentElement.attributes, r = e.length - 1; r >= 0; r--) {
      var D = e[r];
      o(t.getAttribute(D.name), D.name);
    }
  });
}
function remove$3(o) {
  var t = fixKey(o);
  _withStorageEl(function(e) {
    e.removeAttribute(t), e.save(storageName);
  });
}
function clearAll$3() {
  _withStorageEl(function(o) {
    var t = o.XMLDocument.documentElement.attributes;
    o.load(storageName);
    for (var e = t.length - 1; e >= 0; e--)
      o.removeAttribute(t[e].name);
    o.save(storageName);
  });
}
var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g");
function fixKey(o) {
  return o.replace(/^\d/, "___$&").replace(forbiddenCharsRegex, "___");
}
function _makeIEStorageElFunction() {
  if (!doc$1 || !doc$1.documentElement || !doc$1.documentElement.addBehavior)
    return null;
  var o = "script", t, e, r;
  try {
    e = new ActiveXObject("htmlfile"), e.open(), e.write("<" + o + ">document.w=window</" + o + '><iframe src="/favicon.ico"></iframe>'), e.close(), t = e.w.frames[0].document, r = t.createElement("div");
  } catch {
    r = doc$1.createElement("div"), t = doc$1.body;
  }
  return function(D) {
    var N = [].slice.call(arguments, 0);
    N.unshift(r), t.appendChild(r), r.addBehavior("#default#userData"), r.load(storageName), D.apply(this, N), t.removeChild(r);
  };
}
var util$1 = util$6, Global$1 = util$1.Global, trim = util$1.trim, cookieStorage = {
  name: "cookieStorage",
  read: read$2,
  write: write$2,
  each: each$2,
  remove: remove$2,
  clearAll: clearAll$2
}, doc = Global$1.document;
function read$2(o) {
  if (!o || !_has(o))
    return null;
  var t = "(?:^|.*;\\s*)" + escape(o).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*";
  return unescape(doc.cookie.replace(new RegExp(t), "$1"));
}
function each$2(o) {
  for (var t = doc.cookie.split(/; ?/g), e = t.length - 1; e >= 0; e--)
    if (trim(t[e])) {
      var r = t[e].split("="), D = unescape(r[0]), N = unescape(r[1]);
      o(N, D);
    }
}
function write$2(o, t) {
  o && (doc.cookie = escape(o) + "=" + escape(t) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/");
}
function remove$2(o) {
  !o || !_has(o) || (doc.cookie = escape(o) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/");
}
function clearAll$2() {
  each$2(function(o, t) {
    remove$2(t);
  });
}
function _has(o) {
  return new RegExp("(?:^|;\\s*)" + escape(o).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=").test(doc.cookie);
}
var util = util$6, Global = util.Global, sessionStorage_1 = {
  name: "sessionStorage",
  read: read$1,
  write: write$1,
  each: each$1,
  remove: remove$1,
  clearAll: clearAll$1
};
function sessionStorage$1() {
  return Global.sessionStorage;
}
function read$1(o) {
  return sessionStorage$1().getItem(o);
}
function write$1(o, t) {
  return sessionStorage$1().setItem(o, t);
}
function each$1(o) {
  for (var t = sessionStorage$1().length - 1; t >= 0; t--) {
    var e = sessionStorage$1().key(t);
    o(read$1(e), e);
  }
}
function remove$1(o) {
  return sessionStorage$1().removeItem(o);
}
function clearAll$1() {
  return sessionStorage$1().clear();
}
var memoryStorage_1 = {
  name: "memoryStorage",
  read,
  write,
  each,
  remove,
  clearAll
}, memoryStorage = {};
function read(o) {
  return memoryStorage[o];
}
function write(o, t) {
  memoryStorage[o] = t;
}
function each(o) {
  for (var t in memoryStorage)
    memoryStorage.hasOwnProperty(t) && o(memoryStorage[t], t);
}
function remove(o) {
  delete memoryStorage[o];
}
function clearAll(o) {
  memoryStorage = {};
}
var all = [
  // Listed in order of usage preference
  localStorage_1,
  oldFFGlobalStorage,
  oldIEUserDataStorage,
  cookieStorage,
  sessionStorage_1,
  memoryStorage_1
], json2$1 = {}, hasRequiredJson2;
function requireJson2() {
  return hasRequiredJson2 || (hasRequiredJson2 = 1, typeof JSON != "object" && (JSON = {}), function() {
    var rx_one = /^[\],:{}\s]*$/, rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, rx_four = /(?:^|:|,)(?:\s*\[)+/g, rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    function f(o) {
      return o < 10 ? "0" + o : o;
    }
    function this_value() {
      return this.valueOf();
    }
    typeof Date.prototype.toJSON != "function" && (Date.prototype.toJSON = function() {
      return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null;
    }, Boolean.prototype.toJSON = this_value, Number.prototype.toJSON = this_value, String.prototype.toJSON = this_value);
    var gap, indent, meta, rep;
    function quote(o) {
      return rx_escapable.lastIndex = 0, rx_escapable.test(o) ? '"' + o.replace(rx_escapable, function(t) {
        var e = meta[t];
        return typeof e == "string" ? e : "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + o + '"';
    }
    function str(o, t) {
      var e, r, D, N, k = gap, $, G = t[o];
      switch (G && typeof G == "object" && typeof G.toJSON == "function" && (G = G.toJSON(o)), typeof rep == "function" && (G = rep.call(t, o, G)), typeof G) {
        case "string":
          return quote(G);
        case "number":
          return isFinite(G) ? String(G) : "null";
        case "boolean":
        case "null":
          return String(G);
        case "object":
          if (!G)
            return "null";
          if (gap += indent, $ = [], Object.prototype.toString.apply(G) === "[object Array]") {
            for (N = G.length, e = 0; e < N; e += 1)
              $[e] = str(e, G) || "null";
            return D = $.length === 0 ? "[]" : gap ? `[
` + gap + $.join(`,
` + gap) + `
` + k + "]" : "[" + $.join(",") + "]", gap = k, D;
          }
          if (rep && typeof rep == "object")
            for (N = rep.length, e = 0; e < N; e += 1)
              typeof rep[e] == "string" && (r = rep[e], D = str(r, G), D && $.push(quote(r) + (gap ? ": " : ":") + D));
          else
            for (r in G)
              Object.prototype.hasOwnProperty.call(G, r) && (D = str(r, G), D && $.push(quote(r) + (gap ? ": " : ":") + D));
          return D = $.length === 0 ? "{}" : gap ? `{
` + gap + $.join(`,
` + gap) + `
` + k + "}" : "{" + $.join(",") + "}", gap = k, D;
      }
    }
    typeof JSON.stringify != "function" && (meta = {
      // table of character substitutions
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    }, JSON.stringify = function(o, t, e) {
      var r;
      if (gap = "", indent = "", typeof e == "number")
        for (r = 0; r < e; r += 1)
          indent += " ";
      else
        typeof e == "string" && (indent = e);
      if (rep = t, t && typeof t != "function" && (typeof t != "object" || typeof t.length != "number"))
        throw new Error("JSON.stringify");
      return str("", { "": o });
    }), typeof JSON.parse != "function" && (JSON.parse = function(text, reviver) {
      var j;
      function walk(o, t) {
        var e, r, D = o[t];
        if (D && typeof D == "object")
          for (e in D)
            Object.prototype.hasOwnProperty.call(D, e) && (r = walk(D, e), r !== void 0 ? D[e] = r : delete D[e]);
        return reviver.call(o, t, D);
      }
      if (text = String(text), rx_dangerous.lastIndex = 0, rx_dangerous.test(text) && (text = text.replace(rx_dangerous, function(o) {
        return "\\u" + ("0000" + o.charCodeAt(0).toString(16)).slice(-4);
      })), rx_one.test(
        text.replace(rx_two, "@").replace(rx_three, "]").replace(rx_four, "")
      ))
        return j = eval("(" + text + ")"), typeof reviver == "function" ? walk({ "": j }, "") : j;
      throw new SyntaxError("JSON.parse");
    });
  }()), json2$1;
}
var json2 = json2Plugin;
function json2Plugin() {
  return requireJson2(), {};
}
var engine = storeEngine, storages = all, plugins = [json2], store_legacy = engine.createStore(storages, plugins);
const store = /* @__PURE__ */ getDefaultExportFromCjs(store_legacy);
/*!
devtools-detect
https://github.com/sindresorhus/devtools-detect
By Sindre Sorhus
MIT License
*/
const devtools = {
  isOpen: !1,
  orientation: void 0
}, threshold = 170, emitEvent = (o, t) => {
  globalThis.dispatchEvent(new globalThis.CustomEvent("devtoolschange", {
    detail: {
      isOpen: o,
      orientation: t
    }
  }));
}, main = ({ emitEvents: o = !0 } = {}) => {
  const t = globalThis.outerWidth - globalThis.innerWidth > threshold, e = globalThis.outerHeight - globalThis.innerHeight > threshold, r = t ? "vertical" : "horizontal";
  !(e && t) && (globalThis.Firebug && globalThis.Firebug.chrome && globalThis.Firebug.chrome.isInitialized || t || e) ? ((!devtools.isOpen || devtools.orientation !== r) && o && emitEvent(!0, r), devtools.isOpen = !0, devtools.orientation = r) : (devtools.isOpen && o && emitEvent(!1, void 0), devtools.isOpen = !1, devtools.orientation = void 0);
};
main({ emitEvents: !1 });
setInterval(main, 500);
var Ua, tu, Oi, eu;
class SysWeb extends SysBase {
  constructor(e = {}, r = { cur: "prj/", crypto: !1, dip: "" }) {
    super(e, r);
    rt(this, Ua, "");
    rt(this, tu, ":");
    It(this, "run", async () => {
      H(this, Oi) && (H(this, Oi).destroy(10), await new Promise((r) => setTimeout(r, 10))), ot(this, Oi, new Main(this));
    });
    rt(this, Oi, void 0);
    It(this, "pathBaseCnvSnPath4Dbg", "${pathbase}/");
    // プレイデータをエクスポート
    It(this, "_export", () => ((async () => {
      const e = JSON.stringify({
        sys: this.data.sys,
        mark: this.data.mark,
        kidoku: this.data.kidoku
      }), r = this.crypto ? await this.enc(e) : e, D = new Blob([r], { type: "text/json" }), N = document.createElement("a");
      N.href = URL.createObjectURL(D), N.download = (this.crypto ? "" : "no_crypto_") + this.cfg.getNs() + getDateStr("-", "_", "") + ".swpd", N.click(), CmnLib.debugLog && console.log("プレイデータをエクスポートしました"), setTimeout(() => this.fire("sn:exported", new Event("click")), 10);
    })(), !1));
    // プレイデータをインポート
    It(this, "_import", () => (new Promise((e, r) => {
      const D = document.createElement("input");
      D.type = "file", D.accept = ".swpd, text/plain", D.onchange = () => {
        D.files ? e(D.files[0]) : r();
      }, D.click();
    }).then((e) => new Promise((r) => {
      const D = new FileReader();
      D.readAsText(e), D.onload = () => r(D.result);
    })).then(async (e) => {
      const r = JSON.parse(this.crypto ? this.decStr("json", e) : e);
      if (!r.sys || !r.mark || !r.kidoku)
        throw new Error("異常なプレイデータです");
      if (r.sys[SysBase.VALNM_CFG_NS] !== this.cfg.oCfg.save_ns) {
        console.error(`別のゲーム【プロジェクト名=${r.sys[SysBase.VALNM_CFG_NS]}】のプレイデータです`);
        return;
      }
      this.data.sys = r.sys, this.data.mark = r.mark, this.data.kidoku = r.kidoku, this.flush(), this.val.updateData(r), CmnLib.debugLog && console.log("プレイデータをインポートしました"), this.fire("sn:imported", new Event("click"));
    }).catch((e) => console.error(`異常なプレイデータです ${e.message}`)), !1));
    // ＵＲＬを開く
    It(this, "navigate_to", (e) => {
      const { url: r } = e;
      if (!r)
        throw "[navigate_to] urlは必須です";
      return globalThis.open(r, "_blank"), !1;
    });
    rt(this, eu, {});
    const D = r.cur.split("/");
    ot(this, Ua, D.length > 2 ? D.slice(0, -2).join("/") + "/" : ""), globalThis.onload = async () => this.loaded(e, r);
  }
  async loaded(e, r) {
    await super.loaded(e, r), document.querySelectorAll("[data-prj]").forEach(($) => {
      const G = $.attributes.getNamedItem("data-prj");
      G && $.addEventListener("click", () => this.runSN(G.value), { passive: !0 });
    }), document.querySelectorAll("[data-reload]").forEach(
      ($) => $.addEventListener("click", () => this.run(), { passive: !0 })
      //this.elc.add(v, 'click', ()=> this.run(), {passive: true})
      // ギャラリーであっても、ここには一度しか来ないので
    ), r.dip && (CmnLib.hDip = JSON.parse(r.dip));
    const D = new URLSearchParams(location.search), N = D.get("dip");
    if (N && (CmnLib.hDip = { ...CmnLib.hDip, ...JSON.parse(N.replaceAll("%2C", ",")) }), !argChk_Boolean(CmnLib.hDip, "oninit_run", !0))
      return;
    argChk_Boolean(CmnLib.hDip, "dbg", !1) && (CmnLib.isDbg = !0, this.fetch = ($) => fetch($, { mode: "cors" })), this.extPort = argChk_Num(CmnLib.hDip, "port", this.extPort);
    const k = D.get("cur");
    k && (r.cur = H(this, Ua) + k + "/"), this.run();
  }
  runSN(e) {
    this.arg.cur = H(this, Ua) + e + "/", H(this, tu) !== this.arg.cur && (ot(this, tu, this.arg.cur), this.run());
  }
  stop() {
    H(this, Oi) && (H(this, Oi).destroy(), ot(this, Oi, void 0));
  }
  async loadPath(e, r) {
    await super.loadPath(e, r);
    const D = this.arg.cur + "path.json", N = await fetch(D);
    if (!N.ok)
      throw Error(N.statusText);
    const k = await N.text(), $ = JSON.parse(this.decStr(D, k));
    for (const [G, U] of Object.entries($)) {
      const z = e[G] = U;
      for (const [X, V] of Object.entries(z))
        X !== ":cnt" && (z[X] = this.arg.cur + V);
    }
  }
  initVal(e, r, D) {
    const N = encodeURIComponent(document.location.hostname);
    r["const.sn.isDebugger"] = N === "localhost" || N === "127.0.0.1";
    const k = this.cfg.getNs();
    this.flush = this.crypto ? async () => {
      store.set(k + "sys_", this.enc(JSON.stringify(this.data.sys))), store.set(k + "mark_", this.enc(JSON.stringify(this.data.mark))), store.set(k + "kidoku_", this.enc(JSON.stringify(this.data.kidoku)));
    } : () => {
      store.set(k + "sys", this.data.sys), store.set(k + "mark", this.data.mark), store.set(k + "kidoku", this.data.kidoku);
    };
    const $ = k + (this.arg.crypto ? "sys_" : "sys");
    if (r["const.sn.isFirstBoot"] = store.get($) === void 0) {
      this.data.sys = e.sys, this.data.mark = e.mark, this.data.kidoku = e.kidoku, this.flush(), D(this.data);
      return;
    }
    if (!this.crypto) {
      this.data.sys = store.get(k + "sys"), this.data.mark = store.get(k + "mark"), this.data.kidoku = store.get(k + "kidoku"), D(this.data);
      return;
    }
    let G = "";
    try {
      G = "sys", this.data.sys = JSON.parse(this.decStr("json", store.get(k + "sys_"))), G += Number(this.val.getVal("sys:TextLayer.Back.Alpha", 1)), G = "mark", this.data.mark = JSON.parse(this.decStr("json", store.get(k + "mark_"))), G = "kidoku", this.data.kidoku = JSON.parse(this.decStr("json", store.get(k + "kidoku_")));
    } catch (U) {
      console.error(`セーブデータ（${G}）が壊れています。一度クリアする必要があります %o`, U);
    }
    D(this.data);
  }
  init(e, r, D, N) {
    super.init(e, r, D, N);
    const k = r.view.parentElement;
    if ("requestFullscreen" in document.body)
      this.tglFlscr_sub = () => this.isFullScr ? document.exitFullscreen() : k.requestFullscreen(), this.elc.add(document, "fullscreenchange", () => this.isFullScr = !!document.fullscreenElement);
    else {
      const $ = document;
      this.tglFlscr_sub = () => this.isFullScr ? $.webkitCancelFullScreen() : k.webkitRequestFullscreen(), this.elc.add(document, "fullscreenchange", () => this.isFullScr = !!$.webkitFullscreenElement);
    }
    return this.cfg.oCfg.debug.devtool || this.elc.add(window, "devtoolschange", ($) => {
      $.detail.isOpen && (console.error("DevToolは禁止されています。許可する場合は【プロジェクト設定】の【devtool】をONに。"), N.destroy());
    }, { once: !0, passive: !0 }), [];
  }
  cvsResize() {
    if (super.cvsResize(), this.isFullScr) {
      const e = Main.cvs.style;
      e.width = e.height = "";
    }
  }
  // タイトル指定
  titleSub(e) {
    document.title = e, document.querySelectorAll("[data-title]").forEach((r) => r.textContent = e);
  }
  async savePic(e, r) {
    const D = document.createElement("a");
    D.href = r, D.download = e, D.click(), CmnLib.debugLog && console.log("画像ファイルをダウンロードします");
  }
  async appendFile(e, r, D) {
    const N = (H(this, eu)[e] ?? "") + r;
    H(this, eu)[e] = N;
    const k = new Blob([N], { type: "text/json" }), $ = document.createElement("a");
    $.href = URL.createObjectURL(k), $.download = e, $.click();
  }
}
Ua = new WeakMap(), tu = new WeakMap(), Oi = new WeakMap(), eu = new WeakMap();
export {
  CmnLib,
  Layer,
  SysWeb,
  argChk_Boolean,
  argChk_Num
};
//# sourceMappingURL=web.js.map
